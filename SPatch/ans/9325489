
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,1/2] mm, mincore2(): retrieve dax and tlb-size attributes of an address range - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,1/2] mm, mincore2(): retrieve dax and tlb-size attributes of an address range</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=320">Dan Williams</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 11, 2016, 5:31 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;147361509579.17004.5258725187329709824.stgit@dwillia2-desk3.amr.corp.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9325489/mbox/"
   >mbox</a>
|
   <a href="/patch/9325489/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9325489/">/patch/9325489/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4538A6089F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 11 Sep 2016 17:34:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2FC2C28A5C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 11 Sep 2016 17:34:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 2423D28A5E; Sun, 11 Sep 2016 17:34:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id F344A28A5C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 11 Sep 2016 17:34:50 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756345AbcIKReo (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 11 Sep 2016 13:34:44 -0400
Received: from mga03.intel.com ([134.134.136.65]:15563 &quot;EHLO mga03.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1756123AbcIKRek (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 11 Sep 2016 13:34:40 -0400
Received: from fmsmga003.fm.intel.com ([10.253.24.29])
	by orsmga103.jf.intel.com with ESMTP; 11 Sep 2016 10:34:39 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.30,318,1470726000&quot;; d=&quot;scan&#39;208&quot;;a=&quot;759584999&quot;
Received: from dwillia2-desk3.jf.intel.com (HELO
	dwillia2-desk3.amr.corp.intel.com) ([10.54.39.14])
	by FMSMGA003.fm.intel.com with ESMTP; 11 Sep 2016 10:34:39 -0700
Subject: [RFC PATCH 1/2] mm,
	mincore2(): retrieve dax and tlb-size attributes of an address range
From: Dan Williams &lt;dan.j.williams@intel.com&gt;
To: linux-mm@kvack.org
Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;,
	Xiao Guangrong &lt;guangrong.xiao@linux.intel.com&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;, linux-nvdimm@lists.01.org,
	linux-api@vger.kernel.org, Dave Hansen &lt;dave.hansen@linux.intel.com&gt;,
	linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	&quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;
Date: Sun, 11 Sep 2016 10:31:35 -0700
Message-ID: &lt;147361509579.17004.5258725187329709824.stgit@dwillia2-desk3.amr.corp.intel.com&gt;
User-Agent: StGit/0.17.1-9-g687f
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=320">Dan Williams</a> - Sept. 11, 2016, 5:31 p.m.</div>
<pre class="content">
As evidenced by this bug report [1], userspace libraries are interested
in whether a mapping is DAX mapped, i.e. no intervening page cache.
Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an
explicit &quot;is dax&quot; indication as a new flag in the page vector populated
by mincore.

There are also cases, particularly for testing and validating a
configuration to know the hardware mapping geometry of the pages in a
given process address range.  Consider filesystem-dax where a
configuration needs to take care to align partitions and block
allocations before huge page mappings might be used, or
anonymous-transparent-huge-pages where a process is opportunistically
assigned large pages.  mincore2() allows these configurations to be
surveyed and validated.

The implementation takes advantage of the unused bits in the per-page
byte returned for each PAGE_SIZE extent of a given address range.  The
new format of each vector byte is:

(TLB_SHIFT - PAGE_SHIFT) &lt;&lt; 2 | vma_is_dax() &lt;&lt; 1 | page_present

[1]: https://lkml.org/lkml/2016/9/7/61

Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;
Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;
Cc: Xiao Guangrong &lt;guangrong.xiao@linux.intel.com&gt;
Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;
<span class="signed-off-by">Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;</span>
---
 include/linux/syscalls.h               |    2 +
 include/uapi/asm-generic/mman-common.h |    3 +
 kernel/sys_ni.c                        |    1 
 mm/mincore.c                           |  126 +++++++++++++++++++++++++-------
 4 files changed, 104 insertions(+), 28 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=169395">Nicholas Piggin</a> - Sept. 12, 2016, 3:35 a.m.</div>
<pre class="content">
On Sun, 11 Sep 2016 10:31:35 -0700
Dan Williams &lt;dan.j.williams@intel.com&gt; wrote:
<span class="quote">
&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt; by mincore.</span>

Can you cc linux-arch when adding new syscalls (or other such things that
need arch enablement).

I wonder if the changelog for a new syscall should have a bit more grandeur.
Without seeing patch 2, you might not know this was a new syscall just by
reading the subject and changelog.

mincore() defines other bits to be reserved, but I guess it probably breaks
things if you suddenly started using them.

It&#39;s a bit sad to introduce a new syscall for this and immediately use up
all bits that can be returned. Would it be a serious problem to return a
larger mask per page?

Thanks,
Nick
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=169873">Oliver O&#39;Halloran</a> - Sept. 12, 2016, 6:29 a.m.</div>
<pre class="content">
On Mon, Sep 12, 2016 at 3:31 AM, Dan Williams &lt;dan.j.williams@intel.com&gt; wrote:
<span class="quote">&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt; by mincore.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; There are also cases, particularly for testing and validating a</span>
<span class="quote">&gt; configuration to know the hardware mapping geometry of the pages in a</span>
<span class="quote">&gt; given process address range.  Consider filesystem-dax where a</span>
<span class="quote">&gt; configuration needs to take care to align partitions and block</span>
<span class="quote">&gt; allocations before huge page mappings might be used, or</span>
<span class="quote">&gt; anonymous-transparent-huge-pages where a process is opportunistically</span>
<span class="quote">&gt; assigned large pages.  mincore2() allows these configurations to be</span>
<span class="quote">&gt; surveyed and validated.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The implementation takes advantage of the unused bits in the per-page</span>
<span class="quote">&gt; byte returned for each PAGE_SIZE extent of a given address range.  The</span>
<span class="quote">&gt; new format of each vector byte is:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; (TLB_SHIFT - PAGE_SHIFT) &lt;&lt; 2 | vma_is_dax() &lt;&lt; 1 | page_present</span>

What is userspace expected to do with the information in vec? Whether
PMD or THP mappings can be used is going to depend more on the block
allocations done by the filesystem rather than anything the an
application can directly influence. Returning a vector for each page
makes some sense in the mincore() case since the application can touch
each page to fault them in, but I don&#39;t see what they can do here.

Why not just get rid of vec entirely and make mincore2() a yes/no
check over the range for whatever is supplied in flags? That would
work for NVML&#39;s use case and it should be easier to extend if needed.

Oliver
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Sept. 12, 2016, 10:09 a.m.</div>
<pre class="content">
On Sun, Sep 11, 2016 at 10:31:35AM -0700, Dan Williams wrote:
<span class="quote">&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt; by mincore.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There are also cases, particularly for testing and validating a</span>
<span class="quote">&gt; configuration to know the hardware mapping geometry of the pages in a</span>
<span class="quote">&gt; given process address range.  Consider filesystem-dax where a</span>
<span class="quote">&gt; configuration needs to take care to align partitions and block</span>
<span class="quote">&gt; allocations before huge page mappings might be used, or</span>
<span class="quote">&gt; anonymous-transparent-huge-pages where a process is opportunistically</span>
<span class="quote">&gt; assigned large pages.  mincore2() allows these configurations to be</span>
<span class="quote">&gt; surveyed and validated.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The implementation takes advantage of the unused bits in the per-page</span>
<span class="quote">&gt; byte returned for each PAGE_SIZE extent of a given address range.  The</span>
<span class="quote">&gt; new format of each vector byte is:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; (TLB_SHIFT - PAGE_SHIFT) &lt;&lt; 2 | vma_is_dax() &lt;&lt; 1 | page_present</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [1]: https://lkml.org/lkml/2016/9/7/61</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="quote">&gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;</span>
<span class="quote">&gt; Cc: Xiao Guangrong &lt;guangrong.xiao@linux.intel.com&gt;</span>
<span class="quote">&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  include/linux/syscalls.h               |    2 +</span>
<span class="quote">&gt;  include/uapi/asm-generic/mman-common.h |    3 +</span>
<span class="quote">&gt;  kernel/sys_ni.c                        |    1 </span>
<span class="quote">&gt;  mm/mincore.c                           |  126 +++++++++++++++++++++++++-------</span>
<span class="quote">&gt;  4 files changed, 104 insertions(+), 28 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h</span>
<span class="quote">&gt; index d02239022bd0..4aa2ee7e359a 100644</span>
<span class="quote">&gt; --- a/include/linux/syscalls.h</span>
<span class="quote">&gt; +++ b/include/linux/syscalls.h</span>
<span class="quote">&gt; @@ -467,6 +467,8 @@ asmlinkage long sys_munlockall(void);</span>
<span class="quote">&gt;  asmlinkage long sys_madvise(unsigned long start, size_t len, int behavior);</span>
<span class="quote">&gt;  asmlinkage long sys_mincore(unsigned long start, size_t len,</span>
<span class="quote">&gt;  				unsigned char __user * vec);</span>
<span class="quote">&gt; +asmlinkage long sys_mincore2(unsigned long start, size_t len,</span>
<span class="quote">&gt; +				unsigned char __user * vec, int flags);</span>

We had few attempts to extand mincore(2) interface/functionality before.
None of them ended up in upsteam.

How this attempt compares to previous?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=320">Dan Williams</a> - Sept. 12, 2016, 5:15 p.m.</div>
<pre class="content">
On Mon, Sep 12, 2016 at 3:09 AM, Kirill A. Shutemov
&lt;kirill@shutemov.name&gt; wrote:
<span class="quote">&gt; On Sun, Sep 11, 2016 at 10:31:35AM -0700, Dan Williams wrote:</span>
<span class="quote">&gt;&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt;&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt;&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt;&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt;&gt; by mincore.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; There are also cases, particularly for testing and validating a</span>
<span class="quote">&gt;&gt; configuration to know the hardware mapping geometry of the pages in a</span>
<span class="quote">&gt;&gt; given process address range.  Consider filesystem-dax where a</span>
<span class="quote">&gt;&gt; configuration needs to take care to align partitions and block</span>
<span class="quote">&gt;&gt; allocations before huge page mappings might be used, or</span>
<span class="quote">&gt;&gt; anonymous-transparent-huge-pages where a process is opportunistically</span>
<span class="quote">&gt;&gt; assigned large pages.  mincore2() allows these configurations to be</span>
<span class="quote">&gt;&gt; surveyed and validated.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The implementation takes advantage of the unused bits in the per-page</span>
<span class="quote">&gt;&gt; byte returned for each PAGE_SIZE extent of a given address range.  The</span>
<span class="quote">&gt;&gt; new format of each vector byte is:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; (TLB_SHIFT - PAGE_SHIFT) &lt;&lt; 2 | vma_is_dax() &lt;&lt; 1 | page_present</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [1]: https://lkml.org/lkml/2016/9/7/61</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="quote">&gt;&gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Xiao Guangrong &lt;guangrong.xiao@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Dan Williams &lt;dan.j.williams@intel.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  include/linux/syscalls.h               |    2 +</span>
<span class="quote">&gt;&gt;  include/uapi/asm-generic/mman-common.h |    3 +</span>
<span class="quote">&gt;&gt;  kernel/sys_ni.c                        |    1</span>
<span class="quote">&gt;&gt;  mm/mincore.c                           |  126 +++++++++++++++++++++++++-------</span>
<span class="quote">&gt;&gt;  4 files changed, 104 insertions(+), 28 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h</span>
<span class="quote">&gt;&gt; index d02239022bd0..4aa2ee7e359a 100644</span>
<span class="quote">&gt;&gt; --- a/include/linux/syscalls.h</span>
<span class="quote">&gt;&gt; +++ b/include/linux/syscalls.h</span>
<span class="quote">&gt;&gt; @@ -467,6 +467,8 @@ asmlinkage long sys_munlockall(void);</span>
<span class="quote">&gt;&gt;  asmlinkage long sys_madvise(unsigned long start, size_t len, int behavior);</span>
<span class="quote">&gt;&gt;  asmlinkage long sys_mincore(unsigned long start, size_t len,</span>
<span class="quote">&gt;&gt;                               unsigned char __user * vec);</span>
<span class="quote">&gt;&gt; +asmlinkage long sys_mincore2(unsigned long start, size_t len,</span>
<span class="quote">&gt;&gt; +                             unsigned char __user * vec, int flags);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; We had few attempts to extand mincore(2) interface/functionality before.</span>
<span class="quote">&gt; None of them ended up in upsteam.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; How this attempt compares to previous?</span>

Not sure, I&#39;m wading into this cold trying to get my pet problem
solved, hence the RFC.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=320">Dan Williams</a> - Sept. 12, 2016, 5:25 p.m.</div>
<pre class="content">
On Sun, Sep 11, 2016 at 11:29 PM, Oliver O&#39;Halloran &lt;oohall@gmail.com&gt; wrote:
<span class="quote">&gt; On Mon, Sep 12, 2016 at 3:31 AM, Dan Williams &lt;dan.j.williams@intel.com&gt; wrote:</span>
<span class="quote">&gt;&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt;&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt;&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt;&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt;&gt; by mincore.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; There are also cases, particularly for testing and validating a</span>
<span class="quote">&gt;&gt; configuration to know the hardware mapping geometry of the pages in a</span>
<span class="quote">&gt;&gt; given process address range.  Consider filesystem-dax where a</span>
<span class="quote">&gt;&gt; configuration needs to take care to align partitions and block</span>
<span class="quote">&gt;&gt; allocations before huge page mappings might be used, or</span>
<span class="quote">&gt;&gt; anonymous-transparent-huge-pages where a process is opportunistically</span>
<span class="quote">&gt;&gt; assigned large pages.  mincore2() allows these configurations to be</span>
<span class="quote">&gt;&gt; surveyed and validated.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The implementation takes advantage of the unused bits in the per-page</span>
<span class="quote">&gt;&gt; byte returned for each PAGE_SIZE extent of a given address range.  The</span>
<span class="quote">&gt;&gt; new format of each vector byte is:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; (TLB_SHIFT - PAGE_SHIFT) &lt;&lt; 2 | vma_is_dax() &lt;&lt; 1 | page_present</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What is userspace expected to do with the information in vec? Whether</span>
<span class="quote">&gt; PMD or THP mappings can be used is going to depend more on the block</span>
<span class="quote">&gt; allocations done by the filesystem rather than anything the an</span>
<span class="quote">&gt; application can directly influence. Returning a vector for each page</span>
<span class="quote">&gt; makes some sense in the mincore() case since the application can touch</span>
<span class="quote">&gt; each page to fault them in, but I don&#39;t see what they can do here.</span>

It&#39;s not a &quot;can huge pages be used?&quot; question it&#39;s interrogating the
mapping that got established after the fact.  If an
application/environment expects huge mappings, but pte mappings are
getting established
<span class="quote">
&gt; Why not just get rid of vec entirely and make mincore2() a yes/no</span>
<span class="quote">&gt; check over the range for whatever is supplied in flags? That would</span>
<span class="quote">&gt; work for NVML&#39;s use case and it should be easier to extend if needed.</span>

I think having a way to ask the kernel if an address range satisfies a
certain set of input attributes is a useful interface.  Perhaps a
&quot;MINCORE_CHECK&quot; flag can indicate that the input vector contains a
single character that it wants the kernel to validate during the page
table walk, and return zero or the offset of the first mismatch.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=320">Dan Williams</a> - Sept. 12, 2016, 5:29 p.m.</div>
<pre class="content">
On Sun, Sep 11, 2016 at 8:35 PM, Nicholas Piggin &lt;npiggin@gmail.com&gt; wrote:
<span class="quote">&gt; On Sun, 11 Sep 2016 10:31:35 -0700</span>
<span class="quote">&gt; Dan Williams &lt;dan.j.williams@intel.com&gt; wrote:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt;&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt;&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt;&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt;&gt; by mincore.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can you cc linux-arch when adding new syscalls (or other such things that</span>
<span class="quote">&gt; need arch enablement).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I wonder if the changelog for a new syscall should have a bit more grandeur.</span>
<span class="quote">&gt; Without seeing patch 2, you might not know this was a new syscall just by</span>
<span class="quote">&gt; reading the subject and changelog.</span>

Fair point, I&#39;ll beef up the documentation if this moves past an RFC.
<span class="quote">
&gt; mincore() defines other bits to be reserved, but I guess it probably breaks</span>
<span class="quote">&gt; things if you suddenly started using them.</span>

The new bits are left as zero unless an application explicitly asks
for them, so an existing mincore() user shouldn&#39;t break.
<span class="quote">
&gt; It&#39;s a bit sad to introduce a new syscall for this and immediately use up</span>
<span class="quote">&gt; all bits that can be returned. Would it be a serious problem to return a</span>
<span class="quote">&gt; larger mask per page?</span>

Certainly one of the new request flags can indicate that the vector is
made up of larger entries.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=169395">Nicholas Piggin</a> - Sept. 13, 2016, 2:16 a.m.</div>
<pre class="content">
On Mon, 12 Sep 2016 10:29:17 -0700
Dan Williams &lt;dan.j.williams@intel.com&gt; wrote:
<span class="quote">
&gt; On Sun, Sep 11, 2016 at 8:35 PM, Nicholas Piggin &lt;npiggin@gmail.com&gt; wrote:</span>
<span class="quote">&gt; &gt; On Sun, 11 Sep 2016 10:31:35 -0700</span>
<span class="quote">&gt; &gt; Dan Williams &lt;dan.j.williams@intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt; &gt;&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt; &gt;&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt; &gt;&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt; &gt;&gt; by mincore.  </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Can you cc linux-arch when adding new syscalls (or other such things that</span>
<span class="quote">&gt; &gt; need arch enablement).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I wonder if the changelog for a new syscall should have a bit more grandeur.</span>
<span class="quote">&gt; &gt; Without seeing patch 2, you might not know this was a new syscall just by</span>
<span class="quote">&gt; &gt; reading the subject and changelog.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fair point, I&#39;ll beef up the documentation if this moves past an RFC.</span>

Okay. Also, it would be good to summarise some of the justification
directly in the changelog rather than external link. Performance
numbers, etc.
<span class="quote">

&gt; &gt; mincore() defines other bits to be reserved, but I guess it probably breaks</span>
<span class="quote">&gt; &gt; things if you suddenly started using them.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The new bits are left as zero unless an application explicitly asks</span>
<span class="quote">&gt; for them, so an existing mincore() user shouldn&#39;t break.</span>

Oh yeah, I was just musing that we can&#39;t really use the old syscall
despite it claims to have some reserved bits for future use.
<span class="quote">

&gt; &gt; It&#39;s a bit sad to introduce a new syscall for this and immediately use up</span>
<span class="quote">&gt; &gt; all bits that can be returned. Would it be a serious problem to return a</span>
<span class="quote">&gt; &gt; larger mask per page?  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Certainly one of the new request flags can indicate that the vector is</span>
<span class="quote">&gt; made up of larger entries.</span>

Hmm. Changing prototype depending on flags. I thought I was having
a nightmare about ioctls for a minute there :)

In general, is this what we want for a new API? Should we be thinking
about an extent API?

Thanks,
Nick
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=320">Dan Williams</a> - Sept. 13, 2016, 3:49 a.m.</div>
<pre class="content">
On Mon, Sep 12, 2016 at 7:16 PM, Nicholas Piggin &lt;npiggin@gmail.com&gt; wrote:
<span class="quote">&gt; On Mon, 12 Sep 2016 10:29:17 -0700</span>
[..]
<span class="quote">&gt;&gt; Certainly one of the new request flags can indicate that the vector is</span>
<span class="quote">&gt;&gt; made up of larger entries.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Hmm. Changing prototype depending on flags. I thought I was having</span>
<span class="quote">&gt; a nightmare about ioctls for a minute there :)</span>

Heh :)
<span class="quote">
&gt; In general, is this what we want for a new API? Should we be thinking</span>
<span class="quote">&gt; about an extent API?</span>

This probably fits better with the use cases I know that want to
consume this information, something like fiemap (mextmap, maybe?) for
memory.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=101">Christoph Hellwig</a> - Sept. 13, 2016, 6:44 a.m.</div>
<pre class="content">
On Sun, Sep 11, 2016 at 10:31:35AM -0700, Dan Williams wrote:
<span class="quote">&gt; As evidenced by this bug report [1], userspace libraries are interested</span>
<span class="quote">&gt; in whether a mapping is DAX mapped, i.e. no intervening page cache.</span>
<span class="quote">&gt; Rather than using the ambiguous VM_MIXEDMAP flag in smaps, provide an</span>
<span class="quote">&gt; explicit &quot;is dax&quot; indication as a new flag in the page vector populated</span>
<span class="quote">&gt; by mincore.</span>

And how exactly does an implementation detail like DAX matter for an
application?  The only thing that might matter is the atomicy boundary,
but mincore is not the right interface for that.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h</span>
<span class="p_header">index d02239022bd0..4aa2ee7e359a 100644</span>
<span class="p_header">--- a/include/linux/syscalls.h</span>
<span class="p_header">+++ b/include/linux/syscalls.h</span>
<span class="p_chunk">@@ -467,6 +467,8 @@</span> <span class="p_context"> asmlinkage long sys_munlockall(void);</span>
 asmlinkage long sys_madvise(unsigned long start, size_t len, int behavior);
 asmlinkage long sys_mincore(unsigned long start, size_t len,
 				unsigned char __user * vec);
<span class="p_add">+asmlinkage long sys_mincore2(unsigned long start, size_t len,</span>
<span class="p_add">+				unsigned char __user * vec, int flags);</span>
 
 asmlinkage long sys_pivot_root(const char __user *new_root,
 				const char __user *put_old);
<span class="p_header">diff --git a/include/uapi/asm-generic/mman-common.h b/include/uapi/asm-generic/mman-common.h</span>
<span class="p_header">index 58274382a616..05037343f0da 100644</span>
<span class="p_header">--- a/include/uapi/asm-generic/mman-common.h</span>
<span class="p_header">+++ b/include/uapi/asm-generic/mman-common.h</span>
<span class="p_chunk">@@ -72,4 +72,7 @@</span> <span class="p_context"></span>
 #define MAP_HUGE_SHIFT	26
 #define MAP_HUGE_MASK	0x3f
 
<span class="p_add">+#define MINCORE_DAX	1		/* indicate pages that are dax-mapped */</span>
<span class="p_add">+#define MINCORE_ORDER	2		/* retrieve hardware mapping-size-order */</span>
<span class="p_add">+</span>
 #endif /* __ASM_GENERIC_MMAN_COMMON_H */
<span class="p_header">diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c</span>
<span class="p_header">index 2c5e3a8e00d7..e14b87834054 100644</span>
<span class="p_header">--- a/kernel/sys_ni.c</span>
<span class="p_header">+++ b/kernel/sys_ni.c</span>
<span class="p_chunk">@@ -197,6 +197,7 @@</span> <span class="p_context"> cond_syscall(sys_mlockall);</span>
 cond_syscall(sys_munlockall);
 cond_syscall(sys_mlock2);
 cond_syscall(sys_mincore);
<span class="p_add">+cond_syscall(sys_mincore2);</span>
 cond_syscall(sys_madvise);
 cond_syscall(sys_mremap);
 cond_syscall(sys_remap_file_pages);
<span class="p_header">diff --git a/mm/mincore.c b/mm/mincore.c</span>
<span class="p_header">index c0b5ba965200..15f9eb5de65b 100644</span>
<span class="p_header">--- a/mm/mincore.c</span>
<span class="p_header">+++ b/mm/mincore.c</span>
<span class="p_chunk">@@ -15,25 +15,62 @@</span> <span class="p_context"></span>
 #include &lt;linux/swap.h&gt;
 #include &lt;linux/swapops.h&gt;
 #include &lt;linux/hugetlb.h&gt;
<span class="p_add">+#include &lt;linux/dax.h&gt;</span>
 
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/pgtable.h&gt;
 
<span class="p_add">+#define MINCORE_DAX_MASK 2</span>
<span class="p_add">+#define MINCORE_DAX_SHIFT 1</span>
<span class="p_add">+</span>
<span class="p_add">+#define MINCORE_ORDER_MASK 0x7c</span>
<span class="p_add">+#define MINCORE_ORDER_SHIFT 2</span>
<span class="p_add">+</span>
<span class="p_add">+struct mincore_params {</span>
<span class="p_add">+	unsigned char *vec;</span>
<span class="p_add">+	int flags;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void mincore_set(unsigned char *vec, struct vm_area_struct *vma, int nr,</span>
<span class="p_add">+		int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char mincore = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!nr) {</span>
<span class="p_add">+		*vec = 0;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((flags &amp; MINCORE_DAX) &amp;&amp; vma_is_dax(vma))</span>
<span class="p_add">+		mincore |= 1 &lt;&lt; MINCORE_DAX_SHIFT;</span>
<span class="p_add">+	if (flags &amp; MINCORE_ORDER) {</span>
<span class="p_add">+		unsigned char order = ilog2(nr);</span>
<span class="p_add">+</span>
<span class="p_add">+		WARN_ON((order &lt;&lt; MINCORE_ORDER_SHIFT) &amp; ~MINCORE_ORDER_MASK);</span>
<span class="p_add">+		mincore |= order &lt;&lt; MINCORE_ORDER_SHIFT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memset(vec, mincore, nr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mincore_hugetlb(pte_t *pte, unsigned long hmask, unsigned long addr,
 			unsigned long end, struct mm_walk *walk)
 {
 #ifdef CONFIG_HUGETLB_PAGE
<span class="p_add">+	struct mincore_params *p = walk-&gt;private;</span>
<span class="p_add">+	int nr = (end - addr) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	unsigned char *vec = p-&gt;vec;</span>
 	unsigned char present;
<span class="p_del">-	unsigned char *vec = walk-&gt;private;</span>
 
 	/*
 	 * Hugepages under user process are always in RAM and never
 	 * swapped out, but theoretically it needs to be checked.
 	 */
 	present = pte &amp;&amp; !huge_pte_none(huge_ptep_get(pte));
<span class="p_del">-	for (; addr != end; vec++, addr += PAGE_SIZE)</span>
<span class="p_del">-		*vec = present;</span>
<span class="p_del">-	walk-&gt;private = vec;</span>
<span class="p_add">+	if (!present)</span>
<span class="p_add">+		memset(vec, 0, nr);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mincore_set(vec, walk-&gt;vma, nr, p-&gt;flags);</span>
<span class="p_add">+	p-&gt;vec = vec + nr;</span>
 #else
 	BUG();
 #endif
<span class="p_chunk">@@ -82,20 +119,24 @@</span> <span class="p_context"> static unsigned char mincore_page(struct address_space *mapping, pgoff_t pgoff)</span>
 }
 
 static int __mincore_unmapped_range(unsigned long addr, unsigned long end,
<span class="p_del">-				struct vm_area_struct *vma, unsigned char *vec)</span>
<span class="p_add">+				struct vm_area_struct *vma, unsigned char *vec,</span>
<span class="p_add">+				int flags)</span>
 {
 	unsigned long nr = (end - addr) &gt;&gt; PAGE_SHIFT;
<span class="p_add">+	unsigned char present;</span>
 	int i;
 
 	if (vma-&gt;vm_file) {
 		pgoff_t pgoff;
 
 		pgoff = linear_page_index(vma, addr);
<span class="p_del">-		for (i = 0; i &lt; nr; i++, pgoff++)</span>
<span class="p_del">-			vec[i] = mincore_page(vma-&gt;vm_file-&gt;f_mapping, pgoff);</span>
<span class="p_add">+		for (i = 0; i &lt; nr; i++, pgoff++) {</span>
<span class="p_add">+			present = mincore_page(vma-&gt;vm_file-&gt;f_mapping, pgoff);</span>
<span class="p_add">+			mincore_set(vec + i, vma, present, flags);</span>
<span class="p_add">+		}</span>
 	} else {
 		for (i = 0; i &lt; nr; i++)
<span class="p_del">-			vec[i] = 0;</span>
<span class="p_add">+			mincore_set(vec + i, vma, 0, flags);</span>
 	}
 	return nr;
 }
<span class="p_chunk">@@ -103,8 +144,11 @@</span> <span class="p_context"> static int __mincore_unmapped_range(unsigned long addr, unsigned long end,</span>
 static int mincore_unmapped_range(unsigned long addr, unsigned long end,
 				   struct mm_walk *walk)
 {
<span class="p_del">-	walk-&gt;private += __mincore_unmapped_range(addr, end,</span>
<span class="p_del">-						  walk-&gt;vma, walk-&gt;private);</span>
<span class="p_add">+	struct mincore_params *p = walk-&gt;private;</span>
<span class="p_add">+	int nr = __mincore_unmapped_range(addr, end, walk-&gt;vma, p-&gt;vec,</span>
<span class="p_add">+			p-&gt;flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	p-&gt;vec += nr;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -114,18 +158,20 @@</span> <span class="p_context"> static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,</span>
 	spinlock_t *ptl;
 	struct vm_area_struct *vma = walk-&gt;vma;
 	pte_t *ptep;
<span class="p_del">-	unsigned char *vec = walk-&gt;private;</span>
<span class="p_add">+	struct mincore_params *p = walk-&gt;private;</span>
<span class="p_add">+	unsigned char *vec = p-&gt;vec;</span>
 	int nr = (end - addr) &gt;&gt; PAGE_SHIFT;
<span class="p_add">+	int flags = p-&gt;flags;</span>
 
 	ptl = pmd_trans_huge_lock(pmd, vma);
 	if (ptl) {
<span class="p_del">-		memset(vec, 1, nr);</span>
<span class="p_add">+		mincore_set(vec, vma, nr, flags);</span>
 		spin_unlock(ptl);
 		goto out;
 	}
 
 	if (pmd_trans_unstable(pmd)) {
<span class="p_del">-		__mincore_unmapped_range(addr, end, vma, vec);</span>
<span class="p_add">+		__mincore_unmapped_range(addr, end, vma, vec, flags);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -135,9 +181,9 @@</span> <span class="p_context"> static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,</span>
 
 		if (pte_none(pte))
 			__mincore_unmapped_range(addr, addr + PAGE_SIZE,
<span class="p_del">-						 vma, vec);</span>
<span class="p_add">+						 vma, vec, flags);</span>
 		else if (pte_present(pte))
<span class="p_del">-			*vec = 1;</span>
<span class="p_add">+			mincore_set(vec, vma, 1, flags);</span>
 		else { /* pte is a swap entry */
 			swp_entry_t entry = pte_to_swp_entry(pte);
 
<span class="p_chunk">@@ -146,14 +192,17 @@</span> <span class="p_context"> static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,</span>
 				 * migration or hwpoison entries are always
 				 * uptodate
 				 */
<span class="p_del">-				*vec = 1;</span>
<span class="p_add">+				mincore_set(vec, vma, 1, flags);</span>
 			} else {
 #ifdef CONFIG_SWAP
<span class="p_del">-				*vec = mincore_page(swap_address_space(entry),</span>
<span class="p_del">-					entry.val);</span>
<span class="p_add">+				unsigned char present;</span>
<span class="p_add">+</span>
<span class="p_add">+				present = mincore_page(swap_address_space(entry),</span>
<span class="p_add">+						entry.val);</span>
<span class="p_add">+				mincore_set(vec, vma, present, flags);</span>
 #else
 				WARN_ON(1);
<span class="p_del">-				*vec = 1;</span>
<span class="p_add">+				mincore_set(vec, vma, 1, flags);</span>
 #endif
 			}
 		}
<span class="p_chunk">@@ -161,7 +210,7 @@</span> <span class="p_context"> static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,</span>
 	}
 	pte_unmap_unlock(ptep - 1, ptl);
 out:
<span class="p_del">-	walk-&gt;private += nr;</span>
<span class="p_add">+	p-&gt;vec = vec + nr;</span>
 	cond_resched();
 	return 0;
 }
<span class="p_chunk">@@ -171,16 +220,21 @@</span> <span class="p_context"> out:</span>
  * all the arguments, we hold the mmap semaphore: we should
  * just return the amount of info we&#39;re asked for.
  */
<span class="p_del">-static long do_mincore(unsigned long addr, unsigned long pages, unsigned char *vec)</span>
<span class="p_add">+static long do_mincore(unsigned long addr, unsigned long pages,</span>
<span class="p_add">+		unsigned char *vec, int flags)</span>
 {
 	struct vm_area_struct *vma;
 	unsigned long end;
 	int err;
<span class="p_add">+	struct mincore_params p = {</span>
<span class="p_add">+		.vec = vec,</span>
<span class="p_add">+		.flags = flags,</span>
<span class="p_add">+	};</span>
 	struct mm_walk mincore_walk = {
 		.pmd_entry = mincore_pte_range,
 		.pte_hole = mincore_unmapped_range,
 		.hugetlb_entry = mincore_hugetlb,
<span class="p_del">-		.private = vec,</span>
<span class="p_add">+		.private = &amp;p,</span>
 	};
 
 	vma = find_vma(current-&gt;mm, addr);
<span class="p_chunk">@@ -195,13 +249,19 @@</span> <span class="p_context"> static long do_mincore(unsigned long addr, unsigned long pages, unsigned char *v</span>
 }
 
 /*
<span class="p_del">- * The mincore(2) system call.</span>
<span class="p_add">+ * The mincore2(2) system call.</span>
  *
<span class="p_del">- * mincore() returns the memory residency status of the pages in the</span>
<span class="p_add">+ * mincore2() returns the memory residency status of the pages in the</span>
  * current process&#39;s address space specified by [addr, addr + len).
  * The status is returned in a vector of bytes.  The least significant
  * bit of each byte is 1 if the referenced page is in memory, otherwise
<span class="p_del">- * it is zero.</span>
<span class="p_add">+ * it is zero.  When &#39;flags&#39; is non-zero each byte additionally contains</span>
<span class="p_add">+ * an indication of whether the referenced page in memory is a DAX</span>
<span class="p_add">+ * mapping (bit 2 of each vector byte), and/or the order of the mapping</span>
<span class="p_add">+ * (bits 3 through 7 of each vector byte).  Where the order relates to</span>
<span class="p_add">+ * the hardware mapping size backing the given logical-page.  For</span>
<span class="p_add">+ * example, a 2MB-dax-mapped-huge-page would correspond to 512 vector</span>
<span class="p_add">+ * entries with the value 0x27.</span>
  *
  * Because the status of a page can change after mincore() checks it
  * but before it returns to the application, the returned vector may
<span class="p_chunk">@@ -218,8 +278,8 @@</span> <span class="p_context"> static long do_mincore(unsigned long addr, unsigned long pages, unsigned char *v</span>
  *		mapped
  *  -EAGAIN - A kernel resource was temporarily unavailable.
  */
<span class="p_del">-SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,</span>
<span class="p_del">-		unsigned char __user *, vec)</span>
<span class="p_add">+SYSCALL_DEFINE4(mincore2, unsigned long, start, size_t, len,</span>
<span class="p_add">+		unsigned char __user *, vec, int, flags)</span>
 {
 	long retval;
 	unsigned long pages;
<span class="p_chunk">@@ -229,6 +289,10 @@</span> <span class="p_context"> SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,</span>
 	if (start &amp; ~PAGE_MASK)
 		return -EINVAL;
 
<span class="p_add">+	/* Check that undefined flags are zero */</span>
<span class="p_add">+	if (flags &amp; ~(MINCORE_DAX | MINCORE_ORDER))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* ..and we need to be passed a valid user-space range */
 	if (!access_ok(VERIFY_READ, (void __user *) start, len))
 		return -ENOMEM;
<span class="p_chunk">@@ -251,7 +315,7 @@</span> <span class="p_context"> SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,</span>
 		 * the temporary buffer size.
 		 */
 		down_read(&amp;current-&gt;mm-&gt;mmap_sem);
<span class="p_del">-		retval = do_mincore(start, min(pages, PAGE_SIZE), tmp);</span>
<span class="p_add">+		retval = do_mincore(start, min(pages, PAGE_SIZE), tmp, flags);</span>
 		up_read(&amp;current-&gt;mm-&gt;mmap_sem);
 
 		if (retval &lt;= 0)
<span class="p_chunk">@@ -268,3 +332,9 @@</span> <span class="p_context"> SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,</span>
 	free_page((unsigned long) tmp);
 	return retval;
 }
<span class="p_add">+</span>
<span class="p_add">+SYSCALL_DEFINE3(mincore, unsigned long, start, size_t, len,</span>
<span class="p_add">+		unsigned char __user *, vec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sys_mincore2(start, len, vec, 0);</span>
<span class="p_add">+}</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



