
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.45 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.45</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 26, 2017, 7:48 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170126074827.GB16737@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9538391/mbox/"
   >mbox</a>
|
   <a href="/patch/9538391/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9538391/">/patch/9538391/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	8A34B6046A for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 26 Jan 2017 07:48:27 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7711427F17
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 26 Jan 2017 07:48:27 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6BE9827F99; Thu, 26 Jan 2017 07:48:27 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6595727F17
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 26 Jan 2017 07:48:25 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752949AbdAZHsU (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 26 Jan 2017 02:48:20 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:56222 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752918AbdAZHsQ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 26 Jan 2017 02:48:16 -0500
Received: from localhost (unknown [78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id E8D588CC;
	Thu, 26 Jan 2017 07:48:14 +0000 (UTC)
Date: Thu, 26 Jan 2017 08:48:27 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.45
Message-ID: &lt;20170126074827.GB16737@kroah.com&gt;
References: &lt;20170126074820.GA16737@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170126074820.GA16737@kroah.com&gt;
User-Agent: Mutt/1.7.2 (2016-11-26)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 26, 2017, 7:48 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/clock/imx31-clock.txt b/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_header">index 19df842c694f..8163d565f697 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/clock/imx31-clock.txt</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> Examples:</span>
 clks: ccm@53f80000{
 	compatible = &quot;fsl,imx31-ccm&quot;;
 	reg = &lt;0x53f80000 0x4000&gt;;
<span class="p_del">-	interrupts = &lt;0 31 0x04 0 53 0x04&gt;;</span>
<span class="p_add">+	interrupts = &lt;31&gt;, &lt;53&gt;;</span>
 	#clock-cells = &lt;1&gt;;
 };
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index d6a1de0e2bd7..a3dfc73da722 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 44</span>
<span class="p_add">+SUBLEVEL = 45</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/da850-evm.dts b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">index 4f935ad9f27b..6881757b03e8 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/da850-evm.dts</span>
<span class="p_chunk">@@ -85,6 +85,7 @@</span> <span class="p_context"></span>
 				#size-cells = &lt;1&gt;;
 				compatible = &quot;m25p64&quot;;
 				spi-max-frequency = &lt;30000000&gt;;
<span class="p_add">+				m25p,fast-read;</span>
 				reg = &lt;0&gt;;
 				partition@0 {
 					label = &quot;U-Boot-SPL&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx31.dtsi b/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_header">index 5fdb222636a7..cbe5fd5ed179 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx31.dtsi</span>
<span class="p_chunk">@@ -30,11 +30,11 @@</span> <span class="p_context"></span>
 		};
 	};
 
<span class="p_del">-	avic: avic-interrupt-controller@60000000 {</span>
<span class="p_add">+	avic: interrupt-controller@68000000 {</span>
 		compatible = &quot;fsl,imx31-avic&quot;, &quot;fsl,avic&quot;;
 		interrupt-controller;
 		#interrupt-cells = &lt;1&gt;;
<span class="p_del">-		reg = &lt;0x60000000 0x100000&gt;;</span>
<span class="p_add">+		reg = &lt;0x68000000 0x100000&gt;;</span>
 	};
 
 	soc {
<span class="p_chunk">@@ -110,13 +110,6 @@</span> <span class="p_context"></span>
 				interrupts = &lt;19&gt;;
 				clocks = &lt;&amp;clks 25&gt;;
 			};
<span class="p_del">-</span>
<span class="p_del">-			clks: ccm@53f80000{</span>
<span class="p_del">-				compatible = &quot;fsl,imx31-ccm&quot;;</span>
<span class="p_del">-				reg = &lt;0x53f80000 0x4000&gt;;</span>
<span class="p_del">-				interrupts = &lt;0 31 0x04 0 53 0x04&gt;;</span>
<span class="p_del">-				#clock-cells = &lt;1&gt;;</span>
<span class="p_del">-			};</span>
 		};
 
 		aips@53f00000 { /* AIPS2 */
<span class="p_chunk">@@ -126,6 +119,13 @@</span> <span class="p_context"></span>
 			reg = &lt;0x53f00000 0x100000&gt;;
 			ranges;
 
<span class="p_add">+			clks: ccm@53f80000{</span>
<span class="p_add">+				compatible = &quot;fsl,imx31-ccm&quot;;</span>
<span class="p_add">+				reg = &lt;0x53f80000 0x4000&gt;;</span>
<span class="p_add">+				interrupts = &lt;31&gt;, &lt;53&gt;;</span>
<span class="p_add">+				#clock-cells = &lt;1&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
 			gpt: timer@53f90000 {
 				compatible = &quot;fsl,imx31-gpt&quot;;
 				reg = &lt;0x53f90000 0x4000&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi b/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi</span>
<span class="p_header">index a35d54fd9cd3..ddfdb75a6e90 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-nitrogen6_max.dtsi</span>
<span class="p_chunk">@@ -319,8 +319,6 @@</span> <span class="p_context"></span>
 		compatible = &quot;fsl,imx6q-nitrogen6_max-sgtl5000&quot;,
 			     &quot;fsl,imx-audio-sgtl5000&quot;;
 		model = &quot;imx6q-nitrogen6_max-sgtl5000&quot;;
<span class="p_del">-		pinctrl-names = &quot;default&quot;;</span>
<span class="p_del">-		pinctrl-0 = &lt;&amp;pinctrl_sgtl5000&gt;;</span>
 		ssi-controller = &lt;&amp;ssi1&gt;;
 		audio-codec = &lt;&amp;codec&gt;;
 		audio-routing =
<span class="p_chunk">@@ -401,6 +399,8 @@</span> <span class="p_context"></span>
 
 	codec: sgtl5000@0a {
 		compatible = &quot;fsl,sgtl5000&quot;;
<span class="p_add">+		pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+		pinctrl-0 = &lt;&amp;pinctrl_sgtl5000&gt;;</span>
 		reg = &lt;0x0a&gt;;
 		clocks = &lt;&amp;clks 201&gt;;
 		VDDA-supply = &lt;&amp;reg_2p5v&gt;;
<span class="p_header">diff --git a/arch/arm/include/asm/cputype.h b/arch/arm/include/asm/cputype.h</span>
<span class="p_header">index 85e374f873ac..e9d04f475929 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/cputype.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/cputype.h</span>
<span class="p_chunk">@@ -81,6 +81,9 @@</span> <span class="p_context"></span>
 #define ARM_CPU_XSCALE_ARCH_V2		0x4000
 #define ARM_CPU_XSCALE_ARCH_V3		0x6000
 
<span class="p_add">+/* Qualcomm implemented cores */</span>
<span class="p_add">+#define ARM_CPU_PART_SCORPION		0x510002d0</span>
<span class="p_add">+</span>
 extern unsigned int processor_id;
 
 #ifdef CONFIG_CPU_CP15
<span class="p_header">diff --git a/arch/arm/kernel/hw_breakpoint.c b/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_header">index 6284779d64ee..abcbea1ae30b 100644</span>
<span class="p_header">--- a/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_header">+++ b/arch/arm/kernel/hw_breakpoint.c</span>
<span class="p_chunk">@@ -1066,6 +1066,22 @@</span> <span class="p_context"> static int __init arch_hw_breakpoint_init(void)</span>
 		return 0;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Scorpion CPUs (at least those in APQ8060) seem to set DBGPRSR.SPD</span>
<span class="p_add">+	 * whenever a WFI is issued, even if the core is not powered down, in</span>
<span class="p_add">+	 * violation of the architecture.  When DBGPRSR.SPD is set, accesses to</span>
<span class="p_add">+	 * breakpoint and watchpoint registers are treated as undefined, so</span>
<span class="p_add">+	 * this results in boot time and runtime failures when these are</span>
<span class="p_add">+	 * accessed and we unexpectedly take a trap.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * It&#39;s not clear if/how this can be worked around, so we blacklist</span>
<span class="p_add">+	 * Scorpion CPUs to avoid these issues.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	if (read_cpuid_part() == ARM_CPU_PART_SCORPION) {</span>
<span class="p_add">+		pr_info(&quot;Scorpion CPU detected. Hardware breakpoints and watchpoints disabled\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	has_ossr = core_has_os_save_restore();
 
 	/* Determine how many BRPs/WRPs are available. */
<span class="p_header">diff --git a/arch/arm/kernel/smp_tlb.c b/arch/arm/kernel/smp_tlb.c</span>
<span class="p_header">index 2e72be4f623e..7cb079e74010 100644</span>
<span class="p_header">--- a/arch/arm/kernel/smp_tlb.c</span>
<span class="p_header">+++ b/arch/arm/kernel/smp_tlb.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  */
 #include &lt;linux/preempt.h&gt;
 #include &lt;linux/smp.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 
 #include &lt;asm/smp_plat.h&gt;
 #include &lt;asm/tlbflush.h&gt;
<span class="p_chunk">@@ -40,8 +41,11 @@</span> <span class="p_context"> static inline void ipi_flush_tlb_mm(void *arg)</span>
 static inline void ipi_flush_tlb_page(void *arg)
 {
 	struct tlb_args *ta = (struct tlb_args *)arg;
<span class="p_add">+	unsigned int __ua_flags = uaccess_save_and_enable();</span>
 
 	local_flush_tlb_page(ta-&gt;ta_vma, ta-&gt;ta_start);
<span class="p_add">+</span>
<span class="p_add">+	uaccess_restore(__ua_flags);</span>
 }
 
 static inline void ipi_flush_tlb_kernel_page(void *arg)
<span class="p_chunk">@@ -54,8 +58,11 @@</span> <span class="p_context"> static inline void ipi_flush_tlb_kernel_page(void *arg)</span>
 static inline void ipi_flush_tlb_range(void *arg)
 {
 	struct tlb_args *ta = (struct tlb_args *)arg;
<span class="p_add">+	unsigned int __ua_flags = uaccess_save_and_enable();</span>
 
 	local_flush_tlb_range(ta-&gt;ta_vma, ta-&gt;ta_start, ta-&gt;ta_end);
<span class="p_add">+</span>
<span class="p_add">+	uaccess_restore(__ua_flags);</span>
 }
 
 static inline void ipi_flush_tlb_kernel_range(void *arg)
<span class="p_header">diff --git a/arch/arm/mach-ux500/pm.c b/arch/arm/mach-ux500/pm.c</span>
<span class="p_header">index 8538910db202..a970e7fcba9e 100644</span>
<span class="p_header">--- a/arch/arm/mach-ux500/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-ux500/pm.c</span>
<span class="p_chunk">@@ -134,8 +134,8 @@</span> <span class="p_context"> bool prcmu_pending_irq(void)</span>
  */
 bool prcmu_is_cpu_in_wfi(int cpu)
 {
<span class="p_del">-	return readl(PRCM_ARM_WFI_STANDBY) &amp; cpu ? PRCM_ARM_WFI_STANDBY_WFI1 :</span>
<span class="p_del">-		     PRCM_ARM_WFI_STANDBY_WFI0;</span>
<span class="p_add">+	return readl(PRCM_ARM_WFI_STANDBY) &amp;</span>
<span class="p_add">+		(cpu ? PRCM_ARM_WFI_STANDBY_WFI1 : PRCM_ARM_WFI_STANDBY_WFI0);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/ptrace.h b/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_header">index 208db3df135a..3378238b5d8b 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/ptrace.h</span>
<span class="p_chunk">@@ -76,6 +76,7 @@</span> <span class="p_context"> struct user_fpsimd_state {</span>
 	__uint128_t	vregs[32];
 	__u32		fpsr;
 	__u32		fpcr;
<span class="p_add">+	__u32		__reserved[2];</span>
 };
 
 struct user_hwdebug_state {
<span class="p_header">diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S</span>
<span class="p_header">index 5a3753d09e20..bd14849beb73 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/entry.S</span>
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> el0_inv:</span>
 	mov	x0, sp
 	mov	x1, #BAD_SYNC
 	mov	x2, x25
<span class="p_del">-	bl	bad_mode</span>
<span class="p_add">+	bl	bad_el0_sync</span>
 	b	ret_to_user
 ENDPROC(el0_sync)
 
<span class="p_header">diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">index fc779ec6f051..55909b2208cc 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -450,6 +450,8 @@</span> <span class="p_context"> static int hw_break_set(struct task_struct *target,</span>
 	/* (address, ctrl) registers */
 	limit = regset-&gt;n * regset-&gt;size;
 	while (count &amp;&amp; offset &lt; limit) {
<span class="p_add">+		if (count &lt; PTRACE_HBP_ADDR_SZ)</span>
<span class="p_add">+			return -EINVAL;</span>
 		ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;addr,
 					 offset, offset + PTRACE_HBP_ADDR_SZ);
 		if (ret)
<span class="p_chunk">@@ -459,6 +461,8 @@</span> <span class="p_context"> static int hw_break_set(struct task_struct *target,</span>
 			return ret;
 		offset += PTRACE_HBP_ADDR_SZ;
 
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			break;</span>
 		ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;ctrl,
 					 offset, offset + PTRACE_HBP_CTRL_SZ);
 		if (ret)
<span class="p_chunk">@@ -495,7 +499,7 @@</span> <span class="p_context"> static int gpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct user_pt_regs newregs;</span>
<span class="p_add">+	struct user_pt_regs newregs = task_pt_regs(target)-&gt;user_regs;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;newregs, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -525,7 +529,8 @@</span> <span class="p_context"> static int fpr_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	struct user_fpsimd_state newstate;</span>
<span class="p_add">+	struct user_fpsimd_state newstate =</span>
<span class="p_add">+		target-&gt;thread.fpsimd_state.user_fpsimd;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;newstate, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -549,7 +554,7 @@</span> <span class="p_context"> static int tls_set(struct task_struct *target, const struct user_regset *regset,</span>
 		   const void *kbuf, const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	unsigned long tls;</span>
<span class="p_add">+	unsigned long tls = target-&gt;thread.tp_value;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;tls, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -575,7 +580,8 @@</span> <span class="p_context"> static int system_call_set(struct task_struct *target,</span>
 			   unsigned int pos, unsigned int count,
 			   const void *kbuf, const void __user *ubuf)
 {
<span class="p_del">-	int syscallno, ret;</span>
<span class="p_add">+	int syscallno = task_pt_regs(target)-&gt;syscallno;</span>
<span class="p_add">+	int ret;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;syscallno, 0, -1);
 	if (ret)
<span class="p_chunk">@@ -847,7 +853,7 @@</span> <span class="p_context"> static int compat_tls_set(struct task_struct *target,</span>
 			  const void __user *ubuf)
 {
 	int ret;
<span class="p_del">-	compat_ulong_t tls;</span>
<span class="p_add">+	compat_ulong_t tls = target-&gt;thread.tp_value;</span>
 
 	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;tls, 0, -1);
 	if (ret)
<span class="p_header">diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c</span>
<span class="p_header">index e9b9b5364393..ca7f0ac5f708 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/traps.c</span>
<span class="p_chunk">@@ -434,16 +434,33 @@</span> <span class="p_context"> const char *esr_get_class_string(u32 esr)</span>
 }
 
 /*
<span class="p_del">- * bad_mode handles the impossible case in the exception vector.</span>
<span class="p_add">+ * bad_mode handles the impossible case in the exception vector. This is always</span>
<span class="p_add">+ * fatal.</span>
  */
 asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)
 {
<span class="p_del">-	siginfo_t info;</span>
<span class="p_del">-	void __user *pc = (void __user *)instruction_pointer(regs);</span>
 	console_verbose();
 
 	pr_crit(&quot;Bad mode in %s handler detected, code 0x%08x -- %s\n&quot;,
 		handler[reason], esr, esr_get_class_string(esr));
<span class="p_add">+</span>
<span class="p_add">+	die(&quot;Oops - bad mode&quot;, regs, 0);</span>
<span class="p_add">+	local_irq_disable();</span>
<span class="p_add">+	panic(&quot;bad mode&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * bad_el0_sync handles unexpected, but potentially recoverable synchronous</span>
<span class="p_add">+ * exceptions taken from EL0. Unlike bad_mode, this returns.</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void bad_el0_sync(struct pt_regs *regs, int reason, unsigned int esr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+	void __user *pc = (void __user *)instruction_pointer(regs);</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_crit(&quot;Bad EL0 synchronous exception detected on CPU%d, code 0x%08x -- %s\n&quot;,</span>
<span class="p_add">+		smp_processor_id(), esr, esr_get_class_string(esr));</span>
 	__show_regs(regs);
 
 	info.si_signo = SIGILL;
<span class="p_chunk">@@ -451,7 +468,10 @@</span> <span class="p_context"> asmlinkage void bad_mode(struct pt_regs *regs, int reason, unsigned int esr)</span>
 	info.si_code  = ILL_ILLOPC;
 	info.si_addr  = pc;
 
<span class="p_del">-	arm64_notify_die(&quot;Oops - bad mode&quot;, regs, &amp;info, 0);</span>
<span class="p_add">+	current-&gt;thread.fault_address = 0;</span>
<span class="p_add">+	current-&gt;thread.fault_code = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	force_sig_info(info.si_signo, &amp;info, current);</span>
 }
 
 void __pte_error(const char *file, int line, unsigned long val)
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index fdb0fbfb1197..aaacbd667212 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -1875,6 +1875,7 @@</span> <span class="p_context"> static struct irq_chip ioapic_chip __read_mostly = {</span>
 	.irq_ack		= irq_chip_ack_parent,
 	.irq_eoi		= ioapic_ack_level,
 	.irq_set_affinity	= ioapic_set_affinity,
<span class="p_add">+	.irq_retrigger		= irq_chip_retrigger_hierarchy,</span>
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
<span class="p_chunk">@@ -1886,6 +1887,7 @@</span> <span class="p_context"> static struct irq_chip ioapic_ir_chip __read_mostly = {</span>
 	.irq_ack		= irq_chip_ack_parent,
 	.irq_eoi		= ioapic_ir_ack_level,
 	.irq_set_affinity	= ioapic_set_affinity,
<span class="p_add">+	.irq_retrigger		= irq_chip_retrigger_hierarchy,</span>
 	.flags			= IRQCHIP_SKIP_SET_WAKE,
 };
 
<span class="p_header">diff --git a/arch/x86/kernel/mcount_64.S b/arch/x86/kernel/mcount_64.S</span>
<span class="p_header">index 87e1762e2bca..5d9afbcb6074 100644</span>
<span class="p_header">--- a/arch/x86/kernel/mcount_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/mcount_64.S</span>
<span class="p_chunk">@@ -180,7 +180,8 @@</span> <span class="p_context"> GLOBAL(ftrace_graph_call)</span>
 	jmp ftrace_stub
 #endif
 
<span class="p_del">-GLOBAL(ftrace_stub)</span>
<span class="p_add">+/* This is weak to keep gas from relaxing the jumps */</span>
<span class="p_add">+WEAK(ftrace_stub)</span>
 	retq
 END(ftrace_caller)
 
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index 3cd69832d7f4..3961103e9176 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -114,6 +114,16 @@</span> <span class="p_context"> static const struct dmi_system_id pci_crs_quirks[] __initconst = {</span>
 			DMI_MATCH(DMI_BIOS_VERSION, &quot;6JET85WW (1.43 )&quot;),
 		},
 	},
<span class="p_add">+	/* https://bugzilla.kernel.org/show_bug.cgi?id=42606 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_nouse_crs,</span>
<span class="p_add">+		.ident = &quot;Supermicro X8DTH&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Supermicro&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X8DTH-i/6/iF/6F&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BIOS_VERSION, &quot;2.0a&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* https://bugzilla.kernel.org/show_bug.cgi?id=15362 */
 	{
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index ff44082a0827..47f8aafe3344 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -482,6 +482,7 @@</span> <span class="p_context"> static void exynos4_local_timer_stop(struct mct_clock_event_device *mevt)</span>
 	if (mct_int_type == MCT_INT_SPI) {
 		if (evt-&gt;irq != -1)
 			disable_irq_nosync(evt-&gt;irq);
<span class="p_add">+		exynos4_mct_write(0x1, mevt-&gt;base + MCT_L_INT_CSTAT_OFFSET);</span>
 	} else {
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
 	}
<span class="p_header">diff --git a/drivers/dma/pl330.c b/drivers/dma/pl330.c</span>
<span class="p_header">index 17ee758b419f..8250950aab8b 100644</span>
<span class="p_header">--- a/drivers/dma/pl330.c</span>
<span class="p_header">+++ b/drivers/dma/pl330.c</span>
<span class="p_chunk">@@ -445,6 +445,9 @@</span> <span class="p_context"> struct dma_pl330_chan {</span>
 
 	/* for cyclic capability */
 	bool cyclic;
<span class="p_add">+</span>
<span class="p_add">+	/* for runtime pm tracking */</span>
<span class="p_add">+	bool active;</span>
 };
 
 struct pl330_dmac {
<span class="p_chunk">@@ -1994,6 +1997,7 @@</span> <span class="p_context"> static void pl330_tasklet(unsigned long data)</span>
 		_stop(pch-&gt;thread);
 		spin_unlock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
 		power_down = true;
<span class="p_add">+		pch-&gt;active = false;</span>
 	} else {
 		/* Make sure the PL330 Channel thread is active */
 		spin_lock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
<span class="p_chunk">@@ -2015,6 +2019,7 @@</span> <span class="p_context"> static void pl330_tasklet(unsigned long data)</span>
 			desc-&gt;status = PREP;
 			list_move_tail(&amp;desc-&gt;node, &amp;pch-&gt;work_list);
 			if (power_down) {
<span class="p_add">+				pch-&gt;active = true;</span>
 				spin_lock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
 				_start(pch-&gt;thread);
 				spin_unlock(&amp;pch-&gt;thread-&gt;dmac-&gt;lock);
<span class="p_chunk">@@ -2129,6 +2134,7 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	unsigned long flags;
 	struct pl330_dmac *pl330 = pch-&gt;dmac;
 	LIST_HEAD(list);
<span class="p_add">+	bool power_down = false;</span>
 
 	pm_runtime_get_sync(pl330-&gt;ddma.dev);
 	spin_lock_irqsave(&amp;pch-&gt;lock, flags);
<span class="p_chunk">@@ -2139,6 +2145,8 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	pch-&gt;thread-&gt;req[0].desc = NULL;
 	pch-&gt;thread-&gt;req[1].desc = NULL;
 	pch-&gt;thread-&gt;req_running = -1;
<span class="p_add">+	power_down = pch-&gt;active;</span>
<span class="p_add">+	pch-&gt;active = false;</span>
 
 	/* Mark all desc done */
 	list_for_each_entry(desc, &amp;pch-&gt;submitted_list, node) {
<span class="p_chunk">@@ -2156,6 +2164,8 @@</span> <span class="p_context"> static int pl330_terminate_all(struct dma_chan *chan)</span>
 	list_splice_tail_init(&amp;pch-&gt;completed_list, &amp;pl330-&gt;desc_pool);
 	spin_unlock_irqrestore(&amp;pch-&gt;lock, flags);
 	pm_runtime_mark_last_busy(pl330-&gt;ddma.dev);
<span class="p_add">+	if (power_down)</span>
<span class="p_add">+		pm_runtime_put_autosuspend(pl330-&gt;ddma.dev);</span>
 	pm_runtime_put_autosuspend(pl330-&gt;ddma.dev);
 
 	return 0;
<span class="p_chunk">@@ -2302,6 +2312,7 @@</span> <span class="p_context"> static void pl330_issue_pending(struct dma_chan *chan)</span>
 		 * updated on work_list emptiness status.
 		 */
 		WARN_ON(list_empty(&amp;pch-&gt;submitted_list));
<span class="p_add">+		pch-&gt;active = true;</span>
 		pm_runtime_get_sync(pch-&gt;dmac-&gt;ddma.dev);
 	}
 	list_splice_tail_init(&amp;pch-&gt;submitted_list, &amp;pch-&gt;work_list);
<span class="p_header">diff --git a/drivers/hid/hid-corsair.c b/drivers/hid/hid-corsair.c</span>
<span class="p_header">index bcefb9ebb026..88be56321610 100644</span>
<span class="p_header">--- a/drivers/hid/hid-corsair.c</span>
<span class="p_header">+++ b/drivers/hid/hid-corsair.c</span>
<span class="p_chunk">@@ -148,26 +148,36 @@</span> <span class="p_context"> static enum led_brightness k90_backlight_get(struct led_classdev *led_cdev)</span>
 	struct usb_interface *usbif = to_usb_interface(dev-&gt;parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int brightness;
<span class="p_del">-	char data[8];</span>
<span class="p_add">+	char *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kmalloc(8, GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 			      USB_DIR_IN | USB_TYPE_VENDOR |
 			      USB_RECIP_DEVICE, 0, 0, data, 8,
 			      USB_CTRL_SET_TIMEOUT);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_add">+	if (ret &lt; 5) {</span>
 		dev_warn(dev, &quot;Failed to get K90 initial state (error %d).\n&quot;,
 			 ret);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 	brightness = data[4];
 	if (brightness &lt; 0 || brightness &gt; 3) {
 		dev_warn(dev,
 			 &quot;Read invalid backlight brightness: %02hhx.\n&quot;,
 			 data[4]);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
<span class="p_del">-	return brightness;</span>
<span class="p_add">+	ret = brightness;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static enum led_brightness k90_record_led_get(struct led_classdev *led_cdev)
<span class="p_chunk">@@ -253,17 +263,22 @@</span> <span class="p_context"> static ssize_t k90_show_macro_mode(struct device *dev,</span>
 	struct usb_interface *usbif = to_usb_interface(dev-&gt;parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	const char *macro_mode;
<span class="p_del">-	char data[8];</span>
<span class="p_add">+	char *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kmalloc(2, GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_GET_MODE,
 			      USB_DIR_IN | USB_TYPE_VENDOR |
 			      USB_RECIP_DEVICE, 0, 0, data, 2,
 			      USB_CTRL_SET_TIMEOUT);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_add">+	if (ret &lt; 1) {</span>
 		dev_warn(dev, &quot;Failed to get K90 initial mode (error %d).\n&quot;,
 			 ret);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	switch (data[0]) {
<span class="p_chunk">@@ -277,10 +292,15 @@</span> <span class="p_context"> static ssize_t k90_show_macro_mode(struct device *dev,</span>
 	default:
 		dev_warn(dev, &quot;K90 in unknown mode: %02hhx.\n&quot;,
 			 data[0]);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, macro_mode);</span>
<span class="p_add">+	ret = snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, macro_mode);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static ssize_t k90_store_macro_mode(struct device *dev,
<span class="p_chunk">@@ -320,26 +340,36 @@</span> <span class="p_context"> static ssize_t k90_show_current_profile(struct device *dev,</span>
 	struct usb_interface *usbif = to_usb_interface(dev-&gt;parent);
 	struct usb_device *usbdev = interface_to_usbdev(usbif);
 	int current_profile;
<span class="p_del">-	char data[8];</span>
<span class="p_add">+	char *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kmalloc(8, GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	ret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),
 			      K90_REQUEST_STATUS,
 			      USB_DIR_IN | USB_TYPE_VENDOR |
 			      USB_RECIP_DEVICE, 0, 0, data, 8,
 			      USB_CTRL_SET_TIMEOUT);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_add">+	if (ret &lt; 8) {</span>
 		dev_warn(dev, &quot;Failed to get K90 initial state (error %d).\n&quot;,
 			 ret);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 	current_profile = data[7];
 	if (current_profile &lt; 1 || current_profile &gt; 3) {
 		dev_warn(dev, &quot;Read invalid current profile: %02hhx.\n&quot;,
 			 data[7]);
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, current_profile);</span>
<span class="p_add">+	ret = snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, current_profile);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static ssize_t k90_store_current_profile(struct device *dev,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index c007c766c61e..fc21bdbb8b32 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -113,7 +113,9 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 		       !(1 &lt;&lt; ah-&gt;av.eth.stat_rate &amp; dev-&gt;caps.stat_rate_support))
 			--ah-&gt;av.eth.stat_rate;
 	}
<span class="p_del">-</span>
<span class="p_add">+	ah-&gt;av.eth.sl_tclass_flowlabel |=</span>
<span class="p_add">+			cpu_to_be32((ah_attr-&gt;grh.traffic_class &lt;&lt; 20) |</span>
<span class="p_add">+				    ah_attr-&gt;grh.flow_label);</span>
 	/*
 	 * HW requires multicast LID so we just choose one.
 	 */
<span class="p_chunk">@@ -121,7 +123,7 @@</span> <span class="p_context"> static struct ib_ah *create_iboe_ah(struct ib_pd *pd, struct ib_ah_attr *ah_attr</span>
 		ah-&gt;av.ib.dlid = cpu_to_be16(0xc000);
 
 	memcpy(ah-&gt;av.eth.dgid, ah_attr-&gt;grh.dgid.raw, 16);
<span class="p_del">-	ah-&gt;av.eth.sl_tclass_flowlabel = cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 29);</span>
<span class="p_add">+	ah-&gt;av.eth.sl_tclass_flowlabel |= cpu_to_be32(ah_attr-&gt;sl &lt;&lt; 29);</span>
 
 	return &amp;ah-&gt;ibah;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/main.c b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">index 97d6878f9938..77ddf2fa8625 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_chunk">@@ -630,9 +630,11 @@</span> <span class="p_context"> static int eth_link_query_port(struct ib_device *ibdev, u8 port,</span>
 	if (err)
 		goto out;
 
<span class="p_del">-	props-&gt;active_width	=  (((u8 *)mailbox-&gt;buf)[5] == 0x40) ?</span>
<span class="p_del">-						IB_WIDTH_4X : IB_WIDTH_1X;</span>
<span class="p_del">-	props-&gt;active_speed	= IB_SPEED_QDR;</span>
<span class="p_add">+	props-&gt;active_width	=  (((u8 *)mailbox-&gt;buf)[5] == 0x40) ||</span>
<span class="p_add">+				   (((u8 *)mailbox-&gt;buf)[5] == 0x20 /*56Gb*/) ?</span>
<span class="p_add">+					   IB_WIDTH_4X : IB_WIDTH_1X;</span>
<span class="p_add">+	props-&gt;active_speed	=  (((u8 *)mailbox-&gt;buf)[5] == 0x20 /*56Gb*/) ?</span>
<span class="p_add">+					   IB_SPEED_FDR : IB_SPEED_QDR;</span>
 	props-&gt;port_cap_flags	= IB_PORT_CM_SUP | IB_PORT_IP_BASED_GIDS;
 	props-&gt;gid_tbl_len	= mdev-&gt;dev-&gt;caps.gid_table_len[port];
 	props-&gt;max_msg_sz	= mdev-&gt;dev-&gt;caps.max_msg_sz;
<span class="p_chunk">@@ -2401,14 +2403,19 @@</span> <span class="p_context"> static void *mlx4_ib_add(struct mlx4_dev *dev)</span>
 			goto err_steer_qp_release;
 		}
 
<span class="p_del">-		bitmap_zero(ibdev-&gt;ib_uc_qpns_bitmap, ibdev-&gt;steer_qpn_count);</span>
<span class="p_del">-</span>
<span class="p_del">-		err = mlx4_FLOW_STEERING_IB_UC_QP_RANGE(</span>
<span class="p_del">-				dev, ibdev-&gt;steer_qpn_base,</span>
<span class="p_del">-				ibdev-&gt;steer_qpn_base +</span>
<span class="p_del">-				ibdev-&gt;steer_qpn_count - 1);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			goto err_steer_free_bitmap;</span>
<span class="p_add">+		if (dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_DMFS_IPOIB) {</span>
<span class="p_add">+			bitmap_zero(ibdev-&gt;ib_uc_qpns_bitmap,</span>
<span class="p_add">+				    ibdev-&gt;steer_qpn_count);</span>
<span class="p_add">+			err = mlx4_FLOW_STEERING_IB_UC_QP_RANGE(</span>
<span class="p_add">+					dev, ibdev-&gt;steer_qpn_base,</span>
<span class="p_add">+					ibdev-&gt;steer_qpn_base +</span>
<span class="p_add">+					ibdev-&gt;steer_qpn_count - 1);</span>
<span class="p_add">+			if (err)</span>
<span class="p_add">+				goto err_steer_free_bitmap;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			bitmap_fill(ibdev-&gt;ib_uc_qpns_bitmap,</span>
<span class="p_add">+				    ibdev-&gt;steer_qpn_count);</span>
<span class="p_add">+		}</span>
 	}
 
 	for (j = 1; j &lt;= ibdev-&gt;dev-&gt;caps.num_ports; j++)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index f350f2d61c15..1c8b7c22c822 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -1207,7 +1207,8 @@</span> <span class="p_context"> int mlx4_ib_destroy_qp(struct ib_qp *qp)</span>
 	if (is_qp0(dev, mqp))
 		mlx4_CLOSE_PORT(dev-&gt;dev, mqp-&gt;port);
 
<span class="p_del">-	if (dev-&gt;qp1_proxy[mqp-&gt;port - 1] == mqp) {</span>
<span class="p_add">+	if (mqp-&gt;mlx4_ib_qp_type == MLX4_IB_QPT_PROXY_GSI &amp;&amp;</span>
<span class="p_add">+	    dev-&gt;qp1_proxy[mqp-&gt;port - 1] == mqp) {</span>
 		mutex_lock(&amp;dev-&gt;qp1_proxy_lock[mqp-&gt;port - 1]);
 		dev-&gt;qp1_proxy[mqp-&gt;port - 1] = NULL;
 		mutex_unlock(&amp;dev-&gt;qp1_proxy_lock[mqp-&gt;port - 1]);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">index 6000f7aeede9..3399271c235b 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_chunk">@@ -614,6 +614,33 @@</span> <span class="p_context"> int mlx5_mr_cache_init(struct mlx5_ib_dev *dev)</span>
 	return 0;
 }
 
<span class="p_add">+static void wait_for_async_commands(struct mlx5_ib_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx5_mr_cache *cache = &amp;dev-&gt;cache;</span>
<span class="p_add">+	struct mlx5_cache_ent *ent;</span>
<span class="p_add">+	int total = 0;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int j;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_MR_CACHE_ENTRIES; i++) {</span>
<span class="p_add">+		ent = &amp;cache-&gt;ent[i];</span>
<span class="p_add">+		for (j = 0 ; j &lt; 1000; j++) {</span>
<span class="p_add">+			if (!ent-&gt;pending)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			msleep(50);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_MR_CACHE_ENTRIES; i++) {</span>
<span class="p_add">+		ent = &amp;cache-&gt;ent[i];</span>
<span class="p_add">+		total += ent-&gt;pending;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (total)</span>
<span class="p_add">+		mlx5_ib_warn(dev, &quot;aborted while there are %d pending mr requests\n&quot;, total);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mlx5_ib_warn(dev, &quot;done with all pending requests\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int mlx5_mr_cache_cleanup(struct mlx5_ib_dev *dev)
 {
 	int i;
<span class="p_chunk">@@ -627,6 +654,7 @@</span> <span class="p_context"> int mlx5_mr_cache_cleanup(struct mlx5_ib_dev *dev)</span>
 		clean_keys(dev, i);
 
 	destroy_workqueue(dev-&gt;cache.wq);
<span class="p_add">+	wait_for_async_commands(dev);</span>
 	del_timer_sync(&amp;dev-&gt;delay_timer);
 
 	return 0;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 8ca75af0e6d1..de5e2b01ab05 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1035,8 +1035,6 @@</span> <span class="p_context"> static struct ib_qp *ipoib_cm_create_tx_qp(struct net_device *dev, struct ipoib_</span>
 
 	tx_qp = ib_create_qp(priv-&gt;pd, &amp;attr);
 	if (PTR_ERR(tx_qp) == -EINVAL) {
<span class="p_del">-		ipoib_warn(priv, &quot;can&#39;t use GFP_NOIO for QPs on device %s, using GFP_KERNEL\n&quot;,</span>
<span class="p_del">-			   priv-&gt;ca-&gt;name);</span>
 		attr.create_flags &amp;= ~IB_QP_CREATE_USE_GFP_NOIO;
 		tx_qp = ib_create_qp(priv-&gt;pd, &amp;attr);
 	}
<span class="p_header">diff --git a/drivers/media/platform/blackfin/ppi.c b/drivers/media/platform/blackfin/ppi.c</span>
<span class="p_header">index cff63e511e6d..b8f3d9fa66e9 100644</span>
<span class="p_header">--- a/drivers/media/platform/blackfin/ppi.c</span>
<span class="p_header">+++ b/drivers/media/platform/blackfin/ppi.c</span>
<span class="p_chunk">@@ -214,6 +214,8 @@</span> <span class="p_context"> static int ppi_set_params(struct ppi_if *ppi, struct ppi_params *params)</span>
 	if (params-&gt;dlen &gt; 24 || params-&gt;dlen &lt;= 0)
 		return -EINVAL;
 	pctrl = devm_pinctrl_get(ppi-&gt;dev);
<span class="p_add">+	if (IS_ERR(pctrl))</span>
<span class="p_add">+		return PTR_ERR(pctrl);</span>
 	pstate = pinctrl_lookup_state(pctrl,
 				      pin_state[(params-&gt;dlen + 7) / 8 - 1]);
 	if (pinctrl_select_state(pctrl, pstate))
<span class="p_header">diff --git a/drivers/media/rc/ite-cir.c b/drivers/media/rc/ite-cir.c</span>
<span class="p_header">index 0f301903aa6f..63165d324fff 100644</span>
<span class="p_header">--- a/drivers/media/rc/ite-cir.c</span>
<span class="p_header">+++ b/drivers/media/rc/ite-cir.c</span>
<span class="p_chunk">@@ -263,6 +263,8 @@</span> <span class="p_context"> static void ite_set_carrier_params(struct ite_dev *dev)</span>
 
 			if (allowance &gt; ITE_RXDCR_MAX)
 				allowance = ITE_RXDCR_MAX;
<span class="p_add">+</span>
<span class="p_add">+			use_demodulator = true;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mmc/host/mxs-mmc.c b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">index 44ecebd1ea8c..c8b8ac66ff7e 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_chunk">@@ -309,6 +309,9 @@</span> <span class="p_context"> static void mxs_mmc_ac(struct mxs_mmc_host *host)</span>
 	cmd0 = BF_SSP(cmd-&gt;opcode, CMD0_CMD);
 	cmd1 = cmd-&gt;arg;
 
<span class="p_add">+	if (cmd-&gt;opcode == MMC_STOP_TRANSMISSION)</span>
<span class="p_add">+		cmd0 |= BM_SSP_CMD0_APPEND_8CYC;</span>
<span class="p_add">+</span>
 	if (host-&gt;sdio_irq_en) {
 		ctrl0 |= BM_SSP_CTRL0_SDIO_IRQ_CHECK;
 		cmd0 |= BM_SSP_CMD0_CONT_CLKING_EN | BM_SSP_CMD0_SLOW_CLKING_EN;
<span class="p_chunk">@@ -417,8 +420,7 @@</span> <span class="p_context"> static void mxs_mmc_adtc(struct mxs_mmc_host *host)</span>
 		       ssp-&gt;base + HW_SSP_BLOCK_SIZE);
 	}
 
<span class="p_del">-	if ((cmd-&gt;opcode == MMC_STOP_TRANSMISSION) ||</span>
<span class="p_del">-	    (cmd-&gt;opcode == SD_IO_RW_EXTENDED))</span>
<span class="p_add">+	if (cmd-&gt;opcode == SD_IO_RW_EXTENDED)</span>
 		cmd0 |= BM_SSP_CMD0_APPEND_8CYC;
 
 	cmd1 = cmd-&gt;arg;
<span class="p_header">diff --git a/drivers/mtd/nand/Kconfig b/drivers/mtd/nand/Kconfig</span>
<span class="p_header">index 289664089cf3..8f49f8aeff1a 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/Kconfig</span>
<span class="p_header">+++ b/drivers/mtd/nand/Kconfig</span>
<span class="p_chunk">@@ -527,7 +527,7 @@</span> <span class="p_context"> config MTD_NAND_FSMC</span>
 	  Flexible Static Memory Controller (FSMC)
 
 config MTD_NAND_XWAY
<span class="p_del">-	tristate &quot;Support for NAND on Lantiq XWAY SoC&quot;</span>
<span class="p_add">+	bool &quot;Support for NAND on Lantiq XWAY SoC&quot;</span>
 	depends on LANTIQ &amp;&amp; SOC_TYPE_XWAY
 	select MTD_NAND_PLATFORM
 	help
<span class="p_header">diff --git a/drivers/net/ieee802154/atusb.c b/drivers/net/ieee802154/atusb.c</span>
<span class="p_header">index 199a94a9c8bc..3a429f1a8002 100644</span>
<span class="p_header">--- a/drivers/net/ieee802154/atusb.c</span>
<span class="p_header">+++ b/drivers/net/ieee802154/atusb.c</span>
<span class="p_chunk">@@ -110,13 +110,26 @@</span> <span class="p_context"> static int atusb_read_reg(struct atusb *atusb, uint8_t reg)</span>
 {
 	struct usb_device *usb_dev = atusb-&gt;usb_dev;
 	int ret;
<span class="p_add">+	uint8_t *buffer;</span>
 	uint8_t value;
 
<span class="p_add">+	buffer = kmalloc(1, GFP_KERNEL);</span>
<span class="p_add">+	if (!buffer)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	dev_dbg(&amp;usb_dev-&gt;dev, &quot;atusb: reg = 0x%x\n&quot;, reg);
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,
<span class="p_del">-				0, reg, &amp;value, 1, 1000);</span>
<span class="p_del">-	return ret &gt;= 0 ? value : ret;</span>
<span class="p_add">+				0, reg, buffer, 1, 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &gt;= 0) {</span>
<span class="p_add">+		value = buffer[0];</span>
<span class="p_add">+		kfree(buffer);</span>
<span class="p_add">+		return value;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		kfree(buffer);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 }
 
 static int atusb_write_subreg(struct atusb *atusb, uint8_t reg, uint8_t mask,
<span class="p_chunk">@@ -517,9 +530,13 @@</span> <span class="p_context"> static struct ieee802154_ops atusb_ops = {</span>
 static int atusb_get_and_show_revision(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb-&gt;usb_dev;
<span class="p_del">-	unsigned char buffer[3];</span>
<span class="p_add">+	unsigned char *buffer;</span>
 	int ret;
 
<span class="p_add">+	buffer = kmalloc(3, GFP_KERNEL);</span>
<span class="p_add">+	if (!buffer)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	/* Get a couple of the ATMega Firmware values */
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
<span class="p_chunk">@@ -535,15 +552,20 @@</span> <span class="p_context"> static int atusb_get_and_show_revision(struct atusb *atusb)</span>
 		dev_info(&amp;usb_dev-&gt;dev, &quot;Please update to version 0.2 or newer&quot;);
 	}
 
<span class="p_add">+	kfree(buffer);</span>
 	return ret;
 }
 
 static int atusb_get_and_show_build(struct atusb *atusb)
 {
 	struct usb_device *usb_dev = atusb-&gt;usb_dev;
<span class="p_del">-	char build[ATUSB_BUILD_SIZE + 1];</span>
<span class="p_add">+	char *build;</span>
 	int ret;
 
<span class="p_add">+	build = kmalloc(ATUSB_BUILD_SIZE + 1, GFP_KERNEL);</span>
<span class="p_add">+	if (!build)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
 				ATUSB_BUILD, ATUSB_REQ_FROM_DEV, 0, 0,
 				build, ATUSB_BUILD_SIZE, 1000);
<span class="p_chunk">@@ -552,6 +574,7 @@</span> <span class="p_context"> static int atusb_get_and_show_build(struct atusb *atusb)</span>
 		dev_info(&amp;usb_dev-&gt;dev, &quot;Firmware: build %s\n&quot;, build);
 	}
 
<span class="p_add">+	kfree(build);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index b5843c255263..71d9a6d1bd56 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -1019,6 +1019,7 @@</span> <span class="p_context"> void set_pcie_port_type(struct pci_dev *pdev)</span>
 	pos = pci_find_capability(pdev, PCI_CAP_ID_EXP);
 	if (!pos)
 		return;
<span class="p_add">+</span>
 	pdev-&gt;pcie_cap = pos;
 	pci_read_config_word(pdev, pos + PCI_EXP_FLAGS, &amp;reg16);
 	pdev-&gt;pcie_flags_reg = reg16;
<span class="p_chunk">@@ -1026,13 +1027,14 @@</span> <span class="p_context"> void set_pcie_port_type(struct pci_dev *pdev)</span>
 	pdev-&gt;pcie_mpss = reg16 &amp; PCI_EXP_DEVCAP_PAYLOAD;
 
 	/*
<span class="p_del">-	 * A Root Port is always the upstream end of a Link.  No PCIe</span>
<span class="p_del">-	 * component has two Links.  Two Links are connected by a Switch</span>
<span class="p_del">-	 * that has a Port on each Link and internal logic to connect the</span>
<span class="p_del">-	 * two Ports.</span>
<span class="p_add">+	 * A Root Port or a PCI-to-PCIe bridge is always the upstream end</span>
<span class="p_add">+	 * of a Link.  No PCIe component has two Links.  Two Links are</span>
<span class="p_add">+	 * connected by a Switch that has a Port on each Link and internal</span>
<span class="p_add">+	 * logic to connect the two Ports.</span>
 	 */
 	type = pci_pcie_type(pdev);
<span class="p_del">-	if (type == PCI_EXP_TYPE_ROOT_PORT)</span>
<span class="p_add">+	if (type == PCI_EXP_TYPE_ROOT_PORT ||</span>
<span class="p_add">+	    type == PCI_EXP_TYPE_PCIE_BRIDGE)</span>
 		pdev-&gt;has_secondary_link = 1;
 	else if (type == PCI_EXP_TYPE_UPSTREAM ||
 		 type == PCI_EXP_TYPE_DOWNSTREAM) {
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_os.c b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">index c44cbf46221c..3588a56aabb4 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_os.c</span>
<span class="p_chunk">@@ -3365,7 +3365,7 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 				sizeof(struct ct6_dsd), 0,
 				SLAB_HWCACHE_ALIGN, NULL);
 			if (!ctx_cachep)
<span class="p_del">-				goto fail_free_gid_list;</span>
<span class="p_add">+				goto fail_free_srb_mempool;</span>
 		}
 		ha-&gt;ctx_mempool = mempool_create_slab_pool(SRB_MIN_REQ,
 			ctx_cachep);
<span class="p_chunk">@@ -3518,7 +3518,7 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 	ha-&gt;loop_id_map = kzalloc(BITS_TO_LONGS(LOOPID_MAP_SIZE) * sizeof(long),
 	    GFP_KERNEL);
 	if (!ha-&gt;loop_id_map)
<span class="p_del">-		goto fail_async_pd;</span>
<span class="p_add">+		goto fail_loop_id_map;</span>
 	else {
 		qla2x00_set_reserved_loop_ids(ha);
 		ql_dbg_pci(ql_dbg_init, ha-&gt;pdev, 0x0123,
<span class="p_chunk">@@ -3527,6 +3527,8 @@</span> <span class="p_context"> qla2x00_mem_alloc(struct qla_hw_data *ha, uint16_t req_len, uint16_t rsp_len,</span>
 
 	return 0;
 
<span class="p_add">+fail_loop_id_map:</span>
<span class="p_add">+	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;async_pd, ha-&gt;async_pd_dma);</span>
 fail_async_pd:
 	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;ex_init_cb, ha-&gt;ex_init_cb_dma);
 fail_ex_init_cb:
<span class="p_chunk">@@ -3554,6 +3556,10 @@</span> <span class="p_context"> fail_free_ms_iocb:</span>
 	dma_pool_free(ha-&gt;s_dma_pool, ha-&gt;ms_iocb, ha-&gt;ms_iocb_dma);
 	ha-&gt;ms_iocb = NULL;
 	ha-&gt;ms_iocb_dma = 0;
<span class="p_add">+</span>
<span class="p_add">+	if (ha-&gt;sns_cmd)</span>
<span class="p_add">+		dma_free_coherent(&amp;ha-&gt;pdev-&gt;dev, sizeof(struct sns_cmd_pkt),</span>
<span class="p_add">+		    ha-&gt;sns_cmd, ha-&gt;sns_cmd_dma);</span>
 fail_dma_pool:
 	if (IS_QLA82XX(ha) || ql2xenabledif) {
 		dma_pool_destroy(ha-&gt;fcp_cmnd_dma_pool);
<span class="p_chunk">@@ -3571,10 +3577,12 @@</span> <span class="p_context"> fail_free_nvram:</span>
 	kfree(ha-&gt;nvram);
 	ha-&gt;nvram = NULL;
 fail_free_ctx_mempool:
<span class="p_del">-	mempool_destroy(ha-&gt;ctx_mempool);</span>
<span class="p_add">+	if (ha-&gt;ctx_mempool)</span>
<span class="p_add">+		mempool_destroy(ha-&gt;ctx_mempool);</span>
 	ha-&gt;ctx_mempool = NULL;
 fail_free_srb_mempool:
<span class="p_del">-	mempool_destroy(ha-&gt;srb_mempool);</span>
<span class="p_add">+	if (ha-&gt;srb_mempool)</span>
<span class="p_add">+		mempool_destroy(ha-&gt;srb_mempool);</span>
 	ha-&gt;srb_mempool = NULL;
 fail_free_gid_list:
 	dma_free_coherent(&amp;ha-&gt;pdev-&gt;dev, qla2x00_gid_list_size(ha),
<span class="p_header">diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c</span>
<span class="p_header">index e7b130a637f9..239bc9cba28c 100644</span>
<span class="p_header">--- a/fs/ceph/mds_client.c</span>
<span class="p_header">+++ b/fs/ceph/mds_client.c</span>
<span class="p_chunk">@@ -274,12 +274,13 @@</span> <span class="p_context"> static int parse_reply_info_extra(void **p, void *end,</span>
 				  struct ceph_mds_reply_info_parsed *info,
 				  u64 features)
 {
<span class="p_del">-	if (info-&gt;head-&gt;op == CEPH_MDS_OP_GETFILELOCK)</span>
<span class="p_add">+	u32 op = le32_to_cpu(info-&gt;head-&gt;op);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (op == CEPH_MDS_OP_GETFILELOCK)</span>
 		return parse_reply_info_filelock(p, end, info, features);
<span class="p_del">-	else if (info-&gt;head-&gt;op == CEPH_MDS_OP_READDIR ||</span>
<span class="p_del">-		 info-&gt;head-&gt;op == CEPH_MDS_OP_LSSNAP)</span>
<span class="p_add">+	else if (op == CEPH_MDS_OP_READDIR || op == CEPH_MDS_OP_LSSNAP)</span>
 		return parse_reply_info_dir(p, end, info, features);
<span class="p_del">-	else if (info-&gt;head-&gt;op == CEPH_MDS_OP_CREATE)</span>
<span class="p_add">+	else if (op == CEPH_MDS_OP_CREATE)</span>
 		return parse_reply_info_create(p, end, info, features);
 	else
 		return -EIO;
<span class="p_header">diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c</span>
<span class="p_header">index ebb5e37455a0..9096d44eb221 100644</span>
<span class="p_header">--- a/fs/fuse/dev.c</span>
<span class="p_header">+++ b/fs/fuse/dev.c</span>
<span class="p_chunk">@@ -2083,7 +2083,6 @@</span> <span class="p_context"> static void end_requests(struct fuse_conn *fc, struct list_head *head)</span>
 		struct fuse_req *req;
 		req = list_entry(head-&gt;next, struct fuse_req, list);
 		req-&gt;out.h.error = -ECONNABORTED;
<span class="p_del">-		clear_bit(FR_PENDING, &amp;req-&gt;flags);</span>
 		clear_bit(FR_SENT, &amp;req-&gt;flags);
 		list_del_init(&amp;req-&gt;list);
 		request_end(fc, req);
<span class="p_chunk">@@ -2161,6 +2160,8 @@</span> <span class="p_context"> void fuse_abort_conn(struct fuse_conn *fc)</span>
 		spin_lock(&amp;fiq-&gt;waitq.lock);
 		fiq-&gt;connected = 0;
 		list_splice_init(&amp;fiq-&gt;pending, &amp;to_end2);
<span class="p_add">+		list_for_each_entry(req, &amp;to_end2, list)</span>
<span class="p_add">+			clear_bit(FR_PENDING, &amp;req-&gt;flags);</span>
 		while (forget_pending(fiq))
 			kfree(dequeue_forget(fiq, 1, NULL));
 		wake_up_all_locked(&amp;fiq-&gt;waitq);
<span class="p_header">diff --git a/fs/posix_acl.c b/fs/posix_acl.c</span>
<span class="p_header">index a60d3cc5b55d..993bb3b5f4d5 100644</span>
<span class="p_header">--- a/fs/posix_acl.c</span>
<span class="p_header">+++ b/fs/posix_acl.c</span>
<span class="p_chunk">@@ -903,11 +903,10 @@</span> <span class="p_context"> int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	int error;
 
 	if (type == ACL_TYPE_ACCESS) {
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		if (error == 0)</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_add">+		error = posix_acl_update_mode(inode,</span>
<span class="p_add">+				&amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
 	}
 
 	inode-&gt;i_ctime = CURRENT_TIME;
<span class="p_header">diff --git a/fs/ubifs/tnc.c b/fs/ubifs/tnc.c</span>
<span class="p_header">index fa9a20cc60d6..fe5e8d4970ae 100644</span>
<span class="p_header">--- a/fs/ubifs/tnc.c</span>
<span class="p_header">+++ b/fs/ubifs/tnc.c</span>
<span class="p_chunk">@@ -34,6 +34,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &quot;ubifs.h&quot;
 
<span class="p_add">+static int try_read_node(const struct ubifs_info *c, void *buf, int type,</span>
<span class="p_add">+			 int len, int lnum, int offs);</span>
<span class="p_add">+static int fallible_read_node(struct ubifs_info *c, const union ubifs_key *key,</span>
<span class="p_add">+			      struct ubifs_zbranch *zbr, void *node);</span>
<span class="p_add">+</span>
 /*
  * Returned codes of &#39;matches_name()&#39; and &#39;fallible_matches_name()&#39; functions.
  * @NAME_LESS: name corresponding to the first argument is less than second
<span class="p_chunk">@@ -402,7 +407,19 @@</span> <span class="p_context"> static int tnc_read_node_nm(struct ubifs_info *c, struct ubifs_zbranch *zbr,</span>
 		return 0;
 	}
 
<span class="p_del">-	err = ubifs_tnc_read_node(c, zbr, node);</span>
<span class="p_add">+	if (c-&gt;replaying) {</span>
<span class="p_add">+		err = fallible_read_node(c, &amp;zbr-&gt;key, zbr, node);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * When the node was not found, return -ENOENT, 0 otherwise.</span>
<span class="p_add">+		 * Negative return codes stay as-is.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (err == 0)</span>
<span class="p_add">+			err = -ENOENT;</span>
<span class="p_add">+		else if (err == 1)</span>
<span class="p_add">+			err = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = ubifs_tnc_read_node(c, zbr, node);</span>
<span class="p_add">+	}</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -2766,7 +2783,11 @@</span> <span class="p_context"> struct ubifs_dent_node *ubifs_tnc_next_ent(struct ubifs_info *c,</span>
 	if (nm-&gt;name) {
 		if (err) {
 			/* Handle collisions */
<span class="p_del">-			err = resolve_collision(c, key, &amp;znode, &amp;n, nm);</span>
<span class="p_add">+			if (c-&gt;replaying)</span>
<span class="p_add">+				err = fallible_resolve_collision(c, key, &amp;znode, &amp;n,</span>
<span class="p_add">+							 nm, 0);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				err = resolve_collision(c, key, &amp;znode, &amp;n, nm);</span>
 			dbg_tnc(&quot;rc returned %d, znode %p, n %d&quot;,
 				err, znode, n);
 			if (unlikely(err &lt; 0))
<span class="p_header">diff --git a/net/sunrpc/auth_gss/svcauth_gss.c b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">index 4605dc73def6..033fec307528 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/svcauth_gss.c</span>
<span class="p_chunk">@@ -1481,7 +1481,7 @@</span> <span class="p_context"> svcauth_gss_accept(struct svc_rqst *rqstp, __be32 *authp)</span>
 	case RPC_GSS_PROC_DESTROY:
 		if (gss_write_verf(rqstp, rsci-&gt;mechctx, gc-&gt;gc_seq))
 			goto auth_err;
<span class="p_del">-		rsci-&gt;h.expiry_time = get_seconds();</span>
<span class="p_add">+		rsci-&gt;h.expiry_time = seconds_since_boot();</span>
 		set_bit(CACHE_NEGATIVE, &amp;rsci-&gt;h.flags);
 		if (resv-&gt;iov_len + 4 &gt; PAGE_SIZE)
 			goto drop;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_header">index ff4f01e527ec..d4e0d648bcea 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_chunk">@@ -346,8 +346,6 @@</span> <span class="p_context"> int rdma_read_chunk_frmr(struct svcxprt_rdma *xprt,</span>
 	atomic_inc(&amp;rdma_stat_read);
 	return ret;
  err:
<span class="p_del">-	ib_dma_unmap_sg(xprt-&gt;sc_cm_id-&gt;device,</span>
<span class="p_del">-			frmr-&gt;sg, frmr-&gt;sg_nents, frmr-&gt;direction);</span>
 	svc_rdma_put_context(ctxt, 0);
 	svc_rdma_put_frmr(xprt, frmr);
 	return ret;
<span class="p_header">diff --git a/tools/perf/util/trace-event-scripting.c b/tools/perf/util/trace-event-scripting.c</span>
<span class="p_header">index 9df61059a85d..a2fd6e79d5a5 100644</span>
<span class="p_header">--- a/tools/perf/util/trace-event-scripting.c</span>
<span class="p_header">+++ b/tools/perf/util/trace-event-scripting.c</span>
<span class="p_chunk">@@ -95,7 +95,8 @@</span> <span class="p_context"> static void register_python_scripting(struct scripting_ops *scripting_ops)</span>
 	if (err)
 		die(&quot;error registering py script extension&quot;);
 
<span class="p_del">-	scripting_context = malloc(sizeof(struct scripting_context));</span>
<span class="p_add">+	if (scripting_context == NULL)</span>
<span class="p_add">+		scripting_context = malloc(sizeof(*scripting_context));</span>
 }
 
 #ifdef NO_LIBPYTHON
<span class="p_chunk">@@ -159,7 +160,8 @@</span> <span class="p_context"> static void register_perl_scripting(struct scripting_ops *scripting_ops)</span>
 	if (err)
 		die(&quot;error registering pl script extension&quot;);
 
<span class="p_del">-	scripting_context = malloc(sizeof(struct scripting_context));</span>
<span class="p_add">+	if (scripting_context == NULL)</span>
<span class="p_add">+		scripting_context = malloc(sizeof(*scripting_context));</span>
 }
 
 #ifdef NO_LIBPERL
<span class="p_header">diff --git a/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c b/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_header">index c22860ab9733..30e1ac62e8cb 100644</span>
<span class="p_header">--- a/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_header">+++ b/tools/testing/selftests/powerpc/pmu/ebb/pmc56_overflow_test.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> int pmc56_overflow(void)</span>
 
 	FAIL_IF(ebb_event_enable(&amp;event));
 
<span class="p_del">-	mtspr(SPRN_PMC1, pmc_sample_period(sample_period));</span>
<span class="p_add">+	mtspr(SPRN_PMC2, pmc_sample_period(sample_period));</span>
 	mtspr(SPRN_PMC5, 0);
 	mtspr(SPRN_PMC6, 0);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



