
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>powerpc/8xx: Perf events on PPC 8xx - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    powerpc/8xx: Perf events on PPC 8xx</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 15, 2016, 12:42 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161215124219.1E4C268021@localhost.localdomain&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9476047/mbox/"
   >mbox</a>
|
   <a href="/patch/9476047/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9476047/">/patch/9476047/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	51FCA60571 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 12:43:28 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 35B482865F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 12:43:28 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 290AB28764; Thu, 15 Dec 2016 12:43:28 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D51582865F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 12:43:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S935780AbcLOMnR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 15 Dec 2016 07:43:17 -0500
Received: from pegase1.c-s.fr ([93.17.236.30]:15833 &quot;EHLO pegase1.c-s.fr&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752990AbcLOMnN (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 15 Dec 2016 07:43:13 -0500
Received: from localhost (unknown [192.168.12.234])
	by localhost (Postfix) with ESMTP id 3tfY4C4Cf7z9ttFr;
	Thu, 15 Dec 2016 13:42:19 +0100 (CET)
X-Virus-Scanned: Debian amavisd-new at c-s.fr
Received: from pegase1.c-s.fr ([192.168.12.234])
	by localhost (pegase1.c-s.fr [192.168.12.234]) (amavisd-new,
	port 10024)
	with ESMTP id hRlMQ-pno07R; Thu, 15 Dec 2016 13:42:19 +0100 (CET)
Received: from messagerie.si.c-s.fr (messagerie.si.c-s.fr [192.168.25.192])
	by pegase1.c-s.fr (Postfix) with ESMTP id 3tfY4C3CVDz9ttDr;
	Thu, 15 Dec 2016 13:42:19 +0100 (CET)
Received: from localhost (localhost [127.0.0.1])
	by messagerie.si.c-s.fr (Postfix) with ESMTP id F23A98B7A8;
	Thu, 15 Dec 2016 13:42:19 +0100 (CET)
X-Virus-Scanned: amavisd-new at c-s.fr
Received: from messagerie.si.c-s.fr ([127.0.0.1])
	by localhost (messagerie.si.c-s.fr [127.0.0.1]) (amavisd-new,
	port 10023)
	with ESMTP id eW-RpDfQOOca; Thu, 15 Dec 2016 13:42:19 +0100 (CET)
Received: from PO15451.localdomain (po15451.idsi0.si.c-s.fr [172.25.231.2])
	by messagerie.si.c-s.fr (Postfix) with ESMTP id 5B7CD8B798;
	Thu, 15 Dec 2016 13:42:19 +0100 (CET)
Received: by localhost.localdomain (Postfix, from userid 0)
	id 1E4C268021; Thu, 15 Dec 2016 13:42:18 +0100 (CET)
From: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;
Subject: [PATCH] powerpc/8xx: Perf events on PPC 8xx
To: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;,
	Paul Mackerras &lt;paulus@samba.org&gt;, Michael Ellerman &lt;mpe@ellerman.id.au&gt;,
	Scott Wood &lt;oss@buserror.net&gt;, Peter Zijlstra &lt;peterz@infradead.org&gt;,
	Ingo Molnar &lt;mingo@redhat.com&gt;,
	Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;
Cc: linux-kernel@vger.kernel.org, linuxppc-dev@lists.ozlabs.org,
	Alexander Shishkin &lt;alexander.shishkin@linux.intel.com&gt;
Message-Id: &lt;20161215124219.1E4C268021@localhost.localdomain&gt;
Date: Thu, 15 Dec 2016 13:42:18 +0100 (CET)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a> - Dec. 15, 2016, 12:42 p.m.</div>
<pre class="content">
This patch has been reworked since RFC version. In the RFC, this patch
was preceded by a patch clearing MSR RI for all PPC32 at all time at
exception prologs. Now MSR RI clearing is done only when this 8xx perf
events functionality is compiled in, it is therefore limited to 8xx
and merged inside this patch.
Other main changes have been to take into account detailed review from
Peter Zijlstra. The instructions counter has been reworked to behave
as a free running counter like the three other counters.

The 8xx has no PMU, however some events can be emulated by other means.

This patch implements the following events (as reported by &#39;perf list&#39;):
  cpu-cycles OR cycles				[Hardware event]
  instructions					[Hardware event]
  dTLB-load-misses				[Hardware cache event]
  iTLB-load-misses				[Hardware cache event]

&#39;cycles&#39; event is implemented using the timebase clock. Timebase clock
corresponds to CPU clock divided by 16, so number of cycles is
approximatly 16 times the number of TB ticks

On the 8xx, TLB misses are handled by software. It is therefore
easy to count all TLB misses each time the TLB miss exception is
called.

&#39;instructions&#39; is calculated by using instruction watchpoint counter.
This patch sets counter A to count instructions at address greater
than 0, hence we count all instructions executed while MSR RI bit is
set. The counter is set to the maximum which is 0xffff. Every 65535
instructions, debug instruction breakpoint exception fires. The
exception handler increments a counter in memory which then
represent the upper part of the instruction counter. We therefore
end up with a 48 bits counter. In order to avoid unnecessary overhead
while no perf event is active, this counter is started when the first
event referring to this counter is added, and the counter is stopped
when the last event referring to it is deleted. In order to properly
support breakpoint exceptions, MSR RI bit has to be unset in exception
epilogs in order to avoid breakpoint exceptions during critical
sections during changes to SRR0 and SRR1 would be problematic.

All counters are handled as free running counters.
<span class="signed-off-by">
Signed-off-by: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;</span>
---
 arch/powerpc/include/asm/reg.h         |   2 +
 arch/powerpc/include/asm/reg_8xx.h     |   4 +
 arch/powerpc/kernel/entry_32.S         |  15 +++
 arch/powerpc/kernel/head_8xx.S         |  46 ++++++++-
 arch/powerpc/perf/8xx-pmu.c            | 173 +++++++++++++++++++++++++++++++++
 arch/powerpc/perf/Makefile             |   2 +
 arch/powerpc/platforms/Kconfig.cputype |   7 ++
 7 files changed, 248 insertions(+), 1 deletion(-)
 create mode 100644 arch/powerpc/perf/8xx-pmu.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a> - Dec. 15, 2016, 12:50 p.m.</div>
<pre class="content">
Note that this patch applies on top of the following patches:
- powerpc/32: Remove FIX_SRR1
- [2/2] powerpc/8xx: Implement hw_breakpoint

Christophe

Le 15/12/2016 à 13:42, Christophe Leroy a écrit :
<span class="quote">&gt; This patch has been reworked since RFC version. In the RFC, this patch</span>
<span class="quote">&gt; was preceded by a patch clearing MSR RI for all PPC32 at all time at</span>
<span class="quote">&gt; exception prologs. Now MSR RI clearing is done only when this 8xx perf</span>
<span class="quote">&gt; events functionality is compiled in, it is therefore limited to 8xx</span>
<span class="quote">&gt; and merged inside this patch.</span>
<span class="quote">&gt; Other main changes have been to take into account detailed review from</span>
<span class="quote">&gt; Peter Zijlstra. The instructions counter has been reworked to behave</span>
<span class="quote">&gt; as a free running counter like the three other counters.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The 8xx has no PMU, however some events can be emulated by other means.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This patch implements the following events (as reported by &#39;perf list&#39;):</span>
<span class="quote">&gt;   cpu-cycles OR cycles				[Hardware event]</span>
<span class="quote">&gt;   instructions					[Hardware event]</span>
<span class="quote">&gt;   dTLB-load-misses				[Hardware cache event]</span>
<span class="quote">&gt;   iTLB-load-misses				[Hardware cache event]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; &#39;cycles&#39; event is implemented using the timebase clock. Timebase clock</span>
<span class="quote">&gt; corresponds to CPU clock divided by 16, so number of cycles is</span>
<span class="quote">&gt; approximatly 16 times the number of TB ticks</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On the 8xx, TLB misses are handled by software. It is therefore</span>
<span class="quote">&gt; easy to count all TLB misses each time the TLB miss exception is</span>
<span class="quote">&gt; called.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; &#39;instructions&#39; is calculated by using instruction watchpoint counter.</span>
<span class="quote">&gt; This patch sets counter A to count instructions at address greater</span>
<span class="quote">&gt; than 0, hence we count all instructions executed while MSR RI bit is</span>
<span class="quote">&gt; set. The counter is set to the maximum which is 0xffff. Every 65535</span>
<span class="quote">&gt; instructions, debug instruction breakpoint exception fires. The</span>
<span class="quote">&gt; exception handler increments a counter in memory which then</span>
<span class="quote">&gt; represent the upper part of the instruction counter. We therefore</span>
<span class="quote">&gt; end up with a 48 bits counter. In order to avoid unnecessary overhead</span>
<span class="quote">&gt; while no perf event is active, this counter is started when the first</span>
<span class="quote">&gt; event referring to this counter is added, and the counter is stopped</span>
<span class="quote">&gt; when the last event referring to it is deleted. In order to properly</span>
<span class="quote">&gt; support breakpoint exceptions, MSR RI bit has to be unset in exception</span>
<span class="quote">&gt; epilogs in order to avoid breakpoint exceptions during critical</span>
<span class="quote">&gt; sections during changes to SRR0 and SRR1 would be problematic.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; All counters are handled as free running counters.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/powerpc/include/asm/reg.h         |   2 +</span>
<span class="quote">&gt;  arch/powerpc/include/asm/reg_8xx.h     |   4 +</span>
<span class="quote">&gt;  arch/powerpc/kernel/entry_32.S         |  15 +++</span>
<span class="quote">&gt;  arch/powerpc/kernel/head_8xx.S         |  46 ++++++++-</span>
<span class="quote">&gt;  arch/powerpc/perf/8xx-pmu.c            | 173 +++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/powerpc/perf/Makefile             |   2 +</span>
<span class="quote">&gt;  arch/powerpc/platforms/Kconfig.cputype |   7 ++</span>
<span class="quote">&gt;  7 files changed, 248 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt;  create mode 100644 arch/powerpc/perf/8xx-pmu.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="quote">&gt; index 0d4531a..9098b35 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/reg.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/reg.h</span>
<span class="quote">&gt; @@ -548,7 +548,9 @@</span>
<span class="quote">&gt;  #define SPRN_IBAT7U	0x236		/* Instruction BAT 7 Upper Register */</span>
<span class="quote">&gt;  #define SPRN_ICMP	0x3D5		/* Instruction TLB Compare Register */</span>
<span class="quote">&gt;  #define SPRN_ICTC	0x3FB	/* Instruction Cache Throttling Control Reg */</span>
<span class="quote">&gt; +#ifndef SPRN_ICTRL</span>
<span class="quote">&gt;  #define SPRN_ICTRL	0x3F3	/* 1011 7450 icache and interrupt ctrl */</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  #define ICTRL_EICE	0x08000000	/* enable icache parity errs */</span>
<span class="quote">&gt;  #define ICTRL_EDC	0x04000000	/* enable dcache parity errs */</span>
<span class="quote">&gt;  #define ICTRL_EICP	0x00000100	/* enable icache par. check */</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/reg_8xx.h b/arch/powerpc/include/asm/reg_8xx.h</span>
<span class="quote">&gt; index c52725b..ae16fef 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/reg_8xx.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/reg_8xx.h</span>
<span class="quote">&gt; @@ -28,12 +28,16 @@</span>
<span class="quote">&gt;  /* Special MSR manipulation registers */</span>
<span class="quote">&gt;  #define SPRN_EIE	80	/* External interrupt enable (EE=1, RI=1) */</span>
<span class="quote">&gt;  #define SPRN_EID	81	/* External interrupt disable (EE=0, RI=1) */</span>
<span class="quote">&gt; +#define SPRN_NRI	82	/* Non recoverable interrupt (EE=0, RI=0) */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  /* Debug registers */</span>
<span class="quote">&gt; +#define SPRN_CMPA	144</span>
<span class="quote">&gt; +#define SPRN_COUNTA	150</span>
<span class="quote">&gt;  #define SPRN_CMPE	152</span>
<span class="quote">&gt;  #define SPRN_CMPF	153</span>
<span class="quote">&gt;  #define SPRN_LCTRL1	156</span>
<span class="quote">&gt;  #define SPRN_LCTRL2	157</span>
<span class="quote">&gt; +#define SPRN_ICTRL	158</span>
<span class="quote">&gt;  #define SPRN_BAR	159</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  /* Commands.  Only the first few are available to the instruction cache.</span>
<span class="quote">&gt; diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S</span>
<span class="quote">&gt; index 980626a..f3e4fc1 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kernel/entry_32.S</span>
<span class="quote">&gt; +++ b/arch/powerpc/kernel/entry_32.S</span>
<span class="quote">&gt; @@ -205,6 +205,9 @@ transfer_to_handler_cont:</span>
<span class="quote">&gt;  	mflr	r9</span>
<span class="quote">&gt;  	lwz	r11,0(r9)		/* virtual address of handler */</span>
<span class="quote">&gt;  	lwz	r9,4(r9)		/* where to go when done */</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	mtspr	SPRN_NRI, r0</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  #ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="quote">&gt;  	lis	r12,reenable_mmu@h</span>
<span class="quote">&gt;  	ori	r12,r12,reenable_mmu@l</span>
<span class="quote">&gt; @@ -292,6 +295,9 @@ stack_ovf:</span>
<span class="quote">&gt;  	lis	r9,StackOverflow@ha</span>
<span class="quote">&gt;  	addi	r9,r9,StackOverflow@l</span>
<span class="quote">&gt;  	LOAD_MSR_KERNEL(r10,MSR_KERNEL)</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	mtspr	SPRN_NRI, r0</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR0,r9</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR1,r10</span>
<span class="quote">&gt;  	SYNC</span>
<span class="quote">&gt; @@ -418,6 +424,9 @@ END_FTR_SECTION_IFSET(CPU_FTR_NEED_PAIRED_STWCX)</span>
<span class="quote">&gt;  	lwz	r7,_NIP(r1)</span>
<span class="quote">&gt;  	lwz	r2,GPR2(r1)</span>
<span class="quote">&gt;  	lwz	r1,GPR1(r1)</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	mtspr	SPRN_NRI, r0</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR0,r7</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR1,r8</span>
<span class="quote">&gt;  	SYNC</span>
<span class="quote">&gt; @@ -701,6 +710,9 @@ fast_exception_return:</span>
<span class="quote">&gt;  	lwz	r10,_LINK(r11)</span>
<span class="quote">&gt;  	mtlr	r10</span>
<span class="quote">&gt;  	REST_GPR(10, r11)</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	mtspr	SPRN_NRI, r0</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR1,r9</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR0,r12</span>
<span class="quote">&gt;  	REST_GPR(9, r11)</span>
<span class="quote">&gt; @@ -949,6 +961,9 @@ END_FTR_SECTION_IFSET(CPU_FTR_NEED_PAIRED_STWCX)</span>
<span class="quote">&gt;  	.globl exc_exit_restart</span>
<span class="quote">&gt;  exc_exit_restart:</span>
<span class="quote">&gt;  	lwz	r12,_NIP(r1)</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	mtspr	SPRN_NRI, r0</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR0,r12</span>
<span class="quote">&gt;  	mtspr	SPRN_SRR1,r9</span>
<span class="quote">&gt;  	REST_4GPRS(9, r1)</span>
<span class="quote">&gt; diff --git a/arch/powerpc/kernel/head_8xx.S b/arch/powerpc/kernel/head_8xx.S</span>
<span class="quote">&gt; index 5fcbd79..c032fe8c 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kernel/head_8xx.S</span>
<span class="quote">&gt; +++ b/arch/powerpc/kernel/head_8xx.S</span>
<span class="quote">&gt; @@ -329,6 +329,12 @@ InstructionTLBMiss:</span>
<span class="quote">&gt;  	mtspr	SPRN_SPRG_SCRATCH2, r3</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  	EXCEPTION_PROLOG_0</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	lis	r10, (itlb_miss_counter - PAGE_OFFSET)@ha</span>
<span class="quote">&gt; +	lwz	r11, (itlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="quote">&gt; +	addi	r11, r11, 1</span>
<span class="quote">&gt; +	stw	r11, (itlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	/* If we are faulting a kernel address, we have to use the</span>
<span class="quote">&gt;  	 * kernel page tables.</span>
<span class="quote">&gt; @@ -429,6 +435,12 @@ InstructionTLBMiss:</span>
<span class="quote">&gt;  DataStoreTLBMiss:</span>
<span class="quote">&gt;  	mtspr	SPRN_SPRG_SCRATCH2, r3</span>
<span class="quote">&gt;  	EXCEPTION_PROLOG_0</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	lis	r10, (dtlb_miss_counter - PAGE_OFFSET)@ha</span>
<span class="quote">&gt; +	lwz	r11, (dtlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="quote">&gt; +	addi	r11, r11, 1</span>
<span class="quote">&gt; +	stw	r11, (dtlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	mfcr	r3</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  	/* If we are faulting a kernel address, we have to use the</span>
<span class="quote">&gt; @@ -625,7 +637,22 @@ DataBreakpoint:</span>
<span class="quote">&gt;  	EXCEPTION_EPILOG_0</span>
<span class="quote">&gt;  	rfi</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	. = 0x1d00</span>
<span class="quote">&gt; +InstructionBreakpoint:</span>
<span class="quote">&gt; +	EXCEPTION_PROLOG_0</span>
<span class="quote">&gt; +	lis	r10, (instruction_counter - PAGE_OFFSET)@ha</span>
<span class="quote">&gt; +	lwz	r11, (instruction_counter - PAGE_OFFSET)@l(r10)</span>
<span class="quote">&gt; +	addi	r11, r11, -1</span>
<span class="quote">&gt; +	stw	r11, (instruction_counter - PAGE_OFFSET)@l(r10)</span>
<span class="quote">&gt; +	lis	r10, 0xffff</span>
<span class="quote">&gt; +	ori	r10, r10, 0x01</span>
<span class="quote">&gt; +	mtspr	SPRN_COUNTA, r10</span>
<span class="quote">&gt; +	EXCEPTION_EPILOG_0</span>
<span class="quote">&gt; +	rfi</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt;  	EXCEPTION(0x1d00, Trap_1d, unknown_exception, EXC_XFER_EE)</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	EXCEPTION(0x1e00, Trap_1e, unknown_exception, EXC_XFER_EE)</span>
<span class="quote">&gt;  	EXCEPTION(0x1f00, Trap_1f, unknown_exception, EXC_XFER_EE)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -999,9 +1026,13 @@ initial_mmu:</span>
<span class="quote">&gt;  	lis	r8, IDC_ENABLE@h</span>
<span class="quote">&gt;  	mtspr	SPRN_DC_CST, r8</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt; -	/* Disable debug mode entry on data breakpoints */</span>
<span class="quote">&gt; +	/* Disable debug mode entry on breakpoints */</span>
<span class="quote">&gt;  	mfspr	r8, SPRN_DER</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	rlwinm	r8, r8, 0, ~0xc</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt;  	rlwinm	r8, r8, 0, ~0x8</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  	mtspr	SPRN_DER, r8</span>
<span class="quote">&gt;  	blr</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -1036,3 +1067,16 @@ cpu6_errata_word:</span>
<span class="quote">&gt;  	.space	16</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	.globl	itlb_miss_counter</span>
<span class="quote">&gt; +itlb_miss_counter:</span>
<span class="quote">&gt; +	.space	4</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.globl	dtlb_miss_counter</span>
<span class="quote">&gt; +dtlb_miss_counter:</span>
<span class="quote">&gt; +	.space	4</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.globl	instruction_counter</span>
<span class="quote">&gt; +instruction_counter:</span>
<span class="quote">&gt; +	.space	4</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; diff --git a/arch/powerpc/perf/8xx-pmu.c b/arch/powerpc/perf/8xx-pmu.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..3c39f05</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/powerpc/perf/8xx-pmu.c</span>
<span class="quote">&gt; @@ -0,0 +1,173 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Performance event support - PPC 8xx</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright 2016 Christophe Leroy, CS Systemes d&#39;Information</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + * modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + * as published by the Free Software Foundation; either version</span>
<span class="quote">&gt; + * 2 of the License, or (at your option) any later version.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/sched.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/perf_event.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/percpu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/hardirq.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/pmc.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/machdep.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/firmware.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/ptrace.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PERF_8xx_ID_CPU_CYCLES		1</span>
<span class="quote">&gt; +#define PERF_8xx_ID_HW_INSTRUCTIONS	2</span>
<span class="quote">&gt; +#define PERF_8xx_ID_ITLB_LOAD_MISS	3</span>
<span class="quote">&gt; +#define PERF_8xx_ID_DTLB_LOAD_MISS	4</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define C(x)	PERF_COUNT_HW_CACHE_##x</span>
<span class="quote">&gt; +#define DTLB_LOAD_MISS	(C(DTLB) | (C(OP_READ) &lt;&lt; 8) | (C(RESULT_MISS) &lt;&lt; 16))</span>
<span class="quote">&gt; +#define ITLB_LOAD_MISS	(C(ITLB) | (C(OP_READ) &lt;&lt; 8) | (C(RESULT_MISS) &lt;&lt; 16))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern unsigned long itlb_miss_counter, dtlb_miss_counter;</span>
<span class="quote">&gt; +extern atomic_t instruction_counter;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static atomic_t insn_ctr_ref;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static s64 get_insn_ctr(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int ctr;</span>
<span class="quote">&gt; +	unsigned long counta;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	do {</span>
<span class="quote">&gt; +		ctr = atomic_read(&amp;instruction_counter);</span>
<span class="quote">&gt; +		counta = mfspr(SPRN_COUNTA);</span>
<span class="quote">&gt; +	} while (ctr != atomic_read(&amp;instruction_counter));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ((s64)ctr &lt;&lt; 16) | (counta &gt;&gt; 16);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int event_type(struct perf_event *event)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	switch (event-&gt;attr.type) {</span>
<span class="quote">&gt; +	case PERF_TYPE_HARDWARE:</span>
<span class="quote">&gt; +		if (event-&gt;attr.config == PERF_COUNT_HW_CPU_CYCLES)</span>
<span class="quote">&gt; +			return PERF_8xx_ID_CPU_CYCLES;</span>
<span class="quote">&gt; +		if (event-&gt;attr.config == PERF_COUNT_HW_INSTRUCTIONS)</span>
<span class="quote">&gt; +			return PERF_8xx_ID_HW_INSTRUCTIONS;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case PERF_TYPE_HW_CACHE:</span>
<span class="quote">&gt; +		if (event-&gt;attr.config == ITLB_LOAD_MISS)</span>
<span class="quote">&gt; +			return PERF_8xx_ID_ITLB_LOAD_MISS;</span>
<span class="quote">&gt; +		if (event-&gt;attr.config == DTLB_LOAD_MISS)</span>
<span class="quote">&gt; +			return PERF_8xx_ID_DTLB_LOAD_MISS;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case PERF_TYPE_RAW:</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	default:</span>
<span class="quote">&gt; +		return -ENOENT;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return -EOPNOTSUPP;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mpc8xx_pmu_event_init(struct perf_event *event)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int type = event_type(event);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (type &lt; 0)</span>
<span class="quote">&gt; +		return type;</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mpc8xx_pmu_add(struct perf_event *event, int flags)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int type = event_type(event);</span>
<span class="quote">&gt; +	s64 val = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (type &lt; 0)</span>
<span class="quote">&gt; +		return type;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	switch (type) {</span>
<span class="quote">&gt; +	case PERF_8xx_ID_CPU_CYCLES:</span>
<span class="quote">&gt; +		val = get_tb();</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case PERF_8xx_ID_HW_INSTRUCTIONS:</span>
<span class="quote">&gt; +		if (atomic_inc_return(&amp;insn_ctr_ref) == 1)</span>
<span class="quote">&gt; +			mtspr(SPRN_ICTRL, 0xc0080007);</span>
<span class="quote">&gt; +		val = get_insn_ctr();</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case PERF_8xx_ID_ITLB_LOAD_MISS:</span>
<span class="quote">&gt; +		val = itlb_miss_counter;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case PERF_8xx_ID_DTLB_LOAD_MISS:</span>
<span class="quote">&gt; +		val = dtlb_miss_counter;</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	local64_set(&amp;event-&gt;hw.prev_count, val);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mpc8xx_pmu_read(struct perf_event *event)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int type = event_type(event);</span>
<span class="quote">&gt; +	s64 prev, val = 0, delta = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (type &lt; 0)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	do {</span>
<span class="quote">&gt; +		prev = local64_read(&amp;event-&gt;hw.prev_count);</span>
<span class="quote">&gt; +		switch (type) {</span>
<span class="quote">&gt; +		case PERF_8xx_ID_CPU_CYCLES:</span>
<span class="quote">&gt; +			val = get_tb();</span>
<span class="quote">&gt; +			delta = 16 * (val - prev);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		case PERF_8xx_ID_HW_INSTRUCTIONS:</span>
<span class="quote">&gt; +			val = get_insn_ctr();</span>
<span class="quote">&gt; +			delta = prev - val;</span>
<span class="quote">&gt; +			if (delta &lt; 0)</span>
<span class="quote">&gt; +				delta += 0x1000000000000LL;</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		case PERF_8xx_ID_ITLB_LOAD_MISS:</span>
<span class="quote">&gt; +			val = itlb_miss_counter;</span>
<span class="quote">&gt; +			delta = (s64)((s32)val - (s32)prev);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		case PERF_8xx_ID_DTLB_LOAD_MISS:</span>
<span class="quote">&gt; +			val = dtlb_miss_counter;</span>
<span class="quote">&gt; +			delta = (s64)((s32)val - (s32)prev);</span>
<span class="quote">&gt; +			break;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	} while (local64_cmpxchg(&amp;event-&gt;hw.prev_count, prev, val) != prev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	local64_add(delta, &amp;event-&gt;count);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mpc8xx_pmu_del(struct perf_event *event, int flags)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	mpc8xx_pmu_read(event);</span>
<span class="quote">&gt; +	if (event_type(event) != PERF_8xx_ID_HW_INSTRUCTIONS)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* If it was the last user, stop counting to avoid useles overhead */</span>
<span class="quote">&gt; +	if (atomic_dec_return(&amp;insn_ctr_ref) == 0)</span>
<span class="quote">&gt; +		mtspr(SPRN_ICTRL, 7);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct pmu mpc8xx_pmu = {</span>
<span class="quote">&gt; +	.event_init	= mpc8xx_pmu_event_init,</span>
<span class="quote">&gt; +	.add		= mpc8xx_pmu_add,</span>
<span class="quote">&gt; +	.del		= mpc8xx_pmu_del,</span>
<span class="quote">&gt; +	.read		= mpc8xx_pmu_read,</span>
<span class="quote">&gt; +	.capabilities	= PERF_PMU_CAP_NO_INTERRUPT |</span>
<span class="quote">&gt; +			  PERF_PMU_CAP_NO_NMI,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int init_mpc8xx_pmu(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	mtspr(SPRN_ICTRL, 7);</span>
<span class="quote">&gt; +	mtspr(SPRN_CMPA, 0);</span>
<span class="quote">&gt; +	mtspr(SPRN_COUNTA, 0xffff);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return perf_pmu_register(&amp;mpc8xx_pmu, &quot;cpu&quot;, PERF_TYPE_RAW);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +early_initcall(init_mpc8xx_pmu);</span>
<span class="quote">&gt; diff --git a/arch/powerpc/perf/Makefile b/arch/powerpc/perf/Makefile</span>
<span class="quote">&gt; index f102d53..4d606b9 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/perf/Makefile</span>
<span class="quote">&gt; +++ b/arch/powerpc/perf/Makefile</span>
<span class="quote">&gt; @@ -13,5 +13,7 @@ obj-$(CONFIG_FSL_EMB_PERF_EVENT_E500) += e500-pmu.o e6500-pmu.o</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  obj-$(CONFIG_HV_PERF_CTRS) += hv-24x7.o hv-gpci.o hv-common.o</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +obj-$(CONFIG_PPC_8xx_PERF_EVENT) += 8xx-pmu.o</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  obj-$(CONFIG_PPC64)		+= $(obj64-y)</span>
<span class="quote">&gt;  obj-$(CONFIG_PPC32)		+= $(obj32-y)</span>
<span class="quote">&gt; diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype</span>
<span class="quote">&gt; index 6e89e5a..99b0ae8 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/platforms/Kconfig.cputype</span>
<span class="quote">&gt; +++ b/arch/powerpc/platforms/Kconfig.cputype</span>
<span class="quote">&gt; @@ -172,6 +172,13 @@ config PPC_FPU</span>
<span class="quote">&gt;  	bool</span>
<span class="quote">&gt;  	default y if PPC64</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +config PPC_8xx_PERF_EVENT</span>
<span class="quote">&gt; +	bool &quot;PPC 8xx perf events&quot;</span>
<span class="quote">&gt; +	depends on PPC_8xx &amp;&amp; PERF_EVENTS</span>
<span class="quote">&gt; +	help</span>
<span class="quote">&gt; +	  This is Performance Events support for PPC 8xx. The 8xx doesn&#39;t</span>
<span class="quote">&gt; +	  have a PMU but some events are emulated using 8xx features.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  config FSL_EMB_PERFMON</span>
<span class="quote">&gt;  	bool &quot;Freescale Embedded Perfmon&quot;</span>
<span class="quote">&gt;  	depends on E500 || PPC_83xx</span>
<span class="quote">&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index 0d4531a..9098b35 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -548,7 +548,9 @@</span> <span class="p_context"></span>
 #define SPRN_IBAT7U	0x236		/* Instruction BAT 7 Upper Register */
 #define SPRN_ICMP	0x3D5		/* Instruction TLB Compare Register */
 #define SPRN_ICTC	0x3FB	/* Instruction Cache Throttling Control Reg */
<span class="p_add">+#ifndef SPRN_ICTRL</span>
 #define SPRN_ICTRL	0x3F3	/* 1011 7450 icache and interrupt ctrl */
<span class="p_add">+#endif</span>
 #define ICTRL_EICE	0x08000000	/* enable icache parity errs */
 #define ICTRL_EDC	0x04000000	/* enable dcache parity errs */
 #define ICTRL_EICP	0x00000100	/* enable icache par. check */
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg_8xx.h b/arch/powerpc/include/asm/reg_8xx.h</span>
<span class="p_header">index c52725b..ae16fef 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg_8xx.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg_8xx.h</span>
<span class="p_chunk">@@ -28,12 +28,16 @@</span> <span class="p_context"></span>
 /* Special MSR manipulation registers */
 #define SPRN_EIE	80	/* External interrupt enable (EE=1, RI=1) */
 #define SPRN_EID	81	/* External interrupt disable (EE=0, RI=1) */
<span class="p_add">+#define SPRN_NRI	82	/* Non recoverable interrupt (EE=0, RI=0) */</span>
 
 /* Debug registers */
<span class="p_add">+#define SPRN_CMPA	144</span>
<span class="p_add">+#define SPRN_COUNTA	150</span>
 #define SPRN_CMPE	152
 #define SPRN_CMPF	153
 #define SPRN_LCTRL1	156
 #define SPRN_LCTRL2	157
<span class="p_add">+#define SPRN_ICTRL	158</span>
 #define SPRN_BAR	159
 
 /* Commands.  Only the first few are available to the instruction cache.
<span class="p_header">diff --git a/arch/powerpc/kernel/entry_32.S b/arch/powerpc/kernel/entry_32.S</span>
<span class="p_header">index 980626a..f3e4fc1 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/entry_32.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/entry_32.S</span>
<span class="p_chunk">@@ -205,6 +205,9 @@</span> <span class="p_context"> transfer_to_handler_cont:</span>
 	mflr	r9
 	lwz	r11,0(r9)		/* virtual address of handler */
 	lwz	r9,4(r9)		/* where to go when done */
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	mtspr	SPRN_NRI, r0</span>
<span class="p_add">+#endif</span>
 #ifdef CONFIG_TRACE_IRQFLAGS
 	lis	r12,reenable_mmu@h
 	ori	r12,r12,reenable_mmu@l
<span class="p_chunk">@@ -292,6 +295,9 @@</span> <span class="p_context"> stack_ovf:</span>
 	lis	r9,StackOverflow@ha
 	addi	r9,r9,StackOverflow@l
 	LOAD_MSR_KERNEL(r10,MSR_KERNEL)
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	mtspr	SPRN_NRI, r0</span>
<span class="p_add">+#endif</span>
 	mtspr	SPRN_SRR0,r9
 	mtspr	SPRN_SRR1,r10
 	SYNC
<span class="p_chunk">@@ -418,6 +424,9 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_NEED_PAIRED_STWCX)</span>
 	lwz	r7,_NIP(r1)
 	lwz	r2,GPR2(r1)
 	lwz	r1,GPR1(r1)
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	mtspr	SPRN_NRI, r0</span>
<span class="p_add">+#endif</span>
 	mtspr	SPRN_SRR0,r7
 	mtspr	SPRN_SRR1,r8
 	SYNC
<span class="p_chunk">@@ -701,6 +710,9 @@</span> <span class="p_context"> fast_exception_return:</span>
 	lwz	r10,_LINK(r11)
 	mtlr	r10
 	REST_GPR(10, r11)
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	mtspr	SPRN_NRI, r0</span>
<span class="p_add">+#endif</span>
 	mtspr	SPRN_SRR1,r9
 	mtspr	SPRN_SRR0,r12
 	REST_GPR(9, r11)
<span class="p_chunk">@@ -949,6 +961,9 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_NEED_PAIRED_STWCX)</span>
 	.globl exc_exit_restart
 exc_exit_restart:
 	lwz	r12,_NIP(r1)
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	mtspr	SPRN_NRI, r0</span>
<span class="p_add">+#endif</span>
 	mtspr	SPRN_SRR0,r12
 	mtspr	SPRN_SRR1,r9
 	REST_4GPRS(9, r1)
<span class="p_header">diff --git a/arch/powerpc/kernel/head_8xx.S b/arch/powerpc/kernel/head_8xx.S</span>
<span class="p_header">index 5fcbd79..c032fe8c 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/head_8xx.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/head_8xx.S</span>
<span class="p_chunk">@@ -329,6 +329,12 @@</span> <span class="p_context"> InstructionTLBMiss:</span>
 	mtspr	SPRN_SPRG_SCRATCH2, r3
 #endif
 	EXCEPTION_PROLOG_0
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	lis	r10, (itlb_miss_counter - PAGE_OFFSET)@ha</span>
<span class="p_add">+	lwz	r11, (itlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="p_add">+	addi	r11, r11, 1</span>
<span class="p_add">+	stw	r11, (itlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="p_add">+#endif</span>
 
 	/* If we are faulting a kernel address, we have to use the
 	 * kernel page tables.
<span class="p_chunk">@@ -429,6 +435,12 @@</span> <span class="p_context"> InstructionTLBMiss:</span>
 DataStoreTLBMiss:
 	mtspr	SPRN_SPRG_SCRATCH2, r3
 	EXCEPTION_PROLOG_0
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	lis	r10, (dtlb_miss_counter - PAGE_OFFSET)@ha</span>
<span class="p_add">+	lwz	r11, (dtlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="p_add">+	addi	r11, r11, 1</span>
<span class="p_add">+	stw	r11, (dtlb_miss_counter - PAGE_OFFSET)@l(r10)</span>
<span class="p_add">+#endif</span>
 	mfcr	r3
 
 	/* If we are faulting a kernel address, we have to use the
<span class="p_chunk">@@ -625,7 +637,22 @@</span> <span class="p_context"> DataBreakpoint:</span>
 	EXCEPTION_EPILOG_0
 	rfi
 
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	. = 0x1d00</span>
<span class="p_add">+InstructionBreakpoint:</span>
<span class="p_add">+	EXCEPTION_PROLOG_0</span>
<span class="p_add">+	lis	r10, (instruction_counter - PAGE_OFFSET)@ha</span>
<span class="p_add">+	lwz	r11, (instruction_counter - PAGE_OFFSET)@l(r10)</span>
<span class="p_add">+	addi	r11, r11, -1</span>
<span class="p_add">+	stw	r11, (instruction_counter - PAGE_OFFSET)@l(r10)</span>
<span class="p_add">+	lis	r10, 0xffff</span>
<span class="p_add">+	ori	r10, r10, 0x01</span>
<span class="p_add">+	mtspr	SPRN_COUNTA, r10</span>
<span class="p_add">+	EXCEPTION_EPILOG_0</span>
<span class="p_add">+	rfi</span>
<span class="p_add">+#else</span>
 	EXCEPTION(0x1d00, Trap_1d, unknown_exception, EXC_XFER_EE)
<span class="p_add">+#endif</span>
 	EXCEPTION(0x1e00, Trap_1e, unknown_exception, EXC_XFER_EE)
 	EXCEPTION(0x1f00, Trap_1f, unknown_exception, EXC_XFER_EE)
 
<span class="p_chunk">@@ -999,9 +1026,13 @@</span> <span class="p_context"> initial_mmu:</span>
 	lis	r8, IDC_ENABLE@h
 	mtspr	SPRN_DC_CST, r8
 #endif
<span class="p_del">-	/* Disable debug mode entry on data breakpoints */</span>
<span class="p_add">+	/* Disable debug mode entry on breakpoints */</span>
 	mfspr	r8, SPRN_DER
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	rlwinm	r8, r8, 0, ~0xc</span>
<span class="p_add">+#else</span>
 	rlwinm	r8, r8, 0, ~0x8
<span class="p_add">+#endif</span>
 	mtspr	SPRN_DER, r8
 	blr
 
<span class="p_chunk">@@ -1036,3 +1067,16 @@</span> <span class="p_context"> cpu6_errata_word:</span>
 	.space	16
 #endif
 
<span class="p_add">+#ifdef CONFIG_PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	.globl	itlb_miss_counter</span>
<span class="p_add">+itlb_miss_counter:</span>
<span class="p_add">+	.space	4</span>
<span class="p_add">+</span>
<span class="p_add">+	.globl	dtlb_miss_counter</span>
<span class="p_add">+dtlb_miss_counter:</span>
<span class="p_add">+	.space	4</span>
<span class="p_add">+</span>
<span class="p_add">+	.globl	instruction_counter</span>
<span class="p_add">+instruction_counter:</span>
<span class="p_add">+	.space	4</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/powerpc/perf/8xx-pmu.c b/arch/powerpc/perf/8xx-pmu.c</span>
new file mode 100644
<span class="p_header">index 0000000..3c39f05</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/powerpc/perf/8xx-pmu.c</span>
<span class="p_chunk">@@ -0,0 +1,173 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Performance event support - PPC 8xx</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2016 Christophe Leroy, CS Systemes d&#39;Information</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ * as published by the Free Software Foundation; either version</span>
<span class="p_add">+ * 2 of the License, or (at your option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/perf_event.h&gt;</span>
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/hardirq.h&gt;</span>
<span class="p_add">+#include &lt;asm/pmc.h&gt;</span>
<span class="p_add">+#include &lt;asm/machdep.h&gt;</span>
<span class="p_add">+#include &lt;asm/firmware.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define PERF_8xx_ID_CPU_CYCLES		1</span>
<span class="p_add">+#define PERF_8xx_ID_HW_INSTRUCTIONS	2</span>
<span class="p_add">+#define PERF_8xx_ID_ITLB_LOAD_MISS	3</span>
<span class="p_add">+#define PERF_8xx_ID_DTLB_LOAD_MISS	4</span>
<span class="p_add">+</span>
<span class="p_add">+#define C(x)	PERF_COUNT_HW_CACHE_##x</span>
<span class="p_add">+#define DTLB_LOAD_MISS	(C(DTLB) | (C(OP_READ) &lt;&lt; 8) | (C(RESULT_MISS) &lt;&lt; 16))</span>
<span class="p_add">+#define ITLB_LOAD_MISS	(C(ITLB) | (C(OP_READ) &lt;&lt; 8) | (C(RESULT_MISS) &lt;&lt; 16))</span>
<span class="p_add">+</span>
<span class="p_add">+extern unsigned long itlb_miss_counter, dtlb_miss_counter;</span>
<span class="p_add">+extern atomic_t instruction_counter;</span>
<span class="p_add">+</span>
<span class="p_add">+static atomic_t insn_ctr_ref;</span>
<span class="p_add">+</span>
<span class="p_add">+static s64 get_insn_ctr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ctr;</span>
<span class="p_add">+	unsigned long counta;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		ctr = atomic_read(&amp;instruction_counter);</span>
<span class="p_add">+		counta = mfspr(SPRN_COUNTA);</span>
<span class="p_add">+	} while (ctr != atomic_read(&amp;instruction_counter));</span>
<span class="p_add">+</span>
<span class="p_add">+	return ((s64)ctr &lt;&lt; 16) | (counta &gt;&gt; 16);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int event_type(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (event-&gt;attr.type) {</span>
<span class="p_add">+	case PERF_TYPE_HARDWARE:</span>
<span class="p_add">+		if (event-&gt;attr.config == PERF_COUNT_HW_CPU_CYCLES)</span>
<span class="p_add">+			return PERF_8xx_ID_CPU_CYCLES;</span>
<span class="p_add">+		if (event-&gt;attr.config == PERF_COUNT_HW_INSTRUCTIONS)</span>
<span class="p_add">+			return PERF_8xx_ID_HW_INSTRUCTIONS;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PERF_TYPE_HW_CACHE:</span>
<span class="p_add">+		if (event-&gt;attr.config == ITLB_LOAD_MISS)</span>
<span class="p_add">+			return PERF_8xx_ID_ITLB_LOAD_MISS;</span>
<span class="p_add">+		if (event-&gt;attr.config == DTLB_LOAD_MISS)</span>
<span class="p_add">+			return PERF_8xx_ID_DTLB_LOAD_MISS;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PERF_TYPE_RAW:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mpc8xx_pmu_event_init(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int type = event_type(event);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type &lt; 0)</span>
<span class="p_add">+		return type;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mpc8xx_pmu_add(struct perf_event *event, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int type = event_type(event);</span>
<span class="p_add">+	s64 val = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type &lt; 0)</span>
<span class="p_add">+		return type;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (type) {</span>
<span class="p_add">+	case PERF_8xx_ID_CPU_CYCLES:</span>
<span class="p_add">+		val = get_tb();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PERF_8xx_ID_HW_INSTRUCTIONS:</span>
<span class="p_add">+		if (atomic_inc_return(&amp;insn_ctr_ref) == 1)</span>
<span class="p_add">+			mtspr(SPRN_ICTRL, 0xc0080007);</span>
<span class="p_add">+		val = get_insn_ctr();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PERF_8xx_ID_ITLB_LOAD_MISS:</span>
<span class="p_add">+		val = itlb_miss_counter;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PERF_8xx_ID_DTLB_LOAD_MISS:</span>
<span class="p_add">+		val = dtlb_miss_counter;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	local64_set(&amp;event-&gt;hw.prev_count, val);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mpc8xx_pmu_read(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int type = event_type(event);</span>
<span class="p_add">+	s64 prev, val = 0, delta = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		prev = local64_read(&amp;event-&gt;hw.prev_count);</span>
<span class="p_add">+		switch (type) {</span>
<span class="p_add">+		case PERF_8xx_ID_CPU_CYCLES:</span>
<span class="p_add">+			val = get_tb();</span>
<span class="p_add">+			delta = 16 * (val - prev);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case PERF_8xx_ID_HW_INSTRUCTIONS:</span>
<span class="p_add">+			val = get_insn_ctr();</span>
<span class="p_add">+			delta = prev - val;</span>
<span class="p_add">+			if (delta &lt; 0)</span>
<span class="p_add">+				delta += 0x1000000000000LL;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case PERF_8xx_ID_ITLB_LOAD_MISS:</span>
<span class="p_add">+			val = itlb_miss_counter;</span>
<span class="p_add">+			delta = (s64)((s32)val - (s32)prev);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case PERF_8xx_ID_DTLB_LOAD_MISS:</span>
<span class="p_add">+			val = dtlb_miss_counter;</span>
<span class="p_add">+			delta = (s64)((s32)val - (s32)prev);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (local64_cmpxchg(&amp;event-&gt;hw.prev_count, prev, val) != prev);</span>
<span class="p_add">+</span>
<span class="p_add">+	local64_add(delta, &amp;event-&gt;count);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mpc8xx_pmu_del(struct perf_event *event, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mpc8xx_pmu_read(event);</span>
<span class="p_add">+	if (event_type(event) != PERF_8xx_ID_HW_INSTRUCTIONS)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If it was the last user, stop counting to avoid useles overhead */</span>
<span class="p_add">+	if (atomic_dec_return(&amp;insn_ctr_ref) == 0)</span>
<span class="p_add">+		mtspr(SPRN_ICTRL, 7);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pmu mpc8xx_pmu = {</span>
<span class="p_add">+	.event_init	= mpc8xx_pmu_event_init,</span>
<span class="p_add">+	.add		= mpc8xx_pmu_add,</span>
<span class="p_add">+	.del		= mpc8xx_pmu_del,</span>
<span class="p_add">+	.read		= mpc8xx_pmu_read,</span>
<span class="p_add">+	.capabilities	= PERF_PMU_CAP_NO_INTERRUPT |</span>
<span class="p_add">+			  PERF_PMU_CAP_NO_NMI,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int init_mpc8xx_pmu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mtspr(SPRN_ICTRL, 7);</span>
<span class="p_add">+	mtspr(SPRN_CMPA, 0);</span>
<span class="p_add">+	mtspr(SPRN_COUNTA, 0xffff);</span>
<span class="p_add">+</span>
<span class="p_add">+	return perf_pmu_register(&amp;mpc8xx_pmu, &quot;cpu&quot;, PERF_TYPE_RAW);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+early_initcall(init_mpc8xx_pmu);</span>
<span class="p_header">diff --git a/arch/powerpc/perf/Makefile b/arch/powerpc/perf/Makefile</span>
<span class="p_header">index f102d53..4d606b9 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/perf/Makefile</span>
<span class="p_chunk">@@ -13,5 +13,7 @@</span> <span class="p_context"> obj-$(CONFIG_FSL_EMB_PERF_EVENT_E500) += e500-pmu.o e6500-pmu.o</span>
 
 obj-$(CONFIG_HV_PERF_CTRS) += hv-24x7.o hv-gpci.o hv-common.o
 
<span class="p_add">+obj-$(CONFIG_PPC_8xx_PERF_EVENT) += 8xx-pmu.o</span>
<span class="p_add">+</span>
 obj-$(CONFIG_PPC64)		+= $(obj64-y)
 obj-$(CONFIG_PPC32)		+= $(obj32-y)
<span class="p_header">diff --git a/arch/powerpc/platforms/Kconfig.cputype b/arch/powerpc/platforms/Kconfig.cputype</span>
<span class="p_header">index 6e89e5a..99b0ae8 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/Kconfig.cputype</span>
<span class="p_header">+++ b/arch/powerpc/platforms/Kconfig.cputype</span>
<span class="p_chunk">@@ -172,6 +172,13 @@</span> <span class="p_context"> config PPC_FPU</span>
 	bool
 	default y if PPC64
 
<span class="p_add">+config PPC_8xx_PERF_EVENT</span>
<span class="p_add">+	bool &quot;PPC 8xx perf events&quot;</span>
<span class="p_add">+	depends on PPC_8xx &amp;&amp; PERF_EVENTS</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This is Performance Events support for PPC 8xx. The 8xx doesn&#39;t</span>
<span class="p_add">+	  have a PMU but some events are emulated using 8xx features.</span>
<span class="p_add">+</span>
 config FSL_EMB_PERFMON
 	bool &quot;Freescale Embedded Perfmon&quot;
 	depends on E500 || PPC_83xx

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



