
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.1.17 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.1.17</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 31, 2016, 7:32 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160131193253.GB13497@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8174881/mbox/"
   >mbox</a>
|
   <a href="/patch/8174881/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8174881/">/patch/8174881/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 61C129F96D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 31 Jan 2016 19:33:30 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id EC9D0202F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 31 Jan 2016 19:33:21 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 0D21120256
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 31 Jan 2016 19:33:13 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933483AbcAaTdH (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 31 Jan 2016 14:33:07 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:60610 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S933272AbcAaTcy (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 31 Jan 2016 14:32:54 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 5E3DD117E;
	Sun, 31 Jan 2016 19:32:53 +0000 (UTC)
Date: Sun, 31 Jan 2016 11:32:53 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.1.17
Message-ID: &lt;20160131193253.GB13497@kroah.com&gt;
References: &lt;20160131193246.GA13497@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160131193246.GA13497@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 31, 2016, 7:32 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 7609f1dcdcb9..d398dd440bc9 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 1
<span class="p_del">-SUBLEVEL = 16</span>
<span class="p_add">+SUBLEVEL = 17</span>
 EXTRAVERSION =
 NAME = Series 4800
 
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 191dcfab9f60..da09ddcfcc00 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -98,6 +98,11 @@</span> <span class="p_context"> static void kvm_flush_dcache_pud(pud_t pud)</span>
 	__kvm_flush_dcache_pud(pud);
 }
 
<span class="p_add">+static bool kvm_is_device_pfn(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !pfn_valid(pfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * stage2_dissolve_pmd() - clear and flush huge PMD entry
  * @kvm:	pointer to kvm structure.
<span class="p_chunk">@@ -213,7 +218,7 @@</span> <span class="p_context"> static void unmap_ptes(struct kvm *kvm, pmd_t *pmd,</span>
 			kvm_tlb_flush_vmid_ipa(kvm, addr);
 
 			/* No need to invalidate the cache for device mappings */
<span class="p_del">-			if ((pte_val(old_pte) &amp; PAGE_S2_DEVICE) != PAGE_S2_DEVICE)</span>
<span class="p_add">+			if (!kvm_is_device_pfn(pte_pfn(old_pte)))</span>
 				kvm_flush_dcache_pte(old_pte);
 
 			put_page(virt_to_page(pte));
<span class="p_chunk">@@ -305,8 +310,7 @@</span> <span class="p_context"> static void stage2_flush_ptes(struct kvm *kvm, pmd_t *pmd,</span>
 
 	pte = pte_offset_kernel(pmd, addr);
 	do {
<span class="p_del">-		if (!pte_none(*pte) &amp;&amp;</span>
<span class="p_del">-		    (pte_val(*pte) &amp; PAGE_S2_DEVICE) != PAGE_S2_DEVICE)</span>
<span class="p_add">+		if (!pte_none(*pte) &amp;&amp; !kvm_is_device_pfn(pte_pfn(*pte)))</span>
 			kvm_flush_dcache_pte(*pte);
 	} while (pte++, addr += PAGE_SIZE, addr != end);
 }
<span class="p_chunk">@@ -1037,11 +1041,6 @@</span> <span class="p_context"> static bool kvm_is_write_fault(struct kvm_vcpu *vcpu)</span>
 	return kvm_vcpu_dabt_iswrite(vcpu);
 }
 
<span class="p_del">-static bool kvm_is_device_pfn(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return !pfn_valid(pfn);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * stage2_wp_ptes - write protect PMD range
  * @pmd:	pointer to pmd entry
<span class="p_header">diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">index e0e23582c8b4..5fe949b084ac 100644</span>
<span class="p_header">--- a/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">+++ b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_chunk">@@ -162,19 +162,6 @@</span> <span class="p_context"> static inline int mem_words_used(struct jit_ctx *ctx)</span>
 	return fls(ctx-&gt;seen &amp; SEEN_MEM);
 }
 
<span class="p_del">-static inline bool is_load_to_a(u16 inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (inst) {</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void jit_fill_hole(void *area, unsigned int size)
 {
 	u32 *ptr;
<span class="p_chunk">@@ -186,7 +173,6 @@</span> <span class="p_context"> static void jit_fill_hole(void *area, unsigned int size)</span>
 static void build_prologue(struct jit_ctx *ctx)
 {
 	u16 reg_set = saved_regs(ctx);
<span class="p_del">-	u16 first_inst = ctx-&gt;skf-&gt;insns[0].code;</span>
 	u16 off;
 
 #ifdef CONFIG_FRAME_POINTER
<span class="p_chunk">@@ -216,7 +202,7 @@</span> <span class="p_context"> static void build_prologue(struct jit_ctx *ctx)</span>
 		emit(ARM_MOV_I(r_X, 0), ctx);
 
 	/* do not leak kernel data to userspace */
<span class="p_del">-	if ((first_inst != (BPF_RET | BPF_K)) &amp;&amp; !(is_load_to_a(first_inst)))</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;ctx-&gt;skf-&gt;insns[0]))</span>
 		emit(ARM_MOV_I(r_A, 0), ctx);
 
 	/* stack space for the BPF_MEM words */
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index 17e92f05b1fe..3ca894ecf699 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -99,11 +99,13 @@</span> <span class="p_context"> static inline void vcpu_set_thumb(struct kvm_vcpu *vcpu)</span>
 	*vcpu_cpsr(vcpu) |= COMPAT_PSR_T_BIT;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * vcpu_reg should always be passed a register number coming from a</span>
<span class="p_add">+ * read of ESR_EL2. Otherwise, it may give the wrong result on AArch32</span>
<span class="p_add">+ * with banked registers.</span>
<span class="p_add">+ */</span>
 static inline unsigned long *vcpu_reg(const struct kvm_vcpu *vcpu, u8 reg_num)
 {
<span class="p_del">-	if (vcpu_mode_is_32bit(vcpu))</span>
<span class="p_del">-		return vcpu_reg32(vcpu, reg_num);</span>
<span class="p_del">-</span>
 	return (unsigned long *)&amp;vcpu_gp_regs(vcpu)-&gt;regs.regs[reg_num];
 }
 
<span class="p_header">diff --git a/arch/arm64/kernel/ptrace.c b/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">index d882b833dbdb..608ac6aa497b 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/ptrace.c</span>
<span class="p_chunk">@@ -58,6 +58,12 @@</span> <span class="p_context"></span>
  */
 void ptrace_disable(struct task_struct *child)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This would be better off in core code, but PTRACE_DETACH has</span>
<span class="p_add">+	 * grown its fair share of arch-specific worts and changing it</span>
<span class="p_add">+	 * is likely to cause regressions on obscure architectures.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	user_disable_single_step(child);</span>
 }
 
 #ifdef CONFIG_HAVE_HW_BREAKPOINT
<span class="p_header">diff --git a/arch/arm64/kernel/setup.c b/arch/arm64/kernel/setup.c</span>
<span class="p_header">index 74753132c3ac..bbdb53b87e13 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/setup.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/setup.c</span>
<span class="p_chunk">@@ -523,6 +523,10 @@</span> <span class="p_context"> static int c_show(struct seq_file *m, void *v)</span>
 		seq_printf(m, &quot;processor\t: %d\n&quot;, i);
 #endif
 
<span class="p_add">+		seq_printf(m, &quot;BogoMIPS\t: %lu.%02lu\n&quot;,</span>
<span class="p_add">+			   loops_per_jiffy / (500000UL/HZ),</span>
<span class="p_add">+			   loops_per_jiffy / (5000UL/HZ) % 100);</span>
<span class="p_add">+</span>
 		/*
 		 * Dump out the common processor features in a single line.
 		 * Userspace should read the hwcaps with getauxval(AT_HWCAP)
<span class="p_header">diff --git a/arch/arm64/kernel/suspend.c b/arch/arm64/kernel/suspend.c</span>
<span class="p_header">index 53f1f8dccf6c..357418137db7 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/suspend.c</span>
<span class="p_chunk">@@ -1,3 +1,4 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;linux/ftrace.h&gt;</span>
 #include &lt;linux/percpu.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;asm/cacheflush.h&gt;
<span class="p_chunk">@@ -71,6 +72,13 @@</span> <span class="p_context"> int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 	local_dbg_save(flags);
 
 	/*
<span class="p_add">+	 * Function graph tracer state gets incosistent when the kernel</span>
<span class="p_add">+	 * calls functions that never return (aka suspend finishers) hence</span>
<span class="p_add">+	 * disable graph tracing during their execution.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pause_graph_tracing();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * mm context saved on the stack, it will be restored when
 	 * the cpu comes out of reset through the identity mapped
 	 * page tables, so that the thread address space is properly
<span class="p_chunk">@@ -111,6 +119,8 @@</span> <span class="p_context"> int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 			hw_breakpoint_restore(NULL);
 	}
 
<span class="p_add">+	unpause_graph_tracing();</span>
<span class="p_add">+</span>
 	/*
 	 * Restore pstate flags. OS lock and mdscr have been already
 	 * restored, so from this point onwards, debugging is fully
<span class="p_header">diff --git a/arch/arm64/kvm/inject_fault.c b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">index 85c57158dcd9..648112e90ed5 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/inject_fault.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/inject_fault.c</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static void prepare_fault32(struct kvm_vcpu *vcpu, u32 mode, u32 vect_offset)</span>
 
 	/* Note: These now point to the banked copies */
 	*vcpu_spsr(vcpu) = new_spsr_value;
<span class="p_del">-	*vcpu_reg(vcpu, 14) = *vcpu_pc(vcpu) + return_offset;</span>
<span class="p_add">+	*vcpu_reg32(vcpu, 14) = *vcpu_pc(vcpu) + return_offset;</span>
 
 	/* Branch to exception vector */
 	if (sctlr &amp; (1 &lt;&lt; 13))
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index 5b8b664422d3..cb34eb8bbb9d 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -450,6 +450,9 @@</span> <span class="p_context"> void __init paging_init(void)</span>
 
 	empty_zero_page = virt_to_page(zero_page);
 
<span class="p_add">+	/* Ensure the zero page is visible to the page table walker */</span>
<span class="p_add">+	dsb(ishst);</span>
<span class="p_add">+</span>
 	/*
 	 * TTBR0 is only used for the identity mapping at this stage. Make it
 	 * point to zero page to avoid speculatively fetching new entries.
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit.h b/arch/arm64/net/bpf_jit.h</span>
<span class="p_header">index 98a26ce82d26..aee5637ea436 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit.h</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit.h</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 /*
  * BPF JIT compiler for ARM64
  *
<span class="p_del">- * Copyright (C) 2014 Zi Shen Lim &lt;zlim.lnx@gmail.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2014-2015 Zi Shen Lim &lt;zlim.lnx@gmail.com&gt;</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 	aarch64_insn_gen_comp_branch_imm(0, offset, Rt, A64_VARIANT(sf), \
 		AARCH64_INSN_BRANCH_COMP_##type)
 #define A64_CBZ(sf, Rt, imm19) A64_COMP_BRANCH(sf, Rt, (imm19) &lt;&lt; 2, ZERO)
<span class="p_add">+#define A64_CBNZ(sf, Rt, imm19) A64_COMP_BRANCH(sf, Rt, (imm19) &lt;&lt; 2, NONZERO)</span>
 
 /* Conditional branch (immediate) */
 #define A64_COND_BRANCH(cond, offset) \
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit_comp.c b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">index c047598b09e0..6217f80702d2 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 /*
  * BPF JIT compiler for ARM64
  *
<span class="p_del">- * Copyright (C) 2014 Zi Shen Lim &lt;zlim.lnx@gmail.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2014-2015 Zi Shen Lim &lt;zlim.lnx@gmail.com&gt;</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
<span class="p_chunk">@@ -225,6 +225,17 @@</span> <span class="p_context"> static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)</span>
 	u8 jmp_cond;
 	s32 jmp_offset;
 
<span class="p_add">+#define check_imm(bits, imm) do {				\</span>
<span class="p_add">+	if ((((imm) &gt; 0) &amp;&amp; ((imm) &gt;&gt; (bits))) ||		\</span>
<span class="p_add">+	    (((imm) &lt; 0) &amp;&amp; (~(imm) &gt;&gt; (bits)))) {		\</span>
<span class="p_add">+		pr_info(&quot;[%2d] imm=%d(0x%x) out of range\n&quot;,	\</span>
<span class="p_add">+			i, imm, imm);				\</span>
<span class="p_add">+		return -EINVAL;					\</span>
<span class="p_add">+	}							\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#define check_imm19(imm) check_imm(19, imm)</span>
<span class="p_add">+#define check_imm26(imm) check_imm(26, imm)</span>
<span class="p_add">+</span>
 	switch (code) {
 	/* dst = src */
 	case BPF_ALU | BPF_MOV | BPF_X:
<span class="p_chunk">@@ -258,15 +269,33 @@</span> <span class="p_context"> static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)</span>
 		break;
 	case BPF_ALU | BPF_DIV | BPF_X:
 	case BPF_ALU64 | BPF_DIV | BPF_X:
<span class="p_del">-		emit(A64_UDIV(is64, dst, dst, src), ctx);</span>
<span class="p_del">-		break;</span>
 	case BPF_ALU | BPF_MOD | BPF_X:
 	case BPF_ALU64 | BPF_MOD | BPF_X:
<span class="p_del">-		ctx-&gt;tmp_used = 1;</span>
<span class="p_del">-		emit(A64_UDIV(is64, tmp, dst, src), ctx);</span>
<span class="p_del">-		emit(A64_MUL(is64, tmp, tmp, src), ctx);</span>
<span class="p_del">-		emit(A64_SUB(is64, dst, dst, tmp), ctx);</span>
<span class="p_add">+	{</span>
<span class="p_add">+		const u8 r0 = bpf2a64[BPF_REG_0];</span>
<span class="p_add">+</span>
<span class="p_add">+		/* if (src == 0) return 0 */</span>
<span class="p_add">+		jmp_offset = 3; /* skip ahead to else path */</span>
<span class="p_add">+		check_imm19(jmp_offset);</span>
<span class="p_add">+		emit(A64_CBNZ(is64, src, jmp_offset), ctx);</span>
<span class="p_add">+		emit(A64_MOVZ(1, r0, 0, 0), ctx);</span>
<span class="p_add">+		jmp_offset = epilogue_offset(ctx);</span>
<span class="p_add">+		check_imm26(jmp_offset);</span>
<span class="p_add">+		emit(A64_B(jmp_offset), ctx);</span>
<span class="p_add">+		/* else */</span>
<span class="p_add">+		switch (BPF_OP(code)) {</span>
<span class="p_add">+		case BPF_DIV:</span>
<span class="p_add">+			emit(A64_UDIV(is64, dst, dst, src), ctx);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BPF_MOD:</span>
<span class="p_add">+			ctx-&gt;tmp_used = 1;</span>
<span class="p_add">+			emit(A64_UDIV(is64, tmp, dst, src), ctx);</span>
<span class="p_add">+			emit(A64_MUL(is64, tmp, tmp, src), ctx);</span>
<span class="p_add">+			emit(A64_SUB(is64, dst, dst, tmp), ctx);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		break;
<span class="p_add">+	}</span>
 	case BPF_ALU | BPF_LSH | BPF_X:
 	case BPF_ALU64 | BPF_LSH | BPF_X:
 		emit(A64_LSLV(is64, dst, dst, src), ctx);
<span class="p_chunk">@@ -393,17 +422,6 @@</span> <span class="p_context"> emit_bswap_uxt:</span>
 		emit(A64_ASR(is64, dst, dst, imm), ctx);
 		break;
 
<span class="p_del">-#define check_imm(bits, imm) do {				\</span>
<span class="p_del">-	if ((((imm) &gt; 0) &amp;&amp; ((imm) &gt;&gt; (bits))) ||		\</span>
<span class="p_del">-	    (((imm) &lt; 0) &amp;&amp; (~(imm) &gt;&gt; (bits)))) {		\</span>
<span class="p_del">-		pr_info(&quot;[%2d] imm=%d(0x%x) out of range\n&quot;,	\</span>
<span class="p_del">-			i, imm, imm);				\</span>
<span class="p_del">-		return -EINVAL;					\</span>
<span class="p_del">-	}							\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-#define check_imm19(imm) check_imm(19, imm)</span>
<span class="p_del">-#define check_imm26(imm) check_imm(26, imm)</span>
<span class="p_del">-</span>
 	/* JUMP off */
 	case BPF_JMP | BPF_JA:
 		jmp_offset = bpf2a64_offset(i + off, i, ctx);
<span class="p_header">diff --git a/arch/mips/net/bpf_jit.c b/arch/mips/net/bpf_jit.c</span>
<span class="p_header">index e23fdf2a9c80..d6d27d51d131 100644</span>
<span class="p_header">--- a/arch/mips/net/bpf_jit.c</span>
<span class="p_header">+++ b/arch/mips/net/bpf_jit.c</span>
<span class="p_chunk">@@ -556,19 +556,6 @@</span> <span class="p_context"> static inline u16 align_sp(unsigned int num)</span>
 	return num;
 }
 
<span class="p_del">-static bool is_load_to_a(u16 inst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (inst) {</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void save_bpf_jit_regs(struct jit_ctx *ctx, unsigned offset)
 {
 	int i = 0, real_off = 0;
<span class="p_chunk">@@ -686,7 +673,6 @@</span> <span class="p_context"> static unsigned int get_stack_depth(struct jit_ctx *ctx)</span>
 
 static void build_prologue(struct jit_ctx *ctx)
 {
<span class="p_del">-	u16 first_inst = ctx-&gt;skf-&gt;insns[0].code;</span>
 	int sp_off;
 
 	/* Calculate the total offset for the stack pointer */
<span class="p_chunk">@@ -700,7 +686,7 @@</span> <span class="p_context"> static void build_prologue(struct jit_ctx *ctx)</span>
 		emit_jit_reg_move(r_X, r_zero, ctx);
 
 	/* Do not leak kernel data to userspace */
<span class="p_del">-	if ((first_inst != (BPF_RET | BPF_K)) &amp;&amp; !(is_load_to_a(first_inst)))</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;ctx-&gt;skf-&gt;insns[0]))</span>
 		emit_jit_reg_move(r_A, r_zero, ctx);
 }
 
<span class="p_header">diff --git a/arch/mn10300/Kconfig b/arch/mn10300/Kconfig</span>
<span class="p_header">index 4434b54e1d87..78ae5552fdb8 100644</span>
<span class="p_header">--- a/arch/mn10300/Kconfig</span>
<span class="p_header">+++ b/arch/mn10300/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 config MN10300
 	def_bool y
 	select HAVE_OPROFILE
<span class="p_add">+	select HAVE_UID16</span>
 	select GENERIC_IRQ_SHOW
 	select ARCH_WANT_IPC_PARSE_VERSION
 	select HAVE_ARCH_TRACEHOOK
<span class="p_chunk">@@ -37,9 +38,6 @@</span> <span class="p_context"> config HIGHMEM</span>
 config NUMA
 	def_bool n
 
<span class="p_del">-config UID16</span>
<span class="p_del">-	def_bool y</span>
<span class="p_del">-</span>
 config RWSEM_GENERIC_SPINLOCK
 	def_bool y
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/cmpxchg.h b/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_header">index d463c68fe7f0..99897f6645c1 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -18,12 +18,12 @@</span> <span class="p_context"> __xchg_u32(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned int *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -61,12 +61,12 @@</span> <span class="p_context"> __xchg_u64(volatile void *p, unsigned long val)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__(
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2 \n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stdcx.	%3,0,%2 \n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*(volatile unsigned long *)p)
 	: &quot;r&quot; (p), &quot;r&quot; (val)
 	: &quot;cc&quot;, &quot;memory&quot;);
<span class="p_chunk">@@ -152,14 +152,14 @@</span> <span class="p_context"> __cmpxchg_u32(volatile unsigned int *p, unsigned long old, unsigned long new)</span>
 	unsigned int prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	lwarx	%0,0,%2		# __cmpxchg_u32\n\
 	cmpw	0,%0,%3\n\
 	bne-	2f\n&quot;
 	PPC405_ERR77(0,%2)
 &quot;	stwcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_chunk">@@ -198,13 +198,13 @@</span> <span class="p_context"> __cmpxchg_u64(volatile unsigned long *p, unsigned long old, unsigned long new)</span>
 	unsigned long prev;
 
 	__asm__ __volatile__ (
<span class="p_del">-	PPC_RELEASE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_ENTRY_BARRIER</span>
 &quot;1:	ldarx	%0,0,%2		# __cmpxchg_u64\n\
 	cmpd	0,%0,%3\n\
 	bne-	2f\n\
 	stdcx.	%4,0,%2\n\
 	bne-	1b&quot;
<span class="p_del">-	PPC_ACQUIRE_BARRIER</span>
<span class="p_add">+	PPC_ATOMIC_EXIT_BARRIER</span>
 	&quot;\n\
 2:&quot;
 	: &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*p)
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index af56b5c6c81a..f4f99f01b746 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -108,6 +108,7 @@</span> <span class="p_context"></span>
 #define MSR_TS_T	__MASK(MSR_TS_T_LG)	/*  Transaction Transactional */
 #define MSR_TS_MASK	(MSR_TS_T | MSR_TS_S)   /* Transaction State bits */
 #define MSR_TM_ACTIVE(x) (((x) &amp; MSR_TS_MASK) != 0) /* Transaction active? */
<span class="p_add">+#define MSR_TM_RESV(x) (((x) &amp; MSR_TS_MASK) == MSR_TS_MASK) /* Reserved */</span>
 #define MSR_TM_TRANSACTIONAL(x)	(((x) &amp; MSR_TS_MASK) == MSR_TS_T)
 #define MSR_TM_SUSPENDED(x)	(((x) &amp; MSR_TS_MASK) == MSR_TS_S)
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/synch.h b/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">index e682a7143edb..c50868681f9e 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/synch.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/synch.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline void isync(void)</span>
 	MAKE_LWSYNC_SECTION_ENTRY(97, __lwsync_fixup);
 #define PPC_ACQUIRE_BARRIER	 &quot;\n&quot; stringify_in_c(__PPC_ACQUIRE_BARRIER)
 #define PPC_RELEASE_BARRIER	 stringify_in_c(LWSYNC) &quot;\n&quot;
<span class="p_del">-#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(LWSYNC) &quot;\n&quot;</span>
<span class="p_add">+#define PPC_ATOMIC_ENTRY_BARRIER &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;</span>
 #define PPC_ATOMIC_EXIT_BARRIER	 &quot;\n&quot; stringify_in_c(sync) &quot;\n&quot;
 #else
 #define PPC_ACQUIRE_BARRIER
<span class="p_header">diff --git a/arch/powerpc/include/uapi/asm/elf.h b/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_header">index 59dad113897b..c2d21d11c2d2 100644</span>
<span class="p_header">--- a/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_header">+++ b/arch/powerpc/include/uapi/asm/elf.h</span>
<span class="p_chunk">@@ -295,6 +295,8 @@</span> <span class="p_context"> do {									\</span>
 #define R_PPC64_TLSLD		108
 #define R_PPC64_TOCSAVE		109
 
<span class="p_add">+#define R_PPC64_ENTRY		118</span>
<span class="p_add">+</span>
 #define R_PPC64_REL16		249
 #define R_PPC64_REL16_LO	250
 #define R_PPC64_REL16_HI	251
<span class="p_header">diff --git a/arch/powerpc/kernel/module_64.c b/arch/powerpc/kernel/module_64.c</span>
<span class="p_header">index 68384514506b..59663af9315f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/module_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/module_64.c</span>
<span class="p_chunk">@@ -635,6 +635,33 @@</span> <span class="p_context"> int apply_relocate_add(Elf64_Shdr *sechdrs,</span>
 			 */
 			break;
 
<span class="p_add">+		case R_PPC64_ENTRY:</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Optimize ELFv2 large code model entry point if</span>
<span class="p_add">+			 * the TOC is within 2GB range of current location.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			value = my_r2(sechdrs, me) - (unsigned long)location;</span>
<span class="p_add">+			if (value + 0x80008000 &gt; 0xffffffff)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Check for the large code model prolog sequence:</span>
<span class="p_add">+		         *	ld r2, ...(r12)</span>
<span class="p_add">+			 *	add r2, r2, r12</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if ((((uint32_t *)location)[0] &amp; ~0xfffc)</span>
<span class="p_add">+			    != 0xe84c0000)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			if (((uint32_t *)location)[1] != 0x7c426214)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If found, replace it with:</span>
<span class="p_add">+			 *	addis r2, r12, (.TOC.-func)@ha</span>
<span class="p_add">+			 *	addi r2, r12, (.TOC.-func)@l</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			((uint32_t *)location)[0] = 0x3c4c0000 + PPC_HA(value);</span>
<span class="p_add">+			((uint32_t *)location)[1] = 0x38420000 + PPC_LO(value);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		case R_PPC64_REL16_HA:
 			/* Subtract location pointer */
 			value -= (unsigned long)location;
<span class="p_header">diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c</span>
<span class="p_header">index 0596373cd1c3..c8c8275765e7 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/process.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/process.c</span>
<span class="p_chunk">@@ -551,6 +551,24 @@</span> <span class="p_context"> static void tm_reclaim_thread(struct thread_struct *thr,</span>
 		msr_diff &amp;= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Use the current MSR TM suspended bit to track if we have</span>
<span class="p_add">+	 * checkpointed state outstanding.</span>
<span class="p_add">+	 * On signal delivery, we&#39;d normally reclaim the checkpointed</span>
<span class="p_add">+	 * state to obtain stack pointer (see:get_tm_stackpointer()).</span>
<span class="p_add">+	 * This will then directly return to userspace without going</span>
<span class="p_add">+	 * through __switch_to(). However, if the stack frame is bad,</span>
<span class="p_add">+	 * we need to exit this thread which calls __switch_to() which</span>
<span class="p_add">+	 * will again attempt to reclaim the already saved tm state.</span>
<span class="p_add">+	 * Hence we need to check that we&#39;ve not already reclaimed</span>
<span class="p_add">+	 * this state.</span>
<span class="p_add">+	 * We do this using the current MSR, rather tracking it in</span>
<span class="p_add">+	 * some specific thread_struct bit, as it has the additional</span>
<span class="p_add">+	 * benifit of checking for a potential TM bad thing exception.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!MSR_TM_SUSPENDED(mfmsr()))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	tm_reclaim(thr, thr-&gt;regs-&gt;msr, cause);
 
 	/* Having done the reclaim, we now have the checkpointed
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_32.c b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">index da50e0c9c57e..7356c33dc897 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_32.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_32.c</span>
<span class="p_chunk">@@ -875,6 +875,15 @@</span> <span class="p_context"> static long restore_tm_user_regs(struct pt_regs *regs,</span>
 		return 1;
 #endif /* CONFIG_SPE */
 
<span class="p_add">+	/* Get the top half of the MSR from the user context */</span>
<span class="p_add">+	if (__get_user(msr_hi, &amp;tm_sr-&gt;mc_gregs[PT_MSR]))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	msr_hi &lt;&lt;= 32;</span>
<span class="p_add">+	/* If TM bits are set to the reserved value, it&#39;s an invalid context */</span>
<span class="p_add">+	if (MSR_TM_RESV(msr_hi))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	/* Pull in the MSR TM bits from the user context */</span>
<span class="p_add">+	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | (msr_hi &amp; MSR_TS_MASK);</span>
 	/* Now, recheckpoint.  This loads up all of the checkpointed (older)
 	 * registers, including FP and V[S]Rs.  After recheckpointing, the
 	 * transactional versions should be loaded.
<span class="p_chunk">@@ -884,11 +893,6 @@</span> <span class="p_context"> static long restore_tm_user_regs(struct pt_regs *regs,</span>
 	current-&gt;thread.tm_texasr |= TEXASR_FS;
 	/* This loads the checkpointed FP/VEC state, if used */
 	tm_recheckpoint(&amp;current-&gt;thread, msr);
<span class="p_del">-	/* Get the top half of the MSR */</span>
<span class="p_del">-	if (__get_user(msr_hi, &amp;tm_sr-&gt;mc_gregs[PT_MSR]))</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	/* Pull in MSR TM from user context */</span>
<span class="p_del">-	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | ((msr_hi&lt;&lt;32) &amp; MSR_TS_MASK);</span>
 
 	/* This loads the speculative FP/VEC state, if used */
 	if (msr &amp; MSR_FP) {
<span class="p_header">diff --git a/arch/powerpc/kernel/signal_64.c b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">index c7c24d2e2bdb..164fd6474843 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal_64.c</span>
<span class="p_chunk">@@ -427,6 +427,10 @@</span> <span class="p_context"> static long restore_tm_sigcontexts(struct pt_regs *regs,</span>
 
 	/* get MSR separately, transfer the LE bit if doing signal return */
 	err |= __get_user(msr, &amp;sc-&gt;gp_regs[PT_MSR]);
<span class="p_add">+	/* Don&#39;t allow reserved mode. */</span>
<span class="p_add">+	if (MSR_TM_RESV(msr))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* pull in MSR TM from user context */
 	regs-&gt;msr = (regs-&gt;msr &amp; ~MSR_TS_MASK) | (msr &amp; MSR_TS_MASK);
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index f1e0e5522e3a..f5b3de7f7fa2 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -210,6 +210,12 @@</span> <span class="p_context"> static void kvmppc_core_vcpu_put_hv(struct kvm_vcpu *vcpu)</span>
 
 static void kvmppc_set_msr_hv(struct kvm_vcpu *vcpu, u64 msr)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for illegal transactional state bit combination</span>
<span class="p_add">+	 * and if we find it, force the TS field to a safe state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((msr &amp; MSR_TS_MASK) == MSR_TS_MASK)</span>
<span class="p_add">+		msr &amp;= ~MSR_TS_MASK;</span>
 	vcpu-&gt;arch.shregs.msr = msr;
 	kvmppc_end_cede(vcpu);
 }
<span class="p_header">diff --git a/arch/powerpc/net/bpf_jit_comp.c b/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_header">index 17cea18a09d3..264c473c1b3c 100644</span>
<span class="p_header">--- a/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/powerpc/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -78,18 +78,9 @@</span> <span class="p_context"> static void bpf_jit_build_prologue(struct bpf_prog *fp, u32 *image,</span>
 		PPC_LI(r_X, 0);
 	}
 
<span class="p_del">-	switch (filter[0].code) {</span>
<span class="p_del">-	case BPF_RET | BPF_K:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-		/* first instruction sets A register (or is RET &#39;constant&#39;) */</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* make sure we dont leak kernel information to user */</span>
<span class="p_add">+	/* make sure we dont leak kernel information to user */</span>
<span class="p_add">+	if (bpf_needs_clear_a(&amp;filter[0]))</span>
 		PPC_LI(r_A, 0);
<span class="p_del">-	}</span>
 }
 
 static void bpf_jit_build_epilogue(u32 *image, struct codegen_context *ctx)
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal.c b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">index 2241565b0739..b831a2ee32e9 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal.c</span>
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> static void opal_handle_message(void)</span>
 
 	/* Sanity check */
 	if (type &gt;= OPAL_MSG_TYPE_MAX) {
<span class="p_del">-		pr_warning(&quot;%s: Unknown message type: %u\n&quot;, __func__, type);</span>
<span class="p_add">+		pr_warn_once(&quot;%s: Unknown message type: %u\n&quot;, __func__, type);</span>
 		return;
 	}
 	opal_message_do_notify(type, (void *)&amp;msg);
<span class="p_header">diff --git a/arch/sparc/net/bpf_jit_comp.c b/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_header">index 7931eeeb649a..8109e92cd619 100644</span>
<span class="p_header">--- a/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/sparc/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -420,22 +420,9 @@</span> <span class="p_context"> void bpf_jit_compile(struct bpf_prog *fp)</span>
 		}
 		emit_reg_move(O7, r_saved_O7);
 
<span class="p_del">-		switch (filter[0].code) {</span>
<span class="p_del">-		case BPF_RET | BPF_K:</span>
<span class="p_del">-		case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_del">-		case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_del">-		case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_del">-		case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_del">-			/* The first instruction sets the A register (or is</span>
<span class="p_del">-			 * a &quot;RET &#39;constant&#39;&quot;)</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			/* Make sure we dont leak kernel information to the</span>
<span class="p_del">-			 * user.</span>
<span class="p_del">-			 */</span>
<span class="p_add">+		/* Make sure we dont leak kernel information to the user. */</span>
<span class="p_add">+		if (bpf_needs_clear_a(&amp;filter[0]))</span>
 			emit_clear(r_A); /* A = 0 */
<span class="p_del">-		}</span>
 
 		for (i = 0; i &lt; flen; i++) {
 			unsigned int K = filter[i].k;
<span class="p_header">diff --git a/arch/x86/include/asm/boot.h b/arch/x86/include/asm/boot.h</span>
<span class="p_header">index 4fa687a47a62..6b8d6e8cd449 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/boot.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/boot.h</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"></span>
 #define BOOT_HEAP_SIZE             0x400000
 #else /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_del">-#define BOOT_HEAP_SIZE	0x8000</span>
<span class="p_add">+#define BOOT_HEAP_SIZE	0x10000</span>
 
 #endif /* !CONFIG_KERNEL_BZIP2 */
 
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 80d67dd80351..73e38f14ddeb 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -104,8 +104,36 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 #endif
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
<span class="p_del">-		/* Re-load page tables */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Re-load page tables.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This logic has an ordering constraint:</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 *  CPU 0: Write to a PTE for &#39;next&#39;</span>
<span class="p_add">+		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.</span>
<span class="p_add">+		 *  CPU 1: set bit 1 in next&#39;s mm_cpumask</span>
<span class="p_add">+		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We need to prevent an outcome in which CPU 1 observes</span>
<span class="p_add">+		 * the new PTE value and CPU 0 observes bit 1 clear in</span>
<span class="p_add">+		 * mm_cpumask.  (If that occurs, then the IPI will never</span>
<span class="p_add">+		 * be sent, and CPU 0&#39;s TLB will contain a stale entry.)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The bad outcome can occur if either CPU&#39;s load is</span>
<span class="p_add">+		 * reordered before that CPU&#39;s store, so both CPUs must</span>
<span class="p_add">+		 * execute full barriers to prevent this from happening.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Thus, switch_mm needs a full barrier between the</span>
<span class="p_add">+		 * store to mm_cpumask and any operation that could load</span>
<span class="p_add">+		 * from next-&gt;pgd.  TLB fills are special and can happen</span>
<span class="p_add">+		 * due to instruction fetches or for no reason at all,</span>
<span class="p_add">+		 * and neither LOCK nor MFENCE orders them.</span>
<span class="p_add">+		 * Fortunately, load_cr3() is serializing and gives the</span>
<span class="p_add">+		 * ordering guarantee we need.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 */</span>
 		load_cr3(next-&gt;pgd);
<span class="p_add">+</span>
 		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
 
 		/* Stop flush ipis for the previous mm */
<span class="p_chunk">@@ -142,10 +170,14 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 			 * schedule, protecting us from simultaneous changes.
 			 */
 			cpumask_set_cpu(cpu, mm_cpumask(next));
<span class="p_add">+</span>
 			/*
 			 * We were in lazy tlb mode and leave_mm disabled
 			 * tlb flush IPI delivery. We must reload CR3
 			 * to make sure to use no freed page tables.
<span class="p_add">+			 *</span>
<span class="p_add">+			 * As above, load_cr3() is serializing and orders TLB</span>
<span class="p_add">+			 * fills with respect to the mm_cpumask write.</span>
 			 */
 			load_cr3(next-&gt;pgd);
 			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index 86db4bcd7ce5..0549ae3cb332 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -182,6 +182,14 @@</span> <span class="p_context"> static struct dmi_system_id __initdata reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac9,1&quot;),
 		},
 	},
<span class="p_add">+	{	/* Handle problems with rebooting on the iMac10,1. */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;Apple iMac10,1&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+		    DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+		    DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac10,1&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* ASRock */
 	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */
<span class="p_header">diff --git a/arch/x86/kernel/signal.c b/arch/x86/kernel/signal.c</span>
<span class="p_header">index e0fd5f47fbb9..5d2e2e9af1c4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/signal.c</span>
<span class="p_header">+++ b/arch/x86/kernel/signal.c</span>
<span class="p_chunk">@@ -667,12 +667,15 @@</span> <span class="p_context"> handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span>
 	signal_setup_done(failed, ksig, stepping);
 }
 
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-#define NR_restart_syscall	__NR_restart_syscall</span>
<span class="p_del">-#else /* !CONFIG_X86_32 */</span>
<span class="p_del">-#define NR_restart_syscall	\</span>
<span class="p_del">-	test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall</span>
<span class="p_del">-#endif /* CONFIG_X86_32 */</span>
<span class="p_add">+static inline unsigned long get_nr_restart_syscall(const struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if defined(CONFIG_X86_32) || !defined(CONFIG_X86_64)</span>
<span class="p_add">+	return __NR_restart_syscall;</span>
<span class="p_add">+#else /* !CONFIG_X86_32 &amp;&amp; CONFIG_X86_64 */</span>
<span class="p_add">+	return test_thread_flag(TIF_IA32) ? __NR_ia32_restart_syscall :</span>
<span class="p_add">+		__NR_restart_syscall | (regs-&gt;orig_ax &amp; __X32_SYSCALL_BIT);</span>
<span class="p_add">+#endif /* CONFIG_X86_32 || !CONFIG_X86_64 */</span>
<span class="p_add">+}</span>
 
 /*
  * Note that &#39;init&#39; is a special process: it doesn&#39;t get signals it doesn&#39;t
<span class="p_chunk">@@ -701,7 +704,7 @@</span> <span class="p_context"> static void do_signal(struct pt_regs *regs)</span>
 			break;
 
 		case -ERESTART_RESTARTBLOCK:
<span class="p_del">-			regs-&gt;ax = NR_restart_syscall;</span>
<span class="p_add">+			regs-&gt;ax = get_nr_restart_syscall(regs);</span>
 			regs-&gt;ip -= 2;
 			break;
 		}
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 454ccb082e18..0d039cd268a8 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -1106,6 +1106,7 @@</span> <span class="p_context"> static void init_vmcb(struct vcpu_svm *svm)</span>
 	set_exception_intercept(svm, UD_VECTOR);
 	set_exception_intercept(svm, MC_VECTOR);
 	set_exception_intercept(svm, AC_VECTOR);
<span class="p_add">+	set_exception_intercept(svm, DB_VECTOR);</span>
 
 	set_intercept(svm, INTERCEPT_INTR);
 	set_intercept(svm, INTERCEPT_NMI);
<span class="p_chunk">@@ -1638,20 +1639,13 @@</span> <span class="p_context"> static void svm_set_segment(struct kvm_vcpu *vcpu,</span>
 	mark_dirty(svm-&gt;vmcb, VMCB_SEG);
 }
 
<span class="p_del">-static void update_db_bp_intercept(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+static void update_bp_intercept(struct kvm_vcpu *vcpu)</span>
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
 
<span class="p_del">-	clr_exception_intercept(svm, DB_VECTOR);</span>
 	clr_exception_intercept(svm, BP_VECTOR);
 
<span class="p_del">-	if (svm-&gt;nmi_singlestep)</span>
<span class="p_del">-		set_exception_intercept(svm, DB_VECTOR);</span>
<span class="p_del">-</span>
 	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_ENABLE) {
<span class="p_del">-		if (vcpu-&gt;guest_debug &amp;</span>
<span class="p_del">-		    (KVM_GUESTDBG_SINGLESTEP | KVM_GUESTDBG_USE_HW_BP))</span>
<span class="p_del">-			set_exception_intercept(svm, DB_VECTOR);</span>
 		if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_SW_BP)
 			set_exception_intercept(svm, BP_VECTOR);
 	} else
<span class="p_chunk">@@ -1757,7 +1751,6 @@</span> <span class="p_context"> static int db_interception(struct vcpu_svm *svm)</span>
 		if (!(svm-&gt;vcpu.guest_debug &amp; KVM_GUESTDBG_SINGLESTEP))
 			svm-&gt;vmcb-&gt;save.rflags &amp;=
 				~(X86_EFLAGS_TF | X86_EFLAGS_RF);
<span class="p_del">-		update_db_bp_intercept(&amp;svm-&gt;vcpu);</span>
 	}
 
 	if (svm-&gt;vcpu.guest_debug &amp;
<span class="p_chunk">@@ -3751,7 +3744,6 @@</span> <span class="p_context"> static void enable_nmi_window(struct kvm_vcpu *vcpu)</span>
 	 */
 	svm-&gt;nmi_singlestep = true;
 	svm-&gt;vmcb-&gt;save.rflags |= (X86_EFLAGS_TF | X86_EFLAGS_RF);
<span class="p_del">-	update_db_bp_intercept(vcpu);</span>
 }
 
 static int svm_set_tss_addr(struct kvm *kvm, unsigned int addr)
<span class="p_chunk">@@ -4367,7 +4359,7 @@</span> <span class="p_context"> static struct kvm_x86_ops svm_x86_ops = {</span>
 	.vcpu_load = svm_vcpu_load,
 	.vcpu_put = svm_vcpu_put,
 
<span class="p_del">-	.update_db_bp_intercept = update_db_bp_intercept,</span>
<span class="p_add">+	.update_db_bp_intercept = update_bp_intercept,</span>
 	.get_msr = svm_get_msr,
 	.set_msr = svm_set_msr,
 	.get_segment_base = svm_get_segment_base,
<span class="p_header">diff --git a/arch/x86/kvm/trace.h b/arch/x86/kvm/trace.h</span>
<span class="p_header">index 7c7bc8bef21f..21dda139eb3a 100644</span>
<span class="p_header">--- a/arch/x86/kvm/trace.h</span>
<span class="p_header">+++ b/arch/x86/kvm/trace.h</span>
<span class="p_chunk">@@ -250,7 +250,7 @@</span> <span class="p_context"> TRACE_EVENT(kvm_inj_virq,</span>
 #define kvm_trace_sym_exc						\
 	EXS(DE), EXS(DB), EXS(BP), EXS(OF), EXS(BR), EXS(UD), EXS(NM),	\
 	EXS(DF), EXS(TS), EXS(NP), EXS(SS), EXS(GP), EXS(PF),		\
<span class="p_del">-	EXS(MF), EXS(MC)</span>
<span class="p_add">+	EXS(MF), EXS(AC), EXS(MC)</span>
 
 /*
  * Tracepoint for kvm interrupt injection:
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index a243854c35d5..945f9e13f1aa 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -3652,20 +3652,21 @@</span> <span class="p_context"> static int vmx_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)</span>
 		if (!is_paging(vcpu)) {
 			hw_cr4 &amp;= ~X86_CR4_PAE;
 			hw_cr4 |= X86_CR4_PSE;
<span class="p_del">-			/*</span>
<span class="p_del">-			 * SMEP/SMAP is disabled if CPU is in non-paging mode</span>
<span class="p_del">-			 * in hardware. However KVM always uses paging mode to</span>
<span class="p_del">-			 * emulate guest non-paging mode with TDP.</span>
<span class="p_del">-			 * To emulate this behavior, SMEP/SMAP needs to be</span>
<span class="p_del">-			 * manually disabled when guest switches to non-paging</span>
<span class="p_del">-			 * mode.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			hw_cr4 &amp;= ~(X86_CR4_SMEP | X86_CR4_SMAP);</span>
 		} else if (!(cr4 &amp; X86_CR4_PAE)) {
 			hw_cr4 &amp;= ~X86_CR4_PAE;
 		}
 	}
 
<span class="p_add">+	if (!enable_unrestricted_guest &amp;&amp; !is_paging(vcpu))</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * SMEP/SMAP is disabled if CPU is in non-paging mode in</span>
<span class="p_add">+		 * hardware.  However KVM always uses paging mode without</span>
<span class="p_add">+		 * unrestricted guest.</span>
<span class="p_add">+		 * To emulate this behavior, SMEP/SMAP needs to be manually</span>
<span class="p_add">+		 * disabled when guest switches to non-paging mode.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		hw_cr4 &amp;= ~(X86_CR4_SMEP | X86_CR4_SMAP);</span>
<span class="p_add">+</span>
 	vmcs_writel(CR4_READ_SHADOW, cr4);
 	vmcs_writel(GUEST_CR4, hw_cr4);
 	return 0;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 47a32f743a91..fed4c84eac44 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -940,7 +940,7 @@</span> <span class="p_context"> static u32 msrs_to_save[] = {</span>
 	MSR_CSTAR, MSR_KERNEL_GS_BASE, MSR_SYSCALL_MASK, MSR_LSTAR,
 #endif
 	MSR_IA32_TSC, MSR_IA32_CR_PAT, MSR_VM_HSAVE_PA,
<span class="p_del">-	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS</span>
<span class="p_add">+	MSR_IA32_FEATURE_CONTROL, MSR_IA32_BNDCFGS, MSR_TSC_AUX,</span>
 };
 
 static unsigned num_msrs_to_save;
<span class="p_chunk">@@ -4117,16 +4117,17 @@</span> <span class="p_context"> static void kvm_init_msr_list(void)</span>
 
 		/*
 		 * Even MSRs that are valid in the host may not be exposed
<span class="p_del">-		 * to the guests in some cases.  We could work around this</span>
<span class="p_del">-		 * in VMX with the generic MSR save/load machinery, but it</span>
<span class="p_del">-		 * is not really worthwhile since it will really only</span>
<span class="p_del">-		 * happen with nested virtualization.</span>
<span class="p_add">+		 * to the guests in some cases.</span>
 		 */
 		switch (msrs_to_save[i]) {
 		case MSR_IA32_BNDCFGS:
 			if (!kvm_x86_ops-&gt;mpx_supported())
 				continue;
 			break;
<span class="p_add">+		case MSR_TSC_AUX:</span>
<span class="p_add">+			if (!kvm_x86_ops-&gt;rdtscp_supported())</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			break;</span>
 		default:
 			break;
 		}
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index 4d1c11c07fe1..f738c61bc891 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -120,19 +120,19 @@</span> <span class="p_context"> static int get_reg_offset(struct insn *insn, struct pt_regs *regs,</span>
 	switch (type) {
 	case REG_TYPE_RM:
 		regno = X86_MODRM_RM(insn-&gt;modrm.value);
<span class="p_del">-		if (X86_REX_B(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_B(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
 	case REG_TYPE_INDEX:
 		regno = X86_SIB_INDEX(insn-&gt;sib.value);
<span class="p_del">-		if (X86_REX_X(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_X(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
 	case REG_TYPE_BASE:
 		regno = X86_SIB_BASE(insn-&gt;sib.value);
<span class="p_del">-		if (X86_REX_B(insn-&gt;rex_prefix.value) == 1)</span>
<span class="p_add">+		if (X86_REX_B(insn-&gt;rex_prefix.value))</span>
 			regno += 8;
 		break;
 
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 90b924acd982..061e0114005e 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -160,7 +160,10 @@</span> <span class="p_context"> void flush_tlb_current_task(void)</span>
 	preempt_disable();
 
 	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
<span class="p_add">+</span>
<span class="p_add">+	/* This is an implicit full barrier that synchronizes with switch_mm. */</span>
 	local_flush_tlb();
<span class="p_add">+</span>
 	trace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
 		flush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);
<span class="p_chunk">@@ -187,17 +190,29 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 	unsigned long base_pages_to_flush = TLB_FLUSH_ALL;
 
 	preempt_disable();
<span class="p_del">-	if (current-&gt;active_mm != mm)</span>
<span class="p_add">+	if (current-&gt;active_mm != mm) {</span>
<span class="p_add">+		/* Synchronize with switch_mm. */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	if (!current-&gt;mm) {
 		leave_mm(smp_processor_id());
<span class="p_add">+</span>
<span class="p_add">+		/* Synchronize with switch_mm. */</span>
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		goto out;
 	}
 
 	if ((end != TLB_FLUSH_ALL) &amp;&amp; !(vmflag &amp; VM_HUGETLB))
 		base_pages_to_flush = (end - start) &gt;&gt; PAGE_SHIFT;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Both branches below are implicit full barriers (MOV to CR or</span>
<span class="p_add">+	 * INVLPG) that synchronize with switch_mm.</span>
<span class="p_add">+	 */</span>
 	if (base_pages_to_flush &gt; tlb_single_page_flush_ceiling) {
 		base_pages_to_flush = TLB_FLUSH_ALL;
 		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
<span class="p_chunk">@@ -227,10 +242,18 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
 	preempt_disable();
 
 	if (current-&gt;active_mm == mm) {
<span class="p_del">-		if (current-&gt;mm)</span>
<span class="p_add">+		if (current-&gt;mm) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Implicit full barrier (INVLPG) that synchronizes</span>
<span class="p_add">+			 * with switch_mm.</span>
<span class="p_add">+			 */</span>
 			__flush_tlb_one(start);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			leave_mm(smp_processor_id());
<span class="p_add">+</span>
<span class="p_add">+			/* Synchronize with switch_mm. */</span>
<span class="p_add">+			smp_mb();</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_header">diff --git a/arch/x86/xen/suspend.c b/arch/x86/xen/suspend.c</span>
<span class="p_header">index 53b4c0811f4f..6d3415144dab 100644</span>
<span class="p_header">--- a/arch/x86/xen/suspend.c</span>
<span class="p_header">+++ b/arch/x86/xen/suspend.c</span>
<span class="p_chunk">@@ -32,7 +32,8 @@</span> <span class="p_context"> static void xen_hvm_post_suspend(int suspend_cancelled)</span>
 {
 #ifdef CONFIG_XEN_PVHVM
 	int cpu;
<span class="p_del">-	xen_hvm_init_shared_info();</span>
<span class="p_add">+	if (!suspend_cancelled)</span>
<span class="p_add">+	    xen_hvm_init_shared_info();</span>
 	xen_callback_vector();
 	xen_unplug_emulated_devices();
 	if (xen_feature(XENFEAT_hvm_safe_pvclock)) {
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 8a45e92ff60c..05222706dc66 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -404,18 +404,42 @@</span> <span class="p_context"> static enum si_sm_result start_next_msg(struct smi_info *smi_info)</span>
 	return rv;
 }
 
<span class="p_del">-static void start_check_enables(struct smi_info *smi_info)</span>
<span class="p_add">+static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smi_info-&gt;last_timeout_jiffies = jiffies;</span>
<span class="p_add">+	mod_timer(&amp;smi_info-&gt;si_timer, new_val);</span>
<span class="p_add">+	smi_info-&gt;timer_running = true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Start a new message and (re)start the timer and thread.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void start_new_msg(struct smi_info *smi_info, unsigned char *msg,</span>
<span class="p_add">+			  unsigned int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	smi_mod_timer(smi_info, jiffies + SI_TIMEOUT_JIFFIES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (smi_info-&gt;thread)</span>
<span class="p_add">+		wake_up_process(smi_info-&gt;thread);</span>
<span class="p_add">+</span>
<span class="p_add">+	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void start_check_enables(struct smi_info *smi_info, bool start_timer)</span>
 {
 	unsigned char msg[2];
 
 	msg[0] = (IPMI_NETFN_APP_REQUEST &lt;&lt; 2);
 	msg[1] = IPMI_GET_BMC_GLOBAL_ENABLES_CMD;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 2);</span>
<span class="p_add">+	if (start_timer)</span>
<span class="p_add">+		start_new_msg(smi_info, msg, 2);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 2);</span>
 	smi_info-&gt;si_state = SI_CHECKING_ENABLES;
 }
 
<span class="p_del">-static void start_clear_flags(struct smi_info *smi_info)</span>
<span class="p_add">+static void start_clear_flags(struct smi_info *smi_info, bool start_timer)</span>
 {
 	unsigned char msg[3];
 
<span class="p_chunk">@@ -424,7 +448,10 @@</span> <span class="p_context"> static void start_clear_flags(struct smi_info *smi_info)</span>
 	msg[1] = IPMI_CLEAR_MSG_FLAGS_CMD;
 	msg[2] = WDT_PRE_TIMEOUT_INT;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 3);</span>
<span class="p_add">+	if (start_timer)</span>
<span class="p_add">+		start_new_msg(smi_info, msg, 3);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		smi_info-&gt;handlers-&gt;start_transaction(smi_info-&gt;si_sm, msg, 3);</span>
 	smi_info-&gt;si_state = SI_CLEARING_FLAGS;
 }
 
<span class="p_chunk">@@ -434,10 +461,8 @@</span> <span class="p_context"> static void start_getting_msg_queue(struct smi_info *smi_info)</span>
 	smi_info-&gt;curr_msg-&gt;data[1] = IPMI_GET_MSG_CMD;
 	smi_info-&gt;curr_msg-&gt;data_size = 2;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-		smi_info-&gt;si_sm,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data_size);</span>
<span class="p_add">+	start_new_msg(smi_info, smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_add">+		      smi_info-&gt;curr_msg-&gt;data_size);</span>
 	smi_info-&gt;si_state = SI_GETTING_MESSAGES;
 }
 
<span class="p_chunk">@@ -447,20 +472,11 @@</span> <span class="p_context"> static void start_getting_events(struct smi_info *smi_info)</span>
 	smi_info-&gt;curr_msg-&gt;data[1] = IPMI_READ_EVENT_MSG_BUFFER_CMD;
 	smi_info-&gt;curr_msg-&gt;data_size = 2;
 
<span class="p_del">-	smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-		smi_info-&gt;si_sm,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_del">-		smi_info-&gt;curr_msg-&gt;data_size);</span>
<span class="p_add">+	start_new_msg(smi_info, smi_info-&gt;curr_msg-&gt;data,</span>
<span class="p_add">+		      smi_info-&gt;curr_msg-&gt;data_size);</span>
 	smi_info-&gt;si_state = SI_GETTING_EVENTS;
 }
 
<span class="p_del">-static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	smi_info-&gt;last_timeout_jiffies = jiffies;</span>
<span class="p_del">-	mod_timer(&amp;smi_info-&gt;si_timer, new_val);</span>
<span class="p_del">-	smi_info-&gt;timer_running = true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * When we have a situtaion where we run out of memory and cannot
  * allocate messages, we just leave them in the BMC and run the system
<span class="p_chunk">@@ -470,11 +486,11 @@</span> <span class="p_context"> static void smi_mod_timer(struct smi_info *smi_info, unsigned long new_val)</span>
  * Note that we cannot just use disable_irq(), since the interrupt may
  * be shared.
  */
<span class="p_del">-static inline bool disable_si_irq(struct smi_info *smi_info)</span>
<span class="p_add">+static inline bool disable_si_irq(struct smi_info *smi_info, bool start_timer)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (!smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = true;
<span class="p_del">-		start_check_enables(smi_info);</span>
<span class="p_add">+		start_check_enables(smi_info, start_timer);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -484,7 +500,7 @@</span> <span class="p_context"> static inline bool enable_si_irq(struct smi_info *smi_info)</span>
 {
 	if ((smi_info-&gt;irq) &amp;&amp; (smi_info-&gt;interrupt_disabled)) {
 		smi_info-&gt;interrupt_disabled = false;
<span class="p_del">-		start_check_enables(smi_info);</span>
<span class="p_add">+		start_check_enables(smi_info, true);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -502,7 +518,7 @@</span> <span class="p_context"> static struct ipmi_smi_msg *alloc_msg_handle_irq(struct smi_info *smi_info)</span>
 
 	msg = ipmi_alloc_smi_msg();
 	if (!msg) {
<span class="p_del">-		if (!disable_si_irq(smi_info))</span>
<span class="p_add">+		if (!disable_si_irq(smi_info, true))</span>
 			smi_info-&gt;si_state = SI_NORMAL;
 	} else if (enable_si_irq(smi_info)) {
 		ipmi_free_smi_msg(msg);
<span class="p_chunk">@@ -518,7 +534,7 @@</span> <span class="p_context"> static void handle_flags(struct smi_info *smi_info)</span>
 		/* Watchdog pre-timeout */
 		smi_inc_stat(smi_info, watchdog_pretimeouts);
 
<span class="p_del">-		start_clear_flags(smi_info);</span>
<span class="p_add">+		start_clear_flags(smi_info, true);</span>
 		smi_info-&gt;msg_flags &amp;= ~WDT_PRE_TIMEOUT_INT;
 		if (smi_info-&gt;intf)
 			ipmi_smi_watchdog_pretimeout(smi_info-&gt;intf);
<span class="p_chunk">@@ -870,8 +886,7 @@</span> <span class="p_context"> static enum si_sm_result smi_event_handler(struct smi_info *smi_info,</span>
 			msg[0] = (IPMI_NETFN_APP_REQUEST &lt;&lt; 2);
 			msg[1] = IPMI_GET_MSG_FLAGS_CMD;
 
<span class="p_del">-			smi_info-&gt;handlers-&gt;start_transaction(</span>
<span class="p_del">-				smi_info-&gt;si_sm, msg, 2);</span>
<span class="p_add">+			start_new_msg(smi_info, msg, 2);</span>
 			smi_info-&gt;si_state = SI_GETTING_FLAGS;
 			goto restart;
 		}
<span class="p_chunk">@@ -901,7 +916,7 @@</span> <span class="p_context"> static enum si_sm_result smi_event_handler(struct smi_info *smi_info,</span>
 		 * disable and messages disabled.
 		 */
 		if (smi_info-&gt;supports_event_msg_buff || smi_info-&gt;irq) {
<span class="p_del">-			start_check_enables(smi_info);</span>
<span class="p_add">+			start_check_enables(smi_info, true);</span>
 		} else {
 			smi_info-&gt;curr_msg = alloc_msg_handle_irq(smi_info);
 			if (!smi_info-&gt;curr_msg)
<span class="p_chunk">@@ -1203,14 +1218,14 @@</span> <span class="p_context"> static int smi_start_processing(void       *send_info,</span>
 
 	new_smi-&gt;intf = intf;
 
<span class="p_del">-	/* Try to claim any interrupts. */</span>
<span class="p_del">-	if (new_smi-&gt;irq_setup)</span>
<span class="p_del">-		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_del">-</span>
 	/* Set up the timer that drives the interface. */
 	setup_timer(&amp;new_smi-&gt;si_timer, smi_timeout, (long)new_smi);
 	smi_mod_timer(new_smi, jiffies + SI_TIMEOUT_JIFFIES);
 
<span class="p_add">+	/* Try to claim any interrupts. */</span>
<span class="p_add">+	if (new_smi-&gt;irq_setup)</span>
<span class="p_add">+		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_add">+</span>
 	/*
 	 * Check if the user forcefully enabled the daemon.
 	 */
<span class="p_chunk">@@ -3515,7 +3530,7 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 	 * Start clearing the flags before we enable interrupts or the
 	 * timer to avoid racing with the timer.
 	 */
<span class="p_del">-	start_clear_flags(new_smi);</span>
<span class="p_add">+	start_clear_flags(new_smi, false);</span>
 
 	/*
 	 * IRQ is defined to be set when non-zero.  req_events will
<span class="p_chunk">@@ -3817,7 +3832,7 @@</span> <span class="p_context"> static void cleanup_one_si(struct smi_info *to_clean)</span>
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
 	}
<span class="p_del">-	disable_si_irq(to_clean);</span>
<span class="p_add">+	disable_si_irq(to_clean, false);</span>
 	while (to_clean-&gt;curr_msg || (to_clean-&gt;si_state != SI_NORMAL)) {
 		poll(to_clean);
 		schedule_timeout_uninterruptible(1);
<span class="p_header">diff --git a/drivers/connector/connector.c b/drivers/connector/connector.c</span>
<span class="p_header">index 30f522848c73..c19e7fc717c3 100644</span>
<span class="p_header">--- a/drivers/connector/connector.c</span>
<span class="p_header">+++ b/drivers/connector/connector.c</span>
<span class="p_chunk">@@ -178,26 +178,21 @@</span> <span class="p_context"> static int cn_call_callback(struct sk_buff *skb)</span>
  *
  * It checks skb, netlink header and msg sizes, and calls callback helper.
  */
<span class="p_del">-static void cn_rx_skb(struct sk_buff *__skb)</span>
<span class="p_add">+static void cn_rx_skb(struct sk_buff *skb)</span>
 {
 	struct nlmsghdr *nlh;
<span class="p_del">-	struct sk_buff *skb;</span>
 	int len, err;
 
<span class="p_del">-	skb = skb_get(__skb);</span>
<span class="p_del">-</span>
 	if (skb-&gt;len &gt;= NLMSG_HDRLEN) {
 		nlh = nlmsg_hdr(skb);
 		len = nlmsg_len(nlh);
 
 		if (len &lt; (int)sizeof(struct cn_msg) ||
 		    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||
<span class="p_del">-		    len &gt; CONNECTOR_MAX_MSG_SIZE) {</span>
<span class="p_del">-			kfree_skb(skb);</span>
<span class="p_add">+		    len &gt; CONNECTOR_MAX_MSG_SIZE)</span>
 			return;
<span class="p_del">-		}</span>
 
<span class="p_del">-		err = cn_call_callback(skb);</span>
<span class="p_add">+		err = cn_call_callback(skb_get(skb));</span>
 		if (err &lt; 0)
 			kfree_skb(skb);
 	}
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index 722a925795a2..9ce9dfeb1258 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -1589,7 +1589,7 @@</span> <span class="p_context"> int hid_connect(struct hid_device *hdev, unsigned int connect_mask)</span>
 		&quot;Multi-Axis Controller&quot;
 	};
 	const char *type, *bus;
<span class="p_del">-	char buf[64];</span>
<span class="p_add">+	char buf[64] = &quot;&quot;;</span>
 	unsigned int i;
 	int len;
 	int ret;
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 8b0178db6a04..b85a8614c128 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -3928,14 +3928,17 @@</span> <span class="p_context"> int dmar_find_matched_atsr_unit(struct pci_dev *dev)</span>
 	dev = pci_physfn(dev);
 	for (bus = dev-&gt;bus; bus; bus = bus-&gt;parent) {
 		bridge = bus-&gt;self;
<span class="p_del">-		if (!bridge || !pci_is_pcie(bridge) ||</span>
<span class="p_add">+		/* If it&#39;s an integrated device, allow ATS */</span>
<span class="p_add">+		if (!bridge)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		/* Connected via non-PCIe: no ATS */</span>
<span class="p_add">+		if (!pci_is_pcie(bridge) ||</span>
 		    pci_pcie_type(bridge) == PCI_EXP_TYPE_PCI_BRIDGE)
 			return 0;
<span class="p_add">+		/* If we found the root port, look it up in the ATSR */</span>
 		if (pci_pcie_type(bridge) == PCI_EXP_TYPE_ROOT_PORT)
 			break;
 	}
<span class="p_del">-	if (!bridge)</span>
<span class="p_del">-		return 0;</span>
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(atsru, &amp;dmar_atsr_units, list) {
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">index c4198fa490bf..9c1e8adaf4fc 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_chunk">@@ -301,6 +301,8 @@</span> <span class="p_context"> isdn_ppp_open(int min, struct file *file)</span>
 	is-&gt;compflags = 0;
 
 	is-&gt;reset = isdn_ppp_ccp_reset_alloc(is);
<span class="p_add">+	if (!is-&gt;reset)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	is-&gt;lp = NULL;
 	is-&gt;mp_seqno = 0;       /* MP sequence number */
<span class="p_chunk">@@ -320,6 +322,10 @@</span> <span class="p_context"> isdn_ppp_open(int min, struct file *file)</span>
 	 * VJ header compression init
 	 */
 	is-&gt;slcomp = slhc_init(16, 16);	/* not necessary for 2. link in bundle */
<span class="p_add">+	if (IS_ERR(is-&gt;slcomp)) {</span>
<span class="p_add">+		isdn_ppp_ccp_reset_free(is);</span>
<span class="p_add">+		return PTR_ERR(is-&gt;slcomp);</span>
<span class="p_add">+	}</span>
 #endif
 #ifdef CONFIG_IPPP_FILTER
 	is-&gt;pass_filter = NULL;
<span class="p_chunk">@@ -567,10 +573,8 @@</span> <span class="p_context"> isdn_ppp_ioctl(int min, struct file *file, unsigned int cmd, unsigned long arg)</span>
 			is-&gt;maxcid = val;
 #ifdef CONFIG_ISDN_PPP_VJ
 			sltmp = slhc_init(16, val);
<span class="p_del">-			if (!sltmp) {</span>
<span class="p_del">-				printk(KERN_ERR &quot;ippp, can&#39;t realloc slhc struct\n&quot;);</span>
<span class="p_del">-				return -ENOMEM;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			if (IS_ERR(sltmp))</span>
<span class="p_add">+				return PTR_ERR(sltmp);</span>
 			if (is-&gt;slcomp)
 				slhc_free(is-&gt;slcomp);
 			is-&gt;slcomp = sltmp;
<span class="p_header">diff --git a/drivers/media/platform/vivid/vivid-osd.c b/drivers/media/platform/vivid/vivid-osd.c</span>
<span class="p_header">index 084d346fb4c4..e15eef6a94e5 100644</span>
<span class="p_header">--- a/drivers/media/platform/vivid/vivid-osd.c</span>
<span class="p_header">+++ b/drivers/media/platform/vivid/vivid-osd.c</span>
<span class="p_chunk">@@ -85,6 +85,7 @@</span> <span class="p_context"> static int vivid_fb_ioctl(struct fb_info *info, unsigned cmd, unsigned long arg)</span>
 	case FBIOGET_VBLANK: {
 		struct fb_vblank vblank;
 
<span class="p_add">+		memset(&amp;vblank, 0, sizeof(vblank));</span>
 		vblank.flags = FB_VBLANK_HAVE_COUNT | FB_VBLANK_HAVE_VCOUNT |
 			FB_VBLANK_HAVE_VSYNC;
 		vblank.count = 0;
<span class="p_header">diff --git a/drivers/media/usb/airspy/airspy.c b/drivers/media/usb/airspy/airspy.c</span>
<span class="p_header">index 4069234abed5..a50750ce511d 100644</span>
<span class="p_header">--- a/drivers/media/usb/airspy/airspy.c</span>
<span class="p_header">+++ b/drivers/media/usb/airspy/airspy.c</span>
<span class="p_chunk">@@ -132,7 +132,7 @@</span> <span class="p_context"> struct airspy {</span>
 	int            urbs_submitted;
 
 	/* USB control message buffer */
<span class="p_del">-	#define BUF_SIZE 24</span>
<span class="p_add">+	#define BUF_SIZE 128</span>
 	u8 buf[BUF_SIZE];
 
 	/* Current configuration */
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index 16d87bf8ac3c..72ba774df7a7 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -1194,7 +1194,6 @@</span> <span class="p_context"> static int bond_master_upper_dev_link(struct net_device *bond_dev,</span>
 	err = netdev_master_upper_dev_link_private(slave_dev, bond_dev, slave);
 	if (err)
 		return err;
<span class="p_del">-	slave_dev-&gt;flags |= IFF_SLAVE;</span>
 	rtmsg_ifinfo(RTM_NEWLINK, slave_dev, IFF_SLAVE, GFP_KERNEL);
 	return 0;
 }
<span class="p_chunk">@@ -1452,6 +1451,9 @@</span> <span class="p_context"> int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)</span>
 		}
 	}
 
<span class="p_add">+	/* set slave flag before open to prevent IPv6 addrconf */</span>
<span class="p_add">+	slave_dev-&gt;flags |= IFF_SLAVE;</span>
<span class="p_add">+</span>
 	/* open the slave since the application closed it */
 	res = dev_open(slave_dev);
 	if (res) {
<span class="p_chunk">@@ -1712,6 +1714,7 @@</span> <span class="p_context"> err_close:</span>
 	dev_close(slave_dev);
 
 err_restore_mac:
<span class="p_add">+	slave_dev-&gt;flags &amp;= ~IFF_SLAVE;</span>
 	if (!bond-&gt;params.fail_over_mac ||
 	    BOND_MODE(bond) != BOND_MODE_ACTIVEBACKUP) {
 		/* XXX TODO - fom follow mode needs to change master&#39;s
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index 9d15566521a7..cfe49a07c7c1 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -715,10 +715,8 @@</span> <span class="p_context"> static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 			val &amp;= 0xffff;
 		}
 		vj = slhc_init(val2+1, val+1);
<span class="p_del">-		if (!vj) {</span>
<span class="p_del">-			netdev_err(ppp-&gt;dev,</span>
<span class="p_del">-				   &quot;PPP: no memory (VJ compressor)\n&quot;);</span>
<span class="p_del">-			err = -ENOMEM;</span>
<span class="p_add">+		if (IS_ERR(vj)) {</span>
<span class="p_add">+			err = PTR_ERR(vj);</span>
 			break;
 		}
 		ppp_lock(ppp);
<span class="p_header">diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c</span>
<span class="p_header">index 079f7adfcde5..27ed25252aac 100644</span>
<span class="p_header">--- a/drivers/net/slip/slhc.c</span>
<span class="p_header">+++ b/drivers/net/slip/slhc.c</span>
<span class="p_chunk">@@ -84,8 +84,9 @@</span> <span class="p_context"> static long decode(unsigned char **cpp);</span>
 static unsigned char * put16(unsigned char *cp, unsigned short x);
 static unsigned short pull16(unsigned char **cpp);
 
<span class="p_del">-/* Initialize compression data structure</span>
<span class="p_add">+/* Allocate compression data structure</span>
  *	slots must be in range 0 to 255 (zero meaning no compression)
<span class="p_add">+ * Returns pointer to structure or ERR_PTR() on error.</span>
  */
 struct slcompress *
 slhc_init(int rslots, int tslots)
<span class="p_chunk">@@ -94,11 +95,14 @@</span> <span class="p_context"> slhc_init(int rslots, int tslots)</span>
 	register struct cstate *ts;
 	struct slcompress *comp;
 
<span class="p_add">+	if (rslots &lt; 0 || rslots &gt; 255 || tslots &lt; 0 || tslots &gt; 255)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	comp = kzalloc(sizeof(struct slcompress), GFP_KERNEL);
 	if (! comp)
 		goto out_fail;
 
<span class="p_del">-	if ( rslots &gt; 0  &amp;&amp;  rslots &lt; 256 ) {</span>
<span class="p_add">+	if (rslots &gt; 0) {</span>
 		size_t rsize = rslots * sizeof(struct cstate);
 		comp-&gt;rstate = kzalloc(rsize, GFP_KERNEL);
 		if (! comp-&gt;rstate)
<span class="p_chunk">@@ -106,7 +110,7 @@</span> <span class="p_context"> slhc_init(int rslots, int tslots)</span>
 		comp-&gt;rslot_limit = rslots - 1;
 	}
 
<span class="p_del">-	if ( tslots &gt; 0  &amp;&amp;  tslots &lt; 256 ) {</span>
<span class="p_add">+	if (tslots &gt; 0) {</span>
 		size_t tsize = tslots * sizeof(struct cstate);
 		comp-&gt;tstate = kzalloc(tsize, GFP_KERNEL);
 		if (! comp-&gt;tstate)
<span class="p_chunk">@@ -141,7 +145,7 @@</span> <span class="p_context"> out_free2:</span>
 out_free:
 	kfree(comp);
 out_fail:
<span class="p_del">-	return NULL;</span>
<span class="p_add">+	return ERR_PTR(-ENOMEM);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c</span>
<span class="p_header">index 05387b1e2e95..a17d86a57734 100644</span>
<span class="p_header">--- a/drivers/net/slip/slip.c</span>
<span class="p_header">+++ b/drivers/net/slip/slip.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int sl_alloc_bufs(struct slip *sl, int mtu)</span>
 	if (cbuff == NULL)
 		goto err_exit;
 	slcomp = slhc_init(16, 16);
<span class="p_del">-	if (slcomp == NULL)</span>
<span class="p_add">+	if (IS_ERR(slcomp))</span>
 		goto err_exit;
 #endif
 	spin_lock_bh(&amp;sl-&gt;lock);
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index 6928448f6b7f..2b45d0168c3c 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -1845,10 +1845,10 @@</span> <span class="p_context"> static int team_vlan_rx_kill_vid(struct net_device *dev, __be16 proto, u16 vid)</span>
 	struct team *team = netdev_priv(dev);
 	struct team_port *port;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	list_for_each_entry_rcu(port, &amp;team-&gt;port_list, list)</span>
<span class="p_add">+	mutex_lock(&amp;team-&gt;lock);</span>
<span class="p_add">+	list_for_each_entry(port, &amp;team-&gt;port_list, list)</span>
 		vlan_vid_del(port-&gt;dev, proto, vid);
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_add">+	mutex_unlock(&amp;team-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/usb/cdc_mbim.c b/drivers/net/usb/cdc_mbim.c</span>
<span class="p_header">index e4b7a47a825c..5efaa9ab5af5 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_mbim.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_mbim.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> static const struct net_device_ops cdc_mbim_netdev_ops = {</span>
 	.ndo_stop             = usbnet_stop,
 	.ndo_start_xmit       = usbnet_start_xmit,
 	.ndo_tx_timeout       = usbnet_tx_timeout,
<span class="p_del">-	.ndo_change_mtu       = usbnet_change_mtu,</span>
<span class="p_add">+	.ndo_change_mtu       = cdc_ncm_change_mtu,</span>
 	.ndo_set_mac_address  = eth_mac_addr,
 	.ndo_validate_addr    = eth_validate_addr,
 	.ndo_vlan_rx_add_vid  = cdc_mbim_rx_add_vid,
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index 8067b8fbb0ee..0b481c30979b 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/netdevice.h&gt;
 #include &lt;linux/ctype.h&gt;
<span class="p_add">+#include &lt;linux/etherdevice.h&gt;</span>
 #include &lt;linux/ethtool.h&gt;
 #include &lt;linux/workqueue.h&gt;
 #include &lt;linux/mii.h&gt;
<span class="p_chunk">@@ -687,6 +688,33 @@</span> <span class="p_context"> static void cdc_ncm_free(struct cdc_ncm_ctx *ctx)</span>
 	kfree(ctx);
 }
 
<span class="p_add">+/* we need to override the usbnet change_mtu ndo for two reasons:</span>
<span class="p_add">+ *  - respect the negotiated maximum datagram size</span>
<span class="p_add">+ *  - avoid unwanted changes to rx and tx buffers</span>
<span class="p_add">+ */</span>
<span class="p_add">+int cdc_ncm_change_mtu(struct net_device *net, int new_mtu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usbnet *dev = netdev_priv(net);</span>
<span class="p_add">+	struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev-&gt;data[0];</span>
<span class="p_add">+	int maxmtu = ctx-&gt;max_datagram_size - cdc_ncm_eth_hlen(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (new_mtu &lt;= 0 || new_mtu &gt; maxmtu)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	net-&gt;mtu = new_mtu;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(cdc_ncm_change_mtu);</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct net_device_ops cdc_ncm_netdev_ops = {</span>
<span class="p_add">+	.ndo_open	     = usbnet_open,</span>
<span class="p_add">+	.ndo_stop	     = usbnet_stop,</span>
<span class="p_add">+	.ndo_start_xmit	     = usbnet_start_xmit,</span>
<span class="p_add">+	.ndo_tx_timeout	     = usbnet_tx_timeout,</span>
<span class="p_add">+	.ndo_change_mtu	     = cdc_ncm_change_mtu,</span>
<span class="p_add">+	.ndo_set_mac_address = eth_mac_addr,</span>
<span class="p_add">+	.ndo_validate_addr   = eth_validate_addr,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting)
 {
 	const struct usb_cdc_union_desc *union_desc = NULL;
<span class="p_chunk">@@ -861,6 +889,9 @@</span> <span class="p_context"> advance:</span>
 	/* add our sysfs attrs */
 	dev-&gt;net-&gt;sysfs_groups[0] = &amp;cdc_ncm_sysfs_attr_group;
 
<span class="p_add">+	/* must handle MTU changes */</span>
<span class="p_add">+	dev-&gt;net-&gt;netdev_ops = &amp;cdc_ncm_netdev_ops;</span>
<span class="p_add">+</span>
 	return 0;
 
 error2:
<span class="p_header">diff --git a/drivers/net/veth.c b/drivers/net/veth.c</span>
<span class="p_header">index c8186ffda1a3..2e61a799f32a 100644</span>
<span class="p_header">--- a/drivers/net/veth.c</span>
<span class="p_header">+++ b/drivers/net/veth.c</span>
<span class="p_chunk">@@ -117,12 +117,6 @@</span> <span class="p_context"> static netdev_tx_t veth_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		kfree_skb(skb);
 		goto drop;
 	}
<span class="p_del">-	/* don&#39;t change ip_summed == CHECKSUM_PARTIAL, as that</span>
<span class="p_del">-	 * will cause bad checksum on forwarded packets</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (skb-&gt;ip_summed == CHECKSUM_NONE &amp;&amp;</span>
<span class="p_del">-	    rcv-&gt;features &amp; NETIF_F_RXCSUM)</span>
<span class="p_del">-		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
 
 	if (likely(dev_forward_skb(rcv, skb) == NET_RX_SUCCESS)) {
 		struct pcpu_vstats *stats = this_cpu_ptr(dev-&gt;vstats);
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 0085b8df83e2..940f78e41993 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -2581,7 +2581,7 @@</span> <span class="p_context"> static int vxlan_newlink(struct net *src_net, struct net_device *dev,</span>
 			 struct nlattr *tb[], struct nlattr *data[])
 {
 	struct vxlan_net *vn = net_generic(src_net, vxlan_net_id);
<span class="p_del">-	struct vxlan_dev *vxlan = netdev_priv(dev);</span>
<span class="p_add">+	struct vxlan_dev *vxlan = netdev_priv(dev), *tmp;</span>
 	struct vxlan_rdst *dst = &amp;vxlan-&gt;default_dst;
 	__u32 vni;
 	int err;
<span class="p_chunk">@@ -2714,9 +2714,13 @@</span> <span class="p_context"> static int vxlan_newlink(struct net *src_net, struct net_device *dev,</span>
 	if (data[IFLA_VXLAN_REMCSUM_NOPARTIAL])
 		vxlan-&gt;flags |= VXLAN_F_REMCSUM_NOPARTIAL;
 
<span class="p_del">-	if (vxlan_find_vni(src_net, vni, use_ipv6 ? AF_INET6 : AF_INET,</span>
<span class="p_del">-			   vxlan-&gt;dst_port, vxlan-&gt;flags)) {</span>
<span class="p_del">-		pr_info(&quot;duplicate VNI %u\n&quot;, vni);</span>
<span class="p_add">+	list_for_each_entry(tmp, &amp;vn-&gt;vxlan_list, next) {</span>
<span class="p_add">+		if (tmp-&gt;default_dst.remote_vni == vni &amp;&amp;</span>
<span class="p_add">+		    (tmp-&gt;default_dst.remote_ip.sa.sa_family == AF_INET6 ||</span>
<span class="p_add">+		     tmp-&gt;saddr.sa.sa_family == AF_INET6) == use_ipv6 &amp;&amp;</span>
<span class="p_add">+		    tmp-&gt;dst_port == vxlan-&gt;dst_port &amp;&amp;</span>
<span class="p_add">+		    (tmp-&gt;flags &amp; VXLAN_F_RCV_FLAGS) ==</span>
<span class="p_add">+		    (vxlan-&gt;flags &amp; VXLAN_F_RCV_FLAGS))</span>
 		return -EEXIST;
 	}
 
<span class="p_header">diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c</span>
<span class="p_header">index 0866c5dfdf87..5e5b6184e720 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/netback.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/netback.c</span>
<span class="p_chunk">@@ -2007,8 +2007,11 @@</span> <span class="p_context"> static int __init netback_init(void)</span>
 	if (!xen_domain())
 		return -ENODEV;
 
<span class="p_del">-	/* Allow as many queues as there are CPUs, by default */</span>
<span class="p_del">-	xenvif_max_queues = num_online_cpus();</span>
<span class="p_add">+	/* Allow as many queues as there are CPUs if user has not</span>
<span class="p_add">+	 * specified a value.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xenvif_max_queues == 0)</span>
<span class="p_add">+		xenvif_max_queues = num_online_cpus();</span>
 
 	if (fatal_skb_slots &lt; XEN_NETBK_LEGACY_SLOTS_MAX) {
 		pr_info(&quot;fatal_skb_slots too small (%d), bump it to XEN_NETBK_LEGACY_SLOTS_MAX (%d)\n&quot;,
<span class="p_header">diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c</span>
<span class="p_header">index 52f081f4dfd5..fd51626e859e 100644</span>
<span class="p_header">--- a/drivers/net/xen-netfront.c</span>
<span class="p_header">+++ b/drivers/net/xen-netfront.c</span>
<span class="p_chunk">@@ -1710,19 +1710,19 @@</span> <span class="p_context"> static void xennet_destroy_queues(struct netfront_info *info)</span>
 }
 
 static int xennet_create_queues(struct netfront_info *info,
<span class="p_del">-				unsigned int num_queues)</span>
<span class="p_add">+				unsigned int *num_queues)</span>
 {
 	unsigned int i;
 	int ret;
 
<span class="p_del">-	info-&gt;queues = kcalloc(num_queues, sizeof(struct netfront_queue),</span>
<span class="p_add">+	info-&gt;queues = kcalloc(*num_queues, sizeof(struct netfront_queue),</span>
 			       GFP_KERNEL);
 	if (!info-&gt;queues)
 		return -ENOMEM;
 
 	rtnl_lock();
 
<span class="p_del">-	for (i = 0; i &lt; num_queues; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; *num_queues; i++) {</span>
 		struct netfront_queue *queue = &amp;info-&gt;queues[i];
 
 		queue-&gt;id = i;
<span class="p_chunk">@@ -1732,7 +1732,7 @@</span> <span class="p_context"> static int xennet_create_queues(struct netfront_info *info,</span>
 		if (ret &lt; 0) {
 			dev_warn(&amp;info-&gt;netdev-&gt;dev,
 				 &quot;only created %d queues\n&quot;, i);
<span class="p_del">-			num_queues = i;</span>
<span class="p_add">+			*num_queues = i;</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1742,11 +1742,11 @@</span> <span class="p_context"> static int xennet_create_queues(struct netfront_info *info,</span>
 			napi_enable(&amp;queue-&gt;napi);
 	}
 
<span class="p_del">-	netif_set_real_num_tx_queues(info-&gt;netdev, num_queues);</span>
<span class="p_add">+	netif_set_real_num_tx_queues(info-&gt;netdev, *num_queues);</span>
 
 	rtnl_unlock();
 
<span class="p_del">-	if (num_queues == 0) {</span>
<span class="p_add">+	if (*num_queues == 0) {</span>
 		dev_err(&amp;info-&gt;netdev-&gt;dev, &quot;no queues\n&quot;);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -1792,7 +1792,7 @@</span> <span class="p_context"> static int talk_to_netback(struct xenbus_device *dev,</span>
 	if (info-&gt;queues)
 		xennet_destroy_queues(info);
 
<span class="p_del">-	err = xennet_create_queues(info, num_queues);</span>
<span class="p_add">+	err = xennet_create_queues(info, &amp;num_queues);</span>
 	if (err &lt; 0)
 		goto destroy_ring;
 
<span class="p_chunk">@@ -2140,8 +2140,11 @@</span> <span class="p_context"> static int __init netif_init(void)</span>
 
 	pr_info(&quot;Initialising Xen virtual ethernet driver\n&quot;);
 
<span class="p_del">-	/* Allow as many queues as there are CPUs, by default */</span>
<span class="p_del">-	xennet_max_queues = num_online_cpus();</span>
<span class="p_add">+	/* Allow as many queues as there are CPUs if user has not</span>
<span class="p_add">+	 * specified a value.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xennet_max_queues == 0)</span>
<span class="p_add">+		xennet_max_queues = num_online_cpus();</span>
 
 	return xenbus_register_frontend(&amp;netfront_driver);
 }
<span class="p_header">diff --git a/drivers/parisc/iommu-helpers.h b/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">index 761e77bfce5d..e56f1569f6c3 100644</span>
<span class="p_header">--- a/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">+++ b/drivers/parisc/iommu-helpers.h</span>
<span class="p_chunk">@@ -104,7 +104,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 	struct scatterlist *contig_sg;	   /* contig chunk head */
 	unsigned long dma_offset, dma_len; /* start/len of DMA stream */
 	unsigned int n_mappings = 0;
<span class="p_del">-	unsigned int max_seg_size = dma_get_max_seg_size(dev);</span>
<span class="p_add">+	unsigned int max_seg_size = min(dma_get_max_seg_size(dev),</span>
<span class="p_add">+					(unsigned)DMA_CHUNK_SIZE);</span>
<span class="p_add">+	unsigned int max_seg_boundary = dma_get_seg_boundary(dev) + 1;</span>
<span class="p_add">+	if (max_seg_boundary)	/* check if the addition above didn&#39;t overflow */</span>
<span class="p_add">+		max_seg_size = min(max_seg_size, max_seg_boundary);</span>
 
 	while (nents &gt; 0) {
 
<span class="p_chunk">@@ -138,14 +142,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 
 			/*
 			** First make sure current dma stream won&#39;t
<span class="p_del">-			** exceed DMA_CHUNK_SIZE if we coalesce the</span>
<span class="p_add">+			** exceed max_seg_size if we coalesce the</span>
 			** next entry.
 			*/   
<span class="p_del">-			if(unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length,</span>
<span class="p_del">-					    IOVP_SIZE) &gt; DMA_CHUNK_SIZE))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (startsg-&gt;length + dma_len &gt; max_seg_size)</span>
<span class="p_add">+			if (unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length, IOVP_SIZE) &gt;</span>
<span class="p_add">+				     max_seg_size))</span>
 				break;
 
 			/*
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/obdecho/echo_client.c b/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_header">index d542e06d6cd3..10e520d6bb75 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/obdecho/echo_client.c</span>
<span class="p_chunk">@@ -1268,6 +1268,7 @@</span> <span class="p_context"> static int</span>
 echo_copyout_lsm(struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)
 {
 	struct lov_stripe_md *ulsm = _ulsm;
<span class="p_add">+	struct lov_oinfo **p;</span>
 	int nob, i;
 
 	nob = offsetof(struct lov_stripe_md, lsm_oinfo[lsm-&gt;lsm_stripe_count]);
<span class="p_chunk">@@ -1277,9 +1278,10 @@</span> <span class="p_context"> echo_copyout_lsm(struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)</span>
 	if (copy_to_user(ulsm, lsm, sizeof(*ulsm)))
 		return -EFAULT;
 
<span class="p_del">-	for (i = 0; i &lt; lsm-&gt;lsm_stripe_count; i++) {</span>
<span class="p_del">-		if (copy_to_user(ulsm-&gt;lsm_oinfo[i], lsm-&gt;lsm_oinfo[i],</span>
<span class="p_del">-				      sizeof(lsm-&gt;lsm_oinfo[0])))</span>
<span class="p_add">+	for (i = 0, p = lsm-&gt;lsm_oinfo; i &lt; lsm-&gt;lsm_stripe_count; i++, p++) {</span>
<span class="p_add">+		struct lov_oinfo __user *up;</span>
<span class="p_add">+		if (get_user(up, ulsm-&gt;lsm_oinfo + i) ||</span>
<span class="p_add">+		    copy_to_user(up, *p, sizeof(struct lov_oinfo)))</span>
 			return -EFAULT;
 	}
 	return 0;
<span class="p_chunk">@@ -1287,9 +1289,10 @@</span> <span class="p_context"> echo_copyout_lsm(struct lov_stripe_md *lsm, void *_ulsm, int ulsm_nob)</span>
 
 static int
 echo_copyin_lsm(struct echo_device *ed, struct lov_stripe_md *lsm,
<span class="p_del">-		 void *ulsm, int ulsm_nob)</span>
<span class="p_add">+		struct lov_stripe_md __user *ulsm, int ulsm_nob)</span>
 {
 	struct echo_client_obd *ec = ed-&gt;ed_ec;
<span class="p_add">+	struct lov_oinfo **p;</span>
 	int		     i;
 
 	if (ulsm_nob &lt; sizeof(*lsm))
<span class="p_chunk">@@ -1305,11 +1308,10 @@</span> <span class="p_context"> echo_copyin_lsm(struct echo_device *ed, struct lov_stripe_md *lsm,</span>
 		return -EINVAL;
 
 
<span class="p_del">-	for (i = 0; i &lt; lsm-&gt;lsm_stripe_count; i++) {</span>
<span class="p_del">-		if (copy_from_user(lsm-&gt;lsm_oinfo[i],</span>
<span class="p_del">-				       ((struct lov_stripe_md *)ulsm)-&gt; \</span>
<span class="p_del">-				       lsm_oinfo[i],</span>
<span class="p_del">-				       sizeof(lsm-&gt;lsm_oinfo[0])))</span>
<span class="p_add">+	for (i = 0, p = lsm-&gt;lsm_oinfo; i &lt; lsm-&gt;lsm_stripe_count; i++, p++) {</span>
<span class="p_add">+		struct lov_oinfo __user *up;</span>
<span class="p_add">+		if (get_user(up, ulsm-&gt;lsm_oinfo + i) ||</span>
<span class="p_add">+		    copy_from_user(*p, up, sizeof(struct lov_oinfo)))</span>
 			return -EFAULT;
 	}
 	return 0;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index d68c4a4db682..ee11b301f3da 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -1034,10 +1034,20 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	unsigned delay;
 
 	/* Continue a partial initialization */
<span class="p_del">-	if (type == HUB_INIT2)</span>
<span class="p_del">-		goto init2;</span>
<span class="p_del">-	if (type == HUB_INIT3)</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3) {</span>
<span class="p_add">+		device_lock(hub-&gt;intfdev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Was the hub disconnected while we were waiting? */</span>
<span class="p_add">+		if (hub-&gt;disconnected) {</span>
<span class="p_add">+			device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+			kref_put(&amp;hub-&gt;kref, hub_release);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (type == HUB_INIT2)</span>
<span class="p_add">+			goto init2;</span>
 		goto init3;
<span class="p_add">+	}</span>
<span class="p_add">+	kref_get(&amp;hub-&gt;kref);</span>
 
 	/* The superspeed hub except for root hub has to use Hub Depth
 	 * value as an offset into the route string to locate the bits
<span class="p_chunk">@@ -1235,6 +1245,7 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 			queue_delayed_work(system_power_efficient_wq,
 					&amp;hub-&gt;init_work,
 					msecs_to_jiffies(delay));
<span class="p_add">+			device_unlock(hub-&gt;intfdev);</span>
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
<span class="p_chunk">@@ -1256,6 +1267,11 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	/* Allow autosuspend if it was suppressed */
 	if (type &lt;= HUB_INIT3)
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
<span class="p_add">+</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3)</span>
<span class="p_add">+		device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	kref_put(&amp;hub-&gt;kref, hub_release);</span>
 }
 
 /* Implement the continuations for the delays above */
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 1e6d7579709e..f6bb118e4501 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -4794,8 +4794,16 @@</span> <span class="p_context"> int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,</span>
 	ctrl_ctx-&gt;add_flags |= cpu_to_le32(SLOT_FLAG);
 	slot_ctx = xhci_get_slot_ctx(xhci, config_cmd-&gt;in_ctx);
 	slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_HUB);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * refer to section 6.2.2: MTT should be 0 for full speed hub,</span>
<span class="p_add">+	 * but it may be already set to 1 when setup an xHCI virtual</span>
<span class="p_add">+	 * device, so clear it anyway.</span>
<span class="p_add">+	 */</span>
 	if (tt-&gt;multi)
 		slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_MTT);
<span class="p_add">+	else if (hdev-&gt;speed == USB_SPEED_FULL)</span>
<span class="p_add">+		slot_ctx-&gt;dev_info &amp;= cpu_to_le32(~DEV_MTT);</span>
<span class="p_add">+</span>
 	if (xhci-&gt;hci_version &gt; 0x95) {
 		xhci_dbg(xhci, &quot;xHCI version %x needs hub &quot;
 				&quot;TT think time and number of ports\n&quot;,
<span class="p_chunk">@@ -5046,6 +5054,10 @@</span> <span class="p_context"> static int __init xhci_hcd_init(void)</span>
 	BUILD_BUG_ON(sizeof(struct xhci_intr_reg) != 8*32/8);
 	/* xhci_run_regs has eight fields and embeds 128 xhci_intr_regs */
 	BUILD_BUG_ON(sizeof(struct xhci_run_regs) != (8+8*128)*32/8);
<span class="p_add">+</span>
<span class="p_add">+	if (usb_disabled())</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 7d4f51a32e66..59b2126b21a3 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -160,6 +160,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x17F4, 0xAAAA) }, /* Wavesense Jazz blood glucose meter */
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */</span>
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
 	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
<span class="p_header">diff --git a/drivers/usb/serial/ipaq.c b/drivers/usb/serial/ipaq.c</span>
<span class="p_header">index f51a5d52c0ed..ec1b8f2c1183 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ipaq.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ipaq.c</span>
<span class="p_chunk">@@ -531,7 +531,8 @@</span> <span class="p_context"> static int ipaq_open(struct tty_struct *tty,</span>
 	 * through. Since this has a reasonably high failure rate, we retry
 	 * several times.
 	 */
<span class="p_del">-	while (retries--) {</span>
<span class="p_add">+	while (retries) {</span>
<span class="p_add">+		retries--;</span>
 		result = usb_control_msg(serial-&gt;dev,
 				usb_sndctrlpipe(serial-&gt;dev, 0), 0x22, 0x21,
 				0x1, 0, NULL, 0, 100);
<span class="p_header">diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c</span>
<span class="p_header">index 4bd23bba816f..ee71baddbb10 100644</span>
<span class="p_header">--- a/drivers/xen/gntdev.c</span>
<span class="p_header">+++ b/drivers/xen/gntdev.c</span>
<span class="p_chunk">@@ -804,7 +804,7 @@</span> <span class="p_context"> static int gntdev_mmap(struct file *flip, struct vm_area_struct *vma)</span>
 
 	vma-&gt;vm_ops = &amp;gntdev_vmops;
 
<span class="p_del">-	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;</span>
<span class="p_add">+	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP | VM_IO;</span>
 
 	if (use_ptemod)
 		vma-&gt;vm_flags |= VM_DONTCOPY;
<span class="p_header">diff --git a/fs/direct-io.c b/fs/direct-io.c</span>
<span class="p_header">index 745d2342651a..d83a021a659f 100644</span>
<span class="p_header">--- a/fs/direct-io.c</span>
<span class="p_header">+++ b/fs/direct-io.c</span>
<span class="p_chunk">@@ -1159,6 +1159,16 @@</span> <span class="p_context"> do_blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,</span>
 		}
 	}
 
<span class="p_add">+	/* Once we sampled i_size check for reads beyond EOF */</span>
<span class="p_add">+	dio-&gt;i_size = i_size_read(inode);</span>
<span class="p_add">+	if (iov_iter_rw(iter) == READ &amp;&amp; offset &gt;= dio-&gt;i_size) {</span>
<span class="p_add">+		if (dio-&gt;flags &amp; DIO_LOCKING)</span>
<span class="p_add">+			mutex_unlock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+		kmem_cache_free(dio_cache, dio);</span>
<span class="p_add">+		retval = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * For file extending writes updating i_size before data writeouts
 	 * complete can expose uninitialized blocks in dumb filesystems.
<span class="p_chunk">@@ -1212,7 +1222,6 @@</span> <span class="p_context"> do_blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,</span>
 	sdio.next_block_for_io = -1;
 
 	dio-&gt;iocb = iocb;
<span class="p_del">-	dio-&gt;i_size = i_size_read(inode);</span>
 
 	spin_lock_init(&amp;dio-&gt;bio_lock);
 	dio-&gt;refcount = 1;
<span class="p_header">diff --git a/include/linux/filter.h b/include/linux/filter.h</span>
<span class="p_header">index fa11b3a367be..1ce6e1049a3b 100644</span>
<span class="p_header">--- a/include/linux/filter.h</span>
<span class="p_header">+++ b/include/linux/filter.h</span>
<span class="p_chunk">@@ -428,6 +428,25 @@</span> <span class="p_context"> static inline void bpf_jit_free(struct bpf_prog *fp)</span>
 
 #define BPF_ANC		BIT(15)
 
<span class="p_add">+static inline bool bpf_needs_clear_a(const struct sock_filter *first)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (first-&gt;code) {</span>
<span class="p_add">+	case BPF_RET | BPF_K:</span>
<span class="p_add">+	case BPF_LD | BPF_W | BPF_LEN:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	case BPF_LD | BPF_W | BPF_ABS:</span>
<span class="p_add">+	case BPF_LD | BPF_H | BPF_ABS:</span>
<span class="p_add">+	case BPF_LD | BPF_B | BPF_ABS:</span>
<span class="p_add">+		if (first-&gt;k == SKF_AD_OFF + SKF_AD_ALU_XOR_X)</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u16 bpf_anc_helper(const struct sock_filter *ftest)
 {
 	BUG_ON(ftest-&gt;code &amp; BPF_ANC);
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 61f4f2d5c882..9128b4e9f541 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -802,6 +802,7 @@</span> <span class="p_context"> struct user_struct {</span>
 	unsigned long mq_bytes;	/* How many bytes can be allocated to mqueue? */
 #endif
 	unsigned long locked_shm; /* How many pages of mlocked shm ? */
<span class="p_add">+	unsigned long unix_inflight;	/* How many files in flight in unix sockets */</span>
 
 #ifdef CONFIG_KEYS
 	struct key *uid_keyring;	/* UID specific keyring */
<span class="p_header">diff --git a/include/linux/skbuff.h b/include/linux/skbuff.h</span>
<span class="p_header">index 4307e20a4a4a..1f17abe23725 100644</span>
<span class="p_header">--- a/include/linux/skbuff.h</span>
<span class="p_header">+++ b/include/linux/skbuff.h</span>
<span class="p_chunk">@@ -3320,7 +3320,8 @@</span> <span class="p_context"> struct skb_gso_cb {</span>
 	int	encap_level;
 	__u16	csum_start;
 };
<span class="p_del">-#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)(skb)-&gt;cb)</span>
<span class="p_add">+#define SKB_SGO_CB_OFFSET	32</span>
<span class="p_add">+#define SKB_GSO_CB(skb) ((struct skb_gso_cb *)((skb)-&gt;cb + SKB_SGO_CB_OFFSET))</span>
 
 static inline int skb_tnl_header_len(const struct sk_buff *inner_skb)
 {
<span class="p_header">diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h</span>
<span class="p_header">index 76d1e38aabe1..0c53fd51bf9b 100644</span>
<span class="p_header">--- a/include/linux/syscalls.h</span>
<span class="p_header">+++ b/include/linux/syscalls.h</span>
<span class="p_chunk">@@ -524,7 +524,7 @@</span> <span class="p_context"> asmlinkage long sys_chown(const char __user *filename,</span>
 asmlinkage long sys_lchown(const char __user *filename,
 				uid_t user, gid_t group);
 asmlinkage long sys_fchown(unsigned int fd, uid_t user, gid_t group);
<span class="p_del">-#ifdef CONFIG_UID16</span>
<span class="p_add">+#ifdef CONFIG_HAVE_UID16</span>
 asmlinkage long sys_chown16(const char __user *filename,
 				old_uid_t user, old_gid_t group);
 asmlinkage long sys_lchown16(const char __user *filename,
<span class="p_header">diff --git a/include/linux/types.h b/include/linux/types.h</span>
<span class="p_header">index 8715287c3b1f..69c44d981da3 100644</span>
<span class="p_header">--- a/include/linux/types.h</span>
<span class="p_header">+++ b/include/linux/types.h</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> typedef __kernel_gid16_t        gid16_t;</span>
 
 typedef unsigned long		uintptr_t;
 
<span class="p_del">-#ifdef CONFIG_UID16</span>
<span class="p_add">+#ifdef CONFIG_HAVE_UID16</span>
 /* This is defined by include/asm-{arch}/posix_types.h */
 typedef __kernel_old_uid_t	old_uid_t;
 typedef __kernel_old_gid_t	old_gid_t;
<span class="p_header">diff --git a/include/linux/usb/cdc_ncm.h b/include/linux/usb/cdc_ncm.h</span>
<span class="p_header">index 7c9b484735c5..e7827ae2462c 100644</span>
<span class="p_header">--- a/include/linux/usb/cdc_ncm.h</span>
<span class="p_header">+++ b/include/linux/usb/cdc_ncm.h</span>
<span class="p_chunk">@@ -133,6 +133,7 @@</span> <span class="p_context"> struct cdc_ncm_ctx {</span>
 };
 
 u8 cdc_ncm_select_altsetting(struct usb_interface *intf);
<span class="p_add">+int cdc_ncm_change_mtu(struct net_device *net, int new_mtu);</span>
 int cdc_ncm_bind_common(struct usbnet *dev, struct usb_interface *intf, u8 data_altsetting);
 void cdc_ncm_unbind(struct usbnet *dev, struct usb_interface *intf);
 struct sk_buff *cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign);
<span class="p_header">diff --git a/include/net/inet_ecn.h b/include/net/inet_ecn.h</span>
<span class="p_header">index 84b20835b736..0dc0a51da38f 100644</span>
<span class="p_header">--- a/include/net/inet_ecn.h</span>
<span class="p_header">+++ b/include/net/inet_ecn.h</span>
<span class="p_chunk">@@ -111,11 +111,24 @@</span> <span class="p_context"> static inline void ipv4_copy_dscp(unsigned int dscp, struct iphdr *inner)</span>
 
 struct ipv6hdr;
 
<span class="p_del">-static inline int IP6_ECN_set_ce(struct ipv6hdr *iph)</span>
<span class="p_add">+/* Note:</span>
<span class="p_add">+ * IP_ECN_set_ce() has to tweak IPV4 checksum when setting CE,</span>
<span class="p_add">+ * meaning both changes have no effect on skb-&gt;csum if/when CHECKSUM_COMPLETE</span>
<span class="p_add">+ * In IPv6 case, no checksum compensates the change in IPv6 header,</span>
<span class="p_add">+ * so we have to update skb-&gt;csum.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int IP6_ECN_set_ce(struct sk_buff *skb, struct ipv6hdr *iph)</span>
 {
<span class="p_add">+	__be32 from, to;</span>
<span class="p_add">+</span>
 	if (INET_ECN_is_not_ect(ipv6_get_dsfield(iph)))
 		return 0;
<span class="p_del">-	*(__be32*)iph |= htonl(INET_ECN_CE &lt;&lt; 20);</span>
<span class="p_add">+</span>
<span class="p_add">+	from = *(__be32 *)iph;</span>
<span class="p_add">+	to = from | htonl(INET_ECN_CE &lt;&lt; 20);</span>
<span class="p_add">+	*(__be32 *)iph = to;</span>
<span class="p_add">+	if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)</span>
<span class="p_add">+		skb-&gt;csum = csum_add(csum_sub(skb-&gt;csum, from), to);</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -142,7 +155,7 @@</span> <span class="p_context"> static inline int INET_ECN_set_ce(struct sk_buff *skb)</span>
 	case cpu_to_be16(ETH_P_IPV6):
 		if (skb_network_header(skb) + sizeof(struct ipv6hdr) &lt;=
 		    skb_tail_pointer(skb))
<span class="p_del">-			return IP6_ECN_set_ce(ipv6_hdr(skb));</span>
<span class="p_add">+			return IP6_ECN_set_ce(skb, ipv6_hdr(skb));</span>
 		break;
 	}
 
<span class="p_header">diff --git a/include/net/inet_timewait_sock.h b/include/net/inet_timewait_sock.h</span>
<span class="p_header">index 360c4802288d..7682cb2ae237 100644</span>
<span class="p_header">--- a/include/net/inet_timewait_sock.h</span>
<span class="p_header">+++ b/include/net/inet_timewait_sock.h</span>
<span class="p_chunk">@@ -112,7 +112,19 @@</span> <span class="p_context"> struct inet_timewait_sock *inet_twsk_alloc(const struct sock *sk,</span>
 void __inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,
 			   struct inet_hashinfo *hashinfo);
 
<span class="p_del">-void inet_twsk_schedule(struct inet_timewait_sock *tw, const int timeo);</span>
<span class="p_add">+void __inet_twsk_schedule(struct inet_timewait_sock *tw, int timeo,</span>
<span class="p_add">+			  bool rearm);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void inet_twsk_schedule(struct inet_timewait_sock *tw, int timeo)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__inet_twsk_schedule(tw, timeo, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void inet_twsk_reschedule(struct inet_timewait_sock *tw, int timeo)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__inet_twsk_schedule(tw, timeo, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void inet_twsk_deschedule(struct inet_timewait_sock *tw);
 
 void inet_twsk_purge(struct inet_hashinfo *hashinfo,
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 47dcd3aa6e23..141d562064a7 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -1019,6 +1019,16 @@</span> <span class="p_context"> static int check_alu_op(struct reg_state *regs, struct bpf_insn *insn)</span>
 			return -EINVAL;
 		}
 
<span class="p_add">+		if ((opcode == BPF_LSH || opcode == BPF_RSH ||</span>
<span class="p_add">+		     opcode == BPF_ARSH) &amp;&amp; BPF_SRC(insn-&gt;code) == BPF_K) {</span>
<span class="p_add">+			int size = BPF_CLASS(insn-&gt;code) == BPF_ALU64 ? 64 : 32;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (insn-&gt;imm &lt; 0 || insn-&gt;imm &gt;= size) {</span>
<span class="p_add">+				verbose(&quot;invalid shift %d\n&quot;, insn-&gt;imm);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* pattern match &#39;bpf_add Rx, imm&#39; instruction */
 		if (opcode == BPF_ADD &amp;&amp; BPF_CLASS(insn-&gt;code) == BPF_ALU64 &amp;&amp;
 		    regs[insn-&gt;dst_reg].type == FRAME_PTR &amp;&amp;
<span class="p_header">diff --git a/net/batman-adv/bridge_loop_avoidance.c b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">index ac4b96eccade..bd3357e69c5c 100644</span>
<span class="p_header">--- a/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_header">+++ b/net/batman-adv/bridge_loop_avoidance.c</span>
<span class="p_chunk">@@ -112,21 +112,17 @@</span> <span class="p_context"> batadv_backbone_gw_free_ref(struct batadv_bla_backbone_gw *backbone_gw)</span>
 }
 
 /* finally deinitialize the claim */
<span class="p_del">-static void batadv_claim_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_claim_release(struct batadv_bla_claim *claim)</span>
 {
<span class="p_del">-	struct batadv_bla_claim *claim;</span>
<span class="p_del">-</span>
<span class="p_del">-	claim = container_of(rcu, struct batadv_bla_claim, rcu);</span>
<span class="p_del">-</span>
 	batadv_backbone_gw_free_ref(claim-&gt;backbone_gw);
<span class="p_del">-	kfree(claim);</span>
<span class="p_add">+	kfree_rcu(claim, rcu);</span>
 }
 
 /* free a claim, call claim_free_rcu if its the last reference */
 static void batadv_claim_free_ref(struct batadv_bla_claim *claim)
 {
 	if (atomic_dec_and_test(&amp;claim-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;claim-&gt;rcu, batadv_claim_free_rcu);</span>
<span class="p_add">+		batadv_claim_release(claim);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/batman-adv/hard-interface.h b/net/batman-adv/hard-interface.h</span>
<span class="p_header">index 1918cd50b62e..b6bff9c1877a 100644</span>
<span class="p_header">--- a/net/batman-adv/hard-interface.h</span>
<span class="p_header">+++ b/net/batman-adv/hard-interface.h</span>
<span class="p_chunk">@@ -64,18 +64,6 @@</span> <span class="p_context"> batadv_hardif_free_ref(struct batadv_hard_iface *hard_iface)</span>
 		call_rcu(&amp;hard_iface-&gt;rcu, batadv_hardif_free_rcu);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_hardif_free_ref_now - decrement the hard interface refcounter and</span>
<span class="p_del">- *  possibly free it (without rcu callback)</span>
<span class="p_del">- * @hard_iface: the hard interface to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void</span>
<span class="p_del">-batadv_hardif_free_ref_now(struct batadv_hard_iface *hard_iface)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;hard_iface-&gt;refcount))</span>
<span class="p_del">-		batadv_hardif_free_rcu(&amp;hard_iface-&gt;rcu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline struct batadv_hard_iface *
 batadv_primary_if_get_selected(struct batadv_priv *bat_priv)
 {
<span class="p_header">diff --git a/net/batman-adv/network-coding.c b/net/batman-adv/network-coding.c</span>
<span class="p_header">index a449195c5b2b..2fbd3a6bde9a 100644</span>
<span class="p_header">--- a/net/batman-adv/network-coding.c</span>
<span class="p_header">+++ b/net/batman-adv/network-coding.c</span>
<span class="p_chunk">@@ -175,28 +175,25 @@</span> <span class="p_context"> void batadv_nc_init_orig(struct batadv_orig_node *orig_node)</span>
 }
 
 /**
<span class="p_del">- * batadv_nc_node_free_rcu - rcu callback to free an nc node and remove</span>
<span class="p_del">- *  its refcount on the orig_node</span>
<span class="p_del">- * @rcu: rcu pointer of the nc node</span>
<span class="p_add">+ * batadv_nc_node_release - release nc_node from lists and queue for free after</span>
<span class="p_add">+ *  rcu grace period</span>
<span class="p_add">+ * @nc_node: the nc node to free</span>
  */
<span class="p_del">-static void batadv_nc_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_nc_node_release(struct batadv_nc_node *nc_node)</span>
 {
<span class="p_del">-	struct batadv_nc_node *nc_node;</span>
<span class="p_del">-</span>
<span class="p_del">-	nc_node = container_of(rcu, struct batadv_nc_node, rcu);</span>
 	batadv_orig_node_free_ref(nc_node-&gt;orig_node);
<span class="p_del">-	kfree(nc_node);</span>
<span class="p_add">+	kfree_rcu(nc_node, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_nc_node_free_ref - decrements the nc node refcounter and possibly</span>
<span class="p_del">- * frees it</span>
<span class="p_add">+ * batadv_nc_node_free_ref - decrement the nc node refcounter and possibly</span>
<span class="p_add">+ *  release it</span>
  * @nc_node: the nc node to free
  */
 static void batadv_nc_node_free_ref(struct batadv_nc_node *nc_node)
 {
 	if (atomic_dec_and_test(&amp;nc_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;nc_node-&gt;rcu, batadv_nc_node_free_rcu);</span>
<span class="p_add">+		batadv_nc_node_release(nc_node);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c</span>
<span class="p_header">index dfae97408628..77ea1d4de2ba 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.c</span>
<span class="p_header">+++ b/net/batman-adv/originator.c</span>
<span class="p_chunk">@@ -150,86 +150,58 @@</span> <span class="p_context"> err:</span>
 }
 
 /**
<span class="p_del">- * batadv_neigh_ifinfo_free_rcu - free the neigh_ifinfo object</span>
<span class="p_del">- * @rcu: rcu pointer of the neigh_ifinfo object</span>
<span class="p_del">- */</span>
<span class="p_del">-static void batadv_neigh_ifinfo_free_rcu(struct rcu_head *rcu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct batadv_neigh_ifinfo *neigh_ifinfo;</span>
<span class="p_del">-</span>
<span class="p_del">-	neigh_ifinfo = container_of(rcu, struct batadv_neigh_ifinfo, rcu);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (neigh_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)</span>
<span class="p_del">-		batadv_hardif_free_ref_now(neigh_ifinfo-&gt;if_outgoing);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(neigh_ifinfo);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_neigh_ifinfo_free_now - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the neigh_ifinfo (without rcu callback)</span>
<span class="p_add">+ * batadv_neigh_ifinfo_release - release neigh_ifinfo from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
  * @neigh_ifinfo: the neigh_ifinfo object to release
  */
 static void
<span class="p_del">-batadv_neigh_ifinfo_free_ref_now(struct batadv_neigh_ifinfo *neigh_ifinfo)</span>
<span class="p_add">+batadv_neigh_ifinfo_release(struct batadv_neigh_ifinfo *neigh_ifinfo)</span>
 {
<span class="p_del">-	if (atomic_dec_and_test(&amp;neigh_ifinfo-&gt;refcount))</span>
<span class="p_del">-		batadv_neigh_ifinfo_free_rcu(&amp;neigh_ifinfo-&gt;rcu);</span>
<span class="p_add">+	if (neigh_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)</span>
<span class="p_add">+		batadv_hardif_free_ref(neigh_ifinfo-&gt;if_outgoing);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree_rcu(neigh_ifinfo, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_neigh_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_add">+ * batadv_neigh_ifinfo_free_ref - decrement the refcounter and possibly release</span>
  *  the neigh_ifinfo
  * @neigh_ifinfo: the neigh_ifinfo object to release
  */
 void batadv_neigh_ifinfo_free_ref(struct batadv_neigh_ifinfo *neigh_ifinfo)
 {
 	if (atomic_dec_and_test(&amp;neigh_ifinfo-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;neigh_ifinfo-&gt;rcu, batadv_neigh_ifinfo_free_rcu);</span>
<span class="p_add">+		batadv_neigh_ifinfo_release(neigh_ifinfo);</span>
 }
 
 /**
<span class="p_del">- * batadv_neigh_node_free_rcu - free the neigh_node</span>
<span class="p_del">- * @rcu: rcu pointer of the neigh_node</span>
<span class="p_add">+ * batadv_neigh_node_release - release neigh_node from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @neigh_node: neigh neighbor to free</span>
  */
<span class="p_del">-static void batadv_neigh_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_neigh_node_release(struct batadv_neigh_node *neigh_node)</span>
 {
 	struct hlist_node *node_tmp;
<span class="p_del">-	struct batadv_neigh_node *neigh_node;</span>
 	struct batadv_neigh_ifinfo *neigh_ifinfo;
 
<span class="p_del">-	neigh_node = container_of(rcu, struct batadv_neigh_node, rcu);</span>
<span class="p_del">-</span>
 	hlist_for_each_entry_safe(neigh_ifinfo, node_tmp,
 				  &amp;neigh_node-&gt;ifinfo_list, list) {
<span class="p_del">-		batadv_neigh_ifinfo_free_ref_now(neigh_ifinfo);</span>
<span class="p_add">+		batadv_neigh_ifinfo_free_ref(neigh_ifinfo);</span>
 	}
<span class="p_del">-	batadv_hardif_free_ref_now(neigh_node-&gt;if_incoming);</span>
<span class="p_add">+	batadv_hardif_free_ref(neigh_node-&gt;if_incoming);</span>
 
<span class="p_del">-	kfree(neigh_node);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_neigh_node_free_ref_now - decrement the neighbors refcounter</span>
<span class="p_del">- *  and possibly free it (without rcu callback)</span>
<span class="p_del">- * @neigh_node: neigh neighbor to free</span>
<span class="p_del">- */</span>
<span class="p_del">-static void</span>
<span class="p_del">-batadv_neigh_node_free_ref_now(struct batadv_neigh_node *neigh_node)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;neigh_node-&gt;refcount))</span>
<span class="p_del">-		batadv_neigh_node_free_rcu(&amp;neigh_node-&gt;rcu);</span>
<span class="p_add">+	kfree_rcu(neigh_node, rcu);</span>
 }
 
 /**
  * batadv_neigh_node_free_ref - decrement the neighbors refcounter
<span class="p_del">- *  and possibly free it</span>
<span class="p_add">+ *  and possibly release it</span>
  * @neigh_node: neigh neighbor to free
  */
 void batadv_neigh_node_free_ref(struct batadv_neigh_node *neigh_node)
 {
 	if (atomic_dec_and_test(&amp;neigh_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;neigh_node-&gt;rcu, batadv_neigh_node_free_rcu);</span>
<span class="p_add">+		batadv_neigh_node_release(neigh_node);</span>
 }
 
 /**
<span class="p_chunk">@@ -495,108 +467,99 @@</span> <span class="p_context"> batadv_neigh_node_get(const struct batadv_orig_node *orig_node,</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_rcu - free the orig_ifinfo object</span>
<span class="p_del">- * @rcu: rcu pointer of the orig_ifinfo object</span>
<span class="p_add">+ * batadv_orig_ifinfo_release - release orig_ifinfo from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @orig_ifinfo: the orig_ifinfo object to release</span>
  */
<span class="p_del">-static void batadv_orig_ifinfo_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+static void batadv_orig_ifinfo_release(struct batadv_orig_ifinfo *orig_ifinfo)</span>
 {
<span class="p_del">-	struct batadv_orig_ifinfo *orig_ifinfo;</span>
 	struct batadv_neigh_node *router;
 
<span class="p_del">-	orig_ifinfo = container_of(rcu, struct batadv_orig_ifinfo, rcu);</span>
<span class="p_del">-</span>
 	if (orig_ifinfo-&gt;if_outgoing != BATADV_IF_DEFAULT)
<span class="p_del">-		batadv_hardif_free_ref_now(orig_ifinfo-&gt;if_outgoing);</span>
<span class="p_add">+		batadv_hardif_free_ref(orig_ifinfo-&gt;if_outgoing);</span>
 
 	/* this is the last reference to this object */
 	router = rcu_dereference_protected(orig_ifinfo-&gt;router, true);
 	if (router)
<span class="p_del">-		batadv_neigh_node_free_ref_now(router);</span>
<span class="p_del">-	kfree(orig_ifinfo);</span>
<span class="p_add">+		batadv_neigh_node_free_ref(router);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree_rcu(orig_ifinfo, rcu);</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the orig_ifinfo (without rcu callback)</span>
<span class="p_add">+ * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly release</span>
<span class="p_add">+ *  the orig_ifinfo</span>
  * @orig_ifinfo: the orig_ifinfo object to release
  */
<span class="p_del">-static void</span>
<span class="p_del">-batadv_orig_ifinfo_free_ref_now(struct batadv_orig_ifinfo *orig_ifinfo)</span>
<span class="p_add">+void batadv_orig_ifinfo_free_ref(struct batadv_orig_ifinfo *orig_ifinfo)</span>
 {
 	if (atomic_dec_and_test(&amp;orig_ifinfo-&gt;refcount))
<span class="p_del">-		batadv_orig_ifinfo_free_rcu(&amp;orig_ifinfo-&gt;rcu);</span>
<span class="p_add">+		batadv_orig_ifinfo_release(orig_ifinfo);</span>
 }
 
 /**
<span class="p_del">- * batadv_orig_ifinfo_free_ref - decrement the refcounter and possibly free</span>
<span class="p_del">- *  the orig_ifinfo</span>
<span class="p_del">- * @orig_ifinfo: the orig_ifinfo object to release</span>
<span class="p_add">+ * batadv_orig_node_free_rcu - free the orig_node</span>
<span class="p_add">+ * @rcu: rcu pointer of the orig_node</span>
  */
<span class="p_del">-void batadv_orig_ifinfo_free_ref(struct batadv_orig_ifinfo *orig_ifinfo)</span>
<span class="p_add">+static void batadv_orig_node_free_rcu(struct rcu_head *rcu)</span>
 {
<span class="p_del">-	if (atomic_dec_and_test(&amp;orig_ifinfo-&gt;refcount))</span>
<span class="p_del">-		call_rcu(&amp;orig_ifinfo-&gt;rcu, batadv_orig_ifinfo_free_rcu);</span>
<span class="p_add">+	struct batadv_orig_node *orig_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	orig_node = container_of(rcu, struct batadv_orig_node, rcu);</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_mcast_purge_orig(orig_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	batadv_frag_purge_orig(orig_node, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free)</span>
<span class="p_add">+		orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free(orig_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(orig_node-&gt;tt_buff);</span>
<span class="p_add">+	kfree(orig_node);</span>
 }
 
<span class="p_del">-static void batadv_orig_node_free_rcu(struct rcu_head *rcu)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_orig_node_release - release orig_node from lists and queue for</span>
<span class="p_add">+ *  free after rcu grace period</span>
<span class="p_add">+ * @orig_node: the orig node to free</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void batadv_orig_node_release(struct batadv_orig_node *orig_node)</span>
 {
 	struct hlist_node *node_tmp;
 	struct batadv_neigh_node *neigh_node;
<span class="p_del">-	struct batadv_orig_node *orig_node;</span>
 	struct batadv_orig_ifinfo *orig_ifinfo;
 
<span class="p_del">-	orig_node = container_of(rcu, struct batadv_orig_node, rcu);</span>
<span class="p_del">-</span>
 	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
 	/* for all neighbors towards this originator ... */
 	hlist_for_each_entry_safe(neigh_node, node_tmp,
 				  &amp;orig_node-&gt;neigh_list, list) {
 		hlist_del_rcu(&amp;neigh_node-&gt;list);
<span class="p_del">-		batadv_neigh_node_free_ref_now(neigh_node);</span>
<span class="p_add">+		batadv_neigh_node_free_ref(neigh_node);</span>
 	}
 
 	hlist_for_each_entry_safe(orig_ifinfo, node_tmp,
 				  &amp;orig_node-&gt;ifinfo_list, list) {
 		hlist_del_rcu(&amp;orig_ifinfo-&gt;list);
<span class="p_del">-		batadv_orig_ifinfo_free_ref_now(orig_ifinfo);</span>
<span class="p_add">+		batadv_orig_ifinfo_free_ref(orig_ifinfo);</span>
 	}
 	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
<span class="p_del">-	batadv_mcast_purge_orig(orig_node);</span>
<span class="p_del">-</span>
 	/* Free nc_nodes */
 	batadv_nc_purge_orig(orig_node-&gt;bat_priv, orig_node, NULL);
 
<span class="p_del">-	batadv_frag_purge_orig(orig_node, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free)</span>
<span class="p_del">-		orig_node-&gt;bat_priv-&gt;bat_algo_ops-&gt;bat_orig_free(orig_node);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(orig_node-&gt;tt_buff);</span>
<span class="p_del">-	kfree(orig_node);</span>
<span class="p_add">+	call_rcu(&amp;orig_node-&gt;rcu, batadv_orig_node_free_rcu);</span>
 }
 
 /**
  * batadv_orig_node_free_ref - decrement the orig node refcounter and possibly
<span class="p_del">- * schedule an rcu callback for freeing it</span>
<span class="p_add">+ *  release it</span>
  * @orig_node: the orig node to free
  */
 void batadv_orig_node_free_ref(struct batadv_orig_node *orig_node)
 {
 	if (atomic_dec_and_test(&amp;orig_node-&gt;refcount))
<span class="p_del">-		call_rcu(&amp;orig_node-&gt;rcu, batadv_orig_node_free_rcu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * batadv_orig_node_free_ref_now - decrement the orig node refcounter and</span>
<span class="p_del">- * possibly free it (without rcu callback)</span>
<span class="p_del">- * @orig_node: the orig node to free</span>
<span class="p_del">- */</span>
<span class="p_del">-void batadv_orig_node_free_ref_now(struct batadv_orig_node *orig_node)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;orig_node-&gt;refcount))</span>
<span class="p_del">-		batadv_orig_node_free_rcu(&amp;orig_node-&gt;rcu);</span>
<span class="p_add">+		batadv_orig_node_release(orig_node);</span>
 }
 
 void batadv_originator_free(struct batadv_priv *bat_priv)
<span class="p_header">diff --git a/net/batman-adv/originator.h b/net/batman-adv/originator.h</span>
<span class="p_header">index aa4a43696295..28b751ad549c 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.h</span>
<span class="p_header">+++ b/net/batman-adv/originator.h</span>
<span class="p_chunk">@@ -25,7 +25,6 @@</span> <span class="p_context"> int batadv_originator_init(struct batadv_priv *bat_priv);</span>
 void batadv_originator_free(struct batadv_priv *bat_priv);
 void batadv_purge_orig_ref(struct batadv_priv *bat_priv);
 void batadv_orig_node_free_ref(struct batadv_orig_node *orig_node);
<span class="p_del">-void batadv_orig_node_free_ref_now(struct batadv_orig_node *orig_node);</span>
 struct batadv_orig_node *batadv_orig_node_new(struct batadv_priv *bat_priv,
 					      const uint8_t *addr);
 struct batadv_neigh_node *
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index 4f2a9d2c56db..ddd62c9af5b4 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -219,20 +219,6 @@</span> <span class="p_context"> int batadv_tt_global_hash_count(struct batadv_priv *bat_priv,</span>
 	return count;
 }
 
<span class="p_del">-static void batadv_tt_orig_list_entry_free_rcu(struct rcu_head *rcu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct batadv_tt_orig_list_entry *orig_entry;</span>
<span class="p_del">-</span>
<span class="p_del">-	orig_entry = container_of(rcu, struct batadv_tt_orig_list_entry, rcu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We are in an rcu callback here, therefore we cannot use</span>
<span class="p_del">-	 * batadv_orig_node_free_ref() and its call_rcu():</span>
<span class="p_del">-	 * An rcu_barrier() wouldn&#39;t wait for that to finish</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	batadv_orig_node_free_ref_now(orig_entry-&gt;orig_node);</span>
<span class="p_del">-	kfree(orig_entry);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * batadv_tt_local_size_mod - change the size by v of the local table identified
  *  by vid
<span class="p_chunk">@@ -328,13 +314,25 @@</span> <span class="p_context"> static void batadv_tt_global_size_dec(struct batadv_orig_node *orig_node,</span>
 	batadv_tt_global_size_mod(orig_node, vid, -1);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_tt_orig_list_entry_release - release tt orig entry from lists and</span>
<span class="p_add">+ *  queue for free after rcu grace period</span>
<span class="p_add">+ * @orig_entry: tt orig entry to be free&#39;d</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+batadv_tt_orig_list_entry_release(struct batadv_tt_orig_list_entry *orig_entry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	batadv_orig_node_free_ref(orig_entry-&gt;orig_node);</span>
<span class="p_add">+	kfree_rcu(orig_entry, rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void
 batadv_tt_orig_list_entry_free_ref(struct batadv_tt_orig_list_entry *orig_entry)
 {
 	if (!atomic_dec_and_test(&amp;orig_entry-&gt;refcount))
 		return;
 
<span class="p_del">-	call_rcu(&amp;orig_entry-&gt;rcu, batadv_tt_orig_list_entry_free_rcu);</span>
<span class="p_add">+	batadv_tt_orig_list_entry_release(orig_entry);</span>
 }
 
 /**
<span class="p_header">diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c</span>
<span class="p_header">index 4ff77a16956c..3d6c8e222391 100644</span>
<span class="p_header">--- a/net/bridge/br_device.c</span>
<span class="p_header">+++ b/net/bridge/br_device.c</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"></span>
 const struct nf_br_ops __rcu *nf_br_ops __read_mostly;
 EXPORT_SYMBOL_GPL(nf_br_ops);
 
<span class="p_add">+static struct lock_class_key bridge_netdev_addr_lock_key;</span>
<span class="p_add">+</span>
 /* net device transmit always called with BH disabled */
 netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
<span class="p_chunk">@@ -87,6 +89,11 @@</span> <span class="p_context"> out:</span>
 	return NETDEV_TX_OK;
 }
 
<span class="p_add">+static void br_set_lockdep_class(struct net_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	lockdep_set_class(&amp;dev-&gt;addr_list_lock, &amp;bridge_netdev_addr_lock_key);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int br_dev_init(struct net_device *dev)
 {
 	struct net_bridge *br = netdev_priv(dev);
<span class="p_chunk">@@ -99,6 +106,7 @@</span> <span class="p_context"> static int br_dev_init(struct net_device *dev)</span>
 	err = br_vlan_init(br);
 	if (err)
 		free_percpu(br-&gt;stats);
<span class="p_add">+	br_set_lockdep_class(dev);</span>
 
 	return err;
 }
<span class="p_header">diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c</span>
<span class="p_header">index 7832d07f48f6..ce658abdc2c8 100644</span>
<span class="p_header">--- a/net/bridge/br_stp_if.c</span>
<span class="p_header">+++ b/net/bridge/br_stp_if.c</span>
<span class="p_chunk">@@ -128,7 +128,10 @@</span> <span class="p_context"> static void br_stp_start(struct net_bridge *br)</span>
 	char *argv[] = { BR_STP_PROG, br-&gt;dev-&gt;name, &quot;start&quot;, NULL };
 	char *envp[] = { NULL };
 
<span class="p_del">-	r = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);</span>
<span class="p_add">+	if (net_eq(dev_net(br-&gt;dev), &amp;init_net))</span>
<span class="p_add">+		r = call_usermodehelper(BR_STP_PROG, argv, envp, UMH_WAIT_PROC);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		r = -ENOENT;</span>
 
 	spin_lock_bh(&amp;br-&gt;lock);
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index a42b232805a5..185a3398c651 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2479,6 +2479,8 @@</span> <span class="p_context"> static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)</span>
  *
  *	It may return NULL if the skb requires no segmentation.  This is
  *	only possible when GSO is used for verifying header integrity.
<span class="p_add">+ *</span>
<span class="p_add">+ *	Segmentation preserves SKB_SGO_CB_OFFSET bytes of previous skb cb.</span>
  */
 struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 				  netdev_features_t features, bool tx_path)
<span class="p_chunk">@@ -2493,6 +2495,9 @@</span> <span class="p_context"> struct sk_buff *__skb_gso_segment(struct sk_buff *skb,</span>
 			return ERR_PTR(err);
 	}
 
<span class="p_add">+	BUILD_BUG_ON(SKB_SGO_CB_OFFSET +</span>
<span class="p_add">+		     sizeof(*SKB_GSO_CB(skb)) &gt; sizeof(skb-&gt;cb));</span>
<span class="p_add">+</span>
 	SKB_GSO_CB(skb)-&gt;mac_offset = skb_headroom(skb);
 	SKB_GSO_CB(skb)-&gt;encap_level = 0;
 
<span class="p_header">diff --git a/net/core/dst.c b/net/core/dst.c</span>
<span class="p_header">index f8db4032d45a..540066cb33ef 100644</span>
<span class="p_header">--- a/net/core/dst.c</span>
<span class="p_header">+++ b/net/core/dst.c</span>
<span class="p_chunk">@@ -282,10 +282,11 @@</span> <span class="p_context"> void dst_release(struct dst_entry *dst)</span>
 {
 	if (dst) {
 		int newrefcnt;
<span class="p_add">+		unsigned short nocache = dst-&gt;flags &amp; DST_NOCACHE;</span>
 
 		newrefcnt = atomic_dec_return(&amp;dst-&gt;__refcnt);
 		WARN_ON(newrefcnt &lt; 0);
<span class="p_del">-		if (!newrefcnt &amp;&amp; unlikely(dst-&gt;flags &amp; DST_NOCACHE))</span>
<span class="p_add">+		if (!newrefcnt &amp;&amp; unlikely(nocache))</span>
 			call_rcu(&amp;dst-&gt;rcu_head, dst_destroy_rcu);
 	}
 }
<span class="p_header">diff --git a/net/core/filter.c b/net/core/filter.c</span>
<span class="p_header">index 0fa2613b5e35..238bb3f9c51d 100644</span>
<span class="p_header">--- a/net/core/filter.c</span>
<span class="p_header">+++ b/net/core/filter.c</span>
<span class="p_chunk">@@ -775,6 +775,11 @@</span> <span class="p_context"> int bpf_check_classic(const struct sock_filter *filter, unsigned int flen)</span>
 			if (ftest-&gt;k == 0)
 				return -EINVAL;
 			break;
<span class="p_add">+		case BPF_ALU | BPF_LSH | BPF_K:</span>
<span class="p_add">+		case BPF_ALU | BPF_RSH | BPF_K:</span>
<span class="p_add">+			if (ftest-&gt;k &gt;= 32)</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			break;</span>
 		case BPF_LD | BPF_MEM:
 		case BPF_LDX | BPF_MEM:
 		case BPF_ST:
<span class="p_header">diff --git a/net/dccp/minisocks.c b/net/dccp/minisocks.c</span>
<span class="p_header">index 30addee2dd03..838f524cf11a 100644</span>
<span class="p_header">--- a/net/dccp/minisocks.c</span>
<span class="p_header">+++ b/net/dccp/minisocks.c</span>
<span class="p_chunk">@@ -48,8 +48,6 @@</span> <span class="p_context"> void dccp_time_wait(struct sock *sk, int state, int timeo)</span>
 			tw-&gt;tw_ipv6only = sk-&gt;sk_ipv6only;
 		}
 #endif
<span class="p_del">-		/* Linkage updates. */</span>
<span class="p_del">-		__inet_twsk_hashdance(tw, sk, &amp;dccp_hashinfo);</span>
 
 		/* Get the TIME_WAIT timeout firing. */
 		if (timeo &lt; rto)
<span class="p_chunk">@@ -60,6 +58,8 @@</span> <span class="p_context"> void dccp_time_wait(struct sock *sk, int state, int timeo)</span>
 			timeo = DCCP_TIMEWAIT_LEN;
 
 		inet_twsk_schedule(tw, timeo);
<span class="p_add">+		/* Linkage updates. */</span>
<span class="p_add">+		__inet_twsk_hashdance(tw, sk, &amp;dccp_hashinfo);</span>
 		inet_twsk_put(tw);
 	} else {
 		/* Sorry, if we&#39;re out of memory, just CLOSE this
<span class="p_header">diff --git a/net/ipv4/inet_timewait_sock.c b/net/ipv4/inet_timewait_sock.c</span>
<span class="p_header">index 00ec8d5d7e7e..bb96c1c4edd6 100644</span>
<span class="p_header">--- a/net/ipv4/inet_timewait_sock.c</span>
<span class="p_header">+++ b/net/ipv4/inet_timewait_sock.c</span>
<span class="p_chunk">@@ -153,13 +153,15 @@</span> <span class="p_context"> void __inet_twsk_hashdance(struct inet_timewait_sock *tw, struct sock *sk,</span>
 	/*
 	 * Step 2: Hash TW into tcp ehash chain.
 	 * Notes :
<span class="p_del">-	 * - tw_refcnt is set to 3 because :</span>
<span class="p_add">+	 * - tw_refcnt is set to 4 because :</span>
 	 * - We have one reference from bhash chain.
 	 * - We have one reference from ehash chain.
<span class="p_add">+	 * - We have one reference from timer.</span>
<span class="p_add">+	 * - One reference for ourself (our caller will release it).</span>
 	 * We can use atomic_set() because prior spin_lock()/spin_unlock()
 	 * committed into memory all tw fields.
 	 */
<span class="p_del">-	atomic_set(&amp;tw-&gt;tw_refcnt, 1 + 1 + 1);</span>
<span class="p_add">+	atomic_set(&amp;tw-&gt;tw_refcnt, 4);</span>
 	inet_twsk_add_node_rcu(tw, &amp;ehead-&gt;chain);
 
 	/* Step 3: Remove SK from hash chain */
<span class="p_chunk">@@ -243,7 +245,7 @@</span> <span class="p_context"> void inet_twsk_deschedule(struct inet_timewait_sock *tw)</span>
 }
 EXPORT_SYMBOL(inet_twsk_deschedule);
 
<span class="p_del">-void inet_twsk_schedule(struct inet_timewait_sock *tw, const int timeo)</span>
<span class="p_add">+void __inet_twsk_schedule(struct inet_timewait_sock *tw, int timeo, bool rearm)</span>
 {
 	/* timeout := RTO * 3.5
 	 *
<span class="p_chunk">@@ -271,12 +273,14 @@</span> <span class="p_context"> void inet_twsk_schedule(struct inet_timewait_sock *tw, const int timeo)</span>
 	 */
 
 	tw-&gt;tw_kill = timeo &lt;= 4*HZ;
<span class="p_del">-	if (!mod_timer_pinned(&amp;tw-&gt;tw_timer, jiffies + timeo)) {</span>
<span class="p_del">-		atomic_inc(&amp;tw-&gt;tw_refcnt);</span>
<span class="p_add">+	if (!rearm) {</span>
<span class="p_add">+		BUG_ON(mod_timer_pinned(&amp;tw-&gt;tw_timer, jiffies + timeo));</span>
 		atomic_inc(&amp;tw-&gt;tw_dr-&gt;tw_count);
<span class="p_add">+	} else {</span>
<span class="p_add">+		mod_timer_pending(&amp;tw-&gt;tw_timer, jiffies + timeo);</span>
 	}
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(inet_twsk_schedule);</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(__inet_twsk_schedule);</span>
 
 void inet_twsk_purge(struct inet_hashinfo *hashinfo,
 		     struct inet_timewait_death_row *twdr, int family)
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index c65b93a7b711..51573f8a39bc 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -235,6 +235,7 @@</span> <span class="p_context"> static int ip_finish_output_gso(struct sock *sk, struct sk_buff *skb)</span>
 	 * from host network stack.
 	 */
 	features = netif_skb_features(skb);
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IPCB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = skb_gso_segment(skb, features &amp; ~NETIF_F_GSO_MASK);
 	if (IS_ERR_OR_NULL(segs)) {
 		kfree_skb(skb);
<span class="p_chunk">@@ -893,7 +894,7 @@</span> <span class="p_context"> static int __ip_append_data(struct sock *sk,</span>
 	if (((length &gt; mtu) || (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !sk-&gt;sk_no_check_tx) {</span>
 		err = ip_ufo_append_data(sk, queue, getfrag, from, length,
 					 hh_len, fragheaderlen, transhdrlen,
 					 maxfraglen, flags);
<span class="p_header">diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">index 17e7339ee5ca..fec2907b85e8 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_minisocks.c</span>
<span class="p_chunk">@@ -163,9 +163,9 @@</span> <span class="p_context"> kill_with_rst:</span>
 		if (tcp_death_row.sysctl_tw_recycle &amp;&amp;
 		    tcptw-&gt;tw_ts_recent_stamp &amp;&amp;
 		    tcp_tw_remember_stamp(tw))
<span class="p_del">-			inet_twsk_schedule(tw, tw-&gt;tw_timeout);</span>
<span class="p_add">+			inet_twsk_reschedule(tw, tw-&gt;tw_timeout);</span>
 		else
<span class="p_del">-			inet_twsk_schedule(tw, TCP_TIMEWAIT_LEN);</span>
<span class="p_add">+			inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span>
 		return TCP_TW_ACK;
 	}
 
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> kill:</span>
 				return TCP_TW_SUCCESS;
 			}
 		}
<span class="p_del">-		inet_twsk_schedule(tw, TCP_TIMEWAIT_LEN);</span>
<span class="p_add">+		inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span>
 
 		if (tmp_opt.saw_tstamp) {
 			tcptw-&gt;tw_ts_recent	  = tmp_opt.rcv_tsval;
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> kill:</span>
 		 * Do not reschedule in the last case.
 		 */
 		if (paws_reject || th-&gt;ack)
<span class="p_del">-			inet_twsk_schedule(tw, TCP_TIMEWAIT_LEN);</span>
<span class="p_add">+			inet_twsk_reschedule(tw, TCP_TIMEWAIT_LEN);</span>
 
 		return tcp_timewait_check_oow_rate_limit(
 			tw, skb, LINUX_MIB_TCPACKSKIPPEDTIMEWAIT);
<span class="p_chunk">@@ -324,9 +324,6 @@</span> <span class="p_context"> void tcp_time_wait(struct sock *sk, int state, int timeo)</span>
 		} while (0);
 #endif
 
<span class="p_del">-		/* Linkage updates. */</span>
<span class="p_del">-		__inet_twsk_hashdance(tw, sk, &amp;tcp_hashinfo);</span>
<span class="p_del">-</span>
 		/* Get the TIME_WAIT timeout firing. */
 		if (timeo &lt; rto)
 			timeo = rto;
<span class="p_chunk">@@ -340,6 +337,8 @@</span> <span class="p_context"> void tcp_time_wait(struct sock *sk, int state, int timeo)</span>
 		}
 
 		inet_twsk_schedule(tw, timeo);
<span class="p_add">+		/* Linkage updates. */</span>
<span class="p_add">+		__inet_twsk_hashdance(tw, sk, &amp;tcp_hashinfo);</span>
 		inet_twsk_put(tw);
 	} else {
 		/* Sorry, if we&#39;re out of memory, just CLOSE this
<span class="p_header">diff --git a/net/ipv4/tcp_yeah.c b/net/ipv4/tcp_yeah.c</span>
<span class="p_header">index 17d35662930d..3e6a472e6b88 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_yeah.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_yeah.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static u32 tcp_yeah_ssthresh(struct sock *sk)</span>
 	yeah-&gt;fast_count = 0;
 	yeah-&gt;reno_count = max(yeah-&gt;reno_count&gt;&gt;1, 2U);
 
<span class="p_del">-	return tp-&gt;snd_cwnd - reduction;</span>
<span class="p_add">+	return max_t(int, tp-&gt;snd_cwnd - reduction, 2);</span>
 }
 
 static struct tcp_congestion_ops tcp_yeah __read_mostly = {
<span class="p_header">diff --git a/net/ipv4/xfrm4_policy.c b/net/ipv4/xfrm4_policy.c</span>
<span class="p_header">index bff69746e05f..78526087126d 100644</span>
<span class="p_header">--- a/net/ipv4/xfrm4_policy.c</span>
<span class="p_header">+++ b/net/ipv4/xfrm4_policy.c</span>
<span class="p_chunk">@@ -230,7 +230,7 @@</span> <span class="p_context"> static void xfrm4_dst_ifdown(struct dst_entry *dst, struct net_device *dev,</span>
 	xfrm_dst_ifdown(dst, dev);
 }
 
<span class="p_del">-static struct dst_ops xfrm4_dst_ops = {</span>
<span class="p_add">+static struct dst_ops xfrm4_dst_ops_template = {</span>
 	.family =		AF_INET,
 	.gc =			xfrm4_garbage_collect,
 	.update_pmtu =		xfrm4_update_pmtu,
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> static struct dst_ops xfrm4_dst_ops = {</span>
 
 static struct xfrm_policy_afinfo xfrm4_policy_afinfo = {
 	.family = 		AF_INET,
<span class="p_del">-	.dst_ops =		&amp;xfrm4_dst_ops,</span>
<span class="p_add">+	.dst_ops =		&amp;xfrm4_dst_ops_template,</span>
 	.dst_lookup =		xfrm4_dst_lookup,
 	.get_saddr =		xfrm4_get_saddr,
 	.decode_session =	_decode_session4,
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static struct ctl_table xfrm4_policy_table[] = {</span>
 	{ }
 };
 
<span class="p_del">-static int __net_init xfrm4_net_init(struct net *net)</span>
<span class="p_add">+static int __net_init xfrm4_net_sysctl_init(struct net *net)</span>
 {
 	struct ctl_table *table;
 	struct ctl_table_header *hdr;
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> err_alloc:</span>
 	return -ENOMEM;
 }
 
<span class="p_del">-static void __net_exit xfrm4_net_exit(struct net *net)</span>
<span class="p_add">+static void __net_exit xfrm4_net_sysctl_exit(struct net *net)</span>
 {
 	struct ctl_table *table;
 
<span class="p_chunk">@@ -306,12 +306,44 @@</span> <span class="p_context"> static void __net_exit xfrm4_net_exit(struct net *net)</span>
 	if (!net_eq(net, &amp;init_net))
 		kfree(table);
 }
<span class="p_add">+#else /* CONFIG_SYSCTL */</span>
<span class="p_add">+static int inline xfrm4_net_sysctl_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void inline xfrm4_net_sysctl_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int __net_init xfrm4_net_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;net-&gt;xfrm.xfrm4_dst_ops, &amp;xfrm4_dst_ops_template,</span>
<span class="p_add">+	       sizeof(xfrm4_dst_ops_template));</span>
<span class="p_add">+	ret = dst_entries_init(&amp;net-&gt;xfrm.xfrm4_dst_ops);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xfrm4_net_sysctl_init(net);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		dst_entries_destroy(&amp;net-&gt;xfrm.xfrm4_dst_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __net_exit xfrm4_net_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xfrm4_net_sysctl_exit(net);</span>
<span class="p_add">+	dst_entries_destroy(&amp;net-&gt;xfrm.xfrm4_dst_ops);</span>
<span class="p_add">+}</span>
 
 static struct pernet_operations __net_initdata xfrm4_net_ops = {
 	.init	= xfrm4_net_init,
 	.exit	= xfrm4_net_exit,
 };
<span class="p_del">-#endif</span>
 
 static void __init xfrm4_policy_init(void)
 {
<span class="p_chunk">@@ -320,13 +352,9 @@</span> <span class="p_context"> static void __init xfrm4_policy_init(void)</span>
 
 void __init xfrm4_init(void)
 {
<span class="p_del">-	dst_entries_init(&amp;xfrm4_dst_ops);</span>
<span class="p_del">-</span>
 	xfrm4_state_init();
 	xfrm4_policy_init();
 	xfrm4_protocol_init();
<span class="p_del">-#ifdef CONFIG_SYSCTL</span>
 	register_pernet_subsys(&amp;xfrm4_net_ops);
<span class="p_del">-#endif</span>
 }
 
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index a2d685030a34..f4795b0d6e6e 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -5267,13 +5267,10 @@</span> <span class="p_context"> static int addrconf_sysctl_stable_secret(struct ctl_table *ctl, int write,</span>
 		goto out;
 	}
 
<span class="p_del">-	if (!write) {</span>
<span class="p_del">-		err = snprintf(str, sizeof(str), &quot;%pI6&quot;,</span>
<span class="p_del">-			       &amp;secret-&gt;secret);</span>
<span class="p_del">-		if (err &gt;= sizeof(str)) {</span>
<span class="p_del">-			err = -EIO;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	err = snprintf(str, sizeof(str), &quot;%pI6&quot;, &amp;secret-&gt;secret);</span>
<span class="p_add">+	if (err &gt;= sizeof(str)) {</span>
<span class="p_add">+		err = -EIO;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	err = proc_dostring(&amp;lctl, write, buffer, lenp, ppos);
<span class="p_header">diff --git a/net/ipv6/addrlabel.c b/net/ipv6/addrlabel.c</span>
<span class="p_header">index 882124ebb438..a8f6986dcbe5 100644</span>
<span class="p_header">--- a/net/ipv6/addrlabel.c</span>
<span class="p_header">+++ b/net/ipv6/addrlabel.c</span>
<span class="p_chunk">@@ -552,7 +552,7 @@</span> <span class="p_context"> static int ip6addrlbl_get(struct sk_buff *in_skb, struct nlmsghdr *nlh)</span>
 
 	rcu_read_lock();
 	p = __ipv6_addr_label(net, addr, ipv6_addr_type(addr), ifal-&gt;ifal_index);
<span class="p_del">-	if (p &amp;&amp; ip6addrlbl_hold(p))</span>
<span class="p_add">+	if (p &amp;&amp; !ip6addrlbl_hold(p))</span>
 		p = NULL;
 	lseq = ip6addrlbl_table.seq;
 	rcu_read_unlock();
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index bc09cb97b840..f50228b0abe5 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1329,7 +1329,7 @@</span> <span class="p_context"> emsgsize:</span>
 	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !udp_get_no_check6_tx(sk)) {</span>
 		err = ip6_ufo_append_data(sk, queue, getfrag, from, length,
 					  hh_len, fragheaderlen,
 					  transhdrlen, mtu, flags, rt);
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index c1938ad39f8c..c1147acbc8c4 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -465,8 +465,10 @@</span> <span class="p_context"> static int tcp_v6_send_synack(struct sock *sk, struct dst_entry *dst,</span>
 			fl6-&gt;flowlabel = ip6_flowlabel(ipv6_hdr(ireq-&gt;pktopts));
 
 		skb_set_queue_mapping(skb, queue_mapping);
<span class="p_add">+		rcu_read_lock();</span>
 		err = ip6_xmit(sk, skb, fl6, rcu_dereference(np-&gt;opt),
 			       np-&gt;tclass);
<span class="p_add">+		rcu_read_unlock();</span>
 		err = net_xmit_eval(err);
 	}
 
<span class="p_header">diff --git a/net/ipv6/xfrm6_mode_tunnel.c b/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_header">index 901ef6f8addc..5266ad2d6419 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_mode_tunnel.c</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"> static inline void ipip6_ecn_decapsulate(struct sk_buff *skb)</span>
 	struct ipv6hdr *inner_iph = ipipv6_hdr(skb);
 
 	if (INET_ECN_is_ce(ipv6_get_dsfield(outer_iph)))
<span class="p_del">-		IP6_ECN_set_ce(inner_iph);</span>
<span class="p_add">+		IP6_ECN_set_ce(skb, inner_iph);</span>
 }
 
 /* Add encapsulation header.
<span class="p_header">diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">index f337a908a76a..4fb94f6ee15b 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_policy.c</span>
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> static void xfrm6_dst_ifdown(struct dst_entry *dst, struct net_device *dev,</span>
 	xfrm_dst_ifdown(dst, dev);
 }
 
<span class="p_del">-static struct dst_ops xfrm6_dst_ops = {</span>
<span class="p_add">+static struct dst_ops xfrm6_dst_ops_template = {</span>
 	.family =		AF_INET6,
 	.gc =			xfrm6_garbage_collect,
 	.update_pmtu =		xfrm6_update_pmtu,
<span class="p_chunk">@@ -303,7 +303,7 @@</span> <span class="p_context"> static struct dst_ops xfrm6_dst_ops = {</span>
 
 static struct xfrm_policy_afinfo xfrm6_policy_afinfo = {
 	.family =		AF_INET6,
<span class="p_del">-	.dst_ops =		&amp;xfrm6_dst_ops,</span>
<span class="p_add">+	.dst_ops =		&amp;xfrm6_dst_ops_template,</span>
 	.dst_lookup =		xfrm6_dst_lookup,
 	.get_saddr =		xfrm6_get_saddr,
 	.decode_session =	_decode_session6,
<span class="p_chunk">@@ -336,7 +336,7 @@</span> <span class="p_context"> static struct ctl_table xfrm6_policy_table[] = {</span>
 	{ }
 };
 
<span class="p_del">-static int __net_init xfrm6_net_init(struct net *net)</span>
<span class="p_add">+static int __net_init xfrm6_net_sysctl_init(struct net *net)</span>
 {
 	struct ctl_table *table;
 	struct ctl_table_header *hdr;
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> err_alloc:</span>
 	return -ENOMEM;
 }
 
<span class="p_del">-static void __net_exit xfrm6_net_exit(struct net *net)</span>
<span class="p_add">+static void __net_exit xfrm6_net_sysctl_exit(struct net *net)</span>
 {
 	struct ctl_table *table;
 
<span class="p_chunk">@@ -376,24 +376,52 @@</span> <span class="p_context"> static void __net_exit xfrm6_net_exit(struct net *net)</span>
 	if (!net_eq(net, &amp;init_net))
 		kfree(table);
 }
<span class="p_add">+#else /* CONFIG_SYSCTL */</span>
<span class="p_add">+static int inline xfrm6_net_sysctl_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void inline xfrm6_net_sysctl_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int __net_init xfrm6_net_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;net-&gt;xfrm.xfrm6_dst_ops, &amp;xfrm6_dst_ops_template,</span>
<span class="p_add">+	       sizeof(xfrm6_dst_ops_template));</span>
<span class="p_add">+	ret = dst_entries_init(&amp;net-&gt;xfrm.xfrm6_dst_ops);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xfrm6_net_sysctl_init(net);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		dst_entries_destroy(&amp;net-&gt;xfrm.xfrm6_dst_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __net_exit xfrm6_net_exit(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xfrm6_net_sysctl_exit(net);</span>
<span class="p_add">+	dst_entries_destroy(&amp;net-&gt;xfrm.xfrm6_dst_ops);</span>
<span class="p_add">+}</span>
 
 static struct pernet_operations xfrm6_net_ops = {
 	.init	= xfrm6_net_init,
 	.exit	= xfrm6_net_exit,
 };
<span class="p_del">-#endif</span>
 
 int __init xfrm6_init(void)
 {
 	int ret;
 
<span class="p_del">-	dst_entries_init(&amp;xfrm6_dst_ops);</span>
<span class="p_del">-</span>
 	ret = xfrm6_policy_init();
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		dst_entries_destroy(&amp;xfrm6_dst_ops);</span>
<span class="p_add">+	if (ret)</span>
 		goto out;
<span class="p_del">-	}</span>
 	ret = xfrm6_state_init();
 	if (ret)
 		goto out_policy;
<span class="p_chunk">@@ -402,9 +430,7 @@</span> <span class="p_context"> int __init xfrm6_init(void)</span>
 	if (ret)
 		goto out_state;
 
<span class="p_del">-#ifdef CONFIG_SYSCTL</span>
 	register_pernet_subsys(&amp;xfrm6_net_ops);
<span class="p_del">-#endif</span>
 out:
 	return ret;
 out_state:
<span class="p_chunk">@@ -416,11 +442,8 @@</span> <span class="p_context"> out_policy:</span>
 
 void xfrm6_fini(void)
 {
<span class="p_del">-#ifdef CONFIG_SYSCTL</span>
 	unregister_pernet_subsys(&amp;xfrm6_net_ops);
<span class="p_del">-#endif</span>
 	xfrm6_protocol_fini();
 	xfrm6_policy_fini();
 	xfrm6_state_fini();
<span class="p_del">-	dst_entries_destroy(&amp;xfrm6_dst_ops);</span>
 }
<span class="p_header">diff --git a/net/openvswitch/datapath.c b/net/openvswitch/datapath.c</span>
<span class="p_header">index 27e14962b504..b3fe02a2339e 100644</span>
<span class="p_header">--- a/net/openvswitch/datapath.c</span>
<span class="p_header">+++ b/net/openvswitch/datapath.c</span>
<span class="p_chunk">@@ -337,12 +337,10 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 	unsigned short gso_type = skb_shinfo(skb)-&gt;gso_type;
 	struct sw_flow_key later_key;
 	struct sk_buff *segs, *nskb;
<span class="p_del">-	struct ovs_skb_cb ovs_cb;</span>
 	int err;
 
<span class="p_del">-	ovs_cb = *OVS_CB(skb);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(*OVS_CB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = __skb_gso_segment(skb, NETIF_F_SG, false);
<span class="p_del">-	*OVS_CB(skb) = ovs_cb;</span>
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
 	if (segs == NULL)
<span class="p_chunk">@@ -360,7 +358,6 @@</span> <span class="p_context"> static int queue_gso_packets(struct datapath *dp, struct sk_buff *skb,</span>
 	/* Queue all of the segments. */
 	skb = segs;
 	do {
<span class="p_del">-		*OVS_CB(skb) = ovs_cb;</span>
 		if (gso_type &amp; SKB_GSO_UDP &amp;&amp; skb != segs)
 			key = &amp;later_key;
 
<span class="p_header">diff --git a/net/phonet/af_phonet.c b/net/phonet/af_phonet.c</span>
<span class="p_header">index 32ab87d34828..11d0b29ce4b8 100644</span>
<span class="p_header">--- a/net/phonet/af_phonet.c</span>
<span class="p_header">+++ b/net/phonet/af_phonet.c</span>
<span class="p_chunk">@@ -377,6 +377,10 @@</span> <span class="p_context"> static int phonet_rcv(struct sk_buff *skb, struct net_device *dev,</span>
 	struct sockaddr_pn sa;
 	u16 len;
 
<span class="p_add">+	skb = skb_share_check(skb, GFP_ATOMIC);</span>
<span class="p_add">+	if (!skb)</span>
<span class="p_add">+		return NET_RX_DROP;</span>
<span class="p_add">+</span>
 	/* check we have at least a full Phonet header */
 	if (!pskb_pull(skb, sizeof(struct phonethdr)))
 		goto out;
<span class="p_header">diff --git a/net/sched/sch_generic.c b/net/sched/sch_generic.c</span>
<span class="p_header">index b453270be3fd..3c6f6b774ba6 100644</span>
<span class="p_header">--- a/net/sched/sch_generic.c</span>
<span class="p_header">+++ b/net/sched/sch_generic.c</span>
<span class="p_chunk">@@ -666,8 +666,10 @@</span> <span class="p_context"> static void qdisc_rcu_free(struct rcu_head *head)</span>
 {
 	struct Qdisc *qdisc = container_of(head, struct Qdisc, rcu_head);
 
<span class="p_del">-	if (qdisc_is_percpu_stats(qdisc))</span>
<span class="p_add">+	if (qdisc_is_percpu_stats(qdisc)) {</span>
 		free_percpu(qdisc-&gt;cpu_bstats);
<span class="p_add">+		free_percpu(qdisc-&gt;cpu_qstats);</span>
<span class="p_add">+	}</span>
 
 	kfree((char *) qdisc - qdisc-&gt;padded);
 }
<span class="p_header">diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c</span>
<span class="p_header">index fef2acdf4a2e..ecae5561b912 100644</span>
<span class="p_header">--- a/net/sctp/sm_sideeffect.c</span>
<span class="p_header">+++ b/net/sctp/sm_sideeffect.c</span>
<span class="p_chunk">@@ -244,12 +244,13 @@</span> <span class="p_context"> void sctp_generate_t3_rtx_event(unsigned long peer)</span>
 	int error;
 	struct sctp_transport *transport = (struct sctp_transport *) peer;
 	struct sctp_association *asoc = transport-&gt;asoc;
<span class="p_del">-	struct net *net = sock_net(asoc-&gt;base.sk);</span>
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
<span class="p_add">+	struct net *net = sock_net(sk);</span>
 
 	/* Check whether a task is in the sock.  */
 
<span class="p_del">-	bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		pr_debug(&quot;%s: sock is busy\n&quot;, __func__);
 
 		/* Try again later.  */
<span class="p_chunk">@@ -272,10 +273,10 @@</span> <span class="p_context"> void sctp_generate_t3_rtx_event(unsigned long peer)</span>
 			   transport, GFP_ATOMIC);
 
 	if (error)
<span class="p_del">-		asoc-&gt;base.sk-&gt;sk_err = -error;</span>
<span class="p_add">+		sk-&gt;sk_err = -error;</span>
 
 out_unlock:
<span class="p_del">-	bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	bh_unlock_sock(sk);</span>
 	sctp_transport_put(transport);
 }
 
<span class="p_chunk">@@ -285,11 +286,12 @@</span> <span class="p_context"> out_unlock:</span>
 static void sctp_generate_timeout_event(struct sctp_association *asoc,
 					sctp_event_timeout_t timeout_type)
 {
<span class="p_del">-	struct net *net = sock_net(asoc-&gt;base.sk);</span>
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
<span class="p_add">+	struct net *net = sock_net(sk);</span>
 	int error = 0;
 
<span class="p_del">-	bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		pr_debug(&quot;%s: sock is busy: timer %d\n&quot;, __func__,
 			 timeout_type);
 
<span class="p_chunk">@@ -312,10 +314,10 @@</span> <span class="p_context"> static void sctp_generate_timeout_event(struct sctp_association *asoc,</span>
 			   (void *)timeout_type, GFP_ATOMIC);
 
 	if (error)
<span class="p_del">-		asoc-&gt;base.sk-&gt;sk_err = -error;</span>
<span class="p_add">+		sk-&gt;sk_err = -error;</span>
 
 out_unlock:
<span class="p_del">-	bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	bh_unlock_sock(sk);</span>
 	sctp_association_put(asoc);
 }
 
<span class="p_chunk">@@ -365,10 +367,11 @@</span> <span class="p_context"> void sctp_generate_heartbeat_event(unsigned long data)</span>
 	int error = 0;
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport-&gt;asoc;
<span class="p_del">-	struct net *net = sock_net(asoc-&gt;base.sk);</span>
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
<span class="p_add">+	struct net *net = sock_net(sk);</span>
 
<span class="p_del">-	bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		pr_debug(&quot;%s: sock is busy\n&quot;, __func__);
 
 		/* Try again later.  */
<span class="p_chunk">@@ -389,10 +392,10 @@</span> <span class="p_context"> void sctp_generate_heartbeat_event(unsigned long data)</span>
 			   transport, GFP_ATOMIC);
 
 	 if (error)
<span class="p_del">-		 asoc-&gt;base.sk-&gt;sk_err = -error;</span>
<span class="p_add">+		sk-&gt;sk_err = -error;</span>
 
 out_unlock:
<span class="p_del">-	bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	bh_unlock_sock(sk);</span>
 	sctp_transport_put(transport);
 }
 
<span class="p_chunk">@@ -403,10 +406,11 @@</span> <span class="p_context"> void sctp_generate_proto_unreach_event(unsigned long data)</span>
 {
 	struct sctp_transport *transport = (struct sctp_transport *) data;
 	struct sctp_association *asoc = transport-&gt;asoc;
<span class="p_del">-	struct net *net = sock_net(asoc-&gt;base.sk);</span>
<span class="p_add">+	struct sock *sk = asoc-&gt;base.sk;</span>
<span class="p_add">+	struct net *net = sock_net(sk);</span>
 
<span class="p_del">-	bh_lock_sock(asoc-&gt;base.sk);</span>
<span class="p_del">-	if (sock_owned_by_user(asoc-&gt;base.sk)) {</span>
<span class="p_add">+	bh_lock_sock(sk);</span>
<span class="p_add">+	if (sock_owned_by_user(sk)) {</span>
 		pr_debug(&quot;%s: sock is busy\n&quot;, __func__);
 
 		/* Try again later.  */
<span class="p_chunk">@@ -427,7 +431,7 @@</span> <span class="p_context"> void sctp_generate_proto_unreach_event(unsigned long data)</span>
 		   asoc-&gt;state, asoc-&gt;ep, asoc, transport, GFP_ATOMIC);
 
 out_unlock:
<span class="p_del">-	bh_unlock_sock(asoc-&gt;base.sk);</span>
<span class="p_add">+	bh_unlock_sock(sk);</span>
 	sctp_association_put(asoc);
 }
 
<span class="p_header">diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c</span>
<span class="p_header">index 3ee27b7704ff..e6bb98e583fb 100644</span>
<span class="p_header">--- a/net/sctp/sm_statefuns.c</span>
<span class="p_header">+++ b/net/sctp/sm_statefuns.c</span>
<span class="p_chunk">@@ -4829,7 +4829,8 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_do_9_1_prm_abort(</span>
 
 	retval = SCTP_DISPOSITION_CONSUME;
 
<span class="p_del">-	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
<span class="p_add">+	if (abort)</span>
<span class="p_add">+		sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
 
 	/* Even if we can&#39;t send the ABORT due to low memory delete the
 	 * TCB.  This is a departure from our typical NOMEM handling.
<span class="p_chunk">@@ -4966,7 +4967,8 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_cookie_wait_prm_abort(</span>
 			SCTP_TO(SCTP_EVENT_TIMEOUT_T1_INIT));
 	retval = SCTP_DISPOSITION_CONSUME;
 
<span class="p_del">-	sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
<span class="p_add">+	if (abort)</span>
<span class="p_add">+		sctp_add_cmd_sf(commands, SCTP_CMD_REPLY, SCTP_CHUNK(abort));</span>
 
 	sctp_add_cmd_sf(commands, SCTP_CMD_NEW_STATE,
 			SCTP_STATE(SCTP_STATE_CLOSED));
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index a63c2c87a0c6..76e6ec62cf92 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1513,8 +1513,7 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 			struct sctp_chunk *chunk;
 
 			chunk = sctp_make_abort_user(asoc, NULL, 0);
<span class="p_del">-			if (chunk)</span>
<span class="p_del">-				sctp_primitive_ABORT(net, asoc, chunk);</span>
<span class="p_add">+			sctp_primitive_ABORT(net, asoc, chunk);</span>
 		} else
 			sctp_primitive_SHUTDOWN(net, asoc, NULL);
 	}
<span class="p_header">diff --git a/net/sctp/sysctl.c b/net/sctp/sysctl.c</span>
<span class="p_header">index 26d50c565f54..3e0fc5127225 100644</span>
<span class="p_header">--- a/net/sctp/sysctl.c</span>
<span class="p_header">+++ b/net/sctp/sysctl.c</span>
<span class="p_chunk">@@ -320,7 +320,7 @@</span> <span class="p_context"> static int proc_sctp_do_hmac_alg(struct ctl_table *ctl, int write,</span>
 	struct ctl_table tbl;
 	bool changed = false;
 	char *none = &quot;none&quot;;
<span class="p_del">-	char tmp[8];</span>
<span class="p_add">+	char tmp[8] = {0};</span>
 	int ret;
 
 	memset(&amp;tbl, 0, sizeof(struct ctl_table));
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index a398f624c28d..cb3a01a9ed38 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -1481,6 +1481,21 @@</span> <span class="p_context"> static void unix_destruct_scm(struct sk_buff *skb)</span>
 	sock_wfree(skb);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The &quot;user-&gt;unix_inflight&quot; variable is protected by the garbage</span>
<span class="p_add">+ * collection lock, and we just read it locklessly here. If you go</span>
<span class="p_add">+ * over the limit, there might be a tiny race in actually noticing</span>
<span class="p_add">+ * it across threads. Tough.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool too_many_unix_fds(struct task_struct *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct user_struct *user = current_user();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(user-&gt;unix_inflight &gt; task_rlimit(p, RLIMIT_NOFILE)))</span>
<span class="p_add">+		return !capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN);</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define MAX_RECURSION_LEVEL 4
 
 static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)
<span class="p_chunk">@@ -1489,6 +1504,9 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	unsigned char max_level = 0;
 	int unix_sock_count = 0;
 
<span class="p_add">+	if (too_many_unix_fds(current))</span>
<span class="p_add">+		return -ETOOMANYREFS;</span>
<span class="p_add">+</span>
 	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--) {
 		struct sock *sk = unix_get_socket(scm-&gt;fp-&gt;fp[i]);
 
<span class="p_chunk">@@ -1510,10 +1528,8 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	if (!UNIXCB(skb).fp)
 		return -ENOMEM;
 
<span class="p_del">-	if (unix_sock_count) {</span>
<span class="p_del">-		for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)</span>
<span class="p_del">-			unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)</span>
<span class="p_add">+		unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
 	return max_level;
 }
 
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index a73a226f2d33..8fcdc2283af5 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -120,11 +120,11 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_add">+	spin_lock(&amp;unix_gc_lock);</span>
<span class="p_add">+</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_del">-		spin_lock(&amp;unix_gc_lock);</span>
<span class="p_del">-</span>
 		if (atomic_long_inc_return(&amp;u-&gt;inflight) == 1) {
 			BUG_ON(!list_empty(&amp;u-&gt;link));
 			list_add_tail(&amp;u-&gt;link, &amp;gc_inflight_list);
<span class="p_chunk">@@ -132,25 +132,28 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 			BUG_ON(list_empty(&amp;u-&gt;link));
 		}
 		unix_tot_inflight++;
<span class="p_del">-		spin_unlock(&amp;unix_gc_lock);</span>
 	}
<span class="p_add">+	fp-&gt;f_cred-&gt;user-&gt;unix_inflight++;</span>
<span class="p_add">+	spin_unlock(&amp;unix_gc_lock);</span>
 }
 
 void unix_notinflight(struct file *fp)
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_add">+	spin_lock(&amp;unix_gc_lock);</span>
<span class="p_add">+</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_del">-		spin_lock(&amp;unix_gc_lock);</span>
 		BUG_ON(list_empty(&amp;u-&gt;link));
 
 		if (atomic_long_dec_and_test(&amp;u-&gt;inflight))
 			list_del_init(&amp;u-&gt;link);
 		unix_tot_inflight--;
<span class="p_del">-		spin_unlock(&amp;unix_gc_lock);</span>
 	}
<span class="p_add">+	fp-&gt;f_cred-&gt;user-&gt;unix_inflight--;</span>
<span class="p_add">+	spin_unlock(&amp;unix_gc_lock);</span>
 }
 
 static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),
<span class="p_header">diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c</span>
<span class="p_header">index fbcedbe33190..5097dce5b916 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_output.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_output.c</span>
<span class="p_chunk">@@ -153,6 +153,8 @@</span> <span class="p_context"> static int xfrm_output_gso(struct sock *sk, struct sk_buff *skb)</span>
 {
 	struct sk_buff *segs;
 
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IPCB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(*IP6CB(skb)) &gt; SKB_SGO_CB_OFFSET);</span>
 	segs = skb_gso_segment(skb, 0);
 	kfree_skb(skb);
 	if (IS_ERR(segs))
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index 638af0655aaf..4cd2076ff84b 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -2806,7 +2806,6 @@</span> <span class="p_context"> static struct neighbour *xfrm_neigh_lookup(const struct dst_entry *dst,</span>
 
 int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo)
 {
<span class="p_del">-	struct net *net;</span>
 	int err = 0;
 	if (unlikely(afinfo == NULL))
 		return -EINVAL;
<span class="p_chunk">@@ -2837,26 +2836,6 @@</span> <span class="p_context"> int xfrm_policy_register_afinfo(struct xfrm_policy_afinfo *afinfo)</span>
 	}
 	spin_unlock(&amp;xfrm_policy_afinfo_lock);
 
<span class="p_del">-	rtnl_lock();</span>
<span class="p_del">-	for_each_net(net) {</span>
<span class="p_del">-		struct dst_ops *xfrm_dst_ops;</span>
<span class="p_del">-</span>
<span class="p_del">-		switch (afinfo-&gt;family) {</span>
<span class="p_del">-		case AF_INET:</span>
<span class="p_del">-			xfrm_dst_ops = &amp;net-&gt;xfrm.xfrm4_dst_ops;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_del">-		case AF_INET6:</span>
<span class="p_del">-			xfrm_dst_ops = &amp;net-&gt;xfrm.xfrm6_dst_ops;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			BUG();</span>
<span class="p_del">-		}</span>
<span class="p_del">-		*xfrm_dst_ops = *afinfo-&gt;dst_ops;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-</span>
 	return err;
 }
 EXPORT_SYMBOL(xfrm_policy_register_afinfo);
<span class="p_chunk">@@ -2892,22 +2871,6 @@</span> <span class="p_context"> int xfrm_policy_unregister_afinfo(struct xfrm_policy_afinfo *afinfo)</span>
 }
 EXPORT_SYMBOL(xfrm_policy_unregister_afinfo);
 
<span class="p_del">-static void __net_init xfrm_dst_ops_init(struct net *net)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xfrm_policy_afinfo *afinfo;</span>
<span class="p_del">-</span>
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	afinfo = rcu_dereference(xfrm_policy_afinfo[AF_INET]);</span>
<span class="p_del">-	if (afinfo)</span>
<span class="p_del">-		net-&gt;xfrm.xfrm4_dst_ops = *afinfo-&gt;dst_ops;</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_del">-	afinfo = rcu_dereference(xfrm_policy_afinfo[AF_INET6]);</span>
<span class="p_del">-	if (afinfo)</span>
<span class="p_del">-		net-&gt;xfrm.xfrm6_dst_ops = *afinfo-&gt;dst_ops;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
<span class="p_chunk">@@ -3056,7 +3019,6 @@</span> <span class="p_context"> static int __net_init xfrm_net_init(struct net *net)</span>
 	rv = xfrm_policy_init(net);
 	if (rv &lt; 0)
 		goto out_policy;
<span class="p_del">-	xfrm_dst_ops_init(net);</span>
 	rv = xfrm_sysctl_init(net);
 	if (rv &lt; 0)
 		goto out_sysctl;
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index 3d1984e59a30..e00bcd129336 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"></span>
 
 #ifndef EM_AARCH64
 #define EM_AARCH64	183
<span class="p_add">+#define R_AARCH64_NONE		0</span>
 #define R_AARCH64_ABS64	257
 #endif
 
<span class="p_chunk">@@ -160,6 +161,22 @@</span> <span class="p_context"> static int make_nop_x86(void *map, size_t const offset)</span>
 	return 0;
 }
 
<span class="p_add">+static unsigned char ideal_nop4_arm64[4] = {0x1f, 0x20, 0x03, 0xd5};</span>
<span class="p_add">+static int make_nop_arm64(void *map, size_t const offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t *ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	ptr = map + offset;</span>
<span class="p_add">+	/* bl &lt;_mcount&gt; is 0x94000000 before relocation */</span>
<span class="p_add">+	if (*ptr != 0x94000000)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Convert to nop */</span>
<span class="p_add">+	ulseek(fd_map, offset, SEEK_SET);</span>
<span class="p_add">+	uwrite(fd_map, ideal_nop, 4);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Get the whole file as a programming convenience in order to avoid
  * malloc+lseek+read+free of many pieces.  If successful, then mmap
<span class="p_chunk">@@ -353,7 +370,12 @@</span> <span class="p_context"> do_file(char const *const fname)</span>
 			 altmcount = &quot;__gnu_mcount_nc&quot;;
 			 break;
 	case EM_AARCH64:
<span class="p_del">-			 reltype = R_AARCH64_ABS64; gpfx = &#39;_&#39;; break;</span>
<span class="p_add">+			reltype = R_AARCH64_ABS64;</span>
<span class="p_add">+			make_nop = make_nop_arm64;</span>
<span class="p_add">+			rel_type_nop = R_AARCH64_NONE;</span>
<span class="p_add">+			ideal_nop = ideal_nop4_arm64;</span>
<span class="p_add">+			gpfx = &#39;_&#39;;</span>
<span class="p_add">+			break;</span>
 	case EM_IA_64:	 reltype = R_IA64_IMM64;   gpfx = &#39;_&#39;; break;
 	case EM_METAG:	 reltype = R_METAG_ADDR32;
 			 altmcount = &quot;_mcount_wrapper&quot;;
<span class="p_header">diff --git a/scripts/recordmcount.h b/scripts/recordmcount.h</span>
<span class="p_header">index 49b582a225b0..b9897e2be404 100644</span>
<span class="p_header">--- a/scripts/recordmcount.h</span>
<span class="p_header">+++ b/scripts/recordmcount.h</span>
<span class="p_chunk">@@ -377,7 +377,7 @@</span> <span class="p_context"> static void nop_mcount(Elf_Shdr const *const relhdr,</span>
 
 		if (mcountsym == Elf_r_sym(relp) &amp;&amp; !is_fake_mcount(relp)) {
 			if (make_nop)
<span class="p_del">-				ret = make_nop((void *)ehdr, shdr-&gt;sh_offset + relp-&gt;r_offset);</span>
<span class="p_add">+				ret = make_nop((void *)ehdr, _w(shdr-&gt;sh_offset) + _w(relp-&gt;r_offset));</span>
 			if (warn_on_notrace_sect &amp;&amp; !once) {
 				printf(&quot;Section %s has mcount callers being ignored\n&quot;,
 				       txtname);
<span class="p_header">diff --git a/scripts/recordmcount.pl b/scripts/recordmcount.pl</span>
<span class="p_header">index 826470d7f000..96e2486a6fc4 100755</span>
<span class="p_header">--- a/scripts/recordmcount.pl</span>
<span class="p_header">+++ b/scripts/recordmcount.pl</span>
<span class="p_chunk">@@ -263,7 +263,8 @@</span> <span class="p_context"> if ($arch eq &quot;x86_64&quot;) {</span>
 
 } elsif ($arch eq &quot;powerpc&quot;) {
     $local_regex = &quot;^[0-9a-fA-F]+\\s+t\\s+(\\.?\\S+)&quot;;
<span class="p_del">-    $function_regex = &quot;^([0-9a-fA-F]+)\\s+&lt;(\\.?.*?)&gt;:&quot;;</span>
<span class="p_add">+    # See comment in the sparc64 section for why we use &#39;\w&#39;.</span>
<span class="p_add">+    $function_regex = &quot;^([0-9a-fA-F]+)\\s+&lt;(\\.?\\w*?)&gt;:&quot;;</span>
     $mcount_regex = &quot;^\\s*([0-9a-fA-F]+):.*\\s\\.?_mcount\$&quot;;
 
     if ($bits == 64) {
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 196a6fe100ca..a85d45595d02 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1405,6 +1405,8 @@</span> <span class="p_context"> static int snd_ctl_tlv_ioctl(struct snd_ctl_file *file,</span>
 		return -EFAULT;
 	if (tlv.length &lt; sizeof(unsigned int) * 2)
 		return -EINVAL;
<span class="p_add">+	if (!tlv.numid)</span>
<span class="p_add">+		return -EINVAL;</span>
 	down_read(&amp;card-&gt;controls_rwsem);
 	kctl = snd_ctl_find_numid(card, tlv.numid);
 	if (kctl == NULL) {
<span class="p_header">diff --git a/sound/core/hrtimer.c b/sound/core/hrtimer.c</span>
<span class="p_header">index 886be7da989d..38514ed6e55c 100644</span>
<span class="p_header">--- a/sound/core/hrtimer.c</span>
<span class="p_header">+++ b/sound/core/hrtimer.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static int snd_hrtimer_start(struct snd_timer *t)</span>
 	struct snd_hrtimer *stime = t-&gt;private_data;
 
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_del">-	hrtimer_cancel(&amp;stime-&gt;hrt);</span>
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	hrtimer_start(&amp;stime-&gt;hrt, ns_to_ktime(t-&gt;sticks * resolution),
 		      HRTIMER_MODE_REL);
 	atomic_set(&amp;stime-&gt;running, 1);
<span class="p_chunk">@@ -101,6 +101,7 @@</span> <span class="p_context"> static int snd_hrtimer_stop(struct snd_timer *t)</span>
 {
 	struct snd_hrtimer *stime = t-&gt;private_data;
 	atomic_set(&amp;stime-&gt;running, 0);
<span class="p_add">+	hrtimer_try_to_cancel(&amp;stime-&gt;hrt);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/core/pcm_compat.c b/sound/core/pcm_compat.c</span>
<span class="p_header">index b48b434444ed..9630e9f72b7b 100644</span>
<span class="p_header">--- a/sound/core/pcm_compat.c</span>
<span class="p_header">+++ b/sound/core/pcm_compat.c</span>
<span class="p_chunk">@@ -255,10 +255,15 @@</span> <span class="p_context"> static int snd_pcm_ioctl_hw_params_compat(struct snd_pcm_substream *substream,</span>
 	if (! (runtime = substream-&gt;runtime))
 		return -ENOTTY;
 
<span class="p_del">-	/* only fifo_size is different, so just copy all */</span>
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* only fifo_size (RO from userspace) is different, so just copy all */</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32))) {</span>
<span class="p_add">+		err = -EFAULT;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
 
 	if (refine)
 		err = snd_pcm_hw_refine(substream, data);
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index edbdab85fc02..bd4741442909 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1962,7 +1962,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_remove_events(struct snd_seq_client *client,</span>
 		 * No restrictions so for a user client we can clear
 		 * the whole fifo
 		 */
<span class="p_del">-		if (client-&gt;type == USER_CLIENT)</span>
<span class="p_add">+		if (client-&gt;type == USER_CLIENT &amp;&amp; client-&gt;data.user.fifo)</span>
 			snd_seq_fifo_clear(client-&gt;data.user.fifo);
 	}
 
<span class="p_header">diff --git a/sound/core/seq/seq_compat.c b/sound/core/seq/seq_compat.c</span>
<span class="p_header">index 81f7c109dc46..65175902a68a 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_compat.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_compat.c</span>
<span class="p_chunk">@@ -49,11 +49,12 @@</span> <span class="p_context"> static int snd_seq_call_port_info_ioctl(struct snd_seq_client *client, unsigned</span>
 	struct snd_seq_port_info *data;
 	mm_segment_t fs;
 
<span class="p_del">-	data = memdup_user(data32, sizeof(*data32));</span>
<span class="p_del">-	if (IS_ERR(data))</span>
<span class="p_del">-		return PTR_ERR(data);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	if (get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
<span class="p_add">+	if (copy_from_user(data, data32, sizeof(*data32)) ||</span>
<span class="p_add">+	    get_user(data-&gt;flags, &amp;data32-&gt;flags) ||</span>
 	    get_user(data-&gt;time_queue, &amp;data32-&gt;time_queue))
 		goto error;
 	data-&gt;kernel = NULL;
<span class="p_header">diff --git a/sound/core/seq/seq_queue.c b/sound/core/seq/seq_queue.c</span>
<span class="p_header">index a0cda38205b9..77ec21420355 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_queue.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_queue.c</span>
<span class="p_chunk">@@ -142,8 +142,10 @@</span> <span class="p_context"> static struct snd_seq_queue *queue_new(int owner, int locked)</span>
 static void queue_delete(struct snd_seq_queue *q)
 {
 	/* stop and release the timer */
<span class="p_add">+	mutex_lock(&amp;q-&gt;timer_mutex);</span>
 	snd_seq_timer_stop(q-&gt;timer);
 	snd_seq_timer_close(q);
<span class="p_add">+	mutex_unlock(&amp;q-&gt;timer_mutex);</span>
 	/* wait until access free */
 	snd_use_lock_sync(&amp;q-&gt;use_lock);
 	/* release resources... */
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index a9a1a047c521..a419878901c4 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> struct snd_timer_user {</span>
 	int qtail;
 	int qused;
 	int queue_size;
<span class="p_add">+	bool disconnected;</span>
 	struct snd_timer_read *queue;
 	struct snd_timer_tread *tqueue;
 	spinlock_t qlock;
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> struct snd_timer_user {</span>
 	struct timespec tstamp;		/* trigger tstamp */
 	wait_queue_head_t qchange_sleep;
 	struct fasync_struct *fasync;
<span class="p_del">-	struct mutex tread_sem;</span>
<span class="p_add">+	struct mutex ioctl_lock;</span>
 };
 
 /* list of timers */
<span class="p_chunk">@@ -215,11 +216,13 @@</span> <span class="p_context"> static void snd_timer_check_master(struct snd_timer_instance *master)</span>
 		    slave-&gt;slave_id == master-&gt;slave_id) {
 			list_move_tail(&amp;slave-&gt;open_list, &amp;master-&gt;slave_list_head);
 			spin_lock_irq(&amp;slave_active_lock);
<span class="p_add">+			spin_lock(&amp;master-&gt;timer-&gt;lock);</span>
 			slave-&gt;master = master;
 			slave-&gt;timer = master-&gt;timer;
 			if (slave-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)
 				list_add_tail(&amp;slave-&gt;active_list,
 					      &amp;master-&gt;slave_active_head);
<span class="p_add">+			spin_unlock(&amp;master-&gt;timer-&gt;lock);</span>
 			spin_unlock_irq(&amp;slave_active_lock);
 		}
 	}
<span class="p_chunk">@@ -288,6 +291,9 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 		mutex_unlock(&amp;register_mutex);
 		return -ENOMEM;
 	}
<span class="p_add">+	/* take a card refcount for safe disconnection */</span>
<span class="p_add">+	if (timer-&gt;card)</span>
<span class="p_add">+		get_device(&amp;timer-&gt;card-&gt;card_dev);</span>
 	timeri-&gt;slave_class = tid-&gt;dev_sclass;
 	timeri-&gt;slave_id = slave_id;
 	if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp; timer-&gt;hw.open)
<span class="p_chunk">@@ -346,15 +352,21 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		    timer-&gt;hw.close)
 			timer-&gt;hw.close(timer);
 		/* remove slave links */
<span class="p_add">+		spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+		spin_lock(&amp;timer-&gt;lock);</span>
 		list_for_each_entry_safe(slave, tmp, &amp;timeri-&gt;slave_list_head,
 					 open_list) {
<span class="p_del">-			spin_lock_irq(&amp;slave_active_lock);</span>
<span class="p_del">-			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);</span>
 			list_move_tail(&amp;slave-&gt;open_list, &amp;snd_timer_slave_list);
 			slave-&gt;master = NULL;
 			slave-&gt;timer = NULL;
<span class="p_del">-			spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;slave-&gt;active_list);</span>
 		}
<span class="p_add">+		spin_unlock(&amp;timer-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irq(&amp;slave_active_lock);</span>
<span class="p_add">+		/* release a card refcount for safe disconnection */</span>
<span class="p_add">+		if (timer-&gt;card)</span>
<span class="p_add">+			put_device(&amp;timer-&gt;card-&gt;card_dev);</span>
 		mutex_unlock(&amp;register_mutex);
 	}
  out:
<span class="p_chunk">@@ -441,9 +453,12 @@</span> <span class="p_context"> static int snd_timer_start_slave(struct snd_timer_instance *timeri)</span>
 
 	spin_lock_irqsave(&amp;slave_active_lock, flags);
 	timeri-&gt;flags |= SNDRV_TIMER_IFLG_RUNNING;
<span class="p_del">-	if (timeri-&gt;master)</span>
<span class="p_add">+	if (timeri-&gt;master &amp;&amp; timeri-&gt;timer) {</span>
<span class="p_add">+		spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
 		list_add_tail(&amp;timeri-&gt;active_list,
 			      &amp;timeri-&gt;master-&gt;slave_active_head);
<span class="p_add">+		spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 	return 1; /* delayed start */
 }
<span class="p_chunk">@@ -467,6 +482,8 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 	timer = timeri-&gt;timer;
 	if (timer == NULL)
 		return -EINVAL;
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return -ENODEV;</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	timeri-&gt;ticks = timeri-&gt;cticks = ticks;
 	timeri-&gt;pticks = 0;
<span class="p_chunk">@@ -489,6 +506,8 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 		if (!keep_flag) {
 			spin_lock_irqsave(&amp;slave_active_lock, flags);
 			timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
<span class="p_add">+			list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_add">+			list_del_init(&amp;timeri-&gt;active_list);</span>
 			spin_unlock_irqrestore(&amp;slave_active_lock, flags);
 		}
 		goto __end;
<span class="p_chunk">@@ -499,6 +518,10 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	list_del_init(&amp;timeri-&gt;ack_list);
 	list_del_init(&amp;timeri-&gt;active_list);
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
 	if ((timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING) &amp;&amp;
 	    !(--timer-&gt;running)) {
 		timer-&gt;hw.stop(timer);
<span class="p_chunk">@@ -561,6 +584,8 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
 	timer = timeri-&gt;timer;
 	if (! timer)
 		return -EINVAL;
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return -ENODEV;</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	if (!timeri-&gt;cticks)
 		timeri-&gt;cticks = 1;
<span class="p_chunk">@@ -624,6 +649,9 @@</span> <span class="p_context"> static void snd_timer_tasklet(unsigned long arg)</span>
 	unsigned long resolution, ticks;
 	unsigned long flags;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	/* now process all callbacks */
 	while (!list_empty(&amp;timer-&gt;sack_list_head)) {
<span class="p_chunk">@@ -664,6 +692,9 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 	if (timer == NULL)
 		return;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 
 	/* remember the current resolution */
<span class="p_chunk">@@ -694,7 +725,7 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 		} else {
 			ti-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
 			if (--timer-&gt;running)
<span class="p_del">-				list_del(&amp;ti-&gt;active_list);</span>
<span class="p_add">+				list_del_init(&amp;ti-&gt;active_list);</span>
 		}
 		if ((timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_TASKLET) ||
 		    (ti-&gt;flags &amp; SNDRV_TIMER_IFLG_FAST))
<span class="p_chunk">@@ -874,11 +905,28 @@</span> <span class="p_context"> static int snd_timer_dev_register(struct snd_device *dev)</span>
 	return 0;
 }
 
<span class="p_add">+/* just for reference in snd_timer_dev_disconnect() below */</span>
<span class="p_add">+static void snd_timer_user_ccallback(struct snd_timer_instance *timeri,</span>
<span class="p_add">+				     int event, struct timespec *tstamp,</span>
<span class="p_add">+				     unsigned long resolution);</span>
<span class="p_add">+</span>
 static int snd_timer_dev_disconnect(struct snd_device *device)
 {
 	struct snd_timer *timer = device-&gt;device_data;
<span class="p_add">+	struct snd_timer_instance *ti;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;register_mutex);
 	list_del_init(&amp;timer-&gt;device_list);
<span class="p_add">+	/* wake up pending sleepers */</span>
<span class="p_add">+	list_for_each_entry(ti, &amp;timer-&gt;open_list_head, open_list) {</span>
<span class="p_add">+		/* FIXME: better to have a ti.disconnect() op */</span>
<span class="p_add">+		if (ti-&gt;ccallback == snd_timer_user_ccallback) {</span>
<span class="p_add">+			struct snd_timer_user *tu = ti-&gt;callback_data;</span>
<span class="p_add">+</span>
<span class="p_add">+			tu-&gt;disconnected = true;</span>
<span class="p_add">+			wake_up(&amp;tu-&gt;qchange_sleep);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -889,6 +937,8 @@</span> <span class="p_context"> void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstam</span>
 	unsigned long resolution = 0;
 	struct snd_timer_instance *ti, *ts;
 
<span class="p_add">+	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+		return;</span>
 	if (! (timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_SLAVE))
 		return;
 	if (snd_BUG_ON(event &lt; SNDRV_TIMER_EVENT_MSTART ||
<span class="p_chunk">@@ -1047,6 +1097,8 @@</span> <span class="p_context"> static void snd_timer_proc_read(struct snd_info_entry *entry,</span>
 
 	mutex_lock(&amp;register_mutex);
 	list_for_each_entry(timer, &amp;snd_timer_list, device_list) {
<span class="p_add">+		if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)</span>
<span class="p_add">+			continue;</span>
 		switch (timer-&gt;tmr_class) {
 		case SNDRV_TIMER_CLASS_GLOBAL:
 			snd_iprintf(buffer, &quot;G%i: &quot;, timer-&gt;tmr_device);
<span class="p_chunk">@@ -1253,7 +1305,7 @@</span> <span class="p_context"> static int snd_timer_user_open(struct inode *inode, struct file *file)</span>
 		return -ENOMEM;
 	spin_lock_init(&amp;tu-&gt;qlock);
 	init_waitqueue_head(&amp;tu-&gt;qchange_sleep);
<span class="p_del">-	mutex_init(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+	mutex_init(&amp;tu-&gt;ioctl_lock);</span>
 	tu-&gt;ticks = 1;
 	tu-&gt;queue_size = 128;
 	tu-&gt;queue = kmalloc(tu-&gt;queue_size * sizeof(struct snd_timer_read),
<span class="p_chunk">@@ -1273,8 +1325,10 @@</span> <span class="p_context"> static int snd_timer_user_release(struct inode *inode, struct file *file)</span>
 	if (file-&gt;private_data) {
 		tu = file-&gt;private_data;
 		file-&gt;private_data = NULL;
<span class="p_add">+		mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
 		if (tu-&gt;timeri)
 			snd_timer_close(tu-&gt;timeri);
<span class="p_add">+		mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
 		kfree(tu-&gt;queue);
 		kfree(tu-&gt;tqueue);
 		kfree(tu);
<span class="p_chunk">@@ -1512,7 +1566,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	int err = 0;
 
 	tu = file-&gt;private_data;
<span class="p_del">-	mutex_lock(&amp;tu-&gt;tread_sem);</span>
 	if (tu-&gt;timeri) {
 		snd_timer_close(tu-&gt;timeri);
 		tu-&gt;timeri = NULL;
<span class="p_chunk">@@ -1556,7 +1609,6 @@</span> <span class="p_context"> static int snd_timer_user_tselect(struct file *file,</span>
 	}
 
       __err:
<span class="p_del">-      	mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1769,7 +1821,7 @@</span> <span class="p_context"> enum {</span>
 	SNDRV_TIMER_IOCTL_PAUSE_OLD = _IO(&#39;T&#39;, 0x23),
 };
 
<span class="p_del">-static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+static long __snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 				 unsigned long arg)
 {
 	struct snd_timer_user *tu;
<span class="p_chunk">@@ -1786,17 +1838,11 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	{
 		int xarg;
 
<span class="p_del">-		mutex_lock(&amp;tu-&gt;tread_sem);</span>
<span class="p_del">-		if (tu-&gt;timeri)	{	/* too late */</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (tu-&gt;timeri)	/* too late */</span>
 			return -EBUSY;
<span class="p_del">-		}</span>
<span class="p_del">-		if (get_user(xarg, p)) {</span>
<span class="p_del">-			mutex_unlock(&amp;tu-&gt;tread_sem);</span>
<span class="p_add">+		if (get_user(xarg, p))</span>
 			return -EFAULT;
<span class="p_del">-		}</span>
 		tu-&gt;tread = xarg ? 1 : 0;
<span class="p_del">-		mutex_unlock(&amp;tu-&gt;tread_sem);</span>
 		return 0;
 	}
 	case SNDRV_TIMER_IOCTL_GINFO:
<span class="p_chunk">@@ -1829,6 +1875,18 @@</span> <span class="p_context"> static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
 	return -ENOTTY;
 }
 
<span class="p_add">+static long snd_timer_user_ioctl(struct file *file, unsigned int cmd,</span>
<span class="p_add">+				 unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_timer_user *tu = file-&gt;private_data;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	ret = __snd_timer_user_ioctl(file, cmd, arg);</span>
<span class="p_add">+	mutex_unlock(&amp;tu-&gt;ioctl_lock);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int snd_timer_user_fasync(int fd, struct file * file, int on)
 {
 	struct snd_timer_user *tu;
<span class="p_chunk">@@ -1866,6 +1924,10 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 			remove_wait_queue(&amp;tu-&gt;qchange_sleep, &amp;wait);
 
<span class="p_add">+			if (tu-&gt;disconnected) {</span>
<span class="p_add">+				err = -ENODEV;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			if (signal_pending(current)) {
 				err = -ERESTARTSYS;
 				break;
<span class="p_chunk">@@ -1915,6 +1977,8 @@</span> <span class="p_context"> static unsigned int snd_timer_user_poll(struct file *file, poll_table * wait)</span>
 	mask = 0;
 	if (tu-&gt;qused)
 		mask |= POLLIN | POLLRDNORM;
<span class="p_add">+	if (tu-&gt;disconnected)</span>
<span class="p_add">+		mask |= POLLERR;</span>
 
 	return mask;
 }
<span class="p_header">diff --git a/sound/firewire/bebob/Makefile b/sound/firewire/bebob/Makefile</span>
<span class="p_header">index 6cf470c80d1f..af7ed6643266 100644</span>
<span class="p_header">--- a/sound/firewire/bebob/Makefile</span>
<span class="p_header">+++ b/sound/firewire/bebob/Makefile</span>
<span class="p_chunk">@@ -1,4 +1,4 @@</span> <span class="p_context"></span>
 snd-bebob-objs := bebob_command.o bebob_stream.o bebob_proc.o bebob_midi.o \
 		  bebob_pcm.o bebob_hwdep.o bebob_terratec.o bebob_yamaha.o \
 		  bebob_focusrite.o bebob_maudio.o bebob.o
<span class="p_del">-obj-m += snd-bebob.o</span>
<span class="p_add">+obj-$(CONFIG_SND_BEBOB) += snd-bebob.o</span>
<span class="p_header">diff --git a/sound/firewire/dice/Makefile b/sound/firewire/dice/Makefile</span>
<span class="p_header">index 9ef228ef7baf..55b4be9b0034 100644</span>
<span class="p_header">--- a/sound/firewire/dice/Makefile</span>
<span class="p_header">+++ b/sound/firewire/dice/Makefile</span>
<span class="p_chunk">@@ -1,3 +1,3 @@</span> <span class="p_context"></span>
 snd-dice-objs := dice-transaction.o dice-stream.o dice-proc.o dice-midi.o \
 		 dice-pcm.o dice-hwdep.o dice.o
<span class="p_del">-obj-m += snd-dice.o</span>
<span class="p_add">+obj-$(CONFIG_SND_DICE) += snd-dice.o</span>
<span class="p_header">diff --git a/sound/firewire/fireworks/Makefile b/sound/firewire/fireworks/Makefile</span>
<span class="p_header">index 0c7440826db8..15ef7f75a8ef 100644</span>
<span class="p_header">--- a/sound/firewire/fireworks/Makefile</span>
<span class="p_header">+++ b/sound/firewire/fireworks/Makefile</span>
<span class="p_chunk">@@ -1,4 +1,4 @@</span> <span class="p_context"></span>
 snd-fireworks-objs := fireworks_transaction.o fireworks_command.o \
 		      fireworks_stream.o fireworks_proc.o fireworks_midi.o \
 		      fireworks_pcm.o fireworks_hwdep.o fireworks.o
<span class="p_del">-obj-m += snd-fireworks.o</span>
<span class="p_add">+obj-$(CONFIG_SND_FIREWORKS) += snd-fireworks.o</span>
<span class="p_header">diff --git a/sound/firewire/oxfw/Makefile b/sound/firewire/oxfw/Makefile</span>
<span class="p_header">index a926850864f6..06ff50f4e6c0 100644</span>
<span class="p_header">--- a/sound/firewire/oxfw/Makefile</span>
<span class="p_header">+++ b/sound/firewire/oxfw/Makefile</span>
<span class="p_chunk">@@ -1,3 +1,3 @@</span> <span class="p_context"></span>
 snd-oxfw-objs := oxfw-command.o oxfw-stream.o oxfw-control.o oxfw-pcm.o \
 		 oxfw-proc.o oxfw-midi.o oxfw-hwdep.o oxfw.o
<span class="p_del">-obj-m += snd-oxfw.o</span>
<span class="p_add">+obj-$(CONFIG_SND_OXFW) += snd-oxfw.o</span>
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 44dfc7b92bc3..09920ba55ba1 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -329,6 +329,7 @@</span> <span class="p_context"> enum {</span>
 
 #define AZX_DCAPS_PRESET_CTHDA \
 	(AZX_DCAPS_NO_MSI | AZX_DCAPS_POSFIX_LPIB |\
<span class="p_add">+	 AZX_DCAPS_NO_64BIT |\</span>
 	 AZX_DCAPS_4K_BDLE_BOUNDARY | AZX_DCAPS_SNOOP_OFF)
 
 /*
<span class="p_chunk">@@ -839,6 +840,36 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 }
 #endif /* CONFIG_PM_SLEEP || SUPPORT_VGA_SWITCHEROO */
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+/* put codec down to D3 at hibernation for Intel SKL+;</span>
<span class="p_add">+ * otherwise BIOS may still access the codec and screw up the driver</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define IS_SKL(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa170)</span>
<span class="p_add">+#define IS_SKL_LP(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x9d70)</span>
<span class="p_add">+#define IS_BXT(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x5a98)</span>
<span class="p_add">+#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci))</span>
<span class="p_add">+</span>
<span class="p_add">+static int azx_freeze_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pci = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKL_PLUS(pci))</span>
<span class="p_add">+		pci_set_power_state(pci, PCI_D3hot);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int azx_thaw_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pci = to_pci_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKL_PLUS(pci))</span>
<span class="p_add">+		pci_set_power_state(pci, PCI_D0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_PM_SLEEP */</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 static int azx_runtime_suspend(struct device *dev)
 {
<span class="p_chunk">@@ -939,6 +970,10 @@</span> <span class="p_context"> static int azx_runtime_idle(struct device *dev)</span>
 
 static const struct dev_pm_ops azx_pm = {
 	SET_SYSTEM_SLEEP_PM_OPS(azx_suspend, azx_resume)
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
<span class="p_add">+	.freeze_noirq = azx_freeze_noirq,</span>
<span class="p_add">+	.thaw_noirq = azx_thaw_noirq,</span>
<span class="p_add">+#endif</span>
 	SET_RUNTIME_PM_OPS(azx_runtime_suspend, azx_runtime_resume, azx_runtime_idle)
 };
 
<span class="p_chunk">@@ -1937,9 +1972,17 @@</span> <span class="p_context"> out_free:</span>
 static void azx_remove(struct pci_dev *pci)
 {
 	struct snd_card *card = pci_get_drvdata(pci);
<span class="p_add">+	struct azx *chip;</span>
<span class="p_add">+	struct hda_intel *hda;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (card) {</span>
<span class="p_add">+		/* flush the pending probing work */</span>
<span class="p_add">+		chip = card-&gt;private_data;</span>
<span class="p_add">+		hda = container_of(chip, struct hda_intel, chip);</span>
<span class="p_add">+		flush_work(&amp;hda-&gt;probe_work);</span>
 
<span class="p_del">-	if (card)</span>
 		snd_card_free(card);
<span class="p_add">+	}</span>
 }
 
 static void azx_shutdown(struct pci_dev *pci)
<span class="p_chunk">@@ -1976,6 +2019,11 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
 	{ PCI_DEVICE(0x8086, 0x8d21),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
<span class="p_add">+	/* Lewisburg */</span>
<span class="p_add">+	{ PCI_DEVICE(0x8086, 0xa1f0),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },</span>
<span class="p_add">+	{ PCI_DEVICE(0x8086, 0xa270),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },</span>
 	/* Lynx Point-LP */
 	{ PCI_DEVICE(0x8086, 0x9c20),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
<span class="p_chunk">@@ -2156,11 +2204,13 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	  .class = PCI_CLASS_MULTIMEDIA_HD_AUDIO &lt;&lt; 8,
 	  .class_mask = 0xffffff,
 	  .driver_data = AZX_DRIVER_CTX | AZX_DCAPS_CTX_WORKAROUND |
<span class="p_add">+	  AZX_DCAPS_NO_64BIT |</span>
 	  AZX_DCAPS_RIRB_PRE_DELAY | AZX_DCAPS_POSFIX_LPIB },
 #else
 	/* this entry seems still valid -- i.e. without emu20kx chip */
 	{ PCI_DEVICE(0x1102, 0x0009),
 	  .driver_data = AZX_DRIVER_CTX | AZX_DCAPS_CTX_WORKAROUND |
<span class="p_add">+	  AZX_DCAPS_NO_64BIT |</span>
 	  AZX_DCAPS_RIRB_PRE_DELAY | AZX_DCAPS_POSFIX_LPIB },
 #endif
 	/* CM8888 */
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 57bb5a559f8e..8189f02f8446 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -111,6 +111,7 @@</span> <span class="p_context"> struct alc_spec {</span>
 	void (*power_hook)(struct hda_codec *codec);
 #endif
 	void (*shutup)(struct hda_codec *codec);
<span class="p_add">+	void (*reboot_notify)(struct hda_codec *codec);</span>
 
 	int init_amp;
 	int codec_variant;	/* flag for other variants */
<span class="p_chunk">@@ -773,6 +774,25 @@</span> <span class="p_context"> static inline void alc_shutup(struct hda_codec *codec)</span>
 		snd_hda_shutup_pins(codec);
 }
 
<span class="p_add">+static void alc_reboot_notify(struct hda_codec *codec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alc_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (spec &amp;&amp; spec-&gt;reboot_notify)</span>
<span class="p_add">+		spec-&gt;reboot_notify(codec);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		alc_shutup(codec);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* power down codec to D3 at reboot/shutdown; set as reboot_notify ops */</span>
<span class="p_add">+static void alc_d3_at_reboot(struct hda_codec *codec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	snd_hda_codec_set_power_to_all(codec, codec-&gt;core.afg, AC_PWRST_D3);</span>
<span class="p_add">+	snd_hda_codec_write(codec, codec-&gt;core.afg, 0,</span>
<span class="p_add">+			    AC_VERB_SET_POWER_STATE, AC_PWRST_D3);</span>
<span class="p_add">+	msleep(10);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define alc_free	snd_hda_gen_free
 
 #ifdef CONFIG_PM
<span class="p_chunk">@@ -818,7 +838,7 @@</span> <span class="p_context"> static const struct hda_codec_ops alc_patch_ops = {</span>
 	.suspend = alc_suspend,
 	.check_power_status = snd_hda_gen_check_power_status,
 #endif
<span class="p_del">-	.reboot_notify = alc_shutup,</span>
<span class="p_add">+	.reboot_notify = alc_reboot_notify,</span>
 };
 
 
<span class="p_chunk">@@ -1767,10 +1787,12 @@</span> <span class="p_context"> enum {</span>
 	ALC889_FIXUP_MBA11_VREF,
 	ALC889_FIXUP_MBA21_VREF,
 	ALC889_FIXUP_MP11_VREF,
<span class="p_add">+	ALC889_FIXUP_MP41_VREF,</span>
 	ALC882_FIXUP_INV_DMIC,
 	ALC882_FIXUP_NO_PRIMARY_HP,
 	ALC887_FIXUP_ASUS_BASS,
 	ALC887_FIXUP_BASS_CHMAP,
<span class="p_add">+	ALC882_FIXUP_DISABLE_AAMIX,</span>
 };
 
 static void alc889_fixup_coef(struct hda_codec *codec,
<span class="p_chunk">@@ -1854,7 +1876,7 @@</span> <span class="p_context"> static void alc889_fixup_mbp_vref(struct hda_codec *codec,</span>
 				  const struct hda_fixup *fix, int action)
 {
 	struct alc_spec *spec = codec-&gt;spec;
<span class="p_del">-	static hda_nid_t nids[2] = { 0x14, 0x15 };</span>
<span class="p_add">+	static hda_nid_t nids[3] = { 0x14, 0x15, 0x19 };</span>
 	int i;
 
 	if (action != HDA_FIXUP_ACT_INIT)
<span class="p_chunk">@@ -1932,6 +1954,8 @@</span> <span class="p_context"> static void alc882_fixup_no_primary_hp(struct hda_codec *codec,</span>
 
 static void alc_fixup_bass_chmap(struct hda_codec *codec,
 				 const struct hda_fixup *fix, int action);
<span class="p_add">+static void alc_fixup_disable_aamix(struct hda_codec *codec,</span>
<span class="p_add">+				    const struct hda_fixup *fix, int action);</span>
 
 static const struct hda_fixup alc882_fixups[] = {
 	[ALC882_FIXUP_ABIT_AW9D_MAX] = {
<span class="p_chunk">@@ -2142,6 +2166,12 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC885_FIXUP_MACPRO_GPIO,
 	},
<span class="p_add">+	[ALC889_FIXUP_MP41_VREF] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc889_fixup_mbp_vref,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC885_FIXUP_MACPRO_GPIO,</span>
<span class="p_add">+	},</span>
 	[ALC882_FIXUP_INV_DMIC] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_inv_dmic,
<span class="p_chunk">@@ -2163,6 +2193,10 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_bass_chmap,
 	},
<span class="p_add">+	[ALC882_FIXUP_DISABLE_AAMIX] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
<span class="p_chunk">@@ -2220,7 +2254,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x106b, 0x3f00, &quot;Macbook 5,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4000, &quot;MacbookPro 5,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4100, &quot;Macmini 3,1&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_del">-	SND_PCI_QUIRK(0x106b, 0x4200, &quot;Mac Pro 5,1&quot;, ALC885_FIXUP_MACPRO_GPIO),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x4200, &quot;Mac Pro 4,1/5,1&quot;, ALC889_FIXUP_MP41_VREF),</span>
 	SND_PCI_QUIRK(0x106b, 0x4300, &quot;iMac 9,1&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4600, &quot;MacbookPro 5,2&quot;, ALC889_FIXUP_IMAC91_VREF),
 	SND_PCI_QUIRK(0x106b, 0x4900, &quot;iMac 9,1 Aluminum&quot;, ALC889_FIXUP_IMAC91_VREF),
<span class="p_chunk">@@ -2230,6 +2264,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
 	SND_PCI_QUIRK_VENDOR(0x1462, &quot;MSI&quot;, ALC882_FIXUP_GPIO3),
 	SND_PCI_QUIRK(0x1458, 0xa002, &quot;Gigabyte EP45-DS3/Z87X-UD3H&quot;, ALC889_FIXUP_FRONT_HP_NO_PRESENCE),
<span class="p_add">+	SND_PCI_QUIRK(0x1458, 0xa182, &quot;Gigabyte Z170X-UD3&quot;, ALC882_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x147b, 0x107a, &quot;Abit AW9D-MAX&quot;, ALC882_FIXUP_ABIT_AW9D_MAX),
 	SND_PCI_QUIRK_VENDOR(0x1558, &quot;Clevo laptop&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x161f, 0x2054, &quot;Medion laptop&quot;, ALC883_FIXUP_EAPD),
<span class="p_chunk">@@ -4194,6 +4229,8 @@</span> <span class="p_context"> static void alc_fixup_tpt440_dock(struct hda_codec *codec,</span>
 	struct alc_spec *spec = codec-&gt;spec;
 
 	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
<span class="p_add">+		spec-&gt;shutup = alc_no_shutup; /* reduce click noise */</span>
<span class="p_add">+		spec-&gt;reboot_notify = alc_d3_at_reboot; /* reduce noise */</span>
 		spec-&gt;parse_flags = HDA_PINCFG_NO_HP_FIXUP;
 		codec-&gt;power_save_node = 0; /* avoid click noises */
 		snd_hda_apply_pincfgs(codec, pincfgs);
<span class="p_chunk">@@ -4525,6 +4562,7 @@</span> <span class="p_context"> enum {</span>
 	ALC255_FIXUP_HEADSET_MODE_NO_HP_MIC,
 	ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC292_FIXUP_TPT440_DOCK,
<span class="p_add">+	ALC292_FIXUP_TPT440,</span>
 	ALC283_FIXUP_BXBT2807_MIC,
 	ALC255_FIXUP_DELL_WMI_MIC_MUTE_LED,
 	ALC282_FIXUP_ASPIRE_V5_PINS,
<span class="p_chunk">@@ -4993,6 +5031,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC269_FIXUP_LIMIT_INT_MIC_BOOST
 	},
<span class="p_add">+	[ALC292_FIXUP_TPT440] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC292_FIXUP_TPT440_DOCK,</span>
<span class="p_add">+	},</span>
 	[ALC283_FIXUP_BXBT2807_MIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -5107,6 +5151,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0775, &quot;Acer Aspire E1-572&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK_E1_572),
 	SND_PCI_QUIRK(0x1025, 0x079b, &quot;Acer Aspire V5-573G&quot;, ALC282_FIXUP_ASPIRE_V5_PINS),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x106d, &quot;Acer Cloudbook 14&quot;, ALC283_FIXUP_CHROME_BOOK),</span>
 	SND_PCI_QUIRK(0x1028, 0x0470, &quot;Dell M101z&quot;, ALC269_FIXUP_DELL_M101Z),
 	SND_PCI_QUIRK(0x1028, 0x05ca, &quot;Dell Latitude E7240&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x05cb, &quot;Dell Latitude E7440&quot;, ALC292_FIXUP_DELL_E7X),
<span class="p_chunk">@@ -5116,6 +5161,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x05f6, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x0615, &quot;Dell Vostro 5470&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x0616, &quot;Dell Vostro 5470&quot;, ALC290_FIXUP_SUBWOOFER_HSJACK),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x062c, &quot;Dell Latitude E5550&quot;, ALC292_FIXUP_DELL_E7X),</span>
 	SND_PCI_QUIRK(0x1028, 0x062e, &quot;Dell Latitude E7450&quot;, ALC292_FIXUP_DELL_E7X),
 	SND_PCI_QUIRK(0x1028, 0x0638, &quot;Dell Inspiron 5439&quot;, ALC290_FIXUP_MONO_SPEAKERS_HSJACK),
 	SND_PCI_QUIRK(0x1028, 0x064a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
<span class="p_chunk">@@ -5227,12 +5273,13 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x21fb, &quot;Thinkpad T430s&quot;, ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2203, &quot;Thinkpad X230 Tablet&quot;, ALC269_FIXUP_LENOVO_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2208, &quot;Thinkpad T431s&quot;, ALC269_FIXUP_LENOVO_DOCK),
<span class="p_del">-	SND_PCI_QUIRK(0x17aa, 0x220c, &quot;Thinkpad T440s&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x220c, &quot;Thinkpad T440s&quot;, ALC292_FIXUP_TPT440),</span>
 	SND_PCI_QUIRK(0x17aa, 0x220e, &quot;Thinkpad T440p&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2210, &quot;Thinkpad T540p&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2212, &quot;Thinkpad T440&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2214, &quot;Thinkpad X240&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2215, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2218, &quot;Thinkpad X1 Carbon 2nd&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x2223, &quot;ThinkPad T550&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
<span class="p_chunk">@@ -5322,6 +5369,7 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{.id = ALC283_FIXUP_CHROME_BOOK, .name = &quot;alc283-dac-wcaps&quot;},
 	{.id = ALC283_FIXUP_SENSE_COMBO_JACK, .name = &quot;alc283-sense-combo&quot;},
 	{.id = ALC292_FIXUP_TPT440_DOCK, .name = &quot;tpt440-dock&quot;},
<span class="p_add">+	{.id = ALC292_FIXUP_TPT440, .name = &quot;tpt440&quot;},</span>
 	{}
 };
 
<span class="p_chunk">@@ -5448,6 +5496,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC255_STANDARD_PINS,
 		{0x12, 0x90a60170},
<span class="p_add">+		{0x14, 0x90171130},</span>
<span class="p_add">+		{0x21, 0x02211040}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x12, 0x90a60170},</span>
 		{0x14, 0x90170140},
 		{0x17, 0x40000000},
 		{0x1d, 0x40700001},
<span class="p_chunk">@@ -6456,6 +6508,7 @@</span> <span class="p_context"> static const struct hda_fixup alc662_fixups[] = {</span>
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x1019, 0x9087, &quot;ECS&quot;, ALC662_FIXUP_ASUS_MODE2),
 	SND_PCI_QUIRK(0x1025, 0x022f, &quot;Acer Aspire One&quot;, ALC662_FIXUP_INV_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x0241, &quot;Packard Bell DOTS&quot;, ALC662_FIXUP_INV_DMIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0308, &quot;Acer Aspire 8942G&quot;, ALC662_FIXUP_ASPIRE),
 	SND_PCI_QUIRK(0x1025, 0x031c, &quot;Gateway NV79&quot;, ALC662_FIXUP_SKU_IGNORE),
 	SND_PCI_QUIRK(0x1025, 0x0349, &quot;eMachines eM250&quot;, ALC662_FIXUP_INV_DMIC),
<span class="p_chunk">@@ -6473,6 +6526,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x069f, &quot;Dell&quot;, ALC668_FIXUP_DELL_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1632, &quot;HP RP5800&quot;, ALC662_FIXUP_HP_RP5800),
 	SND_PCI_QUIRK(0x1043, 0x11cd, &quot;Asus N550&quot;, ALC662_FIXUP_BASS_1A),
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x13df, &quot;Asus N550JX&quot;, ALC662_FIXUP_BASS_1A),</span>
 	SND_PCI_QUIRK(0x1043, 0x1477, &quot;ASUS N56VZ&quot;, ALC662_FIXUP_BASS_MODE4_CHMAP),
 	SND_PCI_QUIRK(0x1043, 0x15a7, &quot;ASUS UX51VZH&quot;, ALC662_FIXUP_BASS_16),
 	SND_PCI_QUIRK(0x1043, 0x1b73, &quot;ASUS N55SF&quot;, ALC662_FIXUP_BASS_16),
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index b1bc66783974..8e7d4c087a7a 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -702,6 +702,7 @@</span> <span class="p_context"> static bool hp_bnb2011_with_dock(struct hda_codec *codec)</span>
 static bool hp_blike_system(u32 subsystem_id)
 {
 	switch (subsystem_id) {
<span class="p_add">+	case 0x103c1473: /* HP ProBook 6550b */</span>
 	case 0x103c1520:
 	case 0x103c1521:
 	case 0x103c1523:
<span class="p_chunk">@@ -3109,6 +3110,29 @@</span> <span class="p_context"> static void stac92hd71bxx_fixup_hp_hdx(struct hda_codec *codec,</span>
 	spec-&gt;gpio_led = 0x08;
 }
 
<span class="p_add">+static bool is_hp_output(struct hda_codec *codec, hda_nid_t pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* count line-out, too, as BIOS sets often so */</span>
<span class="p_add">+	return get_defcfg_connect(pin_cfg) != AC_JACK_PORT_NONE &amp;&amp;</span>
<span class="p_add">+		(get_defcfg_device(pin_cfg) == AC_JACK_LINE_OUT ||</span>
<span class="p_add">+		 get_defcfg_device(pin_cfg) == AC_JACK_HP_OUT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void fixup_hp_headphone(struct hda_codec *codec, hda_nid_t pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It was changed in the BIOS to just satisfy MS DTM.</span>
<span class="p_add">+	 * Lets turn it back into slaved HP</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pin_cfg = (pin_cfg &amp; (~AC_DEFCFG_DEVICE)) |</span>
<span class="p_add">+		(AC_JACK_HP_OUT &lt;&lt; AC_DEFCFG_DEVICE_SHIFT);</span>
<span class="p_add">+	pin_cfg = (pin_cfg &amp; (~(AC_DEFCFG_DEF_ASSOC | AC_DEFCFG_SEQUENCE))) |</span>
<span class="p_add">+		0x1f;</span>
<span class="p_add">+	snd_hda_codec_set_pincfg(codec, pin, pin_cfg);</span>
<span class="p_add">+}</span>
 
 static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,
 				   const struct hda_fixup *fix, int action)
<span class="p_chunk">@@ -3118,22 +3142,12 @@</span> <span class="p_context"> static void stac92hd71bxx_fixup_hp(struct hda_codec *codec,</span>
 	if (action != HDA_FIXUP_ACT_PRE_PROBE)
 		return;
 
<span class="p_del">-	if (hp_blike_system(codec-&gt;core.subsystem_id)) {</span>
<span class="p_del">-		unsigned int pin_cfg = snd_hda_codec_get_pincfg(codec, 0x0f);</span>
<span class="p_del">-		if (get_defcfg_device(pin_cfg) == AC_JACK_LINE_OUT ||</span>
<span class="p_del">-			get_defcfg_device(pin_cfg) == AC_JACK_SPEAKER  ||</span>
<span class="p_del">-			get_defcfg_device(pin_cfg) == AC_JACK_HP_OUT) {</span>
<span class="p_del">-			/* It was changed in the BIOS to just satisfy MS DTM.</span>
<span class="p_del">-			 * Lets turn it back into slaved HP</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			pin_cfg = (pin_cfg &amp; (~AC_DEFCFG_DEVICE))</span>
<span class="p_del">-					| (AC_JACK_HP_OUT &lt;&lt;</span>
<span class="p_del">-						AC_DEFCFG_DEVICE_SHIFT);</span>
<span class="p_del">-			pin_cfg = (pin_cfg &amp; (~(AC_DEFCFG_DEF_ASSOC</span>
<span class="p_del">-							| AC_DEFCFG_SEQUENCE)))</span>
<span class="p_del">-								| 0x1f;</span>
<span class="p_del">-			snd_hda_codec_set_pincfg(codec, 0x0f, pin_cfg);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/* when both output A and F are assigned, these are supposedly</span>
<span class="p_add">+	 * dock and built-in headphones; fix both pin configs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (is_hp_output(codec, 0x0a) &amp;&amp; is_hp_output(codec, 0x0f)) {</span>
<span class="p_add">+		fixup_hp_headphone(codec, 0x0a);</span>
<span class="p_add">+		fixup_hp_headphone(codec, 0x0f);</span>
 	}
 
 	if (find_mute_led_cfg(codec, 1))
<span class="p_header">diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c</span>
<span class="p_header">index 2306ccf7281e..77c963ced67a 100644</span>
<span class="p_header">--- a/sound/pci/rme96.c</span>
<span class="p_header">+++ b/sound/pci/rme96.c</span>
<span class="p_chunk">@@ -741,10 +741,11 @@</span> <span class="p_context"> snd_rme96_playback_setrate(struct rme96 *rme96,</span>
 	{
 		/* change to/from double-speed: reset the DAC (if available) */
 		snd_rme96_reset_dac(rme96);
<span class="p_add">+		return 1; /* need to restore volume */</span>
 	} else {
 		writel(rme96-&gt;wcreg, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
<span class="p_add">+		return 0;</span>
 	}
<span class="p_del">-	return 0;</span>
 }
 
 static int
<span class="p_chunk">@@ -980,6 +981,7 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
 	int err, rate, dummy;
<span class="p_add">+	bool apply_dac_volume = false;</span>
 
 	runtime-&gt;dma_area = (void __force *)(rme96-&gt;iobase +
 					     RME96_IO_PLAY_BUFFER);
<span class="p_chunk">@@ -993,24 +995,26 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	{
                 /* slave clock */
                 if ((int)params_rate(params) != rate) {
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EIO;                    </span>
<span class="p_del">-                }</span>
<span class="p_del">-	} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((err = snd_rme96_playback_setformat(rme96, params_format(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+			err = -EIO;</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = snd_rme96_playback_setrate(rme96, params_rate(params));</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		apply_dac_volume = err &gt; 0; /* need to restore volume later? */</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = snd_rme96_playback_setformat(rme96, params_format(params));</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
 	snd_rme96_setframelog(rme96, params_channels(params), 1);
 	if (rme96-&gt;capture_periodsize != 0) {
 		if (params_period_size(params) &lt;&lt; rme96-&gt;playback_frlog !=
 		    rme96-&gt;capture_periodsize)
 		{
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_add">+			err = -EBUSY;</span>
<span class="p_add">+			goto error;</span>
 		}
 	}
 	rme96-&gt;playback_periodsize =
<span class="p_chunk">@@ -1021,9 +1025,16 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 		rme96-&gt;wcreg &amp;= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
 		writel(rme96-&gt;wcreg |= rme96-&gt;wcreg_spdif_stream, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+ error:</span>
 	spin_unlock_irq(&amp;rme96-&gt;lock);
<span class="p_del">-		</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (apply_dac_volume) {</span>
<span class="p_add">+		usleep_range(3000, 10000);</span>
<span class="p_add">+		snd_rme96_apply_dac_volume(rme96);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static int
<span class="p_header">diff --git a/sound/soc/codecs/arizona.c b/sound/soc/codecs/arizona.c</span>
<span class="p_header">index ee91edcf3cb0..13191891fc4c 100644</span>
<span class="p_header">--- a/sound/soc/codecs/arizona.c</span>
<span class="p_header">+++ b/sound/soc/codecs/arizona.c</span>
<span class="p_chunk">@@ -1354,7 +1354,7 @@</span> <span class="p_context"> static int arizona_hw_params(struct snd_pcm_substream *substream,</span>
 	bool reconfig;
 	unsigned int aif_tx_state, aif_rx_state;
 
<span class="p_del">-	if (params_rate(params) % 8000)</span>
<span class="p_add">+	if (params_rate(params) % 4000)</span>
 		rates = &amp;arizona_44k1_bclk_rates[0];
 	else
 		rates = &amp;arizona_48k_bclk_rates[0];
<span class="p_header">diff --git a/sound/soc/codecs/es8328.c b/sound/soc/codecs/es8328.c</span>
<span class="p_header">index c5f35a07e8e4..3ad7f5be1cfa 100644</span>
<span class="p_header">--- a/sound/soc/codecs/es8328.c</span>
<span class="p_header">+++ b/sound/soc/codecs/es8328.c</span>
<span class="p_chunk">@@ -85,7 +85,15 @@</span> <span class="p_context"> static const DECLARE_TLV_DB_SCALE(pga_tlv, 0, 300, 0);</span>
 static const DECLARE_TLV_DB_SCALE(bypass_tlv, -1500, 300, 0);
 static const DECLARE_TLV_DB_SCALE(mic_tlv, 0, 300, 0);
 
<span class="p_del">-static const int deemph_settings[] = { 0, 32000, 44100, 48000 };</span>
<span class="p_add">+static const struct {</span>
<span class="p_add">+	int rate;</span>
<span class="p_add">+	unsigned int val;</span>
<span class="p_add">+} deemph_settings[] = {</span>
<span class="p_add">+	{ 0,     ES8328_DACCONTROL6_DEEMPH_OFF },</span>
<span class="p_add">+	{ 32000, ES8328_DACCONTROL6_DEEMPH_32k },</span>
<span class="p_add">+	{ 44100, ES8328_DACCONTROL6_DEEMPH_44_1k },</span>
<span class="p_add">+	{ 48000, ES8328_DACCONTROL6_DEEMPH_48k },</span>
<span class="p_add">+};</span>
 
 static int es8328_set_deemph(struct snd_soc_codec *codec)
 {
<span class="p_chunk">@@ -97,21 +105,22 @@</span> <span class="p_context"> static int es8328_set_deemph(struct snd_soc_codec *codec)</span>
 	 * rate.
 	 */
 	if (es8328-&gt;deemph) {
<span class="p_del">-		best = 1;</span>
<span class="p_del">-		for (i = 2; i &lt; ARRAY_SIZE(deemph_settings); i++) {</span>
<span class="p_del">-			if (abs(deemph_settings[i] - es8328-&gt;playback_fs) &lt;</span>
<span class="p_del">-			    abs(deemph_settings[best] - es8328-&gt;playback_fs))</span>
<span class="p_add">+		best = 0;</span>
<span class="p_add">+		for (i = 1; i &lt; ARRAY_SIZE(deemph_settings); i++) {</span>
<span class="p_add">+			if (abs(deemph_settings[i].rate - es8328-&gt;playback_fs) &lt;</span>
<span class="p_add">+			    abs(deemph_settings[best].rate - es8328-&gt;playback_fs))</span>
 				best = i;
 		}
 
<span class="p_del">-		val = best &lt;&lt; 1;</span>
<span class="p_add">+		val = deemph_settings[best].val;</span>
 	} else {
<span class="p_del">-		val = 0;</span>
<span class="p_add">+		val = ES8328_DACCONTROL6_DEEMPH_OFF;</span>
 	}
 
 	dev_dbg(codec-&gt;dev, &quot;Set deemphasis %d\n&quot;, val);
 
<span class="p_del">-	return snd_soc_update_bits(codec, ES8328_DACCONTROL6, 0x6, val);</span>
<span class="p_add">+	return snd_soc_update_bits(codec, ES8328_DACCONTROL6,</span>
<span class="p_add">+			ES8328_DACCONTROL6_DEEMPH_MASK, val);</span>
 }
 
 static int es8328_get_deemph(struct snd_kcontrol *kcontrol,
<span class="p_header">diff --git a/sound/soc/codecs/es8328.h b/sound/soc/codecs/es8328.h</span>
<span class="p_header">index cb36afe10c0e..156c748c89c7 100644</span>
<span class="p_header">--- a/sound/soc/codecs/es8328.h</span>
<span class="p_header">+++ b/sound/soc/codecs/es8328.h</span>
<span class="p_chunk">@@ -153,6 +153,7 @@</span> <span class="p_context"> int es8328_probe(struct device *dev, struct regmap *regmap);</span>
 #define ES8328_DACCONTROL6_CLICKFREE (1 &lt;&lt; 3)
 #define ES8328_DACCONTROL6_DAC_INVR (1 &lt;&lt; 4)
 #define ES8328_DACCONTROL6_DAC_INVL (1 &lt;&lt; 5)
<span class="p_add">+#define ES8328_DACCONTROL6_DEEMPH_MASK (3 &lt;&lt; 6)</span>
 #define ES8328_DACCONTROL6_DEEMPH_OFF (0 &lt;&lt; 6)
 #define ES8328_DACCONTROL6_DEEMPH_32k (1 &lt;&lt; 6)
 #define ES8328_DACCONTROL6_DEEMPH_44_1k (2 &lt;&lt; 6)
<span class="p_header">diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c</span>
<span class="p_header">index 118b0034ba23..154c1a24a303 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8962.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8962.c</span>
<span class="p_chunk">@@ -365,8 +365,8 @@</span> <span class="p_context"> static struct reg_default wm8962_reg[] = {</span>
 	{ 16924, 0x0059 },   /* R16924 - HDBASS_PG_1 */
 	{ 16925, 0x999A },   /* R16925 - HDBASS_PG_0 */
 
<span class="p_del">-	{ 17048, 0x0083 },   /* R17408 - HPF_C_1 */</span>
<span class="p_del">-	{ 17049, 0x98AD },   /* R17409 - HPF_C_0 */</span>
<span class="p_add">+	{ 17408, 0x0083 },   /* R17408 - HPF_C_1 */</span>
<span class="p_add">+	{ 17409, 0x98AD },   /* R17409 - HPF_C_0 */</span>
 
 	{ 17920, 0x007F },   /* R17920 - ADCL_RETUNE_C1_1 */
 	{ 17921, 0xFFFF },   /* R17921 - ADCL_RETUNE_C1_0 */
<span class="p_header">diff --git a/sound/soc/codecs/wm8974.c b/sound/soc/codecs/wm8974.c</span>
<span class="p_header">index ff0e4646b934..88317c1b7f96 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8974.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8974.c</span>
<span class="p_chunk">@@ -575,6 +575,7 @@</span> <span class="p_context"> static const struct regmap_config wm8974_regmap = {</span>
 	.max_register = WM8974_MONOMIX,
 	.reg_defaults = wm8974_reg_defaults,
 	.num_reg_defaults = ARRAY_SIZE(wm8974_reg_defaults),
<span class="p_add">+	.cache_type = REGCACHE_FLAT,</span>
 };
 
 static int wm8974_probe(struct snd_soc_codec *codec)
<span class="p_header">diff --git a/sound/soc/davinci/davinci-mcasp.c b/sound/soc/davinci/davinci-mcasp.c</span>
<span class="p_header">index 23c91fa65ab8..76dd8c6aa4f0 100644</span>
<span class="p_header">--- a/sound/soc/davinci/davinci-mcasp.c</span>
<span class="p_header">+++ b/sound/soc/davinci/davinci-mcasp.c</span>
<span class="p_chunk">@@ -221,8 +221,8 @@</span> <span class="p_context"> static void mcasp_start_tx(struct davinci_mcasp *mcasp)</span>
 
 	/* wait for XDATA to be cleared */
 	cnt = 0;
<span class="p_del">-	while (!(mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG) &amp;</span>
<span class="p_del">-		 ~XRDATA) &amp;&amp; (cnt &lt; 100000))</span>
<span class="p_add">+	while ((mcasp_get_reg(mcasp, DAVINCI_MCASP_TXSTAT_REG) &amp; XRDATA) &amp;&amp;</span>
<span class="p_add">+	       (cnt &lt; 100000))</span>
 		cnt++;
 
 	/* Release TX state machine */
<span class="p_header">diff --git a/sound/soc/sh/rcar/gen.c b/sound/soc/sh/rcar/gen.c</span>
<span class="p_header">index 8c7dc51b1c4f..f7a0cb786d5c 100644</span>
<span class="p_header">--- a/sound/soc/sh/rcar/gen.c</span>
<span class="p_header">+++ b/sound/soc/sh/rcar/gen.c</span>
<span class="p_chunk">@@ -214,7 +214,7 @@</span> <span class="p_context"> static int rsnd_gen2_probe(struct platform_device *pdev,</span>
 		RSND_GEN_S_REG(SCU_SYS_STATUS0,	0x1c8),
 		RSND_GEN_S_REG(SCU_SYS_INT_EN0,	0x1cc),
 		RSND_GEN_S_REG(SCU_SYS_STATUS1,	0x1d0),
<span class="p_del">-		RSND_GEN_S_REG(SCU_SYS_INT_EN1,	0x1c4),</span>
<span class="p_add">+		RSND_GEN_S_REG(SCU_SYS_INT_EN1,	0x1d4),</span>
 		RSND_GEN_M_REG(SRC_SWRSR,	0x200,	0x40),
 		RSND_GEN_M_REG(SRC_SRCIR,	0x204,	0x40),
 		RSND_GEN_M_REG(SRC_ADINR,	0x214,	0x40),
<span class="p_header">diff --git a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c</span>
<span class="p_header">index 025c38fbe3c0..1874cf0e6cab 100644</span>
<span class="p_header">--- a/sound/soc/soc-compress.c</span>
<span class="p_header">+++ b/sound/soc/soc-compress.c</span>
<span class="p_chunk">@@ -623,6 +623,7 @@</span> <span class="p_context"> int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)</span>
 	struct snd_pcm *be_pcm;
 	char new_name[64];
 	int ret = 0, direction = 0;
<span class="p_add">+	int playback = 0, capture = 0;</span>
 
 	if (rtd-&gt;num_codecs &gt; 1) {
 		dev_err(rtd-&gt;card-&gt;dev, &quot;Multicodec not supported for compressed stream\n&quot;);
<span class="p_chunk">@@ -634,11 +635,27 @@</span> <span class="p_context"> int soc_new_compress(struct snd_soc_pcm_runtime *rtd, int num)</span>
 			rtd-&gt;dai_link-&gt;stream_name, codec_dai-&gt;name, num);
 
 	if (codec_dai-&gt;driver-&gt;playback.channels_min)
<span class="p_add">+		playback = 1;</span>
<span class="p_add">+	if (codec_dai-&gt;driver-&gt;capture.channels_min)</span>
<span class="p_add">+		capture = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	capture = capture &amp;&amp; cpu_dai-&gt;driver-&gt;capture.channels_min;</span>
<span class="p_add">+	playback = playback &amp;&amp; cpu_dai-&gt;driver-&gt;playback.channels_min;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Compress devices are unidirectional so only one of the directions</span>
<span class="p_add">+	 * should be set, check for that (xor)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (playback + capture != 1) {</span>
<span class="p_add">+		dev_err(rtd-&gt;card-&gt;dev, &quot;Invalid direction for compress P %d, C %d\n&quot;,</span>
<span class="p_add">+				playback, capture);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if(playback)</span>
 		direction = SND_COMPRESS_PLAYBACK;
<span class="p_del">-	else if (codec_dai-&gt;driver-&gt;capture.channels_min)</span>
<span class="p_del">-		direction = SND_COMPRESS_CAPTURE;</span>
 	else
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		direction = SND_COMPRESS_CAPTURE;</span>
 
 	compr = kzalloc(sizeof(*compr), GFP_KERNEL);
 	if (compr == NULL) {
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index cd8ed2e393a2..f9a9752d4dbc 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -1336,6 +1336,8 @@</span> <span class="p_context"> static void build_feature_ctl(struct mixer_build *state, void *raw_desc,</span>
 		}
 	}
 
<span class="p_add">+	snd_usb_mixer_fu_apply_quirk(state-&gt;mixer, cval, unitid, kctl);</span>
<span class="p_add">+</span>
 	range = (cval-&gt;max - cval-&gt;min) / cval-&gt;res;
 	/*
 	 * Are there devices with volume range more than 255? I use a bit more
<span class="p_header">diff --git a/sound/usb/mixer_maps.c b/sound/usb/mixer_maps.c</span>
<span class="p_header">index 6a803eff87f7..ddca6547399b 100644</span>
<span class="p_header">--- a/sound/usb/mixer_maps.c</span>
<span class="p_header">+++ b/sound/usb/mixer_maps.c</span>
<span class="p_chunk">@@ -348,13 +348,6 @@</span> <span class="p_context"> static struct usbmix_name_map bose_companion5_map[] = {</span>
 	{ 0 }	/* terminator */
 };
 
<span class="p_del">-/* Dragonfly DAC 1.2, the dB conversion factor is 1 instead of 256 */</span>
<span class="p_del">-static struct usbmix_dB_map dragonfly_1_2_dB = {0, 5000};</span>
<span class="p_del">-static struct usbmix_name_map dragonfly_1_2_map[] = {</span>
<span class="p_del">-	{ 7, NULL, .dB = &amp;dragonfly_1_2_dB },</span>
<span class="p_del">-	{ 0 }	/* terminator */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /*
  * Control map entries
  */
<span class="p_chunk">@@ -470,11 +463,6 @@</span> <span class="p_context"> static struct usbmix_ctl_map usbmix_ctl_maps[] = {</span>
 		.id = USB_ID(0x05a7, 0x1020),
 		.map = bose_companion5_map,
 	},
<span class="p_del">-	{</span>
<span class="p_del">-		/* Dragonfly DAC 1.2 */</span>
<span class="p_del">-		.id = USB_ID(0x21b4, 0x0081),</span>
<span class="p_del">-		.map = dragonfly_1_2_map,</span>
<span class="p_del">-	},</span>
 	{ 0 } /* terminator */
 };
 
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 337c317ead6f..db9547d04f38 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #include &lt;sound/control.h&gt;
 #include &lt;sound/hwdep.h&gt;
 #include &lt;sound/info.h&gt;
<span class="p_add">+#include &lt;sound/tlv.h&gt;</span>
 
 #include &quot;usbaudio.h&quot;
 #include &quot;mixer.h&quot;
<span class="p_chunk">@@ -802,7 +803,7 @@</span> <span class="p_context"> static int snd_nativeinstruments_control_put(struct snd_kcontrol *kcontrol,</span>
 		return 0;
 
 	kcontrol-&gt;private_value &amp;= ~(0xff &lt;&lt; 24);
<span class="p_del">-	kcontrol-&gt;private_value |= newval;</span>
<span class="p_add">+	kcontrol-&gt;private_value |= (unsigned int)newval &lt;&lt; 24;</span>
 	err = snd_ni_update_cur_val(list);
 	return err &lt; 0 ? err : 1;
 }
<span class="p_chunk">@@ -1843,3 +1844,39 @@</span> <span class="p_context"> void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,</span>
 	}
 }
 
<span class="p_add">+static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+					 struct snd_kcontrol *kctl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Approximation using 10 ranges based on output measurement on hw v1.2.</span>
<span class="p_add">+	 * This seems close to the cubic mapping e.g. alsamixer uses. */</span>
<span class="p_add">+	static const DECLARE_TLV_DB_RANGE(scale,</span>
<span class="p_add">+		 0,  1, TLV_DB_MINMAX_ITEM(-5300, -4970),</span>
<span class="p_add">+		 2,  5, TLV_DB_MINMAX_ITEM(-4710, -4160),</span>
<span class="p_add">+		 6,  7, TLV_DB_MINMAX_ITEM(-3884, -3710),</span>
<span class="p_add">+		 8, 14, TLV_DB_MINMAX_ITEM(-3443, -2560),</span>
<span class="p_add">+		15, 16, TLV_DB_MINMAX_ITEM(-2475, -2324),</span>
<span class="p_add">+		17, 19, TLV_DB_MINMAX_ITEM(-2228, -2031),</span>
<span class="p_add">+		20, 26, TLV_DB_MINMAX_ITEM(-1910, -1393),</span>
<span class="p_add">+		27, 31, TLV_DB_MINMAX_ITEM(-1322, -1032),</span>
<span class="p_add">+		32, 40, TLV_DB_MINMAX_ITEM(-968, -490),</span>
<span class="p_add">+		41, 50, TLV_DB_MINMAX_ITEM(-441, 0),</span>
<span class="p_add">+	);</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk\n&quot;);</span>
<span class="p_add">+	kctl-&gt;tlv.p = scale;</span>
<span class="p_add">+	kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_add">+	kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+				  struct usb_mixer_elem_info *cval, int unitid,</span>
<span class="p_add">+				  struct snd_kcontrol *kctl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (mixer-&gt;chip-&gt;usb_id) {</span>
<span class="p_add">+	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */</span>
<span class="p_add">+		if (unitid == 7 &amp;&amp; cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50)</span>
<span class="p_add">+			snd_dragonfly_quirk_db_scale(mixer, kctl);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/sound/usb/mixer_quirks.h b/sound/usb/mixer_quirks.h</span>
<span class="p_header">index bdbfab093816..177c329cd4dd 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.h</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.h</span>
<span class="p_chunk">@@ -9,5 +9,9 @@</span> <span class="p_context"> void snd_emuusb_set_samplerate(struct snd_usb_audio *chip,</span>
 void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,
 				    int unitid);
 
<span class="p_add">+void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
<span class="p_add">+				  struct usb_mixer_elem_info *cval, int unitid,</span>
<span class="p_add">+				  struct snd_kcontrol *kctl);</span>
<span class="p_add">+</span>
 #endif /* SND_USB_MIXER_QUIRKS_H */
 
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index eef9b8e4b949..fb9a8a5787a6 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1122,6 +1122,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
<span class="p_add">+	case USB_ID(0x21B4, 0x0081): /* AudioQuest DragonFly */</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -1265,6 +1266,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
<span class="p_add">+	case USB_ID(0x22d8, 0x0416): /* OPPO HA-1*/</span>
 		if (fp-&gt;altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



