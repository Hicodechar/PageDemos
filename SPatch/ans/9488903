
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[RFC,PATCHv2,29/29] mm, x86: introduce RLIMIT_VADDR - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [RFC,PATCHv2,29/29] mm, x86: introduce RLIMIT_VADDR</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=40781">Kirill A. Shutemov</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 27, 2016, 1:54 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161227015413.187403-30-kirill.shutemov@linux.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9488903/mbox/"
   >mbox</a>
|
   <a href="/patch/9488903/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9488903/">/patch/9488903/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2204B62AAD for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 27 Dec 2016 01:58:20 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 131801FF60
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 27 Dec 2016 01:58:20 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 07FE81FFCA; Tue, 27 Dec 2016 01:58:20 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CE1C41FF60
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 27 Dec 2016 01:58:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756245AbcL0B6N (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 26 Dec 2016 20:58:13 -0500
Received: from mga09.intel.com ([134.134.136.24]:5265 &quot;EHLO mga09.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1755918AbcL0By6 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 26 Dec 2016 20:54:58 -0500
Received: from fmsmga003.fm.intel.com ([10.253.24.29])
	by orsmga102.jf.intel.com with ESMTP; 26 Dec 2016 17:54:50 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.33,414,1477983600&quot;; d=&quot;scan&#39;208&quot;;a=&quot;802523004&quot;
Received: from black.fi.intel.com ([10.237.72.28])
	by FMSMGA003.fm.intel.com with ESMTP; 26 Dec 2016 17:54:47 -0800
Received: by black.fi.intel.com (Postfix, from userid 1000)
	id 843B05BA; Tue, 27 Dec 2016 03:54:35 +0200 (EET)
From: &quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;, x86@kernel.org,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	Ingo Molnar &lt;mingo@redhat.com&gt;, Arnd Bergmann &lt;arnd@arndb.de&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;
Cc: Andi Kleen &lt;ak@linux.intel.com&gt;, Dave Hansen &lt;dave.hansen@intel.com&gt;,
	Andy Lutomirski &lt;luto@amacapital.net&gt;,
	linux-arch@vger.kernel.org, linux-mm@kvack.org,
	linux-kernel@vger.kernel.org,
	&quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;,
	linux-api@vger.kernel.org
Subject: [RFC, PATCHv2 29/29] mm, x86: introduce RLIMIT_VADDR
Date: Tue, 27 Dec 2016 04:54:13 +0300
Message-Id: &lt;20161227015413.187403-30-kirill.shutemov@linux.intel.com&gt;
X-Mailer: git-send-email 2.11.0
In-Reply-To: &lt;20161227015413.187403-1-kirill.shutemov@linux.intel.com&gt;
References: &lt;20161227015413.187403-1-kirill.shutemov@linux.intel.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=40781">Kirill A. Shutemov</a> - Dec. 27, 2016, 1:54 a.m.</div>
<pre class="content">
This patch introduces new rlimit resource to manage maximum virtual
address available to userspace to map.

On x86, 5-level paging enables 56-bit userspace virtual address space.
Not all user space is ready to handle wide addresses. It&#39;s known that
at least some JIT compilers use high bit in pointers to encode their
information. It collides with valid pointers with 5-level paging and
leads to crashes.

The patch aims to address this compatibility issue.

MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual
address available to map by userspace.

The default hard limit will be RLIM_INFINITY, which basically means that
TASK_SIZE limits available address space.

The soft limit will also be RLIM_INFINITY everywhere, but the machine
with 5-level paging enabled. In this case, soft limit would be
(1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level
paging which known to be safe

New rlimit resource would follow usual semantics with regards to
inheritance: preserved on fork(2) and exec(2). This has potential to
break application if limits set too wide or too narrow, but this is not
uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).

As with other resources you can set the limit lower than current usage.
It would affect only future virtual address space allocations.

Use-cases for new rlimit:

  - Bumping the soft limit to RLIM_INFINITY, allows current process all
    its children to use addresses above 47-bits.

  - Bumping the soft limit to RLIM_INFINITY after fork(2), but before
    exec(2) allows the child to use addresses above 47-bits.

  - Lowering the hard limit to 47-bits would prevent current process all
    its children to use addresses above 47-bits, unless a process has
    CAP_SYS_RESOURCES.

  - It’s also can be handy to lower hard or soft limit to arbitrary
    address. User-mode emulation in QEMU may lower the limit to 32-bit
    to emulate 32-bit machine on 64-bit host.

TODO:
  - port to non-x86;

Not-yet-signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;
Cc: linux-api@vger.kernel.org
---
 arch/x86/include/asm/elf.h          |  2 +-
 arch/x86/include/asm/processor.h    | 17 ++++++++++++-----
 arch/x86/kernel/sys_x86_64.c        |  6 +++---
 arch/x86/mm/hugetlbpage.c           |  8 ++++----
 arch/x86/mm/mmap.c                  |  4 ++--
 fs/binfmt_aout.c                    |  2 --
 fs/binfmt_elf.c                     | 10 +++++-----
 fs/hugetlbfs/inode.c                |  6 +++---
 fs/proc/base.c                      |  1 +
 include/asm-generic/resource.h      |  4 ++++
 include/linux/sched.h               |  5 +++++
 include/uapi/asm-generic/resource.h |  3 ++-
 kernel/events/uprobes.c             |  5 +++--
 kernel/sys.c                        |  6 +++---
 mm/mmap.c                           | 20 +++++++++++---------
 mm/mremap.c                         |  3 ++-
 mm/nommu.c                          |  2 +-
 mm/shmem.c                          |  8 ++++----
 18 files changed, 66 insertions(+), 46 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Dec. 27, 2016, 2:06 a.m.</div>
<pre class="content">
On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov
&lt;kirill.shutemov@linux.intel.com&gt; wrote:
<span class="quote">&gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt; address available to userspace to map.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt; leads to crashes.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; address available to map by userspace.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt; paging which known to be safe</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;     to emulate 32-bit machine on 64-bit host.</span>

I tend to think that this should be a personality or an ELF flag, not
an rlimit.  That way setuid works right.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Dec. 27, 2016, 2:24 a.m.</div>
<pre class="content">
On Mon, Dec 26, 2016 at 06:06:01PM -0800, Andy Lutomirski wrote:
<span class="quote">&gt; On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov</span>
<span class="quote">&gt; &lt;kirill.shutemov@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt; &gt; address available to userspace to map.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt; &gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt; &gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt; &gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt; &gt; leads to crashes.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; &gt; address available to map by userspace.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt; &gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt; &gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt; &gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt; &gt; paging which known to be safe</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt; &gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt; &gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt; &gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt; &gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Use-cases for new rlimit:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt; &gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt; &gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt; &gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt; &gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt; &gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt; &gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I tend to think that this should be a personality or an ELF flag, not</span>
<span class="quote">&gt; an rlimit.</span>

My plan was to implement ELF flag on top. Basically, ELF flag would mean
that we bump soft limit to hard limit on exec.
<span class="quote">
&gt; That way setuid works right.</span>

Um.. I probably miss background here.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Dec. 27, 2016, 3:22 a.m.</div>
<pre class="content">
On Mon, Dec 26, 2016 at 6:24 PM, Kirill A. Shutemov
&lt;kirill@shutemov.name&gt; wrote:
<span class="quote">&gt; On Mon, Dec 26, 2016 at 06:06:01PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt; On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov</span>
<span class="quote">&gt;&gt; &lt;kirill.shutemov@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt;&gt; &gt; address available to userspace to map.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt;&gt; &gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt;&gt; &gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt;&gt; &gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt;&gt; &gt; leads to crashes.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt;&gt; &gt; address available to map by userspace.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt;&gt; &gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt;&gt; &gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt;&gt; &gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt;&gt; &gt; paging which known to be safe</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt;&gt; &gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt;&gt; &gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt;&gt; &gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt;&gt; &gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; Use-cases for new rlimit:</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;&gt; &gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt;&gt; &gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;&gt; &gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;&gt; &gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;&gt; &gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;&gt; &gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I tend to think that this should be a personality or an ELF flag, not</span>
<span class="quote">&gt;&gt; an rlimit.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; My plan was to implement ELF flag on top. Basically, ELF flag would mean</span>
<span class="quote">&gt; that we bump soft limit to hard limit on exec.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; That way setuid works right.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Um.. I probably miss background here.</span>
<span class="quote">&gt;</span>

If a setuid program depends on the lower limit, then a malicious
program shouldn&#39;t be able to cause it to run with the higher limit.
The personality code should already get this case right because
personalities are reset when setuid happens.

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=74241">Carlos O&#39;Donell</a> - Dec. 29, 2016, 2:53 a.m.</div>
<pre class="content">
On 12/26/2016 09:24 PM, Kirill A. Shutemov wrote:
<span class="quote">&gt; On Mon, Dec 26, 2016 at 06:06:01PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt; On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov</span>
<span class="quote">&gt;&gt; &lt;kirill.shutemov@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt;&gt;&gt; address available to userspace to map.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt;&gt;&gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt;&gt;&gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt;&gt;&gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt;&gt;&gt; leads to crashes.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt;&gt;&gt; address available to map by userspace.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt;&gt;&gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt;&gt;&gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt;&gt;&gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt;&gt;&gt; paging which known to be safe</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt;&gt;&gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt;&gt;&gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt;&gt;&gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt;&gt;&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;&gt;&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt;&gt;&gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;&gt;&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;&gt;&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;&gt;&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;&gt;&gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I tend to think that this should be a personality or an ELF flag, not</span>
<span class="quote">&gt;&gt; an rlimit.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; My plan was to implement ELF flag on top. Basically, ELF flag would mean</span>
<span class="quote">&gt; that we bump soft limit to hard limit on exec.</span>

Could you clarify what you mean by an &quot;ELF flag?&quot;
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Dec. 31, 2016, 2:08 a.m.</div>
<pre class="content">
On Wed, Dec 28, 2016 at 6:53 PM, Carlos O&#39;Donell &lt;carlos@redhat.com&gt; wrote:
<span class="quote">&gt; On 12/26/2016 09:24 PM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt;&gt; On Mon, Dec 26, 2016 at 06:06:01PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;&gt; On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov</span>
<span class="quote">&gt;&gt;&gt; &lt;kirill.shutemov@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt;&gt;&gt;&gt; address available to userspace to map.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt;&gt;&gt;&gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt;&gt;&gt;&gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt;&gt;&gt;&gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt;&gt;&gt;&gt; leads to crashes.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt;&gt;&gt;&gt; address available to map by userspace.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt;&gt;&gt;&gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt;&gt;&gt;&gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt;&gt;&gt;&gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt;&gt;&gt;&gt; paging which known to be safe</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt;&gt;&gt;&gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt;&gt;&gt;&gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt;&gt;&gt;&gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt;&gt;&gt;&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;&gt;&gt;&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt;&gt;&gt;&gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;&gt;&gt;&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;&gt;&gt;&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;&gt;&gt;&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;&gt;&gt;&gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I tend to think that this should be a personality or an ELF flag, not</span>
<span class="quote">&gt;&gt;&gt; an rlimit.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; My plan was to implement ELF flag on top. Basically, ELF flag would mean</span>
<span class="quote">&gt;&gt; that we bump soft limit to hard limit on exec.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Could you clarify what you mean by an &quot;ELF flag?&quot;</span>

Some way to mark a binary as supporting a larger address space.  I
don&#39;t have a precise solution in mind, but an ELF note might be a good
way to go here.

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Jan. 2, 2017, 8:35 a.m.</div>
<pre class="content">
On Fri, Dec 30, 2016 at 06:08:27PM -0800, Andy Lutomirski wrote:
<span class="quote">&gt; On Wed, Dec 28, 2016 at 6:53 PM, Carlos O&#39;Donell &lt;carlos@redhat.com&gt; wrote:</span>
<span class="quote">&gt; &gt; On 12/26/2016 09:24 PM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt;&gt; On Mon, Dec 26, 2016 at 06:06:01PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov</span>
<span class="quote">&gt; &gt;&gt;&gt; &lt;kirill.shutemov@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; address available to userspace to map.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; leads to crashes.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; address available to map by userspace.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; paging which known to be safe</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I tend to think that this should be a personality or an ELF flag, not</span>
<span class="quote">&gt; &gt;&gt;&gt; an rlimit.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; My plan was to implement ELF flag on top. Basically, ELF flag would mean</span>
<span class="quote">&gt; &gt;&gt; that we bump soft limit to hard limit on exec.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Could you clarify what you mean by an &quot;ELF flag?&quot;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Some way to mark a binary as supporting a larger address space.  I</span>
<span class="quote">&gt; don&#39;t have a precise solution in mind, but an ELF note might be a good</span>
<span class="quote">&gt; way to go here.</span>

+ H.J.

There&#39;s discussion of proposal of &quot;Program Properties&quot;[1]. It seems fits
the purpose.

[1] https://sourceware.org/ml/gnu-gabi/2016-q4/msg00000.html
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Jan. 2, 2017, 8:44 a.m.</div>
<pre class="content">
On Tuesday, December 27, 2016 4:54:13 AM CET Kirill A. Shutemov wrote:
<span class="quote">&gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt; address available to userspace to map.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt; leads to crashes.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; address available to map by userspace.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt; paging which known to be safe</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; TODO:</span>
<span class="quote">&gt;   - port to non-x86;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Not-yet-signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt; Cc: linux-api@vger.kernel.org</span>

This seems to nicely address the same problem on arm64, which has
run into the same issue due to the various page table formats
that can currently be chosen at compile time.

I don&#39;t see how this interacts with the existing
PER_LINUX32/PER_LINUX32_3GB personality flags, but I assume you have
either already thought of that, or we can come up with a good way
to define what happens when conflicting settings are applied.

The two reasonable ways I can think of are to either use the
minimum of the two limits, or to make the personality syscall
set the soft rlimit and use whatever limit was last set.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Jan. 2, 2017, 9:09 a.m.</div>
<pre class="content">
On Mon, Dec 26, 2016 at 07:22:03PM -0800, Andy Lutomirski wrote:
<span class="quote">&gt; On Mon, Dec 26, 2016 at 6:24 PM, Kirill A. Shutemov</span>
<span class="quote">&gt; &lt;kirill@shutemov.name&gt; wrote:</span>
<span class="quote">&gt; &gt; On Mon, Dec 26, 2016 at 06:06:01PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt; &gt;&gt; On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov</span>
<span class="quote">&gt; &gt;&gt; &lt;kirill.shutemov@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt; &gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt; &gt;&gt; &gt; address available to userspace to map.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt; &gt;&gt; &gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt; &gt;&gt; &gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt; &gt;&gt; &gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt; &gt;&gt; &gt; leads to crashes.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; &gt;&gt; &gt; address available to map by userspace.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt; &gt;&gt; &gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt; &gt;&gt; &gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt; &gt;&gt; &gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt; &gt;&gt; &gt; paging which known to be safe</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt; &gt;&gt; &gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt; &gt;&gt; &gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt; &gt;&gt; &gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt; &gt;&gt; &gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; Use-cases for new rlimit:</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt; &gt;&gt; &gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt; &gt;&gt; &gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt; &gt;&gt; &gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt; &gt;&gt; &gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt; &gt;&gt; &gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt; &gt;&gt; &gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I tend to think that this should be a personality or an ELF flag, not</span>
<span class="quote">&gt; &gt;&gt; an rlimit.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; My plan was to implement ELF flag on top. Basically, ELF flag would mean</span>
<span class="quote">&gt; &gt; that we bump soft limit to hard limit on exec.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; That way setuid works right.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Um.. I probably miss background here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If a setuid program depends on the lower limit, then a malicious</span>
<span class="quote">&gt; program shouldn&#39;t be able to cause it to run with the higher limit.</span>
<span class="quote">&gt; The personality code should already get this case right because</span>
<span class="quote">&gt; personalities are reset when setuid happens.</span>

It would be nice to have more fine-grained control than binary personality
flag gives. It would cover more use-cases.

Well, we could reset the limit on exec of setuid binary too. That&#39;s not
ideal, but...
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Jan. 3, 2017, 6:08 a.m.</div>
<pre class="content">
On Mon, Jan 2, 2017 at 12:44 AM, Arnd Bergmann &lt;arnd@arndb.de&gt; wrote:
<span class="quote">&gt; On Tuesday, December 27, 2016 4:54:13 AM CET Kirill A. Shutemov wrote:</span>
<span class="quote">&gt;&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt;&gt; It would affect only future virtual address space allocations.</span>

I still don&#39;t buy all these use cases:
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;&gt;     its children to use addresses above 47-bits.</span>

OK, I get this, but only as a workaround for programs that make
assumptions about the address space and don&#39;t use some mechanism (to
be designed?) to work correctly in spite of a larger address space.
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt;&gt;     exec(2) allows the child to use addresses above 47-bits.</span>

Ditto.
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;&gt;     CAP_SYS_RESOURCES.</span>

I&#39;ve tried and I can&#39;t imagine any reason to do this.
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;&gt;     to emulate 32-bit machine on 64-bit host.</span>

I don&#39;t understand.  QEMU user-mode emulation intercepts all syscalls.
What QEMU would *actually* want is a way to say &quot;allocate me some
memory with the high N bits clear&quot;.  mmap-via-int80 on x86 should be
fixed to do this, but a new syscall with an explicit parameter would
work, as would a prctl changing the current limit.
<span class="quote">
&gt;&gt;</span>
<span class="quote">&gt;&gt; TODO:</span>
<span class="quote">&gt;&gt;   - port to non-x86;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Not-yet-signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt; Cc: linux-api@vger.kernel.org</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This seems to nicely address the same problem on arm64, which has</span>
<span class="quote">&gt; run into the same issue due to the various page table formats</span>
<span class="quote">&gt; that can currently be chosen at compile time.</span>

On further reflection, I think this has very little to do with paging
formats except insofar as paging formats make us notice the problem.
The issue is that user code wants to be able to assume an upper limit
on an address, and it gets an upper limit right now that depends on
architecture due to paging formats.  But someone really might want to
write a *portable* 64-bit program that allocates memory with the high
16 bits clear.  So let&#39;s add such a mechanism directly.

As a thought experiment, what if x86_64 simply never allocated &quot;high&quot;
(above 2^47-1) addresses unless a new mmap-with-explicit-limit syscall
were used?  Old glibc would continue working.  Old VMs would work.
New programs that want to use ginormous mappings would have to use the
new syscall.  This would be totally stateless and would have no issues
with CRIU.

If necessary, we could also have a prctl that changes a
&quot;personality-like&quot; limit that is in effect when the old mmap was used.
I say &quot;personality-like&quot; because it would reset under exactly the same
conditions that personality resets itself.

Thoughts?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Jan. 3, 2017, 1:18 p.m.</div>
<pre class="content">
On Monday, January 2, 2017 10:08:28 PM CET Andy Lutomirski wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; This seems to nicely address the same problem on arm64, which has</span>
<span class="quote">&gt; &gt; run into the same issue due to the various page table formats</span>
<span class="quote">&gt; &gt; that can currently be chosen at compile time.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On further reflection, I think this has very little to do with paging</span>
<span class="quote">&gt; formats except insofar as paging formats make us notice the problem.</span>
<span class="quote">&gt; The issue is that user code wants to be able to assume an upper limit</span>
<span class="quote">&gt; on an address, and it gets an upper limit right now that depends on</span>
<span class="quote">&gt; architecture due to paging formats.  But someone really might want to</span>
<span class="quote">&gt; write a *portable* 64-bit program that allocates memory with the high</span>
<span class="quote">&gt; 16 bits clear.  So let&#39;s add such a mechanism directly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As a thought experiment, what if x86_64 simply never allocated &quot;high&quot;</span>
<span class="quote">&gt; (above 2^47-1) addresses unless a new mmap-with-explicit-limit syscall</span>
<span class="quote">&gt; were used?  Old glibc would continue working.  Old VMs would work.</span>
<span class="quote">&gt; New programs that want to use ginormous mappings would have to use the</span>
<span class="quote">&gt; new syscall.  This would be totally stateless and would have no issues</span>
<span class="quote">&gt; with CRIU.</span>

I can see this working well for the 47-bit addressing default, but
what about applications that actually rely on 39-bit addressing
(I&#39;d have to double-check, but I think this was the limit that
people were most interested in for arm64)?

39 bits seems a little small to make that the default for everyone
who doesn&#39;t pass the extra flag. Having to pass another flag to
limit the addresses introduces other problems (e.g. mmap from
library call that doesn&#39;t pass that flag).
<span class="quote">
&gt; If necessary, we could also have a prctl that changes a</span>
<span class="quote">&gt; &quot;personality-like&quot; limit that is in effect when the old mmap was used.</span>
<span class="quote">&gt; I say &quot;personality-like&quot; because it would reset under exactly the same</span>
<span class="quote">&gt; conditions that personality resets itself.</span>

For &quot;personality-like&quot;, it would still have to interact
with the existing PER_LINUX32 and PER_LINUX32_3GB flags that
do the exact same thing, so actually using personality might
be better.

We still have a few bits in the personality arguments, and
we could combine them with the existing ADDR_LIMIT_3GB
and ADDR_LIMIT_32BIT flags that are mutually exclusive by
definition, such as

        ADDR_LIMIT_32BIT =      0x0800000, /* existing */
        ADDR_LIMIT_3GB   =      0x8000000, /* existing */
        ADDR_LIMIT_39BIT =      0x0010000, /* next free bit */
        ADDR_LIMIT_42BIT =      0x8010000,
        ADDR_LIMIT_47BIT =      0x0810000,
        ADDR_LIMIT_48BIT =      0x8810000,

This would probably take only one or two personality bits for the
limits that are interesting in practice.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Jan. 3, 2017, 4:04 p.m.</div>
<pre class="content">
On Mon, Jan 02, 2017 at 10:08:28PM -0800, Andy Lutomirski wrote:
<span class="quote">&gt; On Mon, Jan 2, 2017 at 12:44 AM, Arnd Bergmann &lt;arnd@arndb.de&gt; wrote:</span>
<span class="quote">&gt; &gt; On Tuesday, December 27, 2016 4:54:13 AM CET Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt;&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt; &gt;&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I still don&#39;t buy all these use cases:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt; &gt;&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; OK, I get this, but only as a workaround for programs that make</span>
<span class="quote">&gt; assumptions about the address space and don&#39;t use some mechanism (to</span>
<span class="quote">&gt; be designed?) to work correctly in spite of a larger address space.</span>

I guess you&#39;ve misread the case. It&#39;s opt-in for large adrress space, not
other way around.

I believe 47-bit VA by default is right way to go to make the transition
without breaking userspace.
<span class="quote">
&gt; &gt;&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt; &gt;&gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ditto.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt; &gt;&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt; &gt;&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;ve tried and I can&#39;t imagine any reason to do this.</span>

That&#39;s just if something went wrong and we want to stop an application
from use addresses above 47-bit.
<span class="quote">
&gt; &gt;&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt; &gt;&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt; &gt;&gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t understand.  QEMU user-mode emulation intercepts all syscalls.</span>
<span class="quote">&gt; What QEMU would *actually* want is a way to say &quot;allocate me some</span>
<span class="quote">&gt; memory with the high N bits clear&quot;.  mmap-via-int80 on x86 should be</span>
<span class="quote">&gt; fixed to do this, but a new syscall with an explicit parameter would</span>
<span class="quote">&gt; work, as would a prctl changing the current limit.</span>

Look at mess in mmap_find_vma(). QEmu has to guess where is free virtual
memory. That&#39;s unnessesary complex.

prctl would work for this too. new-mmap would *not*: there are more ways
to allocate vitual address space: shmat(), mremap(). Changing all of them
just for this is stupid.
<span class="quote">
&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; TODO:</span>
<span class="quote">&gt; &gt;&gt;   - port to non-x86;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Not-yet-signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt; &gt;&gt; Cc: linux-api@vger.kernel.org</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This seems to nicely address the same problem on arm64, which has</span>
<span class="quote">&gt; &gt; run into the same issue due to the various page table formats</span>
<span class="quote">&gt; &gt; that can currently be chosen at compile time.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On further reflection, I think this has very little to do with paging</span>
<span class="quote">&gt; formats except insofar as paging formats make us notice the problem.</span>
<span class="quote">&gt; The issue is that user code wants to be able to assume an upper limit</span>
<span class="quote">&gt; on an address, and it gets an upper limit right now that depends on</span>
<span class="quote">&gt; architecture due to paging formats.  But someone really might want to</span>
<span class="quote">&gt; write a *portable* 64-bit program that allocates memory with the high</span>
<span class="quote">&gt; 16 bits clear.  So let&#39;s add such a mechanism directly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As a thought experiment, what if x86_64 simply never allocated &quot;high&quot;</span>
<span class="quote">&gt; (above 2^47-1) addresses unless a new mmap-with-explicit-limit syscall</span>
<span class="quote">&gt; were used?  Old glibc would continue working.  Old VMs would work.</span>
<span class="quote">&gt; New programs that want to use ginormous mappings would have to use the</span>
<span class="quote">&gt; new syscall.  This would be totally stateless and would have no issues</span>
<span class="quote">&gt; with CRIU.</span>

Except, we need more than mmap as I mentioned.

And what about stack? I&#39;m not sure that everybody would be happy with
stack in the middle of address space.
<span class="quote">
&gt; If necessary, we could also have a prctl that changes a</span>
<span class="quote">&gt; &quot;personality-like&quot; limit that is in effect when the old mmap was used.</span>
<span class="quote">&gt; I say &quot;personality-like&quot; because it would reset under exactly the same</span>
<span class="quote">&gt; conditions that personality resets itself.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thoughts?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe, send a message with &#39;unsubscribe linux-mm&#39; in</span>
<span class="quote">&gt; the body to majordomo@kvack.org.  For more info on Linux MM,</span>
<span class="quote">&gt; see: http://www.linux-mm.org/ .</span>
<span class="quote">&gt; Don&#39;t email: &lt;a href=mailto:&quot;dont@kvack.org&quot;&gt; email@kvack.org &lt;/a&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Jan. 3, 2017, 6:27 p.m.</div>
<pre class="content">
On Tue, Jan 3, 2017 at 8:04 AM, Kirill A. Shutemov &lt;kirill@shutemov.name&gt; wrote:
<span class="quote">&gt; On Mon, Jan 02, 2017 at 10:08:28PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt; On Mon, Jan 2, 2017 at 12:44 AM, Arnd Bergmann &lt;arnd@arndb.de&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; On Tuesday, December 27, 2016 4:54:13 AM CET Kirill A. Shutemov wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt;&gt; &gt;&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I still don&#39;t buy all these use cases:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;&gt; &gt;&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; OK, I get this, but only as a workaround for programs that make</span>
<span class="quote">&gt;&gt; assumptions about the address space and don&#39;t use some mechanism (to</span>
<span class="quote">&gt;&gt; be designed?) to work correctly in spite of a larger address space.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I guess you&#39;ve misread the case. It&#39;s opt-in for large adrress space, not</span>
<span class="quote">&gt; other way around.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I believe 47-bit VA by default is right way to go to make the transition</span>
<span class="quote">&gt; without breaking userspace.</span>

What I meant was: setting the rlimit to anything other than -1ULL is a
workaround, but otherwise I agree.  This still makes little sense if
set by PAM or other conventional rlimit tools.
<span class="quote">
&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;&gt; &gt;&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;&gt; &gt;&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I&#39;ve tried and I can&#39;t imagine any reason to do this.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; That&#39;s just if something went wrong and we want to stop an application</span>
<span class="quote">&gt; from use addresses above 47-bit.</span>

But CAP_SYS_RESOURCES still makes no sense in this context.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;&gt; &gt;&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;&gt; &gt;&gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I don&#39;t understand.  QEMU user-mode emulation intercepts all syscalls.</span>
<span class="quote">&gt;&gt; What QEMU would *actually* want is a way to say &quot;allocate me some</span>
<span class="quote">&gt;&gt; memory with the high N bits clear&quot;.  mmap-via-int80 on x86 should be</span>
<span class="quote">&gt;&gt; fixed to do this, but a new syscall with an explicit parameter would</span>
<span class="quote">&gt;&gt; work, as would a prctl changing the current limit.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Look at mess in mmap_find_vma(). QEmu has to guess where is free virtual</span>
<span class="quote">&gt; memory. That&#39;s unnessesary complex.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; prctl would work for this too. new-mmap would *not*: there are more ways</span>
<span class="quote">&gt; to allocate vitual address space: shmat(), mremap(). Changing all of them</span>
<span class="quote">&gt; just for this is stupid.</span>

Fair enough.

Except that mmap-via-int80, shmat-via-int80, etc should still work (if
I understand what qemu needs correctly), as would the prctl.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; TODO:</span>
<span class="quote">&gt;&gt; &gt;&gt;   - port to non-x86;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Not-yet-signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Cc: linux-api@vger.kernel.org</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; This seems to nicely address the same problem on arm64, which has</span>
<span class="quote">&gt;&gt; &gt; run into the same issue due to the various page table formats</span>
<span class="quote">&gt;&gt; &gt; that can currently be chosen at compile time.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On further reflection, I think this has very little to do with paging</span>
<span class="quote">&gt;&gt; formats except insofar as paging formats make us notice the problem.</span>
<span class="quote">&gt;&gt; The issue is that user code wants to be able to assume an upper limit</span>
<span class="quote">&gt;&gt; on an address, and it gets an upper limit right now that depends on</span>
<span class="quote">&gt;&gt; architecture due to paging formats.  But someone really might want to</span>
<span class="quote">&gt;&gt; write a *portable* 64-bit program that allocates memory with the high</span>
<span class="quote">&gt;&gt; 16 bits clear.  So let&#39;s add such a mechanism directly.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; As a thought experiment, what if x86_64 simply never allocated &quot;high&quot;</span>
<span class="quote">&gt;&gt; (above 2^47-1) addresses unless a new mmap-with-explicit-limit syscall</span>
<span class="quote">&gt;&gt; were used?  Old glibc would continue working.  Old VMs would work.</span>
<span class="quote">&gt;&gt; New programs that want to use ginormous mappings would have to use the</span>
<span class="quote">&gt;&gt; new syscall.  This would be totally stateless and would have no issues</span>
<span class="quote">&gt;&gt; with CRIU.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Except, we need more than mmap as I mentioned.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; And what about stack? I&#39;m not sure that everybody would be happy with</span>
<span class="quote">&gt; stack in the middle of address space.</span>

I would, personally.  I think that, for very large address spaces, we
should allocate a large block of stack and get rid of the &quot;stack grows
down forever&quot; legacy idea.  Then we would never need to worry about
the stack eventually hitting some other allocation.  And 2^57 bytes is
hilariously large for a default stack.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Jan. 3, 2017, 6:29 p.m.</div>
<pre class="content">
On Tue, Jan 3, 2017 at 5:18 AM, Arnd Bergmann &lt;arnd@arndb.de&gt; wrote:
<span class="quote">&gt; On Monday, January 2, 2017 10:08:28 PM CET Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt; This seems to nicely address the same problem on arm64, which has</span>
<span class="quote">&gt;&gt; &gt; run into the same issue due to the various page table formats</span>
<span class="quote">&gt;&gt; &gt; that can currently be chosen at compile time.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On further reflection, I think this has very little to do with paging</span>
<span class="quote">&gt;&gt; formats except insofar as paging formats make us notice the problem.</span>
<span class="quote">&gt;&gt; The issue is that user code wants to be able to assume an upper limit</span>
<span class="quote">&gt;&gt; on an address, and it gets an upper limit right now that depends on</span>
<span class="quote">&gt;&gt; architecture due to paging formats.  But someone really might want to</span>
<span class="quote">&gt;&gt; write a *portable* 64-bit program that allocates memory with the high</span>
<span class="quote">&gt;&gt; 16 bits clear.  So let&#39;s add such a mechanism directly.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; As a thought experiment, what if x86_64 simply never allocated &quot;high&quot;</span>
<span class="quote">&gt;&gt; (above 2^47-1) addresses unless a new mmap-with-explicit-limit syscall</span>
<span class="quote">&gt;&gt; were used?  Old glibc would continue working.  Old VMs would work.</span>
<span class="quote">&gt;&gt; New programs that want to use ginormous mappings would have to use the</span>
<span class="quote">&gt;&gt; new syscall.  This would be totally stateless and would have no issues</span>
<span class="quote">&gt;&gt; with CRIU.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I can see this working well for the 47-bit addressing default, but</span>
<span class="quote">&gt; what about applications that actually rely on 39-bit addressing</span>
<span class="quote">&gt; (I&#39;d have to double-check, but I think this was the limit that</span>
<span class="quote">&gt; people were most interested in for arm64)?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 39 bits seems a little small to make that the default for everyone</span>
<span class="quote">&gt; who doesn&#39;t pass the extra flag. Having to pass another flag to</span>
<span class="quote">&gt; limit the addresses introduces other problems (e.g. mmap from</span>
<span class="quote">&gt; library call that doesn&#39;t pass that flag).</span>

That&#39;s a fair point.  Maybe my straw man isn&#39;t so good.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; If necessary, we could also have a prctl that changes a</span>
<span class="quote">&gt;&gt; &quot;personality-like&quot; limit that is in effect when the old mmap was used.</span>
<span class="quote">&gt;&gt; I say &quot;personality-like&quot; because it would reset under exactly the same</span>
<span class="quote">&gt;&gt; conditions that personality resets itself.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; For &quot;personality-like&quot;, it would still have to interact</span>
<span class="quote">&gt; with the existing PER_LINUX32 and PER_LINUX32_3GB flags that</span>
<span class="quote">&gt; do the exact same thing, so actually using personality might</span>
<span class="quote">&gt; be better.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; We still have a few bits in the personality arguments, and</span>
<span class="quote">&gt; we could combine them with the existing ADDR_LIMIT_3GB</span>
<span class="quote">&gt; and ADDR_LIMIT_32BIT flags that are mutually exclusive by</span>
<span class="quote">&gt; definition, such as</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         ADDR_LIMIT_32BIT =      0x0800000, /* existing */</span>
<span class="quote">&gt;         ADDR_LIMIT_3GB   =      0x8000000, /* existing */</span>
<span class="quote">&gt;         ADDR_LIMIT_39BIT =      0x0010000, /* next free bit */</span>
<span class="quote">&gt;         ADDR_LIMIT_42BIT =      0x8010000,</span>
<span class="quote">&gt;         ADDR_LIMIT_47BIT =      0x0810000,</span>
<span class="quote">&gt;         ADDR_LIMIT_48BIT =      0x8810000,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This would probably take only one or two personality bits for the</span>
<span class="quote">&gt; limits that are interesting in practice.</span>

Hmm.  What if we approached this a bit differently?  We could add a
single new personality bit ADDR_LIMIT_EXPLICIT.  Setting this bit
cause PER_LINUX32_3GB etc to be automatically cleared.  When
ADDR_LIMIT_EXPLICIT is in effect, prctl can set a 64-bit numeric
limit.  If ADDR_LIMIT_EXPLICIT is cleared, the prctl value stops being
settable and reading it via prctl returns whatever is implied by the
other personality bits.

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Jan. 3, 2017, 10:07 p.m.</div>
<pre class="content">
On Tuesday, January 3, 2017 10:29:33 AM CET Andy Lutomirski wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm.  What if we approached this a bit differently?  We could add a</span>
<span class="quote">&gt; single new personality bit ADDR_LIMIT_EXPLICIT.  Setting this bit</span>
<span class="quote">&gt; cause PER_LINUX32_3GB etc to be automatically cleared.</span>

Both the ADDR_LIMIT_32BIT and ADDR_LIMIT_3GB flags I guess?
<span class="quote">
&gt; When</span>
<span class="quote">&gt; ADDR_LIMIT_EXPLICIT is in effect, prctl can set a 64-bit numeric</span>
<span class="quote">&gt; limit.  If ADDR_LIMIT_EXPLICIT is cleared, the prctl value stops being</span>
<span class="quote">&gt; settable and reading it via prctl returns whatever is implied by the</span>
<span class="quote">&gt; other personality bits.</span>

I don&#39;t see anything wrong with it, but I&#39;m a bit confused now
what this would be good for, compared to using just prctl.

Is this about setuid clearing the personality but not the prctl,
or something else?

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Jan. 3, 2017, 10:09 p.m.</div>
<pre class="content">
On Tue, Jan 3, 2017 at 2:07 PM, Arnd Bergmann &lt;arnd@arndb.de&gt; wrote:
<span class="quote">&gt; On Tuesday, January 3, 2017 10:29:33 AM CET Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hmm.  What if we approached this a bit differently?  We could add a</span>
<span class="quote">&gt;&gt; single new personality bit ADDR_LIMIT_EXPLICIT.  Setting this bit</span>
<span class="quote">&gt;&gt; cause PER_LINUX32_3GB etc to be automatically cleared.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Both the ADDR_LIMIT_32BIT and ADDR_LIMIT_3GB flags I guess?</span>

Yes.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; When</span>
<span class="quote">&gt;&gt; ADDR_LIMIT_EXPLICIT is in effect, prctl can set a 64-bit numeric</span>
<span class="quote">&gt;&gt; limit.  If ADDR_LIMIT_EXPLICIT is cleared, the prctl value stops being</span>
<span class="quote">&gt;&gt; settable and reading it via prctl returns whatever is implied by the</span>
<span class="quote">&gt;&gt; other personality bits.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I don&#39;t see anything wrong with it, but I&#39;m a bit confused now</span>
<span class="quote">&gt; what this would be good for, compared to using just prctl.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is this about setuid clearing the personality but not the prctl,</span>
<span class="quote">&gt; or something else?</span>

It&#39;s to avid ambiguity as to what happens if you set ADDR_LIMIT_32BIT
and use the prctl.  ISTM it would be nice for the semantics to be
fully defined in all cases.

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Jan. 4, 2017, 1:55 p.m.</div>
<pre class="content">
On Tuesday, January 3, 2017 2:09:16 PM CET Andy Lutomirski wrote:
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; When</span>
<span class="quote">&gt; &gt;&gt; ADDR_LIMIT_EXPLICIT is in effect, prctl can set a 64-bit numeric</span>
<span class="quote">&gt; &gt;&gt; limit.  If ADDR_LIMIT_EXPLICIT is cleared, the prctl value stops being</span>
<span class="quote">&gt; &gt;&gt; settable and reading it via prctl returns whatever is implied by the</span>
<span class="quote">&gt; &gt;&gt; other personality bits.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I don&#39;t see anything wrong with it, but I&#39;m a bit confused now</span>
<span class="quote">&gt; &gt; what this would be good for, compared to using just prctl.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Is this about setuid clearing the personality but not the prctl,</span>
<span class="quote">&gt; &gt; or something else?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s to avid ambiguity as to what happens if you set ADDR_LIMIT_32BIT</span>
<span class="quote">&gt; and use the prctl.  ISTM it would be nice for the semantics to be</span>
<span class="quote">&gt; fully defined in all cases.</span>
<span class="quote">&gt; </span>

Ok, got it.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Jan. 4, 2017, 2:19 p.m.</div>
<pre class="content">
On Tue, Jan 03, 2017 at 10:27:22AM -0800, Andy Lutomirski wrote:
<span class="quote">&gt; On Tue, Jan 3, 2017 at 8:04 AM, Kirill A. Shutemov &lt;kirill@shutemov.name&gt; wrote:</span>
<span class="quote">&gt; &gt; And what about stack? I&#39;m not sure that everybody would be happy with</span>
<span class="quote">&gt; &gt; stack in the middle of address space.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I would, personally.  I think that, for very large address spaces, we</span>
<span class="quote">&gt; should allocate a large block of stack and get rid of the &quot;stack grows</span>
<span class="quote">&gt; down forever&quot; legacy idea.  Then we would never need to worry about</span>
<span class="quote">&gt; the stack eventually hitting some other allocation.  And 2^57 bytes is</span>
<span class="quote">&gt; hilariously large for a default stack.</span>

The stack in the middle of address space can prevent creating other huuuge
contiguous mapping. Databases may want this.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Jan. 5, 2017, 5:53 p.m.</div>
<pre class="content">
On Wed, Jan 4, 2017 at 6:19 AM, Kirill A. Shutemov &lt;kirill@shutemov.name&gt; wrote:
<span class="quote">&gt; On Tue, Jan 03, 2017 at 10:27:22AM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt; On Tue, Jan 3, 2017 at 8:04 AM, Kirill A. Shutemov &lt;kirill@shutemov.name&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; And what about stack? I&#39;m not sure that everybody would be happy with</span>
<span class="quote">&gt;&gt; &gt; stack in the middle of address space.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I would, personally.  I think that, for very large address spaces, we</span>
<span class="quote">&gt;&gt; should allocate a large block of stack and get rid of the &quot;stack grows</span>
<span class="quote">&gt;&gt; down forever&quot; legacy idea.  Then we would never need to worry about</span>
<span class="quote">&gt;&gt; the stack eventually hitting some other allocation.  And 2^57 bytes is</span>
<span class="quote">&gt;&gt; hilariously large for a default stack.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The stack in the middle of address space can prevent creating other huuuge</span>
<span class="quote">&gt; contiguous mapping. Databases may want this.</span>

Fair enough.  OTOH, 2^47 is nowhere near the middle if we were to put
it near the top of the legacy address space.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=65121">Dave Hansen</a> - Jan. 5, 2017, 7:13 p.m.</div>
<pre class="content">
On 12/26/2016 05:54 PM, Kirill A. Shutemov wrote:
<span class="quote">&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; address available to map by userspace.</span>

What happens to existing mappings above the limit when this upper limit
is dropped?

Similarly, why do we do with an application running with something
incompatible with the larger address space that tries to raise the
limit?  Say, legacy MPX.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=40781">Kirill A. Shutemov</a> - Jan. 5, 2017, 7:29 p.m.</div>
<pre class="content">
On Thu, Jan 05, 2017 at 11:13:57AM -0800, Dave Hansen wrote:
<span class="quote">&gt; On 12/26/2016 05:54 PM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; &gt; address available to map by userspace.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What happens to existing mappings above the limit when this upper limit</span>
<span class="quote">&gt; is dropped?</span>

Nothing: we only prevent creating new mappings. All existing are not
affected.

The semantics here the same as with other resource limits.
<span class="quote">
&gt; Similarly, why do we do with an application running with something</span>
<span class="quote">&gt; incompatible with the larger address space that tries to raise the</span>
<span class="quote">&gt; limit?  Say, legacy MPX.</span>

It has to know what it does. Yes, it can change limit to the point where
application is unusable. But you can to the same with other limits.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=65121">Dave Hansen</a> - Jan. 5, 2017, 7:39 p.m.</div>
<pre class="content">
On 01/05/2017 11:29 AM, Kirill A. Shutemov wrote:
<span class="quote">&gt; On Thu, Jan 05, 2017 at 11:13:57AM -0800, Dave Hansen wrote:</span>
<span class="quote">&gt;&gt; On 12/26/2016 05:54 PM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt;&gt;&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt;&gt;&gt; address available to map by userspace.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; What happens to existing mappings above the limit when this upper limit</span>
<span class="quote">&gt;&gt; is dropped?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nothing: we only prevent creating new mappings. All existing are not</span>
<span class="quote">&gt; affected.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The semantics here the same as with other resource limits.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; Similarly, why do we do with an application running with something</span>
<span class="quote">&gt;&gt; incompatible with the larger address space that tries to raise the</span>
<span class="quote">&gt;&gt; limit?  Say, legacy MPX.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It has to know what it does. Yes, it can change limit to the point where</span>
<span class="quote">&gt; application is unusable. But you can to the same with other limits.</span>

I&#39;m not sure I&#39;m comfortable with this.  Do other rlimit changes cause
silent data corruption?  I&#39;m pretty sure doing this to MPX would.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Jan. 5, 2017, 8:11 p.m.</div>
<pre class="content">
On Thu, Jan 05, 2017 at 11:39:16AM -0800, Dave Hansen wrote:
<span class="quote">&gt; On 01/05/2017 11:29 AM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; On Thu, Jan 05, 2017 at 11:13:57AM -0800, Dave Hansen wrote:</span>
<span class="quote">&gt; &gt;&gt; On 12/26/2016 05:54 PM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt; &gt;&gt;&gt; address available to map by userspace.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; What happens to existing mappings above the limit when this upper limit</span>
<span class="quote">&gt; &gt;&gt; is dropped?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Nothing: we only prevent creating new mappings. All existing are not</span>
<span class="quote">&gt; &gt; affected.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The semantics here the same as with other resource limits.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;&gt; Similarly, why do we do with an application running with something</span>
<span class="quote">&gt; &gt;&gt; incompatible with the larger address space that tries to raise the</span>
<span class="quote">&gt; &gt;&gt; limit?  Say, legacy MPX.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; It has to know what it does. Yes, it can change limit to the point where</span>
<span class="quote">&gt; &gt; application is unusable. But you can to the same with other limits.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m not sure I&#39;m comfortable with this.  Do other rlimit changes cause</span>
<span class="quote">&gt; silent data corruption?  I&#39;m pretty sure doing this to MPX would.</span>

Maybe it&#39;s too ugly, but MPX can set rlim_max to rlim_cur on enabling.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Jan. 5, 2017, 8:14 p.m.</div>
<pre class="content">
On Thu, Jan 5, 2017 at 11:39 AM, Dave Hansen &lt;dave.hansen@intel.com&gt; wrote:
<span class="quote">&gt; On 01/05/2017 11:29 AM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt;&gt; On Thu, Jan 05, 2017 at 11:13:57AM -0800, Dave Hansen wrote:</span>
<span class="quote">&gt;&gt;&gt; On 12/26/2016 05:54 PM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt;&gt;&gt;&gt; address available to map by userspace.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; What happens to existing mappings above the limit when this upper limit</span>
<span class="quote">&gt;&gt;&gt; is dropped?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Nothing: we only prevent creating new mappings. All existing are not</span>
<span class="quote">&gt;&gt; affected.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The semantics here the same as with other resource limits.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Similarly, why do we do with an application running with something</span>
<span class="quote">&gt;&gt;&gt; incompatible with the larger address space that tries to raise the</span>
<span class="quote">&gt;&gt;&gt; limit?  Say, legacy MPX.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; It has to know what it does. Yes, it can change limit to the point where</span>
<span class="quote">&gt;&gt; application is unusable. But you can to the same with other limits.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;m not sure I&#39;m comfortable with this.  Do other rlimit changes cause</span>
<span class="quote">&gt; silent data corruption?  I&#39;m pretty sure doing this to MPX would.</span>
<span class="quote">&gt;</span>

What actually goes wrong in this case?  That is, what combination of
MPX setup of subsequent allocations will cause a problem, and is the
problem worse than just a segfault?  IMO it would be really nice to
keep the messy case confined to MPX.

FWIW, this problem is kind of generic.  If you run code in a process,
MPX or otherwise, that assumes something about pointer values and then
create a pointer that violates its assumptions, you will cause
problems.  For example, some VMs use high bits to store metadata.  If
you feed a pointer that&#39;s too big to such code, boom.  This is exactly
why high addresses need to be opt-in.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=65121">Dave Hansen</a> - Jan. 5, 2017, 8:49 p.m.</div>
<pre class="content">
On 01/05/2017 12:14 PM, Andy Lutomirski wrote:
<span class="quote">&gt;&gt; I&#39;m not sure I&#39;m comfortable with this.  Do other rlimit changes cause</span>
<span class="quote">&gt;&gt; silent data corruption?  I&#39;m pretty sure doing this to MPX would.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; What actually goes wrong in this case?  That is, what combination of</span>
<span class="quote">&gt; MPX setup of subsequent allocations will cause a problem, and is the</span>
<span class="quote">&gt; problem worse than just a segfault?  IMO it would be really nice to</span>
<span class="quote">&gt; keep the messy case confined to MPX.</span>

The MPX bounds tables are indexed by virtual address.  They need to grow
if the virtual address space grows.   There&#39;s an MSR that controls
whether we use the 48-bit or 57-bit layout.  It basically decides
whether we need a 2GB (48-bit) or 1TB (57-bit) bounds directory.

The question is what we do with legacy MPX applications.  We obviously
can&#39;t let them just allocate a 2GB table and then go let the hardware
pretend it&#39;s 1TB in size.  We also can&#39;t hand the hardware using a 2GB
table an address &gt;48-bits.

Ideally, I&#39;d like to make sure that legacy MPX can&#39;t be enabled if this
RLIMIT is set over 48-bits (really 47).  I&#39;d also like to make sure that
legacy MPX is active, that the RLIMIT can&#39;t be raised because all hell
will break loose when the new addresses show up.

Remember, we already have (legacy MPX) binaries in the wild that have no
knowledge of this stuff.  So, we can implicitly have the kernel bump
this rlimit around, but we can&#39;t expect userspace to do it, ever.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41531">Andy Lutomirski</a> - Jan. 5, 2017, 9:27 p.m.</div>
<pre class="content">
On Thu, Jan 5, 2017 at 12:49 PM, Dave Hansen &lt;dave.hansen@intel.com&gt; wrote:
<span class="quote">&gt; On 01/05/2017 12:14 PM, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt;&gt; I&#39;m not sure I&#39;m comfortable with this.  Do other rlimit changes cause</span>
<span class="quote">&gt;&gt;&gt; silent data corruption?  I&#39;m pretty sure doing this to MPX would.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; What actually goes wrong in this case?  That is, what combination of</span>
<span class="quote">&gt;&gt; MPX setup of subsequent allocations will cause a problem, and is the</span>
<span class="quote">&gt;&gt; problem worse than just a segfault?  IMO it would be really nice to</span>
<span class="quote">&gt;&gt; keep the messy case confined to MPX.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The MPX bounds tables are indexed by virtual address.  They need to grow</span>
<span class="quote">&gt; if the virtual address space grows.   There&#39;s an MSR that controls</span>
<span class="quote">&gt; whether we use the 48-bit or 57-bit layout.  It basically decides</span>
<span class="quote">&gt; whether we need a 2GB (48-bit) or 1TB (57-bit) bounds directory.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The question is what we do with legacy MPX applications.  We obviously</span>
<span class="quote">&gt; can&#39;t let them just allocate a 2GB table and then go let the hardware</span>
<span class="quote">&gt; pretend it&#39;s 1TB in size.  We also can&#39;t hand the hardware using a 2GB</span>
<span class="quote">&gt; table an address &gt;48-bits.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ideally, I&#39;d like to make sure that legacy MPX can&#39;t be enabled if this</span>
<span class="quote">&gt; RLIMIT is set over 48-bits (really 47).  I&#39;d also like to make sure that</span>
<span class="quote">&gt; legacy MPX is active, that the RLIMIT can&#39;t be raised because all hell</span>
<span class="quote">&gt; will break loose when the new addresses show up.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Remember, we already have (legacy MPX) binaries in the wild that have no</span>
<span class="quote">&gt; knowledge of this stuff.  So, we can implicitly have the kernel bump</span>
<span class="quote">&gt; this rlimit around, but we can&#39;t expect userspace to do it, ever.</span>

If you s/rlimit/prctl, then I think this all makes sense with one
exception.  It would be a bit sad if the personality-setting tool
didn&#39;t work if compiled with MPX.

So what if we had a second prctl field that is the value that kicks in
after execve()?

--Andy
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=65121">Dave Hansen</a> - Jan. 5, 2017, 11:17 p.m.</div>
<pre class="content">
On 01/05/2017 01:27 PM, Andy Lutomirski wrote:
<span class="quote">&gt; On Thu, Jan 5, 2017 at 12:49 PM, Dave Hansen &lt;dave.hansen@intel.com&gt; wrote:</span>
...
<span class="quote">&gt;&gt; Remember, we already have (legacy MPX) binaries in the wild that have no</span>
<span class="quote">&gt;&gt; knowledge of this stuff.  So, we can implicitly have the kernel bump</span>
<span class="quote">&gt;&gt; this rlimit around, but we can&#39;t expect userspace to do it, ever.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you s/rlimit/prctl, then I think this all makes sense with one</span>
<span class="quote">&gt; exception.  It would be a bit sad if the personality-setting tool</span>
<span class="quote">&gt; didn&#39;t work if compiled with MPX.</span>

Ahh, because if you have MPX enabled you *can&#39;t* sanely switch between
the two modes because you suddenly go from having small bounds tables to
having big ones?

It&#39;s not the simplest thing in the world to do, but there&#39;s nothing
keeping the personality-setting tool from doing all the work.  It can do:

	new_bd = malloc(1TB);
	prctl(MPX_DISABLE_MANAGEMENT);
	memcpy(new_bd, old_bd, LEGACY_MPX_BD_SIZE);
	set_bounds_config(new_bd | ENABLE_BIT);
	prctl(WIDER_VADDR_WIDTH);
	prctl(MPX_ENABLE_MANAGEMENT);
<span class="quote">	

&gt; So what if we had a second prctl field that is the value that kicks in</span>
<span class="quote">&gt; after execve()?</span>

Yeah, that&#39;s a pretty sane way to do it too.  execve() is a nice chokepoint.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2349">H.J. Lu</a> - Jan. 13, 2017, 8:11 p.m.</div>
<pre class="content">
On Mon, Jan 2, 2017 at 12:35 AM, Kirill A. Shutemov
&lt;kirill@shutemov.name&gt; wrote:
<span class="quote">&gt; On Fri, Dec 30, 2016 at 06:08:27PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt; On Wed, Dec 28, 2016 at 6:53 PM, Carlos O&#39;Donell &lt;carlos@redhat.com&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt; On 12/26/2016 09:24 PM, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt; On Mon, Dec 26, 2016 at 06:06:01PM -0800, Andy Lutomirski wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; On Mon, Dec 26, 2016 at 5:54 PM, Kirill A. Shutemov</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; &lt;kirill.shutemov@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; This patch introduces new rlimit resource to manage maximum virtual</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; address available to userspace to map.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; On x86, 5-level paging enables 56-bit userspace virtual address space.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; Not all user space is ready to handle wide addresses. It&#39;s known that</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; at least some JIT compilers use high bit in pointers to encode their</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; information. It collides with valid pointers with 5-level paging and</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; leads to crashes.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; The patch aims to address this compatibility issue.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; MM would use min(RLIMIT_VADDR, TASK_SIZE) as upper limit of virtual</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; address available to map by userspace.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; The default hard limit will be RLIM_INFINITY, which basically means that</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; TASK_SIZE limits available address space.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; The soft limit will also be RLIM_INFINITY everywhere, but the machine</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; with 5-level paging enabled. In this case, soft limit would be</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; (1UL &lt;&lt; 47) - PAGE_SIZE. It’s current x86-64 TASK_SIZE_MAX with 4-level</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; paging which known to be safe</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; New rlimit resource would follow usual semantics with regards to</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; inheritance: preserved on fork(2) and exec(2). This has potential to</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; break application if limits set too wide or too narrow, but this is not</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; uncommon for other resources (consider RLIMIT_DATA or RLIMIT_AS).</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; As with other resources you can set the limit lower than current usage.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; It would affect only future virtual address space allocations.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt; Use-cases for new rlimit:</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY, allows current process all</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;     its children to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;   - Bumping the soft limit to RLIM_INFINITY after fork(2), but before</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;     exec(2) allows the child to use addresses above 47-bits.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;   - Lowering the hard limit to 47-bits would prevent current process all</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;     its children to use addresses above 47-bits, unless a process has</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;     CAP_SYS_RESOURCES.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;   - It’s also can be handy to lower hard or soft limit to arbitrary</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;     address. User-mode emulation in QEMU may lower the limit to 32-bit</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;&gt;     to emulate 32-bit machine on 64-bit host.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; I tend to think that this should be a personality or an ELF flag, not</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; an rlimit.</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; My plan was to implement ELF flag on top. Basically, ELF flag would mean</span>
<span class="quote">&gt;&gt; &gt;&gt; that we bump soft limit to hard limit on exec.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; Could you clarify what you mean by an &quot;ELF flag?&quot;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Some way to mark a binary as supporting a larger address space.  I</span>
<span class="quote">&gt;&gt; don&#39;t have a precise solution in mind, but an ELF note might be a good</span>
<span class="quote">&gt;&gt; way to go here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; + H.J.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; There&#39;s discussion of proposal of &quot;Program Properties&quot;[1]. It seems fits</span>
<span class="quote">&gt; the purpose.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; [1] https://sourceware.org/ml/gnu-gabi/2016-q4/msg00000.html</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt;  Kirill A. Shutemov</span>

There is another proposal:

https://fedoraproject.org/wiki/Toolchain/Watermark#Markup_for_ELF_objects

which covers much more than mine.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/elf.h b/arch/x86/include/asm/elf.h</span>
<span class="p_header">index e7f155c3045e..5ce6f2b2b105 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/elf.h</span>
<span class="p_chunk">@@ -250,7 +250,7 @@</span> <span class="p_context"> extern int force_personality32;</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE		(TASK_SIZE / 3 * 2)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE		(mmap_max_addr() / 3 * 2)</span>
 
 /* This yields a mask that user programs can use to figure out what
    instruction set this CPU supports.  This could be done in user space,
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index eaf100508c36..e02917126859 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -770,8 +770,8 @@</span> <span class="p_context"> static inline void spin_lock_prefetch(const void *x)</span>
  */
 #define TASK_SIZE		PAGE_OFFSET
 #define TASK_SIZE_MAX		TASK_SIZE
<span class="p_del">-#define STACK_TOP		TASK_SIZE</span>
<span class="p_del">-#define STACK_TOP_MAX		STACK_TOP</span>
<span class="p_add">+#define STACK_TOP		mmap_max_addr()</span>
<span class="p_add">+#define STACK_TOP_MAX		TASK_SIZE</span>
 
 #define INIT_THREAD  {							  \
 	.sp0			= TOP_OF_INIT_STACK,			  \
<span class="p_chunk">@@ -809,7 +809,14 @@</span> <span class="p_context"> static inline void spin_lock_prefetch(const void *x)</span>
  * particular problem by preventing anything from being mapped
  * at the maximum canonical address.
  */
<span class="p_del">-#define TASK_SIZE_MAX	((1UL &lt;&lt; 47) - PAGE_SIZE)</span>
<span class="p_add">+#define TASK_SIZE_MAX	((1UL &lt;&lt; __VIRTUAL_MASK_SHIFT) - PAGE_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Default limit on maximum virtual address. This is required for</span>
<span class="p_add">+ * compatibility with applications that assumes 47-bit VA.</span>
<span class="p_add">+ * The limit be overrided with setrlimit(2).</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USER_VADDR_LIM	((1UL &lt;&lt; 47) - PAGE_SIZE)</span>
 
 /* This decides where the kernel will search for a free chunk of vm
  * space during mmap&#39;s.
<span class="p_chunk">@@ -822,7 +829,7 @@</span> <span class="p_context"> static inline void spin_lock_prefetch(const void *x)</span>
 #define TASK_SIZE_OF(child)	((test_tsk_thread_flag(child, TIF_ADDR32)) ? \
 					IA32_PAGE_OFFSET : TASK_SIZE_MAX)
 
<span class="p_del">-#define STACK_TOP		TASK_SIZE</span>
<span class="p_add">+#define STACK_TOP		mmap_max_addr()</span>
 #define STACK_TOP_MAX		TASK_SIZE_MAX
 
 #define INIT_THREAD  {						\
<span class="p_chunk">@@ -844,7 +851,7 @@</span> <span class="p_context"> extern void start_thread(struct pt_regs *regs, unsigned long new_ip,</span>
  * This decides where the kernel will search for a free chunk of vm
  * space during mmap&#39;s.
  */
<span class="p_del">-#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 3))</span>
<span class="p_add">+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(mmap_max_addr() / 3))</span>
 
 #define KSTK_EIP(task)		(task_pt_regs(task)-&gt;ip)
 
<span class="p_header">diff --git a/arch/x86/kernel/sys_x86_64.c b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">index a55ed63b9f91..e31f5b0c5468 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> static void find_start_end(unsigned long flags, unsigned long *begin,</span>
 		}
 	} else {
 		*begin = current-&gt;mm-&gt;mmap_legacy_base;
<span class="p_del">-		*end = TASK_SIZE;</span>
<span class="p_add">+		*end = mmap_max_addr();</span>
 	}
 }
 
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	struct vm_unmapped_area_info info;
 
 	/* requested length too big for entire address space */
<span class="p_del">-	if (len &gt; TASK_SIZE)</span>
<span class="p_add">+	if (len &gt; mmap_max_addr())</span>
 		return -ENOMEM;
 
 	if (flags &amp; MAP_FIXED)
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp;</span>
<span class="p_add">+		if (mmap_max_addr() - len &gt;= addr &amp;&amp;</span>
 				(!vma || addr + len &lt;= vma-&gt;vm_start))
 			return addr;
 	}
<span class="p_header">diff --git a/arch/x86/mm/hugetlbpage.c b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">index 2ae8584b44c7..b55b04b82097 100644</span>
<span class="p_header">--- a/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> static unsigned long hugetlb_get_unmapped_area_bottomup(struct file *file,</span>
 	info.flags = 0;
 	info.length = len;
 	info.low_limit = current-&gt;mm-&gt;mmap_legacy_base;
<span class="p_del">-	info.high_limit = TASK_SIZE;</span>
<span class="p_add">+	info.high_limit = mmap_max_addr();</span>
 	info.align_mask = PAGE_MASK &amp; ~huge_page_mask(h);
 	info.align_offset = 0;
 	return vm_unmapped_area(&amp;info);
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> static unsigned long hugetlb_get_unmapped_area_topdown(struct file *file,</span>
 		VM_BUG_ON(addr != -ENOMEM);
 		info.flags = 0;
 		info.low_limit = TASK_UNMAPPED_BASE;
<span class="p_del">-		info.high_limit = TASK_SIZE;</span>
<span class="p_add">+		info.high_limit = mmap_max_addr();</span>
 		addr = vm_unmapped_area(&amp;info);
 	}
 
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 
 	if (len &amp; ~huge_page_mask(h))
 		return -EINVAL;
<span class="p_del">-	if (len &gt; TASK_SIZE)</span>
<span class="p_add">+	if (len &gt; mmap_max_addr())</span>
 		return -ENOMEM;
 
 	if (flags &amp; MAP_FIXED) {
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 	if (addr) {
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp;</span>
<span class="p_add">+		if (mmap_max_addr() - len &gt;= addr &amp;&amp;</span>
 		    (!vma || addr + len &lt;= vma-&gt;vm_start))
 			return addr;
 	}
<span class="p_header">diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c</span>
<span class="p_header">index d2dc0438d654..c22f0b802576 100644</span>
<span class="p_header">--- a/arch/x86/mm/mmap.c</span>
<span class="p_header">+++ b/arch/x86/mm/mmap.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> static unsigned long stack_maxrandom_size(void)</span>
  * Leave an at least ~128 MB hole with possible stack randomization.
  */
 #define MIN_GAP (128*1024*1024UL + stack_maxrandom_size())
<span class="p_del">-#define MAX_GAP (TASK_SIZE/6*5)</span>
<span class="p_add">+#define MAX_GAP (mmap_max_addr()/6*5)</span>
 
 static int mmap_is_legacy(void)
 {
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static unsigned long mmap_base(unsigned long rnd)</span>
 	else if (gap &gt; MAX_GAP)
 		gap = MAX_GAP;
 
<span class="p_del">-	return PAGE_ALIGN(TASK_SIZE - gap - rnd);</span>
<span class="p_add">+	return PAGE_ALIGN(mmap_max_addr() - gap - rnd);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/binfmt_aout.c b/fs/binfmt_aout.c</span>
<span class="p_header">index 2a59139f520b..7a7f6dba6b00 100644</span>
<span class="p_header">--- a/fs/binfmt_aout.c</span>
<span class="p_header">+++ b/fs/binfmt_aout.c</span>
<span class="p_chunk">@@ -121,8 +121,6 @@</span> <span class="p_context"> static struct linux_binfmt aout_format = {</span>
 	.min_coredump	= PAGE_SIZE
 };
 
<span class="p_del">-#define BAD_ADDR(x)	((unsigned long)(x) &gt;= TASK_SIZE)</span>
<span class="p_del">-</span>
 static int set_brk(unsigned long start, unsigned long end)
 {
 	start = PAGE_ALIGN(start);
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 29a02daf08a9..1f8034aed298 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static struct linux_binfmt elf_format = {</span>
 	.min_coredump	= ELF_EXEC_PAGESIZE,
 };
 
<span class="p_del">-#define BAD_ADDR(x) ((unsigned long)(x) &gt;= TASK_SIZE)</span>
<span class="p_add">+#define BAD_ADDR(x) ((unsigned long)(x) &gt;= mmap_max_addr())</span>
 
 static int set_brk(unsigned long start, unsigned long end)
 {
<span class="p_chunk">@@ -587,8 +587,8 @@</span> <span class="p_context"> static unsigned long load_elf_interp(struct elfhdr *interp_elf_ex,</span>
 			k = load_addr + eppnt-&gt;p_vaddr;
 			if (BAD_ADDR(k) ||
 			    eppnt-&gt;p_filesz &gt; eppnt-&gt;p_memsz ||
<span class="p_del">-			    eppnt-&gt;p_memsz &gt; TASK_SIZE ||</span>
<span class="p_del">-			    TASK_SIZE - eppnt-&gt;p_memsz &lt; k) {</span>
<span class="p_add">+			    eppnt-&gt;p_memsz &gt; mmap_max_addr() ||</span>
<span class="p_add">+			    mmap_max_addr() - eppnt-&gt;p_memsz &lt; k) {</span>
 				error = -ENOMEM;
 				goto out;
 			}
<span class="p_chunk">@@ -960,8 +960,8 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 		 * &lt;= p_memsz so it is only necessary to check p_memsz.
 		 */
 		if (BAD_ADDR(k) || elf_ppnt-&gt;p_filesz &gt; elf_ppnt-&gt;p_memsz ||
<span class="p_del">-		    elf_ppnt-&gt;p_memsz &gt; TASK_SIZE ||</span>
<span class="p_del">-		    TASK_SIZE - elf_ppnt-&gt;p_memsz &lt; k) {</span>
<span class="p_add">+		    elf_ppnt-&gt;p_memsz &gt; mmap_max_addr() ||</span>
<span class="p_add">+		    mmap_max_addr() - elf_ppnt-&gt;p_memsz &lt; k) {</span>
 			/* set_brk can never work. Avoid overflows. */
 			retval = -EINVAL;
 			goto out_free_dentry;
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 54de77e78775..e132e93b85fb 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 
 	if (len &amp; ~huge_page_mask(h))
 		return -EINVAL;
<span class="p_del">-	if (len &gt; TASK_SIZE)</span>
<span class="p_add">+	if (len &gt; mmap_max_addr())</span>
 		return -ENOMEM;
 
 	if (flags &amp; MAP_FIXED) {
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 	if (addr) {
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp;</span>
<span class="p_add">+		if (mmap_max_addr() - len &gt;= addr &amp;&amp;</span>
 		    (!vma || addr + len &lt;= vma-&gt;vm_start))
 			return addr;
 	}
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 	info.flags = 0;
 	info.length = len;
 	info.low_limit = TASK_UNMAPPED_BASE;
<span class="p_del">-	info.high_limit = TASK_SIZE;</span>
<span class="p_add">+	info.high_limit = mmap_max_addr();</span>
 	info.align_mask = PAGE_MASK &amp; ~huge_page_mask(h);
 	info.align_offset = 0;
 	return vm_unmapped_area(&amp;info);
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 8e7e61b28f31..b91247cd171d 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -594,6 +594,7 @@</span> <span class="p_context"> static const struct limit_names lnames[RLIM_NLIMITS] = {</span>
 	[RLIMIT_NICE] = {&quot;Max nice priority&quot;, NULL},
 	[RLIMIT_RTPRIO] = {&quot;Max realtime priority&quot;, NULL},
 	[RLIMIT_RTTIME] = {&quot;Max realtime timeout&quot;, &quot;us&quot;},
<span class="p_add">+	[RLIMIT_VADDR] = {&quot;Max virtual address&quot;, NULL},</span>
 };
 
 /* Display limits for a process */
<span class="p_header">diff --git a/include/asm-generic/resource.h b/include/asm-generic/resource.h</span>
<span class="p_header">index 5e752b959054..d24c978103e5 100644</span>
<span class="p_header">--- a/include/asm-generic/resource.h</span>
<span class="p_header">+++ b/include/asm-generic/resource.h</span>
<span class="p_chunk">@@ -3,6 +3,9 @@</span> <span class="p_context"></span>
 
 #include &lt;uapi/asm-generic/resource.h&gt;
 
<span class="p_add">+#ifndef USER_VADDR_LIM</span>
<span class="p_add">+#define USER_VADDR_LIM RLIM_INFINITY</span>
<span class="p_add">+#endif</span>
 
 /*
  * boot-time rlimit defaults for the init task:
<span class="p_chunk">@@ -25,6 +28,7 @@</span> <span class="p_context"></span>
 	[RLIMIT_NICE]		= { 0, 0 },				\
 	[RLIMIT_RTPRIO]		= { 0, 0 },				\
 	[RLIMIT_RTTIME]		= {  RLIM_INFINITY,  RLIM_INFINITY },	\
<span class="p_add">+	[RLIMIT_VADDR]		= { USER_VADDR_LIM,  RLIM_INFINITY },   \</span>
 }
 
 #endif
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 4d1905245c7a..f0f23afe0838 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -3661,4 +3661,9 @@</span> <span class="p_context"> void cpufreq_add_update_util_hook(int cpu, struct update_util_data *data,</span>
 void cpufreq_remove_update_util_hook(int cpu);
 #endif /* CONFIG_CPU_FREQ */
 
<span class="p_add">+static inline unsigned long mmap_max_addr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return min(TASK_SIZE, rlimit(RLIMIT_VADDR));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/include/uapi/asm-generic/resource.h b/include/uapi/asm-generic/resource.h</span>
<span class="p_header">index c6d10af50123..7843ed0ed7a7 100644</span>
<span class="p_header">--- a/include/uapi/asm-generic/resource.h</span>
<span class="p_header">+++ b/include/uapi/asm-generic/resource.h</span>
<span class="p_chunk">@@ -45,7 +45,8 @@</span> <span class="p_context"></span>
 					   0-39 for nice level 19 .. -20 */
 #define RLIMIT_RTPRIO		14	/* maximum realtime priority */
 #define RLIMIT_RTTIME		15	/* timeout for RT tasks in us */
<span class="p_del">-#define RLIM_NLIMITS		16</span>
<span class="p_add">+#define RLIMIT_VADDR		16	/* maximum virtual address */</span>
<span class="p_add">+#define RLIM_NLIMITS		17</span>
 
 /*
  * SuS says limits have to be unsigned.
<span class="p_header">diff --git a/kernel/events/uprobes.c b/kernel/events/uprobes.c</span>
<span class="p_header">index d416f3baf392..651f571a1a79 100644</span>
<span class="p_header">--- a/kernel/events/uprobes.c</span>
<span class="p_header">+++ b/kernel/events/uprobes.c</span>
<span class="p_chunk">@@ -1142,8 +1142,9 @@</span> <span class="p_context"> static int xol_add_vma(struct mm_struct *mm, struct xol_area *area)</span>
 
 	if (!area-&gt;vaddr) {
 		/* Try to map as high as possible, this is only a hint. */
<span class="p_del">-		area-&gt;vaddr = get_unmapped_area(NULL, TASK_SIZE - PAGE_SIZE,</span>
<span class="p_del">-						PAGE_SIZE, 0, 0);</span>
<span class="p_add">+		area-&gt;vaddr = get_unmapped_area(NULL,</span>
<span class="p_add">+				mmap_max_addr() - PAGE_SIZE,</span>
<span class="p_add">+				PAGE_SIZE, 0, 0);</span>
 		if (area-&gt;vaddr &amp; ~PAGE_MASK) {
 			ret = area-&gt;vaddr;
 			goto fail;
<span class="p_header">diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="p_header">index 842914ef7de4..a5ee7f23beda 100644</span>
<span class="p_header">--- a/kernel/sys.c</span>
<span class="p_header">+++ b/kernel/sys.c</span>
<span class="p_chunk">@@ -1718,7 +1718,7 @@</span> <span class="p_context"> static int prctl_set_mm_exe_file(struct mm_struct *mm, unsigned int fd)</span>
  */
 static int validate_prctl_map(struct prctl_mm_map *prctl_map)
 {
<span class="p_del">-	unsigned long mmap_max_addr = TASK_SIZE;</span>
<span class="p_add">+	unsigned long max_addr = mmap_max_addr();</span>
 	struct mm_struct *mm = current-&gt;mm;
 	int error = -EINVAL, i;
 
<span class="p_chunk">@@ -1743,7 +1743,7 @@</span> <span class="p_context"> static int validate_prctl_map(struct prctl_mm_map *prctl_map)</span>
 	for (i = 0; i &lt; ARRAY_SIZE(offsets); i++) {
 		u64 val = *(u64 *)((char *)prctl_map + offsets[i]);
 
<span class="p_del">-		if ((unsigned long)val &gt;= mmap_max_addr ||</span>
<span class="p_add">+		if ((unsigned long)val &gt;= max_addr ||</span>
 		    (unsigned long)val &lt; mmap_min_addr)
 			goto out;
 	}
<span class="p_chunk">@@ -1949,7 +1949,7 @@</span> <span class="p_context"> static int prctl_set_mm(int opt, unsigned long addr,</span>
 	if (opt == PR_SET_MM_AUXV)
 		return prctl_set_auxv(mm, addr, arg4);
 
<span class="p_del">-	if (addr &gt;= TASK_SIZE || addr &lt; mmap_min_addr)</span>
<span class="p_add">+	if (addr &gt;= mmap_max_addr() || addr &lt; mmap_min_addr)</span>
 		return -EINVAL;
 
 	error = -EINVAL;
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index dc4291dcc99b..a3384f23359e 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -1966,7 +1966,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 	struct vm_area_struct *vma;
 	struct vm_unmapped_area_info info;
 
<span class="p_del">-	if (len &gt; TASK_SIZE - mmap_min_addr)</span>
<span class="p_add">+	if (len &gt; mmap_max_addr() - mmap_min_addr)</span>
 		return -ENOMEM;
 
 	if (flags &amp; MAP_FIXED)
<span class="p_chunk">@@ -1975,15 +1975,16 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;</span>
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		if (mmap_max_addr() - len &gt;= addr &amp;&amp;</span>
<span class="p_add">+				addr &gt;= mmap_min_addr &amp;&amp;</span>
<span class="p_add">+				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
 			return addr;
 	}
 
 	info.flags = 0;
 	info.length = len;
 	info.low_limit = mm-&gt;mmap_base;
<span class="p_del">-	info.high_limit = TASK_SIZE;</span>
<span class="p_add">+	info.high_limit = mmap_max_addr();</span>
 	info.align_mask = 0;
 	return vm_unmapped_area(&amp;info);
 }
<span class="p_chunk">@@ -2005,7 +2006,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	struct vm_unmapped_area_info info;
 
 	/* requested length too big for entire address space */
<span class="p_del">-	if (len &gt; TASK_SIZE - mmap_min_addr)</span>
<span class="p_add">+	if (len &gt; mmap_max_addr() - mmap_min_addr)</span>
 		return -ENOMEM;
 
 	if (flags &amp; MAP_FIXED)
<span class="p_chunk">@@ -2015,7 +2016,8 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;</span>
<span class="p_add">+		if (mmap_max_addr() - len &gt;= addr &amp;&amp;</span>
<span class="p_add">+				addr &gt;= mmap_min_addr &amp;&amp;</span>
 				(!vma || addr + len &lt;= vma-&gt;vm_start))
 			return addr;
 	}
<span class="p_chunk">@@ -2037,7 +2039,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		VM_BUG_ON(addr != -ENOMEM);
 		info.flags = 0;
 		info.low_limit = TASK_UNMAPPED_BASE;
<span class="p_del">-		info.high_limit = TASK_SIZE;</span>
<span class="p_add">+		info.high_limit = mmap_max_addr();</span>
 		addr = vm_unmapped_area(&amp;info);
 	}
 
<span class="p_chunk">@@ -2057,7 +2059,7 @@</span> <span class="p_context"> get_unmapped_area(struct file *file, unsigned long addr, unsigned long len,</span>
 		return error;
 
 	/* Careful about overflows.. */
<span class="p_del">-	if (len &gt; TASK_SIZE)</span>
<span class="p_add">+	if (len &gt; mmap_max_addr())</span>
 		return -ENOMEM;
 
 	get_area = current-&gt;mm-&gt;get_unmapped_area;
<span class="p_chunk">@@ -2078,7 +2080,7 @@</span> <span class="p_context"> get_unmapped_area(struct file *file, unsigned long addr, unsigned long len,</span>
 	if (IS_ERR_VALUE(addr))
 		return addr;
 
<span class="p_del">-	if (addr &gt; TASK_SIZE - len)</span>
<span class="p_add">+	if (addr &gt; mmap_max_addr() - len)</span>
 		return -ENOMEM;
 	if (offset_in_page(addr))
 		return -EINVAL;
<span class="p_header">diff --git a/mm/mremap.c b/mm/mremap.c</span>
<span class="p_header">index 2b3bfcd51c75..a8b4fba3dce6 100644</span>
<span class="p_header">--- a/mm/mremap.c</span>
<span class="p_header">+++ b/mm/mremap.c</span>
<span class="p_chunk">@@ -433,7 +433,8 @@</span> <span class="p_context"> static unsigned long mremap_to(unsigned long addr, unsigned long old_len,</span>
 	if (offset_in_page(new_addr))
 		goto out;
 
<span class="p_del">-	if (new_len &gt; TASK_SIZE || new_addr &gt; TASK_SIZE - new_len)</span>
<span class="p_add">+	if (new_len &gt; mmap_max_addr() ||</span>
<span class="p_add">+			new_addr &gt; mmap_max_addr() - new_len)</span>
 		goto out;
 
 	/* Ensure the old/new locations do not overlap */
<span class="p_header">diff --git a/mm/nommu.c b/mm/nommu.c</span>
<span class="p_header">index 24f9f5f39145..6043b8b82083 100644</span>
<span class="p_header">--- a/mm/nommu.c</span>
<span class="p_header">+++ b/mm/nommu.c</span>
<span class="p_chunk">@@ -905,7 +905,7 @@</span> <span class="p_context"> static int validate_mmap_request(struct file *file,</span>
 
 	/* Careful about overflows.. */
 	rlen = PAGE_ALIGN(len);
<span class="p_del">-	if (!rlen || rlen &gt; TASK_SIZE)</span>
<span class="p_add">+	if (!rlen || rlen &gt; mmap_max_addr())</span>
 		return -ENOMEM;
 
 	/* offset overflow? */
<span class="p_header">diff --git a/mm/shmem.c b/mm/shmem.c</span>
<span class="p_header">index bb53285a1d99..3c9be716083f 100644</span>
<span class="p_header">--- a/mm/shmem.c</span>
<span class="p_header">+++ b/mm/shmem.c</span>
<span class="p_chunk">@@ -1976,7 +1976,7 @@</span> <span class="p_context"> unsigned long shmem_get_unmapped_area(struct file *file,</span>
 	unsigned long inflated_addr;
 	unsigned long inflated_offset;
 
<span class="p_del">-	if (len &gt; TASK_SIZE)</span>
<span class="p_add">+	if (len &gt; mmap_max_addr())</span>
 		return -ENOMEM;
 
 	get_area = current-&gt;mm-&gt;get_unmapped_area;
<span class="p_chunk">@@ -1988,7 +1988,7 @@</span> <span class="p_context"> unsigned long shmem_get_unmapped_area(struct file *file,</span>
 		return addr;
 	if (addr &amp; ~PAGE_MASK)
 		return addr;
<span class="p_del">-	if (addr &gt; TASK_SIZE - len)</span>
<span class="p_add">+	if (addr &gt; mmap_max_addr() - len)</span>
 		return addr;
 
 	if (shmem_huge == SHMEM_HUGE_DENY)
<span class="p_chunk">@@ -2031,7 +2031,7 @@</span> <span class="p_context"> unsigned long shmem_get_unmapped_area(struct file *file,</span>
 		return addr;
 
 	inflated_len = len + HPAGE_PMD_SIZE - PAGE_SIZE;
<span class="p_del">-	if (inflated_len &gt; TASK_SIZE)</span>
<span class="p_add">+	if (inflated_len &gt; mmap_max_addr())</span>
 		return addr;
 	if (inflated_len &lt; len)
 		return addr;
<span class="p_chunk">@@ -2047,7 +2047,7 @@</span> <span class="p_context"> unsigned long shmem_get_unmapped_area(struct file *file,</span>
 	if (inflated_offset &gt; offset)
 		inflated_addr += HPAGE_PMD_SIZE;
 
<span class="p_del">-	if (inflated_addr &gt; TASK_SIZE - len)</span>
<span class="p_add">+	if (inflated_addr &gt; mmap_max_addr() - len)</span>
 		return addr;
 	return inflated_addr;
 }

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



