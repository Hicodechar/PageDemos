
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.66 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.66</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 30, 2017, 8:58 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171130085851.GB2297@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10084421/mbox/"
   >mbox</a>
|
   <a href="/patch/10084421/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10084421/">/patch/10084421/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	12547602B9 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Nov 2017 08:59:08 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CFD5329F04
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Nov 2017 08:59:07 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C22FA29F06; Thu, 30 Nov 2017 08:59:07 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4058B29F04
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Nov 2017 08:59:00 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752275AbdK3I66 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 30 Nov 2017 03:58:58 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:54952 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750849AbdK3I6s (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 30 Nov 2017 03:58:48 -0500
Received: from localhost (cpc92304-cmbg19-2-0-cust157.5-4.cable.virginm.net
	[82.24.196.158])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 3BEFE900;
	Thu, 30 Nov 2017 08:58:46 +0000 (UTC)
Date: Thu, 30 Nov 2017 08:58:51 +0000
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.66
Message-ID: &lt;20171130085851.GB2297@kroah.com&gt;
References: &lt;20171130085847.GA2297@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171130085847.GA2297@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Nov. 30, 2017, 8:58 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 87a641515e9c..8e62f9e2a08c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 65</span>
<span class="p_add">+SUBLEVEL = 66</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/mm/dump.c b/arch/arm/mm/dump.c</span>
<span class="p_header">index 9fe8e241335c..e1f6f0daa847 100644</span>
<span class="p_header">--- a/arch/arm/mm/dump.c</span>
<span class="p_header">+++ b/arch/arm/mm/dump.c</span>
<span class="p_chunk">@@ -126,8 +126,8 @@</span> <span class="p_context"> static const struct prot_bits section_bits[] = {</span>
 		.val	= PMD_SECT_USER,
 		.set	= &quot;USR&quot;,
 	}, {
<span class="p_del">-		.mask	= L_PMD_SECT_RDONLY,</span>
<span class="p_del">-		.val	= L_PMD_SECT_RDONLY,</span>
<span class="p_add">+		.mask	= L_PMD_SECT_RDONLY | PMD_SECT_AP2,</span>
<span class="p_add">+		.val	= L_PMD_SECT_RDONLY | PMD_SECT_AP2,</span>
 		.set	= &quot;ro&quot;,
 		.clear	= &quot;RW&quot;,
 #elif __LINUX_ARM_ARCH__ &gt;= 6
<span class="p_header">diff --git a/arch/arm/mm/init.c b/arch/arm/mm/init.c</span>
<span class="p_header">index 370581aeb871..4c587ad8bfe3 100644</span>
<span class="p_header">--- a/arch/arm/mm/init.c</span>
<span class="p_header">+++ b/arch/arm/mm/init.c</span>
<span class="p_chunk">@@ -619,8 +619,8 @@</span> <span class="p_context"> static struct section_perm ro_perms[] = {</span>
 		.start  = (unsigned long)_stext,
 		.end    = (unsigned long)__init_begin,
 #ifdef CONFIG_ARM_LPAE
<span class="p_del">-		.mask   = ~L_PMD_SECT_RDONLY,</span>
<span class="p_del">-		.prot   = L_PMD_SECT_RDONLY,</span>
<span class="p_add">+		.mask   = ~(L_PMD_SECT_RDONLY | PMD_SECT_AP2),</span>
<span class="p_add">+		.prot   = L_PMD_SECT_RDONLY | PMD_SECT_AP2,</span>
 #else
 		.mask   = ~(PMD_SECT_APX | PMD_SECT_AP_WRITE),
 		.prot   = PMD_SECT_APX | PMD_SECT_AP_WRITE,
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">index 61e214015b38..7acd3c5c7643 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -91,6 +91,8 @@</span> <span class="p_context"> extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];</span>
 	((pte_val(pte) &amp; (PTE_VALID | PTE_USER | PTE_UXN)) == (PTE_VALID | PTE_UXN))
 #define pte_valid_young(pte) \
 	((pte_val(pte) &amp; (PTE_VALID | PTE_AF)) == (PTE_VALID | PTE_AF))
<span class="p_add">+#define pte_valid_user(pte) \</span>
<span class="p_add">+	((pte_val(pte) &amp; (PTE_VALID | PTE_USER)) == (PTE_VALID | PTE_USER))</span>
 
 /*
  * Could the pte be present in the TLB? We must check mm_tlb_flush_pending
<span class="p_chunk">@@ -100,6 +102,18 @@</span> <span class="p_context"> extern unsigned long empty_zero_page[PAGE_SIZE / sizeof(unsigned long)];</span>
 #define pte_accessible(mm, pte)	\
 	(mm_tlb_flush_pending(mm) ? pte_present(pte) : pte_valid_young(pte))
 
<span class="p_add">+/*</span>
<span class="p_add">+ * p??_access_permitted() is true for valid user mappings (subject to the</span>
<span class="p_add">+ * write permission check) other than user execute-only which do not have the</span>
<span class="p_add">+ * PTE_USER bit set. PROT_NONE mappings do not have the PTE_VALID bit set.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define pte_access_permitted(pte, write) \</span>
<span class="p_add">+	(pte_valid_user(pte) &amp;&amp; (!(write) || pte_write(pte)))</span>
<span class="p_add">+#define pmd_access_permitted(pmd, write) \</span>
<span class="p_add">+	(pte_access_permitted(pmd_pte(pmd), (write)))</span>
<span class="p_add">+#define pud_access_permitted(pud, write) \</span>
<span class="p_add">+	(pte_access_permitted(pud_pte(pud), (write)))</span>
<span class="p_add">+</span>
 static inline pte_t clear_pte_bit(pte_t pte, pgprot_t prot)
 {
 	pte_val(pte) &amp;= ~pgprot_val(prot);
<span class="p_header">diff --git a/arch/mips/bcm47xx/leds.c b/arch/mips/bcm47xx/leds.c</span>
<span class="p_header">index d20ae63eb3c2..46abe9e4e0e0 100644</span>
<span class="p_header">--- a/arch/mips/bcm47xx/leds.c</span>
<span class="p_header">+++ b/arch/mips/bcm47xx/leds.c</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> bcm47xx_leds_linksys_wrt54g3gv2[] __initconst = {</span>
 /* Verified on: WRT54GS V1.0 */
 static const struct gpio_led
 bcm47xx_leds_linksys_wrt54g_type_0101[] __initconst = {
<span class="p_del">-	BCM47XX_GPIO_LED(0, &quot;green&quot;, &quot;wlan&quot;, 0, LEDS_GPIO_DEFSTATE_OFF),</span>
<span class="p_add">+	BCM47XX_GPIO_LED(0, &quot;green&quot;, &quot;wlan&quot;, 1, LEDS_GPIO_DEFSTATE_OFF),</span>
 	BCM47XX_GPIO_LED(1, &quot;green&quot;, &quot;power&quot;, 0, LEDS_GPIO_DEFSTATE_ON),
 	BCM47XX_GPIO_LED(7, &quot;green&quot;, &quot;dmz&quot;, 1, LEDS_GPIO_DEFSTATE_OFF),
 };
<span class="p_header">diff --git a/arch/mips/boot/dts/brcm/Makefile b/arch/mips/boot/dts/brcm/Makefile</span>
<span class="p_header">index d61bc2aebf69..7d90a8710425 100644</span>
<span class="p_header">--- a/arch/mips/boot/dts/brcm/Makefile</span>
<span class="p_header">+++ b/arch/mips/boot/dts/brcm/Makefile</span>
<span class="p_chunk">@@ -22,7 +22,6 @@</span> <span class="p_context"> dtb-$(CONFIG_DT_NONE) += \</span>
 	bcm63268-comtrend-vr-3032u.dtb \
 	bcm93384wvg.dtb \
 	bcm93384wvg_viper.dtb \
<span class="p_del">-	bcm96358nb4ser.dtb \</span>
 	bcm96368mvwg.dtb \
 	bcm9ejtagprb.dtb \
 	bcm97125cbmb.dtb \
<span class="p_header">diff --git a/arch/mips/include/asm/asmmacro.h b/arch/mips/include/asm/asmmacro.h</span>
<span class="p_header">index 83054f79f72a..8333ce90b172 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/asmmacro.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/asmmacro.h</span>
<span class="p_chunk">@@ -19,6 +19,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/asmmacro-64.h&gt;
 #endif
 
<span class="p_add">+/* preprocessor replaces the fp in &quot;.set fp=64&quot; with $30 otherwise */</span>
<span class="p_add">+#undef fp</span>
<span class="p_add">+</span>
 /*
  * Helper macros for generating raw instruction encodings.
  */
<span class="p_chunk">@@ -105,6 +108,7 @@</span> <span class="p_context"></span>
 	.macro	fpu_save_16odd thread
 	.set	push
 	.set	mips64r2
<span class="p_add">+	.set	fp=64</span>
 	SET_HARDFLOAT
 	sdc1	$f1,  THREAD_FPR1(\thread)
 	sdc1	$f3,  THREAD_FPR3(\thread)
<span class="p_chunk">@@ -163,6 +167,7 @@</span> <span class="p_context"></span>
 	.macro	fpu_restore_16odd thread
 	.set	push
 	.set	mips64r2
<span class="p_add">+	.set	fp=64</span>
 	SET_HARDFLOAT
 	ldc1	$f1,  THREAD_FPR1(\thread)
 	ldc1	$f3,  THREAD_FPR3(\thread)
<span class="p_chunk">@@ -234,9 +239,6 @@</span> <span class="p_context"></span>
 	.endm
 
 #ifdef TOOLCHAIN_SUPPORTS_MSA
<span class="p_del">-/* preprocessor replaces the fp in &quot;.set fp=64&quot; with $30 otherwise */</span>
<span class="p_del">-#undef fp</span>
<span class="p_del">-</span>
 	.macro	_cfcmsa	rd, cs
 	.set	push
 	.set	mips32r2
<span class="p_header">diff --git a/arch/mips/kernel/ptrace.c b/arch/mips/kernel/ptrace.c</span>
<span class="p_header">index 3de026034c35..11890e6e4093 100644</span>
<span class="p_header">--- a/arch/mips/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/mips/kernel/ptrace.c</span>
<span class="p_chunk">@@ -647,6 +647,19 @@</span> <span class="p_context"> static const struct user_regset_view user_mips64_view = {</span>
 	.n		= ARRAY_SIZE(mips64_regsets),
 };
 
<span class="p_add">+#ifdef CONFIG_MIPS32_N32</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct user_regset_view user_mipsn32_view = {</span>
<span class="p_add">+	.name		= &quot;mipsn32&quot;,</span>
<span class="p_add">+	.e_flags	= EF_MIPS_ABI2,</span>
<span class="p_add">+	.e_machine	= ELF_ARCH,</span>
<span class="p_add">+	.ei_osabi	= ELF_OSABI,</span>
<span class="p_add">+	.regsets	= mips64_regsets,</span>
<span class="p_add">+	.n		= ARRAY_SIZE(mips64_regsets),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_MIPS32_N32 */</span>
<span class="p_add">+</span>
 #endif /* CONFIG_64BIT */
 
 const struct user_regset_view *task_user_regset_view(struct task_struct *task)
<span class="p_chunk">@@ -657,6 +670,10 @@</span> <span class="p_context"> const struct user_regset_view *task_user_regset_view(struct task_struct *task)</span>
 #ifdef CONFIG_MIPS32_O32
 	if (test_tsk_thread_flag(task, TIF_32BIT_REGS))
 		return &amp;user_mips_view;
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_MIPS32_N32</span>
<span class="p_add">+	if (test_tsk_thread_flag(task, TIF_32BIT_ADDR))</span>
<span class="p_add">+		return &amp;user_mipsn32_view;</span>
 #endif
 	return &amp;user_mips64_view;
 #endif
<span class="p_header">diff --git a/arch/mips/pci/pci-mt7620.c b/arch/mips/pci/pci-mt7620.c</span>
<span class="p_header">index 628c5132b3d8..a7962f79c4fe 100644</span>
<span class="p_header">--- a/arch/mips/pci/pci-mt7620.c</span>
<span class="p_header">+++ b/arch/mips/pci/pci-mt7620.c</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> static int wait_pciephy_busy(void)</span>
 		else
 			break;
 		if (retry++ &gt; WAITRETRY_MAX) {
<span class="p_del">-			printk(KERN_WARN &quot;PCIE-PHY retry failed.\n&quot;);</span>
<span class="p_add">+			pr_warn(&quot;PCIE-PHY retry failed.\n&quot;);</span>
 			return -1;
 		}
 	}
<span class="p_header">diff --git a/arch/mips/ralink/mt7620.c b/arch/mips/ralink/mt7620.c</span>
<span class="p_header">index 6f892c1f3ad7..0696142048d5 100644</span>
<span class="p_header">--- a/arch/mips/ralink/mt7620.c</span>
<span class="p_header">+++ b/arch/mips/ralink/mt7620.c</span>
<span class="p_chunk">@@ -141,8 +141,8 @@</span> <span class="p_context"> static struct rt2880_pmx_func i2c_grp_mt7628[] = {</span>
 	FUNC(&quot;i2c&quot;, 0, 4, 2),
 };
 
<span class="p_del">-static struct rt2880_pmx_func refclk_grp_mt7628[] = { FUNC(&quot;reclk&quot;, 0, 36, 1) };</span>
<span class="p_del">-static struct rt2880_pmx_func perst_grp_mt7628[] = { FUNC(&quot;perst&quot;, 0, 37, 1) };</span>
<span class="p_add">+static struct rt2880_pmx_func refclk_grp_mt7628[] = { FUNC(&quot;refclk&quot;, 0, 37, 1) };</span>
<span class="p_add">+static struct rt2880_pmx_func perst_grp_mt7628[] = { FUNC(&quot;perst&quot;, 0, 36, 1) };</span>
 static struct rt2880_pmx_func wdt_grp_mt7628[] = { FUNC(&quot;wdt&quot;, 0, 38, 1) };
 static struct rt2880_pmx_func spi_grp_mt7628[] = { FUNC(&quot;spi&quot;, 0, 7, 4) };
 
<span class="p_header">diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S</span>
<span class="p_header">index 41e60a9c7db2..e775f80ae28c 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall.S</span>
<span class="p_chunk">@@ -690,15 +690,15 @@</span> <span class="p_context"> cas_action:</span>
 	/* ELF32 Process entry path */
 lws_compare_and_swap_2:
 #ifdef CONFIG_64BIT
<span class="p_del">-	/* Clip the input registers */</span>
<span class="p_add">+	/* Clip the input registers. We don&#39;t need to clip %r23 as we</span>
<span class="p_add">+	   only use it for word operations */</span>
 	depdi	0, 31, 32, %r26
 	depdi	0, 31, 32, %r25
 	depdi	0, 31, 32, %r24
<span class="p_del">-	depdi	0, 31, 32, %r23</span>
 #endif
 
 	/* Check the validity of the size pointer */
<span class="p_del">-	subi,&gt;&gt;= 4, %r23, %r0</span>
<span class="p_add">+	subi,&gt;&gt;= 3, %r23, %r0</span>
 	b,n	lws_exit_nosys
 
 	/* Jump to the functions which will load the old and new values into
<span class="p_header">diff --git a/arch/powerpc/kernel/signal.c b/arch/powerpc/kernel/signal.c</span>
<span class="p_header">index bbe77aed198d..3600c0d99ae9 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/signal.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static void check_syscall_restart(struct pt_regs *regs, struct k_sigaction *ka,</span>
 static void do_signal(struct task_struct *tsk)
 {
 	sigset_t *oldset = sigmask_to_save();
<span class="p_del">-	struct ksignal ksig;</span>
<span class="p_add">+	struct ksignal ksig = { .sig = 0 };</span>
 	int ret;
 	int is32 = is_32bit_task();
 
<span class="p_header">diff --git a/arch/s390/include/asm/asm-prototypes.h b/arch/s390/include/asm/asm-prototypes.h</span>
new file mode 100644
<span class="p_header">index 000000000000..2c3413b0ca52</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/s390/include/asm/asm-prototypes.h</span>
<span class="p_chunk">@@ -0,0 +1,8 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_S390_PROTOTYPES_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kvm_host.h&gt;</span>
<span class="p_add">+#include &lt;linux/ftrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/fpu/api.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/asm-prototypes.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_S390_PROTOTYPES_H */</span>
<span class="p_header">diff --git a/arch/s390/include/asm/switch_to.h b/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">index 12d45f0cfdd9..dde6b52359c5 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -34,8 +34,8 @@</span> <span class="p_context"> static inline void restore_access_regs(unsigned int *acrs)</span>
 		save_access_regs(&amp;prev-&gt;thread.acrs[0]);		\
 		save_ri_cb(prev-&gt;thread.ri_cb);				\
 	}								\
<span class="p_add">+	update_cr_regs(next);						\</span>
 	if (next-&gt;mm) {							\
<span class="p_del">-		update_cr_regs(next);					\</span>
 		set_cpu_flag(CIF_FPU);					\
 		restore_access_regs(&amp;next-&gt;thread.acrs[0]);		\
 		restore_ri_cb(next-&gt;thread.ri_cb, prev-&gt;thread.ri_cb);	\
<span class="p_header">diff --git a/arch/s390/kernel/dis.c b/arch/s390/kernel/dis.c</span>
<span class="p_header">index c74c59236f44..aaf9dab3c193 100644</span>
<span class="p_header">--- a/arch/s390/kernel/dis.c</span>
<span class="p_header">+++ b/arch/s390/kernel/dis.c</span>
<span class="p_chunk">@@ -1548,6 +1548,7 @@</span> <span class="p_context"> static struct s390_insn opcode_e7[] = {</span>
 	{ &quot;vfsq&quot;, 0xce, INSTR_VRR_VV000MM },
 	{ &quot;vfs&quot;, 0xe2, INSTR_VRR_VVV00MM },
 	{ &quot;vftci&quot;, 0x4a, INSTR_VRI_VVIMM },
<span class="p_add">+	{ &quot;&quot;, 0, INSTR_INVALID }</span>
 };
 
 static struct s390_insn opcode_eb[] = {
<span class="p_chunk">@@ -1953,7 +1954,7 @@</span> <span class="p_context"> void show_code(struct pt_regs *regs)</span>
 {
 	char *mode = user_mode(regs) ? &quot;User&quot; : &quot;Krnl&quot;;
 	unsigned char code[64];
<span class="p_del">-	char buffer[64], *ptr;</span>
<span class="p_add">+	char buffer[128], *ptr;</span>
 	mm_segment_t old_fs;
 	unsigned long addr;
 	int start, end, opsize, hops, i;
<span class="p_chunk">@@ -2016,7 +2017,7 @@</span> <span class="p_context"> void show_code(struct pt_regs *regs)</span>
 		start += opsize;
 		pr_cont(&quot;%s&quot;, buffer);
 		ptr = buffer;
<span class="p_del">-		ptr += sprintf(ptr, &quot;\n          &quot;);</span>
<span class="p_add">+		ptr += sprintf(ptr, &quot;\n\t  &quot;);</span>
 		hops++;
 	}
 	pr_cont(&quot;\n&quot;);
<span class="p_header">diff --git a/arch/s390/kernel/early.c b/arch/s390/kernel/early.c</span>
<span class="p_header">index 0c196861bc38..29d87444a655 100644</span>
<span class="p_header">--- a/arch/s390/kernel/early.c</span>
<span class="p_header">+++ b/arch/s390/kernel/early.c</span>
<span class="p_chunk">@@ -345,8 +345,10 @@</span> <span class="p_context"> static __init void detect_machine_facilities(void)</span>
 		S390_lowcore.machine_flags |= MACHINE_FLAG_IDTE;
 	if (test_facility(40))
 		S390_lowcore.machine_flags |= MACHINE_FLAG_LPP;
<span class="p_del">-	if (test_facility(50) &amp;&amp; test_facility(73))</span>
<span class="p_add">+	if (test_facility(50) &amp;&amp; test_facility(73)) {</span>
 		S390_lowcore.machine_flags |= MACHINE_FLAG_TE;
<span class="p_add">+		__ctl_set_bit(0, 55);</span>
<span class="p_add">+	}</span>
 	if (test_facility(51))
 		S390_lowcore.machine_flags |= MACHINE_FLAG_TLB_LC;
 	if (test_facility(129)) {
<span class="p_header">diff --git a/arch/s390/kernel/process.c b/arch/s390/kernel/process.c</span>
<span class="p_header">index bba4fa74b321..172fe1121d99 100644</span>
<span class="p_header">--- a/arch/s390/kernel/process.c</span>
<span class="p_header">+++ b/arch/s390/kernel/process.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> int copy_thread(unsigned long clone_flags, unsigned long new_stackp,</span>
 	memset(&amp;p-&gt;thread.per_user, 0, sizeof(p-&gt;thread.per_user));
 	memset(&amp;p-&gt;thread.per_event, 0, sizeof(p-&gt;thread.per_event));
 	clear_tsk_thread_flag(p, TIF_SINGLE_STEP);
<span class="p_add">+	p-&gt;thread.per_flags = 0;</span>
 	/* Initialize per thread user and system timer values */
 	ti = task_thread_info(p);
 	ti-&gt;user_timer = 0;
<span class="p_header">diff --git a/arch/s390/kernel/runtime_instr.c b/arch/s390/kernel/runtime_instr.c</span>
<span class="p_header">index fffa0e5462af..70cdb03d4acd 100644</span>
<span class="p_header">--- a/arch/s390/kernel/runtime_instr.c</span>
<span class="p_header">+++ b/arch/s390/kernel/runtime_instr.c</span>
<span class="p_chunk">@@ -47,11 +47,13 @@</span> <span class="p_context"> void exit_thread_runtime_instr(void)</span>
 {
 	struct task_struct *task = current;
 
<span class="p_add">+	preempt_disable();</span>
 	if (!task-&gt;thread.ri_cb)
 		return;
 	disable_runtime_instr();
 	kfree(task-&gt;thread.ri_cb);
 	task-&gt;thread.ri_cb = NULL;
<span class="p_add">+	preempt_enable();</span>
 }
 
 SYSCALL_DEFINE1(s390_runtime_instr, int, command)
<span class="p_chunk">@@ -62,9 +64,7 @@</span> <span class="p_context"> SYSCALL_DEFINE1(s390_runtime_instr, int, command)</span>
 		return -EOPNOTSUPP;
 
 	if (command == S390_RUNTIME_INSTR_STOP) {
<span class="p_del">-		preempt_disable();</span>
 		exit_thread_runtime_instr();
<span class="p_del">-		preempt_enable();</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index e7b0e7ff4c58..be9df513141e 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -54,15 +54,19 @@</span> <span class="p_context"> ENTRY(native_usergs_sysret64)</span>
 ENDPROC(native_usergs_sysret64)
 #endif /* CONFIG_PARAVIRT */
 
<span class="p_del">-.macro TRACE_IRQS_IRETQ</span>
<span class="p_add">+.macro TRACE_IRQS_FLAGS flags:req</span>
 #ifdef CONFIG_TRACE_IRQFLAGS
<span class="p_del">-	bt	$9, EFLAGS(%rsp)		/* interrupts off? */</span>
<span class="p_add">+	bt	$9, \flags		/* interrupts off? */</span>
 	jnc	1f
 	TRACE_IRQS_ON
 1:
 #endif
 .endm
 
<span class="p_add">+.macro TRACE_IRQS_IRETQ</span>
<span class="p_add">+	TRACE_IRQS_FLAGS EFLAGS(%rsp)</span>
<span class="p_add">+.endm</span>
<span class="p_add">+</span>
 /*
  * When dynamic function tracer is enabled it will add a breakpoint
  * to all locations that it is about to modify, sync CPUs, update
<span class="p_chunk">@@ -868,11 +872,13 @@</span> <span class="p_context"> idtentry simd_coprocessor_error		do_simd_coprocessor_error	has_error_code=0</span>
 ENTRY(native_load_gs_index)
 	pushfq
 	DISABLE_INTERRUPTS(CLBR_ANY &amp; ~CLBR_RDI)
<span class="p_add">+	TRACE_IRQS_OFF</span>
 	SWAPGS
 .Lgs_change:
 	movl	%edi, %gs
 2:	ALTERNATIVE &quot;&quot;, &quot;mfence&quot;, X86_BUG_SWAPGS_FENCE
 	SWAPGS
<span class="p_add">+	TRACE_IRQS_FLAGS (%rsp)</span>
 	popfq
 	ret
 END(native_load_gs_index)
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 8ca1eca5038d..4fbf0c94f2d1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -3583,6 +3583,13 @@</span> <span class="p_context"> static int svm_set_msr(struct kvm_vcpu *vcpu, struct msr_data *msr)</span>
 	u32 ecx = msr-&gt;index;
 	u64 data = msr-&gt;data;
 	switch (ecx) {
<span class="p_add">+	case MSR_IA32_CR_PAT:</span>
<span class="p_add">+		if (!kvm_mtrr_valid(vcpu, MSR_IA32_CR_PAT, data))</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		vcpu-&gt;arch.pat = data;</span>
<span class="p_add">+		svm-&gt;vmcb-&gt;save.g_pat = data;</span>
<span class="p_add">+		mark_dirty(svm-&gt;vmcb, VMCB_NPT);</span>
<span class="p_add">+		break;</span>
 	case MSR_IA32_TSC:
 		kvm_write_tsc(vcpu, msr);
 		break;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index a8ae57acb6f6..0f0b27d96f27 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -10715,6 +10715,8 @@</span> <span class="p_context"> static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,</span>
 	vmcs_writel(GUEST_SYSENTER_EIP, vmcs12-&gt;host_ia32_sysenter_eip);
 	vmcs_writel(GUEST_IDTR_BASE, vmcs12-&gt;host_idtr_base);
 	vmcs_writel(GUEST_GDTR_BASE, vmcs12-&gt;host_gdtr_base);
<span class="p_add">+	vmcs_write32(GUEST_IDTR_LIMIT, 0xFFFF);</span>
<span class="p_add">+	vmcs_write32(GUEST_GDTR_LIMIT, 0xFFFF);</span>
 
 	/* If not VM_EXIT_CLEAR_BNDCFGS, the L2 value propagates to L1.  */
 	if (vmcs12-&gt;vm_exit_controls &amp; VM_EXIT_CLEAR_BNDCFGS)
<span class="p_header">diff --git a/arch/x86/lib/x86-opcode-map.txt b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">index 767be7c76034..1754e094bc28 100644</span>
<span class="p_header">--- a/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">+++ b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_chunk">@@ -896,7 +896,7 @@</span> <span class="p_context"> EndTable</span>
 
 GrpTable: Grp3_1
 0: TEST Eb,Ib
<span class="p_del">-1:</span>
<span class="p_add">+1: TEST Eb,Ib</span>
 2: NOT Eb
 3: NEG Eb
 4: MUL AL,Eb
<span class="p_header">diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c</span>
<span class="p_header">index 1dd796025472..8b5ff88aa4f8 100644</span>
<span class="p_header">--- a/arch/x86/mm/fault.c</span>
<span class="p_header">+++ b/arch/x86/mm/fault.c</span>
<span class="p_chunk">@@ -1393,7 +1393,17 @@</span> <span class="p_context"> __do_page_fault(struct pt_regs *regs, unsigned long error_code,</span>
 	 * make sure we exit gracefully rather than endlessly redo
 	 * the fault.  Since we never set FAULT_FLAG_RETRY_NOWAIT, if
 	 * we get VM_FAULT_RETRY back, the mmap_sem has been unlocked.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that handle_userfault() may also release and reacquire mmap_sem</span>
<span class="p_add">+	 * (and not return with VM_FAULT_RETRY), when returning to userland to</span>
<span class="p_add">+	 * repeat the page fault later with a VM_FAULT_NOPAGE retval</span>
<span class="p_add">+	 * (potentially after handling any pending signal during the return to</span>
<span class="p_add">+	 * userland). The return to userland is identified whenever</span>
<span class="p_add">+	 * FAULT_FLAG_USER|FAULT_FLAG_KILLABLE are both set in flags.</span>
<span class="p_add">+	 * Thus we have to be careful about not touching vma after handling the</span>
<span class="p_add">+	 * fault, so we read the pkey beforehand.</span>
 	 */
<span class="p_add">+	pkey = vma_pkey(vma);</span>
 	fault = handle_mm_fault(vma, address, flags);
 	major |= fault &amp; VM_FAULT_MAJOR;
 
<span class="p_chunk">@@ -1420,7 +1430,6 @@</span> <span class="p_context"> __do_page_fault(struct pt_regs *regs, unsigned long error_code,</span>
 		return;
 	}
 
<span class="p_del">-	pkey = vma_pkey(vma);</span>
 	up_read(&amp;mm-&gt;mmap_sem);
 	if (unlikely(fault &amp; VM_FAULT_ERROR)) {
 		mm_fault_error(regs, error_code, address, &amp;pkey, fault);
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 95379fc83805..b1c76aa73492 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -282,6 +282,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_stop_queue);</span>
 void blk_sync_queue(struct request_queue *q)
 {
 	del_timer_sync(&amp;q-&gt;timeout);
<span class="p_add">+	cancel_work_sync(&amp;q-&gt;timeout_work);</span>
 
 	if (q-&gt;mq_ops) {
 		struct blk_mq_hw_ctx *hctx;
<span class="p_chunk">@@ -720,6 +721,7 @@</span> <span class="p_context"> struct request_queue *blk_alloc_queue_node(gfp_t gfp_mask, int node_id)</span>
 	setup_timer(&amp;q-&gt;backing_dev_info.laptop_mode_wb_timer,
 		    laptop_mode_timer_fn, (unsigned long) q);
 	setup_timer(&amp;q-&gt;timeout, blk_rq_timed_out_timer, (unsigned long) q);
<span class="p_add">+	INIT_WORK(&amp;q-&gt;timeout_work, NULL);</span>
 	INIT_LIST_HEAD(&amp;q-&gt;queue_head);
 	INIT_LIST_HEAD(&amp;q-&gt;timeout_list);
 	INIT_LIST_HEAD(&amp;q-&gt;icq_list);
<span class="p_header">diff --git a/block/blk-timeout.c b/block/blk-timeout.c</span>
<span class="p_header">index a30441a200c0..220661a50f58 100644</span>
<span class="p_header">--- a/block/blk-timeout.c</span>
<span class="p_header">+++ b/block/blk-timeout.c</span>
<span class="p_chunk">@@ -135,8 +135,6 @@</span> <span class="p_context"> void blk_timeout_work(struct work_struct *work)</span>
 	struct request *rq, *tmp;
 	int next_set = 0;
 
<span class="p_del">-	if (blk_queue_enter(q, true))</span>
<span class="p_del">-		return;</span>
 	spin_lock_irqsave(q-&gt;queue_lock, flags);
 
 	list_for_each_entry_safe(rq, tmp, &amp;q-&gt;timeout_list, timeout_list)
<span class="p_chunk">@@ -146,7 +144,6 @@</span> <span class="p_context"> void blk_timeout_work(struct work_struct *work)</span>
 		mod_timer(&amp;q-&gt;timeout, round_jiffies_up(next));
 
 	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
<span class="p_del">-	blk_queue_exit(q);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c</span>
<span class="p_header">index 51874695a730..c3bcb7f5986e 100644</span>
<span class="p_header">--- a/drivers/acpi/ec.c</span>
<span class="p_header">+++ b/drivers/acpi/ec.c</span>
<span class="p_chunk">@@ -482,8 +482,11 @@</span> <span class="p_context"> static inline void __acpi_ec_enable_event(struct acpi_ec *ec)</span>
 {
 	if (!test_and_set_bit(EC_FLAGS_QUERY_ENABLED, &amp;ec-&gt;flags))
 		ec_log_drv(&quot;event unblocked&quot;);
<span class="p_del">-	if (!test_bit(EC_FLAGS_QUERY_PENDING, &amp;ec-&gt;flags))</span>
<span class="p_del">-		advance_transaction(ec);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Unconditionally invoke this once after enabling the event</span>
<span class="p_add">+	 * handling mechanism to detect the pending events.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	advance_transaction(ec);</span>
 }
 
 static inline void __acpi_ec_disable_event(struct acpi_ec *ec)
<span class="p_chunk">@@ -1458,11 +1461,10 @@</span> <span class="p_context"> static int ec_install_handlers(struct acpi_ec *ec, bool handle_events)</span>
 			if (test_bit(EC_FLAGS_STARTED, &amp;ec-&gt;flags) &amp;&amp;
 			    ec-&gt;reference_count &gt;= 1)
 				acpi_ec_enable_gpe(ec, true);
<span class="p_del">-</span>
<span class="p_del">-			/* EC is fully operational, allow queries */</span>
<span class="p_del">-			acpi_ec_enable_event(ec);</span>
 		}
 	}
<span class="p_add">+	/* EC is fully operational, allow queries */</span>
<span class="p_add">+	acpi_ec_enable_event(ec);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index 0e1ec37070d1..6475a1343483 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -2329,8 +2329,8 @@</span> <span class="p_context"> static void ata_eh_link_autopsy(struct ata_link *link)</span>
 		if (dev-&gt;flags &amp; ATA_DFLAG_DUBIOUS_XFER)
 			eflags |= ATA_EFLAG_DUBIOUS_XFER;
 		ehc-&gt;i.action |= ata_eh_speed_down(dev, eflags, all_err_mask);
<span class="p_add">+		trace_ata_eh_link_autopsy(dev, ehc-&gt;i.action, all_err_mask);</span>
 	}
<span class="p_del">-	trace_ata_eh_link_autopsy(dev, ehc-&gt;i.action, all_err_mask);</span>
 	DPRINTK(&quot;EXIT\n&quot;);
 }
 
<span class="p_header">diff --git a/drivers/base/power/opp/of.c b/drivers/base/power/opp/of.c</span>
<span class="p_header">index b52c617947ad..69379443e5eb 100644</span>
<span class="p_header">--- a/drivers/base/power/opp/of.c</span>
<span class="p_header">+++ b/drivers/base/power/opp/of.c</span>
<span class="p_chunk">@@ -348,6 +348,7 @@</span> <span class="p_context"> static int _of_add_opp_table_v2(struct device *dev, struct device_node *opp_np)</span>
 		if (ret) {
 			dev_err(dev, &quot;%s: Failed to add OPP, %d\n&quot;, __func__,
 				ret);
<span class="p_add">+			of_node_put(np);</span>
 			goto free_table;
 		}
 	}
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-ipq4019.c b/drivers/clk/qcom/gcc-ipq4019.c</span>
<span class="p_header">index b593065de8db..8ab6ce4d976f 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-ipq4019.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-ipq4019.c</span>
<span class="p_chunk">@@ -525,10 +525,20 @@</span> <span class="p_context"> static struct clk_rcg2  sdcc1_apps_clk_src = {</span>
 };
 
 static const struct freq_tbl ftbl_gcc_apps_clk[] = {
<span class="p_del">-	F(48000000, P_XO,	   1, 0, 0),</span>
<span class="p_add">+	F(48000000,  P_XO,         1, 0, 0),</span>
 	F(200000000, P_FEPLL200,   1, 0, 0),
<span class="p_add">+	F(384000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(413000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(448000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(488000000, P_DDRPLLAPSS, 1, 0, 0),</span>
 	F(500000000, P_FEPLL500,   1, 0, 0),
<span class="p_del">-	F(626000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(512000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(537000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(565000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(597000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(632000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(672000000, P_DDRPLLAPSS, 1, 0, 0),</span>
<span class="p_add">+	F(716000000, P_DDRPLLAPSS, 1, 0, 0),</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">index 0cca3601d99e..df97e25aec76 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_chunk">@@ -468,8 +468,8 @@</span> <span class="p_context"> static SUNXI_CCU_MUX_WITH_GATE(daudio0_clk, &quot;daudio0&quot;, daudio_parents,</span>
 static SUNXI_CCU_MUX_WITH_GATE(daudio1_clk, &quot;daudio1&quot;, daudio_parents,
 			       0x0b4, 16, 2, BIT(31), CLK_SET_RATE_PARENT);
 
<span class="p_del">-static SUNXI_CCU_M_WITH_GATE(spdif_clk, &quot;spdif&quot;, &quot;pll-audio&quot;,</span>
<span class="p_del">-			     0x0c0, 0, 4, BIT(31), CLK_SET_RATE_PARENT);</span>
<span class="p_add">+static SUNXI_CCU_MUX_WITH_GATE(spdif_clk, &quot;spdif&quot;, daudio_parents,</span>
<span class="p_add">+			       0x0c0, 16, 2, BIT(31), CLK_SET_RATE_PARENT);</span>
 
 static SUNXI_CCU_GATE(usb_phy0_clk,	&quot;usb-phy0&quot;,	&quot;osc24M&quot;,
 		      0x0cc, BIT(8), 0);
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-a33.c b/drivers/clk/sunxi-ng/ccu-sun8i-a33.c</span>
<span class="p_header">index 9bd1f78a0547..e1dc4e5b34e1 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun8i-a33.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun8i-a33.c</span>
<span class="p_chunk">@@ -752,6 +752,13 @@</span> <span class="p_context"> static const struct sunxi_ccu_desc sun8i_a33_ccu_desc = {</span>
 	.num_resets	= ARRAY_SIZE(sun8i_a33_ccu_resets),
 };
 
<span class="p_add">+static struct ccu_mux_nb sun8i_a33_cpu_nb = {</span>
<span class="p_add">+	.common		= &amp;cpux_clk.common,</span>
<span class="p_add">+	.cm		= &amp;cpux_clk.mux,</span>
<span class="p_add">+	.delay_us	= 1, /* &gt; 8 clock cycles at 24 MHz */</span>
<span class="p_add">+	.bypass_index	= 1, /* index of 24 MHz oscillator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void __init sun8i_a33_ccu_setup(struct device_node *node)
 {
 	void __iomem *reg;
<span class="p_chunk">@@ -775,6 +782,9 @@</span> <span class="p_context"> static void __init sun8i_a33_ccu_setup(struct device_node *node)</span>
 	writel(val, reg + SUN8I_A33_PLL_MIPI_REG);
 
 	sunxi_ccu_probe(node, reg, &amp;sun8i_a33_ccu_desc);
<span class="p_add">+</span>
<span class="p_add">+	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,</span>
<span class="p_add">+				  &amp;sun8i_a33_cpu_nb);</span>
 }
 CLK_OF_DECLARE(sun8i_a33_ccu, &quot;allwinner,sun8i-a33-ccu&quot;,
 	       sun8i_a33_ccu_setup);
<span class="p_header">diff --git a/drivers/clk/ti/clk-dra7-atl.c b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">index c77333230bdf..7d060ffe8975 100644</span>
<span class="p_header">--- a/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">+++ b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_chunk">@@ -265,8 +265,7 @@</span> <span class="p_context"> static int of_dra7_atl_clk_probe(struct platform_device *pdev)</span>
 
 		/* Get configuration for the ATL instances */
 		snprintf(prop, sizeof(prop), &quot;atl%u&quot;, i);
<span class="p_del">-		of_node_get(node);</span>
<span class="p_del">-		cfg_node = of_find_node_by_name(node, prop);</span>
<span class="p_add">+		cfg_node = of_get_child_by_name(node, prop);</span>
 		if (cfg_node) {
 			ret = of_property_read_u32(cfg_node, &quot;bws&quot;,
 						   &amp;cdesc-&gt;bws);
<span class="p_header">diff --git a/drivers/crypto/marvell/cesa.h b/drivers/crypto/marvell/cesa.h</span>
<span class="p_header">index e423d33decd4..36291840a12c 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/cesa.h</span>
<span class="p_header">+++ b/drivers/crypto/marvell/cesa.h</span>
<span class="p_chunk">@@ -273,7 +273,8 @@</span> <span class="p_context"> struct mv_cesa_op_ctx {</span>
 #define CESA_TDMA_SRC_IN_SRAM			BIT(30)
 #define CESA_TDMA_END_OF_REQ			BIT(29)
 #define CESA_TDMA_BREAK_CHAIN			BIT(28)
<span class="p_del">-#define CESA_TDMA_TYPE_MSK			GENMASK(27, 0)</span>
<span class="p_add">+#define CESA_TDMA_SET_STATE			BIT(27)</span>
<span class="p_add">+#define CESA_TDMA_TYPE_MSK			GENMASK(26, 0)</span>
 #define CESA_TDMA_DUMMY				0
 #define CESA_TDMA_DATA				1
 #define CESA_TDMA_OP				2
<span class="p_header">diff --git a/drivers/crypto/marvell/hash.c b/drivers/crypto/marvell/hash.c</span>
<span class="p_header">index 77712b375b84..662cf4ddb04b 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/hash.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/hash.c</span>
<span class="p_chunk">@@ -280,13 +280,32 @@</span> <span class="p_context"> static void mv_cesa_ahash_std_prepare(struct ahash_request *req)</span>
 	sreq-&gt;offset = 0;
 }
 
<span class="p_add">+static void mv_cesa_ahash_dma_step(struct ahash_request *req)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mv_cesa_ahash_req *creq = ahash_request_ctx(req);</span>
<span class="p_add">+	struct mv_cesa_req *base = &amp;creq-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We must explicitly set the digest state. */</span>
<span class="p_add">+	if (base-&gt;chain.first-&gt;flags &amp; CESA_TDMA_SET_STATE) {</span>
<span class="p_add">+		struct mv_cesa_engine *engine = base-&gt;engine;</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Set the hash state in the IVDIG regs. */</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(creq-&gt;state); i++)</span>
<span class="p_add">+			writel_relaxed(creq-&gt;state[i], engine-&gt;regs +</span>
<span class="p_add">+				       CESA_IVDIG(i));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mv_cesa_dma_step(base);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void mv_cesa_ahash_step(struct crypto_async_request *req)
 {
 	struct ahash_request *ahashreq = ahash_request_cast(req);
 	struct mv_cesa_ahash_req *creq = ahash_request_ctx(ahashreq);
 
 	if (mv_cesa_req_get_type(&amp;creq-&gt;base) == CESA_DMA_REQ)
<span class="p_del">-		mv_cesa_dma_step(&amp;creq-&gt;base);</span>
<span class="p_add">+		mv_cesa_ahash_dma_step(ahashreq);</span>
 	else
 		mv_cesa_ahash_std_step(ahashreq);
 }
<span class="p_chunk">@@ -562,11 +581,15 @@</span> <span class="p_context"> static int mv_cesa_ahash_dma_req_init(struct ahash_request *req)</span>
 	struct mv_cesa_ahash_dma_iter iter;
 	struct mv_cesa_op_ctx *op = NULL;
 	unsigned int frag_len;
<span class="p_add">+	bool set_state = false;</span>
 	int ret;
 
 	basereq-&gt;chain.first = NULL;
 	basereq-&gt;chain.last = NULL;
 
<span class="p_add">+	if (!mv_cesa_mac_op_is_first_frag(&amp;creq-&gt;op_tmpl))</span>
<span class="p_add">+		set_state = true;</span>
<span class="p_add">+</span>
 	if (creq-&gt;src_nents) {
 		ret = dma_map_sg(cesa_dev-&gt;dev, req-&gt;src, creq-&gt;src_nents,
 				 DMA_TO_DEVICE);
<span class="p_chunk">@@ -650,6 +673,15 @@</span> <span class="p_context"> static int mv_cesa_ahash_dma_req_init(struct ahash_request *req)</span>
 	basereq-&gt;chain.last-&gt;flags |= (CESA_TDMA_END_OF_REQ |
 				       CESA_TDMA_BREAK_CHAIN);
 
<span class="p_add">+	if (set_state) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Put the CESA_TDMA_SET_STATE flag on the first tdma desc to</span>
<span class="p_add">+		 * let the step logic know that the IVDIG registers should be</span>
<span class="p_add">+		 * explicitly set before launching a TDMA chain.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		basereq-&gt;chain.first-&gt;flags |= CESA_TDMA_SET_STATE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 
 err_free_tdma:
<span class="p_header">diff --git a/drivers/crypto/marvell/tdma.c b/drivers/crypto/marvell/tdma.c</span>
<span class="p_header">index 9fd7a5fbaa1b..0cda6e3f2b4b 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/tdma.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/tdma.c</span>
<span class="p_chunk">@@ -112,7 +112,14 @@</span> <span class="p_context"> void mv_cesa_tdma_chain(struct mv_cesa_engine *engine,</span>
 		last-&gt;next = dreq-&gt;chain.first;
 		engine-&gt;chain.last = dreq-&gt;chain.last;
 
<span class="p_del">-		if (!(last-&gt;flags &amp; CESA_TDMA_BREAK_CHAIN))</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Break the DMA chain if the CESA_TDMA_BREAK_CHAIN is set on</span>
<span class="p_add">+		 * the last element of the current chain, or if the request</span>
<span class="p_add">+		 * being queued needs the IV regs to be set before lauching</span>
<span class="p_add">+		 * the request.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!(last-&gt;flags &amp; CESA_TDMA_BREAK_CHAIN) &amp;&amp;</span>
<span class="p_add">+		    !(dreq-&gt;chain.first-&gt;flags &amp; CESA_TDMA_SET_STATE))</span>
 			last-&gt;next_dma = dreq-&gt;chain.first-&gt;cur_dma;
 	}
 }
<span class="p_header">diff --git a/drivers/dma/zx296702_dma.c b/drivers/dma/zx296702_dma.c</span>
<span class="p_header">index 245d759d5ffc..6059d81e701a 100644</span>
<span class="p_header">--- a/drivers/dma/zx296702_dma.c</span>
<span class="p_header">+++ b/drivers/dma/zx296702_dma.c</span>
<span class="p_chunk">@@ -813,6 +813,7 @@</span> <span class="p_context"> static int zx_dma_probe(struct platform_device *op)</span>
 	INIT_LIST_HEAD(&amp;d-&gt;slave.channels);
 	dma_cap_set(DMA_SLAVE, d-&gt;slave.cap_mask);
 	dma_cap_set(DMA_MEMCPY, d-&gt;slave.cap_mask);
<span class="p_add">+	dma_cap_set(DMA_CYCLIC, d-&gt;slave.cap_mask);</span>
 	dma_cap_set(DMA_PRIVATE, d-&gt;slave.cap_mask);
 	d-&gt;slave.dev = &amp;op-&gt;dev;
 	d-&gt;slave.device_free_chan_resources = zx_dma_free_chan_resources;
<span class="p_header">diff --git a/drivers/gpio/gpio-mockup.c b/drivers/gpio/gpio-mockup.c</span>
<span class="p_header">index 1ef85b0c2b1f..d27e9361e236 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mockup.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mockup.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> static int mockup_gpio_probe(struct platform_device *pdev)</span>
 	int i;
 	int base;
 	int ngpio;
<span class="p_del">-	char chip_name[sizeof(GPIO_NAME) + 3];</span>
<span class="p_add">+	char *chip_name;</span>
 
 	if (gpio_mockup_params_nr &lt; 2)
 		return -EINVAL;
<span class="p_chunk">@@ -146,8 +146,12 @@</span> <span class="p_context"> static int mockup_gpio_probe(struct platform_device *pdev)</span>
 			ngpio = gpio_mockup_ranges[i * 2 + 1] - base;
 
 		if (ngpio &gt;= 0) {
<span class="p_del">-			sprintf(chip_name, &quot;%s-%c&quot;, GPIO_NAME,</span>
<span class="p_del">-				pins_name_start + i);</span>
<span class="p_add">+			chip_name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+						   &quot;%s-%c&quot;, GPIO_NAME,</span>
<span class="p_add">+						   pins_name_start + i);</span>
<span class="p_add">+			if (!chip_name)</span>
<span class="p_add">+				return -ENOMEM;</span>
<span class="p_add">+</span>
 			ret = mockup_gpio_add(dev, &amp;cntr[i],
 					      chip_name, base, ngpio);
 		} else {
<span class="p_header">diff --git a/drivers/gpu/drm/armada/Makefile b/drivers/gpu/drm/armada/Makefile</span>
<span class="p_header">index ffd673615772..26412d2f8c98 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/armada/Makefile</span>
<span class="p_header">+++ b/drivers/gpu/drm/armada/Makefile</span>
<span class="p_chunk">@@ -4,3 +4,5 @@</span> <span class="p_context"> armada-y	+= armada_510.o</span>
 armada-$(CONFIG_DEBUG_FS) += armada_debugfs.o
 
 obj-$(CONFIG_DRM_ARMADA) := armada.o
<span class="p_add">+</span>
<span class="p_add">+CFLAGS_armada_trace.o := -I$(src)</span>
<span class="p_header">diff --git a/drivers/gpu/drm/drm_mm.c b/drivers/gpu/drm/drm_mm.c</span>
<span class="p_header">index ee07bb4a57b7..11f54df0c19b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_mm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_mm.c</span>
<span class="p_chunk">@@ -348,14 +348,12 @@</span> <span class="p_context"> static void drm_mm_insert_helper_range(struct drm_mm_node *hole_node,</span>
 
 	BUG_ON(!hole_node-&gt;hole_follows || node-&gt;allocated);
 
<span class="p_del">-	if (adj_start &lt; start)</span>
<span class="p_del">-		adj_start = start;</span>
<span class="p_del">-	if (adj_end &gt; end)</span>
<span class="p_del">-		adj_end = end;</span>
<span class="p_del">-</span>
 	if (mm-&gt;color_adjust)
 		mm-&gt;color_adjust(hole_node, color, &amp;adj_start, &amp;adj_end);
 
<span class="p_add">+	adj_start = max(adj_start, start);</span>
<span class="p_add">+	adj_end = min(adj_end, end);</span>
<span class="p_add">+</span>
 	if (flags &amp; DRM_MM_CREATE_TOP)
 		adj_start = adj_end - size;
 
<span class="p_chunk">@@ -566,17 +564,15 @@</span> <span class="p_context"> static struct drm_mm_node *drm_mm_search_free_in_range_generic(const struct drm_</span>
 			       flags &amp; DRM_MM_SEARCH_BELOW) {
 		u64 hole_size = adj_end - adj_start;
 
<span class="p_del">-		if (adj_start &lt; start)</span>
<span class="p_del">-			adj_start = start;</span>
<span class="p_del">-		if (adj_end &gt; end)</span>
<span class="p_del">-			adj_end = end;</span>
<span class="p_del">-</span>
 		if (mm-&gt;color_adjust) {
 			mm-&gt;color_adjust(entry, color, &amp;adj_start, &amp;adj_end);
 			if (adj_end &lt;= adj_start)
 				continue;
 		}
 
<span class="p_add">+		adj_start = max(adj_start, start);</span>
<span class="p_add">+		adj_end = min(adj_end, end);</span>
<span class="p_add">+</span>
 		if (!check_free_hole(adj_start, adj_end, size, alignment))
 			continue;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index 3ce9ba30d827..a19ec06f9e42 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -457,6 +457,7 @@</span> <span class="p_context"> struct intel_crtc_scaler_state {</span>
 
 struct intel_pipe_wm {
 	struct intel_wm_level wm[5];
<span class="p_add">+	struct intel_wm_level raw_wm[5];</span>
 	uint32_t linetime;
 	bool fbc_wm_enabled;
 	bool pipe_enabled;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 277a8026460b..49de4760cc16 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -27,7 +27,6 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/cpufreq.h&gt;
 #include &lt;drm/drm_plane_helper.h&gt;
<span class="p_del">-#include &lt;drm/drm_atomic_helper.h&gt;</span>
 #include &quot;i915_drv.h&quot;
 #include &quot;intel_drv.h&quot;
 #include &quot;../../../platform/x86/intel_ips.h&quot;
<span class="p_chunk">@@ -2018,9 +2017,9 @@</span> <span class="p_context"> static void ilk_compute_wm_level(const struct drm_i915_private *dev_priv,</span>
 				 const struct intel_crtc *intel_crtc,
 				 int level,
 				 struct intel_crtc_state *cstate,
<span class="p_del">-				 const struct intel_plane_state *pristate,</span>
<span class="p_del">-				 const struct intel_plane_state *sprstate,</span>
<span class="p_del">-				 const struct intel_plane_state *curstate,</span>
<span class="p_add">+				 struct intel_plane_state *pristate,</span>
<span class="p_add">+				 struct intel_plane_state *sprstate,</span>
<span class="p_add">+				 struct intel_plane_state *curstate,</span>
 				 struct intel_wm_level *result)
 {
 	uint16_t pri_latency = dev_priv-&gt;wm.pri_latency[level];
<span class="p_chunk">@@ -2342,24 +2341,28 @@</span> <span class="p_context"> static int ilk_compute_pipe_wm(struct intel_crtc_state *cstate)</span>
 	struct intel_pipe_wm *pipe_wm;
 	struct drm_device *dev = state-&gt;dev;
 	const struct drm_i915_private *dev_priv = to_i915(dev);
<span class="p_del">-	struct drm_plane *plane;</span>
<span class="p_del">-	const struct drm_plane_state *plane_state;</span>
<span class="p_del">-	const struct intel_plane_state *pristate = NULL;</span>
<span class="p_del">-	const struct intel_plane_state *sprstate = NULL;</span>
<span class="p_del">-	const struct intel_plane_state *curstate = NULL;</span>
<span class="p_add">+	struct intel_plane *intel_plane;</span>
<span class="p_add">+	struct intel_plane_state *pristate = NULL;</span>
<span class="p_add">+	struct intel_plane_state *sprstate = NULL;</span>
<span class="p_add">+	struct intel_plane_state *curstate = NULL;</span>
 	int level, max_level = ilk_wm_max_level(dev), usable_level;
 	struct ilk_wm_maximums max;
 
 	pipe_wm = &amp;cstate-&gt;wm.ilk.optimal;
 
<span class="p_del">-	drm_atomic_crtc_state_for_each_plane_state(plane, plane_state, &amp;cstate-&gt;base) {</span>
<span class="p_del">-		const struct intel_plane_state *ps = to_intel_plane_state(plane_state);</span>
<span class="p_add">+	for_each_intel_plane_on_crtc(dev, intel_crtc, intel_plane) {</span>
<span class="p_add">+		struct intel_plane_state *ps;</span>
 
<span class="p_del">-		if (plane-&gt;type == DRM_PLANE_TYPE_PRIMARY)</span>
<span class="p_add">+		ps = intel_atomic_get_existing_plane_state(state,</span>
<span class="p_add">+							   intel_plane);</span>
<span class="p_add">+		if (!ps)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (intel_plane-&gt;base.type == DRM_PLANE_TYPE_PRIMARY)</span>
 			pristate = ps;
<span class="p_del">-		else if (plane-&gt;type == DRM_PLANE_TYPE_OVERLAY)</span>
<span class="p_add">+		else if (intel_plane-&gt;base.type == DRM_PLANE_TYPE_OVERLAY)</span>
 			sprstate = ps;
<span class="p_del">-		else if (plane-&gt;type == DRM_PLANE_TYPE_CURSOR)</span>
<span class="p_add">+		else if (intel_plane-&gt;base.type == DRM_PLANE_TYPE_CURSOR)</span>
 			curstate = ps;
 	}
 
<span class="p_chunk">@@ -2381,9 +2384,11 @@</span> <span class="p_context"> static int ilk_compute_pipe_wm(struct intel_crtc_state *cstate)</span>
 	if (pipe_wm-&gt;sprites_scaled)
 		usable_level = 0;
 
<span class="p_del">-	memset(&amp;pipe_wm-&gt;wm, 0, sizeof(pipe_wm-&gt;wm));</span>
 	ilk_compute_wm_level(dev_priv, intel_crtc, 0, cstate,
<span class="p_del">-			     pristate, sprstate, curstate, &amp;pipe_wm-&gt;wm[0]);</span>
<span class="p_add">+			     pristate, sprstate, curstate, &amp;pipe_wm-&gt;raw_wm[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;pipe_wm-&gt;wm, 0, sizeof(pipe_wm-&gt;wm));</span>
<span class="p_add">+	pipe_wm-&gt;wm[0] = pipe_wm-&gt;raw_wm[0];</span>
 
 	if (IS_HASWELL(dev) || IS_BROADWELL(dev))
 		pipe_wm-&gt;linetime = hsw_compute_linetime_wm(cstate);
<span class="p_chunk">@@ -2393,8 +2398,8 @@</span> <span class="p_context"> static int ilk_compute_pipe_wm(struct intel_crtc_state *cstate)</span>
 
 	ilk_compute_wm_reg_maximums(dev, 1, &amp;max);
 
<span class="p_del">-	for (level = 1; level &lt;= usable_level; level++) {</span>
<span class="p_del">-		struct intel_wm_level *wm = &amp;pipe_wm-&gt;wm[level];</span>
<span class="p_add">+	for (level = 1; level &lt;= max_level; level++) {</span>
<span class="p_add">+		struct intel_wm_level *wm = &amp;pipe_wm-&gt;raw_wm[level];</span>
 
 		ilk_compute_wm_level(dev_priv, intel_crtc, level, cstate,
 				     pristate, sprstate, curstate, wm);
<span class="p_chunk">@@ -2404,10 +2409,13 @@</span> <span class="p_context"> static int ilk_compute_pipe_wm(struct intel_crtc_state *cstate)</span>
 		 * register maximums since such watermarks are
 		 * always invalid.
 		 */
<span class="p_del">-		if (!ilk_validate_wm_level(level, &amp;max, wm)) {</span>
<span class="p_del">-			memset(wm, 0, sizeof(*wm));</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (level &gt; usable_level)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ilk_validate_wm_level(level, &amp;max, wm))</span>
<span class="p_add">+			pipe_wm-&gt;wm[level] = *wm;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			usable_level = level;</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/mediatek/mtk_drm_drv.c b/drivers/gpu/drm/mediatek/mtk_drm_drv.c</span>
<span class="p_header">index cf83f6507ec8..48dfc163233e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/mediatek/mtk_drm_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/mediatek/mtk_drm_drv.c</span>
<span class="p_chunk">@@ -321,7 +321,8 @@</span> <span class="p_context"> static void mtk_drm_unbind(struct device *dev)</span>
 {
 	struct mtk_drm_private *private = dev_get_drvdata(dev);
 
<span class="p_del">-	drm_put_dev(private-&gt;drm);</span>
<span class="p_add">+	drm_dev_unregister(private-&gt;drm);</span>
<span class="p_add">+	drm_dev_unref(private-&gt;drm);</span>
 	private-&gt;drm = NULL;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/sun4i/sun4i_backend.c b/drivers/gpu/drm/sun4i/sun4i_backend.c</span>
<span class="p_header">index 6e6c59a661b6..223944a3ba18 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/sun4i/sun4i_backend.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/sun4i/sun4i_backend.c</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> int sun4i_backend_update_layer_formats(struct sun4i_backend *backend,</span>
 	ret = sun4i_backend_drm_format_to_layer(plane, fb-&gt;pixel_format, &amp;val);
 	if (ret) {
 		DRM_DEBUG_DRIVER(&quot;Invalid format\n&quot;);
<span class="p_del">-		return val;</span>
<span class="p_add">+		return ret;</span>
 	}
 
 	regmap_update_bits(backend-&gt;regs, SUN4I_BACKEND_ATTCTL_REG1(layer),
<span class="p_header">diff --git a/drivers/iio/light/cm3232.c b/drivers/iio/light/cm3232.c</span>
<span class="p_header">index fe89b6823217..263e97235ea0 100644</span>
<span class="p_header">--- a/drivers/iio/light/cm3232.c</span>
<span class="p_header">+++ b/drivers/iio/light/cm3232.c</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> static int cm3232_reg_init(struct cm3232_chip *chip)</span>
 	if (ret &lt; 0)
 		dev_err(&amp;chip-&gt;client-&gt;dev, &quot;Error writing reg_cmd\n&quot;);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 1eee8f7e75ca..84f91858b5e6 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -648,12 +648,19 @@</span> <span class="p_context"> static void srp_path_rec_completion(int status,</span>
 static int srp_lookup_path(struct srp_rdma_ch *ch)
 {
 	struct srp_target_port *target = ch-&gt;target;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENODEV;</span>
 
 	ch-&gt;path.numb_path = 1;
 
 	init_completion(&amp;ch-&gt;done);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid that the SCSI host can be removed by srp_remove_target()</span>
<span class="p_add">+	 * before srp_path_rec_completion() is called.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!scsi_host_get(target-&gt;scsi_host))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	ch-&gt;path_query_id = ib_sa_path_rec_get(&amp;srp_sa_client,
 					       target-&gt;srp_host-&gt;srp_dev-&gt;dev,
 					       target-&gt;srp_host-&gt;port,
<span class="p_chunk">@@ -667,18 +674,24 @@</span> <span class="p_context"> static int srp_lookup_path(struct srp_rdma_ch *ch)</span>
 					       GFP_KERNEL,
 					       srp_path_rec_completion,
 					       ch, &amp;ch-&gt;path_query);
<span class="p_del">-	if (ch-&gt;path_query_id &lt; 0)</span>
<span class="p_del">-		return ch-&gt;path_query_id;</span>
<span class="p_add">+	ret = ch-&gt;path_query_id;</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto put;</span>
 
 	ret = wait_for_completion_interruptible(&amp;ch-&gt;done);
 	if (ret &lt; 0)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto put;</span>
 
<span class="p_del">-	if (ch-&gt;status &lt; 0)</span>
<span class="p_add">+	ret = ch-&gt;status;</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		shost_printk(KERN_WARNING, target-&gt;scsi_host,
 			     PFX &quot;Path record query failed\n&quot;);
 
<span class="p_del">-	return ch-&gt;status;</span>
<span class="p_add">+put:</span>
<span class="p_add">+	scsi_host_put(target-&gt;scsi_host);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int srp_send_req(struct srp_rdma_ch *ch, bool multich)
<span class="p_header">diff --git a/drivers/infiniband/ulp/srpt/ib_srpt.c b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">index 0b1f69ed2e92..b9748970df4a 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srpt/ib_srpt.c</span>
<span class="p_chunk">@@ -2750,7 +2750,7 @@</span> <span class="p_context"> static int srpt_parse_i_port_id(u8 i_port_id[16], const char *name)</span>
 {
 	const char *p;
 	unsigned len, count, leading_zero_bytes;
<span class="p_del">-	int ret, rc;</span>
<span class="p_add">+	int ret;</span>
 
 	p = name;
 	if (strncasecmp(p, &quot;0x&quot;, 2) == 0)
<span class="p_chunk">@@ -2762,10 +2762,9 @@</span> <span class="p_context"> static int srpt_parse_i_port_id(u8 i_port_id[16], const char *name)</span>
 	count = min(len / 2, 16U);
 	leading_zero_bytes = 16 - count;
 	memset(i_port_id, 0, leading_zero_bytes);
<span class="p_del">-	rc = hex2bin(i_port_id + leading_zero_bytes, p, count);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		pr_debug(&quot;hex2bin failed for srpt_parse_i_port_id: %d\n&quot;, rc);</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+	ret = hex2bin(i_port_id + leading_zero_bytes, p, count);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		pr_debug(&quot;hex2bin failed for srpt_parse_i_port_id: %d\n&quot;, ret);</span>
 out:
 	return ret;
 }
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">index 24d388d74011..a37576a1798d 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_chunk">@@ -1022,18 +1022,18 @@</span> <span class="p_context"> static void __init gic_populate_ppi_partitions(struct device_node *gic_node)</span>
 	int nr_parts;
 	struct partition_affinity *parts;
 
<span class="p_del">-	parts_node = of_find_node_by_name(gic_node, &quot;ppi-partitions&quot;);</span>
<span class="p_add">+	parts_node = of_get_child_by_name(gic_node, &quot;ppi-partitions&quot;);</span>
 	if (!parts_node)
 		return;
 
 	nr_parts = of_get_child_count(parts_node);
 
 	if (!nr_parts)
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out_put_node;</span>
 
 	parts = kzalloc(sizeof(*parts) * nr_parts, GFP_KERNEL);
 	if (WARN_ON(!parts))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out_put_node;</span>
 
 	for_each_child_of_node(parts_node, child_part) {
 		struct partition_affinity *part;
<span class="p_chunk">@@ -1100,6 +1100,9 @@</span> <span class="p_context"> static void __init gic_populate_ppi_partitions(struct device_node *gic_node)</span>
 
 		gic_data.ppi_descs[i] = desc;
 	}
<span class="p_add">+</span>
<span class="p_add">+out_put_node:</span>
<span class="p_add">+	of_node_put(parts_node);</span>
 }
 
 static void __init gic_of_setup_kvm_info(struct device_node *node)
<span class="p_header">diff --git a/drivers/md/bcache/alloc.c b/drivers/md/bcache/alloc.c</span>
<span class="p_header">index ca4abe1ccd8d..3fba31cea66e 100644</span>
<span class="p_header">--- a/drivers/md/bcache/alloc.c</span>
<span class="p_header">+++ b/drivers/md/bcache/alloc.c</span>
<span class="p_chunk">@@ -404,7 +404,8 @@</span> <span class="p_context"> long bch_bucket_alloc(struct cache *ca, unsigned reserve, bool wait)</span>
 
 	finish_wait(&amp;ca-&gt;set-&gt;bucket_wait, &amp;w);
 out:
<span class="p_del">-	wake_up_process(ca-&gt;alloc_thread);</span>
<span class="p_add">+	if (ca-&gt;alloc_thread)</span>
<span class="p_add">+		wake_up_process(ca-&gt;alloc_thread);</span>
 
 	trace_bcache_alloc(ca, reserve);
 
<span class="p_header">diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c</span>
<span class="p_header">index 8bf9667ff46b..7643f72adb1c 100644</span>
<span class="p_header">--- a/drivers/md/dm-bufio.c</span>
<span class="p_header">+++ b/drivers/md/dm-bufio.c</span>
<span class="p_chunk">@@ -937,7 +937,8 @@</span> <span class="p_context"> static void __get_memory_limit(struct dm_bufio_client *c,</span>
 		buffers = c-&gt;minimum_buffers;
 
 	*limit_buffers = buffers;
<span class="p_del">-	*threshold_buffers = buffers * DM_BUFIO_WRITEBACK_PERCENT / 100;</span>
<span class="p_add">+	*threshold_buffers = mult_frac(buffers,</span>
<span class="p_add">+				       DM_BUFIO_WRITEBACK_PERCENT, 100);</span>
 }
 
 /*
<span class="p_chunk">@@ -1856,19 +1857,15 @@</span> <span class="p_context"> static int __init dm_bufio_init(void)</span>
 	memset(&amp;dm_bufio_caches, 0, sizeof dm_bufio_caches);
 	memset(&amp;dm_bufio_cache_names, 0, sizeof dm_bufio_cache_names);
 
<span class="p_del">-	mem = (__u64)((totalram_pages - totalhigh_pages) *</span>
<span class="p_del">-		      DM_BUFIO_MEMORY_PERCENT / 100) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	mem = (__u64)mult_frac(totalram_pages - totalhigh_pages,</span>
<span class="p_add">+			       DM_BUFIO_MEMORY_PERCENT, 100) &lt;&lt; PAGE_SHIFT;</span>
 
 	if (mem &gt; ULONG_MAX)
 		mem = ULONG_MAX;
 
 #ifdef CONFIG_MMU
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Get the size of vmalloc space the same way as VMALLOC_TOTAL</span>
<span class="p_del">-	 * in fs/proc/internal.h</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mem &gt; (VMALLOC_END - VMALLOC_START) * DM_BUFIO_VMALLOC_PERCENT / 100)</span>
<span class="p_del">-		mem = (VMALLOC_END - VMALLOC_START) * DM_BUFIO_VMALLOC_PERCENT / 100;</span>
<span class="p_add">+	if (mem &gt; mult_frac(VMALLOC_TOTAL, DM_BUFIO_VMALLOC_PERCENT, 100))</span>
<span class="p_add">+		mem = mult_frac(VMALLOC_TOTAL, DM_BUFIO_VMALLOC_PERCENT, 100);</span>
 #endif
 
 	dm_bufio_default_cache_size = mem;
<span class="p_header">diff --git a/drivers/md/dm-core.h b/drivers/md/dm-core.h</span>
<span class="p_header">index 40ceba1fe8be..1609d4971104 100644</span>
<span class="p_header">--- a/drivers/md/dm-core.h</span>
<span class="p_header">+++ b/drivers/md/dm-core.h</span>
<span class="p_chunk">@@ -29,7 +29,6 @@</span> <span class="p_context"> struct dm_kobject_holder {</span>
  * DM targets must _not_ deference a mapped_device to directly access its members!
  */
 struct mapped_device {
<span class="p_del">-	struct srcu_struct io_barrier;</span>
 	struct mutex suspend_lock;
 
 	/*
<span class="p_chunk">@@ -127,6 +126,8 @@</span> <span class="p_context"> struct mapped_device {</span>
 	struct blk_mq_tag_set *tag_set;
 	bool use_blk_mq:1;
 	bool init_tio_pdu:1;
<span class="p_add">+</span>
<span class="p_add">+	struct srcu_struct io_barrier;</span>
 };
 
 void dm_init_md_queue(struct mapped_device *md);
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index e66f4040d84b..c5522551122f 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/wait.h&gt;
 #include &lt;linux/pr.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
 
 #define DM_MSG_PREFIX &quot;core&quot;
 
<span class="p_chunk">@@ -1511,7 +1512,7 @@</span> <span class="p_context"> static struct mapped_device *alloc_dev(int minor)</span>
 	struct mapped_device *md;
 	void *old_md;
 
<span class="p_del">-	md = kzalloc_node(sizeof(*md), GFP_KERNEL, numa_node_id);</span>
<span class="p_add">+	md = vzalloc_node(sizeof(*md), numa_node_id);</span>
 	if (!md) {
 		DMWARN(&quot;unable to allocate device, out of memory.&quot;);
 		return NULL;
<span class="p_chunk">@@ -1605,7 +1606,7 @@</span> <span class="p_context"> static struct mapped_device *alloc_dev(int minor)</span>
 bad_minor:
 	module_put(THIS_MODULE);
 bad_module_get:
<span class="p_del">-	kfree(md);</span>
<span class="p_add">+	kvfree(md);</span>
 	return NULL;
 }
 
<span class="p_chunk">@@ -1624,7 +1625,7 @@</span> <span class="p_context"> static void free_dev(struct mapped_device *md)</span>
 	free_minor(minor);
 
 	module_put(THIS_MODULE);
<span class="p_del">-	kfree(md);</span>
<span class="p_add">+	kvfree(md);</span>
 }
 
 static void __bind_mempools(struct mapped_device *md, struct dm_table *t)
<span class="p_chunk">@@ -2514,11 +2515,15 @@</span> <span class="p_context"> struct mapped_device *dm_get_from_kobject(struct kobject *kobj)</span>
 
 	md = container_of(kobj, struct mapped_device, kobj_holder.kobj);
 
<span class="p_del">-	if (test_bit(DMF_FREEING, &amp;md-&gt;flags) ||</span>
<span class="p_del">-	    dm_deleting_md(md))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_add">+	spin_lock(&amp;_minor_lock);</span>
<span class="p_add">+	if (test_bit(DMF_FREEING, &amp;md-&gt;flags) || dm_deleting_md(md)) {</span>
<span class="p_add">+		md = NULL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	dm_get(md);
<span class="p_add">+out:</span>
<span class="p_add">+	spin_unlock(&amp;_minor_lock);</span>
<span class="p_add">+</span>
 	return md;
 }
 
<span class="p_header">diff --git a/drivers/media/rc/ir-lirc-codec.c b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">index b49f80cb49c9..d9a5710532f4 100644</span>
<span class="p_header">--- a/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">+++ b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_chunk">@@ -286,11 +286,14 @@</span> <span class="p_context"> static long ir_lirc_ioctl(struct file *filep, unsigned int cmd,</span>
 		if (!dev-&gt;max_timeout)
 			return -ENOSYS;
 
<span class="p_add">+		/* Check for multiply overflow */</span>
<span class="p_add">+		if (val &gt; U32_MAX / 1000)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		tmp = val * 1000;
 
<span class="p_del">-		if (tmp &lt; dev-&gt;min_timeout ||</span>
<span class="p_del">-		    tmp &gt; dev-&gt;max_timeout)</span>
<span class="p_del">-				return -EINVAL;</span>
<span class="p_add">+		if (tmp &lt; dev-&gt;min_timeout || tmp &gt; dev-&gt;max_timeout)</span>
<span class="p_add">+			return -EINVAL;</span>
 
 		if (dev-&gt;s_timeout)
 			ret = dev-&gt;s_timeout(dev, tmp);
<span class="p_header">diff --git a/drivers/media/usb/as102/as102_fw.c b/drivers/media/usb/as102/as102_fw.c</span>
<span class="p_header">index 5a28ce3a1d49..38dbc128340d 100644</span>
<span class="p_header">--- a/drivers/media/usb/as102/as102_fw.c</span>
<span class="p_header">+++ b/drivers/media/usb/as102/as102_fw.c</span>
<span class="p_chunk">@@ -101,18 +101,23 @@</span> <span class="p_context"> static int as102_firmware_upload(struct as10x_bus_adapter_t *bus_adap,</span>
 				 unsigned char *cmd,
 				 const struct firmware *firmware) {
 
<span class="p_del">-	struct as10x_fw_pkt_t fw_pkt;</span>
<span class="p_add">+	struct as10x_fw_pkt_t *fw_pkt;</span>
 	int total_read_bytes = 0, errno = 0;
 	unsigned char addr_has_changed = 0;
 
<span class="p_add">+	fw_pkt = kmalloc(sizeof(*fw_pkt), GFP_KERNEL);</span>
<span class="p_add">+	if (!fw_pkt)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 	for (total_read_bytes = 0; total_read_bytes &lt; firmware-&gt;size; ) {
 		int read_bytes = 0, data_len = 0;
 
 		/* parse intel hex line */
 		read_bytes = parse_hex_line(
 				(u8 *) (firmware-&gt;data + total_read_bytes),
<span class="p_del">-				fw_pkt.raw.address,</span>
<span class="p_del">-				fw_pkt.raw.data,</span>
<span class="p_add">+				fw_pkt-&gt;raw.address,</span>
<span class="p_add">+				fw_pkt-&gt;raw.data,</span>
 				&amp;data_len,
 				&amp;addr_has_changed);
 
<span class="p_chunk">@@ -122,28 +127,28 @@</span> <span class="p_context"> static int as102_firmware_upload(struct as10x_bus_adapter_t *bus_adap,</span>
 		/* detect the end of file */
 		total_read_bytes += read_bytes;
 		if (total_read_bytes == firmware-&gt;size) {
<span class="p_del">-			fw_pkt.u.request[0] = 0x00;</span>
<span class="p_del">-			fw_pkt.u.request[1] = 0x03;</span>
<span class="p_add">+			fw_pkt-&gt;u.request[0] = 0x00;</span>
<span class="p_add">+			fw_pkt-&gt;u.request[1] = 0x03;</span>
 
 			/* send EOF command */
 			errno = bus_adap-&gt;ops-&gt;upload_fw_pkt(bus_adap,
 							     (uint8_t *)
<span class="p_del">-							     &amp;fw_pkt, 2, 0);</span>
<span class="p_add">+							     fw_pkt, 2, 0);</span>
 			if (errno &lt; 0)
 				goto error;
 		} else {
 			if (!addr_has_changed) {
 				/* prepare command to send */
<span class="p_del">-				fw_pkt.u.request[0] = 0x00;</span>
<span class="p_del">-				fw_pkt.u.request[1] = 0x01;</span>
<span class="p_add">+				fw_pkt-&gt;u.request[0] = 0x00;</span>
<span class="p_add">+				fw_pkt-&gt;u.request[1] = 0x01;</span>
 
<span class="p_del">-				data_len += sizeof(fw_pkt.u.request);</span>
<span class="p_del">-				data_len += sizeof(fw_pkt.raw.address);</span>
<span class="p_add">+				data_len += sizeof(fw_pkt-&gt;u.request);</span>
<span class="p_add">+				data_len += sizeof(fw_pkt-&gt;raw.address);</span>
 
 				/* send cmd to device */
 				errno = bus_adap-&gt;ops-&gt;upload_fw_pkt(bus_adap,
 								     (uint8_t *)
<span class="p_del">-								     &amp;fw_pkt,</span>
<span class="p_add">+								     fw_pkt,</span>
 								     data_len,
 								     0);
 				if (errno &lt; 0)
<span class="p_chunk">@@ -152,6 +157,7 @@</span> <span class="p_context"> static int as102_firmware_upload(struct as10x_bus_adapter_t *bus_adap,</span>
 		}
 	}
 error:
<span class="p_add">+	kfree(fw_pkt);</span>
 	return (errno == 0) ? total_read_bytes : errno;
 }
 
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-cards.c b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">index be9e3335dcb7..921cf1edb3b1 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_chunk">@@ -1622,7 +1622,7 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 	nr = dev-&gt;devno;
 
 	assoc_desc = udev-&gt;actconfig-&gt;intf_assoc[0];
<span class="p_del">-	if (assoc_desc-&gt;bFirstInterface != ifnum) {</span>
<span class="p_add">+	if (!assoc_desc || assoc_desc-&gt;bFirstInterface != ifnum) {</span>
 		dev_err(d, &quot;Not found matching IAD interface\n&quot;);
 		retval = -ENODEV;
 		goto err_if;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c</span>
<span class="p_header">index adc2147fcff7..bd6884223a0d 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-ctrls.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-ctrls.c</span>
<span class="p_chunk">@@ -1219,6 +1219,16 @@</span> <span class="p_context"> void v4l2_ctrl_fill(u32 id, const char **name, enum v4l2_ctrl_type *type,</span>
 }
 EXPORT_SYMBOL(v4l2_ctrl_fill);
 
<span class="p_add">+static u32 user_flags(const struct v4l2_ctrl *ctrl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 flags = ctrl-&gt;flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ctrl-&gt;is_ptr)</span>
<span class="p_add">+		flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;</span>
<span class="p_add">+</span>
<span class="p_add">+	return flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void fill_event(struct v4l2_event *ev, struct v4l2_ctrl *ctrl, u32 changes)
 {
 	memset(ev-&gt;reserved, 0, sizeof(ev-&gt;reserved));
<span class="p_chunk">@@ -1226,7 +1236,7 @@</span> <span class="p_context"> static void fill_event(struct v4l2_event *ev, struct v4l2_ctrl *ctrl, u32 change</span>
 	ev-&gt;id = ctrl-&gt;id;
 	ev-&gt;u.ctrl.changes = changes;
 	ev-&gt;u.ctrl.type = ctrl-&gt;type;
<span class="p_del">-	ev-&gt;u.ctrl.flags = ctrl-&gt;flags;</span>
<span class="p_add">+	ev-&gt;u.ctrl.flags = user_flags(ctrl);</span>
 	if (ctrl-&gt;is_ptr)
 		ev-&gt;u.ctrl.value64 = 0;
 	else
<span class="p_chunk">@@ -2550,10 +2560,8 @@</span> <span class="p_context"> int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctr</span>
 	else
 		qc-&gt;id = ctrl-&gt;id;
 	strlcpy(qc-&gt;name, ctrl-&gt;name, sizeof(qc-&gt;name));
<span class="p_del">-	qc-&gt;flags = ctrl-&gt;flags;</span>
<span class="p_add">+	qc-&gt;flags = user_flags(ctrl);</span>
 	qc-&gt;type = ctrl-&gt;type;
<span class="p_del">-	if (ctrl-&gt;is_ptr)</span>
<span class="p_del">-		qc-&gt;flags |= V4L2_CTRL_FLAG_HAS_PAYLOAD;</span>
 	qc-&gt;elem_size = ctrl-&gt;elem_size;
 	qc-&gt;elems = ctrl-&gt;elems;
 	qc-&gt;nr_of_dims = ctrl-&gt;nr_of_dims;
<span class="p_header">diff --git a/drivers/mtd/nand/mtk_ecc.c b/drivers/mtd/nand/mtk_ecc.c</span>
<span class="p_header">index dbf256217b3e..ada2d88fd4c7 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/mtk_ecc.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/mtk_ecc.c</span>
<span class="p_chunk">@@ -116,6 +116,11 @@</span> <span class="p_context"> static irqreturn_t mtk_ecc_irq(int irq, void *id)</span>
 		op = ECC_DECODE;
 		dec = readw(ecc-&gt;regs + ECC_DECDONE);
 		if (dec &amp; ecc-&gt;sectors) {
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Clear decode IRQ status once again to ensure that</span>
<span class="p_add">+			 * there will be no extra IRQ.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			readw(ecc-&gt;regs + ECC_DECIRQ_STA);</span>
 			ecc-&gt;sectors = 0;
 			complete(&amp;ecc-&gt;done);
 		} else {
<span class="p_chunk">@@ -131,8 +136,6 @@</span> <span class="p_context"> static irqreturn_t mtk_ecc_irq(int irq, void *id)</span>
 		}
 	}
 
<span class="p_del">-	writel(0, ecc-&gt;regs + ECC_IRQ_REG(op));</span>
<span class="p_del">-</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_chunk">@@ -342,6 +345,12 @@</span> <span class="p_context"> void mtk_ecc_disable(struct mtk_ecc *ecc)</span>
 
 	/* disable it */
 	mtk_ecc_wait_idle(ecc, op);
<span class="p_add">+	if (op == ECC_DECODE)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Clear decode IRQ status in case there is a timeout to wait</span>
<span class="p_add">+		 * decode IRQ.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		readw(ecc-&gt;regs + ECC_DECIRQ_STA);</span>
 	writew(0, ecc-&gt;regs + ECC_IRQ_REG(op));
 	writew(ECC_OP_DISABLE, ecc-&gt;regs + ECC_CTL_REG(op));
 
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 31a6ee307d80..a77cfd74a92e 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2935,15 +2935,18 @@</span> <span class="p_context"> static int panic_nand_write(struct mtd_info *mtd, loff_t to, size_t len,</span>
 			    size_t *retlen, const uint8_t *buf)
 {
 	struct nand_chip *chip = mtd_to_nand(mtd);
<span class="p_add">+	int chipnr = (int)(to &gt;&gt; chip-&gt;chip_shift);</span>
 	struct mtd_oob_ops ops;
 	int ret;
 
<span class="p_del">-	/* Wait for the device to get ready */</span>
<span class="p_del">-	panic_nand_wait(mtd, chip, 400);</span>
<span class="p_del">-</span>
 	/* Grab the device */
 	panic_nand_get_device(chip, mtd, FL_WRITING);
 
<span class="p_add">+	chip-&gt;select_chip(mtd, chipnr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for the device to get ready */</span>
<span class="p_add">+	panic_nand_wait(mtd, chip, 400);</span>
<span class="p_add">+</span>
 	memset(&amp;ops, 0, sizeof(ops));
 	ops.len = len;
 	ops.datbuf = (uint8_t *)buf;
<span class="p_header">diff --git a/drivers/mtd/nand/omap2.c b/drivers/mtd/nand/omap2.c</span>
<span class="p_header">index c178cb0dd219..f3a516b3f108 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/omap2.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/omap2.c</span>
<span class="p_chunk">@@ -1133,129 +1133,172 @@</span> <span class="p_context"> static u8  bch8_polynomial[] = {0xef, 0x51, 0x2e, 0x09, 0xed, 0x93, 0x9a, 0xc2,</span>
 				0x97, 0x79, 0xe5, 0x24, 0xb5};
 
 /**
<span class="p_del">- * omap_calculate_ecc_bch - Generate bytes of ECC bytes</span>
<span class="p_add">+ * _omap_calculate_ecc_bch - Generate ECC bytes for one sector</span>
  * @mtd:	MTD device structure
  * @dat:	The pointer to data on which ecc is computed
  * @ecc_code:	The ecc_code buffer
<span class="p_add">+ * @i:		The sector number (for a multi sector page)</span>
  *
<span class="p_del">- * Support calculating of BCH4/8 ecc vectors for the page</span>
<span class="p_add">+ * Support calculating of BCH4/8/16 ECC vectors for one sector</span>
<span class="p_add">+ * within a page. Sector number is in @i.</span>
  */
<span class="p_del">-static int __maybe_unused omap_calculate_ecc_bch(struct mtd_info *mtd,</span>
<span class="p_del">-					const u_char *dat, u_char *ecc_calc)</span>
<span class="p_add">+static int _omap_calculate_ecc_bch(struct mtd_info *mtd,</span>
<span class="p_add">+				   const u_char *dat, u_char *ecc_calc, int i)</span>
 {
 	struct omap_nand_info *info = mtd_to_omap(mtd);
 	int eccbytes	= info-&gt;nand.ecc.bytes;
 	struct gpmc_nand_regs	*gpmc_regs = &amp;info-&gt;reg;
 	u8 *ecc_code;
<span class="p_del">-	unsigned long nsectors, bch_val1, bch_val2, bch_val3, bch_val4;</span>
<span class="p_add">+	unsigned long bch_val1, bch_val2, bch_val3, bch_val4;</span>
 	u32 val;
<span class="p_del">-	int i, j;</span>
<span class="p_add">+	int j;</span>
<span class="p_add">+</span>
<span class="p_add">+	ecc_code = ecc_calc;</span>
<span class="p_add">+	switch (info-&gt;ecc_opt) {</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_add">+		bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_add">+		bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_add">+		bch_val3 = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_add">+		bch_val4 = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_add">+		*ecc_code++ = (bch_val4 &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val3 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val3 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val3 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = (bch_val3 &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = (bch_val2 &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = (bch_val1 &amp; 0xFF);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_add">+		bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_add">+		bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val2 &amp; 0xF) &lt;&lt; 4) |</span>
<span class="p_add">+			((bch_val1 &gt;&gt; 28) &amp; 0xF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 20) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_add">+		*ecc_code++ = ((bch_val1 &amp; 0xF) &lt;&lt; 4);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result6[i]);</span>
<span class="p_add">+		ecc_code[0]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[1]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result5[i]);</span>
<span class="p_add">+		ecc_code[2]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[3]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[4]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[5]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result4[i]);</span>
<span class="p_add">+		ecc_code[6]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[7]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[8]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[9]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_add">+		ecc_code[10] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[11] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[12] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[13] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_add">+		ecc_code[14] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[15] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[16] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[17] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_add">+		ecc_code[18] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[19] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[20] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[21] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		val = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_add">+		ecc_code[22] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[23] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[24] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_add">+		ecc_code[25] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ECC scheme specific syndrome customizations */</span>
<span class="p_add">+	switch (info-&gt;ecc_opt) {</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+		/* Add constant polynomial to remainder, so that</span>
<span class="p_add">+		 * ECC of blank pages results in 0x0 on reading back</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_add">+			ecc_calc[j] ^= bch4_polynomial[j];</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_add">+		/* Set  8th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_add">+		ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_add">+		/* Add constant polynomial to remainder, so that</span>
<span class="p_add">+		 * ECC of blank pages results in 0x0 on reading back</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_add">+			ecc_calc[j] ^= bch8_polynomial[j];</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_add">+		/* Set 14th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_add">+		ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * omap_calculate_ecc_bch_sw - ECC generator for sector for SW based correction</span>
<span class="p_add">+ * @mtd:	MTD device structure</span>
<span class="p_add">+ * @dat:	The pointer to data on which ecc is computed</span>
<span class="p_add">+ * @ecc_code:	The ecc_code buffer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Support calculating of BCH4/8/16 ECC vectors for one sector. This is used</span>
<span class="p_add">+ * when SW based correction is required as ECC is required for one sector</span>
<span class="p_add">+ * at a time.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int omap_calculate_ecc_bch_sw(struct mtd_info *mtd,</span>
<span class="p_add">+				     const u_char *dat, u_char *ecc_calc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return _omap_calculate_ecc_bch(mtd, dat, ecc_calc, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * omap_calculate_ecc_bch_multi - Generate ECC for multiple sectors</span>
<span class="p_add">+ * @mtd:	MTD device structure</span>
<span class="p_add">+ * @dat:	The pointer to data on which ecc is computed</span>
<span class="p_add">+ * @ecc_code:	The ecc_code buffer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Support calculating of BCH4/8/16 ecc vectors for the entire page in one go.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int omap_calculate_ecc_bch_multi(struct mtd_info *mtd,</span>
<span class="p_add">+					const u_char *dat, u_char *ecc_calc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct omap_nand_info *info = mtd_to_omap(mtd);</span>
<span class="p_add">+	int eccbytes = info-&gt;nand.ecc.bytes;</span>
<span class="p_add">+	unsigned long nsectors;</span>
<span class="p_add">+	int i, ret;</span>
 
 	nsectors = ((readl(info-&gt;reg.gpmc_ecc_config) &gt;&gt; 4) &amp; 0x7) + 1;
 	for (i = 0; i &lt; nsectors; i++) {
<span class="p_del">-		ecc_code = ecc_calc;</span>
<span class="p_del">-		switch (info-&gt;ecc_opt) {</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_del">-			bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_del">-			bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_del">-			bch_val3 = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_del">-			bch_val4 = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_del">-			*ecc_code++ = (bch_val4 &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val3 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val3 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val3 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = (bch_val3 &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = (bch_val2 &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 8) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = (bch_val1 &amp; 0xFF);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_del">-			bch_val1 = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_del">-			bch_val2 = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val2 &amp; 0xF) &lt;&lt; 4) |</span>
<span class="p_del">-				((bch_val1 &gt;&gt; 28) &amp; 0xF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 20) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 12) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &gt;&gt; 4) &amp; 0xFF);</span>
<span class="p_del">-			*ecc_code++ = ((bch_val1 &amp; 0xF) &lt;&lt; 4);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result6[i]);</span>
<span class="p_del">-			ecc_code[0]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[1]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result5[i]);</span>
<span class="p_del">-			ecc_code[2]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[3]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[4]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[5]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result4[i]);</span>
<span class="p_del">-			ecc_code[6]  = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[7]  = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[8]  = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[9]  = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result3[i]);</span>
<span class="p_del">-			ecc_code[10] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[11] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[12] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[13] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result2[i]);</span>
<span class="p_del">-			ecc_code[14] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[15] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[16] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[17] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result1[i]);</span>
<span class="p_del">-			ecc_code[18] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[19] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[20] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[21] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			val = readl(gpmc_regs-&gt;gpmc_bch_result0[i]);</span>
<span class="p_del">-			ecc_code[22] = ((val &gt;&gt; 24) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[23] = ((val &gt;&gt; 16) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[24] = ((val &gt;&gt;  8) &amp; 0xFF);</span>
<span class="p_del">-			ecc_code[25] = ((val &gt;&gt;  0) &amp; 0xFF);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* ECC scheme specific syndrome customizations */</span>
<span class="p_del">-		switch (info-&gt;ecc_opt) {</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-			/* Add constant polynomial to remainder, so that</span>
<span class="p_del">-			 * ECC of blank pages results in 0x0 on reading back */</span>
<span class="p_del">-			for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_del">-				ecc_calc[j] ^= bch4_polynomial[j];</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH4_CODE_HW:</span>
<span class="p_del">-			/* Set  8th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_del">-			ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW_DETECTION_SW:</span>
<span class="p_del">-			/* Add constant polynomial to remainder, so that</span>
<span class="p_del">-			 * ECC of blank pages results in 0x0 on reading back */</span>
<span class="p_del">-			for (j = 0; j &lt; eccbytes; j++)</span>
<span class="p_del">-				ecc_calc[j] ^= bch8_polynomial[j];</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH8_CODE_HW:</span>
<span class="p_del">-			/* Set 14th ECC byte as 0x0 for ROM compatibility */</span>
<span class="p_del">-			ecc_calc[eccbytes - 1] = 0x0;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case OMAP_ECC_BCH16_CODE_HW:</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		ret = _omap_calculate_ecc_bch(mtd, dat, ecc_calc, i);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
 
<span class="p_del">-	ecc_calc += eccbytes;</span>
<span class="p_add">+		ecc_calc += eccbytes;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -1496,7 +1539,7 @@</span> <span class="p_context"> static int omap_write_page_bch(struct mtd_info *mtd, struct nand_chip *chip,</span>
 	chip-&gt;write_buf(mtd, buf, mtd-&gt;writesize);
 
 	/* Update ecc vector from GPMC result registers */
<span class="p_del">-	chip-&gt;ecc.calculate(mtd, buf, &amp;ecc_calc[0]);</span>
<span class="p_add">+	omap_calculate_ecc_bch_multi(mtd, buf, &amp;ecc_calc[0]);</span>
 
 	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip-&gt;oob_poi, 0,
 					 chip-&gt;ecc.total);
<span class="p_chunk">@@ -1508,6 +1551,72 @@</span> <span class="p_context"> static int omap_write_page_bch(struct mtd_info *mtd, struct nand_chip *chip,</span>
 	return 0;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * omap_write_subpage_bch - BCH hardware ECC based subpage write</span>
<span class="p_add">+ * @mtd:	mtd info structure</span>
<span class="p_add">+ * @chip:	nand chip info structure</span>
<span class="p_add">+ * @offset:	column address of subpage within the page</span>
<span class="p_add">+ * @data_len:	data length</span>
<span class="p_add">+ * @buf:	data buffer</span>
<span class="p_add">+ * @oob_required: must write chip-&gt;oob_poi to OOB</span>
<span class="p_add">+ * @page: page number to write</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * OMAP optimized subpage write method.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int omap_write_subpage_bch(struct mtd_info *mtd,</span>
<span class="p_add">+				  struct nand_chip *chip, u32 offset,</span>
<span class="p_add">+				  u32 data_len, const u8 *buf,</span>
<span class="p_add">+				  int oob_required, int page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *ecc_calc = chip-&gt;buffers-&gt;ecccalc;</span>
<span class="p_add">+	int ecc_size      = chip-&gt;ecc.size;</span>
<span class="p_add">+	int ecc_bytes     = chip-&gt;ecc.bytes;</span>
<span class="p_add">+	int ecc_steps     = chip-&gt;ecc.steps;</span>
<span class="p_add">+	u32 start_step = offset / ecc_size;</span>
<span class="p_add">+	u32 end_step   = (offset + data_len - 1) / ecc_size;</span>
<span class="p_add">+	int step, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Write entire page at one go as it would be optimal</span>
<span class="p_add">+	 * as ECC is calculated by hardware.</span>
<span class="p_add">+	 * ECC is calculated for all subpages but we choose</span>
<span class="p_add">+	 * only what we want.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable GPMC ECC engine */</span>
<span class="p_add">+	chip-&gt;ecc.hwctl(mtd, NAND_ECC_WRITE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Write data */</span>
<span class="p_add">+	chip-&gt;write_buf(mtd, buf, mtd-&gt;writesize);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (step = 0; step &lt; ecc_steps; step++) {</span>
<span class="p_add">+		/* mask ECC of un-touched subpages by padding 0xFF */</span>
<span class="p_add">+		if (step &lt; start_step || step &gt; end_step)</span>
<span class="p_add">+			memset(ecc_calc, 0xff, ecc_bytes);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ret = _omap_calculate_ecc_bch(mtd, buf, ecc_calc, step);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		buf += ecc_size;</span>
<span class="p_add">+		ecc_calc += ecc_bytes;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* copy calculated ECC for whole page to chip-&gt;buffer-&gt;oob */</span>
<span class="p_add">+	/* this include masked-value(0xFF) for unwritten subpages */</span>
<span class="p_add">+	ecc_calc = chip-&gt;buffers-&gt;ecccalc;</span>
<span class="p_add">+	ret = mtd_ooblayout_set_eccbytes(mtd, ecc_calc, chip-&gt;oob_poi, 0,</span>
<span class="p_add">+					 chip-&gt;ecc.total);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* write OOB buffer to NAND device */</span>
<span class="p_add">+	chip-&gt;write_buf(mtd, chip-&gt;oob_poi, mtd-&gt;oobsize);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * omap_read_page_bch - BCH ecc based page read function for entire page
  * @mtd:		mtd info structure
<span class="p_chunk">@@ -1544,7 +1653,7 @@</span> <span class="p_context"> static int omap_read_page_bch(struct mtd_info *mtd, struct nand_chip *chip,</span>
 		       chip-&gt;ecc.total);
 
 	/* Calculate ecc bytes */
<span class="p_del">-	chip-&gt;ecc.calculate(mtd, buf, ecc_calc);</span>
<span class="p_add">+	omap_calculate_ecc_bch_multi(mtd, buf, ecc_calc);</span>
 
 	ret = mtd_ooblayout_get_eccbytes(mtd, ecc_code, chip-&gt;oob_poi, 0,
 					 chip-&gt;ecc.total);
<span class="p_chunk">@@ -2044,7 +2153,7 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 4;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= nand_bch_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
<span class="p_add">+		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch_sw;</span>
 		mtd_set_ooblayout(mtd, &amp;omap_sw_ooblayout_ops);
 		/* Reserve one byte for the OMAP marker */
 		oobbytes_per_step		= nand_chip-&gt;ecc.bytes + 1;
<span class="p_chunk">@@ -2066,9 +2175,9 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 4;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= omap_elm_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
 		nand_chip-&gt;ecc.read_page	= omap_read_page_bch;
 		nand_chip-&gt;ecc.write_page	= omap_write_page_bch;
<span class="p_add">+		nand_chip-&gt;ecc.write_subpage	= omap_write_subpage_bch;</span>
 		mtd_set_ooblayout(mtd, &amp;omap_ooblayout_ops);
 		oobbytes_per_step		= nand_chip-&gt;ecc.bytes;
 
<span class="p_chunk">@@ -2087,7 +2196,7 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 8;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= nand_bch_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
<span class="p_add">+		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch_sw;</span>
 		mtd_set_ooblayout(mtd, &amp;omap_sw_ooblayout_ops);
 		/* Reserve one byte for the OMAP marker */
 		oobbytes_per_step		= nand_chip-&gt;ecc.bytes + 1;
<span class="p_chunk">@@ -2109,9 +2218,9 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 8;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= omap_elm_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
 		nand_chip-&gt;ecc.read_page	= omap_read_page_bch;
 		nand_chip-&gt;ecc.write_page	= omap_write_page_bch;
<span class="p_add">+		nand_chip-&gt;ecc.write_subpage	= omap_write_subpage_bch;</span>
 		mtd_set_ooblayout(mtd, &amp;omap_ooblayout_ops);
 		oobbytes_per_step		= nand_chip-&gt;ecc.bytes;
 
<span class="p_chunk">@@ -2131,9 +2240,9 @@</span> <span class="p_context"> static int omap_nand_probe(struct platform_device *pdev)</span>
 		nand_chip-&gt;ecc.strength		= 16;
 		nand_chip-&gt;ecc.hwctl		= omap_enable_hwecc_bch;
 		nand_chip-&gt;ecc.correct		= omap_elm_correct_data;
<span class="p_del">-		nand_chip-&gt;ecc.calculate	= omap_calculate_ecc_bch;</span>
 		nand_chip-&gt;ecc.read_page	= omap_read_page_bch;
 		nand_chip-&gt;ecc.write_page	= omap_write_page_bch;
<span class="p_add">+		nand_chip-&gt;ecc.write_subpage	= omap_write_subpage_bch;</span>
 		mtd_set_ooblayout(mtd, &amp;omap_ooblayout_ops);
 		oobbytes_per_step		= nand_chip-&gt;ecc.bytes;
 
<span class="p_header">diff --git a/drivers/net/ethernet/3com/typhoon.c b/drivers/net/ethernet/3com/typhoon.c</span>
<span class="p_header">index 8f8418d2ac4a..a0012c3cb4f6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/3com/typhoon.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/3com/typhoon.c</span>
<span class="p_chunk">@@ -2366,9 +2366,9 @@</span> <span class="p_context"> typhoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	 * 4) Get the hardware address.
 	 * 5) Put the card to sleep.
 	 */
<span class="p_del">-	if (typhoon_reset(ioaddr, WaitSleep) &lt; 0) {</span>
<span class="p_add">+	err = typhoon_reset(ioaddr, WaitSleep);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		err_msg = &quot;could not reset 3XP&quot;;
<span class="p_del">-		err = -EIO;</span>
 		goto error_out_dma;
 	}
 
<span class="p_chunk">@@ -2382,24 +2382,25 @@</span> <span class="p_context"> typhoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	typhoon_init_interface(tp);
 	typhoon_init_rings(tp);
 
<span class="p_del">-	if(typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST) &lt; 0) {</span>
<span class="p_add">+	err = typhoon_boot_3XP(tp, TYPHOON_STATUS_WAITING_FOR_HOST);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		err_msg = &quot;cannot boot 3XP sleep image&quot;;
<span class="p_del">-		err = -EIO;</span>
 		goto error_out_reset;
 	}
 
 	INIT_COMMAND_WITH_RESPONSE(&amp;xp_cmd, TYPHOON_CMD_READ_MAC_ADDRESS);
<span class="p_del">-	if(typhoon_issue_command(tp, 1, &amp;xp_cmd, 1, xp_resp) &lt; 0) {</span>
<span class="p_add">+	err = typhoon_issue_command(tp, 1, &amp;xp_cmd, 1, xp_resp);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		err_msg = &quot;cannot read MAC address&quot;;
<span class="p_del">-		err = -EIO;</span>
 		goto error_out_reset;
 	}
 
 	*(__be16 *)&amp;dev-&gt;dev_addr[0] = htons(le16_to_cpu(xp_resp[0].parm1));
 	*(__be32 *)&amp;dev-&gt;dev_addr[2] = htonl(le32_to_cpu(xp_resp[0].parm2));
 
<span class="p_del">-	if(!is_valid_ether_addr(dev-&gt;dev_addr)) {</span>
<span class="p_add">+	if (!is_valid_ether_addr(dev-&gt;dev_addr)) {</span>
 		err_msg = &quot;Could not obtain valid ethernet address, aborting&quot;;
<span class="p_add">+		err = -EIO;</span>
 		goto error_out_reset;
 	}
 
<span class="p_chunk">@@ -2407,7 +2408,8 @@</span> <span class="p_context"> typhoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	 * later when we print out the version reported.
 	 */
 	INIT_COMMAND_WITH_RESPONSE(&amp;xp_cmd, TYPHOON_CMD_READ_VERSIONS);
<span class="p_del">-	if(typhoon_issue_command(tp, 1, &amp;xp_cmd, 3, xp_resp) &lt; 0) {</span>
<span class="p_add">+	err = typhoon_issue_command(tp, 1, &amp;xp_cmd, 3, xp_resp);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		err_msg = &quot;Could not get Sleep Image version&quot;;
 		goto error_out_reset;
 	}
<span class="p_chunk">@@ -2424,9 +2426,9 @@</span> <span class="p_context"> typhoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	if(xp_resp[0].numDesc != 0)
 		tp-&gt;capabilities |= TYPHOON_WAKEUP_NEEDS_RESET;
 
<span class="p_del">-	if(typhoon_sleep(tp, PCI_D3hot, 0) &lt; 0) {</span>
<span class="p_add">+	err = typhoon_sleep(tp, PCI_D3hot, 0);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		err_msg = &quot;cannot put adapter to sleep&quot;;
<span class="p_del">-		err = -EIO;</span>
 		goto error_out_reset;
 	}
 
<span class="p_chunk">@@ -2449,7 +2451,8 @@</span> <span class="p_context"> typhoon_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	dev-&gt;features = dev-&gt;hw_features |
 		NETIF_F_HW_VLAN_CTAG_RX | NETIF_F_RXCSUM;
 
<span class="p_del">-	if(register_netdev(dev) &lt; 0) {</span>
<span class="p_add">+	err = register_netdev(dev);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		err_msg = &quot;unable to register netdev&quot;;
 		goto error_out_reset;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">index 333df540b375..5d2cf56aed0e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_chunk">@@ -3800,6 +3800,30 @@</span> <span class="p_context"> static int hwrm_ring_alloc_send_msg(struct bnxt *bp,</span>
 	return rc;
 }
 
<span class="p_add">+static int bnxt_hwrm_set_async_event_cr(struct bnxt *bp, int idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (BNXT_PF(bp)) {</span>
<span class="p_add">+		struct hwrm_func_cfg_input req = {0};</span>
<span class="p_add">+</span>
<span class="p_add">+		bnxt_hwrm_cmd_hdr_init(bp, &amp;req, HWRM_FUNC_CFG, -1, -1);</span>
<span class="p_add">+		req.fid = cpu_to_le16(0xffff);</span>
<span class="p_add">+		req.enables = cpu_to_le32(FUNC_CFG_REQ_ENABLES_ASYNC_EVENT_CR);</span>
<span class="p_add">+		req.async_event_cr = cpu_to_le16(idx);</span>
<span class="p_add">+		rc = hwrm_send_message(bp, &amp;req, sizeof(req), HWRM_CMD_TIMEOUT);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		struct hwrm_func_vf_cfg_input req = {0};</span>
<span class="p_add">+</span>
<span class="p_add">+		bnxt_hwrm_cmd_hdr_init(bp, &amp;req, HWRM_FUNC_VF_CFG, -1, -1);</span>
<span class="p_add">+		req.enables =</span>
<span class="p_add">+			cpu_to_le32(FUNC_VF_CFG_REQ_ENABLES_ASYNC_EVENT_CR);</span>
<span class="p_add">+		req.async_event_cr = cpu_to_le16(idx);</span>
<span class="p_add">+		rc = hwrm_send_message(bp, &amp;req, sizeof(req), HWRM_CMD_TIMEOUT);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bnxt_hwrm_ring_alloc(struct bnxt *bp)
 {
 	int i, rc = 0;
<span class="p_chunk">@@ -3816,6 +3840,12 @@</span> <span class="p_context"> static int bnxt_hwrm_ring_alloc(struct bnxt *bp)</span>
 			goto err_out;
 		BNXT_CP_DB(cpr-&gt;cp_doorbell, cpr-&gt;cp_raw_cons);
 		bp-&gt;grp_info[i].cp_fw_ring_id = ring-&gt;fw_ring_id;
<span class="p_add">+</span>
<span class="p_add">+		if (!i) {</span>
<span class="p_add">+			rc = bnxt_hwrm_set_async_event_cr(bp, ring-&gt;fw_ring_id);</span>
<span class="p_add">+			if (rc)</span>
<span class="p_add">+				netdev_warn(bp-&gt;dev, &quot;Failed to set async event completion ring.\n&quot;);</span>
<span class="p_add">+		}</span>
 	}
 
 	for (i = 0; i &lt; bp-&gt;tx_nr_rings; i++) {
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/defines.h b/drivers/net/ethernet/intel/e1000e/defines.h</span>
<span class="p_header">index 0641c0098738..afb7ebe20b24 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/defines.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/defines.h</span>
<span class="p_chunk">@@ -398,6 +398,7 @@</span> <span class="p_context"></span>
 #define E1000_ICR_LSC           0x00000004 /* Link Status Change */
 #define E1000_ICR_RXSEQ         0x00000008 /* Rx sequence error */
 #define E1000_ICR_RXDMT0        0x00000010 /* Rx desc min. threshold (0) */
<span class="p_add">+#define E1000_ICR_RXO           0x00000040 /* Receiver Overrun */</span>
 #define E1000_ICR_RXT0          0x00000080 /* Rx timer intr (ring 0) */
 #define E1000_ICR_ECCER         0x00400000 /* Uncorrectable ECC Error */
 /* If this bit asserted, the driver should claim the interrupt */
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/mac.c b/drivers/net/ethernet/intel/e1000e/mac.c</span>
<span class="p_header">index b322011ec282..f457c5703d0c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/mac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/mac.c</span>
<span class="p_chunk">@@ -410,6 +410,9 @@</span> <span class="p_context"> void e1000e_clear_hw_cntrs_base(struct e1000_hw *hw)</span>
  *  Checks to see of the link status of the hardware has changed.  If a
  *  change in link status has been detected, then we read the PHY registers
  *  to get the current speed/duplex if link exists.
<span class="p_add">+ *</span>
<span class="p_add">+ *  Returns a negative error code (-E1000_ERR_*) or 0 (link down) or 1 (link</span>
<span class="p_add">+ *  up).</span>
  **/
 s32 e1000e_check_for_copper_link(struct e1000_hw *hw)
 {
<span class="p_chunk">@@ -423,7 +426,7 @@</span> <span class="p_context"> s32 e1000e_check_for_copper_link(struct e1000_hw *hw)</span>
 	 * Change or Rx Sequence Error interrupt.
 	 */
 	if (!mac-&gt;get_link_status)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return 1;</span>
 
 	/* First we want to see if the MII Status Register reports
 	 * link.  If so, then we want to get the current speed/duplex
<span class="p_chunk">@@ -461,10 +464,12 @@</span> <span class="p_context"> s32 e1000e_check_for_copper_link(struct e1000_hw *hw)</span>
 	 * different link partner.
 	 */
 	ret_val = e1000e_config_fc_after_link_up(hw);
<span class="p_del">-	if (ret_val)</span>
<span class="p_add">+	if (ret_val) {</span>
 		e_dbg(&quot;Error configuring flow control\n&quot;);
<span class="p_add">+		return ret_val;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	return ret_val;</span>
<span class="p_add">+	return 1;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">index 7017281ba2dc..0feddf3393f9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_chunk">@@ -1905,14 +1905,30 @@</span> <span class="p_context"> static irqreturn_t e1000_msix_other(int __always_unused irq, void *data)</span>
 	struct net_device *netdev = data;
 	struct e1000_adapter *adapter = netdev_priv(netdev);
 	struct e1000_hw *hw = &amp;adapter-&gt;hw;
<span class="p_add">+	u32 icr;</span>
<span class="p_add">+	bool enable = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	icr = er32(ICR);</span>
<span class="p_add">+	if (icr &amp; E1000_ICR_RXO) {</span>
<span class="p_add">+		ew32(ICR, E1000_ICR_RXO);</span>
<span class="p_add">+		enable = false;</span>
<span class="p_add">+		/* napi poll will re-enable Other, make sure it runs */</span>
<span class="p_add">+		if (napi_schedule_prep(&amp;adapter-&gt;napi)) {</span>
<span class="p_add">+			adapter-&gt;total_rx_bytes = 0;</span>
<span class="p_add">+			adapter-&gt;total_rx_packets = 0;</span>
<span class="p_add">+			__napi_schedule(&amp;adapter-&gt;napi);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (icr &amp; E1000_ICR_LSC) {</span>
<span class="p_add">+		ew32(ICR, E1000_ICR_LSC);</span>
<span class="p_add">+		hw-&gt;mac.get_link_status = true;</span>
<span class="p_add">+		/* guard against interrupt when we&#39;re going down */</span>
<span class="p_add">+		if (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state))</span>
<span class="p_add">+			mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	hw-&gt;mac.get_link_status = true;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* guard against interrupt when we&#39;re going down */</span>
<span class="p_del">-	if (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state)) {</span>
<span class="p_del">-		mod_timer(&amp;adapter-&gt;watchdog_timer, jiffies + 1);</span>
<span class="p_add">+	if (enable &amp;&amp; !test_bit(__E1000_DOWN, &amp;adapter-&gt;state))</span>
 		ew32(IMS, E1000_IMS_OTHER);
<span class="p_del">-	}</span>
 
 	return IRQ_HANDLED;
 }
<span class="p_chunk">@@ -2683,7 +2699,8 @@</span> <span class="p_context"> static int e1000e_poll(struct napi_struct *napi, int weight)</span>
 		napi_complete_done(napi, work_done);
 		if (!test_bit(__E1000_DOWN, &amp;adapter-&gt;state)) {
 			if (adapter-&gt;msix_entries)
<span class="p_del">-				ew32(IMS, adapter-&gt;rx_ring-&gt;ims_val);</span>
<span class="p_add">+				ew32(IMS, adapter-&gt;rx_ring-&gt;ims_val |</span>
<span class="p_add">+				     E1000_IMS_OTHER);</span>
 			else
 				e1000_irq_enable(adapter);
 		}
<span class="p_chunk">@@ -4178,7 +4195,7 @@</span> <span class="p_context"> static void e1000e_trigger_lsc(struct e1000_adapter *adapter)</span>
 	struct e1000_hw *hw = &amp;adapter-&gt;hw;
 
 	if (adapter-&gt;msix_entries)
<span class="p_del">-		ew32(ICS, E1000_ICS_OTHER);</span>
<span class="p_add">+		ew32(ICS, E1000_ICS_LSC | E1000_ICS_OTHER);</span>
 	else
 		ew32(ICS, E1000_ICS_LSC);
 }
<span class="p_chunk">@@ -5056,7 +5073,7 @@</span> <span class="p_context"> static bool e1000e_has_link(struct e1000_adapter *adapter)</span>
 	case e1000_media_type_copper:
 		if (hw-&gt;mac.get_link_status) {
 			ret_val = hw-&gt;mac.ops.check_for_link(hw);
<span class="p_del">-			link_active = !hw-&gt;mac.get_link_status;</span>
<span class="p_add">+			link_active = ret_val &gt; 0;</span>
 		} else {
 			link_active = true;
 		}
<span class="p_chunk">@@ -5074,7 +5091,7 @@</span> <span class="p_context"> static bool e1000e_has_link(struct e1000_adapter *adapter)</span>
 		break;
 	}
 
<span class="p_del">-	if ((ret_val == E1000_ERR_PHY) &amp;&amp; (hw-&gt;phy.type == e1000_phy_igp_3) &amp;&amp;</span>
<span class="p_add">+	if ((ret_val == -E1000_ERR_PHY) &amp;&amp; (hw-&gt;phy.type == e1000_phy_igp_3) &amp;&amp;</span>
 	    (er32(CTRL) &amp; E1000_PHY_CTRL_GBE_DISABLE)) {
 		/* See e1000_kmrn_lock_loss_workaround_ich8lan() */
 		e_info(&quot;Gigabit has been disabled, downgrading speed\n&quot;);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/phy.c b/drivers/net/ethernet/intel/e1000e/phy.c</span>
<span class="p_header">index d78d47b41a71..86ff0969efb6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/phy.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/phy.c</span>
<span class="p_chunk">@@ -1744,6 +1744,7 @@</span> <span class="p_context"> s32 e1000e_phy_has_link_generic(struct e1000_hw *hw, u32 iterations,</span>
 	s32 ret_val = 0;
 	u16 i, phy_status;
 
<span class="p_add">+	*success = false;</span>
 	for (i = 0; i &lt; iterations; i++) {
 		/* Some PHYs require the MII_BMSR register to be read
 		 * twice due to the link bit being sticky.  No harm doing
<span class="p_chunk">@@ -1763,16 +1764,16 @@</span> <span class="p_context"> s32 e1000e_phy_has_link_generic(struct e1000_hw *hw, u32 iterations,</span>
 		ret_val = e1e_rphy(hw, MII_BMSR, &amp;phy_status);
 		if (ret_val)
 			break;
<span class="p_del">-		if (phy_status &amp; BMSR_LSTATUS)</span>
<span class="p_add">+		if (phy_status &amp; BMSR_LSTATUS) {</span>
<span class="p_add">+			*success = true;</span>
 			break;
<span class="p_add">+		}</span>
 		if (usec_interval &gt;= 1000)
 			msleep(usec_interval / 1000);
 		else
 			udelay(usec_interval);
 	}
 
<span class="p_del">-	*success = (i &lt; iterations);</span>
<span class="p_del">-</span>
 	return ret_val;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_main.c b/drivers/net/ethernet/intel/fm10k/fm10k_main.c</span>
<span class="p_header">index 5de937852436..2aae6f88dca0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/fm10k/fm10k_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/fm10k/fm10k_main.c</span>
<span class="p_chunk">@@ -1225,7 +1225,7 @@</span> <span class="p_context"> static bool fm10k_clean_tx_irq(struct fm10k_q_vector *q_vector,</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;flags &amp; FM10K_TXD_FLAG_DONE))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index 31c97e3937a4..2caafebb0295 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -3604,7 +3604,7 @@</span> <span class="p_context"> static bool i40e_clean_fdir_tx_irq(struct i40e_ring *tx_ring, int budget)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if the descriptor isn&#39;t done, no work yet to do */
 		if (!(eop_desc-&gt;cmd_type_offset_bsz &amp;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_header">index 6287bf63c43c..c5430394fac9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_chunk">@@ -679,7 +679,7 @@</span> <span class="p_context"> static bool i40e_clean_tx_irq(struct i40e_vsi *vsi,</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* we have caught up to head, no work left to do */
 		if (tx_head == tx_desc)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c</span>
<span class="p_header">index 75f2a2cdd738..c03800d1000a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40evf/i40e_txrx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40evf/i40e_txrx.c</span>
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> static bool i40e_clean_tx_irq(struct i40e_vsi *vsi,</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* we have caught up to head, no work left to do */
 		if (tx_head == tx_desc)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index c6c2562d9df3..16839600fb78 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -6660,7 +6660,7 @@</span> <span class="p_context"> static bool igb_clean_tx_irq(struct igb_q_vector *q_vector, int napi_budget)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(E1000_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igbvf/netdev.c b/drivers/net/ethernet/intel/igbvf/netdev.c</span>
<span class="p_header">index 7dff7f6239cd..5428e39fa4e5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igbvf/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igbvf/netdev.c</span>
<span class="p_chunk">@@ -810,7 +810,7 @@</span> <span class="p_context"> static bool igbvf_clean_tx_irq(struct igbvf_ring *tx_ring)</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(E1000_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">index 334eb96ecda3..a5428b6abdac 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_chunk">@@ -1171,7 +1171,7 @@</span> <span class="p_context"> static bool ixgbe_clean_tx_irq(struct ixgbe_q_vector *q_vector,</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(IXGBE_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">index cbf70fe4028a..1499ce2bf9f6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_chunk">@@ -325,7 +325,7 @@</span> <span class="p_context"> static bool ixgbevf_clean_tx_irq(struct ixgbevf_q_vector *q_vector,</span>
 			break;
 
 		/* prevent any other reads prior to eop_desc */
<span class="p_del">-		read_barrier_depends();</span>
<span class="p_add">+		smp_rmb();</span>
 
 		/* if DD is not set pending work has not been completed */
 		if (!(eop_desc-&gt;wb.status &amp; cpu_to_le32(IXGBE_TXD_STAT_DD)))
<span class="p_header">diff --git a/drivers/net/wireless/admtek/adm8211.c b/drivers/net/wireless/admtek/adm8211.c</span>
<span class="p_header">index 70ecd82d674d..098c814e22c8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/admtek/adm8211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/admtek/adm8211.c</span>
<span class="p_chunk">@@ -413,6 +413,13 @@</span> <span class="p_context"> static void adm8211_interrupt_rci(struct ieee80211_hw *dev)</span>
 						       skb_tail_pointer(newskb),
 						       RX_PKT_SIZE,
 						       PCI_DMA_FROMDEVICE);
<span class="p_add">+				if (pci_dma_mapping_error(priv-&gt;pdev,</span>
<span class="p_add">+					   priv-&gt;rx_buffers[entry].mapping)) {</span>
<span class="p_add">+					priv-&gt;rx_buffers[entry].skb = NULL;</span>
<span class="p_add">+					dev_kfree_skb(newskb);</span>
<span class="p_add">+					skb = NULL;</span>
<span class="p_add">+					/* TODO: update rx dropped stats */</span>
<span class="p_add">+				}</span>
 			} else {
 				skb = NULL;
 				/* TODO: update rx dropped stats */
<span class="p_chunk">@@ -1450,6 +1457,12 @@</span> <span class="p_context"> static int adm8211_init_rings(struct ieee80211_hw *dev)</span>
 						  skb_tail_pointer(rx_info-&gt;skb),
 						  RX_PKT_SIZE,
 						  PCI_DMA_FROMDEVICE);
<span class="p_add">+		if (pci_dma_mapping_error(priv-&gt;pdev, rx_info-&gt;mapping)) {</span>
<span class="p_add">+			dev_kfree_skb(rx_info-&gt;skb);</span>
<span class="p_add">+			rx_info-&gt;skb = NULL;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		desc-&gt;buffer1 = cpu_to_le32(rx_info-&gt;mapping);
 		desc-&gt;status = cpu_to_le32(RDES0_STATUS_OWN | RDES0_STATUS_SQL);
 	}
<span class="p_chunk">@@ -1613,7 +1626,7 @@</span> <span class="p_context"> static void adm8211_calc_durations(int *dur, int *plcp, size_t payload_len, int</span>
 }
 
 /* Transmit skb w/adm8211_tx_hdr (802.11 header created by hardware) */
<span class="p_del">-static void adm8211_tx_raw(struct ieee80211_hw *dev, struct sk_buff *skb,</span>
<span class="p_add">+static int adm8211_tx_raw(struct ieee80211_hw *dev, struct sk_buff *skb,</span>
 			   u16 plcp_signal,
 			   size_t hdrlen)
 {
<span class="p_chunk">@@ -1625,6 +1638,8 @@</span> <span class="p_context"> static void adm8211_tx_raw(struct ieee80211_hw *dev, struct sk_buff *skb,</span>
 
 	mapping = pci_map_single(priv-&gt;pdev, skb-&gt;data, skb-&gt;len,
 				 PCI_DMA_TODEVICE);
<span class="p_add">+	if (pci_dma_mapping_error(priv-&gt;pdev, mapping))</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
<span class="p_chunk">@@ -1657,6 +1672,8 @@</span> <span class="p_context"> static void adm8211_tx_raw(struct ieee80211_hw *dev, struct sk_buff *skb,</span>
 
 	/* Trigger transmit poll */
 	ADM8211_CSR_WRITE(TDR, 0);
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 /* Put adm8211_tx_hdr on skb and transmit */
<span class="p_chunk">@@ -1710,7 +1727,10 @@</span> <span class="p_context"> static void adm8211_tx(struct ieee80211_hw *dev,</span>
 
 	txhdr-&gt;retry_limit = info-&gt;control.rates[0].count;
 
<span class="p_del">-	adm8211_tx_raw(dev, skb, plcp_signal, hdrlen);</span>
<span class="p_add">+	if (adm8211_tx_raw(dev, skb, plcp_signal, hdrlen)) {</span>
<span class="p_add">+		/* Drop packet */</span>
<span class="p_add">+		ieee80211_free_txskb(dev, skb);</span>
<span class="p_add">+	}</span>
 }
 
 static int adm8211_alloc_rings(struct ieee80211_hw *dev)
<span class="p_chunk">@@ -1843,7 +1863,8 @@</span> <span class="p_context"> static int adm8211_probe(struct pci_dev *pdev,</span>
 	priv-&gt;rx_ring_size = rx_ring_size;
 	priv-&gt;tx_ring_size = tx_ring_size;
 
<span class="p_del">-	if (adm8211_alloc_rings(dev)) {</span>
<span class="p_add">+	err = adm8211_alloc_rings(dev);</span>
<span class="p_add">+	if (err) {</span>
 		printk(KERN_ERR &quot;%s (adm8211): Cannot allocate TX/RX ring\n&quot;,
 		       pci_name(pdev));
 		goto err_iounmap;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_header">index 366d3dcb8e9d..7b3017f55e3d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_chunk">@@ -691,8 +691,11 @@</span> <span class="p_context"> static int ath10k_core_get_board_id_from_otp(struct ath10k *ar)</span>
 		   &quot;boot get otp board id result 0x%08x board_id %d chip_id %d\n&quot;,
 		   result, board_id, chip_id);
 
<span class="p_del">-	if ((result &amp; ATH10K_BMI_BOARD_ID_STATUS_MASK) != 0)</span>
<span class="p_add">+	if ((result &amp; ATH10K_BMI_BOARD_ID_STATUS_MASK) != 0 ||</span>
<span class="p_add">+	    (board_id == 0)) {</span>
<span class="p_add">+		ath10k_warn(ar, &quot;board id is not exist in otp, ignore it\n&quot;);</span>
 		return -EOPNOTSUPP;
<span class="p_add">+	}</span>
 
 	ar-&gt;id.bmi_ids_valid = true;
 	ar-&gt;id.bmi_board_id = board_id;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">index 30e98afa2e68..17ab8efdac35 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_chunk">@@ -1224,6 +1224,36 @@</span> <span class="p_context"> static int ath10k_monitor_recalc(struct ath10k *ar)</span>
 		return ath10k_monitor_stop(ar);
 }
 
<span class="p_add">+static bool ath10k_mac_can_set_cts_prot(struct ath10k_vif *arvif)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ath10k *ar = arvif-&gt;ar;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held(&amp;ar-&gt;conf_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!arvif-&gt;is_started) {</span>
<span class="p_add">+		ath10k_dbg(ar, ATH10K_DBG_MAC, &quot;defer cts setup, vdev is not ready yet\n&quot;);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int ath10k_mac_set_cts_prot(struct ath10k_vif *arvif)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ath10k *ar = arvif-&gt;ar;</span>
<span class="p_add">+	u32 vdev_param;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held(&amp;ar-&gt;conf_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	vdev_param = ar-&gt;wmi.vdev_param-&gt;protection_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	ath10k_dbg(ar, ATH10K_DBG_MAC, &quot;mac vdev %d cts_protection %d\n&quot;,</span>
<span class="p_add">+		   arvif-&gt;vdev_id, arvif-&gt;use_cts_prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ath10k_wmi_vdev_set_param(ar, arvif-&gt;vdev_id, vdev_param,</span>
<span class="p_add">+					 arvif-&gt;use_cts_prot ? 1 : 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int ath10k_recalc_rtscts_prot(struct ath10k_vif *arvif)
 {
 	struct ath10k *ar = arvif-&gt;ar;
<span class="p_chunk">@@ -4668,7 +4698,8 @@</span> <span class="p_context"> static int ath10k_mac_txpower_recalc(struct ath10k *ar)</span>
 	lockdep_assert_held(&amp;ar-&gt;conf_mutex);
 
 	list_for_each_entry(arvif, &amp;ar-&gt;arvifs, list) {
<span class="p_del">-		WARN_ON(arvif-&gt;txpower &lt; 0);</span>
<span class="p_add">+		if (arvif-&gt;txpower &lt;= 0)</span>
<span class="p_add">+			continue;</span>
 
 		if (txpower == -1)
 			txpower = arvif-&gt;txpower;
<span class="p_chunk">@@ -4676,8 +4707,8 @@</span> <span class="p_context"> static int ath10k_mac_txpower_recalc(struct ath10k *ar)</span>
 			txpower = min(txpower, arvif-&gt;txpower);
 	}
 
<span class="p_del">-	if (WARN_ON(txpower == -1))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (txpower == -1)</span>
<span class="p_add">+		return 0;</span>
 
 	ret = ath10k_mac_txpower_setup(ar, txpower);
 	if (ret) {
<span class="p_chunk">@@ -5321,20 +5352,18 @@</span> <span class="p_context"> static void ath10k_bss_info_changed(struct ieee80211_hw *hw,</span>
 
 	if (changed &amp; BSS_CHANGED_ERP_CTS_PROT) {
 		arvif-&gt;use_cts_prot = info-&gt;use_cts_prot;
<span class="p_del">-		ath10k_dbg(ar, ATH10K_DBG_MAC, &quot;mac vdev %d cts_prot %d\n&quot;,</span>
<span class="p_del">-			   arvif-&gt;vdev_id, info-&gt;use_cts_prot);</span>
 
 		ret = ath10k_recalc_rtscts_prot(arvif);
 		if (ret)
 			ath10k_warn(ar, &quot;failed to recalculate rts/cts prot for vdev %d: %d\n&quot;,
 				    arvif-&gt;vdev_id, ret);
 
<span class="p_del">-		vdev_param = ar-&gt;wmi.vdev_param-&gt;protection_mode;</span>
<span class="p_del">-		ret = ath10k_wmi_vdev_set_param(ar, arvif-&gt;vdev_id, vdev_param,</span>
<span class="p_del">-						info-&gt;use_cts_prot ? 1 : 0);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			ath10k_warn(ar, &quot;failed to set protection mode %d on vdev %i: %d\n&quot;,</span>
<span class="p_del">-				    info-&gt;use_cts_prot, arvif-&gt;vdev_id, ret);</span>
<span class="p_add">+		if (ath10k_mac_can_set_cts_prot(arvif)) {</span>
<span class="p_add">+			ret = ath10k_mac_set_cts_prot(arvif);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				ath10k_warn(ar, &quot;failed to set cts protection for vdev %d: %d\n&quot;,</span>
<span class="p_add">+					    arvif-&gt;vdev_id, ret);</span>
<span class="p_add">+		}</span>
 	}
 
 	if (changed &amp; BSS_CHANGED_ERP_SLOT) {
<span class="p_chunk">@@ -7355,6 +7384,13 @@</span> <span class="p_context"> ath10k_mac_op_assign_vif_chanctx(struct ieee80211_hw *hw,</span>
 		arvif-&gt;is_up = true;
 	}
 
<span class="p_add">+	if (ath10k_mac_can_set_cts_prot(arvif)) {</span>
<span class="p_add">+		ret = ath10k_mac_set_cts_prot(arvif);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			ath10k_warn(ar, &quot;failed to set cts protection for vdev %d: %d\n&quot;,</span>
<span class="p_add">+				    arvif-&gt;vdev_id, ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;ar-&gt;conf_mutex);
 	return 0;
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/wmi-tlv.c b/drivers/net/wireless/ath/ath10k/wmi-tlv.c</span>
<span class="p_header">index e64f59300a7c..0e4d49adddd0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/wmi-tlv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/wmi-tlv.c</span>
<span class="p_chunk">@@ -1105,8 +1105,10 @@</span> <span class="p_context"> static int ath10k_wmi_tlv_op_pull_fw_stats(struct ath10k *ar,</span>
 		struct ath10k_fw_stats_pdev *dst;
 
 		src = data;
<span class="p_del">-		if (data_len &lt; sizeof(*src))</span>
<span class="p_add">+		if (data_len &lt; sizeof(*src)) {</span>
<span class="p_add">+			kfree(tb);</span>
 			return -EPROTO;
<span class="p_add">+		}</span>
 
 		data += sizeof(*src);
 		data_len -= sizeof(*src);
<span class="p_chunk">@@ -1126,8 +1128,10 @@</span> <span class="p_context"> static int ath10k_wmi_tlv_op_pull_fw_stats(struct ath10k *ar,</span>
 		struct ath10k_fw_stats_vdev *dst;
 
 		src = data;
<span class="p_del">-		if (data_len &lt; sizeof(*src))</span>
<span class="p_add">+		if (data_len &lt; sizeof(*src)) {</span>
<span class="p_add">+			kfree(tb);</span>
 			return -EPROTO;
<span class="p_add">+		}</span>
 
 		data += sizeof(*src);
 		data_len -= sizeof(*src);
<span class="p_chunk">@@ -1145,8 +1149,10 @@</span> <span class="p_context"> static int ath10k_wmi_tlv_op_pull_fw_stats(struct ath10k *ar,</span>
 		struct ath10k_fw_stats_peer *dst;
 
 		src = data;
<span class="p_del">-		if (data_len &lt; sizeof(*src))</span>
<span class="p_add">+		if (data_len &lt; sizeof(*src)) {</span>
<span class="p_add">+			kfree(tb);</span>
 			return -EPROTO;
<span class="p_add">+		}</span>
 
 		data += sizeof(*src);
 		data_len -= sizeof(*src);
<span class="p_header">diff --git a/drivers/net/wireless/intersil/p54/main.c b/drivers/net/wireless/intersil/p54/main.c</span>
<span class="p_header">index d5a3bf91a03e..ab6d39e12069 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intersil/p54/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intersil/p54/main.c</span>
<span class="p_chunk">@@ -852,12 +852,11 @@</span> <span class="p_context"> void p54_unregister_common(struct ieee80211_hw *dev)</span>
 {
 	struct p54_common *priv = dev-&gt;priv;
 
<span class="p_del">-#ifdef CONFIG_P54_LEDS</span>
<span class="p_del">-	p54_unregister_leds(priv);</span>
<span class="p_del">-#endif /* CONFIG_P54_LEDS */</span>
<span class="p_del">-</span>
 	if (priv-&gt;registered) {
 		priv-&gt;registered = false;
<span class="p_add">+#ifdef CONFIG_P54_LEDS</span>
<span class="p_add">+		p54_unregister_leds(priv);</span>
<span class="p_add">+#endif /* CONFIG_P54_LEDS */</span>
 		ieee80211_unregister_hw(dev);
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/sdio.c b/drivers/net/wireless/marvell/mwifiex/sdio.c</span>
<span class="p_header">index 8718950004f3..8d601dcf2948 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/sdio.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/sdio.c</span>
<span class="p_chunk">@@ -2296,6 +2296,12 @@</span> <span class="p_context"> static void mwifiex_recreate_adapter(struct sdio_mmc_card *card)</span>
 	mmc_hw_reset(func-&gt;card-&gt;host);
 	sdio_release_host(func);
 
<span class="p_add">+	/* Previous save_adapter won&#39;t be valid after this. We will cancel</span>
<span class="p_add">+	 * pending work requests.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	clear_bit(MWIFIEX_IFACE_WORK_DEVICE_DUMP, &amp;iface_work_flags);</span>
<span class="p_add">+	clear_bit(MWIFIEX_IFACE_WORK_CARD_RESET, &amp;iface_work_flags);</span>
<span class="p_add">+</span>
 	mwifiex_sdio_probe(func, device_id);
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_header">index bf3f0a39908c..9fc6f1615343 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c</span>
<span class="p_chunk">@@ -4707,8 +4707,8 @@</span> <span class="p_context"> static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)</span>
 		rt2x00_set_field32(&amp;reg, MAX_LEN_CFG_MAX_PSDU, 2);
 	else
 		rt2x00_set_field32(&amp;reg, MAX_LEN_CFG_MAX_PSDU, 1);
<span class="p_del">-	rt2x00_set_field32(&amp;reg, MAX_LEN_CFG_MIN_PSDU, 0);</span>
<span class="p_del">-	rt2x00_set_field32(&amp;reg, MAX_LEN_CFG_MIN_MPDU, 0);</span>
<span class="p_add">+	rt2x00_set_field32(&amp;reg, MAX_LEN_CFG_MIN_PSDU, 10);</span>
<span class="p_add">+	rt2x00_set_field32(&amp;reg, MAX_LEN_CFG_MIN_MPDU, 10);</span>
 	rt2800_register_write(rt2x00dev, MAX_LEN_CFG, reg);
 
 	rt2800_register_read(rt2x00dev, LED_CFG, &amp;reg);
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c b/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c</span>
<span class="p_header">index 631df690adbe..f57bb2cd604e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> int rt2x00usb_vendor_request(struct rt2x00_dev *rt2x00dev,</span>
 		if (status &gt;= 0)
 			return 0;
 
<span class="p_del">-		if (status == -ENODEV) {</span>
<span class="p_add">+		if (status == -ENODEV || status == -ENOENT) {</span>
 			/* Device has disappeared. */
 			clear_bit(DEVICE_STATE_PRESENT, &amp;rt2x00dev-&gt;flags);
 			break;
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> static bool rt2x00usb_kick_tx_entry(struct queue_entry *entry, void *data)</span>
 
 	status = usb_submit_urb(entry_priv-&gt;urb, GFP_ATOMIC);
 	if (status) {
<span class="p_del">-		if (status == -ENODEV)</span>
<span class="p_add">+		if (status == -ENODEV || status == -ENOENT)</span>
 			clear_bit(DEVICE_STATE_PRESENT, &amp;rt2x00dev-&gt;flags);
 		set_bit(ENTRY_DATA_IO_FAILED, &amp;entry-&gt;flags);
 		rt2x00lib_dmadone(entry);
<span class="p_chunk">@@ -410,7 +410,7 @@</span> <span class="p_context"> static bool rt2x00usb_kick_rx_entry(struct queue_entry *entry, void *data)</span>
 
 	status = usb_submit_urb(entry_priv-&gt;urb, GFP_ATOMIC);
 	if (status) {
<span class="p_del">-		if (status == -ENODEV)</span>
<span class="p_add">+		if (status == -ENODEV || status == -ENOENT)</span>
 			clear_bit(DEVICE_STATE_PRESENT, &amp;rt2x00dev-&gt;flags);
 		set_bit(ENTRY_DATA_IO_FAILED, &amp;entry-&gt;flags);
 		rt2x00lib_dmadone(entry);
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/fw.c b/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/fw.c</span>
<span class="p_header">index b3f6a9ed15d4..27a0e50c2793 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/fw.c</span>
<span class="p_chunk">@@ -664,7 +664,7 @@</span> <span class="p_context"> void rtl92ee_set_fw_rsvdpagepkt(struct ieee80211_hw *hw, bool b_dl_finished)</span>
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_mac *mac = rtl_mac(rtl_priv(hw));
 	struct sk_buff *skb = NULL;
<span class="p_del">-</span>
<span class="p_add">+	bool rtstatus;</span>
 	u32 totalpacketlen;
 	u8 u1rsvdpageloc[5] = { 0 };
 	bool b_dlok = false;
<span class="p_chunk">@@ -727,7 +727,9 @@</span> <span class="p_context"> void rtl92ee_set_fw_rsvdpagepkt(struct ieee80211_hw *hw, bool b_dl_finished)</span>
 	memcpy((u8 *)skb_put(skb, totalpacketlen),
 	       &amp;reserved_page_packet, totalpacketlen);
 
<span class="p_del">-	b_dlok = true;</span>
<span class="p_add">+	rtstatus = rtl_cmd_send_packet(hw, skb);</span>
<span class="p_add">+	if (rtstatus)</span>
<span class="p_add">+		b_dlok = true;</span>
 
 	if (b_dlok) {
 		RT_TRACE(rtlpriv, COMP_POWER, DBG_LOUD ,
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 1281ebe0c30a..82d53895ce4d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -1378,6 +1378,7 @@</span> <span class="p_context"> static void _rtl8821ae_get_wakeup_reason(struct ieee80211_hw *hw)</span>
 
 	ppsc-&gt;wakeup_reason = 0;
 
<span class="p_add">+	do_gettimeofday(&amp;ts);</span>
 	rtlhal-&gt;last_suspend_sec = ts.tv_sec;
 
 	switch (fw_reason) {
<span class="p_header">diff --git a/drivers/nvdimm/label.c b/drivers/nvdimm/label.c</span>
<span class="p_header">index fac7cabe8f56..d8d189d14834 100644</span>
<span class="p_header">--- a/drivers/nvdimm/label.c</span>
<span class="p_header">+++ b/drivers/nvdimm/label.c</span>
<span class="p_chunk">@@ -861,7 +861,7 @@</span> <span class="p_context"> static int init_labels(struct nd_mapping *nd_mapping, int num_labels)</span>
 	nsindex = to_namespace_index(ndd, 0);
 	memset(nsindex, 0, ndd-&gt;nsarea.config_size);
 	for (i = 0; i &lt; 2; i++) {
<span class="p_del">-		int rc = nd_label_write_index(ndd, i, i*2, ND_NSINDEX_INIT);</span>
<span class="p_add">+		int rc = nd_label_write_index(ndd, i, 3 - i, ND_NSINDEX_INIT);</span>
 
 		if (rc)
 			return rc;
<span class="p_header">diff --git a/drivers/nvdimm/namespace_devs.c b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">index a38ae34b74e4..b8fb1ef1fc15 100644</span>
<span class="p_header">--- a/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_chunk">@@ -1451,7 +1451,7 @@</span> <span class="p_context"> static umode_t namespace_visible(struct kobject *kobj,</span>
 	if (a == &amp;dev_attr_resource.attr) {
 		if (is_namespace_blk(dev))
 			return 0;
<span class="p_del">-		return a-&gt;mode;</span>
<span class="p_add">+		return 0400;</span>
 	}
 
 	if (is_namespace_pmem(dev) || is_namespace_blk(dev)) {
<span class="p_header">diff --git a/drivers/nvdimm/pfn_devs.c b/drivers/nvdimm/pfn_devs.c</span>
<span class="p_header">index 78cb3e2359bd..71eb6c637b60 100644</span>
<span class="p_header">--- a/drivers/nvdimm/pfn_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/pfn_devs.c</span>
<span class="p_chunk">@@ -270,8 +270,16 @@</span> <span class="p_context"> static struct attribute *nd_pfn_attributes[] = {</span>
 	NULL,
 };
 
<span class="p_add">+static umode_t pfn_visible(struct kobject *kobj, struct attribute *a, int n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (a == &amp;dev_attr_resource.attr)</span>
<span class="p_add">+		return 0400;</span>
<span class="p_add">+	return a-&gt;mode;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct attribute_group nd_pfn_attribute_group = {
 	.attrs = nd_pfn_attributes,
<span class="p_add">+	.is_visible = pfn_visible,</span>
 };
 
 static const struct attribute_group *nd_pfn_attribute_groups[] = {
<span class="p_header">diff --git a/drivers/nvme/target/admin-cmd.c b/drivers/nvme/target/admin-cmd.c</span>
<span class="p_header">index 6fe4c48a21e4..f791d46fe50f 100644</span>
<span class="p_header">--- a/drivers/nvme/target/admin-cmd.c</span>
<span class="p_header">+++ b/drivers/nvme/target/admin-cmd.c</span>
<span class="p_chunk">@@ -381,7 +381,6 @@</span> <span class="p_context"> static void nvmet_execute_set_features(struct nvmet_req *req)</span>
 {
 	struct nvmet_subsys *subsys = req-&gt;sq-&gt;ctrl-&gt;subsys;
 	u32 cdw10 = le32_to_cpu(req-&gt;cmd-&gt;common.cdw10[0]);
<span class="p_del">-	u64 val;</span>
 	u32 val32;
 	u16 status = 0;
 
<span class="p_chunk">@@ -391,8 +390,7 @@</span> <span class="p_context"> static void nvmet_execute_set_features(struct nvmet_req *req)</span>
 			(subsys-&gt;max_qid - 1) | ((subsys-&gt;max_qid - 1) &lt;&lt; 16));
 		break;
 	case NVME_FEAT_KATO:
<span class="p_del">-		val = le64_to_cpu(req-&gt;cmd-&gt;prop_set.value);</span>
<span class="p_del">-		val32 = val &amp; 0xffff;</span>
<span class="p_add">+		val32 = le32_to_cpu(req-&gt;cmd-&gt;common.cdw10[1]);</span>
 		req-&gt;sq-&gt;ctrl-&gt;kato = DIV_ROUND_UP(val32, 1000);
 		nvmet_set_result(req, req-&gt;sq-&gt;ctrl-&gt;kato);
 		break;
<span class="p_header">diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c</span>
<span class="p_header">index d266d800f246..60bada90cd75 100644</span>
<span class="p_header">--- a/drivers/pci/probe.c</span>
<span class="p_header">+++ b/drivers/pci/probe.c</span>
<span class="p_chunk">@@ -1438,8 +1438,16 @@</span> <span class="p_context"> static void program_hpp_type0(struct pci_dev *dev, struct hpp_type0 *hpp)</span>
 
 static void program_hpp_type1(struct pci_dev *dev, struct hpp_type1 *hpp)
 {
<span class="p_del">-	if (hpp)</span>
<span class="p_del">-		dev_warn(&amp;dev-&gt;dev, &quot;PCI-X settings not supported\n&quot;);</span>
<span class="p_add">+	int pos;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hpp)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pos = pci_find_capability(dev, PCI_CAP_ID_PCIX);</span>
<span class="p_add">+	if (!pos)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_warn(&amp;dev-&gt;dev, &quot;PCI-X settings not supported\n&quot;);</span>
 }
 
 static bool pcie_root_rcb_set(struct pci_dev *dev)
<span class="p_chunk">@@ -1465,6 +1473,9 @@</span> <span class="p_context"> static void program_hpp_type2(struct pci_dev *dev, struct hpp_type2 *hpp)</span>
 	if (!hpp)
 		return;
 
<span class="p_add">+	if (!pci_is_pcie(dev))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (hpp-&gt;revision &gt; 1) {
 		dev_warn(&amp;dev-&gt;dev, &quot;PCIe settings rev %d not supported\n&quot;,
 			 hpp-&gt;revision);
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 5d8151b43fbb..98eba9127a0b 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -4088,12 +4088,14 @@</span> <span class="p_context"> static int pci_quirk_amd_sb_acs(struct pci_dev *dev, u16 acs_flags)</span>
 static int pci_quirk_cavium_acs(struct pci_dev *dev, u16 acs_flags)
 {
 	/*
<span class="p_del">-	 * Cavium devices matching this quirk do not perform peer-to-peer</span>
<span class="p_del">-	 * with other functions, allowing masking out these bits as if they</span>
<span class="p_del">-	 * were unimplemented in the ACS capability.</span>
<span class="p_add">+	 * Cavium root ports don&#39;t advertise an ACS capability.  However,</span>
<span class="p_add">+	 * the RTL internally implements similar protection as if ACS had</span>
<span class="p_add">+	 * Request Redirection, Completion Redirection, Source Validation,</span>
<span class="p_add">+	 * and Upstream Forwarding features enabled.  Assert that the</span>
<span class="p_add">+	 * hardware implements and enables equivalent ACS functionality for</span>
<span class="p_add">+	 * these flags.</span>
 	 */
<span class="p_del">-	acs_flags &amp;= ~(PCI_ACS_SV | PCI_ACS_TB | PCI_ACS_RR |</span>
<span class="p_del">-		       PCI_ACS_CR | PCI_ACS_UF | PCI_ACS_DT);</span>
<span class="p_add">+	acs_flags &amp;= ~(PCI_ACS_RR | PCI_ACS_CR | PCI_ACS_SV | PCI_ACS_UF);</span>
 
 	return acs_flags ? 0 : 1;
 }
<span class="p_header">diff --git a/drivers/pinctrl/sirf/pinctrl-atlas7.c b/drivers/pinctrl/sirf/pinctrl-atlas7.c</span>
<span class="p_header">index 7f3041697813..f714f67c4b64 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sirf/pinctrl-atlas7.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sirf/pinctrl-atlas7.c</span>
<span class="p_chunk">@@ -5420,14 +5420,15 @@</span> <span class="p_context"> static int atlas7_pinmux_probe(struct platform_device *pdev)</span>
 	sys2pci_np = of_find_node_by_name(NULL, &quot;sys2pci&quot;);
 	if (!sys2pci_np)
 		return -EINVAL;
<span class="p_add">+</span>
 	ret = of_address_to_resource(sys2pci_np, 0, &amp;res);
<span class="p_add">+	of_node_put(sys2pci_np);</span>
 	if (ret)
 		return ret;
<span class="p_add">+</span>
 	pmx-&gt;sys2pci_base = devm_ioremap_resource(&amp;pdev-&gt;dev, &amp;res);
<span class="p_del">-	if (IS_ERR(pmx-&gt;sys2pci_base)) {</span>
<span class="p_del">-		of_node_put(sys2pci_np);</span>
<span class="p_add">+	if (IS_ERR(pmx-&gt;sys2pci_base))</span>
 		return -ENOMEM;
<span class="p_del">-	}</span>
 
 	pmx-&gt;dev = &amp;pdev-&gt;dev;
 
<span class="p_header">diff --git a/drivers/spi/Kconfig b/drivers/spi/Kconfig</span>
<span class="p_header">index b7995474148c..8e281e47afec 100644</span>
<span class="p_header">--- a/drivers/spi/Kconfig</span>
<span class="p_header">+++ b/drivers/spi/Kconfig</span>
<span class="p_chunk">@@ -365,6 +365,7 @@</span> <span class="p_context"> config SPI_FSL_SPI</span>
 config SPI_FSL_DSPI
 	tristate &quot;Freescale DSPI controller&quot;
 	select REGMAP_MMIO
<span class="p_add">+	depends on HAS_DMA</span>
 	depends on SOC_VF610 || SOC_LS1021A || ARCH_LAYERSCAPE || COMPILE_TEST
 	help
 	  This enables support for the Freescale DSPI controller in master
<span class="p_header">diff --git a/drivers/staging/iio/cdc/ad7150.c b/drivers/staging/iio/cdc/ad7150.c</span>
<span class="p_header">index 5578a077fcfb..50a5b0c2cc7b 100644</span>
<span class="p_header">--- a/drivers/staging/iio/cdc/ad7150.c</span>
<span class="p_header">+++ b/drivers/staging/iio/cdc/ad7150.c</span>
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> static int ad7150_write_event_config(struct iio_dev *indio_dev,</span>
 error_ret:
 	mutex_unlock(&amp;chip-&gt;state_lock);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int ad7150_read_event_value(struct iio_dev *indio_dev,
<span class="p_header">diff --git a/drivers/staging/media/cec/cec-adap.c b/drivers/staging/media/cec/cec-adap.c</span>
<span class="p_header">index 057c9b5ab1e5..499d7bfe7147 100644</span>
<span class="p_header">--- a/drivers/staging/media/cec/cec-adap.c</span>
<span class="p_header">+++ b/drivers/staging/media/cec/cec-adap.c</span>
<span class="p_chunk">@@ -288,10 +288,10 @@</span> <span class="p_context"> static void cec_data_cancel(struct cec_data *data)</span>
 
 	/* Mark it as an error */
 	data-&gt;msg.tx_ts = ktime_get_ns();
<span class="p_del">-	data-&gt;msg.tx_status = CEC_TX_STATUS_ERROR |</span>
<span class="p_del">-			      CEC_TX_STATUS_MAX_RETRIES;</span>
<span class="p_add">+	data-&gt;msg.tx_status |= CEC_TX_STATUS_ERROR |</span>
<span class="p_add">+			       CEC_TX_STATUS_MAX_RETRIES;</span>
<span class="p_add">+	data-&gt;msg.tx_error_cnt++;</span>
 	data-&gt;attempts = 0;
<span class="p_del">-	data-&gt;msg.tx_error_cnt = 1;</span>
 	/* Queue transmitted message for monitoring purposes */
 	cec_queue_msg_monitor(data-&gt;adap, &amp;data-&gt;msg, 1);
 
<span class="p_chunk">@@ -1062,6 +1062,8 @@</span> <span class="p_context"> static int cec_config_thread_func(void *arg)</span>
 		for (i = 1; i &lt; las-&gt;num_log_addrs; i++)
 			las-&gt;log_addr[i] = CEC_LOG_ADDR_INVALID;
 	}
<span class="p_add">+	for (i = las-&gt;num_log_addrs; i &lt; CEC_MAX_LOG_ADDRS; i++)</span>
<span class="p_add">+		las-&gt;log_addr[i] = CEC_LOG_ADDR_INVALID;</span>
 	adap-&gt;is_configured = true;
 	adap-&gt;is_configuring = false;
 	cec_post_state_event(adap);
<span class="p_chunk">@@ -1079,8 +1081,6 @@</span> <span class="p_context"> static int cec_config_thread_func(void *arg)</span>
 			cec_report_features(adap, i);
 		cec_report_phys_addr(adap, i);
 	}
<span class="p_del">-	for (i = las-&gt;num_log_addrs; i &lt; CEC_MAX_LOG_ADDRS; i++)</span>
<span class="p_del">-		las-&gt;log_addr[i] = CEC_LOG_ADDR_INVALID;</span>
 	mutex_lock(&amp;adap-&gt;lock);
 	adap-&gt;kthread_config = NULL;
 	mutex_unlock(&amp;adap-&gt;lock);
<span class="p_chunk">@@ -1557,9 +1557,9 @@</span> <span class="p_context"> static int cec_receive_notify(struct cec_adapter *adap, struct cec_msg *msg,</span>
 	}
 
 	case CEC_MSG_GIVE_FEATURES:
<span class="p_del">-		if (adap-&gt;log_addrs.cec_version &gt;= CEC_OP_CEC_VERSION_2_0)</span>
<span class="p_del">-			return cec_report_features(adap, la_idx);</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		if (adap-&gt;log_addrs.cec_version &lt; CEC_OP_CEC_VERSION_2_0)</span>
<span class="p_add">+			return cec_feature_abort(adap, msg);</span>
<span class="p_add">+		return cec_report_features(adap, la_idx);</span>
 
 	default:
 		/*
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index f3c9d18e9dc5..0d578297d9f9 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -2104,12 +2104,14 @@</span> <span class="p_context"> iscsit_handle_task_mgt_cmd(struct iscsi_conn *conn, struct iscsi_cmd *cmd,</span>
 
 	if (!(hdr-&gt;opcode &amp; ISCSI_OP_IMMEDIATE)) {
 		int cmdsn_ret = iscsit_sequence_cmd(conn, cmd, buf, hdr-&gt;cmdsn);
<span class="p_del">-		if (cmdsn_ret == CMDSN_HIGHER_THAN_EXP)</span>
<span class="p_add">+		if (cmdsn_ret == CMDSN_HIGHER_THAN_EXP) {</span>
 			out_of_order_cmdsn = 1;
<span class="p_del">-		else if (cmdsn_ret == CMDSN_LOWER_THAN_EXP)</span>
<span class="p_add">+		} else if (cmdsn_ret == CMDSN_LOWER_THAN_EXP) {</span>
<span class="p_add">+			target_put_sess_cmd(&amp;cmd-&gt;se_cmd);</span>
 			return 0;
<span class="p_del">-		else if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER)</span>
<span class="p_add">+		} else if (cmdsn_ret == CMDSN_ERROR_CANNOT_RECOVER) {</span>
 			return -1;
<span class="p_add">+		}</span>
 	}
 	iscsit_ack_from_expstatsn(conn, be32_to_cpu(hdr-&gt;exp_statsn));
 
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index bacfa8f81be8..4c0782cb1e94 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1976,6 +1976,8 @@</span> <span class="p_context"> static void target_restart_delayed_cmds(struct se_device *dev)</span>
 		list_del(&amp;cmd-&gt;se_delayed_node);
 		spin_unlock(&amp;dev-&gt;delayed_cmd_lock);
 
<span class="p_add">+		cmd-&gt;transport_state |= CMD_T_SENT;</span>
<span class="p_add">+</span>
 		__target_execute_cmd(cmd, true);
 
 		if (cmd-&gt;sam_task_attr == TCM_ORDERED_TAG)
<span class="p_chunk">@@ -2013,6 +2015,8 @@</span> <span class="p_context"> static void transport_complete_task_attr(struct se_cmd *cmd)</span>
 		pr_debug(&quot;Incremented dev_cur_ordered_id: %u for ORDERED\n&quot;,
 			 dev-&gt;dev_cur_ordered_id);
 	}
<span class="p_add">+	cmd-&gt;se_cmd_flags &amp;= ~SCF_TASK_ATTR_SET;</span>
<span class="p_add">+</span>
 restart:
 	target_restart_delayed_cmds(dev);
 }
<span class="p_header">diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c</span>
<span class="p_header">index 6e29d053843d..9e36632b6f0e 100644</span>
<span class="p_header">--- a/drivers/vhost/scsi.c</span>
<span class="p_header">+++ b/drivers/vhost/scsi.c</span>
<span class="p_chunk">@@ -693,6 +693,7 @@</span> <span class="p_context"> vhost_scsi_iov_to_sgl(struct vhost_scsi_cmd *cmd, bool write,</span>
 		      struct scatterlist *sg, int sg_count)
 {
 	size_t off = iter-&gt;iov_offset;
<span class="p_add">+	struct scatterlist *p = sg;</span>
 	int i, ret;
 
 	for (i = 0; i &lt; iter-&gt;nr_segs; i++) {
<span class="p_chunk">@@ -701,8 +702,8 @@</span> <span class="p_context"> vhost_scsi_iov_to_sgl(struct vhost_scsi_cmd *cmd, bool write,</span>
 
 		ret = vhost_scsi_map_to_sgl(cmd, base, len, sg, write);
 		if (ret &lt; 0) {
<span class="p_del">-			for (i = 0; i &lt; sg_count; i++) {</span>
<span class="p_del">-				struct page *page = sg_page(&amp;sg[i]);</span>
<span class="p_add">+			while (p &lt; sg) {</span>
<span class="p_add">+				struct page *page = sg_page(p++);</span>
 				if (page)
 					put_page(page);
 			}
<span class="p_header">diff --git a/drivers/xen/xenbus/xenbus_dev_frontend.c b/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_header">index 1e8be12ebb55..0a3c6762df1b 100644</span>
<span class="p_header">--- a/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_header">+++ b/drivers/xen/xenbus/xenbus_dev_frontend.c</span>
<span class="p_chunk">@@ -316,7 +316,7 @@</span> <span class="p_context"> static int xenbus_write_transaction(unsigned msg_type,</span>
 			rc = -ENOMEM;
 			goto out;
 		}
<span class="p_del">-	} else if (msg_type == XS_TRANSACTION_END) {</span>
<span class="p_add">+	} else if (u-&gt;u.msg.tx_id != 0) {</span>
 		list_for_each_entry(trans, &amp;u-&gt;transactions, list)
 			if (trans-&gt;handle.id == u-&gt;u.msg.tx_id)
 				break;
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index 30ca770c5e0b..f8ab4a66acaf 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -483,6 +483,9 @@</span> <span class="p_context"> static int v9fs_test_inode(struct inode *inode, void *data)</span>
 
 	if (v9inode-&gt;qid.type != st-&gt;qid.type)
 		return 0;
<span class="p_add">+</span>
<span class="p_add">+	if (v9inode-&gt;qid.path != st-&gt;qid.path)</span>
<span class="p_add">+		return 0;</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index afaa4b6de801..c3dd0d42bb3a 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -87,6 +87,9 @@</span> <span class="p_context"> static int v9fs_test_inode_dotl(struct inode *inode, void *data)</span>
 
 	if (v9inode-&gt;qid.type != st-&gt;qid.type)
 		return 0;
<span class="p_add">+</span>
<span class="p_add">+	if (v9inode-&gt;qid.path != st-&gt;qid.path)</span>
<span class="p_add">+		return 0;</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/fs/autofs4/waitq.c b/fs/autofs4/waitq.c</span>
<span class="p_header">index 5db6c8d745ea..4c71dba90120 100644</span>
<span class="p_header">--- a/fs/autofs4/waitq.c</span>
<span class="p_header">+++ b/fs/autofs4/waitq.c</span>
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> static int autofs4_write(struct autofs_sb_info *sbi,</span>
 		spin_unlock_irqrestore(&amp;current-&gt;sighand-&gt;siglock, flags);
 	}
 
<span class="p_del">-	return (bytes &gt; 0);</span>
<span class="p_add">+	/* if &#39;wr&#39; returned 0 (impossible) we assume -EIO (safe) */</span>
<span class="p_add">+	return bytes == 0 ? 0 : wr &lt; 0 ? wr : -EIO;</span>
 }
 
 static void autofs4_notify_daemon(struct autofs_sb_info *sbi,
<span class="p_chunk">@@ -101,6 +102,7 @@</span> <span class="p_context"> static void autofs4_notify_daemon(struct autofs_sb_info *sbi,</span>
 	} pkt;
 	struct file *pipe = NULL;
 	size_t pktsz;
<span class="p_add">+	int ret;</span>
 
 	pr_debug(&quot;wait id = 0x%08lx, name = %.*s, type=%d\n&quot;,
 		 (unsigned long) wq-&gt;wait_queue_token,
<span class="p_chunk">@@ -175,7 +177,18 @@</span> <span class="p_context"> static void autofs4_notify_daemon(struct autofs_sb_info *sbi,</span>
 	mutex_unlock(&amp;sbi-&gt;wq_mutex);
 
 	if (autofs4_write(sbi, pipe, &amp;pkt, pktsz))
<span class="p_add">+	switch (ret = autofs4_write(sbi, pipe, &amp;pkt, pktsz)) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case -ENOMEM:</span>
<span class="p_add">+	case -ERESTARTSYS:</span>
<span class="p_add">+		/* Just fail this one */</span>
<span class="p_add">+		autofs4_wait_release(sbi, wq-&gt;wait_queue_token, ret);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
 		autofs4_catatonic_mode(sbi);
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 	fput(pipe);
 }
 
<span class="p_header">diff --git a/fs/btrfs/uuid-tree.c b/fs/btrfs/uuid-tree.c</span>
<span class="p_header">index 7fc89e4adb41..83bb2f2aa83c 100644</span>
<span class="p_header">--- a/fs/btrfs/uuid-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/uuid-tree.c</span>
<span class="p_chunk">@@ -351,7 +351,5 @@</span> <span class="p_context"> int btrfs_uuid_tree_iterate(struct btrfs_fs_info *fs_info,</span>
 
 out:
 	btrfs_free_path(path);
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		btrfs_warn(fs_info, &quot;btrfs_uuid_tree_iterate failed %d&quot;, ret);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
<span class="p_header">diff --git a/fs/crypto/crypto.c b/fs/crypto/crypto.c</span>
<span class="p_header">index 61cfccea77bc..73de1446c8d4 100644</span>
<span class="p_header">--- a/fs/crypto/crypto.c</span>
<span class="p_header">+++ b/fs/crypto/crypto.c</span>
<span class="p_chunk">@@ -484,9 +484,6 @@</span> <span class="p_context"> int fscrypt_initialize(void)</span>
 {
 	int i, res = -ENOMEM;
 
<span class="p_del">-	if (fscrypt_bounce_page_pool)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;fscrypt_init_mutex);
 	if (fscrypt_bounce_page_pool)
 		goto already_initialized;
<span class="p_header">diff --git a/fs/crypto/fname.c b/fs/crypto/fname.c</span>
<span class="p_header">index d1bbdc9dda76..e14bb7b67e9c 100644</span>
<span class="p_header">--- a/fs/crypto/fname.c</span>
<span class="p_header">+++ b/fs/crypto/fname.c</span>
<span class="p_chunk">@@ -332,7 +332,7 @@</span> <span class="p_context"> int fscrypt_fname_usr_to_disk(struct inode *inode,</span>
 	 * in a directory. Consequently, a user space name cannot be mapped to
 	 * a disk-space name
 	 */
<span class="p_del">-	return -EACCES;</span>
<span class="p_add">+	return -ENOKEY;</span>
 }
 EXPORT_SYMBOL(fscrypt_fname_usr_to_disk);
 
<span class="p_chunk">@@ -367,7 +367,7 @@</span> <span class="p_context"> int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,</span>
 		return 0;
 	}
 	if (!lookup)
<span class="p_del">-		return -EACCES;</span>
<span class="p_add">+		return -ENOKEY;</span>
 
 	/*
 	 * We don&#39;t have the key and we are doing a lookup; decode the
<span class="p_header">diff --git a/fs/crypto/policy.c b/fs/crypto/policy.c</span>
<span class="p_header">index bb4e209bd809..c160d2d0e18d 100644</span>
<span class="p_header">--- a/fs/crypto/policy.c</span>
<span class="p_header">+++ b/fs/crypto/policy.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> int fscrypt_process_policy(struct file *filp,</span>
 
 	if (!inode_has_encryption_context(inode)) {
 		if (!S_ISDIR(inode-&gt;i_mode))
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_add">+			ret = -ENOTDIR;</span>
 		else if (!inode-&gt;i_sb-&gt;s_cop-&gt;empty_dir)
 			ret = -EOPNOTSUPP;
 		else if (!inode-&gt;i_sb-&gt;s_cop-&gt;empty_dir(inode))
<span class="p_header">diff --git a/fs/ecryptfs/messaging.c b/fs/ecryptfs/messaging.c</span>
<span class="p_header">index 286f10b0363b..4f457d5c4933 100644</span>
<span class="p_header">--- a/fs/ecryptfs/messaging.c</span>
<span class="p_header">+++ b/fs/ecryptfs/messaging.c</span>
<span class="p_chunk">@@ -442,15 +442,16 @@</span> <span class="p_context"> void ecryptfs_release_messaging(void)</span>
 	}
 	if (ecryptfs_daemon_hash) {
 		struct ecryptfs_daemon *daemon;
<span class="p_add">+		struct hlist_node *n;</span>
 		int i;
 
 		mutex_lock(&amp;ecryptfs_daemon_hash_mux);
 		for (i = 0; i &lt; (1 &lt;&lt; ecryptfs_hash_bits); i++) {
 			int rc;
 
<span class="p_del">-			hlist_for_each_entry(daemon,</span>
<span class="p_del">-					     &amp;ecryptfs_daemon_hash[i],</span>
<span class="p_del">-					     euid_chain) {</span>
<span class="p_add">+			hlist_for_each_entry_safe(daemon, n,</span>
<span class="p_add">+						  &amp;ecryptfs_daemon_hash[i],</span>
<span class="p_add">+						  euid_chain) {</span>
 				rc = ecryptfs_exorcise_daemon(daemon);
 				if (rc)
 					printk(KERN_ERR &quot;%s: Error whilst &quot;
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index a3e0b3b7441d..a77cbc5b657b 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -4803,7 +4803,8 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 	}
 
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp;
<span class="p_del">-	     offset + len &gt; i_size_read(inode)) {</span>
<span class="p_add">+	    (offset + len &gt; i_size_read(inode) ||</span>
<span class="p_add">+	     offset + len &gt; EXT4_I(inode)-&gt;i_disksize)) {</span>
 		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
<span class="p_chunk">@@ -4974,7 +4975,8 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	}
 
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp;
<span class="p_del">-	     offset + len &gt; i_size_read(inode)) {</span>
<span class="p_add">+	    (offset + len &gt; i_size_read(inode) ||</span>
<span class="p_add">+	     offset + len &gt; EXT4_I(inode)-&gt;i_disksize)) {</span>
 		new_size = offset + len;
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
<span class="p_header">diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c</span>
<span class="p_header">index 170421edfdfe..2d94e8524839 100644</span>
<span class="p_header">--- a/fs/ext4/ialloc.c</span>
<span class="p_header">+++ b/fs/ext4/ialloc.c</span>
<span class="p_chunk">@@ -771,7 +771,7 @@</span> <span class="p_context"> struct inode *__ext4_new_inode(handle_t *handle, struct inode *dir,</span>
 		if (err)
 			return ERR_PTR(err);
 		if (!fscrypt_has_encryption_key(dir))
<span class="p_del">-			return ERR_PTR(-EPERM);</span>
<span class="p_add">+			return ERR_PTR(-ENOKEY);</span>
 		if (!handle)
 			nblocks += EXT4_DATA_TRANS_BLOCKS(dir-&gt;i_sb);
 		encrypt = 1;
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 00b8a5a66961..4438b93f6fd6 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1378,6 +1378,8 @@</span> <span class="p_context"> static struct buffer_head * ext4_find_entry (struct inode *dir,</span>
 		return NULL;
 
 	retval = ext4_fname_setup_filename(dir, d_name, 1, &amp;fname);
<span class="p_add">+	if (retval == -ENOENT)</span>
<span class="p_add">+		return NULL;</span>
 	if (retval)
 		return ERR_PTR(retval);
 
<span class="p_chunk">@@ -3090,7 +3092,7 @@</span> <span class="p_context"> static int ext4_symlink(struct inode *dir,</span>
 		if (err)
 			return err;
 		if (!fscrypt_has_encryption_key(dir))
<span class="p_del">-			return -EPERM;</span>
<span class="p_add">+			return -ENOKEY;</span>
 		disk_link.len = (fscrypt_fname_encrypted_size(dir, len) +
 				 sizeof(struct fscrypt_symlink_data));
 		sd = kzalloc(disk_link.len, GFP_KERNEL);
<span class="p_header">diff --git a/fs/f2fs/dir.c b/fs/f2fs/dir.c</span>
<span class="p_header">index 11f3717ce481..8add4e8bab99 100644</span>
<span class="p_header">--- a/fs/f2fs/dir.c</span>
<span class="p_header">+++ b/fs/f2fs/dir.c</span>
<span class="p_chunk">@@ -277,7 +277,10 @@</span> <span class="p_context"> struct f2fs_dir_entry *f2fs_find_entry(struct inode *dir,</span>
 
 	err = fscrypt_setup_filename(dir, child, 1, &amp;fname);
 	if (err) {
<span class="p_del">-		*res_page = ERR_PTR(err);</span>
<span class="p_add">+		if (err == -ENOENT)</span>
<span class="p_add">+			*res_page = NULL;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			*res_page = ERR_PTR(err);</span>
 		return NULL;
 	}
 
<span class="p_header">diff --git a/fs/f2fs/namei.c b/fs/f2fs/namei.c</span>
<span class="p_header">index 08d7dc99042e..8556fe1ccb8a 100644</span>
<span class="p_header">--- a/fs/f2fs/namei.c</span>
<span class="p_header">+++ b/fs/f2fs/namei.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> static int f2fs_symlink(struct inode *dir, struct dentry *dentry,</span>
 			return err;
 
 		if (!fscrypt_has_encryption_key(dir))
<span class="p_del">-			return -EPERM;</span>
<span class="p_add">+			return -ENOKEY;</span>
 
 		disk_link.len = (fscrypt_fname_encrypted_size(dir, len) +
 				sizeof(struct fscrypt_symlink_data));
<span class="p_chunk">@@ -447,7 +447,7 @@</span> <span class="p_context"> static int f2fs_symlink(struct inode *dir, struct dentry *dentry,</span>
 			goto err_out;
 
 		if (!fscrypt_has_encryption_key(inode)) {
<span class="p_del">-			err = -EPERM;</span>
<span class="p_add">+			err = -ENOKEY;</span>
 			goto err_out;
 		}
 
<span class="p_header">diff --git a/fs/isofs/isofs.h b/fs/isofs/isofs.h</span>
<span class="p_header">index 0ac4c1f73fbd..25177e6bd603 100644</span>
<span class="p_header">--- a/fs/isofs/isofs.h</span>
<span class="p_header">+++ b/fs/isofs/isofs.h</span>
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> static inline unsigned int isonum_733(char *p)</span>
 	/* Ignore bigendian datum due to broken mastering programs */
 	return get_unaligned_le32(p);
 }
<span class="p_del">-extern int iso_date(char *, int);</span>
<span class="p_add">+extern int iso_date(u8 *, int);</span>
 
 struct inode;		/* To make gcc happy */
 
<span class="p_header">diff --git a/fs/isofs/rock.h b/fs/isofs/rock.h</span>
<span class="p_header">index ed09e2b08637..f835976ce033 100644</span>
<span class="p_header">--- a/fs/isofs/rock.h</span>
<span class="p_header">+++ b/fs/isofs/rock.h</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> struct RR_PL_s {</span>
 };
 
 struct stamp {
<span class="p_del">-	char time[7];</span>
<span class="p_add">+	__u8 time[7];		/* actually 6 unsigned, 1 signed */</span>
 } __attribute__ ((packed));
 
 struct RR_TF_s {
<span class="p_header">diff --git a/fs/isofs/util.c b/fs/isofs/util.c</span>
<span class="p_header">index 005a15cfd30a..37860fea364d 100644</span>
<span class="p_header">--- a/fs/isofs/util.c</span>
<span class="p_header">+++ b/fs/isofs/util.c</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"></span>
  * to GMT.  Thus  we should always be correct.
  */
 
<span class="p_del">-int iso_date(char * p, int flag)</span>
<span class="p_add">+int iso_date(u8 *p, int flag)</span>
 {
 	int year, month, day, hour, minute, second, tz;
 	int crtime;
<span class="p_header">diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c</span>
<span class="p_header">index fc4084ef4736..9d373247222c 100644</span>
<span class="p_header">--- a/fs/lockd/svc.c</span>
<span class="p_header">+++ b/fs/lockd/svc.c</span>
<span class="p_chunk">@@ -365,6 +365,7 @@</span> <span class="p_context"> static int lockd_start_svc(struct svc_serv *serv)</span>
 		printk(KERN_WARNING
 			&quot;lockd_up: svc_rqst allocation failed, error=%d\n&quot;,
 			error);
<span class="p_add">+		lockd_unregister_notifiers();</span>
 		goto out_rqst;
 	}
 
<span class="p_chunk">@@ -455,13 +456,16 @@</span> <span class="p_context"> int lockd_up(struct net *net)</span>
 	}
 
 	error = lockd_up_net(serv, net);
<span class="p_del">-	if (error &lt; 0)</span>
<span class="p_del">-		goto err_net;</span>
<span class="p_add">+	if (error &lt; 0) {</span>
<span class="p_add">+		lockd_unregister_notifiers();</span>
<span class="p_add">+		goto err_put;</span>
<span class="p_add">+	}</span>
 
 	error = lockd_start_svc(serv);
<span class="p_del">-	if (error &lt; 0)</span>
<span class="p_del">-		goto err_start;</span>
<span class="p_del">-</span>
<span class="p_add">+	if (error &lt; 0) {</span>
<span class="p_add">+		lockd_down_net(serv, net);</span>
<span class="p_add">+		goto err_put;</span>
<span class="p_add">+	}</span>
 	nlmsvc_users++;
 	/*
 	 * Note: svc_serv structures have an initial use count of 1,
<span class="p_chunk">@@ -472,12 +476,6 @@</span> <span class="p_context"> int lockd_up(struct net *net)</span>
 err_create:
 	mutex_unlock(&amp;nlmsvc_mutex);
 	return error;
<span class="p_del">-</span>
<span class="p_del">-err_start:</span>
<span class="p_del">-	lockd_down_net(serv, net);</span>
<span class="p_del">-err_net:</span>
<span class="p_del">-	lockd_unregister_notifiers();</span>
<span class="p_del">-	goto err_put;</span>
 }
 EXPORT_SYMBOL_GPL(lockd_up);
 
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index a53b8e0c896a..67845220fc27 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -256,15 +256,12 @@</span> <span class="p_context"> const u32 nfs4_fsinfo_bitmap[3] = { FATTR4_WORD0_MAXFILESIZE</span>
 };
 
 const u32 nfs4_fs_locations_bitmap[3] = {
<span class="p_del">-	FATTR4_WORD0_TYPE</span>
<span class="p_del">-	| FATTR4_WORD0_CHANGE</span>
<span class="p_add">+	FATTR4_WORD0_CHANGE</span>
 	| FATTR4_WORD0_SIZE
 	| FATTR4_WORD0_FSID
 	| FATTR4_WORD0_FILEID
 	| FATTR4_WORD0_FS_LOCATIONS,
<span class="p_del">-	FATTR4_WORD1_MODE</span>
<span class="p_del">-	| FATTR4_WORD1_NUMLINKS</span>
<span class="p_del">-	| FATTR4_WORD1_OWNER</span>
<span class="p_add">+	FATTR4_WORD1_OWNER</span>
 	| FATTR4_WORD1_OWNER_GROUP
 	| FATTR4_WORD1_RAWDEV
 	| FATTR4_WORD1_SPACE_USED
<span class="p_chunk">@@ -6678,9 +6675,7 @@</span> <span class="p_context"> static int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,</span>
 				   struct page *page)
 {
 	struct nfs_server *server = NFS_SERVER(dir);
<span class="p_del">-	u32 bitmask[3] = {</span>
<span class="p_del">-		[0] = FATTR4_WORD0_FSID | FATTR4_WORD0_FS_LOCATIONS,</span>
<span class="p_del">-	};</span>
<span class="p_add">+	u32 bitmask[3];</span>
 	struct nfs4_fs_locations_arg args = {
 		.dir_fh = NFS_FH(dir),
 		.name = name,
<span class="p_chunk">@@ -6699,12 +6694,15 @@</span> <span class="p_context"> static int _nfs4_proc_fs_locations(struct rpc_clnt *client, struct inode *dir,</span>
 
 	dprintk(&quot;%s: start\n&quot;, __func__);
 
<span class="p_add">+	bitmask[0] = nfs4_fattr_bitmap[0] | FATTR4_WORD0_FS_LOCATIONS;</span>
<span class="p_add">+	bitmask[1] = nfs4_fattr_bitmap[1];</span>
<span class="p_add">+</span>
 	/* Ask for the fileid of the absent filesystem if mounted_on_fileid
 	 * is not supported */
 	if (NFS_SERVER(dir)-&gt;attr_bitmask[1] &amp; FATTR4_WORD1_MOUNTED_ON_FILEID)
<span class="p_del">-		bitmask[1] |= FATTR4_WORD1_MOUNTED_ON_FILEID;</span>
<span class="p_add">+		bitmask[0] &amp;= ~FATTR4_WORD0_FILEID;</span>
 	else
<span class="p_del">-		bitmask[0] |= FATTR4_WORD0_FILEID;</span>
<span class="p_add">+		bitmask[1] &amp;= ~FATTR4_WORD1_MOUNTED_ON_FILEID;</span>
 
 	nfs_fattr_init(&amp;fs_locations-&gt;fattr);
 	fs_locations-&gt;server = server;
<span class="p_header">diff --git a/fs/nfs/nfs4trace.h b/fs/nfs/nfs4trace.h</span>
<span class="p_header">index cfb8f7ce5cf6..20cd8500452a 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4trace.h</span>
<span class="p_header">+++ b/fs/nfs/nfs4trace.h</span>
<span class="p_chunk">@@ -201,17 +201,13 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(nfs4_clientid_event,</span>
 		TP_ARGS(clp, error),
 
 		TP_STRUCT__entry(
<span class="p_del">-			__string(dstaddr,</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-					RPC_DISPLAY_ADDR))</span>
<span class="p_add">+			__string(dstaddr, clp-&gt;cl_hostname)</span>
 			__field(int, error)
 		),
 
 		TP_fast_assign(
 			__entry-&gt;error = error;
<span class="p_del">-			__assign_str(dstaddr,</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-						RPC_DISPLAY_ADDR));</span>
<span class="p_add">+			__assign_str(dstaddr, clp-&gt;cl_hostname);</span>
 		),
 
 		TP_printk(
<span class="p_chunk">@@ -1103,9 +1099,7 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(nfs4_inode_callback_event,</span>
 			__field(dev_t, dev)
 			__field(u32, fhandle)
 			__field(u64, fileid)
<span class="p_del">-			__string(dstaddr, clp ?</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-					RPC_DISPLAY_ADDR) : &quot;unknown&quot;)</span>
<span class="p_add">+			__string(dstaddr, clp ? clp-&gt;cl_hostname : &quot;unknown&quot;)</span>
 		),
 
 		TP_fast_assign(
<span class="p_chunk">@@ -1118,9 +1112,7 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(nfs4_inode_callback_event,</span>
 				__entry-&gt;fileid = 0;
 				__entry-&gt;dev = 0;
 			}
<span class="p_del">-			__assign_str(dstaddr, clp ?</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-					RPC_DISPLAY_ADDR) : &quot;unknown&quot;)</span>
<span class="p_add">+			__assign_str(dstaddr, clp ? clp-&gt;cl_hostname : &quot;unknown&quot;)</span>
 		),
 
 		TP_printk(
<span class="p_chunk">@@ -1162,9 +1154,7 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(nfs4_inode_stateid_callback_event,</span>
 			__field(dev_t, dev)
 			__field(u32, fhandle)
 			__field(u64, fileid)
<span class="p_del">-			__string(dstaddr, clp ?</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-					RPC_DISPLAY_ADDR) : &quot;unknown&quot;)</span>
<span class="p_add">+			__string(dstaddr, clp ? clp-&gt;cl_hostname : &quot;unknown&quot;)</span>
 			__field(int, stateid_seq)
 			__field(u32, stateid_hash)
 		),
<span class="p_chunk">@@ -1179,9 +1169,7 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(nfs4_inode_stateid_callback_event,</span>
 				__entry-&gt;fileid = 0;
 				__entry-&gt;dev = 0;
 			}
<span class="p_del">-			__assign_str(dstaddr, clp ?</span>
<span class="p_del">-				rpc_peeraddr2str(clp-&gt;cl_rpcclient,</span>
<span class="p_del">-					RPC_DISPLAY_ADDR) : &quot;unknown&quot;)</span>
<span class="p_add">+			__assign_str(dstaddr, clp ? clp-&gt;cl_hostname : &quot;unknown&quot;)</span>
 			__entry-&gt;stateid_seq =
 				be32_to_cpu(stateid-&gt;seqid);
 			__entry-&gt;stateid_hash =
<span class="p_header">diff --git a/fs/nfs/super.c b/fs/nfs/super.c</span>
<span class="p_header">index ddce94ce8142..51bf1f9ab287 100644</span>
<span class="p_header">--- a/fs/nfs/super.c</span>
<span class="p_header">+++ b/fs/nfs/super.c</span>
<span class="p_chunk">@@ -1339,7 +1339,7 @@</span> <span class="p_context"> static int nfs_parse_mount_options(char *raw,</span>
 			mnt-&gt;options |= NFS_OPTION_MIGRATION;
 			break;
 		case Opt_nomigration:
<span class="p_del">-			mnt-&gt;options &amp;= NFS_OPTION_MIGRATION;</span>
<span class="p_add">+			mnt-&gt;options &amp;= ~NFS_OPTION_MIGRATION;</span>
 			break;
 
 		/*
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index d35eb077330f..ec2a69dac536 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -3967,7 +3967,8 @@</span> <span class="p_context"> static struct nfs4_delegation *find_deleg_stateid(struct nfs4_client *cl, statei</span>
 {
 	struct nfs4_stid *ret;
 
<span class="p_del">-	ret = find_stateid_by_type(cl, s, NFS4_DELEG_STID);</span>
<span class="p_add">+	ret = find_stateid_by_type(cl, s,</span>
<span class="p_add">+				NFS4_DELEG_STID|NFS4_REVOKED_DELEG_STID);</span>
 	if (!ret)
 		return NULL;
 	return delegstateid(ret);
<span class="p_chunk">@@ -3990,6 +3991,12 @@</span> <span class="p_context"> nfs4_check_deleg(struct nfs4_client *cl, struct nfsd4_open *open,</span>
 	deleg = find_deleg_stateid(cl, &amp;open-&gt;op_delegate_stateid);
 	if (deleg == NULL)
 		goto out;
<span class="p_add">+	if (deleg-&gt;dl_stid.sc_type == NFS4_REVOKED_DELEG_STID) {</span>
<span class="p_add">+		nfs4_put_stid(&amp;deleg-&gt;dl_stid);</span>
<span class="p_add">+		if (cl-&gt;cl_minorversion)</span>
<span class="p_add">+			status = nfserr_deleg_revoked;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	flags = share_access_to_flags(open-&gt;op_share_access);
 	status = nfs4_check_delegmode(deleg, flags);
 	if (status) {
<span class="p_chunk">@@ -4858,6 +4865,16 @@</span> <span class="p_context"> nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,</span>
 		     struct nfs4_stid **s, struct nfsd_net *nn)
 {
 	__be32 status;
<span class="p_add">+	bool return_revoked = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *  only return revoked delegations if explicitly asked.</span>
<span class="p_add">+	 *  otherwise we report revoked or bad_stateid status.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (typemask &amp; NFS4_REVOKED_DELEG_STID)</span>
<span class="p_add">+		return_revoked = true;</span>
<span class="p_add">+	else if (typemask &amp; NFS4_DELEG_STID)</span>
<span class="p_add">+		typemask |= NFS4_REVOKED_DELEG_STID;</span>
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
 		return nfserr_bad_stateid;
<span class="p_chunk">@@ -4872,6 +4889,12 @@</span> <span class="p_context"> nfsd4_lookup_stateid(struct nfsd4_compound_state *cstate,</span>
 	*s = find_stateid_by_type(cstate-&gt;clp, stateid, typemask);
 	if (!*s)
 		return nfserr_bad_stateid;
<span class="p_add">+	if (((*s)-&gt;sc_type == NFS4_REVOKED_DELEG_STID) &amp;&amp; !return_revoked) {</span>
<span class="p_add">+		nfs4_put_stid(*s);</span>
<span class="p_add">+		if (cstate-&gt;minorversion)</span>
<span class="p_add">+			return nfserr_deleg_revoked;</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
<span class="p_add">+	}</span>
 	return nfs_ok;
 }
 
<span class="p_header">diff --git a/fs/nilfs2/segment.c b/fs/nilfs2/segment.c</span>
<span class="p_header">index 7d18d62e8e07..36362d4bc344 100644</span>
<span class="p_header">--- a/fs/nilfs2/segment.c</span>
<span class="p_header">+++ b/fs/nilfs2/segment.c</span>
<span class="p_chunk">@@ -1956,8 +1956,6 @@</span> <span class="p_context"> static int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,</span>
 					  err, ii-&gt;vfs_inode.i_ino);
 				return err;
 			}
<span class="p_del">-			mark_buffer_dirty(ibh);</span>
<span class="p_del">-			nilfs_mdt_mark_dirty(ifile);</span>
 			spin_lock(&amp;nilfs-&gt;ns_inode_lock);
 			if (likely(!ii-&gt;i_bh))
 				ii-&gt;i_bh = ibh;
<span class="p_chunk">@@ -1966,6 +1964,10 @@</span> <span class="p_context"> static int nilfs_segctor_collect_dirty_files(struct nilfs_sc_info *sci,</span>
 			goto retry;
 		}
 
<span class="p_add">+		// Always redirty the buffer to avoid race condition</span>
<span class="p_add">+		mark_buffer_dirty(ii-&gt;i_bh);</span>
<span class="p_add">+		nilfs_mdt_mark_dirty(ifile);</span>
<span class="p_add">+</span>
 		clear_bit(NILFS_I_QUEUED, &amp;ii-&gt;i_state);
 		set_bit(NILFS_I_BUSY, &amp;ii-&gt;i_state);
 		list_move_tail(&amp;ii-&gt;i_dirty, &amp;sci-&gt;sc_dirty_files);
<span class="p_header">diff --git a/include/trace/events/sunrpc.h b/include/trace/events/sunrpc.h</span>
<span class="p_header">index 8a707f8a41c3..8a13e3903839 100644</span>
<span class="p_header">--- a/include/trace/events/sunrpc.h</span>
<span class="p_header">+++ b/include/trace/events/sunrpc.h</span>
<span class="p_chunk">@@ -455,20 +455,22 @@</span> <span class="p_context"> TRACE_EVENT(svc_recv,</span>
 	TP_ARGS(rqst, status),
 
 	TP_STRUCT__entry(
<span class="p_del">-		__field(struct sockaddr *, addr)</span>
 		__field(__be32, xid)
 		__field(int, status)
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, rqst-&gt;rq_addrlen)</span>
 	),
 
 	TP_fast_assign(
<span class="p_del">-		__entry-&gt;addr = (struct sockaddr *)&amp;rqst-&gt;rq_addr;</span>
 		__entry-&gt;xid = status &gt; 0 ? rqst-&gt;rq_xid : 0;
 		__entry-&gt;status = status;
 		__entry-&gt;flags = rqst-&gt;rq_flags;
<span class="p_add">+		memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+			&amp;rqst-&gt;rq_addr, rqst-&gt;rq_addrlen);</span>
 	),
 
<span class="p_del">-	TP_printk(&quot;addr=%pIScp xid=0x%x status=%d flags=%s&quot;, __entry-&gt;addr,</span>
<span class="p_add">+	TP_printk(&quot;addr=%pIScp xid=0x%x status=%d flags=%s&quot;,</span>
<span class="p_add">+			(struct sockaddr *)__get_dynamic_array(addr),</span>
 			be32_to_cpu(__entry-&gt;xid), __entry-&gt;status,
 			show_rqstp_flags(__entry-&gt;flags))
 );
<span class="p_chunk">@@ -513,22 +515,23 @@</span> <span class="p_context"> DECLARE_EVENT_CLASS(svc_rqst_status,</span>
 	TP_ARGS(rqst, status),
 
 	TP_STRUCT__entry(
<span class="p_del">-		__field(struct sockaddr *, addr)</span>
 		__field(__be32, xid)
<span class="p_del">-		__field(int, dropme)</span>
 		__field(int, status)
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, rqst-&gt;rq_addrlen)</span>
 	),
 
 	TP_fast_assign(
<span class="p_del">-		__entry-&gt;addr = (struct sockaddr *)&amp;rqst-&gt;rq_addr;</span>
 		__entry-&gt;xid = rqst-&gt;rq_xid;
 		__entry-&gt;status = status;
 		__entry-&gt;flags = rqst-&gt;rq_flags;
<span class="p_add">+		memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+			&amp;rqst-&gt;rq_addr, rqst-&gt;rq_addrlen);</span>
 	),
 
 	TP_printk(&quot;addr=%pIScp rq_xid=0x%x status=%d flags=%s&quot;,
<span class="p_del">-		__entry-&gt;addr, be32_to_cpu(__entry-&gt;xid),</span>
<span class="p_add">+		(struct sockaddr *)__get_dynamic_array(addr),</span>
<span class="p_add">+		be32_to_cpu(__entry-&gt;xid),</span>
 		__entry-&gt;status, show_rqstp_flags(__entry-&gt;flags))
 );
 
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 78181c03d9c7..e5066955cc3a 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -507,8 +507,7 @@</span> <span class="p_context"> void resched_cpu(int cpu)</span>
 	struct rq *rq = cpu_rq(cpu);
 	unsigned long flags;
 
<span class="p_del">-	if (!raw_spin_trylock_irqsave(&amp;rq-&gt;lock, flags))</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
 	resched_curr(rq);
 	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);
 }
<span class="p_chunk">@@ -5878,6 +5877,12 @@</span> <span class="p_context"> static int init_rootdomain(struct root_domain *rd)</span>
 	if (!zalloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))
 		goto free_dlo_mask;
 
<span class="p_add">+#ifdef HAVE_RT_PUSH_IPI</span>
<span class="p_add">+	rd-&gt;rto_cpu = -1;</span>
<span class="p_add">+	raw_spin_lock_init(&amp;rd-&gt;rto_lock);</span>
<span class="p_add">+	init_irq_work(&amp;rd-&gt;rto_push_work, rto_push_irq_work_func);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	init_dl_bw(&amp;rd-&gt;dl_bw);
 	if (cpudl_init(&amp;rd-&gt;cpudl) != 0)
 		goto free_dlo_mask;
<span class="p_header">diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c</span>
<span class="p_header">index f139f22ce30d..9c131168d933 100644</span>
<span class="p_header">--- a/kernel/sched/rt.c</span>
<span class="p_header">+++ b/kernel/sched/rt.c</span>
<span class="p_chunk">@@ -72,10 +72,6 @@</span> <span class="p_context"> static void start_rt_bandwidth(struct rt_bandwidth *rt_b)</span>
 	raw_spin_unlock(&amp;rt_b-&gt;rt_runtime_lock);
 }
 
<span class="p_del">-#if defined(CONFIG_SMP) &amp;&amp; defined(HAVE_RT_PUSH_IPI)</span>
<span class="p_del">-static void push_irq_work_func(struct irq_work *work);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 void init_rt_rq(struct rt_rq *rt_rq)
 {
 	struct rt_prio_array *array;
<span class="p_chunk">@@ -95,13 +91,6 @@</span> <span class="p_context"> void init_rt_rq(struct rt_rq *rt_rq)</span>
 	rt_rq-&gt;rt_nr_migratory = 0;
 	rt_rq-&gt;overloaded = 0;
 	plist_head_init(&amp;rt_rq-&gt;pushable_tasks);
<span class="p_del">-</span>
<span class="p_del">-#ifdef HAVE_RT_PUSH_IPI</span>
<span class="p_del">-	rt_rq-&gt;push_flags = 0;</span>
<span class="p_del">-	rt_rq-&gt;push_cpu = nr_cpu_ids;</span>
<span class="p_del">-	raw_spin_lock_init(&amp;rt_rq-&gt;push_lock);</span>
<span class="p_del">-	init_irq_work(&amp;rt_rq-&gt;push_work, push_irq_work_func);</span>
<span class="p_del">-#endif</span>
 #endif /* CONFIG_SMP */
 	/* We start is dequeued state, because no RT tasks are queued */
 	rt_rq-&gt;rt_queued = 0;
<span class="p_chunk">@@ -1864,160 +1853,166 @@</span> <span class="p_context"> static void push_rt_tasks(struct rq *rq)</span>
 }
 
 #ifdef HAVE_RT_PUSH_IPI
<span class="p_add">+</span>
 /*
<span class="p_del">- * The search for the next cpu always starts at rq-&gt;cpu and ends</span>
<span class="p_del">- * when we reach rq-&gt;cpu again. It will never return rq-&gt;cpu.</span>
<span class="p_del">- * This returns the next cpu to check, or nr_cpu_ids if the loop</span>
<span class="p_del">- * is complete.</span>
<span class="p_add">+ * When a high priority task schedules out from a CPU and a lower priority</span>
<span class="p_add">+ * task is scheduled in, a check is made to see if there&#39;s any RT tasks</span>
<span class="p_add">+ * on other CPUs that are waiting to run because a higher priority RT task</span>
<span class="p_add">+ * is currently running on its CPU. In this case, the CPU with multiple RT</span>
<span class="p_add">+ * tasks queued on it (overloaded) needs to be notified that a CPU has opened</span>
<span class="p_add">+ * up that may be able to run one of its non-running queued RT tasks.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * All CPUs with overloaded RT tasks need to be notified as there is currently</span>
<span class="p_add">+ * no way to know which of these CPUs have the highest priority task waiting</span>
<span class="p_add">+ * to run. Instead of trying to take a spinlock on each of these CPUs,</span>
<span class="p_add">+ * which has shown to cause large latency when done on machines with many</span>
<span class="p_add">+ * CPUs, sending an IPI to the CPUs to have them push off the overloaded</span>
<span class="p_add">+ * RT tasks waiting to run.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Just sending an IPI to each of the CPUs is also an issue, as on large</span>
<span class="p_add">+ * count CPU machines, this can cause an IPI storm on a CPU, especially</span>
<span class="p_add">+ * if its the only CPU with multiple RT tasks queued, and a large number</span>
<span class="p_add">+ * of CPUs scheduling a lower priority task at the same time.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Each root domain has its own irq work function that can iterate over</span>
<span class="p_add">+ * all CPUs with RT overloaded tasks. Since all CPUs with overloaded RT</span>
<span class="p_add">+ * tassk must be checked if there&#39;s one or many CPUs that are lowering</span>
<span class="p_add">+ * their priority, there&#39;s a single irq work iterator that will try to</span>
<span class="p_add">+ * push off RT tasks that are waiting to run.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * When a CPU schedules a lower priority task, it will kick off the</span>
<span class="p_add">+ * irq work iterator that will jump to each CPU with overloaded RT tasks.</span>
<span class="p_add">+ * As it only takes the first CPU that schedules a lower priority task</span>
<span class="p_add">+ * to start the process, the rto_start variable is incremented and if</span>
<span class="p_add">+ * the atomic result is one, then that CPU will try to take the rto_lock.</span>
<span class="p_add">+ * This prevents high contention on the lock as the process handles all</span>
<span class="p_add">+ * CPUs scheduling lower priority tasks.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * All CPUs that are scheduling a lower priority task will increment the</span>
<span class="p_add">+ * rt_loop_next variable. This will make sure that the irq work iterator</span>
<span class="p_add">+ * checks all RT overloaded CPUs whenever a CPU schedules a new lower</span>
<span class="p_add">+ * priority task, even if the iterator is in the middle of a scan. Incrementing</span>
<span class="p_add">+ * the rt_loop_next will cause the iterator to perform another scan.</span>
  *
<span class="p_del">- * rq-&gt;rt.push_cpu holds the last cpu returned by this function,</span>
<span class="p_del">- * or if this is the first instance, it must hold rq-&gt;cpu.</span>
  */
 static int rto_next_cpu(struct rq *rq)
 {
<span class="p_del">-	int prev_cpu = rq-&gt;rt.push_cpu;</span>
<span class="p_add">+	struct root_domain *rd = rq-&gt;rd;</span>
<span class="p_add">+	int next;</span>
 	int cpu;
 
<span class="p_del">-	cpu = cpumask_next(prev_cpu, rq-&gt;rd-&gt;rto_mask);</span>
<span class="p_del">-</span>
 	/*
<span class="p_del">-	 * If the previous cpu is less than the rq&#39;s CPU, then it already</span>
<span class="p_del">-	 * passed the end of the mask, and has started from the beginning.</span>
<span class="p_del">-	 * We end if the next CPU is greater or equal to rq&#39;s CPU.</span>
<span class="p_add">+	 * When starting the IPI RT pushing, the rto_cpu is set to -1,</span>
<span class="p_add">+	 * rt_next_cpu() will simply return the first CPU found in</span>
<span class="p_add">+	 * the rto_mask.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If rto_next_cpu() is called with rto_cpu is a valid cpu, it</span>
<span class="p_add">+	 * will return the next CPU found in the rto_mask.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If there are no more CPUs left in the rto_mask, then a check is made</span>
<span class="p_add">+	 * against rto_loop and rto_loop_next. rto_loop is only updated with</span>
<span class="p_add">+	 * the rto_lock held, but any CPU may increment the rto_loop_next</span>
<span class="p_add">+	 * without any locking.</span>
 	 */
<span class="p_del">-	if (prev_cpu &lt; rq-&gt;cpu) {</span>
<span class="p_del">-		if (cpu &gt;= rq-&gt;cpu)</span>
<span class="p_del">-			return nr_cpu_ids;</span>
<span class="p_add">+	for (;;) {</span>
 
<span class="p_del">-	} else if (cpu &gt;= nr_cpu_ids) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We passed the end of the mask, start at the beginning.</span>
<span class="p_del">-		 * If the result is greater or equal to the rq&#39;s CPU, then</span>
<span class="p_del">-		 * the loop is finished.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		cpu = cpumask_first(rq-&gt;rd-&gt;rto_mask);</span>
<span class="p_del">-		if (cpu &gt;= rq-&gt;cpu)</span>
<span class="p_del">-			return nr_cpu_ids;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	rq-&gt;rt.push_cpu = cpu;</span>
<span class="p_add">+		/* When rto_cpu is -1 this acts like cpumask_first() */</span>
<span class="p_add">+		cpu = cpumask_next(rd-&gt;rto_cpu, rd-&gt;rto_mask);</span>
 
<span class="p_del">-	/* Return cpu to let the caller know if the loop is finished or not */</span>
<span class="p_del">-	return cpu;</span>
<span class="p_del">-}</span>
<span class="p_add">+		rd-&gt;rto_cpu = cpu;</span>
 
<span class="p_del">-static int find_next_push_cpu(struct rq *rq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rq *next_rq;</span>
<span class="p_del">-	int cpu;</span>
<span class="p_add">+		if (cpu &lt; nr_cpu_ids)</span>
<span class="p_add">+			return cpu;</span>
 
<span class="p_del">-	while (1) {</span>
<span class="p_del">-		cpu = rto_next_cpu(rq);</span>
<span class="p_del">-		if (cpu &gt;= nr_cpu_ids)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		next_rq = cpu_rq(cpu);</span>
<span class="p_add">+		rd-&gt;rto_cpu = -1;</span>
 
<span class="p_del">-		/* Make sure the next rq can push to this rq */</span>
<span class="p_del">-		if (next_rq-&gt;rt.highest_prio.next &lt; rq-&gt;rt.highest_prio.curr)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * ACQUIRE ensures we see the @rto_mask changes</span>
<span class="p_add">+		 * made prior to the @next value observed.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Matches WMB in rt_set_overload().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		next = atomic_read_acquire(&amp;rd-&gt;rto_loop_next);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (rd-&gt;rto_loop == next)</span>
 			break;
<span class="p_add">+</span>
<span class="p_add">+		rd-&gt;rto_loop = next;</span>
 	}
 
<span class="p_del">-	return cpu;</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool rto_start_trylock(atomic_t *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !atomic_cmpxchg_acquire(v, 0, 1);</span>
 }
 
<span class="p_del">-#define RT_PUSH_IPI_EXECUTING		1</span>
<span class="p_del">-#define RT_PUSH_IPI_RESTART		2</span>
<span class="p_add">+static inline void rto_start_unlock(atomic_t *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_set_release(v, 0);</span>
<span class="p_add">+}</span>
 
 static void tell_cpu_to_push(struct rq *rq)
 {
<span class="p_del">-	int cpu;</span>
<span class="p_add">+	int cpu = -1;</span>
 
<span class="p_del">-	if (rq-&gt;rt.push_flags &amp; RT_PUSH_IPI_EXECUTING) {</span>
<span class="p_del">-		raw_spin_lock(&amp;rq-&gt;rt.push_lock);</span>
<span class="p_del">-		/* Make sure it&#39;s still executing */</span>
<span class="p_del">-		if (rq-&gt;rt.push_flags &amp; RT_PUSH_IPI_EXECUTING) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Tell the IPI to restart the loop as things have</span>
<span class="p_del">-			 * changed since it started.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			rq-&gt;rt.push_flags |= RT_PUSH_IPI_RESTART;</span>
<span class="p_del">-			raw_spin_unlock(&amp;rq-&gt;rt.push_lock);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		raw_spin_unlock(&amp;rq-&gt;rt.push_lock);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Keep the loop going if the IPI is currently active */</span>
<span class="p_add">+	atomic_inc(&amp;rq-&gt;rd-&gt;rto_loop_next);</span>
 
<span class="p_del">-	/* When here, there&#39;s no IPI going around */</span>
<span class="p_del">-</span>
<span class="p_del">-	rq-&gt;rt.push_cpu = rq-&gt;cpu;</span>
<span class="p_del">-	cpu = find_next_push_cpu(rq);</span>
<span class="p_del">-	if (cpu &gt;= nr_cpu_ids)</span>
<span class="p_add">+	/* Only one CPU can initiate a loop at a time */</span>
<span class="p_add">+	if (!rto_start_trylock(&amp;rq-&gt;rd-&gt;rto_loop_start))</span>
 		return;
 
<span class="p_del">-	rq-&gt;rt.push_flags = RT_PUSH_IPI_EXECUTING;</span>
<span class="p_add">+	raw_spin_lock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The rto_cpu is updated under the lock, if it has a valid cpu</span>
<span class="p_add">+	 * then the IPI is still running and will continue due to the</span>
<span class="p_add">+	 * update to loop_next, and nothing needs to be done here.</span>
<span class="p_add">+	 * Otherwise it is finishing up and an ipi needs to be sent.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rq-&gt;rd-&gt;rto_cpu &lt; 0)</span>
<span class="p_add">+		cpu = rto_next_cpu(rq);</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_unlock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
 
<span class="p_del">-	irq_work_queue_on(&amp;rq-&gt;rt.push_work, cpu);</span>
<span class="p_add">+	rto_start_unlock(&amp;rq-&gt;rd-&gt;rto_loop_start);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpu &gt;= 0)</span>
<span class="p_add">+		irq_work_queue_on(&amp;rq-&gt;rd-&gt;rto_push_work, cpu);</span>
 }
 
 /* Called from hardirq context */
<span class="p_del">-static void try_to_push_tasks(void *arg)</span>
<span class="p_add">+void rto_push_irq_work_func(struct irq_work *work)</span>
 {
<span class="p_del">-	struct rt_rq *rt_rq = arg;</span>
<span class="p_del">-	struct rq *rq, *src_rq;</span>
<span class="p_del">-	int this_cpu;</span>
<span class="p_add">+	struct rq *rq;</span>
 	int cpu;
 
<span class="p_del">-	this_cpu = rt_rq-&gt;push_cpu;</span>
<span class="p_add">+	rq = this_rq();</span>
 
<span class="p_del">-	/* Paranoid check */</span>
<span class="p_del">-	BUG_ON(this_cpu != smp_processor_id());</span>
<span class="p_del">-</span>
<span class="p_del">-	rq = cpu_rq(this_cpu);</span>
<span class="p_del">-	src_rq = rq_of_rt_rq(rt_rq);</span>
<span class="p_del">-</span>
<span class="p_del">-again:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We do not need to grab the lock to check for has_pushable_tasks.</span>
<span class="p_add">+	 * When it gets updated, a check is made if a push is possible.</span>
<span class="p_add">+	 */</span>
 	if (has_pushable_tasks(rq)) {
 		raw_spin_lock(&amp;rq-&gt;lock);
<span class="p_del">-		push_rt_task(rq);</span>
<span class="p_add">+		push_rt_tasks(rq);</span>
 		raw_spin_unlock(&amp;rq-&gt;lock);
 	}
 
<span class="p_del">-	/* Pass the IPI to the next rt overloaded queue */</span>
<span class="p_del">-	raw_spin_lock(&amp;rt_rq-&gt;push_lock);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If the source queue changed since the IPI went out,</span>
<span class="p_del">-	 * we need to restart the search from that CPU again.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (rt_rq-&gt;push_flags &amp; RT_PUSH_IPI_RESTART) {</span>
<span class="p_del">-		rt_rq-&gt;push_flags &amp;= ~RT_PUSH_IPI_RESTART;</span>
<span class="p_del">-		rt_rq-&gt;push_cpu = src_rq-&gt;cpu;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	raw_spin_lock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
 
<span class="p_del">-	cpu = find_next_push_cpu(src_rq);</span>
<span class="p_add">+	/* Pass the IPI to the next rt overloaded queue */</span>
<span class="p_add">+	cpu = rto_next_cpu(rq);</span>
 
<span class="p_del">-	if (cpu &gt;= nr_cpu_ids)</span>
<span class="p_del">-		rt_rq-&gt;push_flags &amp;= ~RT_PUSH_IPI_EXECUTING;</span>
<span class="p_del">-	raw_spin_unlock(&amp;rt_rq-&gt;push_lock);</span>
<span class="p_add">+	raw_spin_unlock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
 
<span class="p_del">-	if (cpu &gt;= nr_cpu_ids)</span>
<span class="p_add">+	if (cpu &lt; 0)</span>
 		return;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * It is possible that a restart caused this CPU to be</span>
<span class="p_del">-	 * chosen again. Don&#39;t bother with an IPI, just see if we</span>
<span class="p_del">-	 * have more to push.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (unlikely(cpu == rq-&gt;cpu))</span>
<span class="p_del">-		goto again;</span>
<span class="p_del">-</span>
 	/* Try the next RT overloaded CPU */
<span class="p_del">-	irq_work_queue_on(&amp;rt_rq-&gt;push_work, cpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void push_irq_work_func(struct irq_work *work)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rt_rq *rt_rq = container_of(work, struct rt_rq, push_work);</span>
<span class="p_del">-</span>
<span class="p_del">-	try_to_push_tasks(rt_rq);</span>
<span class="p_add">+	irq_work_queue_on(&amp;rq-&gt;rd-&gt;rto_push_work, cpu);</span>
 }
 #endif /* HAVE_RT_PUSH_IPI */
 
<span class="p_header">diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h</span>
<span class="p_header">index ad77d666583c..cff985feb6e7 100644</span>
<span class="p_header">--- a/kernel/sched/sched.h</span>
<span class="p_header">+++ b/kernel/sched/sched.h</span>
<span class="p_chunk">@@ -463,7 +463,7 @@</span> <span class="p_context"> static inline int rt_bandwidth_enabled(void)</span>
 }
 
 /* RT IPI pull logic requires IRQ_WORK */
<span class="p_del">-#ifdef CONFIG_IRQ_WORK</span>
<span class="p_add">+#if defined(CONFIG_IRQ_WORK) &amp;&amp; defined(CONFIG_SMP)</span>
 # define HAVE_RT_PUSH_IPI
 #endif
 
<span class="p_chunk">@@ -485,12 +485,6 @@</span> <span class="p_context"> struct rt_rq {</span>
 	unsigned long rt_nr_total;
 	int overloaded;
 	struct plist_head pushable_tasks;
<span class="p_del">-#ifdef HAVE_RT_PUSH_IPI</span>
<span class="p_del">-	int push_flags;</span>
<span class="p_del">-	int push_cpu;</span>
<span class="p_del">-	struct irq_work push_work;</span>
<span class="p_del">-	raw_spinlock_t push_lock;</span>
<span class="p_del">-#endif</span>
 #endif /* CONFIG_SMP */
 	int rt_queued;
 
<span class="p_chunk">@@ -572,6 +566,19 @@</span> <span class="p_context"> struct root_domain {</span>
 	struct dl_bw dl_bw;
 	struct cpudl cpudl;
 
<span class="p_add">+#ifdef HAVE_RT_PUSH_IPI</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For IPI pull requests, loop across the rto_mask.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct irq_work rto_push_work;</span>
<span class="p_add">+	raw_spinlock_t rto_lock;</span>
<span class="p_add">+	/* These are only updated and read within rto_lock */</span>
<span class="p_add">+	int rto_loop;</span>
<span class="p_add">+	int rto_cpu;</span>
<span class="p_add">+	/* These atomics are updated outside of a lock */</span>
<span class="p_add">+	atomic_t rto_loop_next;</span>
<span class="p_add">+	atomic_t rto_loop_start;</span>
<span class="p_add">+#endif</span>
 	/*
 	 * The &quot;RT overload&quot; flag: it gets set if a CPU has more than
 	 * one runnable RT task.
<span class="p_chunk">@@ -584,6 +591,9 @@</span> <span class="p_context"> struct root_domain {</span>
 
 extern struct root_domain def_root_domain;
 
<span class="p_add">+#ifdef HAVE_RT_PUSH_IPI</span>
<span class="p_add">+extern void rto_push_irq_work_func(struct irq_work *work);</span>
<span class="p_add">+#endif</span>
 #endif /* CONFIG_SMP */
 
 /*
<span class="p_header">diff --git a/lib/mpi/mpi-pow.c b/lib/mpi/mpi-pow.c</span>
<span class="p_header">index e24388a863a7..468fb7cd1221 100644</span>
<span class="p_header">--- a/lib/mpi/mpi-pow.c</span>
<span class="p_header">+++ b/lib/mpi/mpi-pow.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
  *	 however I decided to publish this code under the plain GPL.
  */
 
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
 #include &lt;linux/string.h&gt;
 #include &quot;mpi-internal.h&quot;
 #include &quot;longlong.h&quot;
<span class="p_chunk">@@ -256,6 +257,7 @@</span> <span class="p_context"> int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)</span>
 				}
 				e &lt;&lt;= 1;
 				c--;
<span class="p_add">+				cond_resched();</span>
 			}
 
 			i--;
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index cf129fec7329..1fd60190177e 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -749,8 +749,7 @@</span> <span class="p_context"> p9_client_rpc(struct p9_client *c, int8_t type, const char *fmt, ...)</span>
 	}
 again:
 	/* Wait for the response */
<span class="p_del">-	err = wait_event_interruptible(*req-&gt;wq,</span>
<span class="p_del">-				       req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
<span class="p_add">+	err = wait_event_killable(*req-&gt;wq, req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
 
 	/*
 	 * Make sure our req is coherent with regard to updates in other
<span class="p_header">diff --git a/net/9p/trans_virtio.c b/net/9p/trans_virtio.c</span>
<span class="p_header">index f24b25c25106..f3a4efcf1456 100644</span>
<span class="p_header">--- a/net/9p/trans_virtio.c</span>
<span class="p_header">+++ b/net/9p/trans_virtio.c</span>
<span class="p_chunk">@@ -286,8 +286,8 @@</span> <span class="p_context"> p9_virtio_request(struct p9_client *client, struct p9_req_t *req)</span>
 		if (err == -ENOSPC) {
 			chan-&gt;ring_bufs_avail = 0;
 			spin_unlock_irqrestore(&amp;chan-&gt;lock, flags);
<span class="p_del">-			err = wait_event_interruptible(*chan-&gt;vc_wq,</span>
<span class="p_del">-							chan-&gt;ring_bufs_avail);</span>
<span class="p_add">+			err = wait_event_killable(*chan-&gt;vc_wq,</span>
<span class="p_add">+						  chan-&gt;ring_bufs_avail);</span>
 			if (err  == -ERESTARTSYS)
 				return err;
 
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> static int p9_get_mapped_pages(struct virtio_chan *chan,</span>
 		 * Other zc request to finish here
 		 */
 		if (atomic_read(&amp;vp_pinned) &gt;= chan-&gt;p9_max_pages) {
<span class="p_del">-			err = wait_event_interruptible(vp_wq,</span>
<span class="p_add">+			err = wait_event_killable(vp_wq,</span>
 			      (atomic_read(&amp;vp_pinned) &lt; chan-&gt;p9_max_pages));
 			if (err == -ERESTARTSYS)
 				return err;
<span class="p_chunk">@@ -471,8 +471,8 @@</span> <span class="p_context"> p9_virtio_zc_request(struct p9_client *client, struct p9_req_t *req,</span>
 		if (err == -ENOSPC) {
 			chan-&gt;ring_bufs_avail = 0;
 			spin_unlock_irqrestore(&amp;chan-&gt;lock, flags);
<span class="p_del">-			err = wait_event_interruptible(*chan-&gt;vc_wq,</span>
<span class="p_del">-						       chan-&gt;ring_bufs_avail);</span>
<span class="p_add">+			err = wait_event_killable(*chan-&gt;vc_wq,</span>
<span class="p_add">+						  chan-&gt;ring_bufs_avail);</span>
 			if (err  == -ERESTARTSYS)
 				goto err_out;
 
<span class="p_chunk">@@ -489,8 +489,7 @@</span> <span class="p_context"> p9_virtio_zc_request(struct p9_client *client, struct p9_req_t *req,</span>
 	virtqueue_kick(chan-&gt;vq);
 	spin_unlock_irqrestore(&amp;chan-&gt;lock, flags);
 	p9_debug(P9_DEBUG_TRANS, &quot;virtio request kicked\n&quot;);
<span class="p_del">-	err = wait_event_interruptible(*req-&gt;wq,</span>
<span class="p_del">-				       req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
<span class="p_add">+	err = wait_event_killable(*req-&gt;wq, req-&gt;status &gt;= REQ_STATUS_RCVD);</span>
 	/*
 	 * Non kernel buffers are pinned, unpin them
 	 */
<span class="p_header">diff --git a/net/ceph/crypto.c b/net/ceph/crypto.c</span>
<span class="p_header">index 292e33bd916e..5f3a627afcc6 100644</span>
<span class="p_header">--- a/net/ceph/crypto.c</span>
<span class="p_header">+++ b/net/ceph/crypto.c</span>
<span class="p_chunk">@@ -34,7 +34,9 @@</span> <span class="p_context"> static int set_secret(struct ceph_crypto_key *key, void *buf)</span>
 		return -ENOTSUPP;
 	}
 
<span class="p_del">-	WARN_ON(!key-&gt;len);</span>
<span class="p_add">+	if (!key-&gt;len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	key-&gt;key = kmemdup(buf, key-&gt;len, GFP_NOIO);
 	if (!key-&gt;key) {
 		ret = -ENOMEM;
<span class="p_header">diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c</span>
<span class="p_header">index 4d37bdcbc2d5..551dd393ceec 100644</span>
<span class="p_header">--- a/net/ipv4/ip_sockglue.c</span>
<span class="p_header">+++ b/net/ipv4/ip_sockglue.c</span>
<span class="p_chunk">@@ -819,6 +819,7 @@</span> <span class="p_context"> static int do_ip_setsockopt(struct sock *sk, int level,</span>
 	{
 		struct ip_mreqn mreq;
 		struct net_device *dev = NULL;
<span class="p_add">+		int midx;</span>
 
 		if (sk-&gt;sk_type == SOCK_STREAM)
 			goto e_inval;
<span class="p_chunk">@@ -863,11 +864,15 @@</span> <span class="p_context"> static int do_ip_setsockopt(struct sock *sk, int level,</span>
 		err = -EADDRNOTAVAIL;
 		if (!dev)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		midx = l3mdev_master_ifindex(dev);</span>
<span class="p_add">+</span>
 		dev_put(dev);
 
 		err = -EINVAL;
 		if (sk-&gt;sk_bound_dev_if &amp;&amp;
<span class="p_del">-		    mreq.imr_ifindex != sk-&gt;sk_bound_dev_if)</span>
<span class="p_add">+		    mreq.imr_ifindex != sk-&gt;sk_bound_dev_if &amp;&amp;</span>
<span class="p_add">+		    (!midx || midx != sk-&gt;sk_bound_dev_if))</span>
 			break;
 
 		inet-&gt;mc_index = mreq.imr_ifindex;
<span class="p_header">diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">index 636ec56f5f50..38bee173dc2b 100644</span>
<span class="p_header">--- a/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">+++ b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_chunk">@@ -585,16 +585,24 @@</span> <span class="p_context"> static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,</span>
 
 		if (val) {
 			struct net_device *dev;
<span class="p_add">+			int midx;</span>
 
<span class="p_del">-			if (sk-&gt;sk_bound_dev_if &amp;&amp; sk-&gt;sk_bound_dev_if != val)</span>
<span class="p_del">-				goto e_inval;</span>
<span class="p_add">+			rcu_read_lock();</span>
 
<span class="p_del">-			dev = dev_get_by_index(net, val);</span>
<span class="p_add">+			dev = dev_get_by_index_rcu(net, val);</span>
 			if (!dev) {
<span class="p_add">+				rcu_read_unlock();</span>
 				retv = -ENODEV;
 				break;
 			}
<span class="p_del">-			dev_put(dev);</span>
<span class="p_add">+			midx = l3mdev_master_ifindex_rcu(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+			rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+			if (sk-&gt;sk_bound_dev_if &amp;&amp;</span>
<span class="p_add">+			    sk-&gt;sk_bound_dev_if != val &amp;&amp;</span>
<span class="p_add">+			    (!midx || midx != sk-&gt;sk_bound_dev_if))</span>
<span class="p_add">+				goto e_inval;</span>
 		}
 		np-&gt;mcast_oif = val;
 		retv = 0;
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 61729641e027..6e8bacb0b458 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -3495,7 +3495,11 @@</span> <span class="p_context"> static int ip6_route_dev_notify(struct notifier_block *this,</span>
 		net-&gt;ipv6.ip6_blk_hole_entry-&gt;dst.dev = dev;
 		net-&gt;ipv6.ip6_blk_hole_entry-&gt;rt6i_idev = in6_dev_get(dev);
 #endif
<span class="p_del">-	 } else if (event == NETDEV_UNREGISTER) {</span>
<span class="p_add">+	 } else if (event == NETDEV_UNREGISTER &amp;&amp;</span>
<span class="p_add">+		    dev-&gt;reg_state != NETREG_UNREGISTERED) {</span>
<span class="p_add">+		/* NETDEV_UNREGISTER could be fired for multiple times by</span>
<span class="p_add">+		 * netdev_wait_allrefs(). Make sure we only call this once.</span>
<span class="p_add">+		 */</span>
 		in6_dev_put(net-&gt;ipv6.ip6_null_entry-&gt;rt6i_idev);
 #ifdef CONFIG_IPV6_MULTIPLE_TABLES
 		in6_dev_put(net-&gt;ipv6.ip6_prohibit_entry-&gt;rt6i_idev);
<span class="p_header">diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h</span>
<span class="p_header">index 34c2add2c455..03dbc6bd8598 100644</span>
<span class="p_header">--- a/net/mac80211/ieee80211_i.h</span>
<span class="p_header">+++ b/net/mac80211/ieee80211_i.h</span>
<span class="p_chunk">@@ -681,7 +681,6 @@</span> <span class="p_context"> struct ieee80211_if_mesh {</span>
 	const struct ieee80211_mesh_sync_ops *sync_ops;
 	s64 sync_offset_clockdrift_max;
 	spinlock_t sync_offset_lock;
<span class="p_del">-	bool adjusting_tbtt;</span>
 	/* mesh power save */
 	enum nl80211_mesh_power_mode nonpeer_pm;
 	int ps_peers_light_sleep;
<span class="p_header">diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c</span>
<span class="p_header">index 50e1b7f78bd4..5c67a696e046 100644</span>
<span class="p_header">--- a/net/mac80211/mesh.c</span>
<span class="p_header">+++ b/net/mac80211/mesh.c</span>
<span class="p_chunk">@@ -279,8 +279,6 @@</span> <span class="p_context"> int mesh_add_meshconf_ie(struct ieee80211_sub_if_data *sdata,</span>
 	/* Mesh PS mode. See IEEE802.11-2012 8.4.2.100.8 */
 	*pos |= ifmsh-&gt;ps_peers_deep_sleep ?
 			IEEE80211_MESHCONF_CAPAB_POWER_SAVE_LEVEL : 0x00;
<span class="p_del">-	*pos++ |= ifmsh-&gt;adjusting_tbtt ?</span>
<span class="p_del">-			IEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING : 0x00;</span>
 	*pos++ = 0x00;
 
 	return 0;
<span class="p_chunk">@@ -850,7 +848,6 @@</span> <span class="p_context"> int ieee80211_start_mesh(struct ieee80211_sub_if_data *sdata)</span>
 	ifmsh-&gt;mesh_cc_id = 0;	/* Disabled */
 	/* register sync ops from extensible synchronization framework */
 	ifmsh-&gt;sync_ops = ieee80211_mesh_sync_ops_get(ifmsh-&gt;mesh_sp_id);
<span class="p_del">-	ifmsh-&gt;adjusting_tbtt = false;</span>
 	ifmsh-&gt;sync_offset_clockdrift_max = 0;
 	set_bit(MESH_WORK_HOUSEKEEPING, &amp;ifmsh-&gt;wrkq_flags);
 	ieee80211_mesh_root_setup(ifmsh);
<span class="p_header">diff --git a/net/mac80211/mesh_plink.c b/net/mac80211/mesh_plink.c</span>
<span class="p_header">index 7fcdcf622655..fcba70e57073 100644</span>
<span class="p_header">--- a/net/mac80211/mesh_plink.c</span>
<span class="p_header">+++ b/net/mac80211/mesh_plink.c</span>
<span class="p_chunk">@@ -505,12 +505,14 @@</span> <span class="p_context"> mesh_sta_info_alloc(struct ieee80211_sub_if_data *sdata, u8 *addr,</span>
 
 	/* Userspace handles station allocation */
 	if (sdata-&gt;u.mesh.user_mpm ||
<span class="p_del">-	    sdata-&gt;u.mesh.security &amp; IEEE80211_MESH_SEC_AUTHED)</span>
<span class="p_del">-		cfg80211_notify_new_peer_candidate(sdata-&gt;dev, addr,</span>
<span class="p_del">-						   elems-&gt;ie_start,</span>
<span class="p_del">-						   elems-&gt;total_len,</span>
<span class="p_del">-						   GFP_KERNEL);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	    sdata-&gt;u.mesh.security &amp; IEEE80211_MESH_SEC_AUTHED) {</span>
<span class="p_add">+		if (mesh_peer_accepts_plinks(elems) &amp;&amp;</span>
<span class="p_add">+		    mesh_plink_availables(sdata))</span>
<span class="p_add">+			cfg80211_notify_new_peer_candidate(sdata-&gt;dev, addr,</span>
<span class="p_add">+							   elems-&gt;ie_start,</span>
<span class="p_add">+							   elems-&gt;total_len,</span>
<span class="p_add">+							   GFP_KERNEL);</span>
<span class="p_add">+	} else</span>
 		sta = __mesh_sta_info_alloc(sdata, addr);
 
 	return sta;
<span class="p_header">diff --git a/net/mac80211/mesh_sync.c b/net/mac80211/mesh_sync.c</span>
<span class="p_header">index faca22cd02b5..75608c07dc7b 100644</span>
<span class="p_header">--- a/net/mac80211/mesh_sync.c</span>
<span class="p_header">+++ b/net/mac80211/mesh_sync.c</span>
<span class="p_chunk">@@ -123,7 +123,6 @@</span> <span class="p_context"> static void mesh_sync_offset_rx_bcn_presp(struct ieee80211_sub_if_data *sdata,</span>
 	 */
 
 	if (elems-&gt;mesh_config &amp;&amp; mesh_peer_tbtt_adjusting(elems)) {
<span class="p_del">-		clear_sta_flag(sta, WLAN_STA_TOFFSET_KNOWN);</span>
 		msync_dbg(sdata, &quot;STA %pM : is adjusting TBTT\n&quot;,
 			  sta-&gt;sta.addr);
 		goto no_sync;
<span class="p_chunk">@@ -172,11 +171,9 @@</span> <span class="p_context"> static void mesh_sync_offset_adjust_tbtt(struct ieee80211_sub_if_data *sdata,</span>
 					 struct beacon_data *beacon)
 {
 	struct ieee80211_if_mesh *ifmsh = &amp;sdata-&gt;u.mesh;
<span class="p_del">-	u8 cap;</span>
 
 	WARN_ON(ifmsh-&gt;mesh_sp_id != IEEE80211_SYNC_METHOD_NEIGHBOR_OFFSET);
 	WARN_ON(!rcu_read_lock_held());
<span class="p_del">-	cap = beacon-&gt;meshconf-&gt;meshconf_cap;</span>
 
 	spin_lock_bh(&amp;ifmsh-&gt;sync_offset_lock);
 
<span class="p_chunk">@@ -190,21 +187,13 @@</span> <span class="p_context"> static void mesh_sync_offset_adjust_tbtt(struct ieee80211_sub_if_data *sdata,</span>
 			  &quot;TBTT : kicking off TBTT adjustment with clockdrift_max=%lld\n&quot;,
 			  ifmsh-&gt;sync_offset_clockdrift_max);
 		set_bit(MESH_WORK_DRIFT_ADJUST, &amp;ifmsh-&gt;wrkq_flags);
<span class="p_del">-</span>
<span class="p_del">-		ifmsh-&gt;adjusting_tbtt = true;</span>
 	} else {
 		msync_dbg(sdata,
 			  &quot;TBTT : max clockdrift=%lld; too small to adjust\n&quot;,
 			  (long long)ifmsh-&gt;sync_offset_clockdrift_max);
 		ifmsh-&gt;sync_offset_clockdrift_max = 0;
<span class="p_del">-</span>
<span class="p_del">-		ifmsh-&gt;adjusting_tbtt = false;</span>
 	}
 	spin_unlock_bh(&amp;ifmsh-&gt;sync_offset_lock);
<span class="p_del">-</span>
<span class="p_del">-	beacon-&gt;meshconf-&gt;meshconf_cap = ifmsh-&gt;adjusting_tbtt ?</span>
<span class="p_del">-			IEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING | cap :</span>
<span class="p_del">-			~IEEE80211_MESHCONF_CAPAB_TBTT_ADJUSTING &amp; cap;</span>
 }
 
 static const struct sync_method sync_methods[] = {
<span class="p_header">diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c</span>
<span class="p_header">index 778fcdb83225..fa3ef25441e5 100644</span>
<span class="p_header">--- a/net/netfilter/nf_tables_api.c</span>
<span class="p_header">+++ b/net/netfilter/nf_tables_api.c</span>
<span class="p_chunk">@@ -2068,7 +2068,7 @@</span> <span class="p_context"> static void nf_tables_rule_destroy(const struct nft_ctx *ctx,</span>
 	 * is called on error from nf_tables_newrule().
 	 */
 	expr = nft_expr_first(rule);
<span class="p_del">-	while (expr-&gt;ops &amp;&amp; expr != nft_expr_last(rule)) {</span>
<span class="p_add">+	while (expr != nft_expr_last(rule) &amp;&amp; expr-&gt;ops) {</span>
 		nf_tables_expr_destroy(ctx, expr);
 		expr = nft_expr_next(expr);
 	}
<span class="p_header">diff --git a/net/netfilter/nft_queue.c b/net/netfilter/nft_queue.c</span>
<span class="p_header">index 393d359a1889..ef4768a451f4 100644</span>
<span class="p_header">--- a/net/netfilter/nft_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nft_queue.c</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static void nft_queue_eval(const struct nft_expr *expr,</span>
 
 	if (priv-&gt;queues_total &gt; 1) {
 		if (priv-&gt;flags &amp; NFT_QUEUE_FLAG_CPU_FANOUT) {
<span class="p_del">-			int cpu = smp_processor_id();</span>
<span class="p_add">+			int cpu = raw_smp_processor_id();</span>
 
 			queue = priv-&gt;queuenum + cpu % priv-&gt;queues_total;
 		} else {
<span class="p_header">diff --git a/net/nfc/core.c b/net/nfc/core.c</span>
<span class="p_header">index 5cf33df888c3..c699d64a0753 100644</span>
<span class="p_header">--- a/net/nfc/core.c</span>
<span class="p_header">+++ b/net/nfc/core.c</span>
<span class="p_chunk">@@ -1106,7 +1106,7 @@</span> <span class="p_context"> struct nfc_dev *nfc_allocate_device(struct nfc_ops *ops,</span>
 err_free_dev:
 	kfree(dev);
 
<span class="p_del">-	return ERR_PTR(rc);</span>
<span class="p_add">+	return NULL;</span>
 }
 EXPORT_SYMBOL(nfc_allocate_device);
 
<span class="p_header">diff --git a/net/rds/ib_frmr.c b/net/rds/ib_frmr.c</span>
<span class="p_header">index d921adc62765..66b3d6228a15 100644</span>
<span class="p_header">--- a/net/rds/ib_frmr.c</span>
<span class="p_header">+++ b/net/rds/ib_frmr.c</span>
<span class="p_chunk">@@ -104,14 +104,15 @@</span> <span class="p_context"> static int rds_ib_post_reg_frmr(struct rds_ib_mr *ibmr)</span>
 	struct rds_ib_frmr *frmr = &amp;ibmr-&gt;u.frmr;
 	struct ib_send_wr *failed_wr;
 	struct ib_reg_wr reg_wr;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, off = 0;</span>
 
 	while (atomic_dec_return(&amp;ibmr-&gt;ic-&gt;i_fastreg_wrs) &lt;= 0) {
 		atomic_inc(&amp;ibmr-&gt;ic-&gt;i_fastreg_wrs);
 		cpu_relax();
 	}
 
<span class="p_del">-	ret = ib_map_mr_sg_zbva(frmr-&gt;mr, ibmr-&gt;sg, ibmr-&gt;sg_len, 0, PAGE_SIZE);</span>
<span class="p_add">+	ret = ib_map_mr_sg_zbva(frmr-&gt;mr, ibmr-&gt;sg, ibmr-&gt;sg_len,</span>
<span class="p_add">+				&amp;off, PAGE_SIZE);</span>
 	if (unlikely(ret != ibmr-&gt;sg_len))
 		return ret &lt; 0 ? ret : -EINVAL;
 
<span class="p_header">diff --git a/net/rds/rdma.c b/net/rds/rdma.c</span>
<span class="p_header">index 8d3a851a3476..60e90f761838 100644</span>
<span class="p_header">--- a/net/rds/rdma.c</span>
<span class="p_header">+++ b/net/rds/rdma.c</span>
<span class="p_chunk">@@ -40,7 +40,6 @@</span> <span class="p_context"></span>
 /*
  * XXX
  *  - build with sparse
<span class="p_del">- *  - should we limit the size of a mr region?  let transport return failure?</span>
  *  - should we detect duplicate keys on a socket?  hmm.
  *  - an rdma is an mlock, apply rlimit?
  */
<span class="p_chunk">@@ -200,6 +199,14 @@</span> <span class="p_context"> static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,</span>
 		goto out;
 	}
 
<span class="p_add">+	/* Restrict the size of mr irrespective of underlying transport</span>
<span class="p_add">+	 * To account for unaligned mr regions, subtract one from nr_pages</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((nr_pages - 1) &gt; (RDS_MAX_MSG_SIZE &gt;&gt; PAGE_SHIFT)) {</span>
<span class="p_add">+		ret = -EMSGSIZE;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rdsdebug(&quot;RDS: get_mr addr %llx len %llu nr_pages %u\n&quot;,
 		args-&gt;vec.addr, args-&gt;vec.bytes, nr_pages);
 
<span class="p_header">diff --git a/net/rds/rds.h b/net/rds/rds.h</span>
<span class="p_header">index f107a968ddff..30a51fec0f63 100644</span>
<span class="p_header">--- a/net/rds/rds.h</span>
<span class="p_header">+++ b/net/rds/rds.h</span>
<span class="p_chunk">@@ -50,6 +50,9 @@</span> <span class="p_context"> void rdsdebug(char *fmt, ...)</span>
 #define RDS_FRAG_SHIFT	12
 #define RDS_FRAG_SIZE	((unsigned int)(1 &lt;&lt; RDS_FRAG_SHIFT))
 
<span class="p_add">+/* Used to limit both RDMA and non-RDMA RDS message to 1MB */</span>
<span class="p_add">+#define RDS_MAX_MSG_SIZE	((unsigned int)(1 &lt;&lt; 20))</span>
<span class="p_add">+</span>
 #define RDS_CONG_MAP_BYTES	(65536 / 8)
 #define RDS_CONG_MAP_PAGES	(PAGE_ALIGN(RDS_CONG_MAP_BYTES) / PAGE_SIZE)
 #define RDS_CONG_MAP_PAGE_BITS	(PAGE_SIZE * 8)
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index f28651b6ae83..ad247dc71ebb 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -946,6 +946,11 @@</span> <span class="p_context"> static int rds_cmsg_send(struct rds_sock *rs, struct rds_message *rm,</span>
 			ret = rds_cmsg_rdma_map(rs, rm, cmsg);
 			if (!ret)
 				*allocated_mr = 1;
<span class="p_add">+			else if (ret == -ENODEV)</span>
<span class="p_add">+				/* Accommodate the get_mr() case which can fail</span>
<span class="p_add">+				 * if connection isn&#39;t established yet.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				ret = -EAGAIN;</span>
 			break;
 		case RDS_CMSG_ATOMIC_CSWP:
 		case RDS_CMSG_ATOMIC_FADD:
<span class="p_chunk">@@ -988,6 +993,26 @@</span> <span class="p_context"> static int rds_send_mprds_hash(struct rds_sock *rs, struct rds_connection *conn)</span>
 	return hash;
 }
 
<span class="p_add">+static int rds_rdma_bytes(struct msghdr *msg, size_t *rdma_bytes)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rds_rdma_args *args;</span>
<span class="p_add">+	struct cmsghdr *cmsg;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_cmsghdr(cmsg, msg) {</span>
<span class="p_add">+		if (!CMSG_OK(msg, cmsg))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (cmsg-&gt;cmsg_level != SOL_RDS)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (cmsg-&gt;cmsg_type == RDS_CMSG_RDMA_ARGS) {</span>
<span class="p_add">+			args = CMSG_DATA(cmsg);</span>
<span class="p_add">+			*rdma_bytes += args-&gt;remote_vec.bytes;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
 {
 	struct sock *sk = sock-&gt;sk;
<span class="p_chunk">@@ -1002,6 +1027,7 @@</span> <span class="p_context"> int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)</span>
 	int nonblock = msg-&gt;msg_flags &amp; MSG_DONTWAIT;
 	long timeo = sock_sndtimeo(sk, nonblock);
 	struct rds_conn_path *cpath;
<span class="p_add">+	size_t total_payload_len = payload_len, rdma_payload_len = 0;</span>
 
 	/* Mirror Linux UDP mirror of BSD error message compatibility */
 	/* XXX: Perhaps MSG_MORE someday */
<span class="p_chunk">@@ -1034,6 +1060,16 @@</span> <span class="p_context"> int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)</span>
 	}
 	release_sock(sk);
 
<span class="p_add">+	ret = rds_rdma_bytes(msg, &amp;rdma_payload_len);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	total_payload_len += rdma_payload_len;</span>
<span class="p_add">+	if (max_t(size_t, payload_len, rdma_payload_len) &gt; RDS_MAX_MSG_SIZE) {</span>
<span class="p_add">+		ret = -EMSGSIZE;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (payload_len &gt; rds_sk_sndbuf(rs)) {
 		ret = -EMSGSIZE;
 		goto out;
<span class="p_chunk">@@ -1083,8 +1119,12 @@</span> <span class="p_context"> int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)</span>
 
 	/* Parse any control messages the user may have included. */
 	ret = rds_cmsg_send(rs, rm, msg, &amp;allocated_mr);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		/* Trigger connection so that its ready for the next retry */</span>
<span class="p_add">+		if (ret ==  -EAGAIN)</span>
<span class="p_add">+			rds_conn_connect_if_down(conn);</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	if (rm-&gt;rdma.op_active &amp;&amp; !conn-&gt;c_trans-&gt;xmit_rdma) {
 		printk_ratelimited(KERN_NOTICE &quot;rdma_op %p conn xmit_rdma %p\n&quot;,
<span class="p_header">diff --git a/net/vmw_vsock/af_vsock.c b/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">index 8a398b3fb532..2f633eec6b7a 100644</span>
<span class="p_header">--- a/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">+++ b/net/vmw_vsock/af_vsock.c</span>
<span class="p_chunk">@@ -1524,8 +1524,7 @@</span> <span class="p_context"> static int vsock_stream_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 	long timeout;
 	int err;
 	struct vsock_transport_send_notify_data send_data;
<span class="p_del">-</span>
<span class="p_del">-	DEFINE_WAIT(wait);</span>
<span class="p_add">+	DEFINE_WAIT_FUNC(wait, woken_wake_function);</span>
 
 	sk = sock-&gt;sk;
 	vsk = vsock_sk(sk);
<span class="p_chunk">@@ -1568,11 +1567,10 @@</span> <span class="p_context"> static int vsock_stream_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 	if (err &lt; 0)
 		goto out;
 
<span class="p_del">-</span>
 	while (total_written &lt; len) {
 		ssize_t written;
 
<span class="p_del">-		prepare_to_wait(sk_sleep(sk), &amp;wait, TASK_INTERRUPTIBLE);</span>
<span class="p_add">+		add_wait_queue(sk_sleep(sk), &amp;wait);</span>
 		while (vsock_stream_has_space(vsk) == 0 &amp;&amp;
 		       sk-&gt;sk_err == 0 &amp;&amp;
 		       !(sk-&gt;sk_shutdown &amp; SEND_SHUTDOWN) &amp;&amp;
<span class="p_chunk">@@ -1581,33 +1579,30 @@</span> <span class="p_context"> static int vsock_stream_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 			/* Don&#39;t wait for non-blocking sockets. */
 			if (timeout == 0) {
 				err = -EAGAIN;
<span class="p_del">-				finish_wait(sk_sleep(sk), &amp;wait);</span>
<span class="p_add">+				remove_wait_queue(sk_sleep(sk), &amp;wait);</span>
 				goto out_err;
 			}
 
 			err = transport-&gt;notify_send_pre_block(vsk, &amp;send_data);
 			if (err &lt; 0) {
<span class="p_del">-				finish_wait(sk_sleep(sk), &amp;wait);</span>
<span class="p_add">+				remove_wait_queue(sk_sleep(sk), &amp;wait);</span>
 				goto out_err;
 			}
 
 			release_sock(sk);
<span class="p_del">-			timeout = schedule_timeout(timeout);</span>
<span class="p_add">+			timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE, timeout);</span>
 			lock_sock(sk);
 			if (signal_pending(current)) {
 				err = sock_intr_errno(timeout);
<span class="p_del">-				finish_wait(sk_sleep(sk), &amp;wait);</span>
<span class="p_add">+				remove_wait_queue(sk_sleep(sk), &amp;wait);</span>
 				goto out_err;
 			} else if (timeout == 0) {
 				err = -EAGAIN;
<span class="p_del">-				finish_wait(sk_sleep(sk), &amp;wait);</span>
<span class="p_add">+				remove_wait_queue(sk_sleep(sk), &amp;wait);</span>
 				goto out_err;
 			}
<span class="p_del">-</span>
<span class="p_del">-			prepare_to_wait(sk_sleep(sk), &amp;wait,</span>
<span class="p_del">-					TASK_INTERRUPTIBLE);</span>
 		}
<span class="p_del">-		finish_wait(sk_sleep(sk), &amp;wait);</span>
<span class="p_add">+		remove_wait_queue(sk_sleep(sk), &amp;wait);</span>
 
 		/* These checks occur both as part of and after the loop
 		 * conditional since we need to check before and after
<span class="p_header">diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c</span>
<span class="p_header">index 7f0598b32f13..c80d80e312e3 100644</span>
<span class="p_header">--- a/sound/core/pcm_lib.c</span>
<span class="p_header">+++ b/sound/core/pcm_lib.c</span>
<span class="p_chunk">@@ -264,8 +264,10 @@</span> <span class="p_context"> static void update_audio_tstamp(struct snd_pcm_substream *substream,</span>
 				runtime-&gt;rate);
 		*audio_tstamp = ns_to_timespec(audio_nsecs);
 	}
<span class="p_del">-	runtime-&gt;status-&gt;audio_tstamp = *audio_tstamp;</span>
<span class="p_del">-	runtime-&gt;status-&gt;tstamp = *curr_tstamp;</span>
<span class="p_add">+	if (!timespec_equal(&amp;runtime-&gt;status-&gt;audio_tstamp, audio_tstamp)) {</span>
<span class="p_add">+		runtime-&gt;status-&gt;audio_tstamp = *audio_tstamp;</span>
<span class="p_add">+		runtime-&gt;status-&gt;tstamp = *curr_tstamp;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * re-take a driver timestamp to let apps detect if the reference tstamp
<span class="p_header">diff --git a/sound/core/timer_compat.c b/sound/core/timer_compat.c</span>
<span class="p_header">index 59127b6ef39e..e00f7e399e46 100644</span>
<span class="p_header">--- a/sound/core/timer_compat.c</span>
<span class="p_header">+++ b/sound/core/timer_compat.c</span>
<span class="p_chunk">@@ -66,11 +66,11 @@</span> <span class="p_context"> static int snd_timer_user_info_compat(struct file *file,</span>
 	struct snd_timer *t;
 
 	tu = file-&gt;private_data;
<span class="p_del">-	if (snd_BUG_ON(!tu-&gt;timeri))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (!tu-&gt;timeri)</span>
<span class="p_add">+		return -EBADFD;</span>
 	t = tu-&gt;timeri-&gt;timer;
<span class="p_del">-	if (snd_BUG_ON(!t))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (!t)</span>
<span class="p_add">+		return -EBADFD;</span>
 	memset(&amp;info, 0, sizeof(info));
 	info.card = t-&gt;card ? t-&gt;card-&gt;number : -1;
 	if (t-&gt;hw.flags &amp; SNDRV_TIMER_HW_SLAVE)
<span class="p_chunk">@@ -99,8 +99,8 @@</span> <span class="p_context"> static int snd_timer_user_status_compat(struct file *file,</span>
 	struct snd_timer_status32 status;
 	
 	tu = file-&gt;private_data;
<span class="p_del">-	if (snd_BUG_ON(!tu-&gt;timeri))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (!tu-&gt;timeri)</span>
<span class="p_add">+		return -EBADFD;</span>
 	memset(&amp;status, 0, sizeof(status));
 	status.tstamp.tv_sec = tu-&gt;tstamp.tv_sec;
 	status.tstamp.tv_nsec = tu-&gt;tstamp.tv_nsec;
<span class="p_header">diff --git a/sound/hda/hdmi_chmap.c b/sound/hda/hdmi_chmap.c</span>
<span class="p_header">index 81acc20c2535..f21633cd9b38 100644</span>
<span class="p_header">--- a/sound/hda/hdmi_chmap.c</span>
<span class="p_header">+++ b/sound/hda/hdmi_chmap.c</span>
<span class="p_chunk">@@ -746,7 +746,7 @@</span> <span class="p_context"> static int hdmi_chmap_ctl_get(struct snd_kcontrol *kcontrol,</span>
 	memset(pcm_chmap, 0, sizeof(pcm_chmap));
 	chmap-&gt;ops.get_chmap(chmap-&gt;hdac, pcm_idx, pcm_chmap);
 
<span class="p_del">-	for (i = 0; i &lt; sizeof(chmap); i++)</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(pcm_chmap); i++)</span>
 		ucontrol-&gt;value.integer.value[i] = pcm_chmap[i];
 
 	return 0;
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 5cb7e04fa4ba..293f3f213776 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2305,6 +2305,9 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* AMD Hudson */
 	{ PCI_DEVICE(0x1022, 0x780d),
 	  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },
<span class="p_add">+	/* AMD Raven */</span>
<span class="p_add">+	{ PCI_DEVICE(0x1022, 0x15e3),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },</span>
 	/* ATI HDMI */
 	{ PCI_DEVICE(0x1002, 0x0002),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 80c40a1b8b65..d7fa7373cb94 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4419,7 +4419,7 @@</span> <span class="p_context"> static void alc_no_shutup(struct hda_codec *codec)</span>
 static void alc_fixup_no_shutup(struct hda_codec *codec,
 				const struct hda_fixup *fix, int action)
 {
<span class="p_del">-	if (action == HDA_FIXUP_ACT_PRE_PROBE) {</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PROBE) {</span>
 		struct alc_spec *spec = codec-&gt;spec;
 		spec-&gt;shutup = alc_no_shutup;
 	}
<span class="p_chunk">@@ -6272,7 +6272,7 @@</span> <span class="p_context"> static int patch_alc269(struct hda_codec *codec)</span>
 	case 0x10ec0703:
 		spec-&gt;codec_variant = ALC269_TYPE_ALC700;
 		spec-&gt;gen.mixer_nid = 0; /* ALC700 does not have any loopback mixer path */
<span class="p_del">-		alc_update_coef_idx(codec, 0x4a, 0, 1 &lt;&lt; 15); /* Combo jack auto trigger control */</span>
<span class="p_add">+		alc_update_coef_idx(codec, 0x4a, 1 &lt;&lt; 15, 0); /* Combo jack auto trigger control */</span>
 		break;
 
 	}
<span class="p_header">diff --git a/sound/soc/codecs/wm_adsp.c b/sound/soc/codecs/wm_adsp.c</span>
<span class="p_header">index 3bdd81930486..757af795cebd 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm_adsp.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm_adsp.c</span>
<span class="p_chunk">@@ -1365,7 +1365,7 @@</span> <span class="p_context"> static int wm_adsp_load(struct wm_adsp *dsp)</span>
 	const struct wmfw_region *region;
 	const struct wm_adsp_region *mem;
 	const char *region_name;
<span class="p_del">-	char *file, *text;</span>
<span class="p_add">+	char *file, *text = NULL;</span>
 	struct wm_adsp_buf *buf;
 	unsigned int reg;
 	int regions = 0;
<span class="p_chunk">@@ -1526,10 +1526,21 @@</span> <span class="p_context"> static int wm_adsp_load(struct wm_adsp *dsp)</span>
 			 regions, le32_to_cpu(region-&gt;len), offset,
 			 region_name);
 
<span class="p_add">+		if ((pos + le32_to_cpu(region-&gt;len) + sizeof(*region)) &gt;</span>
<span class="p_add">+		    firmware-&gt;size) {</span>
<span class="p_add">+			adsp_err(dsp,</span>
<span class="p_add">+				 &quot;%s.%d: %s region len %d bytes exceeds file length %zu\n&quot;,</span>
<span class="p_add">+				 file, regions, region_name,</span>
<span class="p_add">+				 le32_to_cpu(region-&gt;len), firmware-&gt;size);</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto out_fw;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (text) {
 			memcpy(text, region-&gt;data, le32_to_cpu(region-&gt;len));
 			adsp_info(dsp, &quot;%s: %s\n&quot;, file, text);
 			kfree(text);
<span class="p_add">+			text = NULL;</span>
 		}
 
 		if (reg) {
<span class="p_chunk">@@ -1574,6 +1585,7 @@</span> <span class="p_context"> static int wm_adsp_load(struct wm_adsp *dsp)</span>
 	regmap_async_complete(regmap);
 	wm_adsp_buf_free(&amp;buf_list);
 	release_firmware(firmware);
<span class="p_add">+	kfree(text);</span>
 out:
 	kfree(file);
 
<span class="p_chunk">@@ -2054,6 +2066,17 @@</span> <span class="p_context"> static int wm_adsp_load_coeff(struct wm_adsp *dsp)</span>
 		}
 
 		if (reg) {
<span class="p_add">+			if ((pos + le32_to_cpu(blk-&gt;len) + sizeof(*blk)) &gt;</span>
<span class="p_add">+			    firmware-&gt;size) {</span>
<span class="p_add">+				adsp_err(dsp,</span>
<span class="p_add">+					 &quot;%s.%d: %s region len %d bytes exceeds file length %zu\n&quot;,</span>
<span class="p_add">+					 file, blocks, region_name,</span>
<span class="p_add">+					 le32_to_cpu(blk-&gt;len),</span>
<span class="p_add">+					 firmware-&gt;size);</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				goto out_fw;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			buf = wm_adsp_buf_alloc(blk-&gt;data,
 						le32_to_cpu(blk-&gt;len),
 						&amp;buf_list);
<span class="p_header">diff --git a/sound/soc/sh/rcar/core.c b/sound/soc/sh/rcar/core.c</span>
<span class="p_header">index f18141098b50..91b444db575e 100644</span>
<span class="p_header">--- a/sound/soc/sh/rcar/core.c</span>
<span class="p_header">+++ b/sound/soc/sh/rcar/core.c</span>
<span class="p_chunk">@@ -978,10 +978,8 @@</span> <span class="p_context"> static int __rsnd_kctrl_new(struct rsnd_mod *mod,</span>
 		return -ENOMEM;
 
 	ret = snd_ctl_add(card, kctrl);
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		snd_ctl_free_one(kctrl);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		return ret;
<span class="p_del">-	}</span>
 
 	cfg-&gt;update = update;
 	cfg-&gt;card = card;
<span class="p_header">diff --git a/sound/usb/clock.c b/sound/usb/clock.c</span>
<span class="p_header">index 26dd5f20f149..eb3396ffba4c 100644</span>
<span class="p_header">--- a/sound/usb/clock.c</span>
<span class="p_header">+++ b/sound/usb/clock.c</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> static struct uac_clock_source_descriptor *</span>
 	while ((cs = snd_usb_find_csint_desc(ctrl_iface-&gt;extra,
 					     ctrl_iface-&gt;extralen,
 					     cs, UAC2_CLOCK_SOURCE))) {
<span class="p_del">-		if (cs-&gt;bClockID == clock_id)</span>
<span class="p_add">+		if (cs-&gt;bLength &gt;= sizeof(*cs) &amp;&amp; cs-&gt;bClockID == clock_id)</span>
 			return cs;
 	}
 
<span class="p_chunk">@@ -59,8 +59,11 @@</span> <span class="p_context"> static struct uac_clock_selector_descriptor *</span>
 	while ((cs = snd_usb_find_csint_desc(ctrl_iface-&gt;extra,
 					     ctrl_iface-&gt;extralen,
 					     cs, UAC2_CLOCK_SELECTOR))) {
<span class="p_del">-		if (cs-&gt;bClockID == clock_id)</span>
<span class="p_add">+		if (cs-&gt;bLength &gt;= sizeof(*cs) &amp;&amp; cs-&gt;bClockID == clock_id) {</span>
<span class="p_add">+			if (cs-&gt;bLength &lt; 5 + cs-&gt;bNrInPins)</span>
<span class="p_add">+				return NULL;</span>
 			return cs;
<span class="p_add">+		}</span>
 	}
 
 	return NULL;
<span class="p_chunk">@@ -75,7 +78,7 @@</span> <span class="p_context"> static struct uac_clock_multiplier_descriptor *</span>
 	while ((cs = snd_usb_find_csint_desc(ctrl_iface-&gt;extra,
 					     ctrl_iface-&gt;extralen,
 					     cs, UAC2_CLOCK_MULTIPLIER))) {
<span class="p_del">-		if (cs-&gt;bClockID == clock_id)</span>
<span class="p_add">+		if (cs-&gt;bLength &gt;= sizeof(*cs) &amp;&amp; cs-&gt;bClockID == clock_id)</span>
 			return cs;
 	}
 
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index d82e3c81c258..9133d3e53d9d 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -1463,6 +1463,12 @@</span> <span class="p_context"> static int parse_audio_feature_unit(struct mixer_build *state, int unitid,</span>
 	__u8 *bmaControls;
 
 	if (state-&gt;mixer-&gt;protocol == UAC_VERSION_1) {
<span class="p_add">+		if (hdr-&gt;bLength &lt; 7) {</span>
<span class="p_add">+			usb_audio_err(state-&gt;chip,</span>
<span class="p_add">+				      &quot;unit %u: invalid UAC_FEATURE_UNIT descriptor\n&quot;,</span>
<span class="p_add">+				      unitid);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
 		csize = hdr-&gt;bControlSize;
 		if (!csize) {
 			usb_audio_dbg(state-&gt;chip,
<span class="p_chunk">@@ -1480,6 +1486,12 @@</span> <span class="p_context"> static int parse_audio_feature_unit(struct mixer_build *state, int unitid,</span>
 		}
 	} else {
 		struct uac2_feature_unit_descriptor *ftr = _ftr;
<span class="p_add">+		if (hdr-&gt;bLength &lt; 6) {</span>
<span class="p_add">+			usb_audio_err(state-&gt;chip,</span>
<span class="p_add">+				      &quot;unit %u: invalid UAC_FEATURE_UNIT descriptor\n&quot;,</span>
<span class="p_add">+				      unitid);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
 		csize = 4;
 		channels = (hdr-&gt;bLength - 6) / 4 - 1;
 		bmaControls = ftr-&gt;bmaControls;
<span class="p_chunk">@@ -2080,7 +2092,8 @@</span> <span class="p_context"> static int parse_audio_selector_unit(struct mixer_build *state, int unitid,</span>
 	const struct usbmix_name_map *map;
 	char **namelist;
 
<span class="p_del">-	if (!desc-&gt;bNrInPins || desc-&gt;bLength &lt; 5 + desc-&gt;bNrInPins) {</span>
<span class="p_add">+	if (desc-&gt;bLength &lt; 5 || !desc-&gt;bNrInPins ||</span>
<span class="p_add">+	    desc-&gt;bLength &lt; 5 + desc-&gt;bNrInPins) {</span>
 		usb_audio_err(state-&gt;chip,
 			&quot;invalid SELECTOR UNIT descriptor %d\n&quot;, unitid);
 		return -EINVAL;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



