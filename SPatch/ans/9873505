
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v7,07/15] RISC-V: Init and Halt Code - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v7,07/15] RISC-V: Init and Halt Code</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 1, 2017, 1 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170801010009.3302-8-palmer@dabbelt.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9873505/mbox/"
   >mbox</a>
|
   <a href="/patch/9873505/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9873505/">/patch/9873505/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E69976038F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  1 Aug 2017 01:03:44 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D739926247
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  1 Aug 2017 01:03:44 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id CA34327FB6; Tue,  1 Aug 2017 01:03:44 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.4 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, RCVD_IN_DNSWL_HI,
	RCVD_IN_SORBS_SPAM autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2FD8426247
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  1 Aug 2017 01:03:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751836AbdHABDj (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 31 Jul 2017 21:03:39 -0400
Received: from mail-pf0-f195.google.com ([209.85.192.195]:37076 &quot;EHLO
	mail-pf0-f195.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751607AbdHABAy (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 31 Jul 2017 21:00:54 -0400
Received: by mail-pf0-f195.google.com with SMTP id 72so244397pfl.4
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 31 Jul 2017 18:00:54 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=dabbelt-com.20150623.gappssmtp.com; s=20150623;
	h=subject:date:message-id:in-reply-to:references:cc:from:to;
	bh=v9ovjPxtghJIG2ME+n1Jq4RoHVo6VNgYpr6b13FRSno=;
	b=mYcSmVtspzR1jbHj+dw7aVcGe4cJ1eFu3OABs+uU5sk0asvkKpLZumHjP5WgLccgQN
	vT+9KmGtiIkReXoMt+MdhBLUrDDeQgAyidXJziiTclMXd3t6iQedfpy2u96RS9Mgr+k/
	jyBu2DQ61qZiXgZM3EW/Gh/usXSt4LAhQVa649dXSJxXUlNo3vkIBwY9huTA3TCbzztj
	On6+9GLsaDbxKNKdnLk9PxP/bejzHWneIsrPVqdiTmaEMqT4Cq3cR5lFO/dVZ8zLyR9V
	xPmh8mx7dkxoOEMCvuBEAvg6mVXueu+UCDbXdGWmIHIgHpOUWsHDAU3eHQjKS44haIOa
	qvaQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:subject:date:message-id:in-reply-to:references
	:cc:from:to;
	bh=v9ovjPxtghJIG2ME+n1Jq4RoHVo6VNgYpr6b13FRSno=;
	b=mNgvifj0rTGsrzYyKOHGczmA1/4ZxDnYE8jNljUDTZU04fcpr+B2e17Y5tah4GoL9P
	D15QXFkbdo3g1oCjOeK5cSjs6GiSoQXbv9bVJuE1DAnWfCNhdG7xkmBmubqNH1cipbja
	YCo3H9RPBlFDKUURfeeZRbBRtJ5B8jk/B8tlUoDrVq429BY7NURZyv94I1iKNcC4TQ2C
	EKTZeeCAdsWo0iBgec46NCKyJ9G3R4Qs9mTfchYcdIrA0Z9Gsx6/a48A+dq7dEmtvOCz
	jhpqv1zvQnQFh0s0df/n2h9/NMu7vr07dWGA7sd+UTTRRHueILOBCuhm/g+/7S9P1jMc
	jsvg==
X-Gm-Message-State: AIVw111krFYLDXggDkx+Vb6ZIx9YoKsnGYhXnUYVWciOeJAKw3Psc3xs
	Gt30UwrSuDjNpTbX
X-Received: by 10.84.167.230 with SMTP id i35mr18951013plg.181.1501549253036;
	Mon, 31 Jul 2017 18:00:53 -0700 (PDT)
Received: from localhost (c-24-5-193-41.hsd1.ca.comcast.net. [24.5.193.41])
	by smtp.gmail.com with ESMTPSA id
	u26sm35219781pfi.140.2017.07.31.18.00.51
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 31 Jul 2017 18:00:52 -0700 (PDT)
Subject: [PATCH v7 07/15] RISC-V: Init and Halt Code
Date: Mon, 31 Jul 2017 18:00:01 -0700
Message-Id: &lt;20170801010009.3302-8-palmer@dabbelt.com&gt;
X-Mailer: git-send-email 2.13.0
In-Reply-To: &lt;20170801010009.3302-1-palmer@dabbelt.com&gt;
References: &lt;20170801010009.3302-1-palmer@dabbelt.com&gt;
Cc: yamada.masahiro@socionext.com, mmarek@suse.com, albert@sifive.com,
	will.deacon@arm.com, boqun.feng@gmail.com, oleg@redhat.com,
	mingo@redhat.com, daniel.lezcano@linaro.org,
	gregkh@linuxfoundation.org, jslaby@suse.com, davem@davemloft.net,
	mchehab@kernel.org, hverkuil@xs4all.nl, rdunlap@infradead.org,
	viro@zeniv.linux.org.uk, mhiramat@kernel.org, fweisbec@gmail.com,
	mcgrof@kernel.org, dledford@redhat.com, bart.vanassche@sandisk.com,
	sstabellini@kernel.org, mpe@ellerman.id.au,
	rmk+kernel@armlinux.org.uk, paul.gortmaker@windriver.com,
	nicolas.dichtel@6wind.com, linux@roeck-us.net,
	heiko.carstens@de.ibm.com, schwidefsky@de.ibm.com,
	geert@linux-m68k.org, akpm@linux-foundation.org,
	andriy.shevchenko@linux.intel.com, jiri@mellanox.com,
	vgupta@synopsys.com, airlied@redhat.com, jk@ozlabs.org,
	chris@chris-wilson.co.uk, Jason@zx2c4.com,
	paulmck@linux.vnet.ibm.com, ncardwell@google.com,
	linux-kernel@vger.kernel.org, linux-kbuild@vger.kernel.org,
	patches@groups.riscv.org, Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
From: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
To: peterz@infradead.org, tglx@linutronix.de, jason@lakedaemon.net,
	marc.zyngier@arm.com, Arnd Bergmann &lt;arnd@arndb.de&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - Aug. 1, 2017, 1 a.m.</div>
<pre class="content">
This contains the various __init C functions, the initial assembly
kernel entry point, and the code to reset the system.  When a file was
init-related this patch contains the entire file.
<span class="signed-off-by">
Signed-off-by: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;</span>
---
 arch/riscv/include/asm/bug.h   |  88 ++++++++++++++
 arch/riscv/include/asm/cache.h |  22 ++++
 arch/riscv/include/asm/smp.h   |  52 ++++++++
 arch/riscv/kernel/cacheinfo.c  | 105 +++++++++++++++++
 arch/riscv/kernel/cpu.c        |  89 ++++++++++++++
 arch/riscv/kernel/head.S       | 151 ++++++++++++++++++++++++
 arch/riscv/kernel/irq.c        |  20 ++++
 arch/riscv/kernel/reset.c      |  36 ++++++
 arch/riscv/kernel/setup.c      | 261 +++++++++++++++++++++++++++++++++++++++++
 arch/riscv/kernel/smp.c        | 110 +++++++++++++++++
 arch/riscv/kernel/smpboot.c    | 112 ++++++++++++++++++
 arch/riscv/kernel/time.c       |  76 ++++++++++++
 arch/riscv/kernel/traps.c      | 180 ++++++++++++++++++++++++++++
 arch/riscv/kernel/vdso.c       | 125 ++++++++++++++++++++
 arch/riscv/mm/init.c           |  70 +++++++++++
 15 files changed, 1497 insertions(+)
 create mode 100644 arch/riscv/include/asm/bug.h
 create mode 100644 arch/riscv/include/asm/cache.h
 create mode 100644 arch/riscv/include/asm/smp.h
 create mode 100644 arch/riscv/kernel/cacheinfo.c
 create mode 100644 arch/riscv/kernel/cpu.c
 create mode 100644 arch/riscv/kernel/head.S
 create mode 100644 arch/riscv/kernel/irq.c
 create mode 100644 arch/riscv/kernel/reset.c
 create mode 100644 arch/riscv/kernel/setup.c
 create mode 100644 arch/riscv/kernel/smp.c
 create mode 100644 arch/riscv/kernel/smpboot.c
 create mode 100644 arch/riscv/kernel/time.c
 create mode 100644 arch/riscv/kernel/traps.c
 create mode 100644 arch/riscv/kernel/vdso.c
 create mode 100644 arch/riscv/mm/init.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/riscv/include/asm/bug.h b/arch/riscv/include/asm/bug.h</span>
new file mode 100644
<span class="p_header">index 000000000000..c3e13764a943</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/include/asm/bug.h</span>
<span class="p_chunk">@@ -0,0 +1,88 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_RISCV_BUG_H</span>
<span class="p_add">+#define _ASM_RISCV_BUG_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+#include &lt;linux/const.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+#define __BUG_INSN	_AC(0x00100073, UL) /* ebreak */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+typedef u32 bug_insn_t;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG_RELATIVE_POINTERS</span>
<span class="p_add">+#define __BUG_ENTRY_ADDR	INT &quot; 1b - 2b&quot;</span>
<span class="p_add">+#define __BUG_ENTRY_FILE	INT &quot; %0 - 2b&quot;</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define __BUG_ENTRY_ADDR	RISCV_PTR &quot; 1b&quot;</span>
<span class="p_add">+#define __BUG_ENTRY_FILE	RISCV_PTR &quot; %0&quot;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DEBUG_BUGVERBOSE</span>
<span class="p_add">+#define __BUG_ENTRY			\</span>
<span class="p_add">+	__BUG_ENTRY_ADDR &quot;\n\t&quot;		\</span>
<span class="p_add">+	__BUG_ENTRY_FILE &quot;\n\t&quot;		\</span>
<span class="p_add">+	SHORT &quot; %1&quot;</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define __BUG_ENTRY			\</span>
<span class="p_add">+	__BUG_ENTRY_ADDR</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define BUG()							\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	__asm__ __volatile__ (					\</span>
<span class="p_add">+		&quot;1:\n\t&quot;					\</span>
<span class="p_add">+			&quot;ebreak\n&quot;				\</span>
<span class="p_add">+			&quot;.pushsection __bug_table,\&quot;a\&quot;\n\t&quot;	\</span>
<span class="p_add">+		&quot;2:\n\t&quot;					\</span>
<span class="p_add">+			__BUG_ENTRY &quot;\n\t&quot;			\</span>
<span class="p_add">+			&quot;.org 2b + %2\n\t&quot;			\</span>
<span class="p_add">+			&quot;.popsection&quot;				\</span>
<span class="p_add">+		:						\</span>
<span class="p_add">+		: &quot;i&quot; (__FILE__), &quot;i&quot; (__LINE__),		\</span>
<span class="p_add">+		  &quot;i&quot; (sizeof(struct bug_entry)));		\</span>
<span class="p_add">+	unreachable();						\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#endif /* !__ASSEMBLY__ */</span>
<span class="p_add">+#else /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#define BUG()							\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	__asm__ __volatile__ (&quot;ebreak\n&quot;);			\</span>
<span class="p_add">+	unreachable();						\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#endif /* !__ASSEMBLY__ */</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+#define HAVE_ARCH_BUG</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/bug.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+struct pt_regs;</span>
<span class="p_add">+struct task_struct;</span>
<span class="p_add">+</span>
<span class="p_add">+extern void die(struct pt_regs *regs, const char *str);</span>
<span class="p_add">+extern void do_trap(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* !__ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_RISCV_BUG_H */</span>
<span class="p_header">diff --git a/arch/riscv/include/asm/cache.h b/arch/riscv/include/asm/cache.h</span>
new file mode 100644
<span class="p_header">index 000000000000..e8f0d1110d74</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/include/asm/cache.h</span>
<span class="p_chunk">@@ -0,0 +1,22 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_RISCV_CACHE_H</span>
<span class="p_add">+#define _ASM_RISCV_CACHE_H</span>
<span class="p_add">+</span>
<span class="p_add">+#define L1_CACHE_SHIFT		6</span>
<span class="p_add">+</span>
<span class="p_add">+#define L1_CACHE_BYTES		(1 &lt;&lt; L1_CACHE_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_RISCV_CACHE_H */</span>
<span class="p_header">diff --git a/arch/riscv/include/asm/smp.h b/arch/riscv/include/asm/smp.h</span>
new file mode 100644
<span class="p_header">index 000000000000..be872bf5a1cd</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/include/asm/smp.h</span>
<span class="p_chunk">@@ -0,0 +1,52 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_RISCV_SMP_H</span>
<span class="p_add">+#define _ASM_RISCV_SMP_H</span>
<span class="p_add">+</span>
<span class="p_add">+/* This both needs asm-offsets.h and is used when generating it. */</span>
<span class="p_add">+#ifndef GENERATING_ASM_OFFSETS</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cpumask.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqreturn.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+</span>
<span class="p_add">+/* SMP initialization hook for setup_arch */</span>
<span class="p_add">+void __init init_clockevent(void);</span>
<span class="p_add">+</span>
<span class="p_add">+/* SMP initialization hook for setup_arch */</span>
<span class="p_add">+void __init setup_smp(void);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Hook for the generic smp_call_function_many() routine. */</span>
<span class="p_add">+void arch_send_call_function_ipi_mask(struct cpumask *mask);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Hook for the generic smp_call_function_single() routine. */</span>
<span class="p_add">+void arch_send_call_function_single_ipi(int cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is particularly ugly: it appears we can&#39;t actually get the definition</span>
<span class="p_add">+ * of task_struct here, but we need access to the CPU this task is running on.</span>
<span class="p_add">+ * Instead of using C we&#39;re using asm-offsets.h to get the current processor</span>
<span class="p_add">+ * ID.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define raw_smp_processor_id() (*((int*)((char*)get_current() + TASK_CPU)))</span>
<span class="p_add">+</span>
<span class="p_add">+/* Interprocessor interrupt handler */</span>
<span class="p_add">+irqreturn_t handle_ipi(void);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_SMP */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_RISCV_SMP_H */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cacheinfo.c b/arch/riscv/kernel/cacheinfo.c</span>
new file mode 100644
<span class="p_header">index 000000000000..10ed2749e246</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -0,0 +1,105 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cacheinfo.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_device.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="p_add">+			 struct device_node *node,</span>
<span class="p_add">+			 enum cache_type type, unsigned int level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	this_leaf-&gt;of_node = node;</span>
<span class="p_add">+	this_leaf-&gt;level = level;</span>
<span class="p_add">+	this_leaf-&gt;type = type;</span>
<span class="p_add">+	/* not a sector cache */</span>
<span class="p_add">+	this_leaf-&gt;physical_line_partition = 1;</span>
<span class="p_add">+	/* TODO: Add to DTS */</span>
<span class="p_add">+	this_leaf-&gt;attributes =</span>
<span class="p_add">+		CACHE_WRITE_BACK</span>
<span class="p_add">+		| CACHE_READ_ALLOCATE</span>
<span class="p_add">+		| CACHE_WRITE_ALLOCATE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init_cache_level(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 0, leaves = 0, level;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+		++leaves;</span>
<span class="p_add">+	if (leaves &gt; 0)</span>
<span class="p_add">+		levels = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (level &lt;= levels)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+			++leaves;</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	this_cpu_ci-&gt;num_levels = levels;</span>
<span class="p_add">+	this_cpu_ci-&gt;num_leaves = leaves;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __populate_cache_leaves(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct cacheinfo *this_leaf = this_cpu_ci-&gt;info_list;</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 1, level = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+		ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (level &lt;= levels)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;))</span>
<span class="p_add">+			ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c</span>
new file mode 100644
<span class="p_header">index 000000000000..20004bd7a216</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cpu.c</span>
<span class="p_chunk">@@ -0,0 +1,89 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Return -1 if not a valid hart */</span>
<span class="p_add">+int riscv_of_processor_hart(struct device_node *node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char *isa, *status;</span>
<span class="p_add">+	u32 hart;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!of_device_is_compatible(node, &quot;riscv&quot;))</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	if (of_property_read_u32(node, &quot;reg&quot;, &amp;hart)</span>
<span class="p_add">+	    || hart &gt;= NR_CPUS)</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;status&quot;, &amp;status)</span>
<span class="p_add">+	    || strcmp(status, &quot;okay&quot;))</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)</span>
<span class="p_add">+	    || isa[0] != &#39;r&#39;</span>
<span class="p_add">+	    || isa[1] != &#39;v&#39;)</span>
<span class="p_add">+		return -(ENODEV);</span>
<span class="p_add">+</span>
<span class="p_add">+	return hart;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_FS</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_start(struct seq_file *m, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*pos = cpumask_next(*pos - 1, cpu_online_mask);</span>
<span class="p_add">+	if ((*pos) &lt; nr_cpu_ids)</span>
<span class="p_add">+		return (void *)(uintptr_t)(1 + *pos);</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_next(struct seq_file *m, void *v, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	(*pos)++;</span>
<span class="p_add">+	return c_start(m, pos);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void c_stop(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int c_show(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long hart_id = (unsigned long)v - 1;</span>
<span class="p_add">+	struct device_node *node = of_get_cpu_node(hart_id, NULL);</span>
<span class="p_add">+	const char *compat, *isa, *mmu;</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(m, &quot;hart\t: %lu\n&quot;, hart_id);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa)</span>
<span class="p_add">+	    &amp;&amp; isa[0] == &#39;r&#39;</span>
<span class="p_add">+	    &amp;&amp; isa[1] == &#39;v&#39;)</span>
<span class="p_add">+		seq_printf(m, &quot;isa\t: %s\n&quot;, isa);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;mmu-type&quot;, &amp;mmu)</span>
<span class="p_add">+	    &amp;&amp; !strncmp(mmu, &quot;riscv,&quot;, 6))</span>
<span class="p_add">+		seq_printf(m, &quot;mmu\t: %s\n&quot;, mmu+6);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;compatible&quot;, &amp;compat)</span>
<span class="p_add">+	    &amp;&amp; strcmp(compat, &quot;riscv&quot;))</span>
<span class="p_add">+		seq_printf(m, &quot;uarch\t: %s\n&quot;, compat);</span>
<span class="p_add">+	seq_puts(m, &quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct seq_operations cpuinfo_op = {</span>
<span class="p_add">+	.start	= c_start,</span>
<span class="p_add">+	.next	= c_next,</span>
<span class="p_add">+	.stop	= c_stop,</span>
<span class="p_add">+	.show	= c_show</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_PROC_FS */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S</span>
new file mode 100644
<span class="p_header">index 000000000000..708b70ec0795</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/head.S</span>
<span class="p_chunk">@@ -0,0 +1,151 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+__INIT</span>
<span class="p_add">+ENTRY(_start)</span>
<span class="p_add">+	/* Mask all interrupts */</span>
<span class="p_add">+	csrw sie, zero</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load the global pointer */</span>
<span class="p_add">+.option push</span>
<span class="p_add">+.option norelax</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+.option pop</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Disable FPU to detect illegal usage of</span>
<span class="p_add">+	 * floating point in kernel space</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	li t0, SR_FS</span>
<span class="p_add">+	csrc sstatus, t0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Pick one hart to run the main boot sequence */</span>
<span class="p_add">+	la a3, hart_lottery</span>
<span class="p_add">+	li a2, 1</span>
<span class="p_add">+	amoadd.w a3, a2, (a3)</span>
<span class="p_add">+	bnez a3, .Lsecondary_start</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save hart ID and DTB physical address */</span>
<span class="p_add">+	mv s0, a0</span>
<span class="p_add">+	mv s1, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize page tables and relocate to virtual addresses */</span>
<span class="p_add">+	la sp, init_thread_union + THREAD_SIZE</span>
<span class="p_add">+	call setup_vm</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore C environment */</span>
<span class="p_add">+	la tp, init_task</span>
<span class="p_add">+</span>
<span class="p_add">+	la sp, init_thread_union</span>
<span class="p_add">+	li a0, ASM_THREAD_SIZE</span>
<span class="p_add">+	add sp, sp, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start the kernel */</span>
<span class="p_add">+	mv a0, s0</span>
<span class="p_add">+	mv a1, s1</span>
<span class="p_add">+	call sbi_save</span>
<span class="p_add">+	tail start_kernel</span>
<span class="p_add">+</span>
<span class="p_add">+relocate:</span>
<span class="p_add">+	/* Relocate return address */</span>
<span class="p_add">+	li a1, PAGE_OFFSET</span>
<span class="p_add">+	la a0, _start</span>
<span class="p_add">+	sub a1, a1, a0</span>
<span class="p_add">+	add ra, ra, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Point stvec to virtual address of intruction after sptbr write */</span>
<span class="p_add">+	la a0, 1f</span>
<span class="p_add">+	add a0, a0, a1</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute sptbr for kernel page tables, but don&#39;t load it yet */</span>
<span class="p_add">+	la a2, swapper_pg_dir</span>
<span class="p_add">+	srl a2, a2, PAGE_SHIFT</span>
<span class="p_add">+	li a1, SPTBR_MODE</span>
<span class="p_add">+	or a2, a2, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Load trampoline page directory, which will cause us to trap to</span>
<span class="p_add">+	 * stvec if VA != PA, or simply fall through if VA == PA</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	la a0, trampoline_pg_dir</span>
<span class="p_add">+	srl a0, a0, PAGE_SHIFT</span>
<span class="p_add">+	or a0, a0, a1</span>
<span class="p_add">+	sfence.vma</span>
<span class="p_add">+	csrw sptbr, a0</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* Set trap vector to spin forever to help debug */</span>
<span class="p_add">+	la a0, .Lsecondary_park</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reload the global pointer */</span>
<span class="p_add">+.option push</span>
<span class="p_add">+.option norelax</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+.option pop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Switch to kernel page tables */</span>
<span class="p_add">+	csrw sptbr, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_start:</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	li a1, CONFIG_NR_CPUS</span>
<span class="p_add">+	bgeu a0, a1, .Lsecondary_park</span>
<span class="p_add">+</span>
<span class="p_add">+	slli a0, a0, LGREG</span>
<span class="p_add">+	la a1, __cpu_up_stack_pointer</span>
<span class="p_add">+	la a2, __cpu_up_task_pointer</span>
<span class="p_add">+	add a1, a0, a1</span>
<span class="p_add">+	add a2, a0, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This hart didn&#39;t win the lottery, so we wait for the winning hart to</span>
<span class="p_add">+	 * get far enough along the boot process that it should continue.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+.Lwait_for_cpu_up:</span>
<span class="p_add">+	REG_L sp, (a1)</span>
<span class="p_add">+	REG_L tp, (a2)</span>
<span class="p_add">+	beqz sp, .Lwait_for_cpu_up</span>
<span class="p_add">+	beqz tp, .Lwait_for_cpu_up</span>
<span class="p_add">+	fence</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable virtual memory and relocate to virtual address */</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	tail smp_callin</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_park:</span>
<span class="p_add">+	/* We lack SMP support or have too many harts, so park this hart */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	j .Lsecondary_park</span>
<span class="p_add">+END(_start)</span>
<span class="p_add">+</span>
<span class="p_add">+__PAGE_ALIGNED_BSS</span>
<span class="p_add">+	/* Empty zero page */</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+ENTRY(empty_zero_page)</span>
<span class="p_add">+	.fill (empty_zero_page + PAGE_SIZE) - ., 1, 0x00</span>
<span class="p_add">+END(empty_zero_page)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c</span>
new file mode 100644
<span class="p_header">index 000000000000..737d7cce2c6d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/irq.c</span>
<span class="p_chunk">@@ -0,0 +1,20 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/irqchip.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void __init init_IRQ(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	irqchip_init();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/reset.c b/arch/riscv/kernel/reset.c</span>
new file mode 100644
<span class="p_header">index 000000000000..2a53d26ffdd6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/reset.c</span>
<span class="p_chunk">@@ -0,0 +1,36 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void (*pm_power_off)(void) = machine_power_off;</span>
<span class="p_add">+EXPORT_SYMBOL(pm_power_off);</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_restart(char *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	do_kernel_restart(cmd);</span>
<span class="p_add">+	while (1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_halt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	machine_power_off();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_power_off(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sbi_shutdown();</span>
<span class="p_add">+	while (1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c</span>
new file mode 100644
<span class="p_header">index 000000000000..148fd0dc414b</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/setup.c</span>
<span class="p_chunk">@@ -0,0 +1,261 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
<span class="p_add">+#include &lt;linux/screen_info.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_fdt.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+struct screen_info screen_info = {</span>
<span class="p_add">+	.orig_video_lines	= 30,</span>
<span class="p_add">+	.orig_video_cols	= 80,</span>
<span class="p_add">+	.orig_video_mode	= 0,</span>
<span class="p_add">+	.orig_video_ega_bx	= 0,</span>
<span class="p_add">+	.orig_video_isVGA	= 1,</span>
<span class="p_add">+	.orig_video_points	= 8</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long va_pa_offset;</span>
<span class="p_add">+unsigned long pfn_base;</span>
<span class="p_add">+</span>
<span class="p_add">+/* The lucky hart to first increment this variable will boot the other cores */</span>
<span class="p_add">+atomic_t hart_lottery;</span>
<span class="p_add">+</span>
<span class="p_add">+#if defined(CONFIG_HVC_RISCV_SBI) &amp;&amp; defined(CONFIG_EARLY_PRINTK)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The SBI&#39;s early console lives in hvc_riscv_sbi.c, but we want very early</span>
<span class="p_add">+ * access</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern struct console riscv_sbi_early_console_dev;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+static void __init setup_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char __initramfs_start[];</span>
<span class="p_add">+	extern unsigned long __initramfs_size;</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__initramfs_size &gt; 0) {</span>
<span class="p_add">+		initrd_start = (unsigned long)(&amp;__initramfs_start);</span>
<span class="p_add">+		initrd_end = initrd_start + __initramfs_size;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (initrd_start &gt;= initrd_end) {</span>
<span class="p_add">+		printk(KERN_INFO &quot;initrd not found or empty&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (__pa(initrd_end) &gt; PFN_PHYS(max_low_pfn)) {</span>
<span class="p_add">+		printk(KERN_ERR &quot;initrd extends beyond end of memory&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	size =  initrd_end - initrd_start;</span>
<span class="p_add">+	memblock_reserve(__pa(initrd_start), size);</span>
<span class="p_add">+	initrd_below_start_ok = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_INFO &quot;Initial ramdisk at: 0x%p (%lu bytes)\n&quot;,</span>
<span class="p_add">+		(void *)(initrd_start), size);</span>
<span class="p_add">+	return;</span>
<span class="p_add">+disable:</span>
<span class="p_add">+	pr_cont(&quot; - disabling initrd\n&quot;);</span>
<span class="p_add">+	initrd_start = 0;</span>
<span class="p_add">+	initrd_end = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+pgd_t swapper_pg_dir[PTRS_PER_PGD] __page_aligned_bss;</span>
<span class="p_add">+pgd_t trampoline_pg_dir[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+#define NUM_SWAPPER_PMDS ((uintptr_t)-PAGE_OFFSET &gt;&gt; PGDIR_SHIFT)</span>
<span class="p_add">+pmd_t swapper_pmd[PTRS_PER_PMD*((-PAGE_OFFSET)/PGDIR_SIZE)] __page_aligned_bss;</span>
<span class="p_add">+pmd_t trampoline_pmd[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void __init setup_vm(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char _start;</span>
<span class="p_add">+	uintptr_t i;</span>
<span class="p_add">+	uintptr_t pa = (uintptr_t) &amp;_start;</span>
<span class="p_add">+	pgprot_t prot = __pgprot(pgprot_val(PAGE_KERNEL) | _PAGE_EXEC);</span>
<span class="p_add">+</span>
<span class="p_add">+	va_pa_offset = PAGE_OFFSET - pa;</span>
<span class="p_add">+	pfn_base = PFN_DOWN(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Sanity check alignment and size */</span>
<span class="p_add">+	BUG_ON((PAGE_OFFSET % PGDIR_SIZE) != 0);</span>
<span class="p_add">+	BUG_ON((pa % (PAGE_SIZE * PTRS_PER_PTE)) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN((uintptr_t)trampoline_pmd),</span>
<span class="p_add">+			__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	trampoline_pmd[0] = pfn_pmd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {</span>
<span class="p_add">+		size_t o = (PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i;</span>
<span class="p_add">+		swapper_pg_dir[o] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN((uintptr_t)swapper_pmd) + i,</span>
<span class="p_add">+				__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(swapper_pmd); i++)</span>
<span class="p_add">+		swapper_pmd[i] = pfn_pmd(PFN_DOWN(pa + i * PMD_SIZE), prot);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i) {</span>
<span class="p_add">+		size_t o = (PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i;</span>
<span class="p_add">+		swapper_pg_dir[o] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN(pa + i * PGDIR_SIZE), prot);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init sbi_save(unsigned int hartid, void *dtb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	early_init_dt_scan(__va(dtb));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Allow the user to manually add a memory region (in case DTS is broken);</span>
<span class="p_add">+ * &quot;mem_end=nn[KkMmGg]&quot;</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int __init mem_end_override(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	resource_size_t base, end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!p)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	base = (uintptr_t) __pa(PAGE_OFFSET);</span>
<span class="p_add">+	end = memparse(p, &amp;p) &amp; PMD_MASK;</span>
<span class="p_add">+	if (end == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	memblock_add(base, end - base);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+early_param(&quot;mem_end&quot;, mem_end_override);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init setup_bootmem(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct memblock_region *reg;</span>
<span class="p_add">+	phys_addr_t mem_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the memory region containing the kernel */</span>
<span class="p_add">+	for_each_memblock(memory, reg) {</span>
<span class="p_add">+		phys_addr_t vmlinux_end = __pa(_end);</span>
<span class="p_add">+		phys_addr_t end = reg-&gt;base + reg-&gt;size;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (reg-&gt;base &lt;= vmlinux_end &amp;&amp; vmlinux_end &lt;= end) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Reserve from the start of the region to the end of</span>
<span class="p_add">+			 * the kernel</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			memblock_reserve(reg-&gt;base, vmlinux_end - reg-&gt;base);</span>
<span class="p_add">+			mem_size = min(reg-&gt;size, (phys_addr_t)-PAGE_OFFSET);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	BUG_ON(mem_size == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_max_mapnr(PFN_DOWN(mem_size));</span>
<span class="p_add">+	max_low_pfn = pfn_base + PFN_DOWN(mem_size);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+	setup_initrd();</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+	early_init_fdt_reserve_self();</span>
<span class="p_add">+	early_init_fdt_scan_reserved_mem();</span>
<span class="p_add">+	memblock_allow_resize();</span>
<span class="p_add">+	memblock_dump_all();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_arch(char **cmdline_p)</span>
<span class="p_add">+{</span>
<span class="p_add">+#if defined(CONFIG_TTY_RISCV_SBI) &amp;&amp; defined(CONFIG_EARLY_PRINTK)</span>
<span class="p_add">+	if (likely(early_console == NULL)) {</span>
<span class="p_add">+		early_console = &amp;riscv_sbi_early_console;</span>
<span class="p_add">+		register_console(early_console);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_OVERRIDE</span>
<span class="p_add">+	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	if (builtin_cmdline[0] != &#39;\0&#39;) {</span>
<span class="p_add">+		/* Append bootloader command line to built-in */</span>
<span class="p_add">+		strlcat(builtin_cmdline, &quot; &quot;, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcat(builtin_cmdline, boot_command_line, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_OVERRIDE */</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+	*cmdline_p = boot_command_line;</span>
<span class="p_add">+</span>
<span class="p_add">+	parse_early_param();</span>
<span class="p_add">+</span>
<span class="p_add">+	init_mm.start_code = (unsigned long) _stext;</span>
<span class="p_add">+	init_mm.end_code   = (unsigned long) _etext;</span>
<span class="p_add">+	init_mm.end_data   = (unsigned long) _edata;</span>
<span class="p_add">+	init_mm.brk        = (unsigned long) _end;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_bootmem();</span>
<span class="p_add">+	paging_init();</span>
<span class="p_add">+	unflatten_device_tree();</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	setup_smp();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+	conswitchp = &amp;dummy_con;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	riscv_fill_hwcap();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init riscv_device_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+subsys_initcall_sync(riscv_device_init);</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smp.c b/arch/riscv/kernel/smp.c</span>
new file mode 100644
<span class="p_header">index 000000000000..b4a71ec5906f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smp.c</span>
<span class="p_chunk">@@ -0,0 +1,110 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* A collection of single bit ipi messages.  */</span>
<span class="p_add">+static struct {</span>
<span class="p_add">+	unsigned long bits ____cacheline_aligned;</span>
<span class="p_add">+} ipi_data[NR_CPUS] __cacheline_aligned;</span>
<span class="p_add">+</span>
<span class="p_add">+enum ipi_message_type {</span>
<span class="p_add">+	IPI_RESCHEDULE,</span>
<span class="p_add">+	IPI_CALL_FUNC,</span>
<span class="p_add">+	IPI_MAX</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+irqreturn_t handle_ipi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *pending_ipis = &amp;ipi_data[smp_processor_id()].bits;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear pending IPI */</span>
<span class="p_add">+	csr_clear(sip, SIE_SSIE);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (true) {</span>
<span class="p_add">+		unsigned long ops;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Order bit clearing and data access. */</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+</span>
<span class="p_add">+		ops = xchg(pending_ipis, 0);</span>
<span class="p_add">+		if (ops == 0)</span>
<span class="p_add">+			return IRQ_HANDLED;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_RESCHEDULE))</span>
<span class="p_add">+			scheduler_ipi();</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_CALL_FUNC))</span>
<span class="p_add">+			generic_smp_call_function_interrupt();</span>
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON((ops &gt;&gt; IPI_MAX) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Order data access and bit testing. */</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void</span>
<span class="p_add">+send_ipi_message(const struct cpumask *to_whom, enum ipi_message_type operation)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	for_each_cpu(i, to_whom)</span>
<span class="p_add">+		set_bit(operation, &amp;ipi_data[i].bits);</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	sbi_send_ipi(cpumask_bits(to_whom));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_ipi_mask(struct cpumask *mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(mask, IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_single_ipi(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void ipi_stop(void *unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (1)</span>
<span class="p_add">+		wait_for_interrupt();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_stop, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_reschedule(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_RESCHEDULE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smpboot.c b/arch/riscv/kernel/smpboot.c</span>
new file mode 100644
<span class="p_header">index 000000000000..30d8213593bf</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smpboot.c</span>
<span class="p_chunk">@@ -0,0 +1,112 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel_stat.h&gt;</span>
<span class="p_add">+#include &lt;linux/notifier.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;asm/irq.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void *__cpu_up_stack_pointer[NR_CPUS];</span>
<span class="p_add">+void *__cpu_up_task_pointer[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_boot_cpu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_cpus(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_smp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dn = NULL;</span>
<span class="p_add">+	int hart, im_okay_therefore_i_am = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((dn = of_find_node_by_type(dn, &quot;cpu&quot;))) {</span>
<span class="p_add">+		hart = riscv_of_processor_hart(dn);</span>
<span class="p_add">+		if (hart &gt;= 0) {</span>
<span class="p_add">+			set_cpu_possible(hart, true);</span>
<span class="p_add">+			set_cpu_present(hart, true);</span>
<span class="p_add">+			if (hart == smp_processor_id()) {</span>
<span class="p_add">+				BUG_ON(im_okay_therefore_i_am);</span>
<span class="p_add">+				im_okay_therefore_i_am = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!im_okay_therefore_i_am);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __cpu_up(unsigned int cpu, struct task_struct *tidle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On RISC-V systems, all harts boot on their own accord.  Our _start</span>
<span class="p_add">+	 * selects the first hart to boot the kernel and causes the remainder</span>
<span class="p_add">+	 * of the harts to spin in a loop waiting for their stack pointer to be</span>
<span class="p_add">+	 * setup by that main hart.  Writing __cpu_up_stack_pointer signals to</span>
<span class="p_add">+	 * the spinning harts that they can continue the boot process.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+	__cpu_up_stack_pointer[cpu] = task_stack_page(tidle) + THREAD_SIZE;</span>
<span class="p_add">+	__cpu_up_task_pointer[cpu] = tidle;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!cpu_online(cpu))</span>
<span class="p_add">+		cpu_relax();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_cpus_done(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * C entry point for a secondary processor.</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void __init smp_callin(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = &amp;init_mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All kernel threads share the same mm context.  */</span>
<span class="p_add">+	atomic_inc(&amp;mm-&gt;mm_count);</span>
<span class="p_add">+	current-&gt;active_mm = mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	trap_init();</span>
<span class="p_add">+	init_clockevent();</span>
<span class="p_add">+	notify_cpu_starting(smp_processor_id());</span>
<span class="p_add">+	set_cpu_online(smp_processor_id(), 1);</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/time.c b/arch/riscv/kernel/time.c</span>
new file mode 100644
<span class="p_header">index 000000000000..6e72c61ba816</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/time.c</span>
<span class="p_chunk">@@ -0,0 +1,76 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/clocksource.h&gt;</span>
<span class="p_add">+#include &lt;linux/clockchips.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/timer_riscv.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long riscv_timebase;</span>
<span class="p_add">+</span>
<span class="p_add">+static int next_event(unsigned long delta, struct clock_event_device *ce)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * time_init() allocates a timer for each CPU.  Since we&#39;re writing the</span>
<span class="p_add">+	 * timer comparison register here we can&#39;t allow the timers to cross</span>
<span class="p_add">+	 * harts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUG_ON(ce != timer_riscv_device(smp_processor_id()));</span>
<span class="p_add">+	sbi_set_timer(get_cycles64() + delta);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long long rdtime(struct clocksource *cs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * It&#39;s guarnteed that all the timers across all the harts are</span>
<span class="p_add">+	 * synchronized within one tick of each other, so while this could</span>
<span class="p_add">+	 * technically go backwards when hopping between CPUs, practically it</span>
<span class="p_add">+	 * won&#39;t happen.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return get_cycles64();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void riscv_timer_interrupt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
<span class="p_add">+	struct clock_event_device *evdev = timer_riscv_device(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	evdev-&gt;event_handler(evdev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init init_clockevent(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu_id = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	timer_riscv_init(cpu_id, riscv_timebase, &amp;rdtime, &amp;next_event);</span>
<span class="p_add">+	csr_set(sie, SIE_STIE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init time_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *cpu;</span>
<span class="p_add">+	u32 prop;</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu = of_find_node_by_path(&quot;/cpus&quot;);</span>
<span class="p_add">+	if (!cpu || of_property_read_u32(cpu, &quot;timebase-frequency&quot;, &amp;prop))</span>
<span class="p_add">+		panic(KERN_WARNING &quot;RISC-V system with no &#39;timebase-frequency&#39; in DTS\n&quot;);</span>
<span class="p_add">+	riscv_timebase = prop;</span>
<span class="p_add">+</span>
<span class="p_add">+	lpj_fine = riscv_timebase / HZ;</span>
<span class="p_add">+</span>
<span class="p_add">+	init_clockevent();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c</span>
new file mode 100644
<span class="p_header">index 000000000000..93132cb59184</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/traps.c</span>
<span class="p_chunk">@@ -0,0 +1,180 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/kdebug.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+int show_unhandled_signals = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+extern asmlinkage void handle_exception(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_SPINLOCK(die_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+void die(struct pt_regs *regs, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int die_counter;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	oops_enter();</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;die_lock);</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+	bust_spinlocks(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;%s [#%d]\n&quot;, str, ++die_counter);</span>
<span class="p_add">+	print_modules();</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = notify_die(DIE_OOPS, str, regs, 0, regs-&gt;scause, SIGSEGV);</span>
<span class="p_add">+</span>
<span class="p_add">+	bust_spinlocks(0);</span>
<span class="p_add">+	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);</span>
<span class="p_add">+	spin_unlock_irq(&amp;die_lock);</span>
<span class="p_add">+	oops_exit();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (in_interrupt())</span>
<span class="p_add">+		panic(&quot;Fatal exception in interrupt&quot;);</span>
<span class="p_add">+	if (panic_on_oops)</span>
<span class="p_add">+		panic(&quot;Fatal exception&quot;);</span>
<span class="p_add">+	if (ret != NOTIFY_STOP)</span>
<span class="p_add">+		do_exit(SIGSEGV);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void do_trap_siginfo(int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	info.si_signo = signo;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = code;</span>
<span class="p_add">+	info.si_addr = (void __user *)addr;</span>
<span class="p_add">+	force_sig_info(signo, &amp;info, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_trap(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (show_unhandled_signals &amp;&amp; unhandled_signal(tsk, signo)</span>
<span class="p_add">+	    &amp;&amp; printk_ratelimit()) {</span>
<span class="p_add">+		pr_info(&quot;%s[%d]: unhandled signal %d code 0x%x at 0x&quot; REG_FMT,</span>
<span class="p_add">+			tsk-&gt;comm, task_pid_nr(tsk), signo, code, addr);</span>
<span class="p_add">+		print_vma_addr(KERN_CONT &quot; in &quot;, GET_IP(regs));</span>
<span class="p_add">+		pr_cont(&quot;\n&quot;);</span>
<span class="p_add">+		show_regs(regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(signo, code, addr, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void do_trap_error(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		do_trap(regs, signo, code, addr, current);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!fixup_exception(regs))</span>
<span class="p_add">+			die(regs, str);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define DO_ERROR_INFO(name, signo, code, str)				\</span>
<span class="p_add">+asmlinkage void name(struct pt_regs *regs)				\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	do_trap_error(regs, signo, code, regs-&gt;sepc, &quot;Oops - &quot; str);	\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_unknown,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;unknown exception&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;instruction address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;instruction access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_illegal,</span>
<span class="p_add">+	SIGILL, ILL_ILLOPC, &quot;illegal instruction&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_load_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;load address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_load_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;load access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_store_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;store (or AMO) address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_store_fault,</span>
<span class="p_add">+	SIGSEGV, SEGV_ACCERR, &quot;store (or AMO) access fault&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_u,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from U-mode&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_s,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from S-mode&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_ecall_m,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;environment call from M-mode&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void do_trap_break(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+	if (!user_mode(regs)) {</span>
<span class="p_add">+		enum bug_trap_type type;</span>
<span class="p_add">+</span>
<span class="p_add">+		type = report_bug(regs-&gt;sepc, regs);</span>
<span class="p_add">+		switch (type) {</span>
<span class="p_add">+		case BUG_TRAP_TYPE_NONE:</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_WARN:</span>
<span class="p_add">+			regs-&gt;sepc += sizeof(bug_insn_t);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_BUG:</span>
<span class="p_add">+			die(regs, &quot;Kernel BUG&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(SIGTRAP, TRAP_BRKPT, regs-&gt;sepc, current);</span>
<span class="p_add">+	regs-&gt;sepc += 0x4;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+int is_valid_bugaddr(unsigned long pc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bug_insn_t insn;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pc &lt; PAGE_OFFSET)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (probe_kernel_address((bug_insn_t __user *)pc, insn))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return (insn == __BUG_INSN);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+void __init trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set sup0 scratch register to 0, indicating to exception vector</span>
<span class="p_add">+	 * that we are presently executing in the kernel</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	csr_write(sscratch, 0);</span>
<span class="p_add">+	/* Set the exception vector address */</span>
<span class="p_add">+	csr_write(stvec, &amp;handle_exception);</span>
<span class="p_add">+	/* Enable all interrupts */</span>
<span class="p_add">+	csr_write(sie, -1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso.c b/arch/riscv/kernel/vdso.c</span>
new file mode 100644
<span class="p_header">index 000000000000..e8a178df8144</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso.c</span>
<span class="p_chunk">@@ -0,0 +1,125 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2004 Benjamin Herrenschmidt, IBM Corp.</span>
<span class="p_add">+ *                    &lt;benh@kernel.crashing.org&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Limited</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/binfmts.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern char vdso_start[], vdso_end[];</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int vdso_pages;</span>
<span class="p_add">+static struct page **vdso_pagelist;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The vDSO data page.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static union {</span>
<span class="p_add">+	struct vdso_data	data;</span>
<span class="p_add">+	u8			page[PAGE_SIZE];</span>
<span class="p_add">+} vdso_data_store __page_aligned_data;</span>
<span class="p_add">+struct vdso_data *vdso_data = &amp;vdso_data_store.data;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init vdso_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_pages = (vdso_end - vdso_start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	vdso_pagelist =</span>
<span class="p_add">+		kcalloc(vdso_pages + 1, sizeof(struct page *), GFP_KERNEL);</span>
<span class="p_add">+	if (unlikely(vdso_pagelist == NULL)) {</span>
<span class="p_add">+		pr_err(&quot;vdso: pagelist allocation failed\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; vdso_pages; i++) {</span>
<span class="p_add">+		struct page *pg;</span>
<span class="p_add">+</span>
<span class="p_add">+		pg = virt_to_page(vdso_start + (i &lt;&lt; PAGE_SHIFT));</span>
<span class="p_add">+		ClearPageReserved(pg);</span>
<span class="p_add">+		vdso_pagelist[i] = pg;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	vdso_pagelist[i] = virt_to_page(vdso_data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(vdso_init);</span>
<span class="p_add">+</span>
<span class="p_add">+int arch_setup_additional_pages(struct linux_binprm *bprm,</span>
<span class="p_add">+	int uses_interp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = current-&gt;mm;</span>
<span class="p_add">+	unsigned long vdso_base, vdso_len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_len = (vdso_pages + 1) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	vdso_base = get_unmapped_area(NULL, 0, vdso_len, 0, 0);</span>
<span class="p_add">+	if (unlikely(IS_ERR_VALUE(vdso_base))) {</span>
<span class="p_add">+		ret = vdso_base;</span>
<span class="p_add">+		goto end;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Put vDSO base into mm struct. We need to do this before calling</span>
<span class="p_add">+	 * install_special_mapping or the perf counter mmap tracking code</span>
<span class="p_add">+	 * will fail to recognise it as a vDSO (since arch_vma_name fails).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mm-&gt;context.vdso = (void *)vdso_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = install_special_mapping(mm, vdso_base, vdso_len,</span>
<span class="p_add">+		(VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC),</span>
<span class="p_add">+		vdso_pagelist);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(ret))</span>
<span class="p_add">+		mm-&gt;context.vdso = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+end:</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const char *arch_vma_name(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (vma-&gt;vm_mm &amp;&amp; (vma-&gt;vm_start == (long)vma-&gt;vm_mm-&gt;context.vdso))</span>
<span class="p_add">+		return &quot;[vdso]&quot;;</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Function stubs to prevent linker errors when AT_SYSINFO_EHDR is defined</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area_no_mm(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct vm_area_struct *get_gate_vma(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/mm/init.c b/arch/riscv/mm/init.c</span>
new file mode 100644
<span class="p_header">index 000000000000..9f4bee5e51fd</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/mm/init.c</span>
<span class="p_chunk">@@ -0,0 +1,70 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *   GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/bootmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/swap.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/io.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init zone_sizes_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long zones_size[MAX_NR_ZONES];</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(zones_size, 0, sizeof(zones_size));</span>
<span class="p_add">+	zones_size[ZONE_NORMAL] = max_mapnr;</span>
<span class="p_add">+	free_area_init_node(0, zones_size, pfn_base, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void setup_zero_page(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset((void *)empty_zero_page, 0, PAGE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init paging_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	init_mm.pgd = (pgd_t *)pfn_to_virt(csr_read(sptbr));</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_zero_page();</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	zone_sizes_init();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init mem_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_FLATMEM</span>
<span class="p_add">+	BUG_ON(!mem_map);</span>
<span class="p_add">+#endif /* CONFIG_FLATMEM */</span>
<span class="p_add">+</span>
<span class="p_add">+	high_memory = (void *)(__va(PFN_PHYS(max_low_pfn)));</span>
<span class="p_add">+	free_all_bootmem();</span>
<span class="p_add">+</span>
<span class="p_add">+	mem_init_print_info(NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void free_initmem(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	free_initmem_default(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+void free_initrd_mem(unsigned long start, unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



