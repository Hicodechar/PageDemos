
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.14 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.14</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 12, 2017, 1:05 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170312130507.GB18683@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9619321/mbox/"
   >mbox</a>
|
   <a href="/patch/9619321/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9619321/">/patch/9619321/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	33F0F60417 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 12 Mar 2017 13:06:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 161DA284DE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 12 Mar 2017 13:06:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 0896B28503; Sun, 12 Mar 2017 13:06:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 40134284DE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 12 Mar 2017 13:06:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933920AbdCLNGl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 12 Mar 2017 09:06:41 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:44956 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S933758AbdCLNG2 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 12 Mar 2017 09:06:28 -0400
Received: from localhost (unknown [88.128.80.189])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id C27D488A;
	Sun, 12 Mar 2017 13:06:15 +0000 (UTC)
Date: Sun, 12 Mar 2017 14:05:07 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.14
Message-ID: &lt;20170312130507.GB18683@kroah.com&gt;
References: &lt;20170312130502.GA18683@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170312130502.GA18683@kroah.com&gt;
User-Agent: Mutt/1.8.0 (2017-02-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - March 12, 2017, 1:05 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 14dc2758345b..5e7706e94622 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 13</span>
<span class="p_add">+SUBLEVEL = 14</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d2_xplained.dts b/arch/arm/boot/dts/at91-sama5d2_xplained.dts</span>
<span class="p_header">index 0b9a59d5fdac..30fac04289a5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d2_xplained.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d2_xplained.dts</span>
<span class="p_chunk">@@ -148,6 +148,8 @@</span> <span class="p_context"></span>
 			uart1: serial@f8020000 {
 				pinctrl-names = &quot;default&quot;;
 				pinctrl-0 = &lt;&amp;pinctrl_uart1_default&gt;;
<span class="p_add">+				atmel,use-dma-rx;</span>
<span class="p_add">+				atmel,use-dma-tx;</span>
 				status = &quot;okay&quot;;
 			};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d4_xplained.dts b/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_header">index ed7fce297738..44d1171c7fc0 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_chunk">@@ -110,6 +110,8 @@</span> <span class="p_context"></span>
 			};
 
 			usart3: serial@fc00c000 {
<span class="p_add">+				atmel,use-dma-rx;</span>
<span class="p_add">+				atmel,use-dma-tx;</span>
 				status = &quot;okay&quot;;
 			};
 
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_mmu.h b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">index 74a44727f8e1..a58bbaa3ec60 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -150,18 +150,12 @@</span> <span class="p_context"> static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu,</span>
 	 * and iterate over the range.
 	 */
 
<span class="p_del">-	bool need_flush = !vcpu_has_cache_enabled(vcpu) || ipa_uncached;</span>
<span class="p_del">-</span>
 	VM_BUG_ON(size &amp; ~PAGE_MASK);
 
<span class="p_del">-	if (!need_flush &amp;&amp; !icache_is_pipt())</span>
<span class="p_del">-		goto vipt_cache;</span>
<span class="p_del">-</span>
 	while (size) {
 		void *va = kmap_atomic_pfn(pfn);
 
<span class="p_del">-		if (need_flush)</span>
<span class="p_del">-			kvm_flush_dcache_to_poc(va, PAGE_SIZE);</span>
<span class="p_add">+		kvm_flush_dcache_to_poc(va, PAGE_SIZE);</span>
 
 		if (icache_is_pipt())
 			__cpuc_coherent_user_range((unsigned long)va,
<span class="p_chunk">@@ -173,7 +167,6 @@</span> <span class="p_context"> static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu,</span>
 		kunmap_atomic(va);
 	}
 
<span class="p_del">-vipt_cache:</span>
 	if (!icache_is_pipt() &amp;&amp; !icache_is_vivt_asid_tagged()) {
 		/* any kind of VIPT cache */
 		__flush_icache_all();
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">index 6f72fe8b0e3e..6d22017ebbad 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -241,8 +241,7 @@</span> <span class="p_context"> static inline void __coherent_cache_guest_page(struct kvm_vcpu *vcpu,</span>
 {
 	void *va = page_address(pfn_to_page(pfn));
 
<span class="p_del">-	if (!vcpu_has_cache_enabled(vcpu) || ipa_uncached)</span>
<span class="p_del">-		kvm_flush_dcache_to_poc(va, size);</span>
<span class="p_add">+	kvm_flush_dcache_to_poc(va, size);</span>
 
 	if (!icache_is_aliasing()) {		/* PIPT */
 		flush_icache_range((unsigned long)va,
<span class="p_header">diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c</span>
<span class="p_header">index c02504ea304b..3a129d48674e 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpufeature.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpufeature.c</span>
<span class="p_chunk">@@ -653,15 +653,15 @@</span> <span class="p_context"> static u64 __raw_read_system_reg(u32 sys_id)</span>
 	case SYS_ID_ISAR2_EL1:		return read_cpuid(ID_ISAR2_EL1);
 	case SYS_ID_ISAR3_EL1:		return read_cpuid(ID_ISAR3_EL1);
 	case SYS_ID_ISAR4_EL1:		return read_cpuid(ID_ISAR4_EL1);
<span class="p_del">-	case SYS_ID_ISAR5_EL1:		return read_cpuid(ID_ISAR4_EL1);</span>
<span class="p_add">+	case SYS_ID_ISAR5_EL1:		return read_cpuid(ID_ISAR5_EL1);</span>
 	case SYS_MVFR0_EL1:		return read_cpuid(MVFR0_EL1);
 	case SYS_MVFR1_EL1:		return read_cpuid(MVFR1_EL1);
 	case SYS_MVFR2_EL1:		return read_cpuid(MVFR2_EL1);
 
 	case SYS_ID_AA64PFR0_EL1:	return read_cpuid(ID_AA64PFR0_EL1);
<span class="p_del">-	case SYS_ID_AA64PFR1_EL1:	return read_cpuid(ID_AA64PFR0_EL1);</span>
<span class="p_add">+	case SYS_ID_AA64PFR1_EL1:	return read_cpuid(ID_AA64PFR1_EL1);</span>
 	case SYS_ID_AA64DFR0_EL1:	return read_cpuid(ID_AA64DFR0_EL1);
<span class="p_del">-	case SYS_ID_AA64DFR1_EL1:	return read_cpuid(ID_AA64DFR0_EL1);</span>
<span class="p_add">+	case SYS_ID_AA64DFR1_EL1:	return read_cpuid(ID_AA64DFR1_EL1);</span>
 	case SYS_ID_AA64MMFR0_EL1:	return read_cpuid(ID_AA64MMFR0_EL1);
 	case SYS_ID_AA64MMFR1_EL1:	return read_cpuid(ID_AA64MMFR1_EL1);
 	case SYS_ID_AA64MMFR2_EL1:	return read_cpuid(ID_AA64MMFR2_EL1);
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index 02265a589ef5..b5bf46ce873b 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -352,6 +352,13 @@</span> <span class="p_context"> static int __swiotlb_dma_supported(struct device *hwdev, u64 mask)</span>
 	return 1;
 }
 
<span class="p_add">+static int __swiotlb_dma_mapping_error(struct device *hwdev, dma_addr_t addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (swiotlb)</span>
<span class="p_add">+		return swiotlb_dma_mapping_error(hwdev, addr);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct dma_map_ops swiotlb_dma_ops = {
 	.alloc = __dma_alloc,
 	.free = __dma_free,
<span class="p_chunk">@@ -366,7 +373,7 @@</span> <span class="p_context"> static struct dma_map_ops swiotlb_dma_ops = {</span>
 	.sync_sg_for_cpu = __swiotlb_sync_sg_for_cpu,
 	.sync_sg_for_device = __swiotlb_sync_sg_for_device,
 	.dma_supported = __swiotlb_dma_supported,
<span class="p_del">-	.mapping_error = swiotlb_dma_mapping_error,</span>
<span class="p_add">+	.mapping_error = __swiotlb_dma_mapping_error,</span>
 };
 
 static int __init atomic_pool_init(void)
<span class="p_header">diff --git a/arch/mips/bcm47xx/buttons.c b/arch/mips/bcm47xx/buttons.c</span>
<span class="p_header">index 52caa75bfe4e..e2f50d690624 100644</span>
<span class="p_header">--- a/arch/mips/bcm47xx/buttons.c</span>
<span class="p_header">+++ b/arch/mips/bcm47xx/buttons.c</span>
<span class="p_chunk">@@ -17,6 +17,12 @@</span> <span class="p_context"></span>
 		.active_low	= 1,					\
 	}
 
<span class="p_add">+#define BCM47XX_GPIO_KEY_H(_gpio, _code)				\</span>
<span class="p_add">+	{								\</span>
<span class="p_add">+		.code		= _code,				\</span>
<span class="p_add">+		.gpio		= _gpio,				\</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 /* Asus */
 
 static const struct gpio_keys_button
<span class="p_chunk">@@ -79,8 +85,8 @@</span> <span class="p_context"> bcm47xx_buttons_asus_wl500gpv2[] __initconst = {</span>
 
 static const struct gpio_keys_button
 bcm47xx_buttons_asus_wl500w[] __initconst = {
<span class="p_del">-	BCM47XX_GPIO_KEY(6, KEY_RESTART),</span>
<span class="p_del">-	BCM47XX_GPIO_KEY(7, KEY_WPS_BUTTON),</span>
<span class="p_add">+	BCM47XX_GPIO_KEY_H(6, KEY_RESTART),</span>
<span class="p_add">+	BCM47XX_GPIO_KEY_H(7, KEY_WPS_BUTTON),</span>
 };
 
 static const struct gpio_keys_button
<span class="p_header">diff --git a/arch/mips/cavium-octeon/octeon-memcpy.S b/arch/mips/cavium-octeon/octeon-memcpy.S</span>
<span class="p_header">index 64e08df51d65..8b7004132491 100644</span>
<span class="p_header">--- a/arch/mips/cavium-octeon/octeon-memcpy.S</span>
<span class="p_header">+++ b/arch/mips/cavium-octeon/octeon-memcpy.S</span>
<span class="p_chunk">@@ -208,18 +208,18 @@</span> <span class="p_context"> EXC(	STORE	t2, UNIT(6)(dst),	s_exc_p10u)</span>
 	ADD	src, src, 16*NBYTES
 EXC(	STORE	t3, UNIT(7)(dst),	s_exc_p9u)
 	ADD	dst, dst, 16*NBYTES
<span class="p_del">-EXC(	LOAD	t0, UNIT(-8)(src),	l_exc_copy)</span>
<span class="p_del">-EXC(	LOAD	t1, UNIT(-7)(src),	l_exc_copy)</span>
<span class="p_del">-EXC(	LOAD	t2, UNIT(-6)(src),	l_exc_copy)</span>
<span class="p_del">-EXC(	LOAD	t3, UNIT(-5)(src),	l_exc_copy)</span>
<span class="p_add">+EXC(	LOAD	t0, UNIT(-8)(src),	l_exc_copy_rewind16)</span>
<span class="p_add">+EXC(	LOAD	t1, UNIT(-7)(src),	l_exc_copy_rewind16)</span>
<span class="p_add">+EXC(	LOAD	t2, UNIT(-6)(src),	l_exc_copy_rewind16)</span>
<span class="p_add">+EXC(	LOAD	t3, UNIT(-5)(src),	l_exc_copy_rewind16)</span>
 EXC(	STORE	t0, UNIT(-8)(dst),	s_exc_p8u)
 EXC(	STORE	t1, UNIT(-7)(dst),	s_exc_p7u)
 EXC(	STORE	t2, UNIT(-6)(dst),	s_exc_p6u)
 EXC(	STORE	t3, UNIT(-5)(dst),	s_exc_p5u)
<span class="p_del">-EXC(	LOAD	t0, UNIT(-4)(src),	l_exc_copy)</span>
<span class="p_del">-EXC(	LOAD	t1, UNIT(-3)(src),	l_exc_copy)</span>
<span class="p_del">-EXC(	LOAD	t2, UNIT(-2)(src),	l_exc_copy)</span>
<span class="p_del">-EXC(	LOAD	t3, UNIT(-1)(src),	l_exc_copy)</span>
<span class="p_add">+EXC(	LOAD	t0, UNIT(-4)(src),	l_exc_copy_rewind16)</span>
<span class="p_add">+EXC(	LOAD	t1, UNIT(-3)(src),	l_exc_copy_rewind16)</span>
<span class="p_add">+EXC(	LOAD	t2, UNIT(-2)(src),	l_exc_copy_rewind16)</span>
<span class="p_add">+EXC(	LOAD	t3, UNIT(-1)(src),	l_exc_copy_rewind16)</span>
 EXC(	STORE	t0, UNIT(-4)(dst),	s_exc_p4u)
 EXC(	STORE	t1, UNIT(-3)(dst),	s_exc_p3u)
 EXC(	STORE	t2, UNIT(-2)(dst),	s_exc_p2u)
<span class="p_chunk">@@ -383,6 +383,10 @@</span> <span class="p_context"> done:</span>
 	 nop
 	END(memcpy)
 
<span class="p_add">+l_exc_copy_rewind16:</span>
<span class="p_add">+	/* Rewind src and dst by 16*NBYTES for l_exc_copy */</span>
<span class="p_add">+	SUB	src, src, 16*NBYTES</span>
<span class="p_add">+	SUB	dst, dst, 16*NBYTES</span>
 l_exc_copy:
 	/*
 	 * Copy bytes from src until faulting load address (or until a
<span class="p_header">diff --git a/arch/mips/include/asm/checksum.h b/arch/mips/include/asm/checksum.h</span>
<span class="p_header">index bce1ce53149a..0e231970653a 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/checksum.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/checksum.h</span>
<span class="p_chunk">@@ -186,7 +186,9 @@</span> <span class="p_context"> static inline __wsum csum_tcpudp_nofold(__be32 saddr, __be32 daddr,</span>
 	&quot;	daddu	%0, %4		\n&quot;
 	&quot;	dsll32	$1, %0, 0	\n&quot;
 	&quot;	daddu	%0, $1		\n&quot;
<span class="p_add">+	&quot;	sltu	$1, %0, $1	\n&quot;</span>
 	&quot;	dsra32	%0, %0, 0	\n&quot;
<span class="p_add">+	&quot;	addu	%0, $1		\n&quot;</span>
 #endif
 	&quot;	.set	pop&quot;
 	: &quot;=r&quot; (sum)
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index 9514e5f2209f..1652f36acad1 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -195,11 +195,9 @@</span> <span class="p_context"> struct mips_frame_info {</span>
 #define J_TARGET(pc,target)	\
 		(((unsigned long)(pc) &amp; 0xf0000000) | ((target) &lt;&lt; 2))
 
<span class="p_del">-static inline int is_ra_save_ins(union mips_instruction *ip)</span>
<span class="p_add">+static inline int is_ra_save_ins(union mips_instruction *ip, int *poff)</span>
 {
 #ifdef CONFIG_CPU_MICROMIPS
<span class="p_del">-	union mips_instruction mmi;</span>
<span class="p_del">-</span>
 	/*
 	 * swsp ra,offset
 	 * swm16 reglist,offset(sp)
<span class="p_chunk">@@ -209,29 +207,71 @@</span> <span class="p_context"> static inline int is_ra_save_ins(union mips_instruction *ip)</span>
 	 *
 	 * microMIPS is way more fun...
 	 */
<span class="p_del">-	if (mm_insn_16bit(ip-&gt;halfword[0])) {</span>
<span class="p_del">-		mmi.word = (ip-&gt;halfword[0] &lt;&lt; 16);</span>
<span class="p_del">-		return (mmi.mm16_r5_format.opcode == mm_swsp16_op &amp;&amp;</span>
<span class="p_del">-			mmi.mm16_r5_format.rt == 31) ||</span>
<span class="p_del">-		       (mmi.mm16_m_format.opcode == mm_pool16c_op &amp;&amp;</span>
<span class="p_del">-			mmi.mm16_m_format.func == mm_swm16_op);</span>
<span class="p_add">+	if (mm_insn_16bit(ip-&gt;halfword[1])) {</span>
<span class="p_add">+		switch (ip-&gt;mm16_r5_format.opcode) {</span>
<span class="p_add">+		case mm_swsp16_op:</span>
<span class="p_add">+			if (ip-&gt;mm16_r5_format.rt != 31)</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			*poff = ip-&gt;mm16_r5_format.simmediate;</span>
<span class="p_add">+			*poff = (*poff &lt;&lt; 2) / sizeof(ulong);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		case mm_pool16c_op:</span>
<span class="p_add">+			switch (ip-&gt;mm16_m_format.func) {</span>
<span class="p_add">+			case mm_swm16_op:</span>
<span class="p_add">+				*poff = ip-&gt;mm16_m_format.imm;</span>
<span class="p_add">+				*poff += 1 + ip-&gt;mm16_m_format.rlist;</span>
<span class="p_add">+				*poff = (*poff &lt;&lt; 2) / sizeof(ulong);</span>
<span class="p_add">+				return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			default:</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	else {</span>
<span class="p_del">-		mmi.halfword[0] = ip-&gt;halfword[1];</span>
<span class="p_del">-		mmi.halfword[1] = ip-&gt;halfword[0];</span>
<span class="p_del">-		return (mmi.mm_m_format.opcode == mm_pool32b_op &amp;&amp;</span>
<span class="p_del">-			mmi.mm_m_format.rd &gt; 9 &amp;&amp;</span>
<span class="p_del">-			mmi.mm_m_format.base == 29 &amp;&amp;</span>
<span class="p_del">-			mmi.mm_m_format.func == mm_swm32_func) ||</span>
<span class="p_del">-		       (mmi.i_format.opcode == mm_sw32_op &amp;&amp;</span>
<span class="p_del">-			mmi.i_format.rs == 29 &amp;&amp;</span>
<span class="p_del">-			mmi.i_format.rt == 31);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (ip-&gt;i_format.opcode) {</span>
<span class="p_add">+	case mm_sw32_op:</span>
<span class="p_add">+		if (ip-&gt;i_format.rs != 29)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		if (ip-&gt;i_format.rt != 31)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		*poff = ip-&gt;i_format.simmediate / sizeof(ulong);</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	case mm_pool32b_op:</span>
<span class="p_add">+		switch (ip-&gt;mm_m_format.func) {</span>
<span class="p_add">+		case mm_swm32_func:</span>
<span class="p_add">+			if (ip-&gt;mm_m_format.rd &lt; 0x10)</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			if (ip-&gt;mm_m_format.base != 29)</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			*poff = ip-&gt;mm_m_format.simmediate;</span>
<span class="p_add">+			*poff += (ip-&gt;mm_m_format.rd &amp; 0xf) * sizeof(u32);</span>
<span class="p_add">+			*poff /= sizeof(ulong);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return 0;</span>
 	}
 #else
 	/* sw / sd $ra, offset($sp) */
<span class="p_del">-	return (ip-&gt;i_format.opcode == sw_op || ip-&gt;i_format.opcode == sd_op) &amp;&amp;</span>
<span class="p_del">-		ip-&gt;i_format.rs == 29 &amp;&amp;</span>
<span class="p_del">-		ip-&gt;i_format.rt == 31;</span>
<span class="p_add">+	if ((ip-&gt;i_format.opcode == sw_op || ip-&gt;i_format.opcode == sd_op) &amp;&amp;</span>
<span class="p_add">+		ip-&gt;i_format.rs == 29 &amp;&amp; ip-&gt;i_format.rt == 31) {</span>
<span class="p_add">+		*poff = ip-&gt;i_format.simmediate / sizeof(ulong);</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 #endif
 }
 
<span class="p_chunk">@@ -246,13 +286,16 @@</span> <span class="p_context"> static inline int is_jump_ins(union mips_instruction *ip)</span>
 	 *
 	 * microMIPS is kind of more fun...
 	 */
<span class="p_del">-	union mips_instruction mmi;</span>
<span class="p_del">-</span>
<span class="p_del">-	mmi.word = (ip-&gt;halfword[0] &lt;&lt; 16);</span>
<span class="p_add">+	if (mm_insn_16bit(ip-&gt;halfword[1])) {</span>
<span class="p_add">+		if ((ip-&gt;mm16_r5_format.opcode == mm_pool16c_op &amp;&amp;</span>
<span class="p_add">+		    (ip-&gt;mm16_r5_format.rt &amp; mm_jr16_op) == mm_jr16_op))</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if ((mmi.mm16_r5_format.opcode == mm_pool16c_op &amp;&amp;</span>
<span class="p_del">-	    (mmi.mm16_r5_format.rt &amp; mm_jr16_op) == mm_jr16_op) ||</span>
<span class="p_del">-	    ip-&gt;j_format.opcode == mm_jal32_op)</span>
<span class="p_add">+	if (ip-&gt;j_format.opcode == mm_j32_op)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	if (ip-&gt;j_format.opcode == mm_jal32_op)</span>
 		return 1;
 	if (ip-&gt;r_format.opcode != mm_pool32a_op ||
 			ip-&gt;r_format.func != mm_pool32axf_op)
<span class="p_chunk">@@ -280,15 +323,13 @@</span> <span class="p_context"> static inline int is_sp_move_ins(union mips_instruction *ip)</span>
 	 *
 	 * microMIPS is not more fun...
 	 */
<span class="p_del">-	if (mm_insn_16bit(ip-&gt;halfword[0])) {</span>
<span class="p_del">-		union mips_instruction mmi;</span>
<span class="p_del">-</span>
<span class="p_del">-		mmi.word = (ip-&gt;halfword[0] &lt;&lt; 16);</span>
<span class="p_del">-		return (mmi.mm16_r3_format.opcode == mm_pool16d_op &amp;&amp;</span>
<span class="p_del">-			mmi.mm16_r3_format.simmediate &amp;&amp; mm_addiusp_func) ||</span>
<span class="p_del">-		       (mmi.mm16_r5_format.opcode == mm_pool16d_op &amp;&amp;</span>
<span class="p_del">-			mmi.mm16_r5_format.rt == 29);</span>
<span class="p_add">+	if (mm_insn_16bit(ip-&gt;halfword[1])) {</span>
<span class="p_add">+		return (ip-&gt;mm16_r3_format.opcode == mm_pool16d_op &amp;&amp;</span>
<span class="p_add">+			ip-&gt;mm16_r3_format.simmediate &amp;&amp; mm_addiusp_func) ||</span>
<span class="p_add">+		       (ip-&gt;mm16_r5_format.opcode == mm_pool16d_op &amp;&amp;</span>
<span class="p_add">+			ip-&gt;mm16_r5_format.rt == 29);</span>
 	}
<span class="p_add">+</span>
 	return ip-&gt;mm_i_format.opcode == mm_addiu32_op &amp;&amp;
 	       ip-&gt;mm_i_format.rt == 29 &amp;&amp; ip-&gt;mm_i_format.rs == 29;
 #else
<span class="p_chunk">@@ -303,30 +344,36 @@</span> <span class="p_context"> static inline int is_sp_move_ins(union mips_instruction *ip)</span>
 
 static int get_frame_info(struct mips_frame_info *info)
 {
<span class="p_del">-#ifdef CONFIG_CPU_MICROMIPS</span>
<span class="p_del">-	union mips_instruction *ip = (void *) (((char *) info-&gt;func) - 1);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	union mips_instruction *ip = info-&gt;func;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	unsigned max_insns = info-&gt;func_size / sizeof(union mips_instruction);</span>
<span class="p_del">-	unsigned i;</span>
<span class="p_add">+	bool is_mmips = IS_ENABLED(CONFIG_CPU_MICROMIPS);</span>
<span class="p_add">+	union mips_instruction insn, *ip, *ip_end;</span>
<span class="p_add">+	const unsigned int max_insns = 128;</span>
<span class="p_add">+	unsigned int i;</span>
 
 	info-&gt;pc_offset = -1;
 	info-&gt;frame_size = 0;
 
<span class="p_add">+	ip = (void *)msk_isa16_mode((ulong)info-&gt;func);</span>
 	if (!ip)
 		goto err;
 
<span class="p_del">-	if (max_insns == 0)</span>
<span class="p_del">-		max_insns = 128U;	/* unknown function size */</span>
<span class="p_del">-	max_insns = min(128U, max_insns);</span>
<span class="p_add">+	ip_end = (void *)ip + info-&gt;func_size;</span>
 
<span class="p_del">-	for (i = 0; i &lt; max_insns; i++, ip++) {</span>
<span class="p_add">+	for (i = 0; i &lt; max_insns &amp;&amp; ip &lt; ip_end; i++, ip++) {</span>
<span class="p_add">+		if (is_mmips &amp;&amp; mm_insn_16bit(ip-&gt;halfword[0])) {</span>
<span class="p_add">+			insn.halfword[0] = 0;</span>
<span class="p_add">+			insn.halfword[1] = ip-&gt;halfword[0];</span>
<span class="p_add">+		} else if (is_mmips) {</span>
<span class="p_add">+			insn.halfword[0] = ip-&gt;halfword[1];</span>
<span class="p_add">+			insn.halfword[1] = ip-&gt;halfword[0];</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			insn.word = ip-&gt;word;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		if (is_jump_ins(ip))</span>
<span class="p_add">+		if (is_jump_ins(&amp;insn))</span>
 			break;
<span class="p_add">+</span>
 		if (!info-&gt;frame_size) {
<span class="p_del">-			if (is_sp_move_ins(ip))</span>
<span class="p_add">+			if (is_sp_move_ins(&amp;insn))</span>
 			{
 #ifdef CONFIG_CPU_MICROMIPS
 				if (mm_insn_16bit(ip-&gt;halfword[0]))
<span class="p_chunk">@@ -349,11 +396,9 @@</span> <span class="p_context"> static int get_frame_info(struct mips_frame_info *info)</span>
 			}
 			continue;
 		}
<span class="p_del">-		if (info-&gt;pc_offset == -1 &amp;&amp; is_ra_save_ins(ip)) {</span>
<span class="p_del">-			info-&gt;pc_offset =</span>
<span class="p_del">-				ip-&gt;i_format.simmediate / sizeof(long);</span>
<span class="p_add">+		if (info-&gt;pc_offset == -1 &amp;&amp;</span>
<span class="p_add">+		    is_ra_save_ins(&amp;insn, &amp;info-&gt;pc_offset))</span>
 			break;
<span class="p_del">-		}</span>
 	}
 	if (info-&gt;frame_size &amp;&amp; info-&gt;pc_offset &gt;= 0) /* nested */
 		return 0;
<span class="p_header">diff --git a/arch/mips/lantiq/xway/sysctrl.c b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">index 236193b5210b..9a61671c00a7 100644</span>
<span class="p_header">--- a/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">+++ b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_chunk">@@ -545,7 +545,7 @@</span> <span class="p_context"> void __init ltq_soc_init(void)</span>
 		clkdev_add_pmu(&quot;1a800000.pcie&quot;, &quot;msi&quot;, 1, 1, PMU1_PCIE2_MSI);
 		clkdev_add_pmu(&quot;1a800000.pcie&quot;, &quot;pdi&quot;, 1, 1, PMU1_PCIE2_PDI);
 		clkdev_add_pmu(&quot;1a800000.pcie&quot;, &quot;ctl&quot;, 1, 1, PMU1_PCIE2_CTL);
<span class="p_del">-		clkdev_add_pmu(&quot;1e108000.eth&quot;, NULL, 1, 0, PMU_SWITCH | PMU_PPE_DP);</span>
<span class="p_add">+		clkdev_add_pmu(&quot;1e108000.eth&quot;, NULL, 0, 0, PMU_SWITCH | PMU_PPE_DP);</span>
 		clkdev_add_pmu(&quot;1da00000.usif&quot;, &quot;NULL&quot;, 1, 0, PMU_USIF);
 		clkdev_add_pmu(&quot;1e103100.deu&quot;, NULL, 1, 0, PMU_DEU);
 	} else if (of_machine_is_compatible(&quot;lantiq,ar10&quot;)) {
<span class="p_chunk">@@ -553,7 +553,7 @@</span> <span class="p_context"> void __init ltq_soc_init(void)</span>
 				  ltq_ar10_fpi_hz(), ltq_ar10_pp32_hz());
 		clkdev_add_pmu(&quot;1e101000.usb&quot;, &quot;ctl&quot;, 1, 0, PMU_USB0);
 		clkdev_add_pmu(&quot;1e106000.usb&quot;, &quot;ctl&quot;, 1, 0, PMU_USB1);
<span class="p_del">-		clkdev_add_pmu(&quot;1e108000.eth&quot;, NULL, 1, 0, PMU_SWITCH |</span>
<span class="p_add">+		clkdev_add_pmu(&quot;1e108000.eth&quot;, NULL, 0, 0, PMU_SWITCH |</span>
 			       PMU_PPE_DP | PMU_PPE_TC);
 		clkdev_add_pmu(&quot;1da00000.usif&quot;, &quot;NULL&quot;, 1, 0, PMU_USIF);
 		clkdev_add_pmu(&quot;1f203000.rcu&quot;, &quot;gphy&quot;, 1, 0, PMU_GPHY);
<span class="p_chunk">@@ -575,11 +575,11 @@</span> <span class="p_context"> void __init ltq_soc_init(void)</span>
 		clkdev_add_pmu(NULL, &quot;ahb&quot;, 1, 0, PMU_AHBM | PMU_AHBS);
 
 		clkdev_add_pmu(&quot;1da00000.usif&quot;, &quot;NULL&quot;, 1, 0, PMU_USIF);
<span class="p_del">-		clkdev_add_pmu(&quot;1e108000.eth&quot;, NULL, 1, 0,</span>
<span class="p_add">+		clkdev_add_pmu(&quot;1e108000.eth&quot;, NULL, 0, 0,</span>
 				PMU_SWITCH | PMU_PPE_DPLUS | PMU_PPE_DPLUM |
 				PMU_PPE_EMA | PMU_PPE_TC | PMU_PPE_SLL01 |
 				PMU_PPE_QSB | PMU_PPE_TOP);
<span class="p_del">-		clkdev_add_pmu(&quot;1f203000.rcu&quot;, &quot;gphy&quot;, 1, 0, PMU_GPHY);</span>
<span class="p_add">+		clkdev_add_pmu(&quot;1f203000.rcu&quot;, &quot;gphy&quot;, 0, 0, PMU_GPHY);</span>
 		clkdev_add_pmu(&quot;1e103000.sdio&quot;, NULL, 1, 0, PMU_SDIO);
 		clkdev_add_pmu(&quot;1e103100.deu&quot;, NULL, 1, 0, PMU_DEU);
 		clkdev_add_pmu(&quot;1e116000.mei&quot;, &quot;dfe&quot;, 1, 0, PMU_DFE);
<span class="p_header">diff --git a/arch/mips/mm/sc-ip22.c b/arch/mips/mm/sc-ip22.c</span>
<span class="p_header">index 026cb59a914d..f293a97cb885 100644</span>
<span class="p_header">--- a/arch/mips/mm/sc-ip22.c</span>
<span class="p_header">+++ b/arch/mips/mm/sc-ip22.c</span>
<span class="p_chunk">@@ -31,26 +31,40 @@</span> <span class="p_context"> static inline void indy_sc_wipe(unsigned long first, unsigned long last)</span>
 	unsigned long tmp;
 
 	__asm__ __volatile__(
<span class="p_del">-	&quot;.set\tpush\t\t\t# indy_sc_wipe\n\t&quot;</span>
<span class="p_del">-	&quot;.set\tnoreorder\n\t&quot;</span>
<span class="p_del">-	&quot;.set\tmips3\n\t&quot;</span>
<span class="p_del">-	&quot;.set\tnoat\n\t&quot;</span>
<span class="p_del">-	&quot;mfc0\t%2, $12\n\t&quot;</span>
<span class="p_del">-	&quot;li\t$1, 0x80\t\t\t# Go 64 bit\n\t&quot;</span>
<span class="p_del">-	&quot;mtc0\t$1, $12\n\t&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	&quot;dli\t$1, 0x9000000080000000\n\t&quot;</span>
<span class="p_del">-	&quot;or\t%0, $1\t\t\t# first line to flush\n\t&quot;</span>
<span class="p_del">-	&quot;or\t%1, $1\t\t\t# last line to flush\n\t&quot;</span>
<span class="p_del">-	&quot;.set\tat\n\t&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	&quot;1:\tsw\t$0, 0(%0)\n\t&quot;</span>
<span class="p_del">-	&quot;bne\t%0, %1, 1b\n\t&quot;</span>
<span class="p_del">-	&quot; daddu\t%0, 32\n\t&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	&quot;mtc0\t%2, $12\t\t\t# Back to 32 bit\n\t&quot;</span>
<span class="p_del">-	&quot;nop; nop; nop; nop;\n\t&quot;</span>
<span class="p_del">-	&quot;.set\tpop&quot;</span>
<span class="p_add">+	&quot;	.set	push			# indy_sc_wipe		\n&quot;</span>
<span class="p_add">+	&quot;	.set	noreorder					\n&quot;</span>
<span class="p_add">+	&quot;	.set	mips3						\n&quot;</span>
<span class="p_add">+	&quot;	.set	noat						\n&quot;</span>
<span class="p_add">+	&quot;	mfc0	%2, $12						\n&quot;</span>
<span class="p_add">+	&quot;	li	$1, 0x80		# Go 64 bit		\n&quot;</span>
<span class="p_add">+	&quot;	mtc0	$1, $12						\n&quot;</span>
<span class="p_add">+	&quot;								\n&quot;</span>
<span class="p_add">+	&quot;	#							\n&quot;</span>
<span class="p_add">+	&quot;	# Open code a dli $1, 0x9000000080000000		\n&quot;</span>
<span class="p_add">+	&quot;	#							\n&quot;</span>
<span class="p_add">+	&quot;	# Required because binutils 2.25 will happily accept	\n&quot;</span>
<span class="p_add">+	&quot;	# 64 bit instructions in .set mips3 mode but puke on	\n&quot;</span>
<span class="p_add">+	&quot;	# 64 bit constants when generating 32 bit ELF		\n&quot;</span>
<span class="p_add">+	&quot;	#							\n&quot;</span>
<span class="p_add">+	&quot;	lui	$1,0x9000					\n&quot;</span>
<span class="p_add">+	&quot;	dsll	$1,$1,0x10					\n&quot;</span>
<span class="p_add">+	&quot;	ori	$1,$1,0x8000					\n&quot;</span>
<span class="p_add">+	&quot;	dsll	$1,$1,0x10					\n&quot;</span>
<span class="p_add">+	&quot;								\n&quot;</span>
<span class="p_add">+	&quot;	or	%0, $1			# first line to flush	\n&quot;</span>
<span class="p_add">+	&quot;	or	%1, $1			# last line to flush	\n&quot;</span>
<span class="p_add">+	&quot;	.set	at						\n&quot;</span>
<span class="p_add">+	&quot;								\n&quot;</span>
<span class="p_add">+	&quot;1:	sw	$0, 0(%0)					\n&quot;</span>
<span class="p_add">+	&quot;	bne	%0, %1, 1b					\n&quot;</span>
<span class="p_add">+	&quot;	 daddu	%0, 32						\n&quot;</span>
<span class="p_add">+	&quot;								\n&quot;</span>
<span class="p_add">+	&quot;	mtc0	%2, $12			# Back to 32 bit	\n&quot;</span>
<span class="p_add">+	&quot;	nop				# pipeline hazard	\n&quot;</span>
<span class="p_add">+	&quot;	nop							\n&quot;</span>
<span class="p_add">+	&quot;	nop							\n&quot;</span>
<span class="p_add">+	&quot;	nop							\n&quot;</span>
<span class="p_add">+	&quot;	.set	pop						\n&quot;</span>
 	: &quot;=r&quot; (first), &quot;=r&quot; (last), &quot;=&amp;r&quot; (tmp)
 	: &quot;0&quot; (first), &quot;1&quot; (last));
 }
<span class="p_header">diff --git a/arch/mips/pic32/pic32mzda/Makefile b/arch/mips/pic32/pic32mzda/Makefile</span>
<span class="p_header">index 4a4c2728c027..c28649615c6c 100644</span>
<span class="p_header">--- a/arch/mips/pic32/pic32mzda/Makefile</span>
<span class="p_header">+++ b/arch/mips/pic32/pic32mzda/Makefile</span>
<span class="p_chunk">@@ -2,8 +2,7 @@</span> <span class="p_context"></span>
 # Joshua Henderson, &lt;joshua.henderson@microchip.com&gt;
 # Copyright (C) 2015 Microchip Technology, Inc.  All rights reserved.
 #
<span class="p_del">-obj-y			:= init.o time.o config.o</span>
<span class="p_add">+obj-y			:= config.o early_clk.o init.o time.o</span>
 
 obj-$(CONFIG_EARLY_PRINTK)	+= early_console.o      \
<span class="p_del">-				   early_pin.o		\</span>
<span class="p_del">-				   early_clk.o</span>
<span class="p_add">+				   early_pin.o</span>
<span class="p_header">diff --git a/arch/powerpc/include/asm/mmu.h b/arch/powerpc/include/asm/mmu.h</span>
<span class="p_header">index a244e09d2d88..5d22b0bef3d8 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/mmu.h</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> enum {</span>
 		MMU_FTR_NO_SLBIE_B | MMU_FTR_16M_PAGE | MMU_FTR_TLBIEL |
 		MMU_FTR_LOCKLESS_TLBIE | MMU_FTR_CI_LARGE_PAGE |
 		MMU_FTR_1T_SEGMENT | MMU_FTR_TLBIE_CROP_VA |
<span class="p_add">+		MMU_FTR_KERNEL_RO |</span>
 #ifdef CONFIG_PPC_RADIX_MMU
 		MMU_FTR_TYPE_RADIX |
 #endif
<span class="p_header">diff --git a/arch/powerpc/kernel/cpu_setup_power.S b/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_header">index 37c027ca83b2..7803756998e2 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cpu_setup_power.S</span>
<span class="p_chunk">@@ -100,6 +100,8 @@</span> <span class="p_context"> _GLOBAL(__setup_cpu_power9)</span>
 	mfspr	r3,SPRN_LPCR
 	LOAD_REG_IMMEDIATE(r4, LPCR_PECEDH | LPCR_PECE_HVEE | LPCR_HVICE)
 	or	r3, r3, r4
<span class="p_add">+	LOAD_REG_IMMEDIATE(r4, LPCR_UPRT | LPCR_HR)</span>
<span class="p_add">+	andc	r3, r3, r4</span>
 	bl	__init_LPCR
 	bl	__init_HFSCR
 	bl	__init_tlb_power9
<span class="p_chunk">@@ -120,6 +122,8 @@</span> <span class="p_context"> _GLOBAL(__restore_cpu_power9)</span>
 	mfspr   r3,SPRN_LPCR
 	LOAD_REG_IMMEDIATE(r4, LPCR_PECEDH | LPCR_PECE_HVEE | LPCR_HVICE)
 	or	r3, r3, r4
<span class="p_add">+	LOAD_REG_IMMEDIATE(r4, LPCR_UPRT | LPCR_HR)</span>
<span class="p_add">+	andc	r3, r3, r4</span>
 	bl	__init_LPCR
 	bl	__init_HFSCR
 	bl	__init_tlb_power9
<span class="p_header">diff --git a/arch/powerpc/kernel/hw_breakpoint.c b/arch/powerpc/kernel/hw_breakpoint.c</span>
<span class="p_header">index 03d089b3ed72..469d86d1c2a5 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/hw_breakpoint.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/hw_breakpoint.c</span>
<span class="p_chunk">@@ -228,8 +228,10 @@</span> <span class="p_context"> int hw_breakpoint_handler(struct die_args *args)</span>
 	rcu_read_lock();
 
 	bp = __this_cpu_read(bp_per_reg);
<span class="p_del">-	if (!bp)</span>
<span class="p_add">+	if (!bp) {</span>
<span class="p_add">+		rc = NOTIFY_DONE;</span>
 		goto out;
<span class="p_add">+	}</span>
 	info = counter_arch_bp(bp);
 
 	/*
<span class="p_header">diff --git a/arch/x86/include/asm/pkeys.h b/arch/x86/include/asm/pkeys.h</span>
<span class="p_header">index 34684adb6899..b3b09b98896d 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pkeys.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pkeys.h</span>
<span class="p_chunk">@@ -46,6 +46,15 @@</span> <span class="p_context"> extern int __arch_set_user_pkey_access(struct task_struct *tsk, int pkey,</span>
 static inline
 bool mm_pkey_is_allocated(struct mm_struct *mm, int pkey)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * &quot;Allocated&quot; pkeys are those that have been returned</span>
<span class="p_add">+	 * from pkey_alloc().  pkey 0 is special, and never</span>
<span class="p_add">+	 * returned from pkey_alloc().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pkey &lt;= 0)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (pkey &gt;= arch_max_pkey())</span>
<span class="p_add">+		return false;</span>
 	return mm_pkey_allocation_map(mm) &amp; (1U &lt;&lt; pkey);
 }
 
<span class="p_chunk">@@ -82,12 +91,6 @@</span> <span class="p_context"> int mm_pkey_alloc(struct mm_struct *mm)</span>
 static inline
 int mm_pkey_free(struct mm_struct *mm, int pkey)
 {
<span class="p_del">-	/*</span>
<span class="p_del">-	 * pkey 0 is special, always allocated and can never</span>
<span class="p_del">-	 * be freed.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!pkey)</span>
<span class="p_del">-		return -EINVAL;</span>
 	if (!mm_pkey_is_allocated(mm, pkey))
 		return -EINVAL;
 
<span class="p_header">diff --git a/crypto/testmgr.h b/crypto/testmgr.h</span>
<span class="p_header">index e64a4ef9d8ca..9033088ca231 100644</span>
<span class="p_header">--- a/crypto/testmgr.h</span>
<span class="p_header">+++ b/crypto/testmgr.h</span>
<span class="p_chunk">@@ -22813,7 +22813,7 @@</span> <span class="p_context"> static struct aead_testvec aes_ccm_enc_tv_template[] = {</span>
 			  &quot;\x09\x75\x9a\x9b\x3c\x9b\x27\x39&quot;,
 		.klen	= 32,
 		.iv	= &quot;\x03\xf9\xd9\x4e\x63\xb5\x3d\x9d&quot;
<span class="p_del">-			  &quot;\x43\xf6\x1e\x50&quot;,</span>
<span class="p_add">+			  &quot;\x43\xf6\x1e\x50\0\0\0\0&quot;,</span>
 		.assoc	= &quot;\x57\xf5\x6b\x8b\x57\x5c\x3d\x3b&quot;
 			  &quot;\x13\x02\x01\x0c\x83\x4c\x96\x35&quot;
 			  &quot;\x8e\xd6\x39\xcf\x7d\x14\x9b\x94&quot;
<span class="p_header">diff --git a/drivers/bcma/main.c b/drivers/bcma/main.c</span>
<span class="p_header">index 2c1798e38abd..38688236b3cd 100644</span>
<span class="p_header">--- a/drivers/bcma/main.c</span>
<span class="p_header">+++ b/drivers/bcma/main.c</span>
<span class="p_chunk">@@ -633,8 +633,11 @@</span> <span class="p_context"> static int bcma_device_probe(struct device *dev)</span>
 					       drv);
 	int err = 0;
 
<span class="p_add">+	get_device(dev);</span>
 	if (adrv-&gt;probe)
 		err = adrv-&gt;probe(core);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		put_device(dev);</span>
 
 	return err;
 }
<span class="p_chunk">@@ -647,6 +650,7 @@</span> <span class="p_context"> static int bcma_device_remove(struct device *dev)</span>
 
 	if (adrv-&gt;remove)
 		adrv-&gt;remove(core);
<span class="p_add">+	put_device(dev);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/block/loop.c b/drivers/block/loop.c</span>
<span class="p_header">index 4af818766797..24d6cefceb32 100644</span>
<span class="p_header">--- a/drivers/block/loop.c</span>
<span class="p_header">+++ b/drivers/block/loop.c</span>
<span class="p_chunk">@@ -1097,9 +1097,12 @@</span> <span class="p_context"> loop_set_status(struct loop_device *lo, const struct loop_info64 *info)</span>
 	if ((unsigned int) info-&gt;lo_encrypt_key_size &gt; LO_KEY_SIZE)
 		return -EINVAL;
 
<span class="p_add">+	/* I/O need to be drained during transfer transition */</span>
<span class="p_add">+	blk_mq_freeze_queue(lo-&gt;lo_queue);</span>
<span class="p_add">+</span>
 	err = loop_release_xfer(lo);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto exit;</span>
 
 	if (info-&gt;lo_encrypt_type) {
 		unsigned int type = info-&gt;lo_encrypt_type;
<span class="p_chunk">@@ -1114,12 +1117,14 @@</span> <span class="p_context"> loop_set_status(struct loop_device *lo, const struct loop_info64 *info)</span>
 
 	err = loop_init_xfer(lo, xfer, info);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto exit;</span>
 
 	if (lo-&gt;lo_offset != info-&gt;lo_offset ||
 	    lo-&gt;lo_sizelimit != info-&gt;lo_sizelimit)
<span class="p_del">-		if (figure_loop_size(lo, info-&gt;lo_offset, info-&gt;lo_sizelimit))</span>
<span class="p_del">-			return -EFBIG;</span>
<span class="p_add">+		if (figure_loop_size(lo, info-&gt;lo_offset, info-&gt;lo_sizelimit)) {</span>
<span class="p_add">+			err = -EFBIG;</span>
<span class="p_add">+			goto exit;</span>
<span class="p_add">+		}</span>
 
 	loop_config_discard(lo);
 
<span class="p_chunk">@@ -1137,13 +1142,6 @@</span> <span class="p_context"> loop_set_status(struct loop_device *lo, const struct loop_info64 *info)</span>
 	     (info-&gt;lo_flags &amp; LO_FLAGS_AUTOCLEAR))
 		lo-&gt;lo_flags ^= LO_FLAGS_AUTOCLEAR;
 
<span class="p_del">-	if ((info-&gt;lo_flags &amp; LO_FLAGS_PARTSCAN) &amp;&amp;</span>
<span class="p_del">-	     !(lo-&gt;lo_flags &amp; LO_FLAGS_PARTSCAN)) {</span>
<span class="p_del">-		lo-&gt;lo_flags |= LO_FLAGS_PARTSCAN;</span>
<span class="p_del">-		lo-&gt;lo_disk-&gt;flags &amp;= ~GENHD_FL_NO_PART_SCAN;</span>
<span class="p_del">-		loop_reread_partitions(lo, lo-&gt;lo_device);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	lo-&gt;lo_encrypt_key_size = info-&gt;lo_encrypt_key_size;
 	lo-&gt;lo_init[0] = info-&gt;lo_init[0];
 	lo-&gt;lo_init[1] = info-&gt;lo_init[1];
<span class="p_chunk">@@ -1156,7 +1154,17 @@</span> <span class="p_context"> loop_set_status(struct loop_device *lo, const struct loop_info64 *info)</span>
 	/* update dio if lo_offset or transfer is changed */
 	__loop_update_dio(lo, lo-&gt;use_dio);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+ exit:</span>
<span class="p_add">+	blk_mq_unfreeze_queue(lo-&gt;lo_queue);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!err &amp;&amp; (info-&gt;lo_flags &amp; LO_FLAGS_PARTSCAN) &amp;&amp;</span>
<span class="p_add">+	     !(lo-&gt;lo_flags &amp; LO_FLAGS_PARTSCAN)) {</span>
<span class="p_add">+		lo-&gt;lo_flags |= LO_FLAGS_PARTSCAN;</span>
<span class="p_add">+		lo-&gt;lo_disk-&gt;flags &amp;= ~GENHD_FL_NO_PART_SCAN;</span>
<span class="p_add">+		loop_reread_partitions(lo, lo-&gt;lo_device);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static int
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">index eaf5730d79eb..8022bea27fed 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_chunk">@@ -421,7 +421,7 @@</span> <span class="p_context"> static int __init init_tis(void)</span>
 	acpi_bus_unregister_driver(&amp;tis_acpi_driver);
 err_acpi:
 #endif
<span class="p_del">-	platform_device_unregister(force_pdev);</span>
<span class="p_add">+	platform_driver_unregister(&amp;tis_drv);</span>
 err_platform:
 	if (force_pdev)
 		platform_device_unregister(force_pdev);
<span class="p_header">diff --git a/drivers/devfreq/devfreq.c b/drivers/devfreq/devfreq.c</span>
<span class="p_header">index 712592cef1a2..7309c0824887 100644</span>
<span class="p_header">--- a/drivers/devfreq/devfreq.c</span>
<span class="p_header">+++ b/drivers/devfreq/devfreq.c</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static void devfreq_set_freq_table(struct devfreq *devfreq)</span>
  * @devfreq:	the devfreq instance
  * @freq:	the update target frequency
  */
<span class="p_del">-static int devfreq_update_status(struct devfreq *devfreq, unsigned long freq)</span>
<span class="p_add">+int devfreq_update_status(struct devfreq *devfreq, unsigned long freq)</span>
 {
 	int lev, prev_lev, ret = 0;
 	unsigned long cur_time;
<span class="p_chunk">@@ -166,6 +166,7 @@</span> <span class="p_context"> static int devfreq_update_status(struct devfreq *devfreq, unsigned long freq)</span>
 	devfreq-&gt;last_stat_updated = cur_time;
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL(devfreq_update_status);</span>
 
 /**
  * find_devfreq_governor() - find devfreq governor from name
<span class="p_chunk">@@ -939,6 +940,9 @@</span> <span class="p_context"> static ssize_t governor_store(struct device *dev, struct device_attribute *attr,</span>
 	if (df-&gt;governor == governor) {
 		ret = 0;
 		goto out;
<span class="p_add">+	} else if (df-&gt;governor-&gt;immutable || governor-&gt;immutable) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	if (df-&gt;governor) {
<span class="p_chunk">@@ -968,13 +972,33 @@</span> <span class="p_context"> static ssize_t available_governors_show(struct device *d,</span>
 					struct device_attribute *attr,
 					char *buf)
 {
<span class="p_del">-	struct devfreq_governor *tmp_governor;</span>
<span class="p_add">+	struct devfreq *df = to_devfreq(d);</span>
 	ssize_t count = 0;
 
 	mutex_lock(&amp;devfreq_list_lock);
<span class="p_del">-	list_for_each_entry(tmp_governor, &amp;devfreq_governor_list, node)</span>
<span class="p_del">-		count += scnprintf(&amp;buf[count], (PAGE_SIZE - count - 2),</span>
<span class="p_del">-				   &quot;%s &quot;, tmp_governor-&gt;name);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The devfreq with immutable governor (e.g., passive) shows</span>
<span class="p_add">+	 * only own governor.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (df-&gt;governor-&gt;immutable) {</span>
<span class="p_add">+		count = scnprintf(&amp;buf[count], DEVFREQ_NAME_LEN,</span>
<span class="p_add">+				   &quot;%s &quot;, df-&gt;governor_name);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The devfreq device shows the registered governor except for</span>
<span class="p_add">+	 * immutable governors such as passive governor .</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		struct devfreq_governor *governor;</span>
<span class="p_add">+</span>
<span class="p_add">+		list_for_each_entry(governor, &amp;devfreq_governor_list, node) {</span>
<span class="p_add">+			if (governor-&gt;immutable)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			count += scnprintf(&amp;buf[count], (PAGE_SIZE - count - 2),</span>
<span class="p_add">+					   &quot;%s &quot;, governor-&gt;name);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;devfreq_list_lock);
 
 	/* Truncate the trailing space */
<span class="p_header">diff --git a/drivers/devfreq/governor.h b/drivers/devfreq/governor.h</span>
<span class="p_header">index fad7d6321978..71576b8bdfef 100644</span>
<span class="p_header">--- a/drivers/devfreq/governor.h</span>
<span class="p_header">+++ b/drivers/devfreq/governor.h</span>
<span class="p_chunk">@@ -38,4 +38,6 @@</span> <span class="p_context"> extern void devfreq_interval_update(struct devfreq *devfreq,</span>
 extern int devfreq_add_governor(struct devfreq_governor *governor);
 extern int devfreq_remove_governor(struct devfreq_governor *governor);
 
<span class="p_add">+extern int devfreq_update_status(struct devfreq *devfreq, unsigned long freq);</span>
<span class="p_add">+</span>
 #endif /* _GOVERNOR_H */
<span class="p_header">diff --git a/drivers/devfreq/governor_passive.c b/drivers/devfreq/governor_passive.c</span>
<span class="p_header">index 9ef46e2592c4..5be96b2249e7 100644</span>
<span class="p_header">--- a/drivers/devfreq/governor_passive.c</span>
<span class="p_header">+++ b/drivers/devfreq/governor_passive.c</span>
<span class="p_chunk">@@ -112,6 +112,11 @@</span> <span class="p_context"> static int update_devfreq_passive(struct devfreq *devfreq, unsigned long freq)</span>
 	if (ret &lt; 0)
 		goto out;
 
<span class="p_add">+	if (devfreq-&gt;profile-&gt;freq_table</span>
<span class="p_add">+		&amp;&amp; (devfreq_update_status(devfreq, freq)))</span>
<span class="p_add">+		dev_err(&amp;devfreq-&gt;dev,</span>
<span class="p_add">+			&quot;Couldn&#39;t update frequency transition information.\n&quot;);</span>
<span class="p_add">+</span>
 	devfreq-&gt;previous_freq = freq;
 
 out:
<span class="p_chunk">@@ -179,6 +184,7 @@</span> <span class="p_context"> static int devfreq_passive_event_handler(struct devfreq *devfreq,</span>
 
 static struct devfreq_governor devfreq_passive = {
 	.name = &quot;passive&quot;,
<span class="p_add">+	.immutable = 1,</span>
 	.get_target_freq = devfreq_passive_get_target_freq,
 	.event_handler = devfreq_passive_event_handler,
 };
<span class="p_header">diff --git a/drivers/dma/ipu/ipu_irq.c b/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_header">index dd184b50e5b4..284627806b88 100644</span>
<span class="p_header">--- a/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_header">+++ b/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> static void ipu_irq_handler(struct irq_desc *desc)</span>
 	u32 status;
 	int i, line;
 
<span class="p_del">-	for (i = IPU_IRQ_NR_FN_BANKS; i &lt; IPU_IRQ_NR_BANKS; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; IPU_IRQ_NR_BANKS; i++) {</span>
 		struct ipu_irq_bank *bank = irq_bank + i;
 
 		raw_spin_lock(&amp;bank_lock);
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 5fb4c6d9209b..be34547cdb68 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -157,6 +157,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_add">+	open_info-&gt;waiting_channel = newchannel;</span>
 
 	open_msg = (struct vmbus_channel_open_channel *)open_info-&gt;msg;
 	open_msg-&gt;header.msgtype = CHANNELMSG_OPENCHANNEL;
<span class="p_chunk">@@ -181,7 +182,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
 	ret = vmbus_post_msg(open_msg,
<span class="p_del">-			       sizeof(struct vmbus_channel_open_channel));</span>
<span class="p_add">+			     sizeof(struct vmbus_channel_open_channel), true);</span>
 
 	if (ret != 0) {
 		err = ret;
<span class="p_chunk">@@ -194,6 +195,11 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+	if (newchannel-&gt;rescind) {</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto error_free_gpadl;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (open_info-&gt;response.open_result.status) {
 		err = -EAGAIN;
 		goto error_free_gpadl;
<span class="p_chunk">@@ -233,7 +239,7 @@</span> <span class="p_context"> int vmbus_send_tl_connect_request(const uuid_le *shv_guest_servie_id,</span>
 	conn_msg.guest_endpoint_id = *shv_guest_servie_id;
 	conn_msg.host_service_id = *shv_host_servie_id;
 
<span class="p_del">-	return vmbus_post_msg(&amp;conn_msg, sizeof(conn_msg));</span>
<span class="p_add">+	return vmbus_post_msg(&amp;conn_msg, sizeof(conn_msg), true);</span>
 }
 EXPORT_SYMBOL_GPL(vmbus_send_tl_connect_request);
 
<span class="p_chunk">@@ -405,6 +411,7 @@</span> <span class="p_context"> int vmbus_establish_gpadl(struct vmbus_channel *channel, void *kbuffer,</span>
 		return ret;
 
 	init_completion(&amp;msginfo-&gt;waitevent);
<span class="p_add">+	msginfo-&gt;waiting_channel = channel;</span>
 
 	gpadlmsg = (struct vmbus_channel_gpadl_header *)msginfo-&gt;msg;
 	gpadlmsg-&gt;header.msgtype = CHANNELMSG_GPADL_HEADER;
<span class="p_chunk">@@ -419,7 +426,7 @@</span> <span class="p_context"> int vmbus_establish_gpadl(struct vmbus_channel *channel, void *kbuffer,</span>
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
 	ret = vmbus_post_msg(gpadlmsg, msginfo-&gt;msgsize -
<span class="p_del">-			       sizeof(*msginfo));</span>
<span class="p_add">+			     sizeof(*msginfo), true);</span>
 	if (ret != 0)
 		goto cleanup;
 
<span class="p_chunk">@@ -433,14 +440,19 @@</span> <span class="p_context"> int vmbus_establish_gpadl(struct vmbus_channel *channel, void *kbuffer,</span>
 		gpadl_body-&gt;gpadl = next_gpadl_handle;
 
 		ret = vmbus_post_msg(gpadl_body,
<span class="p_del">-				     submsginfo-&gt;msgsize -</span>
<span class="p_del">-				     sizeof(*submsginfo));</span>
<span class="p_add">+				     submsginfo-&gt;msgsize - sizeof(*submsginfo),</span>
<span class="p_add">+				     true);</span>
 		if (ret != 0)
 			goto cleanup;
 
 	}
 	wait_for_completion(&amp;msginfo-&gt;waitevent);
 
<span class="p_add">+	if (channel-&gt;rescind) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* At this point, we received the gpadl created msg */
 	*gpadl_handle = gpadlmsg-&gt;gpadl;
 
<span class="p_chunk">@@ -474,6 +486,7 @@</span> <span class="p_context"> int vmbus_teardown_gpadl(struct vmbus_channel *channel, u32 gpadl_handle)</span>
 		return -ENOMEM;
 
 	init_completion(&amp;info-&gt;waitevent);
<span class="p_add">+	info-&gt;waiting_channel = channel;</span>
 
 	msg = (struct vmbus_channel_gpadl_teardown *)info-&gt;msg;
 
<span class="p_chunk">@@ -485,14 +498,19 @@</span> <span class="p_context"> int vmbus_teardown_gpadl(struct vmbus_channel *channel, u32 gpadl_handle)</span>
 	list_add_tail(&amp;info-&gt;msglistentry,
 		      &amp;vmbus_connection.chn_msg_list);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
<span class="p_del">-	ret = vmbus_post_msg(msg,</span>
<span class="p_del">-			       sizeof(struct vmbus_channel_gpadl_teardown));</span>
<span class="p_add">+	ret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_gpadl_teardown),</span>
<span class="p_add">+			     true);</span>
 
 	if (ret)
 		goto post_msg_err;
 
 	wait_for_completion(&amp;info-&gt;waitevent);
 
<span class="p_add">+	if (channel-&gt;rescind) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto post_msg_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 post_msg_err:
 	spin_lock_irqsave(&amp;vmbus_connection.channelmsg_lock, flags);
 	list_del(&amp;info-&gt;msglistentry);
<span class="p_chunk">@@ -557,7 +575,8 @@</span> <span class="p_context"> static int vmbus_close_internal(struct vmbus_channel *channel)</span>
 	msg-&gt;header.msgtype = CHANNELMSG_CLOSECHANNEL;
 	msg-&gt;child_relid = channel-&gt;offermsg.child_relid;
 
<span class="p_del">-	ret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_close_channel));</span>
<span class="p_add">+	ret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_close_channel),</span>
<span class="p_add">+			     true);</span>
 
 	if (ret) {
 		pr_err(&quot;Close failed: close post msg return is %d\n&quot;, ret);
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index caf341842464..cb9531541a12 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -147,6 +147,29 @@</span> <span class="p_context"> static const struct {</span>
 	{ HV_RDV_GUID	},
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The rescinded channel may be blocked waiting for a response from the host;</span>
<span class="p_add">+ * take care of that.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void vmbus_rescind_cleanup(struct vmbus_channel *channel)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vmbus_channel_msginfo *msginfo;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;vmbus_connection.channelmsg_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(msginfo, &amp;vmbus_connection.chn_msg_list,</span>
<span class="p_add">+				msglistentry) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (msginfo-&gt;waiting_channel == channel) {</span>
<span class="p_add">+			complete(&amp;msginfo-&gt;waitevent);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool is_unsupported_vmbus_devs(const uuid_le *guid)
 {
 	int i;
<span class="p_chunk">@@ -321,7 +344,8 @@</span> <span class="p_context"> static void vmbus_release_relid(u32 relid)</span>
 	memset(&amp;msg, 0, sizeof(struct vmbus_channel_relid_released));
 	msg.child_relid = relid;
 	msg.header.msgtype = CHANNELMSG_RELID_RELEASED;
<span class="p_del">-	vmbus_post_msg(&amp;msg, sizeof(struct vmbus_channel_relid_released));</span>
<span class="p_add">+	vmbus_post_msg(&amp;msg, sizeof(struct vmbus_channel_relid_released),</span>
<span class="p_add">+		       true);</span>
 }
 
 void hv_event_tasklet_disable(struct vmbus_channel *channel)
<span class="p_chunk">@@ -728,7 +752,8 @@</span> <span class="p_context"> void vmbus_initiate_unload(bool crash)</span>
 	init_completion(&amp;vmbus_connection.unload_event);
 	memset(&amp;hdr, 0, sizeof(struct vmbus_channel_message_header));
 	hdr.msgtype = CHANNELMSG_UNLOAD;
<span class="p_del">-	vmbus_post_msg(&amp;hdr, sizeof(struct vmbus_channel_message_header));</span>
<span class="p_add">+	vmbus_post_msg(&amp;hdr, sizeof(struct vmbus_channel_message_header),</span>
<span class="p_add">+		       !crash);</span>
 
 	/*
 	 * vmbus_initiate_unload() is also called on crash and the crash can be
<span class="p_chunk">@@ -823,6 +848,8 @@</span> <span class="p_context"> static void vmbus_onoffer_rescind(struct vmbus_channel_message_header *hdr)</span>
 	channel-&gt;rescind = true;
 	spin_unlock_irqrestore(&amp;channel-&gt;lock, flags);
 
<span class="p_add">+	vmbus_rescind_cleanup(channel);</span>
<span class="p_add">+</span>
 	if (channel-&gt;device_obj) {
 		if (channel-&gt;chn_rescind_callback) {
 			channel-&gt;chn_rescind_callback(channel);
<span class="p_chunk">@@ -1116,8 +1143,8 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 	msg-&gt;msgtype = CHANNELMSG_REQUESTOFFERS;
 
 
<span class="p_del">-	ret = vmbus_post_msg(msg,</span>
<span class="p_del">-			       sizeof(struct vmbus_channel_message_header));</span>
<span class="p_add">+	ret = vmbus_post_msg(msg, sizeof(struct vmbus_channel_message_header),</span>
<span class="p_add">+			     true);</span>
 	if (ret != 0) {
 		pr_err(&quot;Unable to request offers - %d\n&quot;, ret);
 
<span class="p_header">diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c</span>
<span class="p_header">index 78e6368a4423..840b6db0ea4b 100644</span>
<span class="p_header">--- a/drivers/hv/connection.c</span>
<span class="p_header">+++ b/drivers/hv/connection.c</span>
<span class="p_chunk">@@ -110,7 +110,8 @@</span> <span class="p_context"> static int vmbus_negotiate_version(struct vmbus_channel_msginfo *msginfo,</span>
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
 	ret = vmbus_post_msg(msg,
<span class="p_del">-			       sizeof(struct vmbus_channel_initiate_contact));</span>
<span class="p_add">+			     sizeof(struct vmbus_channel_initiate_contact),</span>
<span class="p_add">+			     true);</span>
 	if (ret != 0) {
 		spin_lock_irqsave(&amp;vmbus_connection.channelmsg_lock, flags);
 		list_del(&amp;msginfo-&gt;msglistentry);
<span class="p_chunk">@@ -434,7 +435,7 @@</span> <span class="p_context"> void vmbus_on_event(unsigned long data)</span>
 /*
  * vmbus_post_msg - Send a msg on the vmbus&#39;s message connection
  */
<span class="p_del">-int vmbus_post_msg(void *buffer, size_t buflen)</span>
<span class="p_add">+int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep)</span>
 {
 	union hv_connection_id conn_id;
 	int ret = 0;
<span class="p_chunk">@@ -449,7 +450,7 @@</span> <span class="p_context"> int vmbus_post_msg(void *buffer, size_t buflen)</span>
 	 * insufficient resources. Retry the operation a couple of
 	 * times before giving up.
 	 */
<span class="p_del">-	while (retries &lt; 20) {</span>
<span class="p_add">+	while (retries &lt; 100) {</span>
 		ret = hv_post_message(conn_id, 1, buffer, buflen);
 
 		switch (ret) {
<span class="p_chunk">@@ -472,8 +473,14 @@</span> <span class="p_context"> int vmbus_post_msg(void *buffer, size_t buflen)</span>
 		}
 
 		retries++;
<span class="p_del">-		udelay(usec);</span>
<span class="p_del">-		if (usec &lt; 2048)</span>
<span class="p_add">+		if (can_sleep &amp;&amp; usec &gt; 1000)</span>
<span class="p_add">+			msleep(usec / 1000);</span>
<span class="p_add">+		else if (usec &lt; MAX_UDELAY_MS * 1000)</span>
<span class="p_add">+			udelay(usec);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			mdelay(usec / 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (usec &lt; 256000)</span>
 			usec *= 2;
 	}
 	return ret;
<span class="p_header">diff --git a/drivers/hv/hv.c b/drivers/hv/hv.c</span>
<span class="p_header">index 60dbd6cb4640..6e49a4dd99c0 100644</span>
<span class="p_header">--- a/drivers/hv/hv.c</span>
<span class="p_header">+++ b/drivers/hv/hv.c</span>
<span class="p_chunk">@@ -309,9 +309,10 @@</span> <span class="p_context"> void hv_cleanup(bool crash)</span>
 
 		hypercall_msr.as_uint64 = 0;
 		wrmsrl(HV_X64_MSR_REFERENCE_TSC, hypercall_msr.as_uint64);
<span class="p_del">-		if (!crash)</span>
<span class="p_add">+		if (!crash) {</span>
 			vfree(hv_context.tsc_page);
<span class="p_del">-		hv_context.tsc_page = NULL;</span>
<span class="p_add">+			hv_context.tsc_page = NULL;</span>
<span class="p_add">+		}</span>
 	}
 #endif
 }
<span class="p_chunk">@@ -411,7 +412,7 @@</span> <span class="p_context"> int hv_synic_alloc(void)</span>
 		goto err;
 	}
 
<span class="p_del">-	for_each_online_cpu(cpu) {</span>
<span class="p_add">+	for_each_present_cpu(cpu) {</span>
 		hv_context.event_dpc[cpu] = kmalloc(size, GFP_ATOMIC);
 		if (hv_context.event_dpc[cpu] == NULL) {
 			pr_err(&quot;Unable to allocate event dpc\n&quot;);
<span class="p_chunk">@@ -457,6 +458,8 @@</span> <span class="p_context"> int hv_synic_alloc(void)</span>
 			pr_err(&quot;Unable to allocate post msg page\n&quot;);
 			goto err;
 		}
<span class="p_add">+</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;hv_context.percpu_list[cpu]);</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -482,7 +485,7 @@</span> <span class="p_context"> void hv_synic_free(void)</span>
 	int cpu;
 
 	kfree(hv_context.hv_numa_map);
<span class="p_del">-	for_each_online_cpu(cpu)</span>
<span class="p_add">+	for_each_present_cpu(cpu)</span>
 		hv_synic_free_cpu(cpu);
 }
 
<span class="p_chunk">@@ -552,8 +555,6 @@</span> <span class="p_context"> void hv_synic_init(void *arg)</span>
 	rdmsrl(HV_X64_MSR_VP_INDEX, vp_index);
 	hv_context.vp_index[cpu] = (u32)vp_index;
 
<span class="p_del">-	INIT_LIST_HEAD(&amp;hv_context.percpu_list[cpu]);</span>
<span class="p_del">-</span>
 	/*
 	 * Register the per-cpu clockevent source.
 	 */
<span class="p_header">diff --git a/drivers/hv/hv_fcopy.c b/drivers/hv/hv_fcopy.c</span>
<span class="p_header">index 8b2ba98831ec..e47d8c9db03a 100644</span>
<span class="p_header">--- a/drivers/hv/hv_fcopy.c</span>
<span class="p_header">+++ b/drivers/hv/hv_fcopy.c</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"> static DECLARE_WORK(fcopy_send_work, fcopy_send_data);</span>
 static const char fcopy_devname[] = &quot;vmbus/hv_fcopy&quot;;
 static u8 *recv_buffer;
 static struct hvutil_transport *hvt;
<span class="p_add">+static struct completion release_event;</span>
 /*
  * This state maintains the version number registered by the daemon.
  */
<span class="p_chunk">@@ -317,6 +318,7 @@</span> <span class="p_context"> static void fcopy_on_reset(void)</span>
 
 	if (cancel_delayed_work_sync(&amp;fcopy_timeout_work))
 		fcopy_respond_to_host(HV_E_FAIL);
<span class="p_add">+	complete(&amp;release_event);</span>
 }
 
 int hv_fcopy_init(struct hv_util_service *srv)
<span class="p_chunk">@@ -324,6 +326,7 @@</span> <span class="p_context"> int hv_fcopy_init(struct hv_util_service *srv)</span>
 	recv_buffer = srv-&gt;recv_buffer;
 	fcopy_transaction.recv_channel = srv-&gt;channel;
 
<span class="p_add">+	init_completion(&amp;release_event);</span>
 	/*
 	 * When this driver loads, the user level daemon that
 	 * processes the host requests may not yet be running.
<span class="p_chunk">@@ -345,4 +348,5 @@</span> <span class="p_context"> void hv_fcopy_deinit(void)</span>
 	fcopy_transaction.state = HVUTIL_DEVICE_DYING;
 	cancel_delayed_work_sync(&amp;fcopy_timeout_work);
 	hvutil_transport_destroy(hvt);
<span class="p_add">+	wait_for_completion(&amp;release_event);</span>
 }
<span class="p_header">diff --git a/drivers/hv/hv_kvp.c b/drivers/hv/hv_kvp.c</span>
<span class="p_header">index 5e1fdc8d32ab..3abfc5983c97 100644</span>
<span class="p_header">--- a/drivers/hv/hv_kvp.c</span>
<span class="p_header">+++ b/drivers/hv/hv_kvp.c</span>
<span class="p_chunk">@@ -88,6 +88,7 @@</span> <span class="p_context"> static DECLARE_WORK(kvp_sendkey_work, kvp_send_key);</span>
 static const char kvp_devname[] = &quot;vmbus/hv_kvp&quot;;
 static u8 *recv_buffer;
 static struct hvutil_transport *hvt;
<span class="p_add">+static struct completion release_event;</span>
 /*
  * Register the kernel component with the user-level daemon.
  * As part of this registration, pass the LIC version number.
<span class="p_chunk">@@ -716,6 +717,7 @@</span> <span class="p_context"> static void kvp_on_reset(void)</span>
 	if (cancel_delayed_work_sync(&amp;kvp_timeout_work))
 		kvp_respond_to_host(NULL, HV_E_FAIL);
 	kvp_transaction.state = HVUTIL_DEVICE_INIT;
<span class="p_add">+	complete(&amp;release_event);</span>
 }
 
 int
<span class="p_chunk">@@ -724,6 +726,7 @@</span> <span class="p_context"> hv_kvp_init(struct hv_util_service *srv)</span>
 	recv_buffer = srv-&gt;recv_buffer;
 	kvp_transaction.recv_channel = srv-&gt;channel;
 
<span class="p_add">+	init_completion(&amp;release_event);</span>
 	/*
 	 * When this driver loads, the user level daemon that
 	 * processes the host requests may not yet be running.
<span class="p_chunk">@@ -747,4 +750,5 @@</span> <span class="p_context"> void hv_kvp_deinit(void)</span>
 	cancel_delayed_work_sync(&amp;kvp_timeout_work);
 	cancel_work_sync(&amp;kvp_sendkey_work);
 	hvutil_transport_destroy(hvt);
<span class="p_add">+	wait_for_completion(&amp;release_event);</span>
 }
<span class="p_header">diff --git a/drivers/hv/hv_snapshot.c b/drivers/hv/hv_snapshot.c</span>
<span class="p_header">index a6707133c297..a76e3db0d01f 100644</span>
<span class="p_header">--- a/drivers/hv/hv_snapshot.c</span>
<span class="p_header">+++ b/drivers/hv/hv_snapshot.c</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> static int dm_reg_value;</span>
 static const char vss_devname[] = &quot;vmbus/hv_vss&quot;;
 static __u8 *recv_buffer;
 static struct hvutil_transport *hvt;
<span class="p_add">+static struct completion release_event;</span>
 
 static void vss_timeout_func(struct work_struct *dummy);
 static void vss_handle_request(struct work_struct *dummy);
<span class="p_chunk">@@ -330,11 +331,13 @@</span> <span class="p_context"> static void vss_on_reset(void)</span>
 	if (cancel_delayed_work_sync(&amp;vss_timeout_work))
 		vss_respond_to_host(HV_E_FAIL);
 	vss_transaction.state = HVUTIL_DEVICE_INIT;
<span class="p_add">+	complete(&amp;release_event);</span>
 }
 
 int
 hv_vss_init(struct hv_util_service *srv)
 {
<span class="p_add">+	init_completion(&amp;release_event);</span>
 	if (vmbus_proto_version &lt; VERSION_WIN8_1) {
 		pr_warn(&quot;Integration service &#39;Backup (volume snapshot)&#39;&quot;
 			&quot; not supported on this host version.\n&quot;);
<span class="p_chunk">@@ -365,4 +368,5 @@</span> <span class="p_context"> void hv_vss_deinit(void)</span>
 	cancel_delayed_work_sync(&amp;vss_timeout_work);
 	cancel_work_sync(&amp;vss_handle_request_work);
 	hvutil_transport_destroy(hvt);
<span class="p_add">+	wait_for_completion(&amp;release_event);</span>
 }
<span class="p_header">diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h</span>
<span class="p_header">index 2b13f2a0a71e..8d7f865c1133 100644</span>
<span class="p_header">--- a/drivers/hv/hyperv_vmbus.h</span>
<span class="p_header">+++ b/drivers/hv/hyperv_vmbus.h</span>
<span class="p_chunk">@@ -683,7 +683,7 @@</span> <span class="p_context"> void vmbus_free_channels(void);</span>
 int vmbus_connect(void);
 void vmbus_disconnect(void);
 
<span class="p_del">-int vmbus_post_msg(void *buffer, size_t buflen);</span>
<span class="p_add">+int vmbus_post_msg(void *buffer, size_t buflen, bool can_sleep);</span>
 
 void vmbus_on_event(unsigned long data);
 void vmbus_on_msg_dpc(unsigned long data);
<span class="p_header">diff --git a/drivers/hv/ring_buffer.c b/drivers/hv/ring_buffer.c</span>
<span class="p_header">index 308dbda700eb..e94ed1c22c8b 100644</span>
<span class="p_header">--- a/drivers/hv/ring_buffer.c</span>
<span class="p_header">+++ b/drivers/hv/ring_buffer.c</span>
<span class="p_chunk">@@ -298,6 +298,9 @@</span> <span class="p_context"> int hv_ringbuffer_write(struct vmbus_channel *channel,</span>
 	unsigned long flags = 0;
 	struct hv_ring_buffer_info *outring_info = &amp;channel-&gt;outbound;
 
<span class="p_add">+	if (channel-&gt;rescind)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; kv_count; i++)
 		totalbytes_towrite += kv_list[i].iov_len;
 
<span class="p_chunk">@@ -350,6 +353,10 @@</span> <span class="p_context"> int hv_ringbuffer_write(struct vmbus_channel *channel,</span>
 		spin_unlock_irqrestore(&amp;outring_info-&gt;ring_lock, flags);
 
 	hv_signal_on_write(old_write, channel, kick_q);
<span class="p_add">+</span>
<span class="p_add">+	if (channel-&gt;rescind)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/hwmon/it87.c b/drivers/hwmon/it87.c</span>
<span class="p_header">index ad82cb28d87a..43146162c122 100644</span>
<span class="p_header">--- a/drivers/hwmon/it87.c</span>
<span class="p_header">+++ b/drivers/hwmon/it87.c</span>
<span class="p_chunk">@@ -1300,25 +1300,35 @@</span> <span class="p_context"> static ssize_t set_pwm_enable(struct device *dev, struct device_attribute *attr,</span>
 			it87_write_value(data, IT87_REG_FAN_MAIN_CTRL,
 					 data-&gt;fan_main_ctrl);
 		} else {
<span class="p_add">+			u8 ctrl;</span>
<span class="p_add">+</span>
 			/* No on/off mode, set maximum pwm value */
 			data-&gt;pwm_duty[nr] = pwm_to_reg(data, 0xff);
 			it87_write_value(data, IT87_REG_PWM_DUTY[nr],
 					 data-&gt;pwm_duty[nr]);
 			/* and set manual mode */
<span class="p_del">-			data-&gt;pwm_ctrl[nr] = has_newer_autopwm(data) ?</span>
<span class="p_del">-					     data-&gt;pwm_temp_map[nr] :</span>
<span class="p_del">-					     data-&gt;pwm_duty[nr];</span>
<span class="p_del">-			it87_write_value(data, IT87_REG_PWM[nr],</span>
<span class="p_del">-					 data-&gt;pwm_ctrl[nr]);</span>
<span class="p_add">+			if (has_newer_autopwm(data)) {</span>
<span class="p_add">+				ctrl = (data-&gt;pwm_ctrl[nr] &amp; 0x7c) |</span>
<span class="p_add">+					data-&gt;pwm_temp_map[nr];</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ctrl = data-&gt;pwm_duty[nr];</span>
<span class="p_add">+			}</span>
<span class="p_add">+			data-&gt;pwm_ctrl[nr] = ctrl;</span>
<span class="p_add">+			it87_write_value(data, IT87_REG_PWM[nr], ctrl);</span>
 		}
 	} else {
<span class="p_del">-		if (val == 1)				/* Manual mode */</span>
<span class="p_del">-			data-&gt;pwm_ctrl[nr] = has_newer_autopwm(data) ?</span>
<span class="p_del">-					     data-&gt;pwm_temp_map[nr] :</span>
<span class="p_del">-					     data-&gt;pwm_duty[nr];</span>
<span class="p_del">-		else					/* Automatic mode */</span>
<span class="p_del">-			data-&gt;pwm_ctrl[nr] = 0x80 | data-&gt;pwm_temp_map[nr];</span>
<span class="p_del">-		it87_write_value(data, IT87_REG_PWM[nr], data-&gt;pwm_ctrl[nr]);</span>
<span class="p_add">+		u8 ctrl;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (has_newer_autopwm(data)) {</span>
<span class="p_add">+			ctrl = (data-&gt;pwm_ctrl[nr] &amp; 0x7c) |</span>
<span class="p_add">+				data-&gt;pwm_temp_map[nr];</span>
<span class="p_add">+			if (val != 1)</span>
<span class="p_add">+				ctrl |= 0x80;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ctrl = (val == 1 ? data-&gt;pwm_duty[nr] : 0x80);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		data-&gt;pwm_ctrl[nr] = ctrl;</span>
<span class="p_add">+		it87_write_value(data, IT87_REG_PWM[nr], ctrl);</span>
 
 		if (data-&gt;type != it8603 &amp;&amp; nr &lt; 3) {
 			/* set SmartGuardian mode */
<span class="p_chunk">@@ -1344,6 +1354,7 @@</span> <span class="p_context"> static ssize_t set_pwm(struct device *dev, struct device_attribute *attr,</span>
 		return -EINVAL;
 
 	mutex_lock(&amp;data-&gt;update_lock);
<span class="p_add">+	it87_update_pwm_ctrl(data, nr);</span>
 	if (has_newer_autopwm(data)) {
 		/*
 		 * If we are in automatic mode, the PWM duty cycle register
<span class="p_chunk">@@ -1456,13 +1467,15 @@</span> <span class="p_context"> static ssize_t set_pwm_temp_map(struct device *dev,</span>
 	}
 
 	mutex_lock(&amp;data-&gt;update_lock);
<span class="p_add">+	it87_update_pwm_ctrl(data, nr);</span>
 	data-&gt;pwm_temp_map[nr] = reg;
 	/*
 	 * If we are in automatic mode, write the temp mapping immediately;
 	 * otherwise, just store it for later use.
 	 */
 	if (data-&gt;pwm_ctrl[nr] &amp; 0x80) {
<span class="p_del">-		data-&gt;pwm_ctrl[nr] = 0x80 | data-&gt;pwm_temp_map[nr];</span>
<span class="p_add">+		data-&gt;pwm_ctrl[nr] = (data-&gt;pwm_ctrl[nr] &amp; 0xfc) |</span>
<span class="p_add">+						data-&gt;pwm_temp_map[nr];</span>
 		it87_write_value(data, IT87_REG_PWM[nr], data-&gt;pwm_ctrl[nr]);
 	}
 	mutex_unlock(&amp;data-&gt;update_lock);
<span class="p_header">diff --git a/drivers/hwtracing/coresight/coresight-stm.c b/drivers/hwtracing/coresight/coresight-stm.c</span>
<span class="p_header">index 49e0f1b925a5..8e7905632d25 100644</span>
<span class="p_header">--- a/drivers/hwtracing/coresight/coresight-stm.c</span>
<span class="p_header">+++ b/drivers/hwtracing/coresight/coresight-stm.c</span>
<span class="p_chunk">@@ -356,7 +356,7 @@</span> <span class="p_context"> static void stm_generic_unlink(struct stm_data *stm_data,</span>
 	if (!drvdata || !drvdata-&gt;csdev)
 		return;
 
<span class="p_del">-	stm_disable(drvdata-&gt;csdev, NULL);</span>
<span class="p_add">+	coresight_disable(drvdata-&gt;csdev);</span>
 }
 
 static phys_addr_t
<span class="p_header">diff --git a/drivers/iio/pressure/mpl115.c b/drivers/iio/pressure/mpl115.c</span>
<span class="p_header">index 73f2f0c46e62..8f2bce213248 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/mpl115.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/mpl115.c</span>
<span class="p_chunk">@@ -137,6 +137,7 @@</span> <span class="p_context"> static const struct iio_chan_spec mpl115_channels[] = {</span>
 	{
 		.type = IIO_TEMP,
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
<span class="p_add">+		.info_mask_shared_by_type =</span>
 			BIT(IIO_CHAN_INFO_OFFSET) | BIT(IIO_CHAN_INFO_SCALE),
 	},
 };
<span class="p_header">diff --git a/drivers/iio/pressure/mpl3115.c b/drivers/iio/pressure/mpl3115.c</span>
<span class="p_header">index 6392d7b62841..eb87948fc559 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/mpl3115.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/mpl3115.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static const struct iio_chan_spec mpl3115_channels[] = {</span>
 	{
 		.type = IIO_PRESSURE,
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
<span class="p_del">-			BIT(IIO_CHAN_INFO_SCALE),</span>
<span class="p_add">+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),</span>
 		.scan_index = 0,
 		.scan_type = {
 			.sign = &#39;u&#39;,
<span class="p_chunk">@@ -195,7 +195,7 @@</span> <span class="p_context"> static const struct iio_chan_spec mpl3115_channels[] = {</span>
 	{
 		.type = IIO_TEMP,
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
<span class="p_del">-			BIT(IIO_CHAN_INFO_SCALE),</span>
<span class="p_add">+		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_SCALE),</span>
 		.scan_index = 1,
 		.scan_type = {
 			.sign = &#39;s&#39;,
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index c25768c2dd3b..f2d40c05ef9e 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -3540,6 +3540,9 @@</span> <span class="p_context"> static int cma_accept_iw(struct rdma_id_private *id_priv,</span>
 	struct iw_cm_conn_param iw_param;
 	int ret;
 
<span class="p_add">+	if (!conn_param)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	ret = cma_modify_qp_rtr(id_priv, conn_param);
 	if (ret)
 		return ret;
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index d82637ab09fd..34be95ee9038 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -3325,13 +3325,14 @@</span> <span class="p_context"> static int __init init_dmars(void)</span>
 	iommu_identity_mapping |= IDENTMAP_GFX;
 #endif
 
<span class="p_add">+	check_tylersburg_isoch();</span>
<span class="p_add">+</span>
 	if (iommu_identity_mapping) {
 		ret = si_domain_init(hw_pass_through);
 		if (ret)
 			goto free_iommu;
 	}
 
<span class="p_del">-	check_tylersburg_isoch();</span>
 
 	/*
 	 * If we copied translations from a previous kernel in the kdump
<span class="p_header">diff --git a/drivers/md/dm-cache-target.c b/drivers/md/dm-cache-target.c</span>
<span class="p_header">index 59b2c50562e4..c817627d09ca 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-target.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-target.c</span>
<span class="p_chunk">@@ -248,7 +248,7 @@</span> <span class="p_context"> struct cache {</span>
 	/*
 	 * Fields for converting from sectors to blocks.
 	 */
<span class="p_del">-	uint32_t sectors_per_block;</span>
<span class="p_add">+	sector_t sectors_per_block;</span>
 	int sectors_per_block_shift;
 
 	spinlock_t lock;
<span class="p_chunk">@@ -3546,11 +3546,11 @@</span> <span class="p_context"> static void cache_status(struct dm_target *ti, status_type_t type,</span>
 
 		residency = policy_residency(cache-&gt;policy);
 
<span class="p_del">-		DMEMIT(&quot;%u %llu/%llu %u %llu/%llu %u %u %u %u %u %u %lu &quot;,</span>
<span class="p_add">+		DMEMIT(&quot;%u %llu/%llu %llu %llu/%llu %u %u %u %u %u %u %lu &quot;,</span>
 		       (unsigned)DM_CACHE_METADATA_BLOCK_SIZE,
 		       (unsigned long long)(nr_blocks_metadata - nr_free_blocks_metadata),
 		       (unsigned long long)nr_blocks_metadata,
<span class="p_del">-		       cache-&gt;sectors_per_block,</span>
<span class="p_add">+		       (unsigned long long)cache-&gt;sectors_per_block,</span>
 		       (unsigned long long) from_cblock(residency),
 		       (unsigned long long) from_cblock(cache-&gt;cache_size),
 		       (unsigned) atomic_read(&amp;cache-&gt;stats.read_hit),
<span class="p_header">diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.c</span>
<span class="p_header">index af2d79b52484..15daa36fcea6 100644</span>
<span class="p_header">--- a/drivers/md/dm-raid.c</span>
<span class="p_header">+++ b/drivers/md/dm-raid.c</span>
<span class="p_chunk">@@ -3621,6 +3621,8 @@</span> <span class="p_context"> static int raid_preresume(struct dm_target *ti)</span>
 	return r;
 }
 
<span class="p_add">+#define RESUME_STAY_FROZEN_FLAGS (CTR_FLAG_DELTA_DISKS | CTR_FLAG_DATA_OFFSET)</span>
<span class="p_add">+</span>
 static void raid_resume(struct dm_target *ti)
 {
 	struct raid_set *rs = ti-&gt;private;
<span class="p_chunk">@@ -3638,7 +3640,15 @@</span> <span class="p_context"> static void raid_resume(struct dm_target *ti)</span>
 	mddev-&gt;ro = 0;
 	mddev-&gt;in_sync = 0;
 
<span class="p_del">-	clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Keep the RAID set frozen if reshape/rebuild flags are set.</span>
<span class="p_add">+	 * The RAID set is unfrozen once the next table load/resume,</span>
<span class="p_add">+	 * which clears the reshape/rebuild flags, occurs.</span>
<span class="p_add">+	 * This ensures that the constructor for the inactive table</span>
<span class="p_add">+	 * retrieves an up-to-date reshape_position.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(rs-&gt;ctr_flags &amp; RESUME_STAY_FROZEN_FLAGS))</span>
<span class="p_add">+		clear_bit(MD_RECOVERY_FROZEN, &amp;mddev-&gt;recovery);</span>
 
 	if (mddev-&gt;suspended)
 		mddev_resume(mddev);
<span class="p_header">diff --git a/drivers/md/dm-round-robin.c b/drivers/md/dm-round-robin.c</span>
<span class="p_header">index 6c25213ab38c..bdbb7e6e8212 100644</span>
<span class="p_header">--- a/drivers/md/dm-round-robin.c</span>
<span class="p_header">+++ b/drivers/md/dm-round-robin.c</span>
<span class="p_chunk">@@ -17,8 +17,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 
 #define DM_MSG_PREFIX &quot;multipath round-robin&quot;
<span class="p_del">-#define RR_MIN_IO     1000</span>
<span class="p_del">-#define RR_VERSION    &quot;1.1.0&quot;</span>
<span class="p_add">+#define RR_MIN_IO     1</span>
<span class="p_add">+#define RR_VERSION    &quot;1.2.0&quot;</span>
 
 /*-----------------------------------------------------------------
  * Path-handling code, paths are held in lists
<span class="p_chunk">@@ -47,44 +47,19 @@</span> <span class="p_context"> struct selector {</span>
 	struct list_head valid_paths;
 	struct list_head invalid_paths;
 	spinlock_t lock;
<span class="p_del">-	struct dm_path * __percpu *current_path;</span>
<span class="p_del">-	struct percpu_counter repeat_count;</span>
 };
 
<span class="p_del">-static void set_percpu_current_path(struct selector *s, struct dm_path *path)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int cpu;</span>
<span class="p_del">-</span>
<span class="p_del">-	for_each_possible_cpu(cpu)</span>
<span class="p_del">-		*per_cpu_ptr(s-&gt;current_path, cpu) = path;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct selector *alloc_selector(void)
 {
 	struct selector *s = kmalloc(sizeof(*s), GFP_KERNEL);
 
<span class="p_del">-	if (!s)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;s-&gt;valid_paths);</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;s-&gt;invalid_paths);</span>
<span class="p_del">-	spin_lock_init(&amp;s-&gt;lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	s-&gt;current_path = alloc_percpu(struct dm_path *);</span>
<span class="p_del">-	if (!s-&gt;current_path)</span>
<span class="p_del">-		goto out_current_path;</span>
<span class="p_del">-	set_percpu_current_path(s, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (percpu_counter_init(&amp;s-&gt;repeat_count, 0, GFP_KERNEL))</span>
<span class="p_del">-		goto out_repeat_count;</span>
<span class="p_add">+	if (s) {</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;s-&gt;valid_paths);</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;s-&gt;invalid_paths);</span>
<span class="p_add">+		spin_lock_init(&amp;s-&gt;lock);</span>
<span class="p_add">+	}</span>
 
 	return s;
<span class="p_del">-</span>
<span class="p_del">-out_repeat_count:</span>
<span class="p_del">-	free_percpu(s-&gt;current_path);</span>
<span class="p_del">-out_current_path:</span>
<span class="p_del">-	kfree(s);</span>
<span class="p_del">-	return NULL;;</span>
 }
 
 static int rr_create(struct path_selector *ps, unsigned argc, char **argv)
<span class="p_chunk">@@ -105,8 +80,6 @@</span> <span class="p_context"> static void rr_destroy(struct path_selector *ps)</span>
 
 	free_paths(&amp;s-&gt;valid_paths);
 	free_paths(&amp;s-&gt;invalid_paths);
<span class="p_del">-	free_percpu(s-&gt;current_path);</span>
<span class="p_del">-	percpu_counter_destroy(&amp;s-&gt;repeat_count);</span>
 	kfree(s);
 	ps-&gt;context = NULL;
 }
<span class="p_chunk">@@ -157,6 +130,11 @@</span> <span class="p_context"> static int rr_add_path(struct path_selector *ps, struct dm_path *path,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	if (repeat_count &gt; 1) {</span>
<span class="p_add">+		DMWARN_LIMIT(&quot;repeat_count &gt; 1 is deprecated, using 1 instead&quot;);</span>
<span class="p_add">+		repeat_count = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* allocate the path */
 	pi = kmalloc(sizeof(*pi), GFP_KERNEL);
 	if (!pi) {
<span class="p_chunk">@@ -183,9 +161,6 @@</span> <span class="p_context"> static void rr_fail_path(struct path_selector *ps, struct dm_path *p)</span>
 	struct path_info *pi = p-&gt;pscontext;
 
 	spin_lock_irqsave(&amp;s-&gt;lock, flags);
<span class="p_del">-	if (p == *this_cpu_ptr(s-&gt;current_path))</span>
<span class="p_del">-		set_percpu_current_path(s, NULL);</span>
<span class="p_del">-</span>
 	list_move(&amp;pi-&gt;list, &amp;s-&gt;invalid_paths);
 	spin_unlock_irqrestore(&amp;s-&gt;lock, flags);
 }
<span class="p_chunk">@@ -208,29 +183,15 @@</span> <span class="p_context"> static struct dm_path *rr_select_path(struct path_selector *ps, size_t nr_bytes)</span>
 	unsigned long flags;
 	struct selector *s = ps-&gt;context;
 	struct path_info *pi = NULL;
<span class="p_del">-	struct dm_path *current_path = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_del">-	current_path = *this_cpu_ptr(s-&gt;current_path);</span>
<span class="p_del">-	if (current_path) {</span>
<span class="p_del">-		percpu_counter_dec(&amp;s-&gt;repeat_count);</span>
<span class="p_del">-		if (percpu_counter_read_positive(&amp;s-&gt;repeat_count) &gt; 0) {</span>
<span class="p_del">-			local_irq_restore(flags);</span>
<span class="p_del">-			return current_path;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	spin_lock(&amp;s-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;s-&gt;lock, flags);</span>
 	if (!list_empty(&amp;s-&gt;valid_paths)) {
 		pi = list_entry(s-&gt;valid_paths.next, struct path_info, list);
 		list_move_tail(&amp;pi-&gt;list, &amp;s-&gt;valid_paths);
<span class="p_del">-		percpu_counter_set(&amp;s-&gt;repeat_count, pi-&gt;repeat_count);</span>
<span class="p_del">-		set_percpu_current_path(s, pi-&gt;path);</span>
<span class="p_del">-		current_path = pi-&gt;path;</span>
 	}
 	spin_unlock_irqrestore(&amp;s-&gt;lock, flags);
 
<span class="p_del">-	return current_path;</span>
<span class="p_add">+	return pi ? pi-&gt;path : NULL;</span>
 }
 
 static struct path_selector_type rr_ps = {
<span class="p_header">diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c</span>
<span class="p_header">index 38b05f23b96c..0250e7e521ab 100644</span>
<span class="p_header">--- a/drivers/md/dm-stats.c</span>
<span class="p_header">+++ b/drivers/md/dm-stats.c</span>
<span class="p_chunk">@@ -175,6 +175,7 @@</span> <span class="p_context"> static void dm_stat_free(struct rcu_head *head)</span>
 	int cpu;
 	struct dm_stat *s = container_of(head, struct dm_stat, rcu_head);
 
<span class="p_add">+	kfree(s-&gt;histogram_boundaries);</span>
 	kfree(s-&gt;program_id);
 	kfree(s-&gt;aux_data);
 	for_each_possible_cpu(cpu) {
<span class="p_header">diff --git a/drivers/md/linear.c b/drivers/md/linear.c</span>
<span class="p_header">index 86f5d435901d..b0c0aef92a37 100644</span>
<span class="p_header">--- a/drivers/md/linear.c</span>
<span class="p_header">+++ b/drivers/md/linear.c</span>
<span class="p_chunk">@@ -52,18 +52,26 @@</span> <span class="p_context"> static inline struct dev_info *which_dev(struct mddev *mddev, sector_t sector)</span>
 	return conf-&gt;disks + lo;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * In linear_congested() conf-&gt;raid_disks is used as a copy of</span>
<span class="p_add">+ * mddev-&gt;raid_disks to iterate conf-&gt;disks[], because conf-&gt;raid_disks</span>
<span class="p_add">+ * and conf-&gt;disks[] are created in linear_conf(), they are always</span>
<span class="p_add">+ * consitent with each other, but mddev-&gt;raid_disks does not.</span>
<span class="p_add">+ */</span>
 static int linear_congested(struct mddev *mddev, int bits)
 {
 	struct linear_conf *conf;
 	int i, ret = 0;
 
<span class="p_del">-	conf = mddev-&gt;private;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	conf = rcu_dereference(mddev-&gt;private);</span>
 
<span class="p_del">-	for (i = 0; i &lt; mddev-&gt;raid_disks &amp;&amp; !ret ; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; conf-&gt;raid_disks &amp;&amp; !ret ; i++) {</span>
 		struct request_queue *q = bdev_get_queue(conf-&gt;disks[i].rdev-&gt;bdev);
 		ret |= bdi_congested(&amp;q-&gt;backing_dev_info, bits);
 	}
 
<span class="p_add">+	rcu_read_unlock();</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -143,6 +151,19 @@</span> <span class="p_context"> static struct linear_conf *linear_conf(struct mddev *mddev, int raid_disks)</span>
 			conf-&gt;disks[i-1].end_sector +
 			conf-&gt;disks[i].rdev-&gt;sectors;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * conf-&gt;raid_disks is copy of mddev-&gt;raid_disks. The reason to</span>
<span class="p_add">+	 * keep a copy of mddev-&gt;raid_disks in struct linear_conf is,</span>
<span class="p_add">+	 * mddev-&gt;raid_disks may not be consistent with pointers number of</span>
<span class="p_add">+	 * conf-&gt;disks[] when it is updated in linear_add() and used to</span>
<span class="p_add">+	 * iterate old conf-&gt;disks[] earray in linear_congested().</span>
<span class="p_add">+	 * Here conf-&gt;raid_disks is always consitent with number of</span>
<span class="p_add">+	 * pointers in conf-&gt;disks[] array, and mddev-&gt;private is updated</span>
<span class="p_add">+	 * with rcu_assign_pointer() in linear_addr(), such race can be</span>
<span class="p_add">+	 * avoided.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	conf-&gt;raid_disks = raid_disks;</span>
<span class="p_add">+</span>
 	return conf;
 
 out:
<span class="p_chunk">@@ -195,15 +216,23 @@</span> <span class="p_context"> static int linear_add(struct mddev *mddev, struct md_rdev *rdev)</span>
 	if (!newconf)
 		return -ENOMEM;
 
<span class="p_add">+	/* newconf-&gt;raid_disks already keeps a copy of * the increased</span>
<span class="p_add">+	 * value of mddev-&gt;raid_disks, WARN_ONCE() is just used to make</span>
<span class="p_add">+	 * sure of this. It is possible that oldconf is still referenced</span>
<span class="p_add">+	 * in linear_congested(), therefore kfree_rcu() is used to free</span>
<span class="p_add">+	 * oldconf until no one uses it anymore.</span>
<span class="p_add">+	 */</span>
 	mddev_suspend(mddev);
<span class="p_del">-	oldconf = mddev-&gt;private;</span>
<span class="p_add">+	oldconf = rcu_dereference(mddev-&gt;private);</span>
 	mddev-&gt;raid_disks++;
<span class="p_del">-	mddev-&gt;private = newconf;</span>
<span class="p_add">+	WARN_ONCE(mddev-&gt;raid_disks != newconf-&gt;raid_disks,</span>
<span class="p_add">+		&quot;copied raid_disks doesn&#39;t match mddev-&gt;raid_disks&quot;);</span>
<span class="p_add">+	rcu_assign_pointer(mddev-&gt;private, newconf);</span>
 	md_set_array_sectors(mddev, linear_size(mddev, 0, 0));
 	set_capacity(mddev-&gt;gendisk, mddev-&gt;array_sectors);
 	mddev_resume(mddev);
 	revalidate_disk(mddev-&gt;gendisk);
<span class="p_del">-	kfree(oldconf);</span>
<span class="p_add">+	kfree_rcu(oldconf, rcu);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/md/linear.h b/drivers/md/linear.h</span>
<span class="p_header">index b685ddd7d7f7..8d392e6098b3 100644</span>
<span class="p_header">--- a/drivers/md/linear.h</span>
<span class="p_header">+++ b/drivers/md/linear.h</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"> struct linear_conf</span>
 {
 	struct rcu_head		rcu;
 	sector_t		array_sectors;
<span class="p_add">+	int			raid_disks; /* a copy of mddev-&gt;raid_disks */</span>
 	struct dev_info		disks[0];
 };
 #endif
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cxd2820r_core.c b/drivers/media/dvb-frontends/cxd2820r_core.c</span>
<span class="p_header">index 95267c6edb3a..f6ebbb47b9b2 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cxd2820r_core.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cxd2820r_core.c</span>
<span class="p_chunk">@@ -615,6 +615,7 @@</span> <span class="p_context"> static int cxd2820r_probe(struct i2c_client *client,</span>
 	}
 
 	priv-&gt;client[0] = client;
<span class="p_add">+	priv-&gt;fe.demodulator_priv = priv;</span>
 	priv-&gt;i2c = client-&gt;adapter;
 	priv-&gt;ts_mode = pdata-&gt;ts_mode;
 	priv-&gt;ts_clk_inv = pdata-&gt;ts_clk_inv;
<span class="p_chunk">@@ -697,7 +698,6 @@</span> <span class="p_context"> static int cxd2820r_probe(struct i2c_client *client,</span>
 	memcpy(&amp;priv-&gt;fe.ops, &amp;cxd2820r_ops, sizeof(priv-&gt;fe.ops));
 	if (!pdata-&gt;attach_in_use)
 		priv-&gt;fe.ops.release = NULL;
<span class="p_del">-	priv-&gt;fe.demodulator_priv = priv;</span>
 	i2c_set_clientdata(client, priv);
 
 	/* Setup callbacks */
<span class="p_header">diff --git a/drivers/media/media-device.c b/drivers/media/media-device.c</span>
<span class="p_header">index 2783531f9fc0..4462d8c69d57 100644</span>
<span class="p_header">--- a/drivers/media/media-device.c</span>
<span class="p_header">+++ b/drivers/media/media-device.c</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static long media_device_enum_entities(struct media_device *mdev,</span>
 	 * old range.
 	 */
 	if (ent-&gt;function &lt; MEDIA_ENT_F_OLD_BASE ||
<span class="p_del">-	    ent-&gt;function &gt; MEDIA_ENT_T_DEVNODE_UNKNOWN) {</span>
<span class="p_add">+	    ent-&gt;function &gt; MEDIA_ENT_F_TUNER) {</span>
 		if (is_media_entity_v4l2_subdev(ent))
 			entd-&gt;type = MEDIA_ENT_F_V4L2_SUBDEV_UNKNOWN;
 		else if (ent-&gt;function != MEDIA_ENT_F_IO_V4L)
<span class="p_header">diff --git a/drivers/media/pci/dm1105/Kconfig b/drivers/media/pci/dm1105/Kconfig</span>
<span class="p_header">index 173daf0c0847..14fa7e40f2a6 100644</span>
<span class="p_header">--- a/drivers/media/pci/dm1105/Kconfig</span>
<span class="p_header">+++ b/drivers/media/pci/dm1105/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 config DVB_DM1105
 	tristate &quot;SDMC DM1105 based PCI cards&quot;
<span class="p_del">-	depends on DVB_CORE &amp;&amp; PCI &amp;&amp; I2C</span>
<span class="p_add">+	depends on DVB_CORE &amp;&amp; PCI &amp;&amp; I2C &amp;&amp; I2C_ALGOBIT</span>
 	select DVB_PLL if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0299 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV0288 if MEDIA_SUBDRV_AUTOSELECT
<span class="p_header">diff --git a/drivers/media/platform/am437x/am437x-vpfe.c b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">index b33b9e35e60e..05489a401c5c 100644</span>
<span class="p_header">--- a/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">+++ b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_chunk">@@ -1576,7 +1576,7 @@</span> <span class="p_context"> static int vpfe_s_fmt(struct file *file, void *priv,</span>
 		return -EBUSY;
 	}
 
<span class="p_del">-	ret = vpfe_try_fmt(file, priv, &amp;format);</span>
<span class="p_add">+	ret = __vpfe_get_format(vpfe, &amp;format, &amp;bpp);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/drivers/media/rc/lirc_dev.c b/drivers/media/rc/lirc_dev.c</span>
<span class="p_header">index 91f9bb87ce68..6ebe89551961 100644</span>
<span class="p_header">--- a/drivers/media/rc/lirc_dev.c</span>
<span class="p_header">+++ b/drivers/media/rc/lirc_dev.c</span>
<span class="p_chunk">@@ -589,7 +589,7 @@</span> <span class="p_context"> long lirc_dev_fop_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 		result = put_user(ir-&gt;d.features, (__u32 __user *)arg);
 		break;
 	case LIRC_GET_REC_MODE:
<span class="p_del">-		if (LIRC_CAN_REC(ir-&gt;d.features)) {</span>
<span class="p_add">+		if (!LIRC_CAN_REC(ir-&gt;d.features)) {</span>
 			result = -ENOTTY;
 			break;
 		}
<span class="p_chunk">@@ -599,7 +599,7 @@</span> <span class="p_context"> long lirc_dev_fop_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 				  (__u32 __user *)arg);
 		break;
 	case LIRC_SET_REC_MODE:
<span class="p_del">-		if (LIRC_CAN_REC(ir-&gt;d.features)) {</span>
<span class="p_add">+		if (!LIRC_CAN_REC(ir-&gt;d.features)) {</span>
 			result = -ENOTTY;
 			break;
 		}
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_queue.c b/drivers/media/usb/uvc/uvc_queue.c</span>
<span class="p_header">index 77edd206d345..40e5a6b54955 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_queue.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_queue.c</span>
<span class="p_chunk">@@ -412,7 +412,7 @@</span> <span class="p_context"> struct uvc_buffer *uvc_queue_next_buffer(struct uvc_video_queue *queue,</span>
 		nextbuf = NULL;
 	spin_unlock_irqrestore(&amp;queue-&gt;irqlock, flags);
 
<span class="p_del">-	buf-&gt;state = buf-&gt;error ? VB2_BUF_STATE_ERROR : UVC_BUF_STATE_DONE;</span>
<span class="p_add">+	buf-&gt;state = buf-&gt;error ? UVC_BUF_STATE_ERROR : UVC_BUF_STATE_DONE;</span>
 	vb2_set_plane_payload(&amp;buf-&gt;buf.vb2_buf, 0, buf-&gt;bytesused);
 	vb2_buffer_done(&amp;buf-&gt;buf.vb2_buf, VB2_BUF_STATE_DONE);
 
<span class="p_header">diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c</span>
<span class="p_header">index fa50635512e8..41f318631c6d 100644</span>
<span class="p_header">--- a/drivers/misc/mei/main.c</span>
<span class="p_header">+++ b/drivers/misc/mei/main.c</span>
<span class="p_chunk">@@ -182,32 +182,36 @@</span> <span class="p_context"> static ssize_t mei_read(struct file *file, char __user *ubuf,</span>
 		goto out;
 	}
 
<span class="p_del">-	if (rets == -EBUSY &amp;&amp;</span>
<span class="p_del">-	    !mei_cl_enqueue_ctrl_wr_cb(cl, length, MEI_FOP_READ, file)) {</span>
<span class="p_del">-		rets = -ENOMEM;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	do {</span>
<span class="p_del">-		mutex_unlock(&amp;dev-&gt;device_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (wait_event_interruptible(cl-&gt;rx_wait,</span>
<span class="p_del">-					     (!list_empty(&amp;cl-&gt;rd_completed)) ||</span>
<span class="p_del">-					     (!mei_cl_is_connected(cl)))) {</span>
<span class="p_add">+again:</span>
<span class="p_add">+	mutex_unlock(&amp;dev-&gt;device_lock);</span>
<span class="p_add">+	if (wait_event_interruptible(cl-&gt;rx_wait,</span>
<span class="p_add">+				     !list_empty(&amp;cl-&gt;rd_completed) ||</span>
<span class="p_add">+				     !mei_cl_is_connected(cl))) {</span>
<span class="p_add">+		if (signal_pending(current))</span>
<span class="p_add">+			return -EINTR;</span>
<span class="p_add">+		return -ERESTARTSYS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_lock(&amp;dev-&gt;device_lock);</span>
 
<span class="p_del">-			if (signal_pending(current))</span>
<span class="p_del">-				return -EINTR;</span>
<span class="p_del">-			return -ERESTARTSYS;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (!mei_cl_is_connected(cl)) {</span>
<span class="p_add">+		rets = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-		mutex_lock(&amp;dev-&gt;device_lock);</span>
<span class="p_del">-		if (!mei_cl_is_connected(cl)) {</span>
<span class="p_del">-			rets = -ENODEV;</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	cb = mei_cl_read_cb(cl, file);</span>
<span class="p_add">+	if (!cb) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * For amthif all the waiters are woken up,</span>
<span class="p_add">+		 * but only fp with matching cb-&gt;fp get the cb,</span>
<span class="p_add">+		 * the others have to return to wait on read.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cl == &amp;dev-&gt;iamthif_cl)</span>
<span class="p_add">+			goto again;</span>
 
<span class="p_del">-		cb = mei_cl_read_cb(cl, file);</span>
<span class="p_del">-	} while (!cb);</span>
<span class="p_add">+		rets = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 copy_buffer:
 	/* now copy the data to user space */
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">index fddd0be196f4..80918abfc468 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_chunk">@@ -466,7 +466,10 @@</span> <span class="p_context"> static int sdhci_acpi_probe(struct platform_device *pdev)</span>
 	if (sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD)) {
 		bool v = sdhci_acpi_flag(c, SDHCI_ACPI_SD_CD_OVERRIDE_LEVEL);
 
<span class="p_del">-		if (mmc_gpiod_request_cd(host-&gt;mmc, NULL, 0, v, 0, NULL)) {</span>
<span class="p_add">+		err = mmc_gpiod_request_cd(host-&gt;mmc, NULL, 0, v, 0, NULL);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			if (err == -EPROBE_DEFER)</span>
<span class="p_add">+				goto err_free;</span>
 			dev_warn(dev, &quot;failed to setup card detect gpio\n&quot;);
 			c-&gt;use_runtime_pm = false;
 		}
<span class="p_header">diff --git a/drivers/mtd/nand/fsl_ifc_nand.c b/drivers/mtd/nand/fsl_ifc_nand.c</span>
<span class="p_header">index 0a177b1bfe3e..d1570f512f0b 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/fsl_ifc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/fsl_ifc_nand.c</span>
<span class="p_chunk">@@ -258,9 +258,15 @@</span> <span class="p_context"> static void fsl_ifc_run_command(struct mtd_info *mtd)</span>
 		int bufnum = nctrl-&gt;page &amp; priv-&gt;bufnum_mask;
 		int sector = bufnum * chip-&gt;ecc.steps;
 		int sector_end = sector + chip-&gt;ecc.steps - 1;
<span class="p_add">+		__be32 *eccstat_regs;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ctrl-&gt;version &gt;= FSL_IFC_VERSION_2_0_0)</span>
<span class="p_add">+			eccstat_regs = ifc-&gt;ifc_nand.v2_nand_eccstat;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			eccstat_regs = ifc-&gt;ifc_nand.v1_nand_eccstat;</span>
 
 		for (i = sector / 4; i &lt;= sector_end / 4; i++)
<span class="p_del">-			eccstat[i] = ifc_in32(&amp;ifc-&gt;ifc_nand.nand_eccstat[i]);</span>
<span class="p_add">+			eccstat[i] = ifc_in32(&amp;eccstat_regs[i]);</span>
 
 		for (i = sector; i &lt;= sector_end; i++) {
 			errors = check_read_ecc(mtd, ctrl, eccstat, i);
<span class="p_header">diff --git a/drivers/net/can/usb/gs_usb.c b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">index 77e3cc06a30c..a0dabd4038ba 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_chunk">@@ -908,10 +908,14 @@</span> <span class="p_context"> static int gs_usb_probe(struct usb_interface *intf,</span>
 	struct gs_usb *dev;
 	int rc = -ENOMEM;
 	unsigned int icount, i;
<span class="p_del">-	struct gs_host_config hconf = {</span>
<span class="p_del">-		.byte_order = 0x0000beef,</span>
<span class="p_del">-	};</span>
<span class="p_del">-	struct gs_device_config dconf;</span>
<span class="p_add">+	struct gs_host_config *hconf;</span>
<span class="p_add">+	struct gs_device_config *dconf;</span>
<span class="p_add">+</span>
<span class="p_add">+	hconf = kmalloc(sizeof(*hconf), GFP_KERNEL);</span>
<span class="p_add">+	if (!hconf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	hconf-&gt;byte_order = 0x0000beef;</span>
 
 	/* send host config */
 	rc = usb_control_msg(interface_to_usbdev(intf),
<span class="p_chunk">@@ -920,16 +924,22 @@</span> <span class="p_context"> static int gs_usb_probe(struct usb_interface *intf,</span>
 			     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 			     1,
 			     intf-&gt;altsetting[0].desc.bInterfaceNumber,
<span class="p_del">-			     &amp;hconf,</span>
<span class="p_del">-			     sizeof(hconf),</span>
<span class="p_add">+			     hconf,</span>
<span class="p_add">+			     sizeof(*hconf),</span>
 			     1000);
 
<span class="p_add">+	kfree(hconf);</span>
<span class="p_add">+</span>
 	if (rc &lt; 0) {
 		dev_err(&amp;intf-&gt;dev, &quot;Couldn&#39;t send data format (err=%d)\n&quot;,
 			rc);
 		return rc;
 	}
 
<span class="p_add">+	dconf = kmalloc(sizeof(*dconf), GFP_KERNEL);</span>
<span class="p_add">+	if (!dconf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	/* read device config */
 	rc = usb_control_msg(interface_to_usbdev(intf),
 			     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),
<span class="p_chunk">@@ -937,28 +947,33 @@</span> <span class="p_context"> static int gs_usb_probe(struct usb_interface *intf,</span>
 			     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,
 			     1,
 			     intf-&gt;altsetting[0].desc.bInterfaceNumber,
<span class="p_del">-			     &amp;dconf,</span>
<span class="p_del">-			     sizeof(dconf),</span>
<span class="p_add">+			     dconf,</span>
<span class="p_add">+			     sizeof(*dconf),</span>
 			     1000);
 	if (rc &lt; 0) {
 		dev_err(&amp;intf-&gt;dev, &quot;Couldn&#39;t get device config: (err=%d)\n&quot;,
 			rc);
<span class="p_add">+		kfree(dconf);</span>
 		return rc;
 	}
 
<span class="p_del">-	icount = dconf.icount + 1;</span>
<span class="p_add">+	icount = dconf-&gt;icount + 1;</span>
 	dev_info(&amp;intf-&gt;dev, &quot;Configuring for %d interfaces\n&quot;, icount);
 
 	if (icount &gt; GS_MAX_INTF) {
 		dev_err(&amp;intf-&gt;dev,
 			&quot;Driver cannot handle more that %d CAN interfaces\n&quot;,
 			GS_MAX_INTF);
<span class="p_add">+		kfree(dconf);</span>
 		return -EINVAL;
 	}
 
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
<span class="p_del">-	if (!dev)</span>
<span class="p_add">+	if (!dev) {</span>
<span class="p_add">+		kfree(dconf);</span>
 		return -ENOMEM;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	init_usb_anchor(&amp;dev-&gt;rx_submitted);
 
 	atomic_set(&amp;dev-&gt;active_channels, 0);
<span class="p_chunk">@@ -967,7 +982,7 @@</span> <span class="p_context"> static int gs_usb_probe(struct usb_interface *intf,</span>
 	dev-&gt;udev = interface_to_usbdev(intf);
 
 	for (i = 0; i &lt; icount; i++) {
<span class="p_del">-		dev-&gt;canch[i] = gs_make_candev(i, intf, &amp;dconf);</span>
<span class="p_add">+		dev-&gt;canch[i] = gs_make_candev(i, intf, dconf);</span>
 		if (IS_ERR_OR_NULL(dev-&gt;canch[i])) {
 			/* save error code to return later */
 			rc = PTR_ERR(dev-&gt;canch[i]);
<span class="p_chunk">@@ -978,12 +993,15 @@</span> <span class="p_context"> static int gs_usb_probe(struct usb_interface *intf,</span>
 				gs_destroy_candev(dev-&gt;canch[i]);
 
 			usb_kill_anchored_urbs(&amp;dev-&gt;rx_submitted);
<span class="p_add">+			kfree(dconf);</span>
 			kfree(dev);
 			return rc;
 		}
 		dev-&gt;canch[i]-&gt;parent = dev;
 	}
 
<span class="p_add">+	kfree(dconf);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/can/usb/usb_8dev.c b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">index 108a30e15097..d000cb62d6ae 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/usb_8dev.c</span>
<span class="p_chunk">@@ -951,8 +951,8 @@</span> <span class="p_context"> static int usb_8dev_probe(struct usb_interface *intf,</span>
 	for (i = 0; i &lt; MAX_TX_URBS; i++)
 		priv-&gt;tx_contexts[i].echo_index = MAX_TX_URBS;
 
<span class="p_del">-	priv-&gt;cmd_msg_buffer = kzalloc(sizeof(struct usb_8dev_cmd_msg),</span>
<span class="p_del">-				      GFP_KERNEL);</span>
<span class="p_add">+	priv-&gt;cmd_msg_buffer = devm_kzalloc(&amp;intf-&gt;dev, sizeof(struct usb_8dev_cmd_msg),</span>
<span class="p_add">+					    GFP_KERNEL);</span>
 	if (!priv-&gt;cmd_msg_buffer)
 		goto cleanup_candev;
 
<span class="p_chunk">@@ -966,7 +966,7 @@</span> <span class="p_context"> static int usb_8dev_probe(struct usb_interface *intf,</span>
 	if (err) {
 		netdev_err(netdev,
 			&quot;couldn&#39;t register CAN device: %d\n&quot;, err);
<span class="p_del">-		goto cleanup_cmd_msg_buffer;</span>
<span class="p_add">+		goto cleanup_candev;</span>
 	}
 
 	err = usb_8dev_cmd_version(priv, &amp;version);
<span class="p_chunk">@@ -987,9 +987,6 @@</span> <span class="p_context"> static int usb_8dev_probe(struct usb_interface *intf,</span>
 cleanup_unregister_candev:
 	unregister_netdev(priv-&gt;netdev);
 
<span class="p_del">-cleanup_cmd_msg_buffer:</span>
<span class="p_del">-	kfree(priv-&gt;cmd_msg_buffer);</span>
<span class="p_del">-</span>
 cleanup_candev:
 	free_candev(netdev);
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_header">index 0c4532227f25..972b5e224d5d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/core.c</span>
<span class="p_chunk">@@ -1901,7 +1901,8 @@</span> <span class="p_context"> int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,</span>
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, &quot;firmware %s booted\n&quot;,
 		   ar-&gt;hw-&gt;wiphy-&gt;fw_version);
 
<span class="p_del">-	if (test_bit(WMI_SERVICE_EXT_RES_CFG_SUPPORT, ar-&gt;wmi.svc_map)) {</span>
<span class="p_add">+	if (test_bit(WMI_SERVICE_EXT_RES_CFG_SUPPORT, ar-&gt;wmi.svc_map) &amp;&amp;</span>
<span class="p_add">+	    mode == ATH10K_FIRMWARE_MODE_NORMAL) {</span>
 		val = 0;
 		if (ath10k_peer_stats_enabled(ar))
 			val = WMI_10_4_PEER_STATS;
<span class="p_chunk">@@ -1954,10 +1955,13 @@</span> <span class="p_context"> int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,</span>
 	 * possible to implicitly make it correct by creating a dummy vdev and
 	 * then deleting it.
 	 */
<span class="p_del">-	status = ath10k_core_reset_rx_filter(ar);</span>
<span class="p_del">-	if (status) {</span>
<span class="p_del">-		ath10k_err(ar, &quot;failed to reset rx filter: %d\n&quot;, status);</span>
<span class="p_del">-		goto err_hif_stop;</span>
<span class="p_add">+	if (mode == ATH10K_FIRMWARE_MODE_NORMAL) {</span>
<span class="p_add">+		status = ath10k_core_reset_rx_filter(ar);</span>
<span class="p_add">+		if (status) {</span>
<span class="p_add">+			ath10k_err(ar,</span>
<span class="p_add">+				   &quot;failed to reset rx filter: %d\n&quot;, status);</span>
<span class="p_add">+			goto err_hif_stop;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* If firmware indicates Full Rx Reorder support it must be used in a
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath5k/mac80211-ops.c b/drivers/net/wireless/ath/ath5k/mac80211-ops.c</span>
<span class="p_header">index dc44cfef7517..16e052d02c94 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c</span>
<span class="p_chunk">@@ -502,8 +502,7 @@</span> <span class="p_context"> ath5k_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,</span>
 			break;
 		return -EOPNOTSUPP;
 	default:
<span class="p_del">-		WARN_ON(1);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
 	}
 
 	mutex_lock(&amp;ah-&gt;lock);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h</span>
<span class="p_header">index 107bcfbbe0fb..cb37bf01920e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h</span>
<span class="p_chunk">@@ -73,13 +73,13 @@</span> <span class="p_context"></span>
 #define AR9300_OTP_BASE \
 		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x30000 : 0x14000)
 #define AR9300_OTP_STATUS \
<span class="p_del">-		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x30018 : 0x15f18)</span>
<span class="p_add">+		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x31018 : 0x15f18)</span>
 #define AR9300_OTP_STATUS_TYPE		0x7
 #define AR9300_OTP_STATUS_VALID		0x4
 #define AR9300_OTP_STATUS_ACCESS_BUSY	0x2
 #define AR9300_OTP_STATUS_SM_BUSY	0x1
 #define AR9300_OTP_READ_DATA \
<span class="p_del">-		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x3001c : 0x15f1c)</span>
<span class="p_add">+		((AR_SREV_9340(ah) || AR_SREV_9550(ah)) ? 0x3101c : 0x15f1c)</span>
 
 enum targetPowerHTRates {
 	HT_TARGET_RATE_0_8_16,
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h</span>
<span class="p_header">index 26fc8ecfe8c4..a7316710a902 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ath9k.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ath9k.h</span>
<span class="p_chunk">@@ -959,6 +959,7 @@</span> <span class="p_context"> struct ath_softc {</span>
 	struct survey_info *cur_survey;
 	struct survey_info survey[ATH9K_NUM_CHANNELS];
 
<span class="p_add">+	spinlock_t intr_lock;</span>
 	struct tasklet_struct intr_tq;
 	struct tasklet_struct bcon_tasklet;
 	struct ath_hw *sc_ah;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">index cfa3fe82ade3..297d4bbc5c05 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_chunk">@@ -626,6 +626,7 @@</span> <span class="p_context"> static int ath9k_init_softc(u16 devid, struct ath_softc *sc,</span>
 		common-&gt;bt_ant_diversity = 1;
 
 	spin_lock_init(&amp;common-&gt;cc_lock);
<span class="p_add">+	spin_lock_init(&amp;sc-&gt;intr_lock);</span>
 	spin_lock_init(&amp;sc-&gt;sc_serial_rw);
 	spin_lock_init(&amp;sc-&gt;sc_pm_lock);
 	spin_lock_init(&amp;sc-&gt;chan_lock);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/mac.c b/drivers/net/wireless/ath/ath9k/mac.c</span>
<span class="p_header">index bba85d1a6cd1..d937c39b3a0b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/mac.c</span>
<span class="p_chunk">@@ -805,21 +805,12 @@</span> <span class="p_context"> void ath9k_hw_disable_interrupts(struct ath_hw *ah)</span>
 }
 EXPORT_SYMBOL(ath9k_hw_disable_interrupts);
 
<span class="p_del">-void ath9k_hw_enable_interrupts(struct ath_hw *ah)</span>
<span class="p_add">+static void __ath9k_hw_enable_interrupts(struct ath_hw *ah)</span>
 {
 	struct ath_common *common = ath9k_hw_common(ah);
 	u32 sync_default = AR_INTR_SYNC_DEFAULT;
 	u32 async_mask;
 
<span class="p_del">-	if (!(ah-&gt;imask &amp; ATH9K_INT_GLOBAL))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!atomic_inc_and_test(&amp;ah-&gt;intr_ref_cnt)) {</span>
<span class="p_del">-		ath_dbg(common, INTERRUPT, &quot;Do not enable IER ref count %d\n&quot;,</span>
<span class="p_del">-			atomic_read(&amp;ah-&gt;intr_ref_cnt));</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (AR_SREV_9340(ah) || AR_SREV_9550(ah) || AR_SREV_9531(ah) ||
 	    AR_SREV_9561(ah))
 		sync_default &amp;= ~AR_INTR_SYNC_HOST1_FATAL;
<span class="p_chunk">@@ -841,6 +832,39 @@</span> <span class="p_context"> void ath9k_hw_enable_interrupts(struct ath_hw *ah)</span>
 	ath_dbg(common, INTERRUPT, &quot;AR_IMR 0x%x IER 0x%x\n&quot;,
 		REG_READ(ah, AR_IMR), REG_READ(ah, AR_IER));
 }
<span class="p_add">+</span>
<span class="p_add">+void ath9k_hw_resume_interrupts(struct ath_hw *ah)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ath_common *common = ath9k_hw_common(ah);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(ah-&gt;imask &amp; ATH9K_INT_GLOBAL))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (atomic_read(&amp;ah-&gt;intr_ref_cnt) != 0) {</span>
<span class="p_add">+		ath_dbg(common, INTERRUPT, &quot;Do not enable IER ref count %d\n&quot;,</span>
<span class="p_add">+			atomic_read(&amp;ah-&gt;intr_ref_cnt));</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	__ath9k_hw_enable_interrupts(ah);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(ath9k_hw_resume_interrupts);</span>
<span class="p_add">+</span>
<span class="p_add">+void ath9k_hw_enable_interrupts(struct ath_hw *ah)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ath_common *common = ath9k_hw_common(ah);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(ah-&gt;imask &amp; ATH9K_INT_GLOBAL))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!atomic_inc_and_test(&amp;ah-&gt;intr_ref_cnt)) {</span>
<span class="p_add">+		ath_dbg(common, INTERRUPT, &quot;Do not enable IER ref count %d\n&quot;,</span>
<span class="p_add">+			atomic_read(&amp;ah-&gt;intr_ref_cnt));</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	__ath9k_hw_enable_interrupts(ah);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(ath9k_hw_enable_interrupts);
 
 void ath9k_hw_set_interrupts(struct ath_hw *ah)
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/mac.h b/drivers/net/wireless/ath/ath9k/mac.h</span>
<span class="p_header">index 3bab01435a86..770fc11b41d1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/mac.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/mac.h</span>
<span class="p_chunk">@@ -744,6 +744,7 @@</span> <span class="p_context"> void ath9k_hw_set_interrupts(struct ath_hw *ah);</span>
 void ath9k_hw_enable_interrupts(struct ath_hw *ah);
 void ath9k_hw_disable_interrupts(struct ath_hw *ah);
 void ath9k_hw_kill_interrupts(struct ath_hw *ah);
<span class="p_add">+void ath9k_hw_resume_interrupts(struct ath_hw *ah);</span>
 
 void ar9002_hw_attach_mac_ops(struct ath_hw *ah);
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index e9f32b52fc8c..b868f02ced89 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -373,21 +373,20 @@</span> <span class="p_context"> void ath9k_tasklet(unsigned long data)</span>
 	struct ath_common *common = ath9k_hw_common(ah);
 	enum ath_reset_type type;
 	unsigned long flags;
<span class="p_del">-	u32 status = sc-&gt;intrstatus;</span>
<span class="p_add">+	u32 status;</span>
 	u32 rxmask;
 
<span class="p_add">+	spin_lock_irqsave(&amp;sc-&gt;intr_lock, flags);</span>
<span class="p_add">+	status = sc-&gt;intrstatus;</span>
<span class="p_add">+	sc-&gt;intrstatus = 0;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;sc-&gt;intr_lock, flags);</span>
<span class="p_add">+</span>
 	ath9k_ps_wakeup(sc);
 	spin_lock(&amp;sc-&gt;sc_pcu_lock);
 
 	if (status &amp; ATH9K_INT_FATAL) {
 		type = RESET_TYPE_FATAL_INT;
 		ath9k_queue_reset(sc, type);
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Increment the ref. counter here so that</span>
<span class="p_del">-		 * interrupts are enabled in the reset routine.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		atomic_inc(&amp;ah-&gt;intr_ref_cnt);</span>
 		ath_dbg(common, RESET, &quot;FATAL: Skipping interrupts\n&quot;);
 		goto out;
 	}
<span class="p_chunk">@@ -403,11 +402,6 @@</span> <span class="p_context"> void ath9k_tasklet(unsigned long data)</span>
 			type = RESET_TYPE_BB_WATCHDOG;
 			ath9k_queue_reset(sc, type);
 
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Increment the ref. counter here so that</span>
<span class="p_del">-			 * interrupts are enabled in the reset routine.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			atomic_inc(&amp;ah-&gt;intr_ref_cnt);</span>
 			ath_dbg(common, RESET,
 				&quot;BB_WATCHDOG: Skipping interrupts\n&quot;);
 			goto out;
<span class="p_chunk">@@ -420,7 +414,6 @@</span> <span class="p_context"> void ath9k_tasklet(unsigned long data)</span>
 		if ((sc-&gt;gtt_cnt &gt;= MAX_GTT_CNT) &amp;&amp; !ath9k_hw_check_alive(ah)) {
 			type = RESET_TYPE_TX_GTT;
 			ath9k_queue_reset(sc, type);
<span class="p_del">-			atomic_inc(&amp;ah-&gt;intr_ref_cnt);</span>
 			ath_dbg(common, RESET,
 				&quot;GTT: Skipping interrupts\n&quot;);
 			goto out;
<span class="p_chunk">@@ -477,7 +470,7 @@</span> <span class="p_context"> void ath9k_tasklet(unsigned long data)</span>
 	ath9k_btcoex_handle_interrupt(sc, status);
 
 	/* re-enable hardware interrupt */
<span class="p_del">-	ath9k_hw_enable_interrupts(ah);</span>
<span class="p_add">+	ath9k_hw_resume_interrupts(ah);</span>
 out:
 	spin_unlock(&amp;sc-&gt;sc_pcu_lock);
 	ath9k_ps_restore(sc);
<span class="p_chunk">@@ -541,7 +534,9 @@</span> <span class="p_context"> irqreturn_t ath_isr(int irq, void *dev)</span>
 		return IRQ_NONE;
 
 	/* Cache the status */
<span class="p_del">-	sc-&gt;intrstatus = status;</span>
<span class="p_add">+	spin_lock(&amp;sc-&gt;intr_lock);</span>
<span class="p_add">+	sc-&gt;intrstatus |= status;</span>
<span class="p_add">+	spin_unlock(&amp;sc-&gt;intr_lock);</span>
 
 	if (status &amp; SCHED_INTR)
 		sched = true;
<span class="p_chunk">@@ -587,7 +582,7 @@</span> <span class="p_context"> irqreturn_t ath_isr(int irq, void *dev)</span>
 
 	if (sched) {
 		/* turn off every interrupt */
<span class="p_del">-		ath9k_hw_disable_interrupts(ah);</span>
<span class="p_add">+		ath9k_hw_kill_interrupts(ah);</span>
 		tasklet_schedule(&amp;sc-&gt;intr_tq);
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/pci.h b/drivers/net/wireless/realtek/rtlwifi/pci.h</span>
<span class="p_header">index b951ebac15ea..d2f4dd470fdb 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/pci.h</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/pci.h</span>
<span class="p_chunk">@@ -275,10 +275,10 @@</span> <span class="p_context"> struct mp_adapter {</span>
 };
 
 struct rtl_pci_priv {
<span class="p_add">+	struct bt_coexist_info bt_coexist;</span>
<span class="p_add">+	struct rtl_led_ctl ledctl;</span>
 	struct rtl_pci dev;
 	struct mp_adapter ndis_adapter;
<span class="p_del">-	struct rtl_led_ctl ledctl;</span>
<span class="p_del">-	struct bt_coexist_info bt_coexist;</span>
 };
 
 #define rtl_pcipriv(hw)		(((struct rtl_pci_priv *)(rtl_priv(hw))-&gt;priv))
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/hw.c b/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_header">index ebf663e1a81a..cab4601eba8e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_chunk">@@ -1006,7 +1006,7 @@</span> <span class="p_context"> static void _rtl92ee_hw_configure(struct ieee80211_hw *hw)</span>
 	rtl_write_word(rtlpriv, REG_SIFS_TRX, 0x100a);
 
 	/* Note Data sheet don&#39;t define */
<span class="p_del">-	rtl_write_word(rtlpriv, 0x4C7, 0x80);</span>
<span class="p_add">+	rtl_write_byte(rtlpriv, 0x4C7, 0x80);</span>
 
 	rtl_write_byte(rtlpriv, REG_RX_PKT_LIMIT, 0x20);
 
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 1281ebe0c30a..2cbef9647acc 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -1128,7 +1128,7 @@</span> <span class="p_context"> static u8 _rtl8821ae_dbi_read(struct rtl_priv *rtlpriv, u16 addr)</span>
 	}
 	if (0 == tmp) {
 		read_addr = REG_DBI_RDATA + addr % 4;
<span class="p_del">-		ret = rtl_read_word(rtlpriv, read_addr);</span>
<span class="p_add">+		ret = rtl_read_byte(rtlpriv, read_addr);</span>
 	}
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/usb.h b/drivers/net/wireless/realtek/rtlwifi/usb.h</span>
<span class="p_header">index 685273ca9561..441c4412130c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/usb.h</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/usb.h</span>
<span class="p_chunk">@@ -150,8 +150,9 @@</span> <span class="p_context"> struct rtl_usb {</span>
 };
 
 struct rtl_usb_priv {
<span class="p_del">-	struct rtl_usb dev;</span>
<span class="p_add">+	struct bt_coexist_info bt_coexist;</span>
 	struct rtl_led_ctl ledctl;
<span class="p_add">+	struct rtl_usb dev;</span>
 };
 
 #define rtl_usbpriv(hw)	 (((struct rtl_usb_priv *)(rtl_priv(hw))-&gt;priv))
<span class="p_header">diff --git a/drivers/pci/host/pci-hyperv.c b/drivers/pci/host/pci-hyperv.c</span>
<span class="p_header">index 763ff8745828..61fc349c96d4 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-hyperv.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-hyperv.c</span>
<span class="p_chunk">@@ -130,7 +130,8 @@</span> <span class="p_context"> union pci_version {</span>
  */
 union win_slot_encoding {
 	struct {
<span class="p_del">-		u32	func:8;</span>
<span class="p_add">+		u32	dev:5;</span>
<span class="p_add">+		u32	func:3;</span>
 		u32	reserved:24;
 	} bits;
 	u32 slot;
<span class="p_chunk">@@ -483,7 +484,8 @@</span> <span class="p_context"> static u32 devfn_to_wslot(int devfn)</span>
 	union win_slot_encoding wslot;
 
 	wslot.slot = 0;
<span class="p_del">-	wslot.bits.func = PCI_SLOT(devfn) | (PCI_FUNC(devfn) &lt;&lt; 5);</span>
<span class="p_add">+	wslot.bits.dev = PCI_SLOT(devfn);</span>
<span class="p_add">+	wslot.bits.func = PCI_FUNC(devfn);</span>
 
 	return wslot.slot;
 }
<span class="p_chunk">@@ -501,7 +503,7 @@</span> <span class="p_context"> static int wslot_to_devfn(u32 wslot)</span>
 	union win_slot_encoding slot_no;
 
 	slot_no.slot = wslot;
<span class="p_del">-	return PCI_DEVFN(0, slot_no.bits.func);</span>
<span class="p_add">+	return PCI_DEVFN(slot_no.bits.dev, slot_no.bits.func);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/pci/host/pcie-altera.c b/drivers/pci/host/pcie-altera.c</span>
<span class="p_header">index b0ac4dfafa0b..f2907e7adb5d 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-altera.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-altera.c</span>
<span class="p_chunk">@@ -57,10 +57,14 @@</span> <span class="p_context"></span>
 #define TLP_WRITE_TAG			0x10
 #define RP_DEVFN			0
 #define TLP_REQ_ID(bus, devfn)		(((bus) &lt;&lt; 8) | (devfn))
<span class="p_del">-#define TLP_CFG_DW0(pcie, bus)						\</span>
<span class="p_add">+#define TLP_CFGRD_DW0(pcie, bus)					\</span>
     ((((bus == pcie-&gt;root_bus_nr) ? TLP_FMTTYPE_CFGRD0			\
 				    : TLP_FMTTYPE_CFGRD1) &lt;&lt; 24) |	\
      TLP_PAYLOAD_SIZE)
<span class="p_add">+#define TLP_CFGWR_DW0(pcie, bus)					\</span>
<span class="p_add">+    ((((bus == pcie-&gt;root_bus_nr) ? TLP_FMTTYPE_CFGWR0			\</span>
<span class="p_add">+				    : TLP_FMTTYPE_CFGWR1) &lt;&lt; 24) |	\</span>
<span class="p_add">+     TLP_PAYLOAD_SIZE)</span>
 #define TLP_CFG_DW1(pcie, tag, be)	\
     (((TLP_REQ_ID(pcie-&gt;root_bus_nr,  RP_DEVFN)) &lt;&lt; 16) | (tag &lt;&lt; 8) | (be))
 #define TLP_CFG_DW2(bus, devfn, offset)	\
<span class="p_chunk">@@ -222,7 +226,7 @@</span> <span class="p_context"> static int tlp_cfg_dword_read(struct altera_pcie *pcie, u8 bus, u32 devfn,</span>
 {
 	u32 headers[TLP_HDR_SIZE];
 
<span class="p_del">-	headers[0] = TLP_CFG_DW0(pcie, bus);</span>
<span class="p_add">+	headers[0] = TLP_CFGRD_DW0(pcie, bus);</span>
 	headers[1] = TLP_CFG_DW1(pcie, TLP_READ_TAG, byte_en);
 	headers[2] = TLP_CFG_DW2(bus, devfn, where);
 
<span class="p_chunk">@@ -237,7 +241,7 @@</span> <span class="p_context"> static int tlp_cfg_dword_write(struct altera_pcie *pcie, u8 bus, u32 devfn,</span>
 	u32 headers[TLP_HDR_SIZE];
 	int ret;
 
<span class="p_del">-	headers[0] = TLP_CFG_DW0(pcie, bus);</span>
<span class="p_add">+	headers[0] = TLP_CFGWR_DW0(pcie, bus);</span>
 	headers[1] = TLP_CFG_DW1(pcie, TLP_WRITE_TAG, byte_en);
 	headers[2] = TLP_CFG_DW2(bus, devfn, where);
 
<span class="p_header">diff --git a/drivers/pci/hotplug/pnv_php.c b/drivers/pci/hotplug/pnv_php.c</span>
<span class="p_header">index 56efaf72d08e..acb2be0c8c2c 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/pnv_php.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/pnv_php.c</span>
<span class="p_chunk">@@ -35,9 +35,11 @@</span> <span class="p_context"> static void pnv_php_register(struct device_node *dn);</span>
 static void pnv_php_unregister_one(struct device_node *dn);
 static void pnv_php_unregister(struct device_node *dn);
 
<span class="p_del">-static void pnv_php_disable_irq(struct pnv_php_slot *php_slot)</span>
<span class="p_add">+static void pnv_php_disable_irq(struct pnv_php_slot *php_slot,</span>
<span class="p_add">+				bool disable_device)</span>
 {
 	struct pci_dev *pdev = php_slot-&gt;pdev;
<span class="p_add">+	int irq = php_slot-&gt;irq;</span>
 	u16 ctrl;
 
 	if (php_slot-&gt;irq &gt; 0) {
<span class="p_chunk">@@ -56,10 +58,14 @@</span> <span class="p_context"> static void pnv_php_disable_irq(struct pnv_php_slot *php_slot)</span>
 		php_slot-&gt;wq = NULL;
 	}
 
<span class="p_del">-	if (pdev-&gt;msix_enabled)</span>
<span class="p_del">-		pci_disable_msix(pdev);</span>
<span class="p_del">-	else if (pdev-&gt;msi_enabled)</span>
<span class="p_del">-		pci_disable_msi(pdev);</span>
<span class="p_add">+	if (disable_device || irq &gt; 0) {</span>
<span class="p_add">+		if (pdev-&gt;msix_enabled)</span>
<span class="p_add">+			pci_disable_msix(pdev);</span>
<span class="p_add">+		else if (pdev-&gt;msi_enabled)</span>
<span class="p_add">+			pci_disable_msi(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_disable_device(pdev);</span>
<span class="p_add">+	}</span>
 }
 
 static void pnv_php_free_slot(struct kref *kref)
<span class="p_chunk">@@ -68,7 +74,7 @@</span> <span class="p_context"> static void pnv_php_free_slot(struct kref *kref)</span>
 					struct pnv_php_slot, kref);
 
 	WARN_ON(!list_empty(&amp;php_slot-&gt;children));
<span class="p_del">-	pnv_php_disable_irq(php_slot);</span>
<span class="p_add">+	pnv_php_disable_irq(php_slot, false);</span>
 	kfree(php_slot-&gt;name);
 	kfree(php_slot);
 }
<span class="p_chunk">@@ -759,7 +765,7 @@</span> <span class="p_context"> static void pnv_php_init_irq(struct pnv_php_slot *php_slot, int irq)</span>
 	php_slot-&gt;wq = alloc_workqueue(&quot;pciehp-%s&quot;, 0, 0, php_slot-&gt;name);
 	if (!php_slot-&gt;wq) {
 		dev_warn(&amp;pdev-&gt;dev, &quot;Cannot alloc workqueue\n&quot;);
<span class="p_del">-		pnv_php_disable_irq(php_slot);</span>
<span class="p_add">+		pnv_php_disable_irq(php_slot, true);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -772,7 +778,7 @@</span> <span class="p_context"> static void pnv_php_init_irq(struct pnv_php_slot *php_slot, int irq)</span>
 	ret = request_irq(irq, pnv_php_interrupt, IRQF_SHARED,
 			  php_slot-&gt;name, php_slot);
 	if (ret) {
<span class="p_del">-		pnv_php_disable_irq(php_slot);</span>
<span class="p_add">+		pnv_php_disable_irq(php_slot, true);</span>
 		dev_warn(&amp;pdev-&gt;dev, &quot;Error %d enabling IRQ %d\n&quot;, ret, irq);
 		return;
 	}
<span class="p_header">diff --git a/drivers/power/reset/Kconfig b/drivers/power/reset/Kconfig</span>
<span class="p_header">index c74c3f67b8da..02e46bbcf45d 100644</span>
<span class="p_header">--- a/drivers/power/reset/Kconfig</span>
<span class="p_header">+++ b/drivers/power/reset/Kconfig</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> config POWER_RESET_AT91_RESET</span>
 
 config POWER_RESET_AT91_SAMA5D2_SHDWC
 	tristate &quot;Atmel AT91 SAMA5D2-Compatible shutdown controller driver&quot;
<span class="p_del">-	depends on ARCH_AT91 || COMPILE_TEST</span>
<span class="p_add">+	depends on ARCH_AT91</span>
 	default SOC_SAMA5
 	help
 	  This driver supports the alternate shutdown controller for some Atmel
<span class="p_header">diff --git a/drivers/power/reset/at91-poweroff.c b/drivers/power/reset/at91-poweroff.c</span>
<span class="p_header">index e9e24df35f26..2579f025b90b 100644</span>
<span class="p_header">--- a/drivers/power/reset/at91-poweroff.c</span>
<span class="p_header">+++ b/drivers/power/reset/at91-poweroff.c</span>
<span class="p_chunk">@@ -14,9 +14,12 @@</span> <span class="p_context"></span>
 #include &lt;linux/io.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/of.h&gt;
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/printk.h&gt;
 
<span class="p_add">+#include &lt;soc/at91/at91sam9_ddrsdr.h&gt;</span>
<span class="p_add">+</span>
 #define AT91_SHDW_CR	0x00		/* Shut Down Control Register */
 #define AT91_SHDW_SHDW		BIT(0)			/* Shut Down command */
 #define AT91_SHDW_KEY		(0xa5 &lt;&lt; 24)		/* KEY Password */
<span class="p_chunk">@@ -50,6 +53,7 @@</span> <span class="p_context"> static const char *shdwc_wakeup_modes[] = {</span>
 
 static void __iomem *at91_shdwc_base;
 static struct clk *sclk;
<span class="p_add">+static void __iomem *mpddrc_base;</span>
 
 static void __init at91_wakeup_status(void)
 {
<span class="p_chunk">@@ -73,6 +77,29 @@</span> <span class="p_context"> static void at91_poweroff(void)</span>
 	writel(AT91_SHDW_KEY | AT91_SHDW_SHDW, at91_shdwc_base + AT91_SHDW_CR);
 }
 
<span class="p_add">+static void at91_lpddr_poweroff(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	asm volatile(</span>
<span class="p_add">+		/* Align to cache lines */</span>
<span class="p_add">+		&quot;.balign 32\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Ensure AT91_SHDW_CR is in the TLB by reading it */</span>
<span class="p_add">+		&quot;	ldr	r6, [%2, #&quot; __stringify(AT91_SHDW_CR) &quot;]\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Power down SDRAM0 */</span>
<span class="p_add">+		&quot;	str	%1, [%0, #&quot; __stringify(AT91_DDRSDRC_LPR) &quot;]\n\t&quot;</span>
<span class="p_add">+		/* Shutdown CPU */</span>
<span class="p_add">+		&quot;	str	%3, [%2, #&quot; __stringify(AT91_SHDW_CR) &quot;]\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		&quot;	b	.\n\t&quot;</span>
<span class="p_add">+		:</span>
<span class="p_add">+		: &quot;r&quot; (mpddrc_base),</span>
<span class="p_add">+		  &quot;r&quot; cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),</span>
<span class="p_add">+		  &quot;r&quot; (at91_shdwc_base),</span>
<span class="p_add">+		  &quot;r&quot; cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)</span>
<span class="p_add">+		: &quot;r0&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int at91_poweroff_get_wakeup_mode(struct device_node *np)
 {
 	const char *pm;
<span class="p_chunk">@@ -124,6 +151,8 @@</span> <span class="p_context"> static void at91_poweroff_dt_set_wakeup_mode(struct platform_device *pdev)</span>
 static int __init at91_poweroff_probe(struct platform_device *pdev)
 {
 	struct resource *res;
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+	u32 ddr_type;</span>
 	int ret;
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
<span class="p_chunk">@@ -150,12 +179,30 @@</span> <span class="p_context"> static int __init at91_poweroff_probe(struct platform_device *pdev)</span>
 
 	pm_power_off = at91_poweroff;
 
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, &quot;atmel,sama5d3-ddramc&quot;);</span>
<span class="p_add">+	if (!np)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mpddrc_base = of_iomap(np, 0);</span>
<span class="p_add">+	of_node_put(np);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mpddrc_base)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) &amp; AT91_DDRSDRC_MD;</span>
<span class="p_add">+	if ((ddr_type == AT91_DDRSDRC_MD_LPDDR2) ||</span>
<span class="p_add">+	    (ddr_type == AT91_DDRSDRC_MD_LPDDR3))</span>
<span class="p_add">+		pm_power_off = at91_lpddr_poweroff;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		iounmap(mpddrc_base);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
 static int __exit at91_poweroff_remove(struct platform_device *pdev)
 {
<span class="p_del">-	if (pm_power_off == at91_poweroff)</span>
<span class="p_add">+	if (pm_power_off == at91_poweroff ||</span>
<span class="p_add">+	    pm_power_off == at91_lpddr_poweroff)</span>
 		pm_power_off = NULL;
 
 	clk_disable_unprepare(sclk);
<span class="p_chunk">@@ -163,6 +210,11 @@</span> <span class="p_context"> static int __exit at91_poweroff_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_add">+static const struct of_device_id at91_ramc_of_match[] = {</span>
<span class="p_add">+	{ .compatible = &quot;atmel,sama5d3-ddramc&quot;, },</span>
<span class="p_add">+	{ /* sentinel */ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct of_device_id at91_poweroff_of_match[] = {
 	{ .compatible = &quot;atmel,at91sam9260-shdwc&quot;, },
 	{ .compatible = &quot;atmel,at91sam9rl-shdwc&quot;, },
<span class="p_header">diff --git a/drivers/power/reset/at91-sama5d2_shdwc.c b/drivers/power/reset/at91-sama5d2_shdwc.c</span>
<span class="p_header">index 8a5ac9706c9c..90b0b5a70ce5 100644</span>
<span class="p_header">--- a/drivers/power/reset/at91-sama5d2_shdwc.c</span>
<span class="p_header">+++ b/drivers/power/reset/at91-sama5d2_shdwc.c</span>
<span class="p_chunk">@@ -22,9 +22,12 @@</span> <span class="p_context"></span>
 #include &lt;linux/io.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/of.h&gt;
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/printk.h&gt;
 
<span class="p_add">+#include &lt;soc/at91/at91sam9_ddrsdr.h&gt;</span>
<span class="p_add">+</span>
 #define SLOW_CLOCK_FREQ	32768
 
 #define AT91_SHDW_CR	0x00		/* Shut Down Control Register */
<span class="p_chunk">@@ -75,6 +78,7 @@</span> <span class="p_context"> struct shdwc {</span>
  */
 static struct shdwc *at91_shdwc;
 static struct clk *sclk;
<span class="p_add">+static void __iomem *mpddrc_base;</span>
 
 static const unsigned long long sdwc_dbc_period[] = {
 	0, 3, 32, 512, 4096, 32768,
<span class="p_chunk">@@ -108,6 +112,29 @@</span> <span class="p_context"> static void at91_poweroff(void)</span>
 	       at91_shdwc-&gt;at91_shdwc_base + AT91_SHDW_CR);
 }
 
<span class="p_add">+static void at91_lpddr_poweroff(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	asm volatile(</span>
<span class="p_add">+		/* Align to cache lines */</span>
<span class="p_add">+		&quot;.balign 32\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Ensure AT91_SHDW_CR is in the TLB by reading it */</span>
<span class="p_add">+		&quot;	ldr	r6, [%2, #&quot; __stringify(AT91_SHDW_CR) &quot;]\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Power down SDRAM0 */</span>
<span class="p_add">+		&quot;	str	%1, [%0, #&quot; __stringify(AT91_DDRSDRC_LPR) &quot;]\n\t&quot;</span>
<span class="p_add">+		/* Shutdown CPU */</span>
<span class="p_add">+		&quot;	str	%3, [%2, #&quot; __stringify(AT91_SHDW_CR) &quot;]\n\t&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+		&quot;	b	.\n\t&quot;</span>
<span class="p_add">+		:</span>
<span class="p_add">+		: &quot;r&quot; (mpddrc_base),</span>
<span class="p_add">+		  &quot;r&quot; cpu_to_le32(AT91_DDRSDRC_LPDDR2_PWOFF),</span>
<span class="p_add">+		  &quot;r&quot; (at91_shdwc-&gt;at91_shdwc_base),</span>
<span class="p_add">+		  &quot;r&quot; cpu_to_le32(AT91_SHDW_KEY | AT91_SHDW_SHDW)</span>
<span class="p_add">+		: &quot;r0&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32 at91_shdwc_debouncer_value(struct platform_device *pdev,
 				      u32 in_period_us)
 {
<span class="p_chunk">@@ -212,6 +239,8 @@</span> <span class="p_context"> static int __init at91_shdwc_probe(struct platform_device *pdev)</span>
 {
 	struct resource *res;
 	const struct of_device_id *match;
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+	u32 ddr_type;</span>
 	int ret;
 
 	if (!pdev-&gt;dev.of_node)
<span class="p_chunk">@@ -249,6 +278,23 @@</span> <span class="p_context"> static int __init at91_shdwc_probe(struct platform_device *pdev)</span>
 
 	pm_power_off = at91_poweroff;
 
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, &quot;atmel,sama5d3-ddramc&quot;);</span>
<span class="p_add">+	if (!np)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mpddrc_base = of_iomap(np, 0);</span>
<span class="p_add">+	of_node_put(np);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mpddrc_base)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_type = readl(mpddrc_base + AT91_DDRSDRC_MDR) &amp; AT91_DDRSDRC_MD;</span>
<span class="p_add">+	if ((ddr_type == AT91_DDRSDRC_MD_LPDDR2) ||</span>
<span class="p_add">+	    (ddr_type == AT91_DDRSDRC_MD_LPDDR3))</span>
<span class="p_add">+		pm_power_off = at91_lpddr_poweroff;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		iounmap(mpddrc_base);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -256,7 +302,8 @@</span> <span class="p_context"> static int __exit at91_shdwc_remove(struct platform_device *pdev)</span>
 {
 	struct shdwc *shdw = platform_get_drvdata(pdev);
 
<span class="p_del">-	if (pm_power_off == at91_poweroff)</span>
<span class="p_add">+	if (pm_power_off == at91_poweroff ||</span>
<span class="p_add">+	    pm_power_off == at91_lpddr_poweroff)</span>
 		pm_power_off = NULL;
 
 	/* Reset values to disable wake-up features  */
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index 5c1519b229e0..9faccfceb53c 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -4357,12 +4357,13 @@</span> <span class="p_context"> static void regulator_summary_show_subtree(struct seq_file *s,</span>
 	seq_puts(s, &quot;\n&quot;);
 
 	list_for_each_entry(consumer, &amp;rdev-&gt;consumer_list, list) {
<span class="p_del">-		if (consumer-&gt;dev-&gt;class == &amp;regulator_class)</span>
<span class="p_add">+		if (consumer-&gt;dev &amp;&amp; consumer-&gt;dev-&gt;class == &amp;regulator_class)</span>
 			continue;
 
 		seq_printf(s, &quot;%*s%-*s &quot;,
 			   (level + 1) * 3 + 1, &quot;&quot;,
<span class="p_del">-			   30 - (level + 1) * 3, dev_name(consumer-&gt;dev));</span>
<span class="p_add">+			   30 - (level + 1) * 3,</span>
<span class="p_add">+			   consumer-&gt;dev ? dev_name(consumer-&gt;dev) : &quot;deviceless&quot;);</span>
 
 		switch (rdev-&gt;desc-&gt;type) {
 		case REGULATOR_VOLTAGE:
<span class="p_header">diff --git a/drivers/remoteproc/qcom_mdt_loader.c b/drivers/remoteproc/qcom_mdt_loader.c</span>
<span class="p_header">index 114e8e4cef67..04db02d9059d 100644</span>
<span class="p_header">--- a/drivers/remoteproc/qcom_mdt_loader.c</span>
<span class="p_header">+++ b/drivers/remoteproc/qcom_mdt_loader.c</span>
<span class="p_chunk">@@ -115,6 +115,7 @@</span> <span class="p_context"> int qcom_mdt_load(struct rproc *rproc,</span>
 	const struct elf32_phdr *phdrs;
 	const struct elf32_phdr *phdr;
 	const struct elf32_hdr *ehdr;
<span class="p_add">+	const struct firmware *seg_fw;</span>
 	size_t fw_name_len;
 	char *fw_name;
 	void *ptr;
<span class="p_chunk">@@ -153,16 +154,16 @@</span> <span class="p_context"> int qcom_mdt_load(struct rproc *rproc,</span>
 
 		if (phdr-&gt;p_filesz) {
 			sprintf(fw_name + fw_name_len - 3, &quot;b%02d&quot;, i);
<span class="p_del">-			ret = request_firmware(&amp;fw, fw_name, &amp;rproc-&gt;dev);</span>
<span class="p_add">+			ret = request_firmware(&amp;seg_fw, fw_name, &amp;rproc-&gt;dev);</span>
 			if (ret) {
 				dev_err(&amp;rproc-&gt;dev, &quot;failed to load %s\n&quot;,
 					fw_name);
 				break;
 			}
 
<span class="p_del">-			memcpy(ptr, fw-&gt;data, fw-&gt;size);</span>
<span class="p_add">+			memcpy(ptr, seg_fw-&gt;data, seg_fw-&gt;size);</span>
 
<span class="p_del">-			release_firmware(fw);</span>
<span class="p_add">+			release_firmware(seg_fw);</span>
 		}
 
 		if (phdr-&gt;p_memsz &gt; phdr-&gt;p_filesz)
<span class="p_header">diff --git a/drivers/rtc/Kconfig b/drivers/rtc/Kconfig</span>
<span class="p_header">index e859d148aba9..0723c97ebea3 100644</span>
<span class="p_header">--- a/drivers/rtc/Kconfig</span>
<span class="p_header">+++ b/drivers/rtc/Kconfig</span>
<span class="p_chunk">@@ -1432,7 +1432,7 @@</span> <span class="p_context"> config RTC_DRV_SUN4V</span>
 	  based RTC on SUN4V systems.
 
 config RTC_DRV_SUN6I
<span class="p_del">-	tristate &quot;Allwinner A31 RTC&quot;</span>
<span class="p_add">+	bool &quot;Allwinner A31 RTC&quot;</span>
 	default MACH_SUN6I || MACH_SUN8I || COMPILE_TEST
 	depends on ARCH_SUNXI
 	help
<span class="p_header">diff --git a/drivers/rtc/rtc-sun6i.c b/drivers/rtc/rtc-sun6i.c</span>
<span class="p_header">index c169a2cd4727..b0d45d23a11b 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-sun6i.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-sun6i.c</span>
<span class="p_chunk">@@ -37,9 +37,11 @@</span> <span class="p_context"></span>
 
 /* Control register */
 #define SUN6I_LOSC_CTRL				0x0000
<span class="p_add">+#define SUN6I_LOSC_CTRL_KEY			(0x16aa &lt;&lt; 16)</span>
 #define SUN6I_LOSC_CTRL_ALM_DHMS_ACC		BIT(9)
 #define SUN6I_LOSC_CTRL_RTC_HMS_ACC		BIT(8)
 #define SUN6I_LOSC_CTRL_RTC_YMD_ACC		BIT(7)
<span class="p_add">+#define SUN6I_LOSC_CTRL_EXT_OSC			BIT(0)</span>
 #define SUN6I_LOSC_CTRL_ACC_MASK		GENMASK(9, 7)
 
 /* RTC */
<span class="p_chunk">@@ -114,13 +116,17 @@</span> <span class="p_context"> struct sun6i_rtc_dev {</span>
 	void __iomem *base;
 	int irq;
 	unsigned long alarm;
<span class="p_add">+</span>
<span class="p_add">+	spinlock_t lock;</span>
 };
 
 static irqreturn_t sun6i_rtc_alarmirq(int irq, void *id)
 {
 	struct sun6i_rtc_dev *chip = (struct sun6i_rtc_dev *) id;
<span class="p_add">+	irqreturn_t ret = IRQ_NONE;</span>
 	u32 val;
 
<span class="p_add">+	spin_lock(&amp;chip-&gt;lock);</span>
 	val = readl(chip-&gt;base + SUN6I_ALRM_IRQ_STA);
 
 	if (val &amp; SUN6I_ALRM_IRQ_STA_CNT_IRQ_PEND) {
<span class="p_chunk">@@ -129,10 +135,11 @@</span> <span class="p_context"> static irqreturn_t sun6i_rtc_alarmirq(int irq, void *id)</span>
 
 		rtc_update_irq(chip-&gt;rtc, 1, RTC_AF | RTC_IRQF);
 
<span class="p_del">-		return IRQ_HANDLED;</span>
<span class="p_add">+		ret = IRQ_HANDLED;</span>
 	}
<span class="p_add">+	spin_unlock(&amp;chip-&gt;lock);</span>
 
<span class="p_del">-	return IRQ_NONE;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void sun6i_rtc_setaie(int to, struct sun6i_rtc_dev *chip)
<span class="p_chunk">@@ -140,6 +147,7 @@</span> <span class="p_context"> static void sun6i_rtc_setaie(int to, struct sun6i_rtc_dev *chip)</span>
 	u32 alrm_val = 0;
 	u32 alrm_irq_val = 0;
 	u32 alrm_wake_val = 0;
<span class="p_add">+	unsigned long flags;</span>
 
 	if (to) {
 		alrm_val = SUN6I_ALRM_EN_CNT_EN;
<span class="p_chunk">@@ -150,9 +158,11 @@</span> <span class="p_context"> static void sun6i_rtc_setaie(int to, struct sun6i_rtc_dev *chip)</span>
 		       chip-&gt;base + SUN6I_ALRM_IRQ_STA);
 	}
 
<span class="p_add">+	spin_lock_irqsave(&amp;chip-&gt;lock, flags);</span>
 	writel(alrm_val, chip-&gt;base + SUN6I_ALRM_EN);
 	writel(alrm_irq_val, chip-&gt;base + SUN6I_ALRM_IRQ_EN);
 	writel(alrm_wake_val, chip-&gt;base + SUN6I_ALARM_CONFIG);
<span class="p_add">+	spin_unlock_irqrestore(&amp;chip-&gt;lock, flags);</span>
 }
 
 static int sun6i_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)
<span class="p_chunk">@@ -191,11 +201,15 @@</span> <span class="p_context"> static int sun6i_rtc_gettime(struct device *dev, struct rtc_time *rtc_tm)</span>
 static int sun6i_rtc_getalarm(struct device *dev, struct rtc_wkalrm *wkalrm)
 {
 	struct sun6i_rtc_dev *chip = dev_get_drvdata(dev);
<span class="p_add">+	unsigned long flags;</span>
 	u32 alrm_st;
 	u32 alrm_en;
 
<span class="p_add">+	spin_lock_irqsave(&amp;chip-&gt;lock, flags);</span>
 	alrm_en = readl(chip-&gt;base + SUN6I_ALRM_IRQ_EN);
 	alrm_st = readl(chip-&gt;base + SUN6I_ALRM_IRQ_STA);
<span class="p_add">+	spin_unlock_irqrestore(&amp;chip-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	wkalrm-&gt;enabled = !!(alrm_en &amp; SUN6I_ALRM_EN_CNT_EN);
 	wkalrm-&gt;pending = !!(alrm_st &amp; SUN6I_ALRM_EN_CNT_EN);
 	rtc_time_to_tm(chip-&gt;alarm, &amp;wkalrm-&gt;time);
<span class="p_chunk">@@ -356,6 +370,7 @@</span> <span class="p_context"> static int sun6i_rtc_probe(struct platform_device *pdev)</span>
 	chip = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*chip), GFP_KERNEL);
 	if (!chip)
 		return -ENOMEM;
<span class="p_add">+	spin_lock_init(&amp;chip-&gt;lock);</span>
 
 	platform_set_drvdata(pdev, chip);
 	chip-&gt;dev = &amp;pdev-&gt;dev;
<span class="p_chunk">@@ -404,6 +419,10 @@</span> <span class="p_context"> static int sun6i_rtc_probe(struct platform_device *pdev)</span>
 	/* disable alarm wakeup */
 	writel(0, chip-&gt;base + SUN6I_ALARM_CONFIG);
 
<span class="p_add">+	/* switch to the external, more precise, oscillator */</span>
<span class="p_add">+	writel(SUN6I_LOSC_CTRL_KEY | SUN6I_LOSC_CTRL_EXT_OSC,</span>
<span class="p_add">+	       chip-&gt;base + SUN6I_LOSC_CTRL);</span>
<span class="p_add">+</span>
 	chip-&gt;rtc = rtc_device_register(&quot;rtc-sun6i&quot;, &amp;pdev-&gt;dev,
 					&amp;sun6i_rtc_ops, THIS_MODULE);
 	if (IS_ERR(chip-&gt;rtc)) {
<span class="p_chunk">@@ -439,9 +458,4 @@</span> <span class="p_context"> static struct platform_driver sun6i_rtc_driver = {</span>
 		.of_match_table = sun6i_rtc_dt_ids,
 	},
 };
<span class="p_del">-</span>
<span class="p_del">-module_platform_driver(sun6i_rtc_driver);</span>
<span class="p_del">-</span>
<span class="p_del">-MODULE_DESCRIPTION(&quot;sun6i RTC driver&quot;);</span>
<span class="p_del">-MODULE_AUTHOR(&quot;Chen-Yu Tsai &lt;wens@csie.org&gt;&quot;);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_add">+builtin_platform_driver(sun6i_rtc_driver);</span>
<span class="p_header">diff --git a/drivers/scsi/aacraid/src.c b/drivers/scsi/aacraid/src.c</span>
<span class="p_header">index 0c453880f214..7b178d765726 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/src.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/src.c</span>
<span class="p_chunk">@@ -414,16 +414,23 @@</span> <span class="p_context"> static int aac_src_check_health(struct aac_dev *dev)</span>
 	u32 status = src_readl(dev, MUnit.OMR);
 
 	/*
<span class="p_add">+	 *	Check to see if the board panic&#39;d.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(status &amp; KERNEL_PANIC))</span>
<span class="p_add">+		goto err_blink;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 *	Check to see if the board failed any self tests.
 	 */
 	if (unlikely(status &amp; SELF_TEST_FAILED))
<span class="p_del">-		return -1;</span>
<span class="p_add">+		goto err_out;</span>
 
 	/*
<span class="p_del">-	 *	Check to see if the board panic&#39;d.</span>
<span class="p_add">+	 *	Check to see if the board failed any self tests.</span>
 	 */
<span class="p_del">-	if (unlikely(status &amp; KERNEL_PANIC))</span>
<span class="p_del">-		return (status &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_add">+	if (unlikely(status &amp; MONITOR_PANIC))</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+</span>
 	/*
 	 *	Wait for the adapter to be up and running.
 	 */
<span class="p_chunk">@@ -433,6 +440,12 @@</span> <span class="p_context"> static int aac_src_check_health(struct aac_dev *dev)</span>
 	 *	Everything is OK
 	 */
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+err_blink:</span>
<span class="p_add">+	return (status &gt; 16) &amp; 0xFF;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_hw4.h b/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_header">index ee8022737591..55faa94637a9 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_chunk">@@ -1185,6 +1185,7 @@</span> <span class="p_context"> struct lpfc_mbx_wq_create {</span>
 #define lpfc_mbx_wq_create_page_size_SHIFT	0
 #define lpfc_mbx_wq_create_page_size_MASK	0x000000FF
 #define lpfc_mbx_wq_create_page_size_WORD	word1
<span class="p_add">+#define LPFC_WQ_PAGE_SIZE_4096	0x1</span>
 #define lpfc_mbx_wq_create_wqe_size_SHIFT	8
 #define lpfc_mbx_wq_create_wqe_size_MASK	0x0000000F
 #define lpfc_mbx_wq_create_wqe_size_WORD	word1
<span class="p_chunk">@@ -1256,6 +1257,7 @@</span> <span class="p_context"> struct rq_context {</span>
 #define lpfc_rq_context_page_size_SHIFT	0		/* Version 1 Only */
 #define lpfc_rq_context_page_size_MASK	0x000000FF
 #define lpfc_rq_context_page_size_WORD	word0
<span class="p_add">+#define	LPFC_RQ_PAGE_SIZE_4096	0x1</span>
 	uint32_t reserved1;
 	uint32_t word2;
 #define lpfc_rq_context_cq_id_SHIFT	16
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">index f4f77c5b0c83..49b4c798de18 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_chunk">@@ -13678,7 +13678,7 @@</span> <span class="p_context"> lpfc_wq_create(struct lpfc_hba *phba, struct lpfc_queue *wq,</span>
 			       LPFC_WQ_WQE_SIZE_128);
 			bf_set(lpfc_mbx_wq_create_page_size,
 			       &amp;wq_create-&gt;u.request_1,
<span class="p_del">-			       (PAGE_SIZE/SLI4_PAGE_SIZE));</span>
<span class="p_add">+			       LPFC_WQ_PAGE_SIZE_4096);</span>
 			page = wq_create-&gt;u.request_1.page;
 			break;
 		}
<span class="p_chunk">@@ -13704,8 +13704,9 @@</span> <span class="p_context"> lpfc_wq_create(struct lpfc_hba *phba, struct lpfc_queue *wq,</span>
 			       LPFC_WQ_WQE_SIZE_128);
 			break;
 		}
<span class="p_del">-		bf_set(lpfc_mbx_wq_create_page_size, &amp;wq_create-&gt;u.request_1,</span>
<span class="p_del">-		       (PAGE_SIZE/SLI4_PAGE_SIZE));</span>
<span class="p_add">+		bf_set(lpfc_mbx_wq_create_page_size,</span>
<span class="p_add">+		       &amp;wq_create-&gt;u.request_1,</span>
<span class="p_add">+		       LPFC_WQ_PAGE_SIZE_4096);</span>
 		page = wq_create-&gt;u.request_1.page;
 		break;
 	default:
<span class="p_chunk">@@ -13891,7 +13892,7 @@</span> <span class="p_context"> lpfc_rq_create(struct lpfc_hba *phba, struct lpfc_queue *hrq,</span>
 		       LPFC_RQE_SIZE_8);
 		bf_set(lpfc_rq_context_page_size,
 		       &amp;rq_create-&gt;u.request.context,
<span class="p_del">-		       (PAGE_SIZE/SLI4_PAGE_SIZE));</span>
<span class="p_add">+		       LPFC_RQ_PAGE_SIZE_4096);</span>
 	} else {
 		switch (hrq-&gt;entry_count) {
 		default:
<span class="p_header">diff --git a/drivers/scsi/scsi_dh.c b/drivers/scsi/scsi_dh.c</span>
<span class="p_header">index b8d3b97b217a..84addee05be6 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_dh.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_dh.c</span>
<span class="p_chunk">@@ -219,20 +219,6 @@</span> <span class="p_context"> int scsi_unregister_device_handler(struct scsi_device_handler *scsi_dh)</span>
 }
 EXPORT_SYMBOL_GPL(scsi_unregister_device_handler);
 
<span class="p_del">-static struct scsi_device *get_sdev_from_queue(struct request_queue *q)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_device *sdev;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(q-&gt;queue_lock, flags);</span>
<span class="p_del">-	sdev = q-&gt;queuedata;</span>
<span class="p_del">-	if (!sdev || !get_device(&amp;sdev-&gt;sdev_gendev))</span>
<span class="p_del">-		sdev = NULL;</span>
<span class="p_del">-	spin_unlock_irqrestore(q-&gt;queue_lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sdev;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * scsi_dh_activate - activate the path associated with the scsi_device
  *      corresponding to the given request queue.
<span class="p_chunk">@@ -251,7 +237,7 @@</span> <span class="p_context"> int scsi_dh_activate(struct request_queue *q, activate_complete fn, void *data)</span>
 	struct scsi_device *sdev;
 	int err = SCSI_DH_NOSYS;
 
<span class="p_del">-	sdev = get_sdev_from_queue(q);</span>
<span class="p_add">+	sdev = scsi_device_from_queue(q);</span>
 	if (!sdev) {
 		if (fn)
 			fn(data, err);
<span class="p_chunk">@@ -298,7 +284,7 @@</span> <span class="p_context"> int scsi_dh_set_params(struct request_queue *q, const char *params)</span>
 	struct scsi_device *sdev;
 	int err = -SCSI_DH_NOSYS;
 
<span class="p_del">-	sdev = get_sdev_from_queue(q);</span>
<span class="p_add">+	sdev = scsi_device_from_queue(q);</span>
 	if (!sdev)
 		return err;
 
<span class="p_chunk">@@ -321,7 +307,7 @@</span> <span class="p_context"> int scsi_dh_attach(struct request_queue *q, const char *name)</span>
 	struct scsi_device_handler *scsi_dh;
 	int err = 0;
 
<span class="p_del">-	sdev = get_sdev_from_queue(q);</span>
<span class="p_add">+	sdev = scsi_device_from_queue(q);</span>
 	if (!sdev)
 		return -ENODEV;
 
<span class="p_chunk">@@ -359,7 +345,7 @@</span> <span class="p_context"> const char *scsi_dh_attached_handler_name(struct request_queue *q, gfp_t gfp)</span>
 	struct scsi_device *sdev;
 	const char *handler_name = NULL;
 
<span class="p_del">-	sdev = get_sdev_from_queue(q);</span>
<span class="p_add">+	sdev = scsi_device_from_queue(q);</span>
 	if (!sdev)
 		return NULL;
 
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index e64eae4392a4..d8099c7cab00 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -2127,6 +2127,29 @@</span> <span class="p_context"> void scsi_mq_destroy_tags(struct Scsi_Host *shost)</span>
 	blk_mq_free_tag_set(&amp;shost-&gt;tag_set);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * scsi_device_from_queue - return sdev associated with a request_queue</span>
<span class="p_add">+ * @q: The request queue to return the sdev from</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return the sdev associated with a request queue or NULL if the</span>
<span class="p_add">+ * request_queue does not reference a SCSI device.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct scsi_device *scsi_device_from_queue(struct request_queue *q)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct scsi_device *sdev = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (q-&gt;mq_ops) {</span>
<span class="p_add">+		if (q-&gt;mq_ops == &amp;scsi_mq_ops)</span>
<span class="p_add">+			sdev = q-&gt;queuedata;</span>
<span class="p_add">+	} else if (q-&gt;request_fn == scsi_request_fn)</span>
<span class="p_add">+		sdev = q-&gt;queuedata;</span>
<span class="p_add">+	if (!sdev || !get_device(&amp;sdev-&gt;sdev_gendev))</span>
<span class="p_add">+		sdev = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return sdev;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(scsi_device_from_queue);</span>
<span class="p_add">+</span>
 /*
  * Function:    scsi_block_requests()
  *
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 8ccfc9ea874b..3f218f5cf29b 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -136,6 +136,8 @@</span> <span class="p_context"> struct hv_fc_wwn_packet {</span>
 #define SRB_FLAGS_PORT_DRIVER_RESERVED		0x0F000000
 #define SRB_FLAGS_CLASS_DRIVER_RESERVED		0xF0000000
 
<span class="p_add">+#define SP_UNTAGGED			((unsigned char) ~0)</span>
<span class="p_add">+#define SRB_SIMPLE_TAG_REQUEST		0x20</span>
 
 /*
  * Platform neutral description of a scsi request -
<span class="p_chunk">@@ -375,6 +377,7 @@</span> <span class="p_context"> enum storvsc_request_type {</span>
 #define SRB_STATUS_SUCCESS	0x01
 #define SRB_STATUS_ABORTED	0x02
 #define SRB_STATUS_ERROR	0x04
<span class="p_add">+#define SRB_STATUS_DATA_OVERRUN	0x12</span>
 
 #define SRB_STATUS(status) \
 	(status &amp; ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))
<span class="p_chunk">@@ -889,6 +892,13 @@</span> <span class="p_context"> static void storvsc_handle_error(struct vmscsi_request *vm_srb,</span>
 	switch (SRB_STATUS(vm_srb-&gt;srb_status)) {
 	case SRB_STATUS_ERROR:
 		/*
<span class="p_add">+		 * Let upper layer deal with error when</span>
<span class="p_add">+		 * sense message is present.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+</span>
<span class="p_add">+		if (vm_srb-&gt;srb_status &amp; SRB_STATUS_AUTOSENSE_VALID)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/*</span>
 		 * If there is an error; offline the device since all
 		 * error recovery strategies would have already been
 		 * deployed on the host side. However, if the command
<span class="p_chunk">@@ -953,6 +963,7 @@</span> <span class="p_context"> static void storvsc_command_completion(struct storvsc_cmd_request *cmd_request,</span>
 	struct scsi_cmnd *scmnd = cmd_request-&gt;cmd;
 	struct scsi_sense_hdr sense_hdr;
 	struct vmscsi_request *vm_srb;
<span class="p_add">+	u32 data_transfer_length;</span>
 	struct Scsi_Host *host;
 	u32 payload_sz = cmd_request-&gt;payload_sz;
 	void *payload = cmd_request-&gt;payload;
<span class="p_chunk">@@ -960,6 +971,7 @@</span> <span class="p_context"> static void storvsc_command_completion(struct storvsc_cmd_request *cmd_request,</span>
 	host = stor_dev-&gt;host;
 
 	vm_srb = &amp;cmd_request-&gt;vstor_packet.vm_srb;
<span class="p_add">+	data_transfer_length = vm_srb-&gt;data_transfer_length;</span>
 
 	scmnd-&gt;result = vm_srb-&gt;scsi_status;
 
<span class="p_chunk">@@ -973,13 +985,20 @@</span> <span class="p_context"> static void storvsc_command_completion(struct storvsc_cmd_request *cmd_request,</span>
 					     &amp;sense_hdr);
 	}
 
<span class="p_del">-	if (vm_srb-&gt;srb_status != SRB_STATUS_SUCCESS)</span>
<span class="p_add">+	if (vm_srb-&gt;srb_status != SRB_STATUS_SUCCESS) {</span>
 		storvsc_handle_error(vm_srb, scmnd, host, sense_hdr.asc,
 					 sense_hdr.ascq);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The Windows driver set data_transfer_length on</span>
<span class="p_add">+		 * SRB_STATUS_DATA_OVERRUN. On other errors, this value</span>
<span class="p_add">+		 * is untouched.  In these cases we set it to 0.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (vm_srb-&gt;srb_status != SRB_STATUS_DATA_OVERRUN)</span>
<span class="p_add">+			data_transfer_length = 0;</span>
<span class="p_add">+	}</span>
 
 	scsi_set_resid(scmnd,
<span class="p_del">-		cmd_request-&gt;payload-&gt;range.len -</span>
<span class="p_del">-		vm_srb-&gt;data_transfer_length);</span>
<span class="p_add">+		cmd_request-&gt;payload-&gt;range.len - data_transfer_length);</span>
 
 	scmnd-&gt;scsi_done(scmnd);
 
<span class="p_chunk">@@ -1451,6 +1470,13 @@</span> <span class="p_context"> static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)</span>
 	vm_srb-&gt;win8_extension.srb_flags |=
 		SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
 
<span class="p_add">+	if (scmnd-&gt;device-&gt;tagged_supported) {</span>
<span class="p_add">+		vm_srb-&gt;win8_extension.srb_flags |=</span>
<span class="p_add">+		(SRB_FLAGS_QUEUE_ACTION_ENABLE | SRB_FLAGS_NO_QUEUE_FREEZE);</span>
<span class="p_add">+		vm_srb-&gt;win8_extension.queue_tag = SP_UNTAGGED;</span>
<span class="p_add">+		vm_srb-&gt;win8_extension.queue_action = SRB_SIMPLE_TAG_REQUEST;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Build the SRB */
 	switch (scmnd-&gt;sc_data_direction) {
 	case DMA_TO_DEVICE:
<span class="p_header">diff --git a/drivers/spi/spi-s3c64xx.c b/drivers/spi/spi-s3c64xx.c</span>
<span class="p_header">index 3c09e94cf827..186342b74141 100644</span>
<span class="p_header">--- a/drivers/spi/spi-s3c64xx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-s3c64xx.c</span>
<span class="p_chunk">@@ -1003,7 +1003,7 @@</span> <span class="p_context"> static struct s3c64xx_spi_info *s3c64xx_spi_parse_dt(struct device *dev)</span>
 		sci-&gt;num_cs = temp;
 	}
 
<span class="p_del">-	sci-&gt;no_cs = of_property_read_bool(dev-&gt;of_node, &quot;broken-cs&quot;);</span>
<span class="p_add">+	sci-&gt;no_cs = of_property_read_bool(dev-&gt;of_node, &quot;no-cs-readback&quot;);</span>
 
 	return sci;
 }
<span class="p_header">diff --git a/drivers/staging/greybus/loopback.c b/drivers/staging/greybus/loopback.c</span>
<span class="p_header">index 7882306adeca..29dc249b0c74 100644</span>
<span class="p_header">--- a/drivers/staging/greybus/loopback.c</span>
<span class="p_header">+++ b/drivers/staging/greybus/loopback.c</span>
<span class="p_chunk">@@ -1051,8 +1051,13 @@</span> <span class="p_context"> static int gb_loopback_fn(void *data)</span>
 			gb_loopback_calculate_stats(gb, !!error);
 		}
 		gb-&gt;send_count++;
<span class="p_del">-		if (us_wait)</span>
<span class="p_del">-			udelay(us_wait);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (us_wait) {</span>
<span class="p_add">+			if (us_wait &lt; 20000)</span>
<span class="p_add">+				usleep_range(us_wait, us_wait + 100);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				msleep(us_wait / 1000);</span>
<span class="p_add">+		}</span>
 	}
 
 	gb_pm_runtime_put_autosuspend(bundle);
<span class="p_header">diff --git a/drivers/staging/lustre/lnet/selftest/rpc.c b/drivers/staging/lustre/lnet/selftest/rpc.c</span>
<span class="p_header">index f5619d8744ef..0256d65dfcd8 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lnet/selftest/rpc.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lnet/selftest/rpc.c</span>
<span class="p_chunk">@@ -252,7 +252,7 @@</span> <span class="p_context"> srpc_service_init(struct srpc_service *svc)</span>
 	svc-&gt;sv_shuttingdown = 0;
 
 	svc-&gt;sv_cpt_data = cfs_percpt_alloc(lnet_cpt_table(),
<span class="p_del">-					    sizeof(*svc-&gt;sv_cpt_data));</span>
<span class="p_add">+					    sizeof(**svc-&gt;sv_cpt_data));</span>
 	if (!svc-&gt;sv_cpt_data)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_recv.c b/drivers/staging/rtl8188eu/core/rtw_recv.c</span>
<span class="p_header">index b87cbbbee054..b39fd1e9b4a0 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_recv.c</span>
<span class="p_chunk">@@ -1383,6 +1383,9 @@</span> <span class="p_context"> static int wlanhdr_to_ethhdr(struct recv_frame *precvframe)</span>
 		ptr = recvframe_pull(precvframe, (rmv_len-sizeof(struct ethhdr) + (bsnaphdr ? 2 : 0)));
 	}
 
<span class="p_add">+	if (!ptr)</span>
<span class="p_add">+		return _FAIL;</span>
<span class="p_add">+</span>
 	memcpy(ptr, pattrib-&gt;dst, ETH_ALEN);
 	memcpy(ptr+ETH_ALEN, pattrib-&gt;src, ETH_ALEN);
 
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl871x_recv.c b/drivers/staging/rtl8712/rtl871x_recv.c</span>
<span class="p_header">index cbd2e51ba42b..cedf25b0b093 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl871x_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl871x_recv.c</span>
<span class="p_chunk">@@ -643,11 +643,16 @@</span> <span class="p_context"> sint r8712_wlanhdr_to_ethhdr(union recv_frame *precvframe)</span>
 		/* append rx status for mp test packets */
 		ptr = recvframe_pull(precvframe, (rmv_len -
 		      sizeof(struct ethhdr) + 2) - 24);
<span class="p_add">+		if (!ptr)</span>
<span class="p_add">+			return _FAIL;</span>
 		memcpy(ptr, get_rxmem(precvframe), 24);
 		ptr += 24;
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		ptr = recvframe_pull(precvframe, (rmv_len -
 		      sizeof(struct ethhdr) + (bsnaphdr ? 2 : 0)));
<span class="p_add">+		if (!ptr)</span>
<span class="p_add">+			return _FAIL;</span>
<span class="p_add">+	}</span>
 
 	memcpy(ptr, pattrib-&gt;dst, ETH_ALEN);
 	memcpy(ptr + ETH_ALEN, pattrib-&gt;src, ETH_ALEN);
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index d2b860ebfe13..5dc6bfc91f4b 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1234,6 +1234,9 @@</span> <span class="p_context"> int __dwc3_gadget_ep_set_halt(struct dwc3_ep *dep, int value, int protocol)</span>
 		unsigned transfer_in_flight;
 		unsigned started;
 
<span class="p_add">+		if (dep-&gt;flags &amp; DWC3_EP_STALL)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
 		if (dep-&gt;number &gt; 1)
 			trb = dwc3_ep_prev_trb(dep, dep-&gt;trb_enqueue);
 		else
<span class="p_chunk">@@ -1258,6 +1261,8 @@</span> <span class="p_context"> int __dwc3_gadget_ep_set_halt(struct dwc3_ep *dep, int value, int protocol)</span>
 		else
 			dep-&gt;flags |= DWC3_EP_STALL;
 	} else {
<span class="p_add">+		if (!(dep-&gt;flags &amp; DWC3_EP_STALL))</span>
<span class="p_add">+			return 0;</span>
 
 		ret = dwc3_send_clear_stall_ep_cmd(dep);
 		if (ret)
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_hid.c b/drivers/usb/gadget/function/f_hid.c</span>
<span class="p_header">index e2966f87c860..b0f71957d00b 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_hid.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_hid.c</span>
<span class="p_chunk">@@ -50,12 +50,12 @@</span> <span class="p_context"> struct f_hidg {</span>
 
 	/* recv report */
 	struct list_head		completed_out_req;
<span class="p_del">-	spinlock_t			spinlock;</span>
<span class="p_add">+	spinlock_t			read_spinlock;</span>
 	wait_queue_head_t		read_queue;
 	unsigned int			qlen;
 
 	/* send report */
<span class="p_del">-	struct mutex			lock;</span>
<span class="p_add">+	spinlock_t			write_spinlock;</span>
 	bool				write_pending;
 	wait_queue_head_t		write_queue;
 	struct usb_request		*req;
<span class="p_chunk">@@ -204,28 +204,35 @@</span> <span class="p_context"> static ssize_t f_hidg_read(struct file *file, char __user *buffer,</span>
 	if (!access_ok(VERIFY_WRITE, buffer, count))
 		return -EFAULT;
 
<span class="p_del">-	spin_lock_irqsave(&amp;hidg-&gt;spinlock, flags);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;hidg-&gt;read_spinlock, flags);</span>
 
 #define READ_COND (!list_empty(&amp;hidg-&gt;completed_out_req))
 
 	/* wait for at least one buffer to complete */
 	while (!READ_COND) {
<span class="p_del">-		spin_unlock_irqrestore(&amp;hidg-&gt;spinlock, flags);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;hidg-&gt;read_spinlock, flags);</span>
 		if (file-&gt;f_flags &amp; O_NONBLOCK)
 			return -EAGAIN;
 
 		if (wait_event_interruptible(hidg-&gt;read_queue, READ_COND))
 			return -ERESTARTSYS;
 
<span class="p_del">-		spin_lock_irqsave(&amp;hidg-&gt;spinlock, flags);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;hidg-&gt;read_spinlock, flags);</span>
 	}
 
 	/* pick the first one */
 	list = list_first_entry(&amp;hidg-&gt;completed_out_req,
 				struct f_hidg_req_list, list);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Remove this from list to protect it from beign free()</span>
<span class="p_add">+	 * while host disables our function</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	list_del(&amp;list-&gt;list);</span>
<span class="p_add">+</span>
 	req = list-&gt;req;
 	count = min_t(unsigned int, count, req-&gt;actual - list-&gt;pos);
<span class="p_del">-	spin_unlock_irqrestore(&amp;hidg-&gt;spinlock, flags);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;hidg-&gt;read_spinlock, flags);</span>
 
 	/* copy to user outside spinlock */
 	count -= copy_to_user(buffer, req-&gt;buf + list-&gt;pos, count);
<span class="p_chunk">@@ -238,15 +245,20 @@</span> <span class="p_context"> static ssize_t f_hidg_read(struct file *file, char __user *buffer,</span>
 	 * call, taking into account its current read position.
 	 */
 	if (list-&gt;pos == req-&gt;actual) {
<span class="p_del">-		spin_lock_irqsave(&amp;hidg-&gt;spinlock, flags);</span>
<span class="p_del">-		list_del(&amp;list-&gt;list);</span>
 		kfree(list);
<span class="p_del">-		spin_unlock_irqrestore(&amp;hidg-&gt;spinlock, flags);</span>
 
 		req-&gt;length = hidg-&gt;report_length;
 		ret = usb_ep_queue(hidg-&gt;out_ep, req, GFP_KERNEL);
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			free_ep_req(hidg-&gt;out_ep, req);</span>
 			return ret;
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		spin_lock_irqsave(&amp;hidg-&gt;read_spinlock, flags);</span>
<span class="p_add">+		list_add(&amp;list-&gt;list, &amp;hidg-&gt;completed_out_req);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;hidg-&gt;read_spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+		wake_up(&amp;hidg-&gt;read_queue);</span>
 	}
 
 	return count;
<span class="p_chunk">@@ -255,13 +267,16 @@</span> <span class="p_context"> static ssize_t f_hidg_read(struct file *file, char __user *buffer,</span>
 static void f_hidg_req_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct f_hidg *hidg = (struct f_hidg *)ep-&gt;driver_data;
<span class="p_add">+	unsigned long flags;</span>
 
 	if (req-&gt;status != 0) {
 		ERROR(hidg-&gt;func.config-&gt;cdev,
 			&quot;End Point Request ERROR: %d\n&quot;, req-&gt;status);
 	}
 
<span class="p_add">+	spin_lock_irqsave(&amp;hidg-&gt;write_spinlock, flags);</span>
 	hidg-&gt;write_pending = 0;
<span class="p_add">+	spin_unlock_irqrestore(&amp;hidg-&gt;write_spinlock, flags);</span>
 	wake_up(&amp;hidg-&gt;write_queue);
 }
 
<span class="p_chunk">@@ -269,18 +284,19 @@</span> <span class="p_context"> static ssize_t f_hidg_write(struct file *file, const char __user *buffer,</span>
 			    size_t count, loff_t *offp)
 {
 	struct f_hidg *hidg  = file-&gt;private_data;
<span class="p_add">+	unsigned long flags;</span>
 	ssize_t status = -ENOMEM;
 
 	if (!access_ok(VERIFY_READ, buffer, count))
 		return -EFAULT;
 
<span class="p_del">-	mutex_lock(&amp;hidg-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;hidg-&gt;write_spinlock, flags);</span>
 
 #define WRITE_COND (!hidg-&gt;write_pending)
 
 	/* write queue */
 	while (!WRITE_COND) {
<span class="p_del">-		mutex_unlock(&amp;hidg-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;hidg-&gt;write_spinlock, flags);</span>
 		if (file-&gt;f_flags &amp; O_NONBLOCK)
 			return -EAGAIN;
 
<span class="p_chunk">@@ -288,17 +304,20 @@</span> <span class="p_context"> static ssize_t f_hidg_write(struct file *file, const char __user *buffer,</span>
 				hidg-&gt;write_queue, WRITE_COND))
 			return -ERESTARTSYS;
 
<span class="p_del">-		mutex_lock(&amp;hidg-&gt;lock);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;hidg-&gt;write_spinlock, flags);</span>
 	}
 
<span class="p_add">+	hidg-&gt;write_pending = 1;</span>
 	count  = min_t(unsigned, count, hidg-&gt;report_length);
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;hidg-&gt;write_spinlock, flags);</span>
 	status = copy_from_user(hidg-&gt;req-&gt;buf, buffer, count);
 
 	if (status != 0) {
 		ERROR(hidg-&gt;func.config-&gt;cdev,
 			&quot;copy_from_user error\n&quot;);
<span class="p_del">-		mutex_unlock(&amp;hidg-&gt;lock);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		status = -EINVAL;</span>
<span class="p_add">+		goto release_write_pending;</span>
 	}
 
 	hidg-&gt;req-&gt;status   = 0;
<span class="p_chunk">@@ -306,19 +325,23 @@</span> <span class="p_context"> static ssize_t f_hidg_write(struct file *file, const char __user *buffer,</span>
 	hidg-&gt;req-&gt;length   = count;
 	hidg-&gt;req-&gt;complete = f_hidg_req_complete;
 	hidg-&gt;req-&gt;context  = hidg;
<span class="p_del">-	hidg-&gt;write_pending = 1;</span>
 
 	status = usb_ep_queue(hidg-&gt;in_ep, hidg-&gt;req, GFP_ATOMIC);
 	if (status &lt; 0) {
 		ERROR(hidg-&gt;func.config-&gt;cdev,
 			&quot;usb_ep_queue error on int endpoint %zd\n&quot;, status);
<span class="p_del">-		hidg-&gt;write_pending = 0;</span>
<span class="p_del">-		wake_up(&amp;hidg-&gt;write_queue);</span>
<span class="p_add">+		goto release_write_pending;</span>
 	} else {
 		status = count;
 	}
 
<span class="p_del">-	mutex_unlock(&amp;hidg-&gt;lock);</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+release_write_pending:</span>
<span class="p_add">+	spin_lock_irqsave(&amp;hidg-&gt;write_spinlock, flags);</span>
<span class="p_add">+	hidg-&gt;write_pending = 0;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;hidg-&gt;write_spinlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	wake_up(&amp;hidg-&gt;write_queue);</span>
 
 	return status;
 }
<span class="p_chunk">@@ -371,20 +394,36 @@</span> <span class="p_context"> static inline struct usb_request *hidg_alloc_ep_req(struct usb_ep *ep,</span>
 static void hidg_set_report_complete(struct usb_ep *ep, struct usb_request *req)
 {
 	struct f_hidg *hidg = (struct f_hidg *) req-&gt;context;
<span class="p_add">+	struct usb_composite_dev *cdev = hidg-&gt;func.config-&gt;cdev;</span>
 	struct f_hidg_req_list *req_list;
 	unsigned long flags;
 
<span class="p_del">-	req_list = kzalloc(sizeof(*req_list), GFP_ATOMIC);</span>
<span class="p_del">-	if (!req_list)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	switch (req-&gt;status) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		req_list = kzalloc(sizeof(*req_list), GFP_ATOMIC);</span>
<span class="p_add">+		if (!req_list) {</span>
<span class="p_add">+			ERROR(cdev, &quot;Unable to allocate mem for req_list\n&quot;);</span>
<span class="p_add">+			goto free_req;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	req_list-&gt;req = req;</span>
<span class="p_add">+		req_list-&gt;req = req;</span>
 
<span class="p_del">-	spin_lock_irqsave(&amp;hidg-&gt;spinlock, flags);</span>
<span class="p_del">-	list_add_tail(&amp;req_list-&gt;list, &amp;hidg-&gt;completed_out_req);</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;hidg-&gt;spinlock, flags);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;hidg-&gt;read_spinlock, flags);</span>
<span class="p_add">+		list_add_tail(&amp;req_list-&gt;list, &amp;hidg-&gt;completed_out_req);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;hidg-&gt;read_spinlock, flags);</span>
 
<span class="p_del">-	wake_up(&amp;hidg-&gt;read_queue);</span>
<span class="p_add">+		wake_up(&amp;hidg-&gt;read_queue);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		ERROR(cdev, &quot;Set report failed %d\n&quot;, req-&gt;status);</span>
<span class="p_add">+		/* FALLTHROUGH */</span>
<span class="p_add">+	case -ECONNABORTED:		/* hardware forced ep reset */</span>
<span class="p_add">+	case -ECONNRESET:		/* request dequeued */</span>
<span class="p_add">+	case -ESHUTDOWN:		/* disconnect from host */</span>
<span class="p_add">+free_req:</span>
<span class="p_add">+		free_ep_req(ep, req);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 }
 
 static int hidg_setup(struct usb_function *f,
<span class="p_chunk">@@ -490,14 +529,18 @@</span> <span class="p_context"> static void hidg_disable(struct usb_function *f)</span>
 {
 	struct f_hidg *hidg = func_to_hidg(f);
 	struct f_hidg_req_list *list, *next;
<span class="p_add">+	unsigned long flags;</span>
 
 	usb_ep_disable(hidg-&gt;in_ep);
 	usb_ep_disable(hidg-&gt;out_ep);
 
<span class="p_add">+	spin_lock_irqsave(&amp;hidg-&gt;read_spinlock, flags);</span>
 	list_for_each_entry_safe(list, next, &amp;hidg-&gt;completed_out_req, list) {
<span class="p_add">+		free_ep_req(hidg-&gt;out_ep, list-&gt;req);</span>
 		list_del(&amp;list-&gt;list);
 		kfree(list);
 	}
<span class="p_add">+	spin_unlock_irqrestore(&amp;hidg-&gt;read_spinlock, flags);</span>
 }
 
 static int hidg_set_alt(struct usb_function *f, unsigned intf, unsigned alt)
<span class="p_chunk">@@ -646,8 +689,8 @@</span> <span class="p_context"> static int hidg_bind(struct usb_configuration *c, struct usb_function *f)</span>
 	if (status)
 		goto fail;
 
<span class="p_del">-	mutex_init(&amp;hidg-&gt;lock);</span>
<span class="p_del">-	spin_lock_init(&amp;hidg-&gt;spinlock);</span>
<span class="p_add">+	spin_lock_init(&amp;hidg-&gt;write_spinlock);</span>
<span class="p_add">+	spin_lock_init(&amp;hidg-&gt;read_spinlock);</span>
 	init_waitqueue_head(&amp;hidg-&gt;write_queue);
 	init_waitqueue_head(&amp;hidg-&gt;read_queue);
 	INIT_LIST_HEAD(&amp;hidg-&gt;completed_out_req);
<span class="p_header">diff --git a/drivers/usb/gadget/udc/core.c b/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">index 0402177f93cd..d685d82dcf48 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/core.c</span>
<span class="p_chunk">@@ -1080,6 +1080,24 @@</span> <span class="p_context"> static void usb_udc_nop_release(struct device *dev)</span>
 	dev_vdbg(dev, &quot;%s\n&quot;, __func__);
 }
 
<span class="p_add">+/* should be called with udc_lock held */</span>
<span class="p_add">+static int check_pending_gadget_drivers(struct usb_udc *udc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_gadget_driver *driver;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(driver, &amp;gadget_driver_pending_list, pending)</span>
<span class="p_add">+		if (!driver-&gt;udc_name || strcmp(driver-&gt;udc_name,</span>
<span class="p_add">+						dev_name(&amp;udc-&gt;dev)) == 0) {</span>
<span class="p_add">+			ret = udc_bind_to_driver(udc, driver);</span>
<span class="p_add">+			if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+				list_del(&amp;driver-&gt;pending);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * usb_add_gadget_udc_release - adds a new gadget to the udc class driver list
  * @parent: the parent device to this udc. Usually the controller driver&#39;s
<span class="p_chunk">@@ -1093,7 +1111,6 @@</span> <span class="p_context"> int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,</span>
 		void (*release)(struct device *dev))
 {
 	struct usb_udc		*udc;
<span class="p_del">-	struct usb_gadget_driver *driver;</span>
 	int			ret = -ENOMEM;
 
 	udc = kzalloc(sizeof(*udc), GFP_KERNEL);
<span class="p_chunk">@@ -1136,17 +1153,9 @@</span> <span class="p_context"> int usb_add_gadget_udc_release(struct device *parent, struct usb_gadget *gadget,</span>
 	udc-&gt;vbus = true;
 
 	/* pick up one of pending gadget drivers */
<span class="p_del">-	list_for_each_entry(driver, &amp;gadget_driver_pending_list, pending) {</span>
<span class="p_del">-		if (!driver-&gt;udc_name || strcmp(driver-&gt;udc_name,</span>
<span class="p_del">-						dev_name(&amp;udc-&gt;dev)) == 0) {</span>
<span class="p_del">-			ret = udc_bind_to_driver(udc, driver);</span>
<span class="p_del">-			if (ret != -EPROBE_DEFER)</span>
<span class="p_del">-				list_del(&amp;driver-&gt;pending);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				goto err5;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	ret = check_pending_gadget_drivers(udc);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err5;</span>
 
 	mutex_unlock(&amp;udc_lock);
 
<span class="p_chunk">@@ -1356,14 +1365,22 @@</span> <span class="p_context"> int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)</span>
 		return -EINVAL;
 
 	mutex_lock(&amp;udc_lock);
<span class="p_del">-	list_for_each_entry(udc, &amp;udc_list, list)</span>
<span class="p_add">+	list_for_each_entry(udc, &amp;udc_list, list) {</span>
 		if (udc-&gt;driver == driver) {
 			usb_gadget_remove_driver(udc);
 			usb_gadget_set_state(udc-&gt;gadget,
<span class="p_del">-					USB_STATE_NOTATTACHED);</span>
<span class="p_add">+					     USB_STATE_NOTATTACHED);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Maybe there is someone waiting for this UDC? */</span>
<span class="p_add">+			check_pending_gadget_drivers(udc);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * For now we ignore bind errors as probably it&#39;s</span>
<span class="p_add">+			 * not a valid reason to fail other&#39;s gadget unbind</span>
<span class="p_add">+			 */</span>
 			ret = 0;
 			break;
 		}
<span class="p_add">+	}</span>
 
 	if (ret) {
 		list_del(&amp;driver-&gt;pending);
<span class="p_header">diff --git a/drivers/usb/gadget/udc/fsl_udc_core.c b/drivers/usb/gadget/udc/fsl_udc_core.c</span>
<span class="p_header">index aab5221d6c2e..aac0ce8aeb0b 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/fsl_udc_core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/fsl_udc_core.c</span>
<span class="p_chunk">@@ -1249,6 +1249,12 @@</span> <span class="p_context"> static const struct usb_gadget_ops fsl_gadget_ops = {</span>
 	.udc_stop = fsl_udc_stop,
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Empty complete function used by this driver to fill in the req-&gt;complete</span>
<span class="p_add">+ * field when creating a request since the complete field is mandatory.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void fsl_noop_complete(struct usb_ep *ep, struct usb_request *req) { }</span>
<span class="p_add">+</span>
 /* Set protocol stall on ep0, protocol stall will automatically be cleared
    on new transaction */
 static void ep0stall(struct fsl_udc *udc)
<span class="p_chunk">@@ -1283,7 +1289,7 @@</span> <span class="p_context"> static int ep0_prime_status(struct fsl_udc *udc, int direction)</span>
 	req-&gt;req.length = 0;
 	req-&gt;req.status = -EINPROGRESS;
 	req-&gt;req.actual = 0;
<span class="p_del">-	req-&gt;req.complete = NULL;</span>
<span class="p_add">+	req-&gt;req.complete = fsl_noop_complete;</span>
 	req-&gt;dtd_count = 0;
 
 	ret = usb_gadget_map_request(&amp;ep-&gt;udc-&gt;gadget, &amp;req-&gt;req, ep_is_in(ep));
<span class="p_chunk">@@ -1366,7 +1372,7 @@</span> <span class="p_context"> static void ch9getstatus(struct fsl_udc *udc, u8 request_type, u16 value,</span>
 	req-&gt;req.length = 2;
 	req-&gt;req.status = -EINPROGRESS;
 	req-&gt;req.actual = 0;
<span class="p_del">-	req-&gt;req.complete = NULL;</span>
<span class="p_add">+	req-&gt;req.complete = fsl_noop_complete;</span>
 	req-&gt;dtd_count = 0;
 
 	ret = usb_gadget_map_request(&amp;ep-&gt;udc-&gt;gadget, &amp;req-&gt;req, ep_is_in(ep));
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">index ed56bf9ed885..abe360684f0b 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.c</span>
<span class="p_chunk">@@ -223,9 +223,6 @@</span> <span class="p_context"> static int xhci_plat_probe(struct platform_device *pdev)</span>
 	if (device_property_read_bool(&amp;pdev-&gt;dev, &quot;usb3-lpm-capable&quot;))
 		xhci-&gt;quirks |= XHCI_LPM_SUPPORT;
 
<span class="p_del">-	if (HCC_MAX_PSA(xhci-&gt;hcc_params) &gt;= 4)</span>
<span class="p_del">-		xhci-&gt;shared_hcd-&gt;can_do_streams = 1;</span>
<span class="p_del">-</span>
 	hcd-&gt;usb_phy = devm_usb_get_phy_by_phandle(&amp;pdev-&gt;dev, &quot;usb-phy&quot;, 0);
 	if (IS_ERR(hcd-&gt;usb_phy)) {
 		ret = PTR_ERR(hcd-&gt;usb_phy);
<span class="p_chunk">@@ -242,6 +239,9 @@</span> <span class="p_context"> static int xhci_plat_probe(struct platform_device *pdev)</span>
 	if (ret)
 		goto disable_usb_phy;
 
<span class="p_add">+	if (HCC_MAX_PSA(xhci-&gt;hcc_params) &gt;= 4)</span>
<span class="p_add">+		xhci-&gt;shared_hcd-&gt;can_do_streams = 1;</span>
<span class="p_add">+</span>
 	ret = usb_add_hcd(xhci-&gt;shared_hcd, irq, IRQF_SHARED);
 	if (ret)
 		goto dealloc_usb2_hcd;
<span class="p_header">diff --git a/drivers/usb/musb/da8xx.c b/drivers/usb/musb/da8xx.c</span>
<span class="p_header">index 2440f88e07a3..bacee0fd4dd3 100644</span>
<span class="p_header">--- a/drivers/usb/musb/da8xx.c</span>
<span class="p_header">+++ b/drivers/usb/musb/da8xx.c</span>
<span class="p_chunk">@@ -434,15 +434,11 @@</span> <span class="p_context"> static int da8xx_musb_exit(struct musb *musb)</span>
 }
 
 static const struct musb_platform_ops da8xx_ops = {
<span class="p_del">-	.quirks		= MUSB_DMA_CPPI | MUSB_INDEXED_EP,</span>
<span class="p_add">+	.quirks		= MUSB_INDEXED_EP,</span>
 	.init		= da8xx_musb_init,
 	.exit		= da8xx_musb_exit,
 
 	.fifo_mode	= 2,
<span class="p_del">-#ifdef CONFIG_USB_TI_CPPI_DMA</span>
<span class="p_del">-	.dma_init	= cppi_dma_controller_create,</span>
<span class="p_del">-	.dma_exit	= cppi_dma_controller_destroy,</span>
<span class="p_del">-#endif</span>
 	.enable		= da8xx_musb_enable,
 	.disable	= da8xx_musb_disable,
 
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 181793f07852..9d2738e9217f 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -615,8 +615,12 @@</span> <span class="p_context"> static void virtballoon_remove(struct virtio_device *vdev)</span>
 	cancel_work_sync(&amp;vb-&gt;update_balloon_stats_work);
 
 	remove_common(vb);
<span class="p_add">+#ifdef CONFIG_BALLOON_COMPACTION</span>
 	if (vb-&gt;vb_dev_info.inode)
 		iput(vb-&gt;vb_dev_info.inode);
<span class="p_add">+</span>
<span class="p_add">+	kern_unmount(balloon_mnt);</span>
<span class="p_add">+#endif</span>
 	kfree(vb);
 }
 
<span class="p_header">diff --git a/drivers/vme/vme.c b/drivers/vme/vme.c</span>
<span class="p_header">index bdbadaa47ef3..0035cf79760a 100644</span>
<span class="p_header">--- a/drivers/vme/vme.c</span>
<span class="p_header">+++ b/drivers/vme/vme.c</span>
<span class="p_chunk">@@ -1625,10 +1625,25 @@</span> <span class="p_context"> static int vme_bus_probe(struct device *dev)</span>
 	return retval;
 }
 
<span class="p_add">+static int vme_bus_remove(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int retval = -ENODEV;</span>
<span class="p_add">+	struct vme_driver *driver;</span>
<span class="p_add">+	struct vme_dev *vdev = dev_to_vme_dev(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	driver = dev-&gt;platform_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (driver-&gt;remove != NULL)</span>
<span class="p_add">+		retval = driver-&gt;remove(vdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return retval;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct bus_type vme_bus_type = {
 	.name = &quot;vme&quot;,
 	.match = vme_bus_match,
 	.probe = vme_bus_probe,
<span class="p_add">+	.remove = vme_bus_remove,</span>
 };
 EXPORT_SYMBOL(vme_bus_type);
 
<span class="p_header">diff --git a/drivers/w1/masters/ds2490.c b/drivers/w1/masters/ds2490.c</span>
<span class="p_header">index 049a884a756f..59d74d1b47a8 100644</span>
<span class="p_header">--- a/drivers/w1/masters/ds2490.c</span>
<span class="p_header">+++ b/drivers/w1/masters/ds2490.c</span>
<span class="p_chunk">@@ -153,6 +153,9 @@</span> <span class="p_context"> struct ds_device</span>
 	 */
 	u16			spu_bit;
 
<span class="p_add">+	u8			st_buf[ST_SIZE];</span>
<span class="p_add">+	u8			byte_buf;</span>
<span class="p_add">+</span>
 	struct w1_bus_master	master;
 };
 
<span class="p_chunk">@@ -174,7 +177,6 @@</span> <span class="p_context"> struct ds_status</span>
 	u8			data_in_buffer_status;
 	u8			reserved1;
 	u8			reserved2;
<span class="p_del">-</span>
 };
 
 static struct usb_device_id ds_id_table [] = {
<span class="p_chunk">@@ -244,28 +246,6 @@</span> <span class="p_context"> static int ds_send_control(struct ds_device *dev, u16 value, u16 index)</span>
 	return err;
 }
 
<span class="p_del">-static int ds_recv_status_nodump(struct ds_device *dev, struct ds_status *st,</span>
<span class="p_del">-				 unsigned char *buf, int size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int count, err;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(st, 0, sizeof(*st));</span>
<span class="p_del">-</span>
<span class="p_del">-	count = 0;</span>
<span class="p_del">-	err = usb_interrupt_msg(dev-&gt;udev, usb_rcvintpipe(dev-&gt;udev,</span>
<span class="p_del">-		dev-&gt;ep[EP_STATUS]), buf, size, &amp;count, 1000);</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		pr_err(&quot;Failed to read 1-wire data from 0x%x: err=%d.\n&quot;,</span>
<span class="p_del">-		       dev-&gt;ep[EP_STATUS], err);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (count &gt;= sizeof(*st))</span>
<span class="p_del">-		memcpy(st, buf, sizeof(*st));</span>
<span class="p_del">-</span>
<span class="p_del">-	return count;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void ds_print_msg(unsigned char *buf, unsigned char *str, int off)
 {
 	pr_info(&quot;%45s: %8x\n&quot;, str, buf[off]);
<span class="p_chunk">@@ -324,6 +304,35 @@</span> <span class="p_context"> static void ds_dump_status(struct ds_device *dev, unsigned char *buf, int count)</span>
 	}
 }
 
<span class="p_add">+static int ds_recv_status(struct ds_device *dev, struct ds_status *st,</span>
<span class="p_add">+			  bool dump)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int count, err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (st)</span>
<span class="p_add">+		memset(st, 0, sizeof(*st));</span>
<span class="p_add">+</span>
<span class="p_add">+	count = 0;</span>
<span class="p_add">+	err = usb_interrupt_msg(dev-&gt;udev,</span>
<span class="p_add">+				usb_rcvintpipe(dev-&gt;udev,</span>
<span class="p_add">+					       dev-&gt;ep[EP_STATUS]),</span>
<span class="p_add">+				dev-&gt;st_buf, sizeof(dev-&gt;st_buf),</span>
<span class="p_add">+				&amp;count, 1000);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;Failed to read 1-wire data from 0x%x: err=%d.\n&quot;,</span>
<span class="p_add">+		       dev-&gt;ep[EP_STATUS], err);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dump)</span>
<span class="p_add">+		ds_dump_status(dev, dev-&gt;st_buf, count);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (st &amp;&amp; count &gt;= sizeof(*st))</span>
<span class="p_add">+		memcpy(st, dev-&gt;st_buf, sizeof(*st));</span>
<span class="p_add">+</span>
<span class="p_add">+	return count;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void ds_reset_device(struct ds_device *dev)
 {
 	ds_send_control_cmd(dev, CTL_RESET_DEVICE, 0);
<span class="p_chunk">@@ -344,7 +353,6 @@</span> <span class="p_context"> static void ds_reset_device(struct ds_device *dev)</span>
 static int ds_recv_data(struct ds_device *dev, unsigned char *buf, int size)
 {
 	int count, err;
<span class="p_del">-	struct ds_status st;</span>
 
 	/* Careful on size.  If size is less than what is available in
 	 * the input buffer, the device fails the bulk transfer and
<span class="p_chunk">@@ -359,14 +367,9 @@</span> <span class="p_context"> static int ds_recv_data(struct ds_device *dev, unsigned char *buf, int size)</span>
 	err = usb_bulk_msg(dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;ep[EP_DATA_IN]),
 				buf, size, &amp;count, 1000);
 	if (err &lt; 0) {
<span class="p_del">-		u8 buf[ST_SIZE];</span>
<span class="p_del">-		int count;</span>
<span class="p_del">-</span>
 		pr_info(&quot;Clearing ep0x%x.\n&quot;, dev-&gt;ep[EP_DATA_IN]);
 		usb_clear_halt(dev-&gt;udev, usb_rcvbulkpipe(dev-&gt;udev, dev-&gt;ep[EP_DATA_IN]));
<span class="p_del">-</span>
<span class="p_del">-		count = ds_recv_status_nodump(dev, &amp;st, buf, sizeof(buf));</span>
<span class="p_del">-		ds_dump_status(dev, buf, count);</span>
<span class="p_add">+		ds_recv_status(dev, NULL, true);</span>
 		return err;
 	}
 
<span class="p_chunk">@@ -404,7 +407,6 @@</span> <span class="p_context"> int ds_stop_pulse(struct ds_device *dev, int limit)</span>
 {
 	struct ds_status st;
 	int count = 0, err = 0;
<span class="p_del">-	u8 buf[ST_SIZE];</span>
 
 	do {
 		err = ds_send_control(dev, CTL_HALT_EXE_IDLE, 0);
<span class="p_chunk">@@ -413,7 +415,7 @@</span> <span class="p_context"> int ds_stop_pulse(struct ds_device *dev, int limit)</span>
 		err = ds_send_control(dev, CTL_RESUME_EXE, 0);
 		if (err)
 			break;
<span class="p_del">-		err = ds_recv_status_nodump(dev, &amp;st, buf, sizeof(buf));</span>
<span class="p_add">+		err = ds_recv_status(dev, &amp;st, false);</span>
 		if (err)
 			break;
 
<span class="p_chunk">@@ -456,18 +458,17 @@</span> <span class="p_context"> int ds_detect(struct ds_device *dev, struct ds_status *st)</span>
 
 static int ds_wait_status(struct ds_device *dev, struct ds_status *st)
 {
<span class="p_del">-	u8 buf[ST_SIZE];</span>
 	int err, count = 0;
 
 	do {
 		st-&gt;status = 0;
<span class="p_del">-		err = ds_recv_status_nodump(dev, st, buf, sizeof(buf));</span>
<span class="p_add">+		err = ds_recv_status(dev, st, false);</span>
 #if 0
 		if (err &gt;= 0) {
 			int i;
 			printk(&quot;0x%x: count=%d, status: &quot;, dev-&gt;ep[EP_STATUS], err);
 			for (i=0; i&lt;err; ++i)
<span class="p_del">-				printk(&quot;%02x &quot;, buf[i]);</span>
<span class="p_add">+				printk(&quot;%02x &quot;, dev-&gt;st_buf[i]);</span>
 			printk(&quot;\n&quot;);
 		}
 #endif
<span class="p_chunk">@@ -485,7 +486,7 @@</span> <span class="p_context"> static int ds_wait_status(struct ds_device *dev, struct ds_status *st)</span>
 	 * can do something with it).
 	 */
 	if (err &gt; 16 || count &gt;= 100 || err &lt; 0)
<span class="p_del">-		ds_dump_status(dev, buf, err);</span>
<span class="p_add">+		ds_dump_status(dev, dev-&gt;st_buf, err);</span>
 
 	/* Extended data isn&#39;t an error.  Well, a short is, but the dump
 	 * would have already told the user that and we can&#39;t do anything
<span class="p_chunk">@@ -608,7 +609,6 @@</span> <span class="p_context"> static int ds_write_byte(struct ds_device *dev, u8 byte)</span>
 {
 	int err;
 	struct ds_status st;
<span class="p_del">-	u8 rbyte;</span>
 
 	err = ds_send_control(dev, COMM_BYTE_IO | COMM_IM | dev-&gt;spu_bit, byte);
 	if (err)
<span class="p_chunk">@@ -621,11 +621,11 @@</span> <span class="p_context"> static int ds_write_byte(struct ds_device *dev, u8 byte)</span>
 	if (err)
 		return err;
 
<span class="p_del">-	err = ds_recv_data(dev, &amp;rbyte, sizeof(rbyte));</span>
<span class="p_add">+	err = ds_recv_data(dev, &amp;dev-&gt;byte_buf, 1);</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	return !(byte == rbyte);</span>
<span class="p_add">+	return !(byte == dev-&gt;byte_buf);</span>
 }
 
 static int ds_read_byte(struct ds_device *dev, u8 *byte)
<span class="p_chunk">@@ -712,7 +712,6 @@</span> <span class="p_context"> static void ds9490r_search(void *data, struct w1_master *master,</span>
 	int err;
 	u16 value, index;
 	struct ds_status st;
<span class="p_del">-	u8 st_buf[ST_SIZE];</span>
 	int search_limit;
 	int found = 0;
 	int i;
<span class="p_chunk">@@ -724,7 +723,12 @@</span> <span class="p_context"> static void ds9490r_search(void *data, struct w1_master *master,</span>
 	/* FIFO 128 bytes, bulk packet size 64, read a multiple of the
 	 * packet size.
 	 */
<span class="p_del">-	u64 buf[2*64/8];</span>
<span class="p_add">+	const size_t bufsize = 2 * 64;</span>
<span class="p_add">+	u64 *buf;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = kmalloc(bufsize, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return;</span>
 
 	mutex_lock(&amp;master-&gt;bus_mutex);
 
<span class="p_chunk">@@ -745,10 +749,9 @@</span> <span class="p_context"> static void ds9490r_search(void *data, struct w1_master *master,</span>
 	do {
 		schedule_timeout(jtime);
 
<span class="p_del">-		if (ds_recv_status_nodump(dev, &amp;st, st_buf, sizeof(st_buf)) &lt;</span>
<span class="p_del">-			sizeof(st)) {</span>
<span class="p_add">+		err = ds_recv_status(dev, &amp;st, false);</span>
<span class="p_add">+		if (err &lt; 0 || err &lt; sizeof(st))</span>
 			break;
<span class="p_del">-		}</span>
 
 		if (st.data_in_buffer_status) {
 			/* Bulk in can receive partial ids, but when it does
<span class="p_chunk">@@ -758,7 +761,7 @@</span> <span class="p_context"> static void ds9490r_search(void *data, struct w1_master *master,</span>
 			 * bulk without first checking if status says there
 			 * is data to read.
 			 */
<span class="p_del">-			err = ds_recv_data(dev, (u8 *)buf, sizeof(buf));</span>
<span class="p_add">+			err = ds_recv_data(dev, (u8 *)buf, bufsize);</span>
 			if (err &lt; 0)
 				break;
 			for (i = 0; i &lt; err/8; ++i) {
<span class="p_chunk">@@ -794,9 +797,14 @@</span> <span class="p_context"> static void ds9490r_search(void *data, struct w1_master *master,</span>
 	}
 search_out:
 	mutex_unlock(&amp;master-&gt;bus_mutex);
<span class="p_add">+	kfree(buf);</span>
 }
 
 #if 0
<span class="p_add">+/*</span>
<span class="p_add">+ * FIXME: if this disabled code is ever used in the future all ds_send_data()</span>
<span class="p_add">+ * calls must be changed to use a DMAable buffer.</span>
<span class="p_add">+ */</span>
 static int ds_match_access(struct ds_device *dev, u64 init)
 {
 	int err;
<span class="p_chunk">@@ -845,13 +853,12 @@</span> <span class="p_context"> static int ds_set_path(struct ds_device *dev, u64 init)</span>
 
 static u8 ds9490r_touch_bit(void *data, u8 bit)
 {
<span class="p_del">-	u8 ret;</span>
 	struct ds_device *dev = data;
 
<span class="p_del">-	if (ds_touch_bit(dev, bit, &amp;ret))</span>
<span class="p_add">+	if (ds_touch_bit(dev, bit, &amp;dev-&gt;byte_buf))</span>
 		return 0;
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return dev-&gt;byte_buf;</span>
 }
 
 #if 0
<span class="p_chunk">@@ -866,13 +873,12 @@</span> <span class="p_context"> static u8 ds9490r_read_bit(void *data)</span>
 {
 	struct ds_device *dev = data;
 	int err;
<span class="p_del">-	u8 bit = 0;</span>
 
<span class="p_del">-	err = ds_touch_bit(dev, 1, &amp;bit);</span>
<span class="p_add">+	err = ds_touch_bit(dev, 1, &amp;dev-&gt;byte_buf);</span>
 	if (err)
 		return 0;
 
<span class="p_del">-	return bit &amp; 1;</span>
<span class="p_add">+	return dev-&gt;byte_buf &amp; 1;</span>
 }
 #endif
 
<span class="p_chunk">@@ -887,32 +893,52 @@</span> <span class="p_context"> static u8 ds9490r_read_byte(void *data)</span>
 {
 	struct ds_device *dev = data;
 	int err;
<span class="p_del">-	u8 byte = 0;</span>
 
<span class="p_del">-	err = ds_read_byte(dev, &amp;byte);</span>
<span class="p_add">+	err = ds_read_byte(dev, &amp;dev-&gt;byte_buf);</span>
 	if (err)
 		return 0;
 
<span class="p_del">-	return byte;</span>
<span class="p_add">+	return dev-&gt;byte_buf;</span>
 }
 
 static void ds9490r_write_block(void *data, const u8 *buf, int len)
 {
 	struct ds_device *dev = data;
<span class="p_add">+	u8 *tbuf;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (len &lt;= 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	tbuf = kmalloc(len, GFP_KERNEL);</span>
<span class="p_add">+	if (!tbuf)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	ds_write_block(dev, (u8 *)buf, len);</span>
<span class="p_add">+	memcpy(tbuf, buf, len);</span>
<span class="p_add">+	ds_write_block(dev, tbuf, len);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(tbuf);</span>
 }
 
 static u8 ds9490r_read_block(void *data, u8 *buf, int len)
 {
 	struct ds_device *dev = data;
 	int err;
<span class="p_add">+	u8 *tbuf;</span>
 
<span class="p_del">-	err = ds_read_block(dev, buf, len);</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_add">+	if (len &lt;= 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	tbuf = kmalloc(len, GFP_KERNEL);</span>
<span class="p_add">+	if (!tbuf)</span>
 		return 0;
 
<span class="p_del">-	return len;</span>
<span class="p_add">+	err = ds_read_block(dev, tbuf, len);</span>
<span class="p_add">+	if (err &gt;= 0)</span>
<span class="p_add">+		memcpy(buf, tbuf, len);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(tbuf);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err &gt;= 0 ? len : 0;</span>
 }
 
 static u8 ds9490r_reset(void *data)
<span class="p_header">diff --git a/drivers/w1/w1.c b/drivers/w1/w1.c</span>
<span class="p_header">index e213c678bbfe..ab0931e7a9bb 100644</span>
<span class="p_header">--- a/drivers/w1/w1.c</span>
<span class="p_header">+++ b/drivers/w1/w1.c</span>
<span class="p_chunk">@@ -763,6 +763,7 @@</span> <span class="p_context"> int w1_attach_slave_device(struct w1_master *dev, struct w1_reg_num *rn)</span>
 		dev_err(&amp;dev-&gt;dev, &quot;%s: Attaching %s failed.\n&quot;, __func__,
 			 sl-&gt;name);
 		w1_family_put(sl-&gt;family);
<span class="p_add">+		atomic_dec(&amp;sl-&gt;master-&gt;refcnt);</span>
 		kfree(sl);
 		return err;
 	}
<span class="p_header">diff --git a/fs/ceph/addr.c b/fs/ceph/addr.c</span>
<span class="p_header">index ef3ebd780aff..1e643c718917 100644</span>
<span class="p_header">--- a/fs/ceph/addr.c</span>
<span class="p_header">+++ b/fs/ceph/addr.c</span>
<span class="p_chunk">@@ -363,6 +363,7 @@</span> <span class="p_context"> static int start_read(struct inode *inode, struct list_head *page_list, int max)</span>
 			nr_pages = i;
 			if (nr_pages &gt; 0) {
 				len = nr_pages &lt;&lt; PAGE_SHIFT;
<span class="p_add">+				osd_req_op_extent_update(req, 0, len);</span>
 				break;
 			}
 			goto out_pages;
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 18a1e1d6671f..1cd0e2eefc66 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -2884,7 +2884,15 @@</span> <span class="p_context"> cifs_readdata_to_iov(struct cifs_readdata *rdata, struct iov_iter *iter)</span>
 	for (i = 0; i &lt; rdata-&gt;nr_pages; i++) {
 		struct page *page = rdata-&gt;pages[i];
 		size_t copy = min_t(size_t, remaining, PAGE_SIZE);
<span class="p_del">-		size_t written = copy_page_to_iter(page, 0, copy, iter);</span>
<span class="p_add">+		size_t written;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (unlikely(iter-&gt;type &amp; ITER_PIPE)) {</span>
<span class="p_add">+			void *addr = kmap_atomic(page);</span>
<span class="p_add">+</span>
<span class="p_add">+			written = copy_to_iter(addr, copy, iter);</span>
<span class="p_add">+			kunmap_atomic(addr);</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			written = copy_page_to_iter(page, 0, copy, iter);</span>
 		remaining -= written;
 		if (written &lt; copy &amp;&amp; iov_iter_count(iter) &gt; 0)
 			break;
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index c930a0110fb4..9fbf92ca358c 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -5344,7 +5344,8 @@</span> <span class="p_context"> ext4_ext_shift_extents(struct inode *inode, handle_t *handle,</span>
 	ext4_lblk_t stop, *iterator, ex_start, ex_end;
 
 	/* Let path point to the last extent */
<span class="p_del">-	path = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL, 0);</span>
<span class="p_add">+	path = ext4_find_extent(inode, EXT_MAX_BLOCKS - 1, NULL,</span>
<span class="p_add">+				EXT4_EX_NOCACHE);</span>
 	if (IS_ERR(path))
 		return PTR_ERR(path);
 
<span class="p_chunk">@@ -5353,15 +5354,15 @@</span> <span class="p_context"> ext4_ext_shift_extents(struct inode *inode, handle_t *handle,</span>
 	if (!extent)
 		goto out;
 
<span class="p_del">-	stop = le32_to_cpu(extent-&gt;ee_block) +</span>
<span class="p_del">-			ext4_ext_get_actual_len(extent);</span>
<span class="p_add">+	stop = le32_to_cpu(extent-&gt;ee_block);</span>
 
        /*
 	 * In case of left shift, Don&#39;t start shifting extents until we make
 	 * sure the hole is big enough to accommodate the shift.
 	*/
 	if (SHIFT == SHIFT_LEFT) {
<span class="p_del">-		path = ext4_find_extent(inode, start - 1, &amp;path, 0);</span>
<span class="p_add">+		path = ext4_find_extent(inode, start - 1, &amp;path,</span>
<span class="p_add">+					EXT4_EX_NOCACHE);</span>
 		if (IS_ERR(path))
 			return PTR_ERR(path);
 		depth = path-&gt;p_depth;
<span class="p_chunk">@@ -5393,9 +5394,14 @@</span> <span class="p_context"> ext4_ext_shift_extents(struct inode *inode, handle_t *handle,</span>
 	else
 		iterator = &amp;stop;
 
<span class="p_del">-	/* Its safe to start updating extents */</span>
<span class="p_del">-	while (start &lt; stop) {</span>
<span class="p_del">-		path = ext4_find_extent(inode, *iterator, &amp;path, 0);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Its safe to start updating extents.  Start and stop are unsigned, so</span>
<span class="p_add">+	 * in case of right shift if extent with 0 block is reached, iterator</span>
<span class="p_add">+	 * becomes NULL to indicate the end of the loop.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (iterator &amp;&amp; start &lt;= stop) {</span>
<span class="p_add">+		path = ext4_find_extent(inode, *iterator, &amp;path,</span>
<span class="p_add">+					EXT4_EX_NOCACHE);</span>
 		if (IS_ERR(path))
 			return PTR_ERR(path);
 		depth = path-&gt;p_depth;
<span class="p_chunk">@@ -5422,8 +5428,11 @@</span> <span class="p_context"> ext4_ext_shift_extents(struct inode *inode, handle_t *handle,</span>
 					ext4_ext_get_actual_len(extent);
 		} else {
 			extent = EXT_FIRST_EXTENT(path[depth].p_hdr);
<span class="p_del">-			*iterator =  le32_to_cpu(extent-&gt;ee_block) &gt; 0 ?</span>
<span class="p_del">-				le32_to_cpu(extent-&gt;ee_block) - 1 : 0;</span>
<span class="p_add">+			if (le32_to_cpu(extent-&gt;ee_block) &gt; 0)</span>
<span class="p_add">+				*iterator = le32_to_cpu(extent-&gt;ee_block) - 1;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				/* Beginning is reached, end of the loop */</span>
<span class="p_add">+				iterator = NULL;</span>
 			/* Update path extent in case we need to stop */
 			while (le32_to_cpu(extent-&gt;ee_block) &lt; start)
 				extent++;
<span class="p_header">diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c</span>
<span class="p_header">index d8ca4b9f9dd6..37b521ed39df 100644</span>
<span class="p_header">--- a/fs/ext4/inline.c</span>
<span class="p_header">+++ b/fs/ext4/inline.c</span>
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> static int ext4_update_inline_data(handle_t *handle, struct inode *inode,</span>
 static int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,
 				    unsigned int len)
 {
<span class="p_del">-	int ret, size;</span>
<span class="p_add">+	int ret, size, no_expand;</span>
 	struct ext4_inode_info *ei = EXT4_I(inode);
 
 	if (!ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA))
<span class="p_chunk">@@ -386,15 +386,14 @@</span> <span class="p_context"> static int ext4_prepare_inline_data(handle_t *handle, struct inode *inode,</span>
 	if (size &lt; len)
 		return -ENOSPC;
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
 
 	if (ei-&gt;i_inline_off)
 		ret = ext4_update_inline_data(handle, inode, len);
 	else
 		ret = ext4_create_inline_data(handle, inode, len);
 
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_del">-</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -523,7 +522,7 @@</span> <span class="p_context"> static int ext4_convert_inline_data_to_extent(struct address_space *mapping,</span>
 					      struct inode *inode,
 					      unsigned flags)
 {
<span class="p_del">-	int ret, needed_blocks;</span>
<span class="p_add">+	int ret, needed_blocks, no_expand;</span>
 	handle_t *handle = NULL;
 	int retries = 0, sem_held = 0;
 	struct page *page = NULL;
<span class="p_chunk">@@ -563,7 +562,7 @@</span> <span class="p_context"> static int ext4_convert_inline_data_to_extent(struct address_space *mapping,</span>
 		goto out;
 	}
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
 	sem_held = 1;
 	/* If some one has already done this for us, just exit. */
 	if (!ext4_has_inline_data(inode)) {
<span class="p_chunk">@@ -600,7 +599,7 @@</span> <span class="p_context"> static int ext4_convert_inline_data_to_extent(struct address_space *mapping,</span>
 		put_page(page);
 		page = NULL;
 		ext4_orphan_add(handle, inode);
<span class="p_del">-		up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+		ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 		sem_held = 0;
 		ext4_journal_stop(handle);
 		handle = NULL;
<span class="p_chunk">@@ -626,7 +625,7 @@</span> <span class="p_context"> static int ext4_convert_inline_data_to_extent(struct address_space *mapping,</span>
 		put_page(page);
 	}
 	if (sem_held)
<span class="p_del">-		up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+		ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	if (handle)
 		ext4_journal_stop(handle);
 	brelse(iloc.bh);
<span class="p_chunk">@@ -719,7 +718,7 @@</span> <span class="p_context"> int ext4_try_to_write_inline_data(struct address_space *mapping,</span>
 int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,
 			       unsigned copied, struct page *page)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, no_expand;</span>
 	void *kaddr;
 	struct ext4_iloc iloc;
 
<span class="p_chunk">@@ -737,7 +736,7 @@</span> <span class="p_context"> int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,</span>
 		goto out;
 	}
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
 	BUG_ON(!ext4_has_inline_data(inode));
 
 	kaddr = kmap_atomic(page);
<span class="p_chunk">@@ -747,7 +746,7 @@</span> <span class="p_context"> int ext4_write_inline_data_end(struct inode *inode, loff_t pos, unsigned len,</span>
 	/* clear page dirty so that writepages wouldn&#39;t work for us. */
 	ClearPageDirty(page);
 
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	brelse(iloc.bh);
 out:
 	return copied;
<span class="p_chunk">@@ -758,7 +757,7 @@</span> <span class="p_context"> ext4_journalled_write_inline_data(struct inode *inode,</span>
 				  unsigned len,
 				  struct page *page)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, no_expand;</span>
 	void *kaddr;
 	struct ext4_iloc iloc;
 
<span class="p_chunk">@@ -768,11 +767,11 @@</span> <span class="p_context"> ext4_journalled_write_inline_data(struct inode *inode,</span>
 		return NULL;
 	}
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
 	kaddr = kmap_atomic(page);
 	ext4_write_inline_data(inode, &amp;iloc, kaddr, 0, len);
 	kunmap_atomic(kaddr);
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 
 	return iloc.bh;
 }
<span class="p_chunk">@@ -934,8 +933,15 @@</span> <span class="p_context"> int ext4_da_write_inline_data_end(struct inode *inode, loff_t pos,</span>
 				  struct page *page)
 {
 	int i_size_changed = 0;
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	copied = ext4_write_inline_data_end(inode, pos, len, copied, page);</span>
<span class="p_add">+	ret = ext4_write_inline_data_end(inode, pos, len, copied, page);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		unlock_page(page);</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	copied = ret;</span>
 
 	/*
 	 * No need to use i_size_read() here, the i_size
<span class="p_chunk">@@ -1249,7 +1255,7 @@</span> <span class="p_context"> static int ext4_convert_inline_data_nolock(handle_t *handle,</span>
 int ext4_try_add_inline_entry(handle_t *handle, struct ext4_filename *fname,
 			      struct inode *dir, struct inode *inode)
 {
<span class="p_del">-	int ret, inline_size;</span>
<span class="p_add">+	int ret, inline_size, no_expand;</span>
 	void *inline_start;
 	struct ext4_iloc iloc;
 
<span class="p_chunk">@@ -1257,7 +1263,7 @@</span> <span class="p_context"> int ext4_try_add_inline_entry(handle_t *handle, struct ext4_filename *fname,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	down_write(&amp;EXT4_I(dir)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(dir, &amp;no_expand);</span>
 	if (!ext4_has_inline_data(dir))
 		goto out;
 
<span class="p_chunk">@@ -1303,7 +1309,7 @@</span> <span class="p_context"> int ext4_try_add_inline_entry(handle_t *handle, struct ext4_filename *fname,</span>
 
 out:
 	ext4_mark_inode_dirty(handle, dir);
<span class="p_del">-	up_write(&amp;EXT4_I(dir)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(dir, &amp;no_expand);</span>
 	brelse(iloc.bh);
 	return ret;
 }
<span class="p_chunk">@@ -1663,7 +1669,7 @@</span> <span class="p_context"> int ext4_delete_inline_entry(handle_t *handle,</span>
 			     struct buffer_head *bh,
 			     int *has_inline_data)
 {
<span class="p_del">-	int err, inline_size;</span>
<span class="p_add">+	int err, inline_size, no_expand;</span>
 	struct ext4_iloc iloc;
 	void *inline_start;
 
<span class="p_chunk">@@ -1671,7 +1677,7 @@</span> <span class="p_context"> int ext4_delete_inline_entry(handle_t *handle,</span>
 	if (err)
 		return err;
 
<span class="p_del">-	down_write(&amp;EXT4_I(dir)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(dir, &amp;no_expand);</span>
 	if (!ext4_has_inline_data(dir)) {
 		*has_inline_data = 0;
 		goto out;
<span class="p_chunk">@@ -1705,7 +1711,7 @@</span> <span class="p_context"> int ext4_delete_inline_entry(handle_t *handle,</span>
 
 	ext4_show_inline_dir(dir, iloc.bh, inline_start, inline_size);
 out:
<span class="p_del">-	up_write(&amp;EXT4_I(dir)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(dir, &amp;no_expand);</span>
 	brelse(iloc.bh);
 	if (err != -ENOENT)
 		ext4_std_error(dir-&gt;i_sb, err);
<span class="p_chunk">@@ -1804,11 +1810,11 @@</span> <span class="p_context"> bool empty_inline_dir(struct inode *dir, int *has_inline_data)</span>
 
 int ext4_destroy_inline_data(handle_t *handle, struct inode *inode)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, no_expand;</span>
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
 	ret = ext4_destroy_inline_data_nolock(handle, inode);
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1893,7 +1899,7 @@</span> <span class="p_context"> int ext4_try_to_evict_inline_data(handle_t *handle,</span>
 void ext4_inline_data_truncate(struct inode *inode, int *has_inline)
 {
 	handle_t *handle;
<span class="p_del">-	int inline_size, value_len, needed_blocks;</span>
<span class="p_add">+	int inline_size, value_len, needed_blocks, no_expand;</span>
 	size_t i_size;
 	void *value = NULL;
 	struct ext4_xattr_ibody_find is = {
<span class="p_chunk">@@ -1910,7 +1916,7 @@</span> <span class="p_context"> void ext4_inline_data_truncate(struct inode *inode, int *has_inline)</span>
 	if (IS_ERR(handle))
 		return;
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
 	if (!ext4_has_inline_data(inode)) {
 		*has_inline = 0;
 		ext4_journal_stop(handle);
<span class="p_chunk">@@ -1968,7 +1974,7 @@</span> <span class="p_context"> void ext4_inline_data_truncate(struct inode *inode, int *has_inline)</span>
 	up_write(&amp;EXT4_I(inode)-&gt;i_data_sem);
 out:
 	brelse(is.iloc.bh);
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	kfree(value);
 	if (inode-&gt;i_nlink)
 		ext4_orphan_del(handle, inode);
<span class="p_chunk">@@ -1984,7 +1990,7 @@</span> <span class="p_context"> void ext4_inline_data_truncate(struct inode *inode, int *has_inline)</span>
 
 int ext4_convert_inline_data(struct inode *inode)
 {
<span class="p_del">-	int error, needed_blocks;</span>
<span class="p_add">+	int error, needed_blocks, no_expand;</span>
 	handle_t *handle;
 	struct ext4_iloc iloc;
 
<span class="p_chunk">@@ -2006,15 +2012,10 @@</span> <span class="p_context"> int ext4_convert_inline_data(struct inode *inode)</span>
 		goto out_free;
 	}
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_del">-	if (!ext4_has_inline_data(inode)) {</span>
<span class="p_del">-		up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	error = ext4_convert_inline_data_nolock(handle, inode, &amp;iloc);</span>
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_del">-out:</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
<span class="p_add">+	if (ext4_has_inline_data(inode))</span>
<span class="p_add">+		error = ext4_convert_inline_data_nolock(handle, inode, &amp;iloc);</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	ext4_journal_stop(handle);
 out_free:
 	brelse(iloc.bh);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 33a509c876ee..1d4f5faa04b5 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1324,8 +1324,11 @@</span> <span class="p_context"> static int ext4_write_end(struct file *file,</span>
 	if (ext4_has_inline_data(inode)) {
 		ret = ext4_write_inline_data_end(inode, pos, len,
 						 copied, page);
<span class="p_del">-		if (ret &lt; 0)</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			unlock_page(page);</span>
<span class="p_add">+			put_page(page);</span>
 			goto errout;
<span class="p_add">+		}</span>
 		copied = ret;
 	} else
 		copied = block_write_end(file, mapping, pos,
<span class="p_chunk">@@ -1379,7 +1382,9 @@</span> <span class="p_context"> static int ext4_write_end(struct file *file,</span>
  * set the buffer to be dirty, since in data=journalled mode we need
  * to call ext4_handle_dirty_metadata() instead.
  */
<span class="p_del">-static void zero_new_buffers(struct page *page, unsigned from, unsigned to)</span>
<span class="p_add">+static void ext4_journalled_zero_new_buffers(handle_t *handle,</span>
<span class="p_add">+					    struct page *page,</span>
<span class="p_add">+					    unsigned from, unsigned to)</span>
 {
 	unsigned int block_start = 0, block_end;
 	struct buffer_head *head, *bh;
<span class="p_chunk">@@ -1396,7 +1401,7 @@</span> <span class="p_context"> static void zero_new_buffers(struct page *page, unsigned from, unsigned to)</span>
 					size = min(to, block_end) - start;
 
 					zero_user(page, start, size);
<span class="p_del">-					set_buffer_uptodate(bh);</span>
<span class="p_add">+					write_end_fn(handle, bh);</span>
 				}
 				clear_buffer_new(bh);
 			}
<span class="p_chunk">@@ -1425,18 +1430,25 @@</span> <span class="p_context"> static int ext4_journalled_write_end(struct file *file,</span>
 
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_del">-	if (ext4_has_inline_data(inode))</span>
<span class="p_del">-		copied = ext4_write_inline_data_end(inode, pos, len,</span>
<span class="p_del">-						    copied, page);</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		if (copied &lt; len) {</span>
<span class="p_del">-			if (!PageUptodate(page))</span>
<span class="p_del">-				copied = 0;</span>
<span class="p_del">-			zero_new_buffers(page, from+copied, to);</span>
<span class="p_add">+	if (ext4_has_inline_data(inode)) {</span>
<span class="p_add">+		ret = ext4_write_inline_data_end(inode, pos, len,</span>
<span class="p_add">+						 copied, page);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			unlock_page(page);</span>
<span class="p_add">+			put_page(page);</span>
<span class="p_add">+			goto errout;</span>
 		}
<span class="p_del">-</span>
<span class="p_add">+		copied = ret;</span>
<span class="p_add">+	} else if (unlikely(copied &lt; len) &amp;&amp; !PageUptodate(page)) {</span>
<span class="p_add">+		copied = 0;</span>
<span class="p_add">+		ext4_journalled_zero_new_buffers(handle, page, from, to);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (unlikely(copied &lt; len))</span>
<span class="p_add">+			ext4_journalled_zero_new_buffers(handle, page,</span>
<span class="p_add">+							 from + copied, to);</span>
 		ret = ext4_walk_page_buffers(handle, page_buffers(page), from,
<span class="p_del">-					     to, &amp;partial, write_end_fn);</span>
<span class="p_add">+					     from + copied, &amp;partial,</span>
<span class="p_add">+					     write_end_fn);</span>
 		if (!partial)
 			SetPageUptodate(page);
 	}
<span class="p_chunk">@@ -1462,6 +1474,7 @@</span> <span class="p_context"> static int ext4_journalled_write_end(struct file *file,</span>
 		 */
 		ext4_orphan_add(handle, inode);
 
<span class="p_add">+errout:</span>
 	ret2 = ext4_journal_stop(handle);
 	if (!ret)
 		ret = ret2;
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 7ae43c59bc79..2e9fc7a61048 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -3123,6 +3123,13 @@</span> <span class="p_context"> ext4_mb_normalize_request(struct ext4_allocation_context *ac,</span>
 	if (ar-&gt;pright &amp;&amp; start + size - 1 &gt;= ar-&gt;lright)
 		size -= start + size - ar-&gt;lright;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Trim allocation request for filesystems with artificially small</span>
<span class="p_add">+	 * groups.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (size &gt; EXT4_BLOCKS_PER_GROUP(ac-&gt;ac_sb))</span>
<span class="p_add">+		size = EXT4_BLOCKS_PER_GROUP(ac-&gt;ac_sb);</span>
<span class="p_add">+</span>
 	end = start + size;
 
 	/* check we don&#39;t cross already preallocated blocks */
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index 104f8bfba718..c4a389a6027b 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1616,13 +1616,15 @@</span> <span class="p_context"> static struct dentry *ext4_lookup(struct inode *dir, struct dentry *dentry, unsi</span>
 		    !fscrypt_has_permitted_context(dir, inode)) {
 			int nokey = ext4_encrypted_inode(inode) &amp;&amp;
 				!fscrypt_has_encryption_key(inode);
<span class="p_del">-			iput(inode);</span>
<span class="p_del">-			if (nokey)</span>
<span class="p_add">+			if (nokey) {</span>
<span class="p_add">+				iput(inode);</span>
 				return ERR_PTR(-ENOKEY);
<span class="p_add">+			}</span>
 			ext4_warning(inode-&gt;i_sb,
 				     &quot;Inconsistent encryption contexts: %lu/%lu&quot;,
 				     (unsigned long) dir-&gt;i_ino,
 				     (unsigned long) inode-&gt;i_ino);
<span class="p_add">+			iput(inode);</span>
 			return ERR_PTR(-EPERM);
 		}
 	}
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index bbc316db9495..afe29ba42a4e 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -825,6 +825,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
 	struct ext4_super_block *es = sbi-&gt;s_es;
<span class="p_add">+	int aborted = 0;</span>
 	int i, err;
 
 	ext4_unregister_li_request(sb);
<span class="p_chunk">@@ -834,9 +835,10 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 	destroy_workqueue(sbi-&gt;rsv_conversion_wq);
 
 	if (sbi-&gt;s_journal) {
<span class="p_add">+		aborted = is_journal_aborted(sbi-&gt;s_journal);</span>
 		err = jbd2_journal_destroy(sbi-&gt;s_journal);
 		sbi-&gt;s_journal = NULL;
<span class="p_del">-		if (err &lt; 0)</span>
<span class="p_add">+		if ((err &lt; 0) &amp;&amp; !aborted)</span>
 			ext4_abort(sb, &quot;Couldn&#39;t clean up the journal&quot;);
 	}
 
<span class="p_chunk">@@ -847,7 +849,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 	ext4_mb_release(sb);
 	ext4_ext_release(sb);
 
<span class="p_del">-	if (!(sb-&gt;s_flags &amp; MS_RDONLY)) {</span>
<span class="p_add">+	if (!(sb-&gt;s_flags &amp; MS_RDONLY) &amp;&amp; !aborted) {</span>
 		ext4_clear_feature_journal_needs_recovery(sb);
 		es-&gt;s_state = cpu_to_le16(sbi-&gt;s_mount_state);
 	}
<span class="p_chunk">@@ -3911,7 +3913,8 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 	 * root first: it may be modified in the journal!
 	 */
 	if (!test_opt(sb, NOLOAD) &amp;&amp; ext4_has_feature_journal(sb)) {
<span class="p_del">-		if (ext4_load_journal(sb, es, journal_devnum))</span>
<span class="p_add">+		err = ext4_load_journal(sb, es, journal_devnum);</span>
<span class="p_add">+		if (err)</span>
 			goto failed_mount3a;
 	} else if (test_opt(sb, NOLOAD) &amp;&amp; !(sb-&gt;s_flags &amp; MS_RDONLY) &amp;&amp;
 		   ext4_has_feature_journal_needs_recovery(sb)) {
<span class="p_header">diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c</span>
<span class="p_header">index d77be9e9f535..4448ed37181b 100644</span>
<span class="p_header">--- a/fs/ext4/xattr.c</span>
<span class="p_header">+++ b/fs/ext4/xattr.c</span>
<span class="p_chunk">@@ -1174,16 +1174,14 @@</span> <span class="p_context"> ext4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,</span>
 	struct ext4_xattr_block_find bs = {
 		.s = { .not_found = -ENODATA, },
 	};
<span class="p_del">-	unsigned long no_expand;</span>
<span class="p_add">+	int no_expand;</span>
 	int error;
 
 	if (!name)
 		return -EINVAL;
 	if (strlen(name) &gt; 255)
 		return -ERANGE;
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_del">-	no_expand = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_del">-	ext4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_add">+	ext4_write_lock_xattr(inode, &amp;no_expand);</span>
 
 	error = ext4_reserve_inode_write(handle, inode, &amp;is.iloc);
 	if (error)
<span class="p_chunk">@@ -1251,7 +1249,7 @@</span> <span class="p_context"> ext4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,</span>
 		ext4_xattr_update_super_block(handle, inode-&gt;i_sb);
 		inode-&gt;i_ctime = ext4_current_time(inode);
 		if (!value)
<span class="p_del">-			ext4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_add">+			no_expand = 0;</span>
 		error = ext4_mark_iloc_dirty(handle, inode, &amp;is.iloc);
 		/*
 		 * The bh is consumed by ext4_mark_iloc_dirty, even with
<span class="p_chunk">@@ -1265,9 +1263,7 @@</span> <span class="p_context"> ext4_xattr_set_handle(handle_t *handle, struct inode *inode, int name_index,</span>
 cleanup:
 	brelse(is.iloc.bh);
 	brelse(bs.bh);
<span class="p_del">-	if (no_expand == 0)</span>
<span class="p_del">-		ext4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	return error;
 }
 
<span class="p_chunk">@@ -1484,12 +1480,11 @@</span> <span class="p_context"> int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,</span>
 	int error = 0, tried_min_extra_isize = 0;
 	int s_min_extra_isize = le16_to_cpu(EXT4_SB(inode-&gt;i_sb)-&gt;s_es-&gt;s_min_extra_isize);
 	int isize_diff;	/* How much do we need to grow i_extra_isize */
<span class="p_add">+	int no_expand;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ext4_write_trylock_xattr(inode, &amp;no_expand) == 0)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set EXT4_STATE_NO_EXPAND to avoid recursion when marking inode dirty</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ext4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
 retry:
 	isize_diff = new_extra_isize - EXT4_I(inode)-&gt;i_extra_isize;
 	if (EXT4_I(inode)-&gt;i_extra_isize &gt;= new_extra_isize)
<span class="p_chunk">@@ -1571,17 +1566,16 @@</span> <span class="p_context"> int ext4_expand_extra_isize_ea(struct inode *inode, int new_extra_isize,</span>
 	EXT4_I(inode)-&gt;i_extra_isize = new_extra_isize;
 	brelse(bh);
 out:
<span class="p_del">-	ext4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	return 0;
 
 cleanup:
 	brelse(bh);
 	/*
<span class="p_del">-	 * We deliberately leave EXT4_STATE_NO_EXPAND set here since inode</span>
<span class="p_del">-	 * size expansion failed.</span>
<span class="p_add">+	 * Inode size expansion failed; don&#39;t try again</span>
 	 */
<span class="p_del">-	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	no_expand = 1;</span>
<span class="p_add">+	ext4_write_unlock_xattr(inode, &amp;no_expand);</span>
 	return error;
 }
 
<span class="p_header">diff --git a/fs/ext4/xattr.h b/fs/ext4/xattr.h</span>
<span class="p_header">index a92e783fa057..099c8b670ef5 100644</span>
<span class="p_header">--- a/fs/ext4/xattr.h</span>
<span class="p_header">+++ b/fs/ext4/xattr.h</span>
<span class="p_chunk">@@ -102,6 +102,38 @@</span> <span class="p_context"> extern const struct xattr_handler ext4_xattr_security_handler;</span>
 
 #define EXT4_XATTR_NAME_ENCRYPTION_CONTEXT &quot;c&quot;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The EXT4_STATE_NO_EXPAND is overloaded and used for two purposes.</span>
<span class="p_add">+ * The first is to signal that there the inline xattrs and data are</span>
<span class="p_add">+ * taking up so much space that we might as well not keep trying to</span>
<span class="p_add">+ * expand it.  The second is that xattr_sem is taken for writing, so</span>
<span class="p_add">+ * we shouldn&#39;t try to recurse into the inode expansion.  For this</span>
<span class="p_add">+ * second case, we need to make sure that we take save and restore the</span>
<span class="p_add">+ * NO_EXPAND state flag appropriately.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void ext4_write_lock_xattr(struct inode *inode, int *save)</span>
<span class="p_add">+{</span>
<span class="p_add">+	down_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+	*save = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_add">+	ext4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int ext4_write_trylock_xattr(struct inode *inode, int *save)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (down_write_trylock(&amp;EXT4_I(inode)-&gt;xattr_sem) == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	*save = ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_add">+	ext4_set_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void ext4_write_unlock_xattr(struct inode *inode, int *save)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (*save == 0)</span>
<span class="p_add">+		ext4_clear_inode_state(inode, EXT4_STATE_NO_EXPAND);</span>
<span class="p_add">+	up_write(&amp;EXT4_I(inode)-&gt;xattr_sem);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern ssize_t ext4_listxattr(struct dentry *, char *, size_t);
 
 extern int ext4_xattr_get(struct inode *, int, const char *, void *, size_t);
<span class="p_header">diff --git a/fs/f2fs/dir.c b/fs/f2fs/dir.c</span>
<span class="p_header">index 369f4513be37..ebdc90fc71b7 100644</span>
<span class="p_header">--- a/fs/f2fs/dir.c</span>
<span class="p_header">+++ b/fs/f2fs/dir.c</span>
<span class="p_chunk">@@ -207,9 +207,13 @@</span> <span class="p_context"> static struct f2fs_dir_entry *find_in_level(struct inode *dir,</span>
 		f2fs_put_page(dentry_page, 0);
 	}
 
<span class="p_del">-	if (!de &amp;&amp; room &amp;&amp; F2FS_I(dir)-&gt;chash != namehash) {</span>
<span class="p_del">-		F2FS_I(dir)-&gt;chash = namehash;</span>
<span class="p_del">-		F2FS_I(dir)-&gt;clevel = level;</span>
<span class="p_add">+	/* This is to increase the speed of f2fs_create */</span>
<span class="p_add">+	if (!de &amp;&amp; room) {</span>
<span class="p_add">+		F2FS_I(dir)-&gt;task = current;</span>
<span class="p_add">+		if (F2FS_I(dir)-&gt;chash != namehash) {</span>
<span class="p_add">+			F2FS_I(dir)-&gt;chash = namehash;</span>
<span class="p_add">+			F2FS_I(dir)-&gt;clevel = level;</span>
<span class="p_add">+		}</span>
 	}
 
 	return de;
<span class="p_chunk">@@ -643,14 +647,34 @@</span> <span class="p_context"> int __f2fs_add_link(struct inode *dir, const struct qstr *name,</span>
 				struct inode *inode, nid_t ino, umode_t mode)
 {
 	struct fscrypt_name fname;
<span class="p_add">+	struct page *page = NULL;</span>
<span class="p_add">+	struct f2fs_dir_entry *de = NULL;</span>
 	int err;
 
 	err = fscrypt_setup_filename(dir, name, 0, &amp;fname);
 	if (err)
 		return err;
 
<span class="p_del">-	err = __f2fs_do_add_link(dir, &amp;fname, inode, ino, mode);</span>
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * An immature stakable filesystem shows a race condition between lookup</span>
<span class="p_add">+	 * and create. If we have same task when doing lookup and create, it&#39;s</span>
<span class="p_add">+	 * definitely fine as expected by VFS normally. Otherwise, let&#39;s just</span>
<span class="p_add">+	 * verify on-disk dentry one more time, which guarantees filesystem</span>
<span class="p_add">+	 * consistency more.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (current != F2FS_I(dir)-&gt;task) {</span>
<span class="p_add">+		de = __f2fs_find_entry(dir, &amp;fname, &amp;page);</span>
<span class="p_add">+		F2FS_I(dir)-&gt;task = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (de) {</span>
<span class="p_add">+		f2fs_dentry_kunmap(dir, page);</span>
<span class="p_add">+		f2fs_put_page(page, 0);</span>
<span class="p_add">+		err = -EEXIST;</span>
<span class="p_add">+	} else if (IS_ERR(page)) {</span>
<span class="p_add">+		err = PTR_ERR(page);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = __f2fs_do_add_link(dir, &amp;fname, inode, ino, mode);</span>
<span class="p_add">+	}</span>
 	fscrypt_free_filename(&amp;fname);
 	return err;
 }
<span class="p_header">diff --git a/fs/f2fs/extent_cache.c b/fs/f2fs/extent_cache.c</span>
<span class="p_header">index 2b06d4fcd954..7b32ce979fe1 100644</span>
<span class="p_header">--- a/fs/f2fs/extent_cache.c</span>
<span class="p_header">+++ b/fs/f2fs/extent_cache.c</span>
<span class="p_chunk">@@ -352,11 +352,12 @@</span> <span class="p_context"> static struct extent_node *__try_merge_extent_node(struct inode *inode,</span>
 	}
 
 	if (next_ex &amp;&amp; __is_front_mergeable(ei, &amp;next_ex-&gt;ei)) {
<span class="p_del">-		if (en)</span>
<span class="p_del">-			__release_extent_node(sbi, et, prev_ex);</span>
 		next_ex-&gt;ei.fofs = ei-&gt;fofs;
 		next_ex-&gt;ei.blk = ei-&gt;blk;
 		next_ex-&gt;ei.len += ei-&gt;len;
<span class="p_add">+		if (en)</span>
<span class="p_add">+			__release_extent_node(sbi, et, prev_ex);</span>
<span class="p_add">+</span>
 		en = next_ex;
 	}
 
<span class="p_header">diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h</span>
<span class="p_header">index 506af456412f..3a1640be7ffc 100644</span>
<span class="p_header">--- a/fs/f2fs/f2fs.h</span>
<span class="p_header">+++ b/fs/f2fs/f2fs.h</span>
<span class="p_chunk">@@ -431,6 +431,7 @@</span> <span class="p_context"> struct f2fs_inode_info {</span>
 	atomic_t dirty_pages;		/* # of dirty pages */
 	f2fs_hash_t chash;		/* hash value of given file name */
 	unsigned int clevel;		/* maximum level of given file name */
<span class="p_add">+	struct task_struct *task;	/* lookup and create consistency */</span>
 	nid_t i_xattr_nid;		/* node id that contains xattrs */
 	unsigned long long xattr_ver;	/* cp version of xattr modification */
 	loff_t	last_disk_size;		/* lastly written file size */
<span class="p_chunk">@@ -833,6 +834,9 @@</span> <span class="p_context"> struct f2fs_sb_info {</span>
 	struct f2fs_gc_kthread	*gc_thread;	/* GC thread */
 	unsigned int cur_victim_sec;		/* current victim section num */
 
<span class="p_add">+	/* threshold for converting bg victims for fg */</span>
<span class="p_add">+	u64 fggc_threshold;</span>
<span class="p_add">+</span>
 	/* maximum # of trials to find a victim segment for SSR and GC */
 	unsigned int max_victim_search;
 
<span class="p_header">diff --git a/fs/f2fs/gc.c b/fs/f2fs/gc.c</span>
<span class="p_header">index 6f14ee923acd..34a69e7ed90b 100644</span>
<span class="p_header">--- a/fs/f2fs/gc.c</span>
<span class="p_header">+++ b/fs/f2fs/gc.c</span>
<span class="p_chunk">@@ -166,7 +166,8 @@</span> <span class="p_context"> static void select_policy(struct f2fs_sb_info *sbi, int gc_type,</span>
 		p-&gt;ofs_unit = sbi-&gt;segs_per_sec;
 	}
 
<span class="p_del">-	if (p-&gt;max_search &gt; sbi-&gt;max_victim_search)</span>
<span class="p_add">+	/* we need to check every dirty segments in the FG_GC case */</span>
<span class="p_add">+	if (gc_type != FG_GC &amp;&amp; p-&gt;max_search &gt; sbi-&gt;max_victim_search)</span>
 		p-&gt;max_search = sbi-&gt;max_victim_search;
 
 	p-&gt;offset = sbi-&gt;last_victim[p-&gt;gc_mode];
<span class="p_chunk">@@ -199,6 +200,10 @@</span> <span class="p_context"> static unsigned int check_bg_victims(struct f2fs_sb_info *sbi)</span>
 	for_each_set_bit(secno, dirty_i-&gt;victim_secmap, MAIN_SECS(sbi)) {
 		if (sec_usage_check(sbi, secno))
 			continue;
<span class="p_add">+</span>
<span class="p_add">+		if (no_fggc_candidate(sbi, secno))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		clear_bit(secno, dirty_i-&gt;victim_secmap);
 		return secno * sbi-&gt;segs_per_sec;
 	}
<span class="p_chunk">@@ -322,13 +327,15 @@</span> <span class="p_context"> static int get_victim_by_default(struct f2fs_sb_info *sbi,</span>
 			nsearched++;
 		}
 
<span class="p_del">-</span>
 		secno = GET_SECNO(sbi, segno);
 
 		if (sec_usage_check(sbi, secno))
 			goto next;
 		if (gc_type == BG_GC &amp;&amp; test_bit(secno, dirty_i-&gt;victim_secmap))
 			goto next;
<span class="p_add">+		if (gc_type == FG_GC &amp;&amp; p.alloc_mode == LFS &amp;&amp;</span>
<span class="p_add">+					no_fggc_candidate(sbi, secno))</span>
<span class="p_add">+			goto next;</span>
 
 		cost = get_gc_cost(sbi, segno, &amp;p);
 
<span class="p_chunk">@@ -972,5 +979,16 @@</span> <span class="p_context"> int f2fs_gc(struct f2fs_sb_info *sbi, bool sync)</span>
 
 void build_gc_manager(struct f2fs_sb_info *sbi)
 {
<span class="p_add">+	u64 main_count, resv_count, ovp_count, blocks_per_sec;</span>
<span class="p_add">+</span>
 	DIRTY_I(sbi)-&gt;v_ops = &amp;default_v_ops;
<span class="p_add">+</span>
<span class="p_add">+	/* threshold of # of valid blocks in a section for victims of FG_GC */</span>
<span class="p_add">+	main_count = SM_I(sbi)-&gt;main_segments &lt;&lt; sbi-&gt;log_blocks_per_seg;</span>
<span class="p_add">+	resv_count = SM_I(sbi)-&gt;reserved_segments &lt;&lt; sbi-&gt;log_blocks_per_seg;</span>
<span class="p_add">+	ovp_count = SM_I(sbi)-&gt;ovp_segments &lt;&lt; sbi-&gt;log_blocks_per_seg;</span>
<span class="p_add">+	blocks_per_sec = sbi-&gt;blocks_per_seg * sbi-&gt;segs_per_sec;</span>
<span class="p_add">+</span>
<span class="p_add">+	sbi-&gt;fggc_threshold = div_u64((main_count - ovp_count) * blocks_per_sec,</span>
<span class="p_add">+					(main_count - resv_count));</span>
 }
<span class="p_header">diff --git a/fs/f2fs/segment.c b/fs/f2fs/segment.c</span>
<span class="p_header">index fc886f008449..a7943f861d68 100644</span>
<span class="p_header">--- a/fs/f2fs/segment.c</span>
<span class="p_header">+++ b/fs/f2fs/segment.c</span>
<span class="p_chunk">@@ -813,6 +813,8 @@</span> <span class="p_context"> void clear_prefree_segments(struct f2fs_sb_info *sbi, struct cp_control *cpc)</span>
 		start = start_segno + sbi-&gt;segs_per_sec;
 		if (start &lt; end)
 			goto next;
<span class="p_add">+		else</span>
<span class="p_add">+			end = start - 1;</span>
 	}
 	mutex_unlock(&amp;dirty_i-&gt;seglist_lock);
 
<span class="p_header">diff --git a/fs/f2fs/segment.h b/fs/f2fs/segment.h</span>
<span class="p_header">index fecb856ad874..b164f8339281 100644</span>
<span class="p_header">--- a/fs/f2fs/segment.h</span>
<span class="p_header">+++ b/fs/f2fs/segment.h</span>
<span class="p_chunk">@@ -688,6 +688,15 @@</span> <span class="p_context"> static inline block_t sum_blk_addr(struct f2fs_sb_info *sbi, int base, int type)</span>
 				- (base + 1) + type;
 }
 
<span class="p_add">+static inline bool no_fggc_candidate(struct f2fs_sb_info *sbi,</span>
<span class="p_add">+						unsigned int secno)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (get_valid_blocks(sbi, secno, sbi-&gt;segs_per_sec) &gt;=</span>
<span class="p_add">+						sbi-&gt;fggc_threshold)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool sec_usage_check(struct f2fs_sb_info *sbi, unsigned int secno)
 {
 	if (IS_CURSEC(sbi, secno) || (sbi-&gt;cur_victim_sec == secno))
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index 2401c5dabb2a..5ec5870e423a 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -100,6 +100,7 @@</span> <span class="p_context"> static void fuse_file_put(struct fuse_file *ff, bool sync)</span>
 			iput(req-&gt;misc.release.inode);
 			fuse_put_request(ff-&gt;fc, req);
 		} else if (sync) {
<span class="p_add">+			__set_bit(FR_FORCE, &amp;req-&gt;flags);</span>
 			__clear_bit(FR_BACKGROUND, &amp;req-&gt;flags);
 			fuse_request_send(ff-&gt;fc, req);
 			iput(req-&gt;misc.release.inode);
<span class="p_header">diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c</span>
<span class="p_header">index 14cbf60167a7..133f322573b5 100644</span>
<span class="p_header">--- a/fs/gfs2/glock.c</span>
<span class="p_header">+++ b/fs/gfs2/glock.c</span>
<span class="p_chunk">@@ -658,9 +658,11 @@</span> <span class="p_context"> int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,</span>
 	struct kmem_cache *cachep;
 	int ret, tries = 0;
 
<span class="p_add">+	rcu_read_lock();</span>
 	gl = rhashtable_lookup_fast(&amp;gl_hash_table, &amp;name, ht_parms);
 	if (gl &amp;&amp; !lockref_get_not_dead(&amp;gl-&gt;gl_lockref))
 		gl = NULL;
<span class="p_add">+	rcu_read_unlock();</span>
 
 	*glp = gl;
 	if (gl)
<span class="p_chunk">@@ -728,15 +730,18 @@</span> <span class="p_context"> int gfs2_glock_get(struct gfs2_sbd *sdp, u64 number,</span>
 
 	if (ret == -EEXIST) {
 		ret = 0;
<span class="p_add">+		rcu_read_lock();</span>
 		tmp = rhashtable_lookup_fast(&amp;gl_hash_table, &amp;name, ht_parms);
 		if (tmp == NULL || !lockref_get_not_dead(&amp;tmp-&gt;gl_lockref)) {
 			if (++tries &lt; 100) {
<span class="p_add">+				rcu_read_unlock();</span>
 				cond_resched();
 				goto again;
 			}
 			tmp = NULL;
 			ret = -ENOMEM;
 		}
<span class="p_add">+		rcu_read_unlock();</span>
 	} else {
 		WARN_ON_ONCE(ret);
 	}
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index e1652665bd93..5e659ee08d6a 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -1863,7 +1863,9 @@</span> <span class="p_context"> static void __jbd2_journal_temp_unlink_buffer(struct journal_head *jh)</span>
 
 	__blist_del_buffer(list, jh);
 	jh-&gt;b_jlist = BJ_None;
<span class="p_del">-	if (test_clear_buffer_jbddirty(bh))</span>
<span class="p_add">+	if (transaction &amp;&amp; is_journal_aborted(transaction-&gt;t_journal))</span>
<span class="p_add">+		clear_buffer_jbddirty(bh);</span>
<span class="p_add">+	else if (test_clear_buffer_jbddirty(bh))</span>
 		mark_buffer_dirty(bh);	/* Expose it to the VM */
 }
 
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">index a5c38889e7ae..13abd608af0f 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_chunk">@@ -1073,9 +1073,6 @@</span> <span class="p_context"> static int ff_layout_async_handle_error_v4(struct rpc_task *task,</span>
 	struct nfs_client *mds_client = mds_server-&gt;nfs_client;
 	struct nfs4_slot_table *tbl = &amp;clp-&gt;cl_session-&gt;fc_slot_table;
 
<span class="p_del">-	if (task-&gt;tk_status &gt;= 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	switch (task-&gt;tk_status) {
 	/* MDS state errors */
 	case -NFS4ERR_DELEG_REVOKED:
<span class="p_chunk">@@ -1176,9 +1173,6 @@</span> <span class="p_context"> static int ff_layout_async_handle_error_v3(struct rpc_task *task,</span>
 {
 	struct nfs4_deviceid_node *devid = FF_LAYOUT_DEVID_NODE(lseg, idx);
 
<span class="p_del">-	if (task-&gt;tk_status &gt;= 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	switch (task-&gt;tk_status) {
 	/* File access problems. Don&#39;t mark the device as unavailable */
 	case -EACCES:
<span class="p_chunk">@@ -1213,6 +1207,13 @@</span> <span class="p_context"> static int ff_layout_async_handle_error(struct rpc_task *task,</span>
 {
 	int vers = clp-&gt;cl_nfs_mod-&gt;rpc_vers-&gt;number;
 
<span class="p_add">+	if (task-&gt;tk_status &gt;= 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Handle the case of an invalid layout segment */</span>
<span class="p_add">+	if (!pnfs_is_valid_lseg(lseg))</span>
<span class="p_add">+		return -NFS4ERR_RESET_TO_PNFS;</span>
<span class="p_add">+</span>
 	switch (vers) {
 	case 3:
 		return ff_layout_async_handle_error_v3(task, lseg, idx);
<span class="p_header">diff --git a/fs/nfs/nfs42proc.c b/fs/nfs/nfs42proc.c</span>
<span class="p_header">index 608501971fe0..5cda392028ce 100644</span>
<span class="p_header">--- a/fs/nfs/nfs42proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs42proc.c</span>
<span class="p_chunk">@@ -128,30 +128,26 @@</span> <span class="p_context"> int nfs42_proc_deallocate(struct file *filep, loff_t offset, loff_t len)</span>
 	return err;
 }
 
<span class="p_del">-static ssize_t _nfs42_proc_copy(struct file *src, loff_t pos_src,</span>
<span class="p_add">+static ssize_t _nfs42_proc_copy(struct file *src,</span>
 				struct nfs_lock_context *src_lock,
<span class="p_del">-				struct file *dst, loff_t pos_dst,</span>
<span class="p_add">+				struct file *dst,</span>
 				struct nfs_lock_context *dst_lock,
<span class="p_del">-				size_t count)</span>
<span class="p_add">+				struct nfs42_copy_args *args,</span>
<span class="p_add">+				struct nfs42_copy_res *res)</span>
 {
<span class="p_del">-	struct nfs42_copy_args args = {</span>
<span class="p_del">-		.src_fh		= NFS_FH(file_inode(src)),</span>
<span class="p_del">-		.src_pos	= pos_src,</span>
<span class="p_del">-		.dst_fh		= NFS_FH(file_inode(dst)),</span>
<span class="p_del">-		.dst_pos	= pos_dst,</span>
<span class="p_del">-		.count		= count,</span>
<span class="p_del">-	};</span>
<span class="p_del">-	struct nfs42_copy_res res;</span>
 	struct rpc_message msg = {
 		.rpc_proc = &amp;nfs4_procedures[NFSPROC4_CLNT_COPY],
<span class="p_del">-		.rpc_argp = &amp;args,</span>
<span class="p_del">-		.rpc_resp = &amp;res,</span>
<span class="p_add">+		.rpc_argp = args,</span>
<span class="p_add">+		.rpc_resp = res,</span>
 	};
 	struct inode *dst_inode = file_inode(dst);
 	struct nfs_server *server = NFS_SERVER(dst_inode);
<span class="p_add">+	loff_t pos_src = args-&gt;src_pos;</span>
<span class="p_add">+	loff_t pos_dst = args-&gt;dst_pos;</span>
<span class="p_add">+	size_t count = args-&gt;count;</span>
 	int status;
 
<span class="p_del">-	status = nfs4_set_rw_stateid(&amp;args.src_stateid, src_lock-&gt;open_context,</span>
<span class="p_add">+	status = nfs4_set_rw_stateid(&amp;args-&gt;src_stateid, src_lock-&gt;open_context,</span>
 				     src_lock, FMODE_READ);
 	if (status)
 		return status;
<span class="p_chunk">@@ -161,7 +157,7 @@</span> <span class="p_context"> static ssize_t _nfs42_proc_copy(struct file *src, loff_t pos_src,</span>
 	if (status)
 		return status;
 
<span class="p_del">-	status = nfs4_set_rw_stateid(&amp;args.dst_stateid, dst_lock-&gt;open_context,</span>
<span class="p_add">+	status = nfs4_set_rw_stateid(&amp;args-&gt;dst_stateid, dst_lock-&gt;open_context,</span>
 				     dst_lock, FMODE_WRITE);
 	if (status)
 		return status;
<span class="p_chunk">@@ -171,22 +167,22 @@</span> <span class="p_context"> static ssize_t _nfs42_proc_copy(struct file *src, loff_t pos_src,</span>
 		return status;
 
 	status = nfs4_call_sync(server-&gt;client, server, &amp;msg,
<span class="p_del">-				&amp;args.seq_args, &amp;res.seq_res, 0);</span>
<span class="p_add">+				&amp;args-&gt;seq_args, &amp;res-&gt;seq_res, 0);</span>
 	if (status == -ENOTSUPP)
 		server-&gt;caps &amp;= ~NFS_CAP_COPY;
 	if (status)
 		return status;
 
<span class="p_del">-	if (res.write_res.verifier.committed != NFS_FILE_SYNC) {</span>
<span class="p_del">-		status = nfs_commit_file(dst, &amp;res.write_res.verifier.verifier);</span>
<span class="p_add">+	if (res-&gt;write_res.verifier.committed != NFS_FILE_SYNC) {</span>
<span class="p_add">+		status = nfs_commit_file(dst, &amp;res-&gt;write_res.verifier.verifier);</span>
 		if (status)
 			return status;
 	}
 
 	truncate_pagecache_range(dst_inode, pos_dst,
<span class="p_del">-				 pos_dst + res.write_res.count);</span>
<span class="p_add">+				 pos_dst + res-&gt;write_res.count);</span>
 
<span class="p_del">-	return res.write_res.count;</span>
<span class="p_add">+	return res-&gt;write_res.count;</span>
 }
 
 ssize_t nfs42_proc_copy(struct file *src, loff_t pos_src,
<span class="p_chunk">@@ -196,8 +192,22 @@</span> <span class="p_context"> ssize_t nfs42_proc_copy(struct file *src, loff_t pos_src,</span>
 	struct nfs_server *server = NFS_SERVER(file_inode(dst));
 	struct nfs_lock_context *src_lock;
 	struct nfs_lock_context *dst_lock;
<span class="p_del">-	struct nfs4_exception src_exception = { };</span>
<span class="p_del">-	struct nfs4_exception dst_exception = { };</span>
<span class="p_add">+	struct nfs42_copy_args args = {</span>
<span class="p_add">+		.src_fh		= NFS_FH(file_inode(src)),</span>
<span class="p_add">+		.src_pos	= pos_src,</span>
<span class="p_add">+		.dst_fh		= NFS_FH(file_inode(dst)),</span>
<span class="p_add">+		.dst_pos	= pos_dst,</span>
<span class="p_add">+		.count		= count,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	struct nfs42_copy_res res;</span>
<span class="p_add">+	struct nfs4_exception src_exception = {</span>
<span class="p_add">+		.inode		= file_inode(src),</span>
<span class="p_add">+		.stateid	= &amp;args.src_stateid,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	struct nfs4_exception dst_exception = {</span>
<span class="p_add">+		.inode		= file_inode(dst),</span>
<span class="p_add">+		.stateid	= &amp;args.dst_stateid,</span>
<span class="p_add">+	};</span>
 	ssize_t err, err2;
 
 	if (!nfs_server_capable(file_inode(dst), NFS_CAP_COPY))
<span class="p_chunk">@@ -207,7 +217,6 @@</span> <span class="p_context"> ssize_t nfs42_proc_copy(struct file *src, loff_t pos_src,</span>
 	if (IS_ERR(src_lock))
 		return PTR_ERR(src_lock);
 
<span class="p_del">-	src_exception.inode = file_inode(src);</span>
 	src_exception.state = src_lock-&gt;open_context-&gt;state;
 
 	dst_lock = nfs_get_lock_context(nfs_file_open_context(dst));
<span class="p_chunk">@@ -216,15 +225,17 @@</span> <span class="p_context"> ssize_t nfs42_proc_copy(struct file *src, loff_t pos_src,</span>
 		goto out_put_src_lock;
 	}
 
<span class="p_del">-	dst_exception.inode = file_inode(dst);</span>
 	dst_exception.state = dst_lock-&gt;open_context-&gt;state;
 
 	do {
 		inode_lock(file_inode(dst));
<span class="p_del">-		err = _nfs42_proc_copy(src, pos_src, src_lock,</span>
<span class="p_del">-				       dst, pos_dst, dst_lock, count);</span>
<span class="p_add">+		err = _nfs42_proc_copy(src, src_lock,</span>
<span class="p_add">+				dst, dst_lock,</span>
<span class="p_add">+				&amp;args, &amp;res);</span>
 		inode_unlock(file_inode(dst));
 
<span class="p_add">+		if (err &gt;= 0)</span>
<span class="p_add">+			break;</span>
 		if (err == -ENOTSUPP) {
 			err = -EOPNOTSUPP;
 			break;
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 78ff8b63d5f7..609840de31d3 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -2708,6 +2708,7 @@</span> <span class="p_context"> static int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,</span>
 	ret = PTR_ERR(state);
 	if (IS_ERR(state))
 		goto out;
<span class="p_add">+	ctx-&gt;state = state;</span>
 	if (server-&gt;caps &amp; NFS_CAP_POSIX_LOCK)
 		set_bit(NFS_STATE_POSIX_LOCKS, &amp;state-&gt;flags);
 	if (opendata-&gt;o_res.rflags &amp; NFS4_OPEN_RESULT_MAY_NOTIFY_LOCK)
<span class="p_chunk">@@ -2733,7 +2734,6 @@</span> <span class="p_context"> static int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,</span>
 	if (ret != 0)
 		goto out;
 
<span class="p_del">-	ctx-&gt;state = state;</span>
 	if (d_inode(dentry) == state-&gt;inode) {
 		nfs_inode_attach_open_context(ctx);
 		if (read_seqcount_retry(&amp;sp-&gt;so_reclaim_seqcount, seq))
<span class="p_chunk">@@ -4990,7 +4990,7 @@</span> <span class="p_context"> static void nfs4_write_cached_acl(struct inode *inode, struct page **pages, size</span>
  */
 static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)
 {
<span class="p_del">-	struct page *pages[NFS4ACL_MAXPAGES] = {NULL, };</span>
<span class="p_add">+	struct page *pages[NFS4ACL_MAXPAGES + 1] = {NULL, };</span>
 	struct nfs_getaclargs args = {
 		.fh = NFS_FH(inode),
 		.acl_pages = pages,
<span class="p_chunk">@@ -5004,13 +5004,9 @@</span> <span class="p_context"> static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t bu</span>
 		.rpc_argp = &amp;args,
 		.rpc_resp = &amp;res,
 	};
<span class="p_del">-	unsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);</span>
<span class="p_add">+	unsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE) + 1;</span>
 	int ret = -ENOMEM, i;
 
<span class="p_del">-	/* As long as we&#39;re doing a round trip to the server anyway,</span>
<span class="p_del">-	 * let&#39;s be prepared for a page of acl data. */</span>
<span class="p_del">-	if (npages == 0)</span>
<span class="p_del">-		npages = 1;</span>
 	if (npages &gt; ARRAY_SIZE(pages))
 		return -ERANGE;
 
<span class="p_header">diff --git a/fs/nfs/nfs4xdr.c b/fs/nfs/nfs4xdr.c</span>
<span class="p_header">index fc89e5ed07ee..c9c4d9855976 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4xdr.c</span>
<span class="p_chunk">@@ -2492,7 +2492,7 @@</span> <span class="p_context"> static void nfs4_xdr_enc_getacl(struct rpc_rqst *req, struct xdr_stream *xdr,</span>
 	encode_compound_hdr(xdr, req, &amp;hdr);
 	encode_sequence(xdr, &amp;args-&gt;seq_args, &amp;hdr);
 	encode_putfh(xdr, args-&gt;fh, &amp;hdr);
<span class="p_del">-	replen = hdr.replen + op_decode_hdr_maxsz + 1;</span>
<span class="p_add">+	replen = hdr.replen + op_decode_hdr_maxsz;</span>
 	encode_getattr_two(xdr, FATTR4_WORD0_ACL, 0, &amp;hdr);
 
 	xdr_inline_pages(&amp;req-&gt;rq_rcv_buf, replen &lt;&lt; 2,
<span class="p_header">diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c</span>
<span class="p_header">index 8ca642fe9b21..b829cc9a9b39 100644</span>
<span class="p_header">--- a/fs/nfsd/vfs.c</span>
<span class="p_header">+++ b/fs/nfsd/vfs.c</span>
<span class="p_chunk">@@ -377,7 +377,7 @@</span> <span class="p_context"> nfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,</span>
 	__be32		err;
 	int		host_err;
 	bool		get_write_count;
<span class="p_del">-	int		size_change = 0;</span>
<span class="p_add">+	bool		size_change = (iap-&gt;ia_valid &amp; ATTR_SIZE);</span>
 
 	if (iap-&gt;ia_valid &amp; (ATTR_ATIME | ATTR_MTIME | ATTR_SIZE))
 		accmode |= NFSD_MAY_WRITE|NFSD_MAY_OWNER_OVERRIDE;
<span class="p_chunk">@@ -390,11 +390,11 @@</span> <span class="p_context"> nfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,</span>
 	/* Get inode */
 	err = fh_verify(rqstp, fhp, ftype, accmode);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return err;</span>
 	if (get_write_count) {
 		host_err = fh_want_write(fhp);
 		if (host_err)
<span class="p_del">-			return nfserrno(host_err);</span>
<span class="p_add">+			goto out;</span>
 	}
 
 	dentry = fhp-&gt;fh_dentry;
<span class="p_chunk">@@ -405,20 +405,28 @@</span> <span class="p_context"> nfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,</span>
 		iap-&gt;ia_valid &amp;= ~ATTR_MODE;
 
 	if (!iap-&gt;ia_valid)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return 0;</span>
 
 	nfsd_sanitize_attrs(inode, iap);
 
<span class="p_add">+	if (check_guard &amp;&amp; guardtime != inode-&gt;i_ctime.tv_sec)</span>
<span class="p_add">+		return nfserr_notsync;</span>
<span class="p_add">+</span>
 	/*
 	 * The size case is special, it changes the file in addition to the
<span class="p_del">-	 * attributes.</span>
<span class="p_add">+	 * attributes, and file systems don&#39;t expect it to be mixed with</span>
<span class="p_add">+	 * &quot;random&quot; attribute changes.  We thus split out the size change</span>
<span class="p_add">+	 * into a separate call to -&gt;setattr, and do the rest as a separate</span>
<span class="p_add">+	 * setattr call.</span>
 	 */
<span class="p_del">-	if (iap-&gt;ia_valid &amp; ATTR_SIZE) {</span>
<span class="p_add">+	if (size_change) {</span>
 		err = nfsd_get_write_access(rqstp, fhp, iap);
 		if (err)
<span class="p_del">-			goto out;</span>
<span class="p_del">-		size_change = 1;</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	fh_lock(fhp);</span>
<span class="p_add">+	if (size_change) {</span>
 		/*
 		 * RFC5661, Section 18.30.4:
 		 *   Changing the size of a file with SETATTR indirectly
<span class="p_chunk">@@ -426,29 +434,36 @@</span> <span class="p_context"> nfsd_setattr(struct svc_rqst *rqstp, struct svc_fh *fhp, struct iattr *iap,</span>
 		 *
 		 * (and similar for the older RFCs)
 		 */
<span class="p_del">-		if (iap-&gt;ia_size != i_size_read(inode))</span>
<span class="p_del">-			iap-&gt;ia_valid |= ATTR_MTIME;</span>
<span class="p_del">-	}</span>
<span class="p_add">+		struct iattr size_attr = {</span>
<span class="p_add">+			.ia_valid	= ATTR_SIZE | ATTR_CTIME | ATTR_MTIME,</span>
<span class="p_add">+			.ia_size	= iap-&gt;ia_size,</span>
<span class="p_add">+		};</span>
 
<span class="p_del">-	iap-&gt;ia_valid |= ATTR_CTIME;</span>
<span class="p_add">+		host_err = notify_change(dentry, &amp;size_attr, NULL);</span>
<span class="p_add">+		if (host_err)</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		iap-&gt;ia_valid &amp;= ~ATTR_SIZE;</span>
 
<span class="p_del">-	if (check_guard &amp;&amp; guardtime != inode-&gt;i_ctime.tv_sec) {</span>
<span class="p_del">-		err = nfserr_notsync;</span>
<span class="p_del">-		goto out_put_write_access;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Avoid the additional setattr call below if the only other</span>
<span class="p_add">+		 * attribute that the client sends is the mtime, as we update</span>
<span class="p_add">+		 * it as part of the size change above.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((iap-&gt;ia_valid &amp; ~ATTR_MTIME) == 0)</span>
<span class="p_add">+			goto out_unlock;</span>
 	}
 
<span class="p_del">-	fh_lock(fhp);</span>
<span class="p_add">+	iap-&gt;ia_valid |= ATTR_CTIME;</span>
 	host_err = notify_change(dentry, iap, NULL);
<span class="p_del">-	fh_unlock(fhp);</span>
<span class="p_del">-	err = nfserrno(host_err);</span>
 
<span class="p_del">-out_put_write_access:</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	fh_unlock(fhp);</span>
 	if (size_change)
 		put_write_access(inode);
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		err = nfserrno(commit_metadata(fhp));</span>
 out:
<span class="p_del">-	return err;</span>
<span class="p_add">+	if (!host_err)</span>
<span class="p_add">+		host_err = commit_metadata(fhp);</span>
<span class="p_add">+	return nfserrno(host_err);</span>
 }
 
 #if defined(CONFIG_NFSD_V4)
<span class="p_header">diff --git a/include/linux/compat.h b/include/linux/compat.h</span>
<span class="p_header">index 63609398ef9f..d8535a430caf 100644</span>
<span class="p_header">--- a/include/linux/compat.h</span>
<span class="p_header">+++ b/include/linux/compat.h</span>
<span class="p_chunk">@@ -711,8 +711,10 @@</span> <span class="p_context"> int __compat_save_altstack(compat_stack_t __user *, unsigned long);</span>
 	compat_stack_t __user *__uss = uss; \
 	struct task_struct *t = current; \
 	put_user_ex(ptr_to_compat((void __user *)t-&gt;sas_ss_sp), &amp;__uss-&gt;ss_sp); \
<span class="p_del">-	put_user_ex(sas_ss_flags(sp), &amp;__uss-&gt;ss_flags); \</span>
<span class="p_add">+	put_user_ex(t-&gt;sas_ss_flags, &amp;__uss-&gt;ss_flags); \</span>
 	put_user_ex(t-&gt;sas_ss_size, &amp;__uss-&gt;ss_size); \
<span class="p_add">+	if (t-&gt;sas_ss_flags &amp; SS_AUTODISARM) \</span>
<span class="p_add">+		sas_ss_reset(t); \</span>
 } while (0);
 
 asmlinkage long compat_sys_sched_rr_get_interval(compat_pid_t pid,
<span class="p_header">diff --git a/include/linux/devfreq.h b/include/linux/devfreq.h</span>
<span class="p_header">index 2de4e2eea180..e0acb0e5243b 100644</span>
<span class="p_header">--- a/include/linux/devfreq.h</span>
<span class="p_header">+++ b/include/linux/devfreq.h</span>
<span class="p_chunk">@@ -104,6 +104,8 @@</span> <span class="p_context"> struct devfreq_dev_profile {</span>
  * struct devfreq_governor - Devfreq policy governor
  * @node:		list node - contains registered devfreq governors
  * @name:		Governor&#39;s name
<span class="p_add">+ * @immutable:		Immutable flag for governor. If the value is 1,</span>
<span class="p_add">+ *			this govenror is never changeable to other governor.</span>
  * @get_target_freq:	Returns desired operating frequency for the device.
  *			Basically, get_target_freq will run
  *			devfreq_dev_profile.get_dev_status() to get the
<span class="p_chunk">@@ -121,6 +123,7 @@</span> <span class="p_context"> struct devfreq_governor {</span>
 	struct list_head node;
 
 	const char name[DEVFREQ_NAME_LEN];
<span class="p_add">+	const unsigned int immutable;</span>
 	int (*get_target_freq)(struct devfreq *this, unsigned long *freq);
 	int (*event_handler)(struct devfreq *devfreq,
 				unsigned int event, void *data);
<span class="p_header">diff --git a/include/linux/fsl_ifc.h b/include/linux/fsl_ifc.h</span>
<span class="p_header">index 3f9778cbc79d..c332f0a45607 100644</span>
<span class="p_header">--- a/include/linux/fsl_ifc.h</span>
<span class="p_header">+++ b/include/linux/fsl_ifc.h</span>
<span class="p_chunk">@@ -733,8 +733,12 @@</span> <span class="p_context"> struct fsl_ifc_nand {</span>
 	__be32 nand_erattr1;
 	u32 res19[0x10];
 	__be32 nand_fsr;
<span class="p_del">-	u32 res20[0x3];</span>
<span class="p_del">-	__be32 nand_eccstat[6];</span>
<span class="p_add">+	u32 res20;</span>
<span class="p_add">+	/* The V1 nand_eccstat is actually 4 words that overlaps the</span>
<span class="p_add">+	 * V2 nand_eccstat.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__be32 v1_nand_eccstat[2];</span>
<span class="p_add">+	__be32 v2_nand_eccstat[6];</span>
 	u32 res21[0x1c];
 	__be32 nanndcr;
 	u32 res22[0x2];
<span class="p_header">diff --git a/include/linux/hyperv.h b/include/linux/hyperv.h</span>
<span class="p_header">index c92a083bcf16..192eef2fd766 100644</span>
<span class="p_header">--- a/include/linux/hyperv.h</span>
<span class="p_header">+++ b/include/linux/hyperv.h</span>
<span class="p_chunk">@@ -641,6 +641,7 @@</span> <span class="p_context"> struct vmbus_channel_msginfo {</span>
 
 	/* Synchronize the request/response if needed */
 	struct completion  waitevent;
<span class="p_add">+	struct vmbus_channel *waiting_channel;</span>
 	union {
 		struct vmbus_channel_version_supported version_supported;
 		struct vmbus_channel_open_result open_result;
<span class="p_header">diff --git a/include/linux/intel-iommu.h b/include/linux/intel-iommu.h</span>
<span class="p_header">index d49e26c6cdc7..23e129ef6726 100644</span>
<span class="p_header">--- a/include/linux/intel-iommu.h</span>
<span class="p_header">+++ b/include/linux/intel-iommu.h</span>
<span class="p_chunk">@@ -153,8 +153,8 @@</span> <span class="p_context"> static inline void dmar_writeq(void __iomem *addr, u64 val)</span>
 #define DMA_TLB_GLOBAL_FLUSH (((u64)1) &lt;&lt; 60)
 #define DMA_TLB_DSI_FLUSH (((u64)2) &lt;&lt; 60)
 #define DMA_TLB_PSI_FLUSH (((u64)3) &lt;&lt; 60)
<span class="p_del">-#define DMA_TLB_IIRG(type) ((type &gt;&gt; 60) &amp; 7)</span>
<span class="p_del">-#define DMA_TLB_IAIG(val) (((val) &gt;&gt; 57) &amp; 7)</span>
<span class="p_add">+#define DMA_TLB_IIRG(type) ((type &gt;&gt; 60) &amp; 3)</span>
<span class="p_add">+#define DMA_TLB_IAIG(val) (((val) &gt;&gt; 57) &amp; 3)</span>
 #define DMA_TLB_READ_DRAIN (((u64)1) &lt;&lt; 49)
 #define DMA_TLB_WRITE_DRAIN (((u64)1) &lt;&lt; 48)
 #define DMA_TLB_DID(id)	(((u64)((id) &amp; 0xffff)) &lt;&lt; 32)
<span class="p_chunk">@@ -164,9 +164,9 @@</span> <span class="p_context"> static inline void dmar_writeq(void __iomem *addr, u64 val)</span>
 
 /* INVALID_DESC */
 #define DMA_CCMD_INVL_GRANU_OFFSET  61
<span class="p_del">-#define DMA_ID_TLB_GLOBAL_FLUSH	(((u64)1) &lt;&lt; 3)</span>
<span class="p_del">-#define DMA_ID_TLB_DSI_FLUSH	(((u64)2) &lt;&lt; 3)</span>
<span class="p_del">-#define DMA_ID_TLB_PSI_FLUSH	(((u64)3) &lt;&lt; 3)</span>
<span class="p_add">+#define DMA_ID_TLB_GLOBAL_FLUSH	(((u64)1) &lt;&lt; 4)</span>
<span class="p_add">+#define DMA_ID_TLB_DSI_FLUSH	(((u64)2) &lt;&lt; 4)</span>
<span class="p_add">+#define DMA_ID_TLB_PSI_FLUSH	(((u64)3) &lt;&lt; 4)</span>
 #define DMA_ID_TLB_READ_DRAIN	(((u64)1) &lt;&lt; 7)
 #define DMA_ID_TLB_WRITE_DRAIN	(((u64)1) &lt;&lt; 6)
 #define DMA_ID_TLB_DID(id)	(((u64)((id &amp; 0xffff) &lt;&lt; 16)))
<span class="p_chunk">@@ -316,8 +316,8 @@</span> <span class="p_context"> enum {</span>
 #define QI_DEV_EIOTLB_SIZE	(((u64)1) &lt;&lt; 11)
 #define QI_DEV_EIOTLB_GLOB(g)	((u64)g)
 #define QI_DEV_EIOTLB_PASID(p)	(((u64)p) &lt;&lt; 32)
<span class="p_del">-#define QI_DEV_EIOTLB_SID(sid)	((u64)((sid) &amp; 0xffff) &lt;&lt; 32)</span>
<span class="p_del">-#define QI_DEV_EIOTLB_QDEP(qd)	(((qd) &amp; 0x1f) &lt;&lt; 16)</span>
<span class="p_add">+#define QI_DEV_EIOTLB_SID(sid)	((u64)((sid) &amp; 0xffff) &lt;&lt; 16)</span>
<span class="p_add">+#define QI_DEV_EIOTLB_QDEP(qd)	((u64)((qd) &amp; 0x1f) &lt;&lt; 4)</span>
 #define QI_DEV_EIOTLB_MAX_INVS	32
 
 #define QI_PGRP_IDX(idx)	(((u64)(idx)) &lt;&lt; 55)
<span class="p_header">diff --git a/include/linux/mmzone.h b/include/linux/mmzone.h</span>
<span class="p_header">index f99c993dd500..7e273e243a13 100644</span>
<span class="p_header">--- a/include/linux/mmzone.h</span>
<span class="p_header">+++ b/include/linux/mmzone.h</span>
<span class="p_chunk">@@ -779,7 +779,7 @@</span> <span class="p_context"> static inline struct pglist_data *lruvec_pgdat(struct lruvec *lruvec)</span>
 #endif
 }
 
<span class="p_del">-extern unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru);</span>
<span class="p_add">+extern unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx);</span>
 
 #ifdef CONFIG_HAVE_MEMORY_PRESENT
 void memory_present(int nid, unsigned long start, unsigned long end);
<span class="p_header">diff --git a/include/rdma/ib_sa.h b/include/rdma/ib_sa.h</span>
<span class="p_header">index 5ee7aab95eb8..fd0e53219f93 100644</span>
<span class="p_header">--- a/include/rdma/ib_sa.h</span>
<span class="p_header">+++ b/include/rdma/ib_sa.h</span>
<span class="p_chunk">@@ -153,12 +153,12 @@</span> <span class="p_context"> struct ib_sa_path_rec {</span>
 	union ib_gid sgid;
 	__be16       dlid;
 	__be16       slid;
<span class="p_del">-	int          raw_traffic;</span>
<span class="p_add">+	u8           raw_traffic;</span>
 	/* reserved */
 	__be32       flow_label;
 	u8           hop_limit;
 	u8           traffic_class;
<span class="p_del">-	int          reversible;</span>
<span class="p_add">+	u8           reversible;</span>
 	u8           numb_path;
 	__be16       pkey;
 	__be16       qos_class;
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> struct ib_sa_mcmember_rec {</span>
 	u8           hop_limit;
 	u8           scope;
 	u8           join_state;
<span class="p_del">-	int          proxy_join;</span>
<span class="p_add">+	u8           proxy_join;</span>
 };
 
 /* Service Record Component Mask Sec 15.2.5.14 Ver 1.1	*/
<span class="p_header">diff --git a/include/scsi/scsi_device.h b/include/scsi/scsi_device.h</span>
<span class="p_header">index 8a9563144890..b9ec4939b80c 100644</span>
<span class="p_header">--- a/include/scsi/scsi_device.h</span>
<span class="p_header">+++ b/include/scsi/scsi_device.h</span>
<span class="p_chunk">@@ -315,6 +315,7 @@</span> <span class="p_context"> extern void scsi_remove_device(struct scsi_device *);</span>
 extern int scsi_unregister_device_handler(struct scsi_device_handler *scsi_dh);
 void scsi_attach_vpd(struct scsi_device *sdev);
 
<span class="p_add">+extern struct scsi_device *scsi_device_from_queue(struct request_queue *q);</span>
 extern int scsi_device_get(struct scsi_device *);
 extern void scsi_device_put(struct scsi_device *);
 extern struct scsi_device *scsi_device_lookup(struct Scsi_Host *,
<span class="p_header">diff --git a/include/soc/at91/at91sam9_ddrsdr.h b/include/soc/at91/at91sam9_ddrsdr.h</span>
<span class="p_header">index dc10c52e0e91..393362bdb860 100644</span>
<span class="p_header">--- a/include/soc/at91/at91sam9_ddrsdr.h</span>
<span class="p_header">+++ b/include/soc/at91/at91sam9_ddrsdr.h</span>
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"></span>
 #define			AT91_DDRSDRC_LPCB_POWER_DOWN		2
 #define			AT91_DDRSDRC_LPCB_DEEP_POWER_DOWN	3
 #define		AT91_DDRSDRC_CLKFR	(1 &lt;&lt; 2)	/* Clock Frozen */
<span class="p_add">+#define		AT91_DDRSDRC_LPDDR2_PWOFF	(1 &lt;&lt; 3)	/* LPDDR Power Off */</span>
 #define		AT91_DDRSDRC_PASR	(7 &lt;&lt; 4)	/* Partial Array Self Refresh */
 #define		AT91_DDRSDRC_TCSR	(3 &lt;&lt; 8)	/* Temperature Compensated Self Refresh */
 #define		AT91_DDRSDRC_DS		(3 &lt;&lt; 10)	/* Drive Strength */
<span class="p_chunk">@@ -96,7 +97,9 @@</span> <span class="p_context"></span>
 #define			AT91_DDRSDRC_MD_SDR		0
 #define			AT91_DDRSDRC_MD_LOW_POWER_SDR	1
 #define			AT91_DDRSDRC_MD_LOW_POWER_DDR	3
<span class="p_add">+#define			AT91_DDRSDRC_MD_LPDDR3		5</span>
 #define			AT91_DDRSDRC_MD_DDR2		6	/* [SAM9 Only] */
<span class="p_add">+#define			AT91_DDRSDRC_MD_LPDDR2		7</span>
 #define		AT91_DDRSDRC_DBW	(1 &lt;&lt; 4)		/* Data Bus Width */
 #define			AT91_DDRSDRC_DBW_32BITS		(0 &lt;&lt;  4)
 #define			AT91_DDRSDRC_DBW_16BITS		(1 &lt;&lt;  4)
<span class="p_header">diff --git a/ipc/shm.c b/ipc/shm.c</span>
<span class="p_header">index dbac8860c721..e2072ae4f90e 100644</span>
<span class="p_header">--- a/ipc/shm.c</span>
<span class="p_header">+++ b/ipc/shm.c</span>
<span class="p_chunk">@@ -1085,8 +1085,8 @@</span> <span class="p_context"> SYSCALL_DEFINE3(shmctl, int, shmid, int, cmd, struct shmid_ds __user *, buf)</span>
  * &quot;raddr&quot; thing points to kernel space, and there has to be a wrapper around
  * this.
  */
<span class="p_del">-long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,</span>
<span class="p_del">-	      unsigned long shmlba)</span>
<span class="p_add">+long do_shmat(int shmid, char __user *shmaddr, int shmflg,</span>
<span class="p_add">+	      ulong *raddr, unsigned long shmlba)</span>
 {
 	struct shmid_kernel *shp;
 	unsigned long addr;
<span class="p_chunk">@@ -1107,8 +1107,13 @@</span> <span class="p_context"> long do_shmat(int shmid, char __user *shmaddr, int shmflg, ulong *raddr,</span>
 		goto out;
 	else if ((addr = (ulong)shmaddr)) {
 		if (addr &amp; (shmlba - 1)) {
<span class="p_del">-			if (shmflg &amp; SHM_RND)</span>
<span class="p_del">-				addr &amp;= ~(shmlba - 1);	   /* round down */</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Round down to the nearest multiple of shmlba.</span>
<span class="p_add">+			 * For sane do_mmap_pgoff() parameters, avoid</span>
<span class="p_add">+			 * round downs that trigger nil-page and MAP_FIXED.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if ((shmflg &amp; SHM_RND) &amp;&amp; addr &gt;= shmlba)</span>
<span class="p_add">+				addr &amp;= ~(shmlba - 1);</span>
 			else
 #ifndef __ARCH_FORCE_SHMLBA
 				if (addr &amp; ~PAGE_MASK)
<span class="p_header">diff --git a/kernel/membarrier.c b/kernel/membarrier.c</span>
<span class="p_header">index 536c727a56e9..9f9284f37f8d 100644</span>
<span class="p_header">--- a/kernel/membarrier.c</span>
<span class="p_header">+++ b/kernel/membarrier.c</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/syscalls.h&gt;
 #include &lt;linux/membarrier.h&gt;
<span class="p_add">+#include &lt;linux/tick.h&gt;</span>
 
 /*
  * Bitmask made from a &quot;or&quot; of all commands within enum membarrier_cmd,
<span class="p_chunk">@@ -51,6 +52,9 @@</span> <span class="p_context"></span>
  */
 SYSCALL_DEFINE2(membarrier, int, cmd, int, flags)
 {
<span class="p_add">+	/* MEMBARRIER_CMD_SHARED is not compatible with nohz_full. */</span>
<span class="p_add">+	if (tick_nohz_full_enabled())</span>
<span class="p_add">+		return -ENOSYS;</span>
 	if (unlikely(flags))
 		return -EINVAL;
 	switch (cmd) {
<span class="p_header">diff --git a/kernel/memremap.c b/kernel/memremap.c</span>
<span class="p_header">index 9ecedc28b928..06123234f118 100644</span>
<span class="p_header">--- a/kernel/memremap.c</span>
<span class="p_header">+++ b/kernel/memremap.c</span>
<span class="p_chunk">@@ -246,9 +246,13 @@</span> <span class="p_context"> static void devm_memremap_pages_release(struct device *dev, void *data)</span>
 	/* pages are dead and unused, undo the arch mapping */
 	align_start = res-&gt;start &amp; ~(SECTION_SIZE - 1);
 	align_size = ALIGN(resource_size(res), SECTION_SIZE);
<span class="p_add">+</span>
<span class="p_add">+	lock_device_hotplug();</span>
 	mem_hotplug_begin();
 	arch_remove_memory(align_start, align_size);
 	mem_hotplug_done();
<span class="p_add">+	unlock_device_hotplug();</span>
<span class="p_add">+</span>
 	untrack_pfn(NULL, PHYS_PFN(align_start), align_size);
 	pgmap_radix_release(res);
 	dev_WARN_ONCE(dev, pgmap-&gt;altmap &amp;&amp; pgmap-&gt;altmap-&gt;alloc,
<span class="p_chunk">@@ -360,9 +364,11 @@</span> <span class="p_context"> void *devm_memremap_pages(struct device *dev, struct resource *res,</span>
 	if (error)
 		goto err_pfn_remap;
 
<span class="p_add">+	lock_device_hotplug();</span>
 	mem_hotplug_begin();
 	error = arch_add_memory(nid, align_start, align_size, true);
 	mem_hotplug_done();
<span class="p_add">+	unlock_device_hotplug();</span>
 	if (error)
 		goto err_add_memory;
 
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index 75761acc77cf..0b1415720a15 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -3226,10 +3226,17 @@</span> <span class="p_context"> int compat_restore_altstack(const compat_stack_t __user *uss)</span>
 
 int __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)
 {
<span class="p_add">+	int err;</span>
 	struct task_struct *t = current;
<span class="p_del">-	return  __put_user(ptr_to_compat((void __user *)t-&gt;sas_ss_sp), &amp;uss-&gt;ss_sp) |</span>
<span class="p_del">-		__put_user(sas_ss_flags(sp), &amp;uss-&gt;ss_flags) |</span>
<span class="p_add">+	err = __put_user(ptr_to_compat((void __user *)t-&gt;sas_ss_sp),</span>
<span class="p_add">+			 &amp;uss-&gt;ss_sp) |</span>
<span class="p_add">+		__put_user(t-&gt;sas_ss_flags, &amp;uss-&gt;ss_flags) |</span>
 		__put_user(t-&gt;sas_ss_size, &amp;uss-&gt;ss_size);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	if (t-&gt;sas_ss_flags &amp; SS_AUTODISARM)</span>
<span class="p_add">+		sas_ss_reset(t);</span>
<span class="p_add">+	return 0;</span>
 }
 #endif
 
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index d8d7df82c69a..edfb90e3830c 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -910,9 +910,12 @@</span> <span class="p_context"> void page_endio(struct page *page, bool is_write, int err)</span>
 		unlock_page(page);
 	} else {
 		if (err) {
<span class="p_add">+			struct address_space *mapping;</span>
<span class="p_add">+</span>
 			SetPageError(page);
<span class="p_del">-			if (page-&gt;mapping)</span>
<span class="p_del">-				mapping_set_error(page-&gt;mapping, err);</span>
<span class="p_add">+			mapping = page_mapping(page);</span>
<span class="p_add">+			if (mapping)</span>
<span class="p_add">+				mapping_set_error(mapping, err);</span>
 		}
 		end_page_writeback(page);
 	}
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index f4a02e240fb6..1460e6ad5e14 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -2858,7 +2858,7 @@</span> <span class="p_context"> bool zone_watermark_ok_safe(struct zone *z, unsigned int order,</span>
 #ifdef CONFIG_NUMA
 static bool zone_allows_reclaim(struct zone *local_zone, struct zone *zone)
 {
<span class="p_del">-	return node_distance(zone_to_nid(local_zone), zone_to_nid(zone)) &lt;</span>
<span class="p_add">+	return node_distance(zone_to_nid(local_zone), zone_to_nid(zone)) &lt;=</span>
 				RECLAIM_DISTANCE;
 }
 #else	/* CONFIG_NUMA */
<span class="p_header">diff --git a/mm/vmpressure.c b/mm/vmpressure.c</span>
<span class="p_header">index 149fdf6c5c56..6063581f705c 100644</span>
<span class="p_header">--- a/mm/vmpressure.c</span>
<span class="p_header">+++ b/mm/vmpressure.c</span>
<span class="p_chunk">@@ -112,9 +112,16 @@</span> <span class="p_context"> static enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,</span>
 						    unsigned long reclaimed)
 {
 	unsigned long scale = scanned + reclaimed;
<span class="p_del">-	unsigned long pressure;</span>
<span class="p_add">+	unsigned long pressure = 0;</span>
 
 	/*
<span class="p_add">+	 * reclaimed can be greater than scanned in cases</span>
<span class="p_add">+	 * like THP, where the scanned is 1 and reclaimed</span>
<span class="p_add">+	 * could be 512</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (reclaimed &gt;= scanned)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	/*</span>
 	 * We calculate the ratio (in percents) of how many pages were
 	 * scanned vs. reclaimed in a given time frame (window). Note that
 	 * time is in VM reclaimer&#39;s &quot;ticks&quot;, i.e. number of pages
<span class="p_chunk">@@ -124,6 +131,7 @@</span> <span class="p_context"> static enum vmpressure_levels vmpressure_calc_level(unsigned long scanned,</span>
 	pressure = scale - (reclaimed * scale / scanned);
 	pressure = pressure * 100 / scale;
 
<span class="p_add">+out:</span>
 	pr_debug(&quot;%s: %3lu  (s: %lu  r: %lu)\n&quot;, __func__, pressure,
 		 scanned, reclaimed);
 
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index fa30010a5277..30a88b945a44 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -234,22 +234,39 @@</span> <span class="p_context"> bool pgdat_reclaimable(struct pglist_data *pgdat)</span>
 		pgdat_reclaimable_pages(pgdat) * 6;
 }
 
<span class="p_del">-unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * lruvec_lru_size -  Returns the number of pages on the given LRU list.</span>
<span class="p_add">+ * @lruvec: lru vector</span>
<span class="p_add">+ * @lru: lru to use</span>
<span class="p_add">+ * @zone_idx: zones to consider (use MAX_NR_ZONES for the whole LRU list)</span>
<span class="p_add">+ */</span>
<span class="p_add">+unsigned long lruvec_lru_size(struct lruvec *lruvec, enum lru_list lru, int zone_idx)</span>
 {
<span class="p_add">+	unsigned long lru_size;</span>
<span class="p_add">+	int zid;</span>
<span class="p_add">+</span>
 	if (!mem_cgroup_disabled())
<span class="p_del">-		return mem_cgroup_get_lru_size(lruvec, lru);</span>
<span class="p_add">+		lru_size = mem_cgroup_get_lru_size(lruvec, lru);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		lru_size = node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);</span>
 
<span class="p_del">-	return node_page_state(lruvec_pgdat(lruvec), NR_LRU_BASE + lru);</span>
<span class="p_del">-}</span>
<span class="p_add">+	for (zid = zone_idx + 1; zid &lt; MAX_NR_ZONES; zid++) {</span>
<span class="p_add">+		struct zone *zone = &amp;lruvec_pgdat(lruvec)-&gt;node_zones[zid];</span>
<span class="p_add">+		unsigned long size;</span>
 
<span class="p_del">-unsigned long lruvec_zone_lru_size(struct lruvec *lruvec, enum lru_list lru,</span>
<span class="p_del">-				   int zone_idx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!mem_cgroup_disabled())</span>
<span class="p_del">-		return mem_cgroup_get_zone_lru_size(lruvec, lru, zone_idx);</span>
<span class="p_add">+		if (!managed_zone(zone))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!mem_cgroup_disabled())</span>
<span class="p_add">+			size = mem_cgroup_get_zone_lru_size(lruvec, lru, zid);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			size = zone_page_state(&amp;lruvec_pgdat(lruvec)-&gt;node_zones[zid],</span>
<span class="p_add">+				       NR_ZONE_LRU_BASE + lru);</span>
<span class="p_add">+		lru_size -= min(size, lru_size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return lru_size;</span>
 
<span class="p_del">-	return zone_page_state(&amp;lruvec_pgdat(lruvec)-&gt;node_zones[zone_idx],</span>
<span class="p_del">-			       NR_ZONE_LRU_BASE + lru);</span>
 }
 
 /*
<span class="p_chunk">@@ -2028,11 +2045,10 @@</span> <span class="p_context"> static bool inactive_list_is_low(struct lruvec *lruvec, bool file,</span>
 						struct scan_control *sc)
 {
 	unsigned long inactive_ratio;
<span class="p_del">-	unsigned long inactive;</span>
<span class="p_del">-	unsigned long active;</span>
<span class="p_add">+	unsigned long inactive, active;</span>
<span class="p_add">+	enum lru_list inactive_lru = file * LRU_FILE;</span>
<span class="p_add">+	enum lru_list active_lru = file * LRU_FILE + LRU_ACTIVE;</span>
 	unsigned long gb;
<span class="p_del">-	struct pglist_data *pgdat = lruvec_pgdat(lruvec);</span>
<span class="p_del">-	int zid;</span>
 
 	/*
 	 * If we don&#39;t have swap space, anonymous page deactivation
<span class="p_chunk">@@ -2041,27 +2057,8 @@</span> <span class="p_context"> static bool inactive_list_is_low(struct lruvec *lruvec, bool file,</span>
 	if (!file &amp;&amp; !total_swap_pages)
 		return false;
 
<span class="p_del">-	inactive = lruvec_lru_size(lruvec, file * LRU_FILE);</span>
<span class="p_del">-	active = lruvec_lru_size(lruvec, file * LRU_FILE + LRU_ACTIVE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * For zone-constrained allocations, it is necessary to check if</span>
<span class="p_del">-	 * deactivations are required for lowmem to be reclaimed. This</span>
<span class="p_del">-	 * calculates the inactive/active pages available in eligible zones.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (zid = sc-&gt;reclaim_idx + 1; zid &lt; MAX_NR_ZONES; zid++) {</span>
<span class="p_del">-		struct zone *zone = &amp;pgdat-&gt;node_zones[zid];</span>
<span class="p_del">-		unsigned long inactive_zone, active_zone;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!managed_zone(zone))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		inactive_zone = lruvec_zone_lru_size(lruvec, file * LRU_FILE, zid);</span>
<span class="p_del">-		active_zone = lruvec_zone_lru_size(lruvec, (file * LRU_FILE) + LRU_ACTIVE, zid);</span>
<span class="p_del">-</span>
<span class="p_del">-		inactive -= min(inactive, inactive_zone);</span>
<span class="p_del">-		active -= min(active, active_zone);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	inactive = lruvec_lru_size(lruvec, inactive_lru, sc-&gt;reclaim_idx);</span>
<span class="p_add">+	active = lruvec_lru_size(lruvec, active_lru, sc-&gt;reclaim_idx);</span>
 
 	gb = (inactive + active) &gt;&gt; (30 - PAGE_SHIFT);
 	if (gb)
<span class="p_chunk">@@ -2208,7 +2205,7 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, struct mem_cgroup *memcg,</span>
 	 * system is under heavy pressure.
 	 */
 	if (!inactive_list_is_low(lruvec, true, sc) &amp;&amp;
<span class="p_del">-	    lruvec_lru_size(lruvec, LRU_INACTIVE_FILE) &gt;&gt; sc-&gt;priority) {</span>
<span class="p_add">+	    lruvec_lru_size(lruvec, LRU_INACTIVE_FILE, sc-&gt;reclaim_idx) &gt;&gt; sc-&gt;priority) {</span>
 		scan_balance = SCAN_FILE;
 		goto out;
 	}
<span class="p_chunk">@@ -2234,10 +2231,10 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, struct mem_cgroup *memcg,</span>
 	 * anon in [0], file in [1]
 	 */
 
<span class="p_del">-	anon  = lruvec_lru_size(lruvec, LRU_ACTIVE_ANON) +</span>
<span class="p_del">-		lruvec_lru_size(lruvec, LRU_INACTIVE_ANON);</span>
<span class="p_del">-	file  = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE) +</span>
<span class="p_del">-		lruvec_lru_size(lruvec, LRU_INACTIVE_FILE);</span>
<span class="p_add">+	anon  = lruvec_lru_size(lruvec, LRU_ACTIVE_ANON, MAX_NR_ZONES) +</span>
<span class="p_add">+		lruvec_lru_size(lruvec, LRU_INACTIVE_ANON, MAX_NR_ZONES);</span>
<span class="p_add">+	file  = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES) +</span>
<span class="p_add">+		lruvec_lru_size(lruvec, LRU_INACTIVE_FILE, MAX_NR_ZONES);</span>
 
 	spin_lock_irq(&amp;pgdat-&gt;lru_lock);
 	if (unlikely(reclaim_stat-&gt;recent_scanned[0] &gt; anon / 4)) {
<span class="p_chunk">@@ -2275,7 +2272,7 @@</span> <span class="p_context"> static void get_scan_count(struct lruvec *lruvec, struct mem_cgroup *memcg,</span>
 			unsigned long size;
 			unsigned long scan;
 
<span class="p_del">-			size = lruvec_lru_size(lruvec, lru);</span>
<span class="p_add">+			size = lruvec_lru_size(lruvec, lru, sc-&gt;reclaim_idx);</span>
 			scan = size &gt;&gt; sc-&gt;priority;
 
 			if (!scan &amp;&amp; pass &amp;&amp; force_scan)
<span class="p_header">diff --git a/mm/workingset.c b/mm/workingset.c</span>
<span class="p_header">index fb1f9183d89a..33f6f4db32fd 100644</span>
<span class="p_header">--- a/mm/workingset.c</span>
<span class="p_header">+++ b/mm/workingset.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> bool workingset_refault(void *shadow)</span>
 	}
 	lruvec = mem_cgroup_lruvec(pgdat, memcg);
 	refault = atomic_long_read(&amp;lruvec-&gt;inactive_age);
<span class="p_del">-	active_file = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE);</span>
<span class="p_add">+	active_file = lruvec_lru_size(lruvec, LRU_ACTIVE_FILE, MAX_NR_ZONES);</span>
 	rcu_read_unlock();
 
 	/*
<span class="p_header">diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c</span>
<span class="p_header">index e6ae15bc41b7..0ffeb60cfe67 100644</span>
<span class="p_header">--- a/net/ceph/osd_client.c</span>
<span class="p_header">+++ b/net/ceph/osd_client.c</span>
<span class="p_chunk">@@ -672,7 +672,8 @@</span> <span class="p_context"> void osd_req_op_extent_update(struct ceph_osd_request *osd_req,</span>
 	BUG_ON(length &gt; previous);
 
 	op-&gt;extent.length = length;
<span class="p_del">-	op-&gt;indata_len -= previous - length;</span>
<span class="p_add">+	if (op-&gt;op == CEPH_OSD_OP_WRITE || op-&gt;op == CEPH_OSD_OP_WRITEFULL)</span>
<span class="p_add">+		op-&gt;indata_len -= previous - length;</span>
 }
 EXPORT_SYMBOL(osd_req_op_extent_update);
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 0f87e5d21be7..6bd150882ba4 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -85,11 +85,11 @@</span> <span class="p_context"> static __read_mostly DEFINE_SPINLOCK(nf_conntrack_locks_all_lock);</span>
 static __read_mostly bool nf_conntrack_locks_all;
 
 /* every gc cycle scans at most 1/GC_MAX_BUCKETS_DIV part of table */
<span class="p_del">-#define GC_MAX_BUCKETS_DIV	64u</span>
<span class="p_del">-/* upper bound of scan intervals */</span>
<span class="p_del">-#define GC_INTERVAL_MAX		(2 * HZ)</span>
<span class="p_del">-/* maximum conntracks to evict per gc run */</span>
<span class="p_del">-#define GC_MAX_EVICTS		256u</span>
<span class="p_add">+#define GC_MAX_BUCKETS_DIV	128u</span>
<span class="p_add">+/* upper bound of full table scan */</span>
<span class="p_add">+#define GC_MAX_SCAN_JIFFIES	(16u * HZ)</span>
<span class="p_add">+/* desired ratio of entries found to be expired */</span>
<span class="p_add">+#define GC_EVICT_RATIO	50u</span>
 
 static struct conntrack_gc_work conntrack_gc_work;
 
<span class="p_chunk">@@ -938,6 +938,7 @@</span> <span class="p_context"> static noinline int early_drop(struct net *net, unsigned int _hash)</span>
 
 static void gc_worker(struct work_struct *work)
 {
<span class="p_add">+	unsigned int min_interval = max(HZ / GC_MAX_BUCKETS_DIV, 1u);</span>
 	unsigned int i, goal, buckets = 0, expired_count = 0;
 	struct conntrack_gc_work *gc_work;
 	unsigned int ratio, scanned = 0;
<span class="p_chunk">@@ -979,8 +980,7 @@</span> <span class="p_context"> static void gc_worker(struct work_struct *work)</span>
 		 */
 		rcu_read_unlock();
 		cond_resched_rcu_qs();
<span class="p_del">-	} while (++buckets &lt; goal &amp;&amp;</span>
<span class="p_del">-		 expired_count &lt; GC_MAX_EVICTS);</span>
<span class="p_add">+	} while (++buckets &lt; goal);</span>
 
 	if (gc_work-&gt;exiting)
 		return;
<span class="p_chunk">@@ -997,27 +997,25 @@</span> <span class="p_context"> static void gc_worker(struct work_struct *work)</span>
 	 * 1. Minimize time until we notice a stale entry
 	 * 2. Maximize scan intervals to not waste cycles
 	 *
<span class="p_del">-	 * Normally, expired_count will be 0, this increases the next_run time</span>
<span class="p_del">-	 * to priorize 2) above.</span>
<span class="p_add">+	 * Normally, expire ratio will be close to 0.</span>
 	 *
<span class="p_del">-	 * As soon as a timed-out entry is found, move towards 1) and increase</span>
<span class="p_del">-	 * the scan frequency.</span>
<span class="p_del">-	 * In case we have lots of evictions next scan is done immediately.</span>
<span class="p_add">+	 * As soon as a sizeable fraction of the entries have expired</span>
<span class="p_add">+	 * increase scan frequency.</span>
 	 */
 	ratio = scanned ? expired_count * 100 / scanned : 0;
<span class="p_del">-	if (ratio &gt;= 90 || expired_count == GC_MAX_EVICTS) {</span>
<span class="p_del">-		gc_work-&gt;next_gc_run = 0;</span>
<span class="p_del">-		next_run = 0;</span>
<span class="p_del">-	} else if (expired_count) {</span>
<span class="p_del">-		gc_work-&gt;next_gc_run /= 2U;</span>
<span class="p_del">-		next_run = msecs_to_jiffies(1);</span>
<span class="p_add">+	if (ratio &gt; GC_EVICT_RATIO) {</span>
<span class="p_add">+		gc_work-&gt;next_gc_run = min_interval;</span>
 	} else {
<span class="p_del">-		if (gc_work-&gt;next_gc_run &lt; GC_INTERVAL_MAX)</span>
<span class="p_del">-			gc_work-&gt;next_gc_run += msecs_to_jiffies(1);</span>
<span class="p_add">+		unsigned int max = GC_MAX_SCAN_JIFFIES / GC_MAX_BUCKETS_DIV;</span>
 
<span class="p_del">-		next_run = gc_work-&gt;next_gc_run;</span>
<span class="p_add">+		BUILD_BUG_ON((GC_MAX_SCAN_JIFFIES / GC_MAX_BUCKETS_DIV) == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		gc_work-&gt;next_gc_run += min_interval;</span>
<span class="p_add">+		if (gc_work-&gt;next_gc_run &gt; max)</span>
<span class="p_add">+			gc_work-&gt;next_gc_run = max;</span>
 	}
 
<span class="p_add">+	next_run = gc_work-&gt;next_gc_run;</span>
 	gc_work-&gt;last_bucket = i;
 	queue_delayed_work(system_long_wq, &amp;gc_work-&gt;dwork, next_run);
 }
<span class="p_chunk">@@ -1025,7 +1023,7 @@</span> <span class="p_context"> static void gc_worker(struct work_struct *work)</span>
 static void conntrack_gc_work_init(struct conntrack_gc_work *gc_work)
 {
 	INIT_DELAYED_WORK(&amp;gc_work-&gt;dwork, gc_worker);
<span class="p_del">-	gc_work-&gt;next_gc_run = GC_INTERVAL_MAX;</span>
<span class="p_add">+	gc_work-&gt;next_gc_run = HZ;</span>
 	gc_work-&gt;exiting = false;
 }
 
<span class="p_chunk">@@ -1918,7 +1916,7 @@</span> <span class="p_context"> int nf_conntrack_init_start(void)</span>
 	nf_ct_untracked_status_or(IPS_CONFIRMED | IPS_UNTRACKED);
 
 	conntrack_gc_work_init(&amp;conntrack_gc_work);
<span class="p_del">-	queue_delayed_work(system_long_wq, &amp;conntrack_gc_work.dwork, GC_INTERVAL_MAX);</span>
<span class="p_add">+	queue_delayed_work(system_long_wq, &amp;conntrack_gc_work.dwork, HZ);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/rpc_rdma.c b/net/sunrpc/xprtrdma/rpc_rdma.c</span>
<span class="p_header">index d987c2d3dd6e..f57c9f0ab8f9 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/rpc_rdma.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/rpc_rdma.c</span>
<span class="p_chunk">@@ -125,14 +125,34 @@</span> <span class="p_context"> void rpcrdma_set_max_header_sizes(struct rpcrdma_xprt *r_xprt)</span>
 /* The client can send a request inline as long as the RPCRDMA header
  * plus the RPC call fit under the transport&#39;s inline limit. If the
  * combined call message size exceeds that limit, the client must use
<span class="p_del">- * the read chunk list for this operation.</span>
<span class="p_add">+ * a Read chunk for this operation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A Read chunk is also required if sending the RPC call inline would</span>
<span class="p_add">+ * exceed this device&#39;s max_sge limit.</span>
  */
 static bool rpcrdma_args_inline(struct rpcrdma_xprt *r_xprt,
 				struct rpc_rqst *rqst)
 {
<span class="p_del">-	struct rpcrdma_ia *ia = &amp;r_xprt-&gt;rx_ia;</span>
<span class="p_add">+	struct xdr_buf *xdr = &amp;rqst-&gt;rq_snd_buf;</span>
<span class="p_add">+	unsigned int count, remaining, offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xdr-&gt;len &gt; r_xprt-&gt;rx_ia.ri_max_inline_write)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xdr-&gt;page_len) {</span>
<span class="p_add">+		remaining = xdr-&gt;page_len;</span>
<span class="p_add">+		offset = xdr-&gt;page_base &amp; ~PAGE_MASK;</span>
<span class="p_add">+		count = 0;</span>
<span class="p_add">+		while (remaining) {</span>
<span class="p_add">+			remaining -= min_t(unsigned int,</span>
<span class="p_add">+					   PAGE_SIZE - offset, remaining);</span>
<span class="p_add">+			offset = 0;</span>
<span class="p_add">+			if (++count &gt; r_xprt-&gt;rx_ia.ri_max_send_sges)</span>
<span class="p_add">+				return false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	return rqst-&gt;rq_snd_buf.len &lt;= ia-&gt;ri_max_inline_write;</span>
<span class="p_add">+	return true;</span>
 }
 
 /* The client can&#39;t know how large the actual reply will be. Thus it
<span class="p_chunk">@@ -186,9 +206,9 @@</span> <span class="p_context"> rpcrdma_convert_kvec(struct kvec *vec, struct rpcrdma_mr_seg *seg, int n)</span>
  */
 
 static int
<span class="p_del">-rpcrdma_convert_iovs(struct xdr_buf *xdrbuf, unsigned int pos,</span>
<span class="p_del">-	enum rpcrdma_chunktype type, struct rpcrdma_mr_seg *seg,</span>
<span class="p_del">-	bool reminv_expected)</span>
<span class="p_add">+rpcrdma_convert_iovs(struct rpcrdma_xprt *r_xprt, struct xdr_buf *xdrbuf,</span>
<span class="p_add">+		     unsigned int pos, enum rpcrdma_chunktype type,</span>
<span class="p_add">+		     struct rpcrdma_mr_seg *seg)</span>
 {
 	int len, n, p, page_base;
 	struct page **ppages;
<span class="p_chunk">@@ -226,22 +246,21 @@</span> <span class="p_context"> rpcrdma_convert_iovs(struct xdr_buf *xdrbuf, unsigned int pos,</span>
 	if (len &amp;&amp; n == RPCRDMA_MAX_SEGS)
 		goto out_overflow;
 
<span class="p_del">-	/* When encoding the read list, the tail is always sent inline */</span>
<span class="p_del">-	if (type == rpcrdma_readch)</span>
<span class="p_add">+	/* When encoding a Read chunk, the tail iovec contains an</span>
<span class="p_add">+	 * XDR pad and may be omitted.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (type == rpcrdma_readch &amp;&amp; r_xprt-&gt;rx_ia.ri_implicit_roundup)</span>
 		return n;
 
<span class="p_del">-	/* When encoding the Write list, some servers need to see an extra</span>
<span class="p_del">-	 * segment for odd-length Write chunks. The upper layer provides</span>
<span class="p_del">-	 * space in the tail iovec for this purpose.</span>
<span class="p_add">+	/* When encoding a Write chunk, some servers need to see an</span>
<span class="p_add">+	 * extra segment for non-XDR-aligned Write chunks. The upper</span>
<span class="p_add">+	 * layer provides space in the tail iovec that may be used</span>
<span class="p_add">+	 * for this purpose.</span>
 	 */
<span class="p_del">-	if (type == rpcrdma_writech &amp;&amp; reminv_expected)</span>
<span class="p_add">+	if (type == rpcrdma_writech &amp;&amp; r_xprt-&gt;rx_ia.ri_implicit_roundup)</span>
 		return n;
 
 	if (xdrbuf-&gt;tail[0].iov_len) {
<span class="p_del">-		/* the rpcrdma protocol allows us to omit any trailing</span>
<span class="p_del">-		 * xdr pad bytes, saving the server an RDMA operation. */</span>
<span class="p_del">-		if (xdrbuf-&gt;tail[0].iov_len &lt; 4 &amp;&amp; xprt_rdma_pad_optimize)</span>
<span class="p_del">-			return n;</span>
 		n = rpcrdma_convert_kvec(&amp;xdrbuf-&gt;tail[0], seg, n);
 		if (n == RPCRDMA_MAX_SEGS)
 			goto out_overflow;
<span class="p_chunk">@@ -293,7 +312,8 @@</span> <span class="p_context"> rpcrdma_encode_read_list(struct rpcrdma_xprt *r_xprt,</span>
 	if (rtype == rpcrdma_areadch)
 		pos = 0;
 	seg = req-&gt;rl_segments;
<span class="p_del">-	nsegs = rpcrdma_convert_iovs(&amp;rqst-&gt;rq_snd_buf, pos, rtype, seg, false);</span>
<span class="p_add">+	nsegs = rpcrdma_convert_iovs(r_xprt, &amp;rqst-&gt;rq_snd_buf, pos,</span>
<span class="p_add">+				     rtype, seg);</span>
 	if (nsegs &lt; 0)
 		return ERR_PTR(nsegs);
 
<span class="p_chunk">@@ -355,10 +375,9 @@</span> <span class="p_context"> rpcrdma_encode_write_list(struct rpcrdma_xprt *r_xprt, struct rpcrdma_req *req,</span>
 	}
 
 	seg = req-&gt;rl_segments;
<span class="p_del">-	nsegs = rpcrdma_convert_iovs(&amp;rqst-&gt;rq_rcv_buf,</span>
<span class="p_add">+	nsegs = rpcrdma_convert_iovs(r_xprt, &amp;rqst-&gt;rq_rcv_buf,</span>
 				     rqst-&gt;rq_rcv_buf.head[0].iov_len,
<span class="p_del">-				     wtype, seg,</span>
<span class="p_del">-				     r_xprt-&gt;rx_ia.ri_reminv_expected);</span>
<span class="p_add">+				     wtype, seg);</span>
 	if (nsegs &lt; 0)
 		return ERR_PTR(nsegs);
 
<span class="p_chunk">@@ -423,8 +442,7 @@</span> <span class="p_context"> rpcrdma_encode_reply_chunk(struct rpcrdma_xprt *r_xprt,</span>
 	}
 
 	seg = req-&gt;rl_segments;
<span class="p_del">-	nsegs = rpcrdma_convert_iovs(&amp;rqst-&gt;rq_rcv_buf, 0, wtype, seg,</span>
<span class="p_del">-				     r_xprt-&gt;rx_ia.ri_reminv_expected);</span>
<span class="p_add">+	nsegs = rpcrdma_convert_iovs(r_xprt, &amp;rqst-&gt;rq_rcv_buf, 0, wtype, seg);</span>
 	if (nsegs &lt; 0)
 		return ERR_PTR(nsegs);
 
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/transport.c b/net/sunrpc/xprtrdma/transport.c</span>
<span class="p_header">index ed5e285fd2ea..fa324fe73946 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/transport.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/transport.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> unsigned int xprt_rdma_max_inline_read = RPCRDMA_DEF_INLINE;</span>
 static unsigned int xprt_rdma_max_inline_write = RPCRDMA_DEF_INLINE;
 static unsigned int xprt_rdma_inline_write_padding;
 static unsigned int xprt_rdma_memreg_strategy = RPCRDMA_FRMR;
<span class="p_del">-		int xprt_rdma_pad_optimize = 1;</span>
<span class="p_add">+		int xprt_rdma_pad_optimize = 0;</span>
 
 #if IS_ENABLED(CONFIG_SUNRPC_DEBUG)
 
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">index 8da7f6a4dfc3..e2c37061edbe 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_chunk">@@ -208,6 +208,7 @@</span> <span class="p_context"> rpcrdma_update_connect_private(struct rpcrdma_xprt *r_xprt,</span>
 
 	/* Default settings for RPC-over-RDMA Version One */
 	r_xprt-&gt;rx_ia.ri_reminv_expected = false;
<span class="p_add">+	r_xprt-&gt;rx_ia.ri_implicit_roundup = xprt_rdma_pad_optimize;</span>
 	rsize = RPCRDMA_V1_DEF_INLINE_SIZE;
 	wsize = RPCRDMA_V1_DEF_INLINE_SIZE;
 
<span class="p_chunk">@@ -215,6 +216,7 @@</span> <span class="p_context"> rpcrdma_update_connect_private(struct rpcrdma_xprt *r_xprt,</span>
 	    pmsg-&gt;cp_magic == rpcrdma_cmp_magic &amp;&amp;
 	    pmsg-&gt;cp_version == RPCRDMA_CMP_VERSION) {
 		r_xprt-&gt;rx_ia.ri_reminv_expected = true;
<span class="p_add">+		r_xprt-&gt;rx_ia.ri_implicit_roundup = true;</span>
 		rsize = rpcrdma_decode_buffer_size(pmsg-&gt;cp_send_size);
 		wsize = rpcrdma_decode_buffer_size(pmsg-&gt;cp_recv_size);
 	}
<span class="p_chunk">@@ -477,18 +479,19 @@</span> <span class="p_context"> rpcrdma_ia_close(struct rpcrdma_ia *ia)</span>
  */
 int
 rpcrdma_ep_create(struct rpcrdma_ep *ep, struct rpcrdma_ia *ia,
<span class="p_del">-				struct rpcrdma_create_data_internal *cdata)</span>
<span class="p_add">+		  struct rpcrdma_create_data_internal *cdata)</span>
 {
 	struct rpcrdma_connect_private *pmsg = &amp;ep-&gt;rep_cm_private;
<span class="p_add">+	unsigned int max_qp_wr, max_sge;</span>
 	struct ib_cq *sendcq, *recvcq;
<span class="p_del">-	unsigned int max_qp_wr;</span>
 	int rc;
 
<span class="p_del">-	if (ia-&gt;ri_device-&gt;attrs.max_sge &lt; RPCRDMA_MAX_SEND_SGES) {</span>
<span class="p_del">-		dprintk(&quot;RPC:       %s: insufficient sge&#39;s available\n&quot;,</span>
<span class="p_del">-			__func__);</span>
<span class="p_add">+	max_sge = min(ia-&gt;ri_device-&gt;attrs.max_sge, RPCRDMA_MAX_SEND_SGES);</span>
<span class="p_add">+	if (max_sge &lt; RPCRDMA_MIN_SEND_SGES) {</span>
<span class="p_add">+		pr_warn(&quot;rpcrdma: HCA provides only %d send SGEs\n&quot;, max_sge);</span>
 		return -ENOMEM;
 	}
<span class="p_add">+	ia-&gt;ri_max_send_sges = max_sge - RPCRDMA_MIN_SEND_SGES;</span>
 
 	if (ia-&gt;ri_device-&gt;attrs.max_qp_wr &lt;= RPCRDMA_BACKWARD_WRS) {
 		dprintk(&quot;RPC:       %s: insufficient wqe&#39;s available\n&quot;,
<span class="p_chunk">@@ -513,7 +516,7 @@</span> <span class="p_context"> rpcrdma_ep_create(struct rpcrdma_ep *ep, struct rpcrdma_ia *ia,</span>
 	ep-&gt;rep_attr.cap.max_recv_wr = cdata-&gt;max_requests;
 	ep-&gt;rep_attr.cap.max_recv_wr += RPCRDMA_BACKWARD_WRS;
 	ep-&gt;rep_attr.cap.max_recv_wr += 1;	/* drain cqe */
<span class="p_del">-	ep-&gt;rep_attr.cap.max_send_sge = RPCRDMA_MAX_SEND_SGES;</span>
<span class="p_add">+	ep-&gt;rep_attr.cap.max_send_sge = max_sge;</span>
 	ep-&gt;rep_attr.cap.max_recv_sge = 1;
 	ep-&gt;rep_attr.cap.max_inline_data = 0;
 	ep-&gt;rep_attr.sq_sig_type = IB_SIGNAL_REQ_WR;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/xprt_rdma.h b/net/sunrpc/xprtrdma/xprt_rdma.h</span>
<span class="p_header">index f6ae1b22da47..48989d5b2883 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/xprt_rdma.h</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/xprt_rdma.h</span>
<span class="p_chunk">@@ -74,7 +74,9 @@</span> <span class="p_context"> struct rpcrdma_ia {</span>
 	unsigned int		ri_max_frmr_depth;
 	unsigned int		ri_max_inline_write;
 	unsigned int		ri_max_inline_read;
<span class="p_add">+	unsigned int		ri_max_send_sges;</span>
 	bool			ri_reminv_expected;
<span class="p_add">+	bool			ri_implicit_roundup;</span>
 	struct ib_qp_attr	ri_qp_attr;
 	struct ib_qp_init_attr	ri_qp_init_attr;
 };
<span class="p_chunk">@@ -309,6 +311,7 @@</span> <span class="p_context"> struct rpcrdma_mr_seg {		/* chunk descriptors */</span>
  * - xdr_buf tail iovec
  */
 enum {
<span class="p_add">+	RPCRDMA_MIN_SEND_SGES = 3,</span>
 	RPCRDMA_MAX_SEND_PAGES = PAGE_SIZE + RPCRDMA_MAX_INLINE - 1,
 	RPCRDMA_MAX_PAGE_SGES = (RPCRDMA_MAX_SEND_PAGES &gt;&gt; PAGE_SHIFT) + 1,
 	RPCRDMA_MAX_SEND_SGES = 1 + 1 + RPCRDMA_MAX_PAGE_SGES + 1,
<span class="p_header">diff --git a/samples/seccomp/bpf-helper.h b/samples/seccomp/bpf-helper.h</span>
<span class="p_header">index 38ee70f3cd5b..1d8de9edd858 100644</span>
<span class="p_header">--- a/samples/seccomp/bpf-helper.h</span>
<span class="p_header">+++ b/samples/seccomp/bpf-helper.h</span>
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> union arg64 {</span>
 #define ARG_32(idx) \
 	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, LO_ARG(idx))
 
<span class="p_del">-/* Loads hi into A and lo in X */</span>
<span class="p_add">+/* Loads lo into M[0] and hi into M[1] and A */</span>
 #define ARG_64(idx) \
 	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, LO_ARG(idx)), \
 	BPF_STMT(BPF_ST, 0), /* lo -&gt; M[0] */ \
<span class="p_chunk">@@ -153,88 +153,107 @@</span> <span class="p_context"> union arg64 {</span>
 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (value), 1, 0), \
 	jt
 
<span class="p_del">-/* Checks the lo, then swaps to check the hi. A=lo,X=hi */</span>
<span class="p_add">+#define JA32(value, jt) \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, (value), 0, 1), \</span>
<span class="p_add">+	jt</span>
<span class="p_add">+</span>
<span class="p_add">+#define JGE32(value, jt) \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (value), 0, 1), \</span>
<span class="p_add">+	jt</span>
<span class="p_add">+</span>
<span class="p_add">+#define JGT32(value, jt) \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (value), 0, 1), \</span>
<span class="p_add">+	jt</span>
<span class="p_add">+</span>
<span class="p_add">+#define JLE32(value, jt) \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (value), 1, 0), \</span>
<span class="p_add">+	jt</span>
<span class="p_add">+</span>
<span class="p_add">+#define JLT32(value, jt) \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (value), 1, 0), \</span>
<span class="p_add">+	jt</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * All the JXX64 checks assume lo is saved in M[0] and hi is saved in both</span>
<span class="p_add">+ * A and M[1]. This invariant is kept by restoring A if necessary.</span>
<span class="p_add">+ */</span>
 #define JEQ64(lo, hi, jt) \
<span class="p_add">+	/* if (hi != arg.hi) goto NOMATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \
 	BPF_STMT(BPF_LD+BPF_MEM, 0), /* swap in lo */ \
<span class="p_add">+	/* if (lo != arg.lo) goto NOMATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (lo), 0, 2), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1), /* passed: swap hi back in */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1), \</span>
 	jt, \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1) /* failed: swap hi back in */</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1)</span>
 
 #define JNE64(lo, hi, jt) \
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 5, 0), \</span>
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 0), /* swap in lo */ \</span>
<span class="p_add">+	/* if (hi != arg.hi) goto MATCH; */ \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 3), \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 0), \</span>
<span class="p_add">+	/* if (lo != arg.lo) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (lo), 2, 0), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1), /* passed: swap hi back in */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1), \</span>
 	jt, \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1) /* failed: swap hi back in */</span>
<span class="p_del">-</span>
<span class="p_del">-#define JA32(value, jt) \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, (value), 0, 1), \</span>
<span class="p_del">-	jt</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1)</span>
 
 #define JA64(lo, hi, jt) \
<span class="p_add">+	/* if (hi &amp; arg.hi) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, (hi), 3, 0), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 0), /* swap in lo */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 0), \</span>
<span class="p_add">+	/* if (lo &amp; arg.lo) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, (lo), 0, 2), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1), /* passed: swap hi back in */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1), \</span>
 	jt, \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1) /* failed: swap hi back in */</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1)</span>
 
<span class="p_del">-#define JGE32(value, jt) \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (value), 0, 1), \</span>
<span class="p_del">-	jt</span>
<span class="p_del">-</span>
<span class="p_del">-#define JLT32(value, jt) \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (value), 1, 0), \</span>
<span class="p_del">-	jt</span>
<span class="p_del">-</span>
<span class="p_del">-/* Shortcut checking if hi &gt; arg.hi. */</span>
 #define JGE64(lo, hi, jt) \
<span class="p_add">+	/* if (hi &gt; arg.hi) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (hi), 4, 0), \
<span class="p_add">+	/* if (hi != arg.hi) goto NOMATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 0), /* swap in lo */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 0), \</span>
<span class="p_add">+	/* if (lo &gt;= arg.lo) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (lo), 0, 2), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1), /* passed: swap hi back in */ \</span>
<span class="p_del">-	jt, \</span>
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1) /* failed: swap hi back in */</span>
<span class="p_del">-</span>
<span class="p_del">-#define JLT64(lo, hi, jt) \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (hi), 0, 4), \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \</span>
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 0), /* swap in lo */ \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (lo), 2, 0), \</span>
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1), /* passed: swap hi back in */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1), \</span>
 	jt, \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1) /* failed: swap hi back in */</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1)</span>
 
<span class="p_del">-#define JGT32(value, jt) \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (value), 0, 1), \</span>
<span class="p_del">-	jt</span>
<span class="p_del">-</span>
<span class="p_del">-#define JLE32(value, jt) \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (value), 1, 0), \</span>
<span class="p_del">-	jt</span>
<span class="p_del">-</span>
<span class="p_del">-/* Check hi &gt; args.hi first, then do the GE checking */</span>
 #define JGT64(lo, hi, jt) \
<span class="p_add">+	/* if (hi &gt; arg.hi) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (hi), 4, 0), \
<span class="p_add">+	/* if (hi != arg.hi) goto NOMATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 0), /* swap in lo */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 0), \</span>
<span class="p_add">+	/* if (lo &gt; arg.lo) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (lo), 0, 2), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1), /* passed: swap hi back in */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1), \</span>
 	jt, \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1) /* failed: swap hi back in */</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1)</span>
 
 #define JLE64(lo, hi, jt) \
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (hi), 6, 0), \</span>
<span class="p_del">-	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 3), \</span>
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 0), /* swap in lo */ \</span>
<span class="p_add">+	/* if (hi &lt; arg.hi) goto MATCH; */ \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (hi), 0, 4), \</span>
<span class="p_add">+	/* if (hi != arg.hi) goto NOMATCH; */ \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 0), \</span>
<span class="p_add">+	/* if (lo &lt;= arg.lo) goto MATCH; */ \</span>
 	BPF_JUMP(BPF_JMP+BPF_JGT+BPF_K, (lo), 2, 0), \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1), /* passed: swap hi back in */ \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1), \</span>
<span class="p_add">+	jt, \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define JLT64(lo, hi, jt) \</span>
<span class="p_add">+	/* if (hi &lt; arg.hi) goto MATCH; */ \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (hi), 0, 4), \</span>
<span class="p_add">+	/* if (hi != arg.hi) goto NOMATCH; */ \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, (hi), 0, 5), \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 0), \</span>
<span class="p_add">+	/* if (lo &lt; arg.lo) goto MATCH; */ \</span>
<span class="p_add">+	BPF_JUMP(BPF_JMP+BPF_JGE+BPF_K, (lo), 2, 0), \</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1), \</span>
 	jt, \
<span class="p_del">-	BPF_STMT(BPF_LD+BPF_MEM, 1) /* failed: swap hi back in */</span>
<span class="p_add">+	BPF_STMT(BPF_LD+BPF_MEM, 1)</span>
 
 #define LOAD_SYSCALL_NR \
 	BPF_STMT(BPF_LD+BPF_W+BPF_ABS, \
<span class="p_header">diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h</span>
<span class="p_header">index db25f54a04fe..df7834aa1b8f 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima.h</span>
<span class="p_header">+++ b/security/integrity/ima/ima.h</span>
<span class="p_chunk">@@ -173,7 +173,7 @@</span> <span class="p_context"> int ima_store_template(struct ima_template_entry *entry, int violation,</span>
 		       struct inode *inode,
 		       const unsigned char *filename, int pcr);
 void ima_free_template_entry(struct ima_template_entry *entry);
<span class="p_del">-const char *ima_d_path(const struct path *path, char **pathbuf);</span>
<span class="p_add">+const char *ima_d_path(const struct path *path, char **pathbuf, char *filename);</span>
 
 /* IMA policy related functions */
 int ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,
<span class="p_header">diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c</span>
<span class="p_header">index 9df26a2b75ba..d01a52f8f708 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_api.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_api.c</span>
<span class="p_chunk">@@ -318,7 +318,17 @@</span> <span class="p_context"> void ima_audit_measurement(struct integrity_iint_cache *iint,</span>
 	iint-&gt;flags |= IMA_AUDITED;
 }
 
<span class="p_del">-const char *ima_d_path(const struct path *path, char **pathbuf)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ima_d_path - return a pointer to the full pathname</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Attempt to return a pointer to the full pathname for use in the</span>
<span class="p_add">+ * IMA measurement list, IMA audit records, and auditing logs.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * On failure, return a pointer to a copy of the filename, not dname.</span>
<span class="p_add">+ * Returning a pointer to dname, could result in using the pointer</span>
<span class="p_add">+ * after the memory has been freed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+const char *ima_d_path(const struct path *path, char **pathbuf, char *namebuf)</span>
 {
 	char *pathname = NULL;
 
<span class="p_chunk">@@ -331,5 +341,11 @@</span> <span class="p_context"> const char *ima_d_path(const struct path *path, char **pathbuf)</span>
 			pathname = NULL;
 		}
 	}
<span class="p_del">-	return pathname ?: (const char *)path-&gt;dentry-&gt;d_name.name;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pathname) {</span>
<span class="p_add">+		strlcpy(namebuf, path-&gt;dentry-&gt;d_name.name, NAME_MAX);</span>
<span class="p_add">+		pathname = namebuf;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return pathname;</span>
 }
<span class="p_header">diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c</span>
<span class="p_header">index 423d111b3b94..0e8762945e79 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_main.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_main.c</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> static void ima_rdwr_violation_check(struct file *file,</span>
 				     const char **pathname)
 {
 	struct inode *inode = file_inode(file);
<span class="p_add">+	char filename[NAME_MAX];</span>
 	fmode_t mode = file-&gt;f_mode;
 	bool send_tomtou = false, send_writers = false;
 
<span class="p_chunk">@@ -102,7 +103,7 @@</span> <span class="p_context"> static void ima_rdwr_violation_check(struct file *file,</span>
 	if (!send_tomtou &amp;&amp; !send_writers)
 		return;
 
<span class="p_del">-	*pathname = ima_d_path(&amp;file-&gt;f_path, pathbuf);</span>
<span class="p_add">+	*pathname = ima_d_path(&amp;file-&gt;f_path, pathbuf, filename);</span>
 
 	if (send_tomtou)
 		ima_add_violation(file, *pathname, iint,
<span class="p_chunk">@@ -161,6 +162,7 @@</span> <span class="p_context"> static int process_measurement(struct file *file, char *buf, loff_t size,</span>
 	struct integrity_iint_cache *iint = NULL;
 	struct ima_template_desc *template_desc;
 	char *pathbuf = NULL;
<span class="p_add">+	char filename[NAME_MAX];</span>
 	const char *pathname = NULL;
 	int rc = -ENOMEM, action, must_appraise;
 	int pcr = CONFIG_IMA_MEASURE_PCR_IDX;
<span class="p_chunk">@@ -239,8 +241,8 @@</span> <span class="p_context"> static int process_measurement(struct file *file, char *buf, loff_t size,</span>
 		goto out_digsig;
 	}
 
<span class="p_del">-	if (!pathname)	/* ima_rdwr_violation possibly pre-fetched */</span>
<span class="p_del">-		pathname = ima_d_path(&amp;file-&gt;f_path, &amp;pathbuf);</span>
<span class="p_add">+	if (!pathbuf)	/* ima_rdwr_violation possibly pre-fetched */</span>
<span class="p_add">+		pathname = ima_d_path(&amp;file-&gt;f_path, &amp;pathbuf, filename);</span>
 
 	if (action &amp; IMA_MEASURE)
 		ima_store_measurement(iint, file, pathname,
<span class="p_header">diff --git a/sound/core/seq/seq_fifo.c b/sound/core/seq/seq_fifo.c</span>
<span class="p_header">index 1d5acbe0c08b..86240d02b530 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_fifo.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_fifo.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> int snd_seq_fifo_event_in(struct snd_seq_fifo *f,</span>
 	f-&gt;tail = cell;
 	if (f-&gt;head == NULL)
 		f-&gt;head = cell;
<span class="p_add">+	cell-&gt;next = NULL;</span>
 	f-&gt;cells++;
 	spin_unlock_irqrestore(&amp;f-&gt;lock, flags);
 
<span class="p_chunk">@@ -214,6 +215,8 @@</span> <span class="p_context"> void snd_seq_fifo_cell_putback(struct snd_seq_fifo *f,</span>
 		spin_lock_irqsave(&amp;f-&gt;lock, flags);
 		cell-&gt;next = f-&gt;head;
 		f-&gt;head = cell;
<span class="p_add">+		if (!f-&gt;tail)</span>
<span class="p_add">+			f-&gt;tail = cell;</span>
 		f-&gt;cells++;
 		spin_unlock_irqrestore(&amp;f-&gt;lock, flags);
 	}
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index fc144f43faa6..ad153149b231 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -1702,9 +1702,21 @@</span> <span class="p_context"> static int snd_timer_user_params(struct file *file,</span>
 		return -EBADFD;
 	if (copy_from_user(&amp;params, _params, sizeof(params)))
 		return -EFAULT;
<span class="p_del">-	if (!(t-&gt;hw.flags &amp; SNDRV_TIMER_HW_SLAVE) &amp;&amp; params.ticks &lt; 1) {</span>
<span class="p_del">-		err = -EINVAL;</span>
<span class="p_del">-		goto _end;</span>
<span class="p_add">+	if (!(t-&gt;hw.flags &amp; SNDRV_TIMER_HW_SLAVE)) {</span>
<span class="p_add">+		u64 resolution;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (params.ticks &lt; 1) {</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto _end;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Don&#39;t allow resolution less than 1ms */</span>
<span class="p_add">+		resolution = snd_timer_resolution(tu-&gt;timeri);</span>
<span class="p_add">+		resolution *= params.ticks;</span>
<span class="p_add">+		if (resolution &lt; 1000000) {</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto _end;</span>
<span class="p_add">+		}</span>
 	}
 	if (params.queue_size &gt; 0 &amp;&amp;
 	    (params.queue_size &lt; 32 || params.queue_size &gt; 1024)) {
<span class="p_header">diff --git a/sound/pci/ctxfi/cthw20k1.c b/sound/pci/ctxfi/cthw20k1.c</span>
<span class="p_header">index 9667cbfb0ca2..ab4cdab5cfa5 100644</span>
<span class="p_header">--- a/sound/pci/ctxfi/cthw20k1.c</span>
<span class="p_header">+++ b/sound/pci/ctxfi/cthw20k1.c</span>
<span class="p_chunk">@@ -27,12 +27,6 @@</span> <span class="p_context"></span>
 #include &quot;cthw20k1.h&quot;
 #include &quot;ct20k1reg.h&quot;
 
<span class="p_del">-#if BITS_PER_LONG == 32</span>
<span class="p_del">-#define CT_XFI_DMA_MASK		DMA_BIT_MASK(32) /* 32 bit PTE */</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define CT_XFI_DMA_MASK		DMA_BIT_MASK(64) /* 64 bit PTE */</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 struct hw20k1 {
 	struct hw hw;
 	spinlock_t reg_20k1_lock;
<span class="p_chunk">@@ -1904,19 +1898,18 @@</span> <span class="p_context"> static int hw_card_start(struct hw *hw)</span>
 {
 	int err;
 	struct pci_dev *pci = hw-&gt;pci;
<span class="p_add">+	const unsigned int dma_bits = BITS_PER_LONG;</span>
 
 	err = pci_enable_device(pci);
 	if (err &lt; 0)
 		return err;
 
 	/* Set DMA transfer mask */
<span class="p_del">-	if (dma_set_mask(&amp;pci-&gt;dev, CT_XFI_DMA_MASK) &lt; 0 ||</span>
<span class="p_del">-	    dma_set_coherent_mask(&amp;pci-&gt;dev, CT_XFI_DMA_MASK) &lt; 0) {</span>
<span class="p_del">-		dev_err(hw-&gt;card-&gt;dev,</span>
<span class="p_del">-			&quot;architecture does not support PCI busmaster DMA with mask 0x%llx\n&quot;,</span>
<span class="p_del">-			CT_XFI_DMA_MASK);</span>
<span class="p_del">-		err = -ENXIO;</span>
<span class="p_del">-		goto error1;</span>
<span class="p_add">+	if (dma_set_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(dma_bits))) {</span>
<span class="p_add">+		dma_set_coherent_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(dma_bits));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dma_set_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(32));</span>
<span class="p_add">+		dma_set_coherent_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(32));</span>
 	}
 
 	if (!hw-&gt;io_base) {
<span class="p_header">diff --git a/sound/pci/ctxfi/cthw20k2.c b/sound/pci/ctxfi/cthw20k2.c</span>
<span class="p_header">index 6414ecf93efa..18ee7768b7c4 100644</span>
<span class="p_header">--- a/sound/pci/ctxfi/cthw20k2.c</span>
<span class="p_header">+++ b/sound/pci/ctxfi/cthw20k2.c</span>
<span class="p_chunk">@@ -26,12 +26,6 @@</span> <span class="p_context"></span>
 #include &quot;cthw20k2.h&quot;
 #include &quot;ct20k2reg.h&quot;
 
<span class="p_del">-#if BITS_PER_LONG == 32</span>
<span class="p_del">-#define CT_XFI_DMA_MASK		DMA_BIT_MASK(32) /* 32 bit PTE */</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define CT_XFI_DMA_MASK		DMA_BIT_MASK(64) /* 64 bit PTE */</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 struct hw20k2 {
 	struct hw hw;
 	/* for i2c */
<span class="p_chunk">@@ -2029,19 +2023,18 @@</span> <span class="p_context"> static int hw_card_start(struct hw *hw)</span>
 	int err = 0;
 	struct pci_dev *pci = hw-&gt;pci;
 	unsigned int gctl;
<span class="p_add">+	const unsigned int dma_bits = BITS_PER_LONG;</span>
 
 	err = pci_enable_device(pci);
 	if (err &lt; 0)
 		return err;
 
 	/* Set DMA transfer mask */
<span class="p_del">-	if (dma_set_mask(&amp;pci-&gt;dev, CT_XFI_DMA_MASK) &lt; 0 ||</span>
<span class="p_del">-	    dma_set_coherent_mask(&amp;pci-&gt;dev, CT_XFI_DMA_MASK) &lt; 0) {</span>
<span class="p_del">-		dev_err(hw-&gt;card-&gt;dev,</span>
<span class="p_del">-			&quot;architecture does not support PCI busmaster DMA with mask 0x%llx\n&quot;,</span>
<span class="p_del">-			CT_XFI_DMA_MASK);</span>
<span class="p_del">-		err = -ENXIO;</span>
<span class="p_del">-		goto error1;</span>
<span class="p_add">+	if (!dma_set_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(dma_bits))) {</span>
<span class="p_add">+		dma_set_coherent_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(dma_bits));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		dma_set_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(32));</span>
<span class="p_add">+		dma_set_coherent_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(32));</span>
 	}
 
 	if (!hw-&gt;io_base) {
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index c64d986009a9..bc4462694aaf 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2197,9 +2197,9 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
 	/* Lewisburg */
 	{ PCI_DEVICE(0x8086, 0xa1f0),
<span class="p_del">-	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE },</span>
 	{ PCI_DEVICE(0x8086, 0xa270),
<span class="p_del">-	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE },</span>
 	/* Lynx Point-LP */
 	{ PCI_DEVICE(0x8086, 0x9c20),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_PCH },
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 758ac86a1d3a..0c62b1d8c11b 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5577,6 +5577,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x0725, &quot;Dell Inspiron 3162&quot;, ALC255_FIXUP_DELL_SPK_NOISE),
 	SND_PCI_QUIRK(0x1028, 0x075b, &quot;Dell XPS 13 9360&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),
 	SND_PCI_QUIRK(0x1028, 0x075d, &quot;Dell AIO&quot;, ALC298_FIXUP_SPK_VOLUME),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x0798, &quot;Dell Inspiron 17 7000 Gaming&quot;, ALC256_FIXUP_DELL_INSPIRON_7559_SUBWOOFER),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_chunk">@@ -5692,6 +5693,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x2233, &quot;Thinkpad&quot;, ALC292_FIXUP_TPT460),
 	SND_PCI_QUIRK(0x17aa, 0x30bb, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),
 	SND_PCI_QUIRK(0x17aa, 0x30e2, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x3112, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3902, &quot;Lenovo E50-80&quot;, ALC269_FIXUP_DMIC_THINKPAD_ACPI),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;IdeaPad S210&quot;, ALC283_FIXUP_INT_MIC),
 	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;IdeaPad Y410P&quot;, ALC269_FIXUP_NO_SHUTUP),
<span class="p_chunk">@@ -6065,6 +6067,12 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 	SND_HDA_PIN_QUIRK(0x10ec0298, 0x1028, &quot;Dell&quot;, ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC298_STANDARD_PINS,
 		{0x17, 0x90170150}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0298, 0x1028, &quot;Dell&quot;, ALC298_FIXUP_SPK_VOLUME,</span>
<span class="p_add">+		{0x12, 0xb7a60140},</span>
<span class="p_add">+		{0x13, 0xb7a60150},</span>
<span class="p_add">+		{0x17, 0x90170110},</span>
<span class="p_add">+		{0x1a, 0x03011020},</span>
<span class="p_add">+		{0x21, 0x03211030}),</span>
 	{}
 };
 
<span class="p_header">diff --git a/tools/perf/util/callchain.c b/tools/perf/util/callchain.c</span>
<span class="p_header">index ae58b493af45..ecf6236f3b5f 100644</span>
<span class="p_header">--- a/tools/perf/util/callchain.c</span>
<span class="p_header">+++ b/tools/perf/util/callchain.c</span>
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> fill_node(struct callchain_node *node, struct callchain_cursor *cursor)</span>
 		}
 		call-&gt;ip = cursor_node-&gt;ip;
 		call-&gt;ms.sym = cursor_node-&gt;sym;
<span class="p_del">-		call-&gt;ms.map = cursor_node-&gt;map;</span>
<span class="p_add">+		call-&gt;ms.map = map__get(cursor_node-&gt;map);</span>
 		list_add_tail(&amp;call-&gt;list, &amp;node-&gt;val);
 
 		callchain_cursor_advance(cursor);
<span class="p_chunk">@@ -462,6 +462,7 @@</span> <span class="p_context"> add_child(struct callchain_node *parent,</span>
 
 		list_for_each_entry_safe(call, tmp, &amp;new-&gt;val, list) {
 			list_del(&amp;call-&gt;list);
<span class="p_add">+			map__zput(call-&gt;ms.map);</span>
 			free(call);
 		}
 		free(new);
<span class="p_chunk">@@ -730,6 +731,7 @@</span> <span class="p_context"> merge_chain_branch(struct callchain_cursor *cursor,</span>
 		callchain_cursor_append(cursor, list-&gt;ip,
 					list-&gt;ms.map, list-&gt;ms.sym);
 		list_del(&amp;list-&gt;list);
<span class="p_add">+		map__zput(list-&gt;ms.map);</span>
 		free(list);
 	}
 
<span class="p_chunk">@@ -778,7 +780,8 @@</span> <span class="p_context"> int callchain_cursor_append(struct callchain_cursor *cursor,</span>
 	}
 
 	node-&gt;ip = ip;
<span class="p_del">-	node-&gt;map = map;</span>
<span class="p_add">+	map__zput(node-&gt;map);</span>
<span class="p_add">+	node-&gt;map = map__get(map);</span>
 	node-&gt;sym = sym;
 
 	cursor-&gt;nr++;
<span class="p_chunk">@@ -945,11 +948,13 @@</span> <span class="p_context"> static void free_callchain_node(struct callchain_node *node)</span>
 
 	list_for_each_entry_safe(list, tmp, &amp;node-&gt;parent_val, list) {
 		list_del(&amp;list-&gt;list);
<span class="p_add">+		map__zput(list-&gt;ms.map);</span>
 		free(list);
 	}
 
 	list_for_each_entry_safe(list, tmp, &amp;node-&gt;val, list) {
 		list_del(&amp;list-&gt;list);
<span class="p_add">+		map__zput(list-&gt;ms.map);</span>
 		free(list);
 	}
 
<span class="p_chunk">@@ -1013,6 +1018,7 @@</span> <span class="p_context"> int callchain_node__make_parent_list(struct callchain_node *node)</span>
 				goto out;
 			*new = *chain;
 			new-&gt;has_children = false;
<span class="p_add">+			map__get(new-&gt;ms.map);</span>
 			list_add_tail(&amp;new-&gt;list, &amp;head);
 		}
 		parent = parent-&gt;parent;
<span class="p_chunk">@@ -1033,6 +1039,7 @@</span> <span class="p_context"> int callchain_node__make_parent_list(struct callchain_node *node)</span>
 out:
 	list_for_each_entry_safe(chain, new, &amp;head, list) {
 		list_del(&amp;chain-&gt;list);
<span class="p_add">+		map__zput(chain-&gt;ms.map);</span>
 		free(chain);
 	}
 	return -ENOMEM;
<span class="p_header">diff --git a/tools/perf/util/callchain.h b/tools/perf/util/callchain.h</span>
<span class="p_header">index 47cfd1080975..b7cbabb3931f 100644</span>
<span class="p_header">--- a/tools/perf/util/callchain.h</span>
<span class="p_header">+++ b/tools/perf/util/callchain.h</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/list.h&gt;
 #include &lt;linux/rbtree.h&gt;
 #include &quot;event.h&quot;
<span class="p_add">+#include &quot;map.h&quot;</span>
 #include &quot;symbol.h&quot;
 
 #define HELP_PAD &quot;\t\t\t\t&quot;
<span class="p_chunk">@@ -174,8 +175,13 @@</span> <span class="p_context"> int callchain_merge(struct callchain_cursor *cursor,</span>
  */
 static inline void callchain_cursor_reset(struct callchain_cursor *cursor)
 {
<span class="p_add">+	struct callchain_cursor_node *node;</span>
<span class="p_add">+</span>
 	cursor-&gt;nr = 0;
 	cursor-&gt;last = &amp;cursor-&gt;first;
<span class="p_add">+</span>
<span class="p_add">+	for (node = cursor-&gt;first; node != NULL; node = node-&gt;next)</span>
<span class="p_add">+		map__zput(node-&gt;map);</span>
 }
 
 int callchain_cursor_append(struct callchain_cursor *cursor, u64 ip,
<span class="p_header">diff --git a/tools/perf/util/hist.c b/tools/perf/util/hist.c</span>
<span class="p_header">index a69f027368ef..10849a079026 100644</span>
<span class="p_header">--- a/tools/perf/util/hist.c</span>
<span class="p_header">+++ b/tools/perf/util/hist.c</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 #include &quot;util.h&quot;
 #include &quot;build-id.h&quot;
 #include &quot;hist.h&quot;
<span class="p_add">+#include &quot;map.h&quot;</span>
 #include &quot;session.h&quot;
 #include &quot;sort.h&quot;
 #include &quot;evlist.h&quot;
<span class="p_chunk">@@ -1019,6 +1020,10 @@</span> <span class="p_context"> int hist_entry_iter__add(struct hist_entry_iter *iter, struct addr_location *al,</span>
 			 int max_stack_depth, void *arg)
 {
 	int err, err2;
<span class="p_add">+	struct map *alm = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (al &amp;&amp; al-&gt;map)</span>
<span class="p_add">+		alm = map__get(al-&gt;map);</span>
 
 	err = sample__resolve_callchain(iter-&gt;sample, &amp;callchain_cursor, &amp;iter-&gt;parent,
 					iter-&gt;evsel, al, max_stack_depth);
<span class="p_chunk">@@ -1058,6 +1063,8 @@</span> <span class="p_context"> int hist_entry_iter__add(struct hist_entry_iter *iter, struct addr_location *al,</span>
 	if (!err)
 		err = err2;
 
<span class="p_add">+	map__put(alm);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic-irqfd.c b/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_header">index d918dcf26a5a..f138ed2e9c63 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic-irqfd.c</span>
<span class="p_chunk">@@ -99,6 +99,9 @@</span> <span class="p_context"> int kvm_set_msi(struct kvm_kernel_irq_routing_entry *e,</span>
 	if (!vgic_has_its(kvm))
 		return -ENODEV;
 
<span class="p_add">+	if (!level)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	return vgic_its_inject_msi(kvm, &amp;msi);
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



