
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.109 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.109</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 3, 2018, 2:16 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180103141657.GB14757@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10142455/mbox/"
   >mbox</a>
|
   <a href="/patch/10142455/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10142455/">/patch/10142455/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	775AD6034B for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  3 Jan 2018 14:17:08 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5294328D71
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  3 Jan 2018 14:17:08 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 46963290C3; Wed,  3 Jan 2018 14:17:08 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7FC2028D71
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  3 Jan 2018 14:17:04 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752840AbeACORA (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 3 Jan 2018 09:17:00 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:39236 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751909AbeACOQx (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 3 Jan 2018 09:16:53 -0500
Received: from localhost (LFbn-1-12258-90.w90-92.abo.wanadoo.fr
	[90.92.71.90])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 5F312BAC;
	Wed,  3 Jan 2018 14:16:52 +0000 (UTC)
Date: Wed, 3 Jan 2018 15:16:57 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.109
Message-ID: &lt;20180103141657.GB14757@kroah.com&gt;
References: &lt;20180103141651.GA14757@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180103141651.GA14757@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Jan. 3, 2018, 2:16 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 5d593ecadb90..b4a83a490212 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -2555,6 +2555,8 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 	nopat		[X86] Disable PAT (page attribute table extension of
 			pagetables) support.
 
<span class="p_add">+	nopcid		[X86-64] Disable the PCID cpu feature.</span>
<span class="p_add">+</span>
 	norandmaps	Don&#39;t use address space randomization.  Equivalent to
 			echo 0 &gt; /proc/sys/kernel/randomize_va_space
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 99f9834c4ba6..5d67056e24dd 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 108</span>
<span class="p_add">+SUBLEVEL = 109</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_chunk">@@ -782,6 +782,9 @@</span> <span class="p_context"> KBUILD_CFLAGS += $(call cc-disable-warning, pointer-sign)</span>
 # disable invalid &quot;can&#39;t wrap&quot; optimizations for signed / pointers
 KBUILD_CFLAGS	+= $(call cc-option,-fno-strict-overflow)
 
<span class="p_add">+# Make sure -fstack-check isn&#39;t enabled (like gentoo apparently did)</span>
<span class="p_add">+KBUILD_CFLAGS  += $(call cc-option,-fno-stack-check,)</span>
<span class="p_add">+</span>
 # conserve stack if available
 KBUILD_CFLAGS   += $(call cc-option,-fconserve-stack)
 
<span class="p_header">diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">index d1e65ce545b3..b2ab164a8094 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_chunk">@@ -401,8 +401,12 @@</span> <span class="p_context"> static __u64 power_pmu_bhrb_to(u64 addr)</span>
 	int ret;
 	__u64 target;
 
<span class="p_del">-	if (is_kernel_addr(addr))</span>
<span class="p_del">-		return branch_target((unsigned int *)addr);</span>
<span class="p_add">+	if (is_kernel_addr(addr)) {</span>
<span class="p_add">+		if (probe_kernel_read(&amp;instr, (void *)addr, sizeof(instr)))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		return branch_target(&amp;instr);</span>
<span class="p_add">+	}</span>
 
 	/* Userspace: need copy instruction here then translate it */
 	pagefault_disable();
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 7e40905f6d4c..39d2dc66faa5 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> config X86</span>
 	select ARCH_USE_CMPXCHG_LOCKREF		if X86_64
 	select ARCH_USE_QUEUED_RWLOCKS
 	select ARCH_USE_QUEUED_SPINLOCKS
<span class="p_del">-	select ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH if SMP</span>
<span class="p_add">+	select ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span>
 	select ARCH_WANTS_DYNAMIC_TASK_STRUCT
 	select ARCH_WANT_FRAME_POINTERS
 	select ARCH_WANT_IPC_PARSE_VERSION	if X86_32
<span class="p_header">diff --git a/arch/x86/include/asm/disabled-features.h b/arch/x86/include/asm/disabled-features.h</span>
<span class="p_header">index f226df064660..8b17c2ad1048 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/disabled-features.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/disabled-features.h</span>
<span class="p_chunk">@@ -21,11 +21,13 @@</span> <span class="p_context"></span>
 # define DISABLE_K6_MTRR	(1&lt;&lt;(X86_FEATURE_K6_MTRR &amp; 31))
 # define DISABLE_CYRIX_ARR	(1&lt;&lt;(X86_FEATURE_CYRIX_ARR &amp; 31))
 # define DISABLE_CENTAUR_MCR	(1&lt;&lt;(X86_FEATURE_CENTAUR_MCR &amp; 31))
<span class="p_add">+# define DISABLE_PCID		0</span>
 #else
 # define DISABLE_VME		0
 # define DISABLE_K6_MTRR	0
 # define DISABLE_CYRIX_ARR	0
 # define DISABLE_CENTAUR_MCR	0
<span class="p_add">+# define DISABLE_PCID		(1&lt;&lt;(X86_FEATURE_PCID &amp; 31))</span>
 #endif /* CONFIG_X86_64 */
 
 /*
<span class="p_chunk">@@ -35,7 +37,7 @@</span> <span class="p_context"></span>
 #define DISABLED_MASK1	0
 #define DISABLED_MASK2	0
 #define DISABLED_MASK3	(DISABLE_CYRIX_ARR|DISABLE_CENTAUR_MCR|DISABLE_K6_MTRR)
<span class="p_del">-#define DISABLED_MASK4	0</span>
<span class="p_add">+#define DISABLED_MASK4	(DISABLE_PCID)</span>
 #define DISABLED_MASK5	0
 #define DISABLED_MASK6	0
 #define DISABLED_MASK7	0
<span class="p_header">diff --git a/arch/x86/include/asm/hardirq.h b/arch/x86/include/asm/hardirq.h</span>
<span class="p_header">index 59405a248fc2..9b76cd331990 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hardirq.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hardirq.h</span>
<span class="p_chunk">@@ -22,8 +22,8 @@</span> <span class="p_context"> typedef struct {</span>
 #ifdef CONFIG_SMP
 	unsigned int irq_resched_count;
 	unsigned int irq_call_count;
<span class="p_del">-	unsigned int irq_tlb_count;</span>
 #endif
<span class="p_add">+	unsigned int irq_tlb_count;</span>
 #ifdef CONFIG_X86_THERMAL_VECTOR
 	unsigned int irq_thermal_count;
 #endif
<span class="p_header">diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h</span>
<span class="p_header">index 55234d5e7160..7680b76adafc 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu.h</span>
<span class="p_chunk">@@ -24,12 +24,6 @@</span> <span class="p_context"> typedef struct {</span>
 	atomic_t perf_rdpmc_allowed;	/* nonzero if rdpmc is allowed */
 } mm_context_t;
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
 void leave_mm(int cpu);
<span class="p_del">-#else</span>
<span class="p_del">-static inline void leave_mm(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
 
 #endif /* _ASM_X86_MMU_H */
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 44fc93987869..9bfc5fd77015 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -98,10 +98,8 @@</span> <span class="p_context"> static inline void load_mm_ldt(struct mm_struct *mm)</span>
 
 static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)
 {
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	if (this_cpu_read(cpu_tlbstate.state) == TLBSTATE_OK)
 		this_cpu_write(cpu_tlbstate.state, TLBSTATE_LAZY);
<span class="p_del">-#endif</span>
 }
 
 extern void switch_mm(struct mm_struct *prev, struct mm_struct *next,
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 4dc534175b5e..9fc5968da820 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -6,6 +6,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/special_insns.h&gt;
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
 
 static inline void __invpcid(unsigned long pcid, unsigned long addr,
 			     unsigned long type)
<span class="p_chunk">@@ -64,10 +65,8 @@</span> <span class="p_context"> static inline void invpcid_flush_all_nonglobals(void)</span>
 #endif
 
 struct tlb_state {
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	struct mm_struct *active_mm;
 	int state;
<span class="p_del">-#endif</span>
 
 	/*
 	 * Access to this CR4 shadow and to H/W CR4 is protected by
<span class="p_chunk">@@ -191,6 +190,14 @@</span> <span class="p_context"> static inline void __flush_tlb_all(void)</span>
 		__flush_tlb_global();
 	else
 		__flush_tlb();
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note: if we somehow had PCID but not PGE, then this wouldn&#39;t work --</span>
<span class="p_add">+	 * we&#39;d end up flushing kernel translations for the current ASID but</span>
<span class="p_add">+	 * we might fail to flush kernel translations for other cached ASIDs.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * To avoid this issue, we force PCID off if PGE is off.</span>
<span class="p_add">+	 */</span>
 }
 
 static inline void __flush_tlb_one(unsigned long addr)
<span class="p_chunk">@@ -204,7 +211,6 @@</span> <span class="p_context"> static inline void __flush_tlb_one(unsigned long addr)</span>
 /*
  * TLB flushing:
  *
<span class="p_del">- *  - flush_tlb() flushes the current mm struct TLBs</span>
  *  - flush_tlb_all() flushes all processes TLBs
  *  - flush_tlb_mm(mm) flushes the specified mm context TLB&#39;s
  *  - flush_tlb_page(vma, vmaddr) flushes one page
<span class="p_chunk">@@ -216,84 +222,6 @@</span> <span class="p_context"> static inline void __flush_tlb_one(unsigned long addr)</span>
  * and page-granular flushes are available only on i486 and up.
  */
 
<span class="p_del">-#ifndef CONFIG_SMP</span>
<span class="p_del">-</span>
<span class="p_del">-/* &quot;_up&quot; is for UniProcessor.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is a helper for other header functions.  *Not* intended to be called</span>
<span class="p_del">- * directly.  All global TLB flushes need to either call this, or to bump the</span>
<span class="p_del">- * vm statistics themselves.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void __flush_tlb_up(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);</span>
<span class="p_del">-	__flush_tlb();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_all(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);</span>
<span class="p_del">-	__flush_tlb_all();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void local_flush_tlb(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_mm(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_page(struct vm_area_struct *vma,</span>
<span class="p_del">-				  unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (vma-&gt;vm_mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_one(addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_range(struct vm_area_struct *vma,</span>
<span class="p_del">-				   unsigned long start, unsigned long end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (vma-&gt;vm_mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_mm_range(struct mm_struct *mm,</span>
<span class="p_del">-	   unsigned long start, unsigned long end, unsigned long vmflag)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (mm == current-&gt;active_mm)</span>
<span class="p_del">-		__flush_tlb_up();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void native_flush_tlb_others(const struct cpumask *cpumask,</span>
<span class="p_del">-					   struct mm_struct *mm,</span>
<span class="p_del">-					   unsigned long start,</span>
<span class="p_del">-					   unsigned long end)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void reset_lazy_tlbstate(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void flush_tlb_kernel_range(unsigned long start,</span>
<span class="p_del">-					  unsigned long end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	flush_tlb_all();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#else  /* SMP */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/smp.h&gt;</span>
<span class="p_del">-</span>
 #define local_flush_tlb() __flush_tlb()
 
 #define flush_tlb_mm(mm)	flush_tlb_mm_range(mm, 0UL, TLB_FLUSH_ALL, 0UL)
<span class="p_chunk">@@ -302,13 +230,14 @@</span> <span class="p_context"> static inline void flush_tlb_kernel_range(unsigned long start,</span>
 		flush_tlb_mm_range(vma-&gt;vm_mm, start, end, vma-&gt;vm_flags)
 
 extern void flush_tlb_all(void);
<span class="p_del">-extern void flush_tlb_current_task(void);</span>
<span class="p_del">-extern void flush_tlb_page(struct vm_area_struct *, unsigned long);</span>
 extern void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
 				unsigned long end, unsigned long vmflag);
 extern void flush_tlb_kernel_range(unsigned long start, unsigned long end);
 
<span class="p_del">-#define flush_tlb()	flush_tlb_current_task()</span>
<span class="p_add">+static inline void flush_tlb_page(struct vm_area_struct *vma, unsigned long a)</span>
<span class="p_add">+{</span>
<span class="p_add">+	flush_tlb_mm_range(vma-&gt;vm_mm, a, a + PAGE_SIZE, VM_NONE);</span>
<span class="p_add">+}</span>
 
 void native_flush_tlb_others(const struct cpumask *cpumask,
 				struct mm_struct *mm,
<span class="p_chunk">@@ -323,8 +252,6 @@</span> <span class="p_context"> static inline void reset_lazy_tlbstate(void)</span>
 	this_cpu_write(cpu_tlbstate.active_mm, &amp;init_mm);
 }
 
<span class="p_del">-#endif	/* SMP */</span>
<span class="p_del">-</span>
 #ifndef CONFIG_PARAVIRT
 #define flush_tlb_others(mask, mm, start, end)	\
 	native_flush_tlb_others(mask, mm, start, end)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/bugs.c b/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_header">index bd17db15a2c1..0b6124315441 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/bugs.c</span>
<span class="p_chunk">@@ -19,6 +19,14 @@</span> <span class="p_context"></span>
 
 void __init check_bugs(void)
 {
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Regardless of whether PCID is enumerated, the SDM says</span>
<span class="p_add">+	 * that it can&#39;t be enabled in 32-bit mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	setup_clear_cpu_cap(X86_FEATURE_PCID);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	identify_boot_cpu();
 #ifndef CONFIG_SMP
 	pr_info(&quot;CPU: &quot;);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index c84b62956e8d..aa1e7246b06b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -162,6 +162,24 @@</span> <span class="p_context"> static int __init x86_mpx_setup(char *s)</span>
 }
 __setup(&quot;nompx&quot;, x86_mpx_setup);
 
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static int __init x86_pcid_setup(char *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* require an exact match without trailing characters */</span>
<span class="p_add">+	if (strlen(s))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do not emit a message if the feature is not present */</span>
<span class="p_add">+	if (!boot_cpu_has(X86_FEATURE_PCID))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_clear_cpu_cap(X86_FEATURE_PCID);</span>
<span class="p_add">+	pr_info(&quot;nopcid: PCID feature disabled\n&quot;);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;nopcid&quot;, x86_pcid_setup);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int __init x86_noinvpcid_setup(char *s)
 {
 	/* noinvpcid doesn&#39;t accept parameters */
<span class="p_chunk">@@ -303,6 +321,25 @@</span> <span class="p_context"> static __always_inline void setup_smap(struct cpuinfo_x86 *c)</span>
 	}
 }
 
<span class="p_add">+static void setup_pcid(struct cpuinfo_x86 *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (cpu_has(c, X86_FEATURE_PCID)) {</span>
<span class="p_add">+		if (cpu_has(c, X86_FEATURE_PGE)) {</span>
<span class="p_add">+			cr4_set_bits(X86_CR4_PCIDE);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * flush_tlb_all(), as currently implemented, won&#39;t</span>
<span class="p_add">+			 * work if PCID is on but PGE is not.  Since that</span>
<span class="p_add">+			 * combination doesn&#39;t exist on real hardware, there&#39;s</span>
<span class="p_add">+			 * no reason to try to fully support it, but it&#39;s</span>
<span class="p_add">+			 * polite to avoid corrupting data if we&#39;re on</span>
<span class="p_add">+			 * an improperly configured VM.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			clear_cpu_cap(c, X86_FEATURE_PCID);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Some CPU features depend on higher CPUID levels, which may not always
  * be available due to CPUID level capping or broken virtualization
<span class="p_chunk">@@ -934,6 +971,9 @@</span> <span class="p_context"> static void identify_cpu(struct cpuinfo_x86 *c)</span>
 	setup_smep(c);
 	setup_smap(c);
 
<span class="p_add">+	/* Set up PCID */</span>
<span class="p_add">+	setup_pcid(c);</span>
<span class="p_add">+</span>
 	/*
 	 * The vendor-specific functions might have changed features.
 	 * Now we do &quot;generic changes.&quot;
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index f660d63f40fe..9a16932c7258 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -93,6 +93,10 @@</span> <span class="p_context"> void __noreturn machine_real_restart(unsigned int type)</span>
 	load_cr3(initial_page_table);
 #else
 	write_cr3(real_mode_header-&gt;trampoline_pgd);
<span class="p_add">+</span>
<span class="p_add">+	/* Exiting long mode will fail if CR4.PCIDE is set. */</span>
<span class="p_add">+	if (static_cpu_has(X86_FEATURE_PCID))</span>
<span class="p_add">+		cr4_clear_bits(X86_CR4_PCIDE);</span>
 #endif
 
 	/* Jump to the identity-mapped low memory code */
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index fbabe4fcc7fb..fe89f938e0f0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -104,25 +104,16 @@</span> <span class="p_context"> static inline void smpboot_setup_warm_reset_vector(unsigned long start_eip)</span>
 	spin_lock_irqsave(&amp;rtc_lock, flags);
 	CMOS_WRITE(0xa, 0xf);
 	spin_unlock_irqrestore(&amp;rtc_lock, flags);
<span class="p_del">-	local_flush_tlb();</span>
<span class="p_del">-	pr_debug(&quot;1.\n&quot;);</span>
 	*((volatile unsigned short *)phys_to_virt(TRAMPOLINE_PHYS_HIGH)) =
 							start_eip &gt;&gt; 4;
<span class="p_del">-	pr_debug(&quot;2.\n&quot;);</span>
 	*((volatile unsigned short *)phys_to_virt(TRAMPOLINE_PHYS_LOW)) =
 							start_eip &amp; 0xf;
<span class="p_del">-	pr_debug(&quot;3.\n&quot;);</span>
 }
 
 static inline void smpboot_restore_warm_reset_vector(void)
 {
 	unsigned long flags;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Install writable page 0 entry to set BIOS data area.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	local_flush_tlb();</span>
<span class="p_del">-</span>
 	/*
 	 * Paranoid:  Set warm reset code and vector here back
 	 * to default values.
<span class="p_header">diff --git a/arch/x86/kernel/vm86_32.c b/arch/x86/kernel/vm86_32.c</span>
<span class="p_header">index 524619351961..510e80da7de4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/vm86_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/vm86_32.c</span>
<span class="p_chunk">@@ -187,7 +187,7 @@</span> <span class="p_context"> static void mark_screen_rdonly(struct mm_struct *mm)</span>
 	pte_unmap_unlock(pte, ptl);
 out:
 	up_write(&amp;mm-&gt;mmap_sem);
<span class="p_del">-	flush_tlb();</span>
<span class="p_add">+	flush_tlb_mm_range(mm, 0xA0000, 0xA0000 + 32*PAGE_SIZE, 0UL);</span>
 }
 
 
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 684edebb4a0c..00045499f6c2 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -2383,9 +2383,21 @@</span> <span class="p_context"> static int rsm_load_seg_64(struct x86_emulate_ctxt *ctxt, u64 smbase, int n)</span>
 }
 
 static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,
<span class="p_del">-				     u64 cr0, u64 cr4)</span>
<span class="p_add">+				    u64 cr0, u64 cr3, u64 cr4)</span>
 {
 	int bad;
<span class="p_add">+	u64 pcid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* In order to later set CR4.PCIDE, CR3[11:0] must be zero.  */</span>
<span class="p_add">+	pcid = 0;</span>
<span class="p_add">+	if (cr4 &amp; X86_CR4_PCIDE) {</span>
<span class="p_add">+		pcid = cr3 &amp; 0xfff;</span>
<span class="p_add">+		cr3 &amp;= ~0xfff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	bad = ctxt-&gt;ops-&gt;set_cr(ctxt, 3, cr3);</span>
<span class="p_add">+	if (bad)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
 
 	/*
 	 * First enable PAE, long mode needs it before CR0.PG = 1 is set.
<span class="p_chunk">@@ -2404,6 +2416,12 @@</span> <span class="p_context"> static int rsm_enter_protected_mode(struct x86_emulate_ctxt *ctxt,</span>
 		bad = ctxt-&gt;ops-&gt;set_cr(ctxt, 4, cr4);
 		if (bad)
 			return X86EMUL_UNHANDLEABLE;
<span class="p_add">+		if (pcid) {</span>
<span class="p_add">+			bad = ctxt-&gt;ops-&gt;set_cr(ctxt, 3, cr3 | pcid);</span>
<span class="p_add">+			if (bad)</span>
<span class="p_add">+				return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 	}
 
 	return X86EMUL_CONTINUE;
<span class="p_chunk">@@ -2414,11 +2432,11 @@</span> <span class="p_context"> static int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 	struct desc_struct desc;
 	struct desc_ptr dt;
 	u16 selector;
<span class="p_del">-	u32 val, cr0, cr4;</span>
<span class="p_add">+	u32 val, cr0, cr3, cr4;</span>
 	int i;
 
 	cr0 =                      GET_SMSTATE(u32, smbase, 0x7ffc);
<span class="p_del">-	ctxt-&gt;ops-&gt;set_cr(ctxt, 3, GET_SMSTATE(u32, smbase, 0x7ff8));</span>
<span class="p_add">+	cr3 =                      GET_SMSTATE(u32, smbase, 0x7ff8);</span>
 	ctxt-&gt;eflags =             GET_SMSTATE(u32, smbase, 0x7ff4) | X86_EFLAGS_FIXED;
 	ctxt-&gt;_eip =               GET_SMSTATE(u32, smbase, 0x7ff0);
 
<span class="p_chunk">@@ -2460,14 +2478,14 @@</span> <span class="p_context"> static int rsm_load_state_32(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 
 	ctxt-&gt;ops-&gt;set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7ef8));
 
<span class="p_del">-	return rsm_enter_protected_mode(ctxt, cr0, cr4);</span>
<span class="p_add">+	return rsm_enter_protected_mode(ctxt, cr0, cr3, cr4);</span>
 }
 
 static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)
 {
 	struct desc_struct desc;
 	struct desc_ptr dt;
<span class="p_del">-	u64 val, cr0, cr4;</span>
<span class="p_add">+	u64 val, cr0, cr3, cr4;</span>
 	u32 base3;
 	u16 selector;
 	int i, r;
<span class="p_chunk">@@ -2484,7 +2502,7 @@</span> <span class="p_context"> static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 	ctxt-&gt;ops-&gt;set_dr(ctxt, 7, (val &amp; DR7_VOLATILE) | DR7_FIXED_1);
 
 	cr0 =                       GET_SMSTATE(u64, smbase, 0x7f58);
<span class="p_del">-	ctxt-&gt;ops-&gt;set_cr(ctxt, 3,  GET_SMSTATE(u64, smbase, 0x7f50));</span>
<span class="p_add">+	cr3 =                       GET_SMSTATE(u64, smbase, 0x7f50);</span>
 	cr4 =                       GET_SMSTATE(u64, smbase, 0x7f48);
 	ctxt-&gt;ops-&gt;set_smbase(ctxt, GET_SMSTATE(u32, smbase, 0x7f00));
 	val =                       GET_SMSTATE(u64, smbase, 0x7ed0);
<span class="p_chunk">@@ -2512,7 +2530,7 @@</span> <span class="p_context"> static int rsm_load_state_64(struct x86_emulate_ctxt *ctxt, u64 smbase)</span>
 	dt.address =                GET_SMSTATE(u64, smbase, 0x7e68);
 	ctxt-&gt;ops-&gt;set_gdt(ctxt, &amp;dt);
 
<span class="p_del">-	r = rsm_enter_protected_mode(ctxt, cr0, cr4);</span>
<span class="p_add">+	r = rsm_enter_protected_mode(ctxt, cr0, cr3, cr4);</span>
 	if (r != X86EMUL_CONTINUE)
 		return r;
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index e5f44f33de89..796f1ec67469 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -6941,7 +6941,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_ioctl_set_regs(struct kvm_vcpu *vcpu, struct kvm_regs *regs)</span>
 #endif
 
 	kvm_rip_write(vcpu, regs-&gt;rip);
<span class="p_del">-	kvm_set_rflags(vcpu, regs-&gt;rflags);</span>
<span class="p_add">+	kvm_set_rflags(vcpu, regs-&gt;rflags | X86_EFLAGS_FIXED);</span>
 
 	vcpu-&gt;arch.exception.pending = false;
 
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 3aebbd6c6f5f..ed4b372860e4 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -753,10 +753,8 @@</span> <span class="p_context"> void __init zone_sizes_init(void)</span>
 }
 
 DEFINE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate) = {
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	.active_mm = &amp;init_mm,
 	.state = 0,
<span class="p_del">-#endif</span>
 	.cr4 = ~0UL,	/* fail hard if we screw up cr4 shadow initialization */
 };
 EXPORT_SYMBOL_GPL(cpu_tlbstate);
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 45ba87466e6a..7a4cdb632508 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/debugfs.h&gt;
 
 /*
<span class="p_del">- *	Smarter SMP flushing macros.</span>
<span class="p_add">+ *	TLB flushing, formerly SMP-only</span>
  *		c/o Linus Torvalds.
  *
  *	These mean you can really definitely utterly forget about
<span class="p_chunk">@@ -28,8 +28,6 @@</span> <span class="p_context"></span>
  *	Implement flush IPI by CALL_FUNCTION_VECTOR, Alex Shi
  */
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-</span>
 struct flush_tlb_info {
 	struct mm_struct *flush_mm;
 	unsigned long flush_start;
<span class="p_chunk">@@ -59,8 +57,6 @@</span> <span class="p_context"> void leave_mm(int cpu)</span>
 }
 EXPORT_SYMBOL_GPL(leave_mm);
 
<span class="p_del">-#endif /* CONFIG_SMP */</span>
<span class="p_del">-</span>
 void switch_mm(struct mm_struct *prev, struct mm_struct *next,
 	       struct task_struct *tsk)
 {
<span class="p_chunk">@@ -77,10 +73,8 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 	unsigned cpu = smp_processor_id();
 
 	if (likely(prev != next)) {
<span class="p_del">-#ifdef CONFIG_SMP</span>
 		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);
 		this_cpu_write(cpu_tlbstate.active_mm, next);
<span class="p_del">-#endif</span>
 		cpumask_set_cpu(cpu, mm_cpumask(next));
 
 		/*
<span class="p_chunk">@@ -137,9 +131,7 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 		if (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))
 			load_mm_ldt(next);
 #endif
<span class="p_del">-	}</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-	  else {</span>
<span class="p_add">+	} else {</span>
 		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);
 		BUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);
 
<span class="p_chunk">@@ -166,11 +158,8 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 			load_mm_ldt(next);
 		}
 	}
<span class="p_del">-#endif</span>
 }
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-</span>
 /*
  * The flush IPI assumes that a thread switch happens in this order:
  * [cpu0: the cpu that switches]
<span class="p_chunk">@@ -272,23 +261,6 @@</span> <span class="p_context"> void native_flush_tlb_others(const struct cpumask *cpumask,</span>
 	smp_call_function_many(cpumask, flush_tlb_func, &amp;info, 1);
 }
 
<span class="p_del">-void flush_tlb_current_task(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mm_struct *mm = current-&gt;mm;</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This is an implicit full barrier that synchronizes with switch_mm. */</span>
<span class="p_del">-	local_flush_tlb();</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);</span>
<span class="p_del">-	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)</span>
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, 0UL, TLB_FLUSH_ALL);</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * See Documentation/x86/tlb.txt for details.  We choose 33
  * because it is large enough to cover the vast majority (at
<span class="p_chunk">@@ -309,6 +281,12 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 	unsigned long base_pages_to_flush = TLB_FLUSH_ALL;
 
 	preempt_disable();
<span class="p_add">+</span>
<span class="p_add">+	if ((end != TLB_FLUSH_ALL) &amp;&amp; !(vmflag &amp; VM_HUGETLB))</span>
<span class="p_add">+		base_pages_to_flush = (end - start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (base_pages_to_flush &gt; tlb_single_page_flush_ceiling)</span>
<span class="p_add">+		base_pages_to_flush = TLB_FLUSH_ALL;</span>
<span class="p_add">+</span>
 	if (current-&gt;active_mm != mm) {
 		/* Synchronize with switch_mm. */
 		smp_mb();
<span class="p_chunk">@@ -325,15 +303,11 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 		goto out;
 	}
 
<span class="p_del">-	if ((end != TLB_FLUSH_ALL) &amp;&amp; !(vmflag &amp; VM_HUGETLB))</span>
<span class="p_del">-		base_pages_to_flush = (end - start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-</span>
 	/*
 	 * Both branches below are implicit full barriers (MOV to CR or
 	 * INVLPG) that synchronize with switch_mm.
 	 */
<span class="p_del">-	if (base_pages_to_flush &gt; tlb_single_page_flush_ceiling) {</span>
<span class="p_del">-		base_pages_to_flush = TLB_FLUSH_ALL;</span>
<span class="p_add">+	if (base_pages_to_flush == TLB_FLUSH_ALL) {</span>
 		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
 		local_flush_tlb();
 	} else {
<span class="p_chunk">@@ -354,33 +328,6 @@</span> <span class="p_context"> out:</span>
 	preempt_enable();
 }
 
<span class="p_del">-void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mm_struct *mm = vma-&gt;vm_mm;</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (current-&gt;active_mm == mm) {</span>
<span class="p_del">-		if (current-&gt;mm) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Implicit full barrier (INVLPG) that synchronizes</span>
<span class="p_del">-			 * with switch_mm.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			__flush_tlb_one(start);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			leave_mm(smp_processor_id());</span>
<span class="p_del">-</span>
<span class="p_del">-			/* Synchronize with switch_mm. */</span>
<span class="p_del">-			smp_mb();</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)</span>
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, start, start + PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void do_flush_tlb_all(void *info)
 {
 	count_vm_tlb_event(NR_TLB_REMOTE_FLUSH_RECEIVED);
<span class="p_chunk">@@ -465,5 +412,3 @@</span> <span class="p_context"> static int __init create_tlb_single_page_flush_ceiling(void)</span>
 	return 0;
 }
 late_initcall(create_tlb_single_page_flush_ceiling);
<span class="p_del">-</span>
<span class="p_del">-#endif /* CONFIG_SMP */</span>
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index ffa41591bff9..cbef64b508e1 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -433,6 +433,12 @@</span> <span class="p_context"> static void __init xen_init_cpuid_mask(void)</span>
 		~((1 &lt;&lt; X86_FEATURE_MTRR) |  /* disable MTRR */
 		  (1 &lt;&lt; X86_FEATURE_ACC));   /* thermal monitoring */
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen PV would need some work to support PCID: CR3 handling as well</span>
<span class="p_add">+	 * as xen_flush_tlb_others() would need updating.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cpuid_leaf1_ecx_mask &amp;= ~(1 &lt;&lt; (X86_FEATURE_PCID % 32));  /* disable PCID */</span>
<span class="p_add">+</span>
 	if (!xen_initial_domain())
 		cpuid_leaf1_edx_mask &amp;=
 			~((1 &lt;&lt; X86_FEATURE_ACPI));  /* disable ACPI */
<span class="p_header">diff --git a/crypto/mcryptd.c b/crypto/mcryptd.c</span>
<span class="p_header">index b4f3930266b1..f620fe09d20a 100644</span>
<span class="p_header">--- a/crypto/mcryptd.c</span>
<span class="p_header">+++ b/crypto/mcryptd.c</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> static int mcryptd_init_queue(struct mcryptd_queue *queue,</span>
 		pr_debug(&quot;cpu_queue #%d %p\n&quot;, cpu, queue-&gt;cpu_queue);
 		crypto_init_queue(&amp;cpu_queue-&gt;queue, max_cpu_qlen);
 		INIT_WORK(&amp;cpu_queue-&gt;work, mcryptd_queue_worker);
<span class="p_add">+		spin_lock_init(&amp;cpu_queue-&gt;q_lock);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -103,15 +104,16 @@</span> <span class="p_context"> static int mcryptd_enqueue_request(struct mcryptd_queue *queue,</span>
 	int cpu, err;
 	struct mcryptd_cpu_queue *cpu_queue;
 
<span class="p_del">-	cpu = get_cpu();</span>
<span class="p_del">-	cpu_queue = this_cpu_ptr(queue-&gt;cpu_queue);</span>
<span class="p_del">-	rctx-&gt;tag.cpu = cpu;</span>
<span class="p_add">+	cpu_queue = raw_cpu_ptr(queue-&gt;cpu_queue);</span>
<span class="p_add">+	spin_lock(&amp;cpu_queue-&gt;q_lock);</span>
<span class="p_add">+	cpu = smp_processor_id();</span>
<span class="p_add">+	rctx-&gt;tag.cpu = smp_processor_id();</span>
 
 	err = crypto_enqueue_request(&amp;cpu_queue-&gt;queue, request);
 	pr_debug(&quot;enqueue request: cpu %d cpu_queue %p request %p\n&quot;,
 		 cpu, cpu_queue, request);
<span class="p_add">+	spin_unlock(&amp;cpu_queue-&gt;q_lock);</span>
 	queue_work_on(cpu, kcrypto_wq, &amp;cpu_queue-&gt;work);
<span class="p_del">-	put_cpu();</span>
 
 	return err;
 }
<span class="p_chunk">@@ -164,16 +166,11 @@</span> <span class="p_context"> static void mcryptd_queue_worker(struct work_struct *work)</span>
 	cpu_queue = container_of(work, struct mcryptd_cpu_queue, work);
 	i = 0;
 	while (i &lt; MCRYPTD_BATCH || single_task_running()) {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * preempt_disable/enable is used to prevent</span>
<span class="p_del">-		 * being preempted by mcryptd_enqueue_request()</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		local_bh_disable();</span>
<span class="p_del">-		preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_bh(&amp;cpu_queue-&gt;q_lock);</span>
 		backlog = crypto_get_backlog(&amp;cpu_queue-&gt;queue);
 		req = crypto_dequeue_request(&amp;cpu_queue-&gt;queue);
<span class="p_del">-		preempt_enable();</span>
<span class="p_del">-		local_bh_enable();</span>
<span class="p_add">+		spin_unlock_bh(&amp;cpu_queue-&gt;q_lock);</span>
 
 		if (!req) {
 			mcryptd_opportunistic_flush();
<span class="p_chunk">@@ -188,7 +185,7 @@</span> <span class="p_context"> static void mcryptd_queue_worker(struct work_struct *work)</span>
 		++i;
 	}
 	if (cpu_queue-&gt;queue.qlen)
<span class="p_del">-		queue_work(kcrypto_wq, &amp;cpu_queue-&gt;work);</span>
<span class="p_add">+		queue_work_on(smp_processor_id(), kcrypto_wq, &amp;cpu_queue-&gt;work);</span>
 }
 
 void mcryptd_flusher(struct work_struct *__work)
<span class="p_header">diff --git a/drivers/acpi/apei/erst.c b/drivers/acpi/apei/erst.c</span>
<span class="p_header">index 6682c5daf742..4c9be45ea328 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/erst.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/erst.c</span>
<span class="p_chunk">@@ -1020,7 +1020,7 @@</span> <span class="p_context"> skip:</span>
 	/* The record may be cleared by others, try read next record */
 	if (len == -ENOENT)
 		goto skip;
<span class="p_del">-	else if (len &lt; sizeof(*rcd)) {</span>
<span class="p_add">+	else if (len &lt; 0 || len &lt; sizeof(*rcd)) {</span>
 		rc = -EIO;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/cq.c b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">index bc147582bed9..6d62b69c898e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_chunk">@@ -579,10 +579,10 @@</span> <span class="p_context"> static int poll_cq(struct t4_wq *wq, struct t4_cq *cq, struct t4_cqe *cqe,</span>
 			ret = -EAGAIN;
 			goto skip_cqe;
 		}
<span class="p_del">-		if (unlikely((CQE_WRID_MSN(hw_cqe) != (wq-&gt;rq.msn)))) {</span>
<span class="p_add">+		if (unlikely(!CQE_STATUS(hw_cqe) &amp;&amp;</span>
<span class="p_add">+			     CQE_WRID_MSN(hw_cqe) != wq-&gt;rq.msn)) {</span>
 			t4_set_wq_in_error(wq);
<span class="p_del">-			hw_cqe-&gt;header |= htonl(CQE_STATUS_V(T4_ERR_MSN));</span>
<span class="p_del">-			goto proc_cqe;</span>
<span class="p_add">+			hw_cqe-&gt;header |= cpu_to_be32(CQE_STATUS_V(T4_ERR_MSN));</span>
 		}
 		goto proc_cqe;
 	}
<span class="p_header">diff --git a/drivers/mfd/cros_ec_spi.c b/drivers/mfd/cros_ec_spi.c</span>
<span class="p_header">index 6a0f6ec67c6b..ee7847a1ca06 100644</span>
<span class="p_header">--- a/drivers/mfd/cros_ec_spi.c</span>
<span class="p_header">+++ b/drivers/mfd/cros_ec_spi.c</span>
<span class="p_chunk">@@ -660,6 +660,7 @@</span> <span class="p_context"> static int cros_ec_spi_probe(struct spi_device *spi)</span>
 			   sizeof(struct ec_response_get_protocol_info);
 	ec_dev-&gt;dout_size = sizeof(struct ec_host_request);
 
<span class="p_add">+	ec_spi-&gt;last_transfer_ns = ktime_get_ns();</span>
 
 	err = cros_ec_register(ec_dev);
 	if (err) {
<span class="p_header">diff --git a/drivers/mfd/twl4030-audio.c b/drivers/mfd/twl4030-audio.c</span>
<span class="p_header">index 0a1606480023..cc832d309599 100644</span>
<span class="p_header">--- a/drivers/mfd/twl4030-audio.c</span>
<span class="p_header">+++ b/drivers/mfd/twl4030-audio.c</span>
<span class="p_chunk">@@ -159,13 +159,18 @@</span> <span class="p_context"> unsigned int twl4030_audio_get_mclk(void)</span>
 EXPORT_SYMBOL_GPL(twl4030_audio_get_mclk);
 
 static bool twl4030_audio_has_codec(struct twl4030_audio_data *pdata,
<span class="p_del">-			      struct device_node *node)</span>
<span class="p_add">+			      struct device_node *parent)</span>
 {
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+</span>
 	if (pdata &amp;&amp; pdata-&gt;codec)
 		return true;
 
<span class="p_del">-	if (of_find_node_by_name(node, &quot;codec&quot;))</span>
<span class="p_add">+	node = of_get_child_by_name(parent, &quot;codec&quot;);</span>
<span class="p_add">+	if (node) {</span>
<span class="p_add">+		of_node_put(node);</span>
 		return true;
<span class="p_add">+	}</span>
 
 	return false;
 }
<span class="p_header">diff --git a/drivers/mfd/twl6040.c b/drivers/mfd/twl6040.c</span>
<span class="p_header">index 08a693cd38cc..72aab60ae846 100644</span>
<span class="p_header">--- a/drivers/mfd/twl6040.c</span>
<span class="p_header">+++ b/drivers/mfd/twl6040.c</span>
<span class="p_chunk">@@ -97,12 +97,16 @@</span> <span class="p_context"> static struct reg_sequence twl6040_patch[] = {</span>
 };
 
 
<span class="p_del">-static bool twl6040_has_vibra(struct device_node *node)</span>
<span class="p_add">+static bool twl6040_has_vibra(struct device_node *parent)</span>
 {
<span class="p_del">-#ifdef CONFIG_OF</span>
<span class="p_del">-	if (of_find_node_by_name(node, &quot;vibra&quot;))</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_get_child_by_name(parent, &quot;vibra&quot;);</span>
<span class="p_add">+	if (node) {</span>
<span class="p_add">+		of_node_put(node);</span>
 		return true;
<span class="p_del">-#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return false;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">index 3613469dc5c6..ab53e0cfb4dc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_chunk">@@ -14228,7 +14228,9 @@</span> <span class="p_context"> static int tg3_change_mtu(struct net_device *dev, int new_mtu)</span>
 	/* Reset PHY, otherwise the read DMA engine will be in a mode that
 	 * breaks all requests to 256 bytes.
 	 */
<span class="p_del">-	if (tg3_asic_rev(tp) == ASIC_REV_57766)</span>
<span class="p_add">+	if (tg3_asic_rev(tp) == ASIC_REV_57766 ||</span>
<span class="p_add">+	    tg3_asic_rev(tp) == ASIC_REV_5717 ||</span>
<span class="p_add">+	    tg3_asic_rev(tp) == ASIC_REV_5719)</span>
 		reset_phy = true;
 
 	err = tg3_restart_hw(tp, reset_phy);
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvmdio.c b/drivers/net/ethernet/marvell/mvmdio.c</span>
<span class="p_header">index fc2fb25343f4..c122b3b99cd8 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvmdio.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvmdio.c</span>
<span class="p_chunk">@@ -241,7 +241,8 @@</span> <span class="p_context"> static int orion_mdio_probe(struct platform_device *pdev)</span>
 			dev-&gt;regs + MVMDIO_ERR_INT_MASK);
 
 	} else if (dev-&gt;err_interrupt == -EPROBE_DEFER) {
<span class="p_del">-		return -EPROBE_DEFER;</span>
<span class="p_add">+		ret = -EPROBE_DEFER;</span>
<span class="p_add">+		goto out_mdio;</span>
 	}
 
 	mutex_init(&amp;dev-&gt;lock);
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 15056f06754a..7430dd44019e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -914,6 +914,10 @@</span> <span class="p_context"> static void mvneta_port_disable(struct mvneta_port *pp)</span>
 	val &amp;= ~MVNETA_GMAC0_PORT_ENABLE;
 	mvreg_write(pp, MVNETA_GMAC_CTRL_0, val);
 
<span class="p_add">+	pp-&gt;link = 0;</span>
<span class="p_add">+	pp-&gt;duplex = -1;</span>
<span class="p_add">+	pp-&gt;speed = 0;</span>
<span class="p_add">+</span>
 	udelay(200);
 }
 
<span class="p_header">diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c</span>
<span class="p_header">index c8b85f1069ff..920391165f18 100644</span>
<span class="p_header">--- a/drivers/net/phy/micrel.c</span>
<span class="p_header">+++ b/drivers/net/phy/micrel.c</span>
<span class="p_chunk">@@ -541,6 +541,7 @@</span> <span class="p_context"> static int ksz9031_read_status(struct phy_device *phydev)</span>
 		phydev-&gt;link = 0;
 		if (phydev-&gt;drv-&gt;config_intr &amp;&amp; phy_interrupt_is_valid(phydev))
 			phydev-&gt;drv-&gt;config_intr(phydev);
<span class="p_add">+		return genphy_config_aneg(phydev);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index 2cbecbda1ae3..b0ea8dee5f06 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -737,6 +737,7 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 	{QMI_FIXED_INTF(0x1199, 0x9079, 10)},	/* Sierra Wireless EM74xx */
 	{QMI_FIXED_INTF(0x1199, 0x907b, 8)},	/* Sierra Wireless EM74xx */
 	{QMI_FIXED_INTF(0x1199, 0x907b, 10)},	/* Sierra Wireless EM74xx */
<span class="p_add">+	{QMI_FIXED_INTF(0x1199, 0x9091, 8)},	/* Sierra Wireless EM7565 */</span>
 	{QMI_FIXED_INTF(0x1bbb, 0x011e, 4)},	/* Telekom Speedstick LTE II (Alcatel One Touch L100V LTE) */
 	{QMI_FIXED_INTF(0x1bbb, 0x0203, 2)},	/* Alcatel L800MA */
 	{QMI_FIXED_INTF(0x2357, 0x0201, 4)},	/* TP-LINK HSUPA Modem MA180 */
<span class="p_header">diff --git a/drivers/parisc/lba_pci.c b/drivers/parisc/lba_pci.c</span>
<span class="p_header">index d0c2759076a2..312cb5b74dec 100644</span>
<span class="p_header">--- a/drivers/parisc/lba_pci.c</span>
<span class="p_header">+++ b/drivers/parisc/lba_pci.c</span>
<span class="p_chunk">@@ -1654,3 +1654,36 @@</span> <span class="p_context"> void lba_set_iregs(struct parisc_device *lba, u32 ibase, u32 imask)</span>
 	iounmap(base_addr);
 }
 
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The design of the Diva management card in rp34x0 machines (rp3410, rp3440)</span>
<span class="p_add">+ * seems rushed, so that many built-in components simply don&#39;t work.</span>
<span class="p_add">+ * The following quirks disable the serial AUX port and the built-in ATI RV100</span>
<span class="p_add">+ * Radeon 7000 graphics card which both don&#39;t have any external connectors and</span>
<span class="p_add">+ * thus are useless, and even worse, e.g. the AUX port occupies ttyS0 and as</span>
<span class="p_add">+ * such makes those machines the only PARISC machines on which we can&#39;t use</span>
<span class="p_add">+ * ttyS0 as boot console.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void quirk_diva_ati_card(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dev-&gt;subsystem_vendor != PCI_VENDOR_ID_HP ||</span>
<span class="p_add">+	    dev-&gt;subsystem_device != 0x1292)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;Hiding Diva built-in ATI card&quot;);</span>
<span class="p_add">+	dev-&gt;device = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATI, PCI_DEVICE_ID_ATI_RADEON_QY,</span>
<span class="p_add">+	quirk_diva_ati_card);</span>
<span class="p_add">+</span>
<span class="p_add">+static void quirk_diva_aux_disable(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dev-&gt;subsystem_vendor != PCI_VENDOR_ID_HP ||</span>
<span class="p_add">+	    dev-&gt;subsystem_device != 0x1291)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;Hiding Diva built-in AUX serial device&quot;);</span>
<span class="p_add">+	dev-&gt;device = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_HP, PCI_DEVICE_ID_HP_DIVA_AUX,</span>
<span class="p_add">+	quirk_diva_aux_disable);</span>
<span class="p_header">diff --git a/drivers/pci/pci-driver.c b/drivers/pci/pci-driver.c</span>
<span class="p_header">index fca925543fae..32bd8ab79d53 100644</span>
<span class="p_header">--- a/drivers/pci/pci-driver.c</span>
<span class="p_header">+++ b/drivers/pci/pci-driver.c</span>
<span class="p_chunk">@@ -944,7 +944,12 @@</span> <span class="p_context"> static int pci_pm_thaw_noirq(struct device *dev)</span>
 	if (pci_has_legacy_pm_support(pci_dev))
 		return pci_legacy_resume_early(dev);
 
<span class="p_del">-	pci_update_current_state(pci_dev, PCI_D0);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * pci_restore_state() requires the device to be in D0 (because of MSI</span>
<span class="p_add">+	 * restoration among other things), so force it into D0 in case the</span>
<span class="p_add">+	 * driver&#39;s &quot;freeze&quot; callbacks put it into a low-power state directly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pci_set_power_state(pci_dev, PCI_D0);</span>
 	pci_restore_state(pci_dev);
 
 	if (drv &amp;&amp; drv-&gt;pm &amp;&amp; drv-&gt;pm-&gt;thaw_noirq)
<span class="p_header">diff --git a/drivers/spi/spi-xilinx.c b/drivers/spi/spi-xilinx.c</span>
<span class="p_header">index 3009121173cd..3c6ea5c3ddd2 100644</span>
<span class="p_header">--- a/drivers/spi/spi-xilinx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-xilinx.c</span>
<span class="p_chunk">@@ -271,6 +271,7 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 	while (remaining_words) {
 		int n_words, tx_words, rx_words;
 		u32 sr;
<span class="p_add">+		int stalled;</span>
 
 		n_words = min(remaining_words, xspi-&gt;buffer_size);
 
<span class="p_chunk">@@ -299,7 +300,17 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 
 		/* Read out all the data from the Rx FIFO */
 		rx_words = n_words;
<span class="p_add">+		stalled = 10;</span>
 		while (rx_words) {
<span class="p_add">+			if (rx_words == n_words &amp;&amp; !(stalled--) &amp;&amp;</span>
<span class="p_add">+			    !(sr &amp; XSPI_SR_TX_EMPTY_MASK) &amp;&amp;</span>
<span class="p_add">+			    (sr &amp; XSPI_SR_RX_EMPTY_MASK)) {</span>
<span class="p_add">+				dev_err(&amp;spi-&gt;dev,</span>
<span class="p_add">+					&quot;Detected stall. Check C_SPI_MODE and C_SPI_MEMORY\n&quot;);</span>
<span class="p_add">+				xspi_init_hw(xspi);</span>
<span class="p_add">+				return -EIO;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if ((sr &amp; XSPI_SR_TX_EMPTY_MASK) &amp;&amp; (rx_words &gt; 1)) {
 				xilinx_spi_rx(xspi);
 				rx_words--;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index 84e71bd19082..41dda25da049 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -1801,7 +1801,7 @@</span> <span class="p_context"> static void n_tty_set_termios(struct tty_struct *tty, struct ktermios *old)</span>
 {
 	struct n_tty_data *ldata = tty-&gt;disc_data;
 
<span class="p_del">-	if (!old || (old-&gt;c_lflag ^ tty-&gt;termios.c_lflag) &amp; ICANON) {</span>
<span class="p_add">+	if (!old || (old-&gt;c_lflag ^ tty-&gt;termios.c_lflag) &amp; (ICANON | EXTPROC)) {</span>
 		bitmap_zero(ldata-&gt;read_flags, N_TTY_BUF_SIZE);
 		ldata-&gt;line_start = ldata-&gt;read_tail;
 		if (!L_ICANON(tty) || !read_cnt(ldata)) {
<span class="p_chunk">@@ -2493,7 +2493,7 @@</span> <span class="p_context"> static int n_tty_ioctl(struct tty_struct *tty, struct file *file,</span>
 		return put_user(tty_chars_in_buffer(tty), (int __user *) arg);
 	case TIOCINQ:
 		down_write(&amp;tty-&gt;termios_rwsem);
<span class="p_del">-		if (L_ICANON(tty))</span>
<span class="p_add">+		if (L_ICANON(tty) &amp;&amp; !L_EXTPROC(tty))</span>
 			retval = inq_canon(ldata);
 		else
 			retval = read_cnt(ldata);
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index f6fde903fcad..22dcccf2d286 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -973,7 +973,7 @@</span> <span class="p_context"> int usb_get_bos_descriptor(struct usb_device *dev)</span>
 		case USB_SSP_CAP_TYPE:
 			ssp_cap = (struct usb_ssp_cap_descriptor *)buffer;
 			ssac = (le32_to_cpu(ssp_cap-&gt;bmAttributes) &amp;
<span class="p_del">-				USB_SSP_SUBLINK_SPEED_ATTRIBS) + 1;</span>
<span class="p_add">+				USB_SSP_SUBLINK_SPEED_ATTRIBS);</span>
 			if (length &gt;= USB_DT_USB_SSP_CAP_SIZE(ssac))
 				dev-&gt;bos-&gt;ssp_cap = ssp_cap;
 			break;
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 50010282c010..c05c4f877750 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -57,10 +57,11 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Microsoft LifeCam-VX700 v2.0 */
 	{ USB_DEVICE(0x045e, 0x0770), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_del">-	/* Logitech HD Pro Webcams C920, C920-C and C930e */</span>
<span class="p_add">+	/* Logitech HD Pro Webcams C920, C920-C, C925e and C930e */</span>
 	{ USB_DEVICE(0x046d, 0x082d), .driver_info = USB_QUIRK_DELAY_INIT },
 	{ USB_DEVICE(0x046d, 0x0841), .driver_info = USB_QUIRK_DELAY_INIT },
 	{ USB_DEVICE(0x046d, 0x0843), .driver_info = USB_QUIRK_DELAY_INIT },
<span class="p_add">+	{ USB_DEVICE(0x046d, 0x085b), .driver_info = USB_QUIRK_DELAY_INIT },</span>
 
 	/* Logitech ConferenceCam CC3000e */
 	{ USB_DEVICE(0x046d, 0x0847), .driver_info = USB_QUIRK_DELAY_INIT },
<span class="p_chunk">@@ -154,6 +155,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Genesys Logic hub, internally used by KY-688 USB 3.1 Type-C Hub */
 	{ USB_DEVICE(0x05e3, 0x0612), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_add">+	/* ELSA MicroLink 56K */</span>
<span class="p_add">+	{ USB_DEVICE(0x05cc, 0x2267), .driver_info = USB_QUIRK_RESET_RESUME },</span>
<span class="p_add">+</span>
 	/* Genesys Logic hub, internally used by Moshi USB to Ethernet Adapter */
 	{ USB_DEVICE(0x05e3, 0x0616), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index e8f990642281..cbf3be66f89c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -184,6 +184,9 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 		xhci-&gt;quirks |= XHCI_BROKEN_STREAMS;
 	}
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_RENESAS &amp;&amp;</span>
<span class="p_add">+			pdev-&gt;device == 0x0014)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_RENESAS &amp;&amp;
 			pdev-&gt;device == 0x0015)
 		xhci-&gt;quirks |= XHCI_RESET_ON_RESUME;
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 30344efc123f..64fe9dc25ed4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1017,6 +1017,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_BT_USB_PID) },
 	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_WL_USB_PID) },
<span class="p_add">+	{ USB_DEVICE(AIRBUS_DS_VID, AIRBUS_DS_P8GR) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index f9d15bd62785..543d2801632b 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -913,6 +913,12 @@</span> <span class="p_context"></span>
 #define ICPDAS_I7561U_PID		0x0104
 #define ICPDAS_I7563U_PID		0x0105
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Airbus Defence and Space</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define AIRBUS_DS_VID			0x1e8e  /* Vendor ID */</span>
<span class="p_add">+#define AIRBUS_DS_P8GR			0x6001  /* Tetra P8GR */</span>
<span class="p_add">+</span>
 /*
  * RT Systems programming cables for various ham radios
  */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index ffa8ec917ff5..a818c43a02ec 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -236,6 +236,8 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 /* These Quectel products use Qualcomm&#39;s vendor ID */
 #define QUECTEL_PRODUCT_UC20			0x9003
 #define QUECTEL_PRODUCT_UC15			0x9090
<span class="p_add">+/* These Yuga products use Qualcomm&#39;s vendor ID */</span>
<span class="p_add">+#define YUGA_PRODUCT_CLM920_NC5			0x9625</span>
 
 #define QUECTEL_VENDOR_ID			0x2c7c
 /* These Quectel products use Quectel&#39;s vendor ID */
<span class="p_chunk">@@ -283,6 +285,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE922_USBCFG3		0x1043
 #define TELIT_PRODUCT_LE922_USBCFG5		0x1045
 #define TELIT_PRODUCT_ME910			0x1100
<span class="p_add">+#define TELIT_PRODUCT_ME910_DUAL_MODEM		0x1101</span>
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
 #define TELIT_PRODUCT_LE910_USBCFG4		0x1206
<span class="p_chunk">@@ -648,6 +651,11 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_me910_blacklist = {</span>
 	.reserved = BIT(1) | BIT(3),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_me910_dual_modem_blacklist = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le910_blacklist = {
 	.sendsetup = BIT(0),
 	.reserved = BIT(1) | BIT(2),
<span class="p_chunk">@@ -677,6 +685,10 @@</span> <span class="p_context"> static const struct option_blacklist_info cinterion_rmnet2_blacklist = {</span>
 	.reserved = BIT(4) | BIT(5),
 };
 
<span class="p_add">+static const struct option_blacklist_info yuga_clm920_nc5_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(1) | BIT(4),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1181,6 +1193,9 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC15)},
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC20),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_add">+	/* Yuga products use Qualcomm vendor ID */</span>
<span class="p_add">+	{ USB_DEVICE(QUALCOMM_VENDOR_ID, YUGA_PRODUCT_CLM920_NC5),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;yuga_clm920_nc5_blacklist },</span>
 	/* Quectel products using Quectel vendor ID */
 	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC21),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_chunk">@@ -1247,6 +1262,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_ME910),
 		.driver_info = (kernel_ulong_t)&amp;telit_me910_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_ME910_DUAL_MODEM),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_me910_dual_modem_blacklist },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 4516291df1b8..fb6dc16c754a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -166,6 +166,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x1199, 0x9079)},	/* Sierra Wireless EM74xx */
 	{DEVICE_SWI(0x1199, 0x907a)},	/* Sierra Wireless EM74xx QDL */
 	{DEVICE_SWI(0x1199, 0x907b)},	/* Sierra Wireless EM74xx */
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9090)},	/* Sierra Wireless EM7565 QDL */</span>
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9091)},	/* Sierra Wireless EM7565 */</span>
 	{DEVICE_SWI(0x413c, 0x81a2)},	/* Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a3)},	/* Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a4)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
<span class="p_chunk">@@ -346,6 +348,7 @@</span> <span class="p_context"> static int qcprobe(struct usb_serial *serial, const struct usb_device_id *id)</span>
 			break;
 		case 2:
 			dev_dbg(dev, &quot;NMEA GPS interface found\n&quot;);
<span class="p_add">+			sendsetup = true;</span>
 			break;
 		case 3:
 			dev_dbg(dev, &quot;Modem port found\n&quot;);
<span class="p_header">diff --git a/drivers/usb/usbip/stub_main.c b/drivers/usb/usbip/stub_main.c</span>
<span class="p_header">index af10f7b131a4..325b4c05acdd 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/stub_main.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/stub_main.c</span>
<span class="p_chunk">@@ -252,11 +252,12 @@</span> <span class="p_context"> void stub_device_cleanup_urbs(struct stub_device *sdev)</span>
 	struct stub_priv *priv;
 	struct urb *urb;
 
<span class="p_del">-	dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;free sdev %p\n&quot;, sdev);</span>
<span class="p_add">+	dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;Stub device cleaning up urbs\n&quot;);</span>
 
 	while ((priv = stub_priv_pop(sdev))) {
 		urb = priv-&gt;urb;
<span class="p_del">-		dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;free urb %p\n&quot;, urb);</span>
<span class="p_add">+		dev_dbg(&amp;sdev-&gt;udev-&gt;dev, &quot;free urb seqnum %lu\n&quot;,</span>
<span class="p_add">+			priv-&gt;seqnum);</span>
 		usb_kill_urb(urb);
 
 		kmem_cache_free(stub_priv_cache, priv);
<span class="p_header">diff --git a/drivers/usb/usbip/stub_rx.c b/drivers/usb/usbip/stub_rx.c</span>
<span class="p_header">index 00e475c51a12..7de54a66044f 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/stub_rx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/stub_rx.c</span>
<span class="p_chunk">@@ -230,9 +230,6 @@</span> <span class="p_context"> static int stub_recv_cmd_unlink(struct stub_device *sdev,</span>
 		if (priv-&gt;seqnum != pdu-&gt;u.cmd_unlink.seqnum)
 			continue;
 
<span class="p_del">-		dev_info(&amp;priv-&gt;urb-&gt;dev-&gt;dev, &quot;unlink urb %p\n&quot;,</span>
<span class="p_del">-			 priv-&gt;urb);</span>
<span class="p_del">-</span>
 		/*
 		 * This matched urb is not completed yet (i.e., be in
 		 * flight in usb hcd hardware/driver). Now we are
<span class="p_chunk">@@ -271,8 +268,8 @@</span> <span class="p_context"> static int stub_recv_cmd_unlink(struct stub_device *sdev,</span>
 		ret = usb_unlink_urb(priv-&gt;urb);
 		if (ret != -EINPROGRESS)
 			dev_err(&amp;priv-&gt;urb-&gt;dev-&gt;dev,
<span class="p_del">-				&quot;failed to unlink a urb %p, ret %d\n&quot;,</span>
<span class="p_del">-				priv-&gt;urb, ret);</span>
<span class="p_add">+				&quot;failed to unlink a urb # %lu, ret %d\n&quot;,</span>
<span class="p_add">+				priv-&gt;seqnum, ret);</span>
 
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/usb/usbip/stub_tx.c b/drivers/usb/usbip/stub_tx.c</span>
<span class="p_header">index af858d52608a..f4dd30c56f36 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/stub_tx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/stub_tx.c</span>
<span class="p_chunk">@@ -201,8 +201,8 @@</span> <span class="p_context"> static int stub_send_ret_submit(struct stub_device *sdev)</span>
 
 		/* 1. setup usbip_header */
 		setup_ret_submit_pdu(&amp;pdu_header, urb);
<span class="p_del">-		usbip_dbg_stub_tx(&quot;setup txdata seqnum: %d urb: %p\n&quot;,</span>
<span class="p_del">-				  pdu_header.base.seqnum, urb);</span>
<span class="p_add">+		usbip_dbg_stub_tx(&quot;setup txdata seqnum: %d\n&quot;,</span>
<span class="p_add">+				  pdu_header.base.seqnum);</span>
 		usbip_header_correct_endian(&amp;pdu_header, 1);
 
 		iov[iovnum].iov_base = &amp;pdu_header;
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_hcd.c b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">index 81b2b9f808b5..f9af04d7f02f 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_chunk">@@ -467,9 +467,6 @@</span> <span class="p_context"> static int vhci_urb_enqueue(struct usb_hcd *hcd, struct urb *urb,</span>
 	int ret = 0;
 	struct vhci_device *vdev;
 
<span class="p_del">-	usbip_dbg_vhci_hc(&quot;enter, usb_hcd %p urb %p mem_flags %d\n&quot;,</span>
<span class="p_del">-			  hcd, urb, mem_flags);</span>
<span class="p_del">-</span>
 	/* patch to usb_sg_init() is in 2.5.60 */
 	BUG_ON(!urb-&gt;transfer_buffer &amp;&amp; urb-&gt;transfer_buffer_length);
 
<span class="p_chunk">@@ -627,8 +624,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 	struct vhci_priv *priv;
 	struct vhci_device *vdev;
 
<span class="p_del">-	pr_info(&quot;dequeue a urb %p\n&quot;, urb);</span>
<span class="p_del">-</span>
 	spin_lock(&amp;the_controller-&gt;lock);
 
 	priv = urb-&gt;hcpriv;
<span class="p_chunk">@@ -656,7 +651,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		/* tcp connection is closed */
 		spin_lock(&amp;vdev-&gt;priv_lock);
 
<span class="p_del">-		pr_info(&quot;device %p seems to be disconnected\n&quot;, vdev);</span>
 		list_del(&amp;priv-&gt;list);
 		kfree(priv);
 		urb-&gt;hcpriv = NULL;
<span class="p_chunk">@@ -668,8 +662,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		 * vhci_rx will receive RET_UNLINK and give back the URB.
 		 * Otherwise, we give back it here.
 		 */
<span class="p_del">-		pr_info(&quot;gives back urb %p\n&quot;, urb);</span>
<span class="p_del">-</span>
 		usb_hcd_unlink_urb_from_ep(hcd, urb);
 
 		spin_unlock(&amp;the_controller-&gt;lock);
<span class="p_chunk">@@ -698,8 +690,6 @@</span> <span class="p_context"> static int vhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 
 		unlink-&gt;unlink_seqnum = priv-&gt;seqnum;
 
<span class="p_del">-		pr_info(&quot;device %p seems to be still connected\n&quot;, vdev);</span>
<span class="p_del">-</span>
 		/* send cmd_unlink and try to cancel the pending URB in the
 		 * peer */
 		list_add_tail(&amp;unlink-&gt;list, &amp;vdev-&gt;unlink_tx);
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_rx.c b/drivers/usb/usbip/vhci_rx.c</span>
<span class="p_header">index 00e4a54308e4..bc4eb0855314 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_rx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_rx.c</span>
<span class="p_chunk">@@ -37,24 +37,23 @@</span> <span class="p_context"> struct urb *pickup_urb_and_free_priv(struct vhci_device *vdev, __u32 seqnum)</span>
 		urb = priv-&gt;urb;
 		status = urb-&gt;status;
 
<span class="p_del">-		usbip_dbg_vhci_rx(&quot;find urb %p vurb %p seqnum %u\n&quot;,</span>
<span class="p_del">-				urb, priv, seqnum);</span>
<span class="p_add">+		usbip_dbg_vhci_rx(&quot;find urb seqnum %u\n&quot;, seqnum);</span>
 
 		switch (status) {
 		case -ENOENT:
 			/* fall through */
 		case -ECONNRESET:
<span class="p_del">-			dev_info(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_del">-				 &quot;urb %p was unlinked %ssynchronuously.\n&quot;, urb,</span>
<span class="p_del">-				 status == -ENOENT ? &quot;&quot; : &quot;a&quot;);</span>
<span class="p_add">+			dev_dbg(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_add">+				 &quot;urb seq# %u was unlinked %ssynchronuously\n&quot;,</span>
<span class="p_add">+				 seqnum, status == -ENOENT ? &quot;&quot; : &quot;a&quot;);</span>
 			break;
 		case -EINPROGRESS:
 			/* no info output */
 			break;
 		default:
<span class="p_del">-			dev_info(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_del">-				 &quot;urb %p may be in a error, status %d\n&quot;, urb,</span>
<span class="p_del">-				 status);</span>
<span class="p_add">+			dev_dbg(&amp;urb-&gt;dev-&gt;dev,</span>
<span class="p_add">+				 &quot;urb seq# %u may be in a error, status %d\n&quot;,</span>
<span class="p_add">+				 seqnum, status);</span>
 		}
 
 		list_del(&amp;priv-&gt;list);
<span class="p_chunk">@@ -78,8 +77,8 @@</span> <span class="p_context"> static void vhci_recv_ret_submit(struct vhci_device *vdev,</span>
 	spin_unlock(&amp;vdev-&gt;priv_lock);
 
 	if (!urb) {
<span class="p_del">-		pr_err(&quot;cannot find a urb of seqnum %u\n&quot;, pdu-&gt;base.seqnum);</span>
<span class="p_del">-		pr_info(&quot;max seqnum %d\n&quot;,</span>
<span class="p_add">+		pr_err(&quot;cannot find a urb of seqnum %u max seqnum %d\n&quot;,</span>
<span class="p_add">+			pdu-&gt;base.seqnum,</span>
 			atomic_read(&amp;the_controller-&gt;seqnum));
 		usbip_event_add(ud, VDEV_EVENT_ERROR_TCP);
 		return;
<span class="p_chunk">@@ -102,7 +101,7 @@</span> <span class="p_context"> static void vhci_recv_ret_submit(struct vhci_device *vdev,</span>
 	if (usbip_dbg_flag_vhci_rx)
 		usbip_dump_urb(urb);
 
<span class="p_del">-	usbip_dbg_vhci_rx(&quot;now giveback urb %p\n&quot;, urb);</span>
<span class="p_add">+	usbip_dbg_vhci_rx(&quot;now giveback urb %u\n&quot;, pdu-&gt;base.seqnum);</span>
 
 	spin_lock(&amp;the_controller-&gt;lock);
 	usb_hcd_unlink_urb_from_ep(vhci_to_hcd(the_controller), urb);
<span class="p_chunk">@@ -165,7 +164,7 @@</span> <span class="p_context"> static void vhci_recv_ret_unlink(struct vhci_device *vdev,</span>
 		pr_info(&quot;the urb (seqnum %d) was already given back\n&quot;,
 			pdu-&gt;base.seqnum);
 	} else {
<span class="p_del">-		usbip_dbg_vhci_rx(&quot;now giveback urb %p\n&quot;, urb);</span>
<span class="p_add">+		usbip_dbg_vhci_rx(&quot;now giveback urb %d\n&quot;, pdu-&gt;base.seqnum);</span>
 
 		/* If unlink is successful, status is -ECONNRESET */
 		urb-&gt;status = pdu-&gt;u.ret_unlink.status;
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_tx.c b/drivers/usb/usbip/vhci_tx.c</span>
<span class="p_header">index 409fd99f3257..3c5796c8633a 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_tx.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_tx.c</span>
<span class="p_chunk">@@ -82,7 +82,8 @@</span> <span class="p_context"> static int vhci_send_cmd_submit(struct vhci_device *vdev)</span>
 		memset(&amp;msg, 0, sizeof(msg));
 		memset(&amp;iov, 0, sizeof(iov));
 
<span class="p_del">-		usbip_dbg_vhci_tx(&quot;setup txdata urb %p\n&quot;, urb);</span>
<span class="p_add">+		usbip_dbg_vhci_tx(&quot;setup txdata urb seqnum %lu\n&quot;,</span>
<span class="p_add">+				  priv-&gt;seqnum);</span>
 
 		/* 1. setup usbip_header */
 		setup_cmd_submit_pdu(&amp;pdu_header, urb);
<span class="p_header">diff --git a/include/crypto/mcryptd.h b/include/crypto/mcryptd.h</span>
<span class="p_header">index c23ee1f7ee80..c2ff077168d3 100644</span>
<span class="p_header">--- a/include/crypto/mcryptd.h</span>
<span class="p_header">+++ b/include/crypto/mcryptd.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> static inline struct mcryptd_ahash *__mcryptd_ahash_cast(</span>
 
 struct mcryptd_cpu_queue {
 	struct crypto_queue queue;
<span class="p_add">+	spinlock_t q_lock;</span>
 	struct work_struct work;
 };
 
<span class="p_header">diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h</span>
<span class="p_header">index 402753bccafa..7b8e3afcc291 100644</span>
<span class="p_header">--- a/include/linux/ipv6.h</span>
<span class="p_header">+++ b/include/linux/ipv6.h</span>
<span class="p_chunk">@@ -215,7 +215,8 @@</span> <span class="p_context"> struct ipv6_pinfo {</span>
 						 * 100: prefer care-of address
 						 */
 				dontfrag:1,
<span class="p_del">-				autoflowlabel:1;</span>
<span class="p_add">+				autoflowlabel:1,</span>
<span class="p_add">+				autoflowlabel_set:1;</span>
 	__u8			min_hopcount;
 	__u8			tclass;
 	__be32			rcv_flowinfo;
<span class="p_header">diff --git a/include/linux/vm_event_item.h b/include/linux/vm_event_item.h</span>
<span class="p_header">index e623d392db0c..8ef3a61fdc74 100644</span>
<span class="p_header">--- a/include/linux/vm_event_item.h</span>
<span class="p_header">+++ b/include/linux/vm_event_item.h</span>
<span class="p_chunk">@@ -80,10 +80,8 @@</span> <span class="p_context"> enum vm_event_item { PGPGIN, PGPGOUT, PSWPIN, PSWPOUT,</span>
 #endif
 #endif
 #ifdef CONFIG_DEBUG_TLBFLUSH
<span class="p_del">-#ifdef CONFIG_SMP</span>
 		NR_TLB_REMOTE_FLUSH,	/* cpu tried to flush others&#39; tlbs */
 		NR_TLB_REMOTE_FLUSH_RECEIVED,/* cpu received ipi for flush */
<span class="p_del">-#endif /* CONFIG_SMP */</span>
 		NR_TLB_LOCAL_FLUSH_ALL,
 		NR_TLB_LOCAL_FLUSH_ONE,
 #endif /* CONFIG_DEBUG_TLBFLUSH */
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index 7476bb10ff37..639398af273b 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -33,6 +33,8 @@</span> <span class="p_context"></span>
 #include &lt;net/flow.h&gt;
 #include &lt;net/flow_dissector.h&gt;
 
<span class="p_add">+#define IPV4_MIN_MTU		68			/* RFC 791 */</span>
<span class="p_add">+</span>
 struct sock;
 
 struct inet_skb_parm {
<span class="p_header">diff --git a/kernel/time/tick-sched.c b/kernel/time/tick-sched.c</span>
<span class="p_header">index 22c57e191a23..e5d228f7224c 100644</span>
<span class="p_header">--- a/kernel/time/tick-sched.c</span>
<span class="p_header">+++ b/kernel/time/tick-sched.c</span>
<span class="p_chunk">@@ -568,6 +568,11 @@</span> <span class="p_context"> static void tick_nohz_restart(struct tick_sched *ts, ktime_t now)</span>
 		tick_program_event(hrtimer_get_expires(&amp;ts-&gt;sched_timer), 1);
 }
 
<span class="p_add">+static inline bool local_timer_softirq_pending(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return local_softirq_pending() &amp; TIMER_SOFTIRQ;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,
 					 ktime_t now, int cpu)
 {
<span class="p_chunk">@@ -584,8 +589,18 @@</span> <span class="p_context"> static ktime_t tick_nohz_stop_sched_tick(struct tick_sched *ts,</span>
 	} while (read_seqretry(&amp;jiffies_lock, seq));
 	ts-&gt;last_jiffies = basejiff;
 
<span class="p_del">-	if (rcu_needs_cpu(basemono, &amp;next_rcu) ||</span>
<span class="p_del">-	    arch_needs_cpu() || irq_work_needs_cpu()) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Keep the periodic tick, when RCU, architecture or irq_work</span>
<span class="p_add">+	 * requests it.</span>
<span class="p_add">+	 * Aside of that check whether the local timer softirq is</span>
<span class="p_add">+	 * pending. If so its a bad idea to call get_next_timer_interrupt()</span>
<span class="p_add">+	 * because there is an already expired timer, so it will request</span>
<span class="p_add">+	 * immeditate expiry, which rearms the hardware timer with a</span>
<span class="p_add">+	 * minimal delta which brings us back to this place</span>
<span class="p_add">+	 * immediately. Lather, rinse and repeat...</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rcu_needs_cpu(basemono, &amp;next_rcu) || arch_needs_cpu() ||</span>
<span class="p_add">+	    irq_work_needs_cpu() || local_timer_softirq_pending()) {</span>
 		next_tick = basemono + TICK_NSEC;
 	} else {
 		/*
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 1275175b0946..d9cd6191760b 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -280,6 +280,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ring_buffer_event_data);</span>
 /* Missed count stored at end */
 #define RB_MISSED_STORED	(1 &lt;&lt; 30)
 
<span class="p_add">+#define RB_MISSED_FLAGS		(RB_MISSED_EVENTS|RB_MISSED_STORED)</span>
<span class="p_add">+</span>
 struct buffer_data_page {
 	u64		 time_stamp;	/* page time stamp */
 	local_t		 commit;	/* write committed index */
<span class="p_chunk">@@ -331,7 +333,9 @@</span> <span class="p_context"> static void rb_init_page(struct buffer_data_page *bpage)</span>
  */
 size_t ring_buffer_page_len(void *page)
 {
<span class="p_del">-	return local_read(&amp;((struct buffer_data_page *)page)-&gt;commit)</span>
<span class="p_add">+	struct buffer_data_page *bpage = page;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (local_read(&amp;bpage-&gt;commit) &amp; ~RB_MISSED_FLAGS)</span>
 		+ BUF_PAGE_HDR_SIZE;
 }
 
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 61d0960559c8..8aef4e63ac57 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -5754,7 +5754,7 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 		.spd_release	= buffer_spd_release,
 	};
 	struct buffer_ref *ref;
<span class="p_del">-	int entries, size, i;</span>
<span class="p_add">+	int entries, i;</span>
 	ssize_t ret = 0;
 
 #ifdef CONFIG_TRACER_MAX_TRACE
<span class="p_chunk">@@ -5805,14 +5805,6 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 			break;
 		}
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * zero out any left over data, this is going to</span>
<span class="p_del">-		 * user land.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		size = ring_buffer_page_len(ref-&gt;page);</span>
<span class="p_del">-		if (size &lt; PAGE_SIZE)</span>
<span class="p_del">-			memset(ref-&gt;page + size, 0, PAGE_SIZE - size);</span>
<span class="p_del">-</span>
 		page = virt_to_page(ref-&gt;page);
 
 		spd.pages[i] = page;
<span class="p_chunk">@@ -6539,6 +6531,7 @@</span> <span class="p_context"> allocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size</span>
 	buf-&gt;data = alloc_percpu(struct trace_array_cpu);
 	if (!buf-&gt;data) {
 		ring_buffer_free(buf-&gt;buffer);
<span class="p_add">+		buf-&gt;buffer = NULL;</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -6562,7 +6555,9 @@</span> <span class="p_context"> static int allocate_trace_buffers(struct trace_array *tr, int size)</span>
 				    allocate_snapshot ? size : 1);
 	if (WARN_ON(ret)) {
 		ring_buffer_free(tr-&gt;trace_buffer.buffer);
<span class="p_add">+		tr-&gt;trace_buffer.buffer = NULL;</span>
 		free_percpu(tr-&gt;trace_buffer.data);
<span class="p_add">+		tr-&gt;trace_buffer.data = NULL;</span>
 		return -ENOMEM;
 	}
 	tr-&gt;allocated_snapshot = allocate_snapshot;
<span class="p_header">diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c</span>
<span class="p_header">index a1f697ec4fc2..0ce26a0f7913 100644</span>
<span class="p_header">--- a/net/bridge/br_netlink.c</span>
<span class="p_header">+++ b/net/bridge/br_netlink.c</span>
<span class="p_chunk">@@ -1067,19 +1067,20 @@</span> <span class="p_context"> static int br_dev_newlink(struct net *src_net, struct net_device *dev,</span>
 	struct net_bridge *br = netdev_priv(dev);
 	int err;
 
<span class="p_add">+	err = register_netdevice(dev);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	if (tb[IFLA_ADDRESS]) {
 		spin_lock_bh(&amp;br-&gt;lock);
 		br_stp_change_bridge_id(br, nla_data(tb[IFLA_ADDRESS]));
 		spin_unlock_bh(&amp;br-&gt;lock);
 	}
 
<span class="p_del">-	err = register_netdevice(dev);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
 	err = br_changelink(dev, tb, data);
 	if (err)
<span class="p_del">-		unregister_netdevice(dev);</span>
<span class="p_add">+		br_dev_delete(dev, NULL);</span>
<span class="p_add">+</span>
 	return err;
 }
 
<span class="p_header">diff --git a/net/core/net_namespace.c b/net/core/net_namespace.c</span>
<span class="p_header">index 2e9a1c2818c7..b5c351d2830b 100644</span>
<span class="p_header">--- a/net/core/net_namespace.c</span>
<span class="p_header">+++ b/net/core/net_namespace.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> struct net *get_net_ns_by_id(struct net *net, int id)</span>
 	spin_lock_irqsave(&amp;net-&gt;nsid_lock, flags);
 	peer = idr_find(&amp;net-&gt;netns_ids, id);
 	if (peer)
<span class="p_del">-		get_net(peer);</span>
<span class="p_add">+		peer = maybe_get_net(peer);</span>
 	spin_unlock_irqrestore(&amp;net-&gt;nsid_lock, flags);
 	rcu_read_unlock();
 
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index d33609c2f276..86b619501350 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -3676,7 +3676,7 @@</span> <span class="p_context"> void skb_complete_tx_timestamp(struct sk_buff *skb,</span>
 	struct sock *sk = skb-&gt;sk;
 
 	if (!skb_may_tx_timestamp(sk, false))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto err;</span>
 
 	/* Take a reference to prevent skb_orphan() from freeing the socket,
 	 * but only if the socket refcount is not zero.
<span class="p_chunk">@@ -3685,7 +3685,11 @@</span> <span class="p_context"> void skb_complete_tx_timestamp(struct sk_buff *skb,</span>
 		*skb_hwtstamps(skb) = *hwtstamps;
 		__skb_complete_tx_timestamp(skb, sk, SCM_TSTAMP_SND);
 		sock_put(sk);
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	kfree_skb(skb);</span>
 }
 EXPORT_SYMBOL_GPL(skb_complete_tx_timestamp);
 
<span class="p_header">diff --git a/net/ipv4/devinet.c b/net/ipv4/devinet.c</span>
<span class="p_header">index 0212591b0077..63f99e9a821b 100644</span>
<span class="p_header">--- a/net/ipv4/devinet.c</span>
<span class="p_header">+++ b/net/ipv4/devinet.c</span>
<span class="p_chunk">@@ -1358,7 +1358,7 @@</span> <span class="p_context"> skip:</span>
 
 static bool inetdev_valid_mtu(unsigned int mtu)
 {
<span class="p_del">-	return mtu &gt;= 68;</span>
<span class="p_add">+	return mtu &gt;= IPV4_MIN_MTU;</span>
 }
 
 static void inetdev_send_gratuitous_arp(struct net_device *dev,
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index 0cb240c749bf..c9e68ff48a72 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -1252,7 +1252,7 @@</span> <span class="p_context"> fail:</span>
 
 static void ip_fib_net_exit(struct net *net)
 {
<span class="p_del">-	unsigned int i;</span>
<span class="p_add">+	int i;</span>
 
 	rtnl_lock();
 #ifdef CONFIG_IP_MULTIPLE_TABLES
<span class="p_chunk">@@ -1260,7 +1260,12 @@</span> <span class="p_context"> static void ip_fib_net_exit(struct net *net)</span>
 	RCU_INIT_POINTER(net-&gt;ipv4.fib_main, NULL);
 	RCU_INIT_POINTER(net-&gt;ipv4.fib_default, NULL);
 #endif
<span class="p_del">-	for (i = 0; i &lt; FIB_TABLE_HASHSZ; i++) {</span>
<span class="p_add">+	/* Destroy the tables in reverse order to guarantee that the</span>
<span class="p_add">+	 * local table, ID 255, is destroyed before the main table, ID</span>
<span class="p_add">+	 * 254. This is necessary as the local table may contain</span>
<span class="p_add">+	 * references to data contained in the main table.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = FIB_TABLE_HASHSZ - 1; i &gt;= 0; i--) {</span>
 		struct hlist_head *head = &amp;net-&gt;ipv4.fib_table_hash[i];
 		struct hlist_node *tmp;
 		struct fib_table *tb;
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 3809d523d012..b60106d34346 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/rtnetlink.h&gt;
 #include &lt;linux/times.h&gt;
 #include &lt;linux/pkt_sched.h&gt;
<span class="p_add">+#include &lt;linux/byteorder/generic.h&gt;</span>
 
 #include &lt;net/net_namespace.h&gt;
 #include &lt;net/arp.h&gt;
<span class="p_chunk">@@ -327,6 +328,23 @@</span> <span class="p_context"> igmp_scount(struct ip_mc_list *pmc, int type, int gdeleted, int sdeleted)</span>
 	return scount;
 }
 
<span class="p_add">+/* source address selection per RFC 3376 section 4.2.13 */</span>
<span class="p_add">+static __be32 igmpv3_get_srcaddr(struct net_device *dev,</span>
<span class="p_add">+				 const struct flowi4 *fl4)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct in_device *in_dev = __in_dev_get_rcu(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!in_dev)</span>
<span class="p_add">+		return htonl(INADDR_ANY);</span>
<span class="p_add">+</span>
<span class="p_add">+	for_ifa(in_dev) {</span>
<span class="p_add">+		if (inet_ifa_match(fl4-&gt;saddr, ifa))</span>
<span class="p_add">+			return fl4-&gt;saddr;</span>
<span class="p_add">+	} endfor_ifa(in_dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return htonl(INADDR_ANY);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct sk_buff *igmpv3_newpack(struct net_device *dev, unsigned int mtu)
 {
 	struct sk_buff *skb;
<span class="p_chunk">@@ -374,7 +392,7 @@</span> <span class="p_context"> static struct sk_buff *igmpv3_newpack(struct net_device *dev, unsigned int mtu)</span>
 	pip-&gt;frag_off = htons(IP_DF);
 	pip-&gt;ttl      = 1;
 	pip-&gt;daddr    = fl4.daddr;
<span class="p_del">-	pip-&gt;saddr    = fl4.saddr;</span>
<span class="p_add">+	pip-&gt;saddr    = igmpv3_get_srcaddr(dev, &amp;fl4);</span>
 	pip-&gt;protocol = IPPROTO_IGMP;
 	pip-&gt;tot_len  = 0;	/* filled in later */
 	ip_select_ident(net, skb, NULL);
<span class="p_chunk">@@ -410,16 +428,17 @@</span> <span class="p_context"> static int grec_size(struct ip_mc_list *pmc, int type, int gdel, int sdel)</span>
 }
 
 static struct sk_buff *add_grhead(struct sk_buff *skb, struct ip_mc_list *pmc,
<span class="p_del">-	int type, struct igmpv3_grec **ppgr)</span>
<span class="p_add">+	int type, struct igmpv3_grec **ppgr, unsigned int mtu)</span>
 {
 	struct net_device *dev = pmc-&gt;interface-&gt;dev;
 	struct igmpv3_report *pih;
 	struct igmpv3_grec *pgr;
 
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		skb = igmpv3_newpack(dev, dev-&gt;mtu);</span>
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+	if (!skb) {</span>
<span class="p_add">+		skb = igmpv3_newpack(dev, mtu);</span>
<span class="p_add">+		if (!skb)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+	}</span>
 	pgr = (struct igmpv3_grec *)skb_put(skb, sizeof(struct igmpv3_grec));
 	pgr-&gt;grec_type = type;
 	pgr-&gt;grec_auxwords = 0;
<span class="p_chunk">@@ -441,12 +460,17 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,</span>
 	struct igmpv3_grec *pgr = NULL;
 	struct ip_sf_list *psf, *psf_next, *psf_prev, **psf_list;
 	int scount, stotal, first, isquery, truncate;
<span class="p_add">+	unsigned int mtu;</span>
 
 	if (pmc-&gt;multiaddr == IGMP_ALL_HOSTS)
 		return skb;
 	if (ipv4_is_local_multicast(pmc-&gt;multiaddr) &amp;&amp; !sysctl_igmp_llm_reports)
 		return skb;
 
<span class="p_add">+	mtu = READ_ONCE(dev-&gt;mtu);</span>
<span class="p_add">+	if (mtu &lt; IPV4_MIN_MTU)</span>
<span class="p_add">+		return skb;</span>
<span class="p_add">+</span>
 	isquery = type == IGMPV3_MODE_IS_INCLUDE ||
 		  type == IGMPV3_MODE_IS_EXCLUDE;
 	truncate = type == IGMPV3_MODE_IS_EXCLUDE ||
<span class="p_chunk">@@ -467,7 +491,7 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,</span>
 		    AVAILABLE(skb) &lt; grec_size(pmc, type, gdeleted, sdeleted)) {
 			if (skb)
 				igmpv3_sendpack(skb);
<span class="p_del">-			skb = igmpv3_newpack(dev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = igmpv3_newpack(dev, mtu);</span>
 		}
 	}
 	first = 1;
<span class="p_chunk">@@ -494,12 +518,12 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ip_mc_list *pmc,</span>
 				pgr-&gt;grec_nsrcs = htons(scount);
 			if (skb)
 				igmpv3_sendpack(skb);
<span class="p_del">-			skb = igmpv3_newpack(dev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = igmpv3_newpack(dev, mtu);</span>
 			first = 1;
 			scount = 0;
 		}
 		if (first) {
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 			first = 0;
 		}
 		if (!skb)
<span class="p_chunk">@@ -533,7 +557,7 @@</span> <span class="p_context"> empty_source:</span>
 				igmpv3_sendpack(skb);
 				skb = NULL; /* add_grhead will get a new one */
 			}
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 		}
 	}
 	if (pgr)
<span class="p_header">diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c</span>
<span class="p_header">index 3310ac75e3f3..c18245e05d26 100644</span>
<span class="p_header">--- a/net/ipv4/ip_tunnel.c</span>
<span class="p_header">+++ b/net/ipv4/ip_tunnel.c</span>
<span class="p_chunk">@@ -400,8 +400,8 @@</span> <span class="p_context"> static int ip_tunnel_bind_dev(struct net_device *dev)</span>
 	dev-&gt;needed_headroom = t_hlen + hlen;
 	mtu -= (dev-&gt;hard_header_len + t_hlen);
 
<span class="p_del">-	if (mtu &lt; 68)</span>
<span class="p_del">-		mtu = 68;</span>
<span class="p_add">+	if (mtu &lt; IPV4_MIN_MTU)</span>
<span class="p_add">+		mtu = IPV4_MIN_MTU;</span>
 
 	return mtu;
 }
<span class="p_header">diff --git a/net/ipv4/raw.c b/net/ipv4/raw.c</span>
<span class="p_header">index 8f2cd7d09720..4d3d4291c82f 100644</span>
<span class="p_header">--- a/net/ipv4/raw.c</span>
<span class="p_header">+++ b/net/ipv4/raw.c</span>
<span class="p_chunk">@@ -500,11 +500,16 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 	int err;
 	struct ip_options_data opt_copy;
 	struct raw_frag_vec rfv;
<span class="p_add">+	int hdrincl;</span>
 
 	err = -EMSGSIZE;
 	if (len &gt; 0xFFFF)
 		goto out;
 
<span class="p_add">+	/* hdrincl should be READ_ONCE(inet-&gt;hdrincl)</span>
<span class="p_add">+	 * but READ_ONCE() doesn&#39;t work with bit fields</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	hdrincl = inet-&gt;hdrincl;</span>
 	/*
 	 *	Check the flags.
 	 */
<span class="p_chunk">@@ -579,7 +584,7 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 		/* Linux does not mangle headers on raw sockets,
 		 * so that IP options + IP_HDRINCL is non-sense.
 		 */
<span class="p_del">-		if (inet-&gt;hdrincl)</span>
<span class="p_add">+		if (hdrincl)</span>
 			goto done;
 		if (ipc.opt-&gt;opt.srr) {
 			if (!daddr)
<span class="p_chunk">@@ -601,9 +606,9 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 
 	flowi4_init_output(&amp;fl4, ipc.oif, sk-&gt;sk_mark, tos,
 			   RT_SCOPE_UNIVERSE,
<span class="p_del">-			   inet-&gt;hdrincl ? IPPROTO_RAW : sk-&gt;sk_protocol,</span>
<span class="p_add">+			   hdrincl ? IPPROTO_RAW : sk-&gt;sk_protocol,</span>
 			   inet_sk_flowi_flags(sk) |
<span class="p_del">-			    (inet-&gt;hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),</span>
<span class="p_add">+			    (hdrincl ? FLOWI_FLAG_KNOWN_NH : 0),</span>
 			   daddr, saddr, 0, 0);
 
 	if (!saddr &amp;&amp; ipc.oif) {
<span class="p_chunk">@@ -612,7 +617,7 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 			goto done;
 	}
 
<span class="p_del">-	if (!inet-&gt;hdrincl) {</span>
<span class="p_add">+	if (!hdrincl) {</span>
 		rfv.msg = msg;
 		rfv.hlen = 0;
 
<span class="p_chunk">@@ -637,7 +642,7 @@</span> <span class="p_context"> static int raw_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 		goto do_confirm;
 back_from_confirm:
 
<span class="p_del">-	if (inet-&gt;hdrincl)</span>
<span class="p_add">+	if (hdrincl)</span>
 		err = raw_send_hdrinc(sk, &amp;fl4, msg, len,
 				      &amp;rt, msg-&gt;msg_flags);
 
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index a5d790c13ef5..61c93a93f228 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -823,7 +823,7 @@</span> <span class="p_context"> static void tcp_v4_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,</span>
 			tcp_time_stamp,
 			req-&gt;ts_recent,
 			0,
<span class="p_del">-			tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&amp;ip_hdr(skb)-&gt;daddr,</span>
<span class="p_add">+			tcp_md5_do_lookup(sk, (union tcp_md5_addr *)&amp;ip_hdr(skb)-&gt;saddr,</span>
 					  AF_INET),
 			inet_rsk(req)-&gt;no_srccheck ? IP_REPLY_ARG_NOSRCCHECK : 0,
 			ip_hdr(skb)-&gt;tos);
<span class="p_header">diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c</span>
<span class="p_header">index 83ec6639b04d..637a0e41b0aa 100644</span>
<span class="p_header">--- a/net/ipv6/af_inet6.c</span>
<span class="p_header">+++ b/net/ipv6/af_inet6.c</span>
<span class="p_chunk">@@ -200,7 +200,6 @@</span> <span class="p_context"> lookup_protocol:</span>
 	np-&gt;mcast_hops	= IPV6_DEFAULT_MCASTHOPS;
 	np-&gt;mc_loop	= 1;
 	np-&gt;pmtudisc	= IPV6_PMTUDISC_WANT;
<span class="p_del">-	np-&gt;autoflowlabel = ip6_default_np_autolabel(sock_net(sk));</span>
 	sk-&gt;sk_ipv6only	= net-&gt;ipv6.sysctl.bindv6only;
 
 	/* Init the ipv4 part of the socket since we can have sockets
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 71624cf26832..1b4f5f2d2929 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -148,6 +148,14 @@</span> <span class="p_context"> int ip6_output(struct net *net, struct sock *sk, struct sk_buff *skb)</span>
 			    !(IP6CB(skb)-&gt;flags &amp; IP6SKB_REROUTED));
 }
 
<span class="p_add">+static bool ip6_autoflowlabel(struct net *net, const struct ipv6_pinfo *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!np-&gt;autoflowlabel_set)</span>
<span class="p_add">+		return ip6_default_np_autolabel(net);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return np-&gt;autoflowlabel;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * xmit an sk_buff (used by TCP, SCTP and DCCP)
  * Note : socket lock is not held for SYNACK packets, but might be modified
<span class="p_chunk">@@ -211,7 +219,7 @@</span> <span class="p_context"> int ip6_xmit(const struct sock *sk, struct sk_buff *skb, struct flowi6 *fl6,</span>
 		hlimit = ip6_dst_hoplimit(dst);
 
 	ip6_flow_hdr(hdr, tclass, ip6_make_flowlabel(net, skb, fl6-&gt;flowlabel,
<span class="p_del">-						     np-&gt;autoflowlabel, fl6));</span>
<span class="p_add">+				ip6_autoflowlabel(net, np), fl6));</span>
 
 	hdr-&gt;payload_len = htons(seg_len);
 	hdr-&gt;nexthdr = proto;
<span class="p_chunk">@@ -1675,7 +1683,7 @@</span> <span class="p_context"> struct sk_buff *__ip6_make_skb(struct sock *sk,</span>
 
 	ip6_flow_hdr(hdr, v6_cork-&gt;tclass,
 		     ip6_make_flowlabel(net, skb, fl6-&gt;flowlabel,
<span class="p_del">-					np-&gt;autoflowlabel, fl6));</span>
<span class="p_add">+					ip6_autoflowlabel(net, np), fl6));</span>
 	hdr-&gt;hop_limit = v6_cork-&gt;hop_limit;
 	hdr-&gt;nexthdr = proto;
 	hdr-&gt;saddr = fl6-&gt;saddr;
<span class="p_header">diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">index a4a30d2ca66f..435e26210587 100644</span>
<span class="p_header">--- a/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">+++ b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_chunk">@@ -872,6 +872,7 @@</span> <span class="p_context"> pref_skip_coa:</span>
 		break;
 	case IPV6_AUTOFLOWLABEL:
 		np-&gt;autoflowlabel = valbool;
<span class="p_add">+		np-&gt;autoflowlabel_set = 1;</span>
 		retv = 0;
 		break;
 	}
<span class="p_header">diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c</span>
<span class="p_header">index d64ee7e83664..06640685ff43 100644</span>
<span class="p_header">--- a/net/ipv6/mcast.c</span>
<span class="p_header">+++ b/net/ipv6/mcast.c</span>
<span class="p_chunk">@@ -1668,16 +1668,16 @@</span> <span class="p_context"> static int grec_size(struct ifmcaddr6 *pmc, int type, int gdel, int sdel)</span>
 }
 
 static struct sk_buff *add_grhead(struct sk_buff *skb, struct ifmcaddr6 *pmc,
<span class="p_del">-	int type, struct mld2_grec **ppgr)</span>
<span class="p_add">+	int type, struct mld2_grec **ppgr, unsigned int mtu)</span>
 {
<span class="p_del">-	struct net_device *dev = pmc-&gt;idev-&gt;dev;</span>
 	struct mld2_report *pmr;
 	struct mld2_grec *pgr;
 
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		skb = mld_newpack(pmc-&gt;idev, dev-&gt;mtu);</span>
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+	if (!skb) {</span>
<span class="p_add">+		skb = mld_newpack(pmc-&gt;idev, mtu);</span>
<span class="p_add">+		if (!skb)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+	}</span>
 	pgr = (struct mld2_grec *)skb_put(skb, sizeof(struct mld2_grec));
 	pgr-&gt;grec_type = type;
 	pgr-&gt;grec_auxwords = 0;
<span class="p_chunk">@@ -1700,10 +1700,15 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,</span>
 	struct mld2_grec *pgr = NULL;
 	struct ip6_sf_list *psf, *psf_next, *psf_prev, **psf_list;
 	int scount, stotal, first, isquery, truncate;
<span class="p_add">+	unsigned int mtu;</span>
 
 	if (pmc-&gt;mca_flags &amp; MAF_NOREPORT)
 		return skb;
 
<span class="p_add">+	mtu = READ_ONCE(dev-&gt;mtu);</span>
<span class="p_add">+	if (mtu &lt; IPV6_MIN_MTU)</span>
<span class="p_add">+		return skb;</span>
<span class="p_add">+</span>
 	isquery = type == MLD2_MODE_IS_INCLUDE ||
 		  type == MLD2_MODE_IS_EXCLUDE;
 	truncate = type == MLD2_MODE_IS_EXCLUDE ||
<span class="p_chunk">@@ -1724,7 +1729,7 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,</span>
 		    AVAILABLE(skb) &lt; grec_size(pmc, type, gdeleted, sdeleted)) {
 			if (skb)
 				mld_sendpack(skb);
<span class="p_del">-			skb = mld_newpack(idev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = mld_newpack(idev, mtu);</span>
 		}
 	}
 	first = 1;
<span class="p_chunk">@@ -1751,12 +1756,12 @@</span> <span class="p_context"> static struct sk_buff *add_grec(struct sk_buff *skb, struct ifmcaddr6 *pmc,</span>
 				pgr-&gt;grec_nsrcs = htons(scount);
 			if (skb)
 				mld_sendpack(skb);
<span class="p_del">-			skb = mld_newpack(idev, dev-&gt;mtu);</span>
<span class="p_add">+			skb = mld_newpack(idev, mtu);</span>
 			first = 1;
 			scount = 0;
 		}
 		if (first) {
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 			first = 0;
 		}
 		if (!skb)
<span class="p_chunk">@@ -1790,7 +1795,7 @@</span> <span class="p_context"> empty_source:</span>
 				mld_sendpack(skb);
 				skb = NULL; /* add_grhead will get a new one */
 			}
<span class="p_del">-			skb = add_grhead(skb, pmc, type, &amp;pgr);</span>
<span class="p_add">+			skb = add_grhead(skb, pmc, type, &amp;pgr, mtu);</span>
 		}
 	}
 	if (pgr)
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 59c908ff251a..74cbcc4b399c 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -949,7 +949,7 @@</span> <span class="p_context"> static void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,</span>
 			tcp_rsk(req)-&gt;rcv_nxt,
 			req-&gt;rsk_rcv_wnd &gt;&gt; inet_rsk(req)-&gt;rcv_wscale,
 			tcp_time_stamp, req-&gt;ts_recent, sk-&gt;sk_bound_dev_if,
<span class="p_del">-			tcp_v6_md5_do_lookup(sk, &amp;ipv6_hdr(skb)-&gt;daddr),</span>
<span class="p_add">+			tcp_v6_md5_do_lookup(sk, &amp;ipv6_hdr(skb)-&gt;saddr),</span>
 			0, 0);
 }
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 5fabe68e20dd..48e1608414e6 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -261,6 +261,9 @@</span> <span class="p_context"> static int __netlink_deliver_tap_skb(struct sk_buff *skb,</span>
 	struct sock *sk = skb-&gt;sk;
 	int ret = -ENOMEM;
 
<span class="p_add">+	if (!net_eq(dev_net(dev), sock_net(sk)))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	dev_hold(dev);
 
 	if (is_vmalloc_addr(skb-&gt;head))
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 61189c576963..a870d27ca778 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -4153,7 +4153,7 @@</span> <span class="p_context"> static int sctp_init_sock(struct sock *sk)</span>
 	SCTP_DBG_OBJCNT_INC(sock);
 
 	local_bh_disable();
<span class="p_del">-	percpu_counter_inc(&amp;sctp_sockets_allocated);</span>
<span class="p_add">+	sk_sockets_allocated_inc(sk);</span>
 	sock_prot_inuse_add(net, sk-&gt;sk_prot, 1);
 
 	/* Nothing can fail after this block, otherwise
<span class="p_chunk">@@ -4197,7 +4197,7 @@</span> <span class="p_context"> static void sctp_destroy_sock(struct sock *sk)</span>
 	}
 	sctp_endpoint_free(sp-&gt;ep);
 	local_bh_disable();
<span class="p_del">-	percpu_counter_dec(&amp;sctp_sockets_allocated);</span>
<span class="p_add">+	sk_sockets_allocated_dec(sk);</span>
 	sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, -1);
 	local_bh_enable();
 }
<span class="p_header">diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c</span>
<span class="p_header">index b450a27588c8..16f8124b1150 100644</span>
<span class="p_header">--- a/sound/core/rawmidi.c</span>
<span class="p_header">+++ b/sound/core/rawmidi.c</span>
<span class="p_chunk">@@ -579,15 +579,14 @@</span> <span class="p_context"> static int snd_rawmidi_info_user(struct snd_rawmidi_substream *substream,</span>
 	return 0;
 }
 
<span class="p_del">-int snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info)</span>
<span class="p_add">+static int __snd_rawmidi_info_select(struct snd_card *card,</span>
<span class="p_add">+				     struct snd_rawmidi_info *info)</span>
 {
 	struct snd_rawmidi *rmidi;
 	struct snd_rawmidi_str *pstr;
 	struct snd_rawmidi_substream *substream;
 
<span class="p_del">-	mutex_lock(&amp;register_mutex);</span>
 	rmidi = snd_rawmidi_search(card, info-&gt;device);
<span class="p_del">-	mutex_unlock(&amp;register_mutex);</span>
 	if (!rmidi)
 		return -ENXIO;
 	if (info-&gt;stream &lt; 0 || info-&gt;stream &gt; 1)
<span class="p_chunk">@@ -603,6 +602,16 @@</span> <span class="p_context"> int snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info</span>
 	}
 	return -ENXIO;
 }
<span class="p_add">+</span>
<span class="p_add">+int snd_rawmidi_info_select(struct snd_card *card, struct snd_rawmidi_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;register_mutex);</span>
<span class="p_add">+	ret = __snd_rawmidi_info_select(card, info);</span>
<span class="p_add">+	mutex_unlock(&amp;register_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(snd_rawmidi_info_select);
 
 static int snd_rawmidi_info_select_user(struct snd_card *card,
<span class="p_header">diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c</span>
<span class="p_header">index cce9ae5ec93b..bd7bcf428bcf 100644</span>
<span class="p_header">--- a/sound/hda/hdac_i915.c</span>
<span class="p_header">+++ b/sound/hda/hdac_i915.c</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static int hdac_component_master_match(struct device *dev, void *data)</span>
  */
 int snd_hdac_i915_register_notifier(const struct i915_audio_component_audio_ops *aops)
 {
<span class="p_del">-	if (WARN_ON(!hdac_acomp))</span>
<span class="p_add">+	if (!hdac_acomp)</span>
 		return -ENODEV;
 
 	hdac_acomp-&gt;audio_ops = aops;
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 2159b18f76bf..5875a08d555e 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5953,6 +5953,11 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		{0x1b, 0x01011020},
 		{0x21, 0x02211010}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x12, 0x90a60130},</span>
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x1b, 0x01011020},</span>
<span class="p_add">+		{0x21, 0x0221101f}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		{0x12, 0x90a60160},
 		{0x14, 0x90170120},
<span class="p_header">diff --git a/sound/soc/codecs/twl4030.c b/sound/soc/codecs/twl4030.c</span>
<span class="p_header">index a5a4e9f75c57..a06395507225 100644</span>
<span class="p_header">--- a/sound/soc/codecs/twl4030.c</span>
<span class="p_header">+++ b/sound/soc/codecs/twl4030.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> static struct twl4030_codec_data *twl4030_get_pdata(struct snd_soc_codec *codec)</span>
 	struct twl4030_codec_data *pdata = dev_get_platdata(codec-&gt;dev);
 	struct device_node *twl4030_codec_node = NULL;
 
<span class="p_del">-	twl4030_codec_node = of_find_node_by_name(codec-&gt;dev-&gt;parent-&gt;of_node,</span>
<span class="p_add">+	twl4030_codec_node = of_get_child_by_name(codec-&gt;dev-&gt;parent-&gt;of_node,</span>
 						  &quot;codec&quot;);
 
 	if (!pdata &amp;&amp; twl4030_codec_node) {
<span class="p_chunk">@@ -241,9 +241,11 @@</span> <span class="p_context"> static struct twl4030_codec_data *twl4030_get_pdata(struct snd_soc_codec *codec)</span>
 				     GFP_KERNEL);
 		if (!pdata) {
 			dev_err(codec-&gt;dev, &quot;Can not allocate memory\n&quot;);
<span class="p_add">+			of_node_put(twl4030_codec_node);</span>
 			return NULL;
 		}
 		twl4030_setup_pdata_of(pdata, twl4030_codec_node);
<span class="p_add">+		of_node_put(twl4030_codec_node);</span>
 	}
 
 	return pdata;
<span class="p_header">diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">index 95d2392303eb..7ca67613e0d4 100644</span>
<span class="p_header">--- a/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">+++ b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_chunk">@@ -1408,12 +1408,6 @@</span> <span class="p_context"> static int fsl_ssi_probe(struct platform_device *pdev)</span>
 				sizeof(fsl_ssi_ac97_dai));
 
 		fsl_ac97_data = ssi_private;
<span class="p_del">-</span>
<span class="p_del">-		ret = snd_soc_set_ac97_ops_of_reset(&amp;fsl_ssi_ac97_ops, pdev);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			dev_err(&amp;pdev-&gt;dev, &quot;could not set AC&#39;97 ops\n&quot;);</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		}</span>
 	} else {
 		/* Initialize this copy of the CPU DAI driver structure */
 		memcpy(&amp;ssi_private-&gt;cpu_dai_drv, &amp;fsl_ssi_dai_template,
<span class="p_chunk">@@ -1473,6 +1467,14 @@</span> <span class="p_context"> static int fsl_ssi_probe(struct platform_device *pdev)</span>
 			return ret;
 	}
 
<span class="p_add">+	if (fsl_ssi_is_ac97(ssi_private)) {</span>
<span class="p_add">+		ret = snd_soc_set_ac97_ops_of_reset(&amp;fsl_ssi_ac97_ops, pdev);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev, &quot;could not set AC&#39;97 ops\n&quot;);</span>
<span class="p_add">+			goto error_ac97_ops;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = devm_snd_soc_register_component(&amp;pdev-&gt;dev, &amp;fsl_ssi_component,
 					      &amp;ssi_private-&gt;cpu_dai_drv, 1);
 	if (ret) {
<span class="p_chunk">@@ -1556,6 +1558,10 @@</span> <span class="p_context"> error_sound_card:</span>
 	fsl_ssi_debugfs_remove(&amp;ssi_private-&gt;dbg_stats);
 
 error_asoc_register:
<span class="p_add">+	if (fsl_ssi_is_ac97(ssi_private))</span>
<span class="p_add">+		snd_soc_set_ac97_ops(NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+error_ac97_ops:</span>
 	if (ssi_private-&gt;soc-&gt;imx)
 		fsl_ssi_imx_clean(pdev, ssi_private);
 
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 0ed9ae030ce1..c9ae29068c7c 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -2101,20 +2101,25 @@</span> <span class="p_context"> static int parse_audio_selector_unit(struct mixer_build *state, int unitid,</span>
 	kctl-&gt;private_value = (unsigned long)namelist;
 	kctl-&gt;private_free = usb_mixer_selector_elem_free;
 
<span class="p_del">-	nameid = uac_selector_unit_iSelector(desc);</span>
<span class="p_add">+	/* check the static mapping table at first */</span>
 	len = check_mapped_name(map, kctl-&gt;id.name, sizeof(kctl-&gt;id.name));
<span class="p_del">-	if (len)</span>
<span class="p_del">-		;</span>
<span class="p_del">-	else if (nameid)</span>
<span class="p_del">-		len = snd_usb_copy_string_desc(state, nameid, kctl-&gt;id.name,</span>
<span class="p_del">-					 sizeof(kctl-&gt;id.name));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		len = get_term_name(state, &amp;state-&gt;oterm,</span>
<span class="p_del">-				    kctl-&gt;id.name, sizeof(kctl-&gt;id.name), 0);</span>
<span class="p_del">-</span>
 	if (!len) {
<span class="p_del">-		strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
<span class="p_add">+		/* no mapping ? */</span>
<span class="p_add">+		/* if iSelector is given, use it */</span>
<span class="p_add">+		nameid = uac_selector_unit_iSelector(desc);</span>
<span class="p_add">+		if (nameid)</span>
<span class="p_add">+			len = snd_usb_copy_string_desc(state, nameid,</span>
<span class="p_add">+						       kctl-&gt;id.name,</span>
<span class="p_add">+						       sizeof(kctl-&gt;id.name));</span>
<span class="p_add">+		/* ... or pick up the terminal name at next */</span>
<span class="p_add">+		if (!len)</span>
<span class="p_add">+			len = get_term_name(state, &amp;state-&gt;oterm,</span>
<span class="p_add">+				    kctl-&gt;id.name, sizeof(kctl-&gt;id.name), 0);</span>
<span class="p_add">+		/* ... or use the fixed string &quot;USB&quot; as the last resort */</span>
<span class="p_add">+		if (!len)</span>
<span class="p_add">+			strlcpy(kctl-&gt;id.name, &quot;USB&quot;, sizeof(kctl-&gt;id.name));</span>
 
<span class="p_add">+		/* and add the proper suffix */</span>
 		if (desc-&gt;bDescriptorSubtype == UAC2_CLOCK_SELECTOR)
 			append_ctl_name(kctl, &quot; Clock Source&quot;);
 		else if ((state-&gt;oterm.type &amp; 0xff00) == 0x0100)
<span class="p_header">diff --git a/tools/usb/usbip/src/utils.c b/tools/usb/usbip/src/utils.c</span>
<span class="p_header">index 2b3d6d235015..3d7b42e77299 100644</span>
<span class="p_header">--- a/tools/usb/usbip/src/utils.c</span>
<span class="p_header">+++ b/tools/usb/usbip/src/utils.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"> int modify_match_busid(char *busid, int add)</span>
 	char command[SYSFS_BUS_ID_SIZE + 4];
 	char match_busid_attr_path[SYSFS_PATH_MAX];
 	int rc;
<span class="p_add">+	int cmd_size;</span>
 
 	snprintf(match_busid_attr_path, sizeof(match_busid_attr_path),
 		 &quot;%s/%s/%s/%s/%s/%s&quot;, SYSFS_MNT_PATH, SYSFS_BUS_NAME,
<span class="p_chunk">@@ -37,12 +38,14 @@</span> <span class="p_context"> int modify_match_busid(char *busid, int add)</span>
 		 attr_name);
 
 	if (add)
<span class="p_del">-		snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;add %s&quot;, busid);</span>
<span class="p_add">+		cmd_size = snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;add %s&quot;,</span>
<span class="p_add">+				    busid);</span>
 	else
<span class="p_del">-		snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;del %s&quot;, busid);</span>
<span class="p_add">+		cmd_size = snprintf(command, SYSFS_BUS_ID_SIZE + 4, &quot;del %s&quot;,</span>
<span class="p_add">+				    busid);</span>
 
 	rc = write_sysfs_attribute(match_busid_attr_path, command,
<span class="p_del">-				   sizeof(command));</span>
<span class="p_add">+				   cmd_size);</span>
 	if (rc &lt; 0) {
 		dbg(&quot;failed to write match_busid: %s&quot;, strerror(errno));
 		return -1;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



