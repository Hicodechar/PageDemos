
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v6,2/2] ARM: imx: Add suspend codes for imx7D - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v6,2/2] ARM: imx: Add suspend codes for imx7D</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 22, 2015, 5:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1437584859-64203-3-git-send-email-shenwei.wang@freescale.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6845481/mbox/"
   >mbox</a>
|
   <a href="/patch/6845481/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6845481/">/patch/6845481/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id E9390C05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 22 Jul 2015 17:23:24 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 65789206C5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 22 Jul 2015 17:23:22 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id AFA8B20461
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 22 Jul 2015 17:23:19 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934830AbbGVRXR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 22 Jul 2015 13:23:17 -0400
Received: from mail-bl2on0120.outbound.protection.outlook.com
	([65.55.169.120]:28996
	&quot;EHLO na01-bl2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S932752AbbGVRXN (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 22 Jul 2015 13:23:13 -0400
X-Greylist: delayed 902 seconds by postgrey-1.27 at vger.kernel.org;
	Wed, 22 Jul 2015 13:23:13 EDT
Received: from BY2PR03CA008.namprd03.prod.outlook.com (10.255.93.25) by
	BLUPR03MB1363.namprd03.prod.outlook.com (10.163.80.29) with Microsoft
	SMTP Server (TLS) id 15.1.219.17; Wed, 22 Jul 2015 17:08:09 +0000
Received: from BN1AFFO11FD022.protection.gbl (10.255.93.4) by
	BY2PR03CA008.outlook.office365.com (10.255.93.25) with Microsoft SMTP
	Server (TLS) id 15.1.225.19 via Frontend Transport;
	Wed, 22 Jul 2015 17:08:09 +0000
Authentication-Results: spf=fail (sender IP is 192.88.168.50)
	smtp.mailfrom=freescale.com; freescale.mail.onmicrosoft.com; dkim=none
	(message not signed) header.d=none;
Received-SPF: Fail (protection.outlook.com: domain of freescale.com does not
	designate 192.88.168.50 as permitted sender)
	receiver=protection.outlook.com; 
	client-ip=192.88.168.50; helo=tx30smr01.am.freescale.net;
Received: from tx30smr01.am.freescale.net (192.88.168.50) by
	BN1AFFO11FD022.mail.protection.outlook.com (10.58.52.82) with
	Microsoft SMTP Server (TLS) id 15.1.213.8 via Frontend Transport;
	Wed, 22 Jul 2015 17:08:08 +0000
Received: from [az84smr01.freescale.net (B38339-11.am.freescale.net
	[10.81.93.199])
	by tx30smr01.am.freescale.net (8.14.3/8.14.0) with ESMTP id
	t6MH7l0g024332; Wed, 22 Jul 2015 10:08:08 -0700
From: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;
To: &lt;shawn.guo@linaro.org&gt;, &lt;tglx@linutronix.de&gt;,
	&lt;jason@lakedaemon.net&gt;
CC: &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;b20788@freescale.com&gt;
Subject: [PATCH v6 2/2] ARM: imx: Add suspend codes for imx7D
Date: Wed, 22 Jul 2015 12:07:39 -0500
Message-ID: &lt;1437584859-64203-3-git-send-email-shenwei.wang@freescale.com&gt;
X-Mailer: git-send-email 2.5.0.rc2
In-Reply-To: &lt;1437584859-64203-1-git-send-email-shenwei.wang@freescale.com&gt;
References: &lt;1437584859-64203-1-git-send-email-shenwei.wang@freescale.com&gt;
X-EOPAttributedMessage: 0
X-Microsoft-Exchange-Diagnostics: 1; BN1AFFO11FD022;
	1:/suB2+K+dDdab+MAmjc25x3vWfmN8vrYyCIbOkbJDFJI3xrUG2MymPmVOCzoNPDUXJrlTxmCgQ/linqeGpHxZ/jA+TU7t7E9dxlz2xu7TVdxYHXkw1pv1TQOG83epYn4Z4nO1qhm9gv9d/iLobCKKpzMCVMTGHKWpmdXIa4uCRetFN80Hp4UlGRouOt3EzAZlhzJxwjyu9qdnvD8gT+sVfdEyhU/bjI1TM30KTUaL0dNRIg+yZgdLOQEiQFFogAJPOQSfSplQ3Q0VlXsyEk8ZoItH3JJjPbcrLP1hF8XeK/YnFccwx9z1+65ria3Iv3FGu6C5fJQY3eERu2UOSupf7fzzyEtNzhpuYP6vwLVErbUkSRD0mBVOO9zn7B2qjVv/oGSW0gTKK2twpe2D8uJjRclcNOkeVNtcUFBxrrK9bMZcWlSBNDkXSsj5iWRbrd6
X-Forefront-Antispam-Report: CIP:192.88.168.50; CTRY:US; IPV:NLI; EFV:NLI;
	SFV:NSPM;
	SFS:(10019020)(6009001)(2980300002)(339900001)(199003)(189002)(50466002)(77096005)(575784001)(46102003)(229853001)(77156002)(6806004)(36756003)(5001960100002)(50226001)(92566002)(19580395003)(87936001)(104016003)(62966003)(189998001)(5001770100001)(105606002)(15975445007)(2950100001)(106466001)(107886002)(33646002)(85426001)(50986999)(19580405001)(2201001)(86362001)(48376002)(47776003)(76176999)(5003940100001)(4001430100001);
	DIR:OUT; SFP:1102; SCL:1; SRVR:BLUPR03MB1363;
	H:tx30smr01.am.freescale.net; FPR:; SPF:Fail; MLV:sfv; A:1;
	MX:1; LANG:en; 
MIME-Version: 1.0
Content-Type: text/plain
X-Microsoft-Exchange-Diagnostics: 1; BLUPR03MB1363;
	2:ESYkMJ0P0Dw/MQ45CX2fJWZsPMAQUZWhSzSLyvpOh4Wmzf367jRGtRsGHAXGmsgM;
	3:QbU9OHjwnrMKPCU15fftd7Db+L19rGL25A2cAsc78+o+HkD1jteu425zvBCtzuSLu25+heRq46qAUA2N/41wzbG8R0SeIO8iDMl+Zg2P+dD1+QnEbaShhHPYo7Jcn+ksNtK8WfTNwEOJoF5n94RKcS+tDrbW0XH73LVeRO9eP066niOq/0nA64YmaUQ9j3vAQ5I2wwrArzmR6vIRu4yc2DvWwKhoNZCh3Tysw+/VQgE=;
	25:Da8W8zfyWbLcurFPWXht1WoyUyc1nNDS0GnwUc2/DIVZOUww4BLyHL6ApV6NWFLlTF36yyUmH4mgrTvJwMvtCPbXBJDVsSV7Qe0dYTYKCJgmM6yJCbv6LhAh80latpRXGv+7TGhResdl/3YnDr2ZFg03/1K4DVHhZ8c7//xXCJAa6Y6DNA+6ypJeTlaGH914dPThpXR0w3oRDtHykgtqcHPvjo89wMZmIUqmufFupF6L80km3djPwyslP0ddKFds7Y/qwbV0jWmhbUknwfnU9Q==;
	20:bhvime62xUClk7GImBQNfF0QAp/MeflQ20lUm8UO5h9zVHp0DF96VoRxqGlEpdoVwCE7QiQk/epDr7eopyuWZdipuJllH+MWGzoSgl0zvq2EPplsdgoALka7AXOc+JN3a8QW7etnhbwPj/C0UwZPRMHzJxUM5bYUjFBCowX/qlqguF8cL1wZs8hCrNIMGmQAeQWdrTrhRt4Lfo1XvnpEk6SN3VAb1QfhWYOcR2VBV5ukpECIAoahi2itinPpC2E6QteQ8FUDZOluNHRIZI4uC4gzuIs5C5rHZFLfrrbt5Mukt2aQz5K0K/haelAAnCJsZLWmDXeLw6QXlclXZbtoZY0uPE5
	wgw7MGOReA4Tc4hM=
X-Microsoft-Antispam: UriScan:;BCL:0;PCL:0;RULEID:;SRVR:BLUPR03MB1363;
BLUPR03MB1363: X-MS-Exchange-Organization-RulesExecuted
X-Microsoft-Antispam-PRVS: &lt;BLUPR03MB13638B99B2D204D1950610B683830@BLUPR03MB1363.namprd03.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(601004)(5005006)(3002001); SRVR:BLUPR03MB1363; BCL:0;
	PCL:0; RULEID:; SRVR:BLUPR03MB1363; 
X-Microsoft-Exchange-Diagnostics: 1; BLUPR03MB1363;
	4:A1K0M5uNvdq0lnioXSlFQLSNND0wTuYEYhdu+yoLgRYccwKkxsLiRv4YXhkEwUoEp1E3m6ZTG8H+Eal5sURDAX4JZZU6bbWhKD6RzZqT+LJd25JFc4rCsKv/+nzuv/Dhnp032uMPJTuN83mKoIRvC1y3oMILTjOxeRWmeKcBXZp8kYwtaTC4C0+q4fKUgP0DCBBuJqVTmwg1UMe5B4ZYxaQvm+/p2A42C9s5UZ+6IlIOKtbQ+gxHdquZ711mNSpZpze4pu7o7cC37/jp7hhk3wWj+lNW8pTDhlUcJtFgnIs=
X-Forefront-PRVS: 0645BEB7AA
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; BLUPR03MB1363;
	23:9lDQePtjoHD2uOhJ47xprhNWGIK/nN/fyh7DSUNrn?=
	=?us-ascii?Q?dW8t5Trz2HOB4xct7yI+zJtmoSyhGXUpZC1s8cOus5LesM+UuDvHo3yP5BIT?=
	=?us-ascii?Q?dZrFDZMK2mMbZaLxRZGQZjpF5daYpp3747hmz9fkG1Cf3C0GUiPObVis/tnU?=
	=?us-ascii?Q?FCt0mlXhRy+rvJ2vGhwvE4ODyPov1oAn6pUQrcvYNT7v2BR7EUAaa2n05RMY?=
	=?us-ascii?Q?d2NKqFqvx5RF/93rH7zqt/FNFioCL7qlYbZLL2sLZrZAQ11MIzer0f1mAPq6?=
	=?us-ascii?Q?Yz9jezpz+FyOQTxRJJQZBS77pZTO9ZdlpvZZ1I0EAFe4j7E9ldnsXVhAlk0A?=
	=?us-ascii?Q?P/ZjmtvQFv/vkxP8lhtbubJeI1B65Kd4xjHSSTG6RqF8Kfi/LBAkIwZtuqgI?=
	=?us-ascii?Q?aFfG02VVv++Pdo27nBJpE6uOFOIM0mFV0Qdd48f8Wtb5AcK+N89MVtes5A6i?=
	=?us-ascii?Q?DosxvyU+qBG0z8bCE3mVoKVvMF1PysS7dHgZn2gMdEsHSB5ofohbRTdjhF9g?=
	=?us-ascii?Q?O7rjb1ielGfHQjebw16pkFfrLUeOkNtEvv/k9r7e8AlWfVZw0hrhkdH23s7F?=
	=?us-ascii?Q?q/U4yuWF1TJTvf/mCUVCVYBzcrkziDivhpjITkOESCm5vJR06pEqMc8GjvLY?=
	=?us-ascii?Q?uP5ngn8DpPSBBMa3h4/yF0ZKEms/XQbnnNrgRqRJuk94LKnmkZ51K9ghf1tc?=
	=?us-ascii?Q?Tf1sw6xl9sYnpIXd91ufNkJPZ4CeX1m4yPkXLXO6pXwwiEP5uyLDBuUWVox0?=
	=?us-ascii?Q?KE3+yGD2In8Tl8vgY5/t6y5BCV6TBLRzu7mLlrJwQ8wxEMYSyHdL/reiFuAA?=
	=?us-ascii?Q?hFC3p7dUqIaHbkS9rQelMao6t5d7sULGMtnWYlI75m4IVOoP8L6xMetOX+i+?=
	=?us-ascii?Q?4S+y8KntAM7SBvWWImuNvEMgLIShOMwiCDTGA6O23zE8aoc17mqcK2gHtdWF?=
	=?us-ascii?Q?J1EWDRB0fUXLtO+i+OI986ib+yA+75d/NYvIVcU2VBwRlyvjEZWOUuYsVzwE?=
	=?us-ascii?Q?o4YJbZCKNvHfQWs6qUOaO9whf8aXJ+wTda6EGcqCrRjrw=3D=3D?=
X-Microsoft-Exchange-Diagnostics: 1; BLUPR03MB1363;
	5:+B5721cmzORGrcVDXi7n1wOH8si553+iHLwz1EWCTKP2A/L4q/LhsT6xJ5Iz3RfOPeY4BoftVdINCCxfxazbLsPclAL7Hzyjxy39BFEub9yYGlFoh6UGhYJ5PfoMowLGoDLK9URw+ul9XQU3oQ8lDg==;
	24:2JwYyNFAB0vNjFUg/aJTa4jCt4OyAnU0UfzAuHbooHyUhjR9ZqjvxXr+0dg0m8PZV6P+oqkzr5an5a8OMAtLcE6QnPyv3+4xXATRPqkuZVA=;
	20:NfNP6Rtn7aVAN+M56s5vx3jk3BhIl2mVSxMHpe/W47EYRsXp57mrRw5xfSFyzARc3WqCVqcQqOf885l1urGpaA==
X-OriginatorOrg: freescale.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 22 Jul 2015 17:08:08.9013
	(UTC)
X-MS-Exchange-CrossTenant-Id: 710a03f5-10f6-4d38-9ff4-a80b81da590d
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=710a03f5-10f6-4d38-9ff4-a80b81da590d;
	Ip=[192.88.168.50]; Helo=[tx30smr01.am.freescale.net]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: BLUPR03MB1363
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - July 22, 2015, 5:07 p.m.</div>
<pre class="content">
IMX7D contains a new version of GPC IP block (GPCv2). It has two
major functions: power management and wakeup source management.

GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4
domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.
After configuring the GPCv2 module, the platform can enter into a
selected mode either automatically triggered by ARM WFI instruction or
manually by software. The system will exit the low power states
by the predefined wakeup sources which are managed by the gpcv2
irqchip driver.

This patch adds a new suspend driver to manage the power states on IMX7D.
It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.
<span class="signed-off-by">
Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
---
 arch/arm/mach-imx/Kconfig        |   1 +
 arch/arm/mach-imx/Makefile       |   2 +
 arch/arm/mach-imx/pm-imx7.c      | 765 +++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/suspend-imx7.S | 529 +++++++++++++++++++++++++++
 4 files changed, 1297 insertions(+)
 create mode 100644 arch/arm/mach-imx/pm-imx7.c
 create mode 100644 arch/arm/mach-imx/suspend-imx7.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - July 27, 2015, 1:28 p.m.</div>
<pre class="content">
On Wed, Jul 22, 2015 at 12:07:39PM -0500, Shenwei Wang wrote:
<span class="quote">&gt; IMX7D contains a new version of GPC IP block (GPCv2). It has two</span>
<span class="quote">&gt; major functions: power management and wakeup source management.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; GPCv2 provides low power mode control for Cortex-A7 and Cortex-M4</span>
<span class="quote">&gt; domains. And it can support WAIT, STOP, and DSM(Deep Sleep Mode) modes.</span>
<span class="quote">&gt; After configuring the GPCv2 module, the platform can enter into a</span>
<span class="quote">&gt; selected mode either automatically triggered by ARM WFI instruction or</span>
<span class="quote">&gt; manually by software. The system will exit the low power states</span>
<span class="quote">&gt; by the predefined wakeup sources which are managed by the gpcv2</span>
<span class="quote">&gt; irqchip driver.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This patch adds a new suspend driver to manage the power states on IMX7D.</span>
<span class="quote">&gt; It currently supports &quot;SUSPEND_STANDBY&quot; and &quot;SUSPEND_MEM&quot; states.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Shenwei Wang &lt;shenwei.wang@freescale.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Anson Huang &lt;b20788@freescale.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm/mach-imx/Kconfig        |   1 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/Makefile       |   2 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/pm-imx7.c      | 765 +++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/arm/mach-imx/suspend-imx7.S | 529 +++++++++++++++++++++++++++</span>
<span class="quote">&gt;  4 files changed, 1297 insertions(+)</span>
<span class="quote">&gt;  create mode 100644 arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt;  create mode 100644 arch/arm/mach-imx/suspend-imx7.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; index 5ccc9ea..4269c1e 100644</span>
<span class="quote">&gt; --- a/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/Kconfig</span>
<span class="quote">&gt; @@ -552,6 +552,7 @@ config SOC_IMX7D</span>
<span class="quote">&gt;  	bool &quot;i.MX7 Dual support&quot;</span>
<span class="quote">&gt;  	select PINCTRL_IMX7D</span>
<span class="quote">&gt;  	select ARM_GIC</span>
<span class="quote">&gt; +	select IMX_GPCV2</span>

Yes, the existing list is already a bit out of order, but please do not
make it worse.  Add it after HAVE_IMX_MMDC to keep them sort
alphabetically.
<span class="quote">
&gt;  	select HAVE_IMX_ANATOP</span>
<span class="quote">&gt;  	select HAVE_IMX_MMDC</span>
<span class="quote">&gt;  	help</span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; index 37c502a..b2ad476 100644</span>
<span class="quote">&gt; --- a/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/Makefile</span>
<span class="quote">&gt; @@ -87,6 +87,8 @@ obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  ifeq ($(CONFIG_SUSPEND),y)</span>
<span class="quote">&gt;  AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; +AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; +obj-$(CONFIG_IMX_GPCV2)	+= suspend-imx7.o pm-imx7.o</span>

Shouldn&#39;t it be controlled by CONFIG_SOC_IMX7D instead?
<span class="quote">
&gt;  obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o</span>
<span class="quote">&gt;  obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o</span>
<span class="quote">&gt;  endif</span>
<span class="quote">&gt; diff --git a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..50b9af4</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="quote">&gt; @@ -0,0 +1,765 @@</span>
<span class="quote">&gt; +</span>

Drop this new line.
<span class="quote">
&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/regmap.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; +</span>

Ditto
<span class="quote">
&gt; +#include &lt;linux/suspend.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/suspend.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/fncpy.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;soc/imx/gpcv2.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>

Will this give a checkpatch warning?
<span class="quote">
&gt; +static struct imx_gpcv2 *gpcv2_instance;</span>

I stop right here, as I need to understand why we need to have header
soc/imx/gpcv2.h shared between irqchip driver and pm code.

Shawn
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - July 28, 2015, 1:02 a.m.</div>
<pre class="content">
On Mon, Jul 27, 2015 at 06:24:26PM +0000, Shenwei Wang wrote:
<span class="quote">&gt; &gt; &gt; @@ -87,6 +87,8 @@ obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt;  ifeq ($(CONFIG_SUSPEND),y)</span>
<span class="quote">&gt; &gt; &gt;  AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; &gt; &gt; +AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="quote">&gt; &gt; &gt; +obj-$(CONFIG_IMX_GPCV2)	+= suspend-imx7.o pm-imx7.o</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Shouldn&#39;t it be controlled by CONFIG_SOC_IMX7D instead?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; CONFIG_IMX_GPCV2 is more suitable here. As long as a SOC has the same GPCv2 block, the codes should be reused.</span>

Let&#39;s see what problem it will have.  Saying GPCv2 block is used on
imx8, we will have something like below.

obj-$(CONFIG_IMX_GPCV2) += suspend-imx7.o pm-imx7.o suspend-imx8.o pm-imx8.o

If people want to build a kernel with imx8 support only, suspend-imx7.o
and pm-imx7.o will also be built in there, which is undesirable.

The files are named with &quot;-imx7&quot;.  It&#39;s a clear sign that the build of
the files should be controlled by something like related to &quot;imx7&quot;.
Ideally, it should be CONFIG_SOC_IMX7.  Since imx7d is the only
supported imx7 soc and there is no CONFIG_SOC_IMX7 available so far,
it falls on CONFIG_SOC_IMX7D.
<span class="quote">
&gt; &gt; &gt; +extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Will this give a checkpatch warning?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yes. Any suggestion for that? Move it to a header file?</span>

Get rid of it.

Shawn
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - July 28, 2015, 2:30 p.m.</div>
<pre class="content">
On Tue, Jul 28, 2015 at 02:16:20PM +0000, Shenwei Wang wrote:
<span class="quote">&gt; &gt; The files are named with &quot;-imx7&quot;.  It&#39;s a clear sign that the build of the files</span>
<span class="quote">&gt; &gt; should be controlled by something like related to &quot;imx7&quot;.</span>
<span class="quote">&gt; &gt; Ideally, it should be CONFIG_SOC_IMX7.  Since imx7d is the only supported imx7</span>
<span class="quote">&gt; &gt; soc and there is no CONFIG_SOC_IMX7 available so far, it falls on</span>
<span class="quote">&gt; &gt; CONFIG_SOC_IMX7D.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We can also interpret &quot;-imx7&quot; is the first SoC which has the GPCv2 block. </span>

In that case you should name the block gpc-imx7d rather than gpcv2 and
symbol as GPC_IMX7D rather than IMX_GPCV2.
<span class="quote">
&gt; &gt; &gt; &gt; &gt; +extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>
<span class="quote">&gt; &gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; &gt; Will this give a checkpatch warning?</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; Yes. Any suggestion for that? Move it to a header file?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Get rid of it.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then you may resolve the following compile error:</span>

You didn&#39;t get my point.  Rather than defining it as a global variable,
we should try to keep imx_gpcv2_irq as an internal data structure to
irqchip driver, and use well-defined interface to access the data from
pm driver when necessary.

Shawn
<span class="quote">
&gt; </span>
<span class="quote">&gt; CC      arch/arm/mach-imx/pm-imx7.o</span>
<span class="quote">&gt; arch/arm/mach-imx/pm-imx7.c: In function ‘imx_gpcv2_pm_init’:</span>
<span class="quote">&gt; arch/arm/mach-imx/pm-imx7.c:836:7: error: ‘gpcv2_irq_instance’ undeclared (first use in this function)</span>
<span class="quote">&gt;   cd = gpcv2_irq_instance;</span>
<span class="quote">&gt;        ^</span>
<span class="quote">&gt; arch/arm/mach-imx/pm-imx7.c:836:7: note: each undeclared identifier is reported only once for each function it appears in</span>
<span class="quote">&gt; make[1]: *** [arch/arm/mach-imx/pm-imx7.o] Error 1</span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=130351">Shenwei Wang</a> - July 28, 2015, 3:14 p.m.</div>
<pre class="content">
<span class="quote">&gt; -----Original Message-----</span>
<span class="quote">&gt; From: Shawn Guo [mailto:shawnguo@kernel.org]</span>
<span class="quote">&gt; Sent: 2015?7?28? 9:31</span>
<span class="quote">&gt; To: Wang Shenwei-B38339</span>
<span class="quote">&gt; Cc: jason@lakedaemon.net; Huang Yongcai-B20788;</span>
<span class="quote">&gt; linux-kernel@vger.kernel.org; tglx@linutronix.de; shawn.guo@linaro.org;</span>
<span class="quote">&gt; linux-arm-kernel@lists.infradead.org</span>
<span class="quote">&gt; Subject: Re: [PATCH v6 2/2] ARM: imx: Add suspend codes for imx7D</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Tue, Jul 28, 2015 at 02:16:20PM +0000, Shenwei Wang wrote:</span>
<span class="quote">&gt; &gt; &gt; The files are named with &quot;-imx7&quot;.  It&#39;s a clear sign that the build</span>
<span class="quote">&gt; &gt; &gt; of the files should be controlled by something like related to &quot;imx7&quot;.</span>
<span class="quote">&gt; &gt; &gt; Ideally, it should be CONFIG_SOC_IMX7.  Since imx7d is the only</span>
<span class="quote">&gt; &gt; &gt; supported imx7 soc and there is no CONFIG_SOC_IMX7 available so far,</span>
<span class="quote">&gt; &gt; &gt; it falls on CONFIG_SOC_IMX7D.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; We can also interpret &quot;-imx7&quot; is the first SoC which has the GPCv2 block.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In that case you should name the block gpc-imx7d rather than gpcv2 and symbol</span>
<span class="quote">&gt; as GPC_IMX7D rather than IMX_GPCV2.</span>

I don&#39;t want to couple the gpcv2 driver with a SoC. Let&#39;s use your suggestion CONFIG_SOC_IMX7D
for now, because it introduce less modifications.
<span class="quote"> 
&gt; &gt; &gt; &gt; &gt; &gt; +extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Will this give a checkpatch warning?</span>
<span class="quote">&gt; &gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; &gt; Yes. Any suggestion for that? Move it to a header file?</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; Get rid of it.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Then you may resolve the following compile error:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You didn&#39;t get my point.  Rather than defining it as a global variable, we should</span>
<span class="quote">&gt; try to keep imx_gpcv2_irq as an internal data structure to irqchip driver, and use</span>
<span class="quote">&gt; well-defined interface to access the data from pm driver when necessary.</span>

Either to export a variable or a function, you will finally meet the same problem
:where to declare it? Otherwise the same compile error will happen too.

Regards,
Shenwei
<span class="quote"> 

&gt; Shawn</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; CC      arch/arm/mach-imx/pm-imx7.o</span>
<span class="quote">&gt; &gt; arch/arm/mach-imx/pm-imx7.c: In function ‘imx_gpcv2_pm_init’:</span>
<span class="quote">&gt; &gt; arch/arm/mach-imx/pm-imx7.c:836:7: error: ‘gpcv2_irq_instance’ undeclared</span>
<span class="quote">&gt; (first use in this function)</span>
<span class="quote">&gt; &gt;   cd = gpcv2_irq_instance;</span>
<span class="quote">&gt; &gt;        ^</span>
<span class="quote">&gt; &gt; arch/arm/mach-imx/pm-imx7.c:836:7: note: each undeclared identifier is</span>
<span class="quote">&gt; &gt; reported only once for each function it appears in</span>
<span class="quote">&gt; &gt; make[1]: *** [arch/arm/mach-imx/pm-imx7.o] Error 1</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=52451">Frank Li</a> - July 28, 2015, 4:39 p.m.</div>
<pre class="content">
On Tue, Jul 28, 2015 at 9:30 AM, Shawn Guo &lt;shawnguo@kernel.org&gt; wrote:
<span class="quote">&gt; On Tue, Jul 28, 2015 at 02:16:20PM +0000, Shenwei Wang wrote:</span>
<span class="quote">&gt;&gt; &gt; The files are named with &quot;-imx7&quot;.  It&#39;s a clear sign that the build of the files</span>
<span class="quote">&gt;&gt; &gt; should be controlled by something like related to &quot;imx7&quot;.</span>
<span class="quote">&gt;&gt; &gt; Ideally, it should be CONFIG_SOC_IMX7.  Since imx7d is the only supported imx7</span>
<span class="quote">&gt;&gt; &gt; soc and there is no CONFIG_SOC_IMX7 available so far, it falls on</span>
<span class="quote">&gt;&gt; &gt; CONFIG_SOC_IMX7D.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; We can also interpret &quot;-imx7&quot; is the first SoC which has the GPCv2 block.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; In that case you should name the block gpc-imx7d rather than gpcv2 and</span>
<span class="quote">&gt; symbol as GPC_IMX7D rather than IMX_GPCV2.</span>

So far, only IMX7D use this GPC.
i.MX8 will use system controller to control power.

best regards
Frank Li
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; &gt; +extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; &gt; &gt; Will this give a checkpatch warning?</span>
<span class="quote">&gt;&gt; &gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; &gt; Yes. Any suggestion for that? Move it to a header file?</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; Get rid of it.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Then you may resolve the following compile error:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You didn&#39;t get my point.  Rather than defining it as a global variable,</span>
<span class="quote">&gt; we should try to keep imx_gpcv2_irq as an internal data structure to</span>
<span class="quote">&gt; irqchip driver, and use well-defined interface to access the data from</span>
<span class="quote">&gt; pm driver when necessary.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Shawn</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; CC      arch/arm/mach-imx/pm-imx7.o</span>
<span class="quote">&gt;&gt; arch/arm/mach-imx/pm-imx7.c: In function ‘imx_gpcv2_pm_init’:</span>
<span class="quote">&gt;&gt; arch/arm/mach-imx/pm-imx7.c:836:7: error: ‘gpcv2_irq_instance’ undeclared (first use in this function)</span>
<span class="quote">&gt;&gt;   cd = gpcv2_irq_instance;</span>
<span class="quote">&gt;&gt;        ^</span>
<span class="quote">&gt;&gt; arch/arm/mach-imx/pm-imx7.c:836:7: note: each undeclared identifier is reported only once for each function it appears in</span>
<span class="quote">&gt;&gt; make[1]: *** [arch/arm/mach-imx/pm-imx7.o] Error 1</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; _______________________________________________</span>
<span class="quote">&gt; linux-arm-kernel mailing list</span>
<span class="quote">&gt; linux-arm-kernel@lists.infradead.org</span>
<span class="quote">&gt; http://lists.infradead.org/mailman/listinfo/linux-arm-kernel</span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">index 5ccc9ea..4269c1e 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Kconfig</span>
<span class="p_chunk">@@ -552,6 +552,7 @@</span> <span class="p_context"> config SOC_IMX7D</span>
 	bool &quot;i.MX7 Dual support&quot;
 	select PINCTRL_IMX7D
 	select ARM_GIC
<span class="p_add">+	select IMX_GPCV2</span>
 	select HAVE_IMX_ANATOP
 	select HAVE_IMX_MMDC
 	help
<span class="p_header">diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="p_header">index 37c502a..b2ad476 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Makefile</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Makefile</span>
<span class="p_chunk">@@ -87,6 +87,8 @@</span> <span class="p_context"> obj-$(CONFIG_SOC_IMX7D) += mach-imx7d.o</span>
 
 ifeq ($(CONFIG_SUSPEND),y)
 AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a
<span class="p_add">+AFLAGS_suspend-imx7.o :=-Wa,-march=armv7-a</span>
<span class="p_add">+obj-$(CONFIG_IMX_GPCV2)	+= suspend-imx7.o pm-imx7.o</span>
 obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o
 obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o
 endif
<span class="p_header">diff --git a/arch/arm/mach-imx/pm-imx7.c b/arch/arm/mach-imx/pm-imx7.c</span>
new file mode 100644
<span class="p_header">index 0000000..50b9af4</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/pm-imx7.c</span>
<span class="p_chunk">@@ -0,0 +1,765 @@</span> <span class="p_context"></span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="p_add">+#include &lt;linux/regmap.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/fncpy.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;soc/imx/gpcv2.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct imx_gpcv2_irq *gpcv2_irq_instance;</span>
<span class="p_add">+static struct imx_gpcv2 *gpcv2_instance;</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_clear_slots(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_SLOT_NUMBER; i++)</span>
<span class="p_add">+		writel_relaxed(0x0, cd-&gt;gpc_base + GPC_SLOT0_CFG + i * 0x4);</span>
<span class="p_add">+	writel_relaxed(BM_GPC_PGC_ACK_SEL_A7_DUMMY_PUP_ACK |</span>
<span class="p_add">+		BM_GPC_PGC_ACK_SEL_A7_DUMMY_PDN_ACK,</span>
<span class="p_add">+		cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_enable_core(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+			bool enable, u32 offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	writel_relaxed(enable, cd-&gt;gpc_base + offset);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_slot_setup(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+		u32 index, enum gpcv2_slot m_core, bool mode, bool ack)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (index &gt;= MAX_SLOT_NUMBER)</span>
<span class="p_add">+		pr_err(&quot;Invalid slot index!\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	/* set slot */</span>
<span class="p_add">+	writel_relaxed((mode + 1) &lt;&lt; (m_core * 2), cd-&gt;gpc_base +</span>
<span class="p_add">+		GPC_SLOT0_CFG + index * 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ack) {</span>
<span class="p_add">+		/* set ack */</span>
<span class="p_add">+		val = readl_relaxed(cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+		/* clear dummy ack */</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; (15 + (mode ? 16 : 0)));</span>
<span class="p_add">+		val |= 1 &lt;&lt; (m_core + (mode ? 16 : 0));</span>
<span class="p_add">+		writel_relaxed(val, cd-&gt;gpc_base + GPC_PGC_ACK_SEL_A7);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_setup(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PLL and PFDs overwrite set */</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_SET, 1 &lt;&lt; 20);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_SET, 1 &lt;&lt; 19);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_SET, 0x1ff &lt;&lt; 17);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_SET, 1 &lt;&lt; 13);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_SET, 1 &lt;&lt; 24);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_env_clean(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PLL and PFDs overwrite clear */</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ARM_PLL + REG_CLR, 1 &lt;&lt; 20);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_DDR_PLL + REG_CLR, 1 &lt;&lt; 19);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_SYS_PLL + REG_CLR, 0x1ff &lt;&lt; 17);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_ENET_PLL + REG_CLR, 1 &lt;&lt; 13);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_AUDIO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="p_add">+	regmap_write(pm-&gt;anatop, ANADIG_VIDEO_PLL + REG_CLR, 1 &lt;&lt; 24);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_set_mode(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+		enum gpcv2_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val1, val2;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	val1 = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	val2 = readl_relaxed(cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all cores&#39; LPM settings must be same */</span>
<span class="p_add">+	val1 &amp;= ~(BM_LPCR_A7_BSC_LPM0 | BM_LPCR_A7_BSC_LPM1);</span>
<span class="p_add">+</span>
<span class="p_add">+	val1 |= BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+</span>
<span class="p_add">+	val2 &amp;= ~(BM_SLPCR_EN_DSM | BM_SLPCR_VSTBY | BM_SLPCR_RBC_EN |</span>
<span class="p_add">+		BM_SLPCR_SBYOS | BM_SLPCR_BYPASS_PMIC_READY);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * GPCv2: When improper low-power sequence is used,</span>
<span class="p_add">+	 * the SoC enters low power mode before the ARM core executes WFI.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Software workaround:</span>
<span class="p_add">+	 * 1) Software should trigger IRQ #32 (IOMUX) to be always pending</span>
<span class="p_add">+	 *    by setting IOMUX_GPR1_IRQ.</span>
<span class="p_add">+	 * 2) Software should then unmask IRQ #32 in GPC before setting GPC</span>
<span class="p_add">+	 *    Low-Power mode.</span>
<span class="p_add">+	 * 3) Software should mask IRQ #32 right after GPC Low-Power mode</span>
<span class="p_add">+	 *    is set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	switch (mode) {</span>
<span class="p_add">+	case WAIT_CLOCKED:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case WAIT_UNCLOCKED:</span>
<span class="p_add">+		val1 |= A7_LPM_WAIT &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case STOP_POWER_ON:</span>
<span class="p_add">+		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="p_add">+		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case STOP_POWER_OFF:</span>
<span class="p_add">+		val1 |= A7_LPM_STOP &lt;&lt; BP_LPCR_A7_BSC_LPM0;</span>
<span class="p_add">+		val1 &amp;= ~BM_LPCR_A7_BSC_CPU_CLK_ON_LPM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_EN_DSM;</span>
<span class="p_add">+		val2 |= BM_SLPCR_RBC_EN;</span>
<span class="p_add">+		val2 |= BM_SLPCR_SBYOS;</span>
<span class="p_add">+		val2 |= BM_SLPCR_VSTBY;</span>
<span class="p_add">+		val2 |= BM_SLPCR_BYPASS_PMIC_READY;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel_relaxed(val1, cd-&gt;gpc_base + GPC_LPCR_A7_BSC);</span>
<span class="p_add">+	writel_relaxed(val2, cd-&gt;gpc_base + GPC_SLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_cpu_power_gate(struct imx_gpcv2 *gpc,</span>
<span class="p_add">+				u32 cpu, bool pdn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	const u32 val_pdn[2] = {</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C0_PDN | BM_LPCR_A7_AD_EN_C0_PUP,</span>
<span class="p_add">+		BM_LPCR_A7_AD_EN_C1_PDN | BM_LPCR_A7_AD_EN_C1_PUP,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	if (pdn)</span>
<span class="p_add">+		val |= val_pdn[cpu];</span>
<span class="p_add">+	else</span>
<span class="p_add">+		val &amp;= ~val_pdn[cpu];</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_lpm_plat_power_gate(struct imx_gpcv2 *gpc, bool pdn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+	val = readl_relaxed(cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	val &amp;= ~(BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE);</span>
<span class="p_add">+	if (pdn)</span>
<span class="p_add">+		val |= BM_LPCR_A7_AD_EN_PLAT_PDN | BM_LPCR_A7_AD_L2PGE;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(val, cd-&gt;gpc_base + GPC_LPCR_A7_AD);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cd-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void imx_gpcv2_lpm_standby(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup(gpc);</span>
<span class="p_add">+	/* pm-&gt;set_mode(gpc, STOP_POWER_OFF); */</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, WAIT_UNCLOCKED);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;[GPCv2] %s %d\r\n&quot;, __func__, __LINE__);</span>
<span class="p_add">+	/* Zzz ... */</span>
<span class="p_add">+	cpu_do_idle();</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="p_add">+	pm-&gt;lpm_env_clean(gpc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int gpcv2_suspend_finish(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = (struct imx_gpcv2_suspend *)val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pm-&gt;suspend_fn_in_ocram) {</span>
<span class="p_add">+		cpu_do_idle();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * call low level suspend function in ocram,</span>
<span class="p_add">+		 * as we need to float DDR IO.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		local_flush_tlb_all();</span>
<span class="p_add">+		pm-&gt;suspend_fn_in_ocram(pm-&gt;ocram_vbase);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+static void imx_gpcv2_lpm_suspend(struct imx_gpcv2 *gpc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm = gpc-&gt;pm;</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd = gpc-&gt;irqchip;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup(gpc);</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, STOP_POWER_OFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0 power down/up with low power mode */</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate(gpc, 0, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable plat power down with low power mode */</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate(gpc, true);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * To avoid confuse, we use slot 0~4 for power down,</span>
<span class="p_add">+	 * slot 5~9 for power up.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power down slot sequence:</span>
<span class="p_add">+	 * Slot0 -&gt; CORE0</span>
<span class="p_add">+	 * Slot1 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot2 -&gt; SCU</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Power up slot sequence:</span>
<span class="p_add">+	 * Slot5 -&gt; Mega/Fast MIX</span>
<span class="p_add">+	 * Slot6 -&gt; SCU</span>
<span class="p_add">+	 * Slot7 -&gt; CORE0</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 0, CORE0_A7, false, false);</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 2, SCU_A7, false, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; IMR_NUM; i++) {</span>
<span class="p_add">+		if ((~cd-&gt;wakeup_sources[i] &amp; pm-&gt;mfmix_mask[i]) != 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		pm-&gt;set_slot(gpc, 1, FAST_MEGA_MIX, false, false);</span>
<span class="p_add">+		pm-&gt;set_slot(gpc, 5, FAST_MEGA_MIX, true, false);</span>
<span class="p_add">+		pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_FM);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 6, SCU_A7, true, false);</span>
<span class="p_add">+	pm-&gt;set_slot(gpc, 7, CORE0_A7, true, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable core0, scu */</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_C0);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, true, GPC_PGC_SCU);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Suspend to MEM has not been implemented yet */</span>
<span class="p_add">+	cpu_suspend((unsigned long)pm, gpcv2_suspend_finish);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_clean(gpc);</span>
<span class="p_add">+	pm-&gt;set_mode(gpc, WAIT_CLOCKED);</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate(gpc, 0, false);</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate(gpc, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_C0);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_SCU);</span>
<span class="p_add">+	pm-&gt;lpm_enable_core(gpc, false, GPC_PGC_FM);</span>
<span class="p_add">+	pm-&gt;clear_slots(gpc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_enter(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!gpcv2_instance);</span>
<span class="p_add">+	pm = gpcv2_instance-&gt;pm;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (state) {</span>
<span class="p_add">+	case PM_SUSPEND_STANDBY:</span>
<span class="p_add">+		pm-&gt;standby(gpcv2_instance);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		pm-&gt;suspend(gpcv2_instance);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx_gpcv2_pm_valid(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return state == PM_SUSPEND_MEM || state == PM_SUSPEND_STANDBY;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct platform_suspend_ops imx_gpcv2_pm_ops = {</span>
<span class="p_add">+	.enter = imx_gpcv2_pm_enter,</span>
<span class="p_add">+	.valid = imx_gpcv2_pm_valid,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_MAX_DDRC_NUM		32</span>
<span class="p_add">+#define MX7_MAX_DDRC_PHY_NUM		16</span>
<span class="p_add">+</span>
<span class="p_add">+#define READ_DATA_FROM_HARDWARE		0</span>
<span class="p_add">+#define MX7_SUSPEND_OCRAM_SIZE		0x1000</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_base {</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+	void __iomem *vbase;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct imx7_pm_socdata {</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+	const char *ddrc_compat;</span>
<span class="p_add">+	const char *ddrc_phy_compat;</span>
<span class="p_add">+	const char *src_compat;</span>
<span class="p_add">+	const char *iomuxc_gpr_compat;</span>
<span class="p_add">+	const char *ccm_compat;</span>
<span class="p_add">+	const char *gpc_compat;</span>
<span class="p_add">+	const char *anatop_compat;</span>
<span class="p_add">+	const u32 ddrc_num;</span>
<span class="p_add">+	const u32 (*ddrc_offset)[2];</span>
<span class="p_add">+	const u32 ddrc_phy_num;</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset)[2];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This structure is for passing necessary data for low level ocram</span>
<span class="p_add">+ * suspend code(arch/arm/mach-imx/suspend-imx7.S), if this struct</span>
<span class="p_add">+ * definition is changed, the offset definition in</span>
<span class="p_add">+ * arch/arm/mach-imx/suspend-imx7.S must be also changed accordingly,</span>
<span class="p_add">+ * otherwise, the suspend to ocram function will be broken!</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct imx7_cpu_pm_info {</span>
<span class="p_add">+	u32 m4_reserve0;</span>
<span class="p_add">+	u32 m4_reserve1;</span>
<span class="p_add">+	u32 m4_reserve2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The physical address of pm_info. */</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The physical resume address for asm code */</span>
<span class="p_add">+	phys_addr_t resume_addr;</span>
<span class="p_add">+	u32 ddr_type;</span>
<span class="p_add">+</span>
<span class="p_add">+	u32 pm_info_size;</span>
<span class="p_add">+	struct imx7_pm_base ddrc_base;</span>
<span class="p_add">+	struct imx7_pm_base ddrc_phy_base;</span>
<span class="p_add">+	struct imx7_pm_base src_base;</span>
<span class="p_add">+	struct imx7_pm_base iomuxc_gpr_base;</span>
<span class="p_add">+	struct imx7_pm_base ccm_base;</span>
<span class="p_add">+	struct imx7_pm_base gpc_base;</span>
<span class="p_add">+	struct imx7_pm_base l2_base;</span>
<span class="p_add">+	struct imx7_pm_base anatop_base;</span>
<span class="p_add">+	u32 ttbr1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_num;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* To save offset and value */</span>
<span class="p_add">+	u32 ddrc_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Number of DDRC which need saved/restored. */</span>
<span class="p_add">+	u32 ddrc_phy_num;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* To save offset and value */</span>
<span class="p_add">+	u32 ddrc_phy_val[MX7_MAX_DDRC_NUM][2];</span>
<span class="p_add">+} __aligned(8);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_node(struct device_node *node,</span>
<span class="p_add">+			struct imx7_pm_base *base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase) {</span>
<span class="p_add">+		iounmap(base-&gt;vbase);</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_get_exec_base_from_dt(struct imx7_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = __arm_ioremap_exec(res.start, resource_size(&amp;res), false);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x1a8, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x64, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x490, 0x00000001 },</span>
<span class="p_add">+	{ 0xd0, 0xc0020001 },</span>
<span class="p_add">+	{ 0xd4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xdc, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xe4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0xf4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x100, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x104, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x108, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x110, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x114, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x120, 0x03030803 },</span>
<span class="p_add">+	{ 0x180, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x190, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x194, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x200, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x204, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x214, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x218, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x240, 0x06000601 },</span>
<span class="p_add">+	{ 0x244, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 imx7d_ddrc_phy_ddr3_setting[][2] __initconst = {</span>
<span class="p_add">+	{ 0x0, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x4, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x10, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x9c, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x20, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x30, READ_DATA_FROM_HARDWARE },</span>
<span class="p_add">+	{ 0x50, 0x01000010 },</span>
<span class="p_add">+	{ 0x50, 0x00000010 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447306 },</span>
<span class="p_add">+	{ 0xc0, 0x0e447304 },</span>
<span class="p_add">+	{ 0xc0, 0x0e407306 },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct imx7_pm_socdata imx7d_pm_data_ddr3 __initconst = {</span>
<span class="p_add">+	.ddrc_compat = &quot;fsl,imx7d-ddrc&quot;,</span>
<span class="p_add">+	.ddrc_phy_compat = &quot;fsl,imx7d-ddrc-phy&quot;,</span>
<span class="p_add">+	.ccm_compat = &quot;fsl,imx7d-ccm&quot;,</span>
<span class="p_add">+	.src_compat = &quot;fsl,imx7d-src&quot;,</span>
<span class="p_add">+	.iomuxc_gpr_compat = &quot;fsl,imx7d-iomuxc&quot;,</span>
<span class="p_add">+	.gpc_compat = &quot;fsl,imx7d-gpc&quot;,</span>
<span class="p_add">+	.anatop_compat = &quot;fsl,imx7d-anatop&quot;,</span>
<span class="p_add">+	.ddrc_num = ARRAY_SIZE(imx7d_ddrc_ddr3_setting),</span>
<span class="p_add">+	.ddrc_offset = imx7d_ddrc_ddr3_setting,</span>
<span class="p_add">+	.ddrc_phy_num = ARRAY_SIZE(imx7d_ddrc_phy_ddr3_setting),</span>
<span class="p_add">+	.ddrc_phy_offset = imx7d_ddrc_phy_ddr3_setting,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_suspend_init(struct imx_gpcv2_suspend *pm,</span>
<span class="p_add">+			const struct imx7_pm_socdata *socdata)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx7_pm_base aips_base[3] = { {0, 0}, {0, 0}, {0, 0} };</span>
<span class="p_add">+	struct imx7_pm_base sram_base = {0, 0};</span>
<span class="p_add">+	struct imx7_cpu_pm_info *pm_info;</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	int i, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	const u32 (*ddrc_offset_array)[2];</span>
<span class="p_add">+	const u32 (*ddrc_phy_offset_array)[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!socdata || !pm) {</span>
<span class="p_add">+		pr_warn(&quot;%s: invalid argument!\n&quot;, __func__);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	node = NULL;</span>
<span class="p_add">+	for (i = 0; i &lt; 3; i++) {</span>
<span class="p_add">+		node = of_find_compatible_node(node, NULL, &quot;fsl,aips-bus&quot;);</span>
<span class="p_add">+		if (!node) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to find aips %d node!\n&quot;,</span>
<span class="p_add">+					__func__, i);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ret = imx_get_base_from_node(node, &amp;aips_base[i]);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			pr_warn(&quot;%s: failed to get aips[%d] base %d!\n&quot;,</span>
<span class="p_add">+					__func__, i, ret);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_exec_base_from_dt(&amp;sram_base, &quot;fsl,lpm-sram&quot;);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get lpm-sram base %d!\n&quot;,</span>
<span class="p_add">+				__func__, ret);</span>
<span class="p_add">+		goto lpm_sram_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info = sram_base.vbase;</span>
<span class="p_add">+	pm_info-&gt;pbase = sram_base.pbase;</span>
<span class="p_add">+	pm_info-&gt;resume_addr = virt_to_phys(ca7_cpu_resume);</span>
<span class="p_add">+	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ccm_base, socdata-&gt;ccm_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ccm_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_base, socdata-&gt;ddrc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;ddrc_phy_base,</span>
<span class="p_add">+				socdata-&gt;ddrc_phy_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrc_phy base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrc_phy_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto src_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;iomuxc_gpr_base,</span>
<span class="p_add">+				socdata-&gt;iomuxc_gpr_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get iomuxc_gpr base %d!\n&quot;,</span>
<span class="p_add">+					__func__, ret);</span>
<span class="p_add">+		goto iomuxc_gpr_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto gpc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_get_base_from_dt(&amp;pm_info-&gt;anatop_base,</span>
<span class="p_add">+				socdata-&gt;anatop_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto anatop_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info-&gt;ddrc_num = socdata-&gt;ddrc_num;</span>
<span class="p_add">+	ddrc_offset_array = socdata-&gt;ddrc_offset;</span>
<span class="p_add">+	pm_info-&gt;ddrc_phy_num = socdata-&gt;ddrc_phy_num;</span>
<span class="p_add">+	ddrc_phy_offset_array = socdata-&gt;ddrc_phy_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_val[i][0] = ddrc_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_base.vbase +</span>
<span class="p_add">+				ddrc_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_val[i][1] = ddrc_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* initialize DDRC PHY settings */</span>
<span class="p_add">+	for (i = 0; i &lt; pm_info-&gt;ddrc_phy_num; i++) {</span>
<span class="p_add">+		pm_info-&gt;ddrc_phy_val[i][0] =</span>
<span class="p_add">+			ddrc_phy_offset_array[i][0];</span>
<span class="p_add">+		if (ddrc_phy_offset_array[i][1] == READ_DATA_FROM_HARDWARE)</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				readl_relaxed(pm_info-&gt;ddrc_phy_base.vbase +</span>
<span class="p_add">+				ddrc_phy_offset_array[i][0]);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pm_info-&gt;ddrc_phy_val[i][1] =</span>
<span class="p_add">+				ddrc_phy_offset_array[i][1];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;suspend_fn_in_ocram = fncpy(</span>
<span class="p_add">+		sram_base.vbase + sizeof(*pm_info),</span>
<span class="p_add">+		&amp;imx7_suspend,</span>
<span class="p_add">+		MX7_SUSPEND_OCRAM_SIZE - sizeof(*pm_info));</span>
<span class="p_add">+	pm-&gt;ocram_vbase = sram_base.vbase;</span>
<span class="p_add">+</span>
<span class="p_add">+	goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+anatop_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="p_add">+gpc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="p_add">+iomuxc_gpr_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;iomuxc_gpr_base.vbase);</span>
<span class="p_add">+src_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="p_add">+ddrc_phy_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_phy_base.vbase);</span>
<span class="p_add">+ddrc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrc_base.vbase);</span>
<span class="p_add">+ccm_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="p_add">+lpm_sram_map_failed:</span>
<span class="p_add">+	iounmap(sram_base.vbase);</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_gpcv2_pm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct imx_gpcv2_suspend *pm;</span>
<span class="p_add">+	struct imx_gpcv2_irq *cd;</span>
<span class="p_add">+	struct imx_gpcv2 *gpc;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm = kzalloc(sizeof(struct imx_gpcv2_suspend), GFP_KERNEL);</span>
<span class="p_add">+	gpc = kzalloc(sizeof(struct imx_gpcv2), GFP_KERNEL);</span>
<span class="p_add">+	cd = gpcv2_irq_instance;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cd || !pm || !gpc) {</span>
<span class="p_add">+		pr_debug(&quot;[GPCv2] %s init failed\r\n&quot;, __func__);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	imx_gpcv2_suspend_init(pm, &amp;imx7d_pm_data_ddr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_env_setup = imx_gpcv2_lpm_env_setup;</span>
<span class="p_add">+	pm-&gt;lpm_env_clean = imx_gpcv2_lpm_env_clean;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;lpm_cpu_power_gate = imx_gpcv2_lpm_cpu_power_gate;</span>
<span class="p_add">+	pm-&gt;lpm_plat_power_gate = imx_lpm_plat_power_gate;</span>
<span class="p_add">+	pm-&gt;lpm_enable_core = imx_gpcv2_lpm_enable_core;</span>
<span class="p_add">+	pm-&gt;set_mode = imx_gpcv2_lpm_set_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;clear_slots = imx_gpcv2_lpm_clear_slots;</span>
<span class="p_add">+	pm-&gt;set_slot = imx_gpcv2_lpm_slot_setup;</span>
<span class="p_add">+</span>
<span class="p_add">+	pm-&gt;standby = imx_gpcv2_lpm_standby;</span>
<span class="p_add">+	pm-&gt;suspend = imx_gpcv2_lpm_suspend;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;[GPCv2] %s \r\n&quot;, __func__);</span>
<span class="p_add">+	pm-&gt;anatop = syscon_regmap_lookup_by_compatible(&quot;fsl,imx6q-anatop&quot;);</span>
<span class="p_add">+	WARN_ON(!pm-&gt;anatop);</span>
<span class="p_add">+	pm-&gt;imx_src = syscon_regmap_lookup_by_compatible(&quot;fsl,imx7d-src&quot;);</span>
<span class="p_add">+	WARN_ON(!pm-&gt;imx_src);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Due to hardware design failure, need to make sure GPR</span>
<span class="p_add">+	 * interrupt(#32) is unmasked during RUN mode to avoid entering</span>
<span class="p_add">+	 * DSM by mistake.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	writel_relaxed(~0x1, cd-&gt;gpc_base + cd-&gt;cpu2wakeup);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Mask the wakeup sources in M/F power domain */</span>
<span class="p_add">+	pm-&gt;mfmix_mask[0] = 0x54010000;</span>
<span class="p_add">+	pm-&gt;mfmix_mask[1] = 0xc00;</span>
<span class="p_add">+	pm-&gt;mfmix_mask[2] = 0x0;</span>
<span class="p_add">+	pm-&gt;mfmix_mask[3] = 0x400010;</span>
<span class="p_add">+</span>
<span class="p_add">+	gpc-&gt;pm = pm;</span>
<span class="p_add">+	gpc-&gt;irqchip = cd;</span>
<span class="p_add">+	gpcv2_instance = gpc;</span>
<span class="p_add">+</span>
<span class="p_add">+	suspend_set_ops(&amp;imx_gpcv2_pm_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+device_initcall(imx_gpcv2_pm_init);</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/arm/mach-imx/suspend-imx7.S b/arch/arm/mach-imx/suspend-imx7.S</span>
new file mode 100644
<span class="p_header">index 0000000..8c3f516</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/suspend-imx7.S</span>
<span class="p_chunk">@@ -0,0 +1,529 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2015 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The code contained herein is licensed under the GNU General Public</span>
<span class="p_add">+ * License. You may obtain a copy of the GNU General Public License</span>
<span class="p_add">+ * Version 2 or later at the following locations:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * http://www.opensource.org/licenses/gpl-license.html</span>
<span class="p_add">+ * http://www.gnu.org/copyleft/gpl.html</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &quot;hardware.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ==================== low level suspend ====================</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Better to follow below rules to use ARM registers:</span>
<span class="p_add">+ * r0: pm_info structure address;</span>
<span class="p_add">+ * r1 ~ r4: for saving pm_info members;</span>
<span class="p_add">+ * r5 ~ r10: free registers;</span>
<span class="p_add">+ * r11: io base address.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * suspend ocram space layout:</span>
<span class="p_add">+ * ======================== high address ======================</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                      imx7_suspend code</span>
<span class="p_add">+ *              PM_INFO structure(imx7_cpu_pm_info)</span>
<span class="p_add">+ * ======================== low address =======================</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Below offsets are based on struct imx7_cpu_pm_info</span>
<span class="p_add">+ * which defined in arch/arm/mach-imx/pm-imx7.c, this</span>
<span class="p_add">+ * structure contains necessary pm info for low level</span>
<span class="p_add">+ * suspend related code.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE0_OFFSET		0x0</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE1_OFFSET		0x4</span>
<span class="p_add">+#define PM_INFO_M4_RESERVE2_OFFSET		0x8</span>
<span class="p_add">+#define PM_INFO_PBASE_OFFSET			0xc</span>
<span class="p_add">+#define PM_INFO_RESUME_ADDR_OFFSET		0x10</span>
<span class="p_add">+#define PM_INFO_DDR_TYPE_OFFSET			0x14</span>
<span class="p_add">+#define PM_INFO_PM_INFO_SIZE_OFFSET		0x18</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_P_OFFSET		0x1c</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_V_OFFSET		0x20</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_P_OFFSET		0x24</span>
<span class="p_add">+#define PM_INFO_MX7_DDRC_PHY_V_OFFSET		0x28</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_P_OFFSET		0x2c</span>
<span class="p_add">+#define PM_INFO_MX7_SRC_V_OFFSET		0x30</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_P_OFFSET		0x34</span>
<span class="p_add">+#define PM_INFO_MX7_IOMUXC_GPR_V_OFFSET		0x38</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_P_OFFSET		0x3c</span>
<span class="p_add">+#define PM_INFO_MX7_CCM_V_OFFSET		0x40</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_P_OFFSET		0x44</span>
<span class="p_add">+#define PM_INFO_MX7_GPC_V_OFFSET		0x48</span>
<span class="p_add">+#define PM_INFO_MX7_L2_P_OFFSET			0x4c</span>
<span class="p_add">+#define PM_INFO_MX7_L2_V_OFFSET			0x50</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_P_OFFSET		0x54</span>
<span class="p_add">+#define PM_INFO_MX7_ANATOP_V_OFFSET		0x58</span>
<span class="p_add">+#define PM_INFO_MX7_TTBR1_V_OFFSET		0x5c</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_NUM_OFFSET		0x60</span>
<span class="p_add">+#define PM_INFO_DDRC_REG_OFFSET			0x64</span>
<span class="p_add">+#define PM_INFO_DDRC_VALUE_OFFSET		0x68</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_NUM_OFFSET		0x164</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_REG_OFFSET		0x168</span>
<span class="p_add">+#define PM_INFO_DDRC_PHY_VALUE_OFFSET		0x16c</span>
<span class="p_add">+</span>
<span class="p_add">+#define MX7_SRC_GPR1	0x74</span>
<span class="p_add">+#define MX7_SRC_GPR2	0x78</span>
<span class="p_add">+#define GPC_PGC_FM	0xa00</span>
<span class="p_add">+#define ANADIG_SNVS_MISC_CTRL	0x380</span>
<span class="p_add">+#define DDRC_STAT	0x4</span>
<span class="p_add">+#define DDRC_PWRCTL	0x30</span>
<span class="p_add">+#define DDRC_PSTAT	0x3fc</span>
<span class="p_add">+#define DDRC_PCTRL_0	0x490</span>
<span class="p_add">+#define DDRC_DFIMISC	0x1b0</span>
<span class="p_add">+#define DDRC_SWCTL	0x320</span>
<span class="p_add">+#define DDRC_SWSTAT	0x324</span>
<span class="p_add">+#define DDRPHY_LP_CON0	0x18</span>
<span class="p_add">+</span>
<span class="p_add">+	.align 3</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Flush all data from the L1 data cache before disabling</span>
<span class="p_add">+	 * SCTLR.C bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable d-cache */</span>
<span class="p_add">+	mrc	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	bic	r7, r7, #(1 &lt;&lt; 2)</span>
<span class="p_add">+	mcr	p15, 0, r7, c1, c0, 0</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	push	{r0 - r10, lr}</span>
<span class="p_add">+	ldr	r7, =v7_flush_dcache_all</span>
<span class="p_add">+	mov	lr, pc</span>
<span class="p_add">+	mov	pc, r7</span>
<span class="p_add">+	pop	{r0 - r10, lr}</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable L1 data cache. */</span>
<span class="p_add">+	mrc	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	orr	r6, r6, #0x4</span>
<span class="p_add">+	mcr	p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_enter_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+1:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+2:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	2b</span>
<span class="p_add">+3:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	3b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddrc_exit_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+4:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	beq	4b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable auto self-refresh */</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 0)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro wait_delay</span>
<span class="p_add">+5:</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	5b</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_enter_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait rw port_busy clear */</span>
<span class="p_add">+	ldr	r6, =(0x1 &lt;&lt; 16)</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+6:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_PSTAT]</span>
<span class="p_add">+	ands	r7, r7, r6</span>
<span class="p_add">+	bne	6b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	/* enter self-refresh bit 5 */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+7:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	7b</span>
<span class="p_add">+8:</span>
<span class="p_add">+	ldr	r7, [r11, #DDRC_STAT]</span>
<span class="p_add">+	ands	r7, r7, #0x20</span>
<span class="p_add">+	beq	8b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable dram clk */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 5)</span>
<span class="p_add">+	orr	r7, r7, #(1 &lt;&lt; 3)</span>
<span class="p_add">+	str	r7, [r11, #DDRC_PWRCTL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reset ddr_phy  */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* delay 7 us */</span>
<span class="p_add">+	ldr	r6, =6000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r11, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r11, r6]</span>
<span class="p_add">+	/* turn off ddr power */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r11, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro ddr_exit_retention</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	ldreq	r1, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldrne	r1, [r0, #PM_INFO_MX7_ANATOP_P_OFFSET]</span>
<span class="p_add">+	ldreq	r2, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r2, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r3, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldrne	r3, [r0, #PM_INFO_MX7_DDRC_P_OFFSET]</span>
<span class="p_add">+	ldreq	r4, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldrne	r4, [r0, #PM_INFO_MX7_DDRC_PHY_P_OFFSET]</span>
<span class="p_add">+	ldreq	r10, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	ldrne	r10, [r0, #PM_INFO_MX7_CCM_P_OFFSET]</span>
<span class="p_add">+	ldreq	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldrne	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* turn on ddr power */</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 29)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, =50</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	orr	r7, r7, #0x3</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x1</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+9:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r3, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	9b</span>
<span class="p_add">+	ldr	r7, =0x20</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do PHY, clear ddr_phy reset */</span>
<span class="p_add">+	ldr	r6, =0x1000</span>
<span class="p_add">+	ldr	r7, [r2, r6]</span>
<span class="p_add">+	bic	r7, r7, #0x2</span>
<span class="p_add">+	str	r7, [r2, r6]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =(0x1 &lt;&lt; 30)</span>
<span class="p_add">+	str	r7, [r1, #ANADIG_SNVS_MISC_CTRL]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* need to delay ~5mS */</span>
<span class="p_add">+	ldr	r6, =0x100000</span>
<span class="p_add">+	wait_delay</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRC_PHY_REG_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRC_PHY_REG_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+</span>
<span class="p_add">+10:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r4, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	10b</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	r5, #0x0</span>
<span class="p_add">+	beq	101f</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+101:</span>
<span class="p_add">+	ldr	r7, =0x2</span>
<span class="p_add">+	add	r9, r10, #0x4000</span>
<span class="p_add">+	str	r7, [r9, #0x130]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r7, =0xf</span>
<span class="p_add">+	str	r7, [r4, #DDRPHY_LP_CON0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* wait until self-refresh mode entered */</span>
<span class="p_add">+11:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x3</span>
<span class="p_add">+	bne	11b</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_DFIMISC]</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_SWCTL]</span>
<span class="p_add">+12:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_SWSTAT]</span>
<span class="p_add">+	and	r7, r7, #0x1</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	12b</span>
<span class="p_add">+13:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x20</span>
<span class="p_add">+	cmp	r7, #0x20</span>
<span class="p_add">+	bne	13b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let DDR out of self-refresh */</span>
<span class="p_add">+	ldr	r7, =0x0</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PWRCTL]</span>
<span class="p_add">+14:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x30</span>
<span class="p_add">+	cmp	r7, #0x0</span>
<span class="p_add">+	bne	14b</span>
<span class="p_add">+</span>
<span class="p_add">+15:</span>
<span class="p_add">+	ldr	r7, [r3, #DDRC_STAT]</span>
<span class="p_add">+	and	r7, r7, #0x3</span>
<span class="p_add">+	cmp	r7, #0x1</span>
<span class="p_add">+	bne	15b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable port */</span>
<span class="p_add">+	ldr	r7, =0x1</span>
<span class="p_add">+	str	r7, [r3, #DDRC_PCTRL_0]</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(imx7_suspend)</span>
<span class="p_add">+	push	{r4-r12}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The value of r0 is mapped the same in origin table and IRAM table,</span>
<span class="p_add">+	 * thus no need to care r0 here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r1, [r0, #PM_INFO_PBASE_OFFSET]</span>
<span class="p_add">+	ldr	r2, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	ldr	r3, [r0, #PM_INFO_DDR_TYPE_OFFSET]</span>
<span class="p_add">+	ldr	r4, [r0, #PM_INFO_PM_INFO_SIZE_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * counting the resume address in iram</span>
<span class="p_add">+	 * to set it in SRC register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, =imx7_suspend</span>
<span class="p_add">+	ldr	r7, =resume</span>
<span class="p_add">+	sub	r7, r7, r6</span>
<span class="p_add">+	add	r8, r1, r4</span>
<span class="p_add">+	add	r9, r8, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	/* store physical resume addr and pm_info address. */</span>
<span class="p_add">+	str	r9, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r1, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	disable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure TLB contain the addr we want,</span>
<span class="p_add">+	 * as we will access them after DDR is in</span>
<span class="p_add">+	 * self-refresh mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r0, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_CCM_V_OFFSET]</span>
<span class="p_add">+	add	r6, #0x4000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_ANATOP_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	add	r6, #0x1000</span>
<span class="p_add">+	ldr	r7, [r6]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+	ldr	r7, [r6, #0x490]</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_MX7_DDRC_PHY_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r6, #0x0]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	ddr_only_self_refresh</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_enter_retention</span>
<span class="p_add">+	b	ddr_retention_enter_out</span>
<span class="p_add">+ddr_only_self_refresh:</span>
<span class="p_add">+	ddrc_enter_self_refresh</span>
<span class="p_add">+ddr_retention_enter_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zzz, enter stop mode */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x0</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	wfi_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	wfi_ddr_retention_out</span>
<span class="p_add">+wfi_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+wfi_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_IOMUXC_GPR_V_OFFSET]</span>
<span class="p_add">+	ldr	r7, =0x170</span>
<span class="p_add">+	orr	r7, r7, #0x8</span>
<span class="p_add">+	str	r7, [r11, #0x20]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_V_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_l1_dcache</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	{r4-r12}</span>
<span class="p_add">+	/* return to suspend finish */</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+</span>
<span class="p_add">+resume:</span>
<span class="p_add">+	/* invalidate L1 I-cache first */</span>
<span class="p_add">+	mov     r6, #0x0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 6</span>
<span class="p_add">+	/* enable the Icache and branch prediction */</span>
<span class="p_add">+	mov     r6, #0x1800</span>
<span class="p_add">+	mcr     p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get physical resume address from pm_info. */</span>
<span class="p_add">+	ldr	lr, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	/* clear core0&#39;s entry and parameter */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_SRC_P_OFFSET]</span>
<span class="p_add">+	mov	r7, #0x0</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR1]</span>
<span class="p_add">+	str	r7, [r11, #MX7_SRC_GPR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	r5, #0x1</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_MX7_GPC_P_OFFSET]</span>
<span class="p_add">+	ldr	r7, [r11, #GPC_PGC_FM]</span>
<span class="p_add">+	cmp	r7, #0</span>
<span class="p_add">+	beq	dsm_ddr_self_refresh_out</span>
<span class="p_add">+</span>
<span class="p_add">+	ddr_exit_retention</span>
<span class="p_add">+	b	dsm_ddr_retention_out</span>
<span class="p_add">+dsm_ddr_self_refresh_out:</span>
<span class="p_add">+	ddrc_exit_self_refresh</span>
<span class="p_add">+dsm_ddr_retention_out:</span>
<span class="p_add">+</span>
<span class="p_add">+	mov	pc, lr</span>
<span class="p_add">+ENDPROC(imx7_suspend)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ca7_cpu_resume)</span>
<span class="p_add">+	bl	v7_invalidate_l1</span>
<span class="p_add">+	b	cpu_resume</span>
<span class="p_add">+ENDPROC(ca7_cpu_resume)</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



