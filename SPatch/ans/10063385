
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,10/16] iommu: introduce device fault report API - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,10/16] iommu: introduce device fault report API</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 17, 2017, 6:55 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1510944914-54430-11-git-send-email-jacob.jun.pan@linux.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10063385/mbox/"
   >mbox</a>
|
   <a href="/patch/10063385/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10063385/">/patch/10063385/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	57E31601D3 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Nov 2017 18:56:12 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4A15E20408
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Nov 2017 18:56:12 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 3BA2728AE0; Fri, 17 Nov 2017 18:56:12 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8DC6E20408
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Nov 2017 18:56:11 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1161559AbdKQS4I (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 17 Nov 2017 13:56:08 -0500
Received: from mga03.intel.com ([134.134.136.65]:54156 &quot;EHLO mga03.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S966041AbdKQSyb (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 17 Nov 2017 13:54:31 -0500
Received: from orsmga003.jf.intel.com ([10.7.209.27])
	by orsmga103.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384;
	17 Nov 2017 10:54:15 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.44,410,1505804400&quot;; d=&quot;scan&#39;208&quot;;a=&quot;3461192&quot;
Received: from jacob-builder.jf.intel.com ([10.7.199.155])
	by orsmga003.jf.intel.com with ESMTP; 17 Nov 2017 10:54:15 -0800
From: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
To: iommu@lists.linux-foundation.org, LKML &lt;linux-kernel@vger.kernel.org&gt;,
	Joerg Roedel &lt;joro@8bytes.org&gt;, David Woodhouse &lt;dwmw2@infradead.org&gt;,
	Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;,
	Rafael Wysocki &lt;rafael.j.wysocki@intel.com&gt;,
	Alex Williamson &lt;alex.williamson@redhat.com&gt;
Cc: &quot;Liu, Yi L&quot; &lt;yi.l.liu@intel.com&gt;, Lan Tianyu &lt;tianyu.lan@intel.com&gt;,
	&quot;Tian, Kevin&quot; &lt;kevin.tian@intel.com&gt;, Raj Ashok &lt;ashok.raj@intel.com&gt;,
	Jean Delvare &lt;khali@linux-fr.org&gt;,
	&quot;Christoph Hellwig&quot; &lt;hch@infradead.org&gt;,
	Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
Subject: [PATCH v3 10/16] iommu: introduce device fault report API
Date: Fri, 17 Nov 2017 10:55:08 -0800
Message-Id: &lt;1510944914-54430-11-git-send-email-jacob.jun.pan@linux.intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1510944914-54430-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
References: &lt;1510944914-54430-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Nov. 17, 2017, 6:55 p.m.</div>
<pre class="content">
Traditionally, device specific faults are detected and handled within
their own device drivers. When IOMMU is enabled, faults such as DMA
related transactions are detected by IOMMU. There is no generic
reporting mechanism to report faults back to the in-kernel device
driver or the guest OS in case of assigned devices.

Faults detected by IOMMU is based on the transaction&#39;s source ID which
can be reported at per device basis, regardless of the device type is a
PCI device or not.

The fault types include recoverable (e.g. page request) and
unrecoverable faults(e.g. access error). In most cases, faults can be
handled by IOMMU drivers internally. The primary use cases are as
follows:
1. page request fault originated from an SVM capable device that is
assigned to guest via vIOMMU. In this case, the first level page tables
are owned by the guest. Page request must be propagated to the guest to
let guest OS fault in the pages then send page response. In this
mechanism, the direct receiver of IOMMU fault notification is VFIO,
which can relay notification events to QEMU or other user space
software.

2. faults need more subtle handling by device drivers. Other than
simply invoke reset function, there are needs to let device driver
handle the fault with a smaller impact.

This patchset is intended to create a generic fault report API such
that it can scale as follows:
- all IOMMU types
- PCI and non-PCI devices
- recoverable and unrecoverable faults
- VFIO and other other in kernel users
- DMA &amp; IRQ remapping (TBD)
The original idea was brought up by David Woodhouse and discussions
summarized at https://lwn.net/Articles/608914/.
<span class="signed-off-by">
Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
---
 drivers/iommu/iommu.c | 63 ++++++++++++++++++++++++++++++++++++++++++++++++++-
 include/linux/iommu.h | 36 +++++++++++++++++++++++++++++
 2 files changed, 98 insertions(+), 1 deletion(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=99681">Lu Baolu</a> - Dec. 5, 2017, 6:22 a.m.</div>
<pre class="content">
Hi,

On 11/18/2017 02:55 AM, Jacob Pan wrote:
<span class="quote">&gt; Traditionally, device specific faults are detected and handled within</span>
<span class="quote">&gt; their own device drivers. When IOMMU is enabled, faults such as DMA</span>
<span class="quote">&gt; related transactions are detected by IOMMU. There is no generic</span>
<span class="quote">&gt; reporting mechanism to report faults back to the in-kernel device</span>
<span class="quote">&gt; driver or the guest OS in case of assigned devices.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Faults detected by IOMMU is based on the transaction&#39;s source ID which</span>
<span class="quote">&gt; can be reported at per device basis, regardless of the device type is a</span>
<span class="quote">&gt; PCI device or not.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The fault types include recoverable (e.g. page request) and</span>
<span class="quote">&gt; unrecoverable faults(e.g. access error). In most cases, faults can be</span>
<span class="quote">&gt; handled by IOMMU drivers internally. The primary use cases are as</span>
<span class="quote">&gt; follows:</span>
<span class="quote">&gt; 1. page request fault originated from an SVM capable device that is</span>
<span class="quote">&gt; assigned to guest via vIOMMU. In this case, the first level page tables</span>
<span class="quote">&gt; are owned by the guest. Page request must be propagated to the guest to</span>
<span class="quote">&gt; let guest OS fault in the pages then send page response. In this</span>
<span class="quote">&gt; mechanism, the direct receiver of IOMMU fault notification is VFIO,</span>
<span class="quote">&gt; which can relay notification events to QEMU or other user space</span>
<span class="quote">&gt; software.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 2. faults need more subtle handling by device drivers. Other than</span>
<span class="quote">&gt; simply invoke reset function, there are needs to let device driver</span>
<span class="quote">&gt; handle the fault with a smaller impact.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This patchset is intended to create a generic fault report API such</span>
<span class="quote">&gt; that it can scale as follows:</span>
<span class="quote">&gt; - all IOMMU types</span>
<span class="quote">&gt; - PCI and non-PCI devices</span>
<span class="quote">&gt; - recoverable and unrecoverable faults</span>
<span class="quote">&gt; - VFIO and other other in kernel users</span>
<span class="quote">&gt; - DMA &amp; IRQ remapping (TBD)</span>
<span class="quote">&gt; The original idea was brought up by David Woodhouse and discussions</span>
<span class="quote">&gt; summarized at https://lwn.net/Articles/608914/.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/iommu/iommu.c | 63 ++++++++++++++++++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt;  include/linux/iommu.h | 36 +++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  2 files changed, 98 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; index 829e9e9..97b7990 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; @@ -581,6 +581,12 @@ int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
<span class="quote">&gt;  		goto err_free_name;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	dev-&gt;iommu_param = kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!dev-&gt;iommu_param) {</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +		goto err_free_name;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	kobject_get(group-&gt;devices_kobj);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	dev-&gt;iommu_group = group;</span>
<span class="quote">&gt; @@ -657,7 +663,7 @@ void iommu_group_remove_device(struct device *dev)</span>
<span class="quote">&gt;  	sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	trace_remove_device_from_group(group-&gt;id, dev);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; +	kfree(dev-&gt;iommu_param);</span>
<span class="quote">&gt;  	kfree(device-&gt;name);</span>
<span class="quote">&gt;  	kfree(device);</span>
<span class="quote">&gt;  	dev-&gt;iommu_group = NULL;</span>
<span class="quote">&gt; @@ -791,6 +797,61 @@ int iommu_group_unregister_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +					iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +					void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Device iommu_param should have been allocated when device is</span>
<span class="quote">&gt; +	 * added to its iommu_group.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (!idata)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	/* Only allow one fault handler registered for each device */</span>
<span class="quote">&gt; +	if (idata-&gt;fault_param)</span>
<span class="quote">&gt; +		return -EBUSY;</span>
<span class="quote">&gt; +	get_device(dev);</span>
<span class="quote">&gt; +	idata-&gt;fault_param =</span>
<span class="quote">&gt; +		kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!idata-&gt;fault_param)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	idata-&gt;fault_param-&gt;handler = handler;</span>
<span class="quote">&gt; +	idata-&gt;fault_param-&gt;data = data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!idata)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	kfree(idata-&gt;fault_param);</span>
<span class="quote">&gt; +	idata-&gt;fault_param = NULL;</span>
<span class="quote">&gt; +	put_device(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	/* we only report device fault if there is a handler registered */</span>
<span class="quote">&gt; +	if (!dev-&gt;iommu_param || !dev-&gt;iommu_param-&gt;fault_param ||</span>
<span class="quote">&gt; +		!dev-&gt;iommu_param-&gt;fault_param-&gt;handler)</span>

Can this replaced by:

    if (!iommu_has_device_fault_handler(dev))

?

Best regards,
Lu Baolu
<span class="quote">
&gt; +		return -ENOSYS;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return dev-&gt;iommu_param-&gt;fault_param-&gt;handler(evt,</span>
<span class="quote">&gt; +						dev-&gt;iommu_param-&gt;fault_param-&gt;data);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_report_device_fault);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /**</span>
<span class="quote">&gt;   * iommu_group_id - Return ID for a group</span>
<span class="quote">&gt;   * @group: the group to ID</span>
<span class="quote">&gt; diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="quote">&gt; index dfda89b..841c044 100644</span>
<span class="quote">&gt; --- a/include/linux/iommu.h</span>
<span class="quote">&gt; +++ b/include/linux/iommu.h</span>
<span class="quote">&gt; @@ -463,6 +463,14 @@ extern int iommu_group_register_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  					 struct notifier_block *nb);</span>
<span class="quote">&gt;  extern int iommu_group_unregister_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  					   struct notifier_block *nb);</span>
<span class="quote">&gt; +extern int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +					iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +					void *data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern int iommu_unregister_device_fault_handler(struct device *dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  extern int iommu_group_id(struct iommu_group *group);</span>
<span class="quote">&gt;  extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);</span>
<span class="quote">&gt;  extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);</span>
<span class="quote">&gt; @@ -481,6 +489,12 @@ extern void iommu_domain_window_disable(struct iommu_domain *domain, u32 wnd_nr)</span>
<span class="quote">&gt;  extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,</span>
<span class="quote">&gt;  			      unsigned long iova, int flags);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static inline bool iommu_has_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return dev-&gt;iommu_param &amp;&amp; dev-&gt;iommu_param-&gt;fault_param &amp;&amp;</span>
<span class="quote">&gt; +		dev-&gt;iommu_param-&gt;fault_param-&gt;handler;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static inline void iommu_flush_tlb_all(struct iommu_domain *domain)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	if (domain-&gt;ops-&gt;flush_iotlb_all)</span>
<span class="quote">&gt; @@ -734,6 +748,28 @@ static inline int iommu_group_unregister_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static inline int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +						iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +						void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline bool iommu_has_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return false;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static inline int iommu_group_id(struct iommu_group *group)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	return -ENODEV;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - Dec. 7, 2017, 9:27 p.m.</div>
<pre class="content">
On Fri, 17 Nov 2017 10:55:08 -0800
Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt; wrote:
<span class="quote">
&gt; Traditionally, device specific faults are detected and handled within</span>
<span class="quote">&gt; their own device drivers. When IOMMU is enabled, faults such as DMA</span>
<span class="quote">&gt; related transactions are detected by IOMMU. There is no generic</span>
<span class="quote">&gt; reporting mechanism to report faults back to the in-kernel device</span>
<span class="quote">&gt; driver or the guest OS in case of assigned devices.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Faults detected by IOMMU is based on the transaction&#39;s source ID which</span>
<span class="quote">&gt; can be reported at per device basis, regardless of the device type is a</span>
<span class="quote">&gt; PCI device or not.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The fault types include recoverable (e.g. page request) and</span>
<span class="quote">&gt; unrecoverable faults(e.g. access error). In most cases, faults can be</span>
<span class="quote">&gt; handled by IOMMU drivers internally. The primary use cases are as</span>
<span class="quote">&gt; follows:</span>
<span class="quote">&gt; 1. page request fault originated from an SVM capable device that is</span>
<span class="quote">&gt; assigned to guest via vIOMMU. In this case, the first level page tables</span>
<span class="quote">&gt; are owned by the guest. Page request must be propagated to the guest to</span>
<span class="quote">&gt; let guest OS fault in the pages then send page response. In this</span>
<span class="quote">&gt; mechanism, the direct receiver of IOMMU fault notification is VFIO,</span>
<span class="quote">&gt; which can relay notification events to QEMU or other user space</span>
<span class="quote">&gt; software.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 2. faults need more subtle handling by device drivers. Other than</span>
<span class="quote">&gt; simply invoke reset function, there are needs to let device driver</span>
<span class="quote">&gt; handle the fault with a smaller impact.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This patchset is intended to create a generic fault report API such</span>
<span class="quote">&gt; that it can scale as follows:</span>
<span class="quote">&gt; - all IOMMU types</span>
<span class="quote">&gt; - PCI and non-PCI devices</span>
<span class="quote">&gt; - recoverable and unrecoverable faults</span>
<span class="quote">&gt; - VFIO and other other in kernel users</span>
<span class="quote">&gt; - DMA &amp; IRQ remapping (TBD)</span>
<span class="quote">&gt; The original idea was brought up by David Woodhouse and discussions</span>
<span class="quote">&gt; summarized at https://lwn.net/Articles/608914/.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/iommu/iommu.c | 63 ++++++++++++++++++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt;  include/linux/iommu.h | 36 +++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  2 files changed, 98 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; index 829e9e9..97b7990 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; @@ -581,6 +581,12 @@ int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
<span class="quote">&gt;  		goto err_free_name;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	dev-&gt;iommu_param = kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!dev-&gt;iommu_param) {</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +		goto err_free_name;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	kobject_get(group-&gt;devices_kobj);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	dev-&gt;iommu_group = group;</span>
<span class="quote">&gt; @@ -657,7 +663,7 @@ void iommu_group_remove_device(struct device *dev)</span>
<span class="quote">&gt;  	sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	trace_remove_device_from_group(group-&gt;id, dev);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; +	kfree(dev-&gt;iommu_param);</span>
<span class="quote">&gt;  	kfree(device-&gt;name);</span>
<span class="quote">&gt;  	kfree(device);</span>
<span class="quote">&gt;  	dev-&gt;iommu_group = NULL;</span>
<span class="quote">&gt; @@ -791,6 +797,61 @@ int iommu_group_unregister_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +					iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +					void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Device iommu_param should have been allocated when device is</span>
<span class="quote">&gt; +	 * added to its iommu_group.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (!idata)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	/* Only allow one fault handler registered for each device */</span>
<span class="quote">&gt; +	if (idata-&gt;fault_param)</span>
<span class="quote">&gt; +		return -EBUSY;</span>
<span class="quote">&gt; +	get_device(dev);</span>
<span class="quote">&gt; +	idata-&gt;fault_param =</span>
<span class="quote">&gt; +		kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!idata-&gt;fault_param)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	idata-&gt;fault_param-&gt;handler = handler;</span>
<span class="quote">&gt; +	idata-&gt;fault_param-&gt;data = data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!idata)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	kfree(idata-&gt;fault_param);</span>
<span class="quote">&gt; +	idata-&gt;fault_param = NULL;</span>
<span class="quote">&gt; +	put_device(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	/* we only report device fault if there is a handler registered */</span>
<span class="quote">&gt; +	if (!dev-&gt;iommu_param || !dev-&gt;iommu_param-&gt;fault_param ||</span>
<span class="quote">&gt; +		!dev-&gt;iommu_param-&gt;fault_param-&gt;handler)</span>
<span class="quote">&gt; +		return -ENOSYS;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return dev-&gt;iommu_param-&gt;fault_param-&gt;handler(evt,</span>
<span class="quote">&gt; +						dev-&gt;iommu_param-&gt;fault_param-&gt;data);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_report_device_fault);</span>
<span class="quote">&gt; +</span>

Isn&#39;t this all rather racy?  I see that we can have multiple callers to
register racing.  Unregister is buggy, allowing any caller to decrement
the device reference regardless of whether there&#39;s one outstanding
through this interface.  The reporting callout can also race with an
unregistration.  Might need a mutex on iommu_param to avoid.
<span class="quote">
&gt;  /**</span>
<span class="quote">&gt;   * iommu_group_id - Return ID for a group</span>
<span class="quote">&gt;   * @group: the group to ID</span>
<span class="quote">&gt; diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="quote">&gt; index dfda89b..841c044 100644</span>
<span class="quote">&gt; --- a/include/linux/iommu.h</span>
<span class="quote">&gt; +++ b/include/linux/iommu.h</span>
<span class="quote">&gt; @@ -463,6 +463,14 @@ extern int iommu_group_register_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  					 struct notifier_block *nb);</span>
<span class="quote">&gt;  extern int iommu_group_unregister_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  					   struct notifier_block *nb);</span>
<span class="quote">&gt; +extern int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +					iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +					void *data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern int iommu_unregister_device_fault_handler(struct device *dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  extern int iommu_group_id(struct iommu_group *group);</span>
<span class="quote">&gt;  extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);</span>
<span class="quote">&gt;  extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);</span>
<span class="quote">&gt; @@ -481,6 +489,12 @@ extern void iommu_domain_window_disable(struct iommu_domain *domain, u32 wnd_nr)</span>
<span class="quote">&gt;  extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,</span>
<span class="quote">&gt;  			      unsigned long iova, int flags);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static inline bool iommu_has_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return dev-&gt;iommu_param &amp;&amp; dev-&gt;iommu_param-&gt;fault_param &amp;&amp;</span>
<span class="quote">&gt; +		dev-&gt;iommu_param-&gt;fault_param-&gt;handler;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>

This interface is racy by design, there&#39;s no guarantee that the
handler isn&#39;t immediately unregistered after this check. Thanks,

Alex
<span class="quote">
&gt;  static inline void iommu_flush_tlb_all(struct iommu_domain *domain)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	if (domain-&gt;ops-&gt;flush_iotlb_all)</span>
<span class="quote">&gt; @@ -734,6 +748,28 @@ static inline int iommu_group_unregister_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static inline int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +						iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +						void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline bool iommu_has_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return false;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static inline int iommu_group_id(struct iommu_group *group)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	return -ENODEV;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Dec. 8, 2017, 8:23 p.m.</div>
<pre class="content">
On Thu, 7 Dec 2017 14:27:25 -0700
Alex Williamson &lt;alex.williamson@redhat.com&gt; wrote:
<span class="quote">
&gt; On Fri, 17 Nov 2017 10:55:08 -0800</span>
<span class="quote">&gt; Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Traditionally, device specific faults are detected and handled</span>
<span class="quote">&gt; &gt; within their own device drivers. When IOMMU is enabled, faults such</span>
<span class="quote">&gt; &gt; as DMA related transactions are detected by IOMMU. There is no</span>
<span class="quote">&gt; &gt; generic reporting mechanism to report faults back to the in-kernel</span>
<span class="quote">&gt; &gt; device driver or the guest OS in case of assigned devices.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Faults detected by IOMMU is based on the transaction&#39;s source ID</span>
<span class="quote">&gt; &gt; which can be reported at per device basis, regardless of the device</span>
<span class="quote">&gt; &gt; type is a PCI device or not.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The fault types include recoverable (e.g. page request) and</span>
<span class="quote">&gt; &gt; unrecoverable faults(e.g. access error). In most cases, faults can</span>
<span class="quote">&gt; &gt; be handled by IOMMU drivers internally. The primary use cases are as</span>
<span class="quote">&gt; &gt; follows:</span>
<span class="quote">&gt; &gt; 1. page request fault originated from an SVM capable device that is</span>
<span class="quote">&gt; &gt; assigned to guest via vIOMMU. In this case, the first level page</span>
<span class="quote">&gt; &gt; tables are owned by the guest. Page request must be propagated to</span>
<span class="quote">&gt; &gt; the guest to let guest OS fault in the pages then send page</span>
<span class="quote">&gt; &gt; response. In this mechanism, the direct receiver of IOMMU fault</span>
<span class="quote">&gt; &gt; notification is VFIO, which can relay notification events to QEMU</span>
<span class="quote">&gt; &gt; or other user space software.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 2. faults need more subtle handling by device drivers. Other than</span>
<span class="quote">&gt; &gt; simply invoke reset function, there are needs to let device driver</span>
<span class="quote">&gt; &gt; handle the fault with a smaller impact.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This patchset is intended to create a generic fault report API such</span>
<span class="quote">&gt; &gt; that it can scale as follows:</span>
<span class="quote">&gt; &gt; - all IOMMU types</span>
<span class="quote">&gt; &gt; - PCI and non-PCI devices</span>
<span class="quote">&gt; &gt; - recoverable and unrecoverable faults</span>
<span class="quote">&gt; &gt; - VFIO and other other in kernel users</span>
<span class="quote">&gt; &gt; - DMA &amp; IRQ remapping (TBD)</span>
<span class="quote">&gt; &gt; The original idea was brought up by David Woodhouse and discussions</span>
<span class="quote">&gt; &gt; summarized at https://lwn.net/Articles/608914/.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  drivers/iommu/iommu.c | 63</span>
<span class="quote">&gt; &gt; ++++++++++++++++++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt; &gt; include/linux/iommu.h | 36 +++++++++++++++++++++++++++++ 2 files</span>
<span class="quote">&gt; &gt; changed, 98 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; index 829e9e9..97b7990 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; @@ -581,6 +581,12 @@ int iommu_group_add_device(struct iommu_group</span>
<span class="quote">&gt; &gt; *group, struct device *dev) goto err_free_name;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +	dev-&gt;iommu_param = kzalloc(sizeof(struct</span>
<span class="quote">&gt; &gt; iommu_fault_param), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;iommu_param) {</span>
<span class="quote">&gt; &gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; +		goto err_free_name;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  	kobject_get(group-&gt;devices_kobj);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	dev-&gt;iommu_group = group;</span>
<span class="quote">&gt; &gt; @@ -657,7 +663,7 @@ void iommu_group_remove_device(struct device</span>
<span class="quote">&gt; &gt; *dev) sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	trace_remove_device_from_group(group-&gt;id, dev);</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt; +	kfree(dev-&gt;iommu_param);</span>
<span class="quote">&gt; &gt;  	kfree(device-&gt;name);</span>
<span class="quote">&gt; &gt;  	kfree(device);</span>
<span class="quote">&gt; &gt;  	dev-&gt;iommu_group = NULL;</span>
<span class="quote">&gt; &gt; @@ -791,6 +797,61 @@ int iommu_group_unregister_notifier(struct</span>
<span class="quote">&gt; &gt; iommu_group *group, }</span>
<span class="quote">&gt; &gt;  EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; &gt; +					iommu_dev_fault_handler_t</span>
<span class="quote">&gt; &gt; handler,</span>
<span class="quote">&gt; &gt; +					void *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * Device iommu_param should have been allocated when</span>
<span class="quote">&gt; &gt; device is</span>
<span class="quote">&gt; &gt; +	 * added to its iommu_group.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	if (!idata)</span>
<span class="quote">&gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; +	/* Only allow one fault handler registered for each device</span>
<span class="quote">&gt; &gt; */</span>
<span class="quote">&gt; &gt; +	if (idata-&gt;fault_param)</span>
<span class="quote">&gt; &gt; +		return -EBUSY;</span>
<span class="quote">&gt; &gt; +	get_device(dev);</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param =</span>
<span class="quote">&gt; &gt; +		kzalloc(sizeof(struct iommu_fault_param),</span>
<span class="quote">&gt; &gt; GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!idata-&gt;fault_param)</span>
<span class="quote">&gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param-&gt;handler = handler;</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param-&gt;data = data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!idata)</span>
<span class="quote">&gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	kfree(idata-&gt;fault_param);</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param = NULL;</span>
<span class="quote">&gt; &gt; +	put_device(dev);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +int iommu_report_device_fault(struct device *dev, struct</span>
<span class="quote">&gt; &gt; iommu_fault_event *evt) +{</span>
<span class="quote">&gt; &gt; +	/* we only report device fault if there is a handler</span>
<span class="quote">&gt; &gt; registered */</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;iommu_param || !dev-&gt;iommu_param-&gt;fault_param ||</span>
<span class="quote">&gt; &gt; +		!dev-&gt;iommu_param-&gt;fault_param-&gt;handler)</span>
<span class="quote">&gt; &gt; +		return -ENOSYS;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return dev-&gt;iommu_param-&gt;fault_param-&gt;handler(evt,</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; dev-&gt;iommu_param-&gt;fault_param-&gt;data); +}</span>
<span class="quote">&gt; &gt; +EXPORT_SYMBOL_GPL(iommu_report_device_fault);</span>
<span class="quote">&gt; &gt; +  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Isn&#39;t this all rather racy?  I see that we can have multiple callers</span>
<span class="quote">&gt; to register racing.</span>
I agree, should use a lock here to prevent unregister. For multiple
caller race, it won&#39;t happen since there is only one caller can
register handler.
<span class="quote">&gt;  Unregister is buggy, allowing any caller to</span>
<span class="quote">&gt; decrement the device reference regardless of whether there&#39;s one</span>
<span class="quote">&gt; outstanding through this interface.  The reporting callout can also</span>
<span class="quote">&gt; race with an unregistration.  Might need a mutex on iommu_param to</span>
<span class="quote">&gt; avoid.</span>
<span class="quote">&gt; </span>
you are right, forgot to check outstanding handler. will add mutex also.

Thanks,
<span class="quote">&gt; &gt;  /**</span>
<span class="quote">&gt; &gt;   * iommu_group_id - Return ID for a group</span>
<span class="quote">&gt; &gt;   * @group: the group to ID</span>
<span class="quote">&gt; &gt; diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="quote">&gt; &gt; index dfda89b..841c044 100644</span>
<span class="quote">&gt; &gt; --- a/include/linux/iommu.h</span>
<span class="quote">&gt; &gt; +++ b/include/linux/iommu.h</span>
<span class="quote">&gt; &gt; @@ -463,6 +463,14 @@ extern int</span>
<span class="quote">&gt; &gt; iommu_group_register_notifier(struct iommu_group *group, struct</span>
<span class="quote">&gt; &gt; notifier_block *nb); extern int</span>
<span class="quote">&gt; &gt; iommu_group_unregister_notifier(struct iommu_group *group, struct</span>
<span class="quote">&gt; &gt; notifier_block *nb); +extern int</span>
<span class="quote">&gt; &gt; iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; &gt; +					iommu_dev_fault_handler_t</span>
<span class="quote">&gt; &gt; handler,</span>
<span class="quote">&gt; &gt; +					void *data);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +extern int iommu_unregister_device_fault_handler(struct device</span>
<span class="quote">&gt; &gt; *dev); +</span>
<span class="quote">&gt; &gt; +extern int iommu_report_device_fault(struct device *dev, struct</span>
<span class="quote">&gt; &gt; iommu_fault_event *evt); +</span>
<span class="quote">&gt; &gt;  extern int iommu_group_id(struct iommu_group *group);</span>
<span class="quote">&gt; &gt;  extern struct iommu_group *iommu_group_get_for_dev(struct device</span>
<span class="quote">&gt; &gt; *dev); extern struct iommu_domain</span>
<span class="quote">&gt; &gt; *iommu_group_default_domain(struct iommu_group *); @@ -481,6</span>
<span class="quote">&gt; &gt; +489,12 @@ extern void iommu_domain_window_disable(struct</span>
<span class="quote">&gt; &gt; iommu_domain *domain, u32 wnd_nr) extern int</span>
<span class="quote">&gt; &gt; report_iommu_fault(struct iommu_domain *domain, struct device *dev,</span>
<span class="quote">&gt; &gt; unsigned long iova, int flags); +static inline bool</span>
<span class="quote">&gt; &gt; iommu_has_device_fault_handler(struct device *dev) +{</span>
<span class="quote">&gt; &gt; +	return dev-&gt;iommu_param &amp;&amp; dev-&gt;iommu_param-&gt;fault_param &amp;&amp;</span>
<span class="quote">&gt; &gt; +		dev-&gt;iommu_param-&gt;fault_param-&gt;handler;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This interface is racy by design, there&#39;s no guarantee that the</span>
<span class="quote">&gt; handler isn&#39;t immediately unregistered after this check. Thanks,</span>
<span class="quote">&gt; </span>
right, I will fold this check into report function and protect by a
lock. I was trying to save some cycles but it would not work with the
race condition.
<span class="quote">&gt; Alex</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  static inline void iommu_flush_tlb_all(struct iommu_domain *domain)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	if (domain-&gt;ops-&gt;flush_iotlb_all)</span>
<span class="quote">&gt; &gt; @@ -734,6 +748,28 @@ static inline int</span>
<span class="quote">&gt; &gt; iommu_group_unregister_notifier(struct iommu_group *group, return 0;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +static inline int iommu_register_device_fault_handler(struct</span>
<span class="quote">&gt; &gt; device *dev,</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; &gt; +						void *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static inline int iommu_unregister_device_fault_handler(struct</span>
<span class="quote">&gt; &gt; device *dev) +{</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static inline bool iommu_has_device_fault_handler(struct device</span>
<span class="quote">&gt; &gt; *dev) +{</span>
<span class="quote">&gt; &gt; +	return false;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static inline int iommu_report_device_fault(struct device *dev,</span>
<span class="quote">&gt; &gt; struct iommu_fault_event *evt) +{</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  static inline int iommu_group_id(struct iommu_group *group)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	return -ENODEV;  </span>
<span class="quote">&gt; </span>

[Jacob Pan]
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - Dec. 8, 2017, 8:59 p.m.</div>
<pre class="content">
On Fri, 8 Dec 2017 12:23:58 -0800
Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt; wrote:
<span class="quote">
&gt; On Thu, 7 Dec 2017 14:27:25 -0700</span>
<span class="quote">&gt; Alex Williamson &lt;alex.williamson@redhat.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; On Fri, 17 Nov 2017 10:55:08 -0800</span>
<span class="quote">&gt; &gt; Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt; &gt; Traditionally, device specific faults are detected and handled</span>
<span class="quote">&gt; &gt; &gt; within their own device drivers. When IOMMU is enabled, faults such</span>
<span class="quote">&gt; &gt; &gt; as DMA related transactions are detected by IOMMU. There is no</span>
<span class="quote">&gt; &gt; &gt; generic reporting mechanism to report faults back to the in-kernel</span>
<span class="quote">&gt; &gt; &gt; device driver or the guest OS in case of assigned devices.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Faults detected by IOMMU is based on the transaction&#39;s source ID</span>
<span class="quote">&gt; &gt; &gt; which can be reported at per device basis, regardless of the device</span>
<span class="quote">&gt; &gt; &gt; type is a PCI device or not.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The fault types include recoverable (e.g. page request) and</span>
<span class="quote">&gt; &gt; &gt; unrecoverable faults(e.g. access error). In most cases, faults can</span>
<span class="quote">&gt; &gt; &gt; be handled by IOMMU drivers internally. The primary use cases are as</span>
<span class="quote">&gt; &gt; &gt; follows:</span>
<span class="quote">&gt; &gt; &gt; 1. page request fault originated from an SVM capable device that is</span>
<span class="quote">&gt; &gt; &gt; assigned to guest via vIOMMU. In this case, the first level page</span>
<span class="quote">&gt; &gt; &gt; tables are owned by the guest. Page request must be propagated to</span>
<span class="quote">&gt; &gt; &gt; the guest to let guest OS fault in the pages then send page</span>
<span class="quote">&gt; &gt; &gt; response. In this mechanism, the direct receiver of IOMMU fault</span>
<span class="quote">&gt; &gt; &gt; notification is VFIO, which can relay notification events to QEMU</span>
<span class="quote">&gt; &gt; &gt; or other user space software.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; 2. faults need more subtle handling by device drivers. Other than</span>
<span class="quote">&gt; &gt; &gt; simply invoke reset function, there are needs to let device driver</span>
<span class="quote">&gt; &gt; &gt; handle the fault with a smaller impact.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; This patchset is intended to create a generic fault report API such</span>
<span class="quote">&gt; &gt; &gt; that it can scale as follows:</span>
<span class="quote">&gt; &gt; &gt; - all IOMMU types</span>
<span class="quote">&gt; &gt; &gt; - PCI and non-PCI devices</span>
<span class="quote">&gt; &gt; &gt; - recoverable and unrecoverable faults</span>
<span class="quote">&gt; &gt; &gt; - VFIO and other other in kernel users</span>
<span class="quote">&gt; &gt; &gt; - DMA &amp; IRQ remapping (TBD)</span>
<span class="quote">&gt; &gt; &gt; The original idea was brought up by David Woodhouse and discussions</span>
<span class="quote">&gt; &gt; &gt; summarized at https://lwn.net/Articles/608914/.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="quote">&gt; &gt; &gt; Signed-off-by: Ashok Raj &lt;ashok.raj@intel.com&gt;</span>
<span class="quote">&gt; &gt; &gt; ---</span>
<span class="quote">&gt; &gt; &gt;  drivers/iommu/iommu.c | 63</span>
<span class="quote">&gt; &gt; &gt; ++++++++++++++++++++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt; &gt; &gt; include/linux/iommu.h | 36 +++++++++++++++++++++++++++++ 2 files</span>
<span class="quote">&gt; &gt; &gt; changed, 98 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; &gt; index 829e9e9..97b7990 100644</span>
<span class="quote">&gt; &gt; &gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; &gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; &gt; @@ -581,6 +581,12 @@ int iommu_group_add_device(struct iommu_group</span>
<span class="quote">&gt; &gt; &gt; *group, struct device *dev) goto err_free_name;</span>
<span class="quote">&gt; &gt; &gt;  	}</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; +	dev-&gt;iommu_param = kzalloc(sizeof(struct</span>
<span class="quote">&gt; &gt; &gt; iommu_fault_param), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; &gt; +	if (!dev-&gt;iommu_param) {</span>
<span class="quote">&gt; &gt; &gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; &gt; +		goto err_free_name;</span>
<span class="quote">&gt; &gt; &gt; +	}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt;  	kobject_get(group-&gt;devices_kobj);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	dev-&gt;iommu_group = group;</span>
<span class="quote">&gt; &gt; &gt; @@ -657,7 +663,7 @@ void iommu_group_remove_device(struct device</span>
<span class="quote">&gt; &gt; &gt; *dev) sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	trace_remove_device_from_group(group-&gt;id, dev);</span>
<span class="quote">&gt; &gt; &gt; -</span>
<span class="quote">&gt; &gt; &gt; +	kfree(dev-&gt;iommu_param);</span>
<span class="quote">&gt; &gt; &gt;  	kfree(device-&gt;name);</span>
<span class="quote">&gt; &gt; &gt;  	kfree(device);</span>
<span class="quote">&gt; &gt; &gt;  	dev-&gt;iommu_group = NULL;</span>
<span class="quote">&gt; &gt; &gt; @@ -791,6 +797,61 @@ int iommu_group_unregister_notifier(struct</span>
<span class="quote">&gt; &gt; &gt; iommu_group *group, }</span>
<span class="quote">&gt; &gt; &gt;  EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; +int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; &gt; &gt; +					iommu_dev_fault_handler_t</span>
<span class="quote">&gt; &gt; &gt; handler,</span>
<span class="quote">&gt; &gt; &gt; +					void *data)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; &gt; +	 * Device iommu_param should have been allocated when</span>
<span class="quote">&gt; &gt; &gt; device is</span>
<span class="quote">&gt; &gt; &gt; +	 * added to its iommu_group.</span>
<span class="quote">&gt; &gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; &gt; +	if (!idata)</span>
<span class="quote">&gt; &gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; &gt; +	/* Only allow one fault handler registered for each device</span>
<span class="quote">&gt; &gt; &gt; */</span>
<span class="quote">&gt; &gt; &gt; +	if (idata-&gt;fault_param)</span>
<span class="quote">&gt; &gt; &gt; +		return -EBUSY;</span>
<span class="quote">&gt; &gt; &gt; +	get_device(dev);</span>
<span class="quote">&gt; &gt; &gt; +	idata-&gt;fault_param =</span>
<span class="quote">&gt; &gt; &gt; +		kzalloc(sizeof(struct iommu_fault_param),</span>
<span class="quote">&gt; &gt; &gt; GFP_KERNEL);</span>
<span class="quote">&gt; &gt; &gt; +	if (!idata-&gt;fault_param)</span>
<span class="quote">&gt; &gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; &gt; +	idata-&gt;fault_param-&gt;handler = handler;</span>
<span class="quote">&gt; &gt; &gt; +	idata-&gt;fault_param-&gt;data = data;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +	if (!idata)</span>
<span class="quote">&gt; &gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +	kfree(idata-&gt;fault_param);</span>
<span class="quote">&gt; &gt; &gt; +	idata-&gt;fault_param = NULL;</span>
<span class="quote">&gt; &gt; &gt; +	put_device(dev);</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +int iommu_report_device_fault(struct device *dev, struct</span>
<span class="quote">&gt; &gt; &gt; iommu_fault_event *evt) +{</span>
<span class="quote">&gt; &gt; &gt; +	/* we only report device fault if there is a handler</span>
<span class="quote">&gt; &gt; &gt; registered */</span>
<span class="quote">&gt; &gt; &gt; +	if (!dev-&gt;iommu_param || !dev-&gt;iommu_param-&gt;fault_param ||</span>
<span class="quote">&gt; &gt; &gt; +		!dev-&gt;iommu_param-&gt;fault_param-&gt;handler)</span>
<span class="quote">&gt; &gt; &gt; +		return -ENOSYS;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +	return dev-&gt;iommu_param-&gt;fault_param-&gt;handler(evt,</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; dev-&gt;iommu_param-&gt;fault_param-&gt;data); +}</span>
<span class="quote">&gt; &gt; &gt; +EXPORT_SYMBOL_GPL(iommu_report_device_fault);</span>
<span class="quote">&gt; &gt; &gt; +    </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Isn&#39;t this all rather racy?  I see that we can have multiple callers</span>
<span class="quote">&gt; &gt; to register racing.  </span>
<span class="quote">&gt; I agree, should use a lock here to prevent unregister. For multiple</span>
<span class="quote">&gt; caller race, it won&#39;t happen since there is only one caller can</span>
<span class="quote">&gt; register handler.</span>

If you have multiple simultaneous callers to
iommu_register_device_fault_handler, they can all get past the test
for fault_param (testing and setting is not atomic), then it&#39;s
indeterminate which handler gets installed.  Thanks,

Alex
<span class="quote">
&gt; &gt;  Unregister is buggy, allowing any caller to</span>
<span class="quote">&gt; &gt; decrement the device reference regardless of whether there&#39;s one</span>
<span class="quote">&gt; &gt; outstanding through this interface.  The reporting callout can also</span>
<span class="quote">&gt; &gt; race with an unregistration.  Might need a mutex on iommu_param to</span>
<span class="quote">&gt; &gt; avoid.</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; you are right, forgot to check outstanding handler. will add mutex also.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; &gt; &gt;  /**</span>
<span class="quote">&gt; &gt; &gt;   * iommu_group_id - Return ID for a group</span>
<span class="quote">&gt; &gt; &gt;   * @group: the group to ID</span>
<span class="quote">&gt; &gt; &gt; diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="quote">&gt; &gt; &gt; index dfda89b..841c044 100644</span>
<span class="quote">&gt; &gt; &gt; --- a/include/linux/iommu.h</span>
<span class="quote">&gt; &gt; &gt; +++ b/include/linux/iommu.h</span>
<span class="quote">&gt; &gt; &gt; @@ -463,6 +463,14 @@ extern int</span>
<span class="quote">&gt; &gt; &gt; iommu_group_register_notifier(struct iommu_group *group, struct</span>
<span class="quote">&gt; &gt; &gt; notifier_block *nb); extern int</span>
<span class="quote">&gt; &gt; &gt; iommu_group_unregister_notifier(struct iommu_group *group, struct</span>
<span class="quote">&gt; &gt; &gt; notifier_block *nb); +extern int</span>
<span class="quote">&gt; &gt; &gt; iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; &gt; &gt; +					iommu_dev_fault_handler_t</span>
<span class="quote">&gt; &gt; &gt; handler,</span>
<span class="quote">&gt; &gt; &gt; +					void *data);</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +extern int iommu_unregister_device_fault_handler(struct device</span>
<span class="quote">&gt; &gt; &gt; *dev); +</span>
<span class="quote">&gt; &gt; &gt; +extern int iommu_report_device_fault(struct device *dev, struct</span>
<span class="quote">&gt; &gt; &gt; iommu_fault_event *evt); +</span>
<span class="quote">&gt; &gt; &gt;  extern int iommu_group_id(struct iommu_group *group);</span>
<span class="quote">&gt; &gt; &gt;  extern struct iommu_group *iommu_group_get_for_dev(struct device</span>
<span class="quote">&gt; &gt; &gt; *dev); extern struct iommu_domain</span>
<span class="quote">&gt; &gt; &gt; *iommu_group_default_domain(struct iommu_group *); @@ -481,6</span>
<span class="quote">&gt; &gt; &gt; +489,12 @@ extern void iommu_domain_window_disable(struct</span>
<span class="quote">&gt; &gt; &gt; iommu_domain *domain, u32 wnd_nr) extern int</span>
<span class="quote">&gt; &gt; &gt; report_iommu_fault(struct iommu_domain *domain, struct device *dev,</span>
<span class="quote">&gt; &gt; &gt; unsigned long iova, int flags); +static inline bool</span>
<span class="quote">&gt; &gt; &gt; iommu_has_device_fault_handler(struct device *dev) +{</span>
<span class="quote">&gt; &gt; &gt; +	return dev-&gt;iommu_param &amp;&amp; dev-&gt;iommu_param-&gt;fault_param &amp;&amp;</span>
<span class="quote">&gt; &gt; &gt; +		dev-&gt;iommu_param-&gt;fault_param-&gt;handler;</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +    </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This interface is racy by design, there&#39;s no guarantee that the</span>
<span class="quote">&gt; &gt; handler isn&#39;t immediately unregistered after this check. Thanks,</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; right, I will fold this check into report function and protect by a</span>
<span class="quote">&gt; lock. I was trying to save some cycles but it would not work with the</span>
<span class="quote">&gt; race condition.</span>
<span class="quote">&gt; &gt; Alex</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt; &gt;  static inline void iommu_flush_tlb_all(struct iommu_domain *domain)</span>
<span class="quote">&gt; &gt; &gt;  {</span>
<span class="quote">&gt; &gt; &gt;  	if (domain-&gt;ops-&gt;flush_iotlb_all)</span>
<span class="quote">&gt; &gt; &gt; @@ -734,6 +748,28 @@ static inline int</span>
<span class="quote">&gt; &gt; &gt; iommu_group_unregister_notifier(struct iommu_group *group, return 0;</span>
<span class="quote">&gt; &gt; &gt;  }</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; +static inline int iommu_register_device_fault_handler(struct</span>
<span class="quote">&gt; &gt; &gt; device *dev,</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; &gt; &gt; +						void *data)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +static inline int iommu_unregister_device_fault_handler(struct</span>
<span class="quote">&gt; &gt; &gt; device *dev) +{</span>
<span class="quote">&gt; &gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +static inline bool iommu_has_device_fault_handler(struct device</span>
<span class="quote">&gt; &gt; &gt; *dev) +{</span>
<span class="quote">&gt; &gt; &gt; +	return false;</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +static inline int iommu_report_device_fault(struct device *dev,</span>
<span class="quote">&gt; &gt; &gt; struct iommu_fault_event *evt) +{</span>
<span class="quote">&gt; &gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; &gt; +}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt;  static inline int iommu_group_id(struct iommu_group *group)</span>
<span class="quote">&gt; &gt; &gt;  {</span>
<span class="quote">&gt; &gt; &gt;  	return -ENODEV;    </span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [Jacob Pan]</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Dec. 8, 2017, 9:22 p.m.</div>
<pre class="content">
On Tue, 5 Dec 2017 14:22:41 +0800
Lu Baolu &lt;baolu.lu@linux.intel.com&gt; wrote:
<span class="quote">
&gt; &gt; +int iommu_report_device_fault(struct device *dev, struct</span>
<span class="quote">&gt; &gt; iommu_fault_event *evt) +{</span>
<span class="quote">&gt; &gt; +	/* we only report device fault if there is a handler</span>
<span class="quote">&gt; &gt; registered */</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;iommu_param || !dev-&gt;iommu_param-&gt;fault_param ||</span>
<span class="quote">&gt; &gt; +		!dev-&gt;iommu_param-&gt;fault_param-&gt;handler)  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Can this replaced by:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     if (!iommu_has_device_fault_handler(dev))</span>
<span class="quote">&gt; </span>
right, and under a lock too.

Thanks,

Jacob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Dec. 8, 2017, 9:22 p.m.</div>
<pre class="content">
On Fri, 8 Dec 2017 13:59:09 -0700
Alex Williamson &lt;alex.williamson@redhat.com&gt; wrote:
<span class="quote">
&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Isn&#39;t this all rather racy?  I see that we can have multiple</span>
<span class="quote">&gt; &gt; &gt; callers to register racing.    </span>
<span class="quote">&gt; &gt; I agree, should use a lock here to prevent unregister. For multiple</span>
<span class="quote">&gt; &gt; caller race, it won&#39;t happen since there is only one caller can</span>
<span class="quote">&gt; &gt; register handler.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you have multiple simultaneous callers to</span>
<span class="quote">&gt; iommu_register_device_fault_handler, they can all get past the test</span>
<span class="quote">&gt; for fault_param (testing and setting is not atomic), then it&#39;s</span>
<span class="quote">&gt; indeterminate which handler gets installed.  Thanks,</span>
<span class="quote">&gt; </span>
I see, having the mutex would prevent it. Later callers would get
-EBUSY.
Thanks a lot!
<span class="quote">&gt; Alex</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Jan. 10, 2018, 12:39 p.m.</div>
<pre class="content">
On 17/11/17 18:55, Jacob Pan wrote:
[...]
<span class="quote">&gt; +static inline int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +						iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +						void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline bool iommu_has_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return false;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>

Not too important but these stubs, when CONFIG_IOMMU_API is disabled,
usually return an error value (-ENODEV) instead of 0.

Thanks,
Jean
<span class="quote">
&gt; +</span>
<span class="quote">&gt;  static inline int iommu_group_id(struct iommu_group *group)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	return -ENODEV;</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Jan. 18, 2018, 7:24 p.m.</div>
<pre class="content">
Hi Jacob,

I&#39;ve got minor comments after working with this patch, sorry for the
multiple replies

On 17/11/17 18:55, Jacob Pan wrote:
[...]
<span class="quote">&gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; index 829e9e9..97b7990 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; @@ -581,6 +581,12 @@ int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
<span class="quote">&gt;  		goto err_free_name;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	dev-&gt;iommu_param = kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>

This should be &quot;sizeof(struct iommu_param)&quot; or maybe
&quot;sizeof(*dev-&gt;iommu_param)&quot;.
<span class="quote">
&gt; +	if (!dev-&gt;iommu_param) {</span>
<span class="quote">&gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; +		goto err_free_name;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	kobject_get(group-&gt;devices_kobj);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	dev-&gt;iommu_group = group;</span>
<span class="quote">&gt; @@ -657,7 +663,7 @@ void iommu_group_remove_device(struct device *dev)</span>
<span class="quote">&gt;  	sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	trace_remove_device_from_group(group-&gt;id, dev);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; +	kfree(dev-&gt;iommu_param);</span>
<span class="quote">&gt;  	kfree(device-&gt;name);</span>
<span class="quote">&gt;  	kfree(device);</span>
<span class="quote">&gt;  	dev-&gt;iommu_group = NULL;</span>
<span class="quote">&gt; @@ -791,6 +797,61 @@ int iommu_group_unregister_notifier(struct iommu_group *group,</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; +int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; +					iommu_dev_fault_handler_t handler,</span>
<span class="quote">&gt; +					void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Device iommu_param should have been allocated when device is</span>
<span class="quote">&gt; +	 * added to its iommu_group.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (!idata)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	/* Only allow one fault handler registered for each device */</span>
<span class="quote">&gt; +	if (idata-&gt;fault_param)</span>
<span class="quote">&gt; +		return -EBUSY;</span>
<span class="quote">&gt; +	get_device(dev);</span>
<span class="quote">&gt; +	idata-&gt;fault_param =</span>
<span class="quote">&gt; +		kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!idata-&gt;fault_param)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	idata-&gt;fault_param-&gt;handler = handler;</span>
<span class="quote">&gt; +	idata-&gt;fault_param-&gt;data = data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!idata)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	kfree(idata-&gt;fault_param);</span>
<span class="quote">&gt; +	idata-&gt;fault_param = NULL;</span>
<span class="quote">&gt; +	put_device(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);</span>

We should probably document register() and unregister() functions since
they are part of the device driver API. If it helps I came up with:

/**
 * iommu_register_device_fault_handler() - Register a device fault handler
 * @dev: the device
 * @handler: the fault handler
 * @data: private data passed as argument to the handler
 *
 * When an IOMMU fault event is received, call this handler with the fault event
 * and data as argument. The handler should return 0. If the fault is
 * recoverable (IOMMU_FAULT_PAGE_REQ), the handler must also complete
 * the fault by calling iommu_page_response() with one of the following
 * response code:
 * - IOMMU_PAGE_RESP_SUCCESS: retry the translation
 * - IOMMU_PAGE_RESP_INVALID: terminate the fault
 * - IOMMU_PAGE_RESP_FAILURE: terminate the fault and stop reporting
 *   page faults if possible.
 *
 * Return 0 if the fault handler was installed successfully, or an error.
 */

/**
 * iommu_unregister_device_fault_handler() - Unregister the device fault handler
 * @dev: the device
 *
 * Remove the device fault handler installed with
 * iommu_register_device_fault_handler().
 *
 * Return 0 on success, or an error.
 */

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Jan. 23, 2018, 8:01 p.m.</div>
<pre class="content">
On Thu, 18 Jan 2018 19:24:52 +0000
Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:
<span class="quote">
&gt; Hi Jacob,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;ve got minor comments after working with this patch, sorry for the</span>
<span class="quote">&gt; multiple replies</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 17/11/17 18:55, Jacob Pan wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; index 829e9e9..97b7990 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; @@ -581,6 +581,12 @@ int iommu_group_add_device(struct iommu_group</span>
<span class="quote">&gt; &gt; *group, struct device *dev) goto err_free_name;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +	dev-&gt;iommu_param = kzalloc(sizeof(struct</span>
<span class="quote">&gt; &gt; iommu_fault_param), GFP_KERNEL);  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This should be &quot;sizeof(struct iommu_param)&quot; or maybe</span>
<span class="quote">&gt; &quot;sizeof(*dev-&gt;iommu_param)&quot;.</span>
<span class="quote">&gt; </span>
good catch, thanks,
<span class="quote">&gt; &gt; +	if (!dev-&gt;iommu_param) {</span>
<span class="quote">&gt; &gt; +		ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; +		goto err_free_name;</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  	kobject_get(group-&gt;devices_kobj);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	dev-&gt;iommu_group = group;</span>
<span class="quote">&gt; &gt; @@ -657,7 +663,7 @@ void iommu_group_remove_device(struct device</span>
<span class="quote">&gt; &gt; *dev) sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	trace_remove_device_from_group(group-&gt;id, dev);</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt; +	kfree(dev-&gt;iommu_param);</span>
<span class="quote">&gt; &gt;  	kfree(device-&gt;name);</span>
<span class="quote">&gt; &gt;  	kfree(device);</span>
<span class="quote">&gt; &gt;  	dev-&gt;iommu_group = NULL;</span>
<span class="quote">&gt; &gt; @@ -791,6 +797,61 @@ int iommu_group_unregister_notifier(struct</span>
<span class="quote">&gt; &gt; iommu_group *group, }</span>
<span class="quote">&gt; &gt;  EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; +int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="quote">&gt; &gt; +					iommu_dev_fault_handler_t</span>
<span class="quote">&gt; &gt; handler,</span>
<span class="quote">&gt; &gt; +					void *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * Device iommu_param should have been allocated when</span>
<span class="quote">&gt; &gt; device is</span>
<span class="quote">&gt; &gt; +	 * added to its iommu_group.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; +	if (!idata)</span>
<span class="quote">&gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; +	/* Only allow one fault handler registered for each device</span>
<span class="quote">&gt; &gt; */</span>
<span class="quote">&gt; &gt; +	if (idata-&gt;fault_param)</span>
<span class="quote">&gt; &gt; +		return -EBUSY;</span>
<span class="quote">&gt; &gt; +	get_device(dev);</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param =</span>
<span class="quote">&gt; &gt; +		kzalloc(sizeof(struct iommu_fault_param),</span>
<span class="quote">&gt; &gt; GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +	if (!idata-&gt;fault_param)</span>
<span class="quote">&gt; &gt; +		return -ENOMEM;</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param-&gt;handler = handler;</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param-&gt;data = data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!idata)</span>
<span class="quote">&gt; &gt; +		return -EINVAL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	kfree(idata-&gt;fault_param);</span>
<span class="quote">&gt; &gt; +	idata-&gt;fault_param = NULL;</span>
<span class="quote">&gt; &gt; +	put_device(dev);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We should probably document register() and unregister() functions</span>
<span class="quote">&gt; since they are part of the device driver API. If it helps I came up</span>
<span class="quote">&gt; with:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; /**</span>
<span class="quote">&gt;  * iommu_register_device_fault_handler() - Register a device fault</span>
<span class="quote">&gt; handler</span>
<span class="quote">&gt;  * @dev: the device</span>
<span class="quote">&gt;  * @handler: the fault handler</span>
<span class="quote">&gt;  * @data: private data passed as argument to the handler</span>
<span class="quote">&gt;  *</span>
<span class="quote">&gt;  * When an IOMMU fault event is received, call this handler with the</span>
<span class="quote">&gt; fault event</span>
<span class="quote">&gt;  * and data as argument. The handler should return 0. If the fault is</span>
<span class="quote">&gt;  * recoverable (IOMMU_FAULT_PAGE_REQ), the handler must also complete</span>
<span class="quote">&gt;  * the fault by calling iommu_page_response() with one of the</span>
<span class="quote">&gt; following</span>
<span class="quote">&gt;  * response code:</span>
<span class="quote">&gt;  * - IOMMU_PAGE_RESP_SUCCESS: retry the translation</span>
<span class="quote">&gt;  * - IOMMU_PAGE_RESP_INVALID: terminate the fault</span>
<span class="quote">&gt;  * - IOMMU_PAGE_RESP_FAILURE: terminate the fault and stop reporting</span>
<span class="quote">&gt;  *   page faults if possible.</span>
<span class="quote">&gt;  *</span>
<span class="quote">&gt;  * Return 0 if the fault handler was installed successfully, or an</span>
<span class="quote">&gt; error. */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; /**</span>
<span class="quote">&gt;  * iommu_unregister_device_fault_handler() - Unregister the device</span>
<span class="quote">&gt; fault handler</span>
<span class="quote">&gt;  * @dev: the device</span>
<span class="quote">&gt;  *</span>
<span class="quote">&gt;  * Remove the device fault handler installed with</span>
<span class="quote">&gt;  * iommu_register_device_fault_handler().</span>
<span class="quote">&gt;  *</span>
<span class="quote">&gt;  * Return 0 on success, or an error.</span>
<span class="quote">&gt;  */</span>
<span class="quote">&gt; </span>
agreed. thanks. sorry about the delay.
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Jean</span>

[Jacob Pan]
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="p_header">index 829e9e9..97b7990 100644</span>
<span class="p_header">--- a/drivers/iommu/iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/iommu.c</span>
<span class="p_chunk">@@ -581,6 +581,12 @@</span> <span class="p_context"> int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
 		goto err_free_name;
 	}
 
<span class="p_add">+	dev-&gt;iommu_param = kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>
<span class="p_add">+	if (!dev-&gt;iommu_param) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_free_name;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kobject_get(group-&gt;devices_kobj);
 
 	dev-&gt;iommu_group = group;
<span class="p_chunk">@@ -657,7 +663,7 @@</span> <span class="p_context"> void iommu_group_remove_device(struct device *dev)</span>
 	sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);
 
 	trace_remove_device_from_group(group-&gt;id, dev);
<span class="p_del">-</span>
<span class="p_add">+	kfree(dev-&gt;iommu_param);</span>
 	kfree(device-&gt;name);
 	kfree(device);
 	dev-&gt;iommu_group = NULL;
<span class="p_chunk">@@ -791,6 +797,61 @@</span> <span class="p_context"> int iommu_group_unregister_notifier(struct iommu_group *group,</span>
 }
 EXPORT_SYMBOL_GPL(iommu_group_unregister_notifier);
 
<span class="p_add">+int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="p_add">+					iommu_dev_fault_handler_t handler,</span>
<span class="p_add">+					void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Device iommu_param should have been allocated when device is</span>
<span class="p_add">+	 * added to its iommu_group.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!idata)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	/* Only allow one fault handler registered for each device */</span>
<span class="p_add">+	if (idata-&gt;fault_param)</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	get_device(dev);</span>
<span class="p_add">+	idata-&gt;fault_param =</span>
<span class="p_add">+		kzalloc(sizeof(struct iommu_fault_param), GFP_KERNEL);</span>
<span class="p_add">+	if (!idata-&gt;fault_param)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	idata-&gt;fault_param-&gt;handler = handler;</span>
<span class="p_add">+	idata-&gt;fault_param-&gt;data = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(iommu_register_device_fault_handler);</span>
<span class="p_add">+</span>
<span class="p_add">+int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_param *idata = dev-&gt;iommu_param;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!idata)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(idata-&gt;fault_param);</span>
<span class="p_add">+	idata-&gt;fault_param = NULL;</span>
<span class="p_add">+	put_device(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(iommu_unregister_device_fault_handler);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* we only report device fault if there is a handler registered */</span>
<span class="p_add">+	if (!dev-&gt;iommu_param || !dev-&gt;iommu_param-&gt;fault_param ||</span>
<span class="p_add">+		!dev-&gt;iommu_param-&gt;fault_param-&gt;handler)</span>
<span class="p_add">+		return -ENOSYS;</span>
<span class="p_add">+</span>
<span class="p_add">+	return dev-&gt;iommu_param-&gt;fault_param-&gt;handler(evt,</span>
<span class="p_add">+						dev-&gt;iommu_param-&gt;fault_param-&gt;data);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(iommu_report_device_fault);</span>
<span class="p_add">+</span>
 /**
  * iommu_group_id - Return ID for a group
  * @group: the group to ID
<span class="p_header">diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="p_header">index dfda89b..841c044 100644</span>
<span class="p_header">--- a/include/linux/iommu.h</span>
<span class="p_header">+++ b/include/linux/iommu.h</span>
<span class="p_chunk">@@ -463,6 +463,14 @@</span> <span class="p_context"> extern int iommu_group_register_notifier(struct iommu_group *group,</span>
 					 struct notifier_block *nb);
 extern int iommu_group_unregister_notifier(struct iommu_group *group,
 					   struct notifier_block *nb);
<span class="p_add">+extern int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="p_add">+					iommu_dev_fault_handler_t handler,</span>
<span class="p_add">+					void *data);</span>
<span class="p_add">+</span>
<span class="p_add">+extern int iommu_unregister_device_fault_handler(struct device *dev);</span>
<span class="p_add">+</span>
<span class="p_add">+extern int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt);</span>
<span class="p_add">+</span>
 extern int iommu_group_id(struct iommu_group *group);
 extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
 extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);
<span class="p_chunk">@@ -481,6 +489,12 @@</span> <span class="p_context"> extern void iommu_domain_window_disable(struct iommu_domain *domain, u32 wnd_nr)</span>
 extern int report_iommu_fault(struct iommu_domain *domain, struct device *dev,
 			      unsigned long iova, int flags);
 
<span class="p_add">+static inline bool iommu_has_device_fault_handler(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;iommu_param &amp;&amp; dev-&gt;iommu_param-&gt;fault_param &amp;&amp;</span>
<span class="p_add">+		dev-&gt;iommu_param-&gt;fault_param-&gt;handler;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void iommu_flush_tlb_all(struct iommu_domain *domain)
 {
 	if (domain-&gt;ops-&gt;flush_iotlb_all)
<span class="p_chunk">@@ -734,6 +748,28 @@</span> <span class="p_context"> static inline int iommu_group_unregister_notifier(struct iommu_group *group,</span>
 	return 0;
 }
 
<span class="p_add">+static inline int iommu_register_device_fault_handler(struct device *dev,</span>
<span class="p_add">+						iommu_dev_fault_handler_t handler,</span>
<span class="p_add">+						void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int iommu_unregister_device_fault_handler(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool iommu_has_device_fault_handler(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int iommu_group_id(struct iommu_group *group)
 {
 	return -ENODEV;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



