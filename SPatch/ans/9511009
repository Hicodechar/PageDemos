
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[1/2] dma-mapping: let arch know origin of dma range passed to arch_setup_dma_ops() - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [1/2] dma-mapping: let arch know origin of dma range passed to arch_setup_dma_ops()</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=170319">Nikita Yushchenko</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 11, 2017, 6:31 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1484159512-28515-2-git-send-email-nikita.yoush@cogentembedded.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9511009/mbox/"
   >mbox</a>
|
   <a href="/patch/9511009/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9511009/">/patch/9511009/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	B9D656075C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 18:32:54 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A16B728662
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 18:32:54 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 964DF28667; Wed, 11 Jan 2017 18:32:54 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D83B828662
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 18:32:53 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1031176AbdAKScn (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 11 Jan 2017 13:32:43 -0500
Received: from mail-lf0-f45.google.com ([209.85.215.45]:36591 &quot;EHLO
	mail-lf0-f45.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751898AbdAKScV (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 11 Jan 2017 13:32:21 -0500
Received: by mail-lf0-f45.google.com with SMTP id o140so87631897lff.3
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Wed, 11 Jan 2017 10:32:20 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=cogentembedded-com.20150623.gappssmtp.com; s=20150623;
	h=from:to:cc:subject:date:message-id:in-reply-to:references;
	bh=DsmrLQTYacTBB218+YKtMvjS3EcC+45BYBgx6QuX0Bo=;
	b=YriAQesX1D7UqB2/hu4swdy3MEYeKiaNw8OzpMGBi7BzEHKfMW/m4pytMmM+JldF9L
	mCcyYLrweP/smQ+N0nRL9l3qPEMguFlnucI4egpmua+rgtnHySn6fFC6YRAb8ZJhvRtf
	+xqAhmYH69zov7zaIpwCJFknQKn9ucfJRs4V0h8koR5MlllnckA8cD8BuS31ixhyPfsQ
	qwmJ6m5Em70xqXJz2s8NEdb/6n364QOggRRHWBCLEdO6uI5G8AsTVFcZXUkNWJVZCVil
	nv3j6IDP5ohudDIcGG1aDzLscUKzPJsh9mr17ShZS0oYq2kQIioB0gO+tiUJOC8xW+e5
	qNRQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=DsmrLQTYacTBB218+YKtMvjS3EcC+45BYBgx6QuX0Bo=;
	b=QVqBgXzkLqGtVII32gVy0hc1xB/iM+8FyzoszHwXztg7HkNFewV+VLmyb7+NbB9vvD
	vmoXACH6eN0xWmPRAAOYi3m7MNSmPtHSyFfuoegvBdftAqZbGVMaD7xFt1WbtrOev7lT
	U6LldVbwztLaNAcIN57TAlPwhscMmIUvBEuemsHA6zmaoVVcNH5nRvfwg9zBxs25NQ5y
	LGh1bWA2usmdZ8dZt1CGRhQyYT36cFJxfFH9UOXCeONwhzbXJaMC/2TuNGfXAx7UDYDN
	EXC1sjp47WsZVV5nIAPhfLcwDtqFf9647RFEJ1U8lLKKTy14SPA+QdyxyoRa/+n0XTXa
	BqYQ==
X-Gm-Message-State: AIkVDXLyjz4FJZKyp/MFwZd3rQlDgzkzdGHU4HGjVjkpceTUMs2WPLS93Q5BSfu065tsyQ==
X-Received: by 10.25.234.216 with SMTP id y85mr3412287lfi.35.1484159539746; 
	Wed, 11 Jan 2017 10:32:19 -0800 (PST)
Received: from hugenb.home (nikaet.starlink.ru. [94.141.168.29])
	by smtp.gmail.com with ESMTPSA id
	s20sm361640lfe.41.2017.01.11.10.32.18
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-SHA bits=128/128);
	Wed, 11 Jan 2017 10:32:18 -0800 (PST)
From: Nikita Yushchenko &lt;nikita.yoush@cogentembedded.com&gt;
To: Robin Murphy &lt;robin.murphy@arm.com&gt;, Will Deacon &lt;will.deacon@arm.com&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;
Cc: linux-arm-kernel@lists.infradead.org, linux-renesas-soc@vger.kernel.org,
	Simon Horman &lt;horms@verge.net.au&gt;,
	Bjorn Helgaas &lt;bhelgaas@google.com&gt;, fkan@apm.com,
	linux-kernel@vger.kernel.org,
	Artemi Ivanov &lt;artemi.ivanov@cogentembedded.com&gt;,
	Nikita Yushchenko &lt;nikita.yoush@cogentembedded.com&gt;
Subject: [PATCH 1/2] dma-mapping: let arch know origin of dma range passed
	to arch_setup_dma_ops()
Date: Wed, 11 Jan 2017 21:31:51 +0300
Message-Id: &lt;1484159512-28515-2-git-send-email-nikita.yoush@cogentembedded.com&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1484159512-28515-1-git-send-email-nikita.yoush@cogentembedded.com&gt;
References: &lt;dca35acf-1adf-aa85-7a0b-d0c6ec702fa1@arm.com&gt;
	&lt;1484159512-28515-1-git-send-email-nikita.yoush@cogentembedded.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170319">Nikita Yushchenko</a> - Jan. 11, 2017, 6:31 p.m.</div>
<pre class="content">
There are cases when device is capable of wide DMA mask (and driver
issues corresponding dma_set_mask() call), but bus device sits on can&#39;t
support wide address. Example: NVMe device behind PCIe controller
sitting on 32-bit SoC bus.

To support such case, architecture needs information about such
limitations. Such information can originate from dma-ranges property
in device tree, and is passed to architecture via arch_setup_dma_ops()
call.

Problem is that in wide majority of cases, no dma range is defined.
E.g. ACPI has no means to define it. Thus default range (usually
full 32-bit range, i.e. 4G starting at zero address) is passed instead.

If architecture enforce this range, all setups currently using
wide DMA addresses without explicitly defining support for that via
device tree will break. This is bad, especially for ACPI based
platforms.

To avoid that, this patch adds additional boolean argument to
arch_setup_dma_ops() to show if range originates from authorative source
and thus should be enforced, or is just a guess and should be handled as
such.
<span class="signed-off-by">
Signed-off-by: Nikita Yushchenko &lt;nikita.yoush@cogentembedded.com&gt;</span>
---
 arch/arm/include/asm/dma-mapping.h             | 1 +
 arch/arm/mm/dma-mapping.c                      | 3 ++-
 arch/arm64/include/asm/dma-mapping.h           | 3 ++-
 arch/arm64/mm/dma-mapping.c                    | 3 ++-
 arch/mips/include/asm/dma-mapping.h            | 3 ++-
 drivers/acpi/scan.c                            | 2 +-
 drivers/iommu/rockchip-iommu.c                 | 2 +-
 drivers/net/ethernet/freescale/dpaa/dpaa_eth.c | 2 +-
 drivers/of/device.c                            | 5 ++++-
 drivers/staging/fsl-mc/bus/fsl-mc-bus.c        | 2 +-
 10 files changed, 17 insertions(+), 9 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Jan. 11, 2017, 9:08 p.m.</div>
<pre class="content">
On Wednesday, January 11, 2017 9:31:51 PM CET Nikita Yushchenko wrote:
<span class="quote">
&gt; diff --git a/drivers/iommu/rockchip-iommu.c b/drivers/iommu/rockchip-iommu.c</span>
<span class="quote">&gt; index 9afcbf7..0995ab3 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/rockchip-iommu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/rockchip-iommu.c</span>
<span class="quote">&gt; @@ -1096,7 +1096,7 @@ static int rk_iommu_domain_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;  		return -ENOMEM;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* Set dma_ops for dev, otherwise it would be dummy_dma_ops */</span>
<span class="quote">&gt; -	arch_setup_dma_ops(dev, 0, DMA_BIT_MASK(32), NULL, false);</span>
<span class="quote">&gt; +	arch_setup_dma_ops(dev, 0, DMA_BIT_MASK(32), false, NULL, false);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));</span>
<span class="quote">&gt;  	dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));</span>
<span class="quote">&gt; diff --git a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c</span>
<span class="quote">&gt; index c9b7ad6..19f70d8 100644</span>
<span class="quote">&gt; --- a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c</span>
<span class="quote">&gt; +++ b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c</span>
<span class="quote">&gt; @@ -2533,7 +2533,7 @@ static int dpaa_eth_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;  	priv-&gt;buf_layout[TX].priv_data_size = DPAA_TX_PRIV_DATA_SIZE; /* Tx */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* device used for DMA mapping */</span>
<span class="quote">&gt; -	arch_setup_dma_ops(dev, 0, 0, NULL, false);</span>
<span class="quote">&gt; +	arch_setup_dma_ops(dev, 0, 0, false, NULL, false);</span>
<span class="quote">&gt;  	err = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(40));</span>
<span class="quote">&gt;  	if (err) {</span>
<span class="quote">&gt;  		dev_err(dev, &quot;dma_coerce_mask_and_coherent() failed\n&quot;);</span>
<span class="quote">&gt; diff --git a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; index 5ac373c..480b644 100644</span>
<span class="quote">&gt; --- a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; +++ b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; @@ -540,7 +540,7 @@ int fsl_mc_device_add(struct dprc_obj_desc *obj_desc,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* Objects are coherent, unless &#39;no shareability&#39; flag set. */</span>
<span class="quote">&gt;  	if (!(obj_desc-&gt;flags &amp; DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY))</span>
<span class="quote">&gt; -		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, NULL, true);</span>
<span class="quote">&gt; +		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, false, NULL, true);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * The device-specific probe callback will get invoked by device_add()</span>

Why are these actually calling arch_setup_dma_ops() here in the first
place? Are these all devices that are DMA masters without an OF node?
<span class="quote">
&gt; diff --git a/drivers/of/device.c b/drivers/of/device.c</span>
<span class="quote">&gt; index fd5cfad..1cc2115 100644</span>
<span class="quote">&gt; --- a/drivers/of/device.c</span>
<span class="quote">&gt; +++ b/drivers/of/device.c</span>
<span class="quote">&gt; @@ -89,6 +89,7 @@ void of_dma_configure(struct device *dev, struct device_node *np)</span>
<span class="quote">&gt;  	bool coherent;</span>
<span class="quote">&gt;  	unsigned long offset;</span>
<span class="quote">&gt;  	const struct iommu_ops *iommu;</span>
<span class="quote">&gt; +	bool enforce_range = false;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * Set default coherent_dma_mask to 32 bit.  Drivers are expected to</span>
<span class="quote">&gt; @@ -126,6 +127,8 @@ void of_dma_configure(struct device *dev, struct device_node *np)</span>
<span class="quote">&gt;  			return;</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt;  		dev_dbg(dev, &quot;dma_pfn_offset(%#08lx)\n&quot;, offset);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		enforce_range = true;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	dev-&gt;dma_pfn_offset = offset;</span>

Hmm, I think when the dma-ranges are missing, we should either enforce
a 32-bit mask, or disallow DMA completely. It&#39;s probably too late for
the latter, I wish we had done this earlier in order to force everyone
on ARM64 to have a valid dma-ranges property for any DMA master.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170319">Nikita Yushchenko</a> - Jan. 12, 2017, 5:52 a.m.</div>
<pre class="content">
<span class="quote">&gt;&gt; diff --git a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt; index 5ac373c..480b644 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt; @@ -540,7 +540,7 @@ int fsl_mc_device_add(struct dprc_obj_desc *obj_desc,</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	/* Objects are coherent, unless &#39;no shareability&#39; flag set. */</span>
<span class="quote">&gt;&gt;  	if (!(obj_desc-&gt;flags &amp; DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY))</span>
<span class="quote">&gt;&gt; -		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, NULL, true);</span>
<span class="quote">&gt;&gt; +		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, false, NULL, true);</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	/*</span>
<span class="quote">&gt;&gt;  	 * The device-specific probe callback will get invoked by device_add()</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why are these actually calling arch_setup_dma_ops() here in the first</span>
<span class="quote">&gt; place? Are these all devices that are DMA masters without an OF node?</span>

I don&#39;t know, but that&#39;s a different topic. This patch just adds
argument and sets it to false everywhere but in the location when range
should be definitely enforced.
<span class="quote">
&gt;&gt; @@ -126,6 +127,8 @@ void of_dma_configure(struct device *dev, struct device_node *np)</span>
<span class="quote">&gt;&gt;  			return;</span>
<span class="quote">&gt;&gt;  		}</span>
<span class="quote">&gt;&gt;  		dev_dbg(dev, &quot;dma_pfn_offset(%#08lx)\n&quot;, offset);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		enforce_range = true;</span>
<span class="quote">&gt;&gt;  	}</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	dev-&gt;dma_pfn_offset = offset;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm, I think when the dma-ranges are missing, we should either enforce</span>
<span class="quote">&gt; a 32-bit mask, or disallow DMA completely. It&#39;s probably too late for</span>
<span class="quote">&gt; the latter, I wish we had done this earlier in order to force everyone</span>
<span class="quote">&gt; on ARM64 to have a valid dma-ranges property for any DMA master.</span>

This can be done over time.

However the very idea of this version of patch is - keep working pieces
as-is, thus for now setting enforce_range to false in case of no defined
dma-ranges is intentional.

What I should re-check is - does rcar dtsi set dma-ranges, and add it if
it does not.

Nikita
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170319">Nikita Yushchenko</a> - Jan. 12, 2017, 6:33 a.m.</div>
<pre class="content">
12.01.2017 08:52, Nikita Yushchenko wrote:
<span class="quote">&gt;&gt;&gt; diff --git a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt;&gt; index 5ac373c..480b644 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt;&gt; @@ -540,7 +540,7 @@ int fsl_mc_device_add(struct dprc_obj_desc *obj_desc,</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;  	/* Objects are coherent, unless &#39;no shareability&#39; flag set. */</span>
<span class="quote">&gt;&gt;&gt;  	if (!(obj_desc-&gt;flags &amp; DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY))</span>
<span class="quote">&gt;&gt;&gt; -		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, NULL, true);</span>
<span class="quote">&gt;&gt;&gt; +		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, false, NULL, true);</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;  	/*</span>
<span class="quote">&gt;&gt;&gt;  	 * The device-specific probe callback will get invoked by device_add()</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Why are these actually calling arch_setup_dma_ops() here in the first</span>
<span class="quote">&gt;&gt; place? Are these all devices that are DMA masters without an OF node?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t know, but that&#39;s a different topic. This patch just adds</span>
<span class="quote">&gt; argument and sets it to false everywhere but in the location when range</span>
<span class="quote">&gt; should be definitely enforced.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;&gt; @@ -126,6 +127,8 @@ void of_dma_configure(struct device *dev, struct device_node *np)</span>
<span class="quote">&gt;&gt;&gt;  			return;</span>
<span class="quote">&gt;&gt;&gt;  		}</span>
<span class="quote">&gt;&gt;&gt;  		dev_dbg(dev, &quot;dma_pfn_offset(%#08lx)\n&quot;, offset);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +		enforce_range = true;</span>
<span class="quote">&gt;&gt;&gt;  	}</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;  	dev-&gt;dma_pfn_offset = offset;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hmm, I think when the dma-ranges are missing, we should either enforce</span>
<span class="quote">&gt;&gt; a 32-bit mask, or disallow DMA completely. It&#39;s probably too late for</span>
<span class="quote">&gt;&gt; the latter, I wish we had done this earlier in order to force everyone</span>
<span class="quote">&gt;&gt; on ARM64 to have a valid dma-ranges property for any DMA master.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This can be done over time.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; However the very idea of this version of patch is - keep working pieces</span>
<span class="quote">&gt; as-is, thus for now setting enforce_range to false in case of no defined</span>
<span class="quote">&gt; dma-ranges is intentional.</span>

What we can do is - check bus width (as it is defined in DT) and set
enforce_range to true if bus is 32-bit
<span class="quote">
&gt; What I should re-check is - does rcar dtsi set dma-ranges, and add it if</span>
<span class="quote">&gt; it does not.</span>

It does not, will have to add.

In DT bus is defined as 64-bit. But looks like physically it is 32-bit.
Maybe DT needs fixing.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - Jan. 12, 2017, 12:16 p.m.</div>
<pre class="content">
On Thu, Jan 12, 2017 at 08:52:51AM +0300, Nikita Yushchenko wrote:
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; &gt;&gt; index 5ac373c..480b644 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; &gt;&gt; @@ -540,7 +540,7 @@ int fsl_mc_device_add(struct dprc_obj_desc *obj_desc,</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;  	/* Objects are coherent, unless &#39;no shareability&#39; flag set. */</span>
<span class="quote">&gt; &gt;&gt;  	if (!(obj_desc-&gt;flags &amp; DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY))</span>
<span class="quote">&gt; &gt;&gt; -		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, NULL, true);</span>
<span class="quote">&gt; &gt;&gt; +		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, false, NULL, true);</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;  	/*</span>
<span class="quote">&gt; &gt;&gt;  	 * The device-specific probe callback will get invoked by device_add()</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Why are these actually calling arch_setup_dma_ops() here in the first</span>
<span class="quote">&gt; &gt; place? Are these all devices that are DMA masters without an OF node?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t know, but that&#39;s a different topic. This patch just adds</span>
<span class="quote">&gt; argument and sets it to false everywhere but in the location when range</span>
<span class="quote">&gt; should be definitely enforced.</span>

I also wouldn&#39;t lose any sleep over a staging driver.

Will
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Jan. 12, 2017, 1:25 p.m.</div>
<pre class="content">
On Thursday, January 12, 2017 12:16:24 PM CET Will Deacon wrote:
<span class="quote">&gt; On Thu, Jan 12, 2017 at 08:52:51AM +0300, Nikita Yushchenko wrote:</span>
<span class="quote">&gt; &gt; &gt;&gt; diff --git a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; &gt; &gt;&gt; index 5ac373c..480b644 100644</span>
<span class="quote">&gt; &gt; &gt;&gt; --- a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; &gt; &gt;&gt; +++ b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt; &gt; &gt;&gt; @@ -540,7 +540,7 @@ int fsl_mc_device_add(struct dprc_obj_desc *obj_desc,</span>
<span class="quote">&gt; &gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt; &gt;&gt;    /* Objects are coherent, unless &#39;no shareability&#39; flag set. */</span>
<span class="quote">&gt; &gt; &gt;&gt;    if (!(obj_desc-&gt;flags &amp; DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY))</span>
<span class="quote">&gt; &gt; &gt;&gt; -          arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, NULL, true);</span>
<span class="quote">&gt; &gt; &gt;&gt; +          arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, false, NULL, true);</span>
<span class="quote">&gt; &gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt; &gt;&gt;    /*</span>
<span class="quote">&gt; &gt; &gt;&gt;     * The device-specific probe callback will get invoked by device_add()</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Why are these actually calling arch_setup_dma_ops() here in the first</span>
<span class="quote">&gt; &gt; &gt; place? Are these all devices that are DMA masters without an OF node?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I don&#39;t know, but that&#39;s a different topic. This patch just adds</span>
<span class="quote">&gt; &gt; argument and sets it to false everywhere but in the location when range</span>
<span class="quote">&gt; &gt; should be definitely enforced.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I also wouldn&#39;t lose any sleep over a staging driver.</span>

I think this is in the process of being moved out of staging, and
my question was about the other two as well:

drivers/net/ethernet/freescale/dpaa/dpaa_eth.c
drivers/iommu/rockchip-iommu.c

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Jan. 12, 2017, 1:28 p.m.</div>
<pre class="content">
On Thursday, January 12, 2017 9:33:32 AM CET Nikita Yushchenko wrote:
<span class="quote">&gt; &gt;&gt; Hmm, I think when the dma-ranges are missing, we should either enforce</span>
<span class="quote">&gt; &gt;&gt; a 32-bit mask, or disallow DMA completely. It&#39;s probably too late for</span>
<span class="quote">&gt; &gt;&gt; the latter, I wish we had done this earlier in order to force everyone</span>
<span class="quote">&gt; &gt;&gt; on ARM64 to have a valid dma-ranges property for any DMA master.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This can be done over time.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; However the very idea of this version of patch is - keep working pieces</span>
<span class="quote">&gt; &gt; as-is, thus for now setting enforce_range to false in case of no defined</span>
<span class="quote">&gt; &gt; dma-ranges is intentional.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What we can do is - check bus width (as it is defined in DT) and set</span>
<span class="quote">&gt; enforce_range to true if bus is 32-bit</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; What I should re-check is - does rcar dtsi set dma-ranges, and add it if</span>
<span class="quote">&gt; &gt; it does not.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It does not, will have to add.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In DT bus is defined as 64-bit. But looks like physically it is 32-bit.</span>
<span class="quote">&gt; Maybe DT needs fixing.</span>

I think we always assumed that the lack of a dma-ranges property
implied a 32-bit width, as that is the safe fallback as well as the
most common case.

AFAICT, this means you are actually fine on rcar, and all other
platforms will keep working as we enforce it, but might get slowed
down if they relied on the unintended behavior of allowing 64-bit
DMA.

	Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170319">Nikita Yushchenko</a> - Jan. 12, 2017, 1:39 p.m.</div>
<pre class="content">
<span class="quote">&gt;&gt;&gt;&gt; Hmm, I think when the dma-ranges are missing, we should either enforce</span>
<span class="quote">&gt;&gt;&gt;&gt; a 32-bit mask, or disallow DMA completely. It&#39;s probably too late for</span>
<span class="quote">&gt;&gt;&gt;&gt; the latter, I wish we had done this earlier in order to force everyone</span>
<span class="quote">&gt;&gt;&gt;&gt; on ARM64 to have a valid dma-ranges property for any DMA master.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This can be done over time.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; However the very idea of this version of patch is - keep working pieces</span>
<span class="quote">&gt;&gt;&gt; as-is, thus for now setting enforce_range to false in case of no defined</span>
<span class="quote">&gt;&gt;&gt; dma-ranges is intentional.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; What we can do is - check bus width (as it is defined in DT) and set</span>
<span class="quote">&gt;&gt; enforce_range to true if bus is 32-bit</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; What I should re-check is - does rcar dtsi set dma-ranges, and add it if</span>
<span class="quote">&gt;&gt;&gt; it does not.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; It does not, will have to add.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; In DT bus is defined as 64-bit. But looks like physically it is 32-bit.</span>
<span class="quote">&gt;&gt; Maybe DT needs fixing.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think we always assumed that the lack of a dma-ranges property</span>
<span class="quote">&gt; implied a 32-bit width, as that is the safe fallback as well as the</span>
<span class="quote">&gt; most common case.</span>

Yes we assumed that, but that was combined with blindly accepting wider
dma_mask per driver&#39;s request.  Later is being changed.
<span class="quote">
&gt; AFAICT, this means you are actually fine on rcar, and all other</span>
<span class="quote">&gt; platforms will keep working as we enforce it, but might get slowed</span>
<span class="quote">&gt; down if they relied on the unintended behavior of allowing 64-bit</span>
<span class="quote">&gt; DMA.</span>

Yesterday Robin raised issue that a change starting to enforce default
dma_mask will break existing setups - i.e. those that depend in 64bit
DMA being implicitly supported without manually declaring such support.

In reply to that, I suggested this version of patchset that should keep
existing behavior by default.

I&#39;m fine with both approaches regarding behavior on hw that I don&#39;t have
- but I&#39;m not in position to make any decisions on that.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Jan. 12, 2017, 1:43 p.m.</div>
<pre class="content">
On 12/01/17 13:25, Arnd Bergmann wrote:
<span class="quote">&gt; On Thursday, January 12, 2017 12:16:24 PM CET Will Deacon wrote:</span>
<span class="quote">&gt;&gt; On Thu, Jan 12, 2017 at 08:52:51AM +0300, Nikita Yushchenko wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; diff --git a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; index 5ac373c..480b644 100644</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; --- a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +++ b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; @@ -540,7 +540,7 @@ int fsl_mc_device_add(struct dprc_obj_desc *obj_desc,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;    /* Objects are coherent, unless &#39;no shareability&#39; flag set. */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;    if (!(obj_desc-&gt;flags &amp; DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY))</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; -          arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, NULL, true);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +          arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, false, NULL, true);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;    /*</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;     * The device-specific probe callback will get invoked by device_add()</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Why are these actually calling arch_setup_dma_ops() here in the first</span>
<span class="quote">&gt;&gt;&gt;&gt; place? Are these all devices that are DMA masters without an OF node?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I don&#39;t know, but that&#39;s a different topic. This patch just adds</span>
<span class="quote">&gt;&gt;&gt; argument and sets it to false everywhere but in the location when range</span>
<span class="quote">&gt;&gt;&gt; should be definitely enforced.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I also wouldn&#39;t lose any sleep over a staging driver.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think this is in the process of being moved out of staging, and</span>
<span class="quote">&gt; my question was about the other two as well:</span>

The fsl-mc is actually a sort-of-bus-controller probing and configuring
its (directly DMA-capable) child devices, so is in fact legitimate here.
<span class="quote">
&gt; drivers/net/ethernet/freescale/dpaa/dpaa_eth.c</span>

That one is completely bogus, and should just go away.
<span class="quote">
&gt; drivers/iommu/rockchip-iommu.c</span>

That one is part of some ugly trickery involving creating a fake device
to represent multiple separate IOMMU devices. The driver could probably
be reworked to not need it (the Exynos IOMMU handles a similar situation
without such tricks), but it&#39;s non-trivial.

Robin.
<span class="quote">
&gt; </span>
<span class="quote">&gt; 	Arnd</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=143191">kbuild test robot</a> - Jan. 13, 2017, 10:40 a.m.</div>
<pre class="content">
Hi Nikita,

[auto build test ERROR on linus/master]
[also build test ERROR on v4.10-rc3 next-20170112]
[cannot apply to arm64/for-next/core]
[if your patch is applied to the wrong git tree, please drop us a note to help improve the system]

url:    https://github.com/0day-ci/linux/commits/Nikita-Yushchenko/dma-mapping-let-arch-know-origin-of-dma-range-passed-to-arch_setup_dma_ops/20170113-152733
config: x86_64-randconfig-u0-01131618 (attached as .config)
compiler: gcc-6 (Debian 6.2.0-3) 6.2.0 20160901
reproduce:
        # save the attached .config to linux build tree
        make ARCH=x86_64 

All errors (new ones prefixed by &gt;&gt;):

   drivers/acpi/scan.c: In function &#39;acpi_dma_configure&#39;:
<span class="quote">&gt;&gt; drivers/acpi/scan.c:1388:2: error: too many arguments to function &#39;arch_setup_dma_ops&#39;</span>
     arch_setup_dma_ops(dev, 0, dev-&gt;coherent_dma_mask + 1, false, iommu,
     ^~~~~~~~~~~~~~~~~~
   In file included from drivers/acpi/scan.c:15:0:
   include/linux/dma-mapping.h:611:20: note: declared here
    static inline void arch_setup_dma_ops(struct device *dev, u64 dma_base,
                       ^~~~~~~~~~~~~~~~~~

vim +/arch_setup_dma_ops +1388 drivers/acpi/scan.c

  1382		iommu = iort_iommu_configure(dev);
  1383	
  1384		/*
  1385		 * Assume dma valid range starts at 0 and covers the whole
  1386		 * coherent_dma_mask.
  1387		 */
<span class="quote">&gt; 1388		arch_setup_dma_ops(dev, 0, dev-&gt;coherent_dma_mask + 1, false, iommu,</span>
  1389				   attr == DEV_DMA_COHERENT);
  1390	}
  1391	EXPORT_SYMBOL_GPL(acpi_dma_configure);

---
0-DAY kernel test infrastructure                Open Source Technology Center
https://lists.01.org/pipermail/kbuild-all                   Intel Corporation
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">index bf02dbd..2a3863e 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> static inline unsigned long dma_max_pfn(struct device *dev)</span>
 
 #define arch_setup_dma_ops arch_setup_dma_ops
 extern void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
<span class="p_add">+			       bool enforce_range,</span>
 			       const struct iommu_ops *iommu, bool coherent);
 
 #define arch_teardown_dma_ops arch_teardown_dma_ops
<span class="p_header">diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">index ab77100..b8b11f8 100644</span>
<span class="p_header">--- a/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -2380,7 +2380,8 @@</span> <span class="p_context"> static struct dma_map_ops *arm_get_dma_map_ops(bool coherent)</span>
 }
 
 void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
<span class="p_del">-			const struct iommu_ops *iommu, bool coherent)</span>
<span class="p_add">+			bool enforce_range, const struct iommu_ops *iommu,</span>
<span class="p_add">+			bool coherent)</span>
 {
 	struct dma_map_ops *dma_ops;
 
<span class="p_header">diff --git a/arch/arm64/include/asm/dma-mapping.h b/arch/arm64/include/asm/dma-mapping.h</span>
<span class="p_header">index ccea82c..ae1c23f 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -48,7 +48,8 @@</span> <span class="p_context"> static inline struct dma_map_ops *get_dma_ops(struct device *dev)</span>
 }
 
 void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
<span class="p_del">-			const struct iommu_ops *iommu, bool coherent);</span>
<span class="p_add">+			bool enforce_range, const struct iommu_ops *iommu,</span>
<span class="p_add">+			bool coherent);</span>
 #define arch_setup_dma_ops	arch_setup_dma_ops
 
 #ifdef CONFIG_IOMMU_DMA
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index e040827..ea295f1 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -953,7 +953,8 @@</span> <span class="p_context"> static void __iommu_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,</span>
 #endif  /* CONFIG_IOMMU_DMA */
 
 void arch_setup_dma_ops(struct device *dev, u64 dma_base, u64 size,
<span class="p_del">-			const struct iommu_ops *iommu, bool coherent)</span>
<span class="p_add">+			bool enforce_range, const struct iommu_ops *iommu,</span>
<span class="p_add">+			bool coherent)</span>
 {
 	if (!dev-&gt;archdata.dma_ops)
 		dev-&gt;archdata.dma_ops = &amp;swiotlb_dma_ops;
<span class="p_header">diff --git a/arch/mips/include/asm/dma-mapping.h b/arch/mips/include/asm/dma-mapping.h</span>
<span class="p_header">index 7aa71b9..6af4d87 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -34,7 +34,8 @@</span> <span class="p_context"> extern void dma_cache_sync(struct device *dev, void *vaddr, size_t size,</span>
 
 #define arch_setup_dma_ops arch_setup_dma_ops
 static inline void arch_setup_dma_ops(struct device *dev, u64 dma_base,
<span class="p_del">-				      u64 size, const struct iommu_ops *iommu,</span>
<span class="p_add">+				      u64 size, bool enforce_range,</span>
<span class="p_add">+				      const struct iommu_ops *iommu,</span>
 				      bool coherent)
 {
 #ifdef CONFIG_DMA_PERDEV_COHERENT
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index 1926918..dea17a5 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -1385,7 +1385,7 @@</span> <span class="p_context"> void acpi_dma_configure(struct device *dev, enum dev_dma_attr attr)</span>
 	 * Assume dma valid range starts at 0 and covers the whole
 	 * coherent_dma_mask.
 	 */
<span class="p_del">-	arch_setup_dma_ops(dev, 0, dev-&gt;coherent_dma_mask + 1, iommu,</span>
<span class="p_add">+	arch_setup_dma_ops(dev, 0, dev-&gt;coherent_dma_mask + 1, false, iommu,</span>
 			   attr == DEV_DMA_COHERENT);
 }
 EXPORT_SYMBOL_GPL(acpi_dma_configure);
<span class="p_header">diff --git a/drivers/iommu/rockchip-iommu.c b/drivers/iommu/rockchip-iommu.c</span>
<span class="p_header">index 9afcbf7..0995ab3 100644</span>
<span class="p_header">--- a/drivers/iommu/rockchip-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/rockchip-iommu.c</span>
<span class="p_chunk">@@ -1096,7 +1096,7 @@</span> <span class="p_context"> static int rk_iommu_domain_probe(struct platform_device *pdev)</span>
 		return -ENOMEM;
 
 	/* Set dma_ops for dev, otherwise it would be dummy_dma_ops */
<span class="p_del">-	arch_setup_dma_ops(dev, 0, DMA_BIT_MASK(32), NULL, false);</span>
<span class="p_add">+	arch_setup_dma_ops(dev, 0, DMA_BIT_MASK(32), false, NULL, false);</span>
 
 	dma_set_max_seg_size(dev, DMA_BIT_MASK(32));
 	dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(32));
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c</span>
<span class="p_header">index c9b7ad6..19f70d8 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/dpaa/dpaa_eth.c</span>
<span class="p_chunk">@@ -2533,7 +2533,7 @@</span> <span class="p_context"> static int dpaa_eth_probe(struct platform_device *pdev)</span>
 	priv-&gt;buf_layout[TX].priv_data_size = DPAA_TX_PRIV_DATA_SIZE; /* Tx */
 
 	/* device used for DMA mapping */
<span class="p_del">-	arch_setup_dma_ops(dev, 0, 0, NULL, false);</span>
<span class="p_add">+	arch_setup_dma_ops(dev, 0, 0, false, NULL, false);</span>
 	err = dma_coerce_mask_and_coherent(dev, DMA_BIT_MASK(40));
 	if (err) {
 		dev_err(dev, &quot;dma_coerce_mask_and_coherent() failed\n&quot;);
<span class="p_header">diff --git a/drivers/of/device.c b/drivers/of/device.c</span>
<span class="p_header">index fd5cfad..1cc2115 100644</span>
<span class="p_header">--- a/drivers/of/device.c</span>
<span class="p_header">+++ b/drivers/of/device.c</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"> void of_dma_configure(struct device *dev, struct device_node *np)</span>
 	bool coherent;
 	unsigned long offset;
 	const struct iommu_ops *iommu;
<span class="p_add">+	bool enforce_range = false;</span>
 
 	/*
 	 * Set default coherent_dma_mask to 32 bit.  Drivers are expected to
<span class="p_chunk">@@ -126,6 +127,8 @@</span> <span class="p_context"> void of_dma_configure(struct device *dev, struct device_node *np)</span>
 			return;
 		}
 		dev_dbg(dev, &quot;dma_pfn_offset(%#08lx)\n&quot;, offset);
<span class="p_add">+</span>
<span class="p_add">+		enforce_range = true;</span>
 	}
 
 	dev-&gt;dma_pfn_offset = offset;
<span class="p_chunk">@@ -147,7 +150,7 @@</span> <span class="p_context"> void of_dma_configure(struct device *dev, struct device_node *np)</span>
 	dev_dbg(dev, &quot;device is%sbehind an iommu\n&quot;,
 		iommu ? &quot; &quot; : &quot; not &quot;);
 
<span class="p_del">-	arch_setup_dma_ops(dev, dma_addr, size, iommu, coherent);</span>
<span class="p_add">+	arch_setup_dma_ops(dev, dma_addr, size, enforce_range, iommu, coherent);</span>
 }
 EXPORT_SYMBOL_GPL(of_dma_configure);
 
<span class="p_header">diff --git a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="p_header">index 5ac373c..480b644 100644</span>
<span class="p_header">--- a/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="p_header">+++ b/drivers/staging/fsl-mc/bus/fsl-mc-bus.c</span>
<span class="p_chunk">@@ -540,7 +540,7 @@</span> <span class="p_context"> int fsl_mc_device_add(struct dprc_obj_desc *obj_desc,</span>
 
 	/* Objects are coherent, unless &#39;no shareability&#39; flag set. */
 	if (!(obj_desc-&gt;flags &amp; DPRC_OBJ_FLAG_NO_MEM_SHAREABILITY))
<span class="p_del">-		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, NULL, true);</span>
<span class="p_add">+		arch_setup_dma_ops(&amp;mc_dev-&gt;dev, 0, 0, false, NULL, true);</span>
 
 	/*
 	 * The device-specific probe callback will get invoked by device_add()

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



