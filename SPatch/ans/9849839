
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>powerpc: Convert to using %pOF instead of full_name - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    powerpc: Convert to using %pOF instead of full_name</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=86391">Rob Herring</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 18, 2017, 9:42 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170718214339.7774-6-robh@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9849839/mbox/"
   >mbox</a>
|
   <a href="/patch/9849839/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9849839/">/patch/9849839/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	97A25602C8 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Jul 2017 22:00:56 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 756A8285FF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Jul 2017 22:00:56 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6972628606; Tue, 18 Jul 2017 22:00:56 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.4 required=2.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RCVD_IN_SORBS_SPAM autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 817B228607
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Jul 2017 22:00:50 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753033AbdGRWAq (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 18 Jul 2017 18:00:46 -0400
Received: from mail-pf0-f195.google.com ([209.85.192.195]:34607 &quot;EHLO
	mail-pf0-f195.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752328AbdGRVnz (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 18 Jul 2017 17:43:55 -0400
Received: by mail-pf0-f195.google.com with SMTP id o88so4063400pfk.1;
	Tue, 18 Jul 2017 14:43:54 -0700 (PDT)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id;
	bh=qJud8zJY0C4XXHNUkr0pwasDok9PJDcPoZLzrx0fYoM=;
	b=TboSNTXTtpYJhT8Tf+1lklqmRbRxozDepDJQqj32/GnGxyiQhVNoZ+3Uv6/kpYQzWf
	nowbQyqXDRpcODVOb4kNASEFT6P2Yds9bhEk5fRVZD2bgWxsSnzMQcqHvJDf+VdIZDdp
	emF61NjWq1rjmKn9VHz3gY8oNTf59q1fw3TXaNAghRXI1Q6oEwu15GrYD23FuloZF+BN
	tEpOGluG4ozzCPFj6e26091YwUyAJme92a8FBCYLbv9f762FAKgtnAbVWVf9+id1DMoN
	/yIgAMoXcjLrGBu3QKMTl6Z7+U7l04s44dtg5Ee811LNlgy9kF54UjY5uX3LRlt8QrZf
	O5ig==
X-Gm-Message-State: AIVw110+6pGNEzv2X5O2p3ghRUDwY5ZzUSNzwrepS3/PSHLea7E2I/8Z
	2ew/ZnOp9lXYRQ==
X-Received: by 10.99.36.198 with SMTP id k189mr3815583pgk.230.1500414233562; 
	Tue, 18 Jul 2017 14:43:53 -0700 (PDT)
Received: from localhost.localdomain
	(24-223-123-72.static.usa-companies.net. [24.223.123.72])
	by smtp.googlemail.com with ESMTPSA id
	r207sm7186560pfr.106.2017.07.18.14.43.51
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Tue, 18 Jul 2017 14:43:52 -0700 (PDT)
From: Rob Herring &lt;robh@kernel.org&gt;
To: Michael Ellerman &lt;mpe@ellerman.id.au&gt;
Cc: linux-kernel@vger.kernel.org, devicetree@vger.kernel.org,
	Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;,
	Paul Mackerras &lt;paulus@samba.org&gt;, Anatolij Gustschin &lt;agust@denx.de&gt;,
	Scott Wood &lt;oss@buserror.net&gt;, Kumar Gala &lt;galak@kernel.crashing.org&gt;,
	Arnd Bergmann &lt;arnd@arndb.de&gt;, linuxppc-dev@lists.ozlabs.org
Subject: [PATCH] powerpc: Convert to using %pOF instead of full_name
Date: Tue, 18 Jul 2017 16:42:46 -0500
Message-Id: &lt;20170718214339.7774-6-robh@kernel.org&gt;
X-Mailer: git-send-email 2.11.0
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=86391">Rob Herring</a> - July 18, 2017, 9:42 p.m.</div>
<pre class="content">
Now that we have a custom printf format specifier, convert users of
full_name to use %pOF instead. This is preparation to remove storing
of the full path string for each node.
<span class="signed-off-by">
Signed-off-by: Rob Herring &lt;robh@kernel.org&gt;</span>
Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;
Cc: Paul Mackerras &lt;paulus@samba.org&gt;
Cc: Michael Ellerman &lt;mpe@ellerman.id.au&gt;
Cc: Anatolij Gustschin &lt;agust@denx.de&gt;
Cc: Scott Wood &lt;oss@buserror.net&gt;
Cc: Kumar Gala &lt;galak@kernel.crashing.org&gt;
Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;
Cc: linuxppc-dev@lists.ozlabs.org
---
 arch/powerpc/kernel/btext.c                      |   2 +-
 arch/powerpc/kernel/cacheinfo.c                  |  34 ++++---
 arch/powerpc/kernel/io-workarounds.c             |   4 +-
 arch/powerpc/kernel/isa-bridge.c                 |  32 +++----
 arch/powerpc/kernel/legacy_serial.c              |  12 +--
 arch/powerpc/kernel/of_platform.c                |   2 +-
 arch/powerpc/kernel/pci-common.c                 |  15 ++-
 arch/powerpc/kernel/pci_32.c                     |   4 +-
 arch/powerpc/kernel/pci_64.c                     |   4 +-
 arch/powerpc/kernel/pci_of_scan.c                |  24 ++---
 arch/powerpc/kernel/setup-common.c               |   2 +-
 arch/powerpc/platforms/512x/mpc512x_shared.c     |  12 +--
 arch/powerpc/platforms/52xx/efika.c              |   8 +-
 arch/powerpc/platforms/52xx/media5200.c          |   2 +-
 arch/powerpc/platforms/52xx/mpc52xx_gpt.c        |   4 +-
 arch/powerpc/platforms/52xx/mpc52xx_pci.c        |   8 +-
 arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c   |   3 +-
 arch/powerpc/platforms/83xx/mpc832x_rdb.c        |   2 +-
 arch/powerpc/platforms/85xx/p1022_ds.c           |   8 +-
 arch/powerpc/platforms/85xx/xes_mpc85xx.c        |   4 +-
 arch/powerpc/platforms/amigaone/setup.c          |   6 +-
 arch/powerpc/platforms/cell/axon_msi.c           |  36 +++----
 arch/powerpc/platforms/cell/interrupt.c          |   4 +-
 arch/powerpc/platforms/cell/iommu.c              |  24 ++---
 arch/powerpc/platforms/cell/ras.c                |   4 +-
 arch/powerpc/platforms/cell/spider-pci.c         |   4 +-
 arch/powerpc/platforms/cell/spider-pic.c         |   4 +-
 arch/powerpc/platforms/cell/spu_manage.c         |  26 ++---
 arch/powerpc/platforms/chrp/pci.c                |  18 ++--
 arch/powerpc/platforms/embedded6xx/linkstation.c |   6 +-
 arch/powerpc/platforms/embedded6xx/mvme5100.c    |   2 +-
 arch/powerpc/platforms/embedded6xx/storcenter.c  |   2 +-
 arch/powerpc/platforms/maple/pci.c               |  10 +-
 arch/powerpc/platforms/pasemi/pci.c              |   2 +-
 arch/powerpc/platforms/powermac/feature.c        |  14 +--
 arch/powerpc/platforms/powermac/low_i2c.c        |  50 +++++-----
 arch/powerpc/platforms/powermac/pci.c            |   6 +-
 arch/powerpc/platforms/powermac/pfunc_base.c     |  24 ++---
 arch/powerpc/platforms/powermac/pfunc_core.c     |   6 +-
 arch/powerpc/platforms/powermac/pic.c            |   8 +-
 arch/powerpc/platforms/powermac/setup.c          |   2 +-
 arch/powerpc/platforms/powernv/opal-async.c      |   4 +-
 arch/powerpc/platforms/powernv/opal-xscom.c      |   8 +-
 arch/powerpc/platforms/powernv/pci-ioda.c        |  15 ++-
 arch/powerpc/platforms/powernv/rng.c             |   6 +-
 arch/powerpc/platforms/pseries/dlpar.c           |   3 +-
 arch/powerpc/platforms/pseries/event_sources.c   |   6 +-
 arch/powerpc/platforms/pseries/hotplug-cpu.c     |   4 +-
 arch/powerpc/platforms/pseries/ibmebus.c         |   5 +-
 arch/powerpc/platforms/pseries/iommu.c           |  58 ++++++------
 arch/powerpc/platforms/pseries/msi.c             |  12 +--
 arch/powerpc/platforms/pseries/pci_dlpar.c       |   2 +-
 arch/powerpc/platforms/pseries/vio.c             |  12 +--
 arch/powerpc/sysdev/axonram.c                    |   4 +-
 arch/powerpc/sysdev/dcr.c                        |   4 +-
 arch/powerpc/sysdev/fsl_85xx_cache_sram.c        |  12 +--
 arch/powerpc/sysdev/fsl_gtm.c                    |  14 +--
 arch/powerpc/sysdev/fsl_msi.c                    |  16 ++--
 arch/powerpc/sysdev/fsl_pci.c                    |  47 +++++----
 arch/powerpc/sysdev/fsl_rio.c                    |  36 +++----
 arch/powerpc/sysdev/fsl_rmu.c                    |  12 +--
 arch/powerpc/sysdev/mpic.c                       |   4 +-
 arch/powerpc/sysdev/mpic_msgr.c                  |   2 +-
 arch/powerpc/sysdev/mpic_msi.c                   |   2 +-
 arch/powerpc/sysdev/mpic_timer.c                 |  19 ++--
 arch/powerpc/sysdev/msi_bitmap.c                 |   4 +-
 arch/powerpc/sysdev/mv64x60_dev.c                |  20 ++--
 arch/powerpc/sysdev/mv64x60_pci.c                |   4 +-
 arch/powerpc/sysdev/of_rtc.c                     |  12 +--
 arch/powerpc/sysdev/ppc4xx_cpm.c                 |   8 +-
 arch/powerpc/sysdev/ppc4xx_gpio.c                |   3 +-
 arch/powerpc/sysdev/ppc4xx_msi.c                 |   3 +-
 arch/powerpc/sysdev/ppc4xx_pci.c                 | 116 ++++++++++-------------
 arch/powerpc/sysdev/ppc4xx_soc.c                 |   5 +-
 arch/powerpc/sysdev/scom.c                       |   5 +-
 arch/powerpc/sysdev/simple_gpio.c                |   3 +-
 arch/powerpc/sysdev/tsi108_pci.c                 |   4 +-
 arch/powerpc/sysdev/uic.c                        |  14 +--
 arch/powerpc/sysdev/xive/native.c                |   2 +-
 79 files changed, 464 insertions(+), 490 deletions(-)

--
2.11.0
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=81661">Michael Ellerman</a> - July 19, 2017, 12:03 p.m.</div>
<pre class="content">
Rob Herring &lt;robh@kernel.org&gt; writes:
<span class="quote">
&gt; Now that we have a custom printf format specifier, convert users of</span>
<span class="quote">&gt; full_name to use %pOF instead. This is preparation to remove storing</span>
<span class="quote">&gt; of the full path string for each node.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Rob Herring &lt;robh@kernel.org&gt;</span>
<span class="quote">&gt; Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span>
<span class="quote">&gt; Cc: Paul Mackerras &lt;paulus@samba.org&gt;</span>
<span class="quote">&gt; Cc: Michael Ellerman &lt;mpe@ellerman.id.au&gt;</span>
<span class="quote">&gt; Cc: Anatolij Gustschin &lt;agust@denx.de&gt;</span>
<span class="quote">&gt; Cc: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt; Cc: Kumar Gala &lt;galak@kernel.crashing.org&gt;</span>
<span class="quote">&gt; Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="quote">&gt; Cc: linuxppc-dev@lists.ozlabs.org</span>
<span class="quote">&gt; ---</span>
...
<span class="quote">&gt;  79 files changed, 464 insertions(+), 490 deletions(-)</span>


Is the plan that I&#39;ll merge this for 4.14 ?

cheers
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=86391">Rob Herring</a> - July 19, 2017, 3:37 p.m.</div>
<pre class="content">
On Wed, Jul 19, 2017 at 7:03 AM, Michael Ellerman &lt;mpe@ellerman.id.au&gt; wrote:
<span class="quote">&gt; Rob Herring &lt;robh@kernel.org&gt; writes:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Now that we have a custom printf format specifier, convert users of</span>
<span class="quote">&gt;&gt; full_name to use %pOF instead. This is preparation to remove storing</span>
<span class="quote">&gt;&gt; of the full path string for each node.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Rob Herring &lt;robh@kernel.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Paul Mackerras &lt;paulus@samba.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Michael Ellerman &lt;mpe@ellerman.id.au&gt;</span>
<span class="quote">&gt;&gt; Cc: Anatolij Gustschin &lt;agust@denx.de&gt;</span>
<span class="quote">&gt;&gt; Cc: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt;&gt; Cc: Kumar Gala &lt;galak@kernel.crashing.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="quote">&gt;&gt; Cc: linuxppc-dev@lists.ozlabs.org</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt;&gt;  79 files changed, 464 insertions(+), 490 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Is the plan that I&#39;ll merge this for 4.14 ?</span>

Yes, hence why it&#39;s not a series and sent to you.

Rob
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=101081">Tyrel Datwyler</a> - July 19, 2017, 7:44 p.m.</div>
<pre class="content">
On 07/18/2017 02:42 PM, Rob Herring wrote:
<span class="quote">&gt; Now that we have a custom printf format specifier, convert users of</span>
<span class="quote">&gt; full_name to use %pOF instead. This is preparation to remove storing</span>
<span class="quote">&gt; of the full path string for each node.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Rob Herring &lt;robh@kernel.org&gt;</span>
<span class="quote">&gt; Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span>
<span class="quote">&gt; Cc: Paul Mackerras &lt;paulus@samba.org&gt;</span>
<span class="quote">&gt; Cc: Michael Ellerman &lt;mpe@ellerman.id.au&gt;</span>
<span class="quote">&gt; Cc: Anatolij Gustschin &lt;agust@denx.de&gt;</span>
<span class="quote">&gt; Cc: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt; Cc: Kumar Gala &lt;galak@kernel.crashing.org&gt;</span>
<span class="quote">&gt; Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="quote">&gt; Cc: linuxppc-dev@lists.ozlabs.org</span>
<span class="reviewed-by">
Reviewed-by: Tyrel Datwyler &lt;tyreld@linux.vnet.ibm.com&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=81661">Michael Ellerman</a> - July 20, 2017, 3:34 a.m.</div>
<pre class="content">
Rob Herring &lt;robh@kernel.org&gt; writes:
<span class="quote">&gt; On Wed, Jul 19, 2017 at 7:03 AM, Michael Ellerman &lt;mpe@ellerman.id.au&gt; wrote:</span>
<span class="quote">&gt;&gt; Rob Herring &lt;robh@kernel.org&gt; writes:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Now that we have a custom printf format specifier, convert users of</span>
<span class="quote">&gt;&gt;&gt; full_name to use %pOF instead. This is preparation to remove storing</span>
<span class="quote">&gt;&gt;&gt; of the full path string for each node.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Rob Herring &lt;robh@kernel.org&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Paul Mackerras &lt;paulus@samba.org&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Michael Ellerman &lt;mpe@ellerman.id.au&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Anatolij Gustschin &lt;agust@denx.de&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Scott Wood &lt;oss@buserror.net&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Kumar Gala &lt;galak@kernel.crashing.org&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: linuxppc-dev@lists.ozlabs.org</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt; ...</span>
<span class="quote">&gt;&gt;&gt;  79 files changed, 464 insertions(+), 490 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Is the plan that I&#39;ll merge this for 4.14 ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yes, hence why it&#39;s not a series and sent to you.</span>

OK thanks. That was a bit too subtle for me :)

cheers
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/kernel/btext.c b/arch/powerpc/kernel/btext.c</span>
<span class="p_header">index 8275858a434d..3f46ca1c59f9 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/btext.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/btext.c</span>
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> int __init btext_find_display(int allow_nonstdout)</span>

 	for_each_node_by_type(np, &quot;display&quot;) {
 		if (of_get_property(np, &quot;linux,opened&quot;, NULL)) {
<span class="p_del">-			printk(&quot;trying %s ...\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+			printk(&quot;trying %pOF ...\n&quot;, np);</span>
 			rc = btext_initialize(np);
 			printk(&quot;result: %d\n&quot;, rc);
 		}
<span class="p_header">diff --git a/arch/powerpc/kernel/cacheinfo.c b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">index c641983bbdd6..a8f20e5928e1 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -167,10 +167,10 @@</span> <span class="p_context"> static void release_cache_debugcheck(struct cache *cache)</span>

 	list_for_each_entry(iter, &amp;cache_list, list)
 		WARN_ONCE(iter-&gt;next_local == cache,
<span class="p_del">-			  &quot;cache for %s(%s) refers to cache for %s(%s)\n&quot;,</span>
<span class="p_del">-			  iter-&gt;ofnode-&gt;full_name,</span>
<span class="p_add">+			  &quot;cache for %pOF(%s) refers to cache for %pOF(%s)\n&quot;,</span>
<span class="p_add">+			  iter-&gt;ofnode,</span>
 			  cache_type_string(iter),
<span class="p_del">-			  cache-&gt;ofnode-&gt;full_name,</span>
<span class="p_add">+			  cache-&gt;ofnode,</span>
 			  cache_type_string(cache));
 }

<span class="p_chunk">@@ -179,8 +179,8 @@</span> <span class="p_context"> static void release_cache(struct cache *cache)</span>
 	if (!cache)
 		return;

<span class="p_del">-	pr_debug(&quot;freeing L%d %s cache for %s\n&quot;, cache-&gt;level,</span>
<span class="p_del">-		 cache_type_string(cache), cache-&gt;ofnode-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;freeing L%d %s cache for %pOF\n&quot;, cache-&gt;level,</span>
<span class="p_add">+		 cache_type_string(cache), cache-&gt;ofnode);</span>

 	release_cache_debugcheck(cache);
 	list_del(&amp;cache-&gt;list);
<span class="p_chunk">@@ -194,8 +194,8 @@</span> <span class="p_context"> static void cache_cpu_set(struct cache *cache, int cpu)</span>

 	while (next) {
 		WARN_ONCE(cpumask_test_cpu(cpu, &amp;next-&gt;shared_cpu_map),
<span class="p_del">-			  &quot;CPU %i already accounted in %s(%s)\n&quot;,</span>
<span class="p_del">-			  cpu, next-&gt;ofnode-&gt;full_name,</span>
<span class="p_add">+			  &quot;CPU %i already accounted in %pOF(%s)\n&quot;,</span>
<span class="p_add">+			  cpu, next-&gt;ofnode,</span>
 			  cache_type_string(next));
 		cpumask_set_cpu(cpu, &amp;next-&gt;shared_cpu_map);
 		next = next-&gt;next_local;
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"> static int cache_is_unified_d(const struct device_node *np)</span>
  */
 static struct cache *cache_do_one_devnode_unified(struct device_node *node, int level)
 {
<span class="p_del">-	pr_debug(&quot;creating L%d ucache for %s\n&quot;, level, node-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;creating L%d ucache for %pOF\n&quot;, level, node);</span>

 	return new_cache(cache_is_unified_d(node), level, node);
 }
<span class="p_chunk">@@ -365,8 +365,8 @@</span> <span class="p_context"> static struct cache *cache_do_one_devnode_split(struct device_node *node,</span>
 {
 	struct cache *dcache, *icache;

<span class="p_del">-	pr_debug(&quot;creating L%d dcache and icache for %s\n&quot;, level,</span>
<span class="p_del">-		 node-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;creating L%d dcache and icache for %pOF\n&quot;, level,</span>
<span class="p_add">+		 node);</span>

 	dcache = new_cache(CACHE_TYPE_DATA, level, node);
 	icache = new_cache(CACHE_TYPE_INSTRUCTION, level, node);
<span class="p_chunk">@@ -679,7 +679,6 @@</span> <span class="p_context"> static struct kobj_type cache_index_type = {</span>

 static void cacheinfo_create_index_opt_attrs(struct cache_index_dir *dir)
 {
<span class="p_del">-	const char *cache_name;</span>
 	const char *cache_type;
 	struct cache *cache;
 	char *buf;
<span class="p_chunk">@@ -690,7 +689,6 @@</span> <span class="p_context"> static void cacheinfo_create_index_opt_attrs(struct cache_index_dir *dir)</span>
 		return;

 	cache = dir-&gt;cache;
<span class="p_del">-	cache_name = cache-&gt;ofnode-&gt;full_name;</span>
 	cache_type = cache_type_string(cache);

 	/* We don&#39;t want to create an attribute that can&#39;t provide a
<span class="p_chunk">@@ -707,14 +705,14 @@</span> <span class="p_context"> static void cacheinfo_create_index_opt_attrs(struct cache_index_dir *dir)</span>
 		rc = attr-&gt;show(&amp;dir-&gt;kobj, attr, buf);
 		if (rc &lt;= 0) {
 			pr_debug(&quot;not creating %s attribute for &quot;
<span class="p_del">-				 &quot;%s(%s) (rc = %zd)\n&quot;,</span>
<span class="p_del">-				 attr-&gt;attr.name, cache_name,</span>
<span class="p_add">+				 &quot;%pOF(%s) (rc = %zd)\n&quot;,</span>
<span class="p_add">+				 attr-&gt;attr.name, cache-&gt;ofnode,</span>
 				 cache_type, rc);
 			continue;
 		}
 		if (sysfs_create_file(&amp;dir-&gt;kobj, &amp;attr-&gt;attr))
<span class="p_del">-			pr_debug(&quot;could not create %s attribute for %s(%s)\n&quot;,</span>
<span class="p_del">-				 attr-&gt;attr.name, cache_name, cache_type);</span>
<span class="p_add">+			pr_debug(&quot;could not create %s attribute for %pOF(%s)\n&quot;,</span>
<span class="p_add">+				 attr-&gt;attr.name, cache-&gt;ofnode, cache_type);</span>
 	}

 	kfree(buf);
<span class="p_chunk">@@ -831,8 +829,8 @@</span> <span class="p_context"> static void cache_cpu_clear(struct cache *cache, int cpu)</span>
 		struct cache *next = cache-&gt;next_local;

 		WARN_ONCE(!cpumask_test_cpu(cpu, &amp;cache-&gt;shared_cpu_map),
<span class="p_del">-			  &quot;CPU %i not accounted in %s(%s)\n&quot;,</span>
<span class="p_del">-			  cpu, cache-&gt;ofnode-&gt;full_name,</span>
<span class="p_add">+			  &quot;CPU %i not accounted in %pOF(%s)\n&quot;,</span>
<span class="p_add">+			  cpu, cache-&gt;ofnode,</span>
 			  cache_type_string(cache));

 		cpumask_clear_cpu(cpu, &amp;cache-&gt;shared_cpu_map);
<span class="p_header">diff --git a/arch/powerpc/kernel/io-workarounds.c b/arch/powerpc/kernel/io-workarounds.c</span>
<span class="p_header">index a582e0d42525..9fd7bf1481bf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/io-workarounds.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/io-workarounds.c</span>
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> void iowa_register_bus(struct pci_controller *phb, struct ppc_pci_io *ops,</span>

 	if (iowa_bus_count &gt;= IOWA_MAX_BUS) {
 		pr_err(&quot;IOWA:Too many pci bridges, &quot;
<span class="p_del">-		       &quot;workarounds disabled for %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		       &quot;workarounds disabled for %pOF\n&quot;, np);</span>
 		return;
 	}

<span class="p_chunk">@@ -207,6 +207,6 @@</span> <span class="p_context"> void iowa_register_bus(struct pci_controller *phb, struct ppc_pci_io *ops,</span>

 	iowa_bus_count++;

<span class="p_del">-	pr_debug(&quot;IOWA:[%d]Add bus, %s.\n&quot;, iowa_bus_count-1, np-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;IOWA:[%d]Add bus, %pOF.\n&quot;, iowa_bus_count-1, np);</span>
 }

<span class="p_header">diff --git a/arch/powerpc/kernel/isa-bridge.c b/arch/powerpc/kernel/isa-bridge.c</span>
<span class="p_header">index bb6f8993412e..1df6c74aa731 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/isa-bridge.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/isa-bridge.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> void __init isa_bridge_find_early(struct pci_controller *hose)</span>
 	/* Set the global ISA io base to indicate we have an ISA bridge */
 	isa_io_base = ISA_IO_BASE;

<span class="p_del">-	pr_debug(&quot;ISA bridge (early) is %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;ISA bridge (early) is %pOF\n&quot;, np);</span>
 }

 /**
<span class="p_chunk">@@ -187,15 +187,15 @@</span> <span class="p_context"> void __init isa_bridge_init_non_pci(struct device_node *np)</span>
 	pna = of_n_addr_cells(np);
 	if (of_property_read_u32(np, &quot;#address-cells&quot;, &amp;na) ||
 	    of_property_read_u32(np, &quot;#size-cells&quot;, &amp;ns)) {
<span class="p_del">-		pr_warn(&quot;ISA: Non-PCI bridge %s is missing address format\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;ISA: Non-PCI bridge %pOF is missing address format\n&quot;,</span>
<span class="p_add">+			np);</span>
 		return;
 	}

 	/* Check it&#39;s a supported address format */
 	if (na != 2 || ns != 1) {
<span class="p_del">-		pr_warn(&quot;ISA: Non-PCI bridge %s has unsupported address format\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;ISA: Non-PCI bridge %pOF has unsupported address format\n&quot;,</span>
<span class="p_add">+			np);</span>
 		return;
 	}
 	rs = na + ns + pna;
<span class="p_chunk">@@ -203,8 +203,8 @@</span> <span class="p_context"> void __init isa_bridge_init_non_pci(struct device_node *np)</span>
 	/* Grab the ranges property */
 	ranges = of_get_property(np, &quot;ranges&quot;, &amp;rlen);
 	if (ranges == NULL || rlen &lt; rs) {
<span class="p_del">-		pr_warn(&quot;ISA: Non-PCI bridge %s has absent or invalid ranges\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;ISA: Non-PCI bridge %pOF has absent or invalid ranges\n&quot;,</span>
<span class="p_add">+			np);</span>
 		return;
 	}

<span class="p_chunk">@@ -220,8 +220,8 @@</span> <span class="p_context"> void __init isa_bridge_init_non_pci(struct device_node *np)</span>

 	/* Got something ? */
 	if (!size || !pbasep) {
<span class="p_del">-		pr_warn(&quot;ISA: Non-PCI bridge %s has no usable IO range\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;ISA: Non-PCI bridge %pOF has no usable IO range\n&quot;,</span>
<span class="p_add">+			np);</span>
 		return;
 	}

<span class="p_chunk">@@ -233,15 +233,15 @@</span> <span class="p_context"> void __init isa_bridge_init_non_pci(struct device_node *np)</span>
 	/* Map pbase */
 	pbase = of_translate_address(np, pbasep);
 	if (pbase == OF_BAD_ADDR) {
<span class="p_del">-		pr_warn(&quot;ISA: Non-PCI bridge %s failed to translate IO base\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;ISA: Non-PCI bridge %pOF failed to translate IO base\n&quot;,</span>
<span class="p_add">+			np);</span>
 		return;
 	}

 	/* We need page alignment */
 	if ((cbase &amp; ~PAGE_MASK) || (pbase &amp; ~PAGE_MASK)) {
<span class="p_del">-		pr_warn(&quot;ISA: Non-PCI bridge %s has non aligned IO range\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;ISA: Non-PCI bridge %pOF has non aligned IO range\n&quot;,</span>
<span class="p_add">+			np);</span>
 		return;
 	}

<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> void __init isa_bridge_init_non_pci(struct device_node *np)</span>
 	__ioremap_at(pbase, (void *)ISA_IO_BASE,
 		     size, pgprot_val(pgprot_noncached(__pgprot(0))));

<span class="p_del">-	pr_debug(&quot;ISA: Non-PCI bridge is %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;ISA: Non-PCI bridge is %pOF\n&quot;, np);</span>
 }

 /**
<span class="p_chunk">@@ -277,8 +277,8 @@</span> <span class="p_context"> static void isa_bridge_find_late(struct pci_dev *pdev,</span>
 	/* Set the global ISA io base to indicate we have an ISA bridge */
 	isa_io_base = ISA_IO_BASE;

<span class="p_del">-	pr_debug(&quot;ISA bridge (late) is %s on %s\n&quot;,</span>
<span class="p_del">-		 devnode-&gt;full_name, pci_name(pdev));</span>
<span class="p_add">+	pr_debug(&quot;ISA bridge (late) is %pOF on %s\n&quot;,</span>
<span class="p_add">+		 devnode, pci_name(pdev));</span>
 }

 /**
<span class="p_header">diff --git a/arch/powerpc/kernel/legacy_serial.c b/arch/powerpc/kernel/legacy_serial.c</span>
<span class="p_header">index 0694d20f85b6..5e5a64a8b4e4 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/legacy_serial.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/legacy_serial.c</span>
<span class="p_chunk">@@ -147,8 +147,8 @@</span> <span class="p_context"> static int __init add_legacy_port(struct device_node *np, int want_index,</span>
 		legacy_serial_ports[index].serial_out = tsi_serial_out;
 	}

<span class="p_del">-	printk(KERN_DEBUG &quot;Found legacy serial port %d for %s\n&quot;,</span>
<span class="p_del">-	       index, np-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_DEBUG &quot;Found legacy serial port %d for %pOF\n&quot;,</span>
<span class="p_add">+	       index, np);</span>
 	printk(KERN_DEBUG &quot;  %s=%llx, taddr=%llx, irq=%lx, clk=%d, speed=%d\n&quot;,
 	       (iotype == UPIO_PORT) ? &quot;port&quot; : &quot;mem&quot;,
 	       (unsigned long long)base, (unsigned long long)taddr, irq,
<span class="p_chunk">@@ -207,7 +207,7 @@</span> <span class="p_context"> static int __init add_legacy_isa_port(struct device_node *np,</span>
 	int index = -1;
 	u64 taddr;

<span class="p_del">-	DBG(&quot; -&gt; add_legacy_isa_port(%s)\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot; -&gt; add_legacy_isa_port(%pOF)\n&quot;, np);</span>

 	/* Get the ISA port number */
 	reg = of_get_property(np, &quot;reg&quot;, NULL);
<span class="p_chunk">@@ -256,7 +256,7 @@</span> <span class="p_context"> static int __init add_legacy_pci_port(struct device_node *np,</span>
 	unsigned int flags;
 	int iotype, index = -1, lindex = 0;

<span class="p_del">-	DBG(&quot; -&gt; add_legacy_pci_port(%s)\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot; -&gt; add_legacy_pci_port(%pOF)\n&quot;, np);</span>

 	/* We only support ports that have a clock frequency properly
 	 * encoded in the device-tree (that is have an fcode). Anything
<span class="p_chunk">@@ -374,7 +374,7 @@</span> <span class="p_context"> void __init find_legacy_serial_ports(void)</span>
 	if (path != NULL) {
 		stdout = of_find_node_by_path(path);
 		if (stdout)
<span class="p_del">-			DBG(&quot;stdout is %s\n&quot;, stdout-&gt;full_name);</span>
<span class="p_add">+			DBG(&quot;stdout is %pOF\n&quot;, stdout);</span>
 	} else {
 		DBG(&quot; no linux,stdout-path !\n&quot;);
 	}
<span class="p_chunk">@@ -603,7 +603,7 @@</span> <span class="p_context"> static int __init check_legacy_serial_console(void)</span>
 		DBG(&quot; can&#39;t find stdout package %s !\n&quot;, name);
 		return -ENODEV;
 	}
<span class="p_del">-	DBG(&quot;stdout is %s\n&quot;, prom_stdout-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;stdout is %pOF\n&quot;, prom_stdout);</span>

 	name = of_get_property(prom_stdout, &quot;name&quot;, NULL);
 	if (!name) {
<span class="p_header">diff --git a/arch/powerpc/kernel/of_platform.c b/arch/powerpc/kernel/of_platform.c</span>
<span class="p_header">index 34aeac54f120..becaec990140 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/of_platform.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/of_platform.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> static int of_pci_phb_probe(struct platform_device *dev)</span>
 	if (ppc_md.pci_setup_phb == NULL)
 		return -ENODEV;

<span class="p_del">-	pr_info(&quot;Setting up PCI bus %s\n&quot;, dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+	pr_info(&quot;Setting up PCI bus %pOF\n&quot;, dev-&gt;dev.of_node);</span>

 	/* Alloc and setup PHB data structure */
 	phb = pcibios_alloc_controller(dev-&gt;dev.of_node);
<span class="p_header">diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c</span>
<span class="p_header">index 341a7469cab8..02831a396419 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci-common.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci-common.c</span>
<span class="p_chunk">@@ -373,9 +373,8 @@</span> <span class="p_context"> static int pci_read_irq_line(struct pci_dev *pci_dev)</span>
 		if (virq)
 			irq_set_irq_type(virq, IRQ_TYPE_LEVEL_LOW);
 	} else {
<span class="p_del">-		pr_debug(&quot; Got one, spec %d cells (0x%08x 0x%08x...) on %s\n&quot;,</span>
<span class="p_del">-			 oirq.args_count, oirq.args[0], oirq.args[1],</span>
<span class="p_del">-			 of_node_full_name(oirq.np));</span>
<span class="p_add">+		pr_debug(&quot; Got one, spec %d cells (0x%08x 0x%08x...) on %pOF\n&quot;,</span>
<span class="p_add">+			 oirq.args_count, oirq.args[0], oirq.args[1], oirq.np);</span>

 		virq = irq_create_of_mapping(&amp;oirq);
 	}
<span class="p_chunk">@@ -741,8 +740,8 @@</span> <span class="p_context"> void pci_process_bridge_OF_ranges(struct pci_controller *hose,</span>
 	struct of_pci_range range;
 	struct of_pci_range_parser parser;

<span class="p_del">-	printk(KERN_INFO &quot;PCI host bridge %s %s ranges:\n&quot;,</span>
<span class="p_del">-	       dev-&gt;full_name, primary ? &quot;(primary)&quot; : &quot;&quot;);</span>
<span class="p_add">+	printk(KERN_INFO &quot;PCI host bridge %pOF %s ranges:\n&quot;,</span>
<span class="p_add">+	       dev, primary ? &quot;(primary)&quot; : &quot;&quot;);</span>

 	/* Check for ranges property */
 	if (of_pci_range_parser_init(&amp;parser, dev))
<span class="p_chunk">@@ -1556,8 +1555,8 @@</span> <span class="p_context"> static void pcibios_setup_phb_resources(struct pci_controller *hose,</span>

 	if (!res-&gt;flags) {
 		pr_debug(&quot;PCI: I/O resource not set for host&quot;
<span class="p_del">-			 &quot; bridge %s (domain %d)\n&quot;,</span>
<span class="p_del">-			 hose-&gt;dn-&gt;full_name, hose-&gt;global_number);</span>
<span class="p_add">+			 &quot; bridge %pOF (domain %d)\n&quot;,</span>
<span class="p_add">+			 hose-&gt;dn, hose-&gt;global_number);</span>
 	} else {
 		offset = pcibios_io_space_offset(hose);

<span class="p_chunk">@@ -1668,7 +1667,7 @@</span> <span class="p_context"> void pcibios_scan_phb(struct pci_controller *hose)</span>
 	struct device_node *node = hose-&gt;dn;
 	int mode;

<span class="p_del">-	pr_debug(&quot;PCI: Scanning PHB %s\n&quot;, of_node_full_name(node));</span>
<span class="p_add">+	pr_debug(&quot;PCI: Scanning PHB %pOF\n&quot;, node);</span>

 	/* Get some IO space for the new PHB */
 	pcibios_setup_phb_io_space(hose);
<span class="p_header">diff --git a/arch/powerpc/kernel/pci_32.c b/arch/powerpc/kernel/pci_32.c</span>
<span class="p_header">index 41c86c6b6e4d..1d817f4d97d9 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci_32.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci_32.c</span>
<span class="p_chunk">@@ -79,8 +79,8 @@</span> <span class="p_context"> make_one_node_map(struct device_node* node, u8 pci_bus)</span>
 		return;
 	bus_range = of_get_property(node, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, &quot;</span>
<span class="p_del">-		       &quot;assuming it starts at 0\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, &quot;</span>
<span class="p_add">+		       &quot;assuming it starts at 0\n&quot;, node);</span>
 		pci_to_OF_bus_map[pci_bus] = 0;
 	} else
 		pci_to_OF_bus_map[pci_bus] = bus_range[0];
<span class="p_header">diff --git a/arch/powerpc/kernel/pci_64.c b/arch/powerpc/kernel/pci_64.c</span>
<span class="p_header">index ed5e9ff61a68..932b9741aa8f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci_64.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> int pcibios_unmap_io_space(struct pci_bus *bus)</span>
 	if (hose-&gt;io_base_alloc == NULL)
 		return 0;

<span class="p_del">-	pr_debug(&quot;IO unmapping for PHB %s\n&quot;, hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;IO unmapping for PHB %pOF\n&quot;, hose-&gt;dn);</span>
 	pr_debug(&quot;  alloc=0x%p\n&quot;, hose-&gt;io_base_alloc);

 	/* This is a PHB, we fully unmap the IO area */
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static int pcibios_map_phb_io_space(struct pci_controller *hose)</span>
 	hose-&gt;io_base_virt = (void __iomem *)(area-&gt;addr +
 					      hose-&gt;io_base_phys - phys_page);

<span class="p_del">-	pr_debug(&quot;IO mapping for PHB %s\n&quot;, hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;IO mapping for PHB %pOF\n&quot;, hose-&gt;dn);</span>
 	pr_debug(&quot;  phys=0x%016llx, virt=0x%p (alloc=0x%p)\n&quot;,
 		 hose-&gt;io_base_phys, hose-&gt;io_base_virt, hose-&gt;io_base_alloc);
 	pr_debug(&quot;  size=0x%016llx (alloc=0x%016lx)\n&quot;,
<span class="p_header">diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_header">index ea3d98115b88..0d790f8432d2 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci_of_scan.c</span>
<span class="p_chunk">@@ -211,19 +211,19 @@</span> <span class="p_context"> void of_scan_pci_bridge(struct pci_dev *dev)</span>
 	unsigned int flags;
 	u64 size;

<span class="p_del">-	pr_debug(&quot;of_scan_pci_bridge(%s)\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;of_scan_pci_bridge(%pOF)\n&quot;, node);</span>

 	/* parse bus-range property */
 	busrange = of_get_property(node, &quot;bus-range&quot;, &amp;len);
 	if (busrange == NULL || len != 8) {
<span class="p_del">-		printk(KERN_DEBUG &quot;Can&#39;t get bus-range for PCI-PCI bridge %s\n&quot;,</span>
<span class="p_del">-		       node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_DEBUG &quot;Can&#39;t get bus-range for PCI-PCI bridge %pOF\n&quot;,</span>
<span class="p_add">+		       node);</span>
 		return;
 	}
 	ranges = of_get_property(node, &quot;ranges&quot;, &amp;len);
 	if (ranges == NULL) {
<span class="p_del">-		printk(KERN_DEBUG &quot;Can&#39;t get ranges for PCI-PCI bridge %s\n&quot;,</span>
<span class="p_del">-		       node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_DEBUG &quot;Can&#39;t get ranges for PCI-PCI bridge %pOF\n&quot;,</span>
<span class="p_add">+		       node);</span>
 		return;
 	}

<span class="p_chunk">@@ -233,8 +233,8 @@</span> <span class="p_context"> void of_scan_pci_bridge(struct pci_dev *dev)</span>
 		bus = pci_add_new_bus(dev-&gt;bus, dev,
 				      of_read_number(busrange, 1));
 		if (!bus) {
<span class="p_del">-			printk(KERN_ERR &quot;Failed to create pci bus for %s\n&quot;,</span>
<span class="p_del">-			       node-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_ERR &quot;Failed to create pci bus for %pOF\n&quot;,</span>
<span class="p_add">+			       node);</span>
 			return;
 		}
 	}
<span class="p_chunk">@@ -262,13 +262,13 @@</span> <span class="p_context"> void of_scan_pci_bridge(struct pci_dev *dev)</span>
 			res = bus-&gt;resource[0];
 			if (res-&gt;flags) {
 				printk(KERN_ERR &quot;PCI: ignoring extra I/O range&quot;
<span class="p_del">-				       &quot; for bridge %s\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+				       &quot; for bridge %pOF\n&quot;, node);</span>
 				continue;
 			}
 		} else {
 			if (i &gt;= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {
 				printk(KERN_ERR &quot;PCI: too many memory ranges&quot;
<span class="p_del">-				       &quot; for bridge %s\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+				       &quot; for bridge %pOF\n&quot;, node);</span>
 				continue;
 			}
 			res = bus-&gt;resource[i];
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,</span>
 	struct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));
 #endif

<span class="p_del">-	pr_debug(&quot;  * %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;  * %pOF\n&quot;, dn);</span>
 	if (!of_device_is_available(dn))
 		return NULL;

<span class="p_chunk">@@ -350,8 +350,8 @@</span> <span class="p_context"> static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,</span>
 	struct device_node *child;
 	struct pci_dev *dev;

<span class="p_del">-	pr_debug(&quot;of_scan_bus(%s) bus no %d...\n&quot;,</span>
<span class="p_del">-		 node-&gt;full_name, bus-&gt;number);</span>
<span class="p_add">+	pr_debug(&quot;of_scan_bus(%pOF) bus no %d...\n&quot;,</span>
<span class="p_add">+		 node, bus-&gt;number);</span>

 	/* Scan direct children */
 	for_each_child_of_node(node, child) {
<span class="p_header">diff --git a/arch/powerpc/kernel/setup-common.c b/arch/powerpc/kernel/setup-common.c</span>
<span class="p_header">index 94a948207cd2..417871054006 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/setup-common.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/setup-common.c</span>
<span class="p_chunk">@@ -481,7 +481,7 @@</span> <span class="p_context"> void __init smp_setup_cpu_maps(void)</span>
 		__be32 cpu_be;
 		int j, len;

<span class="p_del">-		DBG(&quot;  * %s...\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+		DBG(&quot;  * %pOF...\n&quot;, dn);</span>

 		intserv = of_get_property(dn, &quot;ibm,ppc-interrupt-server#s&quot;,
 				&amp;len);
<span class="p_header">diff --git a/arch/powerpc/platforms/512x/mpc512x_shared.c b/arch/powerpc/platforms/512x/mpc512x_shared.c</span>
<span class="p_header">index 6b4f4cb7009a..f99e79ee060e 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/512x/mpc512x_shared.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/512x/mpc512x_shared.c</span>
<span class="p_chunk">@@ -387,8 +387,8 @@</span> <span class="p_context"> static unsigned int __init get_fifo_size(struct device_node *np,</span>
 	if (fp)
 		return *fp;

<span class="p_del">-	pr_warning(&quot;no %s property in %s node, defaulting to %d\n&quot;,</span>
<span class="p_del">-		   prop_name, np-&gt;full_name, DEFAULT_FIFO_SIZE);</span>
<span class="p_add">+	pr_warning(&quot;no %s property in %pOF node, defaulting to %d\n&quot;,</span>
<span class="p_add">+		   prop_name, np, DEFAULT_FIFO_SIZE);</span>

 	return DEFAULT_FIFO_SIZE;
 }
<span class="p_chunk">@@ -426,15 +426,15 @@</span> <span class="p_context"> static void __init mpc512x_psc_fifo_init(void)</span>

 		psc = of_iomap(np, 0);
 		if (!psc) {
<span class="p_del">-			pr_err(&quot;%s: Can&#39;t map %s device\n&quot;,</span>
<span class="p_del">-				__func__, np-&gt;full_name);</span>
<span class="p_add">+			pr_err(&quot;%s: Can&#39;t map %pOF device\n&quot;,</span>
<span class="p_add">+				__func__, np);</span>
 			continue;
 		}

 		/* FIFO space is 4KiB, check if requested size is available */
 		if ((fifobase + tx_fifo_size + rx_fifo_size) &gt; 0x1000) {
<span class="p_del">-			pr_err(&quot;%s: no fifo space available for %s\n&quot;,</span>
<span class="p_del">-				__func__, np-&gt;full_name);</span>
<span class="p_add">+			pr_err(&quot;%s: no fifo space available for %pOF\n&quot;,</span>
<span class="p_add">+				__func__, np);</span>
 			iounmap(psc);
 			/*
 			 * chances are that another device requests less
<span class="p_header">diff --git a/arch/powerpc/platforms/52xx/efika.c b/arch/powerpc/platforms/52xx/efika.c</span>
<span class="p_header">index 39b49822ace1..1ecbf176d35a 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/52xx/efika.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/52xx/efika.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static void __init efika_pcisetup(void)</span>
 	bus_range = of_get_property(pcictrl, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
 		printk(KERN_WARNING EFIKA_PLATFORM_NAME
<span class="p_del">-		       &quot;: Can&#39;t get bus-range for %s\n&quot;, pcictrl-&gt;full_name);</span>
<span class="p_add">+		       &quot;: Can&#39;t get bus-range for %pOF\n&quot;, pcictrl);</span>
 		goto out_put;
 	}

<span class="p_chunk">@@ -109,14 +109,14 @@</span> <span class="p_context"> static void __init efika_pcisetup(void)</span>
 	else
 		printk(KERN_INFO EFIKA_PLATFORM_NAME &quot;: PCI buses %d..%d&quot;,
 		       bus_range[0], bus_range[1]);
<span class="p_del">-	printk(&quot; controlled by %s\n&quot;, pcictrl-&gt;full_name);</span>
<span class="p_add">+	printk(&quot; controlled by %pOF\n&quot;, pcictrl);</span>
 	printk(&quot;\n&quot;);

 	hose = pcibios_alloc_controller(pcictrl);
 	if (!hose) {
 		printk(KERN_WARNING EFIKA_PLATFORM_NAME
<span class="p_del">-		       &quot;: Can&#39;t allocate PCI controller structure for %s\n&quot;,</span>
<span class="p_del">-		       pcictrl-&gt;full_name);</span>
<span class="p_add">+		       &quot;: Can&#39;t allocate PCI controller structure for %pOF\n&quot;,</span>
<span class="p_add">+		       pcictrl);</span>
 		goto out_put;
 	}

<span class="p_header">diff --git a/arch/powerpc/platforms/52xx/media5200.c b/arch/powerpc/platforms/52xx/media5200.c</span>
<span class="p_header">index a3227040cc86..1fcab233d2f2 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/52xx/media5200.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/52xx/media5200.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> static void __init media5200_init_irq(void)</span>
 	fpga_np = of_find_compatible_node(NULL, NULL, &quot;fsl,media5200-fpga&quot;);
 	if (!fpga_np)
 		goto out;
<span class="p_del">-	pr_debug(&quot;%s: found fpga node: %s\n&quot;, __func__, fpga_np-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;%s: found fpga node: %pOF\n&quot;, __func__, fpga_np);</span>

 	media5200_irq.regs = of_iomap(fpga_np, 0);
 	if (!media5200_irq.regs)
<span class="p_header">diff --git a/arch/powerpc/platforms/52xx/mpc52xx_gpt.c b/arch/powerpc/platforms/52xx/mpc52xx_gpt.c</span>
<span class="p_header">index 22645a7c6b8a..9e974b1e1697 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/52xx/mpc52xx_gpt.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/52xx/mpc52xx_gpt.c</span>
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> static int mpc52xx_gpt_irq_xlate(struct irq_domain *h, struct device_node *ct,</span>
 	dev_dbg(gpt-&gt;dev, &quot;%s: flags=%i\n&quot;, __func__, intspec[0]);

 	if ((intsize &lt; 1) || (intspec[0] &gt; 3)) {
<span class="p_del">-		dev_err(gpt-&gt;dev, &quot;bad irq specifier in %s\n&quot;, ct-&gt;full_name);</span>
<span class="p_add">+		dev_err(gpt-&gt;dev, &quot;bad irq specifier in %pOF\n&quot;, ct);</span>
 		return -EINVAL;
 	}

<span class="p_chunk">@@ -331,7 +331,7 @@</span> <span class="p_context"> mpc52xx_gpt_gpio_setup(struct mpc52xx_gpt_priv *gpt, struct device_node *node)</span>
 	if (!of_find_property(node, &quot;gpio-controller&quot;, NULL))
 		return;

<span class="p_del">-	gpt-&gt;gc.label = kstrdup(node-&gt;full_name, GFP_KERNEL);</span>
<span class="p_add">+	gpt-&gt;gc.label = kasprintf(GFP_KERNEL, &quot;%pOF&quot;, node);</span>
 	if (!gpt-&gt;gc.label) {
 		dev_err(gpt-&gt;dev, &quot;out of memory\n&quot;);
 		return;
<span class="p_header">diff --git a/arch/powerpc/platforms/52xx/mpc52xx_pci.c b/arch/powerpc/platforms/52xx/mpc52xx_pci.c</span>
<span class="p_header">index 00282c2b0cae..af0f79995214 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/52xx/mpc52xx_pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/52xx/mpc52xx_pci.c</span>
<span class="p_chunk">@@ -369,19 +369,19 @@</span> <span class="p_context"> mpc52xx_add_bridge(struct device_node *node)</span>
 	const int *bus_range;
 	struct resource rsrc;

<span class="p_del">-	pr_debug(&quot;Adding MPC52xx PCI host bridge %s\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;Adding MPC52xx PCI host bridge %pOF\n&quot;, node);</span>

 	pci_add_flags(PCI_REASSIGN_ALL_BUS);

 	if (of_address_to_resource(node, 0, &amp;rsrc) != 0) {
<span class="p_del">-		printk(KERN_ERR &quot;Can&#39;t get %s resources\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;Can&#39;t get %pOF resources\n&quot;, node);</span>
 		return -EINVAL;
 	}

 	bus_range = of_get_property(node, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get %s bus-range, assume bus 0\n&quot;,</span>
<span class="p_del">-		       node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get %pOF bus-range, assume bus 0\n&quot;,</span>
<span class="p_add">+		       node);</span>
 		bus_range = NULL;
 	}

<span class="p_header">diff --git a/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c b/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c</span>
<span class="p_header">index 63c5ab6489c9..96bb55ca61d3 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/83xx/mcu_mpc8349emitx.c</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> static int mcu_gpiochip_add(struct mcu *mcu)</span>
 		return -ENODEV;

 	gc-&gt;owner = THIS_MODULE;
<span class="p_del">-	gc-&gt;label = np-&gt;full_name;</span>
<span class="p_add">+	gc-&gt;label = kasprintf(GFP_KERNEL, &quot;%pOF&quot;, np);</span>
 	gc-&gt;can_sleep = 1;
 	gc-&gt;ngpio = MCU_NUM_GPIO;
 	gc-&gt;base = -1;
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static int mcu_gpiochip_add(struct mcu *mcu)</span>

 static int mcu_gpiochip_remove(struct mcu *mcu)
 {
<span class="p_add">+	kfree(mcu-&gt;gc.label);</span>
 	gpiochip_remove(&amp;mcu-&gt;gc);
 	return 0;
 }
<span class="p_header">diff --git a/arch/powerpc/platforms/83xx/mpc832x_rdb.c b/arch/powerpc/platforms/83xx/mpc832x_rdb.c</span>
<span class="p_header">index d7c9b186954d..53a08d5d7db5 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/83xx/mpc832x_rdb.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/83xx/mpc832x_rdb.c</span>
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static int __init of_fsl_spi_probe(char *type, char *compatible, u32 sysclk,</span>
 unreg:
 		platform_device_del(pdev);
 err:
<span class="p_del">-		pr_err(&quot;%s: registration failed\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: registration failed\n&quot;, np);</span>
 next:
 		i++;
 	}
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/p1022_ds.c b/arch/powerpc/platforms/85xx/p1022_ds.c</span>
<span class="p_header">index 0908abd7e36f..9fb57f78cdbe 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/85xx/p1022_ds.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/p1022_ds.c</span>
<span class="p_chunk">@@ -508,8 +508,8 @@</span> <span class="p_context"> static void __init p1022_ds_setup_arch(void)</span>
 				 * allocate one static local variable for each
 				 * call to this function.
 				 */
<span class="p_del">-				pr_info(&quot;p1022ds: disabling %s node&quot;,</span>
<span class="p_del">-					np2-&gt;full_name);</span>
<span class="p_add">+				pr_info(&quot;p1022ds: disabling %pOF node&quot;,</span>
<span class="p_add">+					np2);</span>
 				of_update_property(np2, &amp;nor_status);
 				of_node_put(np2);
 			}
<span class="p_chunk">@@ -524,8 +524,8 @@</span> <span class="p_context"> static void __init p1022_ds_setup_arch(void)</span>
 					.length = sizeof(&quot;disabled&quot;),
 				};

<span class="p_del">-				pr_info(&quot;p1022ds: disabling %s node&quot;,</span>
<span class="p_del">-					np2-&gt;full_name);</span>
<span class="p_add">+				pr_info(&quot;p1022ds: disabling %pOF node&quot;,</span>
<span class="p_add">+					np2);</span>
 				of_update_property(np2, &amp;nand_status);
 				of_node_put(np2);
 			}
<span class="p_header">diff --git a/arch/powerpc/platforms/85xx/xes_mpc85xx.c b/arch/powerpc/platforms/85xx/xes_mpc85xx.c</span>
<span class="p_header">index cd6ce845f398..77e618dce4a8 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/85xx/xes_mpc85xx.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/85xx/xes_mpc85xx.c</span>
<span class="p_chunk">@@ -100,8 +100,8 @@</span> <span class="p_context"> static void xes_mpc85xx_fixups(void)</span>
 		err = of_address_to_resource(np, 0, &amp;r[0]);
 		if (err) {
 			printk(KERN_WARNING &quot;xes_mpc85xx: Could not get &quot;
<span class="p_del">-			       &quot;resource for device tree node &#39;%s&#39;&quot;,</span>
<span class="p_del">-			       np-&gt;full_name);</span>
<span class="p_add">+			       &quot;resource for device tree node &#39;%pOF&#39;&quot;,</span>
<span class="p_add">+			       np);</span>
 			continue;
 		}

<span class="p_header">diff --git a/arch/powerpc/platforms/amigaone/setup.c b/arch/powerpc/platforms/amigaone/setup.c</span>
<span class="p_header">index 45cb9821173c..b9d466cc2b8a 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/amigaone/setup.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/amigaone/setup.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> static int __init amigaone_add_bridge(struct device_node *dev)</span>
 	const int *bus_range;
 	struct pci_controller *hose;

<span class="p_del">-	printk(KERN_INFO &quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_INFO &quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	cfg_addr = of_get_address(dev, 0, NULL, NULL);
 	cfg_data = of_get_address(dev, 1, NULL, NULL);
<span class="p_chunk">@@ -49,8 +49,8 @@</span> <span class="p_context"> static int __init amigaone_add_bridge(struct device_node *dev)</span>

 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if ((bus_range == NULL) || (len &lt; 2 * sizeof(int)))
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume&quot;</span>
<span class="p_del">-		       &quot; bus 0\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume&quot;</span>
<span class="p_add">+		       &quot; bus 0\n&quot;, dev);</span>

 	hose = pcibios_alloc_controller(dev);
 	if (hose == NULL)
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/axon_msi.c b/arch/powerpc/platforms/cell/axon_msi.c</span>
<span class="p_header">index 8d3ae2cc52bf..6ea3f248b155 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/axon_msi.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/axon_msi.c</span>
<span class="p_chunk">@@ -187,8 +187,8 @@</span> <span class="p_context"> static struct axon_msic *find_msi_translator(struct pci_dev *dev)</span>

 	irq_domain = irq_find_host(dn);
 	if (!irq_domain) {
<span class="p_del">-		dev_dbg(&amp;dev-&gt;dev, &quot;axon_msi: no irq_domain found for node %s\n&quot;,</span>
<span class="p_del">-			dn-&gt;full_name);</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;axon_msi: no irq_domain found for node %pOF\n&quot;,</span>
<span class="p_add">+			dn);</span>
 		goto out_error;
 	}

<span class="p_chunk">@@ -326,8 +326,8 @@</span> <span class="p_context"> static void axon_msi_shutdown(struct platform_device *device)</span>
 	struct axon_msic *msic = dev_get_drvdata(&amp;device-&gt;dev);
 	u32 tmp;

<span class="p_del">-	pr_devel(&quot;axon_msi: disabling %s\n&quot;,</span>
<span class="p_del">-		 irq_domain_get_of_node(msic-&gt;irq_domain)-&gt;full_name);</span>
<span class="p_add">+	pr_devel(&quot;axon_msi: disabling %pOF\n&quot;,</span>
<span class="p_add">+		 irq_domain_get_of_node(msic-&gt;irq_domain));</span>
 	tmp  = dcr_read(msic-&gt;dcr_host, MSIC_CTRL_REG);
 	tmp &amp;= ~MSIC_CTRL_ENABLE &amp; ~MSIC_CTRL_IRQ_ENABLE;
 	msic_dcr_write(msic, MSIC_CTRL_REG, tmp);
<span class="p_chunk">@@ -340,12 +340,12 @@</span> <span class="p_context"> static int axon_msi_probe(struct platform_device *device)</span>
 	unsigned int virq;
 	int dcr_base, dcr_len;

<span class="p_del">-	pr_devel(&quot;axon_msi: setting up dn %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	pr_devel(&quot;axon_msi: setting up dn %pOF\n&quot;, dn);</span>

 	msic = kzalloc(sizeof(struct axon_msic), GFP_KERNEL);
 	if (!msic) {
<span class="p_del">-		printk(KERN_ERR &quot;axon_msi: couldn&#39;t allocate msic for %s\n&quot;,</span>
<span class="p_del">-		       dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;axon_msi: couldn&#39;t allocate msic for %pOF\n&quot;,</span>
<span class="p_add">+		       dn);</span>
 		goto out;
 	}

<span class="p_chunk">@@ -354,30 +354,30 @@</span> <span class="p_context"> static int axon_msi_probe(struct platform_device *device)</span>

 	if (dcr_base == 0 || dcr_len == 0) {
 		printk(KERN_ERR
<span class="p_del">-		       &quot;axon_msi: couldn&#39;t parse dcr properties on %s\n&quot;,</span>
<span class="p_del">-			dn-&gt;full_name);</span>
<span class="p_add">+		       &quot;axon_msi: couldn&#39;t parse dcr properties on %pOF\n&quot;,</span>
<span class="p_add">+			dn);</span>
 		goto out_free_msic;
 	}

 	msic-&gt;dcr_host = dcr_map(dn, dcr_base, dcr_len);
 	if (!DCR_MAP_OK(msic-&gt;dcr_host)) {
<span class="p_del">-		printk(KERN_ERR &quot;axon_msi: dcr_map failed for %s\n&quot;,</span>
<span class="p_del">-		       dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;axon_msi: dcr_map failed for %pOF\n&quot;,</span>
<span class="p_add">+		       dn);</span>
 		goto out_free_msic;
 	}

 	msic-&gt;fifo_virt = dma_alloc_coherent(&amp;device-&gt;dev, MSIC_FIFO_SIZE_BYTES,
 					     &amp;msic-&gt;fifo_phys, GFP_KERNEL);
 	if (!msic-&gt;fifo_virt) {
<span class="p_del">-		printk(KERN_ERR &quot;axon_msi: couldn&#39;t allocate fifo for %s\n&quot;,</span>
<span class="p_del">-		       dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;axon_msi: couldn&#39;t allocate fifo for %pOF\n&quot;,</span>
<span class="p_add">+		       dn);</span>
 		goto out_free_msic;
 	}

 	virq = irq_of_parse_and_map(dn, 0);
 	if (!virq) {
<span class="p_del">-		printk(KERN_ERR &quot;axon_msi: irq parse and map failed for %s\n&quot;,</span>
<span class="p_del">-		       dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;axon_msi: irq parse and map failed for %pOF\n&quot;,</span>
<span class="p_add">+		       dn);</span>
 		goto out_free_fifo;
 	}
 	memset(msic-&gt;fifo_virt, 0xff, MSIC_FIFO_SIZE_BYTES);
<span class="p_chunk">@@ -385,8 +385,8 @@</span> <span class="p_context"> static int axon_msi_probe(struct platform_device *device)</span>
 	/* We rely on being able to stash a virq in a u16, so limit irqs to &lt; 65536 */
 	msic-&gt;irq_domain = irq_domain_add_nomap(dn, 65536, &amp;msic_host_ops, msic);
 	if (!msic-&gt;irq_domain) {
<span class="p_del">-		printk(KERN_ERR &quot;axon_msi: couldn&#39;t allocate irq_domain for %s\n&quot;,</span>
<span class="p_del">-		       dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;axon_msi: couldn&#39;t allocate irq_domain for %pOF\n&quot;,</span>
<span class="p_add">+		       dn);</span>
 		goto out_free_fifo;
 	}

<span class="p_chunk">@@ -412,7 +412,7 @@</span> <span class="p_context"> static int axon_msi_probe(struct platform_device *device)</span>

 	axon_msi_debug_setup(dn, msic);

<span class="p_del">-	printk(KERN_DEBUG &quot;axon_msi: setup MSIC on %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_DEBUG &quot;axon_msi: setup MSIC on %pOF\n&quot;, dn);</span>

 	return 0;

<span class="p_header">diff --git a/arch/powerpc/platforms/cell/interrupt.c b/arch/powerpc/platforms/cell/interrupt.c</span>
<span class="p_header">index 871d38479a25..6fc85e29dc08 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/interrupt.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/interrupt.c</span>
<span class="p_chunk">@@ -303,8 +303,8 @@</span> <span class="p_context"> static void __init init_one_iic(unsigned int hw_cpu, unsigned long addr,</span>
 	iic-&gt;node = of_node_get(node);
 	out_be64(&amp;iic-&gt;regs-&gt;prio, 0);

<span class="p_del">-	printk(KERN_INFO &quot;IIC for CPU %d target id 0x%x : %s\n&quot;,</span>
<span class="p_del">-	       hw_cpu, iic-&gt;target_id, node-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_INFO &quot;IIC for CPU %d target id 0x%x : %pOF\n&quot;,</span>
<span class="p_add">+	       hw_cpu, iic-&gt;target_id, node);</span>
 }

 static int __init setup_iic(void)
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/iommu.c b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">index 29d4f96ed33e..4b91ad08eefd 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/iommu.c</span>
<span class="p_chunk">@@ -278,8 +278,8 @@</span> <span class="p_context"> static int cell_iommu_find_ioc(int nid, unsigned long *base)</span>
 		if (of_node_to_nid(np) != nid)
 			continue;
 		if (of_address_to_resource(np, 0, &amp;r)) {
<span class="p_del">-			printk(KERN_ERR &quot;iommu: can&#39;t get address for %s\n&quot;,</span>
<span class="p_del">-			       np-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_ERR &quot;iommu: can&#39;t get address for %pOF\n&quot;,</span>
<span class="p_add">+			       np);</span>
 			continue;
 		}
 		*base = r.start;
<span class="p_chunk">@@ -458,8 +458,8 @@</span> <span class="p_context"> static inline u32 cell_iommu_get_ioid(struct device_node *np)</span>

 	ioid = of_get_property(np, &quot;ioid&quot;, NULL);
 	if (ioid == NULL) {
<span class="p_del">-		printk(KERN_WARNING &quot;iommu: missing ioid for %s using 0\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;iommu: missing ioid for %pOF using 0\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		return 0;
 	}

<span class="p_chunk">@@ -559,8 +559,8 @@</span> <span class="p_context"> static struct iommu_table *cell_get_iommu_table(struct device *dev)</span>
 	 */
 	iommu = cell_iommu_for_node(dev_to_node(dev));
 	if (iommu == NULL || list_empty(&amp;iommu-&gt;windows)) {
<span class="p_del">-		dev_err(dev, &quot;iommu: missing iommu for %s (node %d)\n&quot;,</span>
<span class="p_del">-		       of_node_full_name(dev-&gt;of_node), dev_to_node(dev));</span>
<span class="p_add">+		dev_err(dev, &quot;iommu: missing iommu for %pOF (node %d)\n&quot;,</span>
<span class="p_add">+		       dev-&gt;of_node, dev_to_node(dev));</span>
 		return NULL;
 	}
 	window = list_entry(iommu-&gt;windows.next, struct iommu_window, list);
<span class="p_chunk">@@ -720,12 +720,12 @@</span> <span class="p_context"> static struct cbe_iommu * __init cell_iommu_alloc(struct device_node *np)</span>
 	/* Get node ID */
 	nid = of_node_to_nid(np);
 	if (nid &lt; 0) {
<span class="p_del">-		printk(KERN_ERR &quot;iommu: failed to get node for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;iommu: failed to get node for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		return NULL;
 	}
<span class="p_del">-	pr_debug(&quot;iommu: setting up iommu for node %d (%s)\n&quot;,</span>
<span class="p_del">-		 nid, np-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;iommu: setting up iommu for node %d (%pOF)\n&quot;,</span>
<span class="p_add">+		 nid, np);</span>

 	/* XXX todo: If we can have multiple windows on the same IOMMU, which
 	 * isn&#39;t the case today, we probably want here to check whether the
<span class="p_chunk">@@ -736,8 +736,8 @@</span> <span class="p_context"> static struct cbe_iommu * __init cell_iommu_alloc(struct device_node *np)</span>
 	 */

 	if (cbe_nr_iommus &gt;= NR_IOMMUS) {
<span class="p_del">-		printk(KERN_ERR &quot;iommu: too many IOMMUs detected ! (%s)\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;iommu: too many IOMMUs detected ! (%pOF)\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		return NULL;
 	}

<span class="p_header">diff --git a/arch/powerpc/platforms/cell/ras.c b/arch/powerpc/platforms/cell/ras.c</span>
<span class="p_header">index 460ab392f0e7..2f704afe9af3 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/ras.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/ras.c</span>
<span class="p_chunk">@@ -196,8 +196,8 @@</span> <span class="p_context"> static int __init cbe_ptcal_enable(void)</span>
 	for_each_node_by_type(np, &quot;cpu&quot;) {
 		const u32 *nid = of_get_property(np, &quot;node-id&quot;, NULL);
 		if (!nid) {
<span class="p_del">-			printk(KERN_ERR &quot;%s: node %s is missing node-id?\n&quot;,</span>
<span class="p_del">-					__func__, np-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_ERR &quot;%s: node %pOF is missing node-id?\n&quot;,</span>
<span class="p_add">+					__func__, np);</span>
 			continue;
 		}
 		cbe_ptcal_enable_on_node(*nid, order);
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/spider-pci.c b/arch/powerpc/platforms/cell/spider-pci.c</span>
<span class="p_header">index f1f7878893f3..d1e61e273e64 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/spider-pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/spider-pci.c</span>
<span class="p_chunk">@@ -130,8 +130,8 @@</span> <span class="p_context"> int __init spiderpci_iowa_init(struct iowa_bus *bus, void *data)</span>
 	struct resource r;
 	unsigned long offset = (unsigned long)data;

<span class="p_del">-	pr_debug(&quot;SPIDERPCI-IOWA:Bus initialize for spider(%s)\n&quot;,</span>
<span class="p_del">-		 np-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;SPIDERPCI-IOWA:Bus initialize for spider(%pOF)\n&quot;,</span>
<span class="p_add">+		 np);</span>

 	priv = kzalloc(sizeof(struct spiderpci_iowa_private), GFP_KERNEL);
 	if (!priv) {
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/spider-pic.c b/arch/powerpc/platforms/cell/spider-pic.c</span>
<span class="p_header">index ff924af00e78..aa44bfc46467 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/spider-pic.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/spider-pic.c</span>
<span class="p_chunk">@@ -323,8 +323,8 @@</span> <span class="p_context"> static void __init spider_init_one(struct device_node *of_node, int chip,</span>
 	irq_set_handler_data(virq, pic);
 	irq_set_chained_handler(virq, spider_irq_cascade);

<span class="p_del">-	printk(KERN_INFO &quot;spider_pic: node %d, addr: 0x%lx %s\n&quot;,</span>
<span class="p_del">-	       pic-&gt;node_id, addr, of_node-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_INFO &quot;spider_pic: node %d, addr: 0x%lx %pOF\n&quot;,</span>
<span class="p_add">+	       pic-&gt;node_id, addr, of_node);</span>

 	/* Enable the interrupt detection enable bit. Do this last! */
 	out_be32(pic-&gt;regs + TIR_DEN, in_be32(pic-&gt;regs + TIR_DEN) | 0x1);
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/spu_manage.c b/arch/powerpc/platforms/cell/spu_manage.c</span>
<span class="p_header">index 672d310dcf14..f636ee22b203 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/spu_manage.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/spu_manage.c</span>
<span class="p_chunk">@@ -191,8 +191,8 @@</span> <span class="p_context"> static int __init spu_map_interrupts(struct spu *spu, struct device_node *np)</span>
 			goto err;
 		}
 		ret = -EINVAL;
<span class="p_del">-		pr_debug(&quot;  irq %d no 0x%x on %s\n&quot;, i, oirq.args[0],</span>
<span class="p_del">-			 oirq.np-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;  irq %d no 0x%x on %pOF\n&quot;, i, oirq.args[0],</span>
<span class="p_add">+			 oirq.np);</span>
 		spu-&gt;irqs[i] = irq_create_of_mapping(&amp;oirq);
 		if (!spu-&gt;irqs[i]) {
 			pr_debug(&quot;spu_new: failed to map it !\n&quot;);
<span class="p_chunk">@@ -243,32 +243,32 @@</span> <span class="p_context"> static int __init spu_map_device(struct spu *spu)</span>
 	ret = spu_map_resource(spu, 0, (void __iomem**)&amp;spu-&gt;local_store,
 			       &amp;spu-&gt;local_store_phys);
 	if (ret) {
<span class="p_del">-		pr_debug(&quot;spu_new: failed to map %s resource 0\n&quot;,</span>
<span class="p_del">-			 np-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;spu_new: failed to map %pOF resource 0\n&quot;,</span>
<span class="p_add">+			 np);</span>
 		goto out;
 	}
 	ret = spu_map_resource(spu, 1, (void __iomem**)&amp;spu-&gt;problem,
 			       &amp;spu-&gt;problem_phys);
 	if (ret) {
<span class="p_del">-		pr_debug(&quot;spu_new: failed to map %s resource 1\n&quot;,</span>
<span class="p_del">-			 np-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;spu_new: failed to map %pOF resource 1\n&quot;,</span>
<span class="p_add">+			 np);</span>
 		goto out_unmap;
 	}
 	ret = spu_map_resource(spu, 2, (void __iomem**)&amp;spu-&gt;priv2, NULL);
 	if (ret) {
<span class="p_del">-		pr_debug(&quot;spu_new: failed to map %s resource 2\n&quot;,</span>
<span class="p_del">-			 np-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;spu_new: failed to map %pOF resource 2\n&quot;,</span>
<span class="p_add">+			 np);</span>
 		goto out_unmap;
 	}
 	if (!firmware_has_feature(FW_FEATURE_LPAR))
 		ret = spu_map_resource(spu, 3,
 			       (void __iomem**)&amp;spu-&gt;priv1, NULL);
 	if (ret) {
<span class="p_del">-		pr_debug(&quot;spu_new: failed to map %s resource 3\n&quot;,</span>
<span class="p_del">-			 np-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;spu_new: failed to map %pOF resource 3\n&quot;,</span>
<span class="p_add">+			 np);</span>
 		goto out_unmap;
 	}
<span class="p_del">-	pr_debug(&quot;spu_new: %s maps:\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;spu_new: %pOF maps:\n&quot;, np);</span>
 	pr_debug(&quot;  local store   : 0x%016lx -&gt; 0x%p\n&quot;,
 		 spu-&gt;local_store_phys, spu-&gt;local_store);
 	pr_debug(&quot;  problem state : 0x%016lx -&gt; 0x%p\n&quot;,
<span class="p_chunk">@@ -316,8 +316,8 @@</span> <span class="p_context"> static int __init of_create_spu(struct spu *spu, void *data)</span>

 	spu-&gt;node = of_node_to_nid(spe);
 	if (spu-&gt;node &gt;= MAX_NUMNODES) {
<span class="p_del">-		printk(KERN_WARNING &quot;SPE %s on node %d ignored,&quot;</span>
<span class="p_del">-		       &quot; node number too big\n&quot;, spe-&gt;full_name, spu-&gt;node);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;SPE %pOF on node %d ignored,&quot;</span>
<span class="p_add">+		       &quot; node number too big\n&quot;, spe, spu-&gt;node);</span>
 		printk(KERN_WARNING &quot;Check if CONFIG_NUMA is enabled.\n&quot;);
 		ret = -ENODEV;
 		goto out;
<span class="p_header">diff --git a/arch/powerpc/platforms/chrp/pci.c b/arch/powerpc/platforms/chrp/pci.c</span>
<span class="p_header">index 1b87e198faa7..27264794f5c0 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/chrp/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/chrp/pci.c</span>
<span class="p_chunk">@@ -235,14 +235,14 @@</span> <span class="p_context"> chrp_find_bridges(void)</span>
 		++index;
 		/* The GG2 bridge on the LongTrail doesn&#39;t have an address */
 		if (of_address_to_resource(dev, 0, &amp;r) &amp;&amp; !is_longtrail) {
<span class="p_del">-			printk(KERN_WARNING &quot;Can&#39;t use %s: no address\n&quot;,</span>
<span class="p_del">-			       dev-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_WARNING &quot;Can&#39;t use %pOF: no address\n&quot;,</span>
<span class="p_add">+			       dev);</span>
 			continue;
 		}
 		bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 		if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-			printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s\n&quot;,</span>
<span class="p_del">-				dev-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF\n&quot;,</span>
<span class="p_add">+				dev);</span>
 			continue;
 		}
 		if (bus_range[1] == bus_range[0])
<span class="p_chunk">@@ -250,15 +250,15 @@</span> <span class="p_context"> chrp_find_bridges(void)</span>
 		else
 			printk(KERN_INFO &quot;PCI buses %d..%d&quot;,
 			       bus_range[0], bus_range[1]);
<span class="p_del">-		printk(&quot; controlled by %s&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(&quot; controlled by %pOF&quot;, dev);</span>
 		if (!is_longtrail)
 			printk(&quot; at %llx&quot;, (unsigned long long)r.start);
 		printk(&quot;\n&quot;);

 		hose = pcibios_alloc_controller(dev);
 		if (!hose) {
<span class="p_del">-			printk(&quot;Can&#39;t allocate PCI controller structure for %s\n&quot;,</span>
<span class="p_del">-				dev-&gt;full_name);</span>
<span class="p_add">+			printk(&quot;Can&#39;t allocate PCI controller structure for %pOF\n&quot;,</span>
<span class="p_add">+				dev);</span>
 			continue;
 		}
 		hose-&gt;first_busno = hose-&gt;self_busno = bus_range[0];
<span class="p_chunk">@@ -297,8 +297,8 @@</span> <span class="p_context"> chrp_find_bridges(void)</span>
 				}
 			}
 		} else {
<span class="p_del">-			printk(&quot;No methods for %s (model %s), using RTAS\n&quot;,</span>
<span class="p_del">-			       dev-&gt;full_name, model);</span>
<span class="p_add">+			printk(&quot;No methods for %pOF (model %s), using RTAS\n&quot;,</span>
<span class="p_add">+			       dev, model);</span>
 			hose-&gt;ops = &amp;rtas_pci_ops;
 		}

<span class="p_header">diff --git a/arch/powerpc/platforms/embedded6xx/linkstation.c b/arch/powerpc/platforms/embedded6xx/linkstation.c</span>
<span class="p_header">index f29cf29b11f8..f514d5d28cd4 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/embedded6xx/linkstation.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/embedded6xx/linkstation.c</span>
<span class="p_chunk">@@ -41,12 +41,12 @@</span> <span class="p_context"> static int __init linkstation_add_bridge(struct device_node *dev)</span>
 	struct pci_controller *hose;
 	const int *bus_range;

<span class="p_del">-	printk(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	printk(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int))
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume&quot;</span>
<span class="p_del">-				&quot; bus 0\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume&quot;</span>
<span class="p_add">+				&quot; bus 0\n&quot;, dev);</span>

 	hose = pcibios_alloc_controller(dev);
 	if (hose == NULL)
<span class="p_header">diff --git a/arch/powerpc/platforms/embedded6xx/mvme5100.c b/arch/powerpc/platforms/embedded6xx/mvme5100.c</span>
<span class="p_header">index 8e3590941960..273dfa3f0252 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/embedded6xx/mvme5100.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/embedded6xx/mvme5100.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> static int __init mvme5100_add_bridge(struct device_node *dev)</span>
 	struct pci_controller	*hose;
 	unsigned short		devid;

<span class="p_del">-	pr_info(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	pr_info(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);

<span class="p_header">diff --git a/arch/powerpc/platforms/embedded6xx/storcenter.c b/arch/powerpc/platforms/embedded6xx/storcenter.c</span>
<span class="p_header">index 471a50bcd074..ed1914dd34bb 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/embedded6xx/storcenter.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/embedded6xx/storcenter.c</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static int __init storcenter_add_bridge(struct device_node *dev)</span>
 	struct pci_controller *hose;
 	const int *bus_range;

<span class="p_del">-	printk(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	printk(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	hose = pcibios_alloc_controller(dev);
 	if (hose == NULL)
<span class="p_header">diff --git a/arch/powerpc/platforms/maple/pci.c b/arch/powerpc/platforms/maple/pci.c</span>
<span class="p_header">index 69794d9389c2..e3821379e86f 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/maple/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/maple/pci.c</span>
<span class="p_chunk">@@ -73,8 +73,8 @@</span> <span class="p_context"> static void __init fixup_bus_range(struct device_node *bridge)</span>
 	/* Lookup the &quot;bus-range&quot; property for the hose */
 	prop = of_find_property(bridge, &quot;bus-range&quot;, &amp;len);
 	if (prop == NULL  || prop-&gt;value == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s\n&quot;,</span>
<span class="p_del">-			       bridge-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF\n&quot;,</span>
<span class="p_add">+			       bridge);</span>
 		return;
 	}
 	bus_range = prop-&gt;value;
<span class="p_chunk">@@ -498,12 +498,12 @@</span> <span class="p_context"> static int __init maple_add_bridge(struct device_node *dev)</span>
 	const int *bus_range;
 	int primary = 1;

<span class="p_del">-	DBG(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume bus 0\n&quot;,</span>
<span class="p_del">-		dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume bus 0\n&quot;,</span>
<span class="p_add">+		dev);</span>
 	}

 	hose = pcibios_alloc_controller(dev);
<span class="p_header">diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c</span>
<span class="p_header">index 10c4e8fc6ea9..5ff6108f19e9 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pasemi/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pasemi/pci.c</span>
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> static int __init pas_add_bridge(struct device_node *dev)</span>
 {
 	struct pci_controller *hose;

<span class="p_del">-	pr_debug(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	hose = pcibios_alloc_controller(dev);
 	if (!hose)
<span class="p_header">diff --git a/arch/powerpc/platforms/powermac/feature.c b/arch/powerpc/platforms/powermac/feature.c</span>
<span class="p_header">index 1e02328c3f2d..9e3f39d36e88 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powermac/feature.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powermac/feature.c</span>
<span class="p_chunk">@@ -2658,25 +2658,25 @@</span> <span class="p_context"> static void __init probe_one_macio(const char *name, const char *compat, int typ</span>

 	if (i &gt;= MAX_MACIO_CHIPS) {
 		printk(KERN_ERR &quot;pmac_feature: Please increase MAX_MACIO_CHIPS !\n&quot;);
<span class="p_del">-		printk(KERN_ERR &quot;pmac_feature: %s skipped\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;pmac_feature: %pOF skipped\n&quot;, node);</span>
 		return;
 	}
 	addrp = of_get_pci_address(node, 0, &amp;size, NULL);
 	if (addrp == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;pmac_feature: %s: can&#39;t find base !\n&quot;,</span>
<span class="p_del">-		       node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;pmac_feature: %pOF: can&#39;t find base !\n&quot;,</span>
<span class="p_add">+		       node);</span>
 		return;
 	}
 	addr = of_translate_address(node, addrp);
 	if (addr == 0) {
<span class="p_del">-		printk(KERN_ERR &quot;pmac_feature: %s, can&#39;t translate base !\n&quot;,</span>
<span class="p_del">-		       node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;pmac_feature: %pOF, can&#39;t translate base !\n&quot;,</span>
<span class="p_add">+		       node);</span>
 		return;
 	}
 	base = ioremap(addr, (unsigned long)size);
 	if (!base) {
<span class="p_del">-		printk(KERN_ERR &quot;pmac_feature: %s, can&#39;t map mac-io chip !\n&quot;,</span>
<span class="p_del">-		       node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;pmac_feature: %pOF, can&#39;t map mac-io chip !\n&quot;,</span>
<span class="p_add">+		       node);</span>
 		return;
 	}
 	if (type == macio_keylargo || type == macio_keylargo2) {
<span class="p_header">diff --git a/arch/powerpc/platforms/powermac/low_i2c.c b/arch/powerpc/platforms/powermac/low_i2c.c</span>
<span class="p_header">index f627c9fd7b48..70183eb3d5c8 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powermac/low_i2c.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powermac/low_i2c.c</span>
<span class="p_chunk">@@ -494,8 +494,8 @@</span> <span class="p_context"> static struct pmac_i2c_host_kw *__init kw_i2c_host_init(struct device_node *np)</span>

 	host = kzalloc(sizeof(struct pmac_i2c_host_kw), GFP_KERNEL);
 	if (host == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;low_i2c: Can&#39;t allocate host for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;low_i2c: Can&#39;t allocate host for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		return NULL;
 	}

<span class="p_chunk">@@ -505,8 +505,8 @@</span> <span class="p_context"> static struct pmac_i2c_host_kw *__init kw_i2c_host_init(struct device_node *np)</span>
 	 */
 	addrp = of_get_property(np, &quot;AAPL,address&quot;, NULL);
 	if (addrp == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;low_i2c: Can&#39;t find address for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;low_i2c: Can&#39;t find address for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		kfree(host);
 		return NULL;
 	}
<span class="p_chunk">@@ -538,13 +538,13 @@</span> <span class="p_context"> static struct pmac_i2c_host_kw *__init kw_i2c_host_init(struct device_node *np)</span>
 	host-&gt;irq = irq_of_parse_and_map(np, 0);
 	if (!host-&gt;irq)
 		printk(KERN_WARNING
<span class="p_del">-		       &quot;low_i2c: Failed to map interrupt for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		       &quot;low_i2c: Failed to map interrupt for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>

 	host-&gt;base = ioremap((*addrp), 0x1000);
 	if (host-&gt;base == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;low_i2c: Can&#39;t map registers for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;low_i2c: Can&#39;t map registers for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		kfree(host);
 		return NULL;
 	}
<span class="p_chunk">@@ -560,8 +560,8 @@</span> <span class="p_context"> static struct pmac_i2c_host_kw *__init kw_i2c_host_init(struct device_node *np)</span>
 			&quot;keywest i2c&quot;, host))
 		host-&gt;irq = 0;

<span class="p_del">-	printk(KERN_INFO &quot;KeyWest i2c @0x%08x irq %d %s\n&quot;,</span>
<span class="p_del">-	       *addrp, host-&gt;irq, np-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_INFO &quot;KeyWest i2c @0x%08x irq %d %pOF\n&quot;,</span>
<span class="p_add">+	       *addrp, host-&gt;irq, np);</span>

 	return host;
 }
<span class="p_chunk">@@ -798,7 +798,7 @@</span> <span class="p_context"> static void __init pmu_i2c_probe(void)</span>
 	if (busnode == NULL)
 		return;

<span class="p_del">-	printk(KERN_INFO &quot;PMU i2c %s\n&quot;, busnode-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_INFO &quot;PMU i2c %pOF\n&quot;, busnode);</span>

 	/*
 	 * We add bus 1 and 2 only for now, bus 0 is &quot;special&quot;
<span class="p_chunk">@@ -913,7 +913,7 @@</span> <span class="p_context"> static void __init smu_i2c_probe(void)</span>
 	if (controller == NULL)
 		return;

<span class="p_del">-	printk(KERN_INFO &quot;SMU i2c %s\n&quot;, controller-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_INFO &quot;SMU i2c %pOF\n&quot;, controller);</span>

 	/* Look for childs, note that they might not be of the right
 	 * type as older device trees mix i2c busses and other things
<span class="p_chunk">@@ -945,8 +945,8 @@</span> <span class="p_context"> static void __init smu_i2c_probe(void)</span>
 		bus-&gt;flags = 0;
 		list_add(&amp;bus-&gt;link, &amp;pmac_i2c_busses);

<span class="p_del">-		printk(KERN_INFO &quot; channel %x bus %s\n&quot;,</span>
<span class="p_del">-		       bus-&gt;channel, busnode-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_INFO &quot; channel %x bus %pOF\n&quot;,</span>
<span class="p_add">+		       bus-&gt;channel, busnode);</span>
 	}
 }

<span class="p_chunk">@@ -1129,7 +1129,7 @@</span> <span class="p_context"> int pmac_i2c_setmode(struct pmac_i2c_bus *bus, int mode)</span>
 	 */
 	if (mode &lt; pmac_i2c_mode_dumb || mode &gt; pmac_i2c_mode_combined) {
 		printk(KERN_ERR &quot;low_i2c: Invalid mode %d requested on&quot;
<span class="p_del">-		       &quot; bus %s !\n&quot;, mode, bus-&gt;busnode-&gt;full_name);</span>
<span class="p_add">+		       &quot; bus %pOF !\n&quot;, mode, bus-&gt;busnode);</span>
 		return -EINVAL;
 	}
 	bus-&gt;mode = mode;
<span class="p_chunk">@@ -1146,8 +1146,8 @@</span> <span class="p_context"> int pmac_i2c_xfer(struct pmac_i2c_bus *bus, u8 addrdir, int subsize,</span>
 	WARN_ON(!bus-&gt;opened);

 	DBG(&quot;xfer() chan=%d, addrdir=0x%x, mode=%d, subsize=%d, subaddr=0x%x,&quot;
<span class="p_del">-	    &quot; %d bytes, bus %s\n&quot;, bus-&gt;channel, addrdir, bus-&gt;mode, subsize,</span>
<span class="p_del">-	    subaddr, len, bus-&gt;busnode-&gt;full_name);</span>
<span class="p_add">+	    &quot; %d bytes, bus %pOF\n&quot;, bus-&gt;channel, addrdir, bus-&gt;mode, subsize,</span>
<span class="p_add">+	    subaddr, len, bus-&gt;busnode);</span>

 	rc = bus-&gt;xfer(bus, addrdir, subsize, subaddr, data, len);

<span class="p_chunk">@@ -1241,13 +1241,13 @@</span> <span class="p_context"> static void* pmac_i2c_do_begin(struct pmf_function *func, struct pmf_args *args)</span>

 	bus = pmac_i2c_find_bus(func-&gt;node);
 	if (bus == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;low_i2c: Can&#39;t find bus for %s (pfunc)\n&quot;,</span>
<span class="p_del">-		       func-&gt;node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;low_i2c: Can&#39;t find bus for %pOF (pfunc)\n&quot;,</span>
<span class="p_add">+		       func-&gt;node);</span>
 		return NULL;
 	}
 	if (pmac_i2c_open(bus, 0)) {
<span class="p_del">-		printk(KERN_ERR &quot;low_i2c: Can&#39;t open i2c bus for %s (pfunc)\n&quot;,</span>
<span class="p_del">-		       func-&gt;node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;low_i2c: Can&#39;t open i2c bus for %pOF (pfunc)\n&quot;,</span>
<span class="p_add">+		       func-&gt;node);</span>
 		return NULL;
 	}

<span class="p_chunk">@@ -1417,7 +1417,7 @@</span> <span class="p_context"> static struct pmf_handlers pmac_i2c_pfunc_handlers = {</span>

 static void __init pmac_i2c_dev_create(struct device_node *np, int quirks)
 {
<span class="p_del">-	DBG(&quot;dev_create(%s)\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;dev_create(%pOF)\n&quot;, np);</span>

 	pmf_register_driver(np, &amp;pmac_i2c_pfunc_handlers,
 			    (void *)(long)quirks);
<span class="p_chunk">@@ -1425,20 +1425,20 @@</span> <span class="p_context"> static void __init pmac_i2c_dev_create(struct device_node *np, int quirks)</span>

 static void __init pmac_i2c_dev_init(struct device_node *np, int quirks)
 {
<span class="p_del">-	DBG(&quot;dev_create(%s)\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;dev_create(%pOF)\n&quot;, np);</span>

 	pmf_do_functions(np, NULL, 0, PMF_FLAGS_ON_INIT, NULL);
 }

 static void pmac_i2c_dev_suspend(struct device_node *np, int quirks)
 {
<span class="p_del">-	DBG(&quot;dev_suspend(%s)\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;dev_suspend(%pOF)\n&quot;, np);</span>
 	pmf_do_functions(np, NULL, 0, PMF_FLAGS_ON_SLEEP, NULL);
 }

 static void pmac_i2c_dev_resume(struct device_node *np, int quirks)
 {
<span class="p_del">-	DBG(&quot;dev_resume(%s)\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;dev_resume(%pOF)\n&quot;, np);</span>
 	pmf_do_functions(np, NULL, 0, PMF_FLAGS_ON_WAKE, NULL);
 }

<span class="p_header">diff --git a/arch/powerpc/platforms/powermac/pci.c b/arch/powerpc/platforms/powermac/pci.c</span>
<span class="p_header">index 6e06c3be2e9a..0b8174a79993 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powermac/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powermac/pci.c</span>
<span class="p_chunk">@@ -783,7 +783,7 @@</span> <span class="p_context"> static int __init pmac_add_bridge(struct device_node *dev)</span>
 	const int *bus_range;
 	int primary = 1, has_address = 0;

<span class="p_del">-	DBG(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	/* Fetch host bridge registers address */
 	has_address = (of_address_to_resource(dev, 0, &amp;rsrc) == 0);
<span class="p_chunk">@@ -791,8 +791,8 @@</span> <span class="p_context"> static int __init pmac_add_bridge(struct device_node *dev)</span>
 	/* Get bus range if any */
 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume&quot;</span>
<span class="p_del">-		       &quot; bus 0\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume&quot;</span>
<span class="p_add">+		       &quot; bus 0\n&quot;, dev);</span>
 	}

 	hose = pcibios_alloc_controller(dev);
<span class="p_header">diff --git a/arch/powerpc/platforms/powermac/pfunc_base.c b/arch/powerpc/platforms/powermac/pfunc_base.c</span>
<span class="p_header">index 459138ed4571..860159d46ab8 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powermac/pfunc_base.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powermac/pfunc_base.c</span>
<span class="p_chunk">@@ -54,8 +54,8 @@</span> <span class="p_context"> static int macio_do_gpio_write(PMF_STD_ARGS, u8 value, u8 mask)</span>
 	raw_spin_lock_irqsave(&amp;feature_lock, flags);
 	tmp = readb(addr);
 	tmp = (tmp &amp; ~mask) | (value &amp; mask);
<span class="p_del">-	DBG(&quot;Do write 0x%02x to GPIO %s (%p)\n&quot;,</span>
<span class="p_del">-	    tmp, func-&gt;node-&gt;full_name, addr);</span>
<span class="p_add">+	DBG(&quot;Do write 0x%02x to GPIO %pOF (%p)\n&quot;,</span>
<span class="p_add">+	    tmp, func-&gt;node, addr);</span>
 	writeb(tmp, addr);
 	raw_spin_unlock_irqrestore(&amp;feature_lock, flags);

<span class="p_chunk">@@ -107,8 +107,8 @@</span> <span class="p_context"> static void macio_gpio_init_one(struct macio_chip *macio)</span>
 	if (gparent == NULL)
 		return;

<span class="p_del">-	DBG(&quot;Installing GPIO functions for macio %s\n&quot;,</span>
<span class="p_del">-	    macio-&gt;of_node-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;Installing GPIO functions for macio %pOF\n&quot;,</span>
<span class="p_add">+	    macio-&gt;of_node);</span>

 	/*
 	 * Ok, got one, we dont need anything special to track them down, so
<span class="p_chunk">@@ -129,8 +129,8 @@</span> <span class="p_context"> static void macio_gpio_init_one(struct macio_chip *macio)</span>
 		pmf_register_driver(gp, &amp;macio_gpio_handlers, (void *)offset);
 	}

<span class="p_del">-	DBG(&quot;Calling initial GPIO functions for macio %s\n&quot;,</span>
<span class="p_del">-	    macio-&gt;of_node-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;Calling initial GPIO functions for macio %pOF\n&quot;,</span>
<span class="p_add">+	    macio-&gt;of_node);</span>

 	/* And now we run all the init ones */
 	for (gp = NULL; (gp = of_get_next_child(gparent, gp)) != NULL;)
<span class="p_chunk">@@ -267,8 +267,8 @@</span> <span class="p_context"> static struct pmf_handlers macio_mmio_handlers = {</span>

 static void macio_mmio_init_one(struct macio_chip *macio)
 {
<span class="p_del">-	DBG(&quot;Installing MMIO functions for macio %s\n&quot;,</span>
<span class="p_del">-	    macio-&gt;of_node-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;Installing MMIO functions for macio %pOF\n&quot;,</span>
<span class="p_add">+	    macio-&gt;of_node);</span>

 	pmf_register_driver(macio-&gt;of_node, &amp;macio_mmio_handlers, macio);
 }
<span class="p_chunk">@@ -298,8 +298,8 @@</span> <span class="p_context"> static void uninorth_install_pfunc(void)</span>
 {
 	struct device_node *np;

<span class="p_del">-	DBG(&quot;Installing functions for UniN %s\n&quot;,</span>
<span class="p_del">-	    uninorth_node-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;Installing functions for UniN %pOF\n&quot;,</span>
<span class="p_add">+	    uninorth_node);</span>

 	/*
 	 * Install handlers for the bridge itself
<span class="p_chunk">@@ -317,8 +317,8 @@</span> <span class="p_context"> static void uninorth_install_pfunc(void)</span>
 			break;
 		}
 	if (unin_hwclock) {
<span class="p_del">-		DBG(&quot;Installing functions for UniN clock %s\n&quot;,</span>
<span class="p_del">-		    unin_hwclock-&gt;full_name);</span>
<span class="p_add">+		DBG(&quot;Installing functions for UniN clock %pOF\n&quot;,</span>
<span class="p_add">+		    unin_hwclock);</span>
 		pmf_register_driver(unin_hwclock, &amp;unin_mmio_handlers, NULL);
 		pmf_do_functions(unin_hwclock, NULL, 0, PMF_FLAGS_ON_INIT,
 				 NULL);
<span class="p_header">diff --git a/arch/powerpc/platforms/powermac/pfunc_core.c b/arch/powerpc/platforms/powermac/pfunc_core.c</span>
<span class="p_header">index 695e8c4d4224..df3c93bef228 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powermac/pfunc_core.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powermac/pfunc_core.c</span>
<span class="p_chunk">@@ -708,7 +708,7 @@</span> <span class="p_context"> int pmf_register_driver(struct device_node *np,</span>
 	if (handlers == NULL)
 		return -EINVAL;

<span class="p_del">-	DBG(&quot;pmf: registering driver for node %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;pmf: registering driver for node %pOF\n&quot;, np);</span>

 	spin_lock_irqsave(&amp;pmf_lock, flags);
 	dev = pmf_find_device(np);
<span class="p_chunk">@@ -781,7 +781,7 @@</span> <span class="p_context"> void pmf_unregister_driver(struct device_node *np)</span>
 	struct pmf_device *dev;
 	unsigned long flags;

<span class="p_del">-	DBG(&quot;pmf: unregistering driver for node %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	DBG(&quot;pmf: unregistering driver for node %pOF\n&quot;, np);</span>

 	spin_lock_irqsave(&amp;pmf_lock, flags);
 	dev = pmf_find_device(np);
<span class="p_chunk">@@ -940,7 +940,7 @@</span> <span class="p_context"> int pmf_call_one(struct pmf_function *func, struct pmf_args *args)</span>
 	void *instdata = NULL;
 	int rc = 0;

<span class="p_del">-	DBG(&quot; ** pmf_call_one(%s/%s) **\n&quot;, dev-&gt;node-&gt;full_name, func-&gt;name);</span>
<span class="p_add">+	DBG(&quot; ** pmf_call_one(%pOF/%s) **\n&quot;, dev-&gt;node, func-&gt;name);</span>

 	if (dev-&gt;handlers-&gt;begin)
 		instdata = dev-&gt;handlers-&gt;begin(func, args);
<span class="p_header">diff --git a/arch/powerpc/platforms/powermac/pic.c b/arch/powerpc/platforms/powermac/pic.c</span>
<span class="p_header">index f5f9ad7c3398..5e0719b27294 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powermac/pic.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powermac/pic.c</span>
<span class="p_chunk">@@ -364,8 +364,8 @@</span> <span class="p_context"> static void __init pmac_pic_probe_oldstyle(void)</span>
 			(addr + 0x10);
 	of_node_put(master);

<span class="p_del">-	printk(KERN_INFO &quot;irq: Found primary Apple PIC %s for %d irqs\n&quot;,</span>
<span class="p_del">-	       master-&gt;full_name, max_real_irqs);</span>
<span class="p_add">+	printk(KERN_INFO &quot;irq: Found primary Apple PIC %pOF for %d irqs\n&quot;,</span>
<span class="p_add">+	       master, max_real_irqs);</span>

 	/* Map interrupts of cascaded controller */
 	if (slave &amp;&amp; !of_address_to_resource(slave, 0, &amp;r)) {
<span class="p_chunk">@@ -378,8 +378,8 @@</span> <span class="p_context"> static void __init pmac_pic_probe_oldstyle(void)</span>
 				(addr + 0x10);
 		pmac_irq_cascade = irq_of_parse_and_map(slave, 0);

<span class="p_del">-		printk(KERN_INFO &quot;irq: Found slave Apple PIC %s for %d irqs&quot;</span>
<span class="p_del">-		       &quot; cascade: %d\n&quot;, slave-&gt;full_name,</span>
<span class="p_add">+		printk(KERN_INFO &quot;irq: Found slave Apple PIC %pOF for %d irqs&quot;</span>
<span class="p_add">+		       &quot; cascade: %d\n&quot;, slave,</span>
 		       max_irqs - max_real_irqs, pmac_irq_cascade);
 	}
 	of_node_put(slave);
<span class="p_header">diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c</span>
<span class="p_header">index 6b4e9d181126..ab668cb72263 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powermac/setup.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powermac/setup.c</span>
<span class="p_chunk">@@ -556,7 +556,7 @@</span> <span class="p_context"> static int __init check_pmac_serial_console(void)</span>
 		pr_debug(&quot; can&#39;t find stdout package %s !\n&quot;, name);
 		return -ENODEV;
 	}
<span class="p_del">-	pr_debug(&quot;stdout is %s\n&quot;, prom_stdout-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;stdout is %pOF\n&quot;, prom_stdout);</span>

 	name = of_get_property(prom_stdout, &quot;name&quot;, NULL);
 	if (!name) {
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-async.c b/arch/powerpc/platforms/powernv/opal-async.c</span>
<span class="p_header">index 83bebeec0fea..cf33769a7b72 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-async.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-async.c</span>
<span class="p_chunk">@@ -171,8 +171,8 @@</span> <span class="p_context"> int __init opal_async_comp_init(void)</span>

 	async = of_get_property(opal_node, &quot;opal-msg-async-num&quot;, NULL);
 	if (!async) {
<span class="p_del">-		pr_err(&quot;%s: %s has no opal-msg-async-num\n&quot;,</span>
<span class="p_del">-				__func__, opal_node-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%s: %pOF has no opal-msg-async-num\n&quot;,</span>
<span class="p_add">+				__func__, opal_node);</span>
 		err = -ENOENT;
 		goto out_opal_node;
 	}
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/opal-xscom.c b/arch/powerpc/platforms/powernv/opal-xscom.c</span>
<span class="p_header">index 28651fb25417..81c0a943dea9 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/opal-xscom.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/opal-xscom.c</span>
<span class="p_chunk">@@ -36,14 +36,14 @@</span> <span class="p_context"> static scom_map_t opal_scom_map(struct device_node *dev, u64 reg, u64 count)</span>
 	const __be32 *gcid;

 	if (!of_get_property(dev, &quot;scom-controller&quot;, NULL)) {
<span class="p_del">-		pr_err(&quot;%s: device %s is not a SCOM controller\n&quot;,</span>
<span class="p_del">-			__func__, dev-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%s: device %pOF is not a SCOM controller\n&quot;,</span>
<span class="p_add">+			__func__, dev);</span>
 		return SCOM_MAP_INVALID;
 	}
 	gcid = of_get_property(dev, &quot;ibm,chip-id&quot;, NULL);
 	if (!gcid) {
<span class="p_del">-		pr_err(&quot;%s: device %s has no ibm,chip-id\n&quot;,</span>
<span class="p_del">-			__func__, dev-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%s: device %pOF has no ibm,chip-id\n&quot;,</span>
<span class="p_add">+			__func__, dev);</span>
 		return SCOM_MAP_INVALID;
 	}
 	m = kmalloc(sizeof(struct opal_scom_map), GFP_KERNEL);
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index 437613588df1..aaa730ff28bc 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -444,8 +444,8 @@</span> <span class="p_context"> static void __init pnv_ioda_parse_m64_window(struct pnv_phb *phb)</span>

 	r = of_get_property(dn, &quot;ibm,opal-m64-window&quot;, NULL);
 	if (!r) {
<span class="p_del">-		pr_info(&quot;  No &lt;ibm,opal-m64-window&gt; on %s\n&quot;,</span>
<span class="p_del">-			dn-&gt;full_name);</span>
<span class="p_add">+		pr_info(&quot;  No &lt;ibm,opal-m64-window&gt; on %pOF\n&quot;,</span>
<span class="p_add">+			dn);</span>
 		return;
 	}

<span class="p_chunk">@@ -3789,8 +3789,7 @@</span> <span class="p_context"> static void __init pnv_pci_init_ioda_phb(struct device_node *np,</span>
 	if (!of_device_is_available(np))
 		return;

<span class="p_del">-	pr_info(&quot;Initializing %s PHB (%s)\n&quot;,</span>
<span class="p_del">-		pnv_phb_names[ioda_type], of_node_full_name(np));</span>
<span class="p_add">+	pr_info(&quot;Initializing %s PHB (%pOF)\n&quot;,	pnv_phb_names[ioda_type], np);</span>

 	prop64 = of_get_property(np, &quot;ibm,opal-phbid&quot;, NULL);
 	if (!prop64) {
<span class="p_chunk">@@ -3805,8 +3804,8 @@</span> <span class="p_context"> static void __init pnv_pci_init_ioda_phb(struct device_node *np,</span>
 	/* Allocate PCI controller */
 	phb-&gt;hose = hose = pcibios_alloc_controller(np);
 	if (!phb-&gt;hose) {
<span class="p_del">-		pr_err(&quot;  Can&#39;t allocate PCI controller for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;  Can&#39;t allocate PCI controller for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		memblock_free(__pa(phb), sizeof(struct pnv_phb));
 		return;
 	}
<span class="p_chunk">@@ -3817,7 +3816,7 @@</span> <span class="p_context"> static void __init pnv_pci_init_ioda_phb(struct device_node *np,</span>
 		hose-&gt;first_busno = be32_to_cpu(prop32[0]);
 		hose-&gt;last_busno = be32_to_cpu(prop32[1]);
 	} else {
<span class="p_del">-		pr_warn(&quot;  Broken &lt;bus-range&gt; on %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;  Broken &lt;bus-range&gt; on %pOF\n&quot;, np);</span>
 		hose-&gt;first_busno = 0;
 		hose-&gt;last_busno = 0xff;
 	}
<span class="p_chunk">@@ -4038,7 +4037,7 @@</span> <span class="p_context"> void __init pnv_pci_init_ioda_hub(struct device_node *np)</span>
 	const __be64 *prop64;
 	u64 hub_id;

<span class="p_del">-	pr_info(&quot;Probing IODA IO-Hub %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	pr_info(&quot;Probing IODA IO-Hub %pOF\n&quot;, np);</span>

 	prop64 = of_get_property(np, &quot;ibm,opal-hubid&quot;, NULL);
 	if (!prop64) {
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/rng.c b/arch/powerpc/platforms/powernv/rng.c</span>
<span class="p_header">index 1a9d84371a4d..ee91433127bc 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/rng.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/rng.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> static __init void rng_init_per_cpu(struct powernv_rng *rng,</span>

 	chip_id = of_get_ibm_chip_id(dn);
 	if (chip_id == -1)
<span class="p_del">-		pr_warn(&quot;No ibm,chip-id found for %s.\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+		pr_warn(&quot;No ibm,chip-id found for %pOF.\n&quot;, dn);</span>

 	for_each_possible_cpu(cpu) {
 		if (per_cpu(powernv_rng, cpu) == NULL ||
<span class="p_chunk">@@ -141,8 +141,8 @@</span> <span class="p_context"> static __init int rng_init(void)</span>
 	for_each_compatible_node(dn, NULL, &quot;ibm,power-rng&quot;) {
 		rc = rng_create(dn);
 		if (rc) {
<span class="p_del">-			pr_err(&quot;Failed creating rng for %s (%d).\n&quot;,</span>
<span class="p_del">-				dn-&gt;full_name, rc);</span>
<span class="p_add">+			pr_err(&quot;Failed creating rng for %pOF (%d).\n&quot;,</span>
<span class="p_add">+				dn, rc);</span>
 			continue;
 		}

<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index 39187696ee74..80b84c9c8509 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -264,8 +264,7 @@</span> <span class="p_context"> int dlpar_attach_node(struct device_node *dn)</span>

 	rc = of_attach_node(dn);
 	if (rc) {
<span class="p_del">-		printk(KERN_ERR &quot;Failed to add device node %s\n&quot;,</span>
<span class="p_del">-		       dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;Failed to add device node %pOF\n&quot;, dn);</span>
 		return rc;
 	}

<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/event_sources.c b/arch/powerpc/platforms/pseries/event_sources.c</span>
<span class="p_header">index 32187dc76730..6eeb0d4bab61 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/event_sources.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/event_sources.c</span>
<span class="p_chunk">@@ -36,8 +36,8 @@</span> <span class="p_context"> void request_event_sources_irqs(struct device_node *np,</span>
 		virqs[count] = irq_create_of_mapping(&amp;oirq);
 		if (!virqs[count]) {
 			pr_err(&quot;event-sources: Unable to allocate &quot;
<span class="p_del">-			       &quot;interrupt number for %s\n&quot;,</span>
<span class="p_del">-			       np-&gt;full_name);</span>
<span class="p_add">+			       &quot;interrupt number for %pOF\n&quot;,</span>
<span class="p_add">+			       np);</span>
 			WARN_ON(1);
 		} else {
 			count++;
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> void request_event_sources_irqs(struct device_node *np,</span>
 	for (i = 0; i &lt; count; i++) {
 		if (request_irq(virqs[i], handler, 0, name, NULL)) {
 			pr_err(&quot;event-sources: Unable to request interrupt &quot;
<span class="p_del">-			       &quot;%d for %s\n&quot;, virqs[i], np-&gt;full_name);</span>
<span class="p_add">+			       &quot;%d for %pOF\n&quot;, virqs[i], np);</span>
 			WARN_ON(1);
 			return;
 		}
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/hotplug-cpu.c b/arch/powerpc/platforms/pseries/hotplug-cpu.c</span>
<span class="p_header">index 6afd1efd3633..0a93093fbcef 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/hotplug-cpu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/hotplug-cpu.c</span>
<span class="p_chunk">@@ -264,8 +264,8 @@</span> <span class="p_context"> static int pseries_add_processor(struct device_node *np)</span>
 		/* If we get here, it most likely means that NR_CPUS is
 		 * less than the partition&#39;s max processors setting.
 		 */
<span class="p_del">-		printk(KERN_ERR &quot;Cannot add cpu %s; this system configuration&quot;</span>
<span class="p_del">-		       &quot; supports %d logical cpus.\n&quot;, np-&gt;full_name,</span>
<span class="p_add">+		printk(KERN_ERR &quot;Cannot add cpu %pOF; this system configuration&quot;</span>
<span class="p_add">+		       &quot; supports %d logical cpus.\n&quot;, np,</span>
 		       num_possible_cpus());
 		goto out_unlock;
 	}
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/ibmebus.c b/arch/powerpc/platforms/pseries/ibmebus.c</span>
<span class="p_header">index 52146b1356d2..408a86044133 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/ibmebus.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/ibmebus.c</span>
<span class="p_chunk">@@ -150,8 +150,7 @@</span> <span class="p_context"> static const struct dma_map_ops ibmebus_dma_ops = {</span>
 static int ibmebus_match_path(struct device *dev, void *data)
 {
 	struct device_node *dn = to_platform_device(dev)-&gt;dev.of_node;
<span class="p_del">-	return (dn-&gt;full_name &amp;&amp;</span>
<span class="p_del">-		(strcasecmp((char *)data, dn-&gt;full_name) == 0));</span>
<span class="p_add">+	return (of_find_node_by_path(data) == dn);</span>
 }

 static int ibmebus_match_node(struct device *dev, void *data)
<span class="p_chunk">@@ -395,7 +394,7 @@</span> <span class="p_context"> static ssize_t devspec_show(struct device *dev,</span>
 	struct platform_device *ofdev;

 	ofdev = to_platform_device(dev);
<span class="p_del">-	return sprintf(buf, &quot;%s\n&quot;, ofdev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+	return sprintf(buf, &quot;%pOF\n&quot;, ofdev-&gt;dev.of_node);</span>
 }
 static DEVICE_ATTR_RO(devspec);

<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/iommu.c b/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_header">index 8374adee27e3..7c181467d0ad 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/iommu.c</span>
<span class="p_chunk">@@ -511,8 +511,8 @@</span> <span class="p_context"> static void iommu_table_setparms(struct pci_controller *phb,</span>
 	basep = of_get_property(node, &quot;linux,tce-base&quot;, NULL);
 	sizep = of_get_property(node, &quot;linux,tce-size&quot;, NULL);
 	if (basep == NULL || sizep == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;PCI_DMA: iommu_table_setparms: %s has &quot;</span>
<span class="p_del">-				&quot;missing tce entries !\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;PCI_DMA: iommu_table_setparms: %pOF has &quot;</span>
<span class="p_add">+				&quot;missing tce entries !\n&quot;, dn);</span>
 		return;
 	}

<span class="p_chunk">@@ -587,7 +587,7 @@</span> <span class="p_context"> static void pci_dma_bus_setup_pSeries(struct pci_bus *bus)</span>

 	dn = pci_bus_to_OF_node(bus);

<span class="p_del">-	pr_debug(&quot;pci_dma_bus_setup_pSeries: setting up bus %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;pci_dma_bus_setup_pSeries: setting up bus %pOF\n&quot;, dn);</span>

 	if (bus-&gt;self) {
 		/* This is not a root bus, any setup will be done for the
<span class="p_chunk">@@ -701,8 +701,8 @@</span> <span class="p_context"> static void pci_dma_bus_setup_pSeriesLP(struct pci_bus *bus)</span>

 	dn = pci_bus_to_OF_node(bus);

<span class="p_del">-	pr_debug(&quot;pci_dma_bus_setup_pSeriesLP: setting up bus %s\n&quot;,</span>
<span class="p_del">-		 dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;pci_dma_bus_setup_pSeriesLP: setting up bus %pOF\n&quot;,</span>
<span class="p_add">+		 dn);</span>

 	/* Find nearest ibm,dma-window, walking up the device tree */
 	for (pdn = dn; pdn != NULL; pdn = pdn-&gt;parent) {
<span class="p_chunk">@@ -718,8 +718,8 @@</span> <span class="p_context"> static void pci_dma_bus_setup_pSeriesLP(struct pci_bus *bus)</span>

 	ppci = PCI_DN(pdn);

<span class="p_del">-	pr_debug(&quot;  parent is %s, iommu_table: 0x%p\n&quot;,</span>
<span class="p_del">-		 pdn-&gt;full_name, ppci-&gt;table_group);</span>
<span class="p_add">+	pr_debug(&quot;  parent is %pOF, iommu_table: 0x%p\n&quot;,</span>
<span class="p_add">+		 pdn, ppci-&gt;table_group);</span>

 	if (!ppci-&gt;table_group) {
 		ppci-&gt;table_group = iommu_pseries_alloc_group(ppci-&gt;phb-&gt;node);
<span class="p_chunk">@@ -817,28 +817,28 @@</span> <span class="p_context"> static void remove_ddw(struct device_node *np, bool remove_prop)</span>
 	ret = tce_clearrange_multi_pSeriesLP(0,
 		1ULL &lt;&lt; (be32_to_cpu(dwp-&gt;window_shift) - PAGE_SHIFT), dwp);
 	if (ret)
<span class="p_del">-		pr_warning(&quot;%s failed to clear tces in window.\n&quot;,</span>
<span class="p_del">-			 np-&gt;full_name);</span>
<span class="p_add">+		pr_warning(&quot;%pOF failed to clear tces in window.\n&quot;,</span>
<span class="p_add">+			 np);</span>
 	else
<span class="p_del">-		pr_debug(&quot;%s successfully cleared tces in window.\n&quot;,</span>
<span class="p_del">-			 np-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;%pOF successfully cleared tces in window.\n&quot;,</span>
<span class="p_add">+			 np);</span>

 	ret = rtas_call(ddw_avail[2], 1, 1, NULL, liobn);
 	if (ret)
<span class="p_del">-		pr_warning(&quot;%s: failed to remove direct window: rtas returned &quot;</span>
<span class="p_add">+		pr_warning(&quot;%pOF: failed to remove direct window: rtas returned &quot;</span>
 			&quot;%d to ibm,remove-pe-dma-window(%x) %llx\n&quot;,
<span class="p_del">-			np-&gt;full_name, ret, ddw_avail[2], liobn);</span>
<span class="p_add">+			np, ret, ddw_avail[2], liobn);</span>
 	else
<span class="p_del">-		pr_debug(&quot;%s: successfully removed direct window: rtas returned &quot;</span>
<span class="p_add">+		pr_debug(&quot;%pOF: successfully removed direct window: rtas returned &quot;</span>
 			&quot;%d to ibm,remove-pe-dma-window(%x) %llx\n&quot;,
<span class="p_del">-			np-&gt;full_name, ret, ddw_avail[2], liobn);</span>
<span class="p_add">+			np, ret, ddw_avail[2], liobn);</span>

 delprop:
 	if (remove_prop)
 		ret = of_remove_property(np, win64);
 	if (ret)
<span class="p_del">-		pr_warning(&quot;%s: failed to remove direct window property: %d\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name, ret);</span>
<span class="p_add">+		pr_warning(&quot;%pOF: failed to remove direct window property: %d\n&quot;,</span>
<span class="p_add">+			np, ret);</span>
 }

 static u64 find_existing_ddw(struct device_node *pdn)
<span class="p_chunk">@@ -1004,7 +1004,7 @@</span> <span class="p_context"> static u64 enable_ddw(struct pci_dev *dev, struct device_node *pdn)</span>
 	 * list.
 	 */
 	list_for_each_entry(fpdn, &amp;failed_ddw_pdn_list, list) {
<span class="p_del">-		if (!strcmp(fpdn-&gt;pdn-&gt;full_name, pdn-&gt;full_name))</span>
<span class="p_add">+		if (fpdn-&gt;pdn == pdn)</span>
 			goto out_unlock;
 	}

<span class="p_chunk">@@ -1087,8 +1087,8 @@</span> <span class="p_context"> static u64 enable_ddw(struct pci_dev *dev, struct device_node *pdn)</span>
 	ddwprop-&gt;tce_shift = cpu_to_be32(page_shift);
 	ddwprop-&gt;window_shift = cpu_to_be32(len);

<span class="p_del">-	dev_dbg(&amp;dev-&gt;dev, &quot;created tce table LIOBN 0x%x for %s\n&quot;,</span>
<span class="p_del">-		  create.liobn, dn-&gt;full_name);</span>
<span class="p_add">+	dev_dbg(&amp;dev-&gt;dev, &quot;created tce table LIOBN 0x%x for %pOF\n&quot;,</span>
<span class="p_add">+		  create.liobn, dn);</span>

 	window = kzalloc(sizeof(*window), GFP_KERNEL);
 	if (!window)
<span class="p_chunk">@@ -1097,15 +1097,15 @@</span> <span class="p_context"> static u64 enable_ddw(struct pci_dev *dev, struct device_node *pdn)</span>
 	ret = walk_system_ram_range(0, memblock_end_of_DRAM() &gt;&gt; PAGE_SHIFT,
 			win64-&gt;value, tce_setrange_multi_pSeriesLP_walk);
 	if (ret) {
<span class="p_del">-		dev_info(&amp;dev-&gt;dev, &quot;failed to map direct window for %s: %d\n&quot;,</span>
<span class="p_del">-			 dn-&gt;full_name, ret);</span>
<span class="p_add">+		dev_info(&amp;dev-&gt;dev, &quot;failed to map direct window for %pOF: %d\n&quot;,</span>
<span class="p_add">+			 dn, ret);</span>
 		goto out_free_window;
 	}

 	ret = of_add_property(pdn, win64);
 	if (ret) {
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;unable to add dma window property for %s: %d&quot;,</span>
<span class="p_del">-			 pdn-&gt;full_name, ret);</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;unable to add dma window property for %pOF: %d&quot;,</span>
<span class="p_add">+			 pdn, ret);</span>
 		goto out_free_window;
 	}

<span class="p_chunk">@@ -1158,7 +1158,7 @@</span> <span class="p_context"> static void pci_dma_dev_setup_pSeriesLP(struct pci_dev *dev)</span>
 	 * already allocated.
 	 */
 	dn = pci_device_to_OF_node(dev);
<span class="p_del">-	pr_debug(&quot;  node is %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;  node is %pOF\n&quot;, dn);</span>

 	for (pdn = dn; pdn &amp;&amp; PCI_DN(pdn) &amp;&amp; !PCI_DN(pdn)-&gt;table_group;
 	     pdn = pdn-&gt;parent) {
<span class="p_chunk">@@ -1169,11 +1169,11 @@</span> <span class="p_context"> static void pci_dma_dev_setup_pSeriesLP(struct pci_dev *dev)</span>

 	if (!pdn || !PCI_DN(pdn)) {
 		printk(KERN_WARNING &quot;pci_dma_dev_setup_pSeriesLP: &quot;
<span class="p_del">-		       &quot;no DMA window found for pci dev=%s dn=%s\n&quot;,</span>
<span class="p_del">-				 pci_name(dev), of_node_full_name(dn));</span>
<span class="p_add">+		       &quot;no DMA window found for pci dev=%s dn=%pOF\n&quot;,</span>
<span class="p_add">+				 pci_name(dev), dn);</span>
 		return;
 	}
<span class="p_del">-	pr_debug(&quot;  parent is %s\n&quot;, pdn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;  parent is %pOF\n&quot;, pdn);</span>

 	pci = PCI_DN(pdn);
 	if (!pci-&gt;table_group) {
<span class="p_chunk">@@ -1213,7 +1213,7 @@</span> <span class="p_context"> static int dma_set_mask_pSeriesLP(struct device *dev, u64 dma_mask)</span>
 	/* only attempt to use a new window if 64-bit DMA is requested */
 	if (!disable_ddw &amp;&amp; dma_mask == DMA_BIT_MASK(64)) {
 		dn = pci_device_to_OF_node(pdev);
<span class="p_del">-		dev_dbg(dev, &quot;node is %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+		dev_dbg(dev, &quot;node is %pOF\n&quot;, dn);</span>

 		/*
 		 * the device tree might contain the dma-window properties
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/msi.c b/arch/powerpc/platforms/pseries/msi.c</span>
<span class="p_header">index 326ef0dd6038..353912e700eb 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/msi.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/msi.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static int check_req(struct pci_dev *pdev, int nvec, char *prop_name)</span>

 	p = of_get_property(dn, prop_name, NULL);
 	if (!p) {
<span class="p_del">-		pr_debug(&quot;rtas_msi: No %s on %s\n&quot;, prop_name, dn-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;rtas_msi: No %s on %pOF\n&quot;, prop_name, dn);</span>
 		return -ENOENT;
 	}

<span class="p_chunk">@@ -182,8 +182,8 @@</span> <span class="p_context"> static struct device_node *find_pe_total_msi(struct pci_dev *dev, int *total)</span>
 	while (dn) {
 		p = of_get_property(dn, &quot;ibm,pe-total-#msi&quot;, NULL);
 		if (p) {
<span class="p_del">-			pr_debug(&quot;rtas_msi: found prop on dn %s\n&quot;,</span>
<span class="p_del">-				dn-&gt;full_name);</span>
<span class="p_add">+			pr_debug(&quot;rtas_msi: found prop on dn %pOF\n&quot;,</span>
<span class="p_add">+				dn);</span>
 			*total = be32_to_cpup(p);
 			return dn;
 		}
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> static struct device_node *find_pe_dn(struct pci_dev *dev, int *total)</span>

 	/* Hardcode of 8 for old firmwares */
 	*total = 8;
<span class="p_del">-	pr_debug(&quot;rtas_msi: using PE dn %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;rtas_msi: using PE dn %pOF\n&quot;, dn);</span>

 	return dn;
 }
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> static void *count_non_bridge_devices(struct device_node *dn, void *data)</span>
 	const __be32 *p;
 	u32 class;

<span class="p_del">-	pr_debug(&quot;rtas_msi: counting %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;rtas_msi: counting %pOF\n&quot;, dn);</span>

 	p = of_get_property(dn, &quot;class-code&quot;, NULL);
 	class = p ? be32_to_cpup(p) : 0;
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> static int msi_quota_for_device(struct pci_dev *dev, int request)</span>
 		goto out;
 	}

<span class="p_del">-	pr_debug(&quot;rtas_msi: found PE %s\n&quot;, pe_dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;rtas_msi: found PE %pOF\n&quot;, pe_dn);</span>

 	memset(&amp;counts, 0, sizeof(struct msi_counts));

<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/pci_dlpar.c b/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_header">index 547fd13e4f8e..561917fa54a8 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> struct pci_controller *init_phb_dynamic(struct device_node *dn)</span>
 {
 	struct pci_controller *phb;

<span class="p_del">-	pr_debug(&quot;PCI: Initializing new hotplug PHB %s\n&quot;, dn-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;PCI: Initializing new hotplug PHB %pOF\n&quot;, dn);</span>

 	phb = pcibios_alloc_controller(dn);
 	if (!phb)
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/vio.c b/arch/powerpc/platforms/pseries/vio.c</span>
<span class="p_header">index 8a47f168476b..3201feb6d32b 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/vio.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/vio.c</span>
<span class="p_chunk">@@ -1357,14 +1357,14 @@</span> <span class="p_context"> struct vio_dev *vio_register_device_node(struct device_node *of_node)</span>
 	 */
 	parent_node = of_get_parent(of_node);
 	if (parent_node) {
<span class="p_del">-		if (!strcmp(parent_node-&gt;full_name, &quot;/ibm,platform-facilities&quot;))</span>
<span class="p_add">+		if (!strcmp(parent_node-&gt;full_name, &quot;ibm,platform-facilities&quot;))</span>
 			family = PFO;
<span class="p_del">-		else if (!strcmp(parent_node-&gt;full_name, &quot;/vdevice&quot;))</span>
<span class="p_add">+		else if (!strcmp(parent_node-&gt;full_name, &quot;vdevice&quot;))</span>
 			family = VDEVICE;
 		else {
<span class="p_del">-			pr_warn(&quot;%s: parent(%s) of %s not recognized.\n&quot;,</span>
<span class="p_add">+			pr_warn(&quot;%s: parent(%pOF) of %s not recognized.\n&quot;,</span>
 					__func__,
<span class="p_del">-					parent_node-&gt;full_name,</span>
<span class="p_add">+					parent_node,</span>
 					of_node_name);
 			of_node_put(parent_node);
 			return NULL;
<span class="p_chunk">@@ -1555,7 +1555,7 @@</span> <span class="p_context"> static ssize_t devspec_show(struct device *dev,</span>
 {
 	struct device_node *of_node = dev-&gt;of_node;

<span class="p_del">-	return sprintf(buf, &quot;%s\n&quot;, of_node_full_name(of_node));</span>
<span class="p_add">+	return sprintf(buf, &quot;%pOF\n&quot;, of_node);</span>
 }
 static DEVICE_ATTR_RO(devspec);

<span class="p_chunk">@@ -1685,7 +1685,7 @@</span> <span class="p_context"> struct vio_dev *vio_find_node(struct device_node *vnode)</span>
 	/* construct the kobject name from the device node */
 	if (!strcmp(dev_type, &quot;vdevice&quot;)) {
 		const __be32 *prop;
<span class="p_del">-</span>
<span class="p_add">+</span>
 		prop = of_get_property(vnode, &quot;reg&quot;, NULL);
 		if (!prop)
 			return NULL;
<span class="p_header">diff --git a/arch/powerpc/sysdev/axonram.c b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">index 2799706106c6..072296eba3e7 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_chunk">@@ -188,8 +188,8 @@</span> <span class="p_context"> static int axon_ram_probe(struct platform_device *device)</span>

 	axon_ram_bank_id++;

<span class="p_del">-	dev_info(&amp;device-&gt;dev, &quot;Found memory controller on %s\n&quot;,</span>
<span class="p_del">-			device-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+	dev_info(&amp;device-&gt;dev, &quot;Found memory controller on %pOF\n&quot;,</span>
<span class="p_add">+			device-&gt;dev.of_node);</span>

 	bank = kzalloc(sizeof(struct axon_ram_bank), GFP_KERNEL);
 	if (bank == NULL) {
<span class="p_header">diff --git a/arch/powerpc/sysdev/dcr.c b/arch/powerpc/sysdev/dcr.c</span>
<span class="p_header">index 121e26fffd50..d72eda568b7d 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/dcr.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/dcr.c</span>
<span class="p_chunk">@@ -195,8 +195,8 @@</span> <span class="p_context"> dcr_host_mmio_t dcr_map_mmio(struct device_node *dev,</span>
 	dcr_host_mmio_t ret = { .token = NULL, .stride = 0, .base = dcr_n };
 	u64 addr;

<span class="p_del">-	pr_debug(&quot;dcr_map(%s, 0x%x, 0x%x)\n&quot;,</span>
<span class="p_del">-		 dev-&gt;full_name, dcr_n, dcr_c);</span>
<span class="p_add">+	pr_debug(&quot;dcr_map(%pOF, 0x%x, 0x%x)\n&quot;,</span>
<span class="p_add">+		 dev, dcr_n, dcr_c);</span>

 	addr = of_translate_dcr_address(dev, dcr_n, &amp;ret.stride);
 	pr_debug(&quot;translates to addr: 0x%llx, stride: 0x%x\n&quot;,
<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_85xx_cache_sram.c b/arch/powerpc/sysdev/fsl_85xx_cache_sram.c</span>
<span class="p_header">index 37a69097e022..00ccf3e4fcb4 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_85xx_cache_sram.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_85xx_cache_sram.c</span>
<span class="p_chunk">@@ -101,8 +101,8 @@</span> <span class="p_context"> int __init instantiate_cache_sram(struct platform_device *dev,</span>

 	if (!request_mem_region(cache_sram-&gt;base_phys, cache_sram-&gt;size,
 						&quot;fsl_85xx_cache_sram&quot;)) {
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;%s: request memory failed\n&quot;,</span>
<span class="p_del">-				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;%pOF: request memory failed\n&quot;,</span>
<span class="p_add">+				dev-&gt;dev.of_node);</span>
 		ret = -ENXIO;
 		goto out_free;
 	}
<span class="p_chunk">@@ -110,16 +110,16 @@</span> <span class="p_context"> int __init instantiate_cache_sram(struct platform_device *dev,</span>
 	cache_sram-&gt;base_virt = ioremap_prot(cache_sram-&gt;base_phys,
 				cache_sram-&gt;size, _PAGE_COHERENT | PAGE_KERNEL);
 	if (!cache_sram-&gt;base_virt) {
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;%s: ioremap_prot failed\n&quot;,</span>
<span class="p_del">-				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;%pOF: ioremap_prot failed\n&quot;,</span>
<span class="p_add">+				dev-&gt;dev.of_node);</span>
 		ret = -ENOMEM;
 		goto out_release;
 	}

 	cache_sram-&gt;rh = rh_create(sizeof(unsigned int));
 	if (IS_ERR(cache_sram-&gt;rh)) {
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;%s: Unable to create remote heap\n&quot;,</span>
<span class="p_del">-				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;%pOF: Unable to create remote heap\n&quot;,</span>
<span class="p_add">+				dev-&gt;dev.of_node);</span>
 		ret = PTR_ERR(cache_sram-&gt;rh);
 		goto out_unmap;
 	}
<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_gtm.c b/arch/powerpc/sysdev/fsl_gtm.c</span>
<span class="p_header">index a6f0b96ce2c9..d902306f4718 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_gtm.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_gtm.c</span>
<span class="p_chunk">@@ -388,8 +388,8 @@</span> <span class="p_context"> static int __init fsl_gtm_init(void)</span>

 		gtm = kzalloc(sizeof(*gtm), GFP_KERNEL);
 		if (!gtm) {
<span class="p_del">-			pr_err(&quot;%s: unable to allocate memory\n&quot;,</span>
<span class="p_del">-				np-&gt;full_name);</span>
<span class="p_add">+			pr_err(&quot;%pOF: unable to allocate memory\n&quot;,</span>
<span class="p_add">+				np);</span>
 			continue;
 		}

<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> static int __init fsl_gtm_init(void)</span>

 		clock = of_get_property(np, &quot;clock-frequency&quot;, &amp;size);
 		if (!clock || size != sizeof(*clock)) {
<span class="p_del">-			pr_err(&quot;%s: no clock-frequency\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+			pr_err(&quot;%pOF: no clock-frequency\n&quot;, np);</span>
 			goto err;
 		}
 		gtm-&gt;clock = *clock;
<span class="p_chunk">@@ -407,8 +407,8 @@</span> <span class="p_context"> static int __init fsl_gtm_init(void)</span>

 			irq = irq_of_parse_and_map(np, i);
 			if (!irq) {
<span class="p_del">-				pr_err(&quot;%s: not enough interrupts specified\n&quot;,</span>
<span class="p_del">-				       np-&gt;full_name);</span>
<span class="p_add">+				pr_err(&quot;%pOF: not enough interrupts specified\n&quot;,</span>
<span class="p_add">+				       np);</span>
 				goto err;
 			}
 			gtm-&gt;timers[i].irq = irq;
<span class="p_chunk">@@ -417,8 +417,8 @@</span> <span class="p_context"> static int __init fsl_gtm_init(void)</span>

 		gtm-&gt;regs = of_iomap(np, 0);
 		if (!gtm-&gt;regs) {
<span class="p_del">-			pr_err(&quot;%s: unable to iomap registers\n&quot;,</span>
<span class="p_del">-			       np-&gt;full_name);</span>
<span class="p_add">+			pr_err(&quot;%pOF: unable to iomap registers\n&quot;,</span>
<span class="p_add">+			       np);</span>
 			goto err;
 		}

<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_msi.c b/arch/powerpc/sysdev/fsl_msi.c</span>
<span class="p_header">index 8a244828782e..44cbf4c12ea1 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_msi.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_msi.c</span>
<span class="p_chunk">@@ -214,8 +214,8 @@</span> <span class="p_context"> static int fsl_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type)</span>
 			phandle = np-&gt;phandle;
 		else {
 			dev_err(&amp;pdev-&gt;dev,
<span class="p_del">-				&quot;node %s has an invalid fsl,msi phandle %u\n&quot;,</span>
<span class="p_del">-				hose-&gt;dn-&gt;full_name, np-&gt;phandle);</span>
<span class="p_add">+				&quot;node %pOF has an invalid fsl,msi phandle %u\n&quot;,</span>
<span class="p_add">+				hose-&gt;dn, np-&gt;phandle);</span>
 			return -EINVAL;
 		}
 	}
<span class="p_chunk">@@ -438,16 +438,16 @@</span> <span class="p_context"> static int fsl_of_msi_probe(struct platform_device *dev)</span>
 	if ((features-&gt;fsl_pic_ip &amp; FSL_PIC_IP_MASK) != FSL_PIC_IP_VMPIC) {
 		err = of_address_to_resource(dev-&gt;dev.of_node, 0, &amp;res);
 		if (err) {
<span class="p_del">-			dev_err(&amp;dev-&gt;dev, &quot;invalid resource for node %s\n&quot;,</span>
<span class="p_del">-				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;invalid resource for node %pOF\n&quot;,</span>
<span class="p_add">+				dev-&gt;dev.of_node);</span>
 			goto error_out;
 		}

 		msi-&gt;msi_regs = ioremap(res.start, resource_size(&amp;res));
 		if (!msi-&gt;msi_regs) {
 			err = -ENOMEM;
<span class="p_del">-			dev_err(&amp;dev-&gt;dev, &quot;could not map node %s\n&quot;,</span>
<span class="p_del">-				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;could not map node %pOF\n&quot;,</span>
<span class="p_add">+				dev-&gt;dev.of_node);</span>
 			goto error_out;
 		}
 		msi-&gt;msiir_offset =
<span class="p_chunk">@@ -522,8 +522,8 @@</span> <span class="p_context"> static int fsl_of_msi_probe(struct platform_device *dev)</span>
 		for (irq_index = 0, i = 0; i &lt; len / (2 * sizeof(u32)); i++) {
 			if (p[i * 2] % IRQS_PER_MSI_REG ||
 			    p[i * 2 + 1] % IRQS_PER_MSI_REG) {
<span class="p_del">-				pr_warn(&quot;%s: %s: msi available range of %u at %u is not IRQ-aligned\n&quot;,</span>
<span class="p_del">-				       __func__, dev-&gt;dev.of_node-&gt;full_name,</span>
<span class="p_add">+				pr_warn(&quot;%s: %pOF: msi available range of %u at %u is not IRQ-aligned\n&quot;,</span>
<span class="p_add">+				       __func__, dev-&gt;dev.of_node,</span>
 				       p[i * 2 + 1], p[i * 2]);
 				err = -EINVAL;
 				goto error_out;
<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_pci.c b/arch/powerpc/sysdev/fsl_pci.c</span>
<span class="p_header">index d3a597456b6e..22d98057f773 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_pci.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_pci.c</span>
<span class="p_chunk">@@ -202,7 +202,6 @@</span> <span class="p_context"> static void setup_pci_atmu(struct pci_controller *hose)</span>
 	u32 pcicsrbar = 0, pcicsrbar_sz;
 	u32 piwar = PIWAR_EN | PIWAR_PF | PIWAR_TGI_LOCAL |
 			PIWAR_READ_SNOOP | PIWAR_WRITE_SNOOP;
<span class="p_del">-	const char *name = hose-&gt;dn-&gt;full_name;</span>
 	const u64 *reg;
 	int len;
 	bool setup_inbound;
<span class="p_chunk">@@ -290,12 +289,12 @@</span> <span class="p_context"> static void setup_pci_atmu(struct pci_controller *hose)</span>
 	paddr_lo -= offset;

 	if (paddr_hi == paddr_lo) {
<span class="p_del">-		pr_err(&quot;%s: No outbound window space\n&quot;, name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: No outbound window space\n&quot;, hose-&gt;dn);</span>
 		return;
 	}

 	if (paddr_lo == 0) {
<span class="p_del">-		pr_err(&quot;%s: No space for inbound window\n&quot;, name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: No space for inbound window\n&quot;, hose-&gt;dn);</span>
 		return;
 	}

<span class="p_chunk">@@ -313,7 +312,7 @@</span> <span class="p_context"> static void setup_pci_atmu(struct pci_controller *hose)</span>

 	paddr_lo = min(paddr_lo, (u64)pcicsrbar);

<span class="p_del">-	pr_info(&quot;%s: PCICSRBAR @ 0x%x\n&quot;, name, pcicsrbar);</span>
<span class="p_add">+	pr_info(&quot;%pOF: PCICSRBAR @ 0x%x\n&quot;, hose-&gt;dn, pcicsrbar);</span>

 	/* Setup inbound mem window */
 	mem = memblock_end_of_DRAM();
<span class="p_chunk">@@ -336,12 +335,12 @@</span> <span class="p_context"> static void setup_pci_atmu(struct pci_controller *hose)</span>
 		u64 address = be64_to_cpup(reg);

 		if ((address &gt;= mem) &amp;&amp; (address &lt; (mem + PAGE_SIZE))) {
<span class="p_del">-			pr_info(&quot;%s: extending DDR ATMU to cover MSIIR&quot;, name);</span>
<span class="p_add">+			pr_info(&quot;%pOF: extending DDR ATMU to cover MSIIR&quot;, hose-&gt;dn);</span>
 			mem += PAGE_SIZE;
 		} else {
 			/* TODO: Create a new ATMU for MSIIR */
<span class="p_del">-			pr_warn(&quot;%s: msi-address-64 address of %llx is &quot;</span>
<span class="p_del">-				&quot;unsupported\n&quot;, name, address);</span>
<span class="p_add">+			pr_warn(&quot;%pOF: msi-address-64 address of %llx is &quot;</span>
<span class="p_add">+				&quot;unsupported\n&quot;, hose-&gt;dn, address);</span>
 		}
 	}

<span class="p_chunk">@@ -354,8 +353,8 @@</span> <span class="p_context"> static void setup_pci_atmu(struct pci_controller *hose)</span>
 		if ((1ull &lt;&lt; mem_log) != mem) {
 			mem_log++;
 			if ((1ull &lt;&lt; mem_log) &gt; mem)
<span class="p_del">-				pr_info(&quot;%s: Setting PCI inbound window &quot;</span>
<span class="p_del">-					&quot;greater than memory size\n&quot;, name);</span>
<span class="p_add">+				pr_info(&quot;%pOF: Setting PCI inbound window &quot;</span>
<span class="p_add">+					&quot;greater than memory size\n&quot;, hose-&gt;dn);</span>
 		}

 		piwar |= ((mem_log - 1) &amp; PIWAR_SZ_MASK);
<span class="p_chunk">@@ -402,7 +401,7 @@</span> <span class="p_context"> static void setup_pci_atmu(struct pci_controller *hose)</span>
 			 */
 			ppc_md.dma_set_mask = fsl_pci_dma_set_mask;

<span class="p_del">-			pr_info(&quot;%s: Setup 64-bit PCI DMA window\n&quot;, name);</span>
<span class="p_add">+			pr_info(&quot;%pOF: Setup 64-bit PCI DMA window\n&quot;, hose-&gt;dn);</span>
 		}
 	} else {
 		u64 paddr = 0;
<span class="p_chunk">@@ -443,18 +442,18 @@</span> <span class="p_context"> static void setup_pci_atmu(struct pci_controller *hose)</span>
 #ifdef CONFIG_SWIOTLB
 		ppc_swiotlb_enable = 1;
 #else
<span class="p_del">-		pr_err(&quot;%s: ERROR: Memory size exceeds PCI ATMU ability to &quot;</span>
<span class="p_add">+		pr_err(&quot;%pOF: ERROR: Memory size exceeds PCI ATMU ability to &quot;</span>
 			&quot;map - enable CONFIG_SWIOTLB to avoid dma errors.\n&quot;,
<span class="p_del">-			 name);</span>
<span class="p_add">+			 hose-&gt;dn);</span>
 #endif
 		/* adjusting outbound windows could reclaim space in mem map */
 		if (paddr_hi &lt; 0xffffffffull)
<span class="p_del">-			pr_warning(&quot;%s: WARNING: Outbound window cfg leaves &quot;</span>
<span class="p_add">+			pr_warning(&quot;%pOF: WARNING: Outbound window cfg leaves &quot;</span>
 				&quot;gaps in memory map. Adjusting the memory map &quot;
 				&quot;could reduce unnecessary bounce buffering.\n&quot;,
<span class="p_del">-				name);</span>
<span class="p_add">+				hose-&gt;dn);</span>

<span class="p_del">-		pr_info(&quot;%s: DMA window size is 0x%llx\n&quot;, name,</span>
<span class="p_add">+		pr_info(&quot;%pOF: DMA window size is 0x%llx\n&quot;, hose-&gt;dn,</span>
 			(u64)hose-&gt;dma_window_size);
 	}
 }
<span class="p_chunk">@@ -532,11 +531,11 @@</span> <span class="p_context"> int fsl_add_bridge(struct platform_device *pdev, int is_primary)</span>
 	dev = pdev-&gt;dev.of_node;

 	if (!of_device_is_available(dev)) {
<span class="p_del">-		pr_warning(&quot;%s: disabled\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		pr_warning(&quot;%pOF: disabled\n&quot;, dev);</span>
 		return -ENODEV;
 	}

<span class="p_del">-	pr_debug(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	/* Fetch host bridge registers address */
 	if (of_address_to_resource(dev, 0, &amp;rsrc)) {
<span class="p_chunk">@@ -547,8 +546,8 @@</span> <span class="p_context"> int fsl_add_bridge(struct platform_device *pdev, int is_primary)</span>
 	/* Get bus range if any */
 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int))
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume&quot;</span>
<span class="p_del">-			&quot; bus 0\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume&quot;</span>
<span class="p_add">+			&quot; bus 0\n&quot;, dev);</span>

 	pci_add_flags(PCI_REASSIGN_ALL_BUS);
 	hose = pcibios_alloc_controller(dev);
<span class="p_chunk">@@ -809,11 +808,11 @@</span> <span class="p_context"> int __init mpc83xx_add_bridge(struct device_node *dev)</span>
 	is_mpc83xx_pci = 1;

 	if (!of_device_is_available(dev)) {
<span class="p_del">-		pr_warning(&quot;%s: disabled by the firmware.\n&quot;,</span>
<span class="p_del">-			   dev-&gt;full_name);</span>
<span class="p_add">+		pr_warning(&quot;%pOF: disabled by the firmware.\n&quot;,</span>
<span class="p_add">+			   dev);</span>
 		return -ENODEV;
 	}
<span class="p_del">-	pr_debug(&quot;Adding PCI host bridge %s\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+	pr_debug(&quot;Adding PCI host bridge %pOF\n&quot;, dev);</span>

 	/* Fetch host bridge registers address */
 	if (of_address_to_resource(dev, 0, &amp;rsrc_reg)) {
<span class="p_chunk">@@ -848,8 +847,8 @@</span> <span class="p_context"> int __init mpc83xx_add_bridge(struct device_node *dev)</span>
 	/* Get bus range if any */
 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume&quot;</span>
<span class="p_del">-		       &quot; bus 0\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume&quot;</span>
<span class="p_add">+		       &quot; bus 0\n&quot;, dev);</span>
 	}

 	pci_add_flags(PCI_REASSIGN_ALL_BUS);
<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_rio.c b/arch/powerpc/sysdev/fsl_rio.c</span>
<span class="p_header">index 1c41c51f22cb..9234be1e66f5 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_rio.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_rio.c</span>
<span class="p_chunk">@@ -450,12 +450,12 @@</span> <span class="p_context"> int fsl_rio_setup(struct platform_device *dev)</span>

 	rc = of_address_to_resource(dev-&gt;dev.of_node, 0, &amp;regs);
 	if (rc) {
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %s property &#39;reg&#39;\n&quot;,</span>
<span class="p_del">-				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %pOF property &#39;reg&#39;\n&quot;,</span>
<span class="p_add">+				dev-&gt;dev.of_node);</span>
 		return -EFAULT;
 	}
<span class="p_del">-	dev_info(&amp;dev-&gt;dev, &quot;Of-device full name %s\n&quot;,</span>
<span class="p_del">-			dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;Of-device full name %pOF\n&quot;,</span>
<span class="p_add">+			dev-&gt;dev.of_node);</span>
 	dev_info(&amp;dev-&gt;dev, &quot;Regs: %pR\n&quot;, &amp;regs);

 	rio_regs_win = ioremap(regs.start, resource_size(&amp;regs));
<span class="p_chunk">@@ -494,8 +494,8 @@</span> <span class="p_context"> int fsl_rio_setup(struct platform_device *dev)</span>
 	}
 	rc = of_address_to_resource(rmu_node, 0, &amp;rmu_regs);
 	if (rc) {
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %s property &#39;reg&#39;\n&quot;,</span>
<span class="p_del">-				rmu_node-&gt;full_name);</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %pOF property &#39;reg&#39;\n&quot;,</span>
<span class="p_add">+				rmu_node);</span>
 		goto err_rmu;
 	}
 	rmu_regs_win = ioremap(rmu_regs.start, resource_size(&amp;rmu_regs));
<span class="p_chunk">@@ -529,8 +529,8 @@</span> <span class="p_context"> int fsl_rio_setup(struct platform_device *dev)</span>
 	aw = of_n_addr_cells(np);
 	dt_range = of_get_property(np, &quot;reg&quot;, &amp;rlen);
 	if (!dt_range) {
<span class="p_del">-		pr_err(&quot;%s: unable to find &#39;reg&#39; property\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: unable to find &#39;reg&#39; property\n&quot;,</span>
<span class="p_add">+			np);</span>
 		rc = -ENOMEM;
 		goto err_pw;
 	}
<span class="p_chunk">@@ -557,8 +557,8 @@</span> <span class="p_context"> int fsl_rio_setup(struct platform_device *dev)</span>
 	aw = of_n_addr_cells(np);
 	dt_range = of_get_property(np, &quot;reg&quot;, &amp;rlen);
 	if (!dt_range) {
<span class="p_del">-		pr_err(&quot;%s: unable to find &#39;reg&#39; property\n&quot;,</span>
<span class="p_del">-			np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: unable to find &#39;reg&#39; property\n&quot;,</span>
<span class="p_add">+			np);</span>
 		rc = -ENOMEM;
 		goto err;
 	}
<span class="p_chunk">@@ -569,15 +569,15 @@</span> <span class="p_context"> int fsl_rio_setup(struct platform_device *dev)</span>
 	for_each_child_of_node(dev-&gt;dev.of_node, np) {
 		port_index = of_get_property(np, &quot;cell-index&quot;, NULL);
 		if (!port_index) {
<span class="p_del">-			dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %s property &#39;cell-index&#39;\n&quot;,</span>
<span class="p_del">-					np-&gt;full_name);</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %pOF property &#39;cell-index&#39;\n&quot;,</span>
<span class="p_add">+					np);</span>
 			continue;
 		}

 		dt_range = of_get_property(np, &quot;ranges&quot;, &amp;rlen);
 		if (!dt_range) {
<span class="p_del">-			dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %s property &#39;ranges&#39;\n&quot;,</span>
<span class="p_del">-					np-&gt;full_name);</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get %pOF property &#39;ranges&#39;\n&quot;,</span>
<span class="p_add">+					np);</span>
 			continue;
 		}

<span class="p_chunk">@@ -598,8 +598,8 @@</span> <span class="p_context"> int fsl_rio_setup(struct platform_device *dev)</span>
 		range_start = of_read_number(dt_range + aw, paw);
 		range_size = of_read_number(dt_range + aw + paw, sw);

<span class="p_del">-		dev_info(&amp;dev-&gt;dev, &quot;%s: LAW start 0x%016llx, size 0x%016llx.\n&quot;,</span>
<span class="p_del">-				np-&gt;full_name, range_start, range_size);</span>
<span class="p_add">+		dev_info(&amp;dev-&gt;dev, &quot;%pOF: LAW start 0x%016llx, size 0x%016llx.\n&quot;,</span>
<span class="p_add">+				np, range_start, range_size);</span>

 		port = kzalloc(sizeof(struct rio_mport), GFP_KERNEL);
 		if (!port)
<span class="p_chunk">@@ -757,8 +757,8 @@</span> <span class="p_context"> int fsl_rio_setup(struct platform_device *dev)</span>
  */
 static int fsl_of_rio_rpn_probe(struct platform_device *dev)
 {
<span class="p_del">-	printk(KERN_INFO &quot;Setting up RapidIO peer-to-peer network %s\n&quot;,</span>
<span class="p_del">-			dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+	printk(KERN_INFO &quot;Setting up RapidIO peer-to-peer network %pOF\n&quot;,</span>
<span class="p_add">+			dev-&gt;dev.of_node);</span>

 	return fsl_rio_setup(dev);
 };
<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_rmu.c b/arch/powerpc/sysdev/fsl_rmu.c</span>
<span class="p_header">index c1826de4e749..ab7a74c75be8 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_rmu.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_rmu.c</span>
<span class="p_chunk">@@ -1074,8 +1074,8 @@</span> <span class="p_context"> int fsl_rio_setup_rmu(struct rio_mport *mport, struct device_node *node)</span>
 	priv = mport-&gt;priv;

 	if (!node) {
<span class="p_del">-		dev_warn(priv-&gt;dev, &quot;Can&#39;t get %s property &#39;fsl,rmu&#39;\n&quot;,</span>
<span class="p_del">-			priv-&gt;dev-&gt;of_node-&gt;full_name);</span>
<span class="p_add">+		dev_warn(priv-&gt;dev, &quot;Can&#39;t get %pOF property &#39;fsl,rmu&#39;\n&quot;,</span>
<span class="p_add">+			priv-&gt;dev-&gt;of_node);</span>
 		return -EINVAL;
 	}

<span class="p_chunk">@@ -1086,8 +1086,8 @@</span> <span class="p_context"> int fsl_rio_setup_rmu(struct rio_mport *mport, struct device_node *node)</span>
 	aw = of_n_addr_cells(node);
 	msg_addr = of_get_property(node, &quot;reg&quot;, &amp;mlen);
 	if (!msg_addr) {
<span class="p_del">-		pr_err(&quot;%s: unable to find &#39;reg&#39; property of message-unit\n&quot;,</span>
<span class="p_del">-			node-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: unable to find &#39;reg&#39; property of message-unit\n&quot;,</span>
<span class="p_add">+			node);</span>
 		kfree(rmu);
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -1098,8 +1098,8 @@</span> <span class="p_context"> int fsl_rio_setup_rmu(struct rio_mport *mport, struct device_node *node)</span>

 	rmu-&gt;txirq = irq_of_parse_and_map(node, 0);
 	rmu-&gt;rxirq = irq_of_parse_and_map(node, 1);
<span class="p_del">-	printk(KERN_INFO &quot;%s: txirq: %d, rxirq %d\n&quot;,</span>
<span class="p_del">-		node-&gt;full_name, rmu-&gt;txirq, rmu-&gt;rxirq);</span>
<span class="p_add">+	printk(KERN_INFO &quot;%pOF: txirq: %d, rxirq %d\n&quot;,</span>
<span class="p_add">+		node, rmu-&gt;txirq, rmu-&gt;rxirq);</span>

 	priv-&gt;rmm_handle = rmu;

<span class="p_header">diff --git a/arch/powerpc/sysdev/mpic.c b/arch/powerpc/sysdev/mpic.c</span>
<span class="p_header">index b9aac951a90f..ead3e2549ebf 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mpic.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mpic.c</span>
<span class="p_chunk">@@ -1650,8 +1650,8 @@</span> <span class="p_context"> void __init mpic_init(struct mpic *mpic)</span>
 	if (mpic-&gt;flags &amp; MPIC_SECONDARY) {
 		int virq = irq_of_parse_and_map(mpic-&gt;node, 0);
 		if (virq) {
<span class="p_del">-			printk(KERN_INFO &quot;%s: hooking up to IRQ %d\n&quot;,</span>
<span class="p_del">-					mpic-&gt;node-&gt;full_name, virq);</span>
<span class="p_add">+			printk(KERN_INFO &quot;%pOF: hooking up to IRQ %d\n&quot;,</span>
<span class="p_add">+					mpic-&gt;node, virq);</span>
 			irq_set_handler_data(virq, mpic);
 			irq_set_chained_handler(virq, &amp;mpic_cascade);
 		}
<span class="p_header">diff --git a/arch/powerpc/sysdev/mpic_msgr.c b/arch/powerpc/sysdev/mpic_msgr.c</span>
<span class="p_header">index db2286be5d9a..eb69a5186243 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mpic_msgr.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mpic_msgr.c</span>
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> static int mpic_msgr_probe(struct platform_device *dev)</span>
 			return -ENOMEM;
 		}
 	}
<span class="p_del">-	dev_info(&amp;dev-&gt;dev, &quot;Of-device full name %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	dev_info(&amp;dev-&gt;dev, &quot;Of-device full name %pOF\n&quot;, np);</span>

 	/* IO map the message register block. */
 	of_address_to_resource(np, 0, &amp;rsrc);
<span class="p_header">diff --git a/arch/powerpc/sysdev/mpic_msi.c b/arch/powerpc/sysdev/mpic_msi.c</span>
<span class="p_header">index 1d48a5385905..9ed860aee9c3 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mpic_msi.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mpic_msi.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static int mpic_msi_reserve_u3_hwirqs(struct mpic *mpic)</span>

 	np = NULL;
 	while ((np = of_find_all_nodes(np))) {
<span class="p_del">-		pr_debug(&quot;mpic: mapping hwirqs for %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		pr_debug(&quot;mpic: mapping hwirqs for %pOF\n&quot;, np);</span>

 		index = 0;
 		while (of_irq_parse_one(np, index++, &amp;oirq) == 0) {
<span class="p_header">diff --git a/arch/powerpc/sysdev/mpic_timer.c b/arch/powerpc/sysdev/mpic_timer.c</span>
<span class="p_header">index 9d9b06217f8b..a418579591be 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mpic_timer.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mpic_timer.c</span>
<span class="p_chunk">@@ -466,8 +466,7 @@</span> <span class="p_context"> static int timer_group_get_irq(struct device_node *np,</span>

 	p = of_get_property(np, &quot;fsl,available-ranges&quot;, &amp;len);
 	if (p &amp;&amp; len % (2 * sizeof(u32)) != 0) {
<span class="p_del">-		pr_err(&quot;%s: malformed available-ranges property.\n&quot;,</span>
<span class="p_del">-				np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: malformed available-ranges property.\n&quot;, np);</span>
 		return -EINVAL;
 	}

<span class="p_chunk">@@ -484,8 +483,7 @@</span> <span class="p_context"> static int timer_group_get_irq(struct device_node *np,</span>
 		for (j = 0; j &lt; count; j++) {
 			irq = irq_of_parse_and_map(np, irq_index);
 			if (!irq) {
<span class="p_del">-				pr_err(&quot;%s: irq parse and map failed.\n&quot;,</span>
<span class="p_del">-						np-&gt;full_name);</span>
<span class="p_add">+				pr_err(&quot;%pOF: irq parse and map failed.\n&quot;, np);</span>
 				return -EINVAL;
 			}

<span class="p_chunk">@@ -508,8 +506,7 @@</span> <span class="p_context"> static void timer_group_init(struct device_node *np)</span>

 	priv = kzalloc(sizeof(struct timer_group_priv), GFP_KERNEL);
 	if (!priv) {
<span class="p_del">-		pr_err(&quot;%s: cannot allocate memory for group.\n&quot;,</span>
<span class="p_del">-				np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: cannot allocate memory for group.\n&quot;, np);</span>
 		return;
 	}

<span class="p_chunk">@@ -518,29 +515,27 @@</span> <span class="p_context"> static void timer_group_init(struct device_node *np)</span>

 	priv-&gt;regs = of_iomap(np, i++);
 	if (!priv-&gt;regs) {
<span class="p_del">-		pr_err(&quot;%s: cannot ioremap timer register address.\n&quot;,</span>
<span class="p_del">-				np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: cannot ioremap timer register address.\n&quot;, np);</span>
 		goto out;
 	}

 	if (priv-&gt;flags &amp; FSL_GLOBAL_TIMER) {
 		priv-&gt;group_tcr = of_iomap(np, i++);
 		if (!priv-&gt;group_tcr) {
<span class="p_del">-			pr_err(&quot;%s: cannot ioremap tcr address.\n&quot;,</span>
<span class="p_del">-					np-&gt;full_name);</span>
<span class="p_add">+			pr_err(&quot;%pOF: cannot ioremap tcr address.\n&quot;, np);</span>
 			goto out;
 		}
 	}

 	ret = timer_group_get_freq(np, priv);
 	if (ret &lt; 0) {
<span class="p_del">-		pr_err(&quot;%s: cannot get timer frequency.\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: cannot get timer frequency.\n&quot;, np);</span>
 		goto out;
 	}

 	ret = timer_group_get_irq(np, priv);
 	if (ret &lt; 0) {
<span class="p_del">-		pr_err(&quot;%s: cannot get timer irqs.\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		pr_err(&quot;%pOF: cannot get timer irqs.\n&quot;, np);</span>
 		goto out;
 	}

<span class="p_header">diff --git a/arch/powerpc/sysdev/msi_bitmap.c b/arch/powerpc/sysdev/msi_bitmap.c</span>
<span class="p_header">index 5ebd3f018295..c4dae27172b3 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/msi_bitmap.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/msi_bitmap.c</span>
<span class="p_chunk">@@ -86,13 +86,13 @@</span> <span class="p_context"> int msi_bitmap_reserve_dt_hwirqs(struct msi_bitmap *bmp)</span>
 	p = of_get_property(bmp-&gt;of_node, &quot;msi-available-ranges&quot;, &amp;len);
 	if (!p) {
 		pr_debug(&quot;msi_bitmap: no msi-available-ranges property &quot; \
<span class="p_del">-			 &quot;found on %s\n&quot;, bmp-&gt;of_node-&gt;full_name);</span>
<span class="p_add">+			 &quot;found on %pOF\n&quot;, bmp-&gt;of_node);</span>
 		return 1;
 	}

 	if (len % (2 * sizeof(u32)) != 0) {
 		printk(KERN_WARNING &quot;msi_bitmap: Malformed msi-available-ranges&quot;
<span class="p_del">-		       &quot; property on %s\n&quot;, bmp-&gt;of_node-&gt;full_name);</span>
<span class="p_add">+		       &quot; property on %pOF\n&quot;, bmp-&gt;of_node);</span>
 		return -EINVAL;
 	}

<span class="p_header">diff --git a/arch/powerpc/sysdev/mv64x60_dev.c b/arch/powerpc/sysdev/mv64x60_dev.c</span>
<span class="p_header">index 026bbc3b2c47..185a67e742a6 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mv64x60_dev.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mv64x60_dev.c</span>
<span class="p_chunk">@@ -452,8 +452,8 @@</span> <span class="p_context"> static int __init mv64x60_device_setup(void)</span>
 		err = mv64x60_mpsc_device_setup(np, id++);
 		if (err)
 			printk(KERN_ERR &quot;Failed to initialize MV64x60 &quot;
<span class="p_del">-					&quot;serial device %s: error %d.\n&quot;,</span>
<span class="p_del">-					np-&gt;full_name, err);</span>
<span class="p_add">+					&quot;serial device %pOF: error %d.\n&quot;,</span>
<span class="p_add">+					np, err);</span>
 	}

 	id = 0;
<span class="p_chunk">@@ -463,8 +463,8 @@</span> <span class="p_context"> static int __init mv64x60_device_setup(void)</span>
 		if (IS_ERR(pdev)) {
 			err = PTR_ERR(pdev);
 			printk(KERN_ERR &quot;Failed to initialize MV64x60 &quot;
<span class="p_del">-					&quot;network block %s: error %d.\n&quot;,</span>
<span class="p_del">-					np-&gt;full_name, err);</span>
<span class="p_add">+					&quot;network block %pOF: error %d.\n&quot;,</span>
<span class="p_add">+					np, err);</span>
 			continue;
 		}
 		for_each_child_of_node(np, np2) {
<span class="p_chunk">@@ -474,9 +474,9 @@</span> <span class="p_context"> static int __init mv64x60_device_setup(void)</span>
 			err = mv64x60_eth_device_setup(np2, id2++, pdev);
 			if (err)
 				printk(KERN_ERR &quot;Failed to initialize &quot;
<span class="p_del">-						&quot;MV64x60 network device %s: &quot;</span>
<span class="p_add">+						&quot;MV64x60 network device %pOF: &quot;</span>
 						&quot;error %d.\n&quot;,
<span class="p_del">-						np2-&gt;full_name, err);</span>
<span class="p_add">+						np2, err);</span>
 		}
 	}

<span class="p_chunk">@@ -485,8 +485,8 @@</span> <span class="p_context"> static int __init mv64x60_device_setup(void)</span>
 		err = mv64x60_i2c_device_setup(np, id++);
 		if (err)
 			printk(KERN_ERR &quot;Failed to initialize MV64x60 I2C &quot;
<span class="p_del">-					&quot;bus %s: error %d.\n&quot;,</span>
<span class="p_del">-					np-&gt;full_name, err);</span>
<span class="p_add">+					&quot;bus %pOF: error %d.\n&quot;,</span>
<span class="p_add">+					np, err);</span>
 	}

 	/* support up to one watchdog timer */
<span class="p_chunk">@@ -494,8 +494,8 @@</span> <span class="p_context"> static int __init mv64x60_device_setup(void)</span>
 	if (np) {
 		if ((err = mv64x60_wdt_device_setup(np, id)))
 			printk(KERN_ERR &quot;Failed to initialize MV64x60 &quot;
<span class="p_del">-					&quot;Watchdog %s: error %d.\n&quot;,</span>
<span class="p_del">-					np-&gt;full_name, err);</span>
<span class="p_add">+					&quot;Watchdog %pOF: error %d.\n&quot;,</span>
<span class="p_add">+					np, err);</span>
 		of_node_put(np);
 	}

<span class="p_header">diff --git a/arch/powerpc/sysdev/mv64x60_pci.c b/arch/powerpc/sysdev/mv64x60_pci.c</span>
<span class="p_header">index 330d56613c5a..5261750dacc4 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mv64x60_pci.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mv64x60_pci.c</span>
<span class="p_chunk">@@ -136,8 +136,8 @@</span> <span class="p_context"> static int __init mv64x60_add_bridge(struct device_node *dev)</span>
 	/* Get bus range if any */
 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int))
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume&quot;</span>
<span class="p_del">-		       &quot; bus 0\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume&quot;</span>
<span class="p_add">+		       &quot; bus 0\n&quot;, dev);</span>

 	hose = pcibios_alloc_controller(dev);
 	if (!hose)
<span class="p_header">diff --git a/arch/powerpc/sysdev/of_rtc.c b/arch/powerpc/sysdev/of_rtc.c</span>
<span class="p_header">index 6f54b54b1328..153fdac4720f 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/of_rtc.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/of_rtc.c</span>
<span class="p_chunk">@@ -38,21 +38,21 @@</span> <span class="p_context"> void __init of_instantiate_rtc(void)</span>
 			res = kmalloc(sizeof(*res), GFP_KERNEL);
 			if (!res) {
 				printk(KERN_ERR &quot;OF RTC: Out of memory &quot;
<span class="p_del">-				       &quot;allocating resource structure for %s\n&quot;,</span>
<span class="p_del">-				       node-&gt;full_name);</span>
<span class="p_add">+				       &quot;allocating resource structure for %pOF\n&quot;,</span>
<span class="p_add">+				       node);</span>
 				continue;
 			}

 			err = of_address_to_resource(node, 0, res);
 			if (err) {
 				printk(KERN_ERR &quot;OF RTC: Error &quot;
<span class="p_del">-				       &quot;translating resources for %s\n&quot;,</span>
<span class="p_del">-				       node-&gt;full_name);</span>
<span class="p_add">+				       &quot;translating resources for %pOF\n&quot;,</span>
<span class="p_add">+				       node);</span>
 				continue;
 			}

<span class="p_del">-			printk(KERN_INFO &quot;OF_RTC: %s is a %s @ 0x%llx-0x%llx\n&quot;,</span>
<span class="p_del">-			       node-&gt;full_name, plat_name,</span>
<span class="p_add">+			printk(KERN_INFO &quot;OF_RTC: %pOF is a %s @ 0x%llx-0x%llx\n&quot;,</span>
<span class="p_add">+			       node, plat_name,</span>
 			       (unsigned long long)res-&gt;start,
 			       (unsigned long long)res-&gt;end);
 			platform_device_register_simple(plat_name, -1, res, 1);
<span class="p_header">diff --git a/arch/powerpc/sysdev/ppc4xx_cpm.c b/arch/powerpc/sysdev/ppc4xx_cpm.c</span>
<span class="p_header">index ba95adf81d8d..ac7af8b5ffa1 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/ppc4xx_cpm.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/ppc4xx_cpm.c</span>
<span class="p_chunk">@@ -278,8 +278,8 @@</span> <span class="p_context"> static int __init cpm_init(void)</span>
 	dcr_len = dcr_resource_len(np, 0);

 	if (dcr_base == 0 || dcr_len == 0) {
<span class="p_del">-		printk(KERN_ERR &quot;cpm: could not parse dcr property for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;cpm: could not parse dcr property for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		ret = -EINVAL;
 		goto node_put;
 	}
<span class="p_chunk">@@ -287,8 +287,8 @@</span> <span class="p_context"> static int __init cpm_init(void)</span>
 	cpm.dcr_host = dcr_map(np, dcr_base, dcr_len);

 	if (!DCR_MAP_OK(cpm.dcr_host)) {
<span class="p_del">-		printk(KERN_ERR &quot;cpm: failed to map dcr property for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;cpm: failed to map dcr property for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		ret = -EINVAL;
 		goto node_put;
 	}
<span class="p_header">diff --git a/arch/powerpc/sysdev/ppc4xx_gpio.c b/arch/powerpc/sysdev/ppc4xx_gpio.c</span>
<span class="p_header">index 5382d04dd872..2238e369cde4 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/ppc4xx_gpio.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/ppc4xx_gpio.c</span>
<span class="p_chunk">@@ -198,8 +198,7 @@</span> <span class="p_context"> static int __init ppc4xx_add_gpiochips(void)</span>
 			goto err;
 		continue;
 err:
<span class="p_del">-		pr_err(&quot;%s: registration failed with status %d\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name, ret);</span>
<span class="p_add">+		pr_err(&quot;%pOF: registration failed with status %d\n&quot;, np, ret);</span>
 		kfree(ppc4xx_gc);
 		/* try others anyway */
 	}
<span class="p_header">diff --git a/arch/powerpc/sysdev/ppc4xx_msi.c b/arch/powerpc/sysdev/ppc4xx_msi.c</span>
<span class="p_header">index 590dab4f47d6..d50417e23add 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/ppc4xx_msi.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/ppc4xx_msi.c</span>
<span class="p_chunk">@@ -233,8 +233,7 @@</span> <span class="p_context"> static int ppc4xx_msi_probe(struct platform_device *dev)</span>
 	/* Get MSI ranges */
 	err = of_address_to_resource(dev-&gt;dev.of_node, 0, &amp;res);
 	if (err) {
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;%s resource error!\n&quot;,</span>
<span class="p_del">-			dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;%pOF resource error!\n&quot;, dev-&gt;dev.of_node);</span>
 		goto error_out;
 	}

<span class="p_header">diff --git a/arch/powerpc/sysdev/ppc4xx_pci.c b/arch/powerpc/sysdev/ppc4xx_pci.c</span>
<span class="p_header">index 086aca69ecae..7adb879590a2 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/ppc4xx_pci.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/ppc4xx_pci.c</span>
<span class="p_chunk">@@ -127,9 +127,9 @@</span> <span class="p_context"> static int __init ppc4xx_parse_dma_ranges(struct pci_controller *hose,</span>
 		 * within 32 bits space
 		 */
 		if (cpu_addr != 0 || pci_addr &gt; 0xffffffff) {
<span class="p_del">-			printk(KERN_WARNING &quot;%s: Ignored unsupported dma range&quot;</span>
<span class="p_add">+			printk(KERN_WARNING &quot;%pOF: Ignored unsupported dma range&quot;</span>
 			       &quot; 0x%016llx...0x%016llx -&gt; 0x%016llx\n&quot;,
<span class="p_del">-			       hose-&gt;dn-&gt;full_name,</span>
<span class="p_add">+			       hose-&gt;dn,</span>
 			       pci_addr, pci_addr + size - 1, cpu_addr);
 			continue;
 		}
<span class="p_chunk">@@ -152,8 +152,7 @@</span> <span class="p_context"> static int __init ppc4xx_parse_dma_ranges(struct pci_controller *hose,</span>

 	/* We only support one global DMA offset */
 	if (dma_offset_set &amp;&amp; pci_dram_offset != res-&gt;start) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: dma-ranges(s) mismatch\n&quot;,</span>
<span class="p_del">-		       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: dma-ranges(s) mismatch\n&quot;, hose-&gt;dn);</span>
 		return -ENXIO;
 	}

<span class="p_chunk">@@ -161,17 +160,16 @@</span> <span class="p_context"> static int __init ppc4xx_parse_dma_ranges(struct pci_controller *hose,</span>
 	 * DMA bounce buffers
 	 */
 	if (size &lt; total_memory) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: dma-ranges too small &quot;</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: dma-ranges too small &quot;</span>
 		       &quot;(size=%llx total_memory=%llx)\n&quot;,
<span class="p_del">-		       hose-&gt;dn-&gt;full_name, size, (u64)total_memory);</span>
<span class="p_add">+		       hose-&gt;dn, size, (u64)total_memory);</span>
 		return -ENXIO;
 	}

 	/* Check we are a power of 2 size and that base is a multiple of size*/
 	if ((size &amp; (size - 1)) != 0  ||
 	    (res-&gt;start &amp; (size - 1)) != 0) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: dma-ranges unaligned\n&quot;,</span>
<span class="p_del">-		       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: dma-ranges unaligned\n&quot;, hose-&gt;dn);</span>
 		return -ENXIO;
 	}

<span class="p_chunk">@@ -181,8 +179,8 @@</span> <span class="p_context"> static int __init ppc4xx_parse_dma_ranges(struct pci_controller *hose,</span>
 	if (res-&gt;end &gt; 0xffffffff &amp;&amp;
 	    !(of_device_is_compatible(hose-&gt;dn, &quot;ibm,plb-pciex-460sx&quot;)
 	      || of_device_is_compatible(hose-&gt;dn, &quot;ibm,plb-pciex-476fpe&quot;))) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: dma-ranges outside of 32 bits space\n&quot;,</span>
<span class="p_del">-		       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: dma-ranges outside of 32 bits space\n&quot;,</span>
<span class="p_add">+		       hose-&gt;dn);</span>
 		return -ENXIO;
 	}
  out:
<span class="p_chunk">@@ -233,8 +231,7 @@</span> <span class="p_context"> static int __init ppc4xx_setup_one_pci_PMM(struct pci_controller	*hose,</span>
 	 */
 	if ((plb_addr + size) &gt; 0xffffffffull || !is_power_of_2(size) ||
 	    size &lt; 0x1000 || (plb_addr &amp; (size - 1)) != 0) {
<span class="p_del">-		printk(KERN_WARNING &quot;%s: Resource out of range\n&quot;,</span>
<span class="p_del">-		       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;%pOF: Resource out of range\n&quot;, hose-&gt;dn);</span>
 		return -1;
 	}
 	ma = (0xffffffffu &lt;&lt; ilog2(size)) | 1;
<span class="p_chunk">@@ -266,8 +263,7 @@</span> <span class="p_context"> static void __init ppc4xx_configure_pci_PMMs(struct pci_controller *hose,</span>
 		if (!(res-&gt;flags &amp; IORESOURCE_MEM))
 			continue;
 		if (j &gt; 2) {
<span class="p_del">-			printk(KERN_WARNING &quot;%s: Too many ranges\n&quot;,</span>
<span class="p_del">-			       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_WARNING &quot;%pOF: Too many ranges\n&quot;, hose-&gt;dn);</span>
 			break;
 		}

<span class="p_chunk">@@ -292,8 +288,8 @@</span> <span class="p_context"> static void __init ppc4xx_configure_pci_PMMs(struct pci_controller *hose,</span>
 	if (j &lt;= 2 &amp;&amp; !found_isa_hole &amp;&amp; hose-&gt;isa_mem_size)
 		if (ppc4xx_setup_one_pci_PMM(hose, reg, hose-&gt;isa_mem_phys, 0,
 					     hose-&gt;isa_mem_size, 0, j) == 0)
<span class="p_del">-			printk(KERN_INFO &quot;%s: Legacy ISA memory support enabled\n&quot;,</span>
<span class="p_del">-			       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_INFO &quot;%pOF: Legacy ISA memory support enabled\n&quot;,</span>
<span class="p_add">+			       hose-&gt;dn);</span>
 }

 static void __init ppc4xx_configure_pci_PTMs(struct pci_controller *hose,
<span class="p_chunk">@@ -333,21 +329,20 @@</span> <span class="p_context"> static void __init ppc4xx_probe_pci_bridge(struct device_node *np)</span>

 	/* Check if device is enabled */
 	if (!of_device_is_available(np)) {
<span class="p_del">-		printk(KERN_INFO &quot;%s: Port disabled via device-tree\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_INFO &quot;%pOF: Port disabled via device-tree\n&quot;, np);</span>
 		return;
 	}

 	/* Fetch config space registers address */
 	if (of_address_to_resource(np, 0, &amp;rsrc_cfg)) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get PCI config register base !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get PCI config register base !&quot;,</span>
<span class="p_add">+		       np);</span>
 		return;
 	}
 	/* Fetch host bridge internal registers address */
 	if (of_address_to_resource(np, 3, &amp;rsrc_reg)) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get PCI internal register base !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get PCI internal register base !&quot;,</span>
<span class="p_add">+		       np);</span>
 		return;
 	}

<span class="p_chunk">@@ -361,7 +356,7 @@</span> <span class="p_context"> static void __init ppc4xx_probe_pci_bridge(struct device_node *np)</span>
 	/* Map registers */
 	reg = ioremap(rsrc_reg.start, resource_size(&amp;rsrc_reg));
 	if (reg == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t map registers !&quot;, np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t map registers !&quot;, np);</span>
 		goto fail;
 	}

<span class="p_chunk">@@ -423,8 +418,8 @@</span> <span class="p_context"> static int __init ppc4xx_setup_one_pcix_POM(struct pci_controller	*hose,</span>

 	if (!is_power_of_2(size) || size &lt; 0x1000 ||
 	    (plb_addr &amp; (size - 1)) != 0) {
<span class="p_del">-		printk(KERN_WARNING &quot;%s: Resource out of range\n&quot;,</span>
<span class="p_del">-		       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;%pOF: Resource out of range\n&quot;,</span>
<span class="p_add">+		       hose-&gt;dn);</span>
 		return -1;
 	}

<span class="p_chunk">@@ -467,8 +462,7 @@</span> <span class="p_context"> static void __init ppc4xx_configure_pcix_POMs(struct pci_controller *hose,</span>
 		if (!(res-&gt;flags &amp; IORESOURCE_MEM))
 			continue;
 		if (j &gt; 1) {
<span class="p_del">-			printk(KERN_WARNING &quot;%s: Too many ranges\n&quot;,</span>
<span class="p_del">-			       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_WARNING &quot;%pOF: Too many ranges\n&quot;, hose-&gt;dn);</span>
 			break;
 		}

<span class="p_chunk">@@ -493,8 +487,8 @@</span> <span class="p_context"> static void __init ppc4xx_configure_pcix_POMs(struct pci_controller *hose,</span>
 	if (j &lt;= 1 &amp;&amp; !found_isa_hole &amp;&amp; hose-&gt;isa_mem_size)
 		if (ppc4xx_setup_one_pcix_POM(hose, reg, hose-&gt;isa_mem_phys, 0,
 					      hose-&gt;isa_mem_size, 0, j) == 0)
<span class="p_del">-			printk(KERN_INFO &quot;%s: Legacy ISA memory support enabled\n&quot;,</span>
<span class="p_del">-			       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_INFO &quot;%pOF: Legacy ISA memory support enabled\n&quot;,</span>
<span class="p_add">+			       hose-&gt;dn);</span>
 }

 static void __init ppc4xx_configure_pcix_PIMs(struct pci_controller *hose,
<span class="p_chunk">@@ -539,14 +533,14 @@</span> <span class="p_context"> static void __init ppc4xx_probe_pcix_bridge(struct device_node *np)</span>

 	/* Fetch config space registers address */
 	if (of_address_to_resource(np, 0, &amp;rsrc_cfg)) {
<span class="p_del">-		printk(KERN_ERR &quot;%s:Can&#39;t get PCI-X config register base !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get PCI-X config register base !&quot;,</span>
<span class="p_add">+		       np);</span>
 		return;
 	}
 	/* Fetch host bridge internal registers address */
 	if (of_address_to_resource(np, 3, &amp;rsrc_reg)) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get PCI-X internal register base !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get PCI-X internal register base !&quot;,</span>
<span class="p_add">+		       np);</span>
 		return;
 	}

<span class="p_chunk">@@ -568,7 +562,7 @@</span> <span class="p_context"> static void __init ppc4xx_probe_pcix_bridge(struct device_node *np)</span>
 	/* Map registers */
 	reg = ioremap(rsrc_reg.start, resource_size(&amp;rsrc_reg));
 	if (reg == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t map registers !&quot;, np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t map registers !&quot;, np);</span>
 		goto fail;
 	}

<span class="p_chunk">@@ -1246,8 +1240,8 @@</span> <span class="p_context"> static void __init ppc460sx_pciex_check_link(struct ppc4xx_pciex_port *port)</span>

 	mbase = ioremap(port-&gt;cfg_space.start + 0x10000000, 0x1000);
 	if (mbase == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t map internal config space !&quot;,</span>
<span class="p_del">-			port-&gt;node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t map internal config space !&quot;,</span>
<span class="p_add">+			port-&gt;node);</span>
 		goto done;
 	}

<span class="p_chunk">@@ -1389,7 +1383,7 @@</span> <span class="p_context"> static void __init ppc_476fpe_pciex_check_link(struct ppc4xx_pciex_port *port)</span>
 		                    port-&gt;index);
 		return;
 	}
<span class="p_del">-</span>
<span class="p_add">+</span>
 	while (timeout_ms--) {
 		val = in_le32(mbase + PECFG_TLDLP);

<span class="p_chunk">@@ -1448,8 +1442,7 @@</span> <span class="p_context"> static int __init ppc4xx_pciex_check_core_init(struct device_node *np)</span>
 		ppc4xx_pciex_hwops = &amp;ppc_476fpe_pcie_hwops;
 #endif
 	if (ppc4xx_pciex_hwops == NULL) {
<span class="p_del">-		printk(KERN_WARNING &quot;PCIE: unknown host type %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;PCIE: unknown host type %pOF\n&quot;, np);</span>
 		return -ENODEV;
 	}

<span class="p_chunk">@@ -1730,8 +1723,7 @@</span> <span class="p_context"> static int __init ppc4xx_setup_one_pciex_POM(struct ppc4xx_pciex_port	*port,</span>
 	    (index &lt; 2 &amp;&amp; size &lt; 0x100000) ||
 	    (index == 2 &amp;&amp; size &lt; 0x100) ||
 	    (plb_addr &amp; (size - 1)) != 0) {
<span class="p_del">-		printk(KERN_WARNING &quot;%s: Resource out of range\n&quot;,</span>
<span class="p_del">-		       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;%pOF: Resource out of range\n&quot;, hose-&gt;dn);</span>
 		return -1;
 	}

<span class="p_chunk">@@ -1807,8 +1799,8 @@</span> <span class="p_context"> static void __init ppc4xx_configure_pciex_POMs(struct ppc4xx_pciex_port *port,</span>
 		if (!(res-&gt;flags &amp; IORESOURCE_MEM))
 			continue;
 		if (j &gt; 1) {
<span class="p_del">-			printk(KERN_WARNING &quot;%s: Too many ranges\n&quot;,</span>
<span class="p_del">-			       port-&gt;node-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_WARNING &quot;%pOF: Too many ranges\n&quot;,</span>
<span class="p_add">+			       port-&gt;node);</span>
 			break;
 		}

<span class="p_chunk">@@ -1834,8 +1826,8 @@</span> <span class="p_context"> static void __init ppc4xx_configure_pciex_POMs(struct ppc4xx_pciex_port *port,</span>
 		if (ppc4xx_setup_one_pciex_POM(port, hose, mbase,
 					       hose-&gt;isa_mem_phys, 0,
 					       hose-&gt;isa_mem_size, 0, j) == 0)
<span class="p_del">-			printk(KERN_INFO &quot;%s: Legacy ISA memory support enabled\n&quot;,</span>
<span class="p_del">-			       hose-&gt;dn-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_INFO &quot;%pOF: Legacy ISA memory support enabled\n&quot;,</span>
<span class="p_add">+			       hose-&gt;dn);</span>

 	/* Configure IO, always 64K starting at 0. We hard wire it to 64K !
 	 * Note also that it -has- to be region index 2 on this HW
<span class="p_chunk">@@ -1970,8 +1962,8 @@</span> <span class="p_context"> static void __init ppc4xx_pciex_port_setup_hose(struct ppc4xx_pciex_port *port)</span>
 				   (hose-&gt;first_busno + 1) * 0x100000,
 				   busses * 0x100000);
 		if (cfg_data == NULL) {
<span class="p_del">-			printk(KERN_ERR &quot;%s: Can&#39;t map external config space !&quot;,</span>
<span class="p_del">-			       port-&gt;node-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_ERR &quot;%pOF: Can&#39;t map external config space !&quot;,</span>
<span class="p_add">+			       port-&gt;node);</span>
 			goto fail;
 		}
 		hose-&gt;cfg_data = cfg_data;
<span class="p_chunk">@@ -1982,13 +1974,13 @@</span> <span class="p_context"> static void __init ppc4xx_pciex_port_setup_hose(struct ppc4xx_pciex_port *port)</span>
 	 */
 	mbase = ioremap(port-&gt;cfg_space.start + 0x10000000, 0x1000);
 	if (mbase == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t map internal config space !&quot;,</span>
<span class="p_del">-		       port-&gt;node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t map internal config space !&quot;,</span>
<span class="p_add">+		       port-&gt;node);</span>
 		goto fail;
 	}
 	hose-&gt;cfg_addr = mbase;

<span class="p_del">-	pr_debug(&quot;PCIE %s, bus %d..%d\n&quot;, port-&gt;node-&gt;full_name,</span>
<span class="p_add">+	pr_debug(&quot;PCIE %pOF, bus %d..%d\n&quot;, port-&gt;node,</span>
 		 hose-&gt;first_busno, hose-&gt;last_busno);
 	pr_debug(&quot;     config space mapped at: root @0x%p, other @0x%p\n&quot;,
 		 hose-&gt;cfg_addr, hose-&gt;cfg_data);
<span class="p_chunk">@@ -2100,14 +2092,13 @@</span> <span class="p_context"> static void __init ppc4xx_probe_pciex_bridge(struct device_node *np)</span>
 	/* Get the port number from the device-tree */
 	pval = of_get_property(np, &quot;port&quot;, NULL);
 	if (pval == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;PCIE: Can&#39;t find port number for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;PCIE: Can&#39;t find port number for %pOF\n&quot;, np);</span>
 		return;
 	}
 	portno = *pval;
 	if (portno &gt;= ppc4xx_pciex_port_count) {
<span class="p_del">-		printk(KERN_ERR &quot;PCIE: port number out of range for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;PCIE: port number out of range for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		return;
 	}
 	port = &amp;ppc4xx_pciex_ports[portno];
<span class="p_chunk">@@ -2125,8 +2116,8 @@</span> <span class="p_context"> static void __init ppc4xx_probe_pciex_bridge(struct device_node *np)</span>
 	if (ppc4xx_pciex_hwops-&gt;want_sdr) {
 		pval = of_get_property(np, &quot;sdr-base&quot;, NULL);
 		if (pval == NULL) {
<span class="p_del">-			printk(KERN_ERR &quot;PCIE: missing sdr-base for %s\n&quot;,</span>
<span class="p_del">-			       np-&gt;full_name);</span>
<span class="p_add">+			printk(KERN_ERR &quot;PCIE: missing sdr-base for %pOF\n&quot;,</span>
<span class="p_add">+			       np);</span>
 			return;
 		}
 		port-&gt;sdr_base = *pval;
<span class="p_chunk">@@ -2142,29 +2133,26 @@</span> <span class="p_context"> static void __init ppc4xx_probe_pciex_bridge(struct device_node *np)</span>
 	} else if (!strcmp(val, &quot;pci&quot;)) {
 		port-&gt;endpoint = 0;
 	} else {
<span class="p_del">-		printk(KERN_ERR &quot;PCIE: missing or incorrect device_type for %s\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;PCIE: missing or incorrect device_type for %pOF\n&quot;,</span>
<span class="p_add">+		       np);</span>
 		return;
 	}

 	/* Fetch config space registers address */
 	if (of_address_to_resource(np, 0, &amp;port-&gt;cfg_space)) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get PCI-E config space !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get PCI-E config space !&quot;, np);</span>
 		return;
 	}
 	/* Fetch host bridge internal registers address */
 	if (of_address_to_resource(np, 1, &amp;port-&gt;utl_regs)) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get UTL register base !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get UTL register base !&quot;, np);</span>
 		return;
 	}

 	/* Map DCRs */
 	dcrs = dcr_resource_start(np, 0);
 	if (dcrs == 0) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get DCR register base !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get DCR register base !&quot;, np);</span>
 		return;
 	}
 	port-&gt;dcrs = dcr_map(np, dcrs, dcr_resource_len(np, 0));
<span class="p_header">diff --git a/arch/powerpc/sysdev/ppc4xx_soc.c b/arch/powerpc/sysdev/ppc4xx_soc.c</span>
<span class="p_header">index d41134d2f786..5e36508b2a70 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/ppc4xx_soc.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/ppc4xx_soc.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static int __init ppc4xx_l2c_probe(void)</span>
 	/* Get l2 cache size */
 	prop = of_get_property(np, &quot;cache-size&quot;, NULL);
 	if (prop == NULL) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get cache-size!\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get cache-size!\n&quot;, np);</span>
 		of_node_put(np);
 		return -ENODEV;
 	}
<span class="p_chunk">@@ -99,8 +99,7 @@</span> <span class="p_context"> static int __init ppc4xx_l2c_probe(void)</span>
 	/* Map DCRs */
 	dcrreg = of_get_property(np, &quot;dcr-reg&quot;, &amp;len);
 	if (!dcrreg || (len != 4 * sizeof(u32))) {
<span class="p_del">-		printk(KERN_ERR &quot;%s: Can&#39;t get DCR register base !&quot;,</span>
<span class="p_del">-		       np-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;%pOF: Can&#39;t get DCR register base !&quot;, np);</span>
 		of_node_put(np);
 		return -ENODEV;
 	}
<span class="p_header">diff --git a/arch/powerpc/sysdev/scom.c b/arch/powerpc/sysdev/scom.c</span>
<span class="p_header">index 76ea32c1b664..0f6fd5d04d33 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/scom.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/scom.c</span>
<span class="p_chunk">@@ -194,12 +194,13 @@</span> <span class="p_context"> static int scom_debug_init_one(struct dentry *root, struct device_node *dn,</span>

 	ent-&gt;dn = of_node_get(dn);
 	snprintf(ent-&gt;name, 16, &quot;%08x&quot;, i);
<span class="p_del">-	ent-&gt;path.data = (void*) dn-&gt;full_name;</span>
<span class="p_del">-	ent-&gt;path.size = strlen(dn-&gt;full_name);</span>
<span class="p_add">+	ent-&gt;path.data = (void*)kasprintf(GFP_KERNEL, &quot;%pOF&quot;, dn);</span>
<span class="p_add">+	ent-&gt;path.size = strlen((char *)ent-&gt;path.data);</span>

 	dir = debugfs_create_dir(ent-&gt;name, root);
 	if (!dir) {
 		of_node_put(dn);
<span class="p_add">+		kfree(ent-&gt;path.data);</span>
 		kfree(ent);
 		return -1;
 	}
<span class="p_header">diff --git a/arch/powerpc/sysdev/simple_gpio.c b/arch/powerpc/sysdev/simple_gpio.c</span>
<span class="p_header">index 6afddae2fb47..f02d4576138c 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/simple_gpio.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/simple_gpio.c</span>
<span class="p_chunk">@@ -142,7 +142,6 @@</span> <span class="p_context"> void __init simple_gpiochip_init(const char *compatible)</span>
 		}
 		continue;
 err:
<span class="p_del">-		pr_err(&quot;%s: registration failed, status %d\n&quot;,</span>
<span class="p_del">-		       np-&gt;full_name, ret);</span>
<span class="p_add">+		pr_err(&quot;%pOF: registration failed, status %d\n&quot;, np, ret);</span>
 	}
 }
<span class="p_header">diff --git a/arch/powerpc/sysdev/tsi108_pci.c b/arch/powerpc/sysdev/tsi108_pci.c</span>
<span class="p_header">index 5692dd569b9b..28ff1f53cefc 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/tsi108_pci.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/tsi108_pci.c</span>
<span class="p_chunk">@@ -213,8 +213,8 @@</span> <span class="p_context"> int __init tsi108_setup_pci(struct device_node *dev, u32 cfg_phys, int primary)</span>
 	/* Get bus range if any */
 	bus_range = of_get_property(dev, &quot;bus-range&quot;, &amp;len);
 	if (bus_range == NULL || len &lt; 2 * sizeof(int)) {
<span class="p_del">-		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %s, assume&quot;</span>
<span class="p_del">-		       &quot; bus 0\n&quot;, dev-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_WARNING &quot;Can&#39;t get bus-range for %pOF, assume&quot;</span>
<span class="p_add">+		       &quot; bus 0\n&quot;, dev);</span>
 	}

 	hose = pcibios_alloc_controller(dev);
<span class="p_header">diff --git a/arch/powerpc/sysdev/uic.c b/arch/powerpc/sysdev/uic.c</span>
<span class="p_header">index a00949f3e378..8b4dd0da0839 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/uic.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/uic.c</span>
<span class="p_chunk">@@ -243,16 +243,16 @@</span> <span class="p_context"> static struct uic * __init uic_init_one(struct device_node *node)</span>
 	raw_spin_lock_init(&amp;uic-&gt;lock);
 	indexp = of_get_property(node, &quot;cell-index&quot;, &amp;len);
 	if (!indexp || (len != sizeof(u32))) {
<span class="p_del">-		printk(KERN_ERR &quot;uic: Device node %s has missing or invalid &quot;</span>
<span class="p_del">-		       &quot;cell-index property\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;uic: Device node %pOF has missing or invalid &quot;</span>
<span class="p_add">+		       &quot;cell-index property\n&quot;, node);</span>
 		return NULL;
 	}
 	uic-&gt;index = *indexp;

 	dcrreg = of_get_property(node, &quot;dcr-reg&quot;, &amp;len);
 	if (!dcrreg || (len != 2*sizeof(u32))) {
<span class="p_del">-		printk(KERN_ERR &quot;uic: Device node %s has missing or invalid &quot;</span>
<span class="p_del">-		       &quot;dcr-reg property\n&quot;, node-&gt;full_name);</span>
<span class="p_add">+		printk(KERN_ERR &quot;uic: Device node %pOF has missing or invalid &quot;</span>
<span class="p_add">+		       &quot;dcr-reg property\n&quot;, node);</span>
 		return NULL;
 	}
 	uic-&gt;dcrbase = *dcrreg;
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> void __init uic_init_tree(void)</span>
 		      * top-level interrupt controller */
 	primary_uic = uic_init_one(np);
 	if (!primary_uic)
<span class="p_del">-		panic(&quot;Unable to initialize primary UIC %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+		panic(&quot;Unable to initialize primary UIC %pOF\n&quot;, np);</span>

 	irq_set_default_host(primary_uic-&gt;irqhost);
 	of_node_put(np);
<span class="p_chunk">@@ -306,8 +306,8 @@</span> <span class="p_context"> void __init uic_init_tree(void)</span>

 			uic = uic_init_one(np);
 			if (! uic)
<span class="p_del">-				panic(&quot;Unable to initialize a secondary UIC %s\n&quot;,</span>
<span class="p_del">-				      np-&gt;full_name);</span>
<span class="p_add">+				panic(&quot;Unable to initialize a secondary UIC %pOF\n&quot;,</span>
<span class="p_add">+				      np);</span>

 			cascade_virq = irq_of_parse_and_map(np, 0);

<span class="p_header">diff --git a/arch/powerpc/sysdev/xive/native.c b/arch/powerpc/sysdev/xive/native.c</span>
<span class="p_header">index 0f95476b01f6..dd563c82046b 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/xive/native.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/xive/native.c</span>
<span class="p_chunk">@@ -551,7 +551,7 @@</span> <span class="p_context"> bool xive_native_init(void)</span>
 		pr_devel(&quot;not found !\n&quot;);
 		return false;
 	}
<span class="p_del">-	pr_devel(&quot;Found %s\n&quot;, np-&gt;full_name);</span>
<span class="p_add">+	pr_devel(&quot;Found %pOF\n&quot;, np);</span>

 	/* Resource 1 is HV window */
 	if (of_address_to_resource(np, 1, &amp;r)) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



