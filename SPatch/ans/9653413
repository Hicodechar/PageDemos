
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.10.7 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.10.7</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 30, 2017, 9:41 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170330094123.GB8346@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9653413/mbox/"
   >mbox</a>
|
   <a href="/patch/9653413/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9653413/">/patch/9653413/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E2AC3602C8 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Mar 2017 09:43:34 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D178828506
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Mar 2017 09:43:34 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C3EA528552; Thu, 30 Mar 2017 09:43:34 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 32AED28506
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Mar 2017 09:43:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932869AbdC3JmF (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 30 Mar 2017 05:42:05 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:52192 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932577AbdC3Jlw (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 30 Mar 2017 05:41:52 -0400
Received: from localhost (unknown [87.190.250.220])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id B5B3CB4B;
	Thu, 30 Mar 2017 09:41:46 +0000 (UTC)
Date: Thu, 30 Mar 2017 11:41:23 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.10.7
Message-ID: &lt;20170330094123.GB8346@kroah.com&gt;
References: &lt;20170330094118.GA8346@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170330094118.GA8346@kroah.com&gt;
User-Agent: Mutt/1.8.0 (2017-02-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - March 30, 2017, 9:41 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 23b6d29cb6da..976e8d1a468a 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 10
<span class="p_del">-SUBLEVEL = 6</span>
<span class="p_add">+SUBLEVEL = 7</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arm/boot/dts/sama5d2.dtsi b/arch/arm/boot/dts/sama5d2.dtsi</span>
<span class="p_header">index ceb9783ff7e1..ff7eae833a6d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sama5d2.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sama5d2.dtsi</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"></span>
 		};
 
 		usb1: ohci@00400000 {
<span class="p_del">-			compatible = &quot;atmel,sama5d2-ohci&quot;, &quot;usb-ohci&quot;;</span>
<span class="p_add">+			compatible = &quot;atmel,at91rm9200-ohci&quot;, &quot;usb-ohci&quot;;</span>
 			reg = &lt;0x00400000 0x100000&gt;;
 			interrupts = &lt;41 IRQ_TYPE_LEVEL_HIGH 2&gt;;
 			clocks = &lt;&amp;uhphs_clk&gt;, &lt;&amp;uhphs_clk&gt;, &lt;&amp;uhpck&gt;;
<span class="p_header">diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c</span>
<span class="p_header">index b4332b727e9c..31dde8b6f2ea 100644</span>
<span class="p_header">--- a/arch/arm/mach-at91/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-at91/pm.c</span>
<span class="p_chunk">@@ -289,6 +289,22 @@</span> <span class="p_context"> static void at91_ddr_standby(void)</span>
 		at91_ramc_write(1, AT91_DDRSDRC_LPR, saved_lpr1);
 }
 
<span class="p_add">+static void sama5d3_ddr_standby(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 lpr0;</span>
<span class="p_add">+	u32 saved_lpr0;</span>
<span class="p_add">+</span>
<span class="p_add">+	saved_lpr0 = at91_ramc_read(0, AT91_DDRSDRC_LPR);</span>
<span class="p_add">+	lpr0 = saved_lpr0 &amp; ~AT91_DDRSDRC_LPCB;</span>
<span class="p_add">+	lpr0 |= AT91_DDRSDRC_LPCB_POWER_DOWN;</span>
<span class="p_add">+</span>
<span class="p_add">+	at91_ramc_write(0, AT91_DDRSDRC_LPR, lpr0);</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu_do_idle();</span>
<span class="p_add">+</span>
<span class="p_add">+	at91_ramc_write(0, AT91_DDRSDRC_LPR, saved_lpr0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* We manage both DDRAM/SDRAM controllers, we need more than one value to
  * remember.
  */
<span class="p_chunk">@@ -323,7 +339,7 @@</span> <span class="p_context"> static const struct of_device_id const ramc_ids[] __initconst = {</span>
 	{ .compatible = &quot;atmel,at91rm9200-sdramc&quot;, .data = at91rm9200_standby },
 	{ .compatible = &quot;atmel,at91sam9260-sdramc&quot;, .data = at91sam9_sdram_standby },
 	{ .compatible = &quot;atmel,at91sam9g45-ddramc&quot;, .data = at91_ddr_standby },
<span class="p_del">-	{ .compatible = &quot;atmel,sama5d3-ddramc&quot;, .data = at91_ddr_standby },</span>
<span class="p_add">+	{ .compatible = &quot;atmel,sama5d3-ddramc&quot;, .data = sama5d3_ddr_standby },</span>
 	{ /*sentinel*/ }
 };
 
<span class="p_header">diff --git a/arch/arm64/kernel/kaslr.c b/arch/arm64/kernel/kaslr.c</span>
<span class="p_header">index 769f24ef628c..d7e90d97f5c4 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/kaslr.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/kaslr.c</span>
<span class="p_chunk">@@ -131,11 +131,15 @@</span> <span class="p_context"> u64 __init kaslr_early_init(u64 dt_phys, u64 modulo_offset)</span>
 	/*
 	 * The kernel Image should not extend across a 1GB/32MB/512MB alignment
 	 * boundary (for 4KB/16KB/64KB granule kernels, respectively). If this
<span class="p_del">-	 * happens, increase the KASLR offset by the size of the kernel image.</span>
<span class="p_add">+	 * happens, increase the KASLR offset by the size of the kernel image</span>
<span class="p_add">+	 * rounded up by SWAPPER_BLOCK_SIZE.</span>
 	 */
 	if ((((u64)_text + offset + modulo_offset) &gt;&gt; SWAPPER_TABLE_SHIFT) !=
<span class="p_del">-	    (((u64)_end + offset + modulo_offset) &gt;&gt; SWAPPER_TABLE_SHIFT))</span>
<span class="p_del">-		offset = (offset + (u64)(_end - _text)) &amp; mask;</span>
<span class="p_add">+	    (((u64)_end + offset + modulo_offset) &gt;&gt; SWAPPER_TABLE_SHIFT)) {</span>
<span class="p_add">+		u64 kimg_sz = _end - _text;</span>
<span class="p_add">+		offset = (offset + round_up(kimg_sz, SWAPPER_BLOCK_SIZE))</span>
<span class="p_add">+				&amp; mask;</span>
<span class="p_add">+	}</span>
 
 	if (IS_ENABLED(CONFIG_KASAN))
 		/*
<span class="p_header">diff --git a/arch/powerpc/kernel/idle_book3s.S b/arch/powerpc/kernel/idle_book3s.S</span>
<span class="p_header">index 72dac0b58061..b350ac5e3111 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/idle_book3s.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/idle_book3s.S</span>
<span class="p_chunk">@@ -439,9 +439,23 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)</span>
 _GLOBAL(pnv_wakeup_tb_loss)
 	ld	r1,PACAR1(r13)
 	/*
<span class="p_del">-	 * Before entering any idle state, the NVGPRs are saved in the stack</span>
<span class="p_del">-	 * and they are restored before switching to the process context. Hence</span>
<span class="p_del">-	 * until they are restored, they are free to be used.</span>
<span class="p_add">+	 * Before entering any idle state, the NVGPRs are saved in the stack.</span>
<span class="p_add">+	 * If there was a state loss, or PACA_NAPSTATELOST was set, then the</span>
<span class="p_add">+	 * NVGPRs are restored. If we are here, it is likely that state is lost,</span>
<span class="p_add">+	 * but not guaranteed -- neither ISA207 nor ISA300 tests to reach</span>
<span class="p_add">+	 * here are the same as the test to restore NVGPRS:</span>
<span class="p_add">+	 * PACA_THREAD_IDLE_STATE test for ISA207, PSSCR test for ISA300,</span>
<span class="p_add">+	 * and SRR1 test for restoring NVGPRs.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We are about to clobber NVGPRs now, so set NAPSTATELOST to</span>
<span class="p_add">+	 * guarantee they will always be restored. This might be tightened</span>
<span class="p_add">+	 * with careful reading of specs (particularly for ISA300) but this</span>
<span class="p_add">+	 * is already a slow wakeup path and it&#39;s simpler to be safe.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	li	r0,1</span>
<span class="p_add">+	stb	r0,PACA_NAPSTATELOST(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 *
 	 * Save SRR1 and LR in NVGPRs as they might be clobbered in
 	 * opal_call() (called in CHECK_HMI_INTERRUPT). SRR1 is required
<span class="p_header">diff --git a/arch/x86/pci/xen.c b/arch/x86/pci/xen.c</span>
<span class="p_header">index e1fb269c87af..292ab0364a89 100644</span>
<span class="p_header">--- a/arch/x86/pci/xen.c</span>
<span class="p_header">+++ b/arch/x86/pci/xen.c</span>
<span class="p_chunk">@@ -234,23 +234,14 @@</span> <span class="p_context"> static int xen_hvm_setup_msi_irqs(struct pci_dev *dev, int nvec, int type)</span>
 		return 1;
 
 	for_each_pci_msi_entry(msidesc, dev) {
<span class="p_del">-		__pci_read_msi_msg(msidesc, &amp;msg);</span>
<span class="p_del">-		pirq = MSI_ADDR_EXT_DEST_ID(msg.address_hi) |</span>
<span class="p_del">-			((msg.address_lo &gt;&gt; MSI_ADDR_DEST_ID_SHIFT) &amp; 0xff);</span>
<span class="p_del">-		if (msg.data != XEN_PIRQ_MSI_DATA ||</span>
<span class="p_del">-		    xen_irq_from_pirq(pirq) &lt; 0) {</span>
<span class="p_del">-			pirq = xen_allocate_pirq_msi(dev, msidesc);</span>
<span class="p_del">-			if (pirq &lt; 0) {</span>
<span class="p_del">-				irq = -ENODEV;</span>
<span class="p_del">-				goto error;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			xen_msi_compose_msg(dev, pirq, &amp;msg);</span>
<span class="p_del">-			__pci_write_msi_msg(msidesc, &amp;msg);</span>
<span class="p_del">-			dev_dbg(&amp;dev-&gt;dev, &quot;xen: msi bound to pirq=%d\n&quot;, pirq);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			dev_dbg(&amp;dev-&gt;dev,</span>
<span class="p_del">-				&quot;xen: msi already bound to pirq=%d\n&quot;, pirq);</span>
<span class="p_add">+		pirq = xen_allocate_pirq_msi(dev, msidesc);</span>
<span class="p_add">+		if (pirq &lt; 0) {</span>
<span class="p_add">+			irq = -ENODEV;</span>
<span class="p_add">+			goto error;</span>
 		}
<span class="p_add">+		xen_msi_compose_msg(dev, pirq, &amp;msg);</span>
<span class="p_add">+		__pci_write_msi_msg(msidesc, &amp;msg);</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;xen: msi bound to pirq=%d\n&quot;, pirq);</span>
 		irq = xen_bind_pirq_msi_to_irq(dev, msidesc, pirq,
 					       (type == PCI_CAP_ID_MSI) ? nvec : 1,
 					       (type == PCI_CAP_ID_MSIX) ?
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index c3400b5444a7..3b57e75098c3 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -678,17 +678,8 @@</span> <span class="p_context"> static void blk_mq_check_expired(struct blk_mq_hw_ctx *hctx,</span>
 {
 	struct blk_mq_timeout_data *data = priv;
 
<span class="p_del">-	if (!test_bit(REQ_ATOM_STARTED, &amp;rq-&gt;atomic_flags)) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If a request wasn&#39;t started before the queue was</span>
<span class="p_del">-		 * marked dying, kill it here or it&#39;ll go unnoticed.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (unlikely(blk_queue_dying(rq-&gt;q))) {</span>
<span class="p_del">-			rq-&gt;errors = -EIO;</span>
<span class="p_del">-			blk_mq_end_request(rq, rq-&gt;errors);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (!test_bit(REQ_ATOM_STARTED, &amp;rq-&gt;atomic_flags))</span>
 		return;
<span class="p_del">-	}</span>
 
 	if (time_after_eq(jiffies, rq-&gt;deadline)) {
 		if (!blk_mark_rq_complete(rq))
<span class="p_header">diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c</span>
<span class="p_header">index d19b09cdf284..54fc90e8339c 100644</span>
<span class="p_header">--- a/crypto/algif_hash.c</span>
<span class="p_header">+++ b/crypto/algif_hash.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static int hash_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	struct alg_sock *ask = alg_sk(sk);
 	struct hash_ctx *ctx = ask-&gt;private;
 	struct ahash_request *req = &amp;ctx-&gt;req;
<span class="p_del">-	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req))];</span>
<span class="p_add">+	char state[crypto_ahash_statesize(crypto_ahash_reqtfm(req)) ? : 1];</span>
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
<span class="p_header">diff --git a/drivers/auxdisplay/img-ascii-lcd.c b/drivers/auxdisplay/img-ascii-lcd.c</span>
<span class="p_header">index bf43b5d2aafc..83f1439e57fd 100644</span>
<span class="p_header">--- a/drivers/auxdisplay/img-ascii-lcd.c</span>
<span class="p_header">+++ b/drivers/auxdisplay/img-ascii-lcd.c</span>
<span class="p_chunk">@@ -218,6 +218,7 @@</span> <span class="p_context"> static const struct of_device_id img_ascii_lcd_matches[] = {</span>
 	{ .compatible = &quot;img,boston-lcd&quot;, .data = &amp;boston_config },
 	{ .compatible = &quot;mti,malta-lcd&quot;, .data = &amp;malta_config },
 	{ .compatible = &quot;mti,sead3-lcd&quot;, .data = &amp;sead3_config },
<span class="p_add">+	{ /* sentinel */ }</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/char/hw_random/amd-rng.c b/drivers/char/hw_random/amd-rng.c</span>
<span class="p_header">index 4a99ac756f08..9959c762da2f 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/amd-rng.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/amd-rng.c</span>
<span class="p_chunk">@@ -55,6 +55,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(pci, pci_tbl);</span>
 struct amd768_priv {
 	void __iomem *iobase;
 	struct pci_dev *pcidev;
<span class="p_add">+	u32 pmbase;</span>
 };
 
 static int amd_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)
<span class="p_chunk">@@ -148,33 +149,58 @@</span> <span class="p_context"> static int __init mod_init(void)</span>
 	if (pmbase == 0)
 		return -EIO;
 
<span class="p_del">-	priv = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
 	if (!priv)
 		return -ENOMEM;
 
<span class="p_del">-	if (!devm_request_region(&amp;pdev-&gt;dev, pmbase + PMBASE_OFFSET,</span>
<span class="p_del">-				PMBASE_SIZE, DRV_NAME)) {</span>
<span class="p_add">+	if (!request_region(pmbase + PMBASE_OFFSET, PMBASE_SIZE, DRV_NAME)) {</span>
 		dev_err(&amp;pdev-&gt;dev, DRV_NAME &quot; region 0x%x already in use!\n&quot;,
 			pmbase + 0xF0);
<span class="p_del">-		return -EBUSY;</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+		goto out;</span>
 	}
 
<span class="p_del">-	priv-&gt;iobase = devm_ioport_map(&amp;pdev-&gt;dev, pmbase + PMBASE_OFFSET,</span>
<span class="p_del">-			PMBASE_SIZE);</span>
<span class="p_add">+	priv-&gt;iobase = ioport_map(pmbase + PMBASE_OFFSET, PMBASE_SIZE);</span>
 	if (!priv-&gt;iobase) {
 		pr_err(DRV_NAME &quot;Cannot map ioport\n&quot;);
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		goto err_iomap;</span>
 	}
 
 	amd_rng.priv = (unsigned long)priv;
<span class="p_add">+	priv-&gt;pmbase = pmbase;</span>
 	priv-&gt;pcidev = pdev;
 
 	pr_info(DRV_NAME &quot; detected\n&quot;);
<span class="p_del">-	return devm_hwrng_register(&amp;pdev-&gt;dev, &amp;amd_rng);</span>
<span class="p_add">+	err = hwrng_register(&amp;amd_rng);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		pr_err(DRV_NAME &quot; registering failed (%d)\n&quot;, err);</span>
<span class="p_add">+		goto err_hwrng;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_hwrng:</span>
<span class="p_add">+	ioport_unmap(priv-&gt;iobase);</span>
<span class="p_add">+err_iomap:</span>
<span class="p_add">+	release_region(pmbase + PMBASE_OFFSET, PMBASE_SIZE);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(priv);</span>
<span class="p_add">+	return err;</span>
 }
 
 static void __exit mod_exit(void)
 {
<span class="p_add">+	struct amd768_priv *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = (struct amd768_priv *)amd_rng.priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	hwrng_unregister(&amp;amd_rng);</span>
<span class="p_add">+</span>
<span class="p_add">+	ioport_unmap(priv-&gt;iobase);</span>
<span class="p_add">+</span>
<span class="p_add">+	release_region(priv-&gt;pmbase + PMBASE_OFFSET, PMBASE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(priv);</span>
 }
 
 module_init(mod_init);
<span class="p_header">diff --git a/drivers/char/hw_random/geode-rng.c b/drivers/char/hw_random/geode-rng.c</span>
<span class="p_header">index e7a245942029..e1d421a36a13 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/geode-rng.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/geode-rng.c</span>
<span class="p_chunk">@@ -31,6 +31,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/pci.h&gt;
 
<span class="p_add">+</span>
<span class="p_add">+#define PFX	KBUILD_MODNAME &quot;: &quot;</span>
<span class="p_add">+</span>
 #define GEODE_RNG_DATA_REG   0x50
 #define GEODE_RNG_STATUS_REG 0x54
 
<span class="p_chunk">@@ -82,6 +85,7 @@</span> <span class="p_context"> static struct hwrng geode_rng = {</span>
 
 static int __init mod_init(void)
 {
<span class="p_add">+	int err = -ENODEV;</span>
 	struct pci_dev *pdev = NULL;
 	const struct pci_device_id *ent;
 	void __iomem *mem;
<span class="p_chunk">@@ -89,27 +93,43 @@</span> <span class="p_context"> static int __init mod_init(void)</span>
 
 	for_each_pci_dev(pdev) {
 		ent = pci_match_id(pci_tbl, pdev);
<span class="p_del">-		if (ent) {</span>
<span class="p_del">-			rng_base = pci_resource_start(pdev, 0);</span>
<span class="p_del">-			if (rng_base == 0)</span>
<span class="p_del">-				return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_del">-			mem = devm_ioremap(&amp;pdev-&gt;dev, rng_base, 0x58);</span>
<span class="p_del">-			if (!mem)</span>
<span class="p_del">-				return -ENOMEM;</span>
<span class="p_del">-			geode_rng.priv = (unsigned long)mem;</span>
<span class="p_del">-</span>
<span class="p_del">-			pr_info(&quot;AMD Geode RNG detected\n&quot;);</span>
<span class="p_del">-			return devm_hwrng_register(&amp;pdev-&gt;dev, &amp;geode_rng);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (ent)</span>
<span class="p_add">+			goto found;</span>
 	}
<span class="p_del">-</span>
 	/* Device not found. */
<span class="p_del">-	return -ENODEV;</span>
<span class="p_add">+	goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+found:</span>
<span class="p_add">+	rng_base = pci_resource_start(pdev, 0);</span>
<span class="p_add">+	if (rng_base == 0)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	err = -ENOMEM;</span>
<span class="p_add">+	mem = ioremap(rng_base, 0x58);</span>
<span class="p_add">+	if (!mem)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	geode_rng.priv = (unsigned long)mem;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;AMD Geode RNG detected\n&quot;);</span>
<span class="p_add">+	err = hwrng_register(&amp;geode_rng);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		pr_err(PFX &quot;RNG registering failed (%d)\n&quot;,</span>
<span class="p_add">+		       err);</span>
<span class="p_add">+		goto err_unmap;</span>
<span class="p_add">+	}</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+</span>
<span class="p_add">+err_unmap:</span>
<span class="p_add">+	iounmap(mem);</span>
<span class="p_add">+	goto out;</span>
 }
 
 static void __exit mod_exit(void)
 {
<span class="p_add">+	void __iomem *mem = (void __iomem *)geode_rng.priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	hwrng_unregister(&amp;geode_rng);</span>
<span class="p_add">+	iounmap(mem);</span>
 }
 
 module_init(mod_init);
<span class="p_header">diff --git a/drivers/char/ppdev.c b/drivers/char/ppdev.c</span>
<span class="p_header">index 87885d146dbb..a372fef7654b 100644</span>
<span class="p_header">--- a/drivers/char/ppdev.c</span>
<span class="p_header">+++ b/drivers/char/ppdev.c</span>
<span class="p_chunk">@@ -84,11 +84,14 @@</span> <span class="p_context"> struct pp_struct {</span>
 	struct ieee1284_info state;
 	struct ieee1284_info saved_state;
 	long default_inactivity;
<span class="p_add">+	int index;</span>
 };
 
 /* should we use PARDEVICE_MAX here? */
 static struct device *devices[PARPORT_MAX];
 
<span class="p_add">+static DEFINE_IDA(ida_index);</span>
<span class="p_add">+</span>
 /* pp_struct.flags bitfields */
 #define PP_CLAIMED    (1&lt;&lt;0)
 #define PP_EXCL       (1&lt;&lt;1)
<span class="p_chunk">@@ -290,7 +293,7 @@</span> <span class="p_context"> static int register_device(int minor, struct pp_struct *pp)</span>
 	struct pardevice *pdev = NULL;
 	char *name;
 	struct pardev_cb ppdev_cb;
<span class="p_del">-	int rc = 0;</span>
<span class="p_add">+	int rc = 0, index;</span>
 
 	name = kasprintf(GFP_KERNEL, CHRDEV &quot;%x&quot;, minor);
 	if (name == NULL)
<span class="p_chunk">@@ -303,20 +306,23 @@</span> <span class="p_context"> static int register_device(int minor, struct pp_struct *pp)</span>
 		goto err;
 	}
 
<span class="p_add">+	index = ida_simple_get(&amp;ida_index, 0, 0, GFP_KERNEL);</span>
 	memset(&amp;ppdev_cb, 0, sizeof(ppdev_cb));
 	ppdev_cb.irq_func = pp_irq;
 	ppdev_cb.flags = (pp-&gt;flags &amp; PP_EXCL) ? PARPORT_FLAG_EXCL : 0;
 	ppdev_cb.private = pp;
<span class="p_del">-	pdev = parport_register_dev_model(port, name, &amp;ppdev_cb, minor);</span>
<span class="p_add">+	pdev = parport_register_dev_model(port, name, &amp;ppdev_cb, index);</span>
 	parport_put_port(port);
 
 	if (!pdev) {
 		pr_warn(&quot;%s: failed to register device!\n&quot;, name);
 		rc = -ENXIO;
<span class="p_add">+		ida_simple_remove(&amp;ida_index, index);</span>
 		goto err;
 	}
 
 	pp-&gt;pdev = pdev;
<span class="p_add">+	pp-&gt;index = index;</span>
 	dev_dbg(&amp;pdev-&gt;dev, &quot;registered pardevice\n&quot;);
 err:
 	kfree(name);
<span class="p_chunk">@@ -755,6 +761,7 @@</span> <span class="p_context"> static int pp_release(struct inode *inode, struct file *file)</span>
 
 	if (pp-&gt;pdev) {
 		parport_unregister_device(pp-&gt;pdev);
<span class="p_add">+		ida_simple_remove(&amp;ida_index, pp-&gt;index);</span>
 		pp-&gt;pdev = NULL;
 		pr_debug(CHRDEV &quot;%x: unregistered pardevice\n&quot;, minor);
 	}
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">index fc75a335a7ce..8ca07fe8d3f3 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_chunk">@@ -608,7 +608,7 @@</span> <span class="p_context"> static SUNXI_CCU_M_WITH_MUX_GATE(hdmi_clk, &quot;hdmi&quot;, lcd_ch1_parents,</span>
 				 0x150, 0, 4, 24, 2, BIT(31),
 				 CLK_SET_RATE_PARENT);
 
<span class="p_del">-static SUNXI_CCU_GATE(hdmi_ddc_clk, &quot;hdmi-ddc&quot;, &quot;osc24M&quot;, 0x150, BIT(31), 0);</span>
<span class="p_add">+static SUNXI_CCU_GATE(hdmi_ddc_clk, &quot;hdmi-ddc&quot;, &quot;osc24M&quot;, 0x150, BIT(30), 0);</span>
 
 static SUNXI_CCU_GATE(ps_clk, &quot;ps&quot;, &quot;lcd1-ch1&quot;, 0x140, BIT(31), 0);
 
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu_mp.c b/drivers/clk/sunxi-ng/ccu_mp.c</span>
<span class="p_header">index ebb1b31568a5..ee7810429c30 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu_mp.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu_mp.c</span>
<span class="p_chunk">@@ -85,6 +85,10 @@</span> <span class="p_context"> static unsigned long ccu_mp_recalc_rate(struct clk_hw *hw,</span>
 	unsigned int m, p;
 	u32 reg;
 
<span class="p_add">+	/* Adjust parent_rate according to pre-dividers */</span>
<span class="p_add">+	ccu_mux_helper_adjust_parent_for_prediv(&amp;cmp-&gt;common, &amp;cmp-&gt;mux,</span>
<span class="p_add">+						-1, &amp;parent_rate);</span>
<span class="p_add">+</span>
 	reg = readl(cmp-&gt;common.base + cmp-&gt;common.reg);
 
 	m = reg &gt;&gt; cmp-&gt;m.shift;
<span class="p_chunk">@@ -114,6 +118,10 @@</span> <span class="p_context"> static int ccu_mp_set_rate(struct clk_hw *hw, unsigned long rate,</span>
 	unsigned int m, p;
 	u32 reg;
 
<span class="p_add">+	/* Adjust parent_rate according to pre-dividers */</span>
<span class="p_add">+	ccu_mux_helper_adjust_parent_for_prediv(&amp;cmp-&gt;common, &amp;cmp-&gt;mux,</span>
<span class="p_add">+						-1, &amp;parent_rate);</span>
<span class="p_add">+</span>
 	max_m = cmp-&gt;m.max ?: 1 &lt;&lt; cmp-&gt;m.width;
 	max_p = cmp-&gt;p.max ?: 1 &lt;&lt; ((1 &lt;&lt; cmp-&gt;p.width) - 1);
 
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">index 061b165d632e..0af2229b09fb 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq.c</span>
<span class="p_chunk">@@ -1190,6 +1190,9 @@</span> <span class="p_context"> static int cpufreq_online(unsigned int cpu)</span>
 		for_each_cpu(j, policy-&gt;related_cpus)
 			per_cpu(cpufreq_cpu_data, j) = policy;
 		write_unlock_irqrestore(&amp;cpufreq_driver_lock, flags);
<span class="p_add">+	} else {</span>
<span class="p_add">+		policy-&gt;min = policy-&gt;user_policy.min;</span>
<span class="p_add">+		policy-&gt;max = policy-&gt;user_policy.max;</span>
 	}
 
 	if (cpufreq_driver-&gt;get &amp;&amp; !cpufreq_driver-&gt;setpolicy) {
<span class="p_header">diff --git a/drivers/cpuidle/sysfs.c b/drivers/cpuidle/sysfs.c</span>
<span class="p_header">index c5adc8c9ac43..ae948b1da93a 100644</span>
<span class="p_header">--- a/drivers/cpuidle/sysfs.c</span>
<span class="p_header">+++ b/drivers/cpuidle/sysfs.c</span>
<span class="p_chunk">@@ -615,6 +615,18 @@</span> <span class="p_context"> int cpuidle_add_sysfs(struct cpuidle_device *dev)</span>
 	struct device *cpu_dev = get_cpu_device((unsigned long)dev-&gt;cpu);
 	int error;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Return if cpu_device is not setup for this CPU.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This could happen if the arch did not set up cpu_device</span>
<span class="p_add">+	 * since this CPU is not in cpu_present mask and the</span>
<span class="p_add">+	 * driver did not send a correct CPU mask during registration.</span>
<span class="p_add">+	 * Without this check we would end up passing bogus</span>
<span class="p_add">+	 * value for &amp;cpu_dev-&gt;kobj in kobject_init_and_add()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cpu_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	kdev = kzalloc(sizeof(*kdev), GFP_KERNEL);
 	if (!kdev)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-dev.c b/drivers/crypto/ccp/ccp-dev.c</span>
<span class="p_header">index 511ab042b5e7..92d1c6959f08 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-dev.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-dev.c</span>
<span class="p_chunk">@@ -283,11 +283,14 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ccp_version);</span>
  */
 int ccp_enqueue_cmd(struct ccp_cmd *cmd)
 {
<span class="p_del">-	struct ccp_device *ccp = ccp_get_device();</span>
<span class="p_add">+	struct ccp_device *ccp;</span>
 	unsigned long flags;
 	unsigned int i;
 	int ret;
 
<span class="p_add">+	/* Some commands might need to be sent to a specific device */</span>
<span class="p_add">+	ccp = cmd-&gt;ccp ? cmd-&gt;ccp : ccp_get_device();</span>
<span class="p_add">+</span>
 	if (!ccp)
 		return -ENODEV;
 
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-dmaengine.c b/drivers/crypto/ccp/ccp-dmaengine.c</span>
<span class="p_header">index e5d9278f4019..8d0eeb46d4a2 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-dmaengine.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-dmaengine.c</span>
<span class="p_chunk">@@ -390,6 +390,7 @@</span> <span class="p_context"> static struct ccp_dma_desc *ccp_create_desc(struct dma_chan *dma_chan,</span>
 			goto err;
 
 		ccp_cmd = &amp;cmd-&gt;ccp_cmd;
<span class="p_add">+		ccp_cmd-&gt;ccp = chan-&gt;ccp;</span>
 		ccp_pt = &amp;ccp_cmd-&gt;u.passthru_nomap;
 		ccp_cmd-&gt;flags = CCP_CMD_MAY_BACKLOG;
 		ccp_cmd-&gt;flags |= CCP_CMD_PASSTHRU_NO_DMA_MAP;
<span class="p_header">diff --git a/drivers/dax/dax.c b/drivers/dax/dax.c</span>
<span class="p_header">index ed758b74ddf0..20ab6bf9d1c7 100644</span>
<span class="p_header">--- a/drivers/dax/dax.c</span>
<span class="p_header">+++ b/drivers/dax/dax.c</span>
<span class="p_chunk">@@ -427,6 +427,7 @@</span> <span class="p_context"> static int __dax_dev_fault(struct dax_dev *dax_dev, struct vm_area_struct *vma,</span>
 	int rc = VM_FAULT_SIGBUS;
 	phys_addr_t phys;
 	pfn_t pfn;
<span class="p_add">+	unsigned int fault_size = PAGE_SIZE;</span>
 
 	if (check_vma(dax_dev, vma, __func__))
 		return VM_FAULT_SIGBUS;
<span class="p_chunk">@@ -437,6 +438,9 @@</span> <span class="p_context"> static int __dax_dev_fault(struct dax_dev *dax_dev, struct vm_area_struct *vma,</span>
 		return VM_FAULT_SIGBUS;
 	}
 
<span class="p_add">+	if (fault_size != dax_region-&gt;align)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
<span class="p_add">+</span>
 	phys = pgoff_to_phys(dax_dev, vmf-&gt;pgoff, PAGE_SIZE);
 	if (phys == -1) {
 		dev_dbg(dev, &quot;%s: phys_to_pgoff(%#lx) failed\n&quot;, __func__,
<span class="p_chunk">@@ -482,6 +486,7 @@</span> <span class="p_context"> static int __dax_dev_pmd_fault(struct dax_dev *dax_dev,</span>
 	phys_addr_t phys;
 	pgoff_t pgoff;
 	pfn_t pfn;
<span class="p_add">+	unsigned int fault_size = PMD_SIZE;</span>
 
 	if (check_vma(dax_dev, vma, __func__))
 		return VM_FAULT_SIGBUS;
<span class="p_chunk">@@ -498,6 +503,16 @@</span> <span class="p_context"> static int __dax_dev_pmd_fault(struct dax_dev *dax_dev,</span>
 		return VM_FAULT_SIGBUS;
 	}
 
<span class="p_add">+	if (fault_size &lt; dax_region-&gt;align)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
<span class="p_add">+	else if (fault_size &gt; dax_region-&gt;align)</span>
<span class="p_add">+		return VM_FAULT_FALLBACK;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if we are outside of the VMA */</span>
<span class="p_add">+	if (pmd_addr &lt; vma-&gt;vm_start ||</span>
<span class="p_add">+			(pmd_addr + PMD_SIZE) &gt; vma-&gt;vm_end)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
<span class="p_add">+</span>
 	pgoff = linear_page_index(vma, pmd_addr);
 	phys = pgoff_to_phys(dax_dev, pgoff, PMD_SIZE);
 	if (phys == -1) {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c</span>
<span class="p_header">index 2534adaebe30..f48da3d6698d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c</span>
<span class="p_chunk">@@ -424,6 +424,7 @@</span> <span class="p_context"> static const struct pci_device_id pciidlist[] = {</span>
 	{0x1002, 0x6985, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
 	{0x1002, 0x6986, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
 	{0x1002, 0x6987, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
<span class="p_add">+	{0x1002, 0x6995, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},</span>
 	{0x1002, 0x699F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
 
 	{0, 0, 0}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/si_dpm.c b/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_header">index 9a5ccae06b6c..054c9c29536d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_chunk">@@ -3498,9 +3498,13 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct amdgpu_device *adev,</span>
 			max_sclk = 75000;
 		}
 	} else if (adev-&gt;asic_type == CHIP_OLAND) {
<span class="p_del">-		if ((adev-&gt;pdev-&gt;device == 0x6604) &amp;&amp;</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;subsystem_vendor == 0x1028) &amp;&amp;</span>
<span class="p_del">-		    (adev-&gt;pdev-&gt;subsystem_device == 0x066F)) {</span>
<span class="p_add">+		if ((adev-&gt;pdev-&gt;revision == 0xC7) ||</span>
<span class="p_add">+		    (adev-&gt;pdev-&gt;revision == 0x80) ||</span>
<span class="p_add">+		    (adev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (adev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		    (adev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_add">+		    (adev-&gt;pdev-&gt;device == 0x6604) ||</span>
<span class="p_add">+		    (adev-&gt;pdev-&gt;device == 0x6605)) {</span>
 			max_sclk = 75000;
 		}
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">index 55e7372ea0a0..205251fae539 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_chunk">@@ -1389,6 +1389,15 @@</span> <span class="p_context"> static int stall_checks(struct drm_crtc *crtc, bool nonblock)</span>
 	return ret &lt; 0 ? ret : 0;
 }
 
<span class="p_add">+void release_crtc_commit(struct completion *completion)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_crtc_commit *commit = container_of(completion,</span>
<span class="p_add">+						      typeof(*commit),</span>
<span class="p_add">+						      flip_done);</span>
<span class="p_add">+</span>
<span class="p_add">+	drm_crtc_commit_put(commit);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * drm_atomic_helper_setup_commit - setup possibly nonblocking commit
  * @state: new modeset state to be committed
<span class="p_chunk">@@ -1481,6 +1490,8 @@</span> <span class="p_context"> int drm_atomic_helper_setup_commit(struct drm_atomic_state *state,</span>
 		}
 
 		crtc_state-&gt;event-&gt;base.completion = &amp;commit-&gt;flip_done;
<span class="p_add">+		crtc_state-&gt;event-&gt;base.completion_release = release_crtc_commit;</span>
<span class="p_add">+		drm_crtc_commit_get(commit);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">index 5d96de40b63f..30c20f90520a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_chunk">@@ -689,8 +689,8 @@</span> <span class="p_context"> void drm_send_event_locked(struct drm_device *dev, struct drm_pending_event *e)</span>
 	assert_spin_locked(&amp;dev-&gt;event_lock);
 
 	if (e-&gt;completion) {
<span class="p_del">-		/* -&gt;completion might disappear as soon as it signalled. */</span>
 		complete_all(e-&gt;completion);
<span class="p_add">+		e-&gt;completion_release(e-&gt;completion);</span>
 		e-&gt;completion = NULL;
 	}
 
<span class="p_header">diff --git a/drivers/hid/hid-sony.c b/drivers/hid/hid-sony.c</span>
<span class="p_header">index f405b07d0381..740996f9bdd4 100644</span>
<span class="p_header">--- a/drivers/hid/hid-sony.c</span>
<span class="p_header">+++ b/drivers/hid/hid-sony.c</span>
<span class="p_chunk">@@ -2632,6 +2632,8 @@</span> <span class="p_context"> static int sony_input_configured(struct hid_device *hdev,</span>
 		sony_leds_remove(sc);
 	if (sc-&gt;quirks &amp; SONY_BATTERY_SUPPORT)
 		sony_battery_remove(sc);
<span class="p_add">+	if (sc-&gt;touchpad)</span>
<span class="p_add">+		sony_unregister_touchpad(sc);</span>
 	sony_cancel_work_sync(sc);
 	kfree(sc-&gt;output_report_dmabuf);
 	sony_remove_dev_list(sc);
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index be34547cdb68..1606e7f08f4b 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -506,12 +506,15 @@</span> <span class="p_context"> int vmbus_teardown_gpadl(struct vmbus_channel *channel, u32 gpadl_handle)</span>
 
 	wait_for_completion(&amp;info-&gt;waitevent);
 
<span class="p_del">-	if (channel-&gt;rescind) {</span>
<span class="p_del">-		ret = -ENODEV;</span>
<span class="p_del">-		goto post_msg_err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 post_msg_err:
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the channel has been rescinded;</span>
<span class="p_add">+	 * we will be awakened by the rescind</span>
<span class="p_add">+	 * handler; set the error code to zero so we don&#39;t leak memory.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (channel-&gt;rescind)</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;vmbus_connection.channelmsg_lock, flags);
 	list_del(&amp;info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 0af7e39006c8..a58cd102af1b 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -779,6 +779,7 @@</span> <span class="p_context"> static void vmbus_onoffer(struct vmbus_channel_message_header *hdr)</span>
 	/* Allocate the channel object and save this offer. */
 	newchannel = alloc_channel();
 	if (!newchannel) {
<span class="p_add">+		vmbus_release_relid(offer-&gt;child_relid);</span>
 		pr_err(&quot;Unable to allocate channel object\n&quot;);
 		return;
 	}
<span class="p_header">diff --git a/drivers/hwtracing/intel_th/core.c b/drivers/hwtracing/intel_th/core.c</span>
<span class="p_header">index cdd9b3b26195..7563eceeaaea 100644</span>
<span class="p_header">--- a/drivers/hwtracing/intel_th/core.c</span>
<span class="p_header">+++ b/drivers/hwtracing/intel_th/core.c</span>
<span class="p_chunk">@@ -221,8 +221,10 @@</span> <span class="p_context"> static int intel_th_output_activate(struct intel_th_device *thdev)</span>
 	else
 		intel_th_trace_enable(thdev);
 
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
 		pm_runtime_put(&amp;thdev-&gt;dev);
<span class="p_add">+		module_put(thdrv-&gt;driver.owner);</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">index ad9dec30bb30..4282ceca3d8f 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_chunk">@@ -169,7 +169,9 @@</span> <span class="p_context"> static irqreturn_t tiadc_irq_h(int irq, void *private)</span>
 {
 	struct iio_dev *indio_dev = private;
 	struct tiadc_device *adc_dev = iio_priv(indio_dev);
<span class="p_del">-	unsigned int status, config;</span>
<span class="p_add">+	unsigned int status, config, adc_fsm;</span>
<span class="p_add">+	unsigned short count = 0;</span>
<span class="p_add">+</span>
 	status = tiadc_readl(adc_dev, REG_IRQSTATUS);
 
 	/*
<span class="p_chunk">@@ -183,6 +185,15 @@</span> <span class="p_context"> static irqreturn_t tiadc_irq_h(int irq, void *private)</span>
 		tiadc_writel(adc_dev, REG_CTRL, config);
 		tiadc_writel(adc_dev, REG_IRQSTATUS, IRQENB_FIFO1OVRRUN
 				| IRQENB_FIFO1UNDRFLW | IRQENB_FIFO1THRES);
<span class="p_add">+</span>
<span class="p_add">+		/* wait for idle state.</span>
<span class="p_add">+		 * ADC needs to finish the current conversion</span>
<span class="p_add">+		 * before disabling the module</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			adc_fsm = tiadc_readl(adc_dev, REG_ADCFSM);</span>
<span class="p_add">+		} while (adc_fsm != 0x10 &amp;&amp; count++ &lt; 100);</span>
<span class="p_add">+</span>
 		tiadc_writel(adc_dev, REG_CTRL, (config | CNTRLREG_TSCSSENB));
 		return IRQ_HANDLED;
 	} else if (status &amp; IRQENB_FIFO1THRES) {
<span class="p_header">diff --git a/drivers/iio/common/hid-sensors/hid-sensor-trigger.c b/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_header">index a3cce3a38300..ecf592d69043 100644</span>
<span class="p_header">--- a/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_header">+++ b/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_chunk">@@ -51,8 +51,6 @@</span> <span class="p_context"> static int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 			st-&gt;report_state.report_id,
 			st-&gt;report_state.index,
 			HID_USAGE_SENSOR_PROP_REPORTING_STATE_ALL_EVENTS_ENUM);
<span class="p_del">-</span>
<span class="p_del">-		poll_value = hid_sensor_read_poll_value(st);</span>
 	} else {
 		int val;
 
<span class="p_chunk">@@ -89,7 +87,9 @@</span> <span class="p_context"> static int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 	sensor_hub_get_feature(st-&gt;hsdev, st-&gt;power_state.report_id,
 			       st-&gt;power_state.index,
 			       sizeof(state_val), &amp;state_val);
<span class="p_del">-	if (state &amp;&amp; poll_value)</span>
<span class="p_add">+	if (state)</span>
<span class="p_add">+		poll_value = hid_sensor_read_poll_value(st);</span>
<span class="p_add">+	if (poll_value &gt; 0)</span>
 		msleep_interruptible(poll_value * 2);
 
 	return 0;
<span class="p_header">diff --git a/drivers/iio/magnetometer/ak8974.c b/drivers/iio/magnetometer/ak8974.c</span>
<span class="p_header">index ce09d771c1fb..75f83424903b 100644</span>
<span class="p_header">--- a/drivers/iio/magnetometer/ak8974.c</span>
<span class="p_header">+++ b/drivers/iio/magnetometer/ak8974.c</span>
<span class="p_chunk">@@ -767,7 +767,7 @@</span> <span class="p_context"> static int ak8974_probe(struct i2c_client *i2c,</span>
 	return ret;
 }
 
<span class="p_del">-static int __exit ak8974_remove(struct i2c_client *i2c)</span>
<span class="p_add">+static int ak8974_remove(struct i2c_client *i2c)</span>
 {
 	struct iio_dev *indio_dev = i2c_get_clientdata(i2c);
 	struct ak8974 *ak8974 = iio_priv(indio_dev);
<span class="p_chunk">@@ -849,7 +849,7 @@</span> <span class="p_context"> static struct i2c_driver ak8974_driver = {</span>
 		.of_match_table = of_match_ptr(ak8974_of_match),
 	},
 	.probe	  = ak8974_probe,
<span class="p_del">-	.remove	  = __exit_p(ak8974_remove),</span>
<span class="p_add">+	.remove	  = ak8974_remove,</span>
 	.id_table = ak8974_id,
 };
 module_i2c_driver(ak8974_driver);
<span class="p_header">diff --git a/drivers/input/joystick/iforce/iforce-usb.c b/drivers/input/joystick/iforce/iforce-usb.c</span>
<span class="p_header">index d96aa27dfcdc..db64adfbe1af 100644</span>
<span class="p_header">--- a/drivers/input/joystick/iforce/iforce-usb.c</span>
<span class="p_header">+++ b/drivers/input/joystick/iforce/iforce-usb.c</span>
<span class="p_chunk">@@ -141,6 +141,9 @@</span> <span class="p_context"> static int iforce_usb_probe(struct usb_interface *intf,</span>
 
 	interface = intf-&gt;cur_altsetting;
 
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 2)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	epirq = &amp;interface-&gt;endpoint[0].desc;
 	epout = &amp;interface-&gt;endpoint[1].desc;
 
<span class="p_header">diff --git a/drivers/input/misc/cm109.c b/drivers/input/misc/cm109.c</span>
<span class="p_header">index 9cc6d057c302..23c191a2a071 100644</span>
<span class="p_header">--- a/drivers/input/misc/cm109.c</span>
<span class="p_header">+++ b/drivers/input/misc/cm109.c</span>
<span class="p_chunk">@@ -700,6 +700,10 @@</span> <span class="p_context"> static int cm109_usb_probe(struct usb_interface *intf,</span>
 	int error = -ENOMEM;
 
 	interface = intf-&gt;cur_altsetting;
<span class="p_add">+</span>
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	endpoint = &amp;interface-&gt;endpoint[0].desc;
 
 	if (!usb_endpoint_is_int_in(endpoint))
<span class="p_header">diff --git a/drivers/input/misc/ims-pcu.c b/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">index 9c0ea36913b4..f4e8fbec6a94 100644</span>
<span class="p_header">--- a/drivers/input/misc/ims-pcu.c</span>
<span class="p_header">+++ b/drivers/input/misc/ims-pcu.c</span>
<span class="p_chunk">@@ -1667,6 +1667,10 @@</span> <span class="p_context"> static int ims_pcu_parse_cdc_data(struct usb_interface *intf, struct ims_pcu *pc</span>
 		return -EINVAL;
 
 	alt = pcu-&gt;ctrl_intf-&gt;cur_altsetting;
<span class="p_add">+</span>
<span class="p_add">+	if (alt-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	pcu-&gt;ep_ctrl = &amp;alt-&gt;endpoint[0].desc;
 	pcu-&gt;max_ctrl_size = usb_endpoint_maxp(pcu-&gt;ep_ctrl);
 
<span class="p_header">diff --git a/drivers/input/misc/yealink.c b/drivers/input/misc/yealink.c</span>
<span class="p_header">index 79c964c075f1..6e7ff9561d92 100644</span>
<span class="p_header">--- a/drivers/input/misc/yealink.c</span>
<span class="p_header">+++ b/drivers/input/misc/yealink.c</span>
<span class="p_chunk">@@ -875,6 +875,10 @@</span> <span class="p_context"> static int usb_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	int ret, pipe, i;
 
 	interface = intf-&gt;cur_altsetting;
<span class="p_add">+</span>
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	endpoint = &amp;interface-&gt;endpoint[0].desc;
 	if (!usb_endpoint_is_int_in(endpoint))
 		return -ENODEV;
<span class="p_header">diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c</span>
<span class="p_header">index 328edc8c8786..2a0f9e79bf69 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.c</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.c</span>
<span class="p_chunk">@@ -1282,10 +1282,8 @@</span> <span class="p_context"> static int alps_decode_ss4_v2(struct alps_fields *f,</span>
 	/* handle buttons */
 	if (pkt_id == SS4_PACKET_ID_STICK) {
 		f-&gt;ts_left = !!(SS4_BTN_V2(p) &amp; 0x01);
<span class="p_del">-		if (!(priv-&gt;flags &amp; ALPS_BUTTONPAD)) {</span>
<span class="p_del">-			f-&gt;ts_right = !!(SS4_BTN_V2(p) &amp; 0x02);</span>
<span class="p_del">-			f-&gt;ts_middle = !!(SS4_BTN_V2(p) &amp; 0x04);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		f-&gt;ts_right = !!(SS4_BTN_V2(p) &amp; 0x02);</span>
<span class="p_add">+		f-&gt;ts_middle = !!(SS4_BTN_V2(p) &amp; 0x04);</span>
 	} else {
 		f-&gt;left = !!(SS4_BTN_V2(p) &amp; 0x01);
 		if (!(priv-&gt;flags &amp; ALPS_BUTTONPAD)) {
<span class="p_chunk">@@ -2462,14 +2460,34 @@</span> <span class="p_context"> static int alps_update_device_area_ss4_v2(unsigned char otp[][4],</span>
 	int num_y_electrode;
 	int x_pitch, y_pitch, x_phys, y_phys;
 
<span class="p_del">-	num_x_electrode = SS4_NUMSENSOR_XOFFSET + (otp[1][0] &amp; 0x0F);</span>
<span class="p_del">-	num_y_electrode = SS4_NUMSENSOR_YOFFSET + ((otp[1][0] &gt;&gt; 4) &amp; 0x0F);</span>
<span class="p_add">+	if (IS_SS4PLUS_DEV(priv-&gt;dev_id)) {</span>
<span class="p_add">+		num_x_electrode =</span>
<span class="p_add">+			SS4PLUS_NUMSENSOR_XOFFSET + (otp[0][2] &amp; 0x0F);</span>
<span class="p_add">+		num_y_electrode =</span>
<span class="p_add">+			SS4PLUS_NUMSENSOR_YOFFSET + ((otp[0][2] &gt;&gt; 4) &amp; 0x0F);</span>
<span class="p_add">+</span>
<span class="p_add">+		priv-&gt;x_max =</span>
<span class="p_add">+			(num_x_electrode - 1) * SS4PLUS_COUNT_PER_ELECTRODE;</span>
<span class="p_add">+		priv-&gt;y_max =</span>
<span class="p_add">+			(num_y_electrode - 1) * SS4PLUS_COUNT_PER_ELECTRODE;</span>
 
<span class="p_del">-	priv-&gt;x_max = (num_x_electrode - 1) * SS4_COUNT_PER_ELECTRODE;</span>
<span class="p_del">-	priv-&gt;y_max = (num_y_electrode - 1) * SS4_COUNT_PER_ELECTRODE;</span>
<span class="p_add">+		x_pitch = (otp[0][1] &amp; 0x0F) + SS4PLUS_MIN_PITCH_MM;</span>
<span class="p_add">+		y_pitch = ((otp[0][1] &gt;&gt; 4) &amp; 0x0F) + SS4PLUS_MIN_PITCH_MM;</span>
 
<span class="p_del">-	x_pitch = ((otp[1][2] &gt;&gt; 2) &amp; 0x07) + SS4_MIN_PITCH_MM;</span>
<span class="p_del">-	y_pitch = ((otp[1][2] &gt;&gt; 5) &amp; 0x07) + SS4_MIN_PITCH_MM;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		num_x_electrode =</span>
<span class="p_add">+			SS4_NUMSENSOR_XOFFSET + (otp[1][0] &amp; 0x0F);</span>
<span class="p_add">+		num_y_electrode =</span>
<span class="p_add">+			SS4_NUMSENSOR_YOFFSET + ((otp[1][0] &gt;&gt; 4) &amp; 0x0F);</span>
<span class="p_add">+</span>
<span class="p_add">+		priv-&gt;x_max =</span>
<span class="p_add">+			(num_x_electrode - 1) * SS4_COUNT_PER_ELECTRODE;</span>
<span class="p_add">+		priv-&gt;y_max =</span>
<span class="p_add">+			(num_y_electrode - 1) * SS4_COUNT_PER_ELECTRODE;</span>
<span class="p_add">+</span>
<span class="p_add">+		x_pitch = ((otp[1][2] &gt;&gt; 2) &amp; 0x07) + SS4_MIN_PITCH_MM;</span>
<span class="p_add">+		y_pitch = ((otp[1][2] &gt;&gt; 5) &amp; 0x07) + SS4_MIN_PITCH_MM;</span>
<span class="p_add">+	}</span>
 
 	x_phys = x_pitch * (num_x_electrode - 1); /* In 0.1 mm units */
 	y_phys = y_pitch * (num_y_electrode - 1); /* In 0.1 mm units */
<span class="p_chunk">@@ -2485,7 +2503,10 @@</span> <span class="p_context"> static int alps_update_btn_info_ss4_v2(unsigned char otp[][4],</span>
 {
 	unsigned char is_btnless;
 
<span class="p_del">-	is_btnless = (otp[1][1] &gt;&gt; 3) &amp; 0x01;</span>
<span class="p_add">+	if (IS_SS4PLUS_DEV(priv-&gt;dev_id))</span>
<span class="p_add">+		is_btnless = (otp[1][0] &gt;&gt; 1) &amp; 0x01;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		is_btnless = (otp[1][1] &gt;&gt; 3) &amp; 0x01;</span>
 
 	if (is_btnless)
 		priv-&gt;flags |= ALPS_BUTTONPAD;
<span class="p_chunk">@@ -2493,6 +2514,21 @@</span> <span class="p_context"> static int alps_update_btn_info_ss4_v2(unsigned char otp[][4],</span>
 	return 0;
 }
 
<span class="p_add">+static int alps_update_dual_info_ss4_v2(unsigned char otp[][4],</span>
<span class="p_add">+				       struct alps_data *priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool is_dual = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SS4PLUS_DEV(priv-&gt;dev_id))</span>
<span class="p_add">+		is_dual = (otp[0][0] &gt;&gt; 4) &amp; 0x01;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_dual)</span>
<span class="p_add">+		priv-&gt;flags |= ALPS_DUALPOINT |</span>
<span class="p_add">+					ALPS_DUALPOINT_WITH_PRESSURE;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int alps_set_defaults_ss4_v2(struct psmouse *psmouse,
 				    struct alps_data *priv)
 {
<span class="p_chunk">@@ -2508,6 +2544,8 @@</span> <span class="p_context"> static int alps_set_defaults_ss4_v2(struct psmouse *psmouse,</span>
 
 	alps_update_btn_info_ss4_v2(otp, priv);
 
<span class="p_add">+	alps_update_dual_info_ss4_v2(otp, priv);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2753,10 +2791,6 @@</span> <span class="p_context"> static int alps_set_protocol(struct psmouse *psmouse,</span>
 		if (alps_set_defaults_ss4_v2(psmouse, priv))
 			return -EIO;
 
<span class="p_del">-		if (priv-&gt;fw_ver[1] == 0x1)</span>
<span class="p_del">-			priv-&gt;flags |= ALPS_DUALPOINT |</span>
<span class="p_del">-					ALPS_DUALPOINT_WITH_PRESSURE;</span>
<span class="p_del">-</span>
 		break;
 	}
 
<span class="p_chunk">@@ -2827,10 +2861,7 @@</span> <span class="p_context"> static int alps_identify(struct psmouse *psmouse, struct alps_data *priv)</span>
 			   ec[2] &gt;= 0x90 &amp;&amp; ec[2] &lt;= 0x9d) {
 			protocol = &amp;alps_v3_protocol_data;
 		} else if (e7[0] == 0x73 &amp;&amp; e7[1] == 0x03 &amp;&amp;
<span class="p_del">-			   e7[2] == 0x14 &amp;&amp; ec[1] == 0x02) {</span>
<span class="p_del">-			protocol = &amp;alps_v8_protocol_data;</span>
<span class="p_del">-		} else if (e7[0] == 0x73 &amp;&amp; e7[1] == 0x03 &amp;&amp;</span>
<span class="p_del">-			   e7[2] == 0x28 &amp;&amp; ec[1] == 0x01) {</span>
<span class="p_add">+			   (e7[2] == 0x14 || e7[2] == 0x28)) {</span>
 			protocol = &amp;alps_v8_protocol_data;
 		} else {
 			psmouse_dbg(psmouse,
<span class="p_chunk">@@ -2840,7 +2871,8 @@</span> <span class="p_context"> static int alps_identify(struct psmouse *psmouse, struct alps_data *priv)</span>
 	}
 
 	if (priv) {
<span class="p_del">-		/* Save the Firmware version */</span>
<span class="p_add">+		/* Save Device ID and Firmware version */</span>
<span class="p_add">+		memcpy(priv-&gt;dev_id, e7, 3);</span>
 		memcpy(priv-&gt;fw_ver, ec, 3);
 		error = alps_set_protocol(psmouse, priv, protocol);
 		if (error)
<span class="p_header">diff --git a/drivers/input/mouse/alps.h b/drivers/input/mouse/alps.h</span>
<span class="p_header">index 6d279aa27cb9..4334f2805d93 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.h</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.h</span>
<span class="p_chunk">@@ -54,6 +54,16 @@</span> <span class="p_context"> enum SS4_PACKET_ID {</span>
 
 #define SS4_MASK_NORMAL_BUTTONS		0x07
 
<span class="p_add">+#define SS4PLUS_COUNT_PER_ELECTRODE	128</span>
<span class="p_add">+#define SS4PLUS_NUMSENSOR_XOFFSET	16</span>
<span class="p_add">+#define SS4PLUS_NUMSENSOR_YOFFSET	5</span>
<span class="p_add">+#define SS4PLUS_MIN_PITCH_MM		37</span>
<span class="p_add">+</span>
<span class="p_add">+#define IS_SS4PLUS_DEV(_b)	(((_b[0]) == 0x73) &amp;&amp;	\</span>
<span class="p_add">+				 ((_b[1]) == 0x03) &amp;&amp;	\</span>
<span class="p_add">+				 ((_b[2]) == 0x28)		\</span>
<span class="p_add">+				)</span>
<span class="p_add">+</span>
 #define SS4_IS_IDLE_V2(_b)	(((_b[0]) == 0x18) &amp;&amp;		\
 				 ((_b[1]) == 0x10) &amp;&amp;		\
 				 ((_b[2]) == 0x00) &amp;&amp;		\
<span class="p_chunk">@@ -283,6 +293,7 @@</span> <span class="p_context"> struct alps_data {</span>
 	int addr_command;
 	u16 proto_version;
 	u8 byte0, mask0;
<span class="p_add">+	u8 dev_id[3];</span>
 	u8 fw_ver[3];
 	int flags;
 	int x_max;
<span class="p_header">diff --git a/drivers/input/mouse/elan_i2c_core.c b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">index 1e1d0ad406f2..a26f44c28d82 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_chunk">@@ -218,17 +218,19 @@</span> <span class="p_context"> static int elan_query_product(struct elan_tp_data *data)</span>
 
 static int elan_check_ASUS_special_fw(struct elan_tp_data *data)
 {
<span class="p_del">-	if (data-&gt;ic_type != 0x0E)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (data-&gt;product_id) {</span>
<span class="p_del">-	case 0x05 ... 0x07:</span>
<span class="p_del">-	case 0x09:</span>
<span class="p_del">-	case 0x13:</span>
<span class="p_add">+	if (data-&gt;ic_type == 0x0E) {</span>
<span class="p_add">+		switch (data-&gt;product_id) {</span>
<span class="p_add">+		case 0x05 ... 0x07:</span>
<span class="p_add">+		case 0x09:</span>
<span class="p_add">+		case 0x13:</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (data-&gt;ic_type == 0x08 &amp;&amp; data-&gt;product_id == 0x26) {</span>
<span class="p_add">+		/* ASUS EeeBook X205TA */</span>
 		return true;
<span class="p_del">-	default:</span>
<span class="p_del">-		return false;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
 }
 
 static int __elan_initialize(struct elan_tp_data *data)
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index a7618776705a..27ae2a0ef1b9 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -120,6 +120,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_noloop_table[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Dell Embedded Box PC 3000 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Embedded Box PC 3000&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* OQO Model 01 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;OQO&quot;),
<span class="p_header">diff --git a/drivers/input/tablet/hanwang.c b/drivers/input/tablet/hanwang.c</span>
<span class="p_header">index cd852059b99e..df4bea96d7ed 100644</span>
<span class="p_header">--- a/drivers/input/tablet/hanwang.c</span>
<span class="p_header">+++ b/drivers/input/tablet/hanwang.c</span>
<span class="p_chunk">@@ -340,6 +340,9 @@</span> <span class="p_context"> static int hanwang_probe(struct usb_interface *intf, const struct usb_device_id</span>
 	int error;
 	int i;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	hanwang = kzalloc(sizeof(struct hanwang), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!hanwang || !input_dev) {
<span class="p_header">diff --git a/drivers/input/tablet/kbtab.c b/drivers/input/tablet/kbtab.c</span>
<span class="p_header">index e850d7e8afbc..4d9d64908b59 100644</span>
<span class="p_header">--- a/drivers/input/tablet/kbtab.c</span>
<span class="p_header">+++ b/drivers/input/tablet/kbtab.c</span>
<span class="p_chunk">@@ -122,6 +122,9 @@</span> <span class="p_context"> static int kbtab_probe(struct usb_interface *intf, const struct usb_device_id *i</span>
 	struct input_dev *input_dev;
 	int error = -ENOMEM;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	kbtab = kzalloc(sizeof(struct kbtab), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!kbtab || !input_dev)
<span class="p_header">diff --git a/drivers/input/touchscreen/sur40.c b/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">index aefb6e11f88a..4c0eecae065c 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/sur40.c</span>
<span class="p_chunk">@@ -527,6 +527,9 @@</span> <span class="p_context"> static int sur40_probe(struct usb_interface *interface,</span>
 	if (iface_desc-&gt;desc.bInterfaceClass != 0xFF)
 		return -ENODEV;
 
<span class="p_add">+	if (iface_desc-&gt;desc.bNumEndpoints &lt; 5)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	/* Use endpoint #4 (0x86). */
 	endpoint = &amp;iface_desc-&gt;endpoint[4].desc;
 	if (endpoint-&gt;bEndpointAddress != TOUCH_ENDPOINT)
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index 57ba0d3091ea..318cc878d0ca 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -509,7 +509,13 @@</span> <span class="p_context"> static void sysmmu_tlb_invalidate_flpdcache(struct sysmmu_drvdata *data,</span>
 	spin_lock_irqsave(&amp;data-&gt;lock, flags);
 	if (data-&gt;active &amp;&amp; data-&gt;version &gt;= MAKE_MMU_VER(3, 3)) {
 		clk_enable(data-&gt;clk_master);
<span class="p_del">-		__sysmmu_tlb_invalidate_entry(data, iova, 1);</span>
<span class="p_add">+		if (sysmmu_block(data)) {</span>
<span class="p_add">+			if (data-&gt;version &gt;= MAKE_MMU_VER(5, 0))</span>
<span class="p_add">+				__sysmmu_tlb_invalidate(data);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				__sysmmu_tlb_invalidate_entry(data, iova, 1);</span>
<span class="p_add">+			sysmmu_unblock(data);</span>
<span class="p_add">+		}</span>
 		clk_disable(data-&gt;clk_master);
 	}
 	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 23eead3cf77c..dfeb3808bc62 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -915,7 +915,7 @@</span> <span class="p_context"> static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf</span>
 				 * which we used for the IOMMU lookup. Strictly speaking
 				 * we could do this for all PCI devices; we only need to
 				 * get the BDF# from the scope table for ACPI matches. */
<span class="p_del">-				if (pdev-&gt;is_virtfn)</span>
<span class="p_add">+				if (pdev &amp;&amp; pdev-&gt;is_virtfn)</span>
 					goto got_pdev;
 
 				*bus = drhd-&gt;devices[i].bus;
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dvb-usb-firmware.c b/drivers/media/usb/dvb-usb/dvb-usb-firmware.c</span>
<span class="p_header">index ab9866024ec7..04033efe7ad5 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dvb-usb-firmware.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dvb-usb-firmware.c</span>
<span class="p_chunk">@@ -36,16 +36,18 @@</span> <span class="p_context"> static int usb_cypress_writemem(struct usb_device *udev,u16 addr,u8 *data, u8 le</span>
 int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw, int type)
 {
 	struct hexline *hx;
<span class="p_del">-	u8 reset;</span>
<span class="p_del">-	int ret,pos=0;</span>
<span class="p_add">+	u8 *buf;</span>
<span class="p_add">+	int ret, pos = 0;</span>
<span class="p_add">+	u16 cpu_cs_register = cypress[type].cpu_cs_register;</span>
 
<span class="p_del">-	hx = kmalloc(sizeof(*hx), GFP_KERNEL);</span>
<span class="p_del">-	if (!hx)</span>
<span class="p_add">+	buf = kmalloc(sizeof(*hx), GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
 		return -ENOMEM;
<span class="p_add">+	hx = (struct hexline *)buf;</span>
 
 	/* stop the CPU */
<span class="p_del">-	reset = 1;</span>
<span class="p_del">-	if ((ret = usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&amp;reset,1)) != 1)</span>
<span class="p_add">+	buf[0] = 1;</span>
<span class="p_add">+	if (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1)</span>
 		err(&quot;could not stop the USB controller CPU.&quot;);
 
 	while ((ret = dvb_usb_get_hexline(fw, hx, &amp;pos)) &gt; 0) {
<span class="p_chunk">@@ -61,21 +63,21 @@</span> <span class="p_context"> int usb_cypress_load_firmware(struct usb_device *udev, const struct firmware *fw</span>
 	}
 	if (ret &lt; 0) {
 		err(&quot;firmware download failed at %d with %d&quot;,pos,ret);
<span class="p_del">-		kfree(hx);</span>
<span class="p_add">+		kfree(buf);</span>
 		return ret;
 	}
 
 	if (ret == 0) {
 		/* restart the CPU */
<span class="p_del">-		reset = 0;</span>
<span class="p_del">-		if (ret || usb_cypress_writemem(udev,cypress[type].cpu_cs_register,&amp;reset,1) != 1) {</span>
<span class="p_add">+		buf[0] = 0;</span>
<span class="p_add">+		if (usb_cypress_writemem(udev, cpu_cs_register, buf, 1) != 1) {</span>
 			err(&quot;could not restart the USB controller CPU.&quot;);
 			ret = -EINVAL;
 		}
 	} else
 		ret = -EIO;
 
<span class="p_del">-	kfree(hx);</span>
<span class="p_add">+	kfree(buf);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/misc/mei/bus-fixup.c b/drivers/misc/mei/bus-fixup.c</span>
<span class="p_header">index 3600c9993a98..29f2daed37e0 100644</span>
<span class="p_header">--- a/drivers/misc/mei/bus-fixup.c</span>
<span class="p_header">+++ b/drivers/misc/mei/bus-fixup.c</span>
<span class="p_chunk">@@ -112,11 +112,9 @@</span> <span class="p_context"> struct mkhi_msg {</span>
 
 static int mei_osver(struct mei_cl_device *cldev)
 {
<span class="p_del">-	int ret;</span>
 	const size_t size = sizeof(struct mkhi_msg_hdr) +
 			    sizeof(struct mkhi_fwcaps) +
 			    sizeof(struct mei_os_ver);
<span class="p_del">-	size_t length = 8;</span>
 	char buf[size];
 	struct mkhi_msg *req;
 	struct mkhi_fwcaps *fwcaps;
<span class="p_chunk">@@ -137,15 +135,7 @@</span> <span class="p_context"> static int mei_osver(struct mei_cl_device *cldev)</span>
 	os_ver = (struct mei_os_ver *)fwcaps-&gt;data;
 	os_ver-&gt;os_type = OSTYPE_LINUX;
 
<span class="p_del">-	ret = __mei_cl_send(cldev-&gt;cl, buf, size, mode);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = __mei_cl_recv(cldev-&gt;cl, buf, length, 0);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return __mei_cl_send(cldev-&gt;cl, buf, size, mode);</span>
 }
 
 static void mei_mkhi_fix(struct mei_cl_device *cldev)
<span class="p_chunk">@@ -160,7 +150,7 @@</span> <span class="p_context"> static void mei_mkhi_fix(struct mei_cl_device *cldev)</span>
 		return;
 
 	ret = mei_osver(cldev);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		dev_err(&amp;cldev-&gt;dev, &quot;OS version command failed %d\n&quot;, ret);
 
 	mei_cldev_disable(cldev);
<span class="p_header">diff --git a/drivers/misc/mei/init.c b/drivers/misc/mei/init.c</span>
<span class="p_header">index 41e5760a6886..a13abc8fa1bc 100644</span>
<span class="p_header">--- a/drivers/misc/mei/init.c</span>
<span class="p_header">+++ b/drivers/misc/mei/init.c</span>
<span class="p_chunk">@@ -124,8 +124,6 @@</span> <span class="p_context"> int mei_reset(struct mei_device *dev)</span>
 
 	mei_clear_interrupts(dev);
 
<span class="p_del">-	mei_synchronize_irq(dev);</span>
<span class="p_del">-</span>
 	/* we&#39;re already in reset, cancel the init timer
 	 * if the reset was called due the hbm protocol error
 	 * we need to call it before hw start
<span class="p_chunk">@@ -304,6 +302,9 @@</span> <span class="p_context"> static void mei_reset_work(struct work_struct *work)</span>
 		container_of(work, struct mei_device,  reset_work);
 	int ret;
 
<span class="p_add">+	mei_clear_interrupts(dev);</span>
<span class="p_add">+	mei_synchronize_irq(dev);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;dev-&gt;device_lock);
 
 	ret = mei_reset(dev);
<span class="p_chunk">@@ -328,6 +329,9 @@</span> <span class="p_context"> void mei_stop(struct mei_device *dev)</span>
 
 	mei_cancel_work(dev);
 
<span class="p_add">+	mei_clear_interrupts(dev);</span>
<span class="p_add">+	mei_synchronize_irq(dev);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;dev-&gt;device_lock);
 
 	dev-&gt;dev_state = MEI_DEV_POWER_DOWN;
<span class="p_header">diff --git a/drivers/mmc/core/block.c b/drivers/mmc/core/block.c</span>
<span class="p_header">index cb1698f268f1..7f4927a05be0 100644</span>
<span class="p_header">--- a/drivers/mmc/core/block.c</span>
<span class="p_header">+++ b/drivers/mmc/core/block.c</span>
<span class="p_chunk">@@ -1791,6 +1791,7 @@</span> <span class="p_context"> int mmc_blk_issue_rq(struct mmc_queue *mq, struct request *req)</span>
 		ret = mmc_blk_issue_flush(mq, req);
 	} else {
 		ret = mmc_blk_issue_rw_rq(mq, req);
<span class="p_add">+		card-&gt;host-&gt;context_info.is_waiting_last_req = false;</span>
 	}
 
 out:
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 0fccca075e29..4ede0904602c 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -1706,7 +1706,7 @@</span> <span class="p_context"> static int mmc_init_card(struct mmc_host *host, u32 ocr,</span>
 		err = mmc_select_hs400(card);
 		if (err)
 			goto free_card;
<span class="p_del">-	} else {</span>
<span class="p_add">+	} else if (!mmc_card_hs400es(card)) {</span>
 		/* Select the desired bus width optionally */
 		err = mmc_select_bus_width(card);
 		if (err &gt; 0 &amp;&amp; mmc_card_hs(card)) {
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-of-arasan.c b/drivers/mmc/host/sdhci-of-arasan.c</span>
<span class="p_header">index 410a55b1c25f..1cfd7f900339 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-of-arasan.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-of-arasan.c</span>
<span class="p_chunk">@@ -28,13 +28,9 @@</span> <span class="p_context"></span>
 #include &quot;sdhci-pltfm.h&quot;
 #include &lt;linux/of.h&gt;
 
<span class="p_del">-#define SDHCI_ARASAN_CLK_CTRL_OFFSET	0x2c</span>
 #define SDHCI_ARASAN_VENDOR_REGISTER	0x78
 
 #define VENDOR_ENHANCED_STROBE		BIT(0)
<span class="p_del">-#define CLK_CTRL_TIMEOUT_SHIFT		16</span>
<span class="p_del">-#define CLK_CTRL_TIMEOUT_MASK		(0xf &lt;&lt; CLK_CTRL_TIMEOUT_SHIFT)</span>
<span class="p_del">-#define CLK_CTRL_TIMEOUT_MIN_EXP	13</span>
 
 #define PHY_CLK_TOO_SLOW_HZ		400000
 
<span class="p_chunk">@@ -163,15 +159,15 @@</span> <span class="p_context"> static int sdhci_arasan_syscon_write(struct sdhci_host *host,</span>
 
 static unsigned int sdhci_arasan_get_timeout_clock(struct sdhci_host *host)
 {
<span class="p_del">-	u32 div;</span>
 	unsigned long freq;
 	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
 
<span class="p_del">-	div = readl(host-&gt;ioaddr + SDHCI_ARASAN_CLK_CTRL_OFFSET);</span>
<span class="p_del">-	div = (div &amp; CLK_CTRL_TIMEOUT_MASK) &gt;&gt; CLK_CTRL_TIMEOUT_SHIFT;</span>
<span class="p_add">+	/* SDHCI timeout clock is in kHz */</span>
<span class="p_add">+	freq = DIV_ROUND_UP(clk_get_rate(pltfm_host-&gt;clk), 1000);</span>
 
<span class="p_del">-	freq = clk_get_rate(pltfm_host-&gt;clk);</span>
<span class="p_del">-	freq /= 1 &lt;&lt; (CLK_CTRL_TIMEOUT_MIN_EXP + div);</span>
<span class="p_add">+	/* or in MHz */</span>
<span class="p_add">+	if (host-&gt;caps &amp; SDHCI_TIMEOUT_CLK_UNIT)</span>
<span class="p_add">+		freq = DIV_ROUND_UP(freq, 1000);</span>
 
 	return freq;
 }
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-of-at91.c b/drivers/mmc/host/sdhci-of-at91.c</span>
<span class="p_header">index 2f9ad213377a..7fd964256faa 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-of-at91.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-of-at91.c</span>
<span class="p_chunk">@@ -85,11 +85,30 @@</span> <span class="p_context"> static void sdhci_at91_set_clock(struct sdhci_host *host, unsigned int clock)</span>
 	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * In this specific implementation of the SDHCI controller, the power register</span>
<span class="p_add">+ * needs to have a valid voltage set even when the power supply is managed by</span>
<span class="p_add">+ * an external regulator.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sdhci_at91_set_power(struct sdhci_host *host, unsigned char mode,</span>
<span class="p_add">+		     unsigned short vdd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!IS_ERR(host-&gt;mmc-&gt;supply.vmmc)) {</span>
<span class="p_add">+		struct mmc_host *mmc = host-&gt;mmc;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_unlock_irq(&amp;host-&gt;lock);</span>
<span class="p_add">+		mmc_regulator_set_ocr(mmc, mmc-&gt;supply.vmmc, vdd);</span>
<span class="p_add">+		spin_lock_irq(&amp;host-&gt;lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	sdhci_set_power_noreg(host, mode, vdd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct sdhci_ops sdhci_at91_sama5d2_ops = {
 	.set_clock		= sdhci_at91_set_clock,
 	.set_bus_width		= sdhci_set_bus_width,
 	.reset			= sdhci_reset,
 	.set_uhs_signaling	= sdhci_set_uhs_signaling,
<span class="p_add">+	.set_power		= sdhci_at91_set_power,</span>
 };
 
 static const struct sdhci_pltfm_data soc_data_sama5d2 = {
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_header">index 1a72d32af07f..e977048a8428 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_chunk">@@ -452,6 +452,8 @@</span> <span class="p_context"> static void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode,</span>
 	if (mode == MMC_POWER_OFF)
 		return;
 
<span class="p_add">+	spin_unlock_irq(&amp;host-&gt;lock);</span>
<span class="p_add">+</span>
 	/*
 	 * Bus power might not enable after D3 -&gt; D0 transition due to the
 	 * present state not yet having propagated. Retry for up to 2ms.
<span class="p_chunk">@@ -464,6 +466,8 @@</span> <span class="p_context"> static void sdhci_intel_set_power(struct sdhci_host *host, unsigned char mode,</span>
 		reg |= SDHCI_POWER_ON;
 		sdhci_writeb(host, reg, SDHCI_POWER_CONTROL);
 	}
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;host-&gt;lock);</span>
 }
 
 static const struct sdhci_ops sdhci_intel_byt_ops = {
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 0def99590d16..d0819d18ad08 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -1362,7 +1362,9 @@</span> <span class="p_context"> void sdhci_enable_clk(struct sdhci_host *host, u16 clk)</span>
 			return;
 		}
 		timeout--;
<span class="p_del">-		mdelay(1);</span>
<span class="p_add">+		spin_unlock_irq(&amp;host-&gt;lock);</span>
<span class="p_add">+		usleep_range(900, 1100);</span>
<span class="p_add">+		spin_lock_irq(&amp;host-&gt;lock);</span>
 	}
 
 	clk |= SDHCI_CLOCK_CARD_EN;
<span class="p_header">diff --git a/drivers/mmc/host/ushc.c b/drivers/mmc/host/ushc.c</span>
<span class="p_header">index d2c386f09d69..1d843357422e 100644</span>
<span class="p_header">--- a/drivers/mmc/host/ushc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/ushc.c</span>
<span class="p_chunk">@@ -426,6 +426,9 @@</span> <span class="p_context"> static int ushc_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	struct ushc_data *ushc;
 	int ret;
 
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	mmc = mmc_alloc_host(sizeof(struct ushc_data), &amp;intf-&gt;dev);
 	if (mmc == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-common.h b/drivers/net/ethernet/amd/xgbe/xgbe-common.h</span>
<span class="p_header">index 8a280e7d66bd..127adbeefb10 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-common.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-common.h</span>
<span class="p_chunk">@@ -984,29 +984,29 @@</span> <span class="p_context"></span>
 #define XP_ECC_CNT1_DESC_DED_WIDTH		8
 #define XP_ECC_CNT1_DESC_SEC_INDEX		0
 #define XP_ECC_CNT1_DESC_SEC_WIDTH		8
<span class="p_del">-#define XP_ECC_IER_DESC_DED_INDEX		0</span>
<span class="p_add">+#define XP_ECC_IER_DESC_DED_INDEX		5</span>
 #define XP_ECC_IER_DESC_DED_WIDTH		1
<span class="p_del">-#define XP_ECC_IER_DESC_SEC_INDEX		1</span>
<span class="p_add">+#define XP_ECC_IER_DESC_SEC_INDEX		4</span>
 #define XP_ECC_IER_DESC_SEC_WIDTH		1
<span class="p_del">-#define XP_ECC_IER_RX_DED_INDEX			2</span>
<span class="p_add">+#define XP_ECC_IER_RX_DED_INDEX			3</span>
 #define XP_ECC_IER_RX_DED_WIDTH			1
<span class="p_del">-#define XP_ECC_IER_RX_SEC_INDEX			3</span>
<span class="p_add">+#define XP_ECC_IER_RX_SEC_INDEX			2</span>
 #define XP_ECC_IER_RX_SEC_WIDTH			1
<span class="p_del">-#define XP_ECC_IER_TX_DED_INDEX			4</span>
<span class="p_add">+#define XP_ECC_IER_TX_DED_INDEX			1</span>
 #define XP_ECC_IER_TX_DED_WIDTH			1
<span class="p_del">-#define XP_ECC_IER_TX_SEC_INDEX			5</span>
<span class="p_add">+#define XP_ECC_IER_TX_SEC_INDEX			0</span>
 #define XP_ECC_IER_TX_SEC_WIDTH			1
<span class="p_del">-#define XP_ECC_ISR_DESC_DED_INDEX		0</span>
<span class="p_add">+#define XP_ECC_ISR_DESC_DED_INDEX		5</span>
 #define XP_ECC_ISR_DESC_DED_WIDTH		1
<span class="p_del">-#define XP_ECC_ISR_DESC_SEC_INDEX		1</span>
<span class="p_add">+#define XP_ECC_ISR_DESC_SEC_INDEX		4</span>
 #define XP_ECC_ISR_DESC_SEC_WIDTH		1
<span class="p_del">-#define XP_ECC_ISR_RX_DED_INDEX			2</span>
<span class="p_add">+#define XP_ECC_ISR_RX_DED_INDEX			3</span>
 #define XP_ECC_ISR_RX_DED_WIDTH			1
<span class="p_del">-#define XP_ECC_ISR_RX_SEC_INDEX			3</span>
<span class="p_add">+#define XP_ECC_ISR_RX_SEC_INDEX			2</span>
 #define XP_ECC_ISR_RX_SEC_WIDTH			1
<span class="p_del">-#define XP_ECC_ISR_TX_DED_INDEX			4</span>
<span class="p_add">+#define XP_ECC_ISR_TX_DED_INDEX			1</span>
 #define XP_ECC_ISR_TX_DED_WIDTH			1
<span class="p_del">-#define XP_ECC_ISR_TX_SEC_INDEX			5</span>
<span class="p_add">+#define XP_ECC_ISR_TX_SEC_INDEX			0</span>
 #define XP_ECC_ISR_TX_SEC_WIDTH			1
 #define XP_I2C_MUTEX_BUSY_INDEX			31
 #define XP_I2C_MUTEX_BUSY_WIDTH			1
<span class="p_chunk">@@ -1148,8 +1148,8 @@</span> <span class="p_context"></span>
 #define RX_PACKET_ATTRIBUTES_CSUM_DONE_WIDTH	1
 #define RX_PACKET_ATTRIBUTES_VLAN_CTAG_INDEX	1
 #define RX_PACKET_ATTRIBUTES_VLAN_CTAG_WIDTH	1
<span class="p_del">-#define RX_PACKET_ATTRIBUTES_INCOMPLETE_INDEX	2</span>
<span class="p_del">-#define RX_PACKET_ATTRIBUTES_INCOMPLETE_WIDTH	1</span>
<span class="p_add">+#define RX_PACKET_ATTRIBUTES_LAST_INDEX		2</span>
<span class="p_add">+#define RX_PACKET_ATTRIBUTES_LAST_WIDTH		1</span>
 #define RX_PACKET_ATTRIBUTES_CONTEXT_NEXT_INDEX	3
 #define RX_PACKET_ATTRIBUTES_CONTEXT_NEXT_WIDTH	1
 #define RX_PACKET_ATTRIBUTES_CONTEXT_INDEX	4
<span class="p_chunk">@@ -1158,6 +1158,8 @@</span> <span class="p_context"></span>
 #define RX_PACKET_ATTRIBUTES_RX_TSTAMP_WIDTH	1
 #define RX_PACKET_ATTRIBUTES_RSS_HASH_INDEX	6
 #define RX_PACKET_ATTRIBUTES_RSS_HASH_WIDTH	1
<span class="p_add">+#define RX_PACKET_ATTRIBUTES_FIRST_INDEX	7</span>
<span class="p_add">+#define RX_PACKET_ATTRIBUTES_FIRST_WIDTH	1</span>
 
 #define RX_NORMAL_DESC0_OVT_INDEX		0
 #define RX_NORMAL_DESC0_OVT_WIDTH		16
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">index 937f37a5dcb2..24a687ce4388 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_chunk">@@ -1896,10 +1896,15 @@</span> <span class="p_context"> static int xgbe_dev_read(struct xgbe_channel *channel)</span>
 
 	/* Get the header length */
 	if (XGMAC_GET_BITS_LE(rdesc-&gt;desc3, RX_NORMAL_DESC3, FD)) {
<span class="p_add">+		XGMAC_SET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES,</span>
<span class="p_add">+			       FIRST, 1);</span>
 		rdata-&gt;rx.hdr_len = XGMAC_GET_BITS_LE(rdesc-&gt;desc2,
 						      RX_NORMAL_DESC2, HL);
 		if (rdata-&gt;rx.hdr_len)
 			pdata-&gt;ext_stats.rx_split_header_packets++;
<span class="p_add">+	} else {</span>
<span class="p_add">+		XGMAC_SET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES,</span>
<span class="p_add">+			       FIRST, 0);</span>
 	}
 
 	/* Get the RSS hash */
<span class="p_chunk">@@ -1922,19 +1927,16 @@</span> <span class="p_context"> static int xgbe_dev_read(struct xgbe_channel *channel)</span>
 		}
 	}
 
<span class="p_del">-	/* Get the packet length */</span>
<span class="p_del">-	rdata-&gt;rx.len = XGMAC_GET_BITS_LE(rdesc-&gt;desc3, RX_NORMAL_DESC3, PL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!XGMAC_GET_BITS_LE(rdesc-&gt;desc3, RX_NORMAL_DESC3, LD)) {</span>
<span class="p_del">-		/* Not all the data has been transferred for this packet */</span>
<span class="p_del">-		XGMAC_SET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES,</span>
<span class="p_del">-			       INCOMPLETE, 1);</span>
<span class="p_add">+	/* Not all the data has been transferred for this packet */</span>
<span class="p_add">+	if (!XGMAC_GET_BITS_LE(rdesc-&gt;desc3, RX_NORMAL_DESC3, LD))</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	/* This is the last of the data for this packet */
 	XGMAC_SET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES,
<span class="p_del">-		       INCOMPLETE, 0);</span>
<span class="p_add">+		       LAST, 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the packet length */</span>
<span class="p_add">+	rdata-&gt;rx.len = XGMAC_GET_BITS_LE(rdesc-&gt;desc3, RX_NORMAL_DESC3, PL);</span>
 
 	/* Set checksum done indicator as appropriate */
 	if (netdev-&gt;features &amp; NETIF_F_RXCSUM)
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">index 742e5d1b5da4..36fd1a158251 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_chunk">@@ -1973,13 +1973,12 @@</span> <span class="p_context"> static struct sk_buff *xgbe_create_skb(struct xgbe_prv_data *pdata,</span>
 {
 	struct sk_buff *skb;
 	u8 *packet;
<span class="p_del">-	unsigned int copy_len;</span>
 
 	skb = napi_alloc_skb(napi, rdata-&gt;rx.hdr.dma_len);
 	if (!skb)
 		return NULL;
 
<span class="p_del">-	/* Start with the header buffer which may contain just the header</span>
<span class="p_add">+	/* Pull in the header buffer which may contain just the header</span>
 	 * or the header plus data
 	 */
 	dma_sync_single_range_for_cpu(pdata-&gt;dev, rdata-&gt;rx.hdr.dma_base,
<span class="p_chunk">@@ -1988,30 +1987,49 @@</span> <span class="p_context"> static struct sk_buff *xgbe_create_skb(struct xgbe_prv_data *pdata,</span>
 
 	packet = page_address(rdata-&gt;rx.hdr.pa.pages) +
 		 rdata-&gt;rx.hdr.pa.pages_offset;
<span class="p_del">-	copy_len = (rdata-&gt;rx.hdr_len) ? rdata-&gt;rx.hdr_len : len;</span>
<span class="p_del">-	copy_len = min(rdata-&gt;rx.hdr.dma_len, copy_len);</span>
<span class="p_del">-	skb_copy_to_linear_data(skb, packet, copy_len);</span>
<span class="p_del">-	skb_put(skb, copy_len);</span>
<span class="p_del">-</span>
<span class="p_del">-	len -= copy_len;</span>
<span class="p_del">-	if (len) {</span>
<span class="p_del">-		/* Add the remaining data as a frag */</span>
<span class="p_del">-		dma_sync_single_range_for_cpu(pdata-&gt;dev,</span>
<span class="p_del">-					      rdata-&gt;rx.buf.dma_base,</span>
<span class="p_del">-					      rdata-&gt;rx.buf.dma_off,</span>
<span class="p_del">-					      rdata-&gt;rx.buf.dma_len,</span>
<span class="p_del">-					      DMA_FROM_DEVICE);</span>
<span class="p_del">-</span>
<span class="p_del">-		skb_add_rx_frag(skb, skb_shinfo(skb)-&gt;nr_frags,</span>
<span class="p_del">-				rdata-&gt;rx.buf.pa.pages,</span>
<span class="p_del">-				rdata-&gt;rx.buf.pa.pages_offset,</span>
<span class="p_del">-				len, rdata-&gt;rx.buf.dma_len);</span>
<span class="p_del">-		rdata-&gt;rx.buf.pa.pages = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	skb_copy_to_linear_data(skb, packet, len);</span>
<span class="p_add">+	skb_put(skb, len);</span>
 
 	return skb;
 }
 
<span class="p_add">+static unsigned int xgbe_rx_buf1_len(struct xgbe_ring_data *rdata,</span>
<span class="p_add">+				     struct xgbe_packet_data *packet)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Always zero if not the first descriptor */</span>
<span class="p_add">+	if (!XGMAC_GET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES, FIRST))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* First descriptor with split header, return header length */</span>
<span class="p_add">+	if (rdata-&gt;rx.hdr_len)</span>
<span class="p_add">+		return rdata-&gt;rx.hdr_len;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* First descriptor but not the last descriptor and no split header,</span>
<span class="p_add">+	 * so the full buffer was used</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!XGMAC_GET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES, LAST))</span>
<span class="p_add">+		return rdata-&gt;rx.hdr.dma_len;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* First descriptor and last descriptor and no split header, so</span>
<span class="p_add">+	 * calculate how much of the buffer was used</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return min_t(unsigned int, rdata-&gt;rx.hdr.dma_len, rdata-&gt;rx.len);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int xgbe_rx_buf2_len(struct xgbe_ring_data *rdata,</span>
<span class="p_add">+				     struct xgbe_packet_data *packet,</span>
<span class="p_add">+				     unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Always the full buffer if not the last descriptor */</span>
<span class="p_add">+	if (!XGMAC_GET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES, LAST))</span>
<span class="p_add">+		return rdata-&gt;rx.buf.dma_len;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Last descriptor so calculate how much of the buffer was used</span>
<span class="p_add">+	 * for the last bit of data</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return rdata-&gt;rx.len - len;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int xgbe_tx_poll(struct xgbe_channel *channel)
 {
 	struct xgbe_prv_data *pdata = channel-&gt;pdata;
<span class="p_chunk">@@ -2094,8 +2112,8 @@</span> <span class="p_context"> static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)</span>
 	struct napi_struct *napi;
 	struct sk_buff *skb;
 	struct skb_shared_hwtstamps *hwtstamps;
<span class="p_del">-	unsigned int incomplete, error, context_next, context;</span>
<span class="p_del">-	unsigned int len, rdesc_len, max_len;</span>
<span class="p_add">+	unsigned int last, error, context_next, context;</span>
<span class="p_add">+	unsigned int len, buf1_len, buf2_len, max_len;</span>
 	unsigned int received = 0;
 	int packet_count = 0;
 
<span class="p_chunk">@@ -2105,7 +2123,7 @@</span> <span class="p_context"> static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)</span>
 	if (!ring)
 		return 0;
 
<span class="p_del">-	incomplete = 0;</span>
<span class="p_add">+	last = 0;</span>
 	context_next = 0;
 
 	napi = (pdata-&gt;per_channel_irq) ? &amp;channel-&gt;napi : &amp;pdata-&gt;napi;
<span class="p_chunk">@@ -2139,9 +2157,8 @@</span> <span class="p_context"> static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)</span>
 		received++;
 		ring-&gt;cur++;
 
<span class="p_del">-		incomplete = XGMAC_GET_BITS(packet-&gt;attributes,</span>
<span class="p_del">-					    RX_PACKET_ATTRIBUTES,</span>
<span class="p_del">-					    INCOMPLETE);</span>
<span class="p_add">+		last = XGMAC_GET_BITS(packet-&gt;attributes, RX_PACKET_ATTRIBUTES,</span>
<span class="p_add">+				      LAST);</span>
 		context_next = XGMAC_GET_BITS(packet-&gt;attributes,
 					      RX_PACKET_ATTRIBUTES,
 					      CONTEXT_NEXT);
<span class="p_chunk">@@ -2150,7 +2167,7 @@</span> <span class="p_context"> static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)</span>
 					 CONTEXT);
 
 		/* Earlier error, just drain the remaining data */
<span class="p_del">-		if ((incomplete || context_next) &amp;&amp; error)</span>
<span class="p_add">+		if ((!last || context_next) &amp;&amp; error)</span>
 			goto read_again;
 
 		if (error || packet-&gt;errors) {
<span class="p_chunk">@@ -2162,16 +2179,22 @@</span> <span class="p_context"> static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)</span>
 		}
 
 		if (!context) {
<span class="p_del">-			/* Length is cumulative, get this descriptor&#39;s length */</span>
<span class="p_del">-			rdesc_len = rdata-&gt;rx.len - len;</span>
<span class="p_del">-			len += rdesc_len;</span>
<span class="p_add">+			/* Get the data length in the descriptor buffers */</span>
<span class="p_add">+			buf1_len = xgbe_rx_buf1_len(rdata, packet);</span>
<span class="p_add">+			len += buf1_len;</span>
<span class="p_add">+			buf2_len = xgbe_rx_buf2_len(rdata, packet, len);</span>
<span class="p_add">+			len += buf2_len;</span>
 
<span class="p_del">-			if (rdesc_len &amp;&amp; !skb) {</span>
<span class="p_add">+			if (!skb) {</span>
 				skb = xgbe_create_skb(pdata, napi, rdata,
<span class="p_del">-						      rdesc_len);</span>
<span class="p_del">-				if (!skb)</span>
<span class="p_add">+						      buf1_len);</span>
<span class="p_add">+				if (!skb) {</span>
 					error = 1;
<span class="p_del">-			} else if (rdesc_len) {</span>
<span class="p_add">+					goto skip_data;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (buf2_len) {</span>
 				dma_sync_single_range_for_cpu(pdata-&gt;dev,
 							rdata-&gt;rx.buf.dma_base,
 							rdata-&gt;rx.buf.dma_off,
<span class="p_chunk">@@ -2181,13 +2204,14 @@</span> <span class="p_context"> static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)</span>
 				skb_add_rx_frag(skb, skb_shinfo(skb)-&gt;nr_frags,
 						rdata-&gt;rx.buf.pa.pages,
 						rdata-&gt;rx.buf.pa.pages_offset,
<span class="p_del">-						rdesc_len,</span>
<span class="p_add">+						buf2_len,</span>
 						rdata-&gt;rx.buf.dma_len);
 				rdata-&gt;rx.buf.pa.pages = NULL;
 			}
 		}
 
<span class="p_del">-		if (incomplete || context_next)</span>
<span class="p_add">+skip_data:</span>
<span class="p_add">+		if (!last || context_next)</span>
 			goto read_again;
 
 		if (!skb)
<span class="p_chunk">@@ -2245,7 +2269,7 @@</span> <span class="p_context"> static int xgbe_rx_poll(struct xgbe_channel *channel, int budget)</span>
 	}
 
 	/* Check if we need to save state before leaving */
<span class="p_del">-	if (received &amp;&amp; (incomplete || context_next)) {</span>
<span class="p_add">+	if (received &amp;&amp; (!last || context_next)) {</span>
 		rdata = XGBE_GET_DESC_DATA(ring, ring-&gt;cur);
 		rdata-&gt;state_saved = 1;
 		rdata-&gt;state.skb = skb;
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">index f92896835d2a..3789bed26716 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_chunk">@@ -3395,7 +3395,8 @@</span> <span class="p_context"> static int bcmgenet_suspend(struct device *d)</span>
 
 	bcmgenet_netif_stop(dev);
 
<span class="p_del">-	phy_suspend(priv-&gt;phydev);</span>
<span class="p_add">+	if (!device_may_wakeup(d))</span>
<span class="p_add">+		phy_suspend(priv-&gt;phydev);</span>
 
 	netif_device_detach(dev);
 
<span class="p_chunk">@@ -3492,7 +3493,8 @@</span> <span class="p_context"> static int bcmgenet_resume(struct device *d)</span>
 
 	netif_device_attach(dev);
 
<span class="p_del">-	phy_resume(priv-&gt;phydev);</span>
<span class="p_add">+	if (!device_may_wakeup(d))</span>
<span class="p_add">+		phy_resume(priv-&gt;phydev);</span>
 
 	if (priv-&gt;eee.eee_enabled)
 		bcmgenet_eee_enable_set(dev, true);
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/genet/bcmmii.c b/drivers/net/ethernet/broadcom/genet/bcmmii.c</span>
<span class="p_header">index e87607621e62..2f9281936f0e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/genet/bcmmii.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/genet/bcmmii.c</span>
<span class="p_chunk">@@ -220,20 +220,6 @@</span> <span class="p_context"> void bcmgenet_phy_power_set(struct net_device *dev, bool enable)</span>
 	udelay(60);
 }
 
<span class="p_del">-static void bcmgenet_internal_phy_setup(struct net_device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct bcmgenet_priv *priv = netdev_priv(dev);</span>
<span class="p_del">-	u32 reg;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Power up PHY */</span>
<span class="p_del">-	bcmgenet_phy_power_set(dev, true);</span>
<span class="p_del">-	/* enable APD */</span>
<span class="p_del">-	reg = bcmgenet_ext_readl(priv, EXT_EXT_PWR_MGMT);</span>
<span class="p_del">-	reg |= EXT_PWR_DN_EN_LD;</span>
<span class="p_del">-	bcmgenet_ext_writel(priv, reg, EXT_EXT_PWR_MGMT);</span>
<span class="p_del">-	bcmgenet_mii_reset(dev);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void bcmgenet_moca_phy_setup(struct bcmgenet_priv *priv)
 {
 	u32 reg;
<span class="p_chunk">@@ -281,7 +267,6 @@</span> <span class="p_context"> int bcmgenet_mii_config(struct net_device *dev)</span>
 
 		if (priv-&gt;internal_phy) {
 			phy_name = &quot;internal PHY&quot;;
<span class="p_del">-			bcmgenet_internal_phy_setup(dev);</span>
 		} else if (priv-&gt;phy_interface == PHY_INTERFACE_MODE_MOCA) {
 			phy_name = &quot;MoCA&quot;;
 			bcmgenet_moca_phy_setup(priv);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">index caa837e5e2b9..a380353a78c2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_chunk">@@ -361,6 +361,8 @@</span> <span class="p_context"> static int mlx5_internal_err_ret_value(struct mlx5_core_dev *dev, u16 op,</span>
 	case MLX5_CMD_OP_QUERY_VPORT_COUNTER:
 	case MLX5_CMD_OP_ALLOC_Q_COUNTER:
 	case MLX5_CMD_OP_QUERY_Q_COUNTER:
<span class="p_add">+	case MLX5_CMD_OP_SET_RATE_LIMIT:</span>
<span class="p_add">+	case MLX5_CMD_OP_QUERY_RATE_LIMIT:</span>
 	case MLX5_CMD_OP_ALLOC_PD:
 	case MLX5_CMD_OP_ALLOC_UAR:
 	case MLX5_CMD_OP_CONFIG_INT_MODERATION:
<span class="p_chunk">@@ -497,6 +499,8 @@</span> <span class="p_context"> const char *mlx5_command_str(int command)</span>
 	MLX5_COMMAND_STR_CASE(ALLOC_Q_COUNTER);
 	MLX5_COMMAND_STR_CASE(DEALLOC_Q_COUNTER);
 	MLX5_COMMAND_STR_CASE(QUERY_Q_COUNTER);
<span class="p_add">+	MLX5_COMMAND_STR_CASE(SET_RATE_LIMIT);</span>
<span class="p_add">+	MLX5_COMMAND_STR_CASE(QUERY_RATE_LIMIT);</span>
 	MLX5_COMMAND_STR_CASE(ALLOC_PD);
 	MLX5_COMMAND_STR_CASE(DEALLOC_PD);
 	MLX5_COMMAND_STR_CASE(ALLOC_UAR);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_header">index c69a1f827b65..41db47050991 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_chunk">@@ -921,10 +921,6 @@</span> <span class="p_context"> void mlx5e_destroy_netdev(struct mlx5_core_dev *mdev, struct mlx5e_priv *priv);</span>
 int mlx5e_attach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
 void mlx5e_detach_netdev(struct mlx5_core_dev *mdev, struct net_device *netdev);
 u32 mlx5e_choose_lro_timeout(struct mlx5_core_dev *mdev, u32 wanted_timeout);
<span class="p_del">-void mlx5e_add_vxlan_port(struct net_device *netdev,</span>
<span class="p_del">-			  struct udp_tunnel_info *ti);</span>
<span class="p_del">-void mlx5e_del_vxlan_port(struct net_device *netdev,</span>
<span class="p_del">-			  struct udp_tunnel_info *ti);</span>
 
 int mlx5e_get_offload_stats(int attr_id, const struct net_device *dev,
 			    void *sp);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">index 9d9c64927372..a501d823e87d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_chunk">@@ -3055,8 +3055,8 @@</span> <span class="p_context"> static int mlx5e_get_vf_stats(struct net_device *dev,</span>
 					    vf_stats);
 }
 
<span class="p_del">-void mlx5e_add_vxlan_port(struct net_device *netdev,</span>
<span class="p_del">-			  struct udp_tunnel_info *ti)</span>
<span class="p_add">+static void mlx5e_add_vxlan_port(struct net_device *netdev,</span>
<span class="p_add">+				 struct udp_tunnel_info *ti)</span>
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 
<span class="p_chunk">@@ -3069,8 +3069,8 @@</span> <span class="p_context"> void mlx5e_add_vxlan_port(struct net_device *netdev,</span>
 	mlx5e_vxlan_queue_work(priv, ti-&gt;sa_family, be16_to_cpu(ti-&gt;port), 1);
 }
 
<span class="p_del">-void mlx5e_del_vxlan_port(struct net_device *netdev,</span>
<span class="p_del">-			  struct udp_tunnel_info *ti)</span>
<span class="p_add">+static void mlx5e_del_vxlan_port(struct net_device *netdev,</span>
<span class="p_add">+				 struct udp_tunnel_info *ti)</span>
 {
 	struct mlx5e_priv *priv = netdev_priv(netdev);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c</span>
<span class="p_header">index 850378893b25..871ff3b51293 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rep.c</span>
<span class="p_chunk">@@ -394,8 +394,6 @@</span> <span class="p_context"> static const struct net_device_ops mlx5e_netdev_ops_rep = {</span>
 	.ndo_get_phys_port_name  = mlx5e_rep_get_phys_port_name,
 	.ndo_setup_tc            = mlx5e_rep_ndo_setup_tc,
 	.ndo_get_stats64         = mlx5e_rep_get_stats,
<span class="p_del">-	.ndo_udp_tunnel_add      = mlx5e_add_vxlan_port,</span>
<span class="p_del">-	.ndo_udp_tunnel_del      = mlx5e_del_vxlan_port,</span>
 	.ndo_has_offload_stats	 = mlx5e_has_offload_stats,
 	.ndo_get_offload_stats	 = mlx5e_get_offload_stats,
 };
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_header">index e3b88bbb9dcf..b1939a1d4815 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_chunk">@@ -603,6 +603,10 @@</span> <span class="p_context"> static inline void mlx5e_build_rx_skb(struct mlx5_cqe64 *cqe,</span>
 	if (lro_num_seg &gt; 1) {
 		mlx5e_lro_update_hdr(skb, cqe, cqe_bcnt);
 		skb_shinfo(skb)-&gt;gso_size = DIV_ROUND_UP(cqe_bcnt, lro_num_seg);
<span class="p_add">+		/* Subtract one since we already counted this as one</span>
<span class="p_add">+		 * &quot;regular&quot; packet in mlx5e_complete_rx_cqe()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		rq-&gt;stats.packets += lro_num_seg - 1;</span>
 		rq-&gt;stats.lro_packets++;
 		rq-&gt;stats.lro_bytes += cqe_bcnt;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c</span>
<span class="p_header">index 2ebbe80d8126..cc718814c378 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tc.c</span>
<span class="p_chunk">@@ -128,6 +128,23 @@</span> <span class="p_context"> mlx5e_tc_add_nic_flow(struct mlx5e_priv *priv,</span>
 	return rule;
 }
 
<span class="p_add">+static void mlx5e_tc_del_nic_flow(struct mlx5e_priv *priv,</span>
<span class="p_add">+				  struct mlx5e_tc_flow *flow)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx5_fc *counter = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR(flow-&gt;rule)) {</span>
<span class="p_add">+		counter = mlx5_flow_rule_counter(flow-&gt;rule);</span>
<span class="p_add">+		mlx5_del_flow_rules(flow-&gt;rule);</span>
<span class="p_add">+		mlx5_fc_destroy(priv-&gt;mdev, counter);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mlx5e_tc_num_filters(priv) &amp;&amp; (priv-&gt;fs.tc.t)) {</span>
<span class="p_add">+		mlx5_destroy_flow_table(priv-&gt;fs.tc.t);</span>
<span class="p_add">+		priv-&gt;fs.tc.t = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct mlx5_flow_handle *
 mlx5e_tc_add_fdb_flow(struct mlx5e_priv *priv,
 		      struct mlx5_flow_spec *spec,
<span class="p_chunk">@@ -144,7 +161,24 @@</span> <span class="p_context"> mlx5e_tc_add_fdb_flow(struct mlx5e_priv *priv,</span>
 }
 
 static void mlx5e_detach_encap(struct mlx5e_priv *priv,
<span class="p_del">-			       struct mlx5e_tc_flow *flow) {</span>
<span class="p_add">+			       struct mlx5e_tc_flow *flow);</span>
<span class="p_add">+</span>
<span class="p_add">+static void mlx5e_tc_del_fdb_flow(struct mlx5e_priv *priv,</span>
<span class="p_add">+				  struct mlx5e_tc_flow *flow)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx5_eswitch *esw = priv-&gt;mdev-&gt;priv.eswitch;</span>
<span class="p_add">+</span>
<span class="p_add">+	mlx5_eswitch_del_offloaded_rule(esw, flow-&gt;rule, flow-&gt;attr);</span>
<span class="p_add">+</span>
<span class="p_add">+	mlx5_eswitch_del_vlan_action(esw, flow-&gt;attr);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (flow-&gt;attr-&gt;action &amp; MLX5_FLOW_CONTEXT_ACTION_ENCAP)</span>
<span class="p_add">+		mlx5e_detach_encap(priv, flow);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mlx5e_detach_encap(struct mlx5e_priv *priv,</span>
<span class="p_add">+			       struct mlx5e_tc_flow *flow)</span>
<span class="p_add">+{</span>
 	struct list_head *next = flow-&gt;encap.next;
 
 	list_del(&amp;flow-&gt;encap);
<span class="p_chunk">@@ -169,24 +203,11 @@</span> <span class="p_context"> static void mlx5e_tc_del_flow(struct mlx5e_priv *priv,</span>
 			      struct mlx5e_tc_flow *flow)
 {
 	struct mlx5_eswitch *esw = priv-&gt;mdev-&gt;priv.eswitch;
<span class="p_del">-	struct mlx5_fc *counter = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!IS_ERR(flow-&gt;rule)) {</span>
<span class="p_del">-		counter = mlx5_flow_rule_counter(flow-&gt;rule);</span>
<span class="p_del">-		mlx5_del_flow_rules(flow-&gt;rule);</span>
<span class="p_del">-		mlx5_fc_destroy(priv-&gt;mdev, counter);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (esw &amp;&amp; esw-&gt;mode == SRIOV_OFFLOADS) {</span>
<span class="p_del">-		mlx5_eswitch_del_vlan_action(esw, flow-&gt;attr);</span>
<span class="p_del">-		if (flow-&gt;attr-&gt;action &amp; MLX5_FLOW_CONTEXT_ACTION_ENCAP)</span>
<span class="p_del">-			mlx5e_detach_encap(priv, flow);</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (!mlx5e_tc_num_filters(priv) &amp;&amp; (priv-&gt;fs.tc.t)) {</span>
<span class="p_del">-		mlx5_destroy_flow_table(priv-&gt;fs.tc.t);</span>
<span class="p_del">-		priv-&gt;fs.tc.t = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (esw &amp;&amp; esw-&gt;mode == SRIOV_OFFLOADS)</span>
<span class="p_add">+		mlx5e_tc_del_fdb_flow(priv, flow);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mlx5e_tc_del_nic_flow(priv, flow);</span>
 }
 
 static void parse_vxlan_attr(struct mlx5_flow_spec *spec,
<span class="p_chunk">@@ -243,12 +264,15 @@</span> <span class="p_context"> static int parse_tunnel_attr(struct mlx5e_priv *priv,</span>
 			skb_flow_dissector_target(f-&gt;dissector,
 						  FLOW_DISSECTOR_KEY_ENC_PORTS,
 						  f-&gt;mask);
<span class="p_add">+		struct mlx5_eswitch *esw = priv-&gt;mdev-&gt;priv.eswitch;</span>
<span class="p_add">+		struct net_device *up_dev = mlx5_eswitch_get_uplink_netdev(esw);</span>
<span class="p_add">+		struct mlx5e_priv *up_priv = netdev_priv(up_dev);</span>
 
 		/* Full udp dst port must be given */
 		if (memchr_inv(&amp;mask-&gt;dst, 0xff, sizeof(mask-&gt;dst)))
 			goto vxlan_match_offload_err;
 
<span class="p_del">-		if (mlx5e_vxlan_lookup_port(priv, be16_to_cpu(key-&gt;dst)) &amp;&amp;</span>
<span class="p_add">+		if (mlx5e_vxlan_lookup_port(up_priv, be16_to_cpu(key-&gt;dst)) &amp;&amp;</span>
 		    MLX5_CAP_ESW(priv-&gt;mdev, vxlan_encap_decap))
 			parse_vxlan_attr(spec, f);
 		else {
<span class="p_chunk">@@ -806,6 +830,8 @@</span> <span class="p_context"> static int mlx5e_attach_encap(struct mlx5e_priv *priv,</span>
 			      struct mlx5_esw_flow_attr *attr)
 {
 	struct mlx5_eswitch *esw = priv-&gt;mdev-&gt;priv.eswitch;
<span class="p_add">+	struct net_device *up_dev = mlx5_eswitch_get_uplink_netdev(esw);</span>
<span class="p_add">+	struct mlx5e_priv *up_priv = netdev_priv(up_dev);</span>
 	unsigned short family = ip_tunnel_info_af(tun_info);
 	struct ip_tunnel_key *key = &amp;tun_info-&gt;key;
 	struct mlx5_encap_info info;
<span class="p_chunk">@@ -828,7 +854,7 @@</span> <span class="p_context"> static int mlx5e_attach_encap(struct mlx5e_priv *priv,</span>
 		return -EOPNOTSUPP;
 	}
 
<span class="p_del">-	if (mlx5e_vxlan_lookup_port(priv, be16_to_cpu(key-&gt;tp_dst)) &amp;&amp;</span>
<span class="p_add">+	if (mlx5e_vxlan_lookup_port(up_priv, be16_to_cpu(key-&gt;tp_dst)) &amp;&amp;</span>
 	    MLX5_CAP_ESW(priv-&gt;mdev, vxlan_encap_decap)) {
 		info.tp_dst = key-&gt;tp_dst;
 		info.tun_id = tunnel_id_to_key32(key-&gt;tun_id);
<span class="p_chunk">@@ -953,14 +979,16 @@</span> <span class="p_context"> static int parse_tc_fdb_actions(struct mlx5e_priv *priv, struct tcf_exts *exts,</span>
 		}
 
 		if (is_tcf_vlan(a)) {
<span class="p_del">-			if (tcf_vlan_action(a) == VLAN_F_POP) {</span>
<span class="p_add">+			if (tcf_vlan_action(a) == TCA_VLAN_ACT_POP) {</span>
 				attr-&gt;action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_POP;
<span class="p_del">-			} else if (tcf_vlan_action(a) == VLAN_F_PUSH) {</span>
<span class="p_add">+			} else if (tcf_vlan_action(a) == TCA_VLAN_ACT_PUSH) {</span>
 				if (tcf_vlan_push_proto(a) != htons(ETH_P_8021Q))
 					return -EOPNOTSUPP;
 
 				attr-&gt;action |= MLX5_FLOW_CONTEXT_ACTION_VLAN_PUSH;
 				attr-&gt;vlan = tcf_vlan_push_vid(a);
<span class="p_add">+			} else { /* action is TCA_VLAN_ACT_MODIFY */</span>
<span class="p_add">+				return -EOPNOTSUPP;</span>
 			}
 			continue;
 		}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c</span>
<span class="p_header">index cfb68371c397..574311018e6f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c</span>
<span class="p_chunk">@@ -272,15 +272,18 @@</span> <span class="p_context"> static netdev_tx_t mlx5e_sq_xmit(struct mlx5e_sq *sq, struct sk_buff *skb)</span>
 			sq-&gt;stats.tso_bytes += skb-&gt;len - ihs;
 		}
 
<span class="p_add">+		sq-&gt;stats.packets += skb_shinfo(skb)-&gt;gso_segs;</span>
 		num_bytes = skb-&gt;len + (skb_shinfo(skb)-&gt;gso_segs - 1) * ihs;
 	} else {
 		bf = sq-&gt;bf_budget &amp;&amp;
 		     !skb-&gt;xmit_more &amp;&amp;
 		     !skb_shinfo(skb)-&gt;nr_frags;
 		ihs = mlx5e_get_inline_hdr_size(sq, skb, bf);
<span class="p_add">+		sq-&gt;stats.packets++;</span>
 		num_bytes = max_t(unsigned int, skb-&gt;len, ETH_ZLEN);
 	}
 
<span class="p_add">+	sq-&gt;stats.bytes += num_bytes;</span>
 	wi-&gt;num_bytes = num_bytes;
 
 	if (skb_vlan_tag_present(skb)) {
<span class="p_chunk">@@ -377,8 +380,6 @@</span> <span class="p_context"> static netdev_tx_t mlx5e_sq_xmit(struct mlx5e_sq *sq, struct sk_buff *skb)</span>
 	if (bf)
 		sq-&gt;bf_budget--;
 
<span class="p_del">-	sq-&gt;stats.packets++;</span>
<span class="p_del">-	sq-&gt;stats.bytes += num_bytes;</span>
 	return NETDEV_TX_OK;
 
 dma_unmap_wqe_err:
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h</span>
<span class="p_header">index 8661dd3f542c..b5967df1eeaa 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch.h</span>
<span class="p_chunk">@@ -201,6 +201,7 @@</span> <span class="p_context"> struct mlx5_esw_offload {</span>
 	struct mlx5_eswitch_rep *vport_reps;
 	DECLARE_HASHTABLE(encap_tbl, 8);
 	u8 inline_mode;
<span class="p_add">+	u64 num_flows;</span>
 };
 
 struct mlx5_eswitch {
<span class="p_chunk">@@ -263,6 +264,11 @@</span> <span class="p_context"> struct mlx5_flow_handle *</span>
 mlx5_eswitch_add_offloaded_rule(struct mlx5_eswitch *esw,
 				struct mlx5_flow_spec *spec,
 				struct mlx5_esw_flow_attr *attr);
<span class="p_add">+void</span>
<span class="p_add">+mlx5_eswitch_del_offloaded_rule(struct mlx5_eswitch *esw,</span>
<span class="p_add">+				struct mlx5_flow_handle *rule,</span>
<span class="p_add">+				struct mlx5_esw_flow_attr *attr);</span>
<span class="p_add">+</span>
 struct mlx5_flow_handle *
 mlx5_eswitch_create_vport_rx_rule(struct mlx5_eswitch *esw, int vport, u32 tirn);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c</span>
<span class="p_header">index 595f7c7383b3..7bce2bdbb79b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/eswitch_offloads.c</span>
<span class="p_chunk">@@ -93,10 +93,27 @@</span> <span class="p_context"> mlx5_eswitch_add_offloaded_rule(struct mlx5_eswitch *esw,</span>
 				   spec, &amp;flow_act, dest, i);
 	if (IS_ERR(rule))
 		mlx5_fc_destroy(esw-&gt;dev, counter);
<span class="p_add">+	else</span>
<span class="p_add">+		esw-&gt;offloads.num_flows++;</span>
 
 	return rule;
 }
 
<span class="p_add">+void</span>
<span class="p_add">+mlx5_eswitch_del_offloaded_rule(struct mlx5_eswitch *esw,</span>
<span class="p_add">+				struct mlx5_flow_handle *rule,</span>
<span class="p_add">+				struct mlx5_esw_flow_attr *attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx5_fc *counter = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR(rule)) {</span>
<span class="p_add">+		counter = mlx5_flow_rule_counter(rule);</span>
<span class="p_add">+		mlx5_del_flow_rules(rule);</span>
<span class="p_add">+		mlx5_fc_destroy(esw-&gt;dev, counter);</span>
<span class="p_add">+		esw-&gt;offloads.num_flows--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int esw_set_global_vlan_pop(struct mlx5_eswitch *esw, u8 val)
 {
 	struct mlx5_eswitch_rep *rep;
<span class="p_chunk">@@ -905,6 +922,11 @@</span> <span class="p_context"> int mlx5_devlink_eswitch_inline_mode_set(struct devlink *devlink, u8 mode)</span>
 	    MLX5_CAP_INLINE_MODE_VPORT_CONTEXT)
 		return -EOPNOTSUPP;
 
<span class="p_add">+	if (esw-&gt;offloads.num_flows &gt; 0) {</span>
<span class="p_add">+		esw_warn(dev, &quot;Can&#39;t set inline mode when flows are configured\n&quot;);</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = esw_inline_mode_from_devlink(mode, &amp;mlx5_mode);
 	if (err)
 		goto out;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index 3c315eb8d270..4aca265d9c14 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> static struct mlx5_profile profile[] = {</span>
 	[2] = {
 		.mask		= MLX5_PROF_MASK_QP_SIZE |
 				  MLX5_PROF_MASK_MR_CACHE,
<span class="p_del">-		.log_max_qp	= 17,</span>
<span class="p_add">+		.log_max_qp	= 18,</span>
 		.mr_cache[0]	= {
 			.size	= 500,
 			.limit	= 250
<span class="p_header">diff --git a/drivers/net/ethernet/ti/Kconfig b/drivers/net/ethernet/ti/Kconfig</span>
<span class="p_header">index 296c8efd0038..bd0af5974a75 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ti/Kconfig</span>
<span class="p_header">+++ b/drivers/net/ethernet/ti/Kconfig</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> config TI_CPSW</span>
 config TI_CPTS
 	tristate &quot;TI Common Platform Time Sync (CPTS) Support&quot;
 	depends on TI_CPSW || TI_KEYSTONE_NETCP
<span class="p_del">-	imply PTP_1588_CLOCK</span>
<span class="p_add">+	depends on PTP_1588_CLOCK</span>
 	---help---
 	  This driver supports the Common Platform Time Sync unit of
 	  the CPSW Ethernet Switch and Keystone 2 1g/10g Switch Subsystem.
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index 24d5272cdce5..0d519a9582ca 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -924,6 +924,8 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 	{QMI_FIXED_INTF(0x413c, 0x81a9, 8)},	/* Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */
 	{QMI_FIXED_INTF(0x413c, 0x81b1, 8)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card */
 	{QMI_FIXED_INTF(0x413c, 0x81b3, 8)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */
<span class="p_add">+	{QMI_FIXED_INTF(0x413c, 0x81b6, 8)},	/* Dell Wireless 5811e */</span>
<span class="p_add">+	{QMI_FIXED_INTF(0x413c, 0x81b6, 10)},	/* Dell Wireless 5811e */</span>
 	{QMI_FIXED_INTF(0x03f0, 0x4e1d, 8)},	/* HP lt4111 LTE/EV-DO/HSPA+ Gobi 4G Module */
 	{QMI_FIXED_INTF(0x22de, 0x9061, 3)},	/* WeTelecom WPD-600N */
 	{QMI_FIXED_INTF(0x1e0e, 0x9001, 5)},	/* SIMCom 7230E */
<span class="p_header">diff --git a/drivers/net/vrf.c b/drivers/net/vrf.c</span>
<span class="p_header">index 682aac0a2267..921fef275ea4 100644</span>
<span class="p_header">--- a/drivers/net/vrf.c</span>
<span class="p_header">+++ b/drivers/net/vrf.c</span>
<span class="p_chunk">@@ -462,8 +462,10 @@</span> <span class="p_context"> static void vrf_rt6_release(struct net_device *dev, struct net_vrf *vrf)</span>
 	}
 
 	if (rt6_local) {
<span class="p_del">-		if (rt6_local-&gt;rt6i_idev)</span>
<span class="p_add">+		if (rt6_local-&gt;rt6i_idev) {</span>
 			in6_dev_put(rt6_local-&gt;rt6i_idev);
<span class="p_add">+			rt6_local-&gt;rt6i_idev = NULL;</span>
<span class="p_add">+		}</span>
 
 		dst = &amp;rt6_local-&gt;dst;
 		dev_put(dst-&gt;dev);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/hw.c b/drivers/net/wireless/ath/ath10k/hw.c</span>
<span class="p_header">index 33fb26833cd0..d9f37ee4bfdd 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/hw.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> const struct ath10k_hw_regs qca6174_regs = {</span>
 	.rtc_soc_base_address			= 0x00000800,
 	.rtc_wmac_base_address			= 0x00001000,
 	.soc_core_base_address			= 0x0003a000,
<span class="p_del">-	.wlan_mac_base_address			= 0x00020000,</span>
<span class="p_add">+	.wlan_mac_base_address			= 0x00010000,</span>
 	.ce_wrapper_base_address		= 0x00034000,
 	.ce0_base_address			= 0x00034400,
 	.ce1_base_address			= 0x00034800,
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/pcie.c b/drivers/net/wireless/marvell/mwifiex/pcie.c</span>
<span class="p_header">index 4db07da81d8d..6d724c61cc7a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/pcie.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/pcie.c</span>
<span class="p_chunk">@@ -2742,6 +2742,21 @@</span> <span class="p_context"> static void mwifiex_pcie_device_dump(struct mwifiex_adapter *adapter)</span>
 	schedule_work(&amp;pcie_work);
 }
 
<span class="p_add">+static void mwifiex_pcie_free_buffers(struct mwifiex_adapter *adapter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pcie_service_card *card = adapter-&gt;card;</span>
<span class="p_add">+	const struct mwifiex_pcie_card_reg *reg = card-&gt;pcie.reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (reg-&gt;sleep_cookie)</span>
<span class="p_add">+		mwifiex_pcie_delete_sleep_cookie_buf(adapter);</span>
<span class="p_add">+</span>
<span class="p_add">+	mwifiex_pcie_delete_cmdrsp_buf(adapter);</span>
<span class="p_add">+	mwifiex_pcie_delete_evtbd_ring(adapter);</span>
<span class="p_add">+	mwifiex_pcie_delete_rxbd_ring(adapter);</span>
<span class="p_add">+	mwifiex_pcie_delete_txbd_ring(adapter);</span>
<span class="p_add">+	card-&gt;cmdrsp_buf = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * This function initializes the PCI-E host memory space, WCB rings, etc.
  *
<span class="p_chunk">@@ -2853,13 +2868,6 @@</span> <span class="p_context"> static int mwifiex_pcie_init(struct mwifiex_adapter *adapter)</span>
 
 /*
  * This function cleans up the allocated card buffers.
<span class="p_del">- *</span>
<span class="p_del">- * The following are freed by this function -</span>
<span class="p_del">- *      - TXBD ring buffers</span>
<span class="p_del">- *      - RXBD ring buffers</span>
<span class="p_del">- *      - Event BD ring buffers</span>
<span class="p_del">- *      - Command response ring buffer</span>
<span class="p_del">- *      - Sleep cookie buffer</span>
  */
 static void mwifiex_pcie_cleanup(struct mwifiex_adapter *adapter)
 {
<span class="p_chunk">@@ -2875,6 +2883,8 @@</span> <span class="p_context"> static void mwifiex_pcie_cleanup(struct mwifiex_adapter *adapter)</span>
 				    &quot;Failed to write driver not-ready signature\n&quot;);
 	}
 
<span class="p_add">+	mwifiex_pcie_free_buffers(adapter);</span>
<span class="p_add">+</span>
 	if (pdev) {
 		pci_iounmap(pdev, card-&gt;pci_mmap);
 		pci_iounmap(pdev, card-&gt;pci_mmap1);
<span class="p_chunk">@@ -3115,10 +3125,7 @@</span> <span class="p_context"> static void mwifiex_pcie_up_dev(struct mwifiex_adapter *adapter)</span>
 	pci_iounmap(pdev, card-&gt;pci_mmap1);
 }
 
<span class="p_del">-/* This function cleans up the PCI-E host memory space.</span>
<span class="p_del">- * Some code is extracted from mwifiex_unregister_dev()</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_add">+/* This function cleans up the PCI-E host memory space. */</span>
 static void mwifiex_pcie_down_dev(struct mwifiex_adapter *adapter)
 {
 	struct pcie_service_card *card = adapter-&gt;card;
<span class="p_chunk">@@ -3130,14 +3137,7 @@</span> <span class="p_context"> static void mwifiex_pcie_down_dev(struct mwifiex_adapter *adapter)</span>
 	adapter-&gt;seq_num = 0;
 	adapter-&gt;tx_buf_size = MWIFIEX_TX_DATA_BUF_SIZE_4K;
 
<span class="p_del">-	if (reg-&gt;sleep_cookie)</span>
<span class="p_del">-		mwifiex_pcie_delete_sleep_cookie_buf(adapter);</span>
<span class="p_del">-</span>
<span class="p_del">-	mwifiex_pcie_delete_cmdrsp_buf(adapter);</span>
<span class="p_del">-	mwifiex_pcie_delete_evtbd_ring(adapter);</span>
<span class="p_del">-	mwifiex_pcie_delete_rxbd_ring(adapter);</span>
<span class="p_del">-	mwifiex_pcie_delete_txbd_ring(adapter);</span>
<span class="p_del">-	card-&gt;cmdrsp_buf = NULL;</span>
<span class="p_add">+	mwifiex_pcie_free_buffers(adapter);</span>
 }
 
 static struct mwifiex_if_ops pcie_ops = {
<span class="p_header">diff --git a/drivers/parport/share.c b/drivers/parport/share.c</span>
<span class="p_header">index 3308427ed9f7..4399de34054a 100644</span>
<span class="p_header">--- a/drivers/parport/share.c</span>
<span class="p_header">+++ b/drivers/parport/share.c</span>
<span class="p_chunk">@@ -939,8 +939,10 @@</span> <span class="p_context"> parport_register_dev_model(struct parport *port, const char *name,</span>
 	 * pardevice fields. -arca
 	 */
 	port-&gt;ops-&gt;init_state(par_dev, par_dev-&gt;state);
<span class="p_del">-	port-&gt;proc_device = par_dev;</span>
<span class="p_del">-	parport_device_proc_register(par_dev);</span>
<span class="p_add">+	if (!test_and_set_bit(PARPORT_DEVPROC_REGISTERED, &amp;port-&gt;devflags)) {</span>
<span class="p_add">+		port-&gt;proc_device = par_dev;</span>
<span class="p_add">+		parport_device_proc_register(par_dev);</span>
<span class="p_add">+	}</span>
 
 	return par_dev;
 
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index 245fbe2f1696..6e620242a600 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -4658,7 +4658,6 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 	struct MPT3SAS_DEVICE *sas_device_priv_data;
 	u32 response_code = 0;
 	unsigned long flags;
<span class="p_del">-	unsigned int sector_sz;</span>
 
 	mpi_reply = mpt3sas_base_get_reply_virt_addr(ioc, reply);
 	scmd = _scsih_scsi_lookup_get_clear(ioc, smid);
<span class="p_chunk">@@ -4717,20 +4716,6 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 	}
 
 	xfer_cnt = le32_to_cpu(mpi_reply-&gt;TransferCount);
<span class="p_del">-</span>
<span class="p_del">-	/* In case of bogus fw or device, we could end up having</span>
<span class="p_del">-	 * unaligned partial completion. We can force alignment here,</span>
<span class="p_del">-	 * then scsi-ml does not need to handle this misbehavior.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	sector_sz = scmd-&gt;device-&gt;sector_size;</span>
<span class="p_del">-	if (unlikely(scmd-&gt;request-&gt;cmd_type == REQ_TYPE_FS &amp;&amp; sector_sz &amp;&amp;</span>
<span class="p_del">-		     xfer_cnt % sector_sz)) {</span>
<span class="p_del">-		sdev_printk(KERN_INFO, scmd-&gt;device,</span>
<span class="p_del">-		    &quot;unaligned partial completion avoided (xfer_cnt=%u, sector_sz=%u)\n&quot;,</span>
<span class="p_del">-			    xfer_cnt, sector_sz);</span>
<span class="p_del">-		xfer_cnt = round_down(xfer_cnt, sector_sz);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	scsi_set_resid(scmd, scsi_bufflen(scmd) - xfer_cnt);
 	if (ioc_status &amp; MPI2_IOCSTATUS_FLAG_LOG_INFO_AVAILABLE)
 		log_info =  le32_to_cpu(mpi_reply-&gt;IOCLogInfo);
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 1f5d92a25a49..1ee57619c95e 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -1790,6 +1790,8 @@</span> <span class="p_context"> static int sd_done(struct scsi_cmnd *SCpnt)</span>
 {
 	int result = SCpnt-&gt;result;
 	unsigned int good_bytes = result ? 0 : scsi_bufflen(SCpnt);
<span class="p_add">+	unsigned int sector_size = SCpnt-&gt;device-&gt;sector_size;</span>
<span class="p_add">+	unsigned int resid;</span>
 	struct scsi_sense_hdr sshdr;
 	struct scsi_disk *sdkp = scsi_disk(SCpnt-&gt;request-&gt;rq_disk);
 	struct request *req = SCpnt-&gt;request;
<span class="p_chunk">@@ -1820,6 +1822,21 @@</span> <span class="p_context"> static int sd_done(struct scsi_cmnd *SCpnt)</span>
 			scsi_set_resid(SCpnt, blk_rq_bytes(req));
 		}
 		break;
<span class="p_add">+	default:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * In case of bogus fw or device, we could end up having</span>
<span class="p_add">+		 * an unaligned partial completion. Check this here and force</span>
<span class="p_add">+		 * alignment.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		resid = scsi_get_resid(SCpnt);</span>
<span class="p_add">+		if (resid &amp; (sector_size - 1)) {</span>
<span class="p_add">+			sd_printk(KERN_INFO, sdkp,</span>
<span class="p_add">+				&quot;Unaligned partial completion (resid=%u, sector_sz=%u)\n&quot;,</span>
<span class="p_add">+				resid, sector_size);</span>
<span class="p_add">+			resid = min(scsi_bufflen(SCpnt),</span>
<span class="p_add">+				    round_up(resid, sector_size));</span>
<span class="p_add">+			scsi_set_resid(SCpnt, resid);</span>
<span class="p_add">+		}</span>
 	}
 
 	if (result) {
<span class="p_header">diff --git a/drivers/usb/class/usbtmc.c b/drivers/usb/class/usbtmc.c</span>
<span class="p_header">index f03692ec5520..8fb309a0ff6b 100644</span>
<span class="p_header">--- a/drivers/usb/class/usbtmc.c</span>
<span class="p_header">+++ b/drivers/usb/class/usbtmc.c</span>
<span class="p_chunk">@@ -1381,7 +1381,7 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 
 	dev_dbg(&amp;intf-&gt;dev, &quot;%s called\n&quot;, __func__);
 
<span class="p_del">-	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
 	if (!data)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -1444,6 +1444,13 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 			break;
 		}
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!data-&gt;bulk_out || !data-&gt;bulk_in) {</span>
<span class="p_add">+		dev_err(&amp;intf-&gt;dev, &quot;bulk endpoints not found\n&quot;);</span>
<span class="p_add">+		retcode = -ENODEV;</span>
<span class="p_add">+		goto err_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Find int endpoint */
 	for (n = 0; n &lt; iface_desc-&gt;desc.bNumEndpoints; n++) {
 		endpoint = &amp;iface_desc-&gt;endpoint[n].desc;
<span class="p_chunk">@@ -1469,8 +1476,10 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 	if (data-&gt;iin_ep_present) {
 		/* allocate int urb */
 		data-&gt;iin_urb = usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-		if (!data-&gt;iin_urb)</span>
<span class="p_add">+		if (!data-&gt;iin_urb) {</span>
<span class="p_add">+			retcode = -ENOMEM;</span>
 			goto error_register;
<span class="p_add">+		}</span>
 
 		/* Protect interrupt in endpoint data until iin_urb is freed */
 		kref_get(&amp;data-&gt;kref);
<span class="p_chunk">@@ -1478,8 +1487,10 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 		/* allocate buffer for interrupt in */
 		data-&gt;iin_buffer = kmalloc(data-&gt;iin_wMaxPacketSize,
 					GFP_KERNEL);
<span class="p_del">-		if (!data-&gt;iin_buffer)</span>
<span class="p_add">+		if (!data-&gt;iin_buffer) {</span>
<span class="p_add">+			retcode = -ENOMEM;</span>
 			goto error_register;
<span class="p_add">+		}</span>
 
 		/* fill interrupt urb */
 		usb_fill_int_urb(data-&gt;iin_urb, data-&gt;usb_dev,
<span class="p_chunk">@@ -1512,6 +1523,7 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;capability_attr_grp);
 	sysfs_remove_group(&amp;intf-&gt;dev.kobj, &amp;data_attr_grp);
 	usbtmc_free_int(data);
<span class="p_add">+err_put:</span>
 	kref_put(&amp;data-&gt;kref, usbtmc_delete);
 	return retcode;
 }
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 25dbd8c7aec7..4be52c602e9b 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -280,6 +280,16 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 
 			/*
 			 * Adjust bInterval for quirked devices.
<span class="p_add">+			 */</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This quirk fixes bIntervals reported in ms.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (to_usb_device(ddev)-&gt;quirks &amp;</span>
<span class="p_add">+				USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL) {</span>
<span class="p_add">+				n = clamp(fls(d-&gt;bInterval) + 3, i, j);</span>
<span class="p_add">+				i = j = n;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/*</span>
 			 * This quirk fixes bIntervals reported in
 			 * linear microframes.
 			 */
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index a56c75e09786..48fbf523d186 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -4275,7 +4275,7 @@</span> <span class="p_context"> static void hub_set_initial_usb2_lpm_policy(struct usb_device *udev)</span>
 	struct usb_hub *hub = usb_hub_to_struct_hub(udev-&gt;parent);
 	int connect_type = USB_PORT_CONNECT_TYPE_UNKNOWN;
 
<span class="p_del">-	if (!udev-&gt;usb2_hw_lpm_capable)</span>
<span class="p_add">+	if (!udev-&gt;usb2_hw_lpm_capable || !udev-&gt;bos)</span>
 		return;
 
 	if (hub)
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 24f9f98968a5..96b21b0dac1e 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -170,6 +170,14 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* M-Systems Flash Disk Pioneers */
 	{ USB_DEVICE(0x08ec, 0x1000), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_add">+	/* Baum Vario Ultra */</span>
<span class="p_add">+	{ USB_DEVICE(0x0904, 0x6101), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL },</span>
<span class="p_add">+	{ USB_DEVICE(0x0904, 0x6102), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL },</span>
<span class="p_add">+	{ USB_DEVICE(0x0904, 0x6103), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL },</span>
<span class="p_add">+</span>
 	/* Keytouch QWERTY Panel keyboard */
 	{ USB_DEVICE(0x0926, 0x3333), .driver_info =
 			USB_QUIRK_CONFIG_INTF_STRINGS },
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_acm.c b/drivers/usb/gadget/function/f_acm.c</span>
<span class="p_header">index a30766ca4226..5e3828d9dac7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_acm.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_acm.c</span>
<span class="p_chunk">@@ -535,13 +535,15 @@</span> <span class="p_context"> static int acm_notify_serial_state(struct f_acm *acm)</span>
 {
 	struct usb_composite_dev *cdev = acm-&gt;port.func.config-&gt;cdev;
 	int			status;
<span class="p_add">+	__le16			serial_state;</span>
 
 	spin_lock(&amp;acm-&gt;lock);
 	if (acm-&gt;notify_req) {
 		dev_dbg(&amp;cdev-&gt;gadget-&gt;dev, &quot;acm ttyGS%d serial state %04x\n&quot;,
 			acm-&gt;port_num, acm-&gt;serial_state);
<span class="p_add">+		serial_state = cpu_to_le16(acm-&gt;serial_state);</span>
 		status = acm_cdc_notify(acm, USB_CDC_NOTIFY_SERIAL_STATE,
<span class="p_del">-				0, &amp;acm-&gt;serial_state, sizeof(acm-&gt;serial_state));</span>
<span class="p_add">+				0, &amp;serial_state, sizeof(acm-&gt;serial_state));</span>
 	} else {
 		acm-&gt;pending = true;
 		status = 0;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_uvc.c b/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_header">index 29b41b5dee04..c7689d05356c 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_chunk">@@ -625,7 +625,7 @@</span> <span class="p_context"> uvc_function_bind(struct usb_configuration *c, struct usb_function *f)</span>
 	uvc_ss_streaming_comp.bMaxBurst = opts-&gt;streaming_maxburst;
 	uvc_ss_streaming_comp.wBytesPerInterval =
 		cpu_to_le16(max_packet_size * max_packet_mult *
<span class="p_del">-			    opts-&gt;streaming_maxburst);</span>
<span class="p_add">+			    (opts-&gt;streaming_maxburst + 1));</span>
 
 	/* Allocate endpoints. */
 	ep = usb_ep_autoconfig(cdev-&gt;gadget, &amp;uvc_control_ep);
<span class="p_header">diff --git a/drivers/usb/misc/idmouse.c b/drivers/usb/misc/idmouse.c</span>
<span class="p_header">index debc1fd74b0d..dc9328fd8030 100644</span>
<span class="p_header">--- a/drivers/usb/misc/idmouse.c</span>
<span class="p_header">+++ b/drivers/usb/misc/idmouse.c</span>
<span class="p_chunk">@@ -346,6 +346,9 @@</span> <span class="p_context"> static int idmouse_probe(struct usb_interface *interface,</span>
 	if (iface_desc-&gt;desc.bInterfaceClass != 0x0A)
 		return -ENODEV;
 
<span class="p_add">+	if (iface_desc-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	/* allocate memory for our device state and initialize it */
 	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (dev == NULL)
<span class="p_header">diff --git a/drivers/usb/misc/lvstest.c b/drivers/usb/misc/lvstest.c</span>
<span class="p_header">index 77176511658f..d3d124753266 100644</span>
<span class="p_header">--- a/drivers/usb/misc/lvstest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/lvstest.c</span>
<span class="p_chunk">@@ -366,6 +366,10 @@</span> <span class="p_context"> static int lvs_rh_probe(struct usb_interface *intf,</span>
 
 	hdev = interface_to_usbdev(intf);
 	desc = intf-&gt;cur_altsetting;
<span class="p_add">+</span>
<span class="p_add">+	if (desc-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	endpoint = &amp;desc-&gt;endpoint[0].desc;
 
 	/* valid only for SS root hub */
<span class="p_header">diff --git a/drivers/usb/misc/uss720.c b/drivers/usb/misc/uss720.c</span>
<span class="p_header">index 356d312add57..9ff66525924e 100644</span>
<span class="p_header">--- a/drivers/usb/misc/uss720.c</span>
<span class="p_header">+++ b/drivers/usb/misc/uss720.c</span>
<span class="p_chunk">@@ -708,6 +708,11 @@</span> <span class="p_context"> static int uss720_probe(struct usb_interface *intf,</span>
 
 	interface = intf-&gt;cur_altsetting;
 
<span class="p_add">+	if (interface-&gt;desc.bNumEndpoints &lt; 3) {</span>
<span class="p_add">+		usb_put_dev(usbdev);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Allocate parport interface 
 	 */
<span class="p_header">diff --git a/drivers/usb/musb/musb_cppi41.c b/drivers/usb/musb/musb_cppi41.c</span>
<span class="p_header">index 16363852c034..cac3b21a720b 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_cppi41.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_cppi41.c</span>
<span class="p_chunk">@@ -231,8 +231,27 @@</span> <span class="p_context"> static void cppi41_dma_callback(void *private_data)</span>
 			transferred &lt; cppi41_channel-&gt;packet_sz)
 		cppi41_channel-&gt;prog_len = 0;
 
<span class="p_del">-	if (cppi41_channel-&gt;is_tx)</span>
<span class="p_del">-		empty = musb_is_tx_fifo_empty(hw_ep);</span>
<span class="p_add">+	if (cppi41_channel-&gt;is_tx) {</span>
<span class="p_add">+		u8 type;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (is_host_active(musb))</span>
<span class="p_add">+			type = hw_ep-&gt;out_qh-&gt;type;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			type = hw_ep-&gt;ep_in.type;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (type == USB_ENDPOINT_XFER_ISOC)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Don&#39;t use the early-TX-interrupt workaround below</span>
<span class="p_add">+			 * for Isoch transfter. Since Isoch are periodic</span>
<span class="p_add">+			 * transfer, by the time the next transfer is</span>
<span class="p_add">+			 * scheduled, the current one should be done already.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * This avoids audio playback underrun issue.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			empty = true;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			empty = musb_is_tx_fifo_empty(hw_ep);</span>
<span class="p_add">+	}</span>
 
 	if (!cppi41_channel-&gt;is_tx || empty) {
 		cppi41_trans_done(cppi41_channel);
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 42cc72e54c05..af67a0de6b5d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -233,6 +233,14 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define BANDRICH_PRODUCT_1012			0x1012
 
 #define QUALCOMM_VENDOR_ID			0x05C6
<span class="p_add">+/* These Quectel products use Qualcomm&#39;s vendor ID */</span>
<span class="p_add">+#define QUECTEL_PRODUCT_UC20			0x9003</span>
<span class="p_add">+#define QUECTEL_PRODUCT_UC15			0x9090</span>
<span class="p_add">+</span>
<span class="p_add">+#define QUECTEL_VENDOR_ID			0x2c7c</span>
<span class="p_add">+/* These Quectel products use Quectel&#39;s vendor ID */</span>
<span class="p_add">+#define QUECTEL_PRODUCT_EC21			0x0121</span>
<span class="p_add">+#define QUECTEL_PRODUCT_EC25			0x0125</span>
 
 #define CMOTECH_VENDOR_ID			0x16d8
 #define CMOTECH_PRODUCT_6001			0x6001
<span class="p_chunk">@@ -1161,7 +1169,14 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6613)}, /* Onda H600/ZTE MF330 */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0023)}, /* ONYX 3G device */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
<span class="p_del">-	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9003), /* Quectel UC20 */</span>
<span class="p_add">+	/* Quectel products using Qualcomm vendor ID */</span>
<span class="p_add">+	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC15)},</span>
<span class="p_add">+	{ USB_DEVICE(QUALCOMM_VENDOR_ID, QUECTEL_PRODUCT_UC20),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
<span class="p_add">+	/* Quectel products using Quectel vendor ID */</span>
<span class="p_add">+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC21),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE(QUECTEL_VENDOR_ID, QUECTEL_PRODUCT_EC25),</span>
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_6001) },
 	{ USB_DEVICE(CMOTECH_VENDOR_ID, CMOTECH_PRODUCT_CMU_300) },
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index 696458db7e3c..38b3f0d8cd58 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -169,6 +169,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x413c, 0x81a9)},	/* Dell Wireless 5808e Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81b1)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81b3)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81b5)},	/* Dell Wireless 5811e QDL */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81b6)},	/* Dell Wireless 5811e QDL */</span>
 
 	/* Huawei devices */
 	{DEVICE_HWI(0x03f0, 0x581d)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Modem (Huawei me906e) */
<span class="p_header">diff --git a/drivers/usb/wusbcore/wa-hc.c b/drivers/usb/wusbcore/wa-hc.c</span>
<span class="p_header">index 252c7bd9218a..d01496fd27fe 100644</span>
<span class="p_header">--- a/drivers/usb/wusbcore/wa-hc.c</span>
<span class="p_header">+++ b/drivers/usb/wusbcore/wa-hc.c</span>
<span class="p_chunk">@@ -39,6 +39,9 @@</span> <span class="p_context"> int wa_create(struct wahc *wa, struct usb_interface *iface,</span>
 	int result;
 	struct device *dev = &amp;iface-&gt;dev;
 
<span class="p_add">+	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 3)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	result = wa_rpipes_create(wa);
 	if (result &lt; 0)
 		goto error_rpipes_create;
<span class="p_header">diff --git a/drivers/uwb/hwa-rc.c b/drivers/uwb/hwa-rc.c</span>
<span class="p_header">index 0aa6c3c29d17..35a1e777b449 100644</span>
<span class="p_header">--- a/drivers/uwb/hwa-rc.c</span>
<span class="p_header">+++ b/drivers/uwb/hwa-rc.c</span>
<span class="p_chunk">@@ -823,6 +823,9 @@</span> <span class="p_context"> static int hwarc_probe(struct usb_interface *iface,</span>
 	struct hwarc *hwarc;
 	struct device *dev = &amp;iface-&gt;dev;
 
<span class="p_add">+	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	result = -ENOMEM;
 	uwb_rc = uwb_rc_alloc();
 	if (uwb_rc == NULL) {
<span class="p_header">diff --git a/drivers/uwb/i1480/dfu/usb.c b/drivers/uwb/i1480/dfu/usb.c</span>
<span class="p_header">index 2bfc846ac071..6345e85822a4 100644</span>
<span class="p_header">--- a/drivers/uwb/i1480/dfu/usb.c</span>
<span class="p_header">+++ b/drivers/uwb/i1480/dfu/usb.c</span>
<span class="p_chunk">@@ -362,6 +362,9 @@</span> <span class="p_context"> int i1480_usb_probe(struct usb_interface *iface, const struct usb_device_id *id)</span>
 				 result);
 	}
 
<span class="p_add">+	if (iface-&gt;cur_altsetting-&gt;desc.bNumEndpoints &lt; 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	result = -ENOMEM;
 	i1480_usb = kzalloc(sizeof(*i1480_usb), GFP_KERNEL);
 	if (i1480_usb == NULL) {
<span class="p_header">diff --git a/drivers/vfio/vfio.c b/drivers/vfio/vfio.c</span>
<span class="p_header">index 9901c4671e2f..6e10325596b6 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio.c</span>
<span class="p_chunk">@@ -403,6 +403,7 @@</span> <span class="p_context"> static void vfio_group_release(struct kref *kref)</span>
 	struct iommu_group *iommu_group = group-&gt;iommu_group;
 
 	WARN_ON(!list_empty(&amp;group-&gt;device_list));
<span class="p_add">+	WARN_ON(group-&gt;notifier.head);</span>
 
 	list_for_each_entry_safe(unbound, tmp,
 				 &amp;group-&gt;unbound_list, unbound_next) {
<span class="p_chunk">@@ -1573,6 +1574,10 @@</span> <span class="p_context"> static int vfio_group_fops_open(struct inode *inode, struct file *filep)</span>
 		return -EBUSY;
 	}
 
<span class="p_add">+	/* Warn if previous user didn&#39;t cleanup and re-init to drop them */</span>
<span class="p_add">+	if (WARN_ON(group-&gt;notifier.head))</span>
<span class="p_add">+		BLOCKING_INIT_NOTIFIER_HEAD(&amp;group-&gt;notifier);</span>
<span class="p_add">+</span>
 	filep-&gt;private_data = group;
 
 	return 0;
<span class="p_chunk">@@ -1584,9 +1589,6 @@</span> <span class="p_context"> static int vfio_group_fops_release(struct inode *inode, struct file *filep)</span>
 
 	filep-&gt;private_data = NULL;
 
<span class="p_del">-	/* Any user didn&#39;t unregister? */</span>
<span class="p_del">-	WARN_ON(group-&gt;notifier.head);</span>
<span class="p_del">-</span>
 	vfio_group_try_dissolve_container(group);
 
 	atomic_dec(&amp;group-&gt;opened);
<span class="p_header">diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c</span>
<span class="p_header">index a44f5627b82a..f4daadff8a6c 100644</span>
<span class="p_header">--- a/drivers/video/console/fbcon.c</span>
<span class="p_header">+++ b/drivers/video/console/fbcon.c</span>
<span class="p_chunk">@@ -1165,6 +1165,8 @@</span> <span class="p_context"> static void fbcon_free_font(struct display *p, bool freefont)</span>
 	p-&gt;userfont = 0;
 }
 
<span class="p_add">+static void set_vc_hi_font(struct vc_data *vc, bool set);</span>
<span class="p_add">+</span>
 static void fbcon_deinit(struct vc_data *vc)
 {
 	struct display *p = &amp;fb_display[vc-&gt;vc_num];
<span class="p_chunk">@@ -1200,6 +1202,9 @@</span> <span class="p_context"> static void fbcon_deinit(struct vc_data *vc)</span>
 	if (free_font)
 		vc-&gt;vc_font.data = NULL;
 
<span class="p_add">+	if (vc-&gt;vc_hi_font_mask)</span>
<span class="p_add">+		set_vc_hi_font(vc, false);</span>
<span class="p_add">+</span>
 	if (!con_is_bound(&amp;fb_con))
 		fbcon_exit();
 
<span class="p_chunk">@@ -2436,32 +2441,10 @@</span> <span class="p_context"> static int fbcon_get_font(struct vc_data *vc, struct console_font *font)</span>
 	return 0;
 }
 
<span class="p_del">-static int fbcon_do_set_font(struct vc_data *vc, int w, int h,</span>
<span class="p_del">-			     const u8 * data, int userfont)</span>
<span class="p_add">+/* set/clear vc_hi_font_mask and update vc attrs accordingly */</span>
<span class="p_add">+static void set_vc_hi_font(struct vc_data *vc, bool set)</span>
 {
<span class="p_del">-	struct fb_info *info = registered_fb[con2fb_map[vc-&gt;vc_num]];</span>
<span class="p_del">-	struct fbcon_ops *ops = info-&gt;fbcon_par;</span>
<span class="p_del">-	struct display *p = &amp;fb_display[vc-&gt;vc_num];</span>
<span class="p_del">-	int resize;</span>
<span class="p_del">-	int cnt;</span>
<span class="p_del">-	char *old_data = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (con_is_visible(vc) &amp;&amp; softback_lines)</span>
<span class="p_del">-		fbcon_set_origin(vc);</span>
<span class="p_del">-</span>
<span class="p_del">-	resize = (w != vc-&gt;vc_font.width) || (h != vc-&gt;vc_font.height);</span>
<span class="p_del">-	if (p-&gt;userfont)</span>
<span class="p_del">-		old_data = vc-&gt;vc_font.data;</span>
<span class="p_del">-	if (userfont)</span>
<span class="p_del">-		cnt = FNTCHARCNT(data);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		cnt = 256;</span>
<span class="p_del">-	vc-&gt;vc_font.data = (void *)(p-&gt;fontdata = data);</span>
<span class="p_del">-	if ((p-&gt;userfont = userfont))</span>
<span class="p_del">-		REFCOUNT(data)++;</span>
<span class="p_del">-	vc-&gt;vc_font.width = w;</span>
<span class="p_del">-	vc-&gt;vc_font.height = h;</span>
<span class="p_del">-	if (vc-&gt;vc_hi_font_mask &amp;&amp; cnt == 256) {</span>
<span class="p_add">+	if (!set) {</span>
 		vc-&gt;vc_hi_font_mask = 0;
 		if (vc-&gt;vc_can_do_color) {
 			vc-&gt;vc_complement_mask &gt;&gt;= 1;
<span class="p_chunk">@@ -2484,7 +2467,7 @@</span> <span class="p_context"> static int fbcon_do_set_font(struct vc_data *vc, int w, int h,</span>
 			    ((c &amp; 0xfe00) &gt;&gt; 1) | (c &amp; 0xff);
 			vc-&gt;vc_attr &gt;&gt;= 1;
 		}
<span class="p_del">-	} else if (!vc-&gt;vc_hi_font_mask &amp;&amp; cnt == 512) {</span>
<span class="p_add">+	} else {</span>
 		vc-&gt;vc_hi_font_mask = 0x100;
 		if (vc-&gt;vc_can_do_color) {
 			vc-&gt;vc_complement_mask &lt;&lt;= 1;
<span class="p_chunk">@@ -2516,8 +2499,38 @@</span> <span class="p_context"> static int fbcon_do_set_font(struct vc_data *vc, int w, int h,</span>
 			} else
 				vc-&gt;vc_video_erase_char = c &amp; ~0x100;
 		}
<span class="p_del">-</span>
 	}
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int fbcon_do_set_font(struct vc_data *vc, int w, int h,</span>
<span class="p_add">+			     const u8 * data, int userfont)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fb_info *info = registered_fb[con2fb_map[vc-&gt;vc_num]];</span>
<span class="p_add">+	struct fbcon_ops *ops = info-&gt;fbcon_par;</span>
<span class="p_add">+	struct display *p = &amp;fb_display[vc-&gt;vc_num];</span>
<span class="p_add">+	int resize;</span>
<span class="p_add">+	int cnt;</span>
<span class="p_add">+	char *old_data = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (con_is_visible(vc) &amp;&amp; softback_lines)</span>
<span class="p_add">+		fbcon_set_origin(vc);</span>
<span class="p_add">+</span>
<span class="p_add">+	resize = (w != vc-&gt;vc_font.width) || (h != vc-&gt;vc_font.height);</span>
<span class="p_add">+	if (p-&gt;userfont)</span>
<span class="p_add">+		old_data = vc-&gt;vc_font.data;</span>
<span class="p_add">+	if (userfont)</span>
<span class="p_add">+		cnt = FNTCHARCNT(data);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		cnt = 256;</span>
<span class="p_add">+	vc-&gt;vc_font.data = (void *)(p-&gt;fontdata = data);</span>
<span class="p_add">+	if ((p-&gt;userfont = userfont))</span>
<span class="p_add">+		REFCOUNT(data)++;</span>
<span class="p_add">+	vc-&gt;vc_font.width = w;</span>
<span class="p_add">+	vc-&gt;vc_font.height = h;</span>
<span class="p_add">+	if (vc-&gt;vc_hi_font_mask &amp;&amp; cnt == 256)</span>
<span class="p_add">+		set_vc_hi_font(vc, false);</span>
<span class="p_add">+	else if (!vc-&gt;vc_hi_font_mask &amp;&amp; cnt == 512)</span>
<span class="p_add">+		set_vc_hi_font(vc, true);</span>
 
 	if (resize) {
 		int cols, rows;
<span class="p_header">diff --git a/drivers/xen/xen-acpi-processor.c b/drivers/xen/xen-acpi-processor.c</span>
<span class="p_header">index 4ce10bcca18b..4b857463a2b4 100644</span>
<span class="p_header">--- a/drivers/xen/xen-acpi-processor.c</span>
<span class="p_header">+++ b/drivers/xen/xen-acpi-processor.c</span>
<span class="p_chunk">@@ -27,10 +27,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/syscore_ops.h&gt;</span>
 #include &lt;linux/acpi.h&gt;
 #include &lt;acpi/processor.h&gt;
 #include &lt;xen/xen.h&gt;
<span class="p_del">-#include &lt;xen/xen-ops.h&gt;</span>
 #include &lt;xen/interface/platform.h&gt;
 #include &lt;asm/xen/hypercall.h&gt;
 
<span class="p_chunk">@@ -466,15 +466,33 @@</span> <span class="p_context"> static int xen_upload_processor_pm_data(void)</span>
 	return rc;
 }
 
<span class="p_del">-static int xen_acpi_processor_resume(struct notifier_block *nb,</span>
<span class="p_del">-				     unsigned long action, void *data)</span>
<span class="p_add">+static void xen_acpi_processor_resume_worker(struct work_struct *dummy)</span>
 {
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
 	bitmap_zero(acpi_ids_done, nr_acpi_bits);
<span class="p_del">-	return xen_upload_processor_pm_data();</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = xen_upload_processor_pm_data();</span>
<span class="p_add">+	if (rc != 0)</span>
<span class="p_add">+		pr_info(&quot;ACPI data upload failed, error = %d\n&quot;, rc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_acpi_processor_resume(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static DECLARE_WORK(wq, xen_acpi_processor_resume_worker);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * xen_upload_processor_pm_data() calls non-atomic code.</span>
<span class="p_add">+	 * However, the context for xen_acpi_processor_resume is syscore</span>
<span class="p_add">+	 * with only the boot CPU online and in an atomic context.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * So defer the upload for some point safer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	schedule_work(&amp;wq);</span>
 }
 
<span class="p_del">-struct notifier_block xen_acpi_processor_resume_nb = {</span>
<span class="p_del">-	.notifier_call = xen_acpi_processor_resume,</span>
<span class="p_add">+static struct syscore_ops xap_syscore_ops = {</span>
<span class="p_add">+	.resume	= xen_acpi_processor_resume,</span>
 };
 
 static int __init xen_acpi_processor_init(void)
<span class="p_chunk">@@ -527,7 +545,7 @@</span> <span class="p_context"> static int __init xen_acpi_processor_init(void)</span>
 	if (rc)
 		goto err_unregister;
 
<span class="p_del">-	xen_resume_notifier_register(&amp;xen_acpi_processor_resume_nb);</span>
<span class="p_add">+	register_syscore_ops(&amp;xap_syscore_ops);</span>
 
 	return 0;
 err_unregister:
<span class="p_chunk">@@ -544,7 +562,7 @@</span> <span class="p_context"> static void __exit xen_acpi_processor_exit(void)</span>
 {
 	int i;
 
<span class="p_del">-	xen_resume_notifier_unregister(&amp;xen_acpi_processor_resume_nb);</span>
<span class="p_add">+	unregister_syscore_ops(&amp;xap_syscore_ops);</span>
 	kfree(acpi_ids_done);
 	kfree(acpi_id_present);
 	kfree(acpi_id_cst_present);
<span class="p_header">diff --git a/fs/crypto/crypto.c b/fs/crypto/crypto.c</span>
<span class="p_header">index ac8e4f6a3773..3c2ca312c251 100644</span>
<span class="p_header">--- a/fs/crypto/crypto.c</span>
<span class="p_header">+++ b/fs/crypto/crypto.c</span>
<span class="p_chunk">@@ -394,7 +394,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(fscrypt_zeroout_range);</span>
 static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)
 {
 	struct dentry *dir;
<span class="p_del">-	struct fscrypt_info *ci;</span>
 	int dir_has_key, cached_with_key;
 
 	if (flags &amp; LOOKUP_RCU)
<span class="p_chunk">@@ -406,18 +405,11 @@</span> <span class="p_context"> static int fscrypt_d_revalidate(struct dentry *dentry, unsigned int flags)</span>
 		return 0;
 	}
 
<span class="p_del">-	ci = d_inode(dir)-&gt;i_crypt_info;</span>
<span class="p_del">-	if (ci &amp;&amp; ci-&gt;ci_keyring_key &amp;&amp;</span>
<span class="p_del">-	    (ci-&gt;ci_keyring_key-&gt;flags &amp; ((1 &lt;&lt; KEY_FLAG_INVALIDATED) |</span>
<span class="p_del">-					  (1 &lt;&lt; KEY_FLAG_REVOKED) |</span>
<span class="p_del">-					  (1 &lt;&lt; KEY_FLAG_DEAD))))</span>
<span class="p_del">-		ci = NULL;</span>
<span class="p_del">-</span>
 	/* this should eventually be an flag in d_flags */
 	spin_lock(&amp;dentry-&gt;d_lock);
 	cached_with_key = dentry-&gt;d_flags &amp; DCACHE_ENCRYPTED_WITH_KEY;
 	spin_unlock(&amp;dentry-&gt;d_lock);
<span class="p_del">-	dir_has_key = (ci != NULL);</span>
<span class="p_add">+	dir_has_key = (d_inode(dir)-&gt;i_crypt_info != NULL);</span>
 	dput(dir);
 
 	/*
<span class="p_header">diff --git a/fs/crypto/fname.c b/fs/crypto/fname.c</span>
<span class="p_header">index 56ad9d195f18..8af4d5224bdd 100644</span>
<span class="p_header">--- a/fs/crypto/fname.c</span>
<span class="p_header">+++ b/fs/crypto/fname.c</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> int fscrypt_setup_filename(struct inode *dir, const struct qstr *iname,</span>
 		fname-&gt;disk_name.len = iname-&gt;len;
 		return 0;
 	}
<span class="p_del">-	ret = fscrypt_get_crypt_info(dir);</span>
<span class="p_add">+	ret = fscrypt_get_encryption_info(dir);</span>
 	if (ret &amp;&amp; ret != -EOPNOTSUPP)
 		return ret;
 
<span class="p_header">diff --git a/fs/crypto/fscrypt_private.h b/fs/crypto/fscrypt_private.h</span>
<span class="p_header">index aeab032d7d35..b7b9b566bd86 100644</span>
<span class="p_header">--- a/fs/crypto/fscrypt_private.h</span>
<span class="p_header">+++ b/fs/crypto/fscrypt_private.h</span>
<span class="p_chunk">@@ -67,7 +67,6 @@</span> <span class="p_context"> struct fscrypt_info {</span>
 	u8 ci_filename_mode;
 	u8 ci_flags;
 	struct crypto_skcipher *ci_ctfm;
<span class="p_del">-	struct key *ci_keyring_key;</span>
 	u8 ci_master_key[FS_KEY_DESCRIPTOR_SIZE];
 };
 
<span class="p_chunk">@@ -87,7 +86,4 @@</span> <span class="p_context"> struct fscrypt_completion_result {</span>
 /* crypto.c */
 int fscrypt_initialize(unsigned int cop_flags);
 
<span class="p_del">-/* keyinfo.c */</span>
<span class="p_del">-extern int fscrypt_get_crypt_info(struct inode *);</span>
<span class="p_del">-</span>
 #endif /* _FSCRYPT_PRIVATE_H */
<span class="p_header">diff --git a/fs/crypto/keyinfo.c b/fs/crypto/keyinfo.c</span>
<span class="p_header">index 95cd4c3b06c3..6df6ad3af432 100644</span>
<span class="p_header">--- a/fs/crypto/keyinfo.c</span>
<span class="p_header">+++ b/fs/crypto/keyinfo.c</span>
<span class="p_chunk">@@ -99,6 +99,7 @@</span> <span class="p_context"> static int validate_user_key(struct fscrypt_info *crypt_info,</span>
 	kfree(full_key_descriptor);
 	if (IS_ERR(keyring_key))
 		return PTR_ERR(keyring_key);
<span class="p_add">+	down_read(&amp;keyring_key-&gt;sem);</span>
 
 	if (keyring_key-&gt;type != &amp;key_type_logon) {
 		printk_once(KERN_WARNING
<span class="p_chunk">@@ -106,11 +107,9 @@</span> <span class="p_context"> static int validate_user_key(struct fscrypt_info *crypt_info,</span>
 		res = -ENOKEY;
 		goto out;
 	}
<span class="p_del">-	down_read(&amp;keyring_key-&gt;sem);</span>
 	ukp = user_key_payload(keyring_key);
 	if (ukp-&gt;datalen != sizeof(struct fscrypt_key)) {
 		res = -EINVAL;
<span class="p_del">-		up_read(&amp;keyring_key-&gt;sem);</span>
 		goto out;
 	}
 	master_key = (struct fscrypt_key *)ukp-&gt;data;
<span class="p_chunk">@@ -121,17 +120,11 @@</span> <span class="p_context"> static int validate_user_key(struct fscrypt_info *crypt_info,</span>
 				&quot;%s: key size incorrect: %d\n&quot;,
 				__func__, master_key-&gt;size);
 		res = -ENOKEY;
<span class="p_del">-		up_read(&amp;keyring_key-&gt;sem);</span>
 		goto out;
 	}
 	res = derive_key_aes(ctx-&gt;nonce, master_key-&gt;raw, raw_key);
<span class="p_del">-	up_read(&amp;keyring_key-&gt;sem);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	crypt_info-&gt;ci_keyring_key = keyring_key;</span>
<span class="p_del">-	return 0;</span>
 out:
<span class="p_add">+	up_read(&amp;keyring_key-&gt;sem);</span>
 	key_put(keyring_key);
 	return res;
 }
<span class="p_chunk">@@ -173,12 +166,11 @@</span> <span class="p_context"> static void put_crypt_info(struct fscrypt_info *ci)</span>
 	if (!ci)
 		return;
 
<span class="p_del">-	key_put(ci-&gt;ci_keyring_key);</span>
 	crypto_free_skcipher(ci-&gt;ci_ctfm);
 	kmem_cache_free(fscrypt_info_cachep, ci);
 }
 
<span class="p_del">-int fscrypt_get_crypt_info(struct inode *inode)</span>
<span class="p_add">+int fscrypt_get_encryption_info(struct inode *inode)</span>
 {
 	struct fscrypt_info *crypt_info;
 	struct fscrypt_context ctx;
<span class="p_chunk">@@ -188,21 +180,15 @@</span> <span class="p_context"> int fscrypt_get_crypt_info(struct inode *inode)</span>
 	u8 *raw_key = NULL;
 	int res;
 
<span class="p_add">+	if (inode-&gt;i_crypt_info)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	res = fscrypt_initialize(inode-&gt;i_sb-&gt;s_cop-&gt;flags);
 	if (res)
 		return res;
 
 	if (!inode-&gt;i_sb-&gt;s_cop-&gt;get_context)
 		return -EOPNOTSUPP;
<span class="p_del">-retry:</span>
<span class="p_del">-	crypt_info = ACCESS_ONCE(inode-&gt;i_crypt_info);</span>
<span class="p_del">-	if (crypt_info) {</span>
<span class="p_del">-		if (!crypt_info-&gt;ci_keyring_key ||</span>
<span class="p_del">-				key_validate(crypt_info-&gt;ci_keyring_key) == 0)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		fscrypt_put_encryption_info(inode, crypt_info);</span>
<span class="p_del">-		goto retry;</span>
<span class="p_del">-	}</span>
 
 	res = inode-&gt;i_sb-&gt;s_cop-&gt;get_context(inode, &amp;ctx, sizeof(ctx));
 	if (res &lt; 0) {
<span class="p_chunk">@@ -230,7 +216,6 @@</span> <span class="p_context"> int fscrypt_get_crypt_info(struct inode *inode)</span>
 	crypt_info-&gt;ci_data_mode = ctx.contents_encryption_mode;
 	crypt_info-&gt;ci_filename_mode = ctx.filenames_encryption_mode;
 	crypt_info-&gt;ci_ctfm = NULL;
<span class="p_del">-	crypt_info-&gt;ci_keyring_key = NULL;</span>
 	memcpy(crypt_info-&gt;ci_master_key, ctx.master_key_descriptor,
 				sizeof(crypt_info-&gt;ci_master_key));
 
<span class="p_chunk">@@ -286,14 +271,8 @@</span> <span class="p_context"> int fscrypt_get_crypt_info(struct inode *inode)</span>
 	if (res)
 		goto out;
 
<span class="p_del">-	kzfree(raw_key);</span>
<span class="p_del">-	raw_key = NULL;</span>
<span class="p_del">-	if (cmpxchg(&amp;inode-&gt;i_crypt_info, NULL, crypt_info) != NULL) {</span>
<span class="p_del">-		put_crypt_info(crypt_info);</span>
<span class="p_del">-		goto retry;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_add">+	if (cmpxchg(&amp;inode-&gt;i_crypt_info, NULL, crypt_info) == NULL)</span>
<span class="p_add">+		crypt_info = NULL;</span>
 out:
 	if (res == -ENOKEY)
 		res = 0;
<span class="p_chunk">@@ -301,6 +280,7 @@</span> <span class="p_context"> int fscrypt_get_crypt_info(struct inode *inode)</span>
 	kzfree(raw_key);
 	return res;
 }
<span class="p_add">+EXPORT_SYMBOL(fscrypt_get_encryption_info);</span>
 
 void fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)
 {
<span class="p_chunk">@@ -318,17 +298,3 @@</span> <span class="p_context"> void fscrypt_put_encryption_info(struct inode *inode, struct fscrypt_info *ci)</span>
 	put_crypt_info(ci);
 }
 EXPORT_SYMBOL(fscrypt_put_encryption_info);
<span class="p_del">-</span>
<span class="p_del">-int fscrypt_get_encryption_info(struct inode *inode)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct fscrypt_info *ci = inode-&gt;i_crypt_info;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ci ||</span>
<span class="p_del">-		(ci-&gt;ci_keyring_key &amp;&amp;</span>
<span class="p_del">-		 (ci-&gt;ci_keyring_key-&gt;flags &amp; ((1 &lt;&lt; KEY_FLAG_INVALIDATED) |</span>
<span class="p_del">-					       (1 &lt;&lt; KEY_FLAG_REVOKED) |</span>
<span class="p_del">-					       (1 &lt;&lt; KEY_FLAG_DEAD)))))</span>
<span class="p_del">-		return fscrypt_get_crypt_info(inode);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(fscrypt_get_encryption_info);</span>
<span class="p_header">diff --git a/fs/ext4/inline.c b/fs/ext4/inline.c</span>
<span class="p_header">index 627ace344739..b6a38ecbca00 100644</span>
<span class="p_header">--- a/fs/ext4/inline.c</span>
<span class="p_header">+++ b/fs/ext4/inline.c</span>
<span class="p_chunk">@@ -1167,10 +1167,9 @@</span> <span class="p_context"> static int ext4_finish_convert_inline_dir(handle_t *handle,</span>
 	set_buffer_uptodate(dir_block);
 	err = ext4_handle_dirty_dirent_node(handle, inode, dir_block);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return err;</span>
 	set_buffer_verified(dir_block);
<span class="p_del">-out:</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return ext4_mark_inode_dirty(handle, inode);</span>
 }
 
 static int ext4_convert_inline_data_nolock(handle_t *handle,
<span class="p_header">diff --git a/fs/ext4/xattr.c b/fs/ext4/xattr.c</span>
<span class="p_header">index c40bd55b6400..7b5a683defe6 100644</span>
<span class="p_header">--- a/fs/ext4/xattr.c</span>
<span class="p_header">+++ b/fs/ext4/xattr.c</span>
<span class="p_chunk">@@ -131,31 +131,26 @@</span> <span class="p_context"> static __le32 ext4_xattr_block_csum(struct inode *inode,</span>
 }
 
 static int ext4_xattr_block_csum_verify(struct inode *inode,
<span class="p_del">-					sector_t block_nr,</span>
<span class="p_del">-					struct ext4_xattr_header *hdr)</span>
<span class="p_add">+					struct buffer_head *bh)</span>
 {
<span class="p_del">-	if (ext4_has_metadata_csum(inode-&gt;i_sb) &amp;&amp;</span>
<span class="p_del">-	    (hdr-&gt;h_checksum != ext4_xattr_block_csum(inode, block_nr, hdr)))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void ext4_xattr_block_csum_set(struct inode *inode,</span>
<span class="p_del">-				      sector_t block_nr,</span>
<span class="p_del">-				      struct ext4_xattr_header *hdr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!ext4_has_metadata_csum(inode-&gt;i_sb))</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	struct ext4_xattr_header *hdr = BHDR(bh);</span>
<span class="p_add">+	int ret = 1;</span>
 
<span class="p_del">-	hdr-&gt;h_checksum = ext4_xattr_block_csum(inode, block_nr, hdr);</span>
<span class="p_add">+	if (ext4_has_metadata_csum(inode-&gt;i_sb)) {</span>
<span class="p_add">+		lock_buffer(bh);</span>
<span class="p_add">+		ret = (hdr-&gt;h_checksum == ext4_xattr_block_csum(inode,</span>
<span class="p_add">+							bh-&gt;b_blocknr, hdr));</span>
<span class="p_add">+		unlock_buffer(bh);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
 }
 
<span class="p_del">-static inline int ext4_handle_dirty_xattr_block(handle_t *handle,</span>
<span class="p_del">-						struct inode *inode,</span>
<span class="p_del">-						struct buffer_head *bh)</span>
<span class="p_add">+static void ext4_xattr_block_csum_set(struct inode *inode,</span>
<span class="p_add">+				      struct buffer_head *bh)</span>
 {
<span class="p_del">-	ext4_xattr_block_csum_set(inode, bh-&gt;b_blocknr, BHDR(bh));</span>
<span class="p_del">-	return ext4_handle_dirty_metadata(handle, inode, bh);</span>
<span class="p_add">+	if (ext4_has_metadata_csum(inode-&gt;i_sb))</span>
<span class="p_add">+		BHDR(bh)-&gt;h_checksum = ext4_xattr_block_csum(inode,</span>
<span class="p_add">+						bh-&gt;b_blocknr, BHDR(bh));</span>
 }
 
 static inline const struct xattr_handler *
<span class="p_chunk">@@ -233,7 +228,7 @@</span> <span class="p_context"> ext4_xattr_check_block(struct inode *inode, struct buffer_head *bh)</span>
 	if (BHDR(bh)-&gt;h_magic != cpu_to_le32(EXT4_XATTR_MAGIC) ||
 	    BHDR(bh)-&gt;h_blocks != cpu_to_le32(1))
 		return -EFSCORRUPTED;
<span class="p_del">-	if (!ext4_xattr_block_csum_verify(inode, bh-&gt;b_blocknr, BHDR(bh)))</span>
<span class="p_add">+	if (!ext4_xattr_block_csum_verify(inode, bh))</span>
 		return -EFSBADCRC;
 	error = ext4_xattr_check_names(BFIRST(bh), bh-&gt;b_data + bh-&gt;b_size,
 				       bh-&gt;b_data);
<span class="p_chunk">@@ -615,23 +610,22 @@</span> <span class="p_context"> ext4_xattr_release_block(handle_t *handle, struct inode *inode,</span>
 			}
 		}
 
<span class="p_add">+		ext4_xattr_block_csum_set(inode, bh);</span>
 		/*
 		 * Beware of this ugliness: Releasing of xattr block references
 		 * from different inodes can race and so we have to protect
 		 * from a race where someone else frees the block (and releases
 		 * its journal_head) before we are done dirtying the buffer. In
 		 * nojournal mode this race is harmless and we actually cannot
<span class="p_del">-		 * call ext4_handle_dirty_xattr_block() with locked buffer as</span>
<span class="p_add">+		 * call ext4_handle_dirty_metadata() with locked buffer as</span>
 		 * that function can call sync_dirty_buffer() so for that case
 		 * we handle the dirtying after unlocking the buffer.
 		 */
 		if (ext4_handle_valid(handle))
<span class="p_del">-			error = ext4_handle_dirty_xattr_block(handle, inode,</span>
<span class="p_del">-							      bh);</span>
<span class="p_add">+			error = ext4_handle_dirty_metadata(handle, inode, bh);</span>
 		unlock_buffer(bh);
 		if (!ext4_handle_valid(handle))
<span class="p_del">-			error = ext4_handle_dirty_xattr_block(handle, inode,</span>
<span class="p_del">-							      bh);</span>
<span class="p_add">+			error = ext4_handle_dirty_metadata(handle, inode, bh);</span>
 		if (IS_SYNC(inode))
 			ext4_handle_sync(handle);
 		dquot_free_block(inode, EXT4_C2B(EXT4_SB(inode-&gt;i_sb), 1));
<span class="p_chunk">@@ -860,13 +854,14 @@</span> <span class="p_context"> ext4_xattr_block_set(handle_t *handle, struct inode *inode,</span>
 				ext4_xattr_cache_insert(ext4_mb_cache,
 					bs-&gt;bh);
 			}
<span class="p_add">+			ext4_xattr_block_csum_set(inode, bs-&gt;bh);</span>
 			unlock_buffer(bs-&gt;bh);
 			if (error == -EFSCORRUPTED)
 				goto bad_block;
 			if (!error)
<span class="p_del">-				error = ext4_handle_dirty_xattr_block(handle,</span>
<span class="p_del">-								      inode,</span>
<span class="p_del">-								      bs-&gt;bh);</span>
<span class="p_add">+				error = ext4_handle_dirty_metadata(handle,</span>
<span class="p_add">+								   inode,</span>
<span class="p_add">+								   bs-&gt;bh);</span>
 			if (error)
 				goto cleanup;
 			goto inserted;
<span class="p_chunk">@@ -964,10 +959,11 @@</span> <span class="p_context"> ext4_xattr_block_set(handle_t *handle, struct inode *inode,</span>
 					ce-&gt;e_reusable = 0;
 				ea_bdebug(new_bh, &quot;reusing; refcount now=%d&quot;,
 					  ref);
<span class="p_add">+				ext4_xattr_block_csum_set(inode, new_bh);</span>
 				unlock_buffer(new_bh);
<span class="p_del">-				error = ext4_handle_dirty_xattr_block(handle,</span>
<span class="p_del">-								      inode,</span>
<span class="p_del">-								      new_bh);</span>
<span class="p_add">+				error = ext4_handle_dirty_metadata(handle,</span>
<span class="p_add">+								   inode,</span>
<span class="p_add">+								   new_bh);</span>
 				if (error)
 					goto cleanup_dquot;
 			}
<span class="p_chunk">@@ -1017,11 +1013,12 @@</span> <span class="p_context"> ext4_xattr_block_set(handle_t *handle, struct inode *inode,</span>
 				goto getblk_failed;
 			}
 			memcpy(new_bh-&gt;b_data, s-&gt;base, new_bh-&gt;b_size);
<span class="p_add">+			ext4_xattr_block_csum_set(inode, new_bh);</span>
 			set_buffer_uptodate(new_bh);
 			unlock_buffer(new_bh);
 			ext4_xattr_cache_insert(ext4_mb_cache, new_bh);
<span class="p_del">-			error = ext4_handle_dirty_xattr_block(handle,</span>
<span class="p_del">-							      inode, new_bh);</span>
<span class="p_add">+			error = ext4_handle_dirty_metadata(handle, inode,</span>
<span class="p_add">+							   new_bh);</span>
 			if (error)
 				goto cleanup;
 		}
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index a097048ed1a3..bdc3afad4a8c 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -1125,10 +1125,8 @@</span> <span class="p_context"> static journal_t *journal_init_common(struct block_device *bdev,</span>
 
 	/* Set up a default-sized revoke table for the new mount. */
 	err = jbd2_journal_init_revoke(journal, JOURNAL_REVOKE_DEFAULT_HASH);
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		kfree(journal);</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto err_cleanup;</span>
 
 	spin_lock_init(&amp;journal-&gt;j_history_lock);
 
<span class="p_chunk">@@ -1145,23 +1143,25 @@</span> <span class="p_context"> static journal_t *journal_init_common(struct block_device *bdev,</span>
 	journal-&gt;j_wbufsize = n;
 	journal-&gt;j_wbuf = kmalloc_array(n, sizeof(struct buffer_head *),
 					GFP_KERNEL);
<span class="p_del">-	if (!journal-&gt;j_wbuf) {</span>
<span class="p_del">-		kfree(journal);</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!journal-&gt;j_wbuf)</span>
<span class="p_add">+		goto err_cleanup;</span>
 
 	bh = getblk_unmovable(journal-&gt;j_dev, start, journal-&gt;j_blocksize);
 	if (!bh) {
 		pr_err(&quot;%s: Cannot get buffer for journal superblock\n&quot;,
 			__func__);
<span class="p_del">-		kfree(journal-&gt;j_wbuf);</span>
<span class="p_del">-		kfree(journal);</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		goto err_cleanup;</span>
 	}
 	journal-&gt;j_sb_buffer = bh;
 	journal-&gt;j_superblock = (journal_superblock_t *)bh-&gt;b_data;
 
 	return journal;
<span class="p_add">+</span>
<span class="p_add">+err_cleanup:</span>
<span class="p_add">+	kfree(journal-&gt;j_wbuf);</span>
<span class="p_add">+	jbd2_journal_destroy_revoke(journal);</span>
<span class="p_add">+	kfree(journal);</span>
<span class="p_add">+	return NULL;</span>
 }
 
 /* jbd2_journal_init_dev and jbd2_journal_init_inode:
<span class="p_header">diff --git a/fs/jbd2/revoke.c b/fs/jbd2/revoke.c</span>
<span class="p_header">index cfc38b552118..f9aefcda5854 100644</span>
<span class="p_header">--- a/fs/jbd2/revoke.c</span>
<span class="p_header">+++ b/fs/jbd2/revoke.c</span>
<span class="p_chunk">@@ -280,6 +280,7 @@</span> <span class="p_context"> int jbd2_journal_init_revoke(journal_t *journal, int hash_size)</span>
 
 fail1:
 	jbd2_journal_destroy_revoke_table(journal-&gt;j_revoke_table[0]);
<span class="p_add">+	journal-&gt;j_revoke_table[0] = NULL;</span>
 fail0:
 	return -ENOMEM;
 }
<span class="p_header">diff --git a/include/drm/drmP.h b/include/drm/drmP.h</span>
<span class="p_header">index 9c4ee144b5f6..1871ca60e079 100644</span>
<span class="p_header">--- a/include/drm/drmP.h</span>
<span class="p_header">+++ b/include/drm/drmP.h</span>
<span class="p_chunk">@@ -360,6 +360,7 @@</span> <span class="p_context"> struct drm_ioctl_desc {</span>
 /* Event queued up for userspace to read */
 struct drm_pending_event {
 	struct completion *completion;
<span class="p_add">+	void (*completion_release)(struct completion *completion);</span>
 	struct drm_event *event;
 	struct dma_fence *fence;
 	struct list_head link;
<span class="p_header">diff --git a/include/linux/ccp.h b/include/linux/ccp.h</span>
<span class="p_header">index c71dd8fa5764..c41b8d99dd0e 100644</span>
<span class="p_header">--- a/include/linux/ccp.h</span>
<span class="p_header">+++ b/include/linux/ccp.h</span>
<span class="p_chunk">@@ -556,7 +556,7 @@</span> <span class="p_context"> enum ccp_engine {</span>
  * struct ccp_cmd - CCP operation request
  * @entry: list element (ccp driver use only)
  * @work: work element used for callbacks (ccp driver use only)
<span class="p_del">- * @ccp: CCP device to be run on (ccp driver use only)</span>
<span class="p_add">+ * @ccp: CCP device to be run on</span>
  * @ret: operation return code (ccp driver use only)
  * @flags: cmd processing flags
  * @engine: CCP operation to perform
<span class="p_header">diff --git a/include/linux/iio/sw_device.h b/include/linux/iio/sw_device.h</span>
<span class="p_header">index 23ca41515527..fa7931933067 100644</span>
<span class="p_header">--- a/include/linux/iio/sw_device.h</span>
<span class="p_header">+++ b/include/linux/iio/sw_device.h</span>
<span class="p_chunk">@@ -62,7 +62,7 @@</span> <span class="p_context"> void iio_swd_group_init_type_name(struct iio_sw_device *d,</span>
 				  const char *name,
 				  struct config_item_type *type)
 {
<span class="p_del">-#ifdef CONFIG_CONFIGFS_FS</span>
<span class="p_add">+#if IS_ENABLED(CONFIG_CONFIGFS_FS)</span>
 	config_group_init_type_name(&amp;d-&gt;group, name, type);
 #endif
 }
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index 27914672602d..bdef8b7d4305 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -330,6 +330,7 @@</span> <span class="p_context"> struct napi_struct {</span>
 
 enum {
 	NAPI_STATE_SCHED,	/* Poll is scheduled */
<span class="p_add">+	NAPI_STATE_MISSED,	/* reschedule a napi */</span>
 	NAPI_STATE_DISABLE,	/* Disable pending */
 	NAPI_STATE_NPSVC,	/* Netpoll - don&#39;t dequeue from poll_list */
 	NAPI_STATE_HASHED,	/* In NAPI hash (busy polling possible) */
<span class="p_chunk">@@ -338,12 +339,13 @@</span> <span class="p_context"> enum {</span>
 };
 
 enum {
<span class="p_del">-	NAPIF_STATE_SCHED	 = (1UL &lt;&lt; NAPI_STATE_SCHED),</span>
<span class="p_del">-	NAPIF_STATE_DISABLE	 = (1UL &lt;&lt; NAPI_STATE_DISABLE),</span>
<span class="p_del">-	NAPIF_STATE_NPSVC	 = (1UL &lt;&lt; NAPI_STATE_NPSVC),</span>
<span class="p_del">-	NAPIF_STATE_HASHED	 = (1UL &lt;&lt; NAPI_STATE_HASHED),</span>
<span class="p_del">-	NAPIF_STATE_NO_BUSY_POLL = (1UL &lt;&lt; NAPI_STATE_NO_BUSY_POLL),</span>
<span class="p_del">-	NAPIF_STATE_IN_BUSY_POLL = (1UL &lt;&lt; NAPI_STATE_IN_BUSY_POLL),</span>
<span class="p_add">+	NAPIF_STATE_SCHED	 = BIT(NAPI_STATE_SCHED),</span>
<span class="p_add">+	NAPIF_STATE_MISSED	 = BIT(NAPI_STATE_MISSED),</span>
<span class="p_add">+	NAPIF_STATE_DISABLE	 = BIT(NAPI_STATE_DISABLE),</span>
<span class="p_add">+	NAPIF_STATE_NPSVC	 = BIT(NAPI_STATE_NPSVC),</span>
<span class="p_add">+	NAPIF_STATE_HASHED	 = BIT(NAPI_STATE_HASHED),</span>
<span class="p_add">+	NAPIF_STATE_NO_BUSY_POLL = BIT(NAPI_STATE_NO_BUSY_POLL),</span>
<span class="p_add">+	NAPIF_STATE_IN_BUSY_POLL = BIT(NAPI_STATE_IN_BUSY_POLL),</span>
 };
 
 enum gro_result {
<span class="p_chunk">@@ -413,20 +415,7 @@</span> <span class="p_context"> static inline bool napi_disable_pending(struct napi_struct *n)</span>
 	return test_bit(NAPI_STATE_DISABLE, &amp;n-&gt;state);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- *	napi_schedule_prep - check if NAPI can be scheduled</span>
<span class="p_del">- *	@n: NAPI context</span>
<span class="p_del">- *</span>
<span class="p_del">- * Test if NAPI routine is already running, and if not mark</span>
<span class="p_del">- * it as running.  This is used as a condition variable to</span>
<span class="p_del">- * insure only one NAPI poll instance runs.  We also make</span>
<span class="p_del">- * sure there is no pending NAPI disable.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline bool napi_schedule_prep(struct napi_struct *n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return !napi_disable_pending(n) &amp;&amp;</span>
<span class="p_del">-		!test_and_set_bit(NAPI_STATE_SCHED, &amp;n-&gt;state);</span>
<span class="p_del">-}</span>
<span class="p_add">+bool napi_schedule_prep(struct napi_struct *n);</span>
 
 /**
  *	napi_schedule - schedule NAPI poll
<span class="p_header">diff --git a/include/linux/usb/quirks.h b/include/linux/usb/quirks.h</span>
<span class="p_header">index 1d0043dc34e4..de2a722fe3cf 100644</span>
<span class="p_header">--- a/include/linux/usb/quirks.h</span>
<span class="p_header">+++ b/include/linux/usb/quirks.h</span>
<span class="p_chunk">@@ -50,4 +50,10 @@</span> <span class="p_context"></span>
 /* device can&#39;t handle Link Power Management */
 #define USB_QUIRK_NO_LPM			BIT(10)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Device reports its bInterval as linear frames instead of the</span>
<span class="p_add">+ * USB 2.0 calculation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USB_QUIRK_LINEAR_FRAME_INTR_BINTERVAL	BIT(11)</span>
<span class="p_add">+</span>
 #endif /* __LINUX_USB_QUIRKS_H */
<span class="p_header">diff --git a/kernel/audit.c b/kernel/audit.c</span>
<span class="p_header">index 6e399bb69d7c..ba4481d20fa1 100644</span>
<span class="p_header">--- a/kernel/audit.c</span>
<span class="p_header">+++ b/kernel/audit.c</span>
<span class="p_chunk">@@ -54,6 +54,10 @@</span> <span class="p_context"></span>
 #include &lt;linux/kthread.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/syscalls.h&gt;
<span class="p_add">+#include &lt;linux/spinlock.h&gt;</span>
<span class="p_add">+#include &lt;linux/rcupdate.h&gt;</span>
<span class="p_add">+#include &lt;linux/mutex.h&gt;</span>
<span class="p_add">+#include &lt;linux/gfp.h&gt;</span>
 
 #include &lt;linux/audit.h&gt;
 
<span class="p_chunk">@@ -90,13 +94,34 @@</span> <span class="p_context"> static u32	audit_default;</span>
 /* If auditing cannot proceed, audit_failure selects what happens. */
 static u32	audit_failure = AUDIT_FAIL_PRINTK;
 
<span class="p_del">-/*</span>
<span class="p_del">- * If audit records are to be written to the netlink socket, audit_pid</span>
<span class="p_del">- * contains the pid of the auditd process and audit_nlk_portid contains</span>
<span class="p_del">- * the portid to use to send netlink messages to that process.</span>
<span class="p_add">+/* private audit network namespace index */</span>
<span class="p_add">+static unsigned int audit_net_id;</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * struct audit_net - audit private network namespace data</span>
<span class="p_add">+ * @sk: communication socket</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct audit_net {</span>
<span class="p_add">+	struct sock *sk;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * struct auditd_connection - kernel/auditd connection state</span>
<span class="p_add">+ * @pid: auditd PID</span>
<span class="p_add">+ * @portid: netlink portid</span>
<span class="p_add">+ * @net: the associated network namespace</span>
<span class="p_add">+ * @lock: spinlock to protect write access</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description:</span>
<span class="p_add">+ * This struct is RCU protected; you must either hold the RCU lock for reading</span>
<span class="p_add">+ * or the included spinlock for writing.</span>
  */
<span class="p_del">-int		audit_pid;</span>
<span class="p_del">-static __u32	audit_nlk_portid;</span>
<span class="p_add">+static struct auditd_connection {</span>
<span class="p_add">+	int pid;</span>
<span class="p_add">+	u32 portid;</span>
<span class="p_add">+	struct net *net;</span>
<span class="p_add">+	spinlock_t lock;</span>
<span class="p_add">+} auditd_conn;</span>
 
 /* If audit_rate_limit is non-zero, limit the rate of sending audit records
  * to that number per second.  This prevents DoS attacks, but results in
<span class="p_chunk">@@ -123,10 +148,6 @@</span> <span class="p_context"> u32		audit_sig_sid = 0;</span>
 */
 static atomic_t    audit_lost = ATOMIC_INIT(0);
 
<span class="p_del">-/* The netlink socket. */</span>
<span class="p_del">-static struct sock *audit_sock;</span>
<span class="p_del">-static unsigned int audit_net_id;</span>
<span class="p_del">-</span>
 /* Hash for inode-based rules */
 struct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];
 
<span class="p_chunk">@@ -139,6 +160,7 @@</span> <span class="p_context"> static LIST_HEAD(audit_freelist);</span>
 
 /* queue msgs to send via kauditd_task */
 static struct sk_buff_head audit_queue;
<span class="p_add">+static void kauditd_hold_skb(struct sk_buff *skb);</span>
 /* queue msgs due to temporary unicast send problems */
 static struct sk_buff_head audit_retry_queue;
 /* queue msgs waiting for new auditd connection */
<span class="p_chunk">@@ -192,6 +214,43 @@</span> <span class="p_context"> struct audit_reply {</span>
 	struct sk_buff *skb;
 };
 
<span class="p_add">+/**</span>
<span class="p_add">+ * auditd_test_task - Check to see if a given task is an audit daemon</span>
<span class="p_add">+ * @task: the task to check</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description:</span>
<span class="p_add">+ * Return 1 if the task is a registered audit daemon, 0 otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int auditd_test_task(const struct task_struct *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	rc = (auditd_conn.pid &amp;&amp; task-&gt;tgid == auditd_conn.pid ? 1 : 0);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * audit_get_sk - Return the audit socket for the given network namespace</span>
<span class="p_add">+ * @net: the destination network namespace</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description:</span>
<span class="p_add">+ * Returns the sock pointer if valid, NULL otherwise.  The caller must ensure</span>
<span class="p_add">+ * that a reference is held for the network namespace while the sock is in use.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sock *audit_get_sk(const struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct audit_net *aunet;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!net)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	aunet = net_generic(net, audit_net_id);</span>
<span class="p_add">+	return aunet-&gt;sk;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void audit_set_portid(struct audit_buffer *ab, __u32 portid)
 {
 	if (ab) {
<span class="p_chunk">@@ -210,9 +269,7 @@</span> <span class="p_context"> void audit_panic(const char *message)</span>
 			pr_err(&quot;%s\n&quot;, message);
 		break;
 	case AUDIT_FAIL_PANIC:
<span class="p_del">-		/* test audit_pid since printk is always losey, why bother? */</span>
<span class="p_del">-		if (audit_pid)</span>
<span class="p_del">-			panic(&quot;audit: %s\n&quot;, message);</span>
<span class="p_add">+		panic(&quot;audit: %s\n&quot;, message);</span>
 		break;
 	}
 }
<span class="p_chunk">@@ -370,21 +427,87 @@</span> <span class="p_context"> static int audit_set_failure(u32 state)</span>
 	return audit_do_config_change(&quot;audit_failure&quot;, &amp;audit_failure, state);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * For one reason or another this nlh isn&#39;t getting delivered to the userspace</span>
<span class="p_del">- * audit daemon, just send it to printk.</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * auditd_set - Set/Reset the auditd connection state</span>
<span class="p_add">+ * @pid: auditd PID</span>
<span class="p_add">+ * @portid: auditd netlink portid</span>
<span class="p_add">+ * @net: auditd network namespace pointer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description:</span>
<span class="p_add">+ * This function will obtain and drop network namespace references as</span>
<span class="p_add">+ * necessary.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void auditd_set(int pid, u32 portid, struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;auditd_conn.lock, flags);</span>
<span class="p_add">+	auditd_conn.pid = pid;</span>
<span class="p_add">+	auditd_conn.portid = portid;</span>
<span class="p_add">+	if (auditd_conn.net)</span>
<span class="p_add">+		put_net(auditd_conn.net);</span>
<span class="p_add">+	if (net)</span>
<span class="p_add">+		auditd_conn.net = get_net(net);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		auditd_conn.net = NULL;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;auditd_conn.lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * auditd_reset - Disconnect the auditd connection</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description:</span>
<span class="p_add">+ * Break the auditd/kauditd connection and move all the queued records into the</span>
<span class="p_add">+ * hold queue in case auditd reconnects.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void auditd_reset(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if it isn&#39;t already broken, break the connection */</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	if (auditd_conn.pid)</span>
<span class="p_add">+		auditd_set(0, 0, NULL);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* flush all of the main and retry queues to the hold queue */</span>
<span class="p_add">+	while ((skb = skb_dequeue(&amp;audit_retry_queue)))</span>
<span class="p_add">+		kauditd_hold_skb(skb);</span>
<span class="p_add">+	while ((skb = skb_dequeue(&amp;audit_queue)))</span>
<span class="p_add">+		kauditd_hold_skb(skb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * kauditd_print_skb - Print the audit record to the ring buffer</span>
<span class="p_add">+ * @skb: audit record</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Whatever the reason, this packet may not make it to the auditd connection</span>
<span class="p_add">+ * so write it via printk so the information isn&#39;t completely lost.</span>
  */
 static void kauditd_printk_skb(struct sk_buff *skb)
 {
 	struct nlmsghdr *nlh = nlmsg_hdr(skb);
 	char *data = nlmsg_data(nlh);
 
<span class="p_del">-	if (nlh-&gt;nlmsg_type != AUDIT_EOE) {</span>
<span class="p_del">-		if (printk_ratelimit())</span>
<span class="p_del">-			pr_notice(&quot;type=%d %s\n&quot;, nlh-&gt;nlmsg_type, data);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			audit_log_lost(&quot;printk limit exceeded&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (nlh-&gt;nlmsg_type != AUDIT_EOE &amp;&amp; printk_ratelimit())</span>
<span class="p_add">+		pr_notice(&quot;type=%d %s\n&quot;, nlh-&gt;nlmsg_type, data);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * kauditd_rehold_skb - Handle a audit record send failure in the hold queue</span>
<span class="p_add">+ * @skb: audit record</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description:</span>
<span class="p_add">+ * This should only be used by the kauditd_thread when it fails to flush the</span>
<span class="p_add">+ * hold queue.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void kauditd_rehold_skb(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* put the record back in the queue at the same place */</span>
<span class="p_add">+	skb_queue_head(&amp;audit_hold_queue, skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* fail the auditd connection */</span>
<span class="p_add">+	auditd_reset();</span>
 }
 
 /**
<span class="p_chunk">@@ -421,6 +544,9 @@</span> <span class="p_context"> static void kauditd_hold_skb(struct sk_buff *skb)</span>
 	/* we have no other options - drop the message */
 	audit_log_lost(&quot;kauditd hold queue overflow&quot;);
 	kfree_skb(skb);
<span class="p_add">+</span>
<span class="p_add">+	/* fail the auditd connection */</span>
<span class="p_add">+	auditd_reset();</span>
 }
 
 /**
<span class="p_chunk">@@ -441,51 +567,122 @@</span> <span class="p_context"> static void kauditd_retry_skb(struct sk_buff *skb)</span>
 }
 
 /**
<span class="p_del">- * auditd_reset - Disconnect the auditd connection</span>
<span class="p_add">+ * auditd_send_unicast_skb - Send a record via unicast to auditd</span>
<span class="p_add">+ * @skb: audit record</span>
  *
  * Description:
<span class="p_del">- * Break the auditd/kauditd connection and move all the records in the retry</span>
<span class="p_del">- * queue into the hold queue in case auditd reconnects.  The audit_cmd_mutex</span>
<span class="p_del">- * must be held when calling this function.</span>
<span class="p_add">+ * Send a skb to the audit daemon, returns positive/zero values on success and</span>
<span class="p_add">+ * negative values on failure; in all cases the skb will be consumed by this</span>
<span class="p_add">+ * function.  If the send results in -ECONNREFUSED the connection with auditd</span>
<span class="p_add">+ * will be reset.  This function may sleep so callers should not hold any locks</span>
<span class="p_add">+ * where this would cause a problem.</span>
  */
<span class="p_del">-static void auditd_reset(void)</span>
<span class="p_add">+static int auditd_send_unicast_skb(struct sk_buff *skb)</span>
 {
<span class="p_del">-	struct sk_buff *skb;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* break the connection */</span>
<span class="p_del">-	if (audit_sock) {</span>
<span class="p_del">-		sock_put(audit_sock);</span>
<span class="p_del">-		audit_sock = NULL;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+	u32 portid;</span>
<span class="p_add">+	struct net *net;</span>
<span class="p_add">+	struct sock *sk;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: we can&#39;t call netlink_unicast while in the RCU section so</span>
<span class="p_add">+	 *       take a reference to the network namespace and grab local</span>
<span class="p_add">+	 *       copies of the namespace, the sock, and the portid; the</span>
<span class="p_add">+	 *       namespace and sock aren&#39;t going to go away while we hold a</span>
<span class="p_add">+	 *       reference and if the portid does become invalid after the RCU</span>
<span class="p_add">+	 *       section netlink_unicast() should safely return an error */</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	if (!auditd_conn.pid) {</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		rc = -ECONNREFUSED;</span>
<span class="p_add">+		goto err;</span>
 	}
<span class="p_del">-	audit_pid = 0;</span>
<span class="p_del">-	audit_nlk_portid = 0;</span>
<span class="p_add">+	net = auditd_conn.net;</span>
<span class="p_add">+	get_net(net);</span>
<span class="p_add">+	sk = audit_get_sk(net);</span>
<span class="p_add">+	portid = auditd_conn.portid;</span>
<span class="p_add">+	rcu_read_unlock();</span>
 
<span class="p_del">-	/* flush all of the retry queue to the hold queue */</span>
<span class="p_del">-	while ((skb = skb_dequeue(&amp;audit_retry_queue)))</span>
<span class="p_del">-		kauditd_hold_skb(skb);</span>
<span class="p_add">+	rc = netlink_unicast(sk, skb, portid, 0);</span>
<span class="p_add">+	put_net(net);</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	if (rc == -ECONNREFUSED)</span>
<span class="p_add">+		auditd_reset();</span>
<span class="p_add">+	return rc;</span>
 }
 
 /**
<span class="p_del">- * kauditd_send_unicast_skb - Send a record via unicast to auditd</span>
<span class="p_del">- * @skb: audit record</span>
<span class="p_add">+ * kauditd_send_queue - Helper for kauditd_thread to flush skb queues</span>
<span class="p_add">+ * @sk: the sending sock</span>
<span class="p_add">+ * @portid: the netlink destination</span>
<span class="p_add">+ * @queue: the skb queue to process</span>
<span class="p_add">+ * @retry_limit: limit on number of netlink unicast failures</span>
<span class="p_add">+ * @skb_hook: per-skb hook for additional processing</span>
<span class="p_add">+ * @err_hook: hook called if the skb fails the netlink unicast send</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description:</span>
<span class="p_add">+ * Run through the given queue and attempt to send the audit records to auditd,</span>
<span class="p_add">+ * returns zero on success, negative values on failure.  It is up to the caller</span>
<span class="p_add">+ * to ensure that the @sk is valid for the duration of this function.</span>
<span class="p_add">+ *</span>
  */
<span class="p_del">-static int kauditd_send_unicast_skb(struct sk_buff *skb)</span>
<span class="p_add">+static int kauditd_send_queue(struct sock *sk, u32 portid,</span>
<span class="p_add">+			      struct sk_buff_head *queue,</span>
<span class="p_add">+			      unsigned int retry_limit,</span>
<span class="p_add">+			      void (*skb_hook)(struct sk_buff *skb),</span>
<span class="p_add">+			      void (*err_hook)(struct sk_buff *skb))</span>
 {
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc = 0;</span>
<span class="p_add">+	struct sk_buff *skb;</span>
<span class="p_add">+	static unsigned int failed = 0;</span>
 
<span class="p_del">-	/* if we know nothing is connected, don&#39;t even try the netlink call */</span>
<span class="p_del">-	if (!audit_pid)</span>
<span class="p_del">-		return -ECONNREFUSED;</span>
<span class="p_add">+	/* NOTE: kauditd_thread takes care of all our locking, we just use</span>
<span class="p_add">+	 *       the netlink info passed to us (e.g. sk and portid) */</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((skb = skb_dequeue(queue))) {</span>
<span class="p_add">+		/* call the skb_hook for each skb we touch */</span>
<span class="p_add">+		if (skb_hook)</span>
<span class="p_add">+			(*skb_hook)(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* can we send to anyone via unicast? */</span>
<span class="p_add">+		if (!sk) {</span>
<span class="p_add">+			if (err_hook)</span>
<span class="p_add">+				(*err_hook)(skb);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	/* get an extra skb reference in case we fail to send */</span>
<span class="p_del">-	skb_get(skb);</span>
<span class="p_del">-	rc = netlink_unicast(audit_sock, skb, audit_nlk_portid, 0);</span>
<span class="p_del">-	if (rc &gt;= 0) {</span>
<span class="p_del">-		consume_skb(skb);</span>
<span class="p_del">-		rc = 0;</span>
<span class="p_add">+		/* grab an extra skb reference in case of error */</span>
<span class="p_add">+		skb_get(skb);</span>
<span class="p_add">+		rc = netlink_unicast(sk, skb, portid, 0);</span>
<span class="p_add">+		if (rc &lt; 0) {</span>
<span class="p_add">+			/* fatal failure for our queue flush attempt? */</span>
<span class="p_add">+			if (++failed &gt;= retry_limit ||</span>
<span class="p_add">+			    rc == -ECONNREFUSED || rc == -EPERM) {</span>
<span class="p_add">+				/* yes - error processing for the queue */</span>
<span class="p_add">+				sk = NULL;</span>
<span class="p_add">+				if (err_hook)</span>
<span class="p_add">+					(*err_hook)(skb);</span>
<span class="p_add">+				if (!skb_hook)</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+				/* keep processing with the skb_hook */</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			} else</span>
<span class="p_add">+				/* no - requeue to preserve ordering */</span>
<span class="p_add">+				skb_queue_head(queue, skb);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* it worked - drop the extra reference and continue */</span>
<span class="p_add">+			consume_skb(skb);</span>
<span class="p_add">+			failed = 0;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	return rc;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return (rc &gt;= 0 ? 0 : rc);</span>
 }
 
 /*
<span class="p_chunk">@@ -493,16 +690,19 @@</span> <span class="p_context"> static int kauditd_send_unicast_skb(struct sk_buff *skb)</span>
  * @skb: audit record
  *
  * Description:
<span class="p_del">- * This function doesn&#39;t consume an skb as might be expected since it has to</span>
<span class="p_del">- * copy it anyways.</span>
<span class="p_add">+ * Write a multicast message to anyone listening in the initial network</span>
<span class="p_add">+ * namespace.  This function doesn&#39;t consume an skb as might be expected since</span>
<span class="p_add">+ * it has to copy it anyways.</span>
  */
 static void kauditd_send_multicast_skb(struct sk_buff *skb)
 {
 	struct sk_buff *copy;
<span class="p_del">-	struct audit_net *aunet = net_generic(&amp;init_net, audit_net_id);</span>
<span class="p_del">-	struct sock *sock = aunet-&gt;nlsk;</span>
<span class="p_add">+	struct sock *sock = audit_get_sk(&amp;init_net);</span>
 	struct nlmsghdr *nlh;
 
<span class="p_add">+	/* NOTE: we are not taking an additional reference for init_net since</span>
<span class="p_add">+	 *       we don&#39;t have to worry about it going away */</span>
<span class="p_add">+</span>
 	if (!netlink_has_listeners(sock, AUDIT_NLGRP_READLOG))
 		return;
 
<span class="p_chunk">@@ -526,149 +726,75 @@</span> <span class="p_context"> static void kauditd_send_multicast_skb(struct sk_buff *skb)</span>
 }
 
 /**
<span class="p_del">- * kauditd_wake_condition - Return true when it is time to wake kauditd_thread</span>
<span class="p_del">- *</span>
<span class="p_del">- * Description:</span>
<span class="p_del">- * This function is for use by the wait_event_freezable() call in</span>
<span class="p_del">- * kauditd_thread().</span>
<span class="p_add">+ * kauditd_thread - Worker thread to send audit records to userspace</span>
<span class="p_add">+ * @dummy: unused</span>
  */
<span class="p_del">-static int kauditd_wake_condition(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	static int pid_last = 0;</span>
<span class="p_del">-	int rc;</span>
<span class="p_del">-	int pid = audit_pid;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* wake on new messages or a change in the connected auditd */</span>
<span class="p_del">-	rc = skb_queue_len(&amp;audit_queue) || (pid &amp;&amp; pid != pid_last);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		pid_last = pid;</span>
<span class="p_del">-</span>
<span class="p_del">-	return rc;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int kauditd_thread(void *dummy)
 {
 	int rc;
<span class="p_del">-	int auditd = 0;</span>
<span class="p_del">-	int reschedule = 0;</span>
<span class="p_del">-	struct sk_buff *skb;</span>
<span class="p_del">-	struct nlmsghdr *nlh;</span>
<span class="p_add">+	u32 portid = 0;</span>
<span class="p_add">+	struct net *net = NULL;</span>
<span class="p_add">+	struct sock *sk = NULL;</span>
 
 #define UNICAST_RETRIES 5
<span class="p_del">-#define AUDITD_BAD(x,y) \</span>
<span class="p_del">-	((x) == -ECONNREFUSED || (x) == -EPERM || ++(y) &gt;= UNICAST_RETRIES)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* NOTE: we do invalidate the auditd connection flag on any sending</span>
<span class="p_del">-	 * errors, but we only &quot;restore&quot; the connection flag at specific places</span>
<span class="p_del">-	 * in the loop in order to help ensure proper ordering of audit</span>
<span class="p_del">-	 * records */</span>
 
 	set_freezable();
 	while (!kthread_should_stop()) {
<span class="p_del">-		/* NOTE: possible area for future improvement is to look at</span>
<span class="p_del">-		 *       the hold and retry queues, since only this thread</span>
<span class="p_del">-		 *       has access to these queues we might be able to do</span>
<span class="p_del">-		 *       our own queuing and skip some/all of the locking */</span>
<span class="p_del">-</span>
<span class="p_del">-		/* NOTE: it might be a fun experiment to split the hold and</span>
<span class="p_del">-		 *       retry queue handling to another thread, but the</span>
<span class="p_del">-		 *       synchronization issues and other overhead might kill</span>
<span class="p_del">-		 *       any performance gains */</span>
<span class="p_add">+		/* NOTE: see the lock comments in auditd_send_unicast_skb() */</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		if (!auditd_conn.pid) {</span>
<span class="p_add">+			rcu_read_unlock();</span>
<span class="p_add">+			goto main_queue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		net = auditd_conn.net;</span>
<span class="p_add">+		get_net(net);</span>
<span class="p_add">+		sk = audit_get_sk(net);</span>
<span class="p_add">+		portid = auditd_conn.portid;</span>
<span class="p_add">+		rcu_read_unlock();</span>
 
 		/* attempt to flush the hold queue */
<span class="p_del">-		while (auditd &amp;&amp; (skb = skb_dequeue(&amp;audit_hold_queue))) {</span>
<span class="p_del">-			rc = kauditd_send_unicast_skb(skb);</span>
<span class="p_del">-			if (rc) {</span>
<span class="p_del">-				/* requeue to the same spot */</span>
<span class="p_del">-				skb_queue_head(&amp;audit_hold_queue, skb);</span>
<span class="p_del">-</span>
<span class="p_del">-				auditd = 0;</span>
<span class="p_del">-				if (AUDITD_BAD(rc, reschedule)) {</span>
<span class="p_del">-					mutex_lock(&amp;audit_cmd_mutex);</span>
<span class="p_del">-					auditd_reset();</span>
<span class="p_del">-					mutex_unlock(&amp;audit_cmd_mutex);</span>
<span class="p_del">-					reschedule = 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-			} else</span>
<span class="p_del">-				/* we were able to send successfully */</span>
<span class="p_del">-				reschedule = 0;</span>
<span class="p_add">+		rc = kauditd_send_queue(sk, portid,</span>
<span class="p_add">+					&amp;audit_hold_queue, UNICAST_RETRIES,</span>
<span class="p_add">+					NULL, kauditd_rehold_skb);</span>
<span class="p_add">+		if (rc &lt; 0) {</span>
<span class="p_add">+			sk = NULL;</span>
<span class="p_add">+			goto main_queue;</span>
 		}
 
 		/* attempt to flush the retry queue */
<span class="p_del">-		while (auditd &amp;&amp; (skb = skb_dequeue(&amp;audit_retry_queue))) {</span>
<span class="p_del">-			rc = kauditd_send_unicast_skb(skb);</span>
<span class="p_del">-			if (rc) {</span>
<span class="p_del">-				auditd = 0;</span>
<span class="p_del">-				if (AUDITD_BAD(rc, reschedule)) {</span>
<span class="p_del">-					kauditd_hold_skb(skb);</span>
<span class="p_del">-					mutex_lock(&amp;audit_cmd_mutex);</span>
<span class="p_del">-					auditd_reset();</span>
<span class="p_del">-					mutex_unlock(&amp;audit_cmd_mutex);</span>
<span class="p_del">-					reschedule = 0;</span>
<span class="p_del">-				} else</span>
<span class="p_del">-					/* temporary problem (we hope), queue</span>
<span class="p_del">-					 * to the same spot and retry */</span>
<span class="p_del">-					skb_queue_head(&amp;audit_retry_queue, skb);</span>
<span class="p_del">-			} else</span>
<span class="p_del">-				/* we were able to send successfully */</span>
<span class="p_del">-				reschedule = 0;</span>
<span class="p_add">+		rc = kauditd_send_queue(sk, portid,</span>
<span class="p_add">+					&amp;audit_retry_queue, UNICAST_RETRIES,</span>
<span class="p_add">+					NULL, kauditd_hold_skb);</span>
<span class="p_add">+		if (rc &lt; 0) {</span>
<span class="p_add">+			sk = NULL;</span>
<span class="p_add">+			goto main_queue;</span>
 		}
 
<span class="p_del">-		/* standard queue processing, try to be as quick as possible */</span>
<span class="p_del">-quick_loop:</span>
<span class="p_del">-		skb = skb_dequeue(&amp;audit_queue);</span>
<span class="p_del">-		if (skb) {</span>
<span class="p_del">-			/* setup the netlink header, see the comments in</span>
<span class="p_del">-			 * kauditd_send_multicast_skb() for length quirks */</span>
<span class="p_del">-			nlh = nlmsg_hdr(skb);</span>
<span class="p_del">-			nlh-&gt;nlmsg_len = skb-&gt;len - NLMSG_HDRLEN;</span>
<span class="p_del">-</span>
<span class="p_del">-			/* attempt to send to any multicast listeners */</span>
<span class="p_del">-			kauditd_send_multicast_skb(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-			/* attempt to send to auditd, queue on failure */</span>
<span class="p_del">-			if (auditd) {</span>
<span class="p_del">-				rc = kauditd_send_unicast_skb(skb);</span>
<span class="p_del">-				if (rc) {</span>
<span class="p_del">-					auditd = 0;</span>
<span class="p_del">-					if (AUDITD_BAD(rc, reschedule)) {</span>
<span class="p_del">-						mutex_lock(&amp;audit_cmd_mutex);</span>
<span class="p_del">-						auditd_reset();</span>
<span class="p_del">-						mutex_unlock(&amp;audit_cmd_mutex);</span>
<span class="p_del">-						reschedule = 0;</span>
<span class="p_del">-					}</span>
<span class="p_del">-</span>
<span class="p_del">-					/* move to the retry queue */</span>
<span class="p_del">-					kauditd_retry_skb(skb);</span>
<span class="p_del">-				} else</span>
<span class="p_del">-					/* everything is working so go fast! */</span>
<span class="p_del">-					goto quick_loop;</span>
<span class="p_del">-			} else if (reschedule)</span>
<span class="p_del">-				/* we are currently having problems, move to</span>
<span class="p_del">-				 * the retry queue */</span>
<span class="p_del">-				kauditd_retry_skb(skb);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				/* dump the message via printk and hold it */</span>
<span class="p_del">-				kauditd_hold_skb(skb);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			/* we have flushed the backlog so wake everyone */</span>
<span class="p_del">-			wake_up(&amp;audit_backlog_wait);</span>
<span class="p_del">-</span>
<span class="p_del">-			/* if everything is okay with auditd (if present), go</span>
<span class="p_del">-			 * to sleep until there is something new in the queue</span>
<span class="p_del">-			 * or we have a change in the connected auditd;</span>
<span class="p_del">-			 * otherwise simply reschedule to give things a chance</span>
<span class="p_del">-			 * to recover */</span>
<span class="p_del">-			if (reschedule) {</span>
<span class="p_del">-				set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_del">-				schedule();</span>
<span class="p_del">-			} else</span>
<span class="p_del">-				wait_event_freezable(kauditd_wait,</span>
<span class="p_del">-						     kauditd_wake_condition());</span>
<span class="p_del">-</span>
<span class="p_del">-			/* update the auditd connection status */</span>
<span class="p_del">-			auditd = (audit_pid ? 1 : 0);</span>
<span class="p_add">+main_queue:</span>
<span class="p_add">+		/* process the main queue - do the multicast send and attempt</span>
<span class="p_add">+		 * unicast, dump failed record sends to the retry queue; if</span>
<span class="p_add">+		 * sk == NULL due to previous failures we will just do the</span>
<span class="p_add">+		 * multicast send and move the record to the retry queue */</span>
<span class="p_add">+		kauditd_send_queue(sk, portid, &amp;audit_queue, 1,</span>
<span class="p_add">+				   kauditd_send_multicast_skb,</span>
<span class="p_add">+				   kauditd_retry_skb);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* drop our netns reference, no auditd sends past this line */</span>
<span class="p_add">+		if (net) {</span>
<span class="p_add">+			put_net(net);</span>
<span class="p_add">+			net = NULL;</span>
 		}
<span class="p_add">+		sk = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* we have processed all the queues so wake everyone */</span>
<span class="p_add">+		wake_up(&amp;audit_backlog_wait);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* NOTE: we want to wake up if there is anything on the queue,</span>
<span class="p_add">+		 *       regardless of if an auditd is connected, as we need to</span>
<span class="p_add">+		 *       do the multicast send and rotate records from the</span>
<span class="p_add">+		 *       main queue to the retry/hold queues */</span>
<span class="p_add">+		wait_event_freezable(kauditd_wait,</span>
<span class="p_add">+				     (skb_queue_len(&amp;audit_queue) ? 1 : 0));</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -678,17 +804,16 @@</span> <span class="p_context"> int audit_send_list(void *_dest)</span>
 {
 	struct audit_netlink_list *dest = _dest;
 	struct sk_buff *skb;
<span class="p_del">-	struct net *net = dest-&gt;net;</span>
<span class="p_del">-	struct audit_net *aunet = net_generic(net, audit_net_id);</span>
<span class="p_add">+	struct sock *sk = audit_get_sk(dest-&gt;net);</span>
 
 	/* wait for parent to finish and send an ACK */
 	mutex_lock(&amp;audit_cmd_mutex);
 	mutex_unlock(&amp;audit_cmd_mutex);
 
 	while ((skb = __skb_dequeue(&amp;dest-&gt;q)) != NULL)
<span class="p_del">-		netlink_unicast(aunet-&gt;nlsk, skb, dest-&gt;portid, 0);</span>
<span class="p_add">+		netlink_unicast(sk, skb, dest-&gt;portid, 0);</span>
 
<span class="p_del">-	put_net(net);</span>
<span class="p_add">+	put_net(dest-&gt;net);</span>
 	kfree(dest);
 
 	return 0;
<span class="p_chunk">@@ -722,16 +847,15 @@</span> <span class="p_context"> struct sk_buff *audit_make_reply(__u32 portid, int seq, int type, int done,</span>
 static int audit_send_reply_thread(void *arg)
 {
 	struct audit_reply *reply = (struct audit_reply *)arg;
<span class="p_del">-	struct net *net = reply-&gt;net;</span>
<span class="p_del">-	struct audit_net *aunet = net_generic(net, audit_net_id);</span>
<span class="p_add">+	struct sock *sk = audit_get_sk(reply-&gt;net);</span>
 
 	mutex_lock(&amp;audit_cmd_mutex);
 	mutex_unlock(&amp;audit_cmd_mutex);
 
 	/* Ignore failure. It&#39;ll only happen if the sender goes away,
 	   because our timeout is set to infinite. */
<span class="p_del">-	netlink_unicast(aunet-&gt;nlsk , reply-&gt;skb, reply-&gt;portid, 0);</span>
<span class="p_del">-	put_net(net);</span>
<span class="p_add">+	netlink_unicast(sk, reply-&gt;skb, reply-&gt;portid, 0);</span>
<span class="p_add">+	put_net(reply-&gt;net);</span>
 	kfree(reply);
 	return 0;
 }
<span class="p_chunk">@@ -949,12 +1073,12 @@</span> <span class="p_context"> static int audit_set_feature(struct sk_buff *skb)</span>
 
 static int audit_replace(pid_t pid)
 {
<span class="p_del">-	struct sk_buff *skb = audit_make_reply(0, 0, AUDIT_REPLACE, 0, 0,</span>
<span class="p_del">-					       &amp;pid, sizeof(pid));</span>
<span class="p_add">+	struct sk_buff *skb;</span>
 
<span class="p_add">+	skb = audit_make_reply(0, 0, AUDIT_REPLACE, 0, 0, &amp;pid, sizeof(pid));</span>
 	if (!skb)
 		return -ENOMEM;
<span class="p_del">-	return netlink_unicast(audit_sock, skb, audit_nlk_portid, 0);</span>
<span class="p_add">+	return auditd_send_unicast_skb(skb);</span>
 }
 
 static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)
<span class="p_chunk">@@ -981,7 +1105,9 @@</span> <span class="p_context"> static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 		memset(&amp;s, 0, sizeof(s));
 		s.enabled		= audit_enabled;
 		s.failure		= audit_failure;
<span class="p_del">-		s.pid			= audit_pid;</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		s.pid			= auditd_conn.pid;</span>
<span class="p_add">+		rcu_read_unlock();</span>
 		s.rate_limit		= audit_rate_limit;
 		s.backlog_limit		= audit_backlog_limit;
 		s.lost			= atomic_read(&amp;audit_lost);
<span class="p_chunk">@@ -1014,30 +1140,44 @@</span> <span class="p_context"> static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 			 *       from the initial pid namespace, but something
 			 *       to keep in mind if this changes */
 			int new_pid = s.pid;
<span class="p_add">+			pid_t auditd_pid;</span>
 			pid_t requesting_pid = task_tgid_vnr(current);
 
<span class="p_del">-			if ((!new_pid) &amp;&amp; (requesting_pid != audit_pid)) {</span>
<span class="p_del">-				audit_log_config_change(&quot;audit_pid&quot;, new_pid, audit_pid, 0);</span>
<span class="p_add">+			/* test the auditd connection */</span>
<span class="p_add">+			audit_replace(requesting_pid);</span>
<span class="p_add">+</span>
<span class="p_add">+			rcu_read_lock();</span>
<span class="p_add">+			auditd_pid = auditd_conn.pid;</span>
<span class="p_add">+			/* only the current auditd can unregister itself */</span>
<span class="p_add">+			if ((!new_pid) &amp;&amp; (requesting_pid != auditd_pid)) {</span>
<span class="p_add">+				rcu_read_unlock();</span>
<span class="p_add">+				audit_log_config_change(&quot;audit_pid&quot;, new_pid,</span>
<span class="p_add">+							auditd_pid, 0);</span>
 				return -EACCES;
 			}
<span class="p_del">-			if (audit_pid &amp;&amp; new_pid &amp;&amp;</span>
<span class="p_del">-			    audit_replace(requesting_pid) != -ECONNREFUSED) {</span>
<span class="p_del">-				audit_log_config_change(&quot;audit_pid&quot;, new_pid, audit_pid, 0);</span>
<span class="p_add">+			/* replacing a healthy auditd is not allowed */</span>
<span class="p_add">+			if (auditd_pid &amp;&amp; new_pid) {</span>
<span class="p_add">+				rcu_read_unlock();</span>
<span class="p_add">+				audit_log_config_change(&quot;audit_pid&quot;, new_pid,</span>
<span class="p_add">+							auditd_pid, 0);</span>
 				return -EEXIST;
 			}
<span class="p_add">+			rcu_read_unlock();</span>
<span class="p_add">+</span>
 			if (audit_enabled != AUDIT_OFF)
<span class="p_del">-				audit_log_config_change(&quot;audit_pid&quot;, new_pid, audit_pid, 1);</span>
<span class="p_add">+				audit_log_config_change(&quot;audit_pid&quot;, new_pid,</span>
<span class="p_add">+							auditd_pid, 1);</span>
<span class="p_add">+</span>
 			if (new_pid) {
<span class="p_del">-				if (audit_sock)</span>
<span class="p_del">-					sock_put(audit_sock);</span>
<span class="p_del">-				audit_pid = new_pid;</span>
<span class="p_del">-				audit_nlk_portid = NETLINK_CB(skb).portid;</span>
<span class="p_del">-				sock_hold(skb-&gt;sk);</span>
<span class="p_del">-				audit_sock = skb-&gt;sk;</span>
<span class="p_del">-			} else {</span>
<span class="p_add">+				/* register a new auditd connection */</span>
<span class="p_add">+				auditd_set(new_pid,</span>
<span class="p_add">+					   NETLINK_CB(skb).portid,</span>
<span class="p_add">+					   sock_net(NETLINK_CB(skb).sk));</span>
<span class="p_add">+				/* try to process any backlog */</span>
<span class="p_add">+				wake_up_interruptible(&amp;kauditd_wait);</span>
<span class="p_add">+			} else</span>
<span class="p_add">+				/* unregister the auditd connection */</span>
 				auditd_reset();
<span class="p_del">-			}</span>
<span class="p_del">-			wake_up_interruptible(&amp;kauditd_wait);</span>
 		}
 		if (s.mask &amp; AUDIT_STATUS_RATE_LIMIT) {
 			err = audit_set_rate_limit(s.rate_limit);
<span class="p_chunk">@@ -1084,7 +1224,6 @@</span> <span class="p_context"> static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 				if (err)
 					break;
 			}
<span class="p_del">-			mutex_unlock(&amp;audit_cmd_mutex);</span>
 			audit_log_common_recv_msg(&amp;ab, msg_type);
 			if (msg_type != AUDIT_USER_TTY)
 				audit_log_format(ab, &quot; msg=&#39;%.*s&#39;&quot;,
<span class="p_chunk">@@ -1102,7 +1241,6 @@</span> <span class="p_context"> static int audit_receive_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 			}
 			audit_set_portid(ab, NETLINK_CB(skb).portid);
 			audit_log_end(ab);
<span class="p_del">-			mutex_lock(&amp;audit_cmd_mutex);</span>
 		}
 		break;
 	case AUDIT_ADD_RULE:
<span class="p_chunk">@@ -1292,26 +1430,26 @@</span> <span class="p_context"> static int __net_init audit_net_init(struct net *net)</span>
 
 	struct audit_net *aunet = net_generic(net, audit_net_id);
 
<span class="p_del">-	aunet-&gt;nlsk = netlink_kernel_create(net, NETLINK_AUDIT, &amp;cfg);</span>
<span class="p_del">-	if (aunet-&gt;nlsk == NULL) {</span>
<span class="p_add">+	aunet-&gt;sk = netlink_kernel_create(net, NETLINK_AUDIT, &amp;cfg);</span>
<span class="p_add">+	if (aunet-&gt;sk == NULL) {</span>
 		audit_panic(&quot;cannot initialize netlink socket in namespace&quot;);
 		return -ENOMEM;
 	}
<span class="p_del">-	aunet-&gt;nlsk-&gt;sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;</span>
<span class="p_add">+	aunet-&gt;sk-&gt;sk_sndtimeo = MAX_SCHEDULE_TIMEOUT;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
 static void __net_exit audit_net_exit(struct net *net)
 {
 	struct audit_net *aunet = net_generic(net, audit_net_id);
<span class="p_del">-	struct sock *sock = aunet-&gt;nlsk;</span>
<span class="p_del">-	mutex_lock(&amp;audit_cmd_mutex);</span>
<span class="p_del">-	if (sock == audit_sock)</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	if (net == auditd_conn.net)</span>
 		auditd_reset();
<span class="p_del">-	mutex_unlock(&amp;audit_cmd_mutex);</span>
<span class="p_add">+	rcu_read_unlock();</span>
 
<span class="p_del">-	netlink_kernel_release(sock);</span>
<span class="p_del">-	aunet-&gt;nlsk = NULL;</span>
<span class="p_add">+	netlink_kernel_release(aunet-&gt;sk);</span>
 }
 
 static struct pernet_operations audit_net_ops __net_initdata = {
<span class="p_chunk">@@ -1329,20 +1467,24 @@</span> <span class="p_context"> static int __init audit_init(void)</span>
 	if (audit_initialized == AUDIT_DISABLED)
 		return 0;
 
<span class="p_del">-	pr_info(&quot;initializing netlink subsys (%s)\n&quot;,</span>
<span class="p_del">-		audit_default ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="p_del">-	register_pernet_subsys(&amp;audit_net_ops);</span>
<span class="p_add">+	memset(&amp;auditd_conn, 0, sizeof(auditd_conn));</span>
<span class="p_add">+	spin_lock_init(&amp;auditd_conn.lock);</span>
 
 	skb_queue_head_init(&amp;audit_queue);
 	skb_queue_head_init(&amp;audit_retry_queue);
 	skb_queue_head_init(&amp;audit_hold_queue);
<span class="p_del">-	audit_initialized = AUDIT_INITIALIZED;</span>
<span class="p_del">-	audit_enabled = audit_default;</span>
<span class="p_del">-	audit_ever_enabled |= !!audit_default;</span>
 
 	for (i = 0; i &lt; AUDIT_INODE_BUCKETS; i++)
 		INIT_LIST_HEAD(&amp;audit_inode_hash[i]);
 
<span class="p_add">+	pr_info(&quot;initializing netlink subsys (%s)\n&quot;,</span>
<span class="p_add">+		audit_default ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="p_add">+	register_pernet_subsys(&amp;audit_net_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	audit_initialized = AUDIT_INITIALIZED;</span>
<span class="p_add">+	audit_enabled = audit_default;</span>
<span class="p_add">+	audit_ever_enabled |= !!audit_default;</span>
<span class="p_add">+</span>
 	kauditd_task = kthread_run(kauditd_thread, NULL, &quot;kauditd&quot;);
 	if (IS_ERR(kauditd_task)) {
 		int err = PTR_ERR(kauditd_task);
<span class="p_chunk">@@ -1511,20 +1653,16 @@</span> <span class="p_context"> struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,</span>
 	if (unlikely(!audit_filter(type, AUDIT_FILTER_TYPE)))
 		return NULL;
 
<span class="p_del">-	/* don&#39;t ever fail/sleep on these two conditions:</span>
<span class="p_add">+	/* NOTE: don&#39;t ever fail/sleep on these two conditions:</span>
 	 * 1. auditd generated record - since we need auditd to drain the
 	 *    queue; also, when we are checking for auditd, compare PIDs using
 	 *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()
 	 *    using a PID anchored in the caller&#39;s namespace
<span class="p_del">-	 * 2. audit command message - record types 1000 through 1099 inclusive</span>
<span class="p_del">-	 *    are command messages/records used to manage the kernel subsystem</span>
<span class="p_del">-	 *    and the audit userspace, blocking on these messages could cause</span>
<span class="p_del">-	 *    problems under load so don&#39;t do it (note: not all of these</span>
<span class="p_del">-	 *    command types are valid as record types, but it is quicker to</span>
<span class="p_del">-	 *    just check two ints than a series of ints in a if/switch stmt) */</span>
<span class="p_del">-	if (!((audit_pid &amp;&amp; audit_pid == task_tgid_vnr(current)) ||</span>
<span class="p_del">-	      (type &gt;= 1000 &amp;&amp; type &lt;= 1099))) {</span>
<span class="p_del">-		long sleep_time = audit_backlog_wait_time;</span>
<span class="p_add">+	 * 2. generator holding the audit_cmd_mutex - we don&#39;t want to block</span>
<span class="p_add">+	 *    while holding the mutex */</span>
<span class="p_add">+	if (!(auditd_test_task(current) ||</span>
<span class="p_add">+	      (current == __mutex_owner(&amp;audit_cmd_mutex)))) {</span>
<span class="p_add">+		long stime = audit_backlog_wait_time;</span>
 
 		while (audit_backlog_limit &amp;&amp;
 		       (skb_queue_len(&amp;audit_queue) &gt; audit_backlog_limit)) {
<span class="p_chunk">@@ -1533,14 +1671,13 @@</span> <span class="p_context"> struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,</span>
 
 			/* sleep if we are allowed and we haven&#39;t exhausted our
 			 * backlog wait limit */
<span class="p_del">-			if ((gfp_mask &amp; __GFP_DIRECT_RECLAIM) &amp;&amp;</span>
<span class="p_del">-			    (sleep_time &gt; 0)) {</span>
<span class="p_add">+			if (gfpflags_allow_blocking(gfp_mask) &amp;&amp; (stime &gt; 0)) {</span>
 				DECLARE_WAITQUEUE(wait, current);
 
 				add_wait_queue_exclusive(&amp;audit_backlog_wait,
 							 &amp;wait);
 				set_current_state(TASK_UNINTERRUPTIBLE);
<span class="p_del">-				sleep_time = schedule_timeout(sleep_time);</span>
<span class="p_add">+				stime = schedule_timeout(stime);</span>
 				remove_wait_queue(&amp;audit_backlog_wait, &amp;wait);
 			} else {
 				if (audit_rate_check() &amp;&amp; printk_ratelimit())
<span class="p_chunk">@@ -2119,15 +2256,27 @@</span> <span class="p_context"> void audit_log_link_denied(const char *operation, const struct path *link)</span>
  */
 void audit_log_end(struct audit_buffer *ab)
 {
<span class="p_add">+	struct sk_buff *skb;</span>
<span class="p_add">+	struct nlmsghdr *nlh;</span>
<span class="p_add">+</span>
 	if (!ab)
 		return;
<span class="p_del">-	if (!audit_rate_check()) {</span>
<span class="p_del">-		audit_log_lost(&quot;rate limit exceeded&quot;);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		skb_queue_tail(&amp;audit_queue, ab-&gt;skb);</span>
<span class="p_del">-		wake_up_interruptible(&amp;kauditd_wait);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (audit_rate_check()) {</span>
<span class="p_add">+		skb = ab-&gt;skb;</span>
 		ab-&gt;skb = NULL;
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* setup the netlink header, see the comments in</span>
<span class="p_add">+		 * kauditd_send_multicast_skb() for length quirks */</span>
<span class="p_add">+		nlh = nlmsg_hdr(skb);</span>
<span class="p_add">+		nlh-&gt;nlmsg_len = skb-&gt;len - NLMSG_HDRLEN;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* queue the netlink packet and poke the kauditd thread */</span>
<span class="p_add">+		skb_queue_tail(&amp;audit_queue, skb);</span>
<span class="p_add">+		wake_up_interruptible(&amp;kauditd_wait);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		audit_log_lost(&quot;rate limit exceeded&quot;);</span>
<span class="p_add">+</span>
 	audit_buffer_free(ab);
 }
 
<span class="p_header">diff --git a/kernel/audit.h b/kernel/audit.h</span>
<span class="p_header">index 960d49c9db5e..c6fba919b2e4 100644</span>
<span class="p_header">--- a/kernel/audit.h</span>
<span class="p_header">+++ b/kernel/audit.h</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> extern void audit_log_name(struct audit_context *context,</span>
 			   struct audit_names *n, const struct path *path,
 			   int record_num, int *call_panic);
 
<span class="p_del">-extern int audit_pid;</span>
<span class="p_add">+extern int auditd_test_task(const struct task_struct *task);</span>
 
 #define AUDIT_INODE_BUCKETS	32
 extern struct list_head audit_inode_hash[AUDIT_INODE_BUCKETS];
<span class="p_chunk">@@ -247,10 +247,6 @@</span> <span class="p_context"> struct audit_netlink_list {</span>
 
 int audit_send_list(void *);
 
<span class="p_del">-struct audit_net {</span>
<span class="p_del">-	struct sock *nlsk;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 extern int selinux_audit_rule_update(void);
 
 extern struct mutex audit_filter_mutex;
<span class="p_chunk">@@ -337,8 +333,7 @@</span> <span class="p_context"> extern int audit_filter(int msgtype, unsigned int listtype);</span>
 extern int __audit_signal_info(int sig, struct task_struct *t);
 static inline int audit_signal_info(int sig, struct task_struct *t)
 {
<span class="p_del">-	if (unlikely((audit_pid &amp;&amp; t-&gt;tgid == audit_pid) ||</span>
<span class="p_del">-		     (audit_signals &amp;&amp; !audit_dummy_context())))</span>
<span class="p_add">+	if (auditd_test_task(t) || (audit_signals &amp;&amp; !audit_dummy_context()))</span>
 		return __audit_signal_info(sig, t);
 	return 0;
 }
<span class="p_header">diff --git a/kernel/auditsc.c b/kernel/auditsc.c</span>
<span class="p_header">index cf1fa43512c1..9e69c3a6b732 100644</span>
<span class="p_header">--- a/kernel/auditsc.c</span>
<span class="p_header">+++ b/kernel/auditsc.c</span>
<span class="p_chunk">@@ -762,7 +762,7 @@</span> <span class="p_context"> static enum audit_state audit_filter_syscall(struct task_struct *tsk,</span>
 	struct audit_entry *e;
 	enum audit_state state;
 
<span class="p_del">-	if (audit_pid &amp;&amp; tsk-&gt;tgid == audit_pid)</span>
<span class="p_add">+	if (auditd_test_task(tsk))</span>
 		return AUDIT_DISABLED;
 
 	rcu_read_lock();
<span class="p_chunk">@@ -816,7 +816,7 @@</span> <span class="p_context"> void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)</span>
 {
 	struct audit_names *n;
 
<span class="p_del">-	if (audit_pid &amp;&amp; tsk-&gt;tgid == audit_pid)</span>
<span class="p_add">+	if (auditd_test_task(tsk))</span>
 		return;
 
 	rcu_read_lock();
<span class="p_chunk">@@ -2251,7 +2251,7 @@</span> <span class="p_context"> int __audit_signal_info(int sig, struct task_struct *t)</span>
 	struct audit_context *ctx = tsk-&gt;audit_context;
 	kuid_t uid = current_uid(), t_uid = task_uid(t);
 
<span class="p_del">-	if (audit_pid &amp;&amp; t-&gt;tgid == audit_pid) {</span>
<span class="p_add">+	if (auditd_test_task(t)) {</span>
 		if (sig == SIGTERM || sig == SIGHUP || sig == SIGUSR1 || sig == SIGUSR2) {
 			audit_sig_pid = task_tgid_nr(tsk);
 			if (uid_valid(tsk-&gt;loginuid))
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index d2436880b305..d3f6c26425b3 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -1334,7 +1334,6 @@</span> <span class="p_context"> static int decode_new_up_state_weight(void **p, void *end,</span>
 		if ((map-&gt;osd_state[osd] &amp; CEPH_OSD_EXISTS) &amp;&amp;
 		    (xorstate &amp; CEPH_OSD_EXISTS)) {
 			pr_info(&quot;osd%d does not exist\n&quot;, osd);
<span class="p_del">-			map-&gt;osd_weight[osd] = CEPH_OSD_IN;</span>
 			ret = set_primary_affinity(map, osd,
 						   CEPH_OSD_DEFAULT_PRIMARY_AFFINITY);
 			if (ret)
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index fd6e2dfda45f..54f8c162ded8 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -4913,6 +4913,39 @@</span> <span class="p_context"> void __napi_schedule(struct napi_struct *n)</span>
 EXPORT_SYMBOL(__napi_schedule);
 
 /**
<span class="p_add">+ *	napi_schedule_prep - check if napi can be scheduled</span>
<span class="p_add">+ *	@n: napi context</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Test if NAPI routine is already running, and if not mark</span>
<span class="p_add">+ * it as running.  This is used as a condition variable</span>
<span class="p_add">+ * insure only one NAPI poll instance runs.  We also make</span>
<span class="p_add">+ * sure there is no pending NAPI disable.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool napi_schedule_prep(struct napi_struct *n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long val, new;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		val = READ_ONCE(n-&gt;state);</span>
<span class="p_add">+		if (unlikely(val &amp; NAPIF_STATE_DISABLE))</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+		new = val | NAPIF_STATE_SCHED;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Sets STATE_MISSED bit if STATE_SCHED was already set</span>
<span class="p_add">+		 * This was suggested by Alexander Duyck, as compiler</span>
<span class="p_add">+		 * emits better code than :</span>
<span class="p_add">+		 * if (val &amp; NAPIF_STATE_SCHED)</span>
<span class="p_add">+		 *     new |= NAPIF_STATE_MISSED;</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		new |= (val &amp; NAPIF_STATE_SCHED) / NAPIF_STATE_SCHED *</span>
<span class="p_add">+						   NAPIF_STATE_MISSED;</span>
<span class="p_add">+	} while (cmpxchg(&amp;n-&gt;state, val, new) != val);</span>
<span class="p_add">+</span>
<span class="p_add">+	return !(val &amp; NAPIF_STATE_SCHED);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(napi_schedule_prep);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * __napi_schedule_irqoff - schedule for receive
  * @n: entry to schedule
  *
<span class="p_chunk">@@ -4943,7 +4976,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(__napi_complete);</span>
 
 bool napi_complete_done(struct napi_struct *n, int work_done)
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long flags, val, new;</span>
 
 	/*
 	 * 1) Don&#39;t let napi dequeue from the cpu poll list
<span class="p_chunk">@@ -4967,14 +5000,33 @@</span> <span class="p_context"> bool napi_complete_done(struct napi_struct *n, int work_done)</span>
 		else
 			napi_gro_flush(n, false);
 	}
<span class="p_del">-	if (likely(list_empty(&amp;n-&gt;poll_list))) {</span>
<span class="p_del">-		WARN_ON_ONCE(!test_and_clear_bit(NAPI_STATE_SCHED, &amp;n-&gt;state));</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (unlikely(!list_empty(&amp;n-&gt;poll_list))) {</span>
 		/* If n-&gt;poll_list is not empty, we need to mask irqs */
 		local_irq_save(flags);
<span class="p_del">-		__napi_complete(n);</span>
<span class="p_add">+		list_del_init(&amp;n-&gt;poll_list);</span>
 		local_irq_restore(flags);
 	}
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		val = READ_ONCE(n-&gt;state);</span>
<span class="p_add">+</span>
<span class="p_add">+		WARN_ON_ONCE(!(val &amp; NAPIF_STATE_SCHED));</span>
<span class="p_add">+</span>
<span class="p_add">+		new = val &amp; ~(NAPIF_STATE_MISSED | NAPIF_STATE_SCHED);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* If STATE_MISSED was set, leave STATE_SCHED set,</span>
<span class="p_add">+		 * because we will call napi-&gt;poll() one more time.</span>
<span class="p_add">+		 * This C code was suggested by Alexander Duyck to help gcc.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		new |= (val &amp; NAPIF_STATE_MISSED) / NAPIF_STATE_MISSED *</span>
<span class="p_add">+						    NAPIF_STATE_SCHED;</span>
<span class="p_add">+	} while (cmpxchg(&amp;n-&gt;state, val, new) != val);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(val &amp; NAPIF_STATE_MISSED)) {</span>
<span class="p_add">+		__napi_schedule(n);</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return true;
 }
 EXPORT_SYMBOL(napi_complete_done);
<span class="p_chunk">@@ -5000,6 +5052,16 @@</span> <span class="p_context"> static void busy_poll_stop(struct napi_struct *napi, void *have_poll_lock)</span>
 {
 	int rc;
 
<span class="p_add">+	/* Busy polling means there is a high chance device driver hard irq</span>
<span class="p_add">+	 * could not grab NAPI_STATE_SCHED, and that NAPI_STATE_MISSED was</span>
<span class="p_add">+	 * set in napi_schedule_prep().</span>
<span class="p_add">+	 * Since we are about to call napi-&gt;poll() once more, we can safely</span>
<span class="p_add">+	 * clear NAPI_STATE_MISSED.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note: x86 could use a single &quot;lock and ...&quot; instruction</span>
<span class="p_add">+	 * to perform these two clear_bit()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	clear_bit(NAPI_STATE_MISSED, &amp;napi-&gt;state);</span>
 	clear_bit(NAPI_STATE_IN_BUSY_POLL, &amp;napi-&gt;state);
 
 	local_bh_disable();
<span class="p_chunk">@@ -5146,8 +5208,13 @@</span> <span class="p_context"> static enum hrtimer_restart napi_watchdog(struct hrtimer *timer)</span>
 	struct napi_struct *napi;
 
 	napi = container_of(timer, struct napi_struct, timer);
<span class="p_del">-	if (napi-&gt;gro_list)</span>
<span class="p_del">-		napi_schedule(napi);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Note : we use a relaxed variant of napi_schedule_prep() not setting</span>
<span class="p_add">+	 * NAPI_STATE_MISSED, since we do not react to a device IRQ.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (napi-&gt;gro_list &amp;&amp; !napi_disable_pending(napi) &amp;&amp;</span>
<span class="p_add">+	    !test_and_set_bit(NAPI_STATE_SCHED, &amp;napi-&gt;state))</span>
<span class="p_add">+		__napi_schedule_irqoff(napi);</span>
 
 	return HRTIMER_NORESTART;
 }
<span class="p_header">diff --git a/net/core/netclassid_cgroup.c b/net/core/netclassid_cgroup.c</span>
<span class="p_header">index 11fce17274f6..46e8830c1979 100644</span>
<span class="p_header">--- a/net/core/netclassid_cgroup.c</span>
<span class="p_header">+++ b/net/core/netclassid_cgroup.c</span>
<span class="p_chunk">@@ -69,27 +69,17 @@</span> <span class="p_context"> static int update_classid_sock(const void *v, struct file *file, unsigned n)</span>
 	return 0;
 }
 
<span class="p_del">-static void update_classid(struct cgroup_subsys_state *css, void *v)</span>
<span class="p_add">+static void cgrp_attach(struct cgroup_taskset *tset)</span>
 {
<span class="p_del">-	struct css_task_iter it;</span>
<span class="p_add">+	struct cgroup_subsys_state *css;</span>
 	struct task_struct *p;
 
<span class="p_del">-	css_task_iter_start(css, &amp;it);</span>
<span class="p_del">-	while ((p = css_task_iter_next(&amp;it))) {</span>
<span class="p_add">+	cgroup_taskset_for_each(p, css, tset) {</span>
 		task_lock(p);
<span class="p_del">-		iterate_fd(p-&gt;files, 0, update_classid_sock, v);</span>
<span class="p_add">+		iterate_fd(p-&gt;files, 0, update_classid_sock,</span>
<span class="p_add">+			   (void *)(unsigned long)css_cls_state(css)-&gt;classid);</span>
 		task_unlock(p);
 	}
<span class="p_del">-	css_task_iter_end(&amp;it);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void cgrp_attach(struct cgroup_taskset *tset)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cgroup_subsys_state *css;</span>
<span class="p_del">-</span>
<span class="p_del">-	cgroup_taskset_first(tset, &amp;css);</span>
<span class="p_del">-	update_classid(css,</span>
<span class="p_del">-		       (void *)(unsigned long)css_cls_state(css)-&gt;classid);</span>
 }
 
 static u64 read_classid(struct cgroup_subsys_state *css, struct cftype *cft)
<span class="p_chunk">@@ -101,12 +91,22 @@</span> <span class="p_context"> static int write_classid(struct cgroup_subsys_state *css, struct cftype *cft,</span>
 			 u64 value)
 {
 	struct cgroup_cls_state *cs = css_cls_state(css);
<span class="p_add">+	struct css_task_iter it;</span>
<span class="p_add">+	struct task_struct *p;</span>
 
 	cgroup_sk_alloc_disable();
 
 	cs-&gt;classid = (u32)value;
 
<span class="p_del">-	update_classid(css, (void *)(unsigned long)cs-&gt;classid);</span>
<span class="p_add">+	css_task_iter_start(css, &amp;it);</span>
<span class="p_add">+	while ((p = css_task_iter_next(&amp;it))) {</span>
<span class="p_add">+		task_lock(p);</span>
<span class="p_add">+		iterate_fd(p-&gt;files, 0, update_classid_sock,</span>
<span class="p_add">+			   (void *)(unsigned long)cs-&gt;classid);</span>
<span class="p_add">+		task_unlock(p);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	css_task_iter_end(&amp;it);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index 4eca27dc5c94..4e7f10c92666 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1444,6 +1444,11 @@</span> <span class="p_context"> static void __sk_destruct(struct rcu_head *head)</span>
 		pr_debug(&quot;%s: optmem leakage (%d bytes) detected\n&quot;,
 			 __func__, atomic_read(&amp;sk-&gt;sk_omem_alloc));
 
<span class="p_add">+	if (sk-&gt;sk_frag.page) {</span>
<span class="p_add">+		put_page(sk-&gt;sk_frag.page);</span>
<span class="p_add">+		sk-&gt;sk_frag.page = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (sk-&gt;sk_peer_cred)
 		put_cred(sk-&gt;sk_peer_cred);
 	put_pid(sk-&gt;sk_peer_pid);
<span class="p_chunk">@@ -1540,6 +1545,12 @@</span> <span class="p_context"> struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</span>
 			is_charged = sk_filter_charge(newsk, filter);
 
 		if (unlikely(!is_charged || xfrm_sk_clone_policy(newsk, sk))) {
<span class="p_add">+			/* We need to make sure that we don&#39;t uncharge the new</span>
<span class="p_add">+			 * socket if we couldn&#39;t charge it in the first place</span>
<span class="p_add">+			 * as otherwise we uncharge the parent&#39;s filter.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!is_charged)</span>
<span class="p_add">+				RCU_INIT_POINTER(newsk-&gt;sk_filter, NULL);</span>
 			/* It is still raw copy of parent, so invalidate
 			 * destructor and make plain sk_free() */
 			newsk-&gt;sk_destruct = NULL;
<span class="p_chunk">@@ -2774,11 +2785,6 @@</span> <span class="p_context"> void sk_common_release(struct sock *sk)</span>
 
 	sk_refcnt_debug_release(sk);
 
<span class="p_del">-	if (sk-&gt;sk_frag.page) {</span>
<span class="p_del">-		put_page(sk-&gt;sk_frag.page);</span>
<span class="p_del">-		sk-&gt;sk_frag.page = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	sock_put(sk);
 }
 EXPORT_SYMBOL(sk_common_release);
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index b39a791f6756..091de0b93d5d 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -1082,7 +1082,8 @@</span> <span class="p_context"> static void nl_fib_input(struct sk_buff *skb)</span>
 
 	net = sock_net(skb-&gt;sk);
 	nlh = nlmsg_hdr(skb);
<span class="p_del">-	if (skb-&gt;len &lt; NLMSG_HDRLEN || skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span>
<span class="p_add">+	if (skb-&gt;len &lt; nlmsg_total_size(sizeof(*frn)) ||</span>
<span class="p_add">+	    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span>
 	    nlmsg_len(nlh) &lt; sizeof(*frn))
 		return;
 
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 28777a0307c8..e7516efa99dc 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -5571,6 +5571,7 @@</span> <span class="p_context"> void tcp_finish_connect(struct sock *sk, struct sk_buff *skb)</span>
 	struct inet_connection_sock *icsk = inet_csk(sk);
 
 	tcp_set_state(sk, TCP_ESTABLISHED);
<span class="p_add">+	icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span>
 
 	if (skb) {
 		icsk-&gt;icsk_af_ops-&gt;sk_rx_dst_set(sk, skb);
<span class="p_chunk">@@ -5789,7 +5790,6 @@</span> <span class="p_context"> static int tcp_rcv_synsent_state_process(struct sock *sk, struct sk_buff *skb,</span>
 			 * to stand against the temptation 8)     --ANK
 			 */
 			inet_csk_schedule_ack(sk);
<span class="p_del">-			icsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span>
 			tcp_enter_quickack_mode(sk);
 			inet_csk_reset_xmit_timer(sk, ICSK_TIME_DACK,
 						  TCP_DELACK_MAX, TCP_RTO_MAX);
<span class="p_header">diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">index 28ce5ee831f5..80ff517a7542 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_minisocks.c</span>
<span class="p_chunk">@@ -466,6 +466,7 @@</span> <span class="p_context"> struct sock *tcp_create_openreq_child(const struct sock *sk,</span>
 		newtp-&gt;mdev_us = jiffies_to_usecs(TCP_TIMEOUT_INIT);
 		minmax_reset(&amp;newtp-&gt;rtt_min, tcp_time_stamp, ~0U);
 		newicsk-&gt;icsk_rto = TCP_TIMEOUT_INIT;
<span class="p_add">+		newicsk-&gt;icsk_ack.lrcvtime = tcp_time_stamp;</span>
 
 		newtp-&gt;packets_out = 0;
 		newtp-&gt;retrans_out = 0;
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index 221825a9407a..0770f95f5e1c 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -1022,6 +1022,7 @@</span> <span class="p_context"> int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 	ipc6.hlimit = -1;
 	ipc6.tclass = -1;
 	ipc6.dontfrag = -1;
<span class="p_add">+	sockc.tsflags = sk-&gt;sk_tsflags;</span>
 
 	/* destination address check */
 	if (sin6) {
<span class="p_chunk">@@ -1146,7 +1147,6 @@</span> <span class="p_context"> int udpv6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 
 	fl6.flowi6_mark = sk-&gt;sk_mark;
 	fl6.flowi6_uid = sk-&gt;sk_uid;
<span class="p_del">-	sockc.tsflags = sk-&gt;sk_tsflags;</span>
 
 	if (msg-&gt;msg_controllen) {
 		opt = &amp;opt_space;
<span class="p_header">diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c</span>
<span class="p_header">index fb6e10fdb217..92e0981f7404 100644</span>
<span class="p_header">--- a/net/netlink/genetlink.c</span>
<span class="p_header">+++ b/net/netlink/genetlink.c</span>
<span class="p_chunk">@@ -783,8 +783,10 @@</span> <span class="p_context"> static int ctrl_dumpfamily(struct sk_buff *skb, struct netlink_callback *cb)</span>
 
 		if (ctrl_fill_info(rt, NETLINK_CB(cb-&gt;skb).portid,
 				   cb-&gt;nlh-&gt;nlmsg_seq, NLM_F_MULTI,
<span class="p_del">-				   skb, CTRL_CMD_NEWFAMILY) &lt; 0)</span>
<span class="p_add">+				   skb, CTRL_CMD_NEWFAMILY) &lt; 0) {</span>
<span class="p_add">+			n--;</span>
 			break;
<span class="p_add">+		}</span>
 	}
 
 	cb-&gt;args[0] = n;
<span class="p_header">diff --git a/net/openvswitch/flow_netlink.c b/net/openvswitch/flow_netlink.c</span>
<span class="p_header">index c87d359b9b37..256e8f1450fd 100644</span>
<span class="p_header">--- a/net/openvswitch/flow_netlink.c</span>
<span class="p_header">+++ b/net/openvswitch/flow_netlink.c</span>
<span class="p_chunk">@@ -588,7 +588,7 @@</span> <span class="p_context"> static int ip_tun_from_nlattr(const struct nlattr *attr,</span>
 			ipv4 = true;
 			break;
 		case OVS_TUNNEL_KEY_ATTR_IPV6_SRC:
<span class="p_del">-			SW_FLOW_KEY_PUT(match, tun_key.u.ipv6.dst,</span>
<span class="p_add">+			SW_FLOW_KEY_PUT(match, tun_key.u.ipv6.src,</span>
 					nla_get_in6_addr(a), is_mask);
 			ipv6 = true;
 			break;
<span class="p_chunk">@@ -649,6 +649,8 @@</span> <span class="p_context"> static int ip_tun_from_nlattr(const struct nlattr *attr,</span>
 			tun_flags |= TUNNEL_VXLAN_OPT;
 			opts_type = type;
 			break;
<span class="p_add">+		case OVS_TUNNEL_KEY_ATTR_PAD:</span>
<span class="p_add">+			break;</span>
 		default:
 			OVS_NLERR(log, &quot;Unknown IP tunnel attribute %d&quot;,
 				  type);
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index 6a0d48525fcf..c36757e72844 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -146,6 +146,7 @@</span> <span class="p_context"> void unix_notinflight(struct user_struct *user, struct file *fp)</span>
 	if (s) {
 		struct unix_sock *u = unix_sk(s);
 
<span class="p_add">+		BUG_ON(!atomic_long_read(&amp;u-&gt;inflight));</span>
 		BUG_ON(list_empty(&amp;u-&gt;link));
 
 		if (atomic_long_dec_and_test(&amp;u-&gt;inflight))
<span class="p_chunk">@@ -341,6 +342,14 @@</span> <span class="p_context"> void unix_gc(void)</span>
 	}
 	list_del(&amp;cursor);
 
<span class="p_add">+	/* Now gc_candidates contains only garbage.  Restore original</span>
<span class="p_add">+	 * inflight counters for these as well, and remove the skbuffs</span>
<span class="p_add">+	 * which are creating the cycle(s).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	skb_queue_head_init(&amp;hitlist);</span>
<span class="p_add">+	list_for_each_entry(u, &amp;gc_candidates, link)</span>
<span class="p_add">+		scan_children(&amp;u-&gt;sk, inc_inflight, &amp;hitlist);</span>
<span class="p_add">+</span>
 	/* not_cycle_list contains those sockets which do not make up a
 	 * cycle.  Restore these to the inflight list.
 	 */
<span class="p_chunk">@@ -350,14 +359,6 @@</span> <span class="p_context"> void unix_gc(void)</span>
 		list_move_tail(&amp;u-&gt;link, &amp;gc_inflight_list);
 	}
 
<span class="p_del">-	/* Now gc_candidates contains only garbage.  Restore original</span>
<span class="p_del">-	 * inflight counters for these as well, and remove the skbuffs</span>
<span class="p_del">-	 * which are creating the cycle(s).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	skb_queue_head_init(&amp;hitlist);</span>
<span class="p_del">-	list_for_each_entry(u, &amp;gc_candidates, link)</span>
<span class="p_del">-	scan_children(&amp;u-&gt;sk, inc_inflight, &amp;hitlist);</span>
<span class="p_del">-</span>
 	spin_unlock(&amp;unix_gc_lock);
 
 	/* Here we are. Hitlist is filled. Die. */
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index aee396b9f190..c1081a6e31ef 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -540,22 +540,18 @@</span> <span class="p_context"> static int nl80211_prepare_wdev_dump(struct sk_buff *skb,</span>
 {
 	int err;
 
<span class="p_del">-	rtnl_lock();</span>
<span class="p_del">-</span>
 	if (!cb-&gt;args[0]) {
 		err = nlmsg_parse(cb-&gt;nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
 				  genl_family_attrbuf(&amp;nl80211_fam),
 				  nl80211_fam.maxattr, nl80211_policy);
 		if (err)
<span class="p_del">-			goto out_unlock;</span>
<span class="p_add">+			return err;</span>
 
 		*wdev = __cfg80211_wdev_from_attrs(
 					sock_net(skb-&gt;sk),
 					genl_family_attrbuf(&amp;nl80211_fam));
<span class="p_del">-		if (IS_ERR(*wdev)) {</span>
<span class="p_del">-			err = PTR_ERR(*wdev);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (IS_ERR(*wdev))</span>
<span class="p_add">+			return PTR_ERR(*wdev);</span>
 		*rdev = wiphy_to_rdev((*wdev)-&gt;wiphy);
 		/* 0 is the first index - add 1 to parse only once */
 		cb-&gt;args[0] = (*rdev)-&gt;wiphy_idx + 1;
<span class="p_chunk">@@ -565,10 +561,8 @@</span> <span class="p_context"> static int nl80211_prepare_wdev_dump(struct sk_buff *skb,</span>
 		struct wiphy *wiphy = wiphy_idx_to_wiphy(cb-&gt;args[0] - 1);
 		struct wireless_dev *tmp;
 
<span class="p_del">-		if (!wiphy) {</span>
<span class="p_del">-			err = -ENODEV;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!wiphy)</span>
<span class="p_add">+			return -ENODEV;</span>
 		*rdev = wiphy_to_rdev(wiphy);
 		*wdev = NULL;
 
<span class="p_chunk">@@ -579,21 +573,11 @@</span> <span class="p_context"> static int nl80211_prepare_wdev_dump(struct sk_buff *skb,</span>
 			}
 		}
 
<span class="p_del">-		if (!*wdev) {</span>
<span class="p_del">-			err = -ENODEV;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!*wdev)</span>
<span class="p_add">+			return -ENODEV;</span>
 	}
 
 	return 0;
<span class="p_del">- out_unlock:</span>
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void nl80211_finish_wdev_dump(struct cfg80211_registered_device *rdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	rtnl_unlock();</span>
 }
 
 /* IE validation */
<span class="p_chunk">@@ -2599,17 +2583,17 @@</span> <span class="p_context"> static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *</span>
 	int filter_wiphy = -1;
 	struct cfg80211_registered_device *rdev;
 	struct wireless_dev *wdev;
<span class="p_add">+	int ret;</span>
 
 	rtnl_lock();
 	if (!cb-&gt;args[2]) {
 		struct nl80211_dump_wiphy_state state = {
 			.filter_wiphy = -1,
 		};
<span class="p_del">-		int ret;</span>
 
 		ret = nl80211_dump_wiphy_parse(skb, cb, &amp;state);
 		if (ret)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out_unlock;</span>
 
 		filter_wiphy = state.filter_wiphy;
 
<span class="p_chunk">@@ -2654,12 +2638,14 @@</span> <span class="p_context"> static int nl80211_dump_interface(struct sk_buff *skb, struct netlink_callback *</span>
 		wp_idx++;
 	}
  out:
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-</span>
 	cb-&gt;args[0] = wp_idx;
 	cb-&gt;args[1] = if_idx;
 
<span class="p_del">-	return skb-&gt;len;</span>
<span class="p_add">+	ret = skb-&gt;len;</span>
<span class="p_add">+ out_unlock:</span>
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int nl80211_get_interface(struct sk_buff *skb, struct genl_info *info)
<span class="p_chunk">@@ -4398,9 +4384,10 @@</span> <span class="p_context"> static int nl80211_dump_station(struct sk_buff *skb,</span>
 	int sta_idx = cb-&gt;args[2];
 	int err;
 
<span class="p_add">+	rtnl_lock();</span>
 	err = nl80211_prepare_wdev_dump(skb, cb, &amp;rdev, &amp;wdev);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_err;</span>
 
 	if (!wdev-&gt;netdev) {
 		err = -EINVAL;
<span class="p_chunk">@@ -4435,7 +4422,7 @@</span> <span class="p_context"> static int nl80211_dump_station(struct sk_buff *skb,</span>
 	cb-&gt;args[2] = sta_idx;
 	err = skb-&gt;len;
  out_err:
<span class="p_del">-	nl80211_finish_wdev_dump(rdev);</span>
<span class="p_add">+	rtnl_unlock();</span>
 
 	return err;
 }
<span class="p_chunk">@@ -5221,9 +5208,10 @@</span> <span class="p_context"> static int nl80211_dump_mpath(struct sk_buff *skb,</span>
 	int path_idx = cb-&gt;args[2];
 	int err;
 
<span class="p_add">+	rtnl_lock();</span>
 	err = nl80211_prepare_wdev_dump(skb, cb, &amp;rdev, &amp;wdev);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_err;</span>
 
 	if (!rdev-&gt;ops-&gt;dump_mpath) {
 		err = -EOPNOTSUPP;
<span class="p_chunk">@@ -5256,7 +5244,7 @@</span> <span class="p_context"> static int nl80211_dump_mpath(struct sk_buff *skb,</span>
 	cb-&gt;args[2] = path_idx;
 	err = skb-&gt;len;
  out_err:
<span class="p_del">-	nl80211_finish_wdev_dump(rdev);</span>
<span class="p_add">+	rtnl_unlock();</span>
 	return err;
 }
 
<span class="p_chunk">@@ -5416,9 +5404,10 @@</span> <span class="p_context"> static int nl80211_dump_mpp(struct sk_buff *skb,</span>
 	int path_idx = cb-&gt;args[2];
 	int err;
 
<span class="p_add">+	rtnl_lock();</span>
 	err = nl80211_prepare_wdev_dump(skb, cb, &amp;rdev, &amp;wdev);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_err;</span>
 
 	if (!rdev-&gt;ops-&gt;dump_mpp) {
 		err = -EOPNOTSUPP;
<span class="p_chunk">@@ -5451,7 +5440,7 @@</span> <span class="p_context"> static int nl80211_dump_mpp(struct sk_buff *skb,</span>
 	cb-&gt;args[2] = path_idx;
 	err = skb-&gt;len;
  out_err:
<span class="p_del">-	nl80211_finish_wdev_dump(rdev);</span>
<span class="p_add">+	rtnl_unlock();</span>
 	return err;
 }
 
<span class="p_chunk">@@ -7596,9 +7585,12 @@</span> <span class="p_context"> static int nl80211_dump_scan(struct sk_buff *skb, struct netlink_callback *cb)</span>
 	int start = cb-&gt;args[2], idx = 0;
 	int err;
 
<span class="p_add">+	rtnl_lock();</span>
 	err = nl80211_prepare_wdev_dump(skb, cb, &amp;rdev, &amp;wdev);
<span class="p_del">-	if (err)</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		rtnl_unlock();</span>
 		return err;
<span class="p_add">+	}</span>
 
 	wdev_lock(wdev);
 	spin_lock_bh(&amp;rdev-&gt;bss_lock);
<span class="p_chunk">@@ -7621,7 +7613,7 @@</span> <span class="p_context"> static int nl80211_dump_scan(struct sk_buff *skb, struct netlink_callback *cb)</span>
 	wdev_unlock(wdev);
 
 	cb-&gt;args[2] = idx;
<span class="p_del">-	nl80211_finish_wdev_dump(rdev);</span>
<span class="p_add">+	rtnl_unlock();</span>
 
 	return skb-&gt;len;
 }
<span class="p_chunk">@@ -7706,9 +7698,10 @@</span> <span class="p_context"> static int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)</span>
 	int res;
 	bool radio_stats;
 
<span class="p_add">+	rtnl_lock();</span>
 	res = nl80211_prepare_wdev_dump(skb, cb, &amp;rdev, &amp;wdev);
 	if (res)
<span class="p_del">-		return res;</span>
<span class="p_add">+		goto out_err;</span>
 
 	/* prepare_wdev_dump parsed the attributes */
 	radio_stats = attrbuf[NL80211_ATTR_SURVEY_RADIO_STATS];
<span class="p_chunk">@@ -7749,7 +7742,7 @@</span> <span class="p_context"> static int nl80211_dump_survey(struct sk_buff *skb, struct netlink_callback *cb)</span>
 	cb-&gt;args[2] = survey_idx;
 	res = skb-&gt;len;
  out_err:
<span class="p_del">-	nl80211_finish_wdev_dump(rdev);</span>
<span class="p_add">+	rtnl_unlock();</span>
 	return res;
 }
 
<span class="p_chunk">@@ -11378,17 +11371,13 @@</span> <span class="p_context"> static int nl80211_prepare_vendor_dump(struct sk_buff *skb,</span>
 	void *data = NULL;
 	unsigned int data_len = 0;
 
<span class="p_del">-	rtnl_lock();</span>
<span class="p_del">-</span>
 	if (cb-&gt;args[0]) {
 		/* subtract the 1 again here */
 		struct wiphy *wiphy = wiphy_idx_to_wiphy(cb-&gt;args[0] - 1);
 		struct wireless_dev *tmp;
 
<span class="p_del">-		if (!wiphy) {</span>
<span class="p_del">-			err = -ENODEV;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!wiphy)</span>
<span class="p_add">+			return -ENODEV;</span>
 		*rdev = wiphy_to_rdev(wiphy);
 		*wdev = NULL;
 
<span class="p_chunk">@@ -11408,23 +11397,19 @@</span> <span class="p_context"> static int nl80211_prepare_vendor_dump(struct sk_buff *skb,</span>
 	err = nlmsg_parse(cb-&gt;nlh, GENL_HDRLEN + nl80211_fam.hdrsize,
 			  attrbuf, nl80211_fam.maxattr, nl80211_policy);
 	if (err)
<span class="p_del">-		goto out_unlock;</span>
<span class="p_add">+		return err;</span>
 
 	if (!attrbuf[NL80211_ATTR_VENDOR_ID] ||
<span class="p_del">-	    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD]) {</span>
<span class="p_del">-		err = -EINVAL;</span>
<span class="p_del">-		goto out_unlock;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	    !attrbuf[NL80211_ATTR_VENDOR_SUBCMD])</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	*wdev = __cfg80211_wdev_from_attrs(sock_net(skb-&gt;sk), attrbuf);
 	if (IS_ERR(*wdev))
 		*wdev = NULL;
 
 	*rdev = __cfg80211_rdev_from_attrs(sock_net(skb-&gt;sk), attrbuf);
<span class="p_del">-	if (IS_ERR(*rdev)) {</span>
<span class="p_del">-		err = PTR_ERR(*rdev);</span>
<span class="p_del">-		goto out_unlock;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (IS_ERR(*rdev))</span>
<span class="p_add">+		return PTR_ERR(*rdev);</span>
 
 	vid = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_ID]);
 	subcmd = nla_get_u32(attrbuf[NL80211_ATTR_VENDOR_SUBCMD]);
<span class="p_chunk">@@ -11437,19 +11422,15 @@</span> <span class="p_context"> static int nl80211_prepare_vendor_dump(struct sk_buff *skb,</span>
 		if (vcmd-&gt;info.vendor_id != vid || vcmd-&gt;info.subcmd != subcmd)
 			continue;
 
<span class="p_del">-		if (!vcmd-&gt;dumpit) {</span>
<span class="p_del">-			err = -EOPNOTSUPP;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!vcmd-&gt;dumpit)</span>
<span class="p_add">+			return -EOPNOTSUPP;</span>
 
 		vcmd_idx = i;
 		break;
 	}
 
<span class="p_del">-	if (vcmd_idx &lt; 0) {</span>
<span class="p_del">-		err = -EOPNOTSUPP;</span>
<span class="p_del">-		goto out_unlock;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (vcmd_idx &lt; 0)</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
 
 	if (attrbuf[NL80211_ATTR_VENDOR_DATA]) {
 		data = nla_data(attrbuf[NL80211_ATTR_VENDOR_DATA]);
<span class="p_chunk">@@ -11466,9 +11447,6 @@</span> <span class="p_context"> static int nl80211_prepare_vendor_dump(struct sk_buff *skb,</span>
 
 	/* keep rtnl locked in successful case */
 	return 0;
<span class="p_del">- out_unlock:</span>
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-	return err;</span>
 }
 
 static int nl80211_vendor_cmd_dump(struct sk_buff *skb,
<span class="p_chunk">@@ -11483,9 +11461,10 @@</span> <span class="p_context"> static int nl80211_vendor_cmd_dump(struct sk_buff *skb,</span>
 	int err;
 	struct nlattr *vendor_data;
 
<span class="p_add">+	rtnl_lock();</span>
 	err = nl80211_prepare_vendor_dump(skb, cb, &amp;rdev, &amp;wdev);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out;</span>
 
 	vcmd_idx = cb-&gt;args[2];
 	data = (void *)cb-&gt;args[3];
<span class="p_chunk">@@ -11494,15 +11473,21 @@</span> <span class="p_context"> static int nl80211_vendor_cmd_dump(struct sk_buff *skb,</span>
 
 	if (vcmd-&gt;flags &amp; (WIPHY_VENDOR_CMD_NEED_WDEV |
 			   WIPHY_VENDOR_CMD_NEED_NETDEV)) {
<span class="p_del">-		if (!wdev)</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+		if (!wdev) {</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		if (vcmd-&gt;flags &amp; WIPHY_VENDOR_CMD_NEED_NETDEV &amp;&amp;
<span class="p_del">-		    !wdev-&gt;netdev)</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+		    !wdev-&gt;netdev) {</span>
<span class="p_add">+			err = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
 		if (vcmd-&gt;flags &amp; WIPHY_VENDOR_CMD_NEED_RUNNING) {
<span class="p_del">-			if (!wdev_running(wdev))</span>
<span class="p_del">-				return -ENETDOWN;</span>
<span class="p_add">+			if (!wdev_running(wdev)) {</span>
<span class="p_add">+				err = -ENETDOWN;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index 4c935202ce23..f3b1d7f50b81 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1832,6 +1832,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_set_client_pool(struct snd_seq_client *client,</span>
 	     info-&gt;output_pool != client-&gt;pool-&gt;size)) {
 		if (snd_seq_write_pool_allocated(client)) {
 			/* remove all existing cells */
<span class="p_add">+			snd_seq_pool_mark_closing(client-&gt;pool);</span>
 			snd_seq_queue_client_leave_cells(client-&gt;number);
 			snd_seq_pool_done(client-&gt;pool);
 		}
<span class="p_header">diff --git a/sound/core/seq/seq_fifo.c b/sound/core/seq/seq_fifo.c</span>
<span class="p_header">index 86240d02b530..3f4efcb85df5 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_fifo.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_fifo.c</span>
<span class="p_chunk">@@ -70,6 +70,9 @@</span> <span class="p_context"> void snd_seq_fifo_delete(struct snd_seq_fifo **fifo)</span>
 		return;
 	*fifo = NULL;
 
<span class="p_add">+	if (f-&gt;pool)</span>
<span class="p_add">+		snd_seq_pool_mark_closing(f-&gt;pool);</span>
<span class="p_add">+</span>
 	snd_seq_fifo_clear(f);
 
 	/* wake up clients if any */
<span class="p_header">diff --git a/sound/core/seq/seq_memory.c b/sound/core/seq/seq_memory.c</span>
<span class="p_header">index dfa5156f3585..5847c4475bf3 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_memory.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_memory.c</span>
<span class="p_chunk">@@ -414,6 +414,18 @@</span> <span class="p_context"> int snd_seq_pool_init(struct snd_seq_pool *pool)</span>
 	return 0;
 }
 
<span class="p_add">+/* refuse the further insertion to the pool */</span>
<span class="p_add">+void snd_seq_pool_mark_closing(struct snd_seq_pool *pool)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (snd_BUG_ON(!pool))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pool-&gt;lock, flags);</span>
<span class="p_add">+	pool-&gt;closing = 1;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* remove events */
 int snd_seq_pool_done(struct snd_seq_pool *pool)
 {
<span class="p_chunk">@@ -424,10 +436,6 @@</span> <span class="p_context"> int snd_seq_pool_done(struct snd_seq_pool *pool)</span>
 		return -EINVAL;
 
 	/* wait for closing all threads */
<span class="p_del">-	spin_lock_irqsave(&amp;pool-&gt;lock, flags);</span>
<span class="p_del">-	pool-&gt;closing = 1;</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	if (waitqueue_active(&amp;pool-&gt;output_sleep))
 		wake_up(&amp;pool-&gt;output_sleep);
 
<span class="p_chunk">@@ -484,6 +492,7 @@</span> <span class="p_context"> int snd_seq_pool_delete(struct snd_seq_pool **ppool)</span>
 	*ppool = NULL;
 	if (pool == NULL)
 		return 0;
<span class="p_add">+	snd_seq_pool_mark_closing(pool);</span>
 	snd_seq_pool_done(pool);
 	kfree(pool);
 	return 0;
<span class="p_header">diff --git a/sound/core/seq/seq_memory.h b/sound/core/seq/seq_memory.h</span>
<span class="p_header">index 4a2ec779b8a7..32f959c17786 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_memory.h</span>
<span class="p_header">+++ b/sound/core/seq/seq_memory.h</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> static inline int snd_seq_total_cells(struct snd_seq_pool *pool)</span>
 int snd_seq_pool_init(struct snd_seq_pool *pool);
 
 /* done pool - free events */
<span class="p_add">+void snd_seq_pool_mark_closing(struct snd_seq_pool *pool);</span>
 int snd_seq_pool_done(struct snd_seq_pool *pool);
 
 /* create pool */
<span class="p_header">diff --git a/sound/pci/ctxfi/cthw20k1.c b/sound/pci/ctxfi/cthw20k1.c</span>
<span class="p_header">index ab4cdab5cfa5..79edd88d5cd0 100644</span>
<span class="p_header">--- a/sound/pci/ctxfi/cthw20k1.c</span>
<span class="p_header">+++ b/sound/pci/ctxfi/cthw20k1.c</span>
<span class="p_chunk">@@ -1905,7 +1905,7 @@</span> <span class="p_context"> static int hw_card_start(struct hw *hw)</span>
 		return err;
 
 	/* Set DMA transfer mask */
<span class="p_del">-	if (dma_set_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(dma_bits))) {</span>
<span class="p_add">+	if (!dma_set_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(dma_bits))) {</span>
 		dma_set_coherent_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(dma_bits));
 	} else {
 		dma_set_mask(&amp;pci-&gt;dev, DMA_BIT_MASK(32));
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 6b041f7268fb..c813ad857650 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -6058,6 +6058,8 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		ALC295_STANDARD_PINS,
 		{0x17, 0x21014040},
 		{0x18, 0x21a19050}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0295, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC295_STANDARD_PINS),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0298, 0x1028, &quot;Dell&quot;, ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC298_STANDARD_PINS,
 		{0x17, 0x90170110}),

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



