
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.8.2 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.8.2</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 16, 2016, 4:11 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161016161154.GB19792@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9378247/mbox/"
   >mbox</a>
|
   <a href="/patch/9378247/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9378247/">/patch/9378247/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	C6726600CA for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:12:18 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B6B2928BE4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:12:18 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A9ACD28DE0; Sun, 16 Oct 2016 16:12:18 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6F0DE28BE4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:12:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932865AbcJPQMD (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 16 Oct 2016 12:12:03 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:47556 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932797AbcJPQLt (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 16 Oct 2016 12:11:49 -0400
Received: from localhost (unknown [37.162.138.181])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 84198A48;
	Sun, 16 Oct 2016 16:11:47 +0000 (UTC)
Date: Sun, 16 Oct 2016 18:11:54 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.8.2
Message-ID: &lt;20161016161154.GB19792@kroah.com&gt;
References: &lt;20161016161145.GA19792@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161016161145.GA19792@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 16, 2016, 4:11 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/virtual/kvm/devices/vcpu.txt b/Documentation/virtual/kvm/devices/vcpu.txt</span>
<span class="p_header">index c04165868faf..02f50686c418 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/devices/vcpu.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/devices/vcpu.txt</span>
<span class="p_chunk">@@ -30,4 +30,6 @@</span> <span class="p_context"> Returns: -ENODEV: PMUv3 not supported</span>
                  attribute
          -EBUSY: PMUv3 already initialized
 
<span class="p_del">-Request the initialization of the PMUv3.</span>
<span class="p_add">+Request the initialization of the PMUv3.  This must be done after creating the</span>
<span class="p_add">+in-kernel irqchip.  Creating a PMU with a userspace irqchip is currently not</span>
<span class="p_add">+supported.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 75db9f3988f3..bf6e44a421df 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 8
<span class="p_del">-SUBLEVEL = 1</span>
<span class="p_add">+SUBLEVEL = 2</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-390.dtsi b/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_header">index 094e39c66039..6cd18d8aaac7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_chunk">@@ -47,6 +47,8 @@</span> <span class="p_context"></span>
 #include &quot;armada-39x.dtsi&quot;
 
 / {
<span class="p_add">+	compatible = &quot;marvell,armada390&quot;;</span>
<span class="p_add">+</span>
 	soc {
 		internal-regs {
 			pinctrl@18000 {
<span class="p_chunk">@@ -54,4 +56,5 @@</span> <span class="p_context"></span>
 				reg = &lt;0x18000 0x20&gt;;
 			};
 		};
<span class="p_add">+	};</span>
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/qcom-apq8064.dtsi b/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_header">index 74a9b6c394f5..9dc83b09d987 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;dt-bindings/reset/qcom,gcc-msm8960.h&gt;
 #include &lt;dt-bindings/clock/qcom,mmcc-msm8960.h&gt;
 #include &lt;dt-bindings/soc/qcom,gsbi.h&gt;
<span class="p_add">+#include &lt;dt-bindings/interrupt-controller/irq.h&gt;</span>
 #include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;
 / {
 	model = &quot;Qualcomm APQ8064&quot;;
<span class="p_chunk">@@ -559,22 +560,50 @@</span> <span class="p_context"></span>
 					compatible = &quot;qcom,pm8921-gpio&quot;,
 						     &quot;qcom,ssbi-gpio&quot;;
 					reg = &lt;0x150&gt;;
<span class="p_del">-					interrupts = &lt;192 1&gt;, &lt;193 1&gt;, &lt;194 1&gt;,</span>
<span class="p_del">-						     &lt;195 1&gt;, &lt;196 1&gt;, &lt;197 1&gt;,</span>
<span class="p_del">-						     &lt;198 1&gt;, &lt;199 1&gt;, &lt;200 1&gt;,</span>
<span class="p_del">-						     &lt;201 1&gt;, &lt;202 1&gt;, &lt;203 1&gt;,</span>
<span class="p_del">-						     &lt;204 1&gt;, &lt;205 1&gt;, &lt;206 1&gt;,</span>
<span class="p_del">-						     &lt;207 1&gt;, &lt;208 1&gt;, &lt;209 1&gt;,</span>
<span class="p_del">-						     &lt;210 1&gt;, &lt;211 1&gt;, &lt;212 1&gt;,</span>
<span class="p_del">-						     &lt;213 1&gt;, &lt;214 1&gt;, &lt;215 1&gt;,</span>
<span class="p_del">-						     &lt;216 1&gt;, &lt;217 1&gt;, &lt;218 1&gt;,</span>
<span class="p_del">-						     &lt;219 1&gt;, &lt;220 1&gt;, &lt;221 1&gt;,</span>
<span class="p_del">-						     &lt;222 1&gt;, &lt;223 1&gt;, &lt;224 1&gt;,</span>
<span class="p_del">-						     &lt;225 1&gt;, &lt;226 1&gt;, &lt;227 1&gt;,</span>
<span class="p_del">-						     &lt;228 1&gt;, &lt;229 1&gt;, &lt;230 1&gt;,</span>
<span class="p_del">-						     &lt;231 1&gt;, &lt;232 1&gt;, &lt;233 1&gt;,</span>
<span class="p_del">-						     &lt;234 1&gt;, &lt;235 1&gt;;</span>
<span class="p_del">-</span>
<span class="p_add">+					interrupts = &lt;192 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;193 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;194 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;195 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;196 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;197 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;198 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;199 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;200 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;201 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;202 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;203 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;204 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;205 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;206 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;207 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;208 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;209 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;210 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;211 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;212 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;213 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;214 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;215 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;216 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;217 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;218 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;219 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;220 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;221 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;222 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;223 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;224 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;225 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;226 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;227 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;228 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;229 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;230 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;231 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;232 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;233 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;234 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;235 IRQ_TYPE_NONE&gt;;</span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 
<span class="p_chunk">@@ -587,9 +616,18 @@</span> <span class="p_context"></span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 					interrupts =
<span class="p_del">-					&lt;128 1&gt;, &lt;129 1&gt;, &lt;130 1&gt;, &lt;131 1&gt;,</span>
<span class="p_del">-					&lt;132 1&gt;, &lt;133 1&gt;, &lt;134 1&gt;, &lt;135 1&gt;,</span>
<span class="p_del">-					&lt;136 1&gt;, &lt;137 1&gt;, &lt;138 1&gt;, &lt;139 1&gt;;</span>
<span class="p_add">+					&lt;128 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;129 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;130 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;131 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;132 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;133 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;134 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;135 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;136 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;137 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;138 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;139 IRQ_TYPE_NONE&gt;;</span>
 				};
 
 				rtc@11d {
<span class="p_header">diff --git a/arch/arm/boot/dts/qcom-msm8660.dtsi b/arch/arm/boot/dts/qcom-msm8660.dtsi</span>
<span class="p_header">index acbe71febe13..8c65e0d82559 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/qcom-msm8660.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/qcom-msm8660.dtsi</span>
<span class="p_chunk">@@ -2,6 +2,7 @@</span> <span class="p_context"></span>
 
 /include/ &quot;skeleton.dtsi&quot;
 
<span class="p_add">+#include &lt;dt-bindings/interrupt-controller/irq.h&gt;</span>
 #include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;
 #include &lt;dt-bindings/clock/qcom,gcc-msm8660.h&gt;
 #include &lt;dt-bindings/soc/qcom,gsbi.h&gt;
<span class="p_chunk">@@ -159,21 +160,50 @@</span> <span class="p_context"></span>
 						     &quot;qcom,ssbi-gpio&quot;;
 					reg = &lt;0x150&gt;;
 					interrupt-parent = &lt;&amp;pmicintc&gt;;
<span class="p_del">-					interrupts = &lt;192 1&gt;, &lt;193 1&gt;, &lt;194 1&gt;,</span>
<span class="p_del">-						     &lt;195 1&gt;, &lt;196 1&gt;, &lt;197 1&gt;,</span>
<span class="p_del">-						     &lt;198 1&gt;, &lt;199 1&gt;, &lt;200 1&gt;,</span>
<span class="p_del">-						     &lt;201 1&gt;, &lt;202 1&gt;, &lt;203 1&gt;,</span>
<span class="p_del">-						     &lt;204 1&gt;, &lt;205 1&gt;, &lt;206 1&gt;,</span>
<span class="p_del">-						     &lt;207 1&gt;, &lt;208 1&gt;, &lt;209 1&gt;,</span>
<span class="p_del">-						     &lt;210 1&gt;, &lt;211 1&gt;, &lt;212 1&gt;,</span>
<span class="p_del">-						     &lt;213 1&gt;, &lt;214 1&gt;, &lt;215 1&gt;,</span>
<span class="p_del">-						     &lt;216 1&gt;, &lt;217 1&gt;, &lt;218 1&gt;,</span>
<span class="p_del">-						     &lt;219 1&gt;, &lt;220 1&gt;, &lt;221 1&gt;,</span>
<span class="p_del">-						     &lt;222 1&gt;, &lt;223 1&gt;, &lt;224 1&gt;,</span>
<span class="p_del">-						     &lt;225 1&gt;, &lt;226 1&gt;, &lt;227 1&gt;,</span>
<span class="p_del">-						     &lt;228 1&gt;, &lt;229 1&gt;, &lt;230 1&gt;,</span>
<span class="p_del">-						     &lt;231 1&gt;, &lt;232 1&gt;, &lt;233 1&gt;,</span>
<span class="p_del">-						     &lt;234 1&gt;, &lt;235 1&gt;;</span>
<span class="p_add">+					interrupts = &lt;192 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;193 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;194 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;195 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;196 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;197 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;198 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;199 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;200 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;201 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;202 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;203 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;204 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;205 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;206 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;207 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;208 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;209 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;210 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;211 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;212 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;213 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;214 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;215 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;216 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;217 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;218 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;219 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;220 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;221 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;222 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;223 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;224 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;225 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;226 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;227 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;228 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;229 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;230 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;231 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;232 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;233 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;234 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;235 IRQ_TYPE_NONE&gt;;</span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 
<span class="p_chunk">@@ -187,9 +217,18 @@</span> <span class="p_context"></span>
 					#gpio-cells = &lt;2&gt;;
 					interrupt-parent = &lt;&amp;pmicintc&gt;;
 					interrupts =
<span class="p_del">-					&lt;128 1&gt;, &lt;129 1&gt;, &lt;130 1&gt;, &lt;131 1&gt;,</span>
<span class="p_del">-					&lt;132 1&gt;, &lt;133 1&gt;, &lt;134 1&gt;, &lt;135 1&gt;,</span>
<span class="p_del">-					&lt;136 1&gt;, &lt;137 1&gt;, &lt;138 1&gt;, &lt;139 1&gt;;</span>
<span class="p_add">+					&lt;128 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;129 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;130 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;131 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;132 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;133 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;134 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;135 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;136 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;137 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;138 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;139 IRQ_TYPE_NONE&gt;;</span>
 				};
 
 				pwrkey@1c {
<span class="p_header">diff --git a/arch/arm/include/asm/delay.h b/arch/arm/include/asm/delay.h</span>
<span class="p_header">index b7a428154355..b1ce037e4380 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/delay.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/delay.h</span>
<span class="p_chunk">@@ -10,7 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/param.h&gt;	/* HZ */
 
 #define MAX_UDELAY_MS	2
<span class="p_del">-#define UDELAY_MULT	UL(2047 * HZ + 483648 * HZ / 1000000)</span>
<span class="p_add">+#define UDELAY_MULT	UL(2147 * HZ + 483648 * HZ / 1000000)</span>
 #define UDELAY_SHIFT	31
 
 #ifndef __ASSEMBLY__
<span class="p_header">diff --git a/arch/arm64/kernel/stacktrace.c b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">index d9751a4769e7..d34fd72172b6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -43,6 +43,9 @@</span> <span class="p_context"> int notrace unwind_frame(struct task_struct *tsk, struct stackframe *frame)</span>
 	unsigned long fp = frame-&gt;fp;
 	unsigned long irq_stack_ptr;
 
<span class="p_add">+	if (!tsk)</span>
<span class="p_add">+		tsk = current;</span>
<span class="p_add">+</span>
 	/*
 	 * Switching between stacks is valid when tracing current and in
 	 * non-preemptible context.
<span class="p_chunk">@@ -67,7 +70,7 @@</span> <span class="p_context"> int notrace unwind_frame(struct task_struct *tsk, struct stackframe *frame)</span>
 	frame-&gt;pc = READ_ONCE_NOCHECK(*(unsigned long *)(fp + 8));
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
<span class="p_del">-	if (tsk &amp;&amp; tsk-&gt;ret_stack &amp;&amp;</span>
<span class="p_add">+	if (tsk-&gt;ret_stack &amp;&amp;</span>
 			(frame-&gt;pc == (unsigned long)return_to_handler)) {
 		/*
 		 * This is a case where function graph tracer has
<span class="p_header">diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c</span>
<span class="p_header">index e04f83873af7..df06750846de 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/traps.c</span>
<span class="p_chunk">@@ -142,6 +142,11 @@</span> <span class="p_context"> static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)</span>
 	unsigned long irq_stack_ptr;
 	int skip;
 
<span class="p_add">+	pr_debug(&quot;%s(regs = %p tsk = %p)\n&quot;, __func__, regs, tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tsk)</span>
<span class="p_add">+		tsk = current;</span>
<span class="p_add">+</span>
 	/*
 	 * Switching between stacks is valid when tracing current and in
 	 * non-preemptible context.
<span class="p_chunk">@@ -151,11 +156,6 @@</span> <span class="p_context"> static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)</span>
 	else
 		irq_stack_ptr = 0;
 
<span class="p_del">-	pr_debug(&quot;%s(regs = %p tsk = %p)\n&quot;, __func__, regs, tsk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!tsk)</span>
<span class="p_del">-		tsk = current;</span>
<span class="p_del">-</span>
 	if (tsk == current) {
 		frame.fp = (unsigned long)__builtin_frame_address(0);
 		frame.sp = current_stack_pointer;
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index e788515f766b..43853ec6e160 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -846,6 +846,47 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbr(struct kvm_vcpu *vcpu)</span>
 	return EMULATE_FAIL;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * kvm_mips_invalidate_guest_tlb() - Indicates a change in guest MMU map.</span>
<span class="p_add">+ * @vcpu:	VCPU with changed mappings.</span>
<span class="p_add">+ * @tlb:	TLB entry being removed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is called to indicate a single change in guest MMU mappings, so that we</span>
<span class="p_add">+ * can arrange TLB flushes on this and other CPUs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void kvm_mips_invalidate_guest_tlb(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+					  struct kvm_mips_tlb *tlb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu, i;</span>
<span class="p_add">+	bool user;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No need to flush for entries which are already invalid */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_lo[0] | tlb-&gt;tlb_lo[1]) &amp; ENTRYLO_V))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	/* User address space doesn&#39;t need flushing for KSeg2/3 changes */</span>
<span class="p_add">+	user = tlb-&gt;tlb_hi &lt; KVM_GUEST_KSEG0;</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_add">+	 * matches, invalidate it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Invalidate the whole ASID on other CPUs */</span>
<span class="p_add">+	cpu = smp_processor_id();</span>
<span class="p_add">+	for_each_possible_cpu(i) {</span>
<span class="p_add">+		if (i == cpu)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (user)</span>
<span class="p_add">+			vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+		vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Write Guest TLB Entry @ Index */
 enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -865,11 +906,8 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)</span>
 	}
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_del">-	 * matches, invalidate it</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -898,11 +936,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwr(struct kvm_vcpu *vcpu)</span>
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_del">-	 * matches, invalidate it</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -1026,6 +1060,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(union mips_instruction inst,</span>
 	enum emulation_result er = EMULATE_DONE;
 	u32 rt, rd, sel;
 	unsigned long curr_pc;
<span class="p_add">+	int cpu, i;</span>
 
 	/*
 	 * Update PC and hold onto current PC in case there is
<span class="p_chunk">@@ -1135,8 +1170,16 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(union mips_instruction inst,</span>
 							&amp; KVM_ENTRYHI_ASID,
 						nasid);
 
<span class="p_add">+					preempt_disable();</span>
 					/* Blow away the shadow host TLBs */
 					kvm_mips_flush_host_tlb(1);
<span class="p_add">+					cpu = smp_processor_id();</span>
<span class="p_add">+					for_each_possible_cpu(i)</span>
<span class="p_add">+						if (i != cpu) {</span>
<span class="p_add">+							vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+							vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+						}</span>
<span class="p_add">+					preempt_enable();</span>
 				}
 				kvm_write_c0_guest_entryhi(cop0,
 							   vcpu-&gt;arch.gprs[rt]);
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index f69f40f1519a..978dada662ae 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -737,6 +737,7 @@</span> <span class="p_context"></span>
 #define   MMCR0_FCHV	0x00000001UL /* freeze conditions in hypervisor mode */
 #define SPRN_MMCR1	798
 #define SPRN_MMCR2	785
<span class="p_add">+#define SPRN_UMMCR2	769</span>
 #define SPRN_MMCRA	0x312
 #define   MMCRA_SDSYNC	0x80000000UL /* SDAR synced with SIAR */
 #define   MMCRA_SDAR_DCACHE_MISS 0x40000000UL
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_emulate.c b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">index 2afdb9c0937d..729f8faa95c5 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_chunk">@@ -498,6 +498,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mtspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong spr_val)</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 #endif
 		break;
 unprivileged:
<span class="p_chunk">@@ -640,6 +641,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mfspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong *spr_val</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 	case SPRN_TIR:
 #endif
 		*spr_val = 0;
<span class="p_header">diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c</span>
<span class="p_header">index 02b4672f7347..df3f2706d3e5 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/booke.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/booke.c</span>
<span class="p_chunk">@@ -2038,7 +2038,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,</span>
 		if (type == KVMPPC_DEBUG_NONE)
 			continue;
 
<span class="p_del">-		if (type &amp; !(KVMPPC_DEBUG_WATCH_READ |</span>
<span class="p_add">+		if (type &amp; ~(KVMPPC_DEBUG_WATCH_READ |</span>
 			     KVMPPC_DEBUG_WATCH_WRITE |
 			     KVMPPC_DEBUG_BREAKPOINT))
 			return -EINVAL;
<span class="p_header">diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h</span>
<span class="p_header">index ae55a43e09c0..19f30a814f54 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/fpu/xstate.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/fpu/xstate.h</span>
<span class="p_chunk">@@ -27,11 +27,12 @@</span> <span class="p_context"></span>
 				 XFEATURE_MASK_YMM | \
 				 XFEATURE_MASK_OPMASK | \
 				 XFEATURE_MASK_ZMM_Hi256 | \
<span class="p_del">-				 XFEATURE_MASK_Hi16_ZMM	 | \</span>
<span class="p_del">-				 XFEATURE_MASK_PKRU)</span>
<span class="p_add">+				 XFEATURE_MASK_Hi16_ZMM)</span>
 
 /* Supported features which require eager state saving */
<span class="p_del">-#define XFEATURE_MASK_EAGER	(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR)</span>
<span class="p_add">+#define XFEATURE_MASK_EAGER	(XFEATURE_MASK_BNDREGS | \</span>
<span class="p_add">+				 XFEATURE_MASK_BNDCSR | \</span>
<span class="p_add">+				 XFEATURE_MASK_PKRU)</span>
 
 /* All currently supported features */
 #define XCNTXT_MASK	(XFEATURE_MASK_LAZY | XFEATURE_MASK_EAGER)
<span class="p_header">diff --git a/arch/x86/include/asm/intel-family.h b/arch/x86/include/asm/intel-family.h</span>
<span class="p_header">index 627719475457..9ae5ab80a497 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/intel-family.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/intel-family.h</span>
<span class="p_chunk">@@ -56,8 +56,8 @@</span> <span class="p_context"></span>
 #define INTEL_FAM6_ATOM_SILVERMONT1	0x37 /* BayTrail/BYT / Valleyview */
 #define INTEL_FAM6_ATOM_SILVERMONT2	0x4D /* Avaton/Rangely */
 #define INTEL_FAM6_ATOM_AIRMONT		0x4C /* CherryTrail / Braswell */
<span class="p_del">-#define INTEL_FAM6_ATOM_MERRIFIELD1	0x4A /* Tangier */</span>
<span class="p_del">-#define INTEL_FAM6_ATOM_MERRIFIELD2	0x5A /* Annidale */</span>
<span class="p_add">+#define INTEL_FAM6_ATOM_MERRIFIELD	0x4A /* Tangier */</span>
<span class="p_add">+#define INTEL_FAM6_ATOM_MOOREFIELD	0x5A /* Annidale */</span>
 #define INTEL_FAM6_ATOM_GOLDMONT	0x5C
 #define INTEL_FAM6_ATOM_DENVERTON	0x5F /* Goldmont Microserver */
 
<span class="p_header">diff --git a/arch/x86/include/asm/mpspec.h b/arch/x86/include/asm/mpspec.h</span>
<span class="p_header">index b07233b64578..c2f94dcc92ce 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mpspec.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mpspec.h</span>
<span class="p_chunk">@@ -6,7 +6,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/x86_init.h&gt;
 #include &lt;asm/apicdef.h&gt;
 
<span class="p_del">-extern int apic_version[];</span>
 extern int pic_mode;
 
 #ifdef CONFIG_X86_32
<span class="p_chunk">@@ -40,6 +39,7 @@</span> <span class="p_context"> extern int mp_bus_id_to_type[MAX_MP_BUSSES];</span>
 extern DECLARE_BITMAP(mp_bus_not_pci, MAX_MP_BUSSES);
 
 extern unsigned int boot_cpu_physical_apicid;
<span class="p_add">+extern u8 boot_cpu_apic_version;</span>
 extern unsigned long mp_lapic_addr;
 
 #ifdef CONFIG_X86_LOCAL_APIC
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index 90d84c3eee53..fbd19444403f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static int acpi_register_lapic(int id, u32 acpiid, u8 enabled)</span>
 	}
 
 	if (boot_cpu_physical_apicid != -1U)
<span class="p_del">-		ver = apic_version[boot_cpu_physical_apicid];</span>
<span class="p_add">+		ver = boot_cpu_apic_version;</span>
 
 	cpu = generic_processor_info(id, ver);
 	if (cpu &gt;= 0)
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index f3e9b2df4b16..076c315cdf18 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -64,6 +64,8 @@</span> <span class="p_context"> unsigned disabled_cpus;</span>
 unsigned int boot_cpu_physical_apicid = -1U;
 EXPORT_SYMBOL_GPL(boot_cpu_physical_apicid);
 
<span class="p_add">+u8 boot_cpu_apic_version;</span>
<span class="p_add">+</span>
 /*
  * The highest APIC ID seen during enumeration.
  */
<span class="p_chunk">@@ -1816,8 +1818,7 @@</span> <span class="p_context"> void __init init_apic_mappings(void)</span>
 		 * since smp_sanity_check is prepared for such a case
 		 * and disable smp mode
 		 */
<span class="p_del">-		apic_version[new_apicid] =</span>
<span class="p_del">-			 GET_APIC_VERSION(apic_read(APIC_LVR));</span>
<span class="p_add">+		boot_cpu_apic_version = GET_APIC_VERSION(apic_read(APIC_LVR));</span>
 	}
 }
 
<span class="p_chunk">@@ -1832,13 +1833,10 @@</span> <span class="p_context"> void __init register_lapic_address(unsigned long address)</span>
 	}
 	if (boot_cpu_physical_apicid == -1U) {
 		boot_cpu_physical_apicid  = read_apic_id();
<span class="p_del">-		apic_version[boot_cpu_physical_apicid] =</span>
<span class="p_del">-			 GET_APIC_VERSION(apic_read(APIC_LVR));</span>
<span class="p_add">+		boot_cpu_apic_version = GET_APIC_VERSION(apic_read(APIC_LVR));</span>
 	}
 }
 
<span class="p_del">-int apic_version[MAX_LOCAL_APIC];</span>
<span class="p_del">-</span>
 /*
  * Local APIC interrupts
  */
<span class="p_chunk">@@ -2130,11 +2128,10 @@</span> <span class="p_context"> int generic_processor_info(int apicid, int version)</span>
 			   cpu, apicid);
 		version = 0x10;
 	}
<span class="p_del">-	apic_version[apicid] = version;</span>
 
<span class="p_del">-	if (version != apic_version[boot_cpu_physical_apicid]) {</span>
<span class="p_add">+	if (version != boot_cpu_apic_version) {</span>
 		pr_warning(&quot;BIOS bug: APIC version mismatch, boot CPU: %x, CPU %d: version %x\n&quot;,
<span class="p_del">-			apic_version[boot_cpu_physical_apicid], cpu, version);</span>
<span class="p_add">+			boot_cpu_apic_version, cpu, version);</span>
 	}
 
 	physid_set(apicid, phys_cpu_present_map);
<span class="p_chunk">@@ -2277,7 +2274,7 @@</span> <span class="p_context"> int __init APIC_init_uniprocessor(void)</span>
 	 * Complain if the BIOS pretends there is one.
 	 */
 	if (!boot_cpu_has(X86_FEATURE_APIC) &amp;&amp;
<span class="p_del">-	    APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {</span>
<span class="p_add">+	    APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 		pr_err(&quot;BIOS bug, local APIC 0x%x not detected!...\n&quot;,
 			boot_cpu_physical_apicid);
 		return -1;
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index 7491f417a8e4..48e6d84f173e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -1593,7 +1593,7 @@</span> <span class="p_context"> void __init setup_ioapic_ids_from_mpc(void)</span>
 	 * no meaning without the serial APIC bus.
 	 */
 	if (!(boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)
<span class="p_del">-		|| APIC_XAPIC(apic_version[boot_cpu_physical_apicid]))</span>
<span class="p_add">+		|| APIC_XAPIC(boot_cpu_apic_version))</span>
 		return;
 	setup_ioapic_ids_from_mpc_nocheck();
 }
<span class="p_chunk">@@ -2423,7 +2423,7 @@</span> <span class="p_context"> static int io_apic_get_unique_id(int ioapic, int apic_id)</span>
 static u8 io_apic_unique_id(int idx, u8 id)
 {
 	if ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) &amp;&amp;
<span class="p_del">-	    !APIC_XAPIC(apic_version[boot_cpu_physical_apicid]))</span>
<span class="p_add">+	    !APIC_XAPIC(boot_cpu_apic_version))</span>
 		return io_apic_get_unique_id(idx, id);
 	else
 		return id;
<span class="p_header">diff --git a/arch/x86/kernel/apic/probe_32.c b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">index 7c43e716c158..563096267ca2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> early_param(&quot;apic&quot;, parse_apic);</span>
 
 void __init default_setup_apic_routing(void)
 {
<span class="p_del">-	int version = apic_version[boot_cpu_physical_apicid];</span>
<span class="p_add">+	int version = boot_cpu_apic_version;</span>
 
 	if (num_possible_cpus() &gt; 8) {
 		switch (boot_cpu_data.x86_vendor) {
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index 6066d945c40e..5d30c5e42bb1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -661,11 +661,28 @@</span> <span class="p_context"> void irq_complete_move(struct irq_cfg *cfg)</span>
  */
 void irq_force_complete_move(struct irq_desc *desc)
 {
<span class="p_del">-	struct irq_data *irqdata = irq_desc_get_irq_data(desc);</span>
<span class="p_del">-	struct apic_chip_data *data = apic_chip_data(irqdata);</span>
<span class="p_del">-	struct irq_cfg *cfg = data ? &amp;data-&gt;cfg : NULL;</span>
<span class="p_add">+	struct irq_data *irqdata;</span>
<span class="p_add">+	struct apic_chip_data *data;</span>
<span class="p_add">+	struct irq_cfg *cfg;</span>
 	unsigned int cpu;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The function is called for all descriptors regardless of which</span>
<span class="p_add">+	 * irqdomain they belong to. For example if an IRQ is provided by</span>
<span class="p_add">+	 * an irq_chip as part of a GPIO driver, the chip data for that</span>
<span class="p_add">+	 * descriptor is specific to the irq_chip in question.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Check first that the chip_data is what we expect</span>
<span class="p_add">+	 * (apic_chip_data) before touching it any further.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	irqdata = irq_domain_get_irq_data(x86_vector_domain,</span>
<span class="p_add">+					  irq_desc_get_irq(desc));</span>
<span class="p_add">+	if (!irqdata)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = apic_chip_data(irqdata);</span>
<span class="p_add">+	cfg = data ? &amp;data-&gt;cfg : NULL;</span>
<span class="p_add">+</span>
 	if (!cfg)
 		return;
 
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 621b501f8935..8a90f1517837 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -348,7 +348,7 @@</span> <span class="p_context"> int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,</span>
 		 * continue building up new bios map based on this
 		 * information
 		 */
<span class="p_del">-		if (current_type != last_type || current_type == E820_PRAM) {</span>
<span class="p_add">+		if (current_type != last_type) {</span>
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]-&gt;addr - last_addr;
<span class="p_chunk">@@ -754,7 +754,7 @@</span> <span class="p_context"> u64 __init early_reserve_e820(u64 size, u64 align)</span>
 /*
  * Find the highest page frame number we have available
  */
<span class="p_del">-static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
<span class="p_add">+static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)</span>
 {
 	int i;
 	unsigned long last_pfn = 0;
<span class="p_chunk">@@ -765,11 +765,7 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Persistent memory is accounted as ram for purposes of</span>
<span class="p_del">-		 * establishing max_pfn and mem_map.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ei-&gt;type != E820_RAM &amp;&amp; ei-&gt;type != E820_PRAM)</span>
<span class="p_add">+		if (ei-&gt;type != type)</span>
 			continue;
 
 		start_pfn = ei-&gt;addr &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -794,12 +790,12 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 }
 unsigned long __init e820_end_of_ram_pfn(void)
 {
<span class="p_del">-	return e820_end_pfn(MAX_ARCH_PFN);</span>
<span class="p_add">+	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);</span>
 }
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
<span class="p_del">-	return e820_end_pfn(1UL &lt;&lt; (32-PAGE_SHIFT));</span>
<span class="p_add">+	return e820_end_pfn(1UL &lt;&lt; (32 - PAGE_SHIFT), E820_RAM);</span>
 }
 
 static void early_panic(char *msg)
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index 63236d8f84bf..a21068e49dac 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -110,12 +110,13 @@</span> <span class="p_context"> void __show_regs(struct pt_regs *regs, int all)</span>
 	get_debugreg(d7, 7);
 
 	/* Only print out debug registers if they are in their non-default state. */
<span class="p_del">-	if ((d0 == 0) &amp;&amp; (d1 == 0) &amp;&amp; (d2 == 0) &amp;&amp; (d3 == 0) &amp;&amp;</span>
<span class="p_del">-	    (d6 == DR6_RESERVED) &amp;&amp; (d7 == 0x400))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	printk(KERN_DEFAULT &quot;DR0: %016lx DR1: %016lx DR2: %016lx\n&quot;, d0, d1, d2);</span>
<span class="p_del">-	printk(KERN_DEFAULT &quot;DR3: %016lx DR6: %016lx DR7: %016lx\n&quot;, d3, d6, d7);</span>
<span class="p_add">+	if (!((d0 == 0) &amp;&amp; (d1 == 0) &amp;&amp; (d2 == 0) &amp;&amp; (d3 == 0) &amp;&amp;</span>
<span class="p_add">+	    (d6 == DR6_RESERVED) &amp;&amp; (d7 == 0x400))) {</span>
<span class="p_add">+		printk(KERN_DEFAULT &quot;DR0: %016lx DR1: %016lx DR2: %016lx\n&quot;,</span>
<span class="p_add">+		       d0, d1, d2);</span>
<span class="p_add">+		printk(KERN_DEFAULT &quot;DR3: %016lx DR6: %016lx DR7: %016lx\n&quot;,</span>
<span class="p_add">+		       d3, d6, d7);</span>
<span class="p_add">+	}</span>
 
 	if (boot_cpu_has(X86_FEATURE_OSPKE))
 		printk(KERN_DEFAULT &quot;PKRU: %08x\n&quot;, read_pkru());
<span class="p_header">diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c</span>
<span class="p_header">index f79576a541ff..a1606eadd9ce 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ptrace.c</span>
<span class="p_chunk">@@ -173,8 +173,8 @@</span> <span class="p_context"> unsigned long kernel_stack_pointer(struct pt_regs *regs)</span>
 		return sp;
 
 	prev_esp = (u32 *)(context);
<span class="p_del">-	if (prev_esp)</span>
<span class="p_del">-		return (unsigned long)prev_esp;</span>
<span class="p_add">+	if (*prev_esp)</span>
<span class="p_add">+		return (unsigned long)*prev_esp;</span>
 
 	return (unsigned long)regs;
 }
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 4296beb8fdd3..82b17373b66a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -690,7 +690,7 @@</span> <span class="p_context"> wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip)</span>
 	 * Give the other CPU some time to accept the IPI.
 	 */
 	udelay(200);
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 		maxlvt = lapic_get_maxlvt();
 		if (maxlvt &gt; 3)			/* Due to the Pentium erratum 3AP.  */
 			apic_write(APIC_ESR, 0);
<span class="p_chunk">@@ -717,7 +717,7 @@</span> <span class="p_context"> wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)</span>
 	/*
 	 * Be paranoid about clearing APIC errors.
 	 */
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[phys_apicid])) {</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 		if (maxlvt &gt; 3)		/* Due to the Pentium erratum 3AP.  */
 			apic_write(APIC_ESR, 0);
 		apic_read(APIC_ESR);
<span class="p_chunk">@@ -756,7 +756,7 @@</span> <span class="p_context"> wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)</span>
 	 * Determine this based on the APIC version.
 	 * If we don&#39;t have an integrated APIC, don&#39;t send the STARTUP IPIs.
 	 */
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[phys_apicid]))</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version))</span>
 		num_starts = 2;
 	else
 		num_starts = 0;
<span class="p_chunk">@@ -994,7 +994,7 @@</span> <span class="p_context"> static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle)</span>
 		/*
 		 * Be paranoid about clearing APIC errors.
 		*/
<span class="p_del">-		if (APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {</span>
<span class="p_add">+		if (APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 			apic_write(APIC_ESR, 0);
 			apic_read(APIC_ESR);
 		}
<span class="p_chunk">@@ -1249,7 +1249,7 @@</span> <span class="p_context"> static int __init smp_sanity_check(unsigned max_cpus)</span>
 	/*
 	 * If we couldn&#39;t find a local APIC, then get out of here now!
 	 */
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid]) &amp;&amp;</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version) &amp;&amp;</span>
 	    !boot_cpu_has(X86_FEATURE_APIC)) {
 		if (!disable_apic) {
 			pr_err(&quot;BIOS bug, local APIC #%d not detected!...\n&quot;,
<span class="p_chunk">@@ -1406,9 +1406,21 @@</span> <span class="p_context"> __init void prefill_possible_map(void)</span>
 {
 	int i, possible;
 
<span class="p_del">-	/* no processor from mptable or madt */</span>
<span class="p_del">-	if (!num_processors)</span>
<span class="p_del">-		num_processors = 1;</span>
<span class="p_add">+	/* No boot processor was found in mptable or ACPI MADT */</span>
<span class="p_add">+	if (!num_processors) {</span>
<span class="p_add">+		int apicid = boot_cpu_physical_apicid;</span>
<span class="p_add">+		int cpu = hard_smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_warn(&quot;Boot CPU (id %d) not listed by BIOS\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Make sure boot cpu is enumerated */</span>
<span class="p_add">+		if (apic-&gt;cpu_present_to_apicid(0) == BAD_APICID &amp;&amp;</span>
<span class="p_add">+		    apic-&gt;apic_id_valid(apicid))</span>
<span class="p_add">+			generic_processor_info(apicid, boot_cpu_apic_version);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!num_processors)</span>
<span class="p_add">+			num_processors = 1;</span>
<span class="p_add">+	}</span>
 
 	i = setup_max_cpus ?: 1;
 	if (setup_possible_cpus == -1) {
<span class="p_header">diff --git a/arch/x86/platform/atom/punit_atom_debug.c b/arch/x86/platform/atom/punit_atom_debug.c</span>
<span class="p_header">index 8ff7b9355416..d49d3be81953 100644</span>
<span class="p_header">--- a/arch/x86/platform/atom/punit_atom_debug.c</span>
<span class="p_header">+++ b/arch/x86/platform/atom/punit_atom_debug.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> static void punit_dbgfs_unregister(void)</span>
 
 static const struct x86_cpu_id intel_punit_cpu_ids[] = {
 	ICPU(INTEL_FAM6_ATOM_SILVERMONT1, punit_device_byt),
<span class="p_del">-	ICPU(INTEL_FAM6_ATOM_MERRIFIELD1, punit_device_tng),</span>
<span class="p_add">+	ICPU(INTEL_FAM6_ATOM_MERRIFIELD,  punit_device_tng),</span>
 	ICPU(INTEL_FAM6_ATOM_AIRMONT,	  punit_device_cht),
 	{}
 };
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/pwr.c b/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_header">index c901a3423772..6eca0f6fe57d 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/pwr.c</span>
<span class="p_chunk">@@ -354,7 +354,7 @@</span> <span class="p_context"> static int mid_pwr_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 	return 0;
 }
 
<span class="p_del">-static int mid_set_initial_state(struct mid_pwr *pwr)</span>
<span class="p_add">+static int mid_set_initial_state(struct mid_pwr *pwr, const u32 *states)</span>
 {
 	unsigned int i, j;
 	int ret;
<span class="p_chunk">@@ -379,10 +379,10 @@</span> <span class="p_context"> static int mid_set_initial_state(struct mid_pwr *pwr)</span>
 	 * NOTE: The actual device mapping is provided by a platform at run
 	 * time using vendor capability of PCI configuration space.
 	 */
<span class="p_del">-	mid_pwr_set_state(pwr, 0, 0xffffffff);</span>
<span class="p_del">-	mid_pwr_set_state(pwr, 1, 0xffffffff);</span>
<span class="p_del">-	mid_pwr_set_state(pwr, 2, 0xffffffff);</span>
<span class="p_del">-	mid_pwr_set_state(pwr, 3, 0xffffffff);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 0, states[0]);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 1, states[1]);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 2, states[2]);</span>
<span class="p_add">+	mid_pwr_set_state(pwr, 3, states[3]);</span>
 
 	/* Send command to SCU */
 	ret = mid_pwr_wait_for_cmd(pwr, CMD_SET_CFG);
<span class="p_chunk">@@ -397,13 +397,41 @@</span> <span class="p_context"> static int mid_set_initial_state(struct mid_pwr *pwr)</span>
 	return 0;
 }
 
<span class="p_del">-static const struct mid_pwr_device_info mid_info = {</span>
<span class="p_del">-	.set_initial_state = mid_set_initial_state,</span>
<span class="p_add">+static int pnw_set_initial_state(struct mid_pwr *pwr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* On Penwell SRAM must stay powered on */</span>
<span class="p_add">+	const u32 states[] = {</span>
<span class="p_add">+		0xf00fffff,		/* PM_SSC(0) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(1) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(2) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(3) */</span>
<span class="p_add">+	};</span>
<span class="p_add">+	return mid_set_initial_state(pwr, states);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int tng_set_initial_state(struct mid_pwr *pwr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const u32 states[] = {</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(0) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(1) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(2) */</span>
<span class="p_add">+		0xffffffff,		/* PM_SSC(3) */</span>
<span class="p_add">+	};</span>
<span class="p_add">+	return mid_set_initial_state(pwr, states);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct mid_pwr_device_info pnw_info = {</span>
<span class="p_add">+	.set_initial_state = pnw_set_initial_state,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct mid_pwr_device_info tng_info = {</span>
<span class="p_add">+	.set_initial_state = tng_set_initial_state,</span>
 };
 
<span class="p_add">+/* This table should be in sync with the one in drivers/pci/pci-mid.c */</span>
 static const struct pci_device_id mid_pwr_pci_ids[] = {
<span class="p_del">-	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PENWELL), (kernel_ulong_t)&amp;mid_info },</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER), (kernel_ulong_t)&amp;mid_info },</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_PENWELL), (kernel_ulong_t)&amp;pnw_info },</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, PCI_DEVICE_ID_TANGIER), (kernel_ulong_t)&amp;tng_info },</span>
 	{}
 };
 
<span class="p_header">diff --git a/arch/x86/xen/smp.c b/arch/x86/xen/smp.c</span>
<span class="p_header">index 0b4d04c8ab4d..62284035be84 100644</span>
<span class="p_header">--- a/arch/x86/xen/smp.c</span>
<span class="p_header">+++ b/arch/x86/xen/smp.c</span>
<span class="p_chunk">@@ -87,6 +87,12 @@</span> <span class="p_context"> static void cpu_bringup(void)</span>
 	cpu_data(cpu).x86_max_cores = 1;
 	set_cpu_sibling_map(cpu);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * identify_cpu() may have set logical_pkg_id to -1 due</span>
<span class="p_add">+	 * to incorrect phys_proc_id. Let&#39;s re-comupte it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	topology_update_package_map(apic-&gt;cpu_present_to_apicid(cpu), cpu);</span>
<span class="p_add">+</span>
 	xen_setup_cpu_clockevents();
 
 	notify_cpu_starting(cpu);
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 811f9b97e360..d4d55f60cd81 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -251,6 +251,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0cf3, 0xe300), .driver_info = BTUSB_QCA_ROME },
 	{ USB_DEVICE(0x0cf3, 0xe360), .driver_info = BTUSB_QCA_ROME },
 	{ USB_DEVICE(0x0489, 0xe092), .driver_info = BTUSB_QCA_ROME },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x3011), .driver_info = BTUSB_QCA_ROME },</span>
 
 	/* Broadcom BCM2035 */
 	{ USB_DEVICE(0x0a5c, 0x2009), .driver_info = BTUSB_BCM92035 },
<span class="p_header">diff --git a/drivers/char/tpm/tpm-dev.c b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">index f5d452151c6b..912ad30be585 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> static ssize_t tpm_write(struct file *file, const char __user *buf,</span>
 		return -EPIPE;
 	}
 	out_size = tpm_transmit(priv-&gt;chip, priv-&gt;data_buffer,
<span class="p_del">-				sizeof(priv-&gt;data_buffer));</span>
<span class="p_add">+				sizeof(priv-&gt;data_buffer), 0);</span>
 
 	tpm_put_ops(priv-&gt;chip);
 	if (out_size &lt; 0) {
<span class="p_header">diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">index 1abe2d7a2610..aef20ee2331a 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_chunk">@@ -330,8 +330,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);</span>
 /*
  * Internal kernel interface to transmit TPM commands
  */
<span class="p_del">-ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
<span class="p_del">-		     size_t bufsiz)</span>
<span class="p_add">+ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,</span>
<span class="p_add">+		     unsigned int flags)</span>
 {
 	ssize_t rc;
 	u32 count, ordinal;
<span class="p_chunk">@@ -350,7 +350,8 @@</span> <span class="p_context"> ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
 		return -E2BIG;
 	}
 
<span class="p_del">-	mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	if (!(flags &amp; TPM_TRANSMIT_UNLOCKED))</span>
<span class="p_add">+		mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
 
 	rc = chip-&gt;ops-&gt;send(chip, (u8 *) buf, count);
 	if (rc &lt; 0) {
<span class="p_chunk">@@ -393,20 +394,21 @@</span> <span class="p_context"> out_recv:</span>
 		dev_err(&amp;chip-&gt;dev,
 			&quot;tpm_transmit: tpm_recv: error %zd\n&quot;, rc);
 out:
<span class="p_del">-	mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	if (!(flags &amp; TPM_TRANSMIT_UNLOCKED))</span>
<span class="p_add">+		mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
 	return rc;
 }
 
 #define TPM_DIGEST_SIZE 20
 #define TPM_RET_CODE_IDX 6
 
<span class="p_del">-ssize_t tpm_transmit_cmd(struct tpm_chip *chip, void *cmd,</span>
<span class="p_del">-			 int len, const char *desc)</span>
<span class="p_add">+ssize_t tpm_transmit_cmd(struct tpm_chip *chip, const void *cmd,</span>
<span class="p_add">+			 int len, unsigned int flags, const char *desc)</span>
 {
<span class="p_del">-	struct tpm_output_header *header;</span>
<span class="p_add">+	const struct tpm_output_header *header;</span>
 	int err;
 
<span class="p_del">-	len = tpm_transmit(chip, (u8 *) cmd, len);</span>
<span class="p_add">+	len = tpm_transmit(chip, (const u8 *)cmd, len, flags);</span>
 	if (len &lt;  0)
 		return len;
 	else if (len &lt; TPM_HEADER_SIZE)
<span class="p_chunk">@@ -453,7 +455,8 @@</span> <span class="p_context"> ssize_t tpm_getcap(struct tpm_chip *chip, __be32 subcap_id, cap_t *cap,</span>
 		tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 		tpm_cmd.params.getcap_in.subcap = subcap_id;
 	}
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, desc);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
<span class="p_add">+			      desc);</span>
 	if (!rc)
 		*cap = tpm_cmd.params.getcap_out.cap;
 	return rc;
<span class="p_chunk">@@ -469,7 +472,7 @@</span> <span class="p_context"> void tpm_gen_interrupt(struct tpm_chip *chip)</span>
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 			      &quot;attempting to determine the timeouts&quot;);
 }
 EXPORT_SYMBOL_GPL(tpm_gen_interrupt);
<span class="p_chunk">@@ -490,7 +493,7 @@</span> <span class="p_context"> static int tpm_startup(struct tpm_chip *chip, __be16 startup_type)</span>
 	start_cmd.header.in = tpm_startup_header;
 
 	start_cmd.params.startup_in.startup_type = startup_type;
<span class="p_del">-	return tpm_transmit_cmd(chip, &amp;start_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	return tpm_transmit_cmd(chip, &amp;start_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 				&quot;attempting to start the TPM&quot;);
 }
 
<span class="p_chunk">@@ -521,7 +524,8 @@</span> <span class="p_context"> int tpm_get_timeouts(struct tpm_chip *chip)</span>
 	tpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, NULL);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
<span class="p_add">+			      NULL);</span>
 
 	if (rc == TPM_ERR_INVALID_POSTINIT) {
 		/* The TPM is not started, we are the first to talk to it.
<span class="p_chunk">@@ -535,7 +539,7 @@</span> <span class="p_context"> int tpm_get_timeouts(struct tpm_chip *chip)</span>
 		tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 		tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
 		rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,
<span class="p_del">-				  NULL);</span>
<span class="p_add">+				      0, NULL);</span>
 	}
 	if (rc) {
 		dev_err(&amp;chip-&gt;dev,
<span class="p_chunk">@@ -596,7 +600,7 @@</span> <span class="p_context"> duration:</span>
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_DURATION;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 			      &quot;attempting to determine the durations&quot;);
 	if (rc)
 		return rc;
<span class="p_chunk">@@ -652,7 +656,7 @@</span> <span class="p_context"> static int tpm_continue_selftest(struct tpm_chip *chip)</span>
 	struct tpm_cmd_t cmd;
 
 	cmd.header.in = continue_selftest_header;
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, CONTINUE_SELFTEST_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, CONTINUE_SELFTEST_RESULT_SIZE, 0,</span>
 			      &quot;continue selftest&quot;);
 	return rc;
 }
<span class="p_chunk">@@ -672,7 +676,7 @@</span> <span class="p_context"> int tpm_pcr_read_dev(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)</span>
 
 	cmd.header.in = pcrread_header;
 	cmd.params.pcrread_in.pcr_idx = cpu_to_be32(pcr_idx);
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, READ_PCR_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, READ_PCR_RESULT_SIZE, 0,</span>
 			      &quot;attempting to read a pcr value&quot;);
 
 	if (rc == 0)
<span class="p_chunk">@@ -770,7 +774,7 @@</span> <span class="p_context"> int tpm_pcr_extend(u32 chip_num, int pcr_idx, const u8 *hash)</span>
 	cmd.header.in = pcrextend_header;
 	cmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);
 	memcpy(cmd.params.pcrextend_in.hash, hash, TPM_DIGEST_SIZE);
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE, 0,</span>
 			      &quot;attempting extend a PCR value&quot;);
 
 	tpm_put_ops(chip);
<span class="p_chunk">@@ -809,7 +813,7 @@</span> <span class="p_context"> int tpm_do_selftest(struct tpm_chip *chip)</span>
 		/* Attempt to read a PCR value */
 		cmd.header.in = pcrread_header;
 		cmd.params.pcrread_in.pcr_idx = cpu_to_be32(0);
<span class="p_del">-		rc = tpm_transmit(chip, (u8 *) &amp;cmd, READ_PCR_RESULT_SIZE);</span>
<span class="p_add">+		rc = tpm_transmit(chip, (u8 *) &amp;cmd, READ_PCR_RESULT_SIZE, 0);</span>
 		/* Some buggy TPMs will not respond to tpm_tis_ready() for
 		 * around 300ms while the self test is ongoing, keep trying
 		 * until the self test duration expires. */
<span class="p_chunk">@@ -879,7 +883,7 @@</span> <span class="p_context"> int tpm_send(u32 chip_num, void *cmd, size_t buflen)</span>
 	if (chip == NULL)
 		return -ENODEV;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, cmd, buflen, &quot;attempting tpm_cmd&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, cmd, buflen, 0, &quot;attempting tpm_cmd&quot;);</span>
 
 	tpm_put_ops(chip);
 	return rc;
<span class="p_chunk">@@ -981,14 +985,15 @@</span> <span class="p_context"> int tpm_pm_suspend(struct device *dev)</span>
 		cmd.params.pcrextend_in.pcr_idx = cpu_to_be32(tpm_suspend_pcr);
 		memcpy(cmd.params.pcrextend_in.hash, dummy_hash,
 		       TPM_DIGEST_SIZE);
<span class="p_del">-		rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE,</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE, 0,</span>
 				      &quot;extending dummy pcr before suspend&quot;);
 	}
 
 	/* now do the actual savestate */
 	for (try = 0; try &lt; TPM_RETRY; try++) {
 		cmd.header.in = savestate_header;
<span class="p_del">-		rc = tpm_transmit_cmd(chip, &amp;cmd, SAVESTATE_RESULT_SIZE, NULL);</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, SAVESTATE_RESULT_SIZE, 0,</span>
<span class="p_add">+				      NULL);</span>
 
 		/*
 		 * If the TPM indicates that it is too busy to respond to
<span class="p_chunk">@@ -1072,8 +1077,8 @@</span> <span class="p_context"> int tpm_get_random(u32 chip_num, u8 *out, size_t max)</span>
 		tpm_cmd.params.getrandom_in.num_bytes = cpu_to_be32(num_bytes);
 
 		err = tpm_transmit_cmd(chip, &amp;tpm_cmd,
<span class="p_del">-				   TPM_GETRANDOM_RESULT_SIZE + num_bytes,</span>
<span class="p_del">-				   &quot;attempting get random&quot;);</span>
<span class="p_add">+				       TPM_GETRANDOM_RESULT_SIZE + num_bytes,</span>
<span class="p_add">+				       0, &quot;attempting get random&quot;);</span>
 		if (err)
 			break;
 
<span class="p_header">diff --git a/drivers/char/tpm/tpm-sysfs.c b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">index b46cf70c8b16..e1f7236c115c 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static ssize_t pubek_show(struct device *dev, struct device_attribute *attr,</span>
 	struct tpm_chip *chip = to_tpm_chip(dev);
 
 	tpm_cmd.header.in = tpm_readpubek_header;
<span class="p_del">-	err = tpm_transmit_cmd(chip, &amp;tpm_cmd, READ_PUBEK_RESULT_SIZE,</span>
<span class="p_add">+	err = tpm_transmit_cmd(chip, &amp;tpm_cmd, READ_PUBEK_RESULT_SIZE, 0,</span>
 			       &quot;attempting to read the PUBEK&quot;);
 	if (err)
 		goto out;
<span class="p_header">diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h</span>
<span class="p_header">index 3e32d5bd2dc6..b0585e99da49 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm.h</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm.h</span>
<span class="p_chunk">@@ -476,12 +476,16 @@</span> <span class="p_context"> extern dev_t tpm_devt;</span>
 extern const struct file_operations tpm_fops;
 extern struct idr dev_nums_idr;
 
<span class="p_add">+enum tpm_transmit_flags {</span>
<span class="p_add">+	TPM_TRANSMIT_UNLOCKED	= BIT(0),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,</span>
<span class="p_add">+		     unsigned int flags);</span>
<span class="p_add">+ssize_t tpm_transmit_cmd(struct tpm_chip *chip, const void *cmd, int len,</span>
<span class="p_add">+			 unsigned int flags, const char *desc);</span>
 ssize_t tpm_getcap(struct tpm_chip *chip, __be32 subcap_id, cap_t *cap,
 		   const char *desc);
<span class="p_del">-ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
<span class="p_del">-		     size_t bufsiz);</span>
<span class="p_del">-ssize_t tpm_transmit_cmd(struct tpm_chip *chip, void *cmd, int len,</span>
<span class="p_del">-			 const char *desc);</span>
 extern int tpm_get_timeouts(struct tpm_chip *);
 extern void tpm_gen_interrupt(struct tpm_chip *);
 int tpm1_auto_startup(struct tpm_chip *chip);
<span class="p_header">diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">index 0c75c3f1689f..ef5a58b986f6 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> int tpm2_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)</span>
 	       sizeof(cmd.params.pcrread_in.pcr_select));
 	cmd.params.pcrread_in.pcr_select[pcr_idx &gt;&gt; 3] = 1 &lt;&lt; (pcr_idx &amp; 0x7);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 			      &quot;attempting to read a pcr value&quot;);
 	if (rc == 0) {
 		buf = cmd.params.pcrread_out.digest;
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> int tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, const u8 *hash)</span>
 	cmd.params.pcrextend_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);
 	memcpy(cmd.params.pcrextend_in.digest, hash, TPM_DIGEST_SIZE);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 			      &quot;attempting extend a PCR value&quot;);
 
 	return rc;
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> int tpm2_get_random(struct tpm_chip *chip, u8 *out, size_t max)</span>
 		cmd.header.in = tpm2_getrandom_header;
 		cmd.params.getrandom_in.size = cpu_to_be16(num_bytes);
 
<span class="p_del">-		err = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+		err = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 				       &quot;attempting get random&quot;);
 		if (err)
 			break;
<span class="p_chunk">@@ -434,12 +434,12 @@</span> <span class="p_context"> static void tpm2_buf_append_auth(struct tpm_buf *buf, u32 session_handle,</span>
 }
 
 /**
<span class="p_del">- * tpm2_seal_trusted() - seal a trusted key</span>
<span class="p_del">- * @chip_num: A specific chip number for the request or TPM_ANY_NUM</span>
<span class="p_del">- * @options: authentication values and other options</span>
<span class="p_add">+ * tpm2_seal_trusted() - seal the payload of a trusted key</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
  * @payload: the key data in clear and encrypted form
<span class="p_add">+ * @options: authentication values and other options</span>
  *
<span class="p_del">- * Returns &lt; 0 on error and 0 on success.</span>
<span class="p_add">+ * Return: &lt; 0 on error and 0 on success.</span>
  */
 int tpm2_seal_trusted(struct tpm_chip *chip,
 		      struct trusted_key_payload *payload,
<span class="p_chunk">@@ -512,7 +512,7 @@</span> <span class="p_context"> int tpm2_seal_trusted(struct tpm_chip *chip,</span>
 		goto out;
 	}
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;sealing data&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, 0, &quot;sealing data&quot;);</span>
 	if (rc)
 		goto out;
 
<span class="p_chunk">@@ -538,10 +538,18 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_del">-static int tpm2_load(struct tpm_chip *chip,</span>
<span class="p_del">-		     struct trusted_key_payload *payload,</span>
<span class="p_del">-		     struct trusted_key_options *options,</span>
<span class="p_del">-		     u32 *blob_handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_load_cmd() - execute a TPM2_Load command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int tpm2_load_cmd(struct tpm_chip *chip,</span>
<span class="p_add">+			 struct trusted_key_payload *payload,</span>
<span class="p_add">+			 struct trusted_key_options *options,</span>
<span class="p_add">+			 u32 *blob_handle, unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	unsigned int private_len;
<span class="p_chunk">@@ -576,7 +584,7 @@</span> <span class="p_context"> static int tpm2_load(struct tpm_chip *chip,</span>
 		goto out;
 	}
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;loading blob&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags, &quot;loading blob&quot;);</span>
 	if (!rc)
 		*blob_handle = be32_to_cpup(
 			(__be32 *) &amp;buf.data[TPM_HEADER_SIZE]);
<span class="p_chunk">@@ -590,7 +598,16 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_del">-static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_flush_context_cmd() - execute a TPM2_FlushContext command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void tpm2_flush_context_cmd(struct tpm_chip *chip, u32 handle,</span>
<span class="p_add">+				   unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	int rc;
<span class="p_chunk">@@ -604,7 +621,8 @@</span> <span class="p_context"> static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
 
 	tpm_buf_append_u32(&amp;buf, handle);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;flushing context&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags,</span>
<span class="p_add">+			      &quot;flushing context&quot;);</span>
 	if (rc)
 		dev_warn(&amp;chip-&gt;dev, &quot;0x%08x was not flushed, rc=%d\n&quot;, handle,
 			 rc);
<span class="p_chunk">@@ -612,10 +630,18 @@</span> <span class="p_context"> static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
 	tpm_buf_destroy(&amp;buf);
 }
 
<span class="p_del">-static int tpm2_unseal(struct tpm_chip *chip,</span>
<span class="p_del">-		       struct trusted_key_payload *payload,</span>
<span class="p_del">-		       struct trusted_key_options *options,</span>
<span class="p_del">-		       u32 blob_handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_unseal_cmd() - execute a TPM2_Unload command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int tpm2_unseal_cmd(struct tpm_chip *chip,</span>
<span class="p_add">+			   struct trusted_key_payload *payload,</span>
<span class="p_add">+			   struct trusted_key_options *options,</span>
<span class="p_add">+			   u32 blob_handle, unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	u16 data_len;
<span class="p_chunk">@@ -635,7 +661,7 @@</span> <span class="p_context"> static int tpm2_unseal(struct tpm_chip *chip,</span>
 			     options-&gt;blobauth /* hmac */,
 			     TPM_DIGEST_SIZE);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;unsealing&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags, &quot;unsealing&quot;);</span>
 	if (rc &gt; 0)
 		rc = -EPERM;
 
<span class="p_chunk">@@ -654,12 +680,12 @@</span> <span class="p_context"> static int tpm2_unseal(struct tpm_chip *chip,</span>
 }
 
 /**
<span class="p_del">- * tpm_unseal_trusted() - unseal a trusted key</span>
<span class="p_del">- * @chip_num: A specific chip number for the request or TPM_ANY_NUM</span>
<span class="p_del">- * @options: authentication values and other options</span>
<span class="p_add">+ * tpm_unseal_trusted() - unseal the payload of a trusted key</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
  * @payload: the key data in clear and encrypted form
<span class="p_add">+ * @options: authentication values and other options</span>
  *
<span class="p_del">- * Returns &lt; 0 on error and 0 on success.</span>
<span class="p_add">+ * Return: &lt; 0 on error and 0 on success.</span>
  */
 int tpm2_unseal_trusted(struct tpm_chip *chip,
 			struct trusted_key_payload *payload,
<span class="p_chunk">@@ -668,14 +694,17 @@</span> <span class="p_context"> int tpm2_unseal_trusted(struct tpm_chip *chip,</span>
 	u32 blob_handle;
 	int rc;
 
<span class="p_del">-	rc = tpm2_load(chip, payload, options, &amp;blob_handle);</span>
<span class="p_add">+	mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	rc = tpm2_load_cmd(chip, payload, options, &amp;blob_handle,</span>
<span class="p_add">+			   TPM_TRANSMIT_UNLOCKED);</span>
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = tpm2_unseal(chip, payload, options, blob_handle);</span>
<span class="p_del">-</span>
<span class="p_del">-	tpm2_flush_context(chip, blob_handle);</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_add">+	rc = tpm2_unseal_cmd(chip, payload, options, blob_handle,</span>
<span class="p_add">+			     TPM_TRANSMIT_UNLOCKED);</span>
<span class="p_add">+	tpm2_flush_context_cmd(chip, blob_handle, TPM_TRANSMIT_UNLOCKED);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -701,7 +730,7 @@</span> <span class="p_context"> ssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,  u32 *value,</span>
 	cmd.params.get_tpm_pt_in.property_id = cpu_to_be32(property_id);
 	cmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), desc);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, desc);</span>
 	if (!rc)
 		*value = be32_to_cpu(cmd.params.get_tpm_pt_out.value);
 
<span class="p_chunk">@@ -735,7 +764,7 @@</span> <span class="p_context"> static int tpm2_startup(struct tpm_chip *chip, u16 startup_type)</span>
 	cmd.header.in = tpm2_startup_header;
 
 	cmd.params.startup_in.startup_type = cpu_to_be16(startup_type);
<span class="p_del">-	return tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	return tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 				&quot;attempting to start the TPM&quot;);
 }
 
<span class="p_chunk">@@ -763,7 +792,7 @@</span> <span class="p_context"> void tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type)</span>
 	cmd.header.in = tpm2_shutdown_header;
 	cmd.params.startup_in.startup_type = cpu_to_be16(shutdown_type);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), &quot;stopping the TPM&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, &quot;stopping the TPM&quot;);</span>
 
 	/* In places where shutdown command is sent there&#39;s no much we can do
 	 * except print the error code on a system failure.
<span class="p_chunk">@@ -828,7 +857,7 @@</span> <span class="p_context"> static int tpm2_start_selftest(struct tpm_chip *chip, bool full)</span>
 	cmd.header.in = tpm2_selftest_header;
 	cmd.params.selftest_in.full_test = full;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, TPM2_SELF_TEST_IN_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, TPM2_SELF_TEST_IN_SIZE, 0,</span>
 			      &quot;continue selftest&quot;);
 
 	/* At least some prototype chips seem to give RC_TESTING error
<span class="p_chunk">@@ -880,7 +909,7 @@</span> <span class="p_context"> static int tpm2_do_selftest(struct tpm_chip *chip)</span>
 		cmd.params.pcrread_in.pcr_select[1] = 0x00;
 		cmd.params.pcrread_in.pcr_select[2] = 0x00;
 
<span class="p_del">-		rc = tpm_transmit_cmd(chip, (u8 *) &amp;cmd, sizeof(cmd), NULL);</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, NULL);</span>
 		if (rc &lt; 0)
 			break;
 
<span class="p_chunk">@@ -928,7 +957,7 @@</span> <span class="p_context"> int tpm2_probe(struct tpm_chip *chip)</span>
 	cmd.params.get_tpm_pt_in.property_id = cpu_to_be32(0x100);
 	cmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);
 
<span class="p_del">-	rc = tpm_transmit(chip, (const char *) &amp;cmd, sizeof(cmd));</span>
<span class="p_add">+	rc = tpm_transmit(chip, (const u8 *)&amp;cmd, sizeof(cmd), 0);</span>
 	if (rc &lt;  0)
 		return rc;
 	else if (rc &lt; TPM_HEADER_SIZE)
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index 018c382554ba..1801f382377e 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -142,6 +142,11 @@</span> <span class="p_context"> static int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)</span>
 	struct crb_priv *priv = dev_get_drvdata(&amp;chip-&gt;dev);
 	int rc = 0;
 
<span class="p_add">+	/* Zero the cancel register so that the next command will not get</span>
<span class="p_add">+	 * canceled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	iowrite32(0, &amp;priv-&gt;cca-&gt;cancel);</span>
<span class="p_add">+</span>
 	if (len &gt; ioread32(&amp;priv-&gt;cca-&gt;cmd_size)) {
 		dev_err(&amp;chip-&gt;dev,
 			&quot;invalid command count value %x %zx\n&quot;,
<span class="p_chunk">@@ -175,8 +180,6 @@</span> <span class="p_context"> static void crb_cancel(struct tpm_chip *chip)</span>
 
 	if ((priv-&gt;flags &amp; CRB_FL_ACPI_START) &amp;&amp; crb_do_acpi_start(chip))
 		dev_err(&amp;chip-&gt;dev, &quot;ACPI Start failed\n&quot;);
<span class="p_del">-</span>
<span class="p_del">-	iowrite32(0, &amp;priv-&gt;cca-&gt;cancel);</span>
 }
 
 static bool crb_req_canceled(struct tpm_chip *chip, u8 status)
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle-arm.c b/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_header">index 4ba3d3fe142f..f440d385ed34 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_chunk">@@ -121,6 +121,7 @@</span> <span class="p_context"> static int __init arm_idle_init(void)</span>
 		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 		if (!dev) {
 			pr_err(&quot;Failed to allocate cpuidle device\n&quot;);
<span class="p_add">+			ret = -ENOMEM;</span>
 			goto out_fail;
 		}
 		dev-&gt;cpu = cpu;
<span class="p_header">diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig</span>
<span class="p_header">index 2d1fb6420592..580f4f280d6b 100644</span>
<span class="p_header">--- a/drivers/mfd/Kconfig</span>
<span class="p_header">+++ b/drivers/mfd/Kconfig</span>
<span class="p_chunk">@@ -1549,6 +1549,7 @@</span> <span class="p_context"> config MFD_WM8350</span>
 config MFD_WM8350_I2C
 	bool &quot;Wolfson Microelectronics WM8350 with I2C&quot;
 	select MFD_WM8350
<span class="p_add">+	select REGMAP_I2C</span>
 	depends on I2C=y
 	help
 	  The WM8350 is an integrated audio and power management
<span class="p_header">diff --git a/drivers/mfd/atmel-hlcdc.c b/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_header">index eca7ea69b81c..4b15b0840f16 100644</span>
<span class="p_header">--- a/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_header">+++ b/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_chunk">@@ -50,8 +50,9 @@</span> <span class="p_context"> static int regmap_atmel_hlcdc_reg_write(void *context, unsigned int reg,</span>
 	if (reg &lt;= ATMEL_HLCDC_DIS) {
 		u32 status;
 
<span class="p_del">-		readl_poll_timeout(hregmap-&gt;regs + ATMEL_HLCDC_SR, status,</span>
<span class="p_del">-				   !(status &amp; ATMEL_HLCDC_SIP), 1, 100);</span>
<span class="p_add">+		readl_poll_timeout_atomic(hregmap-&gt;regs + ATMEL_HLCDC_SR,</span>
<span class="p_add">+					  status, !(status &amp; ATMEL_HLCDC_SIP),</span>
<span class="p_add">+					  1, 100);</span>
 	}
 
 	writel(val, hregmap-&gt;regs + reg);
<span class="p_header">diff --git a/drivers/mfd/rtsx_usb.c b/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">index dbd907d7170e..691dab791f7a 100644</span>
<span class="p_header">--- a/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">+++ b/drivers/mfd/rtsx_usb.c</span>
<span class="p_chunk">@@ -46,9 +46,6 @@</span> <span class="p_context"> static void rtsx_usb_sg_timed_out(unsigned long data)</span>
 
 	dev_dbg(&amp;ucr-&gt;pusb_intf-&gt;dev, &quot;%s: sg transfer timed out&quot;, __func__);
 	usb_sg_cancel(&amp;ucr-&gt;current_sg);
<span class="p_del">-</span>
<span class="p_del">-	/* we know the cancellation is caused by time-out */</span>
<span class="p_del">-	ucr-&gt;current_sg.status = -ETIMEDOUT;</span>
 }
 
 static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,
<span class="p_chunk">@@ -67,12 +64,15 @@</span> <span class="p_context"> static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,</span>
 	ucr-&gt;sg_timer.expires = jiffies + msecs_to_jiffies(timeout);
 	add_timer(&amp;ucr-&gt;sg_timer);
 	usb_sg_wait(&amp;ucr-&gt;current_sg);
<span class="p_del">-	del_timer_sync(&amp;ucr-&gt;sg_timer);</span>
<span class="p_add">+	if (!del_timer_sync(&amp;ucr-&gt;sg_timer))</span>
<span class="p_add">+		ret = -ETIMEDOUT;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = ucr-&gt;current_sg.status;</span>
 
 	if (act_len)
 		*act_len = ucr-&gt;current_sg.bytes;
 
<span class="p_del">-	return ucr-&gt;current_sg.status;</span>
<span class="p_add">+	return ret;</span>
 }
 
 int rtsx_usb_transfer_data(struct rtsx_ucr *ucr, unsigned int pipe,
<span class="p_header">diff --git a/drivers/pci/pci-mid.c b/drivers/pci/pci-mid.c</span>
<span class="p_header">index c878aa71173b..55f453de562e 100644</span>
<span class="p_header">--- a/drivers/pci/pci-mid.c</span>
<span class="p_header">+++ b/drivers/pci/pci-mid.c</span>
<span class="p_chunk">@@ -60,8 +60,13 @@</span> <span class="p_context"> static struct pci_platform_pm_ops mid_pci_platform_pm = {</span>
 
 #define ICPU(model)	{ X86_VENDOR_INTEL, 6, model, X86_FEATURE_ANY, }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This table should be in sync with the one in</span>
<span class="p_add">+ * arch/x86/platform/intel-mid/pwr.c.</span>
<span class="p_add">+ */</span>
 static const struct x86_cpu_id lpss_cpu_ids[] = {
<span class="p_del">-	ICPU(INTEL_FAM6_ATOM_MERRIFIELD1),</span>
<span class="p_add">+	ICPU(INTEL_FAM6_ATOM_PENWELL),</span>
<span class="p_add">+	ICPU(INTEL_FAM6_ATOM_MERRIFIELD),</span>
 	{}
 };
 
<span class="p_header">diff --git a/drivers/phy/phy-sun4i-usb.c b/drivers/phy/phy-sun4i-usb.c</span>
<span class="p_header">index 8c7eb335622e..4d74ca9186c7 100644</span>
<span class="p_header">--- a/drivers/phy/phy-sun4i-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-sun4i-usb.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/power_supply.h&gt;
 #include &lt;linux/regulator/consumer.h&gt;
 #include &lt;linux/reset.h&gt;
<span class="p_add">+#include &lt;linux/spinlock.h&gt;</span>
 #include &lt;linux/usb/of.h&gt;
 #include &lt;linux/workqueue.h&gt;
 
<span class="p_chunk">@@ -112,7 +113,7 @@</span> <span class="p_context"> struct sun4i_usb_phy_data {</span>
 	void __iomem *base;
 	const struct sun4i_usb_phy_cfg *cfg;
 	enum usb_dr_mode dr_mode;
<span class="p_del">-	struct mutex mutex;</span>
<span class="p_add">+	spinlock_t reg_lock; /* guard access to phyctl reg */</span>
 	struct sun4i_usb_phy {
 		struct phy *phy;
 		void __iomem *pmu;
<span class="p_chunk">@@ -179,9 +180,10 @@</span> <span class="p_context"> static void sun4i_usb_phy_write(struct sun4i_usb_phy *phy, u32 addr, u32 data,</span>
 	struct sun4i_usb_phy_data *phy_data = to_sun4i_usb_phy_data(phy);
 	u32 temp, usbc_bit = BIT(phy-&gt;index * 2);
 	void __iomem *phyctl = phy_data-&gt;base + phy_data-&gt;cfg-&gt;phyctl_offset;
<span class="p_add">+	unsigned long flags;</span>
 	int i;
 
<span class="p_del">-	mutex_lock(&amp;phy_data-&gt;mutex);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;phy_data-&gt;reg_lock, flags);</span>
 
 	if (phy_data-&gt;cfg-&gt;type == sun8i_a33_phy) {
 		/* A33 needs us to set phyctl to 0 explicitly */
<span class="p_chunk">@@ -218,7 +220,8 @@</span> <span class="p_context"> static void sun4i_usb_phy_write(struct sun4i_usb_phy *phy, u32 addr, u32 data,</span>
 
 		data &gt;&gt;= 1;
 	}
<span class="p_del">-	mutex_unlock(&amp;phy_data-&gt;mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;phy_data-&gt;reg_lock, flags);</span>
 }
 
 static void sun4i_usb_phy_passby(struct sun4i_usb_phy *phy, int enable)
<span class="p_chunk">@@ -577,7 +580,7 @@</span> <span class="p_context"> static int sun4i_usb_phy_probe(struct platform_device *pdev)</span>
 	if (!data)
 		return -ENOMEM;
 
<span class="p_del">-	mutex_init(&amp;data-&gt;mutex);</span>
<span class="p_add">+	spin_lock_init(&amp;data-&gt;reg_lock);</span>
 	INIT_DELAYED_WORK(&amp;data-&gt;detect, sun4i_usb_phy0_id_vbus_det_scan);
 	dev_set_drvdata(dev, data);
 	data-&gt;cfg = of_device_get_match_data(dev);
<span class="p_header">diff --git a/drivers/powercap/intel_rapl.c b/drivers/powercap/intel_rapl.c</span>
<span class="p_header">index fbab29dfa793..243b233ff31b 100644</span>
<span class="p_header">--- a/drivers/powercap/intel_rapl.c</span>
<span class="p_header">+++ b/drivers/powercap/intel_rapl.c</span>
<span class="p_chunk">@@ -1154,8 +1154,8 @@</span> <span class="p_context"> static const struct x86_cpu_id rapl_ids[] __initconst = {</span>
 
 	RAPL_CPU(INTEL_FAM6_ATOM_SILVERMONT1,	rapl_defaults_byt),
 	RAPL_CPU(INTEL_FAM6_ATOM_AIRMONT,	rapl_defaults_cht),
<span class="p_del">-	RAPL_CPU(INTEL_FAM6_ATOM_MERRIFIELD1,	rapl_defaults_tng),</span>
<span class="p_del">-	RAPL_CPU(INTEL_FAM6_ATOM_MERRIFIELD2,	rapl_defaults_ann),</span>
<span class="p_add">+	RAPL_CPU(INTEL_FAM6_ATOM_MERRIFIELD,	rapl_defaults_tng),</span>
<span class="p_add">+	RAPL_CPU(INTEL_FAM6_ATOM_MOOREFIELD,	rapl_defaults_ann),</span>
 	RAPL_CPU(INTEL_FAM6_ATOM_GOLDMONT,	rapl_defaults_core),
 	RAPL_CPU(INTEL_FAM6_ATOM_DENVERTON,	rapl_defaults_core),
 
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 122e64df2f4d..68544618982e 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -348,7 +348,8 @@</span> <span class="p_context"> static int dwc3_send_clear_stall_ep_cmd(struct dwc3_ep *dep)</span>
 	 * IN transfers due to a mishandled error condition. Synopsys
 	 * STAR 9000614252.
 	 */
<span class="p_del">-	if (dep-&gt;direction &amp;&amp; (dwc-&gt;revision &gt;= DWC3_REVISION_260A))</span>
<span class="p_add">+	if (dep-&gt;direction &amp;&amp; (dwc-&gt;revision &gt;= DWC3_REVISION_260A) &amp;&amp;</span>
<span class="p_add">+	    (dwc-&gt;gadget.speed &gt;= USB_SPEED_SUPER))</span>
 		cmd |= DWC3_DEPCMD_CLEARPENDIN;
 
 	memset(&amp;params, 0, sizeof(params));
<span class="p_header">diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c</span>
<span class="p_header">index ef2d8cde6ef7..8c5f0115166a 100644</span>
<span class="p_header">--- a/drivers/usb/storage/usb.c</span>
<span class="p_header">+++ b/drivers/usb/storage/usb.c</span>
<span class="p_chunk">@@ -1070,17 +1070,17 @@</span> <span class="p_context"> int usb_stor_probe2(struct us_data *us)</span>
 	result = usb_stor_acquire_resources(us);
 	if (result)
 		goto BadDevice;
<span class="p_add">+	usb_autopm_get_interface_no_resume(us-&gt;pusb_intf);</span>
 	snprintf(us-&gt;scsi_name, sizeof(us-&gt;scsi_name), &quot;usb-storage %s&quot;,
 					dev_name(&amp;us-&gt;pusb_intf-&gt;dev));
 	result = scsi_add_host(us_to_host(us), dev);
 	if (result) {
 		dev_warn(dev,
 				&quot;Unable to add the scsi host\n&quot;);
<span class="p_del">-		goto BadDevice;</span>
<span class="p_add">+		goto HostAddErr;</span>
 	}
 
 	/* Submit the delayed_work for SCSI-device scanning */
<span class="p_del">-	usb_autopm_get_interface_no_resume(us-&gt;pusb_intf);</span>
 	set_bit(US_FLIDX_SCAN_PENDING, &amp;us-&gt;dflags);
 
 	if (delay_use &gt; 0)
<span class="p_chunk">@@ -1090,6 +1090,8 @@</span> <span class="p_context"> int usb_stor_probe2(struct us_data *us)</span>
 	return 0;
 
 	/* We come here if there are any problems */
<span class="p_add">+HostAddErr:</span>
<span class="p_add">+	usb_autopm_put_interface_no_suspend(us-&gt;pusb_intf);</span>
 BadDevice:
 	usb_stor_dbg(us, &quot;storage_probe() failed\n&quot;);
 	release_everything(us);
<span class="p_header">diff --git a/include/linux/mfd/88pm80x.h b/include/linux/mfd/88pm80x.h</span>
<span class="p_header">index d409ceb2231e..c118a7ec94d6 100644</span>
<span class="p_header">--- a/include/linux/mfd/88pm80x.h</span>
<span class="p_header">+++ b/include/linux/mfd/88pm80x.h</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> static inline int pm80x_dev_suspend(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		set_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		set_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -362,7 +362,7 @@</span> <span class="p_context"> static inline int pm80x_dev_resume(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		clear_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		clear_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c</span>
<span class="p_header">index e07fb093f819..37dec7e3db43 100644</span>
<span class="p_header">--- a/kernel/time/timekeeping.c</span>
<span class="p_header">+++ b/kernel/time/timekeeping.c</span>
<span class="p_chunk">@@ -403,8 +403,11 @@</span> <span class="p_context"> static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)</span>
 		tkr = tkf-&gt;base + (seq &amp; 0x01);
 		now = ktime_to_ns(tkr-&gt;base);
 
<span class="p_del">-		now += clocksource_delta(tkr-&gt;read(tkr-&gt;clock),</span>
<span class="p_del">-					 tkr-&gt;cycle_last, tkr-&gt;mask);</span>
<span class="p_add">+		now += timekeeping_delta_to_ns(tkr,</span>
<span class="p_add">+				clocksource_delta(</span>
<span class="p_add">+					tkr-&gt;read(tkr-&gt;clock),</span>
<span class="p_add">+					tkr-&gt;cycle_last,</span>
<span class="p_add">+					tkr-&gt;mask));</span>
 	} while (read_seqcount_retry(&amp;tkf-&gt;seq, seq));
 
 	return now;
<span class="p_header">diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">index 4b9b4a4e1b89..ef1e4e701780 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_appraise.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> int ima_appraise_measurement(enum ima_hooks func,</span>
 {
 	static const char op[] = &quot;appraise_data&quot;;
 	char *cause = &quot;unknown&quot;;
<span class="p_del">-	struct dentry *dentry = file-&gt;f_path.dentry;</span>
<span class="p_add">+	struct dentry *dentry = file_dentry(file);</span>
 	struct inode *inode = d_backing_inode(dentry);
 	enum integrity_status status = INTEGRITY_UNKNOWN;
 	int rc = xattr_len, hash_start = 0;
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> out:</span>
  */
 void ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)
 {
<span class="p_del">-	struct dentry *dentry = file-&gt;f_path.dentry;</span>
<span class="p_add">+	struct dentry *dentry = file_dentry(file);</span>
 	int rc = 0;
 
 	/* do not collect and update hash for digital signatures */
<span class="p_header">diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c</span>
<span class="p_header">index 596ef616ac21..423d111b3b94 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_main.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_main.c</span>
<span class="p_chunk">@@ -228,7 +228,7 @@</span> <span class="p_context"> static int process_measurement(struct file *file, char *buf, loff_t size,</span>
 	if ((action &amp; IMA_APPRAISE_SUBMASK) ||
 		    strcmp(template_desc-&gt;name, IMA_TEMPLATE_IMA_NAME) != 0)
 		/* read &#39;security.ima&#39; */
<span class="p_del">-		xattr_len = ima_read_xattr(file-&gt;f_path.dentry, &amp;xattr_value);</span>
<span class="p_add">+		xattr_len = ima_read_xattr(file_dentry(file), &amp;xattr_value);</span>
 
 	hash_algo = ima_get_hash_algo(xattr_value, xattr_len);
 
<span class="p_header">diff --git a/sound/pci/ali5451/ali5451.c b/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">index 36470af7eda7..92b819e4f729 100644</span>
<span class="p_header">--- a/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">+++ b/sound/pci/ali5451/ali5451.c</span>
<span class="p_chunk">@@ -1408,6 +1408,7 @@</span> <span class="p_context"> snd_ali_playback_pointer(struct snd_pcm_substream *substream)</span>
 	spin_unlock(&amp;codec-&gt;reg_lock);
 	dev_dbg(codec-&gt;card-&gt;dev, &quot;playback pointer returned cso=%xh.\n&quot;, cso);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_chunk">@@ -1428,6 +1429,7 @@</span> <span class="p_context"> static snd_pcm_uframes_t snd_ali_pointer(struct snd_pcm_substream *substream)</span>
 	cso = inw(ALI_REG(codec, ALI_CSO_ALPHA_FMS + 2));
 	spin_unlock(&amp;codec-&gt;reg_lock);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_header">diff --git a/sound/usb/line6/driver.c b/sound/usb/line6/driver.c</span>
<span class="p_header">index 81b7da8e56d3..183311cb849e 100644</span>
<span class="p_header">--- a/sound/usb/line6/driver.c</span>
<span class="p_header">+++ b/sound/usb/line6/driver.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 /*
 	This is Line 6&#39;s MIDI manufacturer ID.
 */
<span class="p_del">-const unsigned char line6_midi_id[] = {</span>
<span class="p_add">+const unsigned char line6_midi_id[3] = {</span>
 	0x00, 0x01, 0x0c
 };
 EXPORT_SYMBOL_GPL(line6_midi_id);
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index f6c3bf79af9a..04991b009132 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -1831,6 +1831,7 @@</span> <span class="p_context"> void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,</span>
 }
 
 static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,
<span class="p_add">+					 struct usb_mixer_elem_info *cval,</span>
 					 struct snd_kcontrol *kctl)
 {
 	/* Approximation using 10 ranges based on output measurement on hw v1.2.
<span class="p_chunk">@@ -1848,10 +1849,19 @@</span> <span class="p_context"> static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,</span>
 		41, 50, TLV_DB_MINMAX_ITEM(-441, 0),
 	);
 
<span class="p_del">-	usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk\n&quot;);</span>
<span class="p_del">-	kctl-&gt;tlv.p = scale;</span>
<span class="p_del">-	kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_del">-	kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50) {</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk (0-50 variant)\n&quot;);</span>
<span class="p_add">+		kctl-&gt;tlv.p = scale;</span>
<span class="p_add">+		kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max &lt;= 1000) {</span>
<span class="p_add">+		/* Some other clearly broken DragonFly variant.</span>
<span class="p_add">+		 * At least a 0..53 variant (hw v1.0) exists.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;ignoring too narrow dB range on a DragonFly device&quot;);</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	}</span>
 }
 
 void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,
<span class="p_chunk">@@ -1860,8 +1870,8 @@</span> <span class="p_context"> void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
 {
 	switch (mixer-&gt;chip-&gt;usb_id) {
 	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */
<span class="p_del">-		if (unitid == 7 &amp;&amp; cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50)</span>
<span class="p_del">-			snd_dragonfly_quirk_db_scale(mixer, kctl);</span>
<span class="p_add">+		if (unitid == 7 &amp;&amp; cval-&gt;control == UAC_FU_VOLUME)</span>
<span class="p_add">+			snd_dragonfly_quirk_db_scale(mixer, cval, kctl);</span>
 		break;
 	}
 }
<span class="p_header">diff --git a/virt/kvm/arm/pmu.c b/virt/kvm/arm/pmu.c</span>
<span class="p_header">index a027569facfa..6e9c40eea208 100644</span>
<span class="p_header">--- a/virt/kvm/arm/pmu.c</span>
<span class="p_header">+++ b/virt/kvm/arm/pmu.c</span>
<span class="p_chunk">@@ -423,6 +423,14 @@</span> <span class="p_context"> static int kvm_arm_pmu_v3_init(struct kvm_vcpu *vcpu)</span>
 	if (!kvm_arm_support_pmu_v3())
 		return -ENODEV;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We currently require an in-kernel VGIC to use the PMU emulation,</span>
<span class="p_add">+	 * because we do not support forwarding PMU overflow interrupts to</span>
<span class="p_add">+	 * userspace yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!irqchip_in_kernel(vcpu-&gt;kvm) || !vgic_initialized(vcpu-&gt;kvm))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	if (!test_bit(KVM_ARM_VCPU_PMU_V3, vcpu-&gt;arch.features) ||
 	    !kvm_arm_pmu_irq_initialized(vcpu))
 		return -ENXIO;
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic.c b/virt/kvm/arm/vgic/vgic.c</span>
<span class="p_header">index e83b7fe4baae..b465ac6d5d48 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic.c</span>
<span class="p_chunk">@@ -645,6 +645,9 @@</span> <span class="p_context"> next:</span>
 /* Sync back the hardware VGIC state into our emulation after a guest&#39;s run. */
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	if (unlikely(!vgic_initialized(vcpu-&gt;kvm)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	vgic_process_maintenance_interrupt(vcpu);
 	vgic_fold_lr_state(vcpu);
 	vgic_prune_ap_list(vcpu);
<span class="p_chunk">@@ -653,6 +656,9 @@</span> <span class="p_context"> void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu)</span>
 /* Flush our emulation state into the GIC hardware before entering the guest. */
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	if (unlikely(!vgic_initialized(vcpu-&gt;kvm)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;vcpu-&gt;arch.vgic_cpu.ap_list_lock);
 	vgic_flush_lr_state(vcpu);
 	spin_unlock(&amp;vcpu-&gt;arch.vgic_cpu.ap_list_lock);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



