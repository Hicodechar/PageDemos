
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v5,29/32] x86/mm: Add support to encrypt the kernel in-place - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v5,29/32] x86/mm: Add support to encrypt the kernel in-place</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 18, 2017, 9:21 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170418212149.10190.70894.stgit@tlendack-t1.amdoffice.net&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9686405/mbox/"
   >mbox</a>
|
   <a href="/patch/9686405/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9686405/">/patch/9686405/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	448B4602C2 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Apr 2017 21:22:23 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 32B5B2094F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Apr 2017 21:22:23 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 26E57252D5; Tue, 18 Apr 2017 21:22:23 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1A90F2094F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 18 Apr 2017 21:22:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1758129AbdDRVWR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 18 Apr 2017 17:22:17 -0400
Received: from mail-bl2nam02on0087.outbound.protection.outlook.com
	([104.47.38.87]:54736
	&quot;EHLO NAM02-BL2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1757967AbdDRVWG (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 18 Apr 2017 17:22:06 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=amdcloud.onmicrosoft.com; s=selector1-amd-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=adsn/SLy0FIKVpPgHHkF+K3Mlh90UIM+h0Cf/9cjJxQ=;
	b=DesB9flW6lEynhOJnwXR/tArnbzeWhFwzSgYeV+KrtQDhpj5GN1bwvOt95PBMuBvTifnLuTvJK36IEyN0MLENUtBZqBFz/qzI2au2pw3veuCBCNweR5Y4xC+WlSUXLdb0x0fTL/p6Kqw1xc7FFqhtan7PYftCa1JVFji+tPGwuo=
Authentication-Results: vger.kernel.org; dkim=none (message not signed)
	header.d=none; vger.kernel.org;
	dmarc=none action=none header.from=amd.com; 
Received: from tlendack-t1.amdoffice.net (165.204.77.1) by
	CY4PR12MB1142.namprd12.prod.outlook.com (10.168.163.150) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id
	15.1.1034.10; Tue, 18 Apr 2017 21:21:52 +0000
From: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
Subject: [PATCH v5 29/32] x86/mm: Add support to encrypt the kernel in-place
To: &lt;linux-arch@vger.kernel.org&gt;, &lt;linux-efi@vger.kernel.org&gt;,
	&lt;kvm@vger.kernel.org&gt;, &lt;linux-doc@vger.kernel.org&gt;,
	&lt;x86@kernel.org&gt;, &lt;kexec@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;kasan-dev@googlegroups.com&gt;,
	&lt;linux-mm@kvack.org&gt;, &lt;iommu@lists.linux-foundation.org&gt;
CC: Rik van Riel &lt;riel@redhat.com&gt;,
	Radim =?utf-8?b?S3LEjW3DocWZ?= &lt;rkrcmar@redhat.com&gt;,
	Toshimitsu Kani &lt;toshi.kani@hpe.com&gt;, Arnd Bergmann &lt;arnd@arndb.de&gt;,
	Jonathan Corbet &lt;corbet@lwn.net&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	&quot;Michael S. Tsirkin&quot; &lt;mst@redhat.com&gt;, Joerg Roedel &lt;joro@8bytes.org&gt;,
	Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;,
	Paolo Bonzini &lt;pbonzini@redhat.com&gt;, Larry Woodman &lt;lwoodman@redhat.com&gt;,
	Brijesh Singh &lt;brijesh.singh@amd.com&gt;,
	Ingo Molnar &lt;mingo@redhat.com&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Andrey Ryabinin &lt;aryabinin@virtuozzo.com&gt;,
	Alexander Potapenko &lt;glider@google.com&gt;, Dave Young &lt;dyoung@redhat.com&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Dmitry Vyukov &lt;dvyukov@google.com&gt;
Date: Tue, 18 Apr 2017 16:21:49 -0500
Message-ID: &lt;20170418212149.10190.70894.stgit@tlendack-t1.amdoffice.net&gt;
In-Reply-To: &lt;20170418211612.10190.82788.stgit@tlendack-t1.amdoffice.net&gt;
References: &lt;20170418211612.10190.82788.stgit@tlendack-t1.amdoffice.net&gt;
User-Agent: StGit/0.17.1-dirty
MIME-Version: 1.0
Content-Type: text/plain; charset=&quot;utf-8&quot;
Content-Transfer-Encoding: 7bit
X-Originating-IP: [165.204.77.1]
X-ClientProxiedBy: MWHPR10CA0016.namprd10.prod.outlook.com (10.172.48.26) To
	CY4PR12MB1142.namprd12.prod.outlook.com (10.168.163.150)
X-MS-PublicTrafficType: Email
X-MS-Office365-Filtering-Correlation-Id: 5ae00b7e-f798-41be-2982-08d486a0f080
X-MS-Office365-Filtering-HT: Tenant
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(22001)(48565401081)(201703131423075)(201703031133081);
	SRVR:CY4PR12MB1142; 
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1142;
	3:oWlMlYTIc9xNttVjRy9sQRyeABZHD/0XyQEtbqQveltyvmwTKTebOXTCb3UcAjhXXv5z7q7TgvDmDzaRgkijOnXjqYbIv73RxvoNbGuCf255HP3D5W/uFnGk1/RPUJnOXjp5Smj+bqqBtP2nvDH8F/hyPwR0goh1Ra1H98ZreX1XNHELOdolX+rR/UK1VqSRYaqBUBIhoHMhDI6du8GyyEkVqNKT3q8R+GGKaZd65BwEUj4OHysqQNpjVdjJjDhmtVHtP3YY4wVdepxXiLSoP+BU7I5mzSRtu+tX48WuGDItBVdJjxzKh9LXwu3csZjXYG3H8P1j8ugvIp/sgrNh6Idv/aBxBjkuzNoZoBqr9xk=;
	25:9lFxeMktf0GS2fnbdjrq4r1WUzJkqOyUYUPCFjkMtW11JrCEWkSXNlp0Y34Gcu5Ccg8qkVOKxnrqQbiakIknrLM83/OS0/1Z3ved5iDpMq35/+cp4ZXxoCySF4nf9q3b5kz32qucqCdM8F6PNtrCrchJ0uvFmDa1b/JlVGn2HhyZZK8mh+nzXGkmk6G4qFw+HAHsg08veQEtWufbdzQu1ecRMblIEaVG4zFxWYYV4ing/PlzwJ4g6Jd+kPLXylk+DNa8caqUs/3AoI1R9OvcS6L6o8YtT8u4G+aQaSy4KppyGYNTBeuiXG77Nd7YgHAOOGIJI7cIJgMpsCFhCrwIQomrHq/OAfdTwwubImaH6VWulxZDNIFeHQzurKva+bzUwWAGbVpr80cWqgGYzznO+uwG74nmB9vWOi8X31h7JjWl4FYYMhtOCEmFNMnY3RbmrrtyJiw84rghsLOOiOU3jg==
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1142;
	31:z58SkSTcTGyZp8rFglYsxevB/N0scCEQzPwXAm7tvkxqA4WanYjUnWMGaKrtyuK9XhBbFnQpTaq6zA+YhTeFZ2mRUNeZFwj7+AtGJAbtWAiZdF0JcKlcqvQOOp6L3XWBZUIK9XZ3z9RJrCijLkCPcg8Gyx+p4Ya+StzXXkQuV8/ejUpdD0dcaDuQ9k0uCIBpD0CiPt6ZxHBlR9MgfjsSckrHtr/PkmrORgvb1prykhBdADQsSvCiLezgWfQGSnwG;
	20:aKBBuxBz5I9rUlEjqCiTvflnE5uNZsax79tYgiuyy588gGbcyybqOHDyPTQpKFSC9IWNDFiU6T8qQFz94Ld/9oFgzAeNhabcA+Xv9qknNhJgwtfFa1vQQmMYf6gPs3sfYVv8NoZvqjfJuSuGVOBjm63v/So7+o/irXU/mRJSeO7AgnOPEYv7MvJzKwSEjq1Oi5Kg3cdkay8D8B/fkleu2eqT53O7G6HoNu2ckln7EmrB0QcTvSgMMr9w31ncj37pJKaJ74voRLT+QMjxwpx2ELHsQcccjP48j7xJv61/zaYCx8CjrD7WDEBsiugqHcnpeheTKOdDSWTYDWdi77te63WQ8WJM5r0Kc+uU+u6pDk14vOrRf8wdgBZ4D964NYwG6eMixRP7ZOJLvAUhHLmwwtuOvZVjUSmeeL3PvxJvz0sSija34tVgI94VusRV2EJ2uxebP36rDck777JncJvdnoSF+B4cgorqAyicz20TQGVnRGvlUcEMkC5hpLDOK3N4
X-Microsoft-Antispam-PRVS: &lt;CY4PR12MB114291285FF66C7245E89835EC190@CY4PR12MB1142.namprd12.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(767451399110);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(6040450)(601004)(2401047)(5005006)(8121501046)(93006095)(93001095)(3002001)(10201501046)(6055026)(6041248)(20161123562025)(20161123564025)(201703131423075)(201702281528075)(201703061421075)(20161123560025)(20161123555025)(6072148);
	SRVR:CY4PR12MB1142; BCL:0; PCL:0; RULEID:; SRVR:CY4PR12MB1142;
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1142;
	4:ROlflOQkaOSho4Kkd0ZLDqH7ilWYg2uVoyn9icbIFWeJ4CyUMa0/w8kS+wW5MMWxJTP3KqBkmRR+beUbgwwtODEBxvCeUM4hq2yPh1VhUkbAzZ60b6INXbQVykK8isuHkSeuc6qr64icBTUi+YVzHUQWgzbE+Kd0Er+wbAh0zhsgHiEX20WIQCduuW8YSIsxs44B2afA5gAb30GjyH3lBkeBZ213lIBQfzeGWxpfcpTDYBrwxskeDZo6SfRSADsHWL61s/NTw7zhH1AmggCuRwFngIOlcb8RVVQuMC1v8YdE2agoU+yi8zFp5uqYxs1zgg6Iyf4shxOnZelDKroYgPYpnT9I0rSOhughvM5s3oM7fpOskGnc9lpWeSkLlpnF7KlRBpA5jy8cbVSQz8Y+iHBKFfHXcP7YQtcj81SwTiMD7Yyy2RT5aUFAzbPHtkNRo64Y/Svy9+AdCZOpBjmqgy4Etan5Pja16z7TOVFy3HYVbCjzTETYLbo+FJNgV7Wp7Dg5LSOETQqTXJ/qrtSie/ye4OR6l9TJxCjrQhftmJ1pdLSpKUEYsrSTeKsB2RwCDGt42Ke8pC/Rqk+44Lp1WDA7+U6tS6ZAjQk1+tSLd3lnl6gaWEvkZOkvCWycpyfOJKm+qYoo07ZqF682I5OFUcVntUM4TKT4SGETsyaSy0u1XtWjP1FxEq60i7gzyvqordGjy0cydFhhAlY5KpAtDKWz+QHgehD0fgto7vrxrR1WFT6ML3ssSSaiO77VV8Z0H62Mez4dQAebn+9/g4cyIg==
X-Forefront-PRVS: 028166BF91
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(6009001)(39410400002)(39400400002)(39850400002)(39860400002)(39840400002)(39450400003)(33646002)(81166006)(7416002)(5660300001)(8676002)(7406005)(189998001)(50466002)(103116003)(3846002)(2906002)(25786009)(4326008)(23676002)(66066001)(53416004)(6116002)(6506006)(54356999)(9686003)(230700001)(1076002)(50986999)(54906002)(2201001)(53936002)(76176999)(7736002)(305945005)(4001350100001)(83506001)(38730400002)(86362001)(42186005)(2950100002)(6666003)(55016002)(97746001)(47776003)(2004002)(921003)(71626007)(1121003);
	DIR:OUT; SFP:1101; SCL:1; SRVR:CY4PR12MB1142;
	H:tlendack-t1.amdoffice.net; FPR:; SPF:None; MLV:sfv; LANG:en;
X-Microsoft-Exchange-Diagnostics: =?utf-8?B?MTtDWTRQUjEyTUIxMTQyOzIzOmhRNlQxc1p1UzVkaVZybWlsZnN2YjhZNDU3?=
	=?utf-8?B?UTJJSlhCbjdvV012T1JPQzNRN3ltRyt1SmpzSGVBVHUrNGxySnF3cUYzR20z?=
	=?utf-8?B?ZitnVTRrTzBpcE1IcTZXSGdNTk1haEpyREdFZ2lVUGFOd05ObHVtVmhZOTMv?=
	=?utf-8?B?SXYvZStKUUNPWUZhZFZ4MnAzTkROSGV6a0JzQXZxVnNZanRxbEtqTTRFSFAy?=
	=?utf-8?B?c0REMWdnV0hqeHcyLzlmSlBhRTZFR0Y2WTFPUU4veVZyL09GOWQrVVhzOTNw?=
	=?utf-8?B?TkZOZXUwVVp3ZGppNjl5L0I2dzV4NTU4K01yS0pod3QwQ1NpeFlyaEs1K1VP?=
	=?utf-8?B?ZHJLcERUMHFnVkNxcnZHQ0dQYSsvMW1Pb2xNVWp6N3NmekJNTzBqcUM4Mmlh?=
	=?utf-8?B?SUhiUmZVNCtRVGVESGc5SU5nQXNvT2FUbTBpdFhLNWx6cVpXZEZRL1FINUNn?=
	=?utf-8?B?ZE5kVWZaRWNJcXg4dDlwT2Qwclo5Njk5UVBTanZrZTNGdVhlYm5KcWMvUm8r?=
	=?utf-8?B?WWpQYlBZazRNU0lPcnhwY3loZGFOazhYb09NWVErZW5td2o5cVpzSGJJamJt?=
	=?utf-8?B?R3NkeGRKaGgxc1ZXdk9ZaEdpMGtZSUE1ckE0eVl0RVVKdnZacjZBbnhXM3Jq?=
	=?utf-8?B?QmJhRzdyZ0NFWXdnOGQ5Ykt3TUJyRVRsN3oxUW9XTkRrZ2JiajBPMFdUYUNI?=
	=?utf-8?B?a0xraGpHNkJkZExYWWtBQWU0aFhTaFMzTk5WM1NOcG9vZlhUK2FlM0lyNGtq?=
	=?utf-8?B?RWNBVVN6bWQ3QWhzOE9qbEVnUHJ4RFBCcGo1T0JHR3R1TEYrWVpsenY0VG5B?=
	=?utf-8?B?RjYxeGJzWDYrUDFYZ2EvZnczTFhPTUJuUUt2NWFEeFdxd29YUStteHNrOHls?=
	=?utf-8?B?UjE2eVlrbXcyTjVYc1ROV3YzV1hLcVBIcjk4bXdPNHhCNFlLY1F6bWp6dWMz?=
	=?utf-8?B?UE9oZ0wyS2ZHTzZmbHpDcVJNNXgra2k5a3dHL2xMZEc3RG1ZdEJWUmVnWUxF?=
	=?utf-8?B?UytXUEtaekUya2xLK3BLY1ZOMEIxSGJQbFJPYVFHSnJCWnVKT29XaUpxUWNZ?=
	=?utf-8?B?c0V6RTMyc245U2hrWEpjQVcvUXRHMWNZbW9KMTNNTUxMZEcvV1gxN0FyUnM1?=
	=?utf-8?B?eTBYcXVRWkd2WWcwdnd0bU5BUjVrVGMxRDJkZzhoZmVuNzZuWjdxanVrSkxG?=
	=?utf-8?B?YUFRYWRhUmZGaVRsSkt1N05WY0VuUmtneGxLcVRsN3hraDJoRk1yMFp1MWNy?=
	=?utf-8?B?ZlN1eWNHQmJyUkM0RDF3YW9LNTRVN2JuNmU4U2JYd2FEeFFuWnZKWGxSQkdE?=
	=?utf-8?B?LzZkNjdvMWt2Vzd3Ykw2ekVlWUZ3Y3pSM2hVSzlBUjBaZXJpZlhZTDVzaUN0?=
	=?utf-8?B?UUFnbnJjbE1yY05NQUt2eFhPNlZpMnhRRW5wNHBHSHF4L2lBVWZyVmJhdVVX?=
	=?utf-8?B?THUzNFdQOEFZaHpjSkVLQjNBNUZUYmExUXV5SFF4U0F1cHhOTWtNeW9MY1ZR?=
	=?utf-8?B?TElBZUlLck03VWdFL2dHZFdmTWU5ZXNqbEVEVWJZOWJOK01LN1doVi9kd3dK?=
	=?utf-8?B?Rmc4MWQxSFZTZ251VTBNcW1xV0pIVWpBT0RLdFhaZElPL0hWZDVsVkhwSkd4?=
	=?utf-8?B?SDlMT2ZJWkNqWTNXbUdnblJkQTRyMkhwVk41RTUySG9xekxRQ1VnWWc0cm1C?=
	=?utf-8?Q?/olb1grKv0sb4zHUZY=3D?=
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1142;
	6:keusiv2yW7cDup4L/PA0YVeYDbswVuvBBdi5nAojzl70+R83cCR7D5h00LDOgZHW/jcmKBwRzSJSEiQE6HPYKpxE80pst/nPizumNQztkr1BxZNEqeWLU+cawBtopfI+4v0J7cbqtxPOU4XU2QQWg7w78m+1z0BWEvmbfi6Fe6HGi4AyKTTM8seRic+ld4EoNOSu9mo6X4liub21AkKV7AnDz3MNgKRuoQNjGKUNDzO3Q1vM/iwRV6qQiTG9q5gNHm4pSg1PU4liM6265e2QDt1NvhabEjxazsIszd8ZL/xlMt3rsSOzIV2zu8nSLbmHR4Ln3FoVFhfV2VmSOTWEWmeRwdZEAv3uw4eWKIDr6Gdd+6BcP3z9H3S3ojt55eUm4WFtb4kX5EUFRVhbaXsyEOoD1+yE8mAjKuA+Qa68AORYa1/PKH1HkINecVeGX5f2Hkk3ber772/RxvF0NzCwrB0eh6WSmG8gqyKlAKN9qvs=;
	5:GvCmwGcmB/p2/r6L7db8W85g+I26vDYTHnxBwWA9Mbvx5sjiqfiqSh9BrUu3yyNYTKnp25Pp2BEY4R1xlj13+koc4a8PKA79slwJZ4X6qfHUCR4k45MsZm9w9a9E3rVClI7oOapQ9eSPcUOFbad6hQ==;
	24:/sZlQxb3jyuKpzwmM6NOMyKu++MDgzUEYc3NbKpjnLftmqCBDHCSn1LUHA8IWDgbmKxX2WkErEMTXVUe4kWY4F7k9gKakp/inOVQEsP2GZY=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; CY4PR12MB1142;
	7:gv5YP5YzGcAMfbfv9ErzUBJyYcDfhKrAqBtNApuD8jiJgveM0h5Tq5VDpvWopAOR8k080gfpMVyanDDt+Eg0t8yyairuhlpR7jkxUm1ceT4p5IhHRAgmIGMLc7LiB6OJrRMlzZ2rVFb926RihEXjk4Co30TiTZVpt6/hvh7TyQocYxrYf0i3GjPKKJSs2//Qri0MgsV+26SlQEzEeFzE+OWF+pBdR5yfqcIfgrqCjSp0KuMWV0ueyLudtB9SIpWcRMDmA5Pa3/S2Pf5LXHIyQnmysQ2ZZuBXBzBOCWq2nGyfTApKw0yIG0BwIlwFMfaaBL5icX8Juw7PwRTBH7PlmQ==;
	20:DrOsM2/J8cGcSEWRnXiMt8uMOraKSP8TWPija6WzEfKxZ9Mgpd95x7sA6+40JFF5Brz73SkyOhlAGepi5VsHi+Qj1tox8WpeneaWx2Fw0o6Ko58XauLalJow7ps7cWjUlkHE6FyBmQCPAVBrSKLvogF+FgirdGltdpWvWxJ2EAO9QnqO+Z9i3GxXnut4YxEAS9/8+78ww0+rYFeoxdgut5/yQuVK6W63GRd4z0W3MxtU/ASZ8bCZJ7NyW0bdd72U
X-OriginatorOrg: amd.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 18 Apr 2017 21:21:52.7611
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY4PR12MB1142
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - April 18, 2017, 9:21 p.m.</div>
<pre class="content">
Add the support to encrypt the kernel in-place. This is done by creating
new page mappings for the kernel - a decrypted write-protected mapping
and an encrypted mapping. The kernel is encrypted by copying it through
a temporary buffer.
<span class="signed-off-by">
Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
---
 arch/x86/include/asm/mem_encrypt.h |    6 +
 arch/x86/mm/Makefile               |    2 
 arch/x86/mm/mem_encrypt.c          |  262 ++++++++++++++++++++++++++++++++++++
 arch/x86/mm/mem_encrypt_boot.S     |  151 +++++++++++++++++++++
 4 files changed, 421 insertions(+)
 create mode 100644 arch/x86/mm/mem_encrypt_boot.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 18, 2017, 12:46 p.m.</div>
<pre class="content">
On Tue, Apr 18, 2017 at 04:21:49PM -0500, Tom Lendacky wrote:
<span class="quote">&gt; Add the support to encrypt the kernel in-place. This is done by creating</span>
<span class="quote">&gt; new page mappings for the kernel - a decrypted write-protected mapping</span>
<span class="quote">&gt; and an encrypted mapping. The kernel is encrypted by copying it through</span>
<span class="quote">&gt; a temporary buffer.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/include/asm/mem_encrypt.h |    6 +</span>
<span class="quote">&gt;  arch/x86/mm/Makefile               |    2 </span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt.c          |  262 ++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt_boot.S     |  151 +++++++++++++++++++++</span>
<span class="quote">&gt;  4 files changed, 421 insertions(+)</span>
<span class="quote">&gt;  create mode 100644 arch/x86/mm/mem_encrypt_boot.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt; index b406df2..8f6f9b4 100644</span>
<span class="quote">&gt; --- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt; +++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt; @@ -31,6 +31,12 @@ static inline u64 sme_dma_mask(void)</span>
<span class="quote">&gt;  	return ((u64)sme_me_mask &lt;&lt; 1) - 1;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +void sme_encrypt_execute(unsigned long encrypted_kernel_vaddr,</span>
<span class="quote">&gt; +			 unsigned long decrypted_kernel_vaddr,</span>
<span class="quote">&gt; +			 unsigned long kernel_len,</span>
<span class="quote">&gt; +			 unsigned long encryption_wa,</span>
<span class="quote">&gt; +			 unsigned long encryption_pgd);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  void __init sme_early_encrypt(resource_size_t paddr,</span>
<span class="quote">&gt;  			      unsigned long size);</span>
<span class="quote">&gt;  void __init sme_early_decrypt(resource_size_t paddr,</span>
<span class="quote">&gt; diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="quote">&gt; index 9e13841..0633142 100644</span>
<span class="quote">&gt; --- a/arch/x86/mm/Makefile</span>
<span class="quote">&gt; +++ b/arch/x86/mm/Makefile</span>
<span class="quote">&gt; @@ -38,3 +38,5 @@ obj-$(CONFIG_NUMA_EMU)		+= numa_emulation.o</span>
<span class="quote">&gt;  obj-$(CONFIG_X86_INTEL_MPX)	+= mpx.o</span>
<span class="quote">&gt;  obj-$(CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS) += pkeys.o</span>
<span class="quote">&gt;  obj-$(CONFIG_RANDOMIZE_MEMORY) += kaslr.o</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o</span>
<span class="quote">&gt; diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; index 30b07a3..0ff41a4 100644</span>
<span class="quote">&gt; --- a/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; +++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; @@ -24,6 +24,7 @@</span>
<span class="quote">&gt;  #include &lt;asm/setup.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/bootparam.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/cacheflush.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/sections.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Since SME related variables are set early in the boot process they must</span>
<span class="quote">&gt; @@ -216,8 +217,269 @@ void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
<span class="quote">&gt;  	set_memory_decrypted((unsigned long)vaddr, size &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +void __init sme_clear_pgd(pgd_t *pgd_base, unsigned long start,</span>

static
<span class="quote">
&gt; +			  unsigned long end)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long addr = start;</span>
<span class="quote">&gt; +	pgdval_t *pgd_p;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	while (addr &lt; end) {</span>
<span class="quote">&gt; +		unsigned long pgd_end;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pgd_end = (addr &amp; PGDIR_MASK) + PGDIR_SIZE;</span>
<span class="quote">&gt; +		if (pgd_end &gt; end)</span>
<span class="quote">&gt; +			pgd_end = end;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pgd_p = (pgdval_t *)pgd_base + pgd_index(addr);</span>
<span class="quote">&gt; +		*pgd_p = 0;</span>

Hmm, so this is a contiguous range from [start:end] which translates to
8-byte PGD pointers in the PGD page so you can simply memset that range,
no?

Instead of iterating over each one?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		addr = pgd_end;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PGD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; +#define PUD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; +#define PMD_FLAGS	(__PAGE_KERNEL_LARGE_EXEC &amp; ~_PAGE_GLOBAL)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void __init *sme_populate_pgd(pgd_t *pgd_base, void *pgtable_area,</span>
<span class="quote">&gt; +				     unsigned long vaddr, pmdval_t pmd_val)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pgdval_t pgd, *pgd_p;</span>
<span class="quote">&gt; +	pudval_t pud, *pud_p;</span>
<span class="quote">&gt; +	pmdval_t pmd, *pmd_p;</span>

You should use the enclosing type, not the underlying one. I.e.,

	pgd_t *pgd;
	pud_t *pud;
	...

and then the macros native_p*d_val(), p*d_offset() and so on. I say
native_* because we don&#39;t want to have any paravirt nastyness here.
I believe your previous version was using the proper interfaces.

And the kernel has gotten 5-level pagetables support in
the meantime, so this&#39;ll need to start at p4d AFAICT.
arch/x86/mm/fault.c::dump_pagetable() looks like a good example to stare
at.
<span class="quote">
&gt; +	pgd_p = (pgdval_t *)pgd_base + pgd_index(vaddr);</span>
<span class="quote">&gt; +	pgd = *pgd_p;</span>
<span class="quote">&gt; +	if (pgd) {</span>
<span class="quote">&gt; +		pud_p = (pudval_t *)(pgd &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		pud_p = pgtable_area;</span>
<span class="quote">&gt; +		memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="quote">&gt; +		pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		*pgd_p = (pgdval_t)pud_p + PGD_FLAGS;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pud_p += pud_index(vaddr);</span>
<span class="quote">&gt; +	pud = *pud_p;</span>
<span class="quote">&gt; +	if (pud) {</span>
<span class="quote">&gt; +		if (pud &amp; _PAGE_PSE)</span>
<span class="quote">&gt; +			goto out;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pmd_p = (pmdval_t *)(pud &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		pmd_p = pgtable_area;</span>
<span class="quote">&gt; +		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="quote">&gt; +		pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		*pud_p = (pudval_t)pmd_p + PUD_FLAGS;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmd_p += pmd_index(vaddr);</span>
<span class="quote">&gt; +	pmd = *pmd_p;</span>
<span class="quote">&gt; +	if (!pmd || !(pmd &amp; _PAGE_PSE))</span>
<span class="quote">&gt; +		*pmd_p = pmd_val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt; +	return pgtable_area;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static unsigned long __init sme_pgtable_calc(unsigned long len)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long pud_tables, pmd_tables;</span>
<span class="quote">&gt; +	unsigned long total = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Perform a relatively simplistic calculation of the pagetable</span>
<span class="quote">&gt; +	 * entries that are needed. That mappings will be covered by 2MB</span>
<span class="quote">&gt; +	 * PMD entries so we can conservatively calculate the required</span>
<span class="quote">&gt; +	 * number of PUD and PMD structures needed to perform the mappings.</span>
<span class="quote">&gt; +	 * Incrementing the count for each covers the case where the</span>
<span class="quote">&gt; +	 * addresses cross entries.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	pud_tables = ALIGN(len, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="quote">&gt; +	pud_tables++;</span>
<span class="quote">&gt; +	pmd_tables = ALIGN(len, PUD_SIZE) / PUD_SIZE;</span>
<span class="quote">&gt; +	pmd_tables++;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	total += pud_tables * sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="quote">&gt; +	total += pmd_tables * sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Now calculate the added pagetable structures needed to populate</span>
<span class="quote">&gt; +	 * the new pagetables.</span>
<span class="quote">&gt; +	 */</span>

Nice commenting, helps following what&#39;s going on.
<span class="quote">
&gt; +	pud_tables = ALIGN(total, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="quote">&gt; +	pmd_tables = ALIGN(total, PUD_SIZE) / PUD_SIZE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	total += pud_tables * sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="quote">&gt; +	total += pmd_tables * sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return total;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  void __init sme_encrypt_kernel(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; +	pgd_t *pgd;</span>
<span class="quote">&gt; +	void *pgtable_area;</span>
<span class="quote">&gt; +	unsigned long kernel_start, kernel_end, kernel_len;</span>
<span class="quote">&gt; +	unsigned long workarea_start, workarea_end, workarea_len;</span>
<span class="quote">&gt; +	unsigned long execute_start, execute_end, execute_len;</span>
<span class="quote">&gt; +	unsigned long pgtable_area_len;</span>
<span class="quote">&gt; +	unsigned long decrypted_base;</span>
<span class="quote">&gt; +	unsigned long paddr, pmd_flags;</span>


Please sort function local variables declaration in a reverse christmas
tree order:

	&lt;type&gt; longest_variable_name;
	&lt;type&gt; shorter_var_name;
	&lt;type&gt; even_shorter;
	&lt;type&gt; i;
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	if (!sme_active())</span>
<span class="quote">&gt; +		return;</span>

...
<span class="quote">
&gt; diff --git a/arch/x86/mm/mem_encrypt_boot.S b/arch/x86/mm/mem_encrypt_boot.S</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..fb58f9f</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/x86/mm/mem_encrypt_boot.S</span>
<span class="quote">&gt; @@ -0,0 +1,151 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * AMD Memory Encryption Support</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright (C) 2016 Advanced Micro Devices, Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/linkage.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/page.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/processor-flags.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/msr-index.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	.text</span>
<span class="quote">&gt; +	.code64</span>
<span class="quote">&gt; +ENTRY(sme_encrypt_execute)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Entry parameters:</span>
<span class="quote">&gt; +	 *   RDI - virtual address for the encrypted kernel mapping</span>
<span class="quote">&gt; +	 *   RSI - virtual address for the decrypted kernel mapping</span>
<span class="quote">&gt; +	 *   RDX - length of kernel</span>
<span class="quote">&gt; +	 *   RCX - virtual address of the encryption workarea, including:</span>
<span class="quote">&gt; +	 *     - stack page (PAGE_SIZE)</span>
<span class="quote">&gt; +	 *     - encryption routine page (PAGE_SIZE)</span>
<span class="quote">&gt; +	 *     - intermediate copy buffer (PMD_PAGE_SIZE)</span>
<span class="quote">&gt; +	 *    R8 - physcial address of the pagetables to use for encryption</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	push	%rbp</span>
<span class="quote">&gt; +	push	%r12</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set up a one page stack in the non-encrypted memory area */</span>
<span class="quote">&gt; +	movq	%rsp, %rbp		/* Save current stack pointer */</span>
<span class="quote">&gt; +	movq	%rcx, %rax		/* Workarea stack page */</span>
<span class="quote">&gt; +	movq	%rax, %rsp		/* Set new stack pointer */</span>
<span class="quote">&gt; +	addq	$PAGE_SIZE, %rsp	/* Stack grows from the bottom */</span>
<span class="quote">&gt; +	addq	$PAGE_SIZE, %rax	/* Workarea encryption routine */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	movq	%rdi, %r10		/* Encrypted kernel */</span>
<span class="quote">&gt; +	movq	%rsi, %r11		/* Decrypted kernel */</span>
<span class="quote">&gt; +	movq	%rdx, %r12		/* Kernel length */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Copy encryption routine into the workarea */</span>
<span class="quote">&gt; +	movq	%rax, %rdi		/* Workarea encryption routine */</span>
<span class="quote">&gt; +	leaq	.Lenc_start(%rip), %rsi	/* Encryption routine */</span>
<span class="quote">&gt; +	movq	$(.Lenc_stop - .Lenc_start), %rcx	/* Encryption routine length */</span>
<span class="quote">&gt; +	rep	movsb</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Setup registers for call */</span>
<span class="quote">&gt; +	movq	%r10, %rdi		/* Encrypted kernel */</span>
<span class="quote">&gt; +	movq	%r11, %rsi		/* Decrypted kernel */</span>
<span class="quote">&gt; +	movq	%r8, %rdx		/* Pagetables used for encryption */</span>
<span class="quote">&gt; +	movq	%r12, %rcx		/* Kernel length */</span>
<span class="quote">&gt; +	movq	%rax, %r8		/* Workarea encryption routine */</span>
<span class="quote">&gt; +	addq	$PAGE_SIZE, %r8		/* Workarea intermediate copy buffer */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	call	*%rax			/* Call the encryption routine */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	movq	%rbp, %rsp		/* Restore original stack pointer */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pop	%r12</span>
<span class="quote">&gt; +	pop	%rbp</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret</span>
<span class="quote">&gt; +ENDPROC(sme_encrypt_execute)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +.Lenc_start:</span>
<span class="quote">&gt; +ENTRY(sme_enc_routine)</span>

A function called a &quot;routine&quot;? Why do we need the global symbol?
Nothing&#39;s referencing it AFAICT.
<span class="quote">
&gt; +/*</span>
<span class="quote">&gt; + * Routine used to encrypt kernel.</span>
<span class="quote">&gt; + *   This routine must be run outside of the kernel proper since</span>
<span class="quote">&gt; + *   the kernel will be encrypted during the process. So this</span>
<span class="quote">&gt; + *   routine is defined here and then copied to an area outside</span>
<span class="quote">&gt; + *   of the kernel where it will remain and run decrypted</span>
<span class="quote">&gt; + *   during execution.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   On entry the registers must be:</span>
<span class="quote">&gt; + *     RDI - virtual address for the encrypted kernel mapping</span>
<span class="quote">&gt; + *     RSI - virtual address for the decrypted kernel mapping</span>
<span class="quote">&gt; + *     RDX - address of the pagetables to use for encryption</span>
<span class="quote">&gt; + *     RCX - length of kernel</span>
<span class="quote">&gt; + *      R8 - intermediate copy buffer</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *     RAX - points to this routine</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * The kernel will be encrypted by copying from the non-encrypted</span>
<span class="quote">&gt; + * kernel space to an intermediate buffer and then copying from the</span>
<span class="quote">&gt; + * intermediate buffer back to the encrypted kernel space. The physical</span>
<span class="quote">&gt; + * addresses of the two kernel space mappings are the same which</span>
<span class="quote">&gt; + * results in the kernel being encrypted &quot;in place&quot;.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +	/* Enable the new page tables */</span>
<span class="quote">&gt; +	mov	%rdx, %cr3</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Flush any global TLBs */</span>
<span class="quote">&gt; +	mov	%cr4, %rdx</span>
<span class="quote">&gt; +	andq	$~X86_CR4_PGE, %rdx</span>
<span class="quote">&gt; +	mov	%rdx, %cr4</span>
<span class="quote">&gt; +	orq	$X86_CR4_PGE, %rdx</span>
<span class="quote">&gt; +	mov	%rdx, %cr4</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set the PAT register PA5 entry to write-protect */</span>
<span class="quote">&gt; +	push	%rcx</span>
<span class="quote">&gt; +	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="quote">&gt; +	rdmsr</span>
<span class="quote">&gt; +	push	%rdx			/* Save original PAT value */</span>
<span class="quote">&gt; +	andl	$0xffff00ff, %edx	/* Clear PA5 */</span>
<span class="quote">&gt; +	orl	$0x00000500, %edx	/* Set PA5 to WP */</span>

Maybe check first whether PA5 is already set correctly and avoid the
WRMSR and the restoring below too?
<span class="quote">
&gt; +	wrmsr</span>
<span class="quote">&gt; +	pop	%rdx			/* RDX contains original PAT value */</span>
<span class="quote">&gt; +	pop	%rcx</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	movq	%rcx, %r9		/* Save kernel length */</span>
<span class="quote">&gt; +	movq	%rdi, %r10		/* Save encrypted kernel address */</span>
<span class="quote">&gt; +	movq	%rsi, %r11		/* Save decrypted kernel address */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	wbinvd				/* Invalidate any cache entries */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Copy/encrypt 2MB at a time */</span>
<span class="quote">&gt; +1:</span>
<span class="quote">&gt; +	movq	%r11, %rsi		/* Source - decrypted kernel */</span>
<span class="quote">&gt; +	movq	%r8, %rdi		/* Dest   - intermediate copy buffer */</span>
<span class="quote">&gt; +	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="quote">&gt; +	rep	movsb</span>

not movsQ?
<span class="quote">
&gt; +	movq	%r8, %rsi		/* Source - intermediate copy buffer */</span>
<span class="quote">&gt; +	movq	%r10, %rdi		/* Dest   - encrypted kernel */</span>
<span class="quote">&gt; +	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="quote">&gt; +	rep	movsb</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	addq	$PMD_PAGE_SIZE, %r11</span>
<span class="quote">&gt; +	addq	$PMD_PAGE_SIZE, %r10</span>
<span class="quote">&gt; +	subq	$PMD_PAGE_SIZE, %r9	/* Kernel length decrement */</span>
<span class="quote">&gt; +	jnz	1b			/* Kernel length not zero? */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Restore PAT register */</span>
<span class="quote">&gt; +	push	%rdx			/* Save original PAT value */</span>
<span class="quote">&gt; +	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="quote">&gt; +	rdmsr</span>
<span class="quote">&gt; +	pop	%rdx			/* Restore original PAT value */</span>
<span class="quote">&gt; +	wrmsr</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret</span>
<span class="quote">&gt; +ENDPROC(sme_enc_routine)</span>
<span class="quote">&gt; +.Lenc_stop:</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - May 25, 2017, 10:24 p.m.</div>
<pre class="content">
On 5/18/2017 7:46 AM, Borislav Petkov wrote:
<span class="quote">&gt; On Tue, Apr 18, 2017 at 04:21:49PM -0500, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt; Add the support to encrypt the kernel in-place. This is done by creating</span>
<span class="quote">&gt;&gt; new page mappings for the kernel - a decrypted write-protected mapping</span>
<span class="quote">&gt;&gt; and an encrypted mapping. The kernel is encrypted by copying it through</span>
<span class="quote">&gt;&gt; a temporary buffer.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/x86/include/asm/mem_encrypt.h |    6 +</span>
<span class="quote">&gt;&gt;  arch/x86/mm/Makefile               |    2</span>
<span class="quote">&gt;&gt;  arch/x86/mm/mem_encrypt.c          |  262 ++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  arch/x86/mm/mem_encrypt_boot.S     |  151 +++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  4 files changed, 421 insertions(+)</span>
<span class="quote">&gt;&gt;  create mode 100644 arch/x86/mm/mem_encrypt_boot.S</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt;&gt; index b406df2..8f6f9b4 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="quote">&gt;&gt; @@ -31,6 +31,12 @@ static inline u64 sme_dma_mask(void)</span>
<span class="quote">&gt;&gt;  	return ((u64)sme_me_mask &lt;&lt; 1) - 1;</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +void sme_encrypt_execute(unsigned long encrypted_kernel_vaddr,</span>
<span class="quote">&gt;&gt; +			 unsigned long decrypted_kernel_vaddr,</span>
<span class="quote">&gt;&gt; +			 unsigned long kernel_len,</span>
<span class="quote">&gt;&gt; +			 unsigned long encryption_wa,</span>
<span class="quote">&gt;&gt; +			 unsigned long encryption_pgd);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  void __init sme_early_encrypt(resource_size_t paddr,</span>
<span class="quote">&gt;&gt;  			      unsigned long size);</span>
<span class="quote">&gt;&gt;  void __init sme_early_decrypt(resource_size_t paddr,</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="quote">&gt;&gt; index 9e13841..0633142 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/mm/Makefile</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/mm/Makefile</span>
<span class="quote">&gt;&gt; @@ -38,3 +38,5 @@ obj-$(CONFIG_NUMA_EMU)		+= numa_emulation.o</span>
<span class="quote">&gt;&gt;  obj-$(CONFIG_X86_INTEL_MPX)	+= mpx.o</span>
<span class="quote">&gt;&gt;  obj-$(CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS) += pkeys.o</span>
<span class="quote">&gt;&gt;  obj-$(CONFIG_RANDOMIZE_MEMORY) += kaslr.o</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt;&gt; index 30b07a3..0ff41a4 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt;&gt; @@ -24,6 +24,7 @@</span>
<span class="quote">&gt;&gt;  #include &lt;asm/setup.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/bootparam.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/cacheflush.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/sections.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  /*</span>
<span class="quote">&gt;&gt;   * Since SME related variables are set early in the boot process they must</span>
<span class="quote">&gt;&gt; @@ -216,8 +217,269 @@ void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
<span class="quote">&gt;&gt;  	set_memory_decrypted((unsigned long)vaddr, size &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +void __init sme_clear_pgd(pgd_t *pgd_base, unsigned long start,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; static</span>

Yup.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +			  unsigned long end)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	unsigned long addr = start;</span>
<span class="quote">&gt;&gt; +	pgdval_t *pgd_p;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	while (addr &lt; end) {</span>
<span class="quote">&gt;&gt; +		unsigned long pgd_end;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		pgd_end = (addr &amp; PGDIR_MASK) + PGDIR_SIZE;</span>
<span class="quote">&gt;&gt; +		if (pgd_end &gt; end)</span>
<span class="quote">&gt;&gt; +			pgd_end = end;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		pgd_p = (pgdval_t *)pgd_base + pgd_index(addr);</span>
<span class="quote">&gt;&gt; +		*pgd_p = 0;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Hmm, so this is a contiguous range from [start:end] which translates to</span>
<span class="quote">&gt; 8-byte PGD pointers in the PGD page so you can simply memset that range,</span>
<span class="quote">&gt; no?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Instead of iterating over each one?</span>

I guess I could do that, but this will probably only end up clearing a
single PGD entry anyway since it&#39;s highly doubtful the address range
would cross a 512GB boundary.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		addr = pgd_end;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#define PGD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt;&gt; +#define PUD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt;&gt; +#define PMD_FLAGS	(__PAGE_KERNEL_LARGE_EXEC &amp; ~_PAGE_GLOBAL)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static void __init *sme_populate_pgd(pgd_t *pgd_base, void *pgtable_area,</span>
<span class="quote">&gt;&gt; +				     unsigned long vaddr, pmdval_t pmd_val)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	pgdval_t pgd, *pgd_p;</span>
<span class="quote">&gt;&gt; +	pudval_t pud, *pud_p;</span>
<span class="quote">&gt;&gt; +	pmdval_t pmd, *pmd_p;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You should use the enclosing type, not the underlying one. I.e.,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	pgd_t *pgd;</span>
<span class="quote">&gt; 	pud_t *pud;</span>
<span class="quote">&gt; 	...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; and then the macros native_p*d_val(), p*d_offset() and so on. I say</span>
<span class="quote">&gt; native_* because we don&#39;t want to have any paravirt nastyness here.</span>
<span class="quote">&gt; I believe your previous version was using the proper interfaces.</span>

I won&#39;t be able to use the p*d_offset() macros since they use __va()
and we&#39;re identity mapped during this time (which is why I would guess
the proposed changes for the 5-level pagetables in
arch/x86/kernel/head64.c, __startup_64, don&#39;t use these macros
either). I should be able to use the native_set_p*d() and others though,
I&#39;ll look into that.
<span class="quote">
&gt;</span>
<span class="quote">&gt; And the kernel has gotten 5-level pagetables support in</span>
<span class="quote">&gt; the meantime, so this&#39;ll need to start at p4d AFAICT.</span>
<span class="quote">&gt; arch/x86/mm/fault.c::dump_pagetable() looks like a good example to stare</span>
<span class="quote">&gt; at.</span>

Yeah, I accounted for that in the other parts of the code but I need
to do that here also.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	pgd_p = (pgdval_t *)pgd_base + pgd_index(vaddr);</span>
<span class="quote">&gt;&gt; +	pgd = *pgd_p;</span>
<span class="quote">&gt;&gt; +	if (pgd) {</span>
<span class="quote">&gt;&gt; +		pud_p = (pudval_t *)(pgd &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt;&gt; +	} else {</span>
<span class="quote">&gt;&gt; +		pud_p = pgtable_area;</span>
<span class="quote">&gt;&gt; +		memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="quote">&gt;&gt; +		pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		*pgd_p = (pgdval_t)pud_p + PGD_FLAGS;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	pud_p += pud_index(vaddr);</span>
<span class="quote">&gt;&gt; +	pud = *pud_p;</span>
<span class="quote">&gt;&gt; +	if (pud) {</span>
<span class="quote">&gt;&gt; +		if (pud &amp; _PAGE_PSE)</span>
<span class="quote">&gt;&gt; +			goto out;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		pmd_p = (pmdval_t *)(pud &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt;&gt; +	} else {</span>
<span class="quote">&gt;&gt; +		pmd_p = pgtable_area;</span>
<span class="quote">&gt;&gt; +		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="quote">&gt;&gt; +		pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		*pud_p = (pudval_t)pmd_p + PUD_FLAGS;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	pmd_p += pmd_index(vaddr);</span>
<span class="quote">&gt;&gt; +	pmd = *pmd_p;</span>
<span class="quote">&gt;&gt; +	if (!pmd || !(pmd &amp; _PAGE_PSE))</span>
<span class="quote">&gt;&gt; +		*pmd_p = pmd_val;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +out:</span>
<span class="quote">&gt;&gt; +	return pgtable_area;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static unsigned long __init sme_pgtable_calc(unsigned long len)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	unsigned long pud_tables, pmd_tables;</span>
<span class="quote">&gt;&gt; +	unsigned long total = 0;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Perform a relatively simplistic calculation of the pagetable</span>
<span class="quote">&gt;&gt; +	 * entries that are needed. That mappings will be covered by 2MB</span>
<span class="quote">&gt;&gt; +	 * PMD entries so we can conservatively calculate the required</span>
<span class="quote">&gt;&gt; +	 * number of PUD and PMD structures needed to perform the mappings.</span>
<span class="quote">&gt;&gt; +	 * Incrementing the count for each covers the case where the</span>
<span class="quote">&gt;&gt; +	 * addresses cross entries.</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	pud_tables = ALIGN(len, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="quote">&gt;&gt; +	pud_tables++;</span>
<span class="quote">&gt;&gt; +	pmd_tables = ALIGN(len, PUD_SIZE) / PUD_SIZE;</span>
<span class="quote">&gt;&gt; +	pmd_tables++;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	total += pud_tables * sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="quote">&gt;&gt; +	total += pmd_tables * sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Now calculate the added pagetable structures needed to populate</span>
<span class="quote">&gt;&gt; +	 * the new pagetables.</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Nice commenting, helps following what&#39;s going on.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +	pud_tables = ALIGN(total, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="quote">&gt;&gt; +	pmd_tables = ALIGN(total, PUD_SIZE) / PUD_SIZE;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	total += pud_tables * sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="quote">&gt;&gt; +	total += pmd_tables * sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return total;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  void __init sme_encrypt_kernel(void)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt; +	pgd_t *pgd;</span>
<span class="quote">&gt;&gt; +	void *pgtable_area;</span>
<span class="quote">&gt;&gt; +	unsigned long kernel_start, kernel_end, kernel_len;</span>
<span class="quote">&gt;&gt; +	unsigned long workarea_start, workarea_end, workarea_len;</span>
<span class="quote">&gt;&gt; +	unsigned long execute_start, execute_end, execute_len;</span>
<span class="quote">&gt;&gt; +	unsigned long pgtable_area_len;</span>
<span class="quote">&gt;&gt; +	unsigned long decrypted_base;</span>
<span class="quote">&gt;&gt; +	unsigned long paddr, pmd_flags;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Please sort function local variables declaration in a reverse christmas</span>
<span class="quote">&gt; tree order:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	&lt;type&gt; longest_variable_name;</span>
<span class="quote">&gt; 	&lt;type&gt; shorter_var_name;</span>
<span class="quote">&gt; 	&lt;type&gt; even_shorter;</span>
<span class="quote">&gt; 	&lt;type&gt; i;</span>
<span class="quote">&gt;</span>

Will do.
<span class="quote">
&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (!sme_active())</span>
<span class="quote">&gt;&gt; +		return;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/mm/mem_encrypt_boot.S b/arch/x86/mm/mem_encrypt_boot.S</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 0000000..fb58f9f</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/mm/mem_encrypt_boot.S</span>
<span class="quote">&gt;&gt; @@ -0,0 +1,151 @@</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * AMD Memory Encryption Support</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2016 Advanced Micro Devices, Inc.</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt;&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt;&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#include &lt;linux/linkage.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/page.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/processor-flags.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/msr-index.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	.text</span>
<span class="quote">&gt;&gt; +	.code64</span>
<span class="quote">&gt;&gt; +ENTRY(sme_encrypt_execute)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Entry parameters:</span>
<span class="quote">&gt;&gt; +	 *   RDI - virtual address for the encrypted kernel mapping</span>
<span class="quote">&gt;&gt; +	 *   RSI - virtual address for the decrypted kernel mapping</span>
<span class="quote">&gt;&gt; +	 *   RDX - length of kernel</span>
<span class="quote">&gt;&gt; +	 *   RCX - virtual address of the encryption workarea, including:</span>
<span class="quote">&gt;&gt; +	 *     - stack page (PAGE_SIZE)</span>
<span class="quote">&gt;&gt; +	 *     - encryption routine page (PAGE_SIZE)</span>
<span class="quote">&gt;&gt; +	 *     - intermediate copy buffer (PMD_PAGE_SIZE)</span>
<span class="quote">&gt;&gt; +	 *    R8 - physcial address of the pagetables to use for encryption</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	push	%rbp</span>
<span class="quote">&gt;&gt; +	push	%r12</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Set up a one page stack in the non-encrypted memory area */</span>
<span class="quote">&gt;&gt; +	movq	%rsp, %rbp		/* Save current stack pointer */</span>
<span class="quote">&gt;&gt; +	movq	%rcx, %rax		/* Workarea stack page */</span>
<span class="quote">&gt;&gt; +	movq	%rax, %rsp		/* Set new stack pointer */</span>
<span class="quote">&gt;&gt; +	addq	$PAGE_SIZE, %rsp	/* Stack grows from the bottom */</span>
<span class="quote">&gt;&gt; +	addq	$PAGE_SIZE, %rax	/* Workarea encryption routine */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	movq	%rdi, %r10		/* Encrypted kernel */</span>
<span class="quote">&gt;&gt; +	movq	%rsi, %r11		/* Decrypted kernel */</span>
<span class="quote">&gt;&gt; +	movq	%rdx, %r12		/* Kernel length */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Copy encryption routine into the workarea */</span>
<span class="quote">&gt;&gt; +	movq	%rax, %rdi		/* Workarea encryption routine */</span>
<span class="quote">&gt;&gt; +	leaq	.Lenc_start(%rip), %rsi	/* Encryption routine */</span>
<span class="quote">&gt;&gt; +	movq	$(.Lenc_stop - .Lenc_start), %rcx	/* Encryption routine length */</span>
<span class="quote">&gt;&gt; +	rep	movsb</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Setup registers for call */</span>
<span class="quote">&gt;&gt; +	movq	%r10, %rdi		/* Encrypted kernel */</span>
<span class="quote">&gt;&gt; +	movq	%r11, %rsi		/* Decrypted kernel */</span>
<span class="quote">&gt;&gt; +	movq	%r8, %rdx		/* Pagetables used for encryption */</span>
<span class="quote">&gt;&gt; +	movq	%r12, %rcx		/* Kernel length */</span>
<span class="quote">&gt;&gt; +	movq	%rax, %r8		/* Workarea encryption routine */</span>
<span class="quote">&gt;&gt; +	addq	$PAGE_SIZE, %r8		/* Workarea intermediate copy buffer */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	call	*%rax			/* Call the encryption routine */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	movq	%rbp, %rsp		/* Restore original stack pointer */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	pop	%r12</span>
<span class="quote">&gt;&gt; +	pop	%rbp</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	ret</span>
<span class="quote">&gt;&gt; +ENDPROC(sme_encrypt_execute)</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +.Lenc_start:</span>
<span class="quote">&gt;&gt; +ENTRY(sme_enc_routine)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; A function called a &quot;routine&quot;? Why do we need the global symbol?</span>
<span class="quote">&gt; Nothing&#39;s referencing it AFAICT.</span>

I can change the name. As for the use of ENTRY... without the
ENTRY/ENDPROC combination I was receiving a warning about a return
instruction outside of a callable function. It looks like I can just
define the &quot;sme_enc_routine:&quot; label with the ENDPROC and the warning
goes away and the global is avoided. It doesn&#39;t like the local labels
(.L...) so I&#39;ll use the new name.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Routine used to encrypt kernel.</span>
<span class="quote">&gt;&gt; + *   This routine must be run outside of the kernel proper since</span>
<span class="quote">&gt;&gt; + *   the kernel will be encrypted during the process. So this</span>
<span class="quote">&gt;&gt; + *   routine is defined here and then copied to an area outside</span>
<span class="quote">&gt;&gt; + *   of the kernel where it will remain and run decrypted</span>
<span class="quote">&gt;&gt; + *   during execution.</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *   On entry the registers must be:</span>
<span class="quote">&gt;&gt; + *     RDI - virtual address for the encrypted kernel mapping</span>
<span class="quote">&gt;&gt; + *     RSI - virtual address for the decrypted kernel mapping</span>
<span class="quote">&gt;&gt; + *     RDX - address of the pagetables to use for encryption</span>
<span class="quote">&gt;&gt; + *     RCX - length of kernel</span>
<span class="quote">&gt;&gt; + *      R8 - intermediate copy buffer</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *     RAX - points to this routine</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * The kernel will be encrypted by copying from the non-encrypted</span>
<span class="quote">&gt;&gt; + * kernel space to an intermediate buffer and then copying from the</span>
<span class="quote">&gt;&gt; + * intermediate buffer back to the encrypted kernel space. The physical</span>
<span class="quote">&gt;&gt; + * addresses of the two kernel space mappings are the same which</span>
<span class="quote">&gt;&gt; + * results in the kernel being encrypted &quot;in place&quot;.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +	/* Enable the new page tables */</span>
<span class="quote">&gt;&gt; +	mov	%rdx, %cr3</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Flush any global TLBs */</span>
<span class="quote">&gt;&gt; +	mov	%cr4, %rdx</span>
<span class="quote">&gt;&gt; +	andq	$~X86_CR4_PGE, %rdx</span>
<span class="quote">&gt;&gt; +	mov	%rdx, %cr4</span>
<span class="quote">&gt;&gt; +	orq	$X86_CR4_PGE, %rdx</span>
<span class="quote">&gt;&gt; +	mov	%rdx, %cr4</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Set the PAT register PA5 entry to write-protect */</span>
<span class="quote">&gt;&gt; +	push	%rcx</span>
<span class="quote">&gt;&gt; +	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="quote">&gt;&gt; +	rdmsr</span>
<span class="quote">&gt;&gt; +	push	%rdx			/* Save original PAT value */</span>
<span class="quote">&gt;&gt; +	andl	$0xffff00ff, %edx	/* Clear PA5 */</span>
<span class="quote">&gt;&gt; +	orl	$0x00000500, %edx	/* Set PA5 to WP */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Maybe check first whether PA5 is already set correctly and avoid the</span>
<span class="quote">&gt; WRMSR and the restoring below too?</span>

In the overall scheme of things it&#39;s probably not that big a deal when
compared to everything that&#39;s about to happen below.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	wrmsr</span>
<span class="quote">&gt;&gt; +	pop	%rdx			/* RDX contains original PAT value */</span>
<span class="quote">&gt;&gt; +	pop	%rcx</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	movq	%rcx, %r9		/* Save kernel length */</span>
<span class="quote">&gt;&gt; +	movq	%rdi, %r10		/* Save encrypted kernel address */</span>
<span class="quote">&gt;&gt; +	movq	%rsi, %r11		/* Save decrypted kernel address */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	wbinvd				/* Invalidate any cache entries */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Copy/encrypt 2MB at a time */</span>
<span class="quote">&gt;&gt; +1:</span>
<span class="quote">&gt;&gt; +	movq	%r11, %rsi		/* Source - decrypted kernel */</span>
<span class="quote">&gt;&gt; +	movq	%r8, %rdi		/* Dest   - intermediate copy buffer */</span>
<span class="quote">&gt;&gt; +	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="quote">&gt;&gt; +	rep	movsb</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; not movsQ?</span>

The hardware will try to optimize rep movsb into large chunks assuming
things are aligned, sizes are large enough, etc. so we don&#39;t have to
explicitly specify and setup for a rep movsq.

Thanks,
Tom
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	movq	%r8, %rsi		/* Source - intermediate copy buffer */</span>
<span class="quote">&gt;&gt; +	movq	%r10, %rdi		/* Dest   - encrypted kernel */</span>
<span class="quote">&gt;&gt; +	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="quote">&gt;&gt; +	rep	movsb</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	addq	$PMD_PAGE_SIZE, %r11</span>
<span class="quote">&gt;&gt; +	addq	$PMD_PAGE_SIZE, %r10</span>
<span class="quote">&gt;&gt; +	subq	$PMD_PAGE_SIZE, %r9	/* Kernel length decrement */</span>
<span class="quote">&gt;&gt; +	jnz	1b			/* Kernel length not zero? */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Restore PAT register */</span>
<span class="quote">&gt;&gt; +	push	%rdx			/* Save original PAT value */</span>
<span class="quote">&gt;&gt; +	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="quote">&gt;&gt; +	rdmsr</span>
<span class="quote">&gt;&gt; +	pop	%rdx			/* Restore original PAT value */</span>
<span class="quote">&gt;&gt; +	wrmsr</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	ret</span>
<span class="quote">&gt;&gt; +ENDPROC(sme_enc_routine)</span>
<span class="quote">&gt;&gt; +.Lenc_stop:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7500">Borislav Petkov</a> - May 26, 2017, 4:25 p.m.</div>
<pre class="content">
On Thu, May 25, 2017 at 05:24:27PM -0500, Tom Lendacky wrote:
<span class="quote">&gt; I guess I could do that, but this will probably only end up clearing a</span>
<span class="quote">&gt; single PGD entry anyway since it&#39;s highly doubtful the address range</span>
<span class="quote">&gt; would cross a 512GB boundary.</span>

Or you can compute how many 512G-covering, i.e., PGD entries there are
and clear just the right amnount. :^)
<span class="quote">
&gt; I can change the name. As for the use of ENTRY... without the</span>
<span class="quote">&gt; ENTRY/ENDPROC combination I was receiving a warning about a return</span>
<span class="quote">&gt; instruction outside of a callable function. It looks like I can just</span>
<span class="quote">&gt; define the &quot;sme_enc_routine:&quot; label with the ENDPROC and the warning</span>
<span class="quote">&gt; goes away and the global is avoided. It doesn&#39;t like the local labels</span>
<span class="quote">&gt; (.L...) so I&#39;ll use the new name.</span>

Is that warning from objtool or where does it come from?

How do I trigger it locally?
<span class="quote">
&gt; The hardware will try to optimize rep movsb into large chunks assuming</span>
<span class="quote">&gt; things are aligned, sizes are large enough, etc. so we don&#39;t have to</span>
<span class="quote">&gt; explicitly specify and setup for a rep movsq.</span>

I thought the hw does that for movsq too?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - May 30, 2017, 4:39 p.m.</div>
<pre class="content">
On 5/26/2017 11:25 AM, Borislav Petkov wrote:
<span class="quote">&gt; On Thu, May 25, 2017 at 05:24:27PM -0500, Tom Lendacky wrote:</span>
<span class="quote">&gt;&gt; I guess I could do that, but this will probably only end up clearing a</span>
<span class="quote">&gt;&gt; single PGD entry anyway since it&#39;s highly doubtful the address range</span>
<span class="quote">&gt;&gt; would cross a 512GB boundary.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Or you can compute how many 512G-covering, i.e., PGD entries there are</span>
<span class="quote">&gt; and clear just the right amnount. :^)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; I can change the name. As for the use of ENTRY... without the</span>
<span class="quote">&gt;&gt; ENTRY/ENDPROC combination I was receiving a warning about a return</span>
<span class="quote">&gt;&gt; instruction outside of a callable function. It looks like I can just</span>
<span class="quote">&gt;&gt; define the &quot;sme_enc_routine:&quot; label with the ENDPROC and the warning</span>
<span class="quote">&gt;&gt; goes away and the global is avoided. It doesn&#39;t like the local labels</span>
<span class="quote">&gt;&gt; (.L...) so I&#39;ll use the new name.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is that warning from objtool or where does it come from?</span>

Yes, it&#39;s from objtool:

arch/x86/mm/mem_encrypt_boot.o: warning: objtool: .text+0xd2: return 
instruction outside of a callable function
<span class="quote">
&gt; </span>
<span class="quote">&gt; How do I trigger it locally</span>

I think having CONFIG_STACK_VALIDATION=y will trigger it.
<span class="quote">
&gt; </span>
<span class="quote">&gt;&gt; The hardware will try to optimize rep movsb into large chunks assuming</span>
<span class="quote">&gt;&gt; things are aligned, sizes are large enough, etc. so we don&#39;t have to</span>
<span class="quote">&gt;&gt; explicitly specify and setup for a rep movsq.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I thought the hw does that for movsq too?</span>

It does.

Thanks,
Tom
<span class="quote">
&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/mem_encrypt.h b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">index b406df2..8f6f9b4 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mem_encrypt.h</span>
<span class="p_chunk">@@ -31,6 +31,12 @@</span> <span class="p_context"> static inline u64 sme_dma_mask(void)</span>
 	return ((u64)sme_me_mask &lt;&lt; 1) - 1;
 }
 
<span class="p_add">+void sme_encrypt_execute(unsigned long encrypted_kernel_vaddr,</span>
<span class="p_add">+			 unsigned long decrypted_kernel_vaddr,</span>
<span class="p_add">+			 unsigned long kernel_len,</span>
<span class="p_add">+			 unsigned long encryption_wa,</span>
<span class="p_add">+			 unsigned long encryption_pgd);</span>
<span class="p_add">+</span>
 void __init sme_early_encrypt(resource_size_t paddr,
 			      unsigned long size);
 void __init sme_early_decrypt(resource_size_t paddr,
<span class="p_header">diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="p_header">index 9e13841..0633142 100644</span>
<span class="p_header">--- a/arch/x86/mm/Makefile</span>
<span class="p_header">+++ b/arch/x86/mm/Makefile</span>
<span class="p_chunk">@@ -38,3 +38,5 @@</span> <span class="p_context"> obj-$(CONFIG_NUMA_EMU)		+= numa_emulation.o</span>
 obj-$(CONFIG_X86_INTEL_MPX)	+= mpx.o
 obj-$(CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS) += pkeys.o
 obj-$(CONFIG_RANDOMIZE_MEMORY) += kaslr.o
<span class="p_add">+</span>
<span class="p_add">+obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o</span>
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index 30b07a3..0ff41a4 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/bootparam.h&gt;
 #include &lt;asm/cacheflush.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /*
  * Since SME related variables are set early in the boot process they must
<span class="p_chunk">@@ -216,8 +217,269 @@</span> <span class="p_context"> void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
 	set_memory_decrypted((unsigned long)vaddr, size &gt;&gt; PAGE_SHIFT);
 }
 
<span class="p_add">+void __init sme_clear_pgd(pgd_t *pgd_base, unsigned long start,</span>
<span class="p_add">+			  unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long addr = start;</span>
<span class="p_add">+	pgdval_t *pgd_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (addr &lt; end) {</span>
<span class="p_add">+		unsigned long pgd_end;</span>
<span class="p_add">+</span>
<span class="p_add">+		pgd_end = (addr &amp; PGDIR_MASK) + PGDIR_SIZE;</span>
<span class="p_add">+		if (pgd_end &gt; end)</span>
<span class="p_add">+			pgd_end = end;</span>
<span class="p_add">+</span>
<span class="p_add">+		pgd_p = (pgdval_t *)pgd_base + pgd_index(addr);</span>
<span class="p_add">+		*pgd_p = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		addr = pgd_end;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define PGD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define PUD_FLAGS	_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define PMD_FLAGS	(__PAGE_KERNEL_LARGE_EXEC &amp; ~_PAGE_GLOBAL)</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init *sme_populate_pgd(pgd_t *pgd_base, void *pgtable_area,</span>
<span class="p_add">+				     unsigned long vaddr, pmdval_t pmd_val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgdval_t pgd, *pgd_p;</span>
<span class="p_add">+	pudval_t pud, *pud_p;</span>
<span class="p_add">+	pmdval_t pmd, *pmd_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_p = (pgdval_t *)pgd_base + pgd_index(vaddr);</span>
<span class="p_add">+	pgd = *pgd_p;</span>
<span class="p_add">+	if (pgd) {</span>
<span class="p_add">+		pud_p = (pudval_t *)(pgd &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pud_p = pgtable_area;</span>
<span class="p_add">+		memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="p_add">+		pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="p_add">+</span>
<span class="p_add">+		*pgd_p = (pgdval_t)pud_p + PGD_FLAGS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pud_p += pud_index(vaddr);</span>
<span class="p_add">+	pud = *pud_p;</span>
<span class="p_add">+	if (pud) {</span>
<span class="p_add">+		if (pud &amp; _PAGE_PSE)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+		pmd_p = (pmdval_t *)(pud &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pmd_p = pgtable_area;</span>
<span class="p_add">+		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="p_add">+		pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="p_add">+</span>
<span class="p_add">+		*pud_p = (pudval_t)pmd_p + PUD_FLAGS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd_p += pmd_index(vaddr);</span>
<span class="p_add">+	pmd = *pmd_p;</span>
<span class="p_add">+	if (!pmd || !(pmd &amp; _PAGE_PSE))</span>
<span class="p_add">+		*pmd_p = pmd_val;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return pgtable_area;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long __init sme_pgtable_calc(unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pud_tables, pmd_tables;</span>
<span class="p_add">+	unsigned long total = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Perform a relatively simplistic calculation of the pagetable</span>
<span class="p_add">+	 * entries that are needed. That mappings will be covered by 2MB</span>
<span class="p_add">+	 * PMD entries so we can conservatively calculate the required</span>
<span class="p_add">+	 * number of PUD and PMD structures needed to perform the mappings.</span>
<span class="p_add">+	 * Incrementing the count for each covers the case where the</span>
<span class="p_add">+	 * addresses cross entries.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pud_tables = ALIGN(len, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="p_add">+	pud_tables++;</span>
<span class="p_add">+	pmd_tables = ALIGN(len, PUD_SIZE) / PUD_SIZE;</span>
<span class="p_add">+	pmd_tables++;</span>
<span class="p_add">+</span>
<span class="p_add">+	total += pud_tables * sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="p_add">+	total += pmd_tables * sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Now calculate the added pagetable structures needed to populate</span>
<span class="p_add">+	 * the new pagetables.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pud_tables = ALIGN(total, PGDIR_SIZE) / PGDIR_SIZE;</span>
<span class="p_add">+	pmd_tables = ALIGN(total, PUD_SIZE) / PUD_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	total += pud_tables * sizeof(pud_t) * PTRS_PER_PUD;</span>
<span class="p_add">+	total += pmd_tables * sizeof(pmd_t) * PTRS_PER_PMD;</span>
<span class="p_add">+</span>
<span class="p_add">+	return total;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init sme_encrypt_kernel(void)
 {
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	void *pgtable_area;</span>
<span class="p_add">+	unsigned long kernel_start, kernel_end, kernel_len;</span>
<span class="p_add">+	unsigned long workarea_start, workarea_end, workarea_len;</span>
<span class="p_add">+	unsigned long execute_start, execute_end, execute_len;</span>
<span class="p_add">+	unsigned long pgtable_area_len;</span>
<span class="p_add">+	unsigned long decrypted_base;</span>
<span class="p_add">+	unsigned long paddr, pmd_flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sme_active())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prepare for encrypting the kernel by building new pagetables with</span>
<span class="p_add">+	 * the necessary attributes needed to encrypt the kernel in place.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   One range of virtual addresses will map the memory occupied</span>
<span class="p_add">+	 *   by the kernel as encrypted.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   Another range of virtual addresses will map the memory occupied</span>
<span class="p_add">+	 *   by the kernel as decrypted and write-protected.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *     The use of write-protect attribute will prevent any of the</span>
<span class="p_add">+	 *     memory from being cached.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Physical addresses gives us the identity mapped virtual addresses */</span>
<span class="p_add">+	kernel_start = __pa_symbol(_text);</span>
<span class="p_add">+	kernel_end = ALIGN(__pa_symbol(_end), PMD_PAGE_SIZE);</span>
<span class="p_add">+	kernel_len = kernel_end - kernel_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the encryption workarea to be immediately after the kernel */</span>
<span class="p_add">+	workarea_start = kernel_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Calculate required number of workarea bytes needed:</span>
<span class="p_add">+	 *   executable encryption area size:</span>
<span class="p_add">+	 *     stack page (PAGE_SIZE)</span>
<span class="p_add">+	 *     encryption routine page (PAGE_SIZE)</span>
<span class="p_add">+	 *     intermediate copy buffer (PMD_PAGE_SIZE)</span>
<span class="p_add">+	 *   pagetable structures for the encryption of the kernel</span>
<span class="p_add">+	 *   pagetable structures for workarea (in case not currently mapped)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	execute_start = workarea_start;</span>
<span class="p_add">+	execute_end = execute_start + (PAGE_SIZE * 2) + PMD_PAGE_SIZE;</span>
<span class="p_add">+	execute_len = execute_end - execute_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * One PGD for both encrypted and decrypted mappings and a set of</span>
<span class="p_add">+	 * PUDs and PMDs for each of the encrypted and decrypted mappings.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgtable_area_len = sizeof(pgd_t) * PTRS_PER_PGD;</span>
<span class="p_add">+	pgtable_area_len += sme_pgtable_calc(execute_end - kernel_start) * 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PUDs and PMDs needed in the current pagetables for the workarea */</span>
<span class="p_add">+	pgtable_area_len += sme_pgtable_calc(execute_len + pgtable_area_len);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The total workarea includes the executable encryption area and</span>
<span class="p_add">+	 * the pagetable area.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	workarea_len = execute_len + pgtable_area_len;</span>
<span class="p_add">+	workarea_end = workarea_start + workarea_len;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set the address to the start of where newly created pagetable</span>
<span class="p_add">+	 * structures (PGDs, PUDs and PMDs) will be allocated. New pagetable</span>
<span class="p_add">+	 * structures are created when the workarea is added to the current</span>
<span class="p_add">+	 * pagetables and when the new encrypted and decrypted kernel</span>
<span class="p_add">+	 * mappings are populated.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgtable_area = (void *)execute_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the current pagetable structure has entries for</span>
<span class="p_add">+	 * addressing the workarea.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgd = (pgd_t *)native_read_cr3();</span>
<span class="p_add">+	paddr = workarea_start;</span>
<span class="p_add">+	while (paddr &lt; workarea_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr,</span>
<span class="p_add">+						paddr + PMD_FLAGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	native_write_cr3((unsigned long)pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * A new pagetable structure is being built to allow for the kernel</span>
<span class="p_add">+	 * to be encrypted. It starts with an empty PGD that will then be</span>
<span class="p_add">+	 * populated with new PUDs and PMDs as the encrypted and decrypted</span>
<span class="p_add">+	 * kernel mappings are created.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pgd = pgtable_area;</span>
<span class="p_add">+	memset(pgd, 0, sizeof(*pgd) * PTRS_PER_PGD);</span>
<span class="p_add">+	pgtable_area += sizeof(*pgd) * PTRS_PER_PGD;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add encrypted kernel (identity) mappings */</span>
<span class="p_add">+	pmd_flags = PMD_FLAGS | _PAGE_ENC;</span>
<span class="p_add">+	paddr = kernel_start;</span>
<span class="p_add">+	while (paddr &lt; kernel_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr,</span>
<span class="p_add">+						paddr + pmd_flags);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * A different PGD index/entry must be used to get different</span>
<span class="p_add">+	 * pagetable entries for the decrypted mapping. Choose the next</span>
<span class="p_add">+	 * PGD index and convert it to a virtual address to be used as</span>
<span class="p_add">+	 * the base of the mapping.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	decrypted_base = (pgd_index(workarea_end) + 1) &amp; (PTRS_PER_PGD - 1);</span>
<span class="p_add">+	decrypted_base &lt;&lt;= PGDIR_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add decrypted, write-protected kernel (non-identity) mappings */</span>
<span class="p_add">+	pmd_flags = (PMD_FLAGS &amp; ~_PAGE_CACHE_MASK) | (_PAGE_PAT | _PAGE_PWT);</span>
<span class="p_add">+	paddr = kernel_start;</span>
<span class="p_add">+	while (paddr &lt; kernel_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr + decrypted_base,</span>
<span class="p_add">+						paddr + pmd_flags);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add decrypted workarea mappings to both kernel mappings */</span>
<span class="p_add">+	paddr = workarea_start;</span>
<span class="p_add">+	while (paddr &lt; workarea_end) {</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr,</span>
<span class="p_add">+						paddr + PMD_FLAGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		pgtable_area = sme_populate_pgd(pgd, pgtable_area,</span>
<span class="p_add">+						paddr + decrypted_base,</span>
<span class="p_add">+						paddr + PMD_FLAGS);</span>
<span class="p_add">+</span>
<span class="p_add">+		paddr += PMD_PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Perform the encryption */</span>
<span class="p_add">+	sme_encrypt_execute(kernel_start, kernel_start + decrypted_base,</span>
<span class="p_add">+			    kernel_len, workarea_start, (unsigned long)pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * At this point we are running encrypted.  Remove the mappings for</span>
<span class="p_add">+	 * the decrypted areas - all that is needed for this is to remove</span>
<span class="p_add">+	 * the PGD entry/entries.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sme_clear_pgd(pgd, kernel_start + decrypted_base,</span>
<span class="p_add">+		      kernel_end + decrypted_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	sme_clear_pgd(pgd, workarea_start + decrypted_base,</span>
<span class="p_add">+		      workarea_end + decrypted_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush the TLB - no globals so cr3 is enough */</span>
<span class="p_add">+	native_write_cr3(native_read_cr3());</span>
 }
 
 unsigned long __init sme_enable(void)
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt_boot.S b/arch/x86/mm/mem_encrypt_boot.S</span>
new file mode 100644
<span class="p_header">index 0000000..fb58f9f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt_boot.S</span>
<span class="p_chunk">@@ -0,0 +1,151 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * AMD Memory Encryption Support</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor-flags.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr-index.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.code64</span>
<span class="p_add">+ENTRY(sme_encrypt_execute)</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Entry parameters:</span>
<span class="p_add">+	 *   RDI - virtual address for the encrypted kernel mapping</span>
<span class="p_add">+	 *   RSI - virtual address for the decrypted kernel mapping</span>
<span class="p_add">+	 *   RDX - length of kernel</span>
<span class="p_add">+	 *   RCX - virtual address of the encryption workarea, including:</span>
<span class="p_add">+	 *     - stack page (PAGE_SIZE)</span>
<span class="p_add">+	 *     - encryption routine page (PAGE_SIZE)</span>
<span class="p_add">+	 *     - intermediate copy buffer (PMD_PAGE_SIZE)</span>
<span class="p_add">+	 *    R8 - physcial address of the pagetables to use for encryption</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	push	%rbp</span>
<span class="p_add">+	push	%r12</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up a one page stack in the non-encrypted memory area */</span>
<span class="p_add">+	movq	%rsp, %rbp		/* Save current stack pointer */</span>
<span class="p_add">+	movq	%rcx, %rax		/* Workarea stack page */</span>
<span class="p_add">+	movq	%rax, %rsp		/* Set new stack pointer */</span>
<span class="p_add">+	addq	$PAGE_SIZE, %rsp	/* Stack grows from the bottom */</span>
<span class="p_add">+	addq	$PAGE_SIZE, %rax	/* Workarea encryption routine */</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%rdi, %r10		/* Encrypted kernel */</span>
<span class="p_add">+	movq	%rsi, %r11		/* Decrypted kernel */</span>
<span class="p_add">+	movq	%rdx, %r12		/* Kernel length */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Copy encryption routine into the workarea */</span>
<span class="p_add">+	movq	%rax, %rdi		/* Workarea encryption routine */</span>
<span class="p_add">+	leaq	.Lenc_start(%rip), %rsi	/* Encryption routine */</span>
<span class="p_add">+	movq	$(.Lenc_stop - .Lenc_start), %rcx	/* Encryption routine length */</span>
<span class="p_add">+	rep	movsb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Setup registers for call */</span>
<span class="p_add">+	movq	%r10, %rdi		/* Encrypted kernel */</span>
<span class="p_add">+	movq	%r11, %rsi		/* Decrypted kernel */</span>
<span class="p_add">+	movq	%r8, %rdx		/* Pagetables used for encryption */</span>
<span class="p_add">+	movq	%r12, %rcx		/* Kernel length */</span>
<span class="p_add">+	movq	%rax, %r8		/* Workarea encryption routine */</span>
<span class="p_add">+	addq	$PAGE_SIZE, %r8		/* Workarea intermediate copy buffer */</span>
<span class="p_add">+</span>
<span class="p_add">+	call	*%rax			/* Call the encryption routine */</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%rbp, %rsp		/* Restore original stack pointer */</span>
<span class="p_add">+</span>
<span class="p_add">+	pop	%r12</span>
<span class="p_add">+	pop	%rbp</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(sme_encrypt_execute)</span>
<span class="p_add">+</span>
<span class="p_add">+.Lenc_start:</span>
<span class="p_add">+ENTRY(sme_enc_routine)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Routine used to encrypt kernel.</span>
<span class="p_add">+ *   This routine must be run outside of the kernel proper since</span>
<span class="p_add">+ *   the kernel will be encrypted during the process. So this</span>
<span class="p_add">+ *   routine is defined here and then copied to an area outside</span>
<span class="p_add">+ *   of the kernel where it will remain and run decrypted</span>
<span class="p_add">+ *   during execution.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   On entry the registers must be:</span>
<span class="p_add">+ *     RDI - virtual address for the encrypted kernel mapping</span>
<span class="p_add">+ *     RSI - virtual address for the decrypted kernel mapping</span>
<span class="p_add">+ *     RDX - address of the pagetables to use for encryption</span>
<span class="p_add">+ *     RCX - length of kernel</span>
<span class="p_add">+ *      R8 - intermediate copy buffer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *     RAX - points to this routine</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The kernel will be encrypted by copying from the non-encrypted</span>
<span class="p_add">+ * kernel space to an intermediate buffer and then copying from the</span>
<span class="p_add">+ * intermediate buffer back to the encrypted kernel space. The physical</span>
<span class="p_add">+ * addresses of the two kernel space mappings are the same which</span>
<span class="p_add">+ * results in the kernel being encrypted &quot;in place&quot;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+	/* Enable the new page tables */</span>
<span class="p_add">+	mov	%rdx, %cr3</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush any global TLBs */</span>
<span class="p_add">+	mov	%cr4, %rdx</span>
<span class="p_add">+	andq	$~X86_CR4_PGE, %rdx</span>
<span class="p_add">+	mov	%rdx, %cr4</span>
<span class="p_add">+	orq	$X86_CR4_PGE, %rdx</span>
<span class="p_add">+	mov	%rdx, %cr4</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the PAT register PA5 entry to write-protect */</span>
<span class="p_add">+	push	%rcx</span>
<span class="p_add">+	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="p_add">+	rdmsr</span>
<span class="p_add">+	push	%rdx			/* Save original PAT value */</span>
<span class="p_add">+	andl	$0xffff00ff, %edx	/* Clear PA5 */</span>
<span class="p_add">+	orl	$0x00000500, %edx	/* Set PA5 to WP */</span>
<span class="p_add">+	wrmsr</span>
<span class="p_add">+	pop	%rdx			/* RDX contains original PAT value */</span>
<span class="p_add">+	pop	%rcx</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%rcx, %r9		/* Save kernel length */</span>
<span class="p_add">+	movq	%rdi, %r10		/* Save encrypted kernel address */</span>
<span class="p_add">+	movq	%rsi, %r11		/* Save decrypted kernel address */</span>
<span class="p_add">+</span>
<span class="p_add">+	wbinvd				/* Invalidate any cache entries */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Copy/encrypt 2MB at a time */</span>
<span class="p_add">+1:</span>
<span class="p_add">+	movq	%r11, %rsi		/* Source - decrypted kernel */</span>
<span class="p_add">+	movq	%r8, %rdi		/* Dest   - intermediate copy buffer */</span>
<span class="p_add">+	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="p_add">+	rep	movsb</span>
<span class="p_add">+</span>
<span class="p_add">+	movq	%r8, %rsi		/* Source - intermediate copy buffer */</span>
<span class="p_add">+	movq	%r10, %rdi		/* Dest   - encrypted kernel */</span>
<span class="p_add">+	movq	$PMD_PAGE_SIZE, %rcx	/* 2MB length */</span>
<span class="p_add">+	rep	movsb</span>
<span class="p_add">+</span>
<span class="p_add">+	addq	$PMD_PAGE_SIZE, %r11</span>
<span class="p_add">+	addq	$PMD_PAGE_SIZE, %r10</span>
<span class="p_add">+	subq	$PMD_PAGE_SIZE, %r9	/* Kernel length decrement */</span>
<span class="p_add">+	jnz	1b			/* Kernel length not zero? */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore PAT register */</span>
<span class="p_add">+	push	%rdx			/* Save original PAT value */</span>
<span class="p_add">+	movl	$MSR_IA32_CR_PAT, %ecx</span>
<span class="p_add">+	rdmsr</span>
<span class="p_add">+	pop	%rdx			/* Restore original PAT value */</span>
<span class="p_add">+	wrmsr</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(sme_enc_routine)</span>
<span class="p_add">+.Lenc_stop:</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



