
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,5/6] iommu/mediatek: Add mt8173 IOMMU driver - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,5/6] iommu/mediatek: Add mt8173 IOMMU driver</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=123111">Yong Wu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 15, 2015, 9:43 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1431683009-18158-6-git-send-email-yong.wu@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6413221/mbox/"
   >mbox</a>
|
   <a href="/patch/6413221/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6413221/">/patch/6413221/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id DE4C3C0432
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 15 May 2015 09:45:29 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 366AE20444
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 15 May 2015 09:45:28 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id B09672041E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 15 May 2015 09:45:21 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754987AbbEOJpM (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 15 May 2015 05:45:12 -0400
Received: from mailgw02.mediatek.com ([210.61.82.184]:51680 &quot;EHLO
	mailgw02.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S1753429AbbEOJoQ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 15 May 2015 05:44:16 -0400
X-Listener-Flag: 11101
Received: from mtkhts09.mediatek.inc [(172.21.101.70)] by
	mailgw02.mediatek.com (envelope-from &lt;yong.wu@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 121100196; Fri, 15 May 2015 17:44:14 +0800
Received: from localhost.localdomain (10.17.3.153) by mtkhts09.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.181.6;
	Fri, 15 May 2015 17:44:13 +0800
From: Yong Wu &lt;yong.wu@mediatek.com&gt;
To: Rob Herring &lt;robh+dt@kernel.org&gt;, Joerg Roedel &lt;joro@8bytes.org&gt;,
	Matthias Brugger &lt;matthias.bgg@gmail.com&gt;
CC: Robin Murphy &lt;robin.murphy@arm.com&gt;, Will Deacon &lt;will.deacon@arm.com&gt;,
	Daniel Kurtz &lt;djkurtz@google.com&gt;, Tomasz Figa &lt;tfiga@google.com&gt;,
	Lucas Stach &lt;l.stach@pengutronix.de&gt;,
	Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	&lt;linux-mediatek@lists.infradead.org&gt;,
	Sasha Hauer &lt;kernel@pengutronix.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;, &lt;pebolle@tiscali.nl&gt;,
	&lt;arnd@arndb.de&gt;, &lt;mitchelh@codeaurora.org&gt;, &lt;k.zhang@mediatek.com&gt;,
	&lt;youhua.li@mediatek.com&gt;, Yong Wu &lt;yong.wu@mediatek.com&gt;
Subject: [PATCH v2 5/6] iommu/mediatek: Add mt8173 IOMMU driver
Date: Fri, 15 May 2015 17:43:28 +0800
Message-ID: &lt;1431683009-18158-6-git-send-email-yong.wu@mediatek.com&gt;
X-Mailer: git-send-email 1.8.1.1.dirty
In-Reply-To: &lt;1431683009-18158-1-git-send-email-yong.wu@mediatek.com&gt;
References: &lt;1431683009-18158-1-git-send-email-yong.wu@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - May 15, 2015, 9:43 a.m.</div>
<pre class="content">
This patch adds support for mediatek m4u (MultiMedia Memory Management Unit).
<span class="signed-off-by">
Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig     |  11 +
 drivers/iommu/Makefile    |   1 +
 drivers/iommu/mtk_iommu.c | 657 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 669 insertions(+)
 create mode 100644 drivers/iommu/mtk_iommu.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=122981">Tomasz Figa</a> - May 25, 2015, 8:29 a.m.</div>
<pre class="content">
Hi,

Please see my comments inline.

On Fri, May 15, 2015 at 6:43 PM, Yong Wu &lt;yong.wu@mediatek.com&gt; wrote:
[snip]
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct mtk_iommu_info {</span>
<span class="quote">&gt; +       void __iomem            *base;</span>
<span class="quote">&gt; +       int                     irq;</span>
<span class="quote">&gt; +       struct device           *dev;</span>
<span class="quote">&gt; +       struct device           *larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="quote">&gt; +       struct clk              *bclk;</span>
<span class="quote">&gt; +       dma_addr_t              protect_base; /* protect memory base */</span>
<span class="quote">&gt; +       unsigned int            larb_nr;      /* local arbiter number */</span>
<span class="quote">&gt; +       unsigned int            larb_portid_base[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="quote">&gt; +                               /* the port id base for each local arbiter */</span>

It might not be a bad idea to convert this kind of comments into a
proper kerneldoc comment for the whole struct. Similarly for other
structs in the driver.

[snip]
<span class="quote">
&gt; +static void mtk_iommu_clear_intr(void __iomem *m4u_base)</span>

nit: Instead of pasing m4u_base here, could you pass a pointer to the
mtk_iommu_info here and use its base field? This would be more strict,
because currently a void pointer permits passing anything to this
function.
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +       u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = readl(m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +       val |= F_INT_L2_CLR_BIT;</span>
<span class="quote">&gt; +       writel(val, m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +       u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="quote">&gt; +       writel(val, domain-&gt;imuinfo-&gt;base + REG_MMU_INV_SEL);</span>

nit: Do you need this val variable?
<span class="quote">
&gt; +       writel(F_ALL_INVLD, domain-&gt;imuinfo-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="quote">&gt; +                                   bool leaf, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +       void __iomem *m4u_base = domain-&gt;imuinfo-&gt;base;</span>
<span class="quote">&gt; +       unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +       u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="quote">&gt; +       writel(val, m4u_base + REG_MMU_INV_SEL);</span>

nit: Does this write need to go through this val variable?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       writel(iova_start, m4u_base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; +       writel(iova_end, m4u_base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; +       writel(F_MMU_INV_RANGE, m4u_base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = readl_poll_timeout_atomic(m4u_base + REG_MMU_CPE_DONE, val,</span>
<span class="quote">&gt; +                                       val != 0, 10, 1000000);</span>
<span class="quote">&gt; +       if (ret) {</span>
<span class="quote">&gt; +               dev_warn(domain-&gt;imuinfo-&gt;dev, &quot;Invalid tlb don&#39;t done\n&quot;);</span>

Maybe &quot;Partial TLB flush timed out, falling back to full flush\n&quot;?
<span class="quote">
&gt; +               mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       writel(0, m4u_base + REG_MMU_CPE_DONE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       /*</span>
<span class="quote">&gt; +        * After delete arch_setup_dma_ops,</span>
<span class="quote">&gt; +        * This will be replaced with dma_map_page</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +        __dma_flush_range(ptr, ptr + size);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="quote">&gt; +       .tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="quote">&gt; +       .tlb_add_flush = mtk_iommu_tlb_add_flush,</span>
<span class="quote">&gt; +       .tlb_sync = mtk_iommu_tlb_flush_all,</span>
<span class="quote">&gt; +       .flush_pgtable = mtk_iommu_flush_pgtable,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *mtkdomain = dev_id;</span>
<span class="quote">&gt; +       struct mtk_iommu_info *piommu = mtkdomain-&gt;imuinfo;</span>
<span class="quote">&gt; +       struct device *dev = piommu-&gt;dev;</span>
<span class="quote">&gt; +       void __iomem *m4u_base = piommu-&gt;base;</span>
<span class="quote">&gt; +       u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="quote">&gt; +       unsigned int fault_larb, fault_port;</span>
<span class="quote">&gt; +       bool layer, write;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       int_state = readl(m4u_base + REG_MMU_FAULT_ST1);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* read error info from registers */</span>
<span class="quote">&gt; +       fault_iova = readl(m4u_base + REG_MMU_FAULT_VA);</span>
<span class="quote">&gt; +       layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="quote">&gt; +       write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="quote">&gt; +       fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="quote">&gt; +       fault_pa = readl(m4u_base + REG_MMU_INVLD_PA);</span>
<span class="quote">&gt; +       regval = readl(m4u_base + REG_MMU_INT_ID);</span>
<span class="quote">&gt; +       fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="quote">&gt; +       fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       report_iommu_fault(&amp;mtkdomain-&gt;domain, dev, fault_iova,</span>
<span class="quote">&gt; +                          write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (int_state &amp; F_INT_TRANSLATION_FAULT) {</span>
<span class="quote">&gt; +               dev_err_ratelimited(</span>
<span class="quote">&gt; +                       dev,</span>
<span class="quote">&gt; +                       &quot;fault:iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="quote">&gt; +                       fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="quote">&gt; +                       layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (int_state &amp; F_INT_MAIN_MULTI_HIT_FAULT)</span>
<span class="quote">&gt; +               dev_err_ratelimited(dev,</span>
<span class="quote">&gt; +                                   &quot;multi-hit!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; +                                   fault_iova, fault_larb, fault_port);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (int_state &amp; F_INT_INVALID_PA_FAULT) {</span>
<span class="quote">&gt; +               if (!(int_state &amp; F_INT_TRANSLATION_FAULT))</span>
<span class="quote">&gt; +                       dev_err_ratelimited(</span>
<span class="quote">&gt; +                               dev,</span>
<span class="quote">&gt; +                               &quot;invalid pa!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; +                               fault_iova, fault_larb, fault_port);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       if (int_state &amp; F_INT_ENTRY_REPLACEMENT_FAULT)</span>
<span class="quote">&gt; +               dev_err_ratelimited(dev,</span>
<span class="quote">&gt; +                                   &quot;replace-fault!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; +                                   fault_iova, fault_larb, fault_port);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (int_state &amp; F_INT_TLB_MISS_FAULT)</span>
<span class="quote">&gt; +               dev_err_ratelimited(dev,</span>
<span class="quote">&gt; +                                   &quot;tlb miss-fault!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; +                                   fault_iova, fault_larb, fault_port);</span>

Hmm, do you need so many prints here? Could you just dump the full
state (including int_state) regardless of interrupt type here? Also I
wonder if this shouldn&#39;t be printed only when report_iommu_fault()
returns -ENOSYS.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       mtk_iommu_tlb_flush_all(mtkdomain);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       mtk_iommu_clear_intr(m4u_base);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return IRQ_HANDLED;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="quote">&gt; +                             struct mtk_iommu_info *piommu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +       struct device_node *ofnode;</span>
<span class="quote">&gt; +       struct resource *res;</span>
<span class="quote">&gt; +       unsigned int i, port_nr, lastportnr = 0;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ofnode = dev-&gt;of_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="quote">&gt; +       piommu-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="quote">&gt; +       if (IS_ERR(piommu-&gt;base)) {</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to get base (%lx)\n&quot;,</span>
<span class="quote">&gt; +                       PTR_ERR(piommu-&gt;base));</span>

devm_ioremap_resource() already prints a message on error.
<span class="quote">
&gt; +               ret = PTR_ERR(piommu-&gt;base);</span>
<span class="quote">&gt; +               goto err_parse_dt;</span>

You can just return PTR_ERR(piommu-&gt;base) here directly.
<span class="quote">
&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       piommu-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="quote">&gt; +       if (piommu-&gt;irq &lt; 0) {</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to get IRQ (%d)\n&quot;, piommu-&gt;irq);</span>
<span class="quote">&gt; +               ret = piommu-&gt;irq;</span>
<span class="quote">&gt; +               goto err_parse_dt;</span>

Again just return.
<span class="quote">
&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       piommu-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="quote">&gt; +       if (IS_ERR(piommu-&gt;bclk)) {</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to get the bclk (%lx)\n&quot;,</span>
<span class="quote">&gt; +                       PTR_ERR(piommu-&gt;bclk));</span>
<span class="quote">&gt; +               ret = PTR_ERR(piommu-&gt;bclk);</span>
<span class="quote">&gt; +               goto err_parse_dt;</span>

Ditto.
<span class="quote">
&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = of_property_count_u32_elems(ofnode, &quot;larb-portes-nr&quot;);</span>

According to my comments to the patch adding the binding, you should
rather count the number of phandles in &quot;larb&quot; property by
of_count_phandle_with_args(ofnode, &quot;larb&quot;, NULL).
<span class="quote">
&gt; +       if (ret &lt; 0) {</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to get larb-portes-nr\n&quot;);</span>
<span class="quote">&gt; +               goto err_parse_dt;</span>

Ditto.
<span class="quote">
&gt; +       } else {</span>
<span class="quote">&gt; +               piommu-&gt;larb_nr = ret;</span>

You can take this out of &quot;else&quot; block.
<span class="quote">
&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; piommu-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; +               ret = of_property_read_u32_index(ofnode, &quot;larb-portes-nr&quot;,</span>
<span class="quote">&gt; +                                                i, &amp;port_nr);</span>

For logical correctness, you should parse port count from larb node,
as I mentioned in my comments to the patch adding the binding. However
I&#39;m not sure if you even need to know the number of ports. I will
comment more on this below.
<span class="quote">
&gt; +               if (ret) {</span>
<span class="quote">&gt; +                       dev_err(dev, &quot;Failed to get the port nr@larb%d\n&quot;, i);</span>
<span class="quote">&gt; +                       goto err_parse_dt;</span>

Just return here.
<span class="quote">
&gt; +               } else {</span>
<span class="quote">
&gt; +                       piommu-&gt;larb_portid_base[i] = lastportnr;</span>
<span class="quote">&gt; +                       lastportnr += port_nr;</span>

This looks like creating an artificial 1-dimensional namespace from a
natural 2-dimensional space indexed by (larb, port) tuple.

Also you can take this out of the else block.
<span class="quote">
&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       piommu-&gt;larb_portid_base[i] = lastportnr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; piommu-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; +               struct device_node *larbnode;</span>
<span class="quote">&gt; +               struct platform_device *plarbdev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               larbnode = of_parse_phandle(ofnode, &quot;larb&quot;, i);</span>
<span class="quote">&gt; +               if (!larbnode) {</span>
<span class="quote">&gt; +                       dev_err(dev, &quot;Failed to get the larb property\n&quot;);</span>
<span class="quote">&gt; +                       ret = -EINVAL;</span>
<span class="quote">&gt; +                       goto err_parse_dt;</span>

Just return.
<span class="quote">
&gt; +               }</span>
<span class="quote">&gt; +               plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; +               of_node_put(larbnode);</span>
<span class="quote">&gt; +               if (!plarbdev) {</span>
<span class="quote">&gt; +                       dev_err(dev, &quot;Failed to get the dev@larb%d\n&quot;, i);</span>
<span class="quote">&gt; +                       ret = -EINVAL;</span>
<span class="quote">&gt; +                       goto err_parse_dt;</span>

Just return.
<span class="quote">
&gt; +               } else {</span>
<span class="quote">&gt; +                       piommu-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>

Again, no need to put this into else block.
<span class="quote">
&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_parse_dt:</span>
<span class="quote">&gt; +       return ret;</span>

Now, after addressing my comments above, this label can be removed.
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdomain)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_info *piommu = mtkdomain-&gt;imuinfo;</span>
<span class="quote">&gt; +       void __iomem *m4u_base = piommu-&gt;base;</span>
<span class="quote">&gt; +       u32 regval;</span>
<span class="quote">&gt; +       int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = clk_prepare_enable(piommu-&gt;bclk);</span>
<span class="quote">&gt; +       if (ret)</span>
<span class="quote">&gt; +               return -ENODEV;</span>

Why overriding the error returned in ret with -ENODEV?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       writel(mtkdomain-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="quote">&gt; +              m4u_base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; +               F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="quote">&gt; +               F_COHERENCE_EN;</span>
<span class="quote">&gt; +       writel(regval, m4u_base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       regval = F_L2_MULIT_HIT_EN |</span>
<span class="quote">&gt; +               F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="quote">&gt; +               F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; +               F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; +               F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="quote">&gt; +               F_MISS_FIFO_ERR_INT_EN;</span>
<span class="quote">&gt; +       writel(regval, m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       regval = F_INT_TRANSLATION_FAULT |</span>
<span class="quote">&gt; +               F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="quote">&gt; +               F_INT_INVALID_PA_FAULT |</span>
<span class="quote">&gt; +               F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="quote">&gt; +               F_INT_TLB_MISS_FAULT |</span>
<span class="quote">&gt; +               F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="quote">&gt; +               F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="quote">&gt; +       writel(regval, m4u_base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       regval = ALIGN(piommu-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="quote">&gt; +       regval = (u32)F_MMU_IVRP_PA_SET(regval);</span>
<span class="quote">&gt; +       writel(regval, m4u_base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       writel(0, m4u_base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +       writel(0, m4u_base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (devm_request_irq(piommu-&gt;dev, piommu-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; +                            dev_name(piommu-&gt;dev), (void *)mtkdomain)) {</span>
<span class="quote">&gt; +               dev_err(piommu-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, piommu-&gt;irq);</span>
<span class="quote">&gt; +               return -ENODEV;</span>

Hmm, this keeps the clock enabled. Should you add clean-up path
uninitializing the hardware and stopping the clock?
<span class="quote">
&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_config_port(struct mtk_iommu_info *piommu,</span>
<span class="quote">&gt; +                                int portid, bool iommuen)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       bool validlarb = false;</span>
<span class="quote">&gt; +       int i, larbid, larbportid;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (portid &gt;= piommu-&gt;larb_portid_base[piommu-&gt;larb_nr]) {</span>
<span class="quote">&gt; +               dev_err(piommu-&gt;dev, &quot;Invalid portid (%d)\n&quot;, portid);</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = piommu-&gt;larb_nr - 1; i &gt;= 0; i--) {</span>
<span class="quote">&gt; +               if (portid &gt;= piommu-&gt;larb_portid_base[i]) {</span>
<span class="quote">&gt; +                       larbid = i;</span>
<span class="quote">&gt; +                       larbportid = portid -</span>
<span class="quote">&gt; +                                       piommu-&gt;larb_portid_base[i];</span>
<span class="quote">&gt; +                       validlarb = true;</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>

There would be no need for this magic here if two cells was used for
port specifier in DT. By the way, this function seems to be the only
user of port count, so if you don&#39;t strictly need the check for port
specifier being in range, then such information could be simply
removed from DT, simplifying the binding.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       if (validlarb) {</span>
<span class="quote">&gt; +               ret = mtk_smi_config_port(piommu-&gt;larbdev[larbid],</span>
<span class="quote">&gt; +                                         larbportid, iommuen);</span>
<span class="quote">&gt; +               if (ret) {</span>
<span class="quote">&gt; +                       dev_err(piommu-&gt;dev,</span>
<span class="quote">&gt; +                               &quot;Failed to config port portid-%d\n&quot;, portid);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; +               dev_err(piommu-&gt;dev, &quot;Failed to find out portid-%d\n&quot;, portid);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_dev_enable_iommu(struct mtk_iommu_info *imuinfo,</span>
<span class="quote">&gt; +                                     struct device *dev, bool enable)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct of_phandle_args out_args = {0};</span>
<span class="quote">&gt; +       struct device *imudev = imuinfo-&gt;dev;</span>
<span class="quote">&gt; +       unsigned int i = 0;</span>
<span class="quote">&gt; +       int ret = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="quote">&gt; +                                          &quot;#iommu-cells&quot;, i++, &amp;out_args)) {</span>
<span class="quote">&gt; +               if (out_args.np != imudev-&gt;of_node)</span>
<span class="quote">&gt; +                       continue;</span>
<span class="quote">&gt; +               if (out_args.args_count != 1) {</span>
<span class="quote">&gt; +                       dev_err(imudev,</span>
<span class="quote">&gt; +                               &quot;invalid #iommu-cells property for IOMMU\n&quot;);</span>
<span class="quote">&gt; +               }</span>

I don&#39;t believe you need to do this manually. I can see
of_iommu_configure() in
http://lxr.free-electrons.com/source/drivers/iommu/of_iommu.c#L136 ,
which I believe should call .of_xlate from your iommu_ops with correct
node and verified the args count. This callback should parse the args
and prepare some private data.

I don&#39;t see any example of such .of_xlate callback though. Could
someone (Joerg, Will?) advise how this could be used and in particular
how the data obtained from parsing the args should be stored for
further use?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +               dev_dbg(imudev, &quot;%s iommu @ port:%d\n&quot;,</span>
<span class="quote">&gt; +                       enable ? &quot;enable&quot; : &quot;disable&quot;, out_args.args[0]);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               ret = mtk_iommu_config_port(imuinfo, out_args.args[0], enable);</span>
<span class="quote">&gt; +               if (!ret)</span>
<span class="quote">&gt; +                       dev-&gt;archdata.dma_ops = (enable) ?</span>
<span class="quote">&gt; +                                       imudev-&gt;archdata.dma_ops : NULL;</span>
<span class="quote">&gt; +               else</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* We only support unmanaged domains for now */</span>
<span class="quote">&gt; +       if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!priv)</span>
<span class="quote">&gt; +               return ERR_PTR(-ENOMEM);</span>

What&#39;s the proper return convention of this function? The first error
case returns NULL, while this an error pointer. One of them is most
likely wrong.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       priv-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS;</span>
<span class="quote">&gt; +       priv-&gt;cfg.pgsize_bitmap = SZ_16M | SZ_1M | SZ_64K | SZ_4K,</span>
<span class="quote">&gt; +       priv-&gt;cfg.ias = 32;</span>
<span class="quote">&gt; +       priv-&gt;cfg.oas = 32;</span>
<span class="quote">&gt; +       priv-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       priv-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;priv-&gt;cfg, priv);</span>
<span class="quote">&gt; +       if (!priv-&gt;iop) {</span>
<span class="quote">&gt; +               pr_err(&quot;Failed to alloc io pgtable@MTK iommu\n&quot;);</span>
<span class="quote">&gt; +               goto err_free_priv;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       spin_lock_init(&amp;priv-&gt;pgtlock);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="quote">&gt; +       priv-&gt;domain.geometry.aperture_end = ~0;</span>

Should this be UL or ULL?
<span class="quote">
&gt; +       priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return &amp;priv-&gt;domain;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_free_priv:</span>
<span class="quote">&gt; +       kfree(priv);</span>
<span class="quote">&gt; +       return NULL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       free_io_pgtable_ops(priv-&gt;iop);</span>
<span class="quote">&gt; +       kfree(priv);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +                                  struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* word around for arch_setup_dma_ops */</span>

typo: s/word around/Workaround/

Anyway, could you remind me what was the issue with arch_setup_dma_ops, please?
<span class="quote">
&gt; +       if (!priv-&gt;imuinfo)</span>
<span class="quote">&gt; +               ret = 0;</span>
<span class="quote">&gt; +       else</span>
<span class="quote">&gt; +               ret = mtk_iommu_dev_enable_iommu(priv-&gt;imuinfo, dev, true);</span>
<span class="quote">&gt; +       return ret;</span>

Maybe you could rewrite the 5 lines above into the following:

if (!priv-&gt;imuinfo)
    return 0;
return mtk_iommu_dev_enable_iommu(priv-&gt;imuinfo, dev, true);
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +                                   struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       mtk_iommu_dev_enable_iommu(priv-&gt;imuinfo, dev, false);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt; +                        phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; +       unsigned long flags;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +       ret = priv-&gt;iop-&gt;map(priv-&gt;iop, iova, paddr, size, prot);</span>
<span class="quote">&gt; +       spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="quote">&gt; +                             unsigned long iova, size_t size)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; +       unsigned long flags;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +       priv-&gt;iop-&gt;unmap(priv-&gt;iop, iova, size);</span>
<span class="quote">&gt; +       spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return size;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="quote">&gt; +                                         dma_addr_t iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; +       unsigned long flags;</span>
<span class="quote">&gt; +       phys_addr_t pa;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +       pa = priv-&gt;iop-&gt;iova_to_phys(priv-&gt;iop, iova);</span>
<span class="quote">&gt; +       spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return pa;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_ops mtk_iommu_ops = {</span>
<span class="quote">&gt; +       .domain_alloc = mtk_iommu_domain_alloc,</span>
<span class="quote">&gt; +       .domain_free = mtk_iommu_domain_free,</span>
<span class="quote">&gt; +       .attach_dev = mtk_iommu_attach_device,</span>
<span class="quote">&gt; +       .detach_dev = mtk_iommu_detach_device,</span>
<span class="quote">&gt; +       .map = mtk_iommu_map,</span>
<span class="quote">&gt; +       .unmap = mtk_iommu_unmap,</span>
<span class="quote">&gt; +       .map_sg = default_iommu_map_sg,</span>
<span class="quote">&gt; +       .iova_to_phys = mtk_iommu_iova_to_phys,</span>
<span class="quote">&gt; +       .pgsize_bitmap = SZ_4K | SZ_64K | SZ_1M | SZ_16M,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="quote">&gt; +       { .compatible = &quot;mediatek,mt8173-m4u&quot;,</span>
<span class="quote">&gt; +       },</span>

nit: Why is this on a separate line?
<span class="quote">
&gt; +       {}</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct iommu_domain     *domain;</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *mtk_domain;</span>
<span class="quote">&gt; +       struct mtk_iommu_info   *piommu;</span>
<span class="quote">&gt; +       void __iomem            *protect;</span>
<span class="quote">&gt; +       int                     ret;</span>

CodingStyle: Please no tabs in local variable declarations.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       piommu = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*piommu), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!piommu)</span>
<span class="quote">&gt; +               return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       piommu-&gt;dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /*</span>
<span class="quote">&gt; +        * Alloc for Protect memory.</span>
<span class="quote">&gt; +        * HW will access here while translation fault.</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       protect = devm_kzalloc(piommu-&gt;dev, MTK_PROTECT_PA_ALIGN * 2,</span>
<span class="quote">&gt; +                              GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!protect)</span>
<span class="quote">&gt; +               return -ENOMEM;</span>
<span class="quote">&gt; +       piommu-&gt;protect_base = dma_map_single(piommu-&gt;dev, protect,</span>
<span class="quote">&gt; +                                             MTK_PROTECT_PA_ALIGN * 2,</span>
<span class="quote">&gt; +                                             DMA_TO_DEVICE); /* clean cache */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = mtk_iommu_parse_dt(pdev, piommu);</span>
<span class="quote">&gt; +       if (ret)</span>
<span class="quote">&gt; +               return ret;</span>

What about the potential dma mapping created by dma_map_single()? (I&#39;m
not sure how important is to clean this up in practice, but for
consistency, it should be handled in error path to prevent leaking
memory if something changes in future in DMA API internals.)
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       /*</span>
<span class="quote">&gt; +        * arch_setup_dma_ops is not proper.</span>
<span class="quote">&gt; +        * It should be replaced it with iommu_dma_create_domain</span>
<span class="quote">&gt; +        * in next dma patch.</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +       arch_setup_dma_ops(piommu-&gt;dev, 0, (1ULL &lt;&lt; 32) - 1, &amp;mtk_iommu_ops, 0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       domain = iommu_dma_raw_domain(get_dma_domain(piommu-&gt;dev));</span>
<span class="quote">&gt; +       if (!domain) {</span>
<span class="quote">&gt; +               dev_err(piommu-&gt;dev, &quot;Failed to get iommu domain\n&quot;);</span>
<span class="quote">&gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; +               goto err_free_domain;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       mtk_domain = to_mtk_domain(domain);</span>
<span class="quote">&gt; +       mtk_domain-&gt;imuinfo = piommu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       dev_set_drvdata(piommu-&gt;dev, piommu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = mtk_iommu_hw_init(mtk_domain);</span>
<span class="quote">&gt; +       if (ret &lt; 0) {</span>
<span class="quote">&gt; +               dev_err(piommu-&gt;dev, &quot;Failed @ HW init\n&quot;);</span>

nit: Maybe &quot;Hardware initialization failed&quot;?
<span class="quote">
&gt; +               goto err_free_domain;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_free_domain:</span>
<span class="quote">&gt; +       arch_teardown_dma_ops(piommu-&gt;dev);</span>

Shouldn&#39;t the label be called err_teardown_dma_ops then?

Best regards,
Tomasz
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - May 27, 2015, 7:26 a.m.</div>
<pre class="content">
Hi Tomasz,
    Thanks. please help check my comments.
    The others I will change in next version.

On Mon, 2015-05-25 at 17:29 +0900, Tomasz Figa wrote:
<span class="quote">&gt; Hi,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Please see my comments inline.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Fri, May 15, 2015 at 6:43 PM, Yong Wu &lt;yong.wu@mediatek.com&gt; wrote:</span>
<span class="quote">&gt; [snip]</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct mtk_iommu_info {</span>
<span class="quote">&gt; &gt; +       void __iomem            *base;</span>
<span class="quote">&gt; &gt; +       int                     irq;</span>
<span class="quote">&gt; &gt; +       struct device           *dev;</span>
<span class="quote">&gt; &gt; +       struct device           *larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="quote">&gt; &gt; +       struct clk              *bclk;</span>
<span class="quote">&gt; &gt; +       dma_addr_t              protect_base; /* protect memory base */</span>
<span class="quote">&gt; &gt; +       unsigned int            larb_nr;      /* local arbiter number */</span>
<span class="quote">&gt; &gt; +       unsigned int            larb_portid_base[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="quote">&gt; &gt; +                               /* the port id base for each local arbiter */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It might not be a bad idea to convert this kind of comments into a</span>
<span class="quote">&gt; proper kerneldoc comment for the whole struct. Similarly for other</span>
<span class="quote">&gt; structs in the driver.</span>
Yes. I will delete larb_portid_base if iommu-cells is 2.
<span class="quote">&gt; </span>
<span class="quote">&gt; [snip]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +static void mtk_iommu_clear_intr(void __iomem *m4u_base)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; nit: Instead of pasing m4u_base here, could you pass a pointer to the</span>
<span class="quote">&gt; mtk_iommu_info here and use its base field? This would be more strict,</span>
<span class="quote">&gt; because currently a void pointer permits passing anything to this</span>
<span class="quote">&gt; function.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       u32 val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       val = readl(m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +       val |= F_INT_L2_CLR_BIT;</span>
<span class="quote">&gt; &gt; +       writel(val, m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +       u32 val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="quote">&gt; &gt; +       writel(val, domain-&gt;imuinfo-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; nit: Do you need this val variable?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       writel(F_ALL_INVLD, domain-&gt;imuinfo-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="quote">&gt; &gt; +                                   bool leaf, void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +       void __iomem *m4u_base = domain-&gt;imuinfo-&gt;base;</span>
<span class="quote">&gt; &gt; +       unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +       u32 val;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="quote">&gt; &gt; +       writel(val, m4u_base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; nit: Does this write need to go through this val variable?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       writel(iova_start, m4u_base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; &gt; +       writel(iova_end, m4u_base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; &gt; +       writel(F_MMU_INV_RANGE, m4u_base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = readl_poll_timeout_atomic(m4u_base + REG_MMU_CPE_DONE, val,</span>
<span class="quote">&gt; &gt; +                                       val != 0, 10, 1000000);</span>
<span class="quote">&gt; &gt; +       if (ret) {</span>
<span class="quote">&gt; &gt; +               dev_warn(domain-&gt;imuinfo-&gt;dev, &quot;Invalid tlb don&#39;t done\n&quot;);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Maybe &quot;Partial TLB flush timed out, falling back to full flush\n&quot;?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +       writel(0, m4u_base + REG_MMU_CPE_DONE);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       /*</span>
<span class="quote">&gt; &gt; +        * After delete arch_setup_dma_ops,</span>
<span class="quote">&gt; &gt; +        * This will be replaced with dma_map_page</span>
<span class="quote">&gt; &gt; +        */</span>
<span class="quote">&gt; &gt; +        __dma_flush_range(ptr, ptr + size);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="quote">&gt; &gt; +       .tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="quote">&gt; &gt; +       .tlb_add_flush = mtk_iommu_tlb_add_flush,</span>
<span class="quote">&gt; &gt; +       .tlb_sync = mtk_iommu_tlb_flush_all,</span>
<span class="quote">&gt; &gt; +       .flush_pgtable = mtk_iommu_flush_pgtable,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *mtkdomain = dev_id;</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_info *piommu = mtkdomain-&gt;imuinfo;</span>
<span class="quote">&gt; &gt; +       struct device *dev = piommu-&gt;dev;</span>
<span class="quote">&gt; &gt; +       void __iomem *m4u_base = piommu-&gt;base;</span>
<span class="quote">&gt; &gt; +       u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="quote">&gt; &gt; +       unsigned int fault_larb, fault_port;</span>
<span class="quote">&gt; &gt; +       bool layer, write;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       int_state = readl(m4u_base + REG_MMU_FAULT_ST1);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* read error info from registers */</span>
<span class="quote">&gt; &gt; +       fault_iova = readl(m4u_base + REG_MMU_FAULT_VA);</span>
<span class="quote">&gt; &gt; +       layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="quote">&gt; &gt; +       write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="quote">&gt; &gt; +       fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="quote">&gt; &gt; +       fault_pa = readl(m4u_base + REG_MMU_INVLD_PA);</span>
<span class="quote">&gt; &gt; +       regval = readl(m4u_base + REG_MMU_INT_ID);</span>
<span class="quote">&gt; &gt; +       fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="quote">&gt; &gt; +       fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       report_iommu_fault(&amp;mtkdomain-&gt;domain, dev, fault_iova,</span>
<span class="quote">&gt; &gt; +                          write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (int_state &amp; F_INT_TRANSLATION_FAULT) {</span>
<span class="quote">&gt; &gt; +               dev_err_ratelimited(</span>
<span class="quote">&gt; &gt; +                       dev,</span>
<span class="quote">&gt; &gt; +                       &quot;fault:iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="quote">&gt; &gt; +                       fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="quote">&gt; &gt; +                       layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (int_state &amp; F_INT_MAIN_MULTI_HIT_FAULT)</span>
<span class="quote">&gt; &gt; +               dev_err_ratelimited(dev,</span>
<span class="quote">&gt; &gt; +                                   &quot;multi-hit!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; &gt; +                                   fault_iova, fault_larb, fault_port);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (int_state &amp; F_INT_INVALID_PA_FAULT) {</span>
<span class="quote">&gt; &gt; +               if (!(int_state &amp; F_INT_TRANSLATION_FAULT))</span>
<span class="quote">&gt; &gt; +                       dev_err_ratelimited(</span>
<span class="quote">&gt; &gt; +                               dev,</span>
<span class="quote">&gt; &gt; +                               &quot;invalid pa!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; &gt; +                               fault_iova, fault_larb, fault_port);</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +       if (int_state &amp; F_INT_ENTRY_REPLACEMENT_FAULT)</span>
<span class="quote">&gt; &gt; +               dev_err_ratelimited(dev,</span>
<span class="quote">&gt; &gt; +                                   &quot;replace-fault!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; &gt; +                                   fault_iova, fault_larb, fault_port);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (int_state &amp; F_INT_TLB_MISS_FAULT)</span>
<span class="quote">&gt; &gt; +               dev_err_ratelimited(dev,</span>
<span class="quote">&gt; &gt; +                                   &quot;tlb miss-fault!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="quote">&gt; &gt; +                                   fault_iova, fault_larb, fault_port);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm, do you need so many prints here? Could you just dump the full</span>
<span class="quote">&gt; state (including int_state) regardless of interrupt type here? Also I</span>
<span class="quote">&gt; wonder if this shouldn&#39;t be printed only when report_iommu_fault()</span>
<span class="quote">&gt; returns -ENOSYS.</span>
    F_INT_TRANSLATION_FAULT And F_INT_INVALID_PA_FAULT is the most
common case. Can we reserve them? the others we could delete and print
int_state. About report_iommu_fault, like the other iommu, we check
return 0 if it is successful.

Then How about it if it&#39;s like this:
	//===========
	if(!report_iommu_fault(&amp;mtkdomain-&gt;domain, dev, fault_iova,
                          write ? IOMMU_FAULT_WRITE :
IOMMU_FAULT_READ)){
	goto irq_clear;
  }

       if (int_state &amp; F_INT_TRANSLATION_FAULT) {
               dev_err_ratelimited(
                       dev,
                       &quot;fault:iova=0x%x pa=0x%x larb=%d port=%d layer=%d
%s\n&quot;,
                       fault_iova, fault_pa, fault_larb, fault_port,
                       layer, write ? &quot;write&quot; : &quot;read&quot;);
       } else if (int_state &amp; F_INT_INVALID_PA_FAULT) {
                       dev_err_ratelimited(
                               dev,
                               &quot;invalid pa!iova=0x%x larb=%d port=%d\n&quot;,
                               fault_iova, fault_larb, fault_port);
       } else {
		dev_err_ratelimited(dev,&quot;int state 0x%x,iova=0x%x larb=%d port=%d\n&quot;,
			int_state, fault_iova, fault_larb, fault_port);
       }

irq_clear:
      mtk_iommu_tlb_flush_all(mtkdomain);
      mtk_iommu_clear_intr(m4u_base);
      return IRQ_HANDLED;

       //=======
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       mtk_iommu_tlb_flush_all(mtkdomain);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       mtk_iommu_clear_intr(m4u_base);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return IRQ_HANDLED;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="quote">&gt; &gt; +                             struct mtk_iommu_info *piommu)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +       struct device_node *ofnode;</span>
<span class="quote">&gt; &gt; +       struct resource *res;</span>
<span class="quote">&gt; &gt; +       unsigned int i, port_nr, lastportnr = 0;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ofnode = dev-&gt;of_node;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="quote">&gt; &gt; +       piommu-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="quote">&gt; &gt; +       if (IS_ERR(piommu-&gt;base)) {</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to get base (%lx)\n&quot;,</span>
<span class="quote">&gt; &gt; +                       PTR_ERR(piommu-&gt;base));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; devm_ioremap_resource() already prints a message on error.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               ret = PTR_ERR(piommu-&gt;base);</span>
<span class="quote">&gt; &gt; +               goto err_parse_dt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You can just return PTR_ERR(piommu-&gt;base) here directly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       piommu-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="quote">&gt; &gt; +       if (piommu-&gt;irq &lt; 0) {</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to get IRQ (%d)\n&quot;, piommu-&gt;irq);</span>
<span class="quote">&gt; &gt; +               ret = piommu-&gt;irq;</span>
<span class="quote">&gt; &gt; +               goto err_parse_dt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Again just return.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       piommu-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="quote">&gt; &gt; +       if (IS_ERR(piommu-&gt;bclk)) {</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to get the bclk (%lx)\n&quot;,</span>
<span class="quote">&gt; &gt; +                       PTR_ERR(piommu-&gt;bclk));</span>
<span class="quote">&gt; &gt; +               ret = PTR_ERR(piommu-&gt;bclk);</span>
<span class="quote">&gt; &gt; +               goto err_parse_dt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ditto.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = of_property_count_u32_elems(ofnode, &quot;larb-portes-nr&quot;);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; According to my comments to the patch adding the binding, you should</span>
<span class="quote">&gt; rather count the number of phandles in &quot;larb&quot; property by</span>
<span class="quote">&gt; of_count_phandle_with_args(ofnode, &quot;larb&quot;, NULL).</span>
Thanks. I will delete this.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       if (ret &lt; 0) {</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to get larb-portes-nr\n&quot;);</span>
<span class="quote">&gt; &gt; +               goto err_parse_dt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ditto.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       } else {</span>
<span class="quote">&gt; &gt; +               piommu-&gt;larb_nr = ret;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You can take this out of &quot;else&quot; block.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = 0; i &lt; piommu-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; &gt; +               ret = of_property_read_u32_index(ofnode, &quot;larb-portes-nr&quot;,</span>
<span class="quote">&gt; &gt; +                                                i, &amp;port_nr);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For logical correctness, you should parse port count from larb node,</span>
<span class="quote">&gt; as I mentioned in my comments to the patch adding the binding. However</span>
<span class="quote">&gt; I&#39;m not sure if you even need to know the number of ports. I will</span>
<span class="quote">&gt; comment more on this below.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               if (ret) {</span>
<span class="quote">&gt; &gt; +                       dev_err(dev, &quot;Failed to get the port nr@larb%d\n&quot;, i);</span>
<span class="quote">&gt; &gt; +                       goto err_parse_dt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Just return here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               } else {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +                       piommu-&gt;larb_portid_base[i] = lastportnr;</span>
<span class="quote">&gt; &gt; +                       lastportnr += port_nr;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This looks like creating an artificial 1-dimensional namespace from a</span>
<span class="quote">&gt; natural 2-dimensional space indexed by (larb, port) tuple.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also you can take this out of the else block.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +       piommu-&gt;larb_portid_base[i] = lastportnr;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = 0; i &lt; piommu-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; &gt; +               struct device_node *larbnode;</span>
<span class="quote">&gt; &gt; +               struct platform_device *plarbdev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               larbnode = of_parse_phandle(ofnode, &quot;larb&quot;, i);</span>
<span class="quote">&gt; &gt; +               if (!larbnode) {</span>
<span class="quote">&gt; &gt; +                       dev_err(dev, &quot;Failed to get the larb property\n&quot;);</span>
<span class="quote">&gt; &gt; +                       ret = -EINVAL;</span>
<span class="quote">&gt; &gt; +                       goto err_parse_dt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Just return.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +               plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; &gt; +               of_node_put(larbnode);</span>
<span class="quote">&gt; &gt; +               if (!plarbdev) {</span>
<span class="quote">&gt; &gt; +                       dev_err(dev, &quot;Failed to get the dev@larb%d\n&quot;, i);</span>
<span class="quote">&gt; &gt; +                       ret = -EINVAL;</span>
<span class="quote">&gt; &gt; +                       goto err_parse_dt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Just return.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               } else {</span>
<span class="quote">&gt; &gt; +                       piommu-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Again, no need to put this into else block.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_parse_dt:</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Now, after addressing my comments above, this label can be removed.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdomain)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_info *piommu = mtkdomain-&gt;imuinfo;</span>
<span class="quote">&gt; &gt; +       void __iomem *m4u_base = piommu-&gt;base;</span>
<span class="quote">&gt; &gt; +       u32 regval;</span>
<span class="quote">&gt; &gt; +       int ret = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = clk_prepare_enable(piommu-&gt;bclk);</span>
<span class="quote">&gt; &gt; +       if (ret)</span>
<span class="quote">&gt; &gt; +               return -ENODEV;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why overriding the error returned in ret with -ENODEV?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       writel(mtkdomain-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="quote">&gt; &gt; +              m4u_base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; &gt; +               F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="quote">&gt; &gt; +               F_COHERENCE_EN;</span>
<span class="quote">&gt; &gt; +       writel(regval, m4u_base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       regval = F_L2_MULIT_HIT_EN |</span>
<span class="quote">&gt; &gt; +               F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="quote">&gt; &gt; +               F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; &gt; +               F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; &gt; +               F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="quote">&gt; &gt; +               F_MISS_FIFO_ERR_INT_EN;</span>
<span class="quote">&gt; &gt; +       writel(regval, m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       regval = F_INT_TRANSLATION_FAULT |</span>
<span class="quote">&gt; &gt; +               F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="quote">&gt; &gt; +               F_INT_INVALID_PA_FAULT |</span>
<span class="quote">&gt; &gt; +               F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="quote">&gt; &gt; +               F_INT_TLB_MISS_FAULT |</span>
<span class="quote">&gt; &gt; +               F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="quote">&gt; &gt; +               F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="quote">&gt; &gt; +       writel(regval, m4u_base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       regval = ALIGN(piommu-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="quote">&gt; &gt; +       regval = (u32)F_MMU_IVRP_PA_SET(regval);</span>
<span class="quote">&gt; &gt; +       writel(regval, m4u_base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       writel(0, m4u_base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; &gt; +       writel(0, m4u_base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (devm_request_irq(piommu-&gt;dev, piommu-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; &gt; +                            dev_name(piommu-&gt;dev), (void *)mtkdomain)) {</span>
<span class="quote">&gt; &gt; +               dev_err(piommu-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, piommu-&gt;irq);</span>
<span class="quote">&gt; &gt; +               return -ENODEV;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm, this keeps the clock enabled. Should you add clean-up path</span>
<span class="quote">&gt; uninitializing the hardware and stopping the clock?</span>
ok. I will clk_diable and write 0 to pagetable base address register.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_config_port(struct mtk_iommu_info *piommu,</span>
<span class="quote">&gt; &gt; +                                int portid, bool iommuen)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       bool validlarb = false;</span>
<span class="quote">&gt; &gt; +       int i, larbid, larbportid;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (portid &gt;= piommu-&gt;larb_portid_base[piommu-&gt;larb_nr]) {</span>
<span class="quote">&gt; &gt; +               dev_err(piommu-&gt;dev, &quot;Invalid portid (%d)\n&quot;, portid);</span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = piommu-&gt;larb_nr - 1; i &gt;= 0; i--) {</span>
<span class="quote">&gt; &gt; +               if (portid &gt;= piommu-&gt;larb_portid_base[i]) {</span>
<span class="quote">&gt; &gt; +                       larbid = i;</span>
<span class="quote">&gt; &gt; +                       larbportid = portid -</span>
<span class="quote">&gt; &gt; +                                       piommu-&gt;larb_portid_base[i];</span>
<span class="quote">&gt; &gt; +                       validlarb = true;</span>
<span class="quote">&gt; &gt; +                       break;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There would be no need for this magic here if two cells was used for</span>
<span class="quote">&gt; port specifier in DT. By the way, this function seems to be the only</span>
<span class="quote">&gt; user of port count, so if you don&#39;t strictly need the check for port</span>
<span class="quote">&gt; specifier being in range, then such information could be simply</span>
<span class="quote">&gt; removed from DT, simplifying the binding.</span>
Thanks. I will follow it.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (validlarb) {</span>
<span class="quote">&gt; &gt; +               ret = mtk_smi_config_port(piommu-&gt;larbdev[larbid],</span>
<span class="quote">&gt; &gt; +                                         larbportid, iommuen);</span>
<span class="quote">&gt; &gt; +               if (ret) {</span>
<span class="quote">&gt; &gt; +                       dev_err(piommu-&gt;dev,</span>
<span class="quote">&gt; &gt; +                               &quot;Failed to config port portid-%d\n&quot;, portid);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       } else {</span>
<span class="quote">&gt; &gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; &gt; +               dev_err(piommu-&gt;dev, &quot;Failed to find out portid-%d\n&quot;, portid);</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_dev_enable_iommu(struct mtk_iommu_info *imuinfo,</span>
<span class="quote">&gt; &gt; +                                     struct device *dev, bool enable)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct of_phandle_args out_args = {0};</span>
<span class="quote">&gt; &gt; +       struct device *imudev = imuinfo-&gt;dev;</span>
<span class="quote">&gt; &gt; +       unsigned int i = 0;</span>
<span class="quote">&gt; &gt; +       int ret = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="quote">&gt; &gt; +                                          &quot;#iommu-cells&quot;, i++, &amp;out_args)) {</span>
<span class="quote">&gt; &gt; +               if (out_args.np != imudev-&gt;of_node)</span>
<span class="quote">&gt; &gt; +                       continue;</span>
<span class="quote">&gt; &gt; +               if (out_args.args_count != 1) {</span>
<span class="quote">&gt; &gt; +                       dev_err(imudev,</span>
<span class="quote">&gt; &gt; +                               &quot;invalid #iommu-cells property for IOMMU\n&quot;);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t believe you need to do this manually. I can see</span>
<span class="quote">&gt; of_iommu_configure() in</span>
<span class="quote">&gt; http://lxr.free-electrons.com/source/drivers/iommu/of_iommu.c#L136 ,</span>
<span class="quote">&gt; which I believe should call .of_xlate from your iommu_ops with correct</span>
<span class="quote">&gt; node and verified the args count. This callback should parse the args</span>
<span class="quote">&gt; and prepare some private data.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t see any example of such .of_xlate callback though. Could</span>
<span class="quote">&gt; someone (Joerg, Will?) advise how this could be used and in particular</span>
<span class="quote">&gt; how the data obtained from parsing the args should be stored for</span>
<span class="quote">&gt; further use?</span>
I have test of_xlate. It could help parse the args.
In arm64 dma v2 of Robin, We can not get the standard &quot;iommu_dma_ops&quot; in
dma_mapping.c except calling arch_setup_dma_ops, It is static.
So I don&#39;t change it here in this version.
and We may get the dma v3 this weekend.
So in next version, we will try to use of_xlate to replace this.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               dev_dbg(imudev, &quot;%s iommu @ port:%d\n&quot;,</span>
<span class="quote">&gt; &gt; +                       enable ? &quot;enable&quot; : &quot;disable&quot;, out_args.args[0]);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               ret = mtk_iommu_config_port(imuinfo, out_args.args[0], enable);</span>
<span class="quote">&gt; &gt; +               if (!ret)</span>
<span class="quote">&gt; &gt; +                       dev-&gt;archdata.dma_ops = (enable) ?</span>
<span class="quote">&gt; &gt; +                                       imudev-&gt;archdata.dma_ops : NULL;</span>
<span class="quote">&gt; &gt; +               else</span>
<span class="quote">&gt; &gt; +                       break;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* We only support unmanaged domains for now */</span>
<span class="quote">&gt; &gt; +       if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!priv)</span>
<span class="quote">&gt; &gt; +               return ERR_PTR(-ENOMEM);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What&#39;s the proper return convention of this function? The first error</span>
<span class="quote">&gt; case returns NULL, while this an error pointer. One of them is most</span>
<span class="quote">&gt; likely wrong.</span>
I will change to return NULL both.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       priv-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS;</span>
<span class="quote">&gt; &gt; +       priv-&gt;cfg.pgsize_bitmap = SZ_16M | SZ_1M | SZ_64K | SZ_4K,</span>
<span class="quote">&gt; &gt; +       priv-&gt;cfg.ias = 32;</span>
<span class="quote">&gt; &gt; +       priv-&gt;cfg.oas = 32;</span>
<span class="quote">&gt; &gt; +       priv-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       priv-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;priv-&gt;cfg, priv);</span>
<span class="quote">&gt; &gt; +       if (!priv-&gt;iop) {</span>
<span class="quote">&gt; &gt; +               pr_err(&quot;Failed to alloc io pgtable@MTK iommu\n&quot;);</span>
<span class="quote">&gt; &gt; +               goto err_free_priv;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       spin_lock_init(&amp;priv-&gt;pgtlock);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.aperture_end = ~0;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Should this be UL or ULL?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return &amp;priv-&gt;domain;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_free_priv:</span>
<span class="quote">&gt; &gt; +       kfree(priv);</span>
<span class="quote">&gt; &gt; +       return NULL;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       free_io_pgtable_ops(priv-&gt;iop);</span>
<span class="quote">&gt; &gt; +       kfree(priv);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +                                  struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* word around for arch_setup_dma_ops */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; typo: s/word around/Workaround/</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Anyway, could you remind me what was the issue with arch_setup_dma_ops, please?</span>
As above.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       if (!priv-&gt;imuinfo)</span>
<span class="quote">&gt; &gt; +               ret = 0;</span>
<span class="quote">&gt; &gt; +       else</span>
<span class="quote">&gt; &gt; +               ret = mtk_iommu_dev_enable_iommu(priv-&gt;imuinfo, dev, true);</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Maybe you could rewrite the 5 lines above into the following:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; if (!priv-&gt;imuinfo)</span>
<span class="quote">&gt;     return 0;</span>
<span class="quote">&gt; return mtk_iommu_dev_enable_iommu(priv-&gt;imuinfo, dev, true);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
[snip]
<span class="quote">&gt; &gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct iommu_domain     *domain;</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *mtk_domain;</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_info   *piommu;</span>
<span class="quote">&gt; &gt; +       void __iomem            *protect;</span>
<span class="quote">&gt; &gt; +       int                     ret;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; CodingStyle: Please no tabs in local variable declarations.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       piommu = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*piommu), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!piommu)</span>
<span class="quote">&gt; &gt; +               return -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       piommu-&gt;dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /*</span>
<span class="quote">&gt; &gt; +        * Alloc for Protect memory.</span>
<span class="quote">&gt; &gt; +        * HW will access here while translation fault.</span>
<span class="quote">&gt; &gt; +        */</span>
<span class="quote">&gt; &gt; +       protect = devm_kzalloc(piommu-&gt;dev, MTK_PROTECT_PA_ALIGN * 2,</span>
<span class="quote">&gt; &gt; +                              GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!protect)</span>
<span class="quote">&gt; &gt; +               return -ENOMEM;</span>
<span class="quote">&gt; &gt; +       piommu-&gt;protect_base = dma_map_single(piommu-&gt;dev, protect,</span>
<span class="quote">&gt; &gt; +                                             MTK_PROTECT_PA_ALIGN * 2,</span>
<span class="quote">&gt; &gt; +                                             DMA_TO_DEVICE); /* clean cache */</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = mtk_iommu_parse_dt(pdev, piommu);</span>
<span class="quote">&gt; &gt; +       if (ret)</span>
<span class="quote">&gt; &gt; +               return ret;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What about the potential dma mapping created by dma_map_single()? (I&#39;m</span>
<span class="quote">&gt; not sure how important is to clean this up in practice, but for</span>
<span class="quote">&gt; consistency, it should be handled in error path to prevent leaking</span>
<span class="quote">&gt; memory if something changes in future in DMA API internals.)</span>
I think it maybe not important if we don&#39;t clean cache.That is to say
that we can delete this dma_map_single.

If the protect memory don&#39;t do cache sync, HW may read some random data
while translation fault, Then the multimedia HW output may random
error, It maybe don&#39;t need to care.
At that time, iommu will print translation fault log. I think the
multimedia module owner should resolve the translation fault issue
firstly.

And There is no error path. HW will access protect memory while
translation fault. This is HW behavior. If we disable this protect
function, HW will access what it read.the fault address maybe random.
It will be more dangerous.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /*</span>
<span class="quote">&gt; &gt; +        * arch_setup_dma_ops is not proper.</span>
<span class="quote">&gt; &gt; +        * It should be replaced it with iommu_dma_create_domain</span>
<span class="quote">&gt; &gt; +        * in next dma patch.</span>
<span class="quote">&gt; &gt; +        */</span>
<span class="quote">&gt; &gt; +       arch_setup_dma_ops(piommu-&gt;dev, 0, (1ULL &lt;&lt; 32) - 1, &amp;mtk_iommu_ops, 0);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       domain = iommu_dma_raw_domain(get_dma_domain(piommu-&gt;dev));</span>
<span class="quote">&gt; &gt; +       if (!domain) {</span>
<span class="quote">&gt; &gt; +               dev_err(piommu-&gt;dev, &quot;Failed to get iommu domain\n&quot;);</span>
<span class="quote">&gt; &gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; &gt; +               goto err_free_domain;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       mtk_domain = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +       mtk_domain-&gt;imuinfo = piommu;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       dev_set_drvdata(piommu-&gt;dev, piommu);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = mtk_iommu_hw_init(mtk_domain);</span>
<span class="quote">&gt; &gt; +       if (ret &lt; 0) {</span>
<span class="quote">&gt; &gt; +               dev_err(piommu-&gt;dev, &quot;Failed @ HW init\n&quot;);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; nit: Maybe &quot;Hardware initialization failed&quot;?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               goto err_free_domain;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_free_domain:</span>
<span class="quote">&gt; &gt; +       arch_teardown_dma_ops(piommu-&gt;dev);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Shouldn&#39;t the label be called err_teardown_dma_ops then?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Best regards,</span>
<span class="quote">&gt; Tomasz</span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - June 5, 2015, 1:30 p.m.</div>
<pre class="content">
On Fri, May 15, 2015 at 10:43:28AM +0100, Yong Wu wrote:
<span class="quote">&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management Unit).</span>

After looking at the page table code, I thought I&#39;d come and check your
TLB invalidate code here.
<span class="quote">
&gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +       u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="quote">&gt; +       writel(val, domain-&gt;imuinfo-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +       writel(F_ALL_INVLD, domain-&gt;imuinfo-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="quote">&gt; +                                   bool leaf, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +       void __iomem *m4u_base = domain-&gt;imuinfo-&gt;base;</span>
<span class="quote">&gt; +       unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +       u32 val;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="quote">&gt; +       writel(val, m4u_base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       writel(iova_start, m4u_base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; +       writel(iova_end, m4u_base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; +       writel(F_MMU_INV_RANGE, m4u_base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = readl_poll_timeout_atomic(m4u_base + REG_MMU_CPE_DONE, val,</span>
<span class="quote">&gt; +                                       val != 0, 10, 1000000);</span>
<span class="quote">&gt; +       if (ret) {</span>
<span class="quote">&gt; +               dev_warn(domain-&gt;imuinfo-&gt;dev, &quot;Invalid tlb don&#39;t done\n&quot;);</span>
<span class="quote">&gt; +               mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       writel(0, m4u_base + REG_MMU_CPE_DONE);</span>
<span class="quote">&gt; +}</span>

You don&#39;t need to wait for completion here if you can implement a proper
-&gt;tlb_sync callback.
<span class="quote">
&gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       /*</span>
<span class="quote">&gt; +        * After delete arch_setup_dma_ops,</span>
<span class="quote">&gt; +        * This will be replaced with dma_map_page</span>
<span class="quote">&gt; +        */</span>
<span class="quote">&gt; +        __dma_flush_range(ptr, ptr + size);</span>
<span class="quote">&gt; +}</span>

This should give you the necessary barriers to ensure visibility of the
updated page tables, so you can use the _relaxed io accessors for the
other TLB functions.
<span class="quote">
&gt; +static struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="quote">&gt; +       .tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="quote">&gt; +       .tlb_add_flush = mtk_iommu_tlb_add_flush,</span>
<span class="quote">&gt; +       .tlb_sync = mtk_iommu_tlb_flush_all,</span>

sync isn&#39;t required to flush anything; it&#39;s just supposed to wait for
any outstanding invalidation (i.e. from tlb_add_flush) to complete.

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index 3d2eac6..da83704 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -359,4 +359,15 @@</span> <span class="p_context"> config ARM_SMMU</span>
 	  Say Y here if your SoC includes an IOMMU device implementing
 	  the ARM SMMU architecture.
 
<span class="p_add">+config MTK_IOMMU</span>
<span class="p_add">+	bool &quot;MTK IOMMU Support&quot;</span>
<span class="p_add">+	select IOMMU_API</span>
<span class="p_add">+	select IOMMU_DMA</span>
<span class="p_add">+	select IOMMU_IO_PGTABLE_SHORT</span>
<span class="p_add">+	select MTK_SMI</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for the IOMMUs on certain Mediatek SOCs.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N here.</span>
<span class="p_add">+</span>
 endif # IOMMU_SUPPORT
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index 815b3c8..3224d29 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"> obj-$(CONFIG_IRQ_REMAP) += intel_irq_remapping.o irq_remapping.o</span>
 obj-$(CONFIG_OMAP_IOMMU) += omap-iommu.o
 obj-$(CONFIG_OMAP_IOMMU_DEBUG) += omap-iommu-debug.o
 obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o
<span class="p_add">+obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
 obj-$(CONFIG_TEGRA_IOMMU_GART) += tegra-gart.o
 obj-$(CONFIG_TEGRA_IOMMU_SMMU) += tegra-smmu.o
 obj-$(CONFIG_EXYNOS_IOMMU) += exynos-iommu.o
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
new file mode 100644
<span class="p_header">index 0000000..378e53e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.c</span>
<span class="p_chunk">@@ -0,0 +1,657 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="p_add">+ * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-mapping.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;linux/iopoll.h&gt;</span>
<span class="p_add">+#include &lt;linux/mtk-smi.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;io-pgtable.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVALIDATE			0x020</span>
<span class="p_add">+#define F_ALL_INVLD				0x2</span>
<span class="p_add">+#define F_MMU_INV_RANGE				0x1</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_START_A			0x024</span>
<span class="p_add">+#define REG_MMU_INVLD_END_A			0x028</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INV_SEL				0x038</span>
<span class="p_add">+#define F_INVLD_EN0				BIT(0)</span>
<span class="p_add">+#define F_INVLD_EN1				BIT(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_STANDARD_AXI_MODE		0x048</span>
<span class="p_add">+#define REG_MMU_DCM_DIS				0x050</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CTRL_REG			0x110</span>
<span class="p_add">+#define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="p_add">+#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="p_add">+#define F_COHERENCE_EN				BIT(8)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_IVRP_PADDR			0x114</span>
<span class="p_add">+#define F_MMU_IVRP_PA_SET(pa)			((pa) &gt;&gt; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_CONTROL0			0x120</span>
<span class="p_add">+#define F_L2_MULIT_HIT_EN			BIT(0)</span>
<span class="p_add">+#define F_TABLE_WALK_FAULT_INT_EN		BIT(1)</span>
<span class="p_add">+#define F_PREETCH_FIFO_OVERFLOW_INT_EN		BIT(2)</span>
<span class="p_add">+#define F_MISS_FIFO_OVERFLOW_INT_EN		BIT(3)</span>
<span class="p_add">+#define F_PREFETCH_FIFO_ERR_INT_EN		BIT(5)</span>
<span class="p_add">+#define F_MISS_FIFO_ERR_INT_EN			BIT(6)</span>
<span class="p_add">+#define F_INT_L2_CLR_BIT			BIT(12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_MAIN_CONTROL		0x124</span>
<span class="p_add">+#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="p_add">+#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="p_add">+#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="p_add">+#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="p_add">+#define F_INT_TLB_MISS_FAULT			BIT(4)</span>
<span class="p_add">+#define F_INT_MISS_TRANSATION_FIFO_FAULT	BIT(5)</span>
<span class="p_add">+#define F_INT_PRETETCH_TRANSATION_FIFO_FAULT	BIT(6)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CPE_DONE			0x12C</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_ST1			0x134</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_VA			0x13c</span>
<span class="p_add">+#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="p_add">+#define F_MMU_FAULT_VA_WRITE_BIT		BIT(1)</span>
<span class="p_add">+#define F_MMU_FAULT_VA_LAYER_BIT		BIT(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_PA			0x140</span>
<span class="p_add">+#define REG_MMU_INT_ID				0x150</span>
<span class="p_add">+#define F_MMU0_INT_ID_LARB_ID(a)		(((a) &gt;&gt; 7) &amp; 0x7)</span>
<span class="p_add">+#define F_MMU0_INT_ID_PORT_ID(a)		(((a) &gt;&gt; 2) &amp; 0x1f)</span>
<span class="p_add">+</span>
<span class="p_add">+#define MTK_PROTECT_PA_ALIGN			(128)</span>
<span class="p_add">+</span>
<span class="p_add">+#define MTK_IOMMU_LARB_MAX_NR			8</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_info {</span>
<span class="p_add">+	void __iomem		*base;</span>
<span class="p_add">+	int			irq;</span>
<span class="p_add">+	struct device		*dev;</span>
<span class="p_add">+	struct device		*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="p_add">+	struct clk		*bclk;</span>
<span class="p_add">+	dma_addr_t		protect_base; /* protect memory base */</span>
<span class="p_add">+	unsigned int		larb_nr;      /* local arbiter number */</span>
<span class="p_add">+	unsigned int		larb_portid_base[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="p_add">+				/* the port id base for each local arbiter */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_domain {</span>
<span class="p_add">+	struct imu_pgd_t	*pgd;</span>
<span class="p_add">+	spinlock_t		pgtlock;    /* lock for modifying page table */</span>
<span class="p_add">+</span>
<span class="p_add">+	struct io_pgtable_cfg   cfg;</span>
<span class="p_add">+	struct io_pgtable_ops   *iop;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct mtk_iommu_info   *imuinfo;</span>
<span class="p_add">+	struct iommu_domain	domain;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return container_of(dom, struct mtk_iommu_domain, domain);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_clear_intr(void __iomem *m4u_base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = readl(m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	val |= F_INT_L2_CLR_BIT;</span>
<span class="p_add">+	writel(val, m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="p_add">+	writel(val, domain-&gt;imuinfo-&gt;base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel(F_ALL_INVLD, domain-&gt;imuinfo-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="p_add">+				    bool leaf, void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *m4u_base = domain-&gt;imuinfo-&gt;base;</span>
<span class="p_add">+	unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = F_INVLD_EN1 | F_INVLD_EN0;</span>
<span class="p_add">+	writel(val, m4u_base + REG_MMU_INV_SEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(iova_start, m4u_base + REG_MMU_INVLD_START_A);</span>
<span class="p_add">+	writel(iova_end, m4u_base + REG_MMU_INVLD_END_A);</span>
<span class="p_add">+	writel(F_MMU_INV_RANGE, m4u_base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = readl_poll_timeout_atomic(m4u_base + REG_MMU_CPE_DONE, val,</span>
<span class="p_add">+					val != 0, 10, 1000000);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_warn(domain-&gt;imuinfo-&gt;dev, &quot;Invalid tlb don&#39;t done\n&quot;);</span>
<span class="p_add">+		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel(0, m4u_base + REG_MMU_CPE_DONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * After delete arch_setup_dma_ops,</span>
<span class="p_add">+	 * This will be replaced with dma_map_page</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	 __dma_flush_range(ptr, ptr + size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="p_add">+	.tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="p_add">+	.tlb_add_flush = mtk_iommu_tlb_add_flush,</span>
<span class="p_add">+	.tlb_sync = mtk_iommu_tlb_flush_all,</span>
<span class="p_add">+	.flush_pgtable = mtk_iommu_flush_pgtable,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdomain = dev_id;</span>
<span class="p_add">+	struct mtk_iommu_info *piommu = mtkdomain-&gt;imuinfo;</span>
<span class="p_add">+	struct device *dev = piommu-&gt;dev;</span>
<span class="p_add">+	void __iomem *m4u_base = piommu-&gt;base;</span>
<span class="p_add">+	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="p_add">+	unsigned int fault_larb, fault_port;</span>
<span class="p_add">+	bool layer, write;</span>
<span class="p_add">+</span>
<span class="p_add">+	int_state = readl(m4u_base + REG_MMU_FAULT_ST1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* read error info from registers */</span>
<span class="p_add">+	fault_iova = readl(m4u_base + REG_MMU_FAULT_VA);</span>
<span class="p_add">+	layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="p_add">+	write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="p_add">+	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="p_add">+	fault_pa = readl(m4u_base + REG_MMU_INVLD_PA);</span>
<span class="p_add">+	regval = readl(m4u_base + REG_MMU_INT_ID);</span>
<span class="p_add">+	fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="p_add">+	fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="p_add">+</span>
<span class="p_add">+	report_iommu_fault(&amp;mtkdomain-&gt;domain, dev, fault_iova,</span>
<span class="p_add">+			   write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (int_state &amp; F_INT_TRANSLATION_FAULT) {</span>
<span class="p_add">+		dev_err_ratelimited(</span>
<span class="p_add">+			dev,</span>
<span class="p_add">+			&quot;fault:iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="p_add">+			fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="p_add">+			layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (int_state &amp; F_INT_MAIN_MULTI_HIT_FAULT)</span>
<span class="p_add">+		dev_err_ratelimited(dev,</span>
<span class="p_add">+				    &quot;multi-hit!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="p_add">+				    fault_iova, fault_larb, fault_port);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (int_state &amp; F_INT_INVALID_PA_FAULT) {</span>
<span class="p_add">+		if (!(int_state &amp; F_INT_TRANSLATION_FAULT))</span>
<span class="p_add">+			dev_err_ratelimited(</span>
<span class="p_add">+				dev,</span>
<span class="p_add">+				&quot;invalid pa!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="p_add">+				fault_iova, fault_larb, fault_port);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (int_state &amp; F_INT_ENTRY_REPLACEMENT_FAULT)</span>
<span class="p_add">+		dev_err_ratelimited(dev,</span>
<span class="p_add">+				    &quot;replace-fault!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="p_add">+				    fault_iova, fault_larb, fault_port);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (int_state &amp; F_INT_TLB_MISS_FAULT)</span>
<span class="p_add">+		dev_err_ratelimited(dev,</span>
<span class="p_add">+				    &quot;tlb miss-fault!iova=0x%x larb=%d port=%d\n&quot;,</span>
<span class="p_add">+				    fault_iova, fault_larb, fault_port);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_all(mtkdomain);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_clear_intr(m4u_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="p_add">+			      struct mtk_iommu_info *piommu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct device_node *ofnode;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	unsigned int i, port_nr, lastportnr = 0;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ofnode = dev-&gt;of_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	piommu-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="p_add">+	if (IS_ERR(piommu-&gt;base)) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to get base (%lx)\n&quot;,</span>
<span class="p_add">+			PTR_ERR(piommu-&gt;base));</span>
<span class="p_add">+		ret = PTR_ERR(piommu-&gt;base);</span>
<span class="p_add">+		goto err_parse_dt;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	piommu-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (piommu-&gt;irq &lt; 0) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to get IRQ (%d)\n&quot;, piommu-&gt;irq);</span>
<span class="p_add">+		ret = piommu-&gt;irq;</span>
<span class="p_add">+		goto err_parse_dt;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	piommu-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="p_add">+	if (IS_ERR(piommu-&gt;bclk)) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to get the bclk (%lx)\n&quot;,</span>
<span class="p_add">+			PTR_ERR(piommu-&gt;bclk));</span>
<span class="p_add">+		ret = PTR_ERR(piommu-&gt;bclk);</span>
<span class="p_add">+		goto err_parse_dt;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_property_count_u32_elems(ofnode, &quot;larb-portes-nr&quot;);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to get larb-portes-nr\n&quot;);</span>
<span class="p_add">+		goto err_parse_dt;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		piommu-&gt;larb_nr = ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; piommu-&gt;larb_nr; i++) {</span>
<span class="p_add">+		ret = of_property_read_u32_index(ofnode, &quot;larb-portes-nr&quot;,</span>
<span class="p_add">+						 i, &amp;port_nr);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to get the port nr@larb%d\n&quot;, i);</span>
<span class="p_add">+			goto err_parse_dt;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			piommu-&gt;larb_portid_base[i] = lastportnr;</span>
<span class="p_add">+			lastportnr += port_nr;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	piommu-&gt;larb_portid_base[i] = lastportnr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; piommu-&gt;larb_nr; i++) {</span>
<span class="p_add">+		struct device_node *larbnode;</span>
<span class="p_add">+		struct platform_device *plarbdev;</span>
<span class="p_add">+</span>
<span class="p_add">+		larbnode = of_parse_phandle(ofnode, &quot;larb&quot;, i);</span>
<span class="p_add">+		if (!larbnode) {</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to get the larb property\n&quot;);</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto err_parse_dt;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="p_add">+		of_node_put(larbnode);</span>
<span class="p_add">+		if (!plarbdev) {</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to get the dev@larb%d\n&quot;, i);</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto err_parse_dt;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			piommu-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_parse_dt:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdomain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_info *piommu = mtkdomain-&gt;imuinfo;</span>
<span class="p_add">+	void __iomem *m4u_base = piommu-&gt;base;</span>
<span class="p_add">+	u32 regval;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(piommu-&gt;bclk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(mtkdomain-&gt;cfg.arm_short_cfg.ttbr[0],</span>
<span class="p_add">+	       m4u_base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="p_add">+		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="p_add">+		F_COHERENCE_EN;</span>
<span class="p_add">+	writel(regval, m4u_base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_L2_MULIT_HIT_EN |</span>
<span class="p_add">+		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="p_add">+		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="p_add">+	writel(regval, m4u_base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="p_add">+		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="p_add">+		F_INT_INVALID_PA_FAULT |</span>
<span class="p_add">+		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="p_add">+		F_INT_TLB_MISS_FAULT |</span>
<span class="p_add">+		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="p_add">+		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="p_add">+	writel(regval, m4u_base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = ALIGN(piommu-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="p_add">+	regval = (u32)F_MMU_IVRP_PA_SET(regval);</span>
<span class="p_add">+	writel(regval, m4u_base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(0, m4u_base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel(0, m4u_base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devm_request_irq(piommu-&gt;dev, piommu-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="p_add">+			     dev_name(piommu-&gt;dev), (void *)mtkdomain)) {</span>
<span class="p_add">+		dev_err(piommu-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, piommu-&gt;irq);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_config_port(struct mtk_iommu_info *piommu,</span>
<span class="p_add">+				 int portid, bool iommuen)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool validlarb = false;</span>
<span class="p_add">+	int i, larbid, larbportid;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (portid &gt;= piommu-&gt;larb_portid_base[piommu-&gt;larb_nr]) {</span>
<span class="p_add">+		dev_err(piommu-&gt;dev, &quot;Invalid portid (%d)\n&quot;, portid);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = piommu-&gt;larb_nr - 1; i &gt;= 0; i--) {</span>
<span class="p_add">+		if (portid &gt;= piommu-&gt;larb_portid_base[i]) {</span>
<span class="p_add">+			larbid = i;</span>
<span class="p_add">+			larbportid = portid -</span>
<span class="p_add">+					piommu-&gt;larb_portid_base[i];</span>
<span class="p_add">+			validlarb = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (validlarb) {</span>
<span class="p_add">+		ret = mtk_smi_config_port(piommu-&gt;larbdev[larbid],</span>
<span class="p_add">+					  larbportid, iommuen);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(piommu-&gt;dev,</span>
<span class="p_add">+				&quot;Failed to config port portid-%d\n&quot;, portid);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		dev_err(piommu-&gt;dev, &quot;Failed to find out portid-%d\n&quot;, portid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_dev_enable_iommu(struct mtk_iommu_info *imuinfo,</span>
<span class="p_add">+				      struct device *dev, bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct of_phandle_args out_args = {0};</span>
<span class="p_add">+	struct device *imudev = imuinfo-&gt;dev;</span>
<span class="p_add">+	unsigned int i = 0;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!of_parse_phandle_with_args(dev-&gt;of_node, &quot;iommus&quot;,</span>
<span class="p_add">+					   &quot;#iommu-cells&quot;, i++, &amp;out_args)) {</span>
<span class="p_add">+		if (out_args.np != imudev-&gt;of_node)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (out_args.args_count != 1) {</span>
<span class="p_add">+			dev_err(imudev,</span>
<span class="p_add">+				&quot;invalid #iommu-cells property for IOMMU\n&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(imudev, &quot;%s iommu @ port:%d\n&quot;,</span>
<span class="p_add">+			enable ? &quot;enable&quot; : &quot;disable&quot;, out_args.args[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = mtk_iommu_config_port(imuinfo, out_args.args[0], enable);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			dev-&gt;archdata.dma_ops = (enable) ?</span>
<span class="p_add">+					imudev-&gt;archdata.dma_ops : NULL;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We only support unmanaged domains for now */</span>
<span class="p_add">+	if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS;</span>
<span class="p_add">+	priv-&gt;cfg.pgsize_bitmap = SZ_16M | SZ_1M | SZ_64K | SZ_4K,</span>
<span class="p_add">+	priv-&gt;cfg.ias = 32;</span>
<span class="p_add">+	priv-&gt;cfg.oas = 32;</span>
<span class="p_add">+	priv-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;priv-&gt;cfg, priv);</span>
<span class="p_add">+	if (!priv-&gt;iop) {</span>
<span class="p_add">+		pr_err(&quot;Failed to alloc io pgtable@MTK iommu\n&quot;);</span>
<span class="p_add">+		goto err_free_priv;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_init(&amp;priv-&gt;pgtlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_end = ~0;</span>
<span class="p_add">+	priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;priv-&gt;domain;</span>
<span class="p_add">+</span>
<span class="p_add">+err_free_priv:</span>
<span class="p_add">+	kfree(priv);</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	free_io_pgtable_ops(priv-&gt;iop);</span>
<span class="p_add">+	kfree(priv);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				   struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* word around for arch_setup_dma_ops */</span>
<span class="p_add">+	if (!priv-&gt;imuinfo)</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = mtk_iommu_dev_enable_iommu(priv-&gt;imuinfo, dev, true);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				    struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_dev_enable_iommu(priv-&gt;imuinfo, dev, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	ret = priv-&gt;iop-&gt;map(priv-&gt;iop, iova, paddr, size, prot);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="p_add">+			      unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	priv-&gt;iop-&gt;unmap(priv-&gt;iop, iova, size);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="p_add">+					  dma_addr_t iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	pa = priv-&gt;iop-&gt;iova_to_phys(priv-&gt;iop, iova);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops = {</span>
<span class="p_add">+	.domain_alloc = mtk_iommu_domain_alloc,</span>
<span class="p_add">+	.domain_free = mtk_iommu_domain_free,</span>
<span class="p_add">+	.attach_dev = mtk_iommu_attach_device,</span>
<span class="p_add">+	.detach_dev = mtk_iommu_detach_device,</span>
<span class="p_add">+	.map = mtk_iommu_map,</span>
<span class="p_add">+	.unmap = mtk_iommu_unmap,</span>
<span class="p_add">+	.map_sg = default_iommu_map_sg,</span>
<span class="p_add">+	.iova_to_phys = mtk_iommu_iova_to_phys,</span>
<span class="p_add">+	.pgsize_bitmap = SZ_4K | SZ_64K | SZ_1M | SZ_16M,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8173-m4u&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_domain	*domain;</span>
<span class="p_add">+	struct mtk_iommu_domain	*mtk_domain;</span>
<span class="p_add">+	struct mtk_iommu_info	*piommu;</span>
<span class="p_add">+	void __iomem		*protect;</span>
<span class="p_add">+	int			ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	piommu = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*piommu), GFP_KERNEL);</span>
<span class="p_add">+	if (!piommu)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	piommu-&gt;dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Alloc for Protect memory.</span>
<span class="p_add">+	 * HW will access here while translation fault.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	protect = devm_kzalloc(piommu-&gt;dev, MTK_PROTECT_PA_ALIGN * 2,</span>
<span class="p_add">+			       GFP_KERNEL);</span>
<span class="p_add">+	if (!protect)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	piommu-&gt;protect_base = dma_map_single(piommu-&gt;dev, protect,</span>
<span class="p_add">+					      MTK_PROTECT_PA_ALIGN * 2,</span>
<span class="p_add">+					      DMA_TO_DEVICE); /* clean cache */</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_parse_dt(pdev, piommu);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * arch_setup_dma_ops is not proper.</span>
<span class="p_add">+	 * It should be replaced it with iommu_dma_create_domain</span>
<span class="p_add">+	 * in next dma patch.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	arch_setup_dma_ops(piommu-&gt;dev, 0, (1ULL &lt;&lt; 32) - 1, &amp;mtk_iommu_ops, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	domain = iommu_dma_raw_domain(get_dma_domain(piommu-&gt;dev));</span>
<span class="p_add">+	if (!domain) {</span>
<span class="p_add">+		dev_err(piommu-&gt;dev, &quot;Failed to get iommu domain\n&quot;);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto err_free_domain;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_domain = to_mtk_domain(domain);</span>
<span class="p_add">+	mtk_domain-&gt;imuinfo = piommu;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_set_drvdata(piommu-&gt;dev, piommu);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_hw_init(mtk_domain);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_err(piommu-&gt;dev, &quot;Failed @ HW init\n&quot;);</span>
<span class="p_add">+		goto err_free_domain;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_free_domain:</span>
<span class="p_add">+	arch_teardown_dma_ops(piommu-&gt;dev);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_info *piommu =	dev_get_drvdata(&amp;pdev-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	arch_teardown_dma_ops(piommu-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	dma_unmap_single(piommu-&gt;dev, piommu-&gt;protect_base,</span>
<span class="p_add">+			 MTK_PROTECT_PA_ALIGN * 2, DMA_TO_DEVICE);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mtk_iommu_driver = {</span>
<span class="p_add">+	.probe	= mtk_iommu_probe,</span>
<span class="p_add">+	.remove	= mtk_iommu_remove,</span>
<span class="p_add">+	.driver	= {</span>
<span class="p_add">+		.name = &quot;mtkiommu&quot;,</span>
<span class="p_add">+		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mtk_iommu_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(mtk_iommu_init);</span>
<span class="p_add">+</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



