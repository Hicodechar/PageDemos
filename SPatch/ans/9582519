
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[4/5] mm: convert mm_struct.mm_users from atomic_t to refcount_t - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [4/5] mm: convert mm_struct.mm_users from atomic_t to refcount_t</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=169483">Elena Reshetova</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 20, 2017, 10:49 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1487587754-10610-5-git-send-email-elena.reshetova@intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9582519/mbox/"
   >mbox</a>
|
   <a href="/patch/9582519/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9582519/">/patch/9582519/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2D9DA6042F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Feb 2017 10:49:46 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1D082287E2
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Feb 2017 10:49:46 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1143028853; Mon, 20 Feb 2017 10:49:46 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 05530287E2
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Feb 2017 10:49:44 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752817AbdBTKtk (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 20 Feb 2017 05:49:40 -0500
Received: from mga04.intel.com ([192.55.52.120]:30658 &quot;EHLO mga04.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752634AbdBTKtg (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 20 Feb 2017 05:49:36 -0500
Received: from fmsmga002.fm.intel.com ([10.253.24.26])
	by fmsmga104.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384;
	20 Feb 2017 02:49:36 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.35,186,1484035200&quot;; d=&quot;scan&#39;208&quot;;a=&quot;1132318402&quot;
Received: from elena-thinkpad-x230.fi.intel.com ([10.237.72.69])
	by fmsmga002.fm.intel.com with ESMTP; 20 Feb 2017 02:49:32 -0800
From: Elena Reshetova &lt;elena.reshetova@intel.com&gt;
To: linux-kernel@vger.kernel.org
Cc: linux-mm@kvack.org, peterz@infradead.org,
	gregkh@linuxfoundation.org, viro@zeniv.linux.org.uk,
	catalin.marinas@arm.com, mingo@redhat.com,
	akpm@linux-foundation.org, arnd@arndb.de, luto@kernel.org,
	Elena Reshetova &lt;elena.reshetova@intel.com&gt;,
	Hans Liljestrand &lt;ishkamiel@gmail.com&gt;,
	Kees Cook &lt;keescook@chromium.org&gt;, David Windsor &lt;dwindsor@gmail.com&gt;
Subject: [PATCH 4/5] mm: convert mm_struct.mm_users from atomic_t to
	refcount_t
Date: Mon, 20 Feb 2017 12:49:13 +0200
Message-Id: &lt;1487587754-10610-5-git-send-email-elena.reshetova@intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1487587754-10610-1-git-send-email-elena.reshetova@intel.com&gt;
References: &lt;1487587754-10610-1-git-send-email-elena.reshetova@intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=169483">Elena Reshetova</a> - Feb. 20, 2017, 10:49 a.m.</div>
<pre class="content">
refcount_t type and corresponding API should be
used instead of atomic_t when the variable is used as
a reference counter. This allows to avoid accidental
refcounter overflows that might lead to use-after-free
situations.
<span class="signed-off-by">
Signed-off-by: Elena Reshetova &lt;elena.reshetova@intel.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Hans Liljestrand &lt;ishkamiel@gmail.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="signed-off-by">Signed-off-by: David Windsor &lt;dwindsor@gmail.com&gt;</span>
---
 arch/alpha/kernel/smp.c               |  6 +++---
 arch/arc/mm/tlb.c                     |  2 +-
 arch/blackfin/mach-common/smp.c       |  2 +-
 arch/ia64/include/asm/tlbflush.h      |  2 +-
 arch/ia64/kernel/smp.c                |  2 +-
 arch/ia64/sn/kernel/sn2/sn2_smp.c     |  4 ++--
 arch/mips/kernel/process.c            |  2 +-
 arch/mips/kernel/smp.c                |  6 +++---
 arch/parisc/include/asm/mmu_context.h |  2 +-
 arch/powerpc/mm/hugetlbpage.c         |  2 +-
 arch/powerpc/mm/icswx.c               |  4 ++--
 arch/sh/kernel/smp.c                  |  6 +++---
 arch/sparc/kernel/smp_64.c            |  6 +++---
 arch/sparc/mm/srmmu.c                 |  2 +-
 arch/um/kernel/tlb.c                  |  2 +-
 arch/x86/kernel/tboot.c               |  2 +-
 arch/xtensa/kernel/smp.c              |  5 +++++
 drivers/firmware/efi/arm-runtime.c    |  2 +-
 fs/coredump.c                         |  2 +-
 fs/proc/base.c                        | 10 +++++++++-
 include/linux/mm_types.h              |  3 ++-
 include/linux/sched.h                 |  4 ++--
 kernel/events/uprobes.c               |  2 +-
 kernel/exit.c                         |  2 +-
 kernel/fork.c                         | 10 +++++-----
 kernel/sched/core.c                   |  2 +-
 lib/is_single_threaded.c              |  2 +-
 mm/debug.c                            |  2 +-
 mm/init-mm.c                          |  2 +-
 mm/khugepaged.c                       |  2 +-
 mm/ksm.c                              |  2 +-
 mm/memory.c                           |  2 +-
 mm/mmu_notifier.c                     |  4 ++--
 mm/mprotect.c                         |  2 +-
 mm/oom_kill.c                         |  2 +-
 mm/swapfile.c                         |  2 +-
 mm/vmacache.c                         |  2 +-
 37 files changed, 66 insertions(+), 52 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=143191">kbuild test robot</a> - Feb. 20, 2017, 11:46 a.m.</div>
<pre class="content">
Hi Elena,

[auto build test ERROR on mmotm/master]
[also build test ERROR on next-20170220]
[cannot apply to linus/master linux/master v4.10]
[if your patch is applied to the wrong git tree, please drop us a note to help improve the system]

url:    https://github.com/0day-ci/linux/commits/Elena-Reshetova/mm-subsystem-refcounter-conversions/20170220-190351
base:   git://git.cmpxchg.org/linux-mmotm.git master
config: i386-randconfig-x011-201708 (attached as .config)
compiler: gcc-6 (Debian 6.2.0-3) 6.2.0 20160901
reproduce:
        # save the attached .config to linux build tree
        make ARCH=i386 

Note: the linux-review/Elena-Reshetova/mm-subsystem-refcounter-conversions/20170220-190351 HEAD 3b4bd307e7ad16dfd7fa504e7dbd951598fcc757 builds fine.
      It only hurts bisectibility.

All errors (new ones prefixed by &gt;&gt;):

   fs/proc/base.c: In function &#39;environ_read&#39;:
<span class="quote">&gt;&gt; fs/proc/base.c:924:1: error: version control conflict marker in file</span>
    &lt;&lt;&lt;&lt;&lt;&lt;&lt; e5c2d109eae88b7c203d396dfaeb284f95f6ffe5
    ^~~~~~~
   fs/proc/base.c:968:1: warning: label &#39;free&#39; defined but not used [-Wunused-label]
    free:
    ^~~~
   fs/proc/base.c: In function &#39;__set_oom_adj&#39;:
   fs/proc/base.c:1071:1: error: version control conflict marker in file
    &lt;&lt;&lt;&lt;&lt;&lt;&lt; e5c2d109eae88b7c203d396dfaeb284f95f6ffe5
    ^~~~~~~
   fs/proc/base.c:1073:1: error: version control conflict marker in file
    =======
    ^~~~~~~
   fs/proc/base.c:1075:1: error: version control conflict marker in file
<span class="quote">    &gt;&gt;&gt;&gt;&gt;&gt;&gt; mm: convert mm_struct.mm_users from atomic_t to refcount_t</span>
    ^~~~~~~

vim +924 fs/proc/base.c

   918	
   919		page = (char *)__get_free_page(GFP_TEMPORARY);
   920		if (!page)
   921			return -ENOMEM;
   922	
   923		ret = 0;
<span class="quote"> &gt; 924	&lt;&lt;&lt;&lt;&lt;&lt;&lt; e5c2d109eae88b7c203d396dfaeb284f95f6ffe5</span>
   925		if (!mmget_not_zero(mm))
   926	=======
   927		if (!refcount_inc_not_zero(&amp;mm-&gt;mm_users))

---
0-DAY kernel test infrastructure                Open Source Technology Center
https://lists.01.org/pipermail/kbuild-all                   Intel Corporation
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/alpha/kernel/smp.c b/arch/alpha/kernel/smp.c</span>
<span class="p_header">index acb4b14..c4a82f0 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/smp.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/smp.c</span>
<span class="p_chunk">@@ -653,7 +653,7 @@</span> <span class="p_context"> flush_tlb_mm(struct mm_struct *mm)</span>
 
 	if (mm == current-&gt;active_mm) {
 		flush_tlb_current(mm);
<span class="p_del">-		if (atomic_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
<span class="p_add">+		if (refcount_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
 			int cpu, this_cpu = smp_processor_id();
 			for (cpu = 0; cpu &lt; NR_CPUS; cpu++) {
 				if (!cpu_online(cpu) || cpu == this_cpu)
<span class="p_chunk">@@ -702,7 +702,7 @@</span> <span class="p_context"> flush_tlb_page(struct vm_area_struct *vma, unsigned long addr)</span>
 
 	if (mm == current-&gt;active_mm) {
 		flush_tlb_current_page(mm, vma, addr);
<span class="p_del">-		if (atomic_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
<span class="p_add">+		if (refcount_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
 			int cpu, this_cpu = smp_processor_id();
 			for (cpu = 0; cpu &lt; NR_CPUS; cpu++) {
 				if (!cpu_online(cpu) || cpu == this_cpu)
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> flush_icache_user_range(struct vm_area_struct *vma, struct page *page,</span>
 
 	if (mm == current-&gt;active_mm) {
 		__load_new_mm_context(mm);
<span class="p_del">-		if (atomic_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
<span class="p_add">+		if (refcount_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
 			int cpu, this_cpu = smp_processor_id();
 			for (cpu = 0; cpu &lt; NR_CPUS; cpu++) {
 				if (!cpu_online(cpu) || cpu == this_cpu)
<span class="p_header">diff --git a/arch/arc/mm/tlb.c b/arch/arc/mm/tlb.c</span>
<span class="p_header">index bdb295e..6dbdfe7 100644</span>
<span class="p_header">--- a/arch/arc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/arc/mm/tlb.c</span>
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> noinline void local_flush_tlb_mm(struct mm_struct *mm)</span>
 	 * Only for fork( ) do we need to move parent to a new MMU ctxt,
 	 * all other cases are NOPs, hence this check.
 	 */
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == 0)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == 0)</span>
 		return;
 
 	/*
<span class="p_header">diff --git a/arch/blackfin/mach-common/smp.c b/arch/blackfin/mach-common/smp.c</span>
<span class="p_header">index a2e6db2..bab73d2b 100644</span>
<span class="p_header">--- a/arch/blackfin/mach-common/smp.c</span>
<span class="p_header">+++ b/arch/blackfin/mach-common/smp.c</span>
<span class="p_chunk">@@ -422,7 +422,7 @@</span> <span class="p_context"> void cpu_die(void)</span>
 {
 	(void)cpu_report_death();
 
<span class="p_del">-	atomic_dec(&amp;init_mm.mm_users);</span>
<span class="p_add">+	refcount_dec(&amp;init_mm.mm_users);</span>
 	atomic_dec(&amp;init_mm.mm_count);
 
 	local_irq_disable();
<span class="p_header">diff --git a/arch/ia64/include/asm/tlbflush.h b/arch/ia64/include/asm/tlbflush.h</span>
<span class="p_header">index 3be25df..650708a 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"> flush_tlb_mm (struct mm_struct *mm)</span>
 	set_bit(mm-&gt;context, ia64_ctx.flushmap);
 	mm-&gt;context = 0;
 
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == 0)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == 0)</span>
 		return;		/* happens as a result of exit_mmap() */
 
 #ifdef CONFIG_SMP
<span class="p_header">diff --git a/arch/ia64/kernel/smp.c b/arch/ia64/kernel/smp.c</span>
<span class="p_header">index 7f706d4..dd7b680 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/smp.c</span>
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> smp_flush_tlb_mm (struct mm_struct *mm)</span>
 	cpumask_var_t cpus;
 	preempt_disable();
 	/* this happens for the common case of a single-threaded fork():  */
<span class="p_del">-	if (likely(mm == current-&gt;active_mm &amp;&amp; atomic_read(&amp;mm-&gt;mm_users) == 1))</span>
<span class="p_add">+	if (likely(mm == current-&gt;active_mm &amp;&amp; refcount_read(&amp;mm-&gt;mm_users) == 1))</span>
 	{
 		local_finish_flush_tlb_mm(mm);
 		preempt_enable();
<span class="p_header">diff --git a/arch/ia64/sn/kernel/sn2/sn2_smp.c b/arch/ia64/sn/kernel/sn2/sn2_smp.c</span>
<span class="p_header">index c98dc96..1c801b3 100644</span>
<span class="p_header">--- a/arch/ia64/sn/kernel/sn2/sn2_smp.c</span>
<span class="p_header">+++ b/arch/ia64/sn/kernel/sn2/sn2_smp.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> void sn_migrate(struct task_struct *task)</span>
 void sn_tlb_migrate_finish(struct mm_struct *mm)
 {
 	/* flush_tlb_mm is inefficient if more than 1 users of mm */
<span class="p_del">-	if (mm == current-&gt;mm &amp;&amp; mm &amp;&amp; atomic_read(&amp;mm-&gt;mm_users) == 1)</span>
<span class="p_add">+	if (mm == current-&gt;mm &amp;&amp; mm &amp;&amp; refcount_read(&amp;mm-&gt;mm_users) == 1)</span>
 		flush_tlb_mm(mm);
 }
 
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> sn2_global_tlb_purge(struct mm_struct *mm, unsigned long start,</span>
 		return;
 	}
 
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == 1 &amp;&amp; mymm) {</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == 1 &amp;&amp; mymm) {</span>
 		flush_tlb_mm(mm);
 		__this_cpu_inc(ptcstats.change_rid);
 		preempt_enable();
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index 803e255..33fa000 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -698,7 +698,7 @@</span> <span class="p_context"> int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)</span>
 		/* No need to send an IPI for the local CPU */
 		max_users = (task-&gt;mm == current-&gt;mm) ? 1 : 0;
 
<span class="p_del">-		if (atomic_read(&amp;current-&gt;mm-&gt;mm_users) &gt; max_users)</span>
<span class="p_add">+		if (refcount_read(&amp;current-&gt;mm-&gt;mm_users) &gt; max_users)</span>
 			smp_call_function(prepare_for_fp_mode_switch,
 					  (void *)current-&gt;mm, 1);
 	}
<span class="p_header">diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c</span>
<span class="p_header">index 8c60a29..e62aa56 100644</span>
<span class="p_header">--- a/arch/mips/kernel/smp.c</span>
<span class="p_header">+++ b/arch/mips/kernel/smp.c</span>
<span class="p_chunk">@@ -511,7 +511,7 @@</span> <span class="p_context"> void flush_tlb_mm(struct mm_struct *mm)</span>
 {
 	preempt_disable();
 
<span class="p_del">-	if ((atomic_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
<span class="p_add">+	if ((refcount_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
 		smp_on_other_tlbs(flush_tlb_mm_ipi, mm);
 	} else {
 		unsigned int cpu;
<span class="p_chunk">@@ -544,7 +544,7 @@</span> <span class="p_context"> void flush_tlb_range(struct vm_area_struct *vma, unsigned long start, unsigned l</span>
 	struct mm_struct *mm = vma-&gt;vm_mm;
 
 	preempt_disable();
<span class="p_del">-	if ((atomic_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
<span class="p_add">+	if ((refcount_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
 		struct flush_tlb_data fd = {
 			.vma = vma,
 			.addr1 = start,
<span class="p_chunk">@@ -598,7 +598,7 @@</span> <span class="p_context"> static void flush_tlb_page_ipi(void *info)</span>
 void flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 {
 	preempt_disable();
<span class="p_del">-	if ((atomic_read(&amp;vma-&gt;vm_mm-&gt;mm_users) != 1) || (current-&gt;mm != vma-&gt;vm_mm)) {</span>
<span class="p_add">+	if ((refcount_read(&amp;vma-&gt;vm_mm-&gt;mm_users) != 1) || (current-&gt;mm != vma-&gt;vm_mm)) {</span>
 		struct flush_tlb_data fd = {
 			.vma = vma,
 			.addr1 = page,
<span class="p_header">diff --git a/arch/parisc/include/asm/mmu_context.h b/arch/parisc/include/asm/mmu_context.h</span>
<span class="p_header">index 59be257..e64f398 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"> extern void free_sid(unsigned long);</span>
 static inline int
 init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
<span class="p_del">-	BUG_ON(atomic_read(&amp;mm-&gt;mm_users) != 1);</span>
<span class="p_add">+	BUG_ON(refcount_read(&amp;mm-&gt;mm_users) != 1);</span>
 
 	mm-&gt;context = alloc_sid();
 	return 0;
<span class="p_header">diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_header">index 8c3389c..26aef24 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> static void hugepd_free(struct mmu_gather *tlb, void *hugepte)</span>
 
 	batchp = &amp;get_cpu_var(hugepd_freelist_cur);
 
<span class="p_del">-	if (atomic_read(&amp;tlb-&gt;mm-&gt;mm_users) &lt; 2 ||</span>
<span class="p_add">+	if (refcount_read(&amp;tlb-&gt;mm-&gt;mm_users) &lt; 2 ||</span>
 	    cpumask_equal(mm_cpumask(tlb-&gt;mm),
 			  cpumask_of(smp_processor_id()))) {
 		kmem_cache_free(hugepte_cache, hugepte);
<span class="p_header">diff --git a/arch/powerpc/mm/icswx.c b/arch/powerpc/mm/icswx.c</span>
<span class="p_header">index 915412e..2406ff8 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/icswx.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/icswx.c</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"> int use_cop(unsigned long acop, struct mm_struct *mm)</span>
 	 * running. We need to send an IPI to force them to pick up any
 	 * change in PID and ACOP.
 	 */
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) &gt; 1)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) &gt; 1)</span>
 		smp_call_function(sync_cop, mm, 1);
 
 out:
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> void drop_cop(unsigned long acop, struct mm_struct *mm)</span>
 	 * running. We need to send an IPI to force them to pick up any
 	 * change in PID and ACOP.
 	 */
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) &gt; 1)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) &gt; 1)</span>
 		smp_call_function(sync_cop, mm, 1);
 
 	if (free_pid != COP_PID_NONE)
<span class="p_header">diff --git a/arch/sh/kernel/smp.c b/arch/sh/kernel/smp.c</span>
<span class="p_header">index edc4769..9d678bb 100644</span>
<span class="p_header">--- a/arch/sh/kernel/smp.c</span>
<span class="p_header">+++ b/arch/sh/kernel/smp.c</span>
<span class="p_chunk">@@ -363,7 +363,7 @@</span> <span class="p_context"> void flush_tlb_mm(struct mm_struct *mm)</span>
 {
 	preempt_disable();
 
<span class="p_del">-	if ((atomic_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
<span class="p_add">+	if ((refcount_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
 		smp_call_function(flush_tlb_mm_ipi, (void *)mm, 1);
 	} else {
 		int i;
<span class="p_chunk">@@ -395,7 +395,7 @@</span> <span class="p_context"> void flush_tlb_range(struct vm_area_struct *vma,</span>
 	struct mm_struct *mm = vma-&gt;vm_mm;
 
 	preempt_disable();
<span class="p_del">-	if ((atomic_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
<span class="p_add">+	if ((refcount_read(&amp;mm-&gt;mm_users) != 1) || (current-&gt;mm != mm)) {</span>
 		struct flush_tlb_data fd;
 
 		fd.vma = vma;
<span class="p_chunk">@@ -438,7 +438,7 @@</span> <span class="p_context"> static void flush_tlb_page_ipi(void *info)</span>
 void flush_tlb_page(struct vm_area_struct *vma, unsigned long page)
 {
 	preempt_disable();
<span class="p_del">-	if ((atomic_read(&amp;vma-&gt;vm_mm-&gt;mm_users) != 1) ||</span>
<span class="p_add">+	if ((refcount_read(&amp;vma-&gt;vm_mm-&gt;mm_users) != 1) ||</span>
 	    (current-&gt;mm != vma-&gt;vm_mm)) {
 		struct flush_tlb_data fd;
 
<span class="p_header">diff --git a/arch/sparc/kernel/smp_64.c b/arch/sparc/kernel/smp_64.c</span>
<span class="p_header">index dcb12d9..bd5e56c 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/smp_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/smp_64.c</span>
<span class="p_chunk">@@ -1063,7 +1063,7 @@</span> <span class="p_context"> void smp_flush_tlb_mm(struct mm_struct *mm)</span>
 	u32 ctx = CTX_HWBITS(mm-&gt;context);
 	int cpu = get_cpu();
 
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == 1) {</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == 1) {</span>
 		cpumask_copy(mm_cpumask(mm), cpumask_of(cpu));
 		goto local_flush_and_out;
 	}
<span class="p_chunk">@@ -1101,7 +1101,7 @@</span> <span class="p_context"> void smp_flush_tlb_pending(struct mm_struct *mm, unsigned long nr, unsigned long</span>
 	info.nr = nr;
 	info.vaddrs = vaddrs;
 
<span class="p_del">-	if (mm == current-&gt;mm &amp;&amp; atomic_read(&amp;mm-&gt;mm_users) == 1)</span>
<span class="p_add">+	if (mm == current-&gt;mm &amp;&amp; refcount_read(&amp;mm-&gt;mm_users) == 1)</span>
 		cpumask_copy(mm_cpumask(mm), cpumask_of(cpu));
 	else
 		smp_call_function_many(mm_cpumask(mm), tlb_pending_func,
<span class="p_chunk">@@ -1117,7 +1117,7 @@</span> <span class="p_context"> void smp_flush_tlb_page(struct mm_struct *mm, unsigned long vaddr)</span>
 	unsigned long context = CTX_HWBITS(mm-&gt;context);
 	int cpu = get_cpu();
 
<span class="p_del">-	if (mm == current-&gt;mm &amp;&amp; atomic_read(&amp;mm-&gt;mm_users) == 1)</span>
<span class="p_add">+	if (mm == current-&gt;mm &amp;&amp; refcount_read(&amp;mm-&gt;mm_users) == 1)</span>
 		cpumask_copy(mm_cpumask(mm), cpumask_of(cpu));
 	else
 		smp_cross_call_masked(&amp;xcall_flush_tlb_page,
<span class="p_header">diff --git a/arch/sparc/mm/srmmu.c b/arch/sparc/mm/srmmu.c</span>
<span class="p_header">index c7f2a52..17941a8 100644</span>
<span class="p_header">--- a/arch/sparc/mm/srmmu.c</span>
<span class="p_header">+++ b/arch/sparc/mm/srmmu.c</span>
<span class="p_chunk">@@ -1662,7 +1662,7 @@</span> <span class="p_context"> static void smp_flush_tlb_mm(struct mm_struct *mm)</span>
 		cpumask_clear_cpu(smp_processor_id(), &amp;cpu_mask);
 		if (!cpumask_empty(&amp;cpu_mask)) {
 			xc1((smpfunc_t) local_ops-&gt;tlb_mm, (unsigned long) mm);
<span class="p_del">-			if (atomic_read(&amp;mm-&gt;mm_users) == 1 &amp;&amp; current-&gt;active_mm == mm)</span>
<span class="p_add">+			if (refcount_read(&amp;mm-&gt;mm_users) == 1 &amp;&amp; current-&gt;active_mm == mm)</span>
 				cpumask_copy(mm_cpumask(mm),
 					     cpumask_of(smp_processor_id()));
 		}
<span class="p_header">diff --git a/arch/um/kernel/tlb.c b/arch/um/kernel/tlb.c</span>
<span class="p_header">index 3777b82..1da0463 100644</span>
<span class="p_header">--- a/arch/um/kernel/tlb.c</span>
<span class="p_header">+++ b/arch/um/kernel/tlb.c</span>
<span class="p_chunk">@@ -530,7 +530,7 @@</span> <span class="p_context"> void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,</span>
 	 * Don&#39;t bother flushing if this address space is about to be
 	 * destroyed.
 	 */
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == 0)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == 0)</span>
 		return;
 
 	fix_range(mm, start, end, 0);
<span class="p_header">diff --git a/arch/x86/kernel/tboot.c b/arch/x86/kernel/tboot.c</span>
<span class="p_header">index b868fa1..39aaca5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/tboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/tboot.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static pgd_t *tboot_pg_dir;</span>
 static struct mm_struct tboot_mm = {
 	.mm_rb          = RB_ROOT,
 	.pgd            = swapper_pg_dir,
<span class="p_del">-	.mm_users       = ATOMIC_INIT(2),</span>
<span class="p_add">+	.mm_users       = REFCOUNT_INIT(2),</span>
 	.mm_count       = ATOMIC_INIT(1),
 	.mmap_sem       = __RWSEM_INITIALIZER(init_mm.mmap_sem),
 	.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),
<span class="p_header">diff --git a/arch/xtensa/kernel/smp.c b/arch/xtensa/kernel/smp.c</span>
<span class="p_header">index fcea720..c2b3067 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/smp.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/smp.c</span>
<span class="p_chunk">@@ -135,8 +135,13 @@</span> <span class="p_context"> void secondary_start_kernel(void)</span>
 
 	/* All kernel threads share the same mm context. */
 
<span class="p_add">+&lt;&lt;&lt;&lt;&lt;&lt;&lt; e5c2d109eae88b7c203d396dfaeb284f95f6ffe5</span>
 	mmget(mm);
 	mmgrab(mm);
<span class="p_add">+=======</span>
<span class="p_add">+	refcount_inc(&amp;mm-&gt;mm_users);</span>
<span class="p_add">+	atomic_inc(&amp;mm-&gt;mm_count);</span>
<span class="p_add">+&gt;&gt;&gt;&gt;&gt;&gt;&gt; mm: convert mm_struct.mm_users from atomic_t to refcount_t</span>
 	current-&gt;active_mm = mm;
 	cpumask_set_cpu(cpu, mm_cpumask(mm));
 	enter_lazy_tlb(mm, current);
<span class="p_header">diff --git a/drivers/firmware/efi/arm-runtime.c b/drivers/firmware/efi/arm-runtime.c</span>
<span class="p_header">index 349dc3e..23e41f9 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/arm-runtime.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/arm-runtime.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> extern u64 efi_system_table;</span>
 
 static struct mm_struct efi_mm = {
 	.mm_rb			= RB_ROOT,
<span class="p_del">-	.mm_users		= ATOMIC_INIT(2),</span>
<span class="p_add">+	.mm_users		= REFCOUNT_INIT(2),</span>
 	.mm_count		= ATOMIC_INIT(1),
 	.mmap_sem		= __RWSEM_INITIALIZER(efi_mm.mmap_sem),
 	.page_table_lock	= __SPIN_LOCK_UNLOCKED(efi_mm.page_table_lock),
<span class="p_header">diff --git a/fs/coredump.c b/fs/coredump.c</span>
<span class="p_header">index ae6b056..05e43f1 100644</span>
<span class="p_header">--- a/fs/coredump.c</span>
<span class="p_header">+++ b/fs/coredump.c</span>
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> static int zap_threads(struct task_struct *tsk, struct mm_struct *mm,</span>
 		return nr;
 
 	tsk-&gt;flags |= PF_DUMPCORE;
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == nr + 1)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == nr + 1)</span>
 		goto done;
 	/*
 	 * We should find and kill all tasks which use this mm, and we should
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 6e86558..a75dca3 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -921,7 +921,11 @@</span> <span class="p_context"> static ssize_t environ_read(struct file *file, char __user *buf,</span>
 		return -ENOMEM;
 
 	ret = 0;
<span class="p_add">+&lt;&lt;&lt;&lt;&lt;&lt;&lt; e5c2d109eae88b7c203d396dfaeb284f95f6ffe5</span>
 	if (!mmget_not_zero(mm))
<span class="p_add">+=======</span>
<span class="p_add">+	if (!refcount_inc_not_zero(&amp;mm-&gt;mm_users))</span>
<span class="p_add">+&gt;&gt;&gt;&gt;&gt;&gt;&gt; mm: convert mm_struct.mm_users from atomic_t to refcount_t</span>
 		goto free;
 
 	down_read(&amp;mm-&gt;mmap_sem);
<span class="p_chunk">@@ -1062,9 +1066,13 @@</span> <span class="p_context"> static int __set_oom_adj(struct file *file, int oom_adj, bool legacy)</span>
 		struct task_struct *p = find_lock_task_mm(task);
 
 		if (p) {
<span class="p_del">-			if (atomic_read(&amp;p-&gt;mm-&gt;mm_users) &gt; 1) {</span>
<span class="p_add">+			if (refcount_read(&amp;p-&gt;mm-&gt;mm_users) &gt; 1) {</span>
 				mm = p-&gt;mm;
<span class="p_add">+&lt;&lt;&lt;&lt;&lt;&lt;&lt; e5c2d109eae88b7c203d396dfaeb284f95f6ffe5</span>
 				mmgrab(mm);
<span class="p_add">+=======</span>
<span class="p_add">+				refcount_inc(&amp;mm-&gt;mm_count);</span>
<span class="p_add">+&gt;&gt;&gt;&gt;&gt;&gt;&gt; mm: convert mm_struct.mm_users from atomic_t to refcount_t</span>
 			}
 			task_unlock(p);
 		}
<span class="p_header">diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h</span>
<span class="p_header">index 4f6d440..af260d6 100644</span>
<span class="p_header">--- a/include/linux/mm_types.h</span>
<span class="p_header">+++ b/include/linux/mm_types.h</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/list.h&gt;
 #include &lt;linux/spinlock.h&gt;
 #include &lt;linux/rbtree.h&gt;
<span class="p_add">+#include &lt;linux/refcount.h&gt;</span>
 #include &lt;linux/rwsem.h&gt;
 #include &lt;linux/completion.h&gt;
 #include &lt;linux/cpumask.h&gt;
<span class="p_chunk">@@ -417,7 +418,7 @@</span> <span class="p_context"> struct mm_struct {</span>
 	 * (which may then free the &amp;struct mm_struct if @mm_count also
 	 * drops to 0).
 	 */
<span class="p_del">-	atomic_t mm_users;</span>
<span class="p_add">+	refcount_t mm_users;</span>
 
 	/**
 	 * @mm_count: The number of references to &amp;struct mm_struct
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index affcd93..c21682c 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -2967,12 +2967,12 @@</span> <span class="p_context"> static inline void mmdrop_async(struct mm_struct *mm)</span>
  */
 static inline void mmget(struct mm_struct *mm)
 {
<span class="p_del">-	atomic_inc(&amp;mm-&gt;mm_users);</span>
<span class="p_add">+	refcount_inc(&amp;mm-&gt;mm_users);</span>
 }
 
 static inline bool mmget_not_zero(struct mm_struct *mm)
 {
<span class="p_del">-	return atomic_inc_not_zero(&amp;mm-&gt;mm_users);</span>
<span class="p_add">+	return refcount_inc_not_zero(&amp;mm-&gt;mm_users);</span>
 }
 
 /* mmput gets rid of the mappings and all user-space */
<span class="p_header">diff --git a/kernel/events/uprobes.c b/kernel/events/uprobes.c</span>
<span class="p_header">index 95e42f0..a4b33f8 100644</span>
<span class="p_header">--- a/kernel/events/uprobes.c</span>
<span class="p_header">+++ b/kernel/events/uprobes.c</span>
<span class="p_chunk">@@ -1121,7 +1121,7 @@</span> <span class="p_context"> void uprobe_munmap(struct vm_area_struct *vma, unsigned long start, unsigned lon</span>
 	if (no_uprobe_events() || !valid_vma(vma, false))
 		return;
 
<span class="p_del">-	if (!atomic_read(&amp;vma-&gt;vm_mm-&gt;mm_users)) /* called by mmput() ? */</span>
<span class="p_add">+	if (!refcount_read(&amp;vma-&gt;vm_mm-&gt;mm_users)) /* called by mmput() ? */</span>
 		return;
 
 	if (!test_bit(MMF_HAS_UPROBES, &amp;vma-&gt;vm_mm-&gt;flags) ||
<span class="p_header">diff --git a/kernel/exit.c b/kernel/exit.c</span>
<span class="p_header">index 8a768a3..261305d 100644</span>
<span class="p_header">--- a/kernel/exit.c</span>
<span class="p_header">+++ b/kernel/exit.c</span>
<span class="p_chunk">@@ -426,7 +426,7 @@</span> <span class="p_context"> void mm_update_next_owner(struct mm_struct *mm)</span>
 	 * candidates.  Do not leave the mm pointing to a possibly
 	 * freed task structure.
 	 */
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) &lt;= 1) {</span>
 		mm-&gt;owner = NULL;
 		return;
 	}
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 0e096fc..60ff801 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -759,7 +759,7 @@</span> <span class="p_context"> static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p,</span>
 	mm-&gt;mmap = NULL;
 	mm-&gt;mm_rb = RB_ROOT;
 	mm-&gt;vmacache_seqnum = 0;
<span class="p_del">-	atomic_set(&amp;mm-&gt;mm_users, 1);</span>
<span class="p_add">+	refcount_set(&amp;mm-&gt;mm_users, 1);</span>
 	atomic_set(&amp;mm-&gt;mm_count, 1);
 	init_rwsem(&amp;mm-&gt;mmap_sem);
 	INIT_LIST_HEAD(&amp;mm-&gt;mmlist);
<span class="p_chunk">@@ -862,7 +862,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(__mmdrop);</span>
 
 static inline void __mmput(struct mm_struct *mm)
 {
<span class="p_del">-	VM_BUG_ON(atomic_read(&amp;mm-&gt;mm_users));</span>
<span class="p_add">+	VM_BUG_ON(refcount_read(&amp;mm-&gt;mm_users));</span>
 
 	uprobe_clear_state(mm);
 	exit_aio(mm);
<span class="p_chunk">@@ -889,7 +889,7 @@</span> <span class="p_context"> void mmput(struct mm_struct *mm)</span>
 {
 	might_sleep();
 
<span class="p_del">-	if (atomic_dec_and_test(&amp;mm-&gt;mm_users))</span>
<span class="p_add">+	if (refcount_dec_and_test(&amp;mm-&gt;mm_users))</span>
 		__mmput(mm);
 }
 EXPORT_SYMBOL_GPL(mmput);
<span class="p_chunk">@@ -903,7 +903,7 @@</span> <span class="p_context"> static void mmput_async_fn(struct work_struct *work)</span>
 
 void mmput_async(struct mm_struct *mm)
 {
<span class="p_del">-	if (atomic_dec_and_test(&amp;mm-&gt;mm_users)) {</span>
<span class="p_add">+	if (refcount_dec_and_test(&amp;mm-&gt;mm_users)) {</span>
 		INIT_WORK(&amp;mm-&gt;async_put_work, mmput_async_fn);
 		schedule_work(&amp;mm-&gt;async_put_work);
 	}
<span class="p_chunk">@@ -1102,7 +1102,7 @@</span> <span class="p_context"> void mm_release(struct task_struct *tsk, struct mm_struct *mm)</span>
 	 */
 	if (tsk-&gt;clear_child_tid) {
 		if (!(tsk-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_COREDUMP) &amp;&amp;
<span class="p_del">-		    atomic_read(&amp;mm-&gt;mm_users) &gt; 1) {</span>
<span class="p_add">+		    refcount_read(&amp;mm-&gt;mm_users) &gt; 1) {</span>
 			/*
 			 * We don&#39;t check the error code - if userspace has
 			 * not set up a proper pointer then tough luck.
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index c7ded33..324ea09 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -2196,7 +2196,7 @@</span> <span class="p_context"> static void __sched_fork(unsigned long clone_flags, struct task_struct *p)</span>
 #endif
 
 #ifdef CONFIG_NUMA_BALANCING
<span class="p_del">-	if (p-&gt;mm &amp;&amp; atomic_read(&amp;p-&gt;mm-&gt;mm_users) == 1) {</span>
<span class="p_add">+	if (p-&gt;mm &amp;&amp; refcount_read(&amp;p-&gt;mm-&gt;mm_users) == 1) {</span>
 		p-&gt;mm-&gt;numa_next_scan = jiffies + msecs_to_jiffies(sysctl_numa_balancing_scan_delay);
 		p-&gt;mm-&gt;numa_scan_seq = 0;
 	}
<span class="p_header">diff --git a/lib/is_single_threaded.c b/lib/is_single_threaded.c</span>
<span class="p_header">index 391fd23..295ddcf 100644</span>
<span class="p_header">--- a/lib/is_single_threaded.c</span>
<span class="p_header">+++ b/lib/is_single_threaded.c</span>
<span class="p_chunk">@@ -25,7 +25,7 @@</span> <span class="p_context"> bool current_is_single_threaded(void)</span>
 	if (atomic_read(&amp;task-&gt;signal-&gt;live) != 1)
 		return false;
 
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == 1)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == 1)</span>
 		return true;
 
 	ret = false;
<span class="p_header">diff --git a/mm/debug.c b/mm/debug.c</span>
<span class="p_header">index db1cd26..0866505 100644</span>
<span class="p_header">--- a/mm/debug.c</span>
<span class="p_header">+++ b/mm/debug.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> void dump_mm(const struct mm_struct *mm)</span>
 		mm-&gt;get_unmapped_area,
 #endif
 		mm-&gt;mmap_base, mm-&gt;mmap_legacy_base, mm-&gt;highest_vm_end,
<span class="p_del">-		mm-&gt;pgd, atomic_read(&amp;mm-&gt;mm_users),</span>
<span class="p_add">+		mm-&gt;pgd, refcount_read(&amp;mm-&gt;mm_users),</span>
 		atomic_read(&amp;mm-&gt;mm_count),
 		atomic_long_read((atomic_long_t *)&amp;mm-&gt;nr_ptes),
 		mm_nr_pmds((struct mm_struct *)mm),
<span class="p_header">diff --git a/mm/init-mm.c b/mm/init-mm.c</span>
<span class="p_header">index 975e49f..6927a72 100644</span>
<span class="p_header">--- a/mm/init-mm.c</span>
<span class="p_header">+++ b/mm/init-mm.c</span>
<span class="p_chunk">@@ -17,7 +17,7 @@</span> <span class="p_context"></span>
 struct mm_struct init_mm = {
 	.mm_rb		= RB_ROOT,
 	.pgd		= swapper_pg_dir,
<span class="p_del">-	.mm_users	= ATOMIC_INIT(2),</span>
<span class="p_add">+	.mm_users	= REFCOUNT_INIT(2),</span>
 	.mm_count	= ATOMIC_INIT(1),
 	.mmap_sem	= __RWSEM_INITIALIZER(init_mm.mmap_sem),
 	.page_table_lock =  __SPIN_LOCK_UNLOCKED(init_mm.page_table_lock),
<span class="p_header">diff --git a/mm/khugepaged.c b/mm/khugepaged.c</span>
<span class="p_header">index 34bce5c..e7c11a6 100644</span>
<span class="p_header">--- a/mm/khugepaged.c</span>
<span class="p_header">+++ b/mm/khugepaged.c</span>
<span class="p_chunk">@@ -391,7 +391,7 @@</span> <span class="p_context"> static void insert_to_mm_slots_hash(struct mm_struct *mm,</span>
 
 static inline int khugepaged_test_exit(struct mm_struct *mm)
 {
<span class="p_del">-	return atomic_read(&amp;mm-&gt;mm_users) == 0;</span>
<span class="p_add">+	return refcount_read(&amp;mm-&gt;mm_users) == 0;</span>
 }
 
 int __khugepaged_enter(struct mm_struct *mm)
<span class="p_header">diff --git a/mm/ksm.c b/mm/ksm.c</span>
<span class="p_header">index 2e129f0..6152465 100644</span>
<span class="p_header">--- a/mm/ksm.c</span>
<span class="p_header">+++ b/mm/ksm.c</span>
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> static void insert_to_mm_slots_hash(struct mm_struct *mm,</span>
  */
 static inline bool ksm_test_exit(struct mm_struct *mm)
 {
<span class="p_del">-	return atomic_read(&amp;mm-&gt;mm_users) == 0;</span>
<span class="p_add">+	return refcount_read(&amp;mm-&gt;mm_users) == 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 0c759ba..cc93a22 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -374,7 +374,7 @@</span> <span class="p_context"> void tlb_remove_table(struct mmu_gather *tlb, void *table)</span>
 	 * When there&#39;s less then two users of this mm there cannot be a
 	 * concurrent page-table walk.
 	 */
<span class="p_del">-	if (atomic_read(&amp;tlb-&gt;mm-&gt;mm_users) &lt; 2) {</span>
<span class="p_add">+	if (refcount_read(&amp;tlb-&gt;mm-&gt;mm_users) &lt; 2) {</span>
 		__tlb_remove_table(table);
 		return;
 	}
<span class="p_header">diff --git a/mm/mmu_notifier.c b/mm/mmu_notifier.c</span>
<span class="p_header">index 32bc9f2..d8c11e1 100644</span>
<span class="p_header">--- a/mm/mmu_notifier.c</span>
<span class="p_header">+++ b/mm/mmu_notifier.c</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> static int do_mmu_notifier_register(struct mmu_notifier *mn,</span>
 	struct mmu_notifier_mm *mmu_notifier_mm;
 	int ret;
 
<span class="p_del">-	BUG_ON(atomic_read(&amp;mm-&gt;mm_users) &lt;= 0);</span>
<span class="p_add">+	BUG_ON(refcount_read(&amp;mm-&gt;mm_users) &lt;= 0);</span>
 
 	/*
 	 * Verify that mmu_notifier_init() already run and the global srcu is
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> static int do_mmu_notifier_register(struct mmu_notifier *mn,</span>
 		up_write(&amp;mm-&gt;mmap_sem);
 	kfree(mmu_notifier_mm);
 out:
<span class="p_del">-	BUG_ON(atomic_read(&amp;mm-&gt;mm_users) &lt;= 0);</span>
<span class="p_add">+	BUG_ON(refcount_read(&amp;mm-&gt;mm_users) &lt;= 0);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/mm/mprotect.c b/mm/mprotect.c</span>
<span class="p_header">index 77115bb..f482ce9 100644</span>
<span class="p_header">--- a/mm/mprotect.c</span>
<span class="p_header">+++ b/mm/mprotect.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,</span>
 
 	/* Get target node for single threaded private VMAs */
 	if (prot_numa &amp;&amp; !(vma-&gt;vm_flags &amp; VM_SHARED) &amp;&amp;
<span class="p_del">-	    atomic_read(&amp;vma-&gt;vm_mm-&gt;mm_users) == 1)</span>
<span class="p_add">+	    refcount_read(&amp;vma-&gt;vm_mm-&gt;mm_users) == 1)</span>
 		target_node = numa_node_id();
 
 	arch_enter_lazy_mmu_mode();
<span class="p_header">diff --git a/mm/oom_kill.c b/mm/oom_kill.c</span>
<span class="p_header">index 51c0918..cc0348d 100644</span>
<span class="p_header">--- a/mm/oom_kill.c</span>
<span class="p_header">+++ b/mm/oom_kill.c</span>
<span class="p_chunk">@@ -774,7 +774,7 @@</span> <span class="p_context"> static bool task_will_free_mem(struct task_struct *task)</span>
 	if (test_bit(MMF_OOM_SKIP, &amp;mm-&gt;flags))
 		return false;
 
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) &lt;= 1)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) &lt;= 1)</span>
 		return true;
 
 	/*
<span class="p_header">diff --git a/mm/swapfile.c b/mm/swapfile.c</span>
<span class="p_header">index 5ac2cb4..be949e4 100644</span>
<span class="p_header">--- a/mm/swapfile.c</span>
<span class="p_header">+++ b/mm/swapfile.c</span>
<span class="p_chunk">@@ -1722,7 +1722,7 @@</span> <span class="p_context"> int try_to_unuse(unsigned int type, bool frontswap,</span>
 		/*
 		 * Don&#39;t hold on to start_mm if it looks like exiting.
 		 */
<span class="p_del">-		if (atomic_read(&amp;start_mm-&gt;mm_users) == 1) {</span>
<span class="p_add">+		if (refcount_read(&amp;start_mm-&gt;mm_users) == 1) {</span>
 			mmput(start_mm);
 			start_mm = &amp;init_mm;
 			mmget(&amp;init_mm);
<span class="p_header">diff --git a/mm/vmacache.c b/mm/vmacache.c</span>
<span class="p_header">index 035fdeb..4747ee6 100644</span>
<span class="p_header">--- a/mm/vmacache.c</span>
<span class="p_header">+++ b/mm/vmacache.c</span>
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"> void vmacache_flush_all(struct mm_struct *mm)</span>
 	 * to worry about other threads&#39; seqnum. Current&#39;s
 	 * flush will occur upon the next lookup.
 	 */
<span class="p_del">-	if (atomic_read(&amp;mm-&gt;mm_users) == 1)</span>
<span class="p_add">+	if (refcount_read(&amp;mm-&gt;mm_users) == 1)</span>
 		return;
 
 	rcu_read_lock();

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



