
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[2/2] mm: rename page dtor functions to {compound,huge,transhuge}_page__dtor - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [2/2] mm: rename page dtor functions to {compound,huge,transhuge}_page__dtor</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=125281">Du, Changbin</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 16, 2017, 9:19 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1508145557-9944-3-git-send-email-changbin.du@intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10007949/mbox/"
   >mbox</a>
|
   <a href="/patch/10007949/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10007949/">/patch/10007949/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	42F0360230 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 16 Oct 2017 09:26:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3DD0C283FD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 16 Oct 2017 09:26:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 32A30283FF; Mon, 16 Oct 2017 09:26:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 48CF3283FD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 16 Oct 2017 09:26:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752133AbdJPJ0t (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 16 Oct 2017 05:26:49 -0400
Received: from mga05.intel.com ([192.55.52.43]:14032 &quot;EHLO mga05.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752105AbdJPJ0h (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 16 Oct 2017 05:26:37 -0400
Received: from fmsmga006.fm.intel.com ([10.253.24.20])
	by fmsmga105.fm.intel.com with ESMTP; 16 Oct 2017 02:26:37 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.43,386,1503385200&quot;; d=&quot;scan&#39;208&quot;;a=&quot;163576740&quot;
Received: from gvt-dell.bj.intel.com (HELO gvt-dell-host.bj.intel.com)
	([10.238.154.59])
	by fmsmga006.fm.intel.com with ESMTP; 16 Oct 2017 02:26:34 -0700
From: changbin.du@intel.com
To: akpm@linux-foundation.org, corbet@lwn.net, hughd@google.com
Cc: linux-doc@vger.kernel.org, linux-kernel@vger.kernel.org,
	linux-mm@kvack.org, Changbin Du &lt;changbin.du@intel.com&gt;
Subject: [PATCH 2/2] mm: rename page dtor functions to {compound, huge,
	transhuge}_page__dtor
Date: Mon, 16 Oct 2017 17:19:17 +0800
Message-Id: &lt;1508145557-9944-3-git-send-email-changbin.du@intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1508145557-9944-1-git-send-email-changbin.du@intel.com&gt;
References: &lt;1508145557-9944-1-git-send-email-changbin.du@intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=125281">Du, Changbin</a> - Oct. 16, 2017, 9:19 a.m.</div>
<pre class="content">
<span class="from">From: Changbin Du &lt;changbin.du@intel.com&gt;</span>

The current name free_{huge,transhuge}_page are paired with
alloc_{huge,transhuge}_page functions, but the actual page free
function is still free_page() which will indirectly call
free_{huge,transhuge}_page. So this patch removes this confusion
by renaming all the compound page dtors.
<span class="signed-off-by">
Signed-off-by: Changbin Du &lt;changbin.du@intel.com&gt;</span>
---
 Documentation/vm/hugetlbfs_reserv.txt |  4 ++--
 include/linux/huge_mm.h               |  2 +-
 include/linux/hugetlb.h               |  2 +-
 include/linux/mm.h                    |  8 ++++----
 mm/huge_memory.c                      |  4 ++--
 mm/hugetlb.c                          | 14 +++++++-------
 mm/page_alloc.c                       | 10 +++++-----
 mm/swap.c                             |  2 +-
 mm/userfaultfd.c                      |  2 +-
 9 files changed, 24 insertions(+), 24 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=36302">Anshuman Khandual</a> - Oct. 17, 2017, 8:36 a.m.</div>
<pre class="content">
On 10/16/2017 02:49 PM, changbin.du@intel.com wrote:
<span class="quote">&gt; From: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The current name free_{huge,transhuge}_page are paired with</span>
<span class="quote">&gt; alloc_{huge,transhuge}_page functions, but the actual page free</span>
<span class="quote">&gt; function is still free_page() which will indirectly call</span>
<span class="quote">&gt; free_{huge,transhuge}_page. So this patch removes this confusion</span>
<span class="quote">&gt; by renaming all the compound page dtors.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  Documentation/vm/hugetlbfs_reserv.txt |  4 ++--</span>
<span class="quote">&gt;  include/linux/huge_mm.h               |  2 +-</span>
<span class="quote">&gt;  include/linux/hugetlb.h               |  2 +-</span>
<span class="quote">&gt;  include/linux/mm.h                    |  8 ++++----</span>
<span class="quote">&gt;  mm/huge_memory.c                      |  4 ++--</span>
<span class="quote">&gt;  mm/hugetlb.c                          | 14 +++++++-------</span>
<span class="quote">&gt;  mm/page_alloc.c                       | 10 +++++-----</span>
<span class="quote">&gt;  mm/swap.c                             |  2 +-</span>
<span class="quote">&gt;  mm/userfaultfd.c                      |  2 +-</span>
<span class="quote">&gt;  9 files changed, 24 insertions(+), 24 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/Documentation/vm/hugetlbfs_reserv.txt b/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="quote">&gt; index 9aca09a..b3ffa3e 100644</span>
<span class="quote">&gt; --- a/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="quote">&gt; +++ b/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="quote">&gt; @@ -238,7 +238,7 @@ to the global reservation count (resv_huge_pages).</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  Freeing Huge Pages</span>
<span class="quote">&gt;  ------------------</span>
<span class="quote">&gt; -Huge page freeing is performed by the routine free_huge_page().  This routine</span>
<span class="quote">&gt; +Huge page freeing is performed by the routine huge_page_dtor().  This routine</span>
<span class="quote">&gt;  is the destructor for hugetlbfs compound pages.  As a result, it is only</span>
<span class="quote">&gt;  passed a pointer to the page struct.  When a huge page is freed, reservation</span>
<span class="quote">&gt;  accounting may need to be performed.  This would be the case if the page was</span>
<span class="quote">&gt; @@ -468,7 +468,7 @@ However, there are several instances where errors are encountered after a huge</span>
<span class="quote">&gt;  page is allocated but before it is instantiated.  In this case, the page</span>
<span class="quote">&gt;  allocation has consumed the reservation and made the appropriate subpool,</span>
<span class="quote">&gt;  reservation map and global count adjustments.  If the page is freed at this</span>
<span class="quote">&gt; -time (before instantiation and clearing of PagePrivate), then free_huge_page</span>
<span class="quote">&gt; +time (before instantiation and clearing of PagePrivate), then huge_page_dtor</span>
<span class="quote">&gt;  will increment the global reservation count.  However, the reservation map</span>
<span class="quote">&gt;  indicates the reservation was consumed.  This resulting inconsistent state</span>
<span class="quote">&gt;  will cause the &#39;leak&#39; of a reserved huge page.  The global reserve count will</span>
<span class="quote">&gt; diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h</span>
<span class="quote">&gt; index 1dd2c33..40ae3058 100644</span>
<span class="quote">&gt; --- a/include/linux/huge_mm.h</span>
<span class="quote">&gt; +++ b/include/linux/huge_mm.h</span>
<span class="quote">&gt; @@ -130,7 +130,7 @@ extern unsigned long thp_get_unmapped_area(struct file *filp,</span>
<span class="quote">&gt;  		unsigned long addr, unsigned long len, unsigned long pgoff,</span>
<span class="quote">&gt;  		unsigned long flags);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -extern void free_transhuge_page(struct page *page);</span>
<span class="quote">&gt; +extern void transhuge_page_dtor(struct page *page);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  struct page *alloc_transhuge_page_vma(gfp_t gfp_mask,</span>
<span class="quote">&gt;  		struct vm_area_struct *vma, unsigned long addr);</span>
<span class="quote">&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt; index 8bbbd37..24492c5 100644</span>
<span class="quote">&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt; @@ -118,7 +118,7 @@ long hugetlb_unreserve_pages(struct inode *inode, long start, long end,</span>
<span class="quote">&gt;  						long freed);</span>
<span class="quote">&gt;  bool isolate_huge_page(struct page *page, struct list_head *list);</span>
<span class="quote">&gt;  void putback_active_hugepage(struct page *page);</span>
<span class="quote">&gt; -void free_huge_page(struct page *page);</span>
<span class="quote">&gt; +void huge_page_dtor(struct page *page);</span>
<span class="quote">&gt;  void hugetlb_fix_reserve_counts(struct inode *inode);</span>
<span class="quote">&gt;  extern struct mutex *hugetlb_fault_mutex_table;</span>
<span class="quote">&gt;  u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,</span>
<span class="quote">&gt; diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="quote">&gt; index 065d99d..adfa906 100644</span>
<span class="quote">&gt; --- a/include/linux/mm.h</span>
<span class="quote">&gt; +++ b/include/linux/mm.h</span>
<span class="quote">&gt; @@ -616,7 +616,7 @@ void split_page(struct page *page, unsigned int order);</span>
<span class="quote">&gt;   * prototype for that function and accessor functions.</span>
<span class="quote">&gt;   * These are _only_ valid on the head of a compound page.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; -typedef void compound_page_dtor(struct page *);</span>
<span class="quote">&gt; +typedef void compound_page_dtor_t(struct page *);</span>

Why changing this ? I understand _t kind of specifies it more
like a type def but this patch is just to rename the compound
page destructor functions. Not sure we should change datatype
here as well in this patch.
<span class="quote">
&gt;  </span>
<span class="quote">&gt;  /* Keep the enum in sync with compound_page_dtors array in mm/page_alloc.c */</span>
<span class="quote">&gt;  enum compound_dtor_id {</span>
<span class="quote">&gt; @@ -630,7 +630,7 @@ enum compound_dtor_id {</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  	NR_COMPOUND_DTORS,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt; -extern compound_page_dtor * const compound_page_dtors[];</span>
<span class="quote">&gt; +extern compound_page_dtor_t * const compound_page_dtors[];</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static inline void set_compound_page_dtor(struct page *page,</span>
<span class="quote">&gt;  		enum compound_dtor_id compound_dtor)</span>
<span class="quote">&gt; @@ -639,7 +639,7 @@ static inline void set_compound_page_dtor(struct page *page,</span>
<span class="quote">&gt;  	page[1].compound_dtor = compound_dtor;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -static inline compound_page_dtor *get_compound_page_dtor(struct page *page)</span>
<span class="quote">&gt; +static inline compound_page_dtor_t *get_compound_page_dtor(struct page *page)</span>

Which is adding these kind of changes to the patch without
having a corresponding description in the commit message.
<span class="quote">
&gt;  {</span>
<span class="quote">&gt;  	VM_BUG_ON_PAGE(page[1].compound_dtor &gt;= NR_COMPOUND_DTORS, page);</span>
<span class="quote">&gt;  	return compound_page_dtors[page[1].compound_dtor];</span>
<span class="quote">&gt; @@ -657,7 +657,7 @@ static inline void set_compound_order(struct page *page, unsigned int order)</span>
<span class="quote">&gt;  	page[1].compound_order = order;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_compound_page(struct page *page);</span>
<span class="quote">&gt; +void compound_page_dtor(struct page *page);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_MMU</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt; diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="quote">&gt; index e267488..a01125b 100644</span>
<span class="quote">&gt; --- a/mm/huge_memory.c</span>
<span class="quote">&gt; +++ b/mm/huge_memory.c</span>
<span class="quote">&gt; @@ -2717,7 +2717,7 @@ fail:		if (mapping)</span>
<span class="quote">&gt;  	return ret;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_transhuge_page(struct page *page)</span>
<span class="quote">&gt; +void transhuge_page_dtor(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct pglist_data *pgdata = NODE_DATA(page_to_nid(page));</span>
<span class="quote">&gt;  	unsigned long flags;</span>
<span class="quote">&gt; @@ -2728,7 +2728,7 @@ void free_transhuge_page(struct page *page)</span>
<span class="quote">&gt;  		list_del(page_deferred_list(page));</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  	spin_unlock_irqrestore(&amp;pgdata-&gt;split_queue_lock, flags);</span>
<span class="quote">&gt; -	free_compound_page(page);</span>
<span class="quote">&gt; +	compound_page_dtor(page);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  void deferred_split_huge_page(struct page *page)</span>
<span class="quote">&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt; index 424b0ef..1af2c4e7 100644</span>
<span class="quote">&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -1250,7 +1250,7 @@ static void clear_page_huge_active(struct page *page)</span>
<span class="quote">&gt;  	ClearPagePrivate(&amp;page[1]);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_huge_page(struct page *page)</span>
<span class="quote">&gt; +void huge_page_dtor(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * Can&#39;t pass hstate in here because it is called from the</span>
<span class="quote">&gt; @@ -1363,7 +1363,7 @@ int PageHeadHuge(struct page *page_head)</span>
<span class="quote">&gt;  	if (!PageHead(page_head))</span>
<span class="quote">&gt;  		return 0;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	return get_compound_page_dtor(page_head) == free_huge_page;</span>
<span class="quote">&gt; +	return get_compound_page_dtor(page_head) == huge_page_dtor;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  pgoff_t __basepage_index(struct page *page)</span>
<span class="quote">&gt; @@ -1932,11 +1932,11 @@ static long vma_add_reservation(struct hstate *h,</span>
<span class="quote">&gt;   * specific error paths, a huge page was allocated (via alloc_huge_page)</span>
<span class="quote">&gt;   * and is about to be freed.  If a reservation for the page existed,</span>
<span class="quote">&gt;   * alloc_huge_page would have consumed the reservation and set PagePrivate</span>
<span class="quote">&gt; - * in the newly allocated page.  When the page is freed via free_huge_page,</span>
<span class="quote">&gt; + * in the newly allocated page.  When the page is freed via huge_page_dtor,</span>
<span class="quote">&gt;   * the global reservation count will be incremented if PagePrivate is set.</span>
<span class="quote">&gt; - * However, free_huge_page can not adjust the reserve map.  Adjust the</span>
<span class="quote">&gt; + * However, huge_page_dtor can not adjust the reserve map.  Adjust the</span>
<span class="quote">&gt;   * reserve map here to be consistent with global reserve count adjustments</span>
<span class="quote">&gt; - * to be made by free_huge_page.</span>
<span class="quote">&gt; + * to be made by huge_page_dtor.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  static void restore_reserve_on_error(struct hstate *h,</span>
<span class="quote">&gt;  			struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt; @@ -1950,7 +1950,7 @@ static void restore_reserve_on_error(struct hstate *h,</span>
<span class="quote">&gt;  			 * Rare out of memory condition in reserve map</span>
<span class="quote">&gt;  			 * manipulation.  Clear PagePrivate so that</span>
<span class="quote">&gt;  			 * global reserve count will not be incremented</span>
<span class="quote">&gt; -			 * by free_huge_page.  This will make it appear</span>
<span class="quote">&gt; +			 * by huge_page_dtor.  This will make it appear</span>
<span class="quote">&gt;  			 * as though the reservation for this page was</span>
<span class="quote">&gt;  			 * consumed.  This may prevent the task from</span>
<span class="quote">&gt;  			 * faulting in the page at a later time.  This</span>
<span class="quote">&gt; @@ -2304,7 +2304,7 @@ static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
<span class="quote">&gt;  	while (count &gt; persistent_huge_pages(h)) {</span>
<span class="quote">&gt;  		/*</span>
<span class="quote">&gt;  		 * If this allocation races such that we no longer need the</span>
<span class="quote">&gt; -		 * page, free_huge_page will handle it by freeing the page</span>
<span class="quote">&gt; +		 * page, huge_page_dtor will handle it by freeing the page</span>
<span class="quote">&gt;  		 * and reducing the surplus.</span>
<span class="quote">&gt;  		 */</span>
<span class="quote">&gt;  		spin_unlock(&amp;hugetlb_lock);</span>
<span class="quote">&gt; diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="quote">&gt; index 77e4d3c..b31205c 100644</span>
<span class="quote">&gt; --- a/mm/page_alloc.c</span>
<span class="quote">&gt; +++ b/mm/page_alloc.c</span>
<span class="quote">&gt; @@ -248,14 +248,14 @@ char * const migratetype_names[MIGRATE_TYPES] = {</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -compound_page_dtor * const compound_page_dtors[] = {</span>
<span class="quote">&gt; +compound_page_dtor_t * const compound_page_dtors[] = {</span>

Adding this chunk as well.
<span class="quote">
&gt;  	NULL,</span>
<span class="quote">&gt; -	free_compound_page,</span>
<span class="quote">&gt; +	compound_page_dtor,</span>
<span class="quote">&gt;  #ifdef CONFIG_HUGETLB_PAGE</span>
<span class="quote">&gt; -	free_huge_page,</span>
<span class="quote">&gt; +	huge_page_dtor,</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  #ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="quote">&gt; -	free_transhuge_page,</span>
<span class="quote">&gt; +	transhuge_page_dtor,</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  };</span>

Having *dtor* in the destructor functions for the huge pages
(all of them) actually makes sense. It wont be confused with
a lot other free_* functions and some of them dealing with
THP/HugeTLB as well.
<span class="quote">
&gt;  </span>
<span class="quote">&gt; @@ -586,7 +586,7 @@ static void bad_page(struct page *page, const char *reason,</span>
<span class="quote">&gt;   * This usage means that zero-order pages may not be compound.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_compound_page(struct page *page)</span>
<span class="quote">&gt; +void compound_page_dtor(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	__free_pages_ok(page, compound_order(page));</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt; diff --git a/mm/swap.c b/mm/swap.c</span>
<span class="quote">&gt; index a77d68f..8f98caf 100644</span>
<span class="quote">&gt; --- a/mm/swap.c</span>
<span class="quote">&gt; +++ b/mm/swap.c</span>
<span class="quote">&gt; @@ -81,7 +81,7 @@ static void __put_single_page(struct page *page)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static void __put_compound_page(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	compound_page_dtor *dtor;</span>
<span class="quote">&gt; +	compound_page_dtor_t *dtor;</span>

If the typedef change needs to be retained then the commit message
must include a line.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=125281">Du, Changbin</a> - Oct. 17, 2017, 9:21 a.m.</div>
<pre class="content">
Hi Khandual,
<span class="quote">&gt; &gt;  						long freed);</span>
<span class="quote">&gt; &gt;  bool isolate_huge_page(struct page *page, struct list_head *list);</span>
<span class="quote">&gt; &gt;  void putback_active_hugepage(struct page *page);</span>
<span class="quote">&gt; &gt; -void free_huge_page(struct page *page);</span>
<span class="quote">&gt; &gt; +void huge_page_dtor(struct page *page);</span>
<span class="quote">&gt; &gt;  void hugetlb_fix_reserve_counts(struct inode *inode);</span>
<span class="quote">&gt; &gt;  extern struct mutex *hugetlb_fault_mutex_table;</span>
<span class="quote">&gt; &gt;  u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,</span>
<span class="quote">&gt; &gt; diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="quote">&gt; &gt; index 065d99d..adfa906 100644</span>
<span class="quote">&gt; &gt; --- a/include/linux/mm.h</span>
<span class="quote">&gt; &gt; +++ b/include/linux/mm.h</span>
<span class="quote">&gt; &gt; @@ -616,7 +616,7 @@ void split_page(struct page *page, unsigned int order);</span>
<span class="quote">&gt; &gt;   * prototype for that function and accessor functions.</span>
<span class="quote">&gt; &gt;   * These are _only_ valid on the head of a compound page.</span>
<span class="quote">&gt; &gt;   */</span>
<span class="quote">&gt; &gt; -typedef void compound_page_dtor(struct page *);</span>
<span class="quote">&gt; &gt; +typedef void compound_page_dtor_t(struct page *);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why changing this ? I understand _t kind of specifies it more</span>
<span class="quote">&gt; like a type def but this patch is just to rename the compound</span>
<span class="quote">&gt; page destructor functions. Not sure we should change datatype</span>
<span class="quote">&gt; here as well in this patch.</span>
<span class="quote">&gt;</span>
It is because of name conflict. I think you already get it per below comments.
I will describe it in commit message.
<span class="quote">
&gt; &gt;  </span>
<span class="quote">&gt; &gt;  /* Keep the enum in sync with compound_page_dtors array in mm/page_alloc.c */</span>
<span class="quote">&gt; &gt;  enum compound_dtor_id {</span>
<span class="quote">&gt; &gt; @@ -630,7 +630,7 @@ enum compound_dtor_id {</span>
<span class="quote">&gt; &gt;  #endif</span>
<span class="quote">&gt; &gt;  	NR_COMPOUND_DTORS,</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt; -extern compound_page_dtor * const compound_page_dtors[];</span>
<span class="quote">&gt; &gt; +extern compound_page_dtor_t * const compound_page_dtors[];</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static inline void set_compound_page_dtor(struct page *page,</span>
<span class="quote">&gt; &gt;  		enum compound_dtor_id compound_dtor)</span>
<span class="quote">&gt; &gt; @@ -639,7 +639,7 @@ static inline void set_compound_page_dtor(struct page *page,</span>
<span class="quote">&gt; &gt;  	page[1].compound_dtor = compound_dtor;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -static inline compound_page_dtor *get_compound_page_dtor(struct page *page)</span>
<span class="quote">&gt; &gt; +static inline compound_page_dtor_t *get_compound_page_dtor(struct page *page)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Which is adding these kind of changes to the patch without</span>
<span class="quote">&gt; having a corresponding description in the commit message.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	VM_BUG_ON_PAGE(page[1].compound_dtor &gt;= NR_COMPOUND_DTORS, page);</span>
<span class="quote">&gt; &gt;  	return compound_page_dtors[page[1].compound_dtor];</span>
<span class="quote">&gt; &gt; @@ -657,7 +657,7 @@ static inline void set_compound_order(struct page *page, unsigned int order)</span>
<span class="quote">&gt; &gt;  	page[1].compound_order = order;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -void free_compound_page(struct page *page);</span>
<span class="quote">&gt; &gt; +void compound_page_dtor(struct page *page);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  #ifdef CONFIG_MMU</span>
<span class="quote">&gt; &gt;  /*</span>
<span class="quote">&gt; &gt; diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="quote">&gt; &gt; index e267488..a01125b 100644</span>
<span class="quote">&gt; &gt; --- a/mm/huge_memory.c</span>
<span class="quote">&gt; &gt; +++ b/mm/huge_memory.c</span>
<span class="quote">&gt; &gt; @@ -2717,7 +2717,7 @@ fail:		if (mapping)</span>
<span class="quote">&gt; &gt;  	return ret;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -void free_transhuge_page(struct page *page)</span>
<span class="quote">&gt; &gt; +void transhuge_page_dtor(struct page *page)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	struct pglist_data *pgdata = NODE_DATA(page_to_nid(page));</span>
<span class="quote">&gt; &gt;  	unsigned long flags;</span>
<span class="quote">&gt; &gt; @@ -2728,7 +2728,7 @@ void free_transhuge_page(struct page *page)</span>
<span class="quote">&gt; &gt;  		list_del(page_deferred_list(page));</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  	spin_unlock_irqrestore(&amp;pgdata-&gt;split_queue_lock, flags);</span>
<span class="quote">&gt; &gt; -	free_compound_page(page);</span>
<span class="quote">&gt; &gt; +	compound_page_dtor(page);</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  void deferred_split_huge_page(struct page *page)</span>
<span class="quote">&gt; &gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt; &gt; index 424b0ef..1af2c4e7 100644</span>
<span class="quote">&gt; &gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; &gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; &gt; @@ -1250,7 +1250,7 @@ static void clear_page_huge_active(struct page *page)</span>
<span class="quote">&gt; &gt;  	ClearPagePrivate(&amp;page[1]);</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -void free_huge_page(struct page *page)</span>
<span class="quote">&gt; &gt; +void huge_page_dtor(struct page *page)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	/*</span>
<span class="quote">&gt; &gt;  	 * Can&#39;t pass hstate in here because it is called from the</span>
<span class="quote">&gt; &gt; @@ -1363,7 +1363,7 @@ int PageHeadHuge(struct page *page_head)</span>
<span class="quote">&gt; &gt;  	if (!PageHead(page_head))</span>
<span class="quote">&gt; &gt;  		return 0;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	return get_compound_page_dtor(page_head) == free_huge_page;</span>
<span class="quote">&gt; &gt; +	return get_compound_page_dtor(page_head) == huge_page_dtor;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  pgoff_t __basepage_index(struct page *page)</span>
<span class="quote">&gt; &gt; @@ -1932,11 +1932,11 @@ static long vma_add_reservation(struct hstate *h,</span>
<span class="quote">&gt; &gt;   * specific error paths, a huge page was allocated (via alloc_huge_page)</span>
<span class="quote">&gt; &gt;   * and is about to be freed.  If a reservation for the page existed,</span>
<span class="quote">&gt; &gt;   * alloc_huge_page would have consumed the reservation and set PagePrivate</span>
<span class="quote">&gt; &gt; - * in the newly allocated page.  When the page is freed via free_huge_page,</span>
<span class="quote">&gt; &gt; + * in the newly allocated page.  When the page is freed via huge_page_dtor,</span>
<span class="quote">&gt; &gt;   * the global reservation count will be incremented if PagePrivate is set.</span>
<span class="quote">&gt; &gt; - * However, free_huge_page can not adjust the reserve map.  Adjust the</span>
<span class="quote">&gt; &gt; + * However, huge_page_dtor can not adjust the reserve map.  Adjust the</span>
<span class="quote">&gt; &gt;   * reserve map here to be consistent with global reserve count adjustments</span>
<span class="quote">&gt; &gt; - * to be made by free_huge_page.</span>
<span class="quote">&gt; &gt; + * to be made by huge_page_dtor.</span>
<span class="quote">&gt; &gt;   */</span>
<span class="quote">&gt; &gt;  static void restore_reserve_on_error(struct hstate *h,</span>
<span class="quote">&gt; &gt;  			struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt; &gt; @@ -1950,7 +1950,7 @@ static void restore_reserve_on_error(struct hstate *h,</span>
<span class="quote">&gt; &gt;  			 * Rare out of memory condition in reserve map</span>
<span class="quote">&gt; &gt;  			 * manipulation.  Clear PagePrivate so that</span>
<span class="quote">&gt; &gt;  			 * global reserve count will not be incremented</span>
<span class="quote">&gt; &gt; -			 * by free_huge_page.  This will make it appear</span>
<span class="quote">&gt; &gt; +			 * by huge_page_dtor.  This will make it appear</span>
<span class="quote">&gt; &gt;  			 * as though the reservation for this page was</span>
<span class="quote">&gt; &gt;  			 * consumed.  This may prevent the task from</span>
<span class="quote">&gt; &gt;  			 * faulting in the page at a later time.  This</span>
<span class="quote">&gt; &gt; @@ -2304,7 +2304,7 @@ static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
<span class="quote">&gt; &gt;  	while (count &gt; persistent_huge_pages(h)) {</span>
<span class="quote">&gt; &gt;  		/*</span>
<span class="quote">&gt; &gt;  		 * If this allocation races such that we no longer need the</span>
<span class="quote">&gt; &gt; -		 * page, free_huge_page will handle it by freeing the page</span>
<span class="quote">&gt; &gt; +		 * page, huge_page_dtor will handle it by freeing the page</span>
<span class="quote">&gt; &gt;  		 * and reducing the surplus.</span>
<span class="quote">&gt; &gt;  		 */</span>
<span class="quote">&gt; &gt;  		spin_unlock(&amp;hugetlb_lock);</span>
<span class="quote">&gt; &gt; diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="quote">&gt; &gt; index 77e4d3c..b31205c 100644</span>
<span class="quote">&gt; &gt; --- a/mm/page_alloc.c</span>
<span class="quote">&gt; &gt; +++ b/mm/page_alloc.c</span>
<span class="quote">&gt; &gt; @@ -248,14 +248,14 @@ char * const migratetype_names[MIGRATE_TYPES] = {</span>
<span class="quote">&gt; &gt;  #endif</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -compound_page_dtor * const compound_page_dtors[] = {</span>
<span class="quote">&gt; &gt; +compound_page_dtor_t * const compound_page_dtors[] = {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Adding this chunk as well.</span>
<span class="quote">&gt; </span>
Sure.
<span class="quote">
&gt; &gt;  	NULL,</span>
<span class="quote">&gt; &gt; -	free_compound_page,</span>
<span class="quote">&gt; &gt; +	compound_page_dtor,</span>
<span class="quote">&gt; &gt;  #ifdef CONFIG_HUGETLB_PAGE</span>
<span class="quote">&gt; &gt; -	free_huge_page,</span>
<span class="quote">&gt; &gt; +	huge_page_dtor,</span>
<span class="quote">&gt; &gt;  #endif</span>
<span class="quote">&gt; &gt;  #ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="quote">&gt; &gt; -	free_transhuge_page,</span>
<span class="quote">&gt; &gt; +	transhuge_page_dtor,</span>
<span class="quote">&gt; &gt;  #endif</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Having *dtor* in the destructor functions for the huge pages</span>
<span class="quote">&gt; (all of them) actually makes sense. It wont be confused with</span>
<span class="quote">&gt; a lot other free_* functions and some of them dealing with</span>
<span class="quote">&gt; THP/HugeTLB as well.</span>
<span class="quote">&gt; </span>
echo!
<span class="quote">
&gt; &gt;  </span>
<span class="quote">&gt; &gt; @@ -586,7 +586,7 @@ static void bad_page(struct page *page, const char *reason,</span>
<span class="quote">&gt; &gt;   * This usage means that zero-order pages may not be compound.</span>
<span class="quote">&gt; &gt;   */</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -void free_compound_page(struct page *page)</span>
<span class="quote">&gt; &gt; +void compound_page_dtor(struct page *page)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	__free_pages_ok(page, compound_order(page));</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt; diff --git a/mm/swap.c b/mm/swap.c</span>
<span class="quote">&gt; &gt; index a77d68f..8f98caf 100644</span>
<span class="quote">&gt; &gt; --- a/mm/swap.c</span>
<span class="quote">&gt; &gt; +++ b/mm/swap.c</span>
<span class="quote">&gt; &gt; @@ -81,7 +81,7 @@ static void __put_single_page(struct page *page)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static void __put_compound_page(struct page *page)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; -	compound_page_dtor *dtor;</span>
<span class="quote">&gt; &gt; +	compound_page_dtor_t *dtor;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If the typedef change needs to be retained then the commit message</span>
<span class="quote">&gt; must include a line.</span>
<span class="quote">&gt; </span>
will do it. Thanks.
<span class="quote">
&gt; --</span>
<span class="quote">&gt; To unsubscribe, send a message with &#39;unsubscribe linux-mm&#39; in</span>
<span class="quote">&gt; the body to majordomo@kvack.org.  For more info on Linux MM,</span>
<span class="quote">&gt; see: http://www.linux-mm.org/ .</span>
<span class="quote">&gt; Don&#39;t email: &lt;a href=mailto:&quot;dont@kvack.org&quot;&gt; email@kvack.org &lt;/a&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Oct. 17, 2017, 10:22 a.m.</div>
<pre class="content">
On Mon 16-10-17 17:19:17, changbin.du@intel.com wrote:
<span class="quote">&gt; From: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The current name free_{huge,transhuge}_page are paired with</span>
<span class="quote">&gt; alloc_{huge,transhuge}_page functions, but the actual page free</span>
<span class="quote">&gt; function is still free_page() which will indirectly call</span>
<span class="quote">&gt; free_{huge,transhuge}_page. So this patch removes this confusion</span>
<span class="quote">&gt; by renaming all the compound page dtors.</span>

Is this code churn really worth it?
<span class="quote">
&gt; Signed-off-by: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  Documentation/vm/hugetlbfs_reserv.txt |  4 ++--</span>
<span class="quote">&gt;  include/linux/huge_mm.h               |  2 +-</span>
<span class="quote">&gt;  include/linux/hugetlb.h               |  2 +-</span>
<span class="quote">&gt;  include/linux/mm.h                    |  8 ++++----</span>
<span class="quote">&gt;  mm/huge_memory.c                      |  4 ++--</span>
<span class="quote">&gt;  mm/hugetlb.c                          | 14 +++++++-------</span>
<span class="quote">&gt;  mm/page_alloc.c                       | 10 +++++-----</span>
<span class="quote">&gt;  mm/swap.c                             |  2 +-</span>
<span class="quote">&gt;  mm/userfaultfd.c                      |  2 +-</span>
<span class="quote">&gt;  9 files changed, 24 insertions(+), 24 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/Documentation/vm/hugetlbfs_reserv.txt b/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="quote">&gt; index 9aca09a..b3ffa3e 100644</span>
<span class="quote">&gt; --- a/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="quote">&gt; +++ b/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="quote">&gt; @@ -238,7 +238,7 @@ to the global reservation count (resv_huge_pages).</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  Freeing Huge Pages</span>
<span class="quote">&gt;  ------------------</span>
<span class="quote">&gt; -Huge page freeing is performed by the routine free_huge_page().  This routine</span>
<span class="quote">&gt; +Huge page freeing is performed by the routine huge_page_dtor().  This routine</span>
<span class="quote">&gt;  is the destructor for hugetlbfs compound pages.  As a result, it is only</span>
<span class="quote">&gt;  passed a pointer to the page struct.  When a huge page is freed, reservation</span>
<span class="quote">&gt;  accounting may need to be performed.  This would be the case if the page was</span>
<span class="quote">&gt; @@ -468,7 +468,7 @@ However, there are several instances where errors are encountered after a huge</span>
<span class="quote">&gt;  page is allocated but before it is instantiated.  In this case, the page</span>
<span class="quote">&gt;  allocation has consumed the reservation and made the appropriate subpool,</span>
<span class="quote">&gt;  reservation map and global count adjustments.  If the page is freed at this</span>
<span class="quote">&gt; -time (before instantiation and clearing of PagePrivate), then free_huge_page</span>
<span class="quote">&gt; +time (before instantiation and clearing of PagePrivate), then huge_page_dtor</span>
<span class="quote">&gt;  will increment the global reservation count.  However, the reservation map</span>
<span class="quote">&gt;  indicates the reservation was consumed.  This resulting inconsistent state</span>
<span class="quote">&gt;  will cause the &#39;leak&#39; of a reserved huge page.  The global reserve count will</span>
<span class="quote">&gt; diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h</span>
<span class="quote">&gt; index 1dd2c33..40ae3058 100644</span>
<span class="quote">&gt; --- a/include/linux/huge_mm.h</span>
<span class="quote">&gt; +++ b/include/linux/huge_mm.h</span>
<span class="quote">&gt; @@ -130,7 +130,7 @@ extern unsigned long thp_get_unmapped_area(struct file *filp,</span>
<span class="quote">&gt;  		unsigned long addr, unsigned long len, unsigned long pgoff,</span>
<span class="quote">&gt;  		unsigned long flags);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -extern void free_transhuge_page(struct page *page);</span>
<span class="quote">&gt; +extern void transhuge_page_dtor(struct page *page);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  struct page *alloc_transhuge_page_vma(gfp_t gfp_mask,</span>
<span class="quote">&gt;  		struct vm_area_struct *vma, unsigned long addr);</span>
<span class="quote">&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt; index 8bbbd37..24492c5 100644</span>
<span class="quote">&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt; @@ -118,7 +118,7 @@ long hugetlb_unreserve_pages(struct inode *inode, long start, long end,</span>
<span class="quote">&gt;  						long freed);</span>
<span class="quote">&gt;  bool isolate_huge_page(struct page *page, struct list_head *list);</span>
<span class="quote">&gt;  void putback_active_hugepage(struct page *page);</span>
<span class="quote">&gt; -void free_huge_page(struct page *page);</span>
<span class="quote">&gt; +void huge_page_dtor(struct page *page);</span>
<span class="quote">&gt;  void hugetlb_fix_reserve_counts(struct inode *inode);</span>
<span class="quote">&gt;  extern struct mutex *hugetlb_fault_mutex_table;</span>
<span class="quote">&gt;  u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,</span>
<span class="quote">&gt; diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="quote">&gt; index 065d99d..adfa906 100644</span>
<span class="quote">&gt; --- a/include/linux/mm.h</span>
<span class="quote">&gt; +++ b/include/linux/mm.h</span>
<span class="quote">&gt; @@ -616,7 +616,7 @@ void split_page(struct page *page, unsigned int order);</span>
<span class="quote">&gt;   * prototype for that function and accessor functions.</span>
<span class="quote">&gt;   * These are _only_ valid on the head of a compound page.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; -typedef void compound_page_dtor(struct page *);</span>
<span class="quote">&gt; +typedef void compound_page_dtor_t(struct page *);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Keep the enum in sync with compound_page_dtors array in mm/page_alloc.c */</span>
<span class="quote">&gt;  enum compound_dtor_id {</span>
<span class="quote">&gt; @@ -630,7 +630,7 @@ enum compound_dtor_id {</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  	NR_COMPOUND_DTORS,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt; -extern compound_page_dtor * const compound_page_dtors[];</span>
<span class="quote">&gt; +extern compound_page_dtor_t * const compound_page_dtors[];</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static inline void set_compound_page_dtor(struct page *page,</span>
<span class="quote">&gt;  		enum compound_dtor_id compound_dtor)</span>
<span class="quote">&gt; @@ -639,7 +639,7 @@ static inline void set_compound_page_dtor(struct page *page,</span>
<span class="quote">&gt;  	page[1].compound_dtor = compound_dtor;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -static inline compound_page_dtor *get_compound_page_dtor(struct page *page)</span>
<span class="quote">&gt; +static inline compound_page_dtor_t *get_compound_page_dtor(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	VM_BUG_ON_PAGE(page[1].compound_dtor &gt;= NR_COMPOUND_DTORS, page);</span>
<span class="quote">&gt;  	return compound_page_dtors[page[1].compound_dtor];</span>
<span class="quote">&gt; @@ -657,7 +657,7 @@ static inline void set_compound_order(struct page *page, unsigned int order)</span>
<span class="quote">&gt;  	page[1].compound_order = order;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_compound_page(struct page *page);</span>
<span class="quote">&gt; +void compound_page_dtor(struct page *page);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_MMU</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt; diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="quote">&gt; index e267488..a01125b 100644</span>
<span class="quote">&gt; --- a/mm/huge_memory.c</span>
<span class="quote">&gt; +++ b/mm/huge_memory.c</span>
<span class="quote">&gt; @@ -2717,7 +2717,7 @@ fail:		if (mapping)</span>
<span class="quote">&gt;  	return ret;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_transhuge_page(struct page *page)</span>
<span class="quote">&gt; +void transhuge_page_dtor(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct pglist_data *pgdata = NODE_DATA(page_to_nid(page));</span>
<span class="quote">&gt;  	unsigned long flags;</span>
<span class="quote">&gt; @@ -2728,7 +2728,7 @@ void free_transhuge_page(struct page *page)</span>
<span class="quote">&gt;  		list_del(page_deferred_list(page));</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  	spin_unlock_irqrestore(&amp;pgdata-&gt;split_queue_lock, flags);</span>
<span class="quote">&gt; -	free_compound_page(page);</span>
<span class="quote">&gt; +	compound_page_dtor(page);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  void deferred_split_huge_page(struct page *page)</span>
<span class="quote">&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt; index 424b0ef..1af2c4e7 100644</span>
<span class="quote">&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -1250,7 +1250,7 @@ static void clear_page_huge_active(struct page *page)</span>
<span class="quote">&gt;  	ClearPagePrivate(&amp;page[1]);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_huge_page(struct page *page)</span>
<span class="quote">&gt; +void huge_page_dtor(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * Can&#39;t pass hstate in here because it is called from the</span>
<span class="quote">&gt; @@ -1363,7 +1363,7 @@ int PageHeadHuge(struct page *page_head)</span>
<span class="quote">&gt;  	if (!PageHead(page_head))</span>
<span class="quote">&gt;  		return 0;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	return get_compound_page_dtor(page_head) == free_huge_page;</span>
<span class="quote">&gt; +	return get_compound_page_dtor(page_head) == huge_page_dtor;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  pgoff_t __basepage_index(struct page *page)</span>
<span class="quote">&gt; @@ -1932,11 +1932,11 @@ static long vma_add_reservation(struct hstate *h,</span>
<span class="quote">&gt;   * specific error paths, a huge page was allocated (via alloc_huge_page)</span>
<span class="quote">&gt;   * and is about to be freed.  If a reservation for the page existed,</span>
<span class="quote">&gt;   * alloc_huge_page would have consumed the reservation and set PagePrivate</span>
<span class="quote">&gt; - * in the newly allocated page.  When the page is freed via free_huge_page,</span>
<span class="quote">&gt; + * in the newly allocated page.  When the page is freed via huge_page_dtor,</span>
<span class="quote">&gt;   * the global reservation count will be incremented if PagePrivate is set.</span>
<span class="quote">&gt; - * However, free_huge_page can not adjust the reserve map.  Adjust the</span>
<span class="quote">&gt; + * However, huge_page_dtor can not adjust the reserve map.  Adjust the</span>
<span class="quote">&gt;   * reserve map here to be consistent with global reserve count adjustments</span>
<span class="quote">&gt; - * to be made by free_huge_page.</span>
<span class="quote">&gt; + * to be made by huge_page_dtor.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  static void restore_reserve_on_error(struct hstate *h,</span>
<span class="quote">&gt;  			struct vm_area_struct *vma, unsigned long address,</span>
<span class="quote">&gt; @@ -1950,7 +1950,7 @@ static void restore_reserve_on_error(struct hstate *h,</span>
<span class="quote">&gt;  			 * Rare out of memory condition in reserve map</span>
<span class="quote">&gt;  			 * manipulation.  Clear PagePrivate so that</span>
<span class="quote">&gt;  			 * global reserve count will not be incremented</span>
<span class="quote">&gt; -			 * by free_huge_page.  This will make it appear</span>
<span class="quote">&gt; +			 * by huge_page_dtor.  This will make it appear</span>
<span class="quote">&gt;  			 * as though the reservation for this page was</span>
<span class="quote">&gt;  			 * consumed.  This may prevent the task from</span>
<span class="quote">&gt;  			 * faulting in the page at a later time.  This</span>
<span class="quote">&gt; @@ -2304,7 +2304,7 @@ static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
<span class="quote">&gt;  	while (count &gt; persistent_huge_pages(h)) {</span>
<span class="quote">&gt;  		/*</span>
<span class="quote">&gt;  		 * If this allocation races such that we no longer need the</span>
<span class="quote">&gt; -		 * page, free_huge_page will handle it by freeing the page</span>
<span class="quote">&gt; +		 * page, huge_page_dtor will handle it by freeing the page</span>
<span class="quote">&gt;  		 * and reducing the surplus.</span>
<span class="quote">&gt;  		 */</span>
<span class="quote">&gt;  		spin_unlock(&amp;hugetlb_lock);</span>
<span class="quote">&gt; diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="quote">&gt; index 77e4d3c..b31205c 100644</span>
<span class="quote">&gt; --- a/mm/page_alloc.c</span>
<span class="quote">&gt; +++ b/mm/page_alloc.c</span>
<span class="quote">&gt; @@ -248,14 +248,14 @@ char * const migratetype_names[MIGRATE_TYPES] = {</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -compound_page_dtor * const compound_page_dtors[] = {</span>
<span class="quote">&gt; +compound_page_dtor_t * const compound_page_dtors[] = {</span>
<span class="quote">&gt;  	NULL,</span>
<span class="quote">&gt; -	free_compound_page,</span>
<span class="quote">&gt; +	compound_page_dtor,</span>
<span class="quote">&gt;  #ifdef CONFIG_HUGETLB_PAGE</span>
<span class="quote">&gt; -	free_huge_page,</span>
<span class="quote">&gt; +	huge_page_dtor,</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  #ifdef CONFIG_TRANSPARENT_HUGEPAGE</span>
<span class="quote">&gt; -	free_transhuge_page,</span>
<span class="quote">&gt; +	transhuge_page_dtor,</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -586,7 +586,7 @@ static void bad_page(struct page *page, const char *reason,</span>
<span class="quote">&gt;   * This usage means that zero-order pages may not be compound.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void free_compound_page(struct page *page)</span>
<span class="quote">&gt; +void compound_page_dtor(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	__free_pages_ok(page, compound_order(page));</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt; diff --git a/mm/swap.c b/mm/swap.c</span>
<span class="quote">&gt; index a77d68f..8f98caf 100644</span>
<span class="quote">&gt; --- a/mm/swap.c</span>
<span class="quote">&gt; +++ b/mm/swap.c</span>
<span class="quote">&gt; @@ -81,7 +81,7 @@ static void __put_single_page(struct page *page)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static void __put_compound_page(struct page *page)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	compound_page_dtor *dtor;</span>
<span class="quote">&gt; +	compound_page_dtor_t *dtor;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * __page_cache_release() is supposed to be called for thp, not for</span>
<span class="quote">&gt; diff --git a/mm/userfaultfd.c b/mm/userfaultfd.c</span>
<span class="quote">&gt; index 8119270..91d9045 100644</span>
<span class="quote">&gt; --- a/mm/userfaultfd.c</span>
<span class="quote">&gt; +++ b/mm/userfaultfd.c</span>
<span class="quote">&gt; @@ -323,7 +323,7 @@ static __always_inline ssize_t __mcopy_atomic_hugetlb(struct mm_struct *dst_mm,</span>
<span class="quote">&gt;  		 * map of a private mapping, the map was modified to indicate</span>
<span class="quote">&gt;  		 * the reservation was consumed when the page was allocated.</span>
<span class="quote">&gt;  		 * We clear the PagePrivate flag now so that the global</span>
<span class="quote">&gt; -		 * reserve count will not be incremented in free_huge_page.</span>
<span class="quote">&gt; +		 * reserve count will not be incremented in huge_page_dtor.</span>
<span class="quote">&gt;  		 * The reservation map will still indicate the reservation</span>
<span class="quote">&gt;  		 * was consumed and possibly prevent later page allocation.</span>
<span class="quote">&gt;  		 * This is better than leaking a global reservation.  If no</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.7.4</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe, send a message with &#39;unsubscribe linux-mm&#39; in</span>
<span class="quote">&gt; the body to majordomo@kvack.org.  For more info on Linux MM,</span>
<span class="quote">&gt; see: http://www.linux-mm.org/ .</span>
<span class="quote">&gt; Don&#39;t email: &lt;a href=mailto:&quot;dont@kvack.org&quot;&gt; email@kvack.org &lt;/a&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Oct. 17, 2017, 11:22 a.m.</div>
<pre class="content">
On Tue, Oct 17, 2017 at 12:22:03PM +0200, Michal Hocko wrote:
<span class="quote">&gt; On Mon 16-10-17 17:19:17, changbin.du@intel.com wrote:</span>
<span class="quote">&gt; &gt; From: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The current name free_{huge,transhuge}_page are paired with</span>
<span class="quote">&gt; &gt; alloc_{huge,transhuge}_page functions, but the actual page free</span>
<span class="quote">&gt; &gt; function is still free_page() which will indirectly call</span>
<span class="quote">&gt; &gt; free_{huge,transhuge}_page. So this patch removes this confusion</span>
<span class="quote">&gt; &gt; by renaming all the compound page dtors.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is this code churn really worth it?</span>

Getting naming straight is kinda nit. :)

But I don&#39;t feel strong either way.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Oct. 17, 2017, noon</div>
<pre class="content">
On Tue 17-10-17 14:22:14, Kirill A. Shutemov wrote:
<span class="quote">&gt; On Tue, Oct 17, 2017 at 12:22:03PM +0200, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; On Mon 16-10-17 17:19:17, changbin.du@intel.com wrote:</span>
<span class="quote">&gt; &gt; &gt; From: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The current name free_{huge,transhuge}_page are paired with</span>
<span class="quote">&gt; &gt; &gt; alloc_{huge,transhuge}_page functions, but the actual page free</span>
<span class="quote">&gt; &gt; &gt; function is still free_page() which will indirectly call</span>
<span class="quote">&gt; &gt; &gt; free_{huge,transhuge}_page. So this patch removes this confusion</span>
<span class="quote">&gt; &gt; &gt; by renaming all the compound page dtors.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Is this code churn really worth it?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Getting naming straight is kinda nit. :)</span>

yes
<span class="quote">
&gt; But I don&#39;t feel strong either way.</span>

Me neither, I am just trying to understand why the patch has been
created? Is it a preparation for some other changes? If it was removing
some code it would be much more clear but it actually adds twice as much
as it removes so it doesn&#39;t save anything there. It makes the API more
explicit which might be good but is it worth that?
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/vm/hugetlbfs_reserv.txt b/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="p_header">index 9aca09a..b3ffa3e 100644</span>
<span class="p_header">--- a/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="p_header">+++ b/Documentation/vm/hugetlbfs_reserv.txt</span>
<span class="p_chunk">@@ -238,7 +238,7 @@</span> <span class="p_context"> to the global reservation count (resv_huge_pages).</span>
 
 Freeing Huge Pages
 ------------------
<span class="p_del">-Huge page freeing is performed by the routine free_huge_page().  This routine</span>
<span class="p_add">+Huge page freeing is performed by the routine huge_page_dtor().  This routine</span>
 is the destructor for hugetlbfs compound pages.  As a result, it is only
 passed a pointer to the page struct.  When a huge page is freed, reservation
 accounting may need to be performed.  This would be the case if the page was
<span class="p_chunk">@@ -468,7 +468,7 @@</span> <span class="p_context"> However, there are several instances where errors are encountered after a huge</span>
 page is allocated but before it is instantiated.  In this case, the page
 allocation has consumed the reservation and made the appropriate subpool,
 reservation map and global count adjustments.  If the page is freed at this
<span class="p_del">-time (before instantiation and clearing of PagePrivate), then free_huge_page</span>
<span class="p_add">+time (before instantiation and clearing of PagePrivate), then huge_page_dtor</span>
 will increment the global reservation count.  However, the reservation map
 indicates the reservation was consumed.  This resulting inconsistent state
 will cause the &#39;leak&#39; of a reserved huge page.  The global reserve count will
<span class="p_header">diff --git a/include/linux/huge_mm.h b/include/linux/huge_mm.h</span>
<span class="p_header">index 1dd2c33..40ae3058 100644</span>
<span class="p_header">--- a/include/linux/huge_mm.h</span>
<span class="p_header">+++ b/include/linux/huge_mm.h</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> extern unsigned long thp_get_unmapped_area(struct file *filp,</span>
 		unsigned long addr, unsigned long len, unsigned long pgoff,
 		unsigned long flags);
 
<span class="p_del">-extern void free_transhuge_page(struct page *page);</span>
<span class="p_add">+extern void transhuge_page_dtor(struct page *page);</span>
 
 struct page *alloc_transhuge_page_vma(gfp_t gfp_mask,
 		struct vm_area_struct *vma, unsigned long addr);
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index 8bbbd37..24492c5 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -118,7 +118,7 @@</span> <span class="p_context"> long hugetlb_unreserve_pages(struct inode *inode, long start, long end,</span>
 						long freed);
 bool isolate_huge_page(struct page *page, struct list_head *list);
 void putback_active_hugepage(struct page *page);
<span class="p_del">-void free_huge_page(struct page *page);</span>
<span class="p_add">+void huge_page_dtor(struct page *page);</span>
 void hugetlb_fix_reserve_counts(struct inode *inode);
 extern struct mutex *hugetlb_fault_mutex_table;
 u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 065d99d..adfa906 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -616,7 +616,7 @@</span> <span class="p_context"> void split_page(struct page *page, unsigned int order);</span>
  * prototype for that function and accessor functions.
  * These are _only_ valid on the head of a compound page.
  */
<span class="p_del">-typedef void compound_page_dtor(struct page *);</span>
<span class="p_add">+typedef void compound_page_dtor_t(struct page *);</span>
 
 /* Keep the enum in sync with compound_page_dtors array in mm/page_alloc.c */
 enum compound_dtor_id {
<span class="p_chunk">@@ -630,7 +630,7 @@</span> <span class="p_context"> enum compound_dtor_id {</span>
 #endif
 	NR_COMPOUND_DTORS,
 };
<span class="p_del">-extern compound_page_dtor * const compound_page_dtors[];</span>
<span class="p_add">+extern compound_page_dtor_t * const compound_page_dtors[];</span>
 
 static inline void set_compound_page_dtor(struct page *page,
 		enum compound_dtor_id compound_dtor)
<span class="p_chunk">@@ -639,7 +639,7 @@</span> <span class="p_context"> static inline void set_compound_page_dtor(struct page *page,</span>
 	page[1].compound_dtor = compound_dtor;
 }
 
<span class="p_del">-static inline compound_page_dtor *get_compound_page_dtor(struct page *page)</span>
<span class="p_add">+static inline compound_page_dtor_t *get_compound_page_dtor(struct page *page)</span>
 {
 	VM_BUG_ON_PAGE(page[1].compound_dtor &gt;= NR_COMPOUND_DTORS, page);
 	return compound_page_dtors[page[1].compound_dtor];
<span class="p_chunk">@@ -657,7 +657,7 @@</span> <span class="p_context"> static inline void set_compound_order(struct page *page, unsigned int order)</span>
 	page[1].compound_order = order;
 }
 
<span class="p_del">-void free_compound_page(struct page *page);</span>
<span class="p_add">+void compound_page_dtor(struct page *page);</span>
 
 #ifdef CONFIG_MMU
 /*
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index e267488..a01125b 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -2717,7 +2717,7 @@</span> <span class="p_context"> fail:		if (mapping)</span>
 	return ret;
 }
 
<span class="p_del">-void free_transhuge_page(struct page *page)</span>
<span class="p_add">+void transhuge_page_dtor(struct page *page)</span>
 {
 	struct pglist_data *pgdata = NODE_DATA(page_to_nid(page));
 	unsigned long flags;
<span class="p_chunk">@@ -2728,7 +2728,7 @@</span> <span class="p_context"> void free_transhuge_page(struct page *page)</span>
 		list_del(page_deferred_list(page));
 	}
 	spin_unlock_irqrestore(&amp;pgdata-&gt;split_queue_lock, flags);
<span class="p_del">-	free_compound_page(page);</span>
<span class="p_add">+	compound_page_dtor(page);</span>
 }
 
 void deferred_split_huge_page(struct page *page)
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 424b0ef..1af2c4e7 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1250,7 +1250,7 @@</span> <span class="p_context"> static void clear_page_huge_active(struct page *page)</span>
 	ClearPagePrivate(&amp;page[1]);
 }
 
<span class="p_del">-void free_huge_page(struct page *page)</span>
<span class="p_add">+void huge_page_dtor(struct page *page)</span>
 {
 	/*
 	 * Can&#39;t pass hstate in here because it is called from the
<span class="p_chunk">@@ -1363,7 +1363,7 @@</span> <span class="p_context"> int PageHeadHuge(struct page *page_head)</span>
 	if (!PageHead(page_head))
 		return 0;
 
<span class="p_del">-	return get_compound_page_dtor(page_head) == free_huge_page;</span>
<span class="p_add">+	return get_compound_page_dtor(page_head) == huge_page_dtor;</span>
 }
 
 pgoff_t __basepage_index(struct page *page)
<span class="p_chunk">@@ -1932,11 +1932,11 @@</span> <span class="p_context"> static long vma_add_reservation(struct hstate *h,</span>
  * specific error paths, a huge page was allocated (via alloc_huge_page)
  * and is about to be freed.  If a reservation for the page existed,
  * alloc_huge_page would have consumed the reservation and set PagePrivate
<span class="p_del">- * in the newly allocated page.  When the page is freed via free_huge_page,</span>
<span class="p_add">+ * in the newly allocated page.  When the page is freed via huge_page_dtor,</span>
  * the global reservation count will be incremented if PagePrivate is set.
<span class="p_del">- * However, free_huge_page can not adjust the reserve map.  Adjust the</span>
<span class="p_add">+ * However, huge_page_dtor can not adjust the reserve map.  Adjust the</span>
  * reserve map here to be consistent with global reserve count adjustments
<span class="p_del">- * to be made by free_huge_page.</span>
<span class="p_add">+ * to be made by huge_page_dtor.</span>
  */
 static void restore_reserve_on_error(struct hstate *h,
 			struct vm_area_struct *vma, unsigned long address,
<span class="p_chunk">@@ -1950,7 +1950,7 @@</span> <span class="p_context"> static void restore_reserve_on_error(struct hstate *h,</span>
 			 * Rare out of memory condition in reserve map
 			 * manipulation.  Clear PagePrivate so that
 			 * global reserve count will not be incremented
<span class="p_del">-			 * by free_huge_page.  This will make it appear</span>
<span class="p_add">+			 * by huge_page_dtor.  This will make it appear</span>
 			 * as though the reservation for this page was
 			 * consumed.  This may prevent the task from
 			 * faulting in the page at a later time.  This
<span class="p_chunk">@@ -2304,7 +2304,7 @@</span> <span class="p_context"> static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
 	while (count &gt; persistent_huge_pages(h)) {
 		/*
 		 * If this allocation races such that we no longer need the
<span class="p_del">-		 * page, free_huge_page will handle it by freeing the page</span>
<span class="p_add">+		 * page, huge_page_dtor will handle it by freeing the page</span>
 		 * and reducing the surplus.
 		 */
 		spin_unlock(&amp;hugetlb_lock);
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 77e4d3c..b31205c 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -248,14 +248,14 @@</span> <span class="p_context"> char * const migratetype_names[MIGRATE_TYPES] = {</span>
 #endif
 };
 
<span class="p_del">-compound_page_dtor * const compound_page_dtors[] = {</span>
<span class="p_add">+compound_page_dtor_t * const compound_page_dtors[] = {</span>
 	NULL,
<span class="p_del">-	free_compound_page,</span>
<span class="p_add">+	compound_page_dtor,</span>
 #ifdef CONFIG_HUGETLB_PAGE
<span class="p_del">-	free_huge_page,</span>
<span class="p_add">+	huge_page_dtor,</span>
 #endif
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_del">-	free_transhuge_page,</span>
<span class="p_add">+	transhuge_page_dtor,</span>
 #endif
 };
 
<span class="p_chunk">@@ -586,7 +586,7 @@</span> <span class="p_context"> static void bad_page(struct page *page, const char *reason,</span>
  * This usage means that zero-order pages may not be compound.
  */
 
<span class="p_del">-void free_compound_page(struct page *page)</span>
<span class="p_add">+void compound_page_dtor(struct page *page)</span>
 {
 	__free_pages_ok(page, compound_order(page));
 }
<span class="p_header">diff --git a/mm/swap.c b/mm/swap.c</span>
<span class="p_header">index a77d68f..8f98caf 100644</span>
<span class="p_header">--- a/mm/swap.c</span>
<span class="p_header">+++ b/mm/swap.c</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static void __put_single_page(struct page *page)</span>
 
 static void __put_compound_page(struct page *page)
 {
<span class="p_del">-	compound_page_dtor *dtor;</span>
<span class="p_add">+	compound_page_dtor_t *dtor;</span>
 
 	/*
 	 * __page_cache_release() is supposed to be called for thp, not for
<span class="p_header">diff --git a/mm/userfaultfd.c b/mm/userfaultfd.c</span>
<span class="p_header">index 8119270..91d9045 100644</span>
<span class="p_header">--- a/mm/userfaultfd.c</span>
<span class="p_header">+++ b/mm/userfaultfd.c</span>
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static __always_inline ssize_t __mcopy_atomic_hugetlb(struct mm_struct *dst_mm,</span>
 		 * map of a private mapping, the map was modified to indicate
 		 * the reservation was consumed when the page was allocated.
 		 * We clear the PagePrivate flag now so that the global
<span class="p_del">-		 * reserve count will not be incremented in free_huge_page.</span>
<span class="p_add">+		 * reserve count will not be incremented in huge_page_dtor.</span>
 		 * The reservation map will still indicate the reservation
 		 * was consumed and possibly prevent later page allocation.
 		 * This is better than leaking a global reservation.  If no

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



