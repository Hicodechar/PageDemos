
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.0.3 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.0.3</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 13, 2015, 1:17 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150513131757.GB13976@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6397151/mbox/"
   >mbox</a>
|
   <a href="/patch/6397151/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6397151/">/patch/6397151/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 74504BEEE1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 13 May 2015 13:18:38 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id C7206201F5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 13 May 2015 13:18:32 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id A1782203EB
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 13 May 2015 13:18:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S965315AbbEMNSK (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 13 May 2015 09:18:10 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:46991 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S965002AbbEMNR7 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 13 May 2015 09:17:59 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 36590B68;
	Wed, 13 May 2015 13:17:58 +0000 (UTC)
Date: Wed, 13 May 2015 06:17:57 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.0.3
Message-ID: &lt;20150513131757.GB13976@kroah.com&gt;
References: &lt;20150513131751.GA13976@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150513131751.GA13976@kroah.com&gt;
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 13, 2015, 1:17 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index bfcb1a62a7b4..4d68ec841304 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3746,6 +3746,8 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 					READ_CAPACITY_16 command);
 				f = NO_REPORT_OPCODES (don&#39;t use report opcodes
 					command, uas only);
<span class="p_add">+				g = MAX_SECTORS_240 (don&#39;t transfer more than</span>
<span class="p_add">+					240 sectors at a time, uas only);</span>
 				h = CAPACITY_HEURISTICS (decrease the
 					reported device capacity by one
 					sector if the number is odd);
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 0649a6011a76..dc9f43a019d6 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 0
<span class="p_del">-SUBLEVEL = 2</span>
<span class="p_add">+SUBLEVEL = 3</span>
 EXTRAVERSION =
 NAME = Hurr durr I&#39;ma sheep
 
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index ef7d112f5ce0..b0bd4e5fd5cf 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -67,8 +67,7 @@</span> <span class="p_context"> static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)</span>
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
<span class="p_del">-		if (flags &amp; __GFP_ZERO)</span>
<span class="p_del">-			memset(ptr, 0, size);</span>
<span class="p_add">+		memset(ptr, 0, size);</span>
 	}
 
 	return ptr;
<span class="p_chunk">@@ -105,7 +104,6 @@</span> <span class="p_context"> static void *__dma_alloc_coherent(struct device *dev, size_t size,</span>
 		struct page *page;
 		void *addr;
 
<span class="p_del">-		size = PAGE_ALIGN(size);</span>
 		page = dma_alloc_from_contiguous(dev, size &gt;&gt; PAGE_SHIFT,
 							get_order(size));
 		if (!page)
<span class="p_chunk">@@ -113,8 +111,7 @@</span> <span class="p_context"> static void *__dma_alloc_coherent(struct device *dev, size_t size,</span>
 
 		*dma_handle = phys_to_dma(dev, page_to_phys(page));
 		addr = page_address(page);
<span class="p_del">-		if (flags &amp; __GFP_ZERO)</span>
<span class="p_del">-			memset(addr, 0, size);</span>
<span class="p_add">+		memset(addr, 0, size);</span>
 		return addr;
 	} else {
 		return swiotlb_alloc_coherent(dev, size, dma_handle, flags);
<span class="p_chunk">@@ -195,6 +192,8 @@</span> <span class="p_context"> static void __dma_free(struct device *dev, size_t size,</span>
 {
 	void *swiotlb_addr = phys_to_virt(dma_to_phys(dev, dma_handle));
 
<span class="p_add">+	size = PAGE_ALIGN(size);</span>
<span class="p_add">+</span>
 	if (!is_device_dma_coherent(dev)) {
 		if (__free_from_pool(vaddr, size))
 			return;
<span class="p_header">diff --git a/arch/mips/Kconfig b/arch/mips/Kconfig</span>
<span class="p_header">index c7a16904cd03..1a313c468d65 100644</span>
<span class="p_header">--- a/arch/mips/Kconfig</span>
<span class="p_header">+++ b/arch/mips/Kconfig</span>
<span class="p_chunk">@@ -2072,7 +2072,7 @@</span> <span class="p_context"> config MIPSR2_TO_R6_EMULATOR</span>
 	help
 	  Choose this option if you want to run non-R6 MIPS userland code.
 	  Even if you say &#39;Y&#39; here, the emulator will still be disabled by
<span class="p_del">-	  default. You can enable it using the &#39;mipsr2emul&#39; kernel option.</span>
<span class="p_add">+	  default. You can enable it using the &#39;mipsr2emu&#39; kernel option.</span>
 	  The only reason this is a build-time option is to save ~14K from the
 	  final kernel image.
 comment &quot;MIPS R2-to-R6 emulator is only available for UP kernels&quot;
<span class="p_chunk">@@ -2142,7 +2142,7 @@</span> <span class="p_context"> config MIPS_CMP</span>
 
 config MIPS_CPS
 	bool &quot;MIPS Coherent Processing System support&quot;
<span class="p_del">-	depends on SYS_SUPPORTS_MIPS_CPS</span>
<span class="p_add">+	depends on SYS_SUPPORTS_MIPS_CPS &amp;&amp; !64BIT</span>
 	select MIPS_CM
 	select MIPS_CPC
 	select MIPS_CPS_PM if HOTPLUG_CPU
<span class="p_header">diff --git a/arch/mips/Makefile b/arch/mips/Makefile</span>
<span class="p_header">index 8f57fc72d62c..1b4dab1e6ab8 100644</span>
<span class="p_header">--- a/arch/mips/Makefile</span>
<span class="p_header">+++ b/arch/mips/Makefile</span>
<span class="p_chunk">@@ -197,11 +197,17 @@</span> <span class="p_context"> endif</span>
 # Warning: the 64-bit MIPS architecture does not support the `smartmips&#39; extension
 # Pass -Wa,--no-warn to disable all assembler warnings until the kernel code has
 # been fixed properly.
<span class="p_del">-mips-cflags				:= &quot;$(cflags-y)&quot;</span>
<span class="p_del">-cflags-$(CONFIG_CPU_HAS_SMARTMIPS)	+= $(call cc-option,$(mips-cflags),-msmartmips) -Wa,--no-warn</span>
<span class="p_del">-cflags-$(CONFIG_CPU_MICROMIPS)		+= $(call cc-option,$(mips-cflags),-mmicromips)</span>
<span class="p_add">+mips-cflags				:= $(cflags-y)</span>
<span class="p_add">+ifeq ($(CONFIG_CPU_HAS_SMARTMIPS),y)</span>
<span class="p_add">+smartmips-ase				:= $(call cc-option-yn,$(mips-cflags) -msmartmips)</span>
<span class="p_add">+cflags-$(smartmips-ase)			+= -msmartmips -Wa,--no-warn</span>
<span class="p_add">+endif</span>
<span class="p_add">+ifeq ($(CONFIG_CPU_MICROMIPS),y)</span>
<span class="p_add">+micromips-ase				:= $(call cc-option-yn,$(mips-cflags) -mmicromips)</span>
<span class="p_add">+cflags-$(micromips-ase)			+= -mmicromips</span>
<span class="p_add">+endif</span>
 ifeq ($(CONFIG_CPU_HAS_MSA),y)
<span class="p_del">-toolchain-msa				:= $(call cc-option-yn,-$(mips-cflags),mhard-float -mfp64 -Wa$(comma)-mmsa)</span>
<span class="p_add">+toolchain-msa				:= $(call cc-option-yn,$(mips-cflags) -mhard-float -mfp64 -Wa$(comma)-mmsa)</span>
 cflags-$(toolchain-msa)			+= -DTOOLCHAIN_SUPPORTS_MSA
 endif
 
<span class="p_header">diff --git a/arch/mips/bcm47xx/board.c b/arch/mips/bcm47xx/board.c</span>
<span class="p_header">index b3ae068ca4fa..3fd369d74444 100644</span>
<span class="p_header">--- a/arch/mips/bcm47xx/board.c</span>
<span class="p_header">+++ b/arch/mips/bcm47xx/board.c</span>
<span class="p_chunk">@@ -247,8 +247,8 @@</span> <span class="p_context"> static __init const struct bcm47xx_board_type *bcm47xx_board_get_nvram(void)</span>
 	}
 
 	if (bcm47xx_nvram_getenv(&quot;hardware_version&quot;, buf1, sizeof(buf1)) &gt;= 0 &amp;&amp;
<span class="p_del">-	    bcm47xx_nvram_getenv(&quot;boardtype&quot;, buf2, sizeof(buf2)) &gt;= 0) {</span>
<span class="p_del">-		for (e2 = bcm47xx_board_list_boot_hw; e2-&gt;value1; e2++) {</span>
<span class="p_add">+	    bcm47xx_nvram_getenv(&quot;boardnum&quot;, buf2, sizeof(buf2)) &gt;= 0) {</span>
<span class="p_add">+		for (e2 = bcm47xx_board_list_hw_version_num; e2-&gt;value1; e2++) {</span>
 			if (!strstarts(buf1, e2-&gt;value1) &amp;&amp;
 			    !strcmp(buf2, e2-&gt;value2))
 				return &amp;e2-&gt;board;
<span class="p_header">diff --git a/arch/mips/bcm63xx/prom.c b/arch/mips/bcm63xx/prom.c</span>
<span class="p_header">index e1f27d653f60..7019e2967009 100644</span>
<span class="p_header">--- a/arch/mips/bcm63xx/prom.c</span>
<span class="p_header">+++ b/arch/mips/bcm63xx/prom.c</span>
<span class="p_chunk">@@ -17,7 +17,6 @@</span> <span class="p_context"></span>
 #include &lt;bcm63xx_cpu.h&gt;
 #include &lt;bcm63xx_io.h&gt;
 #include &lt;bcm63xx_regs.h&gt;
<span class="p_del">-#include &lt;bcm63xx_gpio.h&gt;</span>
 
 void __init prom_init(void)
 {
<span class="p_chunk">@@ -53,9 +52,6 @@</span> <span class="p_context"> void __init prom_init(void)</span>
 	reg &amp;= ~mask;
 	bcm_perf_writel(reg, PERF_CKCTL_REG);
 
<span class="p_del">-	/* register gpiochip */</span>
<span class="p_del">-	bcm63xx_gpio_init();</span>
<span class="p_del">-</span>
 	/* do low level board init */
 	board_prom_init();
 
<span class="p_header">diff --git a/arch/mips/bcm63xx/setup.c b/arch/mips/bcm63xx/setup.c</span>
<span class="p_header">index 6660c7ddf87b..240fb4ffa55c 100644</span>
<span class="p_header">--- a/arch/mips/bcm63xx/setup.c</span>
<span class="p_header">+++ b/arch/mips/bcm63xx/setup.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;bcm63xx_cpu.h&gt;
 #include &lt;bcm63xx_regs.h&gt;
 #include &lt;bcm63xx_io.h&gt;
<span class="p_add">+#include &lt;bcm63xx_gpio.h&gt;</span>
 
 void bcm63xx_machine_halt(void)
 {
<span class="p_chunk">@@ -160,6 +161,9 @@</span> <span class="p_context"> void __init plat_mem_setup(void)</span>
 
 int __init bcm63xx_register_devices(void)
 {
<span class="p_add">+	/* register gpiochip */</span>
<span class="p_add">+	bcm63xx_gpio_init();</span>
<span class="p_add">+</span>
 	return board_register_devices();
 }
 
<span class="p_header">diff --git a/arch/mips/cavium-octeon/dma-octeon.c b/arch/mips/cavium-octeon/dma-octeon.c</span>
<span class="p_header">index 7d8987818ccf..d8960d46417b 100644</span>
<span class="p_header">--- a/arch/mips/cavium-octeon/dma-octeon.c</span>
<span class="p_header">+++ b/arch/mips/cavium-octeon/dma-octeon.c</span>
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> void __init plat_swiotlb_setup(void)</span>
 		swiotlbsize = 64 * (1&lt;&lt;20);
 	}
 #endif
<span class="p_del">-#ifdef CONFIG_USB_OCTEON_OHCI</span>
<span class="p_add">+#ifdef CONFIG_USB_OHCI_HCD_PLATFORM</span>
 	/* OCTEON II ohci is only 32-bit. */
 	if (OCTEON_IS_OCTEON2() &amp;&amp; max_addr &gt;= 0x100000000ul)
 		swiotlbsize = 64 * (1&lt;&lt;20);
<span class="p_header">diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c</span>
<span class="p_header">index a42110e7edbc..a7f40820e567 100644</span>
<span class="p_header">--- a/arch/mips/cavium-octeon/setup.c</span>
<span class="p_header">+++ b/arch/mips/cavium-octeon/setup.c</span>
<span class="p_chunk">@@ -413,7 +413,10 @@</span> <span class="p_context"> static void octeon_restart(char *command)</span>
 
 	mb();
 	while (1)
<span class="p_del">-		cvmx_write_csr(CVMX_CIU_SOFT_RST, 1);</span>
<span class="p_add">+		if (OCTEON_IS_OCTEON3())</span>
<span class="p_add">+			cvmx_write_csr(CVMX_RST_SOFT_RST, 1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			cvmx_write_csr(CVMX_CIU_SOFT_RST, 1);</span>
 }
 
 
<span class="p_header">diff --git a/arch/mips/include/asm/cacheflush.h b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">index e08381a37f8b..723229f4cf27 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/cacheflush.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/cacheflush.h</span>
<span class="p_chunk">@@ -29,6 +29,20 @@</span> <span class="p_context"></span>
  *  - flush_icache_all() flush the entire instruction cache
  *  - flush_data_cache_page() flushes a page from the data cache
  */
<span class="p_add">+</span>
<span class="p_add">+ /*</span>
<span class="p_add">+ * This flag is used to indicate that the page pointed to by a pte</span>
<span class="p_add">+ * is dirty and requires cleaning before returning it to the user.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PG_dcache_dirty			PG_arch_1</span>
<span class="p_add">+</span>
<span class="p_add">+#define Page_dcache_dirty(page)		\</span>
<span class="p_add">+	test_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+#define SetPageDcacheDirty(page)	\</span>
<span class="p_add">+	set_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+#define ClearPageDcacheDirty(page)	\</span>
<span class="p_add">+	clear_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_add">+</span>
 extern void (*flush_cache_all)(void);
 extern void (*__flush_cache_all)(void);
 extern void (*flush_cache_mm)(struct mm_struct *mm);
<span class="p_chunk">@@ -37,13 +51,15 @@</span> <span class="p_context"> extern void (*flush_cache_range)(struct vm_area_struct *vma,</span>
 	unsigned long start, unsigned long end);
 extern void (*flush_cache_page)(struct vm_area_struct *vma, unsigned long page, unsigned long pfn);
 extern void __flush_dcache_page(struct page *page);
<span class="p_add">+extern void __flush_icache_page(struct vm_area_struct *vma, struct page *page);</span>
 
 #define ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE 1
 static inline void flush_dcache_page(struct page *page)
 {
<span class="p_del">-	if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc)</span>
<span class="p_add">+	if (cpu_has_dc_aliases)</span>
 		__flush_dcache_page(page);
<span class="p_del">-</span>
<span class="p_add">+	else if (!cpu_has_ic_fills_f_dc)</span>
<span class="p_add">+		SetPageDcacheDirty(page);</span>
 }
 
 #define flush_dcache_mmap_lock(mapping)		do { } while (0)
<span class="p_chunk">@@ -61,6 +77,11 @@</span> <span class="p_context"> static inline void flush_anon_page(struct vm_area_struct *vma,</span>
 static inline void flush_icache_page(struct vm_area_struct *vma,
 	struct page *page)
 {
<span class="p_add">+	if (!cpu_has_ic_fills_f_dc &amp;&amp; (vma-&gt;vm_flags &amp; VM_EXEC) &amp;&amp;</span>
<span class="p_add">+	    Page_dcache_dirty(page)) {</span>
<span class="p_add">+		__flush_icache_page(vma, page);</span>
<span class="p_add">+		ClearPageDcacheDirty(page);</span>
<span class="p_add">+	}</span>
 }
 
 extern void (*flush_icache_range)(unsigned long start, unsigned long end);
<span class="p_chunk">@@ -95,19 +116,6 @@</span> <span class="p_context"> extern void (*flush_icache_all)(void);</span>
 extern void (*local_flush_data_cache_page)(void * addr);
 extern void (*flush_data_cache_page)(unsigned long addr);
 
<span class="p_del">-/*</span>
<span class="p_del">- * This flag is used to indicate that the page pointed to by a pte</span>
<span class="p_del">- * is dirty and requires cleaning before returning it to the user.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PG_dcache_dirty			PG_arch_1</span>
<span class="p_del">-</span>
<span class="p_del">-#define Page_dcache_dirty(page)		\</span>
<span class="p_del">-	test_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-#define SetPageDcacheDirty(page)	\</span>
<span class="p_del">-	set_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-#define ClearPageDcacheDirty(page)	\</span>
<span class="p_del">-	clear_bit(PG_dcache_dirty, &amp;(page)-&gt;flags)</span>
<span class="p_del">-</span>
 /* Run kernel code uncached, useful for cache probing functions. */
 unsigned long run_uncached(void *func);
 
<span class="p_header">diff --git a/arch/mips/include/asm/cpu-features.h b/arch/mips/include/asm/cpu-features.h</span>
<span class="p_header">index 0d8208de9a3f..345fd7f80730 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/cpu-features.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/cpu-features.h</span>
<span class="p_chunk">@@ -235,8 +235,39 @@</span> <span class="p_context"></span>
 /* MIPSR2 and MIPSR6 have a lot of similarities */
 #define cpu_has_mips_r2_r6	(cpu_has_mips_r2 | cpu_has_mips_r6)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * cpu_has_mips_r2_exec_hazard - return if IHB is required on current processor</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns non-zero value if the current processor implementation requires</span>
<span class="p_add">+ * an IHB instruction to deal with an instruction hazard as per MIPS R2</span>
<span class="p_add">+ * architecture specification, zero otherwise.</span>
<span class="p_add">+ */</span>
 #ifndef cpu_has_mips_r2_exec_hazard
<span class="p_del">-#define cpu_has_mips_r2_exec_hazard (cpu_has_mips_r2 | cpu_has_mips_r6)</span>
<span class="p_add">+#define cpu_has_mips_r2_exec_hazard					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	int __res;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	switch (current_cpu_type()) {					\</span>
<span class="p_add">+	case CPU_M14KC:							\</span>
<span class="p_add">+	case CPU_74K:							\</span>
<span class="p_add">+	case CPU_1074K:							\</span>
<span class="p_add">+	case CPU_PROAPTIV:						\</span>
<span class="p_add">+	case CPU_P5600:							\</span>
<span class="p_add">+	case CPU_M5150:							\</span>
<span class="p_add">+	case CPU_QEMU_GENERIC:						\</span>
<span class="p_add">+	case CPU_CAVIUM_OCTEON:						\</span>
<span class="p_add">+	case CPU_CAVIUM_OCTEON_PLUS:					\</span>
<span class="p_add">+	case CPU_CAVIUM_OCTEON2:					\</span>
<span class="p_add">+	case CPU_CAVIUM_OCTEON3:					\</span>
<span class="p_add">+		__res = 0;						\</span>
<span class="p_add">+		break;							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	default:							\</span>
<span class="p_add">+		__res = 1;						\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	__res;								\</span>
<span class="p_add">+})</span>
 #endif
 
 /*
<span class="p_header">diff --git a/arch/mips/include/asm/elf.h b/arch/mips/include/asm/elf.h</span>
<span class="p_header">index 535f196ffe02..694925a26924 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/elf.h</span>
<span class="p_chunk">@@ -294,6 +294,9 @@</span> <span class="p_context"> do {									\</span>
 	if (personality(current-&gt;personality) != PER_LINUX)		\
 		set_personality(PER_LINUX);				\
 									\
<span class="p_add">+	clear_thread_flag(TIF_HYBRID_FPREGS);				\</span>
<span class="p_add">+	set_thread_flag(TIF_32BIT_FPREGS);				\</span>
<span class="p_add">+									\</span>
 	mips_set_personality_fp(state);					\
 									\
 	current-&gt;thread.abi = &amp;mips_abi;				\
<span class="p_chunk">@@ -319,6 +322,8 @@</span> <span class="p_context"> do {									\</span>
 	do {								\
 		set_thread_flag(TIF_32BIT_REGS);			\
 		set_thread_flag(TIF_32BIT_ADDR);			\
<span class="p_add">+		clear_thread_flag(TIF_HYBRID_FPREGS);			\</span>
<span class="p_add">+		set_thread_flag(TIF_32BIT_FPREGS);			\</span>
 									\
 		mips_set_personality_fp(state);				\
 									\
<span class="p_header">diff --git a/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h b/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h</span>
<span class="p_header">index fa1f3cfbae8d..d68e685cde60 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-cavium-octeon/cpu-feature-overrides.h</span>
<span class="p_chunk">@@ -50,7 +50,6 @@</span> <span class="p_context"></span>
 #define cpu_has_mips32r2	0
 #define cpu_has_mips64r1	0
 #define cpu_has_mips64r2	1
<span class="p_del">-#define cpu_has_mips_r2_exec_hazard 0</span>
 #define cpu_has_dsp		0
 #define cpu_has_dsp2		0
 #define cpu_has_mipsmt		0
<span class="p_header">diff --git a/arch/mips/include/asm/octeon/cvmx.h b/arch/mips/include/asm/octeon/cvmx.h</span>
<span class="p_header">index 33db1c806b01..774bb45834cb 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/octeon/cvmx.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/octeon/cvmx.h</span>
<span class="p_chunk">@@ -436,14 +436,6 @@</span> <span class="p_context"> static inline uint64_t cvmx_get_cycle_global(void)</span>
 
 /***************************************************************************/
 
<span class="p_del">-static inline void cvmx_reset_octeon(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	union cvmx_ciu_soft_rst ciu_soft_rst;</span>
<span class="p_del">-	ciu_soft_rst.u64 = 0;</span>
<span class="p_del">-	ciu_soft_rst.s.soft_rst = 1;</span>
<span class="p_del">-	cvmx_write_csr(CVMX_CIU_SOFT_RST, ciu_soft_rst.u64);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Return the number of cores available in the chip */
 static inline uint32_t cvmx_octeon_num_cores(void)
 {
<span class="p_header">diff --git a/arch/mips/include/asm/octeon/pci-octeon.h b/arch/mips/include/asm/octeon/pci-octeon.h</span>
<span class="p_header">index 64ba56a02843..1884609741a8 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/octeon/pci-octeon.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/octeon/pci-octeon.h</span>
<span class="p_chunk">@@ -11,9 +11,6 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/pci.h&gt;
 
<span class="p_del">-/* Some PCI cards require delays when accessing config space. */</span>
<span class="p_del">-#define PCI_CONFIG_SPACE_DELAY 10000</span>
<span class="p_del">-</span>
 /*
  * The physical memory base mapped by BAR1.  256MB at the end of the
  * first 4GB.
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index bef782c4a44b..f8f809fd6c6d 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -127,10 +127,6 @@</span> <span class="p_context"> do {									\</span>
 	}								\
 } while(0)
 
<span class="p_del">-</span>
<span class="p_del">-extern void set_pte_at(struct mm_struct *mm, unsigned long addr, pte_t *ptep,</span>
<span class="p_del">-	pte_t pteval);</span>
<span class="p_del">-</span>
 #if defined(CONFIG_PHYS_ADDR_T_64BIT) &amp;&amp; defined(CONFIG_CPU_MIPS32)
 
 #define pte_none(pte)		(!(((pte).pte_low | (pte).pte_high) &amp; ~_PAGE_GLOBAL))
<span class="p_chunk">@@ -154,6 +150,7 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pte)</span>
 		}
 	}
 }
<span class="p_add">+#define set_pte_at(mm, addr, ptep, pteval) set_pte(ptep, pteval)</span>
 
 static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
<span class="p_chunk">@@ -192,6 +189,7 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pteval)</span>
 	}
 #endif
 }
<span class="p_add">+#define set_pte_at(mm, addr, ptep, pteval) set_pte(ptep, pteval)</span>
 
 static inline void pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)
 {
<span class="p_chunk">@@ -407,12 +405,15 @@</span> <span class="p_context"> static inline pte_t pte_modify(pte_t pte, pgprot_t newprot)</span>
 
 extern void __update_tlb(struct vm_area_struct *vma, unsigned long address,
 	pte_t pte);
<span class="p_add">+extern void __update_cache(struct vm_area_struct *vma, unsigned long address,</span>
<span class="p_add">+	pte_t pte);</span>
 
 static inline void update_mmu_cache(struct vm_area_struct *vma,
 	unsigned long address, pte_t *ptep)
 {
 	pte_t pte = *ptep;
 	__update_tlb(vma, address, pte);
<span class="p_add">+	__update_cache(vma, address, pte);</span>
 }
 
 static inline void update_mmu_cache_pmd(struct vm_area_struct *vma,
<span class="p_header">diff --git a/arch/mips/include/asm/r4kcache.h b/arch/mips/include/asm/r4kcache.h</span>
<span class="p_header">index 1b22d2da88a1..38902bf97adc 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/r4kcache.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/r4kcache.h</span>
<span class="p_chunk">@@ -12,6 +12,8 @@</span> <span class="p_context"></span>
 #ifndef _ASM_R4KCACHE_H
 #define _ASM_R4KCACHE_H
 
<span class="p_add">+#include &lt;linux/stringify.h&gt;</span>
<span class="p_add">+</span>
 #include &lt;asm/asm.h&gt;
 #include &lt;asm/cacheops.h&gt;
 #include &lt;asm/compiler.h&gt;
<span class="p_chunk">@@ -344,7 +346,7 @@</span> <span class="p_context"> static inline void invalidate_tcache_page(unsigned long addr)</span>
 	&quot;	cache %1, 0x0a0(%0); cache %1, 0x0b0(%0)\n&quot;	\
 	&quot;	cache %1, 0x0c0(%0); cache %1, 0x0d0(%0)\n&quot;	\
 	&quot;	cache %1, 0x0e0(%0); cache %1, 0x0f0(%0)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, $0, 0x100			\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, %0, 0x100	\n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x010($1)\n&quot;	\
 	&quot;	cache %1, 0x020($1); cache %1, 0x030($1)\n&quot;	\
 	&quot;	cache %1, 0x040($1); cache %1, 0x050($1)\n&quot;	\
<span class="p_chunk">@@ -368,17 +370,17 @@</span> <span class="p_context"> static inline void invalidate_tcache_page(unsigned long addr)</span>
 	&quot;	cache %1, 0x040(%0); cache %1, 0x060(%0)\n&quot;	\
 	&quot;	cache %1, 0x080(%0); cache %1, 0x0a0(%0)\n&quot;	\
 	&quot;	cache %1, 0x0c0(%0); cache %1, 0x0e0(%0)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, %0, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x020($1)\n&quot;	\
 	&quot;	cache %1, 0x040($1); cache %1, 0x060($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0a0($1)\n&quot;	\
 	&quot;	cache %1, 0x0c0($1); cache %1, 0x0e0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, $1, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x020($1)\n&quot;	\
 	&quot;	cache %1, 0x040($1); cache %1, 0x060($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0a0($1)\n&quot;	\
 	&quot;	cache %1, 0x0c0($1); cache %1, 0x0e0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, $1, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100\n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x020($1)\n&quot;	\
 	&quot;	cache %1, 0x040($1); cache %1, 0x060($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0a0($1)\n&quot;	\
<span class="p_chunk">@@ -396,25 +398,25 @@</span> <span class="p_context"> static inline void invalidate_tcache_page(unsigned long addr)</span>
 	&quot;	.set noat\n&quot;					\
 	&quot;	cache %1, 0x000(%0); cache %1, 0x040(%0)\n&quot;	\
 	&quot;	cache %1, 0x080(%0); cache %1, 0x0c0(%0)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, %0, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x040($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0c0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x040($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0c0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x040($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0c0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x040($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0c0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x040($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0c0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x040($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0c0($1)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
 	&quot;	cache %1, 0x000($1); cache %1, 0x040($1)\n&quot;	\
 	&quot;	cache %1, 0x080($1); cache %1, 0x0c0($1)\n&quot;	\
 	&quot;	.set pop\n&quot;					\
<span class="p_chunk">@@ -429,39 +431,38 @@</span> <span class="p_context"> static inline void invalidate_tcache_page(unsigned long addr)</span>
 	&quot;	.set mips64r6\n&quot;				\
 	&quot;	.set noat\n&quot;					\
 	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_del">-	&quot;	cache %1, 0x000(%0); cache %1, 0x080(%0)\n&quot;	\</span>
<span class="p_del">-	&quot;	addiu $1, %0, 0x100\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, %0, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
<span class="p_add">+	&quot;	&quot;__stringify(LONG_ADDIU)&quot; $1, $1, 0x100 \n&quot;	\</span>
<span class="p_add">+	&quot;	cache %1, 0x000($1); cache %1, 0x080($1)\n&quot;	\</span>
 	&quot;	.set pop\n&quot;					\
 		:						\
 		: &quot;r&quot; (base),					\
<span class="p_header">diff --git a/arch/mips/include/asm/spinlock.h b/arch/mips/include/asm/spinlock.h</span>
<span class="p_header">index b4548690ade9..1fca2e0793dc 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> static inline void arch_read_unlock(arch_rwlock_t *rw)</span>
 	if (R10000_LLSC_WAR) {
 		__asm__ __volatile__(
 		&quot;1:	ll	%1, %2		# arch_read_unlock	\n&quot;
<span class="p_del">-		&quot;	addiu	%1, 1					\n&quot;</span>
<span class="p_add">+		&quot;	addiu	%1, -1					\n&quot;</span>
 		&quot;	sc	%1, %0					\n&quot;
 		&quot;	beqzl	%1, 1b					\n&quot;
 		: &quot;=&quot; GCC_OFF_SMALL_ASM() (rw-&gt;lock), &quot;=&amp;r&quot; (tmp)
<span class="p_header">diff --git a/arch/mips/kernel/entry.S b/arch/mips/kernel/entry.S</span>
<span class="p_header">index af41ba6db960..7791840cf22c 100644</span>
<span class="p_header">--- a/arch/mips/kernel/entry.S</span>
<span class="p_header">+++ b/arch/mips/kernel/entry.S</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/asm.h&gt;
 #include &lt;asm/asmmacro.h&gt;
<span class="p_add">+#include &lt;asm/compiler.h&gt;</span>
 #include &lt;asm/regdef.h&gt;
 #include &lt;asm/mipsregs.h&gt;
 #include &lt;asm/stackframe.h&gt;
<span class="p_chunk">@@ -185,7 +186,7 @@</span> <span class="p_context"> syscall_exit_work:</span>
  * For C code use the inline version named instruction_hazard().
  */
 LEAF(mips_ihb)
<span class="p_del">-	.set	mips32r2</span>
<span class="p_add">+	.set	MIPS_ISA_LEVEL_RAW</span>
 	jr.hb	ra
 	nop
 	END(mips_ihb)
<span class="p_header">diff --git a/arch/mips/kernel/smp-cps.c b/arch/mips/kernel/smp-cps.c</span>
<span class="p_header">index bed7590e475f..d5589bedd0a4 100644</span>
<span class="p_header">--- a/arch/mips/kernel/smp-cps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/smp-cps.c</span>
<span class="p_chunk">@@ -88,6 +88,12 @@</span> <span class="p_context"> static void __init cps_smp_setup(void)</span>
 
 	/* Make core 0 coherent with everything */
 	write_gcr_cl_coherence(0xff);
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_MIPS_MT_FPAFF</span>
<span class="p_add">+	/* If we have an FPU, enroll ourselves in the FPU-full mask */</span>
<span class="p_add">+	if (cpu_has_fpu)</span>
<span class="p_add">+		cpu_set(0, mt_fpu_cpumask);</span>
<span class="p_add">+#endif /* CONFIG_MIPS_MT_FPAFF */</span>
 }
 
 static void __init cps_prepare_cpus(unsigned int max_cpus)
<span class="p_header">diff --git a/arch/mips/mm/cache.c b/arch/mips/mm/cache.c</span>
<span class="p_header">index 7e3ea7766822..77d96db8253c 100644</span>
<span class="p_header">--- a/arch/mips/mm/cache.c</span>
<span class="p_header">+++ b/arch/mips/mm/cache.c</span>
<span class="p_chunk">@@ -119,36 +119,37 @@</span> <span class="p_context"> void __flush_anon_page(struct page *page, unsigned long vmaddr)</span>
 
 EXPORT_SYMBOL(__flush_anon_page);
 
<span class="p_del">-static void mips_flush_dcache_from_pte(pte_t pteval, unsigned long address)</span>
<span class="p_add">+void __flush_icache_page(struct vm_area_struct *vma, struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PageHighMem(page))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = (unsigned long) page_address(page);</span>
<span class="p_add">+	flush_data_cache_page(addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(__flush_icache_page);</span>
<span class="p_add">+</span>
<span class="p_add">+void __update_cache(struct vm_area_struct *vma, unsigned long address,</span>
<span class="p_add">+	pte_t pte)</span>
 {
 	struct page *page;
<span class="p_del">-	unsigned long pfn = pte_pfn(pteval);</span>
<span class="p_add">+	unsigned long pfn, addr;</span>
<span class="p_add">+	int exec = (vma-&gt;vm_flags &amp; VM_EXEC) &amp;&amp; !cpu_has_ic_fills_f_dc;</span>
 
<span class="p_add">+	pfn = pte_pfn(pte);</span>
 	if (unlikely(!pfn_valid(pfn)))
 		return;
<span class="p_del">-</span>
 	page = pfn_to_page(pfn);
 	if (page_mapping(page) &amp;&amp; Page_dcache_dirty(page)) {
<span class="p_del">-		unsigned long page_addr = (unsigned long) page_address(page);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!cpu_has_ic_fills_f_dc ||</span>
<span class="p_del">-		    pages_do_alias(page_addr, address &amp; PAGE_MASK))</span>
<span class="p_del">-			flush_data_cache_page(page_addr);</span>
<span class="p_add">+		addr = (unsigned long) page_address(page);</span>
<span class="p_add">+		if (exec || pages_do_alias(addr, address &amp; PAGE_MASK))</span>
<span class="p_add">+			flush_data_cache_page(addr);</span>
 		ClearPageDcacheDirty(page);
 	}
 }
 
<span class="p_del">-void set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-        pte_t *ptep, pte_t pteval)</span>
<span class="p_del">-{</span>
<span class="p_del">-        if (cpu_has_dc_aliases || !cpu_has_ic_fills_f_dc) {</span>
<span class="p_del">-                if (pte_present(pteval))</span>
<span class="p_del">-                        mips_flush_dcache_from_pte(pteval, addr);</span>
<span class="p_del">-        }</span>
<span class="p_del">-</span>
<span class="p_del">-        set_pte(ptep, pteval);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 unsigned long _page_cachable_default;
 EXPORT_SYMBOL(_page_cachable_default);
 
<span class="p_header">diff --git a/arch/mips/mm/tlbex.c b/arch/mips/mm/tlbex.c</span>
<span class="p_header">index d75ff73a2012..a79fd0af0224 100644</span>
<span class="p_header">--- a/arch/mips/mm/tlbex.c</span>
<span class="p_header">+++ b/arch/mips/mm/tlbex.c</span>
<span class="p_chunk">@@ -501,26 +501,9 @@</span> <span class="p_context"> static void build_tlb_write_entry(u32 **p, struct uasm_label **l,</span>
 	case tlb_indexed: tlbw = uasm_i_tlbwi; break;
 	}
 
<span class="p_del">-	if (cpu_has_mips_r2_exec_hazard) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The architecture spec says an ehb is required here,</span>
<span class="p_del">-		 * but a number of cores do not have the hazard and</span>
<span class="p_del">-		 * using an ehb causes an expensive pipeline stall.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		switch (current_cpu_type()) {</span>
<span class="p_del">-		case CPU_M14KC:</span>
<span class="p_del">-		case CPU_74K:</span>
<span class="p_del">-		case CPU_1074K:</span>
<span class="p_del">-		case CPU_PROAPTIV:</span>
<span class="p_del">-		case CPU_P5600:</span>
<span class="p_del">-		case CPU_M5150:</span>
<span class="p_del">-		case CPU_QEMU_GENERIC:</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		default:</span>
<span class="p_add">+	if (cpu_has_mips_r2_r6) {</span>
<span class="p_add">+		if (cpu_has_mips_r2_exec_hazard)</span>
 			uasm_i_ehb(p);
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		tlbw(p);
 		return;
 	}
<span class="p_header">diff --git a/arch/mips/netlogic/xlp/ahci-init-xlp2.c b/arch/mips/netlogic/xlp/ahci-init-xlp2.c</span>
<span class="p_header">index c83dbf3689e2..7b066a44e679 100644</span>
<span class="p_header">--- a/arch/mips/netlogic/xlp/ahci-init-xlp2.c</span>
<span class="p_header">+++ b/arch/mips/netlogic/xlp/ahci-init-xlp2.c</span>
<span class="p_chunk">@@ -203,6 +203,7 @@</span> <span class="p_context"> static u8 read_phy_reg(u64 regbase, u32 addr, u32 physel)</span>
 static void config_sata_phy(u64 regbase)
 {
 	u32 port, i, reg;
<span class="p_add">+	u8 val;</span>
 
 	for (port = 0; port &lt; 2; port++) {
 		for (i = 0, reg = RXCDRCALFOSC0; reg &lt;= CALDUTY; reg++, i++)
<span class="p_chunk">@@ -210,6 +211,18 @@</span> <span class="p_context"> static void config_sata_phy(u64 regbase)</span>
 
 		for (i = 0, reg = RXDPIF; reg &lt;= PPMDRIFTMAX_HI; reg++, i++)
 			write_phy_reg(regbase, reg, port, sata_phy_config2[i]);
<span class="p_add">+</span>
<span class="p_add">+		/* Fix for PHY link up failures at lower temperatures */</span>
<span class="p_add">+		write_phy_reg(regbase, 0x800F, port, 0x1f);</span>
<span class="p_add">+</span>
<span class="p_add">+		val = read_phy_reg(regbase, 0x0029, port);</span>
<span class="p_add">+		write_phy_reg(regbase, 0x0029, port, val | (0x7 &lt;&lt; 1));</span>
<span class="p_add">+</span>
<span class="p_add">+		val = read_phy_reg(regbase, 0x0056, port);</span>
<span class="p_add">+		write_phy_reg(regbase, 0x0056, port, val &amp; ~(1 &lt;&lt; 3));</span>
<span class="p_add">+</span>
<span class="p_add">+		val = read_phy_reg(regbase, 0x0018, port);</span>
<span class="p_add">+		write_phy_reg(regbase, 0x0018, port, val &amp; ~(0x7 &lt;&lt; 0));</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/mips/pci/Makefile b/arch/mips/pci/Makefile</span>
<span class="p_header">index 300591c6278d..2eda01e6e08f 100644</span>
<span class="p_header">--- a/arch/mips/pci/Makefile</span>
<span class="p_header">+++ b/arch/mips/pci/Makefile</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> obj-$(CONFIG_SIBYTE_BCM1x80)	+= pci-bcm1480.o pci-bcm1480ht.o</span>
 obj-$(CONFIG_SNI_RM)		+= fixup-sni.o ops-sni.o
 obj-$(CONFIG_LANTIQ)		+= fixup-lantiq.o
 obj-$(CONFIG_PCI_LANTIQ)	+= pci-lantiq.o ops-lantiq.o
<span class="p_del">-obj-$(CONFIG_SOC_RT2880)	+= pci-rt2880.o</span>
<span class="p_add">+obj-$(CONFIG_SOC_RT288X)	+= pci-rt2880.o</span>
 obj-$(CONFIG_SOC_RT3883)	+= pci-rt3883.o
 obj-$(CONFIG_TANBAC_TB0219)	+= fixup-tb0219.o
 obj-$(CONFIG_TANBAC_TB0226)	+= fixup-tb0226.o
<span class="p_header">diff --git a/arch/mips/pci/pci-octeon.c b/arch/mips/pci/pci-octeon.c</span>
<span class="p_header">index a04af55d89f1..c258cd406fbb 100644</span>
<span class="p_header">--- a/arch/mips/pci/pci-octeon.c</span>
<span class="p_header">+++ b/arch/mips/pci/pci-octeon.c</span>
<span class="p_chunk">@@ -214,6 +214,8 @@</span> <span class="p_context"> const char *octeon_get_pci_interrupts(void)</span>
 		return &quot;AAABAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;;
 	case CVMX_BOARD_TYPE_BBGW_REF:
 		return &quot;AABCD&quot;;
<span class="p_add">+	case CVMX_BOARD_TYPE_CUST_DSR1000N:</span>
<span class="p_add">+		return &quot;CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC&quot;;</span>
 	case CVMX_BOARD_TYPE_THUNDER:
 	case CVMX_BOARD_TYPE_EBH3000:
 	default:
<span class="p_chunk">@@ -271,9 +273,6 @@</span> <span class="p_context"> static int octeon_read_config(struct pci_bus *bus, unsigned int devfn,</span>
 	pci_addr.s.func = devfn &amp; 0x7;
 	pci_addr.s.reg = reg;
 
<span class="p_del">-#if PCI_CONFIG_SPACE_DELAY</span>
<span class="p_del">-	udelay(PCI_CONFIG_SPACE_DELAY);</span>
<span class="p_del">-#endif</span>
 	switch (size) {
 	case 4:
 		*val = le32_to_cpu(cvmx_read64_uint32(pci_addr.u64));
<span class="p_chunk">@@ -308,9 +307,6 @@</span> <span class="p_context"> static int octeon_write_config(struct pci_bus *bus, unsigned int devfn,</span>
 	pci_addr.s.func = devfn &amp; 0x7;
 	pci_addr.s.reg = reg;
 
<span class="p_del">-#if PCI_CONFIG_SPACE_DELAY</span>
<span class="p_del">-	udelay(PCI_CONFIG_SPACE_DELAY);</span>
<span class="p_del">-#endif</span>
 	switch (size) {
 	case 4:
 		cvmx_write64_uint32(pci_addr.u64, cpu_to_le32(val));
<span class="p_header">diff --git a/arch/mips/pci/pcie-octeon.c b/arch/mips/pci/pcie-octeon.c</span>
<span class="p_header">index 1bb0b2bf8d6e..99f3db4f0a9b 100644</span>
<span class="p_header">--- a/arch/mips/pci/pcie-octeon.c</span>
<span class="p_header">+++ b/arch/mips/pci/pcie-octeon.c</span>
<span class="p_chunk">@@ -1762,14 +1762,6 @@</span> <span class="p_context"> static int octeon_pcie_write_config(unsigned int pcie_port, struct pci_bus *bus,</span>
 	default:
 		return PCIBIOS_FUNC_NOT_SUPPORTED;
 	}
<span class="p_del">-#if PCI_CONFIG_SPACE_DELAY</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Delay on writes so that devices have time to come up. Some</span>
<span class="p_del">-	 * bridges need this to allow time for the secondary busses to</span>
<span class="p_del">-	 * work</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	udelay(PCI_CONFIG_SPACE_DELAY);</span>
<span class="p_del">-#endif</span>
 	return PCIBIOS_SUCCESSFUL;
 }
 
<span class="p_header">diff --git a/arch/mips/ralink/Kconfig b/arch/mips/ralink/Kconfig</span>
<span class="p_header">index b1c52ca580f9..e9bc8c96174e 100644</span>
<span class="p_header">--- a/arch/mips/ralink/Kconfig</span>
<span class="p_header">+++ b/arch/mips/ralink/Kconfig</span>
<span class="p_chunk">@@ -7,6 +7,11 @@</span> <span class="p_context"> config CLKEVT_RT3352</span>
 	select CLKSRC_OF
 	select CLKSRC_MMIO
 
<span class="p_add">+config RALINK_ILL_ACC</span>
<span class="p_add">+	bool</span>
<span class="p_add">+	depends on SOC_RT305X</span>
<span class="p_add">+	default y</span>
<span class="p_add">+</span>
 choice
 	prompt &quot;Ralink SoC selection&quot;
 	default SOC_RT305X
<span class="p_header">diff --git a/drivers/acpi/sbs.c b/drivers/acpi/sbs.c</span>
<span class="p_header">index a7a3edd28beb..f23179e84128 100644</span>
<span class="p_header">--- a/drivers/acpi/sbs.c</span>
<span class="p_header">+++ b/drivers/acpi/sbs.c</span>
<span class="p_chunk">@@ -670,7 +670,7 @@</span> <span class="p_context"> static int acpi_sbs_add(struct acpi_device *device)</span>
 	if (!sbs_manager_broken) {
 		result = acpi_manager_get_info(sbs);
 		if (!result) {
<span class="p_del">-			sbs-&gt;manager_present = 0;</span>
<span class="p_add">+			sbs-&gt;manager_present = 1;</span>
 			for (id = 0; id &lt; MAX_SBS_BAT; ++id)
 				if ((sbs-&gt;batteries_supported &amp; (1 &lt;&lt; id)))
 					acpi_battery_add(sbs, id);
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index b40af3203089..b67066d0d9a6 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -2264,6 +2264,11 @@</span> <span class="p_context"> static bool rbd_img_obj_end_request(struct rbd_obj_request *obj_request)</span>
 			result, xferred);
 		if (!img_request-&gt;result)
 			img_request-&gt;result = result;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Need to end I/O on the entire obj_request worth of</span>
<span class="p_add">+		 * bytes in case of error.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		xferred = obj_request-&gt;length;</span>
 	}
 
 	/* Image object requests don&#39;t own their page array */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 9bd56116fd5a..1afc0b419da2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -580,6 +580,9 @@</span> <span class="p_context"> static u32 atombios_adjust_pll(struct drm_crtc *crtc,</span>
 		else
 			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
 
<span class="p_add">+		/* if there is no audio, set MINM_OVER_MAXP  */</span>
<span class="p_add">+		if (!drm_detect_monitor_audio(radeon_connector_edid(connector)))</span>
<span class="p_add">+			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;</span>
 		if (rdev-&gt;family &lt; CHIP_RV770)
 			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;
 		/* use frac fb div on APUs */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index c39c1d0d9d4e..f20eb32406d1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -1729,17 +1729,15 @@</span> <span class="p_context"> radeon_atom_encoder_dpms(struct drm_encoder *encoder, int mode)</span>
 	struct drm_device *dev = encoder-&gt;dev;
 	struct radeon_device *rdev = dev-&gt;dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
<span class="p_del">-	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);</span>
 	int encoder_mode = atombios_get_encoder_mode(encoder);
 
 	DRM_DEBUG_KMS(&quot;encoder dpms %d to mode %d, devices %08x, active_devices %08x\n&quot;,
 		  radeon_encoder-&gt;encoder_id, mode, radeon_encoder-&gt;devices,
 		  radeon_encoder-&gt;active_device);
 
<span class="p_del">-	if (connector &amp;&amp; (radeon_audio != 0) &amp;&amp;</span>
<span class="p_add">+	if ((radeon_audio != 0) &amp;&amp;</span>
 	    ((encoder_mode == ATOM_ENCODER_MODE_HDMI) ||
<span class="p_del">-	     (ENCODER_MODE_IS_DP(encoder_mode) &amp;&amp;</span>
<span class="p_del">-	      drm_detect_monitor_audio(radeon_connector_edid(connector)))))</span>
<span class="p_add">+	     ENCODER_MODE_IS_DP(encoder_mode)))</span>
 		radeon_audio_dpms(encoder, mode);
 
 	switch (radeon_encoder-&gt;encoder_id) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/dce6_afmt.c b/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_header">index 3adc2afe32aa..68fd9fc677e3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/dce6_afmt.c</span>
<span class="p_chunk">@@ -295,28 +295,3 @@</span> <span class="p_context"> void dce6_dp_audio_set_dto(struct radeon_device *rdev,</span>
 		WREG32(DCCG_AUDIO_DTO1_MODULE, clock);
 	}
 }
<span class="p_del">-</span>
<span class="p_del">-void dce6_dp_enable(struct drm_encoder *encoder, bool enable)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct drm_device *dev = encoder-&gt;dev;</span>
<span class="p_del">-	struct radeon_device *rdev = dev-&gt;dev_private;</span>
<span class="p_del">-	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);</span>
<span class="p_del">-	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!dig || !dig-&gt;afmt)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (enable) {</span>
<span class="p_del">-		WREG32(EVERGREEN_DP_SEC_TIMESTAMP + dig-&gt;afmt-&gt;offset,</span>
<span class="p_del">-		       EVERGREEN_DP_SEC_TIMESTAMP_MODE(1));</span>
<span class="p_del">-		WREG32(EVERGREEN_DP_SEC_CNTL + dig-&gt;afmt-&gt;offset,</span>
<span class="p_del">-		       EVERGREEN_DP_SEC_ASP_ENABLE |		/* Audio packet transmission */</span>
<span class="p_del">-		       EVERGREEN_DP_SEC_ATP_ENABLE |		/* Audio timestamp packet transmission */</span>
<span class="p_del">-		       EVERGREEN_DP_SEC_AIP_ENABLE |		/* Audio infoframe packet transmission */</span>
<span class="p_del">-		       EVERGREEN_DP_SEC_STREAM_ENABLE);	/* Master enable for secondary stream engine */</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		WREG32(EVERGREEN_DP_SEC_CNTL + dig-&gt;afmt-&gt;offset, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dig-&gt;afmt-&gt;enabled = enable;</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen_hdmi.c b/drivers/gpu/drm/radeon/evergreen_hdmi.c</span>
<span class="p_header">index c18d4ecbd95d..0926739c9fa7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen_hdmi.c</span>
<span class="p_chunk">@@ -219,13 +219,9 @@</span> <span class="p_context"> void evergreen_set_avi_packet(struct radeon_device *rdev, u32 offset,</span>
 	WREG32(AFMT_AVI_INFO3 + offset,
 		frame[0xC] | (frame[0xD] &lt;&lt; 8) | (buffer[1] &lt;&lt; 24));
 
<span class="p_del">-	WREG32_OR(HDMI_INFOFRAME_CONTROL0 + offset,</span>
<span class="p_del">-		HDMI_AVI_INFO_SEND |	/* enable AVI info frames */</span>
<span class="p_del">-		HDMI_AVI_INFO_CONT);	/* required for audio info values to be updated */</span>
<span class="p_del">-</span>
 	WREG32_P(HDMI_INFOFRAME_CONTROL1 + offset,
<span class="p_del">-		HDMI_AVI_INFO_LINE(2),	/* anything other than 0 */</span>
<span class="p_del">-		~HDMI_AVI_INFO_LINE_MASK);</span>
<span class="p_add">+		 HDMI_AVI_INFO_LINE(2),	/* anything other than 0 */</span>
<span class="p_add">+		 ~HDMI_AVI_INFO_LINE_MASK);</span>
 }
 
 void dce4_hdmi_audio_set_dto(struct radeon_device *rdev,
<span class="p_chunk">@@ -370,9 +366,13 @@</span> <span class="p_context"> void dce4_set_audio_packet(struct drm_encoder *encoder, u32 offset)</span>
 	WREG32(AFMT_AUDIO_PACKET_CONTROL2 + offset,
 		AFMT_AUDIO_CHANNEL_ENABLE(0xff));
 
<span class="p_add">+	WREG32(HDMI_AUDIO_PACKET_CONTROL + offset,</span>
<span class="p_add">+	       HDMI_AUDIO_DELAY_EN(1) | /* set the default audio delay */</span>
<span class="p_add">+	       HDMI_AUDIO_PACKETS_PER_LINE(3)); /* should be suffient for all audio modes and small enough for all hblanks */</span>
<span class="p_add">+</span>
 	/* allow 60958 channel status and send audio packets fields to be updated */
<span class="p_del">-	WREG32(AFMT_AUDIO_PACKET_CONTROL + offset,</span>
<span class="p_del">-		AFMT_AUDIO_SAMPLE_SEND | AFMT_RESET_FIFO_WHEN_AUDIO_DIS | AFMT_60958_CS_UPDATE);</span>
<span class="p_add">+	WREG32_OR(AFMT_AUDIO_PACKET_CONTROL + offset,</span>
<span class="p_add">+		  AFMT_RESET_FIFO_WHEN_AUDIO_DIS | AFMT_60958_CS_UPDATE);</span>
 }
 
 
<span class="p_chunk">@@ -398,17 +398,26 @@</span> <span class="p_context"> void evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable)</span>
 		return;
 
 	if (enable) {
<span class="p_del">-		WREG32(HDMI_INFOFRAME_CONTROL1 + dig-&gt;afmt-&gt;offset,</span>
<span class="p_del">-		       HDMI_AUDIO_INFO_LINE(2)); /* anything other than 0 */</span>
<span class="p_del">-</span>
<span class="p_del">-		WREG32(HDMI_AUDIO_PACKET_CONTROL + dig-&gt;afmt-&gt;offset,</span>
<span class="p_del">-		       HDMI_AUDIO_DELAY_EN(1) | /* set the default audio delay */</span>
<span class="p_del">-		       HDMI_AUDIO_PACKETS_PER_LINE(3)); /* should be suffient for all audio modes and small enough for all hblanks */</span>
<span class="p_add">+		struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);</span>
 
<span class="p_del">-		WREG32(HDMI_INFOFRAME_CONTROL0 + dig-&gt;afmt-&gt;offset,</span>
<span class="p_del">-		       HDMI_AUDIO_INFO_SEND | /* enable audio info frames (frames won&#39;t be set until audio is enabled) */</span>
<span class="p_del">-		       HDMI_AUDIO_INFO_CONT); /* required for audio info values to be updated */</span>
<span class="p_add">+		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_add">+			WREG32(HDMI_INFOFRAME_CONTROL0 + dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+			       HDMI_AVI_INFO_SEND | /* enable AVI info frames */</span>
<span class="p_add">+			       HDMI_AVI_INFO_CONT | /* required for audio info values to be updated */</span>
<span class="p_add">+			       HDMI_AUDIO_INFO_SEND | /* enable audio info frames (frames won&#39;t be set until audio is enabled) */</span>
<span class="p_add">+			       HDMI_AUDIO_INFO_CONT); /* required for audio info values to be updated */</span>
<span class="p_add">+			WREG32_OR(AFMT_AUDIO_PACKET_CONTROL + dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+				  AFMT_AUDIO_SAMPLE_SEND);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			WREG32(HDMI_INFOFRAME_CONTROL0 + dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+			       HDMI_AVI_INFO_SEND | /* enable AVI info frames */</span>
<span class="p_add">+			       HDMI_AVI_INFO_CONT); /* required for audio info values to be updated */</span>
<span class="p_add">+			WREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+				   ~AFMT_AUDIO_SAMPLE_SEND);</span>
<span class="p_add">+		}</span>
 	} else {
<span class="p_add">+		WREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+			   ~AFMT_AUDIO_SAMPLE_SEND);</span>
 		WREG32(HDMI_INFOFRAME_CONTROL0 + dig-&gt;afmt-&gt;offset, 0);
 	}
 
<span class="p_chunk">@@ -424,20 +433,24 @@</span> <span class="p_context"> void evergreen_dp_enable(struct drm_encoder *encoder, bool enable)</span>
 	struct radeon_device *rdev = dev-&gt;dev_private;
 	struct radeon_encoder *radeon_encoder = to_radeon_encoder(encoder);
 	struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;
<span class="p_add">+	struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);</span>
 
 	if (!dig || !dig-&gt;afmt)
 		return;
 
<span class="p_del">-	if (enable) {</span>
<span class="p_add">+	if (enable &amp;&amp; drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
 		struct drm_connector *connector = radeon_get_connector_for_encoder(encoder);
 		struct radeon_connector *radeon_connector = to_radeon_connector(connector);
 		struct radeon_connector_atom_dig *dig_connector;
 		uint32_t val;
 
<span class="p_add">+		WREG32_OR(AFMT_AUDIO_PACKET_CONTROL + dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+			  AFMT_AUDIO_SAMPLE_SEND);</span>
<span class="p_add">+</span>
 		WREG32(EVERGREEN_DP_SEC_TIMESTAMP + dig-&gt;afmt-&gt;offset,
 		       EVERGREEN_DP_SEC_TIMESTAMP_MODE(1));
 
<span class="p_del">-		if (radeon_connector-&gt;con_priv) {</span>
<span class="p_add">+		if (!ASIC_IS_DCE6(rdev) &amp;&amp; radeon_connector-&gt;con_priv) {</span>
 			dig_connector = radeon_connector-&gt;con_priv;
 			val = RREG32(EVERGREEN_DP_SEC_AUD_N + dig-&gt;afmt-&gt;offset);
 			val &amp;= ~EVERGREEN_DP_SEC_N_BASE_MULTIPLE(0xf);
<span class="p_chunk">@@ -457,6 +470,8 @@</span> <span class="p_context"> void evergreen_dp_enable(struct drm_encoder *encoder, bool enable)</span>
 			EVERGREEN_DP_SEC_STREAM_ENABLE);	/* Master enable for secondary stream engine */
 	} else {
 		WREG32(EVERGREEN_DP_SEC_CNTL + dig-&gt;afmt-&gt;offset, 0);
<span class="p_add">+		WREG32_AND(AFMT_AUDIO_PACKET_CONTROL + dig-&gt;afmt-&gt;offset,</span>
<span class="p_add">+			   ~AFMT_AUDIO_SAMPLE_SEND);</span>
 	}
 
 	dig-&gt;afmt-&gt;enabled = enable;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600_hdmi.c b/drivers/gpu/drm/radeon/r600_hdmi.c</span>
<span class="p_header">index dd6606b8e23c..e85894ade95c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600_hdmi.c</span>
<span class="p_chunk">@@ -228,12 +228,13 @@</span> <span class="p_context"> void r600_set_avi_packet(struct radeon_device *rdev, u32 offset,</span>
 	WREG32(HDMI0_AVI_INFO3 + offset,
 		frame[0xC] | (frame[0xD] &lt;&lt; 8) | (buffer[1] &lt;&lt; 24));
 
<span class="p_add">+	WREG32_OR(HDMI0_INFOFRAME_CONTROL1 + offset,</span>
<span class="p_add">+		  HDMI0_AVI_INFO_LINE(2));	/* anything other than 0 */</span>
<span class="p_add">+</span>
 	WREG32_OR(HDMI0_INFOFRAME_CONTROL0 + offset,
<span class="p_del">-		HDMI0_AVI_INFO_SEND |	/* enable AVI info frames */</span>
<span class="p_del">-		HDMI0_AVI_INFO_CONT);	/* send AVI info frames every frame/field */</span>
<span class="p_add">+		  HDMI0_AVI_INFO_SEND |	/* enable AVI info frames */</span>
<span class="p_add">+		  HDMI0_AVI_INFO_CONT);	/* send AVI info frames every frame/field */</span>
 
<span class="p_del">-	WREG32_OR(HDMI0_INFOFRAME_CONTROL1 + offset,</span>
<span class="p_del">-		HDMI0_AVI_INFO_LINE(2));	/* anything other than 0 */</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">index b21ef69a34ac..b7d33a13db9f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_chunk">@@ -102,7 +102,6 @@</span> <span class="p_context"> static void radeon_audio_dp_mode_set(struct drm_encoder *encoder,</span>
 void r600_hdmi_enable(struct drm_encoder *encoder, bool enable);
 void evergreen_hdmi_enable(struct drm_encoder *encoder, bool enable);
 void evergreen_dp_enable(struct drm_encoder *encoder, bool enable);
<span class="p_del">-void dce6_dp_enable(struct drm_encoder *encoder, bool enable);</span>
 
 static const u32 pin_offsets[7] =
 {
<span class="p_chunk">@@ -240,7 +239,7 @@</span> <span class="p_context"> static struct radeon_audio_funcs dce6_dp_funcs = {</span>
 	.set_avi_packet = evergreen_set_avi_packet,
 	.set_audio_packet = dce4_set_audio_packet,
 	.mode_set = radeon_audio_dp_mode_set,
<span class="p_del">-	.dpms = dce6_dp_enable,</span>
<span class="p_add">+	.dpms = evergreen_dp_enable,</span>
 };
 
 static void radeon_audio_interface_init(struct radeon_device *rdev)
<span class="p_chunk">@@ -461,30 +460,33 @@</span> <span class="p_context"> void radeon_audio_detect(struct drm_connector *connector,</span>
 	if (!connector || !connector-&gt;encoder)
 		return;
 
<span class="p_add">+	if (!radeon_encoder_is_digital(connector-&gt;encoder))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	rdev = connector-&gt;encoder-&gt;dev-&gt;dev_private;
 	radeon_encoder = to_radeon_encoder(connector-&gt;encoder);
 	dig = radeon_encoder-&gt;enc_priv;
 
<span class="p_del">-	if (status == connector_status_connected) {</span>
<span class="p_del">-		struct radeon_connector *radeon_connector;</span>
<span class="p_del">-		int sink_type;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_del">-			radeon_encoder-&gt;audio = NULL;</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (!dig-&gt;afmt)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-		radeon_connector = to_radeon_connector(connector);</span>
<span class="p_del">-		sink_type = radeon_dp_getsinktype(radeon_connector);</span>
<span class="p_add">+	if (status == connector_status_connected) {</span>
<span class="p_add">+		struct radeon_connector *radeon_connector = to_radeon_connector(connector);</span>
 
 		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_DisplayPort &amp;&amp;
<span class="p_del">-			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)</span>
<span class="p_add">+		    radeon_dp_getsinktype(radeon_connector) ==</span>
<span class="p_add">+		    CONNECTOR_OBJECT_ID_DISPLAYPORT)</span>
 			radeon_encoder-&gt;audio = rdev-&gt;audio.dp_funcs;
 		else
 			radeon_encoder-&gt;audio = rdev-&gt;audio.hdmi_funcs;
 
 		dig-&gt;afmt-&gt;pin = radeon_audio_get_pin(connector-&gt;encoder);
<span class="p_del">-		radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0xf);</span>
<span class="p_add">+		if (drm_detect_monitor_audio(radeon_connector_edid(connector))) {</span>
<span class="p_add">+			radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0xf);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0);</span>
<span class="p_add">+			dig-&gt;afmt-&gt;pin = NULL;</span>
<span class="p_add">+		}</span>
 	} else {
 		radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0);
 		dig-&gt;afmt-&gt;pin = NULL;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 27def67cb6be..27973e3faf0e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -1333,8 +1333,10 @@</span> <span class="p_context"> out:</span>
 	/* updated in get modes as well since we need to know if it&#39;s analog or digital */
 	radeon_connector_update_scratch_regs(connector, ret);
 
<span class="p_del">-	if (radeon_audio != 0)</span>
<span class="p_add">+	if (radeon_audio != 0) {</span>
<span class="p_add">+		radeon_connector_get_edid(connector);</span>
 		radeon_audio_detect(connector, ret);
<span class="p_add">+	}</span>
 
 exit:
 	pm_runtime_mark_last_busy(connector-&gt;dev-&gt;dev);
<span class="p_chunk">@@ -1659,8 +1661,10 @@</span> <span class="p_context"> radeon_dp_detect(struct drm_connector *connector, bool force)</span>
 
 	radeon_connector_update_scratch_regs(connector, ret);
 
<span class="p_del">-	if (radeon_audio != 0)</span>
<span class="p_add">+	if (radeon_audio != 0) {</span>
<span class="p_add">+		radeon_connector_get_edid(connector);</span>
 		radeon_audio_detect(connector, ret);
<span class="p_add">+	}</span>
 
 out:
 	pm_runtime_mark_last_busy(connector-&gt;dev-&gt;dev);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">index 4d0f96cc3da4..ab39b85e0f76 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> static int radeon_cs_parser_relocs(struct radeon_cs_parser *p)</span>
 	p-&gt;dma_reloc_idx = 0;
 	/* FIXME: we assume that each relocs use 4 dwords */
 	p-&gt;nrelocs = chunk-&gt;length_dw / 4;
<span class="p_del">-	p-&gt;relocs = kcalloc(p-&gt;nrelocs, sizeof(struct radeon_bo_list), GFP_KERNEL);</span>
<span class="p_add">+	p-&gt;relocs = drm_calloc_large(p-&gt;nrelocs, sizeof(struct radeon_bo_list));</span>
 	if (p-&gt;relocs == NULL) {
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -428,7 +428,7 @@</span> <span class="p_context"> static void radeon_cs_parser_fini(struct radeon_cs_parser *parser, int error, bo</span>
 		}
 	}
 	kfree(parser-&gt;track);
<span class="p_del">-	kfree(parser-&gt;relocs);</span>
<span class="p_add">+	drm_free_large(parser-&gt;relocs);</span>
 	drm_free_large(parser-&gt;vm_bos);
 	for (i = 0; i &lt; parser-&gt;nchunks; i++)
 		drm_free_large(parser-&gt;chunks[i].kdata);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vm.c b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">index 2a5a4a9e772d..de42fc4a22b8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_chunk">@@ -473,6 +473,23 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 	}
 
 	mutex_lock(&amp;vm-&gt;mutex);
<span class="p_add">+	soffset /= RADEON_GPU_PAGE_SIZE;</span>
<span class="p_add">+	eoffset /= RADEON_GPU_PAGE_SIZE;</span>
<span class="p_add">+	if (soffset || eoffset) {</span>
<span class="p_add">+		struct interval_tree_node *it;</span>
<span class="p_add">+		it = interval_tree_iter_first(&amp;vm-&gt;va, soffset, eoffset - 1);</span>
<span class="p_add">+		if (it &amp;&amp; it != &amp;bo_va-&gt;it) {</span>
<span class="p_add">+			struct radeon_bo_va *tmp;</span>
<span class="p_add">+			tmp = container_of(it, struct radeon_bo_va, it);</span>
<span class="p_add">+			/* bo and tmp overlap, invalid offset */</span>
<span class="p_add">+			dev_err(rdev-&gt;dev, &quot;bo %p va 0x%010Lx conflict with &quot;</span>
<span class="p_add">+				&quot;(bo %p 0x%010lx 0x%010lx)\n&quot;, bo_va-&gt;bo,</span>
<span class="p_add">+				soffset, tmp-&gt;bo, tmp-&gt;it.start, tmp-&gt;it.last);</span>
<span class="p_add">+			mutex_unlock(&amp;vm-&gt;mutex);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (bo_va-&gt;it.start || bo_va-&gt;it.last) {
 		if (bo_va-&gt;addr) {
 			/* add a clone of the bo_va to clear the old address */
<span class="p_chunk">@@ -490,6 +507,8 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 			spin_lock(&amp;vm-&gt;status_lock);
 			list_add(&amp;tmp-&gt;vm_status, &amp;vm-&gt;freed);
 			spin_unlock(&amp;vm-&gt;status_lock);
<span class="p_add">+</span>
<span class="p_add">+			bo_va-&gt;addr = 0;</span>
 		}
 
 		interval_tree_remove(&amp;bo_va-&gt;it, &amp;vm-&gt;va);
<span class="p_chunk">@@ -497,21 +516,7 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 		bo_va-&gt;it.last = 0;
 	}
 
<span class="p_del">-	soffset /= RADEON_GPU_PAGE_SIZE;</span>
<span class="p_del">-	eoffset /= RADEON_GPU_PAGE_SIZE;</span>
 	if (soffset || eoffset) {
<span class="p_del">-		struct interval_tree_node *it;</span>
<span class="p_del">-		it = interval_tree_iter_first(&amp;vm-&gt;va, soffset, eoffset - 1);</span>
<span class="p_del">-		if (it) {</span>
<span class="p_del">-			struct radeon_bo_va *tmp;</span>
<span class="p_del">-			tmp = container_of(it, struct radeon_bo_va, it);</span>
<span class="p_del">-			/* bo and tmp overlap, invalid offset */</span>
<span class="p_del">-			dev_err(rdev-&gt;dev, &quot;bo %p va 0x%010Lx conflict with &quot;</span>
<span class="p_del">-				&quot;(bo %p 0x%010lx 0x%010lx)\n&quot;, bo_va-&gt;bo,</span>
<span class="p_del">-				soffset, tmp-&gt;bo, tmp-&gt;it.start, tmp-&gt;it.last);</span>
<span class="p_del">-			mutex_unlock(&amp;vm-&gt;mutex);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
 		bo_va-&gt;it.start = soffset;
 		bo_va-&gt;it.last = eoffset - 1;
 		interval_tree_insert(&amp;bo_va-&gt;it, &amp;vm-&gt;va);
<span class="p_chunk">@@ -1107,7 +1112,8 @@</span> <span class="p_context"> void radeon_vm_bo_rmv(struct radeon_device *rdev,</span>
 	list_del(&amp;bo_va-&gt;bo_list);
 
 	mutex_lock(&amp;vm-&gt;mutex);
<span class="p_del">-	interval_tree_remove(&amp;bo_va-&gt;it, &amp;vm-&gt;va);</span>
<span class="p_add">+	if (bo_va-&gt;it.start || bo_va-&gt;it.last)</span>
<span class="p_add">+		interval_tree_remove(&amp;bo_va-&gt;it, &amp;vm-&gt;va);</span>
 	spin_lock(&amp;vm-&gt;status_lock);
 	list_del(&amp;bo_va-&gt;vm_status);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 7be11651b7e6..9dbb3154d559 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2924,6 +2924,7 @@</span> <span class="p_context"> struct si_dpm_quirk {</span>
 static struct si_dpm_quirk si_dpm_quirk_list[] = {
 	/* PITCAIRN - https://bugs.freedesktop.org/show_bug.cgi?id=76490 */
 	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1462, 0x3036, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0xe271, 0, 120000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/hv/channel_mgmt.c b/drivers/hv/channel_mgmt.c</span>
<span class="p_header">index 3736f71bdec5..18def3022f6e 100644</span>
<span class="p_header">--- a/drivers/hv/channel_mgmt.c</span>
<span class="p_header">+++ b/drivers/hv/channel_mgmt.c</span>
<span class="p_chunk">@@ -787,7 +787,7 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 {
 	struct vmbus_channel_message_header *msg;
 	struct vmbus_channel_msginfo *msginfo;
<span class="p_del">-	int ret, t;</span>
<span class="p_add">+	int ret;</span>
 
 	msginfo = kmalloc(sizeof(*msginfo) +
 			  sizeof(struct vmbus_channel_message_header),
<span class="p_chunk">@@ -795,8 +795,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 	if (!msginfo)
 		return -ENOMEM;
 
<span class="p_del">-	init_completion(&amp;msginfo-&gt;waitevent);</span>
<span class="p_del">-</span>
 	msg = (struct vmbus_channel_message_header *)msginfo-&gt;msg;
 
 	msg-&gt;msgtype = CHANNELMSG_REQUESTOFFERS;
<span class="p_chunk">@@ -810,14 +808,6 @@</span> <span class="p_context"> int vmbus_request_offers(void)</span>
 		goto cleanup;
 	}
 
<span class="p_del">-	t = wait_for_completion_timeout(&amp;msginfo-&gt;waitevent, 5*HZ);</span>
<span class="p_del">-	if (t == 0) {</span>
<span class="p_del">-		ret = -ETIMEDOUT;</span>
<span class="p_del">-		goto cleanup;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 cleanup:
 	kfree(msginfo);
 
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c</span>
<span class="p_header">index ee394dc68303..ec1ea8ba7aac 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/cxgb4/t4_hw.c</span>
<span class="p_chunk">@@ -492,7 +492,7 @@</span> <span class="p_context"> int t4_memory_rw(struct adapter *adap, int win, int mtype, u32 addr,</span>
 		memoffset = (mtype * (edc_size * 1024 * 1024));
 	else {
 		mc_size = EXT_MEM0_SIZE_G(t4_read_reg(adap,
<span class="p_del">-						      MA_EXT_MEMORY1_BAR_A));</span>
<span class="p_add">+						      MA_EXT_MEMORY0_BAR_A));</span>
 		memoffset = (MEM_MC0 * edc_size + mc_size) * 1024 * 1024;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index 3485acf03014..2f1324bed7b3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -1467,6 +1467,7 @@</span> <span class="p_context"> static void mlx4_en_service_task(struct work_struct *work)</span>
 		if (mdev-&gt;dev-&gt;caps.flags2 &amp; MLX4_DEV_CAP_FLAG2_TS)
 			mlx4_en_ptp_overflow_check(mdev);
 
<span class="p_add">+		mlx4_en_recover_from_oom(priv);</span>
 		queue_delayed_work(mdev-&gt;workqueue, &amp;priv-&gt;service_task,
 				   SERVICE_TASK_DELAY);
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">index 698d60de1255..05ec5e151ded 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_chunk">@@ -244,6 +244,12 @@</span> <span class="p_context"> static int mlx4_en_prepare_rx_desc(struct mlx4_en_priv *priv,</span>
 	return mlx4_en_alloc_frags(priv, rx_desc, frags, ring-&gt;page_alloc, gfp);
 }
 
<span class="p_add">+static inline bool mlx4_en_is_ring_empty(struct mlx4_en_rx_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON((u32)(ring-&gt;prod - ring-&gt;cons) &gt; ring-&gt;actual_size);</span>
<span class="p_add">+	return ring-&gt;prod == ring-&gt;cons;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void mlx4_en_update_rx_prod_db(struct mlx4_en_rx_ring *ring)
 {
 	*ring-&gt;wqres.db.db = cpu_to_be32(ring-&gt;prod &amp; 0xffff);
<span class="p_chunk">@@ -315,8 +321,7 @@</span> <span class="p_context"> static void mlx4_en_free_rx_buf(struct mlx4_en_priv *priv,</span>
 	       ring-&gt;cons, ring-&gt;prod);
 
 	/* Unmap and free Rx buffers */
<span class="p_del">-	BUG_ON((u32) (ring-&gt;prod - ring-&gt;cons) &gt; ring-&gt;actual_size);</span>
<span class="p_del">-	while (ring-&gt;cons != ring-&gt;prod) {</span>
<span class="p_add">+	while (!mlx4_en_is_ring_empty(ring)) {</span>
 		index = ring-&gt;cons &amp; ring-&gt;size_mask;
 		en_dbg(DRV, priv, &quot;Processing descriptor:%d\n&quot;, index);
 		mlx4_en_free_rx_desc(priv, ring, index);
<span class="p_chunk">@@ -491,6 +496,23 @@</span> <span class="p_context"> err_allocator:</span>
 	return err;
 }
 
<span class="p_add">+/* We recover from out of memory by scheduling our napi poll</span>
<span class="p_add">+ * function (mlx4_en_process_cq), which tries to allocate</span>
<span class="p_add">+ * all missing RX buffers (call to mlx4_en_refill_rx_buffers).</span>
<span class="p_add">+ */</span>
<span class="p_add">+void mlx4_en_recover_from_oom(struct mlx4_en_priv *priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ring;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv-&gt;port_up)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (ring = 0; ring &lt; priv-&gt;rx_ring_num; ring++) {</span>
<span class="p_add">+		if (mlx4_en_is_ring_empty(priv-&gt;rx_ring[ring]))</span>
<span class="p_add">+			napi_reschedule(&amp;priv-&gt;rx_cq[ring]-&gt;napi);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void mlx4_en_destroy_rx_ring(struct mlx4_en_priv *priv,
 			     struct mlx4_en_rx_ring **pring,
 			     u32 size, u16 stride)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">index 55f9f5c5344e..8c234ec1d8aa 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_chunk">@@ -143,8 +143,10 @@</span> <span class="p_context"> int mlx4_en_create_tx_ring(struct mlx4_en_priv *priv,</span>
 	ring-&gt;hwtstamp_tx_type = priv-&gt;hwtstamp_config.tx_type;
 	ring-&gt;queue_index = queue_index;
 
<span class="p_del">-	if (queue_index &lt; priv-&gt;num_tx_rings_p_up &amp;&amp; cpu_online(queue_index))</span>
<span class="p_del">-		cpumask_set_cpu(queue_index, &amp;ring-&gt;affinity_mask);</span>
<span class="p_add">+	if (queue_index &lt; priv-&gt;num_tx_rings_p_up)</span>
<span class="p_add">+		cpumask_set_cpu_local_first(queue_index,</span>
<span class="p_add">+					    priv-&gt;mdev-&gt;dev-&gt;numa_node,</span>
<span class="p_add">+					    &amp;ring-&gt;affinity_mask);</span>
 
 	*pring = ring;
 	return 0;
<span class="p_chunk">@@ -213,7 +215,7 @@</span> <span class="p_context"> int mlx4_en_activate_tx_ring(struct mlx4_en_priv *priv,</span>
 
 	err = mlx4_qp_to_ready(mdev-&gt;dev, &amp;ring-&gt;wqres.mtt, &amp;ring-&gt;context,
 			       &amp;ring-&gt;qp, &amp;ring-&gt;qp_state);
<span class="p_del">-	if (!user_prio &amp;&amp; cpu_online(ring-&gt;queue_index))</span>
<span class="p_add">+	if (!cpumask_empty(&amp;ring-&gt;affinity_mask))</span>
 		netif_set_xps_queue(priv-&gt;dev, &amp;ring-&gt;affinity_mask,
 				    ring-&gt;queue_index);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_header">index ebbe244e80dd..8687c8d54227 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h</span>
<span class="p_chunk">@@ -790,6 +790,7 @@</span> <span class="p_context"> int mlx4_en_activate_tx_ring(struct mlx4_en_priv *priv,</span>
 void mlx4_en_deactivate_tx_ring(struct mlx4_en_priv *priv,
 				struct mlx4_en_tx_ring *ring);
 void mlx4_en_set_num_rx_rings(struct mlx4_en_dev *mdev);
<span class="p_add">+void mlx4_en_recover_from_oom(struct mlx4_en_priv *priv);</span>
 int mlx4_en_create_rx_ring(struct mlx4_en_priv *priv,
 			   struct mlx4_en_rx_ring **pring,
 			   u32 size, u16 stride, int node);
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.c b/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">index 7600639db4c4..add419d6ff34 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.c</span>
<span class="p_chunk">@@ -149,7 +149,6 @@</span> <span class="p_context"> static int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset);</span>
 static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry *sglistarg);
 static void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id);
 static char *twa_string_lookup(twa_message_type *table, unsigned int aen_code);
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id);</span>
 
 /* Functions */
 
<span class="p_chunk">@@ -1340,11 +1339,11 @@</span> <span class="p_context"> static irqreturn_t twa_interrupt(int irq, void *dev_instance)</span>
 				}
 
 				/* Now complete the io */
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 				tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 				twa_free_request_id(tw_dev, request_id);
 				tw_dev-&gt;posted_request_count--;
<span class="p_del">-				tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, request_id);</span>
 			}
 
 			/* Check for valid status after each drain */
<span class="p_chunk">@@ -1402,26 +1401,6 @@</span> <span class="p_context"> static void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_comm</span>
 	}
 } /* End twa_load_sgl() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twa_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1c, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twa_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function will poll for a response interrupt of a request */
 static int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)
 {
<span class="p_chunk">@@ -1600,9 +1579,11 @@</span> <span class="p_context"> static int twa_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
 			if (tw_dev-&gt;srb[i]) {
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+				struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1781,21 +1762,18 @@</span> <span class="p_context"> static int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twa_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	switch (retval) {
 	case SCSI_MLQUEUE_HOST_BUSY:
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		twa_free_request_id(tw_dev, request_id);
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		break;
 	case 1:
<span class="p_del">-		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_del">-		twa_free_request_id(tw_dev, request_id);</span>
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		SCpnt-&gt;result = (DID_ERROR &lt;&lt; 16);
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		done(SCpnt);
<span class="p_add">+		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_add">+		twa_free_request_id(tw_dev, request_id);</span>
 		retval = 0;
 	}
 out:
<span class="p_chunk">@@ -1863,8 +1841,8 @@</span> <span class="p_context"> static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 				command_packet-&gt;sg_list[0].address = TW_CPU_TO_SGL(tw_dev-&gt;generic_buffer_phys[request_id]);
 				command_packet-&gt;sg_list[0].length = cpu_to_le32(TW_MIN_SGL_LENGTH);
 			} else {
<span class="p_del">-				sg_count = twa_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-				if (sg_count == 0)</span>
<span class="p_add">+				sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+				if (sg_count &lt; 0)</span>
 					goto out;
 
 				scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1979,15 +1957,6 @@</span> <span class="p_context"> static char *twa_string_lookup(twa_message_type *table, unsigned int code)</span>
 	return(table[index].text);
 } /* End twa_string_lookup() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twa_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function gets called when a disk is coming on-line */
 static int twa_slave_configure(struct scsi_device *sdev)
 {
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.h b/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">index 040f7214e5b7..0fdc83cfa0e1 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.h</span>
<span class="p_chunk">@@ -324,11 +324,6 @@</span> <span class="p_context"> static twa_message_type twa_error_table[] = {</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE  1</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_9550SX_DRAIN_COMPLETED	      0xFFFF
 #define TW_SECTOR_SIZE                        512
<span class="p_header">diff --git a/drivers/scsi/3w-sas.c b/drivers/scsi/3w-sas.c</span>
<span class="p_header">index 2361772d5909..f8374850f714 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.c</span>
<span class="p_chunk">@@ -290,26 +290,6 @@</span> <span class="p_context"> static int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)</span>
 	return 0;
 } /* End twl_post_command_packet() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twl_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twl_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function hands scsi cdb&#39;s to the firmware */
 static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry_ISO *sglistarg)
 {
<span class="p_chunk">@@ -357,8 +337,8 @@</span> <span class="p_context"> static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 	if (!sglistarg) {
 		/* Map sglist from scsi layer to cmd packet */
 		if (scsi_sg_count(srb)) {
<span class="p_del">-			sg_count = twl_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-			if (sg_count == 0)</span>
<span class="p_add">+			sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+			if (sg_count &lt;= 0)</span>
 				goto out;
 
 			scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1102,15 +1082,6 @@</span> <span class="p_context"> out:</span>
 	return retval;
 } /* End twl_initialize_device_extension() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twl_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twl_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will handle attention interrupts */
 static int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1251,11 +1222,11 @@</span> <span class="p_context"> static irqreturn_t twl_interrupt(int irq, void *dev_instance)</span>
 			}
 
 			/* Now complete the io */
<span class="p_add">+			scsi_dma_unmap(cmd);</span>
<span class="p_add">+			cmd-&gt;scsi_done(cmd);</span>
 			tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 			twl_free_request_id(tw_dev, request_id);
 			tw_dev-&gt;posted_request_count--;
<span class="p_del">-			tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-			twl_unmap_scsi_data(tw_dev, request_id);</span>
 		}
 
 		/* Check for another response interrupt */
<span class="p_chunk">@@ -1400,10 +1371,12 @@</span> <span class="p_context"> static int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_res</span>
 		if ((tw_dev-&gt;state[i] != TW_S_FINISHED) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
<span class="p_del">-			if (tw_dev-&gt;srb[i]) {</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twl_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+			struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+			if (cmd) {</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1507,9 +1480,6 @@</span> <span class="p_context"> static int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	if (retval) {
 		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
<span class="p_header">diff --git a/drivers/scsi/3w-sas.h b/drivers/scsi/3w-sas.h</span>
<span class="p_header">index d474892701d4..fec6449c7595 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.h</span>
<span class="p_chunk">@@ -103,10 +103,6 @@</span> <span class="p_context"> static char *twl_aen_severity_table[] =</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_SECTOR_SIZE                        512
 #define TW_MAX_UNITS			      32
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.c b/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">index c75f2048319f..2940bd769936 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.c</span>
<span class="p_chunk">@@ -1271,32 +1271,6 @@</span> <span class="p_context"> static int tw_initialize_device_extension(TW_Device_Extension *tw_dev)</span>
 	return 0;
 } /* End tw_initialize_device_extension() */
 
<span class="p_del">-static int tw_map_scsi_sg_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (use_sg &lt; 0) {</span>
<span class="p_del">-		printk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data(): pci_map_sg() failed.\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End tw_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
<span class="p_del">-static void tw_unmap_scsi_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_unmap_scsi_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End tw_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will reset a device extension */
 static int tw_reset_device_extension(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1319,8 +1293,8 @@</span> <span class="p_context"> static int tw_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 			srb = tw_dev-&gt;srb[i];
 			if (srb != NULL) {
 				srb-&gt;result = (DID_RESET &lt;&lt; 16);
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[i]);</span>
<span class="p_add">+				scsi_dma_unmap(srb);</span>
<span class="p_add">+				srb-&gt;scsi_done(srb);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1767,8 +1741,8 @@</span> <span class="p_context"> static int tw_scsiop_read_write(TW_Device_Extension *tw_dev, int request_id)</span>
 	command_packet-&gt;byte8.io.lba = lba;
 	command_packet-&gt;byte6.block_count = num_sectors;
 
<span class="p_del">-	use_sg = tw_map_scsi_sg_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_add">+	use_sg = scsi_dma_map(srb);</span>
<span class="p_add">+	if (use_sg &lt;= 0)</span>
 		return 1;
 
 	scsi_for_each_sg(tw_dev-&gt;srb[request_id], sg, use_sg, i) {
<span class="p_chunk">@@ -1955,9 +1929,6 @@</span> <span class="p_context"> static int tw_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_c</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	switch (*command) {
 		case READ_10:
 		case READ_6:
<span class="p_chunk">@@ -2185,12 +2156,11 @@</span> <span class="p_context"> static irqreturn_t tw_interrupt(int irq, void *dev_instance)</span>
 
 				/* Now complete the io */
 				if ((error != TW_ISR_DONT_COMPLETE)) {
<span class="p_add">+					scsi_dma_unmap(tw_dev-&gt;srb[request_id]);</span>
<span class="p_add">+					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
 					tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 					tw_state_request_finish(tw_dev, request_id);
 					tw_dev-&gt;posted_request_count--;
<span class="p_del">-					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-					</span>
<span class="p_del">-					tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
 				}
 			}
 				
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">index 29b0b84ed69e..6f65e663d393 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.h</span>
<span class="p_chunk">@@ -195,11 +195,6 @@</span> <span class="p_context"> static unsigned char tw_sense_table[][4] =</span>
 #define TW_AEN_SMART_FAIL        0x000F
 #define TW_AEN_SBUF_FAIL         0x0024
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE 1</span>
<span class="p_del">-#define TW_PHASE_SGLIST 2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_ALIGNMENT_6000		      64 /* 64 bytes */
 #define TW_ALIGNMENT_7000                     4  /* 4 bytes */
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index 262ab837a704..9f77d23239a2 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -226,6 +226,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;PIONEER&quot;, &quot;CD-ROM DRM-624X&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;Promise&quot;, &quot;VTrak E610f&quot;, NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
<span class="p_add">+	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},</span>
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
 	{&quot;REGAL&quot;, &quot;CDC-4X&quot;, NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},
 	{&quot;SanDisk&quot;, &quot;ImageMate CF-SD1&quot;, NULL, BLIST_FORCELUN},
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 9c0a520d933c..3e6142f61499 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -897,6 +897,12 @@</span> <span class="p_context"> static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,</span>
 	 */
 	if (*bflags &amp; BLIST_MAX_512)
 		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 512);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Max 1024 sector transfer length for targets that report incorrect</span>
<span class="p_add">+	 * max/optimal lengths and relied on the old block layer safe default</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	else if (*bflags &amp; BLIST_MAX_1024)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 1024);</span>
 
 	/*
 	 * Some devices may not want to have a start command automatically
<span class="p_header">diff --git a/drivers/ssb/Kconfig b/drivers/ssb/Kconfig</span>
<span class="p_header">index 75b3603906c1..f0d22cdb51cd 100644</span>
<span class="p_header">--- a/drivers/ssb/Kconfig</span>
<span class="p_header">+++ b/drivers/ssb/Kconfig</span>
<span class="p_chunk">@@ -130,6 +130,7 @@</span> <span class="p_context"> config SSB_DRIVER_MIPS</span>
 	bool &quot;SSB Broadcom MIPS core driver&quot;
 	depends on SSB &amp;&amp; MIPS
 	select SSB_SERIAL
<span class="p_add">+	select SSB_SFLASH</span>
 	help
 	  Driver for the Sonics Silicon Backplane attached
 	  Broadcom MIPS core.
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 4e959c43f680..6afce7eb3d74 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -880,6 +880,7 @@</span> <span class="p_context"> static int atmel_prepare_tx_dma(struct uart_port *port)</span>
 	config.direction = DMA_MEM_TO_DEV;
 	config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 	config.dst_addr = port-&gt;mapbase + ATMEL_US_THR;
<span class="p_add">+	config.dst_maxburst = 1;</span>
 
 	ret = dmaengine_slave_config(atmel_port-&gt;chan_tx,
 				     &amp;config);
<span class="p_chunk">@@ -1059,6 +1060,7 @@</span> <span class="p_context"> static int atmel_prepare_rx_dma(struct uart_port *port)</span>
 	config.direction = DMA_DEV_TO_MEM;
 	config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 	config.src_addr = port-&gt;mapbase + ATMEL_US_RHR;
<span class="p_add">+	config.src_maxburst = 1;</span>
 
 	ret = dmaengine_slave_config(atmel_port-&gt;chan_rx,
 				     &amp;config);
<span class="p_header">diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c</span>
<span class="p_header">index 33fb94f78967..0a52c8b55a5f 100644</span>
<span class="p_header">--- a/drivers/tty/serial/of_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/of_serial.c</span>
<span class="p_chunk">@@ -344,7 +344,6 @@</span> <span class="p_context"> static struct of_device_id of_platform_serial_table[] = {</span>
 	{ .compatible = &quot;ibm,qpace-nwp-serial&quot;,
 		.data = (void *)PORT_NWPSERIAL, },
 #endif
<span class="p_del">-	{ .type = &quot;serial&quot;,         .data = (void *)PORT_UNKNOWN, },</span>
 	{ /* end of list */ },
 };
 
<span class="p_header">diff --git a/drivers/tty/serial/uartlite.c b/drivers/tty/serial/uartlite.c</span>
<span class="p_header">index 189f52e3111f..a0099a7f60d4 100644</span>
<span class="p_header">--- a/drivers/tty/serial/uartlite.c</span>
<span class="p_header">+++ b/drivers/tty/serial/uartlite.c</span>
<span class="p_chunk">@@ -632,7 +632,8 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, ulite_of_match);</span>
 
 static int ulite_probe(struct platform_device *pdev)
 {
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int irq;</span>
 	int id = pdev-&gt;id;
 #ifdef CONFIG_OF
 	const __be32 *prop;
<span class="p_chunk">@@ -646,11 +647,11 @@</span> <span class="p_context"> static int ulite_probe(struct platform_device *pdev)</span>
 	if (!res)
 		return -ENODEV;
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0)</span>
<span class="p_add">+		return -ENXIO;</span>
 
<span class="p_del">-	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, res2-&gt;start);</span>
<span class="p_add">+	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, irq);</span>
 }
 
 static int ulite_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">index cff531a51a78..54853a02ce9e 100644</span>
<span class="p_header">--- a/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">+++ b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_chunk">@@ -1325,9 +1325,9 @@</span> <span class="p_context"> static SIMPLE_DEV_PM_OPS(cdns_uart_dev_pm_ops, cdns_uart_suspend,</span>
  */
 static int cdns_uart_probe(struct platform_device *pdev)
 {
<span class="p_del">-	int rc, id;</span>
<span class="p_add">+	int rc, id, irq;</span>
 	struct uart_port *port;
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
 	struct cdns_uart *cdns_uart_data;
 
 	cdns_uart_data = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*cdns_uart_data),
<span class="p_chunk">@@ -1374,9 +1374,9 @@</span> <span class="p_context"> static int cdns_uart_probe(struct platform_device *pdev)</span>
 		goto err_out_clk_disable;
 	}
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2) {</span>
<span class="p_del">-		rc = -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0) {</span>
<span class="p_add">+		rc = -ENXIO;</span>
 		goto err_out_clk_disable;
 	}
 
<span class="p_chunk">@@ -1405,7 +1405,7 @@</span> <span class="p_context"> static int cdns_uart_probe(struct platform_device *pdev)</span>
 		 * and triggers invocation of the config_port() entry point.
 		 */
 		port-&gt;mapbase = res-&gt;start;
<span class="p_del">-		port-&gt;irq = res2-&gt;start;</span>
<span class="p_add">+		port-&gt;irq = irq;</span>
 		port-&gt;dev = &amp;pdev-&gt;dev;
 		port-&gt;uartclk = clk_get_rate(cdns_uart_data-&gt;uartclk);
 		port-&gt;private_data = cdns_uart_data;
<span class="p_header">diff --git a/drivers/usb/chipidea/otg_fsm.c b/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_header">index 562e581f6765..3770330a2201 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_chunk">@@ -537,7 +537,6 @@</span> <span class="p_context"> static int ci_otg_start_host(struct otg_fsm *fsm, int on)</span>
 {
 	struct ci_hdrc	*ci = container_of(fsm, struct ci_hdrc, fsm);
 
<span class="p_del">-	mutex_unlock(&amp;fsm-&gt;lock);</span>
 	if (on) {
 		ci_role_stop(ci);
 		ci_role_start(ci, CI_ROLE_HOST);
<span class="p_chunk">@@ -546,7 +545,6 @@</span> <span class="p_context"> static int ci_otg_start_host(struct otg_fsm *fsm, int on)</span>
 		hw_device_reset(ci);
 		ci_role_start(ci, CI_ROLE_GADGET);
 	}
<span class="p_del">-	mutex_lock(&amp;fsm-&gt;lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -554,12 +552,10 @@</span> <span class="p_context"> static int ci_otg_start_gadget(struct otg_fsm *fsm, int on)</span>
 {
 	struct ci_hdrc	*ci = container_of(fsm, struct ci_hdrc, fsm);
 
<span class="p_del">-	mutex_unlock(&amp;fsm-&gt;lock);</span>
 	if (on)
 		usb_gadget_vbus_connect(&amp;ci-&gt;gadget);
 	else
 		usb_gadget_vbus_disconnect(&amp;ci-&gt;gadget);
<span class="p_del">-	mutex_lock(&amp;fsm-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 683617714e7c..220c0fd059bb 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1133,11 +1133,16 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	}
 
 	while (buflen &gt; 0) {
<span class="p_add">+		elength = buffer[0];</span>
<span class="p_add">+		if (!elength) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage byte\n&quot;);</span>
<span class="p_add">+			elength = 1;</span>
<span class="p_add">+			goto next_desc;</span>
<span class="p_add">+		}</span>
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage\n&quot;);
 			goto next_desc;
 		}
<span class="p_del">-		elength = buffer[0];</span>
 
 		switch (buffer[2]) {
 		case USB_CDC_UNION_TYPE: /* we&#39;ve found it */
<span class="p_header">diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">index 9893d696fc97..f58caa9e6a27 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">+++ b/drivers/usb/storage/uas-detect.h</span>
<span class="p_chunk">@@ -51,7 +51,8 @@</span> <span class="p_context"> static int uas_find_endpoints(struct usb_host_interface *alt,</span>
 }
 
 static int uas_use_uas_driver(struct usb_interface *intf,
<span class="p_del">-			      const struct usb_device_id *id)</span>
<span class="p_add">+			      const struct usb_device_id *id,</span>
<span class="p_add">+			      unsigned long *flags_ret)</span>
 {
 	struct usb_host_endpoint *eps[4] = { };
 	struct usb_device *udev = interface_to_usbdev(intf);
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 	 * this writing the following versions exist:
 	 * ASM1051 - no uas support version
 	 * ASM1051 - with broken (*) uas support
<span class="p_del">-	 * ASM1053 - with working uas support</span>
<span class="p_add">+	 * ASM1053 - with working uas support, but problems with large xfers</span>
 	 * ASM1153 - with working uas support
 	 *
 	 * Devices with these chips re-use a number of device-ids over the
<span class="p_chunk">@@ -103,6 +104,9 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		} else if (usb_ss_max_streams(&amp;eps[1]-&gt;ss_ep_comp) == 32) {
 			/* Possibly an ASM1051, disable uas */
 			flags |= US_FL_IGNORE_UAS;
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* ASM1053, these have issues with large transfers */</span>
<span class="p_add">+			flags |= US_FL_MAX_SECTORS_240;</span>
 		}
 	}
 
<span class="p_chunk">@@ -132,5 +136,8 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		return 0;
 	}
 
<span class="p_add">+	if (flags_ret)</span>
<span class="p_add">+		*flags_ret = flags;</span>
<span class="p_add">+</span>
 	return 1;
 }
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index 6cdabdc119a7..6d3122afeed3 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -759,7 +759,10 @@</span> <span class="p_context"> static int uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)</span>
 
 static int uas_slave_alloc(struct scsi_device *sdev)
 {
<span class="p_del">-	sdev-&gt;hostdata = (void *)sdev-&gt;host-&gt;hostdata;</span>
<span class="p_add">+	struct uas_dev_info *devinfo =</span>
<span class="p_add">+		(struct uas_dev_info *)sdev-&gt;host-&gt;hostdata;</span>
<span class="p_add">+</span>
<span class="p_add">+	sdev-&gt;hostdata = devinfo;</span>
 
 	/* USB has unusual DMA-alignment requirements: Although the
 	 * starting address of each scatter-gather element doesn&#39;t matter,
<span class="p_chunk">@@ -778,6 +781,11 @@</span> <span class="p_context"> static int uas_slave_alloc(struct scsi_device *sdev)</span>
 	 */
 	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
<span class="p_add">+	if (devinfo-&gt;flags &amp; US_FL_MAX_SECTORS_64)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 64);</span>
<span class="p_add">+	else if (devinfo-&gt;flags &amp; US_FL_MAX_SECTORS_240)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 240);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -887,8 +895,9 @@</span> <span class="p_context"> static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	struct Scsi_Host *shost = NULL;
 	struct uas_dev_info *devinfo;
 	struct usb_device *udev = interface_to_usbdev(intf);
<span class="p_add">+	unsigned long dev_flags;</span>
 
<span class="p_del">-	if (!uas_use_uas_driver(intf, id))</span>
<span class="p_add">+	if (!uas_use_uas_driver(intf, id, &amp;dev_flags))</span>
 		return -ENODEV;
 
 	if (uas_switch_interface(udev, intf))
<span class="p_chunk">@@ -910,8 +919,7 @@</span> <span class="p_context"> static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	devinfo-&gt;udev = udev;
 	devinfo-&gt;resetting = 0;
 	devinfo-&gt;shutdown = 0;
<span class="p_del">-	devinfo-&gt;flags = id-&gt;driver_info;</span>
<span class="p_del">-	usb_stor_adjust_quirks(udev, &amp;devinfo-&gt;flags);</span>
<span class="p_add">+	devinfo-&gt;flags = dev_flags;</span>
 	init_usb_anchor(&amp;devinfo-&gt;cmd_urbs);
 	init_usb_anchor(&amp;devinfo-&gt;sense_urbs);
 	init_usb_anchor(&amp;devinfo-&gt;data_urbs);
<span class="p_header">diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c</span>
<span class="p_header">index 5600c33fcadb..6c10c888f35f 100644</span>
<span class="p_header">--- a/drivers/usb/storage/usb.c</span>
<span class="p_header">+++ b/drivers/usb/storage/usb.c</span>
<span class="p_chunk">@@ -479,7 +479,8 @@</span> <span class="p_context"> void usb_stor_adjust_quirks(struct usb_device *udev, unsigned long *fflags)</span>
 			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |
 			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |
 			US_FL_INITIAL_READ10 | US_FL_WRITE_CACHE |
<span class="p_del">-			US_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES);</span>
<span class="p_add">+			US_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES |</span>
<span class="p_add">+			US_FL_MAX_SECTORS_240);</span>
 
 	p = quirks;
 	while (*p) {
<span class="p_chunk">@@ -520,6 +521,9 @@</span> <span class="p_context"> void usb_stor_adjust_quirks(struct usb_device *udev, unsigned long *fflags)</span>
 		case &#39;f&#39;:
 			f |= US_FL_NO_REPORT_OPCODES;
 			break;
<span class="p_add">+		case &#39;g&#39;:</span>
<span class="p_add">+			f |= US_FL_MAX_SECTORS_240;</span>
<span class="p_add">+			break;</span>
 		case &#39;h&#39;:
 			f |= US_FL_CAPACITY_HEURISTICS;
 			break;
<span class="p_chunk">@@ -1080,7 +1084,7 @@</span> <span class="p_context"> static int storage_probe(struct usb_interface *intf,</span>
 
 	/* If uas is enabled and this device can do uas then ignore it. */
 #if IS_ENABLED(CONFIG_USB_UAS)
<span class="p_del">-	if (uas_use_uas_driver(intf, id))</span>
<span class="p_add">+	if (uas_use_uas_driver(intf, id, NULL))</span>
 		return -ENXIO;
 #endif
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index f23d4be3280e..2b4c5423672d 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2403,7 +2403,7 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 			&quot;Attempt to delete subvolume %llu during send&quot;,
 			dest-&gt;root_key.objectid);
 		err = -EPERM;
<span class="p_del">-		goto out_dput;</span>
<span class="p_add">+		goto out_unlock_inode;</span>
 	}
 
 	d_invalidate(dentry);
<span class="p_chunk">@@ -2498,6 +2498,7 @@</span> <span class="p_context"> out_up_write:</span>
 				root_flags &amp; ~BTRFS_ROOT_SUBVOL_DEAD);
 		spin_unlock(&amp;dest-&gt;root_item_lock);
 	}
<span class="p_add">+out_unlock_inode:</span>
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 	if (!err) {
 		shrink_dcache_sb(root-&gt;fs_info-&gt;sb);
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index bed43081720f..16f6365f65e7 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -4934,13 +4934,6 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * currently supporting (pre)allocate mode for extent-based</span>
<span class="p_del">-	 * files _only_</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-</span>
 	if (mode &amp; FALLOC_FL_COLLAPSE_RANGE)
 		return ext4_collapse_range(inode, offset, len);
 
<span class="p_chunk">@@ -4962,6 +4955,14 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only support preallocation for extent-based files only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {</span>
<span class="p_add">+		ret = -EOPNOTSUPP;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp;
 	     offset + len &gt; i_size_read(inode)) {
 		new_size = offset + len;
<span class="p_header">diff --git a/fs/ext4/extents_status.c b/fs/ext4/extents_status.c</span>
<span class="p_header">index e04d45733976..9a0121376358 100644</span>
<span class="p_header">--- a/fs/ext4/extents_status.c</span>
<span class="p_header">+++ b/fs/ext4/extents_status.c</span>
<span class="p_chunk">@@ -705,6 +705,14 @@</span> <span class="p_context"> int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,</span>
 
 	BUG_ON(end &lt; lblk);
 
<span class="p_add">+	if ((status &amp; EXTENT_STATUS_DELAYED) &amp;&amp;</span>
<span class="p_add">+	    (status &amp; EXTENT_STATUS_WRITTEN)) {</span>
<span class="p_add">+		ext4_warning(inode-&gt;i_sb, &quot;Inserting extent [%u/%u] as &quot;</span>
<span class="p_add">+				&quot; delayed and written which can potentially &quot;</span>
<span class="p_add">+				&quot; cause data loss.\n&quot;, lblk, len);</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	newes.es_lblk = lblk;
 	newes.es_len = len;
 	ext4_es_store_pblock_status(&amp;newes, pblk, status);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 5cb9a212b86f..852cc521f327 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -534,6 +534,7 @@</span> <span class="p_context"> int ext4_map_blocks(handle_t *handle, struct inode *inode,</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_chunk">@@ -638,6 +639,7 @@</span> <span class="p_context"> found:</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_header">diff --git a/fs/hfsplus/xattr.c b/fs/hfsplus/xattr.c</span>
<span class="p_header">index d98094a9f476..ff10f3decbc9 100644</span>
<span class="p_header">--- a/fs/hfsplus/xattr.c</span>
<span class="p_header">+++ b/fs/hfsplus/xattr.c</span>
<span class="p_chunk">@@ -806,9 +806,6 @@</span> <span class="p_context"> end_removexattr:</span>
 static int hfsplus_osx_getxattr(struct dentry *dentry, const char *name,
 					void *buffer, size_t size, int type)
 {
<span class="p_del">-	char *xattr_name;</span>
<span class="p_del">-	int res;</span>
<span class="p_del">-</span>
 	if (!strcmp(name, &quot;&quot;))
 		return -EINVAL;
 
<span class="p_chunk">@@ -818,24 +815,19 @@</span> <span class="p_context"> static int hfsplus_osx_getxattr(struct dentry *dentry, const char *name,</span>
 	 */
 	if (is_known_namespace(name))
 		return -EOPNOTSUPP;
<span class="p_del">-	xattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN</span>
<span class="p_del">-		+ XATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);</span>
<span class="p_del">-	if (!xattr_name)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	strcpy(xattr_name, XATTR_MAC_OSX_PREFIX);</span>
<span class="p_del">-	strcpy(xattr_name + XATTR_MAC_OSX_PREFIX_LEN, name);</span>
 
<span class="p_del">-	res = hfsplus_getxattr(dentry, xattr_name, buffer, size);</span>
<span class="p_del">-	kfree(xattr_name);</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * osx is the namespace we use to indicate an unprefixed</span>
<span class="p_add">+	 * attribute on the filesystem (like the ones that OS X</span>
<span class="p_add">+	 * creates), so we pass the name through unmodified (after</span>
<span class="p_add">+	 * ensuring it doesn&#39;t conflict with another namespace).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return hfsplus_getxattr(dentry, name, buffer, size);</span>
 }
 
 static int hfsplus_osx_setxattr(struct dentry *dentry, const char *name,
 		const void *buffer, size_t size, int flags, int type)
 {
<span class="p_del">-	char *xattr_name;</span>
<span class="p_del">-	int res;</span>
<span class="p_del">-</span>
 	if (!strcmp(name, &quot;&quot;))
 		return -EINVAL;
 
<span class="p_chunk">@@ -845,16 +837,14 @@</span> <span class="p_context"> static int hfsplus_osx_setxattr(struct dentry *dentry, const char *name,</span>
 	 */
 	if (is_known_namespace(name))
 		return -EOPNOTSUPP;
<span class="p_del">-	xattr_name = kmalloc(NLS_MAX_CHARSET_SIZE * HFSPLUS_ATTR_MAX_STRLEN</span>
<span class="p_del">-		+ XATTR_MAC_OSX_PREFIX_LEN + 1, GFP_KERNEL);</span>
<span class="p_del">-	if (!xattr_name)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	strcpy(xattr_name, XATTR_MAC_OSX_PREFIX);</span>
<span class="p_del">-	strcpy(xattr_name + XATTR_MAC_OSX_PREFIX_LEN, name);</span>
 
<span class="p_del">-	res = hfsplus_setxattr(dentry, xattr_name, buffer, size, flags);</span>
<span class="p_del">-	kfree(xattr_name);</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * osx is the namespace we use to indicate an unprefixed</span>
<span class="p_add">+	 * attribute on the filesystem (like the ones that OS X</span>
<span class="p_add">+	 * creates), so we pass the name through unmodified (after</span>
<span class="p_add">+	 * ensuring it doesn&#39;t conflict with another namespace).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return hfsplus_setxattr(dentry, name, buffer, size, flags);</span>
 }
 
 static size_t hfsplus_osx_listxattr(struct dentry *dentry, char *list,
<span class="p_header">diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h</span>
<span class="p_header">index a7f2604c5f25..7f5f78bd15ad 100644</span>
<span class="p_header">--- a/include/linux/usb_usual.h</span>
<span class="p_header">+++ b/include/linux/usb_usual.h</span>
<span class="p_chunk">@@ -77,6 +77,8 @@</span> <span class="p_context"></span>
 		/* Cannot handle ATA_12 or ATA_16 CDBs */	\
 	US_FLAG(NO_REPORT_OPCODES,	0x04000000)		\
 		/* Cannot handle MI_REPORT_SUPPORTED_OPERATION_CODES */	\
<span class="p_add">+	US_FLAG(MAX_SECTORS_240,	0x08000000)		\</span>
<span class="p_add">+		/* Sets max_sectors to 240 */			\</span>
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };
<span class="p_header">diff --git a/include/scsi/scsi_devinfo.h b/include/scsi/scsi_devinfo.h</span>
<span class="p_header">index 183eaab7c380..96e3f56519e7 100644</span>
<span class="p_header">--- a/include/scsi/scsi_devinfo.h</span>
<span class="p_header">+++ b/include/scsi/scsi_devinfo.h</span>
<span class="p_chunk">@@ -36,5 +36,6 @@</span> <span class="p_context"></span>
 					     for sequential scan */
 #define BLIST_TRY_VPD_PAGES	0x10000000 /* Attempt to read VPD pages */
 #define BLIST_NO_RSOC		0x20000000 /* don&#39;t try to issue RSOC */
<span class="p_add">+#define BLIST_MAX_1024		0x40000000 /* maximum 1024 sector cdb length */</span>
 
 #endif
<span class="p_header">diff --git a/include/sound/emu10k1.h b/include/sound/emu10k1.h</span>
<span class="p_header">index 0de95ccb92cf..5bd134651f5e 100644</span>
<span class="p_header">--- a/include/sound/emu10k1.h</span>
<span class="p_header">+++ b/include/sound/emu10k1.h</span>
<span class="p_chunk">@@ -41,7 +41,8 @@</span> <span class="p_context"></span>
 
 #define EMUPAGESIZE     4096
 #define MAXREQVOICES    8
<span class="p_del">-#define MAXPAGES        8192</span>
<span class="p_add">+#define MAXPAGES0       4096	/* 32 bit mode */</span>
<span class="p_add">+#define MAXPAGES1       8192	/* 31 bit mode */</span>
 #define RESERVED        0
 #define NUM_MIDI        16
 #define NUM_G           64              /* use all channels */
<span class="p_chunk">@@ -50,8 +51,7 @@</span> <span class="p_context"></span>
 
 /* FIXME? - according to the OSS driver the EMU10K1 needs a 29 bit DMA mask */
 #define EMU10K1_DMA_MASK	0x7fffffffUL	/* 31bit */
<span class="p_del">-#define AUDIGY_DMA_MASK		0x7fffffffUL	/* 31bit FIXME - 32 should work? */</span>
<span class="p_del">-						/* See ALSA bug #1276 - rlrevell */</span>
<span class="p_add">+#define AUDIGY_DMA_MASK		0xffffffffUL	/* 32bit mode */</span>
 
 #define TMEMSIZE        256*1024
 #define TMEMSIZEREG     4
<span class="p_chunk">@@ -466,8 +466,11 @@</span> <span class="p_context"></span>
 
 #define MAPB			0x0d		/* Cache map B						*/
 
<span class="p_del">-#define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_del">-#define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
<span class="p_add">+#define MAP_PTE_MASK0		0xfffff000	/* The 20 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK0		0x00000fff	/* The 12 bit index to one of the 4096 PTE dwords      	*/</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAP_PTE_MASK1		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK1		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
 
 /* 0x0e, 0x0f: Not used */
 
<span class="p_chunk">@@ -1704,6 +1707,7 @@</span> <span class="p_context"> struct snd_emu10k1 {</span>
 	unsigned short model;			/* subsystem id */
 	unsigned int card_type;			/* EMU10K1_CARD_* */
 	unsigned int ecard_ctrl;		/* ecard control bits */
<span class="p_add">+	unsigned int address_mode;		/* address mode */</span>
 	unsigned long dma_mask;			/* PCI DMA mask */
 	unsigned int delay_pcm_irq;		/* in samples */
 	int max_cache_pages;			/* max memory size / PAGE_SIZE */
<span class="p_header">diff --git a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h</span>
<span class="p_header">index 8d7416e46861..15355892a0ff 100644</span>
<span class="p_header">--- a/include/sound/soc-dapm.h</span>
<span class="p_header">+++ b/include/sound/soc-dapm.h</span>
<span class="p_chunk">@@ -287,7 +287,7 @@</span> <span class="p_context"> struct device;</span>
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
 	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
<span class="p_del">-	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }</span>
<span class="p_add">+	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 1) }</span>
 #define SOC_DAPM_SINGLE_TLV_VIRT(xname, max, tlv_array) \
 	SOC_DAPM_SINGLE(xname, SND_SOC_NOPM, 0, max, 0, tlv_array)
 #define SOC_DAPM_ENUM(xname, xenum) \
<span class="p_header">diff --git a/kernel/bpf/core.c b/kernel/bpf/core.c</span>
<span class="p_header">index a64e7a207d2b..0c5796eadae1 100644</span>
<span class="p_header">--- a/kernel/bpf/core.c</span>
<span class="p_header">+++ b/kernel/bpf/core.c</span>
<span class="p_chunk">@@ -357,8 +357,8 @@</span> <span class="p_context"> select_insn:</span>
 	ALU64_MOD_X:
 		if (unlikely(SRC == 0))
 			return 0;
<span class="p_del">-		tmp = DST;</span>
<span class="p_del">-		DST = do_div(tmp, SRC);</span>
<span class="p_add">+		div64_u64_rem(DST, SRC, &amp;tmp);</span>
<span class="p_add">+		DST = tmp;</span>
 		CONT;
 	ALU_MOD_X:
 		if (unlikely(SRC == 0))
<span class="p_chunk">@@ -367,8 +367,8 @@</span> <span class="p_context"> select_insn:</span>
 		DST = do_div(tmp, (u32) SRC);
 		CONT;
 	ALU64_MOD_K:
<span class="p_del">-		tmp = DST;</span>
<span class="p_del">-		DST = do_div(tmp, IMM);</span>
<span class="p_add">+		div64_u64_rem(DST, IMM, &amp;tmp);</span>
<span class="p_add">+		DST = tmp;</span>
 		CONT;
 	ALU_MOD_K:
 		tmp = (u32) DST;
<span class="p_chunk">@@ -377,7 +377,7 @@</span> <span class="p_context"> select_insn:</span>
 	ALU64_DIV_X:
 		if (unlikely(SRC == 0))
 			return 0;
<span class="p_del">-		do_div(DST, SRC);</span>
<span class="p_add">+		DST = div64_u64(DST, SRC);</span>
 		CONT;
 	ALU_DIV_X:
 		if (unlikely(SRC == 0))
<span class="p_chunk">@@ -387,7 +387,7 @@</span> <span class="p_context"> select_insn:</span>
 		DST = (u32) tmp;
 		CONT;
 	ALU64_DIV_K:
<span class="p_del">-		do_div(DST, IMM);</span>
<span class="p_add">+		DST = div64_u64(DST, IMM);</span>
 		CONT;
 	ALU_DIV_K:
 		tmp = (u32) DST;
<span class="p_header">diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c</span>
<span class="p_header">index 208d5439e59b..787b0d699969 100644</span>
<span class="p_header">--- a/net/ipv4/ping.c</span>
<span class="p_header">+++ b/net/ipv4/ping.c</span>
<span class="p_chunk">@@ -158,6 +158,7 @@</span> <span class="p_context"> void ping_unhash(struct sock *sk)</span>
 	if (sk_hashed(sk)) {
 		write_lock_bh(&amp;ping_table.lock);
 		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);
<span class="p_add">+		sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span>
 		sock_put(sk);
 		isk-&gt;inet_num = 0;
 		isk-&gt;inet_sport = 0;
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index ad5064362c5c..20fc0202cbbe 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -963,10 +963,7 @@</span> <span class="p_context"> static void __ip_rt_update_pmtu(struct rtable *rt, struct flowi4 *fl4, u32 mtu)</span>
 	if (dst_metric_locked(dst, RTAX_MTU))
 		return;
 
<span class="p_del">-	if (dst-&gt;dev-&gt;mtu &lt; mtu)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (rt-&gt;rt_pmtu &amp;&amp; rt-&gt;rt_pmtu &lt; mtu)</span>
<span class="p_add">+	if (ipv4_mtu(dst) &lt; mtu)</span>
 		return;
 
 	if (mtu &lt; ip_rt_min_pmtu)
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">index 37d0220a094c..db7a2e5e4a14 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_chunk">@@ -183,8 +183,10 @@</span> <span class="p_context"> static int snd_card_emu10k1_probe(struct pci_dev *pci,</span>
 	}
 #endif
  
<span class="p_del">-	strcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver);</span>
<span class="p_del">-	strcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name);</span>
<span class="p_add">+	strlcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver,</span>
<span class="p_add">+		sizeof(card-&gt;driver));</span>
<span class="p_add">+	strlcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name,</span>
<span class="p_add">+		sizeof(card-&gt;shortname));</span>
 	snprintf(card-&gt;longname, sizeof(card-&gt;longname),
 		 &quot;%s (rev.%d, serial:0x%x) at 0x%lx, irq %i&quot;,
 		 card-&gt;shortname, emu-&gt;revision, emu-&gt;serial, emu-&gt;port, emu-&gt;irq);
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">index 874cd76c7b7f..d2c7ea3a7610 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
 
 	/* invalidate maps */
<span class="p_del">-	temp = (hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	temp = (hw-&gt;silent_page.addr &lt;&lt; hw-&gt;address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 #if 0
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
<span class="p_del">-		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; hw_address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">index b4458a630a7c..df9f5c7c9c77 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 	snd_emu10k1_ptr_write(emu, TCB, 0, 0);	/* taken from original driver */
 	snd_emu10k1_ptr_write(emu, TCBS, 0, 4);	/* taken from original driver */
 
<span class="p_del">-	silent_page = (emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = (emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	for (ch = 0; ch &lt; NUM_G; ch++) {
 		snd_emu10k1_ptr_write(emu, MAPA, ch, silent_page);
 		snd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);
<span class="p_chunk">@@ -348,6 +348,11 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 		outl(reg | A_IOCFG_GPOUT0, emu-&gt;port + A_IOCFG);
 	}
 
<span class="p_add">+	if (emu-&gt;address_mode == 0) {</span>
<span class="p_add">+		/* use 16M in 4G */</span>
<span class="p_add">+		outl(inl(emu-&gt;port + HCFG) | HCFG_EXPANDED_MEM, emu-&gt;port + HCFG);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1421,7 +1426,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 *
 	 */
 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 ZS Notebook [SB0530]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 ZS Notebook [SB0530]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0108_chip = 1,
<span class="p_chunk">@@ -1571,7 +1576,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 Platinum EX [SB0280]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 Platinum EX [SB0280]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
<span class="p_chunk">@@ -1877,8 +1882,10 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	is_audigy = emu-&gt;audigy = c-&gt;emu10k2_chip;
 
<span class="p_add">+	/* set addressing mode */</span>
<span class="p_add">+	emu-&gt;address_mode = is_audigy ? 0 : 1;</span>
 	/* set the DMA transfer mask */
<span class="p_del">-	emu-&gt;dma_mask = is_audigy ? AUDIGY_DMA_MASK : EMU10K1_DMA_MASK;</span>
<span class="p_add">+	emu-&gt;dma_mask = emu-&gt;address_mode ? EMU10K1_DMA_MASK : AUDIGY_DMA_MASK;</span>
 	if (pci_set_dma_mask(pci, emu-&gt;dma_mask) &lt; 0 ||
 	    pci_set_consistent_dma_mask(pci, emu-&gt;dma_mask) &lt; 0) {
 		dev_err(card-&gt;dev,
<span class="p_chunk">@@ -1903,7 +1910,7 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	emu-&gt;max_cache_pages = max_cache_bytes &gt;&gt; PAGE_SHIFT;
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
<span class="p_del">-				32 * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
<span class="p_add">+				(emu-&gt;address_mode ? 32 : 16) * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
 		err = -ENOMEM;
 		goto error;
 	}
<span class="p_chunk">@@ -2002,8 +2009,8 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	/* Clear silent pages and set up pointers */
 	memset(emu-&gt;silent_page.area, 0, PAGE_SIZE);
<span class="p_del">-	silent_page = emu-&gt;silent_page.addr &lt;&lt; 1;</span>
<span class="p_del">-	for (idx = 0; idx &lt; MAXPAGES; idx++)</span>
<span class="p_add">+	silent_page = emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode;</span>
<span class="p_add">+	for (idx = 0; idx &lt; (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0); idx++)</span>
 		((u32 *)emu-&gt;ptb_pages.area)[idx] = cpu_to_le32(silent_page | idx);
 
 	/* set up voice indices */
<span class="p_header">diff --git a/sound/pci/emu10k1/emupcm.c b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">index 0dc07385af0e..14a305bd8a98 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,</span>
 	snd_emu10k1_ptr_write(emu, Z1, voice, 0);
 	snd_emu10k1_ptr_write(emu, Z2, voice, 0);
 	/* invalidate maps */
<span class="p_del">-	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);
 	snd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);
 	/* modulation envelope */
<span class="p_header">diff --git a/sound/pci/emu10k1/memory.c b/sound/pci/emu10k1/memory.c</span>
<span class="p_header">index c68e6dd2fa67..4f1f69be1865 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/memory.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/memory.c</span>
<span class="p_chunk">@@ -34,10 +34,11 @@</span> <span class="p_context"></span>
  * aligned pages in others
  */
 #define __set_ptb_entry(emu,page,addr) \
<span class="p_del">-	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; 1) | (page)))</span>
<span class="p_add">+	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; (emu-&gt;address_mode)) | (page)))</span>
 
 #define UNIT_PAGES		(PAGE_SIZE / EMUPAGESIZE)
<span class="p_del">-#define MAX_ALIGN_PAGES		(MAXPAGES / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES0		(MAXPAGES0 / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES1		(MAXPAGES1 / UNIT_PAGES)</span>
 /* get aligned page from offset address */
 #define get_aligned_page(offset)	((offset) &gt;&gt; PAGE_SHIFT)
 /* get offset address from aligned page */
<span class="p_chunk">@@ -124,7 +125,7 @@</span> <span class="p_context"> static int search_empty_map_area(struct snd_emu10k1 *emu, int npages, struct lis</span>
 		}
 		page = blk-&gt;mapped_page + blk-&gt;pages;
 	}
<span class="p_del">-	size = MAX_ALIGN_PAGES - page;</span>
<span class="p_add">+	size = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0) - page;</span>
 	if (size &gt;= max_size) {
 		*nextp = pos;
 		return page;
<span class="p_chunk">@@ -181,7 +182,7 @@</span> <span class="p_context"> static int unmap_memblk(struct snd_emu10k1 *emu, struct snd_emu10k1_memblk *blk)</span>
 		q = get_emu10k1_memblk(p, mapped_link);
 		end_page = q-&gt;mapped_page;
 	} else
<span class="p_del">-		end_page = MAX_ALIGN_PAGES;</span>
<span class="p_add">+		end_page = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0);</span>
 
 	/* remove links */
 	list_del(&amp;blk-&gt;mapped_link);
<span class="p_chunk">@@ -307,7 +308,7 @@</span> <span class="p_context"> snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu, struct snd_pcm_substream *subst</span>
 	if (snd_BUG_ON(!emu))
 		return NULL;
 	if (snd_BUG_ON(runtime-&gt;dma_bytes &lt;= 0 ||
<span class="p_del">-		       runtime-&gt;dma_bytes &gt;= MAXPAGES * EMUPAGESIZE))</span>
<span class="p_add">+		       runtime-&gt;dma_bytes &gt;= (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0) * EMUPAGESIZE))</span>
 		return NULL;
 	hdr = emu-&gt;memhdr;
 	if (snd_BUG_ON(!hdr))
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index 2fe86d2e1b09..a63a86332deb 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -3027,6 +3027,16 @@</span> <span class="p_context"> static struct snd_kcontrol_new vmaster_mute_mode = {</span>
 	.put = vmaster_mute_mode_put,
 };
 
<span class="p_add">+/* meta hook to call each driver&#39;s vmaster hook */</span>
<span class="p_add">+static void vmaster_hook(void *private_data, int enabled)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hda_vmaster_mute_hook *hook = private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hook-&gt;mute_mode != HDA_VMUTE_FOLLOW_MASTER)</span>
<span class="p_add">+		enabled = hook-&gt;mute_mode;</span>
<span class="p_add">+	hook-&gt;hook(hook-&gt;codec, enabled);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * snd_hda_add_vmaster_hook - Add a vmaster hook for mute-LED
  * @codec: the HDA codec
<span class="p_chunk">@@ -3045,9 +3055,9 @@</span> <span class="p_context"> int snd_hda_add_vmaster_hook(struct hda_codec *codec,</span>
 
 	if (!hook-&gt;hook || !hook-&gt;sw_kctl)
 		return 0;
<span class="p_del">-	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, hook-&gt;hook, codec);</span>
 	hook-&gt;codec = codec;
 	hook-&gt;mute_mode = HDA_VMUTE_FOLLOW_MASTER;
<span class="p_add">+	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, vmaster_hook, hook);</span>
 	if (!expose_enum_ctl)
 		return 0;
 	kctl = snd_ctl_new1(&amp;vmaster_mute_mode, hook);
<span class="p_chunk">@@ -3073,14 +3083,7 @@</span> <span class="p_context"> void snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)</span>
 	 */
 	if (hook-&gt;codec-&gt;bus-&gt;shutdown)
 		return;
<span class="p_del">-	switch (hook-&gt;mute_mode) {</span>
<span class="p_del">-	case HDA_VMUTE_FOLLOW_MASTER:</span>
<span class="p_del">-		snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		hook-&gt;hook(hook-&gt;codec, hook-&gt;mute_mode);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
 }
 EXPORT_SYMBOL_GPL(snd_hda_sync_vmaster_hook);
 
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index 6ba0b5517c40..2341fc334163 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -72,6 +72,7 @@</span> <span class="p_context"> static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,</span>
 		if (led_set_func(TPACPI_LED_MUTE, false) &gt;= 0) {
 			old_vmaster_hook = spec-&gt;vmaster_mute.hook;
 			spec-&gt;vmaster_mute.hook = update_tpacpi_mute_led;
<span class="p_add">+			spec-&gt;vmaster_mute_enum = 1;</span>
 			removefunc = false;
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) &gt;= 0) {
<span class="p_header">diff --git a/sound/soc/codecs/rt5677.c b/sound/soc/codecs/rt5677.c</span>
<span class="p_header">index fb9c20eace3f..97b33e96439a 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5677.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5677.c</span>
<span class="p_chunk">@@ -62,6 +62,9 @@</span> <span class="p_context"> static const struct reg_default init_list[] = {</span>
 	{RT5677_PR_BASE + 0x1e,	0x0000},
 	{RT5677_PR_BASE + 0x12,	0x0eaa},
 	{RT5677_PR_BASE + 0x14,	0x018a},
<span class="p_add">+	{RT5677_PR_BASE + 0x15,	0x0490},</span>
<span class="p_add">+	{RT5677_PR_BASE + 0x38,	0x0f71},</span>
<span class="p_add">+	{RT5677_PR_BASE + 0x39,	0x0f71},</span>
 };
 #define RT5677_INIT_REG_LEN ARRAY_SIZE(init_list)
 
<span class="p_chunk">@@ -901,7 +904,7 @@</span> <span class="p_context"> static int set_dmic_clk(struct snd_soc_dapm_widget *w,</span>
 {
 	struct snd_soc_codec *codec = snd_soc_dapm_to_codec(w-&gt;dapm);
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int idx = rl6231_calc_dmic_clk(rt5677-&gt;sysclk);</span>
<span class="p_add">+	int idx = rl6231_calc_dmic_clk(rt5677-&gt;lrck[RT5677_AIF1] &lt;&lt; 8);</span>
 
 	if (idx &lt; 0)
 		dev_err(codec-&gt;dev, &quot;Failed to set DMIC clock\n&quot;);
<span class="p_header">diff --git a/sound/soc/codecs/tfa9879.c b/sound/soc/codecs/tfa9879.c</span>
<span class="p_header">index 16f1b71edb55..aab0af681e8c 100644</span>
<span class="p_header">--- a/sound/soc/codecs/tfa9879.c</span>
<span class="p_header">+++ b/sound/soc/codecs/tfa9879.c</span>
<span class="p_chunk">@@ -280,8 +280,8 @@</span> <span class="p_context"> static int tfa9879_i2c_probe(struct i2c_client *i2c,</span>
 	int i;
 
 	tfa9879 = devm_kzalloc(&amp;i2c-&gt;dev, sizeof(*tfa9879), GFP_KERNEL);
<span class="p_del">-	if (IS_ERR(tfa9879))</span>
<span class="p_del">-		return PTR_ERR(tfa9879);</span>
<span class="p_add">+	if (!tfa9879)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	i2c_set_clientdata(i2c, tfa9879);
 
<span class="p_header">diff --git a/sound/soc/samsung/s3c24xx-i2s.c b/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_header">index 326d3c3804e3..5bf723689692 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_chunk">@@ -461,8 +461,8 @@</span> <span class="p_context"> static int s3c24xx_iis_dev_probe(struct platform_device *pdev)</span>
 		return -ENOENT;
 	}
 	s3c24xx_i2s.regs = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
<span class="p_del">-	if (s3c24xx_i2s.regs == NULL)</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (IS_ERR(s3c24xx_i2s.regs))</span>
<span class="p_add">+		return PTR_ERR(s3c24xx_i2s.regs);</span>
 
 	s3c24xx_i2s_pcm_stereo_out.dma_addr = res-&gt;start + S3C2410_IISFIFO;
 	s3c24xx_i2s_pcm_stereo_in.dma_addr = res-&gt;start + S3C2410_IISFIFO;
<span class="p_header">diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c</span>
<span class="p_header">index ab37add269ae..82e350e9501c 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_oss.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_oss.c</span>
<span class="p_chunk">@@ -118,12 +118,8 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (snd_BUG_ON(!arg || !emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!snd_emux_inc_count(emu)) {</span>
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	if (!snd_emux_inc_count(emu))</span>
 		return -EFAULT;
<span class="p_del">-	}</span>
 
 	memset(&amp;callback, 0, sizeof(callback));
 	callback.owner = THIS_MODULE;
<span class="p_chunk">@@ -135,7 +131,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (p == NULL) {
 		snd_printk(KERN_ERR &quot;can&#39;t create port\n&quot;);
 		snd_emux_dec_count(emu);
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -148,8 +143,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	reset_port_mode(p, arg-&gt;seq_mode);
 
 	snd_emux_reset_port(p);
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -195,13 +188,11 @@</span> <span class="p_context"> snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)</span>
 	if (snd_BUG_ON(!emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu-&gt;sflist, SF_CLIENT_NO(p-&gt;chset.port));
 	snd_seq_event_port_detach(p-&gt;chset.client, p-&gt;chset.port);
 	snd_emux_dec_count(emu);
 
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c</span>
<span class="p_header">index 7778b8e19782..a0209204ae48 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_seq.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_seq.c</span>
<span class="p_chunk">@@ -124,12 +124,10 @@</span> <span class="p_context"> snd_emux_detach_seq(struct snd_emux *emu)</span>
 	if (emu-&gt;voices)
 		snd_emux_terminate_all(emu);
 		
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	if (emu-&gt;client &gt;= 0) {
 		snd_seq_delete_kernel_client(emu-&gt;client);
 		emu-&gt;client = -1;
 	}
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 }
 
 
<span class="p_chunk">@@ -269,8 +267,8 @@</span> <span class="p_context"> snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,</span>
 /*
  * increment usage count
  */
<span class="p_del">-int</span>
<span class="p_del">-snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+static int</span>
<span class="p_add">+__snd_emux_inc_count(struct snd_emux *emu)</span>
 {
 	emu-&gt;used++;
 	if (!try_module_get(emu-&gt;ops.owner))
<span class="p_chunk">@@ -284,12 +282,21 @@</span> <span class="p_context"> snd_emux_inc_count(struct snd_emux *emu)</span>
 	return 1;
 }
 
<span class="p_add">+int snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	ret = __snd_emux_inc_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
 /*
  * decrease usage count
  */
<span class="p_del">-void</span>
<span class="p_del">-snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+static void</span>
<span class="p_add">+__snd_emux_dec_count(struct snd_emux *emu)</span>
 {
 	module_put(emu-&gt;card-&gt;module);
 	emu-&gt;used--;
<span class="p_chunk">@@ -298,6 +305,12 @@</span> <span class="p_context"> snd_emux_dec_count(struct snd_emux *emu)</span>
 	module_put(emu-&gt;ops.owner);
 }
 
<span class="p_add">+void snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+}</span>
 
 /*
  * Routine that is called upon a first use of a particular port
<span class="p_chunk">@@ -317,7 +330,7 @@</span> <span class="p_context"> snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_init_port(p);
<span class="p_del">-	snd_emux_inc_count(emu);</span>
<span class="p_add">+	__snd_emux_inc_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -340,7 +353,7 @@</span> <span class="p_context"> snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_sounds_off_all(p);
<span class="p_del">-	snd_emux_dec_count(emu);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



