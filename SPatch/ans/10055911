
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.50 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.50</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 13, 2017, 1:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171113130705.GL2971@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10055911/mbox/"
   >mbox</a>
|
   <a href="/patch/10055911/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10055911/">/patch/10055911/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4B7A760586 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Nov 2017 13:08:29 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EA347294F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Nov 2017 13:08:28 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id DC21A2950B; Mon, 13 Nov 2017 13:08:28 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D7DB2294F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Nov 2017 13:08:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751190AbdKMNIK (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 13 Nov 2017 08:08:10 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:46847 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1752715AbdKMNH2 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 13 Nov 2017 08:07:28 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1eEES9-0001qX-Cq; Mon, 13 Nov 2017 13:07:21 +0000
Date: Mon, 13 Nov 2017 13:07:05 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20171113130705.GL2971@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;6sj9mcRtP+pTWLOo&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.50
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Nov. 13, 2017, 1:07 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.50 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.49 is attached to this message.

Ben.

------------

 Documentation/video4linux/v4l2-pci-skeleton.c      |   2 +-
 Makefile                                           |   3 +-
 arch/alpha/include/asm/types.h                     |   1 -
 arch/alpha/include/uapi/asm/types.h                |  12 +-
 arch/arm/include/asm/kexec.h                       |   5 +
 arch/arm/kernel/iwmmxt.S                           |  13 +
 arch/arm/kernel/machine_kexec.c                    |  11 +-
 arch/arm/kernel/pj4-cp0.c                          |   4 +
 arch/arm/kernel/return_address.c                   |   4 -
 arch/arm/mach-cns3xxx/Makefile                     |   1 +
 arch/arm/mach-omap2/Kconfig                        |   3 -
 arch/arm/mach-pxa/Kconfig                          |   1 +
 arch/arm/mm/cache-l2x0.c                           | 111 ++---
 arch/arm/plat-omap/Kconfig                         |   3 +
 arch/arm64/kernel/fpsimd.c                         |   2 +
 arch/arm64/mm/fault.c                              |   5 +-
 arch/mips/boot/elf2ecoff.c                         |  10 +-
 arch/mips/dec/int-handler.S                        |  18 +-
 arch/mips/include/asm/page.h                       |   3 +-
 arch/mips/jz4740/board-qi_lb60.c                   |   1 +
 arch/mips/jz4740/gpio.c                            |   1 +
 arch/mips/jz4740/irq.h                             |   2 +
 arch/mips/kernel/bmips_vec.S                       |   3 -
 arch/mips/pci/ops-pmcmsp.c                         |  12 -
 arch/mips/pci/ops-tx4927.c                         |   2 -
 arch/mips/sgi-ip22/Platform                        |   2 +-
 arch/powerpc/boot/Makefile                         |  16 +-
 arch/powerpc/kvm/book3s_hv.c                       |   2 +
 arch/powerpc/mm/subpage-prot.c                     |   2 +-
 arch/powerpc/platforms/pseries/reconfig.c          |   1 -
 arch/x86/boot/compressed/misc.h                    |  11 +-
 arch/x86/crypto/sha1_avx2_x86_64_asm.S             |  67 +--
 arch/x86/crypto/sha1_ssse3_glue.c                  |   2 +-
 arch/x86/kernel/acpi/boot.c                        |   8 +
 arch/x86/kernel/cpu/perf_event.c                   |   7 +-
 arch/x86/kernel/entry_64.S                         |   2 +
 arch/x86/kernel/kprobes/core.c                     |  10 +-
 arch/x86/kernel/kvm.c                              |   6 +-
 arch/x86/xen/mmu.c                                 |   2 +-
 arch/xtensa/kernel/xtensa_ksyms.c                  |   2 -
 arch/xtensa/mm/cache.c                             |  12 +-
 block/bio.c                                        |   8 +
 drivers/ata/libata-scsi.c                          |   6 +-
 drivers/ata/pata_hpt366.c                          |   4 +-
 drivers/block/drbd/drbd_bitmap.c                   |   6 +
 drivers/block/paride/pg.c                          |   4 +-
 drivers/clk/clk-efm32gg.c                          |   6 +-
 drivers/dma/amba-pl08x.c                           |   4 +-
 drivers/gpio/gpio-tegra.c                          |   6 +-
 drivers/gpu/drm/drm_gem.c                          |   6 +-
 drivers/gpu/drm/i915/i915_debugfs.c                |   5 +-
 drivers/gpu/drm/msm/msm_gem_submit.c               |   7 +-
 drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c            |   2 +-
 drivers/hid/usbhid/hid-core.c                      |  12 +-
 drivers/i2c/busses/i2c-ismt.c                      |   5 +
 drivers/i2c/muxes/Kconfig                          |   2 +-
 drivers/iio/adc/exynos_adc.c                       |   2 +-
 drivers/iio/adc/vf610_adc.c                        |   2 +-
 drivers/iio/imu/adis16480.c                        |   2 +-
 drivers/iio/light/tsl2563.c                        |   2 +-
 drivers/infiniband/core/cma.c                      |   2 +
 drivers/infiniband/core/uverbs_cmd.c               |   5 +-
 drivers/infiniband/core/uverbs_main.c              |   3 +-
 drivers/infiniband/hw/cxgb3/iwch_provider.c        |   5 +-
 drivers/infiniband/hw/cxgb4/cq.c                   |   1 +
 drivers/infiniband/hw/mlx5/mem.c                   |   2 +-
 drivers/infiniband/hw/ocrdma/ocrdma_verbs.c        |   4 +-
 drivers/infiniband/ulp/ipoib/ipoib_cm.c            |   1 -
 drivers/infiniband/ulp/ipoib/ipoib_main.c          |   3 +-
 drivers/input/joystick/analog.c                    |   2 +-
 drivers/input/mouse/trackpoint.c                   |   3 +-
 drivers/input/mouse/trackpoint.h                   |   3 +-
 drivers/input/serio/gscps2.c                       |   2 +-
 drivers/iommu/amd_iommu_init.c                     |   2 +-
 drivers/irqchip/irq-brcmstb-l2.c                   |   1 +
 drivers/isdn/hardware/mISDN/mISDNipac.c            |  12 +-
 drivers/isdn/hardware/mISDN/w6692.c                |   6 +-
 drivers/md/dm-bufio.c                              |   1 +
 drivers/md/dm.c                                    |  10 -
 drivers/md/raid5.c                                 |   6 +-
 drivers/media/platform/davinci/vpfe_capture.c      |  22 +-
 drivers/media/rc/ir-lirc-codec.c                   |   2 +-
 drivers/message/i2o/i2o_config.c                   |   4 +-
 drivers/mfd/arizona-core.c                         |   4 +-
 drivers/mfd/arizona-i2c.c                          |   5 +-
 drivers/mfd/arizona-spi.c                          |   3 +-
 drivers/mfd/arizona.h                              |   4 +-
 drivers/mtd/maps/pmcmsp-flash.c                    |   4 +-
 drivers/mtd/maps/rbtx4939-flash.c                  |   2 -
 drivers/mtd/nand/nandsim.c                         |   1 +
 drivers/net/Kconfig                                |   3 +
 drivers/net/ethernet/amd/amd8111e.c                |  19 +-
 drivers/net/ethernet/amd/nmclan_cs.c               |   4 +-
 drivers/net/ethernet/broadcom/b44.c                |   1 +
 drivers/net/ethernet/broadcom/bcmsysport.c         |   4 +-
 drivers/net/ethernet/broadcom/genet/bcmgenet.c     | 456 ++++++++++-----------
 drivers/net/ethernet/broadcom/genet/bcmgenet.h     |   9 +
 drivers/net/ethernet/dec/tulip/tulip_core.c        |   9 +-
 drivers/net/ethernet/dec/tulip/uli526x.c           |   2 +-
 drivers/net/ethernet/dec/tulip/winbond-840.c       |   2 +-
 drivers/net/ethernet/emulex/benet/be_main.c        |   1 -
 drivers/net/ethernet/intel/e1000e/ich8lan.c        |  13 +-
 drivers/net/ethernet/intel/i40e/i40e_debugfs.c     |  30 +-
 drivers/net/ethernet/intel/i40e/i40e_txrx.c        |   2 +
 drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c  |   4 +
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c    |  15 +-
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c     |  10 +-
 drivers/net/ethernet/mellanox/mlx4/en_tx.c         |   6 +-
 drivers/net/ethernet/mellanox/mlx4/fw.c            |   4 +
 drivers/net/ethernet/mellanox/mlx4/fw.h            |   1 +
 drivers/net/ethernet/mellanox/mlx4/main.c          |   2 +
 drivers/net/ethernet/mellanox/mlx5/core/cmd.c      |  19 +-
 drivers/net/ethernet/mellanox/mlx5/core/debugfs.c  |   6 +-
 drivers/net/ethernet/neterion/vxge/vxge-main.c     |  31 +-
 drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c |   2 +-
 drivers/net/ethernet/qlogic/qlge/qlge_dbg.c        |   2 +-
 drivers/net/ethernet/realtek/r8169.c               |   5 +-
 drivers/net/ethernet/ti/cpmac.c                    |   7 +-
 drivers/net/ethernet/xilinx/ll_temac_main.c        |   2 +-
 drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c  |   2 +-
 drivers/net/ethernet/xilinx/xilinx_emaclite.c      |   2 +-
 drivers/net/hyperv/netvsc_drv.c                    |   9 +-
 drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c |   2 +-
 .../net/wireless/brcm80211/brcmfmac/wl_cfg80211.c  |  18 +-
 drivers/net/wireless/hostap/hostap_hw.c            |  15 +-
 drivers/net/wireless/iwlegacy/3945.c               |   3 +-
 drivers/net/wireless/iwlwifi/dvm/tx.c              |   2 +-
 drivers/net/wireless/iwlwifi/mvm/sta.c             |   3 +-
 drivers/net/wireless/ti/wl1251/main.c              |   1 +
 drivers/of/device.c                                |   2 +
 drivers/parisc/dino.c                              |   2 +-
 drivers/pinctrl/sunxi/pinctrl-sun4i-a10.c          |   1 +
 drivers/platform/x86/samsung-laptop.c              |   2 +-
 drivers/power/reset/xgene-reboot.c                 |   2 +-
 drivers/s390/net/qeth_l3_main.c                    |   4 +-
 drivers/scsi/advansys.c                            |   3 +-
 drivers/scsi/aic94xx/aic94xx_sds.c                 |   5 +-
 drivers/scsi/be2iscsi/be_main.c                    |   3 +-
 drivers/scsi/bfa/bfa_ioc.c                         |  22 +-
 drivers/scsi/ips.c                                 |   9 +-
 drivers/scsi/mvsas/mv_sas.c                        |   4 +-
 drivers/scsi/scsi_tgt_if.c                         |   2 +-
 drivers/scsi/st.c                                  |   4 +-
 drivers/spi/spi-atmel.c                            |   4 +-
 drivers/spi/spi-pl022.c                            |   2 +-
 drivers/spi/spi-rspi.c                             |   1 -
 drivers/spmi/spmi.c                                |  12 +
 drivers/staging/bcm/Kconfig                        |   1 +
 drivers/staging/dgnc/dgnc_tty.c                    |  16 +-
 drivers/staging/iio/adc/ad7192.c                   |   2 +-
 drivers/staging/iio/resolver/ad2s1210.c            |   2 +-
 drivers/staging/imx-drm/imx-hdmi.c                 |   2 +-
 drivers/staging/lustre/lustre/llite/llite_lib.c    |   3 +-
 drivers/staging/rtl8188eu/os_dep/usb_intf.c        |   2 +
 drivers/staging/rtl8192ee/pci.c                    |   4 +-
 drivers/staging/rtl8723au/core/rtw_wlan_util.c     |   2 +-
 drivers/staging/vt6655/device_main.c               |  10 +-
 drivers/staging/wlan-ng/prism2fw.c                 |  33 +-
 drivers/target/iscsi/iscsi_target.c                |   1 +
 drivers/target/iscsi/iscsi_target_core.h           |   1 +
 drivers/target/iscsi/iscsi_target_login.c          |   7 +-
 drivers/tty/isicom.c                               |   2 +-
 drivers/tty/nozomi.c                               |   2 +-
 drivers/usb/class/cdc-acm.c                        |   3 +
 drivers/usb/core/config.c                          |  20 +-
 drivers/usb/core/hcd.c                             |   2 +
 drivers/usb/core/hub.c                             |  10 +-
 drivers/usb/core/quirks.c                          |   4 +
 drivers/usb/host/pci-quirks.c                      |  71 +++-
 drivers/usb/host/pci-quirks.h                      |   2 +
 drivers/usb/host/xhci-hub.c                        |   3 +
 drivers/usb/host/xhci-pci.c                        |   6 +
 drivers/usb/host/xhci-ring.c                       |  11 +-
 drivers/usb/host/xhci.c                            |  10 +-
 drivers/usb/host/xhci.h                            |   1 +
 drivers/usb/misc/usbtest.c                         |   5 +-
 drivers/usb/renesas_usbhs/common.c                 |   4 +-
 drivers/usb/renesas_usbhs/mod_gadget.c             |  42 +-
 drivers/usb/renesas_usbhs/pipe.c                   |  10 +
 drivers/usb/renesas_usbhs/pipe.h                   |   1 +
 drivers/usb/serial/cp210x.c                        |   1 +
 drivers/usb/serial/option.c                        |   2 +
 drivers/usb/storage/isd200.c                       |   5 +-
 drivers/usb/storage/uas-detect.h                   |  15 +-
 drivers/usb/storage/uas.c                          |  10 +-
 drivers/usb/storage/unusual_uas.h                  |   4 +-
 drivers/video/fbdev/Kconfig                        |   3 +-
 fs/cifs/dir.c                                      |  19 +-
 fs/cifs/smb2pdu.c                                  |   4 +-
 fs/cifs/smb2pdu.h                                  |   4 +-
 fs/eventpoll.c                                     |  36 +-
 fs/ext4/file.c                                     |   3 +
 fs/ext4/resize.c                                   |   3 +-
 fs/fuse/file.c                                     |   2 +-
 fs/gfs2/dir.c                                      |  11 +-
 fs/nfs/client.c                                    |   1 +
 fs/nfsd/nfs4xdr.c                                  |   6 +-
 fs/nilfs2/btree.c                                  |   2 +-
 fs/nilfs2/recovery.c                               |   4 +-
 fs/nilfs2/super.c                                  |   5 +-
 fs/ocfs2/acl.c                                     |  27 +-
 fs/xfs/xfs_ialloc.c                                |   2 +-
 include/asm-generic/topology.h                     |   6 +-
 include/linux/cpumask.h                            |   6 +-
 include/linux/device-mapper.h                      |  70 ++--
 include/linux/fs.h                                 |   4 +-
 include/linux/ftrace_event.h                       |   2 +-
 include/linux/gpio/driver.h                        |   2 +-
 include/linux/mlx4/device.h                        |   1 +
 include/linux/mm_types.h                           |  31 +-
 include/linux/module.h                             |   2 +-
 include/linux/mtd/map.h                            |  12 +-
 include/linux/perf_event.h                         |  28 +-
 include/linux/workqueue.h                          |   4 +-
 include/net/dst.h                                  |  13 +-
 include/net/ip6_fib.h                              |  35 +-
 include/net/ip6_route.h                            |   2 +-
 include/net/ip_fib.h                               |  10 +-
 include/net/sch_generic.h                          |   5 +-
 include/net/sctp/sctp.h                            |   4 +
 include/rdma/ib_addr.h                             |   6 +-
 include/trace/ftrace.h                             |   7 +-
 include/uapi/linux/usb/ch9.h                       |   1 +
 kernel/audit_watch.c                               |  12 +-
 kernel/events/core.c                               | 135 +++---
 kernel/fork.c                                      |   2 +-
 kernel/sched/core.c                                |   2 +-
 kernel/trace/trace.c                               |   1 +
 kernel/trace/trace_event_perf.c                    |   4 +-
 kernel/trace/trace_events_filter.c                 |   4 +
 kernel/trace/trace_kprobe.c                        |   4 +-
 kernel/trace/trace_syscalls.c                      |   4 +-
 kernel/trace/trace_uprobe.c                        |   2 +-
 kernel/workqueue.c                                 |  23 +-
 lib/assoc_array.c                                  |  51 +--
 lib/cpumask.c                                      |  74 ++--
 mm/hugetlb.c                                       |  12 +-
 mm/mempolicy.c                                     |   5 -
 mm/mprotect.c                                      |   4 +-
 mm/page_alloc.c                                    |  37 +-
 net/batman-adv/translation-table.c                 |  57 ++-
 net/batman-adv/types.h                             |   2 +
 net/bridge/br_device.c                             |   3 +-
 net/bridge/br_input.c                              |   3 +-
 net/bridge/br_netfilter.c                          |   2 +-
 net/caif/cfpkt_skbuff.c                            |   2 +-
 net/ceph/messenger.c                               |   6 +-
 net/core/dev.c                                     |  23 +-
 net/core/dst.c                                     |  45 +-
 net/core/pktgen.c                                  |   2 +-
 net/ipv4/fib_frontend.c                            |   9 +-
 net/ipv4/fib_semantics.c                           |  27 +-
 net/ipv4/netfilter/ipt_CLUSTERIP.c                 |   4 +-
 net/ipv4/netfilter/nft_reject_ipv4.c               |   2 +
 net/ipv4/route.c                                   |  10 +-
 net/ipv4/udp_offload.c                             |   2 +-
 net/ipv6/addrconf.c                                |   2 +-
 net/ipv6/ip6_fib.c                                 |  37 +-
 net/ipv6/ip6_tunnel.c                              |   2 +-
 net/ipv6/netfilter/nft_reject_ipv6.c               |   2 +
 net/ipv6/output_core.c                             |   6 +-
 net/ipv6/route.c                                   |  26 +-
 net/ipv6/tcp_ipv6.c                                |   3 +-
 net/ipv6/udp_offload.c                             |   2 +-
 net/ipv6/xfrm6_policy.c                            |   6 +-
 net/key/af_key.c                                   |  48 ++-
 net/l2tp/l2tp_core.c                               |  79 ++--
 net/l2tp/l2tp_core.h                               |  18 +-
 net/l2tp/l2tp_netlink.c                            |  72 ++--
 net/mac80211/key.c                                 |  20 +-
 net/netfilter/ipvs/ip_vs_xmit.c                    |   2 +-
 net/netfilter/nft_compat.c                         |   6 +-
 net/netfilter/nft_ct.c                             |   8 +
 net/netfilter/nft_reject.c                         |   2 +
 net/packet/af_packet.c                             |  30 +-
 net/sched/sch_api.c                                |   2 +
 net/sched/sch_cbq.c                                |  10 +-
 net/sched/sch_fq_codel.c                           |   4 +-
 net/sched/sch_hfsc.c                               |   4 +-
 net/sched/sch_hhf.c                                |  11 +-
 net/sched/sch_htb.c                                |   5 +-
 net/sched/sch_mq.c                                 |  10 +-
 net/sched/sch_mqprio.c                             |  19 +-
 net/sched/sch_multiq.c                             |   9 +-
 net/sched/sch_netem.c                              |   4 +-
 net/sched/sch_sfq.c                                |   8 +-
 net/sched/sch_tbf.c                                |   5 +-
 net/sctp/ipv6.c                                    |   2 +-
 net/xfrm/xfrm_user.c                               |   2 +
 scripts/mod/modpost.c                              |  34 +-
 security/keys/key.c                                |  10 +
 security/keys/keyctl.c                             |   5 +
 sound/core/control.c                               |   2 +-
 sound/core/seq/seq_clientmgr.c                     |   6 +-
 sound/core/seq/seq_lock.c                          |   4 -
 sound/core/seq/seq_lock.h                          |  12 -
 sound/core/seq/seq_ports.c                         |   7 +-
 sound/pci/hda/patch_conexant.c                     |   1 +
 sound/pci/hda/patch_realtek.c                      |   1 +
 sound/soc/codecs/adau1977.c                        |   2 +-
 sound/soc/fsl/fsl_sai.c                            |   3 +-
 sound/soc/fsl/fsl_ssi.c                            |   4 +-
 sound/soc/fsl/imx-audmux.c                         |   8 +-
 sound/soc/soc-pcm.c                                |   4 +
 sound/usb/card.c                                   |  20 +
 sound/usb/mixer.c                                  |  14 +-
 sound/usb/mixer.h                                  |   3 +
 sound/usb/mixer_quirks.c                           |   6 +
 tools/perf/ui/browser.c                            |   2 +-
 309 files changed, 1999 insertions(+), 1318 deletions(-)

A Raghavendra Rao (1):
      Staging: wlan-ng: fix sparse warning in prism2fw.c

Aaron Ma (1):
      Input: trackpoint - add new trackpoint firmware ID

Akinobu Mita (1):
      iio: light: tsl2563: use correct event code

Alan Stern (4):
      USB: Check for dropped connection before switching to full speed
      USB: uas: fix bug in handling of alternate settings
      usb: usbtest: fix NULL pointer dereference
      USB: core: fix out-of-bounds access bug in usb_get_bos_descriptor()

Alan Swanson (1):
      uas: Add US_FL_IGNORE_RESIDUE for Initio Corporation INIC-3069

Alban Bedel (1):
      MIPS: Fix the build on jz4740 after removing the custom gpio.h

Alex Vesker (1):
      IB/ipoib: Prevent setting negative values to max_nonsrq_conn_qp

Alexander Potapenko (1):
      sctp: don&#39;t dereference ptr before leaving _sctp_walk_{params, errors}()

Andrew Morton (1):
      MODULE_DEVICE_TABLE: fix some callsites

Andrey Ryabinin (1):
      module: fix types of device tables aliases

Andy Lutomirski (1):
      x86/asm/64: Clear AC on NMI entries

Andy Shevchenko (1):
      platform/x86: samsung-laptop: Initialize loca variable

Aneesh Kumar K.V (1):
      powerpc/mm/hash: Free the subpage_prot_table correctly

Anil Gurumurthy (1):
      bfa: Fix indentation

Ard Biesheuvel (2):
      ARM: 8221/1: PJ4: allow building in Thumb-2 mode
      ARM: 8452/3: PJ4: make coprocessor access sequences buildable in Thumb2 mode

Arend Van Spriel (1):
      brcmfmac: add length check in brcmf_cfg80211_escan_handler()

Arnd Bergmann (35):
      staging:iio:resolver:ad2s1210 fix negative IIO_ANGL_VEL read
      ARM: pxa: select both FB and FB_W100 for eseries
      qlge: avoid memcpy buffer overflow
      gfs2: remove IS_ERR_VALUE abuse
      iio: adc: fix building on 64-bit
      infiniband: mlx5: avoid a compile-time warning
      ata: hpt366: fix constant cast warning
      tty: nozomi: avoid a harmless gcc warning
      tty/isicom: fix big-endian compile warning
      i2o: hide unsafe ioctl on 64-bit
      dm bufio: hide bogus warning
      scsi-tgt: fix type conversion warning
      scsi: advansys: remove #warning message
      mtd: pmcmsp: use kstrndup instead of kmalloc+strncpy
      mlx5: avoid build warnings on 32-bit
      mISDN: avoid arch specific __builtin_return_address call
      cpmac: remove hopeless #warning
      net: caif: fix misleading indentation
      net: am2150: fix nmclan_cs.c shared interrupt handling
      net: tulip: turn compile-time warning into dev_warn()
      net: vxge: avoid unused function warnings
      hostap: avoid uninitialized variable use in hfa384x_get_rid
      iwlegacy: avoid warning about missing braces
      brcmfmac: avoid gcc-5.1 warning
      video: mx3fb: always enable BACKLIGHT_LCD_SUPPORT
      staging: bcm: add 32-bit host dependency
      staging: imx-drm: fix indentation warning
      staging: vt6655: fix overly large stack usage
      ARM: cns3xxx: shut up frame size warning
      ARM: 8296/1: cache-l2x0: clean up aurora cache handling
      MIPS: ip22: Fix ip28 build for modern gcc
      staging: r8192ee: prorperly format warning message
      mtd: cfi: reduce stack size
      MIPS: jz4740: fix build error in irq.h
      net/xen-netback: disable on 64KB page granularity

Atsushi Nemoto (2):
      mtd: maps: rbtx4939-flash: delete an unused variable in rbtx4939_flash_remove
      MIPS: TXx9: Delete an unused variable in tx4927_pcibios_setup

Banajit Goswami (1):
      ASoC: do not close shared backend dailink

Bart Van Assche (2):
      IB/cma: Fix a race condition in iboe_addr_get_sgid()
      dm: fix printk() rate limiting code

Ben Hutchings (4):
      dst: Increase alignment of metrics to allow extra flag on pointers
      alpha: uapi: Add support for __SANE_USERSPACE_TYPES__
      ALSA: seq: Enable &#39;use&#39; locking in all configurations
      Linux 3.16.50

Bjorn Andersson (1):
      spmi: Include OF based modalias in device uevent

Bodo Stroesser (1):
      scsi: st: fix blk_get_queue usage

Charles Milette (1):
      staging: rtl8188eu: add RNX-N150NUB support

Chen Yu (1):
      PM/hibernate: touch NMI watchdog when creating snapshot

Chris Gorman (1):
      i2c: mux: pinctrl: mention correct module name in Kconfig help text

Chris Wilson (1):
      drm: Release driver tracking before making the object available again

Chuck Lever (1):
      nfsd: Limit end of page list when decoding NFSv4 WRITE

Chunyu Hu (1):
      tracing: Fix kmemleak in instance_rmdir

Colin Ian King (3):
      usb: storage: return on error to avoid a null pointer dereference
      netxen: fix incorrect loop counter decrement
      Staging: iio: adc: fix indent on break statement

Cong Wang (1):
      wl1251: add a missing spin_lock_init()

Dan Carpenter (11):
      libceph: potential NULL dereference in ceph_msg_data_create()
      libata: array underflow in ata_find_dev()
      cxgb4: Fix error codes in c4iw_create_cq()
      IB/cxgb3: Fix error codes in iwch_alloc_mr()
      RDMA/ocrdma: Fix an error code in ocrdma_alloc_pd()
      RDMA/ocrdma: Fix error codes in ocrdma_create_srq()
      drm/msm: fix an integer overflow test
      x86/ldt: Fix off by one in get_segment_base()
      paride: fix the &quot;verbose&quot; module param
      drm/i915: cleanup some indenting
      Staging: lustre: missing curly braces in ll_setattr_raw()

Dave Martin (1):
      arm64: fpsimd: Prevent registers leaking across exec

David Howells (2):
      assoc_array: Fix a buggy node-splitting case
      KEYS: don&#39;t let add_key() update an uninstantiated key

David Malcolm (1):
      drivers/net/ethernet/dec/tulip/uli526x.c: fix misleading indentation in uli526x_timer

David Miller (1):
      netfilter: Fix switch statement warnings with recent gcc.

David S. Miller (1):
      netfilter; Add some missing default cases to switch statements in nft_reject.

Doug Berger (2):
      net: bcmgenet: Fix unmapping of fragments in bcmgenet_xmit()
      net: bcmgenet: Free skb after last Tx frag

Dragos Bogdan (1):
      iio: imu: adis16480: Fix acceleration scale factor for adis16480

Emmanuel Grumbach (1):
      iwlwifi: dvm: prevent an out of bounds access

Eric Biggers (1):
      KEYS: prevent KEYCTL_READ on negative key

Eric Dumazet (6):
      net: reduce skb_warn_bad_offload() noise
      net: skb_needs_check() accepts CHECKSUM_NONE for tx
      af_key: do not use GFP_KERNEL in atomic contexts
      ipv4: add reference counting to metrics
      ipv4: fix NULL dereference in free_fib_info_rcu()
      net_sched: fix error recovery at qdisc creation

Feras Daoud (1):
      IB/ipoib: Set IPOIB_NEIGH_TBL_FLUSH after flushed completion initialization

Florian Fainelli (12):
      net: bcmgenet: check harder for out of memory conditions
      net: bcmgenet: fix off-by-one in incrementing read pointer
      net: bcmgenet: update ring producer index and buffer count in xmit
      b44: Initialize 64-bit stats seqcount
      i40e: Initialize 64-bit statistics TX ring seqcount
      ixgbe: Initialize 64-bit stats seqcounts
      irqchip: brcmstb-l2: Define an irq_pm_shutdown function
      net: systemport: Be drop monitor friendly
      net: bcmgenet: Be drop monitor friendly
      net: systemport: Free DMA coherent descriptors on errors
      r8169: Do not increment tx_dropped in TX ring cleaning
      r8169: Be drop monitor friendly

Geert Uytterhoeven (2):
      Input: gscps2 - fix MODULE_DEVICE_TABLE invocation
      spi: rspi: Remove unused variable in rspi_rz_transfer_one()

Gerald Schaefer (1):
      mm/hugetlb: improve locking in dissolve_free_huge_pages()

Greg Kroah-Hartman (1):
      USB: fix out-of-bounds in usb_set_configuration

Guillaume Nault (8):
      l2tp: initialise session&#39;s refcount before making it reachable
      l2tp: define parameters of l2tp_session_get*() as &quot;const&quot;
      l2tp: hold tunnel while looking up sessions in l2tp_netlink
      l2tp: hold tunnel while processing genl delete command
      l2tp: hold tunnel while handling genl tunnel updates
      l2tp: hold tunnel while handling genl TUNNEL_GET commands
      l2tp: remove useless duplicate session detection in l2tp_netlink
      l2tp: hold tunnel used while creating sessions with netlink

Hannes Reinecke (1):
      aic94xx: Skip reading user settings if flash is not found

Hector Martin (1):
      USB: serial: option: add D-Link DWM-222 device ID

Icenowy Zheng (1):
      pinctrl: sunxi: add a missing function of A10/A20 pinctrl driver

Inbar Karmy (1):
      net/mlx4_en: Fix wrong indication of Wake-on-LAN (WoL) support

Ingo Molnar (1):
      x86/boot: Add CONFIG_PARAVIRT_SPINLOCKS quirk to arch/x86/boot/compressed/misc.h

Ismail, Mustafa (2):
      RDMA/uverbs: Fix the check for port number
      RDMA/core: Initialize port_num in qp_attr

Iván Briano (1):
      net/packet: Fix Tx queue selection for AF_PACKET

Jaejoong Kim (1):
      HID: usbhid: fix out-of-bounds bug

James Bottomley (1):
      ips: remove pointless #warning

Jan Kara (3):
      ocfs2: don&#39;t clear SGID when inheriting ACLs
      ext4: fix SEEK_HOLE/SEEK_DATA for blocksize &lt; pagesize
      audit: Fix use after free in audit_remove_watch_rule()

Jeff Kirsher (2):
      am2150: Update nmclan_cs.c to use update PCMCIA API
      e1000e: fix call to do_div() to use u64 arg

Jerry Lee (1):
      ext4: fix overflow caused by missing cast in ext4_resize_fs()

Jiahau Chang (1):
      xhci: Bad Ethernet performance plugged in ASM1042A host

Jin Yao (1):
      perf annotate: Fix broken arrow at row 0 connecting jmp instruction to its target

Jiri Olsa (1):
      perf/core: Fix locking for children siblings group read

Joe Perches (2):
      dm: convert DM printk macros to pr_&lt;level&gt; macros
      i40e: Reduce stack in i40e_dbg_dump_desc

Joerg Roedel (1):
      iommu/amd: Fix schedule-while-atomic BUG in initialization code

Johan Hovold (1):
      USB: cdc-acm: add device-id for quirky printer

Johannes Berg (1):
      mac80211: accept key reinstall without changing anything

Juergen Gross (1):
      x86/xen: fix upper bound of pmd loop in xen_cleanhighmap()

Julian Wiedmann (1):
      s390/qeth: fix L3 next-hop in xmit qeth hdr

Kai-Heng Feng (1):
      usb: quirks: Add no-lpm quirk for Moshi USB to Ethernet Adapter

Kalderon, Michal (1):
      IB/cma: Fix reference count leak when no ipv4 addresses are set

Kasin Li (1):
      drm/msm: Fix potential buffer overflow issue

Kevin Cernekee (1):
      MIPS: BMIPS: Fix &quot;.previous without corresponding .section&quot; warnings

Konrad Zapalowicz (1):
      staging: dgnc: Fix frame size is larger than 1024B

Konstantin Khlebnikov (2):
      net_sched/sfq: update hierarchical backlog when drop packet
      net_sched: fix order of queue length updates in qdisc_replace()

Lars Ellenberg (1):
      drbd: avoid redefinition of BITS_PER_PAGE

Laurent Vivier (1):
      powerpc/pseries: Fix of_node_put() underflow during reconfig remove

Lee Jones (1):
      mfd: arizona: Rid data size incompatibility warn when building for 64bit

Leon Romanovsky (2):
      IB/ipoib: Remove double pointer assigning
      RDMA/uverbs: Prevent leak of reserved field

Linus Lüssing (1):
      batman-adv: fix TT sync flag inconsistencies

Linus Torvalds (2):
      Clarify (and fix) MAX_LFS_FILESIZE macros
      Disable &quot;frame-address&quot; warning

Linus Walleij (1):
      gpio: drop retval check enforcing from gpiochip_remove()

Luis de Bethencourt (2):
      mvsas: fix misleading indentation
      staging: rtl8723au: core: rtw_wlan_util: fix misleading indentation

Maciej W. Rozycki (1):
      MIPS: DEC: Fix an int-handler.S CPU_DADDI_WORKAROUNDS regression

Mahesh Bandewar (1):
      ipv4: initialize fib_trie prior to register_netdev_notifier call.

Manuel Schölling (1):
      xilinx: Fix compiler warning

Mark Brown (7):
      power/reset: xgene-reset: Fix prototype of xgene_restart()
      Input: joystick - use get_cycles on ARMv8
      dma: pl08x: Use correct specifier for size_t values
      ASoC: imx-audmux: Use uintptr_t for port numbers
      ASoC: adau1977: Fix truncation warning on 64 bit architectures
      spi/atmel: Fix pointer to int conversion warnings on 64 bit builds
      spi/pl022: Explicitly truncate large bitmask

Mark Rutland (2):
      arm64: mm: abort uaccess retries upon fatal signal
      perf/core: Fix group {cpu,task} validation

Martin KaFai Lau (1):
      ipv6: Add rt6_get_cookie() function

Masami Hiramatsu (1):
      kprobes/x86: Release insn_slot in failure path

Mateusz Jurczyk (1):
      fuse: initialize the flock flag in fuse_file on allocation

Mathias Krause (2):
      xfrm_user: fix info leak in xfrm_notify_sa()
      xfrm_user: fix info leak in build_aevent()

Mathias Nyman (2):
      xhci: Fix NULL pointer dereference when cleaning up streams for removed host
      xhci: fix 20000ms port resume timeout

Max Filippov (3):
      xtensa: fix cache aliasing handling code for WT cache
      xtensa: don&#39;t limit csum_partial export by CONFIG_NET
      xtensa: mm/cache: add missing EXPORT_SYMBOLs

Michael Ellerman (1):
      powerpc/boot: Fix 64-bit boot wrapper build with non-biarch compiler

Michael Gugino (1):
      staging: rtl8188eu: add TL-WN722N v2 support

Michał Mirosław (1):
      gpio: tegra: fix unbalanced chained_irq_enter/exit

Moshe Shemesh (1):
      net/mlx5: Fix command bad flow on command entry allocation failure

Nadav Amit (1):
      mm: migrate: prevent racy access to tlb_flush_pending

Naftali Goldstein (1):
      iwlwifi: mvm: set the RTS_MIMO_PROT bit in flag mask when sending sta to fw

Nicholas Bellinger (1):
      iscsi-target: Fix iscsi_np reset hung task during parallel delete

Nicolin Chen (1):
      ASoC: fsl_sai: Set SYNC bit of TCR2 to Asynchronous Mode

Nikolay Aleksandrov (9):
      net: bridge: fix dest lookup when vlan proto doesn&#39;t match
      sch_htb: fix crash on init failure
      sch_multiq: fix double free on init failure
      sch_hhf: fix null pointer dereference on init failure
      sch_hfsc: fix null pointer deref and double free on init failure
      sch_cbq: fix null pointer dereferences on init failure
      sch_fq_codel: avoid double free on init failure
      sch_netem: avoid null pointer deref on init failure
      sch_tbf: fix two null pointer dereferences on init failure

Nikolay Borisov (1):
      ARM: kexec: Make .text R/W in machine_kexec

Ofer Heifetz (1):
      md/raid5: add thread_group worker async_tx_issue_pending_all

Oleg Nesterov (1):
      epoll: fix race between ep_poll_callback(POLLFREE) and ep_free()/ep_remove()

Oliver O&#39;Halloran (1):
      mm/init: fix zone boundary creation

Omar Sandoval (1):
      xfs: fix inobt inode allocation search optimization

Paul Burton (1):
      net: ti: cpmac: Fix compiler warning due to type confusion

Paul Gortmaker (2):
      modpost: expand pattern matching to support substring matches
      modpost: don&#39;t emit section mismatch warnings for compiler optimizations

Paul Mackerras (1):
      KVM: PPC: Book3S HV: Enable TM before accessing TM registers

Pavel Shilovsky (1):
      CIFS: Fix maximum SMB2 header size

Peter Zijlstra (1):
      perf/core: Invert perf_read_group() loops

Peter Zijlstra (Intel) (1):
      perf: Avoid horrible stack usage

Petri Gynther (4):
      net: bcmgenet: simplify __bcmgenet_tx_reclaim()
      net: bcmgenet: rewrite bcmgenet_rx_refill()
      net: bcmgenet: fix dev-&gt;stats.tx_bytes accounting
      net: bcmgenet: cleanup for bcmgenet_xmit_frag()

Pontus Andersson (1):
      i2c: ismt: Separate I2C block read from SMBus block read

Prabhakar Lad (1):
      media: platform: davinci: return -EINVAL for VPFE_CMD_S_CCDC_RAW_PARAMS ioctl

Rafael J. Wysocki (1):
      USB: hcd: Mark secondary HCD as dead if the primary one died

Ralf Baechle (3):
      MIPS: DEC: Avoid la pseudo-instruction in delay slots
      MIPS: elf2ecoff: Fix warning due to dead code.
      MIPS: elf2ecoff: Ignore PT_MIPS_ABIFLAGS program headers.

Ronnie Sahlberg (2):
      cifs: return ENAMETOOLONG for overlong names in cifs_open()/cifs_lookup()
      cifs: check MaxPathNameComponentLength != 0 before using it

Russell King (1):
      ARM: kexec: fix failure to boot crash kernel

Rusty Russell (1):
      cpumask_set_cpu_local_first =&gt; cpumask_local_spread, lament

Ryusuke Konishi (1):
      nilfs2: fix gcc uninitialized-variable warnings in powerpc build

Sabrina Dubroca (1):
      netfilter: ipt_CLUSTERIP: fix use-after-free of proc entry

Sachin Prabhu (1):
      cifs: Fix df output for users with quota limits

Sandeep Singh (1):
      usb:xhci:Add quirk for Certain failing HP keyboard on reset after resume

Sean Young (1):
      media: lirc: LIRC_GET_REC_RESOLUTION should return microseconds

Sergei A. Trusov (1):
      ALSA: hda - Fix speaker output from VAIO VPCL14M1R

Sergey Ryazanov (1):
      MIPS: MSP71xx: remove odd locking in PCI config space access code

Seunghun Han (1):
      x86/acpi: Prevent out of bound access caused by broken ACPI tables

Shu Wang (1):
      xhci: fix memleak in xhci_run()

Sinclair Yeh (1):
      drm/vmwgfx: Fix gcc-7.1.1 warning

Stefan Triller (1):
      USB: serial: cp210x: add support for Qivicon USB ZigBee dongle

Stefan-Gabriel Mirea (1):
      iio: adc: vf610_adc: Fix VALT selection value for REFSEL bits

Stefano Brivio (1):
      ipv6: accept 64k - 1 packet length in ip6_find_1stfragopt()

Steffen Klassert (1):
      ipv6: Fix may be used uninitialized warning in rt6_check

Stephen Boyd (1):
      of: device: Export of_device_{get_modalias, uvent_modalias} to modules

Stephen Douthit (2):
      i2c: ismt: Don&#39;t duplicate the receive length for block reads
      i2c: ismt: Return EMSGSIZE for block reads with bogus length

Steve Dickson (1):
      mount: copy the port field into the cloned nfs_server structure.

Steve French (1):
      CIFS: remove endian related sparse warning

Steven Rostedt (VMware) (1):
      tracing: Fix freeing of filter in create_filter() when set_str is false

Takashi Iwai (6):
      ALSA: usb-audio: Add mute TLV for playback volumes on C-Media devices
      ALSA: core: Fix unexpected error at replacing user TLV
      ALSA: hda - Add stereo mic quirk for Lenovo G50-70 (17aa:3978)
      ALSA: seq: Fix use-after-free at creating a port
      ALSA: usb-audio: Kill stray URB at exiting
      ALSA: usb-audio: Check out-of-bounds access by corrupted buffer descriptor

Tejun Heo (3):
      workqueue: restore WQ_UNBOUND/max_active==1 to be ordered
      workqueue: implicit ordered attribute should be overridable
      cpumask: fix spurious cpumask_of_node() on non-NUMA multi-node configs

Thomas Bogendoerfer (1):
      parisc: pci memory bar assignment fails with 64bit kernels on dino/cujo

Tim Gardner (1):
      be2iscsi: Fix bogus WARN_ON length check

Timur Tabi (1):
      ASoC: fsl-ssi: fix do_div build warning in fsl_ssi_set_bclk()

Tony Lindgren (1):
      ARM: OMAP: Fix Kconfig warning for omap1

Uwe Kleine-König (3):
      mtd: nandsim: remove debugfs entries in error path
      clk/efm32gg: fix dt init prototype
      ARM: 8160/1: drop warning about return_address not using unwind tables

Varka Bhadram (1):
      ethernet: amd: fix pci device ids

Vitaly Mayatskikh (1):
      fix unbalanced page refcounting in bio_map_user_iov

Wanpeng Li (1):
      KVM: async_pf: make rcu irq exit if not triggered from idle task

Wei Wang (3):
      ipv6: reset fn-&gt;rr_ptr when replacing route
      ipv6: add rcu grace period before freeing fib6_node
      ipv6: fix sparse warning on rt6i_node

Willem de Bruijn (3):
      net: avoid skb_warn_bad_offload false positives on UFO
      packet: hold bind lock when rebinding to fanout hook
      packet: in packet_do_bind, test fanout with bind_lock held

Xiao Ni (1):
      Raid5 should update rdev-&gt;sectors after reshape

Xin Long (2):
      sctp: fix the check for _sctp_walk_params and _sctp_walk_errors
      ipv6: set rt6i_protocol properly in the route when it is installed

Yishai Hadas (1):
      IB/uverbs: Fix device cleanup

Yoshihiro Shimoda (4):
      usb: renesas_usbhs: gadget: fix re-enabling pipe without re-connecting
      usb: renesas_usbhs: gadget: Fix NULL pointer dereference in usbhsg_ep_dequeue()
      usb: renesas_usbhs: fix usbhsc_resume() for !USBHSF_RUNTIME_PWCTRL
      usb: renesas_usbhs: gadget: disable all eps when the driver stops

Zubair Lutfullah Kakakhel (1):
      MIPS: Fix a warning for virt_to_page

françois romieu (1):
      net: remove open-coded skb_cow_head.

megha.dey@linux.intel.com (1):
      crypto: x86/sha1 - Fix reads beyond the number of blocks passed

stephen hemminger (1):
      netvsc: fix deadlock betwen link status and removal

zhong jiang (1):
      mm/mempolicy: fix use after free when calling get_mempolicy
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/video4linux/v4l2-pci-skeleton.c b/Documentation/video4linux/v4l2-pci-skeleton.c</span>
<span class="p_header">index 46904fe49609..8c3d3d625c6c 100644</span>
<span class="p_header">--- a/Documentation/video4linux/v4l2-pci-skeleton.c</span>
<span class="p_header">+++ b/Documentation/video4linux/v4l2-pci-skeleton.c</span>
<span class="p_chunk">@@ -42,7 +42,6 @@</span> <span class="p_context"></span>
 MODULE_DESCRIPTION(&quot;V4L2 PCI Skeleton Driver&quot;);
 MODULE_AUTHOR(&quot;Hans Verkuil&quot;);
 MODULE_LICENSE(&quot;GPL v2&quot;);
<span class="p_del">-MODULE_DEVICE_TABLE(pci, skeleton_pci_tbl);</span>
 
 /**
  * struct skeleton - All internal data for one instance of device
<span class="p_chunk">@@ -95,6 +94,7 @@</span> <span class="p_context"> static const struct pci_device_id skeleton_pci_tbl[] = {</span>
 	/* { PCI_DEVICE(PCI_VENDOR_ID_, PCI_DEVICE_ID_) }, */
 	{ 0, }
 };
<span class="p_add">+MODULE_DEVICE_TABLE(pci, skeleton_pci_tbl);</span>
 
 /*
  * HDTV: this structure has the capabilities of the HDTV receiver.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f15a93eded21..11af06e140e2 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 49</span>
<span class="p_add">+SUBLEVEL = 50</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_chunk">@@ -616,6 +616,7 @@</span> <span class="p_context"> all: vmlinux</span>
 include $(srctree)/arch/$(SRCARCH)/Makefile
 
 KBUILD_CFLAGS	+= $(call cc-option,-fno-delete-null-pointer-checks,)
<span class="p_add">+KBUILD_CFLAGS	+= $(call cc-disable-warning,frame-address,)</span>
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
 KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)
<span class="p_header">diff --git a/arch/alpha/include/asm/types.h b/arch/alpha/include/asm/types.h</span>
<span class="p_header">index f61e1a56c378..0bc66e1d3a7e 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/types.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/types.h</span>
<span class="p_chunk">@@ -1,7 +1,6 @@</span> <span class="p_context"></span>
 #ifndef _ALPHA_TYPES_H
 #define _ALPHA_TYPES_H
 
<span class="p_del">-#include &lt;asm-generic/int-ll64.h&gt;</span>
 #include &lt;uapi/asm/types.h&gt;
 
 #endif /* _ALPHA_TYPES_H */
<span class="p_header">diff --git a/arch/alpha/include/uapi/asm/types.h b/arch/alpha/include/uapi/asm/types.h</span>
<span class="p_header">index 9fd3cd459777..8d1024d7be05 100644</span>
<span class="p_header">--- a/arch/alpha/include/uapi/asm/types.h</span>
<span class="p_header">+++ b/arch/alpha/include/uapi/asm/types.h</span>
<span class="p_chunk">@@ -9,8 +9,18 @@</span> <span class="p_context"></span>
  * need to be careful to avoid a name clashes.
  */
 
<span class="p_del">-#ifndef __KERNEL__</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is here because we used to use l64 for alpha</span>
<span class="p_add">+ * and we don&#39;t want to impact user mode with our change to ll64</span>
<span class="p_add">+ * in the kernel.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * However, some user programs are fine with this.  They can</span>
<span class="p_add">+ * flag __SANE_USERSPACE_TYPES__ to get int-ll64.h here.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#if !defined(__SANE_USERSPACE_TYPES__) &amp;&amp; !defined(__KERNEL__)</span>
 #include &lt;asm-generic/int-l64.h&gt;
<span class="p_add">+#else</span>
<span class="p_add">+#include &lt;asm-generic/int-ll64.h&gt;</span>
 #endif
 
 #endif /* _UAPI_ALPHA_TYPES_H */
<span class="p_header">diff --git a/arch/arm/include/asm/kexec.h b/arch/arm/include/asm/kexec.h</span>
<span class="p_header">index c2b9b4bdec00..a664941a5593 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kexec.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kexec.h</span>
<span class="p_chunk">@@ -19,6 +19,11 @@</span> <span class="p_context"></span>
 
 #ifndef __ASSEMBLY__
 
<span class="p_add">+#define ARCH_HAS_KIMAGE_ARCH</span>
<span class="p_add">+struct kimage_arch {</span>
<span class="p_add">+	u32 kernel_r2;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /**
  * crash_setup_regs() - save registers for the panic kernel
  * @newregs: registers are saved here
<span class="p_header">diff --git a/arch/arm/kernel/iwmmxt.S b/arch/arm/kernel/iwmmxt.S</span>
<span class="p_header">index 2b32978ae905..d65bb940d797 100644</span>
<span class="p_header">--- a/arch/arm/kernel/iwmmxt.S</span>
<span class="p_header">+++ b/arch/arm/kernel/iwmmxt.S</span>
<span class="p_chunk">@@ -58,6 +58,7 @@</span> <span class="p_context"></span>
 #define MMX_SIZE		(0x98)
 
 	.text
<span class="p_add">+	.arm</span>
 
 /*
  * Lazy switching of Concan coprocessor context
<span class="p_chunk">@@ -182,6 +183,8 @@</span> <span class="p_context"> ENTRY(iwmmxt_task_enable)</span>
 	tmcr	wCon, r2
 	mov	pc, lr
 
<span class="p_add">+ENDPROC(iwmmxt_task_enable)</span>
<span class="p_add">+</span>
 /*
  * Back up Concan regs to save area and disable access to them
  * (mainly for gdb or sleep mode usage)
<span class="p_chunk">@@ -232,6 +235,8 @@</span> <span class="p_context"> ENTRY(iwmmxt_task_disable)</span>
 1:	msr	cpsr_c, ip			@ restore interrupt mode
 	ldmfd	sp!, {r4, pc}
 
<span class="p_add">+ENDPROC(iwmmxt_task_disable)</span>
<span class="p_add">+</span>
 /*
  * Copy Concan state to given memory address
  *
<span class="p_chunk">@@ -268,6 +273,8 @@</span> <span class="p_context"> ENTRY(iwmmxt_task_copy)</span>
 	msr	cpsr_c, ip			@ restore interrupt mode
 	mov	pc, r3
 
<span class="p_add">+ENDPROC(iwmmxt_task_copy)</span>
<span class="p_add">+</span>
 /*
  * Restore Concan state from given memory address
  *
<span class="p_chunk">@@ -304,6 +311,8 @@</span> <span class="p_context"> ENTRY(iwmmxt_task_restore)</span>
 	msr	cpsr_c, ip			@ restore interrupt mode
 	mov	pc, r3
 
<span class="p_add">+ENDPROC(iwmmxt_task_restore)</span>
<span class="p_add">+</span>
 /*
  * Concan handling on task switch
  *
<span class="p_chunk">@@ -335,6 +344,8 @@</span> <span class="p_context"> ENTRY(iwmmxt_task_switch)</span>
 	mrc	p15, 0, r1, c2, c0, 0
 	sub	pc, lr, r1, lsr #32		@ cpwait and return
 
<span class="p_add">+ENDPROC(iwmmxt_task_switch)</span>
<span class="p_add">+</span>
 /*
  * Remove Concan ownership of given task
  *
<span class="p_chunk">@@ -353,6 +364,8 @@</span> <span class="p_context"> ENTRY(iwmmxt_task_release)</span>
 	msr	cpsr_c, r2			@ restore interrupts
 	mov	pc, lr
 
<span class="p_add">+ENDPROC(iwmmxt_task_release)</span>
<span class="p_add">+</span>
 	.data
 concan_owner:
 	.word	0
<span class="p_header">diff --git a/arch/arm/kernel/machine_kexec.c b/arch/arm/kernel/machine_kexec.c</span>
<span class="p_header">index 8cf0996aa1a8..3c7cda46edeb 100644</span>
<span class="p_header">--- a/arch/arm/kernel/machine_kexec.c</span>
<span class="p_header">+++ b/arch/arm/kernel/machine_kexec.c</span>
<span class="p_chunk">@@ -40,6 +40,9 @@</span> <span class="p_context"> int machine_kexec_prepare(struct kimage *image)</span>
 	__be32 header;
 	int i, err;
 
<span class="p_add">+	image-&gt;arch.kernel_r2 = image-&gt;start - KEXEC_ARM_ZIMAGE_OFFSET</span>
<span class="p_add">+				     + KEXEC_ARM_ATAGS_OFFSET;</span>
<span class="p_add">+</span>
 	/*
 	 * Validate that if the current HW supports SMP, then the SW supports
 	 * and implements CPU hotplug for the current HW. If not, we won&#39;t be
<span class="p_chunk">@@ -63,8 +66,8 @@</span> <span class="p_context"> int machine_kexec_prepare(struct kimage *image)</span>
 		if (err)
 			return err;
 
<span class="p_del">-		if (be32_to_cpu(header) == OF_DT_HEADER)</span>
<span class="p_del">-			kexec_boot_atags = current_segment-&gt;mem;</span>
<span class="p_add">+		if (header == cpu_to_be32(OF_DT_HEADER))</span>
<span class="p_add">+			image-&gt;arch.kernel_r2 = current_segment-&gt;mem;</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -166,9 +169,7 @@</span> <span class="p_context"> void machine_kexec(struct kimage *image)</span>
 	kexec_start_address = image-&gt;start;
 	kexec_indirection_page = page_list;
 	kexec_mach_type = machine_arch_type;
<span class="p_del">-	if (!kexec_boot_atags)</span>
<span class="p_del">-		kexec_boot_atags = image-&gt;start - KEXEC_ARM_ZIMAGE_OFFSET + KEXEC_ARM_ATAGS_OFFSET;</span>
<span class="p_del">-</span>
<span class="p_add">+	kexec_boot_atags = image-&gt;arch.kernel_r2;</span>
 
 	/* copy our kernel relocation code to the control code page */
 	reboot_entry = fncpy(reboot_code_buffer,
<span class="p_header">diff --git a/arch/arm/kernel/pj4-cp0.c b/arch/arm/kernel/pj4-cp0.c</span>
<span class="p_header">index 8153e36b2491..7c9248b74d3f 100644</span>
<span class="p_header">--- a/arch/arm/kernel/pj4-cp0.c</span>
<span class="p_header">+++ b/arch/arm/kernel/pj4-cp0.c</span>
<span class="p_chunk">@@ -66,9 +66,13 @@</span> <span class="p_context"> static void __init pj4_cp_access_write(u32 value)</span>
 
 	__asm__ __volatile__ (
 		&quot;mcr	p15, 0, %1, c1, c0, 2\n\t&quot;
<span class="p_add">+#ifdef CONFIG_THUMB2_KERNEL</span>
<span class="p_add">+		&quot;isb\n\t&quot;</span>
<span class="p_add">+#else</span>
 		&quot;mrc	p15, 0, %0, c1, c0, 2\n\t&quot;
 		&quot;mov	%0, %0\n\t&quot;
 		&quot;sub	pc, pc, #4\n\t&quot;
<span class="p_add">+#endif</span>
 		: &quot;=r&quot; (temp) : &quot;r&quot; (value));
 }
 
<span class="p_header">diff --git a/arch/arm/kernel/return_address.c b/arch/arm/kernel/return_address.c</span>
<span class="p_header">index fafedd86885d..827d946d2be4 100644</span>
<span class="p_header">--- a/arch/arm/kernel/return_address.c</span>
<span class="p_header">+++ b/arch/arm/kernel/return_address.c</span>
<span class="p_chunk">@@ -59,10 +59,6 @@</span> <span class="p_context"> void *return_address(unsigned int level)</span>
 
 #else /* if defined(CONFIG_FRAME_POINTER) &amp;&amp; !defined(CONFIG_ARM_UNWIND) */
 
<span class="p_del">-#if defined(CONFIG_ARM_UNWIND)</span>
<span class="p_del">-#warning &quot;TODO: return_address should use unwind tables&quot;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 void *return_address(unsigned int level)
 {
 	return NULL;
<span class="p_header">diff --git a/arch/arm/mach-cns3xxx/Makefile b/arch/arm/mach-cns3xxx/Makefile</span>
<span class="p_header">index a1ff10848698..fd610561616e 100644</span>
<span class="p_header">--- a/arch/arm/mach-cns3xxx/Makefile</span>
<span class="p_header">+++ b/arch/arm/mach-cns3xxx/Makefile</span>
<span class="p_chunk">@@ -2,4 +2,5 @@</span> <span class="p_context"> obj-$(CONFIG_ARCH_CNS3XXX)		+= cns3xxx.o</span>
 cns3xxx-y				+= core.o pm.o
 cns3xxx-$(CONFIG_ATAGS)			+= devices.o
 cns3xxx-$(CONFIG_PCI)			+= pcie.o
<span class="p_add">+CFLAGS_pcie.o				+= -Wframe-larger-than=1536 # override default 1024, this is safe here</span>
 cns3xxx-$(CONFIG_MACH_CNS3420VB)	+= cns3420vb.o
<span class="p_header">diff --git a/arch/arm/mach-omap2/Kconfig b/arch/arm/mach-omap2/Kconfig</span>
<span class="p_header">index 1c1ed737f7ab..3ac9cb2b2eb2 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/Kconfig</span>
<span class="p_chunk">@@ -1,9 +1,6 @@</span> <span class="p_context"></span>
 menu &quot;TI OMAP/AM/DM/DRA Family&quot;
 	depends on ARCH_MULTI_V6 || ARCH_MULTI_V7
 
<span class="p_del">-config ARCH_OMAP</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
 config ARCH_OMAP2
 	bool &quot;TI OMAP2&quot;
 	depends on ARCH_MULTI_V6
<span class="p_header">diff --git a/arch/arm/mach-pxa/Kconfig b/arch/arm/mach-pxa/Kconfig</span>
<span class="p_header">index e6690a44917d..170bc3ff5da3 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/Kconfig</span>
<span class="p_chunk">@@ -546,6 +546,7 @@</span> <span class="p_context"> config MACH_ICONTROL</span>
 config ARCH_PXA_ESERIES
 	bool &quot;PXA based Toshiba e-series PDAs&quot;
 	select FB_W100
<span class="p_add">+	select FB</span>
 	select PXA25x
 
 config MACH_E330
<span class="p_header">diff --git a/arch/arm/mm/cache-l2x0.c b/arch/arm/mm/cache-l2x0.c</span>
<span class="p_header">index 7c3fb41a462e..011490e7204d 100644</span>
<span class="p_header">--- a/arch/arm/mm/cache-l2x0.c</span>
<span class="p_header">+++ b/arch/arm/mm/cache-l2x0.c</span>
<span class="p_chunk">@@ -135,73 +135,6 @@</span> <span class="p_context"> static void l2c_disable(void)</span>
 	dsb(st);
 }
 
<span class="p_del">-#ifdef CONFIG_CACHE_PL310</span>
<span class="p_del">-static inline void cache_wait(void __iomem *reg, unsigned long mask)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* cache operations by line are atomic on PL310 */</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define cache_wait	l2c_wait_mask</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void cache_sync(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void __iomem *base = l2x0_base;</span>
<span class="p_del">-</span>
<span class="p_del">-	writel_relaxed(0, base + sync_reg_offset);</span>
<span class="p_del">-	cache_wait(base + L2X0_CACHE_SYNC, 1);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)</span>
<span class="p_del">-static inline void debug_writel(unsigned long val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	l2c_set_debug(l2x0_base, val);</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-/* Optimised out for non-errata case */</span>
<span class="p_del">-static inline void debug_writel(unsigned long val)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static void l2x0_cache_sync(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	raw_spin_lock_irqsave(&amp;l2x0_lock, flags);</span>
<span class="p_del">-	cache_sync();</span>
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;l2x0_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __l2x0_flush_all(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	debug_writel(0x03);</span>
<span class="p_del">-	__l2c_op_way(l2x0_base + L2X0_CLEAN_INV_WAY);</span>
<span class="p_del">-	cache_sync();</span>
<span class="p_del">-	debug_writel(0x00);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void l2x0_flush_all(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* clean all ways */</span>
<span class="p_del">-	raw_spin_lock_irqsave(&amp;l2x0_lock, flags);</span>
<span class="p_del">-	__l2x0_flush_all();</span>
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;l2x0_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void l2x0_disable(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	raw_spin_lock_irqsave(&amp;l2x0_lock, flags);</span>
<span class="p_del">-	__l2x0_flush_all();</span>
<span class="p_del">-	l2c_write_sec(0, l2x0_base, L2X0_CTRL);</span>
<span class="p_del">-	dsb(st);</span>
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;l2x0_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void l2c_save(void __iomem *base)
 {
 	l2x0_saved_regs.aux_ctrl = readl_relaxed(l2x0_base + L2X0_AUX_CTRL);
<span class="p_chunk">@@ -1126,14 +1059,15 @@</span> <span class="p_context"> static unsigned long calc_range_end(unsigned long start, unsigned long end)</span>
 static void aurora_pa_range(unsigned long start, unsigned long end,
 			unsigned long offset)
 {
<span class="p_add">+	void __iomem *base = l2x0_base;</span>
 	unsigned long flags;
 
 	raw_spin_lock_irqsave(&amp;l2x0_lock, flags);
<span class="p_del">-	writel_relaxed(start, l2x0_base + AURORA_RANGE_BASE_ADDR_REG);</span>
<span class="p_del">-	writel_relaxed(end, l2x0_base + offset);</span>
<span class="p_add">+	writel_relaxed(start, base + AURORA_RANGE_BASE_ADDR_REG);</span>
<span class="p_add">+	writel_relaxed(end, base + offset);</span>
 	raw_spin_unlock_irqrestore(&amp;l2x0_lock, flags);
 
<span class="p_del">-	cache_sync();</span>
<span class="p_add">+	writel_relaxed(0, base + AURORA_SYNC_REG);</span>
 }
 
 static void aurora_inv_range(unsigned long start, unsigned long end)
<span class="p_chunk">@@ -1193,6 +1127,37 @@</span> <span class="p_context"> static void aurora_flush_range(unsigned long start, unsigned long end)</span>
 	}
 }
 
<span class="p_add">+static void aurora_flush_all(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void __iomem *base = l2x0_base;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clean all ways */</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;l2x0_lock, flags);</span>
<span class="p_add">+	__l2c_op_way(base + L2X0_CLEAN_INV_WAY);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;l2x0_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(0, base + AURORA_SYNC_REG);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void aurora_cache_sync(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	writel_relaxed(0, l2x0_base + AURORA_SYNC_REG);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void aurora_disable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void __iomem *base = l2x0_base;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;l2x0_lock, flags);</span>
<span class="p_add">+	__l2c_op_way(base + L2X0_CLEAN_INV_WAY);</span>
<span class="p_add">+	writel_relaxed(0, base + AURORA_SYNC_REG);</span>
<span class="p_add">+	l2c_write_sec(0, base, L2X0_CTRL);</span>
<span class="p_add">+	dsb(st);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;l2x0_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void aurora_save(void __iomem *base)
 {
 	l2x0_saved_regs.ctrl = readl_relaxed(base + L2X0_CTRL);
<span class="p_chunk">@@ -1267,9 +1232,9 @@</span> <span class="p_context"> static const struct l2c_init_data of_aurora_with_outer_data __initconst = {</span>
 		.inv_range   = aurora_inv_range,
 		.clean_range = aurora_clean_range,
 		.flush_range = aurora_flush_range,
<span class="p_del">-		.flush_all   = l2x0_flush_all,</span>
<span class="p_del">-		.disable     = l2x0_disable,</span>
<span class="p_del">-		.sync        = l2x0_cache_sync,</span>
<span class="p_add">+		.flush_all   = aurora_flush_all,</span>
<span class="p_add">+		.disable     = aurora_disable,</span>
<span class="p_add">+		.sync	     = aurora_cache_sync,</span>
 		.resume      = aurora_resume,
 	},
 };
<span class="p_header">diff --git a/arch/arm/plat-omap/Kconfig b/arch/arm/plat-omap/Kconfig</span>
<span class="p_header">index 02fc10d2d63b..d055db32ffcb 100644</span>
<span class="p_header">--- a/arch/arm/plat-omap/Kconfig</span>
<span class="p_header">+++ b/arch/arm/plat-omap/Kconfig</span>
<span class="p_chunk">@@ -1,3 +1,6 @@</span> <span class="p_context"></span>
<span class="p_add">+config ARCH_OMAP</span>
<span class="p_add">+	bool</span>
<span class="p_add">+</span>
 if ARCH_OMAP
 
 menu &quot;TI OMAP Common Features&quot;
<span class="p_header">diff --git a/arch/arm64/kernel/fpsimd.c b/arch/arm64/kernel/fpsimd.c</span>
<span class="p_header">index a43a40b6a846..5fc3c469654b 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/fpsimd.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/fpsimd.c</span>
<span class="p_chunk">@@ -156,9 +156,11 @@</span> <span class="p_context"> void fpsimd_thread_switch(struct task_struct *next)</span>
 
 void fpsimd_flush_thread(void)
 {
<span class="p_add">+	preempt_disable();</span>
 	memset(&amp;current-&gt;thread.fpsimd_state, 0, sizeof(struct fpsimd_state));
 	fpsimd_flush_task_state(current);
 	set_thread_flag(TIF_FOREIGN_FPSTATE);
<span class="p_add">+	preempt_enable();</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 4e4a10df87c1..8fd2315bdf4d 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -252,8 +252,11 @@</span> <span class="p_context"> static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,</span>
 	 * signal first. We do not need to release the mmap_sem because it
 	 * would already be released in __lock_page_or_retry in mm/filemap.c.
 	 */
<span class="p_del">-	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current))</span>
<span class="p_add">+	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current)) {</span>
<span class="p_add">+		if (!user_mode(regs))</span>
<span class="p_add">+			goto no_context;</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/*
 	 * Major/minor page fault accounting is only done on the initial
<span class="p_header">diff --git a/arch/mips/boot/elf2ecoff.c b/arch/mips/boot/elf2ecoff.c</span>
<span class="p_header">index 8585078ae50e..6950fee4576c 100644</span>
<span class="p_header">--- a/arch/mips/boot/elf2ecoff.c</span>
<span class="p_header">+++ b/arch/mips/boot/elf2ecoff.c</span>
<span class="p_chunk">@@ -49,7 +49,8 @@</span> <span class="p_context"></span>
 /*
  * Some extra ELF definitions
  */
<span class="p_del">-#define PT_MIPS_REGINFO 0x70000000	/* Register usage information */</span>
<span class="p_add">+#define PT_MIPS_REGINFO 	0x70000000	/* Register usage information */</span>
<span class="p_add">+#define PT_MIPS_ABIFLAGS	0x70000003	/* Records ABI related flags  */</span>
 
 /* -------------------------------------------------------------------- */
 
<span class="p_chunk">@@ -267,7 +268,6 @@</span> <span class="p_context"> int main(int argc, char *argv[])</span>
 	Elf32_Ehdr ex;
 	Elf32_Phdr *ph;
 	Elf32_Shdr *sh;
<span class="p_del">-	char *shstrtab;</span>
 	int i, pad;
 	struct sect text, data, bss;
 	struct filehdr efh;
<span class="p_chunk">@@ -335,9 +335,6 @@</span> <span class="p_context"> int main(int argc, char *argv[])</span>
 				     &quot;sh&quot;);
 	if (must_convert_endian)
 		convert_elf_shdrs(sh, ex.e_shnum);
<span class="p_del">-	/* Read in the section string table. */</span>
<span class="p_del">-	shstrtab = saveRead(infile, sh[ex.e_shstrndx].sh_offset,</span>
<span class="p_del">-			    sh[ex.e_shstrndx].sh_size, &quot;shstrtab&quot;);</span>
 
 	/* Figure out if we can cram the program header into an ECOFF
 	   header...  Basically, we can&#39;t handle anything but loadable
<span class="p_chunk">@@ -351,7 +348,8 @@</span> <span class="p_context"> int main(int argc, char *argv[])</span>
 		/* Section types we can ignore... */
 		if (ph[i].p_type == PT_NULL || ph[i].p_type == PT_NOTE ||
 		    ph[i].p_type == PT_PHDR
<span class="p_del">-		    || ph[i].p_type == PT_MIPS_REGINFO)</span>
<span class="p_add">+		    || ph[i].p_type == PT_MIPS_REGINFO</span>
<span class="p_add">+		    || ph[i].p_type == PT_MIPS_ABIFLAGS)</span>
 			continue;
 		/* Section types we can&#39;t handle... */
 		else if (ph[i].p_type != PT_LOAD) {
<span class="p_header">diff --git a/arch/mips/dec/int-handler.S b/arch/mips/dec/int-handler.S</span>
<span class="p_header">index 41a2fa1fa12e..a0c2d6ccdedc 100644</span>
<span class="p_header">--- a/arch/mips/dec/int-handler.S</span>
<span class="p_header">+++ b/arch/mips/dec/int-handler.S</span>
<span class="p_chunk">@@ -146,7 +146,14 @@</span> <span class="p_context"></span>
 		/*
 		 * Find irq with highest priority
 		 */
<span class="p_del">-		 PTR_LA	t1,cpu_mask_nr_tbl</span>
<span class="p_add">+		# open coded PTR_LA t1, cpu_mask_nr_tbl</span>
<span class="p_add">+#if defined(CONFIG_32BIT) || defined(KBUILD_64BIT_SYM32)</span>
<span class="p_add">+		# open coded la t1, cpu_mask_nr_tbl</span>
<span class="p_add">+		lui	t1, %hi(cpu_mask_nr_tbl)</span>
<span class="p_add">+		addiu	t1, %lo(cpu_mask_nr_tbl)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#error GCC `-msym32&#39; option required for 64-bit DECstation builds</span>
<span class="p_add">+#endif</span>
 1:		lw	t2,(t1)
 		nop
 		and	t2,t0
<span class="p_chunk">@@ -195,7 +202,14 @@</span> <span class="p_context"></span>
 		/*
 		 * Find irq with highest priority
 		 */
<span class="p_del">-		 PTR_LA	t1,asic_mask_nr_tbl</span>
<span class="p_add">+		# open coded PTR_LA t1,asic_mask_nr_tbl</span>
<span class="p_add">+#if defined(CONFIG_32BIT) || defined(KBUILD_64BIT_SYM32)</span>
<span class="p_add">+		# open coded la t1, asic_mask_nr_tbl</span>
<span class="p_add">+		lui	t1, %hi(asic_mask_nr_tbl)</span>
<span class="p_add">+		addiu	t1, %lo(asic_mask_nr_tbl)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#error GCC `-msym32&#39; option required for 64-bit DECstation builds</span>
<span class="p_add">+#endif</span>
 2:		lw	t2,(t1)
 		nop
 		and	t2,t0
<span class="p_header">diff --git a/arch/mips/include/asm/page.h b/arch/mips/include/asm/page.h</span>
<span class="p_header">index 5699ec3a71af..fd0347da36df 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/page.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/page.h</span>
<span class="p_chunk">@@ -223,7 +223,8 @@</span> <span class="p_context"> static inline int pfn_valid(unsigned long pfn)</span>
 
 #endif
 
<span class="p_del">-#define virt_to_page(kaddr)	pfn_to_page(PFN_DOWN(virt_to_phys(kaddr)))</span>
<span class="p_add">+#define virt_to_page(kaddr)	pfn_to_page(PFN_DOWN(virt_to_phys((void *)     \</span>
<span class="p_add">+								  (kaddr))))</span>
 
 extern int __virt_addr_valid(const volatile void *kaddr);
 #define virt_addr_valid(kaddr)						\
<span class="p_header">diff --git a/arch/mips/jz4740/board-qi_lb60.c b/arch/mips/jz4740/board-qi_lb60.c</span>
<span class="p_header">index 088e92a79ae6..7da9ff143499 100644</span>
<span class="p_header">--- a/arch/mips/jz4740/board-qi_lb60.c</span>
<span class="p_header">+++ b/arch/mips/jz4740/board-qi_lb60.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/power/jz4740-battery.h&gt;
 #include &lt;linux/power/gpio-charger.h&gt;
 
<span class="p_add">+#include &lt;asm/mach-jz4740/gpio.h&gt;</span>
 #include &lt;asm/mach-jz4740/jz4740_fb.h&gt;
 #include &lt;asm/mach-jz4740/jz4740_mmc.h&gt;
 #include &lt;asm/mach-jz4740/jz4740_nand.h&gt;
<span class="p_header">diff --git a/arch/mips/jz4740/gpio.c b/arch/mips/jz4740/gpio.c</span>
<span class="p_header">index 00b798d2fb7c..000d2d91b704 100644</span>
<span class="p_header">--- a/arch/mips/jz4740/gpio.c</span>
<span class="p_header">+++ b/arch/mips/jz4740/gpio.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/seq_file.h&gt;
 
 #include &lt;asm/mach-jz4740/base.h&gt;
<span class="p_add">+#include &lt;asm/mach-jz4740/gpio.h&gt;</span>
 
 #include &quot;irq.h&quot;
 
<span class="p_header">diff --git a/arch/mips/jz4740/irq.h b/arch/mips/jz4740/irq.h</span>
<span class="p_header">index 0f48720b5b63..486db78808cc 100644</span>
<span class="p_header">--- a/arch/mips/jz4740/irq.h</span>
<span class="p_header">+++ b/arch/mips/jz4740/irq.h</span>
<span class="p_chunk">@@ -16,7 +16,9 @@</span> <span class="p_context"></span>
 #define __MIPS_JZ4740_IRQ_H__
 
 #include &lt;linux/irq.h&gt;
<span class="p_add">+#include &lt;asm/mach-jz4740/irq.h&gt;</span>
 
<span class="p_add">+struct irq_data;</span>
 extern void jz4740_irq_suspend(struct irq_data *data);
 extern void jz4740_irq_resume(struct irq_data *data);
 
<span class="p_header">diff --git a/arch/mips/kernel/bmips_vec.S b/arch/mips/kernel/bmips_vec.S</span>
<span class="p_header">index d4614d31d828..d9495f3f3fad 100644</span>
<span class="p_header">--- a/arch/mips/kernel/bmips_vec.S</span>
<span class="p_header">+++ b/arch/mips/kernel/bmips_vec.S</span>
<span class="p_chunk">@@ -211,7 +211,6 @@</span> <span class="p_context"> NESTED(bmips_reset_nmi_vec, PT_SIZE, sp)</span>
 END(bmips_reset_nmi_vec)
 
 	.set	pop
<span class="p_del">-	.previous</span>
 
 /***********************************************************************
  * CPU1 warm restart vector (used for second and subsequent boots).
<span class="p_chunk">@@ -286,5 +285,3 @@</span> <span class="p_context"> LEAF(bmips_enable_xks01)</span>
 	jr	ra
 
 END(bmips_enable_xks01)
<span class="p_del">-</span>
<span class="p_del">-	.previous</span>
<span class="p_header">diff --git a/arch/mips/pci/ops-pmcmsp.c b/arch/mips/pci/ops-pmcmsp.c</span>
<span class="p_header">index 50034f985be1..dd2d9f7e9412 100644</span>
<span class="p_header">--- a/arch/mips/pci/ops-pmcmsp.c</span>
<span class="p_header">+++ b/arch/mips/pci/ops-pmcmsp.c</span>
<span class="p_chunk">@@ -193,8 +193,6 @@</span> <span class="p_context"> static void pci_proc_init(void)</span>
 }
 #endif /* CONFIG_PROC_FS &amp;&amp; PCI_COUNTERS */
 
<span class="p_del">-static DEFINE_SPINLOCK(bpci_lock);</span>
<span class="p_del">-</span>
 /*****************************************************************************
  *
  *  STRUCT: pci_io_resource
<span class="p_chunk">@@ -368,7 +366,6 @@</span> <span class="p_context"> int msp_pcibios_config_access(unsigned char access_type,</span>
 	struct msp_pci_regs *preg = (void *)PCI_BASE_REG;
 	unsigned char bus_num = bus-&gt;number;
 	unsigned char dev_fn = (unsigned char)devfn;
<span class="p_del">-	unsigned long flags;</span>
 	unsigned long intr;
 	unsigned long value;
 	static char pciirqflag;
<span class="p_chunk">@@ -401,10 +398,7 @@</span> <span class="p_context"> int msp_pcibios_config_access(unsigned char access_type,</span>
 	}
 
 #if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)
<span class="p_del">-	local_irq_save(flags);</span>
 	vpe_status = dvpe();
<span class="p_del">-#else</span>
<span class="p_del">-	spin_lock_irqsave(&amp;bpci_lock, flags);</span>
 #endif
 
 	/*
<span class="p_chunk">@@ -457,9 +451,6 @@</span> <span class="p_context"> int msp_pcibios_config_access(unsigned char access_type,</span>
 
 #if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)
 		evpe(vpe_status);
<span class="p_del">-		local_irq_restore(flags);</span>
<span class="p_del">-#else</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;bpci_lock, flags);</span>
 #endif
 
 		return -1;
<span class="p_chunk">@@ -467,9 +458,6 @@</span> <span class="p_context"> int msp_pcibios_config_access(unsigned char access_type,</span>
 
 #if defined(CONFIG_PMC_MSP7120_GW) || defined(CONFIG_PMC_MSP7120_EVAL)
 	evpe(vpe_status);
<span class="p_del">-	local_irq_restore(flags);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;bpci_lock, flags);</span>
 #endif
 
 	return PCIBIOS_SUCCESSFUL;
<span class="p_header">diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c</span>
<span class="p_header">index 0e046d82e4e3..d54ea93651ac 100644</span>
<span class="p_header">--- a/arch/mips/pci/ops-tx4927.c</span>
<span class="p_header">+++ b/arch/mips/pci/ops-tx4927.c</span>
<span class="p_chunk">@@ -199,8 +199,6 @@</span> <span class="p_context"> static struct {</span>
 
 char *tx4927_pcibios_setup(char *str)
 {
<span class="p_del">-	unsigned long val;</span>
<span class="p_del">-</span>
 	if (!strncmp(str, &quot;trdyto=&quot;, 7)) {
 		u8 val = 0;
 		if (kstrtou8(str + 7, 0, &amp;val) == 0)
<span class="p_header">diff --git a/arch/mips/sgi-ip22/Platform b/arch/mips/sgi-ip22/Platform</span>
<span class="p_header">index b7a4b7e04c38..e8f6b3a42a48 100644</span>
<span class="p_header">--- a/arch/mips/sgi-ip22/Platform</span>
<span class="p_header">+++ b/arch/mips/sgi-ip22/Platform</span>
<span class="p_chunk">@@ -25,7 +25,7 @@</span> <span class="p_context"> endif</span>
 # Simplified: what IP22 does at 128MB+ in ksegN, IP28 does at 512MB+ in xkphys
 #
 ifdef CONFIG_SGI_IP28
<span class="p_del">-  ifeq ($(call cc-option-yn,-mr10k-cache-barrier=store), n)</span>
<span class="p_add">+  ifeq ($(call cc-option-yn,-march=r10000 -mr10k-cache-barrier=store), n)</span>
       $(error gcc doesn&#39;t support needed option -mr10k-cache-barrier=store)
   endif
 endif
<span class="p_header">diff --git a/arch/powerpc/boot/Makefile b/arch/powerpc/boot/Makefile</span>
<span class="p_header">index f5443645ffca..4dcd7f5b027f 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/boot/Makefile</span>
<span class="p_chunk">@@ -21,11 +21,19 @@</span> <span class="p_context"> all: $(obj)/zImage</span>
 
 BOOTCFLAGS    := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \
 		 -fno-strict-aliasing -Os -msoft-float -pipe \
<span class="p_del">-		 -fomit-frame-pointer -fno-builtin -fPIC -nostdinc \</span>
<span class="p_del">-		 -isystem $(shell $(CROSS32CC) -print-file-name=include)</span>
<span class="p_add">+		 -fomit-frame-pointer -fno-builtin -fPIC -nostdinc</span>
<span class="p_add">+BOOTCC := $(CC)</span>
 ifdef CONFIG_PPC64_BOOT_WRAPPER
 BOOTCFLAGS	+= -m64
<span class="p_add">+else</span>
<span class="p_add">+BOOTCFLAGS	+= -m32</span>
<span class="p_add">+ifdef CROSS32_COMPILE</span>
<span class="p_add">+    BOOTCC := $(CROSS32_COMPILE)gcc</span>
<span class="p_add">+endif</span>
 endif
<span class="p_add">+</span>
<span class="p_add">+BOOTCFLAGS	+= -isystem $(shell $(BOOTCC) -print-file-name=include)</span>
<span class="p_add">+</span>
 ifdef CONFIG_CPU_BIG_ENDIAN
 BOOTCFLAGS	+= -mbig-endian
 else
<span class="p_chunk">@@ -165,10 +173,10 @@</span> <span class="p_context"> clean-files := $(zlib) $(zlibheader) $(zliblinuxheader) \</span>
 		empty.c zImage.coff.lds zImage.ps3.lds zImage.lds
 
 quiet_cmd_bootcc = BOOTCC  $@
<span class="p_del">-      cmd_bootcc = $(CROSS32CC) -Wp,-MD,$(depfile) $(BOOTCFLAGS) -c -o $@ $&lt;</span>
<span class="p_add">+      cmd_bootcc = $(BOOTCC) -Wp,-MD,$(depfile) $(BOOTCFLAGS) -c -o $@ $&lt;</span>
 
 quiet_cmd_bootas = BOOTAS  $@
<span class="p_del">-      cmd_bootas = $(CROSS32CC) -Wp,-MD,$(depfile) $(BOOTAFLAGS) -c -o $@ $&lt;</span>
<span class="p_add">+      cmd_bootas = $(BOOTCC) -Wp,-MD,$(depfile) $(BOOTAFLAGS) -c -o $@ $&lt;</span>
 
 quiet_cmd_bootar = BOOTAR  $@
       cmd_bootar = $(CROSS32AR) -cr$(KBUILD_ARFLAGS) $@.$$$$ $(filter-out FORCE,$^); mv $@.$$$$ $@
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 73abf3119ad1..eaac0cb57717 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -1816,6 +1816,8 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 			run-&gt;fail_entry.hardware_entry_failure_reason = 0;
 			return -EINVAL;
 		}
<span class="p_add">+		/* Enable TM so we can read the TM SPRs */</span>
<span class="p_add">+		mtmsr(mfmsr() | MSR_TM);</span>
 		current-&gt;thread.tm_tfhar = mfspr(SPRN_TFHAR);
 		current-&gt;thread.tm_tfiar = mfspr(SPRN_TFIAR);
 		current-&gt;thread.tm_texasr = mfspr(SPRN_TEXASR);
<span class="p_header">diff --git a/arch/powerpc/mm/subpage-prot.c b/arch/powerpc/mm/subpage-prot.c</span>
<span class="p_header">index 6c0b1f5f8d2c..6fd582b16e22 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/subpage-prot.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/subpage-prot.c</span>
<span class="p_chunk">@@ -36,7 +36,7 @@</span> <span class="p_context"> void subpage_prot_free(struct mm_struct *mm)</span>
 		}
 	}
 	addr = 0;
<span class="p_del">-	for (i = 0; i &lt; 2; ++i) {</span>
<span class="p_add">+	for (i = 0; i &lt; (TASK_SIZE_USER64 &gt;&gt; 43); ++i) {</span>
 		p = spt-&gt;protptrs[i];
 		if (!p)
 			continue;
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/reconfig.c b/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_header">index 1c0a60d98867..c24c73a2e2b5 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_chunk">@@ -112,7 +112,6 @@</span> <span class="p_context"> static int pSeries_reconfig_remove_node(struct device_node *np)</span>
 
 	of_detach_node(np);
 	of_node_put(parent);
<span class="p_del">-	of_node_put(np); /* Must decrement the refcount */</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/boot/compressed/misc.h b/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">index 24e3e569a13c..124312be129b 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/misc.h</span>
<span class="p_chunk">@@ -2,14 +2,13 @@</span> <span class="p_context"></span>
 #define BOOT_COMPRESSED_MISC_H
 
 /*
<span class="p_del">- * we have to be careful, because no indirections are allowed here, and</span>
<span class="p_del">- * paravirt_ops is a kind of one. As it will only run in baremetal anyway,</span>
<span class="p_del">- * we just keep it from happening</span>
<span class="p_add">+ * Special hack: we have to be careful, because no indirections are allowed here,</span>
<span class="p_add">+ * and paravirt_ops is a kind of one. As it will only run in baremetal anyway,</span>
<span class="p_add">+ * we just keep it from happening. (This list needs to be extended when new</span>
<span class="p_add">+ * paravirt and debugging variants are added.)</span>
  */
 #undef CONFIG_PARAVIRT
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-#define _ASM_X86_DESC_H 1</span>
<span class="p_del">-#endif</span>
<span class="p_add">+#undef CONFIG_PARAVIRT_SPINLOCKS</span>
 
 #include &lt;linux/linkage.h&gt;
 #include &lt;linux/screen_info.h&gt;
<span class="p_header">diff --git a/arch/x86/crypto/sha1_avx2_x86_64_asm.S b/arch/x86/crypto/sha1_avx2_x86_64_asm.S</span>
<span class="p_header">index 1cd792db15ef..1eab79c9ac48 100644</span>
<span class="p_header">--- a/arch/x86/crypto/sha1_avx2_x86_64_asm.S</span>
<span class="p_header">+++ b/arch/x86/crypto/sha1_avx2_x86_64_asm.S</span>
<span class="p_chunk">@@ -117,11 +117,10 @@</span> <span class="p_context"></span>
 	.set T1, REG_T1
 .endm
 
<span class="p_del">-#define K_BASE		%r8</span>
 #define HASH_PTR	%r9
<span class="p_add">+#define BLOCKS_CTR	%r8</span>
 #define BUFFER_PTR	%r10
 #define BUFFER_PTR2	%r13
<span class="p_del">-#define BUFFER_END	%r11</span>
 
 #define PRECALC_BUF	%r14
 #define WK_BUF		%r15
<span class="p_chunk">@@ -205,14 +204,14 @@</span> <span class="p_context"></span>
 		 * blended AVX2 and ALU instruction scheduling
 		 * 1 vector iteration per 8 rounds
 		 */
<span class="p_del">-		vmovdqu ((i * 2) + PRECALC_OFFSET)(BUFFER_PTR), W_TMP</span>
<span class="p_add">+		vmovdqu (i * 2)(BUFFER_PTR), W_TMP</span>
 	.elseif ((i &amp; 7) == 1)
<span class="p_del">-		vinsertf128 $1, (((i-1) * 2)+PRECALC_OFFSET)(BUFFER_PTR2),\</span>
<span class="p_add">+		vinsertf128 $1, ((i-1) * 2)(BUFFER_PTR2),\</span>
 			 WY_TMP, WY_TMP
 	.elseif ((i &amp; 7) == 2)
 		vpshufb YMM_SHUFB_BSWAP, WY_TMP, WY
 	.elseif ((i &amp; 7) == 4)
<span class="p_del">-		vpaddd  K_XMM(K_BASE), WY, WY_TMP</span>
<span class="p_add">+		vpaddd  K_XMM + K_XMM_AR(%rip), WY, WY_TMP</span>
 	.elseif ((i &amp; 7) == 7)
 		vmovdqu  WY_TMP, PRECALC_WK(i&amp;~7)
 
<span class="p_chunk">@@ -255,7 +254,7 @@</span> <span class="p_context"></span>
 		vpxor	WY, WY_TMP, WY_TMP
 	.elseif ((i &amp; 7) == 7)
 		vpxor	WY_TMP2, WY_TMP, WY
<span class="p_del">-		vpaddd	K_XMM(K_BASE), WY, WY_TMP</span>
<span class="p_add">+		vpaddd  K_XMM + K_XMM_AR(%rip), WY, WY_TMP</span>
 		vmovdqu	WY_TMP, PRECALC_WK(i&amp;~7)
 
 		PRECALC_ROTATE_WY
<span class="p_chunk">@@ -291,7 +290,7 @@</span> <span class="p_context"></span>
 		vpsrld	$30, WY, WY
 		vpor	WY, WY_TMP, WY
 	.elseif ((i &amp; 7) == 7)
<span class="p_del">-		vpaddd	K_XMM(K_BASE), WY, WY_TMP</span>
<span class="p_add">+		vpaddd  K_XMM + K_XMM_AR(%rip), WY, WY_TMP</span>
 		vmovdqu	WY_TMP, PRECALC_WK(i&amp;~7)
 
 		PRECALC_ROTATE_WY
<span class="p_chunk">@@ -446,6 +445,16 @@</span> <span class="p_context"></span>
 
 .endm
 
<span class="p_add">+/* Add constant only if (%2 &gt; %3) condition met (uses RTA as temp)</span>
<span class="p_add">+ * %1 + %2 &gt;= %3 ? %4 : 0</span>
<span class="p_add">+ */</span>
<span class="p_add">+.macro ADD_IF_GE a, b, c, d</span>
<span class="p_add">+	mov     \a, RTA</span>
<span class="p_add">+	add     $\d, RTA</span>
<span class="p_add">+	cmp     $\c, \b</span>
<span class="p_add">+	cmovge  RTA, \a</span>
<span class="p_add">+.endm</span>
<span class="p_add">+</span>
 /*
  * macro implements 80 rounds of SHA-1, for multiple blocks with s/w pipelining
  */
<span class="p_chunk">@@ -463,13 +472,16 @@</span> <span class="p_context"></span>
 	lea	(2*4*80+32)(%rsp), WK_BUF
 
 	# Precalc WK for first 2 blocks
<span class="p_del">-	PRECALC_OFFSET = 0</span>
<span class="p_add">+	ADD_IF_GE BUFFER_PTR2, BLOCKS_CTR, 2, 64</span>
 	.set i, 0
 	.rept    160
 		PRECALC i
 		.set i, i + 1
 	.endr
<span class="p_del">-	PRECALC_OFFSET = 128</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Go to next block if needed */</span>
<span class="p_add">+	ADD_IF_GE BUFFER_PTR, BLOCKS_CTR, 3, 128</span>
<span class="p_add">+	ADD_IF_GE BUFFER_PTR2, BLOCKS_CTR, 4, 128</span>
 	xchg	WK_BUF, PRECALC_BUF
 
 	.align 32
<span class="p_chunk">@@ -479,8 +491,8 @@</span> <span class="p_context"></span>
 	 * we use K_BASE value as a signal of a last block,
 	 * it is set below by: cmovae BUFFER_PTR, K_BASE
 	 */
<span class="p_del">-	cmp	K_BASE, BUFFER_PTR</span>
<span class="p_del">-	jne	_begin</span>
<span class="p_add">+	test BLOCKS_CTR, BLOCKS_CTR</span>
<span class="p_add">+	jnz _begin</span>
 	.align 32
 	jmp	_end
 	.align 32
<span class="p_chunk">@@ -512,10 +524,10 @@</span> <span class="p_context"></span>
 		.set j, j+2
 	.endr
 
<span class="p_del">-	add	$(2*64), BUFFER_PTR       /* move to next odd-64-byte block */</span>
<span class="p_del">-	cmp	BUFFER_END, BUFFER_PTR    /* is current block the last one? */</span>
<span class="p_del">-	cmovae	K_BASE, BUFFER_PTR	/* signal the last iteration smartly */</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Update Counter */</span>
<span class="p_add">+	sub $1, BLOCKS_CTR</span>
<span class="p_add">+	/* Move to the next block only if needed*/</span>
<span class="p_add">+	ADD_IF_GE BUFFER_PTR, BLOCKS_CTR, 4, 128</span>
 	/*
 	 * rounds
 	 * 60,62,64,66,68
<span class="p_chunk">@@ -532,8 +544,8 @@</span> <span class="p_context"></span>
 	UPDATE_HASH	12(HASH_PTR), D
 	UPDATE_HASH	16(HASH_PTR), E
 
<span class="p_del">-	cmp	K_BASE, BUFFER_PTR	/* is current block the last one? */</span>
<span class="p_del">-	je	_loop</span>
<span class="p_add">+	test	BLOCKS_CTR, BLOCKS_CTR</span>
<span class="p_add">+	jz	_loop</span>
 
 	mov	TB, B
 
<span class="p_chunk">@@ -575,10 +587,10 @@</span> <span class="p_context"></span>
 		.set j, j+2
 	.endr
 
<span class="p_del">-	add	$(2*64), BUFFER_PTR2      /* move to next even-64-byte block */</span>
<span class="p_del">-</span>
<span class="p_del">-	cmp	BUFFER_END, BUFFER_PTR2   /* is current block the last one */</span>
<span class="p_del">-	cmovae	K_BASE, BUFFER_PTR       /* signal the last iteration smartly */</span>
<span class="p_add">+	/* update counter */</span>
<span class="p_add">+	sub     $1, BLOCKS_CTR</span>
<span class="p_add">+	/* Move to the next block only if needed*/</span>
<span class="p_add">+	ADD_IF_GE BUFFER_PTR2, BLOCKS_CTR, 4, 128</span>
 
 	jmp	_loop3
 _loop3:
<span class="p_chunk">@@ -641,19 +653,12 @@</span> <span class="p_context"></span>
 
 	avx2_zeroupper
 
<span class="p_del">-	lea	K_XMM_AR(%rip), K_BASE</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Setup initial values */</span>
 	mov	CTX, HASH_PTR
 	mov	BUF, BUFFER_PTR
<span class="p_del">-	lea	64(BUF), BUFFER_PTR2</span>
<span class="p_del">-</span>
<span class="p_del">-	shl	$6, CNT			/* mul by 64 */</span>
<span class="p_del">-	add	BUF, CNT</span>
<span class="p_del">-	add	$64, CNT</span>
<span class="p_del">-	mov	CNT, BUFFER_END</span>
 
<span class="p_del">-	cmp	BUFFER_END, BUFFER_PTR2</span>
<span class="p_del">-	cmovae	K_BASE, BUFFER_PTR2</span>
<span class="p_add">+	mov	BUF, BUFFER_PTR2</span>
<span class="p_add">+	mov	CNT, BLOCKS_CTR</span>
 
 	xmm_mov	BSWAP_SHUFB_CTL(%rip), YMM_SHUFB_BSWAP
 
<span class="p_header">diff --git a/arch/x86/crypto/sha1_ssse3_glue.c b/arch/x86/crypto/sha1_ssse3_glue.c</span>
<span class="p_header">index ba9c75c5a432..b11fb043c80f 100644</span>
<span class="p_header">--- a/arch/x86/crypto/sha1_ssse3_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/sha1_ssse3_glue.c</span>
<span class="p_chunk">@@ -224,7 +224,7 @@</span> <span class="p_context"> static bool __init avx_usable(void)</span>
 #ifdef CONFIG_AS_AVX2
 static bool __init avx2_usable(void)
 {
<span class="p_del">-	if (false &amp;&amp; avx_usable() &amp;&amp; cpu_has_avx2 &amp;&amp;</span>
<span class="p_add">+	if (avx_usable() &amp;&amp; cpu_has_avx2 &amp;&amp;</span>
 	    boot_cpu_has(X86_FEATURE_BMI1) &amp;&amp;
 	    boot_cpu_has(X86_FEATURE_BMI2))
 		return true;
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index 86281ffb96d6..239cd7913df6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -909,6 +909,14 @@</span> <span class="p_context"> void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger, u32 gsi)</span>
 	int pin;
 	struct mpc_intsrc mp_irq;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check bus_irq boundary.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bus_irq &gt;= NR_IRQS_LEGACY) {</span>
<span class="p_add">+		pr_warn(&quot;Invalid bus_irq %u for legacy override\n&quot;, bus_irq);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Convert &#39;gsi&#39; to &#39;ioapic.pin&#39;.
 	 */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">index 10544b9ae3d0..ec91ccee0661 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_chunk">@@ -2009,17 +2009,14 @@</span> <span class="p_context"> static unsigned long get_segment_base(unsigned int segment)</span>
 	if ((segment &amp; SEGMENT_TI_MASK) == SEGMENT_LDT) {
 		struct ldt_struct *ldt;
 
<span class="p_del">-		if (idx &gt; LDT_ENTRIES)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-</span>
 		/* IRQs are off, so this synchronizes with smp_store_release */
 		ldt = lockless_dereference(current-&gt;active_mm-&gt;context.ldt);
<span class="p_del">-		if (!ldt || idx &gt; ldt-&gt;size)</span>
<span class="p_add">+		if (!ldt || idx &gt;= ldt-&gt;size)</span>
 			return 0;
 
 		desc = &amp;ldt-&gt;entries[idx];
 	} else {
<span class="p_del">-		if (idx &gt; GDT_ENTRIES)</span>
<span class="p_add">+		if (idx &gt;= GDT_ENTRIES)</span>
 			return 0;
 
 		desc = __this_cpu_ptr(&amp;gdt_page.gdt[0]) + idx;
<span class="p_header">diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S</span>
<span class="p_header">index 701db48562b1..42a970d19ab3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/entry_64.S</span>
<span class="p_chunk">@@ -1476,6 +1476,8 @@</span> <span class="p_context"> ENTRY(nmi)</span>
 	 * other IST entries.
 	 */
 
<span class="p_add">+	ASM_CLAC</span>
<span class="p_add">+</span>
 	/* Use %rdx as out temp variable throughout */
 	pushq_cfi %rdx
 	CFI_REL_OFFSET rdx, 0
<span class="p_header">diff --git a/arch/x86/kernel/kprobes/core.c b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">index b6547a441bad..608f18c62412 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kprobes/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kprobes/core.c</span>
<span class="p_chunk">@@ -401,6 +401,8 @@</span> <span class="p_context"> static int arch_copy_kprobe(struct kprobe *p)</span>
 
 int arch_prepare_kprobe(struct kprobe *p)
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	if (alternatives_text_reserved(p-&gt;addr, p-&gt;addr))
 		return -EINVAL;
 
<span class="p_chunk">@@ -411,7 +413,13 @@</span> <span class="p_context"> int arch_prepare_kprobe(struct kprobe *p)</span>
 	if (!p-&gt;ainsn.insn)
 		return -ENOMEM;
 
<span class="p_del">-	return arch_copy_kprobe(p);</span>
<span class="p_add">+	ret = arch_copy_kprobe(p);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		free_insn_slot(p-&gt;ainsn.insn, 0);</span>
<span class="p_add">+		p-&gt;ainsn.insn = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 void arch_arm_kprobe(struct kprobe *p)
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index 61da6be309a7..17cc2a2e27d6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -150,6 +150,8 @@</span> <span class="p_context"> void kvm_async_pf_task_wait(u32 token)</span>
 		if (hlist_unhashed(&amp;n.link))
 			break;
 
<span class="p_add">+		rcu_irq_exit();</span>
<span class="p_add">+</span>
 		if (!n.halted) {
 			local_irq_enable();
 			schedule();
<span class="p_chunk">@@ -158,11 +160,11 @@</span> <span class="p_context"> void kvm_async_pf_task_wait(u32 token)</span>
 			/*
 			 * We cannot reschedule. So halt.
 			 */
<span class="p_del">-			rcu_irq_exit();</span>
 			native_safe_halt();
 			local_irq_disable();
<span class="p_del">-			rcu_irq_enter();</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		rcu_irq_enter();</span>
 	}
 	if (!n.halted)
 		finish_wait(&amp;n.wq, &amp;wait);
<span class="p_header">diff --git a/arch/x86/xen/mmu.c b/arch/x86/xen/mmu.c</span>
<span class="p_header">index 16fb0099b7f2..f05f2d897a67 100644</span>
<span class="p_header">--- a/arch/x86/xen/mmu.c</span>
<span class="p_header">+++ b/arch/x86/xen/mmu.c</span>
<span class="p_chunk">@@ -1187,7 +1187,7 @@</span> <span class="p_context"> static void __init xen_cleanhighmap(unsigned long vaddr,</span>
 
 	/* NOTE: The loop is more greedy than the cleanup_highmap variant.
 	 * We include the PMD passed in on _both_ boundaries. */
<span class="p_del">-	for (; vaddr &lt;= vaddr_end &amp;&amp; (pmd &lt; (level2_kernel_pgt + PAGE_SIZE));</span>
<span class="p_add">+	for (; vaddr &lt;= vaddr_end &amp;&amp; (pmd &lt; (level2_kernel_pgt + PTRS_PER_PMD));</span>
 			pmd++, vaddr += PMD_SIZE) {
 		if (pmd_none(*pmd))
 			continue;
<span class="p_header">diff --git a/arch/xtensa/kernel/xtensa_ksyms.c b/arch/xtensa/kernel/xtensa_ksyms.c</span>
<span class="p_header">index 4d2872fd9bb5..a71d2739fa82 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/xtensa_ksyms.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/xtensa_ksyms.c</span>
<span class="p_chunk">@@ -94,13 +94,11 @@</span> <span class="p_context"> unsigned long __sync_fetch_and_or_4(unsigned long *p, unsigned long v)</span>
 }
 EXPORT_SYMBOL(__sync_fetch_and_or_4);
 
<span class="p_del">-#ifdef CONFIG_NET</span>
 /*
  * Networking support
  */
 EXPORT_SYMBOL(csum_partial);
 EXPORT_SYMBOL(csum_partial_copy_generic);
<span class="p_del">-#endif /* CONFIG_NET */</span>
 
 /*
  * Architecture-specific symbols
<span class="p_header">diff --git a/arch/xtensa/mm/cache.c b/arch/xtensa/mm/cache.c</span>
<span class="p_header">index 63cbb867dadd..1fface176acd 100644</span>
<span class="p_header">--- a/arch/xtensa/mm/cache.c</span>
<span class="p_header">+++ b/arch/xtensa/mm/cache.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"></span>
 #error &quot;HIGHMEM is not supported on cores with aliasing cache.&quot;
 #endif
 
<span class="p_del">-#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE) &amp;&amp; XCHAL_DCACHE_IS_WRITEBACK</span>
<span class="p_add">+#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE)</span>
 
 /*
  * Any time the kernel writes to a user page cache page, or it is about to
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> void flush_dcache_page(struct page *page)</span>
 
 	/* There shouldn&#39;t be an entry in the cache for this page anymore. */
 }
<span class="p_del">-</span>
<span class="p_add">+EXPORT_SYMBOL(flush_dcache_page);</span>
 
 /*
  * For now, flush the whole cache. FIXME??
<span class="p_chunk">@@ -128,6 +128,7 @@</span> <span class="p_context"> void local_flush_cache_range(struct vm_area_struct *vma,</span>
 	__flush_invalidate_dcache_all();
 	__invalidate_icache_all();
 }
<span class="p_add">+EXPORT_SYMBOL(local_flush_cache_range);</span>
 
 /* 
  * Remove any entry in the cache for this page. 
<span class="p_chunk">@@ -147,8 +148,9 @@</span> <span class="p_context"> void local_flush_cache_page(struct vm_area_struct *vma, unsigned long address,</span>
 	__flush_invalidate_dcache_page_alias(virt, phys);
 	__invalidate_icache_page_alias(virt, phys);
 }
<span class="p_add">+EXPORT_SYMBOL(local_flush_cache_page);</span>
 
<span class="p_del">-#endif</span>
<span class="p_add">+#endif /* DCACHE_WAY_SIZE &gt; PAGE_SIZE */</span>
 
 void
 update_mmu_cache(struct vm_area_struct * vma, unsigned long addr, pte_t *ptep)
<span class="p_chunk">@@ -165,7 +167,7 @@</span> <span class="p_context"> update_mmu_cache(struct vm_area_struct * vma, unsigned long addr, pte_t *ptep)</span>
 
 	flush_tlb_page(vma, addr);
 
<span class="p_del">-#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE) &amp;&amp; XCHAL_DCACHE_IS_WRITEBACK</span>
<span class="p_add">+#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE)</span>
 
 	if (!PageReserved(page) &amp;&amp; test_bit(PG_arch_1, &amp;page-&gt;flags)) {
 
<span class="p_chunk">@@ -197,7 +199,7 @@</span> <span class="p_context"> update_mmu_cache(struct vm_area_struct * vma, unsigned long addr, pte_t *ptep)</span>
  * flush_dcache_page() on the page.
  */
 
<span class="p_del">-#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE) &amp;&amp; XCHAL_DCACHE_IS_WRITEBACK</span>
<span class="p_add">+#if (DCACHE_WAY_SIZE &gt; PAGE_SIZE)</span>
 
 void copy_to_user_page(struct vm_area_struct *vma, struct page *page,
 		unsigned long vaddr, void *dst, const void *src,
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 529e4195724e..dcc6365bcc11 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1337,6 +1337,7 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 		offset = uaddr &amp; ~PAGE_MASK;
 		for (j = cur_page; j &lt; page_limit; j++) {
 			unsigned int bytes = PAGE_SIZE - offset;
<span class="p_add">+			unsigned short prev_bi_vcnt = bio-&gt;bi_vcnt;</span>
 
 			if (len &lt;= 0)
 				break;
<span class="p_chunk">@@ -1351,6 +1352,13 @@</span> <span class="p_context"> static struct bio *__bio_map_user_iov(struct request_queue *q,</span>
 					    bytes)
 				break;
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * check if vector was merged with previous</span>
<span class="p_add">+			 * drop page reference if needed</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (bio-&gt;bi_vcnt == prev_bi_vcnt)</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+</span>
 			len -= bytes;
 			offset = 0;
 		}
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index 90112092d1e6..b297d43e1121 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2796,10 +2796,12 @@</span> <span class="p_context"> static unsigned int atapi_xlat(struct ata_queued_cmd *qc)</span>
 static struct ata_device *ata_find_dev(struct ata_port *ap, int devno)
 {
 	if (!sata_pmp_attached(ap)) {
<span class="p_del">-		if (likely(devno &lt; ata_link_max_devices(&amp;ap-&gt;link)))</span>
<span class="p_add">+		if (likely(devno &gt;= 0 &amp;&amp;</span>
<span class="p_add">+			   devno &lt; ata_link_max_devices(&amp;ap-&gt;link)))</span>
 			return &amp;ap-&gt;link.device[devno];
 	} else {
<span class="p_del">-		if (likely(devno &lt; ap-&gt;nr_pmp_links))</span>
<span class="p_add">+		if (likely(devno &gt;= 0 &amp;&amp;</span>
<span class="p_add">+			   devno &lt; ap-&gt;nr_pmp_links))</span>
 			return &amp;ap-&gt;pmp_link[devno].device[0];
 	}
 
<span class="p_header">diff --git a/drivers/ata/pata_hpt366.c b/drivers/ata/pata_hpt366.c</span>
<span class="p_header">index cbc3de793d1d..0038dc4c06c7 100644</span>
<span class="p_header">--- a/drivers/ata/pata_hpt366.c</span>
<span class="p_header">+++ b/drivers/ata/pata_hpt366.c</span>
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> static int hpt36x_init_one(struct pci_dev *dev, const struct pci_device_id *id)</span>
 	};
 	const struct ata_port_info *ppi[] = { &amp;info_hpt366, NULL };
 
<span class="p_del">-	void *hpriv = NULL;</span>
<span class="p_add">+	const void *hpriv = NULL;</span>
 	u32 reg1;
 	int rc;
 
<span class="p_chunk">@@ -383,7 +383,7 @@</span> <span class="p_context"> static int hpt36x_init_one(struct pci_dev *dev, const struct pci_device_id *id)</span>
 		break;
 	}
 	/* Now kick off ATA set up */
<span class="p_del">-	return ata_pci_bmdma_init_one(dev, ppi, &amp;hpt36x_sht, hpriv, 0);</span>
<span class="p_add">+	return ata_pci_bmdma_init_one(dev, ppi, &amp;hpt36x_sht, (void *)hpriv, 0);</span>
 }
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_header">diff --git a/drivers/block/drbd/drbd_bitmap.c b/drivers/block/drbd/drbd_bitmap.c</span>
<span class="p_header">index 1aa29f8fdfe1..7c76f7270bec 100644</span>
<span class="p_header">--- a/drivers/block/drbd/drbd_bitmap.c</span>
<span class="p_header">+++ b/drivers/block/drbd/drbd_bitmap.c</span>
<span class="p_chunk">@@ -478,8 +478,14 @@</span> <span class="p_context"> void drbd_bm_cleanup(struct drbd_device *device)</span>
  * this masks out the remaining bits.
  * Returns the number of bits cleared.
  */
<span class="p_add">+#ifndef BITS_PER_PAGE</span>
 #define BITS_PER_PAGE		(1UL &lt;&lt; (PAGE_SHIFT + 3))
 #define BITS_PER_PAGE_MASK	(BITS_PER_PAGE - 1)
<span class="p_add">+#else</span>
<span class="p_add">+# if BITS_PER_PAGE != (1UL &lt;&lt; (PAGE_SHIFT + 3))</span>
<span class="p_add">+#  error &quot;ambiguous BITS_PER_PAGE&quot;</span>
<span class="p_add">+# endif</span>
<span class="p_add">+#endif</span>
 #define BITS_PER_LONG_MASK	(BITS_PER_LONG - 1)
 static int bm_clear_surplus(struct drbd_bitmap *b)
 {
<span class="p_header">diff --git a/drivers/block/paride/pg.c b/drivers/block/paride/pg.c</span>
<span class="p_header">index 2ce3dfd7e6b9..876d0c3eaf58 100644</span>
<span class="p_header">--- a/drivers/block/paride/pg.c</span>
<span class="p_header">+++ b/drivers/block/paride/pg.c</span>
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"></span>
 
 */
 
<span class="p_del">-static bool verbose = 0;</span>
<span class="p_add">+static int verbose;</span>
 static int major = PG_MAJOR;
 static char *name = PG_NAME;
 static int disable = 0;
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> enum {D_PRT, D_PRO, D_UNI, D_MOD, D_SLV, D_DLY};</span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_del">-module_param(verbose, bool, 0644);</span>
<span class="p_add">+module_param(verbose, int, 0644);</span>
 module_param(major, int, 0);
 module_param(name, charp, 0);
 module_param_array(drive0, int, NULL, 0);
<span class="p_header">diff --git a/drivers/clk/clk-efm32gg.c b/drivers/clk/clk-efm32gg.c</span>
<span class="p_header">index bac2ddf49d02..73a8d0ff530c 100644</span>
<span class="p_header">--- a/drivers/clk/clk-efm32gg.c</span>
<span class="p_header">+++ b/drivers/clk/clk-efm32gg.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"> static struct clk_onecell_data clk_data = {</span>
 	.clk_num = ARRAY_SIZE(clk),
 };
 
<span class="p_del">-static int __init efm32gg_cmu_init(struct device_node *np)</span>
<span class="p_add">+static void __init efm32gg_cmu_init(struct device_node *np)</span>
 {
 	int i;
 	void __iomem *base;
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> static int __init efm32gg_cmu_init(struct device_node *np)</span>
 	base = of_iomap(np, 0);
 	if (!base) {
 		pr_warn(&quot;Failed to map address range for efm32gg,cmu node\n&quot;);
<span class="p_del">-		return -EADDRNOTAVAIL;</span>
<span class="p_add">+		return;</span>
 	}
 
 	clk[clk_HFXO] = clk_register_fixed_rate(NULL, &quot;HFXO&quot;, NULL,
<span class="p_chunk">@@ -76,6 +76,6 @@</span> <span class="p_context"> static int __init efm32gg_cmu_init(struct device_node *np)</span>
 	clk[clk_HFPERCLKDAC0] = clk_register_gate(NULL, &quot;HFPERCLK.DAC0&quot;,
 			&quot;HFXO&quot;, 0, base + CMU_HFPERCLKEN0, 17, 0, NULL);
 
<span class="p_del">-	return of_clk_add_provider(np, of_clk_src_onecell_get, &amp;clk_data);</span>
<span class="p_add">+	of_clk_add_provider(np, of_clk_src_onecell_get, &amp;clk_data);</span>
 }
 CLK_OF_DECLARE(efm32ggcmu, &quot;efm32gg,cmu&quot;, efm32gg_cmu_init);
<span class="p_header">diff --git a/drivers/dma/amba-pl08x.c b/drivers/dma/amba-pl08x.c</span>
<span class="p_header">index 8114731a1c62..8ff32b126605 100644</span>
<span class="p_header">--- a/drivers/dma/amba-pl08x.c</span>
<span class="p_header">+++ b/drivers/dma/amba-pl08x.c</span>
<span class="p_chunk">@@ -1040,7 +1040,7 @@</span> <span class="p_context"> static int pl08x_fill_llis_for_desc(struct pl08x_driver_data *pl08x,</span>
 
 		if (early_bytes) {
 			dev_vdbg(&amp;pl08x-&gt;adev-&gt;dev,
<span class="p_del">-				&quot;%s byte width LLIs (remain 0x%08x)\n&quot;,</span>
<span class="p_add">+				&quot;%s byte width LLIs (remain 0x%08zx)\n&quot;,</span>
 				__func__, bd.remainder);
 			prep_byte_width_lli(pl08x, &amp;bd, &amp;cctl, early_bytes,
 				num_llis++, &amp;total_bytes);
<span class="p_chunk">@@ -1662,7 +1662,7 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *pl08x_prep_dma_cyclic(</span>
 	dma_addr_t slave_addr;
 
 	dev_dbg(&amp;pl08x-&gt;adev-&gt;dev,
<span class="p_del">-		&quot;%s prepare cyclic transaction of %d/%d bytes %s %s\n&quot;,</span>
<span class="p_add">+		&quot;%s prepare cyclic transaction of %zd/%zd bytes %s %s\n&quot;,</span>
 		__func__, period_len, buf_len,
 		direction == DMA_MEM_TO_DEV ? &quot;to&quot; : &quot;from&quot;,
 		plchan-&gt;name);
<span class="p_header">diff --git a/drivers/gpio/gpio-tegra.c b/drivers/gpio/gpio-tegra.c</span>
<span class="p_header">index 4e8fb8261a87..8dc43ac6fa8d 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-tegra.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-tegra.c</span>
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static void tegra_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)</span>
 	struct tegra_gpio_bank *bank;
 	int port;
 	int pin;
<span class="p_del">-	int unmasked = 0;</span>
<span class="p_add">+	bool unmasked = false;</span>
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 
 	chained_irq_enter(chip, desc);
<span class="p_chunk">@@ -291,8 +291,8 @@</span> <span class="p_context"> static void tegra_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)</span>
 			 * before executing the hander so that we don&#39;t
 			 * miss edges
 			 */
<span class="p_del">-			if (lvl &amp; (0x100 &lt;&lt; pin)) {</span>
<span class="p_del">-				unmasked = 1;</span>
<span class="p_add">+			if (!unmasked &amp;&amp; lvl &amp; (0x100 &lt;&lt; pin)) {</span>
<span class="p_add">+				unmasked = true;</span>
 				chained_irq_exit(chip, desc);
 			}
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_gem.c b/drivers/gpu/drm/drm_gem.c</span>
<span class="p_header">index f7d71190aad5..903d059fc7a6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_gem.c</span>
<span class="p_chunk">@@ -698,13 +698,13 @@</span> <span class="p_context"> drm_gem_object_release_handle(int id, void *ptr, void *data)</span>
 	struct drm_gem_object *obj = ptr;
 	struct drm_device *dev = obj-&gt;dev;
 
<span class="p_add">+	if (dev-&gt;driver-&gt;gem_close_object)</span>
<span class="p_add">+		dev-&gt;driver-&gt;gem_close_object(obj, file_priv);</span>
<span class="p_add">+</span>
 	if (drm_core_check_feature(dev, DRIVER_PRIME))
 		drm_gem_remove_prime_handles(obj, file_priv);
 	drm_vma_node_revoke(&amp;obj-&gt;vma_node, file_priv-&gt;filp);
 
<span class="p_del">-	if (dev-&gt;driver-&gt;gem_close_object)</span>
<span class="p_del">-		dev-&gt;driver-&gt;gem_close_object(obj, file_priv);</span>
<span class="p_del">-</span>
 	drm_gem_object_handle_unreference_unlocked(obj);
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c</span>
<span class="p_header">index b8c689202c40..14d2f2cfd88f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_debugfs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_debugfs.c</span>
<span class="p_chunk">@@ -141,10 +141,11 @@</span> <span class="p_context"> describe_obj(struct seq_file *m, struct drm_i915_gem_object *obj)</span>
 		   obj-&gt;madv == I915_MADV_DONTNEED ? &quot; purgeable&quot; : &quot;&quot;);
 	if (obj-&gt;base.name)
 		seq_printf(m, &quot; (name: %d)&quot;, obj-&gt;base.name);
<span class="p_del">-	list_for_each_entry(vma, &amp;obj-&gt;vma_list, vma_link)</span>
<span class="p_add">+	list_for_each_entry(vma, &amp;obj-&gt;vma_list, vma_link) {</span>
 		if (vma-&gt;pin_count &gt; 0)
 			pin_count++;
<span class="p_del">-		seq_printf(m, &quot; (pinned x %d)&quot;, pin_count);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	seq_printf(m, &quot; (pinned x %d)&quot;, pin_count);</span>
 	if (obj-&gt;pin_display)
 		seq_printf(m, &quot; (display)&quot;);
 	if (obj-&gt;fence_reg != I915_FENCE_REG_NONE)
<span class="p_header">diff --git a/drivers/gpu/drm/msm/msm_gem_submit.c b/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_header">index 057951163126..80a708396e49 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/msm/msm_gem_submit.c</span>
<span class="p_chunk">@@ -34,10 +34,13 @@</span> <span class="p_context"> static inline void __user *to_user_ptr(u64 address)</span>
 }
 
 static struct msm_gem_submit *submit_create(struct drm_device *dev,
<span class="p_del">-		struct msm_gpu *gpu, int nr)</span>
<span class="p_add">+		struct msm_gpu *gpu, uint32_t nr)</span>
 {
 	struct msm_gem_submit *submit;
<span class="p_del">-	int sz = sizeof(*submit) + (nr * sizeof(submit-&gt;bos[0]));</span>
<span class="p_add">+	uint64_t sz = sizeof(*submit) + ((u64)nr * sizeof(submit-&gt;bos[0]));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sz &gt; SIZE_MAX)</span>
<span class="p_add">+		return NULL;</span>
 
 	submit = kmalloc(sz, GFP_TEMPORARY | __GFP_NOWARN | __GFP_NORETRY);
 	if (submit) {
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index 118e2206b792..129751121684 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"> static int vmw_cmd_invalid(struct vmw_private *dev_priv,</span>
 			   struct vmw_sw_context *sw_context,
 			   SVGA3dCmdHeader *header)
 {
<span class="p_del">-	return capable(CAP_SYS_ADMIN) ? : -EINVAL;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int vmw_cmd_ok(struct vmw_private *dev_priv,
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">index b8021c499bbd..f2f729adc3fd 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_chunk">@@ -975,6 +975,8 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 	unsigned int rsize = 0;
 	char *rdesc;
 	int ret, n;
<span class="p_add">+	int num_descriptors;</span>
<span class="p_add">+	size_t offset = offsetof(struct hid_descriptor, desc);</span>
 
 	quirks = usbhid_lookup_quirk(le16_to_cpu(dev-&gt;descriptor.idVendor),
 			le16_to_cpu(dev-&gt;descriptor.idProduct));
<span class="p_chunk">@@ -997,10 +999,18 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 		return -ENODEV;
 	}
 
<span class="p_add">+	if (hdesc-&gt;bLength &lt; sizeof(struct hid_descriptor)) {</span>
<span class="p_add">+		dbg_hid(&quot;hid descriptor is too short\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	hid-&gt;version = le16_to_cpu(hdesc-&gt;bcdHID);
 	hid-&gt;country = hdesc-&gt;bCountryCode;
 
<span class="p_del">-	for (n = 0; n &lt; hdesc-&gt;bNumDescriptors; n++)</span>
<span class="p_add">+	num_descriptors = min_t(int, hdesc-&gt;bNumDescriptors,</span>
<span class="p_add">+	       (hdesc-&gt;bLength - offset) / sizeof(struct hid_class_descriptor));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (n = 0; n &lt; num_descriptors; n++)</span>
 		if (hdesc-&gt;desc[n].bDescriptorType == HID_DT_REPORT)
 			rsize = le16_to_cpu(hdesc-&gt;desc[n].wDescriptorLength);
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-ismt.c b/drivers/i2c/busses/i2c-ismt.c</span>
<span class="p_header">index eb3ba56e90b1..51d62e0c1113 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-ismt.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-ismt.c</span>
<span class="p_chunk">@@ -343,6 +343,11 @@</span> <span class="p_context"> static int ismt_process_desc(const struct ismt_desc *desc,</span>
 			data-&gt;word = dma_buffer[0] | (dma_buffer[1] &lt;&lt; 8);
 			break;
 		case I2C_SMBUS_BLOCK_DATA:
<span class="p_add">+			if (desc-&gt;rxbytes != dma_buffer[0] + 1)</span>
<span class="p_add">+				return -EMSGSIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+			memcpy(data-&gt;block, dma_buffer, desc-&gt;rxbytes);</span>
<span class="p_add">+			break;</span>
 		case I2C_SMBUS_I2C_BLOCK_DATA:
 			memcpy(&amp;data-&gt;block[1], dma_buffer, desc-&gt;rxbytes);
 			data-&gt;block[0] = desc-&gt;rxbytes;
<span class="p_header">diff --git a/drivers/i2c/muxes/Kconfig b/drivers/i2c/muxes/Kconfig</span>
<span class="p_header">index f6d313e528de..15248f63583e 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/Kconfig</span>
<span class="p_header">+++ b/drivers/i2c/muxes/Kconfig</span>
<span class="p_chunk">@@ -58,6 +58,6 @@</span> <span class="p_context"> config I2C_MUX_PINCTRL</span>
 	  different sets of pins at run-time.
 
 	  This driver can also be built as a module. If so, the module will be
<span class="p_del">-	  called pinctrl-i2cmux.</span>
<span class="p_add">+	  called i2c-mux-pinctrl.</span>
 
 endmenu
<span class="p_header">diff --git a/drivers/iio/adc/exynos_adc.c b/drivers/iio/adc/exynos_adc.c</span>
<span class="p_header">index 010578f1d762..bb7c50cd3f72 100644</span>
<span class="p_header">--- a/drivers/iio/adc/exynos_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/exynos_adc.c</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> static inline unsigned int exynos_adc_get_version(struct platform_device *pdev)</span>
 	const struct of_device_id *match;
 
 	match = of_match_node(exynos_adc_match, pdev-&gt;dev.of_node);
<span class="p_del">-	return (unsigned int)match-&gt;data;</span>
<span class="p_add">+	return (uintptr_t)match-&gt;data;</span>
 }
 
 static void exynos_adc_hw_init(struct exynos_adc *info)
<span class="p_header">diff --git a/drivers/iio/adc/vf610_adc.c b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">index 0062d0e71d03..fb58b2d11d28 100644</span>
<span class="p_header">--- a/drivers/iio/adc/vf610_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/vf610_adc.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"></span>
 #define VF610_ADC_ADSTS_MASK		0x300
 #define VF610_ADC_ADLPC_EN		0x80
 #define VF610_ADC_ADHSC_EN		0x400
<span class="p_del">-#define VF610_ADC_REFSEL_VALT		0x100</span>
<span class="p_add">+#define VF610_ADC_REFSEL_VALT		0x800</span>
 #define VF610_ADC_REFSEL_VBG		0x1000
 #define VF610_ADC_ADTRG_HARD		0x2000
 #define VF610_ADC_AVGS_8		0x4000
<span class="p_header">diff --git a/drivers/iio/imu/adis16480.c b/drivers/iio/imu/adis16480.c</span>
<span class="p_header">index 5e1b117d4e3b..4f2994a667d0 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis16480.c</span>
<span class="p_header">+++ b/drivers/iio/imu/adis16480.c</span>
<span class="p_chunk">@@ -724,7 +724,7 @@</span> <span class="p_context"> static const struct adis16480_chip_info adis16480_chip_info[] = {</span>
 		.gyro_max_val = IIO_RAD_TO_DEGREE(22500),
 		.gyro_max_scale = 450,
 		.accel_max_val = IIO_M_S_2_TO_G(12500),
<span class="p_del">-		.accel_max_scale = 5,</span>
<span class="p_add">+		.accel_max_scale = 10,</span>
 	},
 	[ADIS16485] = {
 		.channels = adis16485_channels,
<span class="p_header">diff --git a/drivers/iio/light/tsl2563.c b/drivers/iio/light/tsl2563.c</span>
<span class="p_header">index 94daa9fc1247..6a135effb7c5 100644</span>
<span class="p_header">--- a/drivers/iio/light/tsl2563.c</span>
<span class="p_header">+++ b/drivers/iio/light/tsl2563.c</span>
<span class="p_chunk">@@ -626,7 +626,7 @@</span> <span class="p_context"> static irqreturn_t tsl2563_event_handler(int irq, void *private)</span>
 	struct tsl2563_chip *chip = iio_priv(dev_info);
 
 	iio_push_event(dev_info,
<span class="p_del">-		       IIO_UNMOD_EVENT_CODE(IIO_LIGHT,</span>
<span class="p_add">+		       IIO_UNMOD_EVENT_CODE(IIO_INTENSITY,</span>
 					    0,
 					    IIO_EV_TYPE_THRESH,
 					    IIO_EV_DIR_EITHER),
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index fb9bb266a517..bb20bc543a29 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -753,6 +753,8 @@</span> <span class="p_context"> int rdma_init_qp_attr(struct rdma_cm_id *id, struct ib_qp_attr *qp_attr,</span>
 		} else
 			ret = iw_cm_init_qp_attr(id_priv-&gt;cm_id.iw, qp_attr,
 						 qp_attr_mask);
<span class="p_add">+		qp_attr-&gt;port_num = id_priv-&gt;id.port_num;</span>
<span class="p_add">+		*qp_attr_mask |= IB_QP_PORT;</span>
 		break;
 	default:
 		ret = -ENOSYS;
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index ab6326cdde23..622da19f3f21 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -1303,7 +1303,7 @@</span> <span class="p_context"> ssize_t ib_uverbs_resize_cq(struct ib_uverbs_file *file,</span>
 			    int out_len)
 {
 	struct ib_uverbs_resize_cq	cmd;
<span class="p_del">-	struct ib_uverbs_resize_cq_resp	resp;</span>
<span class="p_add">+	struct ib_uverbs_resize_cq_resp	resp = {};</span>
 	struct ib_udata                 udata;
 	struct ib_cq			*cq;
 	int				ret = -EINVAL;
<span class="p_chunk">@@ -1915,7 +1915,8 @@</span> <span class="p_context"> ssize_t ib_uverbs_modify_qp(struct ib_uverbs_file *file,</span>
 		goto out;
 	}
 
<span class="p_del">-	if (!rdma_is_port_valid(qp-&gt;device, cmd.port_num)) {</span>
<span class="p_add">+	if ((cmd.attr_mask &amp; IB_QP_PORT) &amp;&amp;</span>
<span class="p_add">+	    !rdma_is_port_valid(qp-&gt;device, cmd.port_num)) {</span>
 		ret = -EINVAL;
 		goto release_qp;
 	}
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 5bbfd0ecb31a..6354c1c7576f 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -315,6 +315,7 @@</span> <span class="p_context"> static void ib_uverbs_release_file(struct kref *ref)</span>
 	if (atomic_dec_and_test(&amp;file-&gt;device-&gt;refcount))
 		ib_uverbs_comp_dev(file-&gt;device);
 
<span class="p_add">+	kobject_put(&amp;file-&gt;device-&gt;kobj);</span>
 	kfree(file);
 }
 
<span class="p_chunk">@@ -784,7 +785,6 @@</span> <span class="p_context"> static int ib_uverbs_open(struct inode *inode, struct file *filp)</span>
 static int ib_uverbs_close(struct inode *inode, struct file *filp)
 {
 	struct ib_uverbs_file *file = filp-&gt;private_data;
<span class="p_del">-	struct ib_uverbs_device *dev = file-&gt;device;</span>
 
 	ib_uverbs_cleanup_ucontext(file, file-&gt;ucontext);
 
<span class="p_chunk">@@ -792,7 +792,6 @@</span> <span class="p_context"> static int ib_uverbs_close(struct inode *inode, struct file *filp)</span>
 		kref_put(&amp;file-&gt;async_file-&gt;ref, ib_uverbs_release_event_file);
 
 	kref_put(&amp;file-&gt;ref, ib_uverbs_release_file);
<span class="p_del">-	kobject_put(&amp;dev-&gt;kobj);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb3/iwch_provider.c b/drivers/infiniband/hw/cxgb3/iwch_provider.c</span>
<span class="p_header">index 811b24a539c0..736cf45f8c0c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb3/iwch_provider.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb3/iwch_provider.c</span>
<span class="p_chunk">@@ -794,7 +794,7 @@</span> <span class="p_context"> static struct ib_mr *iwch_alloc_fast_reg_mr(struct ib_pd *pd, int pbl_depth)</span>
 	struct iwch_mr *mhp;
 	u32 mmid;
 	u32 stag = 0;
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = -ENOMEM;</span>
 
 	php = to_iwch_pd(pd);
 	rhp = php-&gt;rhp;
<span class="p_chunk">@@ -817,7 +817,8 @@</span> <span class="p_context"> static struct ib_mr *iwch_alloc_fast_reg_mr(struct ib_pd *pd, int pbl_depth)</span>
 	mhp-&gt;attr.state = 1;
 	mmid = (stag) &gt;&gt; 8;
 	mhp-&gt;ibmr.rkey = mhp-&gt;ibmr.lkey = stag;
<span class="p_del">-	if (insert_handle(rhp, &amp;rhp-&gt;mmidr, mhp, mmid))</span>
<span class="p_add">+	ret = insert_handle(rhp, &amp;rhp-&gt;mmidr, mhp, mmid);</span>
<span class="p_add">+	if (ret)</span>
 		goto err3;
 
 	PDBG(&quot;%s mmid 0x%x mhp %p stag 0x%x\n&quot;, __func__, mmid, mhp, stag);
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/cq.c b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">index c04292c950f1..94f7856c3bdb 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/cq.c</span>
<span class="p_chunk">@@ -938,6 +938,7 @@</span> <span class="p_context"> struct ib_cq *c4iw_create_cq(struct ib_device *ibdev, int entries,</span>
 		goto err2;
 
 	if (ucontext) {
<span class="p_add">+		ret = -ENOMEM;</span>
 		mm = kmalloc(sizeof *mm, GFP_KERNEL);
 		if (!mm)
 			goto err3;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mem.c b/drivers/infiniband/hw/mlx5/mem.c</span>
<span class="p_header">index 8499aec94db6..deff377934ff 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mem.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mem.c</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> void mlx5_ib_cont_pages(struct ib_umem *umem, u64 addr, int *count, int *shift,</span>
 		for (k = 0; k &lt; len; k++) {
 			if (!(i &amp; mask)) {
 				tmp = (unsigned long)pfn;
<span class="p_del">-				m = min(m, find_first_bit(&amp;tmp, sizeof(tmp)));</span>
<span class="p_add">+				m = min_t(unsigned long, m, find_first_bit(&amp;tmp, sizeof(tmp)));</span>
 				skip = 1 &lt;&lt; m;
 				mask = skip - 1;
 				base = pfn;
<span class="p_header">diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c</span>
<span class="p_header">index edf6211d84b8..43e6f0572717 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c</span>
<span class="p_chunk">@@ -565,7 +565,8 @@</span> <span class="p_context"> struct ib_pd *ocrdma_alloc_pd(struct ib_device *ibdev,</span>
 	if (is_uctx_pd) {
 		ocrdma_release_ucontext_pd(uctx);
 	} else {
<span class="p_del">-		status = ocrdma_mbx_dealloc_pd(dev, pd);</span>
<span class="p_add">+		if (ocrdma_mbx_dealloc_pd(dev, pd))</span>
<span class="p_add">+			pr_err(&quot;%s: ocrdma_mbx_dealloc_pd() failed\n&quot;, __func__);</span>
 		kfree(pd);
 	}
 exit:
<span class="p_chunk">@@ -1719,6 +1720,7 @@</span> <span class="p_context"> struct ib_srq *ocrdma_create_srq(struct ib_pd *ibpd,</span>
 		goto err;
 
 	if (udata == NULL) {
<span class="p_add">+		status = -ENOMEM;</span>
 		srq-&gt;rqe_wr_id_tbl = kzalloc(sizeof(u64) * srq-&gt;rq.max_cnt,
 			    GFP_KERNEL);
 		if (srq-&gt;rqe_wr_id_tbl == NULL)
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index d7db3486f933..4a5764fe4b23 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -508,7 +508,6 @@</span> <span class="p_context"> static int ipoib_cm_rx_handler(struct ib_cm_id *cm_id,</span>
 	case IB_CM_REQ_RECEIVED:
 		return ipoib_cm_req_handler(cm_id, event);
 	case IB_CM_DREQ_RECEIVED:
<span class="p_del">-		p = cm_id-&gt;context;</span>
 		ib_send_cm_drep(cm_id, NULL, 0);
 		/* Fall through */
 	case IB_CM_REJ_RECEIVED:
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 40be7b4206c0..1370012798cb 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -1235,6 +1235,7 @@</span> <span class="p_context"> static void ipoib_flush_neighs(struct ipoib_dev_priv *priv)</span>
 	int i, wait_flushed = 0;
 
 	init_completion(&amp;priv-&gt;ntbl.flushed);
<span class="p_add">+	set_bit(IPOIB_NEIGH_TBL_FLUSH, &amp;priv-&gt;flags);</span>
 
 	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
<span class="p_chunk">@@ -1279,7 +1280,6 @@</span> <span class="p_context"> static void ipoib_neigh_hash_uninit(struct net_device *dev)</span>
 
 	ipoib_dbg(priv, &quot;ipoib_neigh_hash_uninit\n&quot;);
 	init_completion(&amp;priv-&gt;ntbl.deleted);
<span class="p_del">-	set_bit(IPOIB_NEIGH_TBL_FLUSH, &amp;priv-&gt;flags);</span>
 
 	/* Stop GC if called at init fail need to cancel work */
 	stopped = test_and_set_bit(IPOIB_STOP_NEIGH_GC, &amp;priv-&gt;flags);
<span class="p_chunk">@@ -1768,6 +1768,7 @@</span> <span class="p_context"> static int __init ipoib_init_module(void)</span>
 	ipoib_sendq_size = max3(ipoib_sendq_size, 2 * MAX_SEND_CQE, IPOIB_MIN_QUEUE_SIZE);
 #ifdef CONFIG_INFINIBAND_IPOIB_CM
 	ipoib_max_conn_qp = min(ipoib_max_conn_qp, IPOIB_CM_MAX_CONN_QP);
<span class="p_add">+	ipoib_max_conn_qp = max(ipoib_max_conn_qp, 0);</span>
 #endif
 
 	/*
<span class="p_header">diff --git a/drivers/input/joystick/analog.c b/drivers/input/joystick/analog.c</span>
<span class="p_header">index 9135606c8649..ab0fdcd36e18 100644</span>
<span class="p_header">--- a/drivers/input/joystick/analog.c</span>
<span class="p_header">+++ b/drivers/input/joystick/analog.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> static unsigned int get_time_pit(void)</span>
 #define GET_TIME(x)	rdtscl(x)
 #define DELTA(x,y)	((y)-(x))
 #define TIME_NAME	&quot;TSC&quot;
<span class="p_del">-#elif defined(__alpha__) || defined(CONFIG_MN10300) || defined(CONFIG_ARM) || defined(CONFIG_TILE)</span>
<span class="p_add">+#elif defined(__alpha__) || defined(CONFIG_MN10300) || defined(CONFIG_ARM) || defined(CONFIG_ARM64) || defined(CONFIG_TILE)</span>
 #define GET_TIME(x)	do { x = get_cycles(); } while (0)
 #define DELTA(x,y)	((y)-(x))
 #define TIME_NAME	&quot;get_cycles&quot;
<span class="p_header">diff --git a/drivers/input/mouse/trackpoint.c b/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">index ca843b6cf6bd..db511998fc4c 100644</span>
<span class="p_header">--- a/drivers/input/mouse/trackpoint.c</span>
<span class="p_header">+++ b/drivers/input/mouse/trackpoint.c</span>
<span class="p_chunk">@@ -263,7 +263,8 @@</span> <span class="p_context"> static int trackpoint_start_protocol(struct psmouse *psmouse, unsigned char *fir</span>
 	if (ps2_command(&amp;psmouse-&gt;ps2dev, param, MAKE_PS2_CMD(0, 2, TP_READ_ID)))
 		return -1;
 
<span class="p_del">-	if (param[0] != TP_MAGIC_IDENT)</span>
<span class="p_add">+	/* add new TP ID. */</span>
<span class="p_add">+	if (!(param[0] &amp; TP_MAGIC_IDENT))</span>
 		return -1;
 
 	if (firmware_id)
<span class="p_header">diff --git a/drivers/input/mouse/trackpoint.h b/drivers/input/mouse/trackpoint.h</span>
<span class="p_header">index ecd0547964a5..2d7be0435957 100644</span>
<span class="p_header">--- a/drivers/input/mouse/trackpoint.h</span>
<span class="p_header">+++ b/drivers/input/mouse/trackpoint.h</span>
<span class="p_chunk">@@ -21,8 +21,9 @@</span> <span class="p_context"></span>
 #define TP_COMMAND		0xE2	/* Commands start with this */
 
 #define TP_READ_ID		0xE1	/* Sent for device identification */
<span class="p_del">-#define TP_MAGIC_IDENT		0x01	/* Sent after a TP_READ_ID followed */</span>
<span class="p_add">+#define TP_MAGIC_IDENT		0x03	/* Sent after a TP_READ_ID followed */</span>
 					/* by the firmware ID */
<span class="p_add">+					/* Firmware ID includes 0x1, 0x2, 0x3 */</span>
 
 
 /*
<span class="p_header">diff --git a/drivers/input/serio/gscps2.c b/drivers/input/serio/gscps2.c</span>
<span class="p_header">index 8d9ba0c3827c..94ab494a6ade 100644</span>
<span class="p_header">--- a/drivers/input/serio/gscps2.c</span>
<span class="p_header">+++ b/drivers/input/serio/gscps2.c</span>
<span class="p_chunk">@@ -40,7 +40,6 @@</span> <span class="p_context"></span>
 MODULE_AUTHOR(&quot;Laurent Canet &lt;canetl@esiee.fr&gt;, Thibaut Varene &lt;varenet@parisc-linux.org&gt;, Helge Deller &lt;deller@gmx.de&gt;&quot;);
 MODULE_DESCRIPTION(&quot;HP GSC PS2 port driver&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_del">-MODULE_DEVICE_TABLE(parisc, gscps2_device_tbl);</span>
 
 #define PFX &quot;gscps2.c: &quot;
 
<span class="p_chunk">@@ -439,6 +438,7 @@</span> <span class="p_context"> static struct parisc_device_id gscps2_device_tbl[] = {</span>
 #endif
 	{ 0, }	/* 0 terminated list */
 };
<span class="p_add">+MODULE_DEVICE_TABLE(parisc, gscps2_device_tbl);</span>
 
 static struct parisc_driver parisc_ps2_driver = {
 	.name		= &quot;gsc_ps2&quot;,
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c</span>
<span class="p_header">index 69f1b6adb904..48b726f4ad48 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_init.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_init.c</span>
<span class="p_chunk">@@ -2027,11 +2027,11 @@</span> <span class="p_context"> static int __init state_next(void)</span>
 		break;
 	case IOMMU_ACPI_FINISHED:
 		early_enable_iommus();
<span class="p_del">-		register_syscore_ops(&amp;amd_iommu_syscore_ops);</span>
 		x86_platform.iommu_shutdown = disable_iommus;
 		init_state = IOMMU_ENABLED;
 		break;
 	case IOMMU_ENABLED:
<span class="p_add">+		register_syscore_ops(&amp;amd_iommu_syscore_ops);</span>
 		ret = amd_iommu_init_pci();
 		init_state = ret ? IOMMU_INIT_ERROR : IOMMU_PCI_INIT;
 		enable_iommus_v2();
<span class="p_header">diff --git a/drivers/irqchip/irq-brcmstb-l2.c b/drivers/irqchip/irq-brcmstb-l2.c</span>
<span class="p_header">index c15c840987d2..94a15ae52212 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-brcmstb-l2.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-brcmstb-l2.c</span>
<span class="p_chunk">@@ -176,6 +176,7 @@</span> <span class="p_context"> int __init brcmstb_l2_intc_of_init(struct device_node *np,</span>
 
 	ct-&gt;chip.irq_suspend = brcmstb_l2_intc_suspend;
 	ct-&gt;chip.irq_resume = brcmstb_l2_intc_resume;
<span class="p_add">+	ct-&gt;chip.irq_pm_shutdown = brcmstb_l2_intc_suspend;</span>
 
 	if (of_property_read_bool(np, &quot;brcm,irq-can-wake&quot;)) {
 		data-&gt;can_wake = true;
<span class="p_header">diff --git a/drivers/isdn/hardware/mISDN/mISDNipac.c b/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_header">index 92cf6fcd20ac..cb428b9ee441 100644</span>
<span class="p_header">--- a/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_header">+++ b/drivers/isdn/hardware/mISDN/mISDNipac.c</span>
<span class="p_chunk">@@ -754,10 +754,10 @@</span> <span class="p_context"> dbusy_timer_handler(struct isac_hw *isac)</span>
 }
 
 static int
<span class="p_del">-open_dchannel(struct isac_hw *isac, struct channel_req *rq)</span>
<span class="p_add">+open_dchannel_caller(struct isac_hw *isac, struct channel_req *rq, void *caller)</span>
 {
 	pr_debug(&quot;%s: %s dev(%d) open from %p\n&quot;, isac-&gt;name, __func__,
<span class="p_del">-		 isac-&gt;dch.dev.id, __builtin_return_address(1));</span>
<span class="p_add">+		 isac-&gt;dch.dev.id, caller);</span>
 	if (rq-&gt;protocol != ISDN_P_TE_S0)
 		return -EINVAL;
 	if (rq-&gt;adr.channel == 1)
<span class="p_chunk">@@ -771,6 +771,12 @@</span> <span class="p_context"> open_dchannel(struct isac_hw *isac, struct channel_req *rq)</span>
 	return 0;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+open_dchannel(struct isac_hw *isac, struct channel_req *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return open_dchannel_caller(isac, rq, __builtin_return_address(0));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const char *ISACVer[] =
 {&quot;2086/2186 V1.1&quot;, &quot;2085 B1&quot;, &quot;2085 B2&quot;,
  &quot;2085 V2.3&quot;};
<span class="p_chunk">@@ -1547,7 +1553,7 @@</span> <span class="p_context"> ipac_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)</span>
 	case OPEN_CHANNEL:
 		rq = arg;
 		if (rq-&gt;protocol == ISDN_P_TE_S0)
<span class="p_del">-			err = open_dchannel(isac, rq);</span>
<span class="p_add">+			err = open_dchannel_caller(isac, rq, __builtin_return_address(0));</span>
 		else
 			err = open_bchannel(ipac, rq);
 		if (err)
<span class="p_header">diff --git a/drivers/isdn/hardware/mISDN/w6692.c b/drivers/isdn/hardware/mISDN/w6692.c</span>
<span class="p_header">index de69f6828c76..741675525b53 100644</span>
<span class="p_header">--- a/drivers/isdn/hardware/mISDN/w6692.c</span>
<span class="p_header">+++ b/drivers/isdn/hardware/mISDN/w6692.c</span>
<span class="p_chunk">@@ -1176,10 +1176,10 @@</span> <span class="p_context"> w6692_l1callback(struct dchannel *dch, u32 cmd)</span>
 }
 
 static int
<span class="p_del">-open_dchannel(struct w6692_hw *card, struct channel_req *rq)</span>
<span class="p_add">+open_dchannel(struct w6692_hw *card, struct channel_req *rq, void *caller)</span>
 {
 	pr_debug(&quot;%s: %s dev(%d) open from %p\n&quot;, card-&gt;name, __func__,
<span class="p_del">-		 card-&gt;dch.dev.id, __builtin_return_address(1));</span>
<span class="p_add">+		 card-&gt;dch.dev.id, caller);</span>
 	if (rq-&gt;protocol != ISDN_P_TE_S0)
 		return -EINVAL;
 	if (rq-&gt;adr.channel == 1)
<span class="p_chunk">@@ -1207,7 +1207,7 @@</span> <span class="p_context"> w6692_dctrl(struct mISDNchannel *ch, u32 cmd, void *arg)</span>
 	case OPEN_CHANNEL:
 		rq = arg;
 		if (rq-&gt;protocol == ISDN_P_TE_S0)
<span class="p_del">-			err = open_dchannel(card, rq);</span>
<span class="p_add">+			err = open_dchannel(card, rq, __builtin_return_address(0));</span>
 		else
 			err = open_bchannel(card, rq);
 		if (err)
<span class="p_header">diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c</span>
<span class="p_header">index 08ae5b492bc4..c0e44d210326 100644</span>
<span class="p_header">--- a/drivers/md/dm-bufio.c</span>
<span class="p_header">+++ b/drivers/md/dm-bufio.c</span>
<span class="p_chunk">@@ -349,6 +349,7 @@</span> <span class="p_context"> static void *alloc_buffer_data(struct dm_bufio_client *c, gfp_t gfp_mask,</span>
 	 * as if GFP_NOIO was specified.
 	 */
 
<span class="p_add">+	noio_flag = 0;</span>
 	if (gfp_mask &amp; __GFP_NORETRY)
 		noio_flag = memalloc_noio_save();
 
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 4f0773c8ad20..98a47dbf48c2 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -24,16 +24,6 @@</span> <span class="p_context"></span>
 
 #define DM_MSG_PREFIX &quot;core&quot;
 
<span class="p_del">-#ifdef CONFIG_PRINTK</span>
<span class="p_del">-/*</span>
<span class="p_del">- * ratelimit state to be used in DMXXX_LIMIT().</span>
<span class="p_del">- */</span>
<span class="p_del">-DEFINE_RATELIMIT_STATE(dm_ratelimit_state,</span>
<span class="p_del">-		       DEFAULT_RATELIMIT_INTERVAL,</span>
<span class="p_del">-		       DEFAULT_RATELIMIT_BURST);</span>
<span class="p_del">-EXPORT_SYMBOL(dm_ratelimit_state);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /*
  * Cookies are numeric values sent with CHANGE and REMOVE
  * uevents while resuming, removing or renaming the device.
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 16789320135f..affe5d3e768b 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -5240,6 +5240,8 @@</span> <span class="p_context"> static void raid5_do_work(struct work_struct *work)</span>
 	pr_debug(&quot;%d stripes handled\n&quot;, handled);
 
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
<span class="p_add">+</span>
<span class="p_add">+	async_tx_issue_pending_all();</span>
 	blk_finish_plug(&amp;plug);
 
 	pr_debug(&quot;--- raid5worker inactive\n&quot;);
<span class="p_chunk">@@ -6741,12 +6743,10 @@</span> <span class="p_context"> static void end_reshape(struct r5conf *conf)</span>
 {
 
 	if (!test_bit(MD_RECOVERY_INTR, &amp;conf-&gt;mddev-&gt;recovery)) {
<span class="p_del">-		struct md_rdev *rdev;</span>
 
 		spin_lock_irq(&amp;conf-&gt;device_lock);
 		conf-&gt;previous_raid_disks = conf-&gt;raid_disks;
<span class="p_del">-		rdev_for_each(rdev, conf-&gt;mddev)</span>
<span class="p_del">-			rdev-&gt;data_offset = rdev-&gt;new_data_offset;</span>
<span class="p_add">+		md_finish_reshape(conf-&gt;mddev);</span>
 		smp_wmb();
 		conf-&gt;reshape_progress = MaxSector;
 		spin_unlock_irq(&amp;conf-&gt;device_lock);
<span class="p_header">diff --git a/drivers/media/platform/davinci/vpfe_capture.c b/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_header">index ff10c2e90a5a..93a374fcced8 100644</span>
<span class="p_header">--- a/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_header">+++ b/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_chunk">@@ -1708,27 +1708,9 @@</span> <span class="p_context"> static long vpfe_param_handler(struct file *file, void *priv,</span>
 
 	switch (cmd) {
 	case VPFE_CMD_S_CCDC_RAW_PARAMS:
<span class="p_add">+		ret = -EINVAL;</span>
 		v4l2_warn(&amp;vpfe_dev-&gt;v4l2_dev,
<span class="p_del">-			  &quot;VPFE_CMD_S_CCDC_RAW_PARAMS: experimental ioctl\n&quot;);</span>
<span class="p_del">-		if (ccdc_dev-&gt;hw_ops.set_params) {</span>
<span class="p_del">-			ret = ccdc_dev-&gt;hw_ops.set_params(param);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				v4l2_dbg(1, debug, &amp;vpfe_dev-&gt;v4l2_dev,</span>
<span class="p_del">-					&quot;Error setting parameters in CCDC\n&quot;);</span>
<span class="p_del">-				goto unlock_out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			ret = vpfe_get_ccdc_image_format(vpfe_dev,</span>
<span class="p_del">-							 &amp;vpfe_dev-&gt;fmt);</span>
<span class="p_del">-			if (ret &lt; 0) {</span>
<span class="p_del">-				v4l2_dbg(1, debug, &amp;vpfe_dev-&gt;v4l2_dev,</span>
<span class="p_del">-					&quot;Invalid image format at CCDC\n&quot;);</span>
<span class="p_del">-				goto unlock_out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			v4l2_dbg(1, debug, &amp;vpfe_dev-&gt;v4l2_dev,</span>
<span class="p_del">-				&quot;VPFE_CMD_S_CCDC_RAW_PARAMS not supported\n&quot;);</span>
<span class="p_del">-		}</span>
<span class="p_add">+			&quot;VPFE_CMD_S_CCDC_RAW_PARAMS not supported\n&quot;);</span>
 		break;
 	default:
 		ret = -ENOTTY;
<span class="p_header">diff --git a/drivers/media/rc/ir-lirc-codec.c b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">index 2af2326ab3d2..33d6c05352a2 100644</span>
<span class="p_header">--- a/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">+++ b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static long ir_lirc_ioctl(struct file *filep, unsigned int cmd,</span>
 		return 0;
 
 	case LIRC_GET_REC_RESOLUTION:
<span class="p_del">-		val = dev-&gt;rx_resolution;</span>
<span class="p_add">+		val = dev-&gt;rx_resolution / 1000;</span>
 		break;
 
 	case LIRC_SET_WIDEBAND_RECEIVER:
<span class="p_header">diff --git a/drivers/message/i2o/i2o_config.c b/drivers/message/i2o/i2o_config.c</span>
<span class="p_header">index 04bd3b6de401..67ceb3010a10 100644</span>
<span class="p_header">--- a/drivers/message/i2o/i2o_config.c</span>
<span class="p_header">+++ b/drivers/message/i2o/i2o_config.c</span>
<span class="p_chunk">@@ -772,7 +772,7 @@</span> <span class="p_context"> static long i2o_cfg_compat_ioctl(struct file *file, unsigned cmd,</span>
 
 #endif
 
<span class="p_del">-#ifdef CONFIG_I2O_EXT_ADAPTEC</span>
<span class="p_add">+#if defined(CONFIG_I2O_EXT_ADAPTEC) &amp;&amp; !defined(CONFIG_64BIT)</span>
 static int i2o_cfg_passthru(unsigned long arg)
 {
 	struct i2o_cmd_passthru __user *cmd =
<span class="p_chunk">@@ -1045,7 +1045,7 @@</span> <span class="p_context"> static long i2o_cfg_ioctl(struct file *fp, unsigned int cmd, unsigned long arg)</span>
 		ret = i2o_cfg_evt_get(arg, fp);
 		break;
 
<span class="p_del">-#ifdef CONFIG_I2O_EXT_ADAPTEC</span>
<span class="p_add">+#if defined(CONFIG_I2O_EXT_ADAPTEC) &amp;&amp; !defined(CONFIG_64BIT)</span>
 	case I2OPASSTHRU:
 		ret = i2o_cfg_passthru(arg);
 		break;
<span class="p_header">diff --git a/drivers/mfd/arizona-core.c b/drivers/mfd/arizona-core.c</span>
<span class="p_header">index 1577e6418306..c39d119b4cbd 100644</span>
<span class="p_header">--- a/drivers/mfd/arizona-core.c</span>
<span class="p_header">+++ b/drivers/mfd/arizona-core.c</span>
<span class="p_chunk">@@ -497,12 +497,12 @@</span> <span class="p_context"> const struct dev_pm_ops arizona_pm_ops = {</span>
 EXPORT_SYMBOL_GPL(arizona_pm_ops);
 
 #ifdef CONFIG_OF
<span class="p_del">-int arizona_of_get_type(struct device *dev)</span>
<span class="p_add">+unsigned long arizona_of_get_type(struct device *dev)</span>
 {
 	const struct of_device_id *id = of_match_device(arizona_of_match, dev);
 
 	if (id)
<span class="p_del">-		return (int)id-&gt;data;</span>
<span class="p_add">+		return (unsigned long)id-&gt;data;</span>
 	else
 		return 0;
 }
<span class="p_header">diff --git a/drivers/mfd/arizona-i2c.c b/drivers/mfd/arizona-i2c.c</span>
<span class="p_header">index beccb790c9ba..9d4156fb082a 100644</span>
<span class="p_header">--- a/drivers/mfd/arizona-i2c.c</span>
<span class="p_header">+++ b/drivers/mfd/arizona-i2c.c</span>
<span class="p_chunk">@@ -24,11 +24,12 @@</span> <span class="p_context"></span>
 #include &quot;arizona.h&quot;
 
 static int arizona_i2c_probe(struct i2c_client *i2c,
<span class="p_del">-					  const struct i2c_device_id *id)</span>
<span class="p_add">+			     const struct i2c_device_id *id)</span>
 {
 	struct arizona *arizona;
 	const struct regmap_config *regmap_config;
<span class="p_del">-	int ret, type;</span>
<span class="p_add">+	unsigned long type;</span>
<span class="p_add">+	int ret;</span>
 
 	if (i2c-&gt;dev.of_node)
 		type = arizona_of_get_type(&amp;i2c-&gt;dev);
<span class="p_header">diff --git a/drivers/mfd/arizona-spi.c b/drivers/mfd/arizona-spi.c</span>
<span class="p_header">index 1ca554b18bef..5145d78bf07e 100644</span>
<span class="p_header">--- a/drivers/mfd/arizona-spi.c</span>
<span class="p_header">+++ b/drivers/mfd/arizona-spi.c</span>
<span class="p_chunk">@@ -28,7 +28,8 @@</span> <span class="p_context"> static int arizona_spi_probe(struct spi_device *spi)</span>
 	const struct spi_device_id *id = spi_get_device_id(spi);
 	struct arizona *arizona;
 	const struct regmap_config *regmap_config;
<span class="p_del">-	int ret, type;</span>
<span class="p_add">+	unsigned long type;</span>
<span class="p_add">+	int ret;</span>
 
 	if (spi-&gt;dev.of_node)
 		type = arizona_of_get_type(&amp;spi-&gt;dev);
<span class="p_header">diff --git a/drivers/mfd/arizona.h b/drivers/mfd/arizona.h</span>
<span class="p_header">index b4cef777df73..2951498ab9a1 100644</span>
<span class="p_header">--- a/drivers/mfd/arizona.h</span>
<span class="p_header">+++ b/drivers/mfd/arizona.h</span>
<span class="p_chunk">@@ -46,9 +46,9 @@</span> <span class="p_context"> int arizona_irq_init(struct arizona *arizona);</span>
 int arizona_irq_exit(struct arizona *arizona);
 
 #ifdef CONFIG_OF
<span class="p_del">-int arizona_of_get_type(struct device *dev);</span>
<span class="p_add">+unsigned long arizona_of_get_type(struct device *dev);</span>
 #else
<span class="p_del">-static inline int arizona_of_get_type(struct device *dev)</span>
<span class="p_add">+static inline unsigned long arizona_of_get_type(struct device *dev)</span>
 {
 	return 0;
 }
<span class="p_header">diff --git a/drivers/mtd/maps/pmcmsp-flash.c b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">index f9fa3fad728e..2051f28ddac6 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_chunk">@@ -139,15 +139,13 @@</span> <span class="p_context"> static int __init init_msp_flash(void)</span>
 		}
 
 		msp_maps[i].bankwidth = 1;
<span class="p_del">-		msp_maps[i].name = kmalloc(7, GFP_KERNEL);</span>
<span class="p_add">+		msp_maps[i].name = kstrndup(flash_name, 7, GFP_KERNEL);</span>
 		if (!msp_maps[i].name) {
 			iounmap(msp_maps[i].virt);
 			kfree(msp_parts[i]);
 			goto cleanup_loop;
 		}
 
<span class="p_del">-		msp_maps[i].name = strncpy(msp_maps[i].name, flash_name, 7);</span>
<span class="p_del">-</span>
 		for (j = 0; j &lt; pcnt; j++) {
 			part_name[5] = &#39;0&#39; + i;
 			part_name[7] = &#39;0&#39; + j;
<span class="p_header">diff --git a/drivers/mtd/maps/rbtx4939-flash.c b/drivers/mtd/maps/rbtx4939-flash.c</span>
<span class="p_header">index 146b6047ed2b..a84fdfb10518 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/rbtx4939-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/rbtx4939-flash.c</span>
<span class="p_chunk">@@ -35,8 +35,6 @@</span> <span class="p_context"> static int rbtx4939_flash_remove(struct platform_device *dev)</span>
 		return 0;
 
 	if (info-&gt;mtd) {
<span class="p_del">-		struct rbtx4939_flash_data *pdata = dev_get_platdata(&amp;dev-&gt;dev);</span>
<span class="p_del">-</span>
 		mtd_device_unregister(info-&gt;mtd);
 		map_destroy(info-&gt;mtd);
 	}
<span class="p_header">diff --git a/drivers/mtd/nand/nandsim.c b/drivers/mtd/nand/nandsim.c</span>
<span class="p_header">index 4f0d83648e5a..9a7d0f3081fe 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nandsim.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nandsim.c</span>
<span class="p_chunk">@@ -2387,6 +2387,7 @@</span> <span class="p_context"> static int __init ns_init_module(void)</span>
         return 0;
 
 err_exit:
<span class="p_add">+	nandsim_debugfs_remove(nand);</span>
 	free_nandsim(nand);
 	nand_release(nsmtd);
 	for (i = 0;i &lt; ARRAY_SIZE(nand-&gt;partitions); ++i)
<span class="p_header">diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig</span>
<span class="p_header">index 3fdfe317a6c5..b7e2fb72578d 100644</span>
<span class="p_header">--- a/drivers/net/Kconfig</span>
<span class="p_header">+++ b/drivers/net/Kconfig</span>
<span class="p_chunk">@@ -331,6 +331,9 @@</span> <span class="p_context"> config XEN_NETDEV_FRONTEND</span>
 config XEN_NETDEV_BACKEND
 	tristate &quot;Xen backend network device&quot;
 	depends on XEN_BACKEND
<span class="p_add">+	depends on !(PAGE_SIZE_64KB || ARM64_64K_PAGES || \</span>
<span class="p_add">+		     IA64_PAGE_SIZE_64KB || MICROBLAZE_64K_PAGES || \</span>
<span class="p_add">+		     PARISC_PAGE_SIZE_64KB || PPC_64K_PAGES)</span>
 	help
 	  This driver allows the kernel to act as a Xen network driver
 	  domain which exports paravirtual network devices to other
<span class="p_header">diff --git a/drivers/net/ethernet/amd/amd8111e.c b/drivers/net/ethernet/amd/amd8111e.c</span>
<span class="p_header">index 068dc7cad5fa..47b34f7c4512 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/amd8111e.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/amd8111e.c</span>
<span class="p_chunk">@@ -101,7 +101,6 @@</span> <span class="p_context"></span>
 MODULE_AUTHOR(&quot;Advanced Micro Devices, Inc.&quot;);
 MODULE_DESCRIPTION (&quot;AMD8111 based 10/100 Ethernet Controller. Driver Version &quot;MODULE_VERS);
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_del">-MODULE_DEVICE_TABLE(pci, amd8111e_pci_tbl);</span>
 module_param_array(speed_duplex, int, NULL, 0);
 MODULE_PARM_DESC(speed_duplex, &quot;Set device speed and duplex modes, 0: Auto Negotiate, 1: 10Mbps Half Duplex, 2: 10Mbps Full Duplex, 3: 100Mbps Half Duplex, 4: 100Mbps Full Duplex&quot;);
 module_param_array(coalesce, bool, NULL, 0);
<span class="p_chunk">@@ -109,13 +108,6 @@</span> <span class="p_context"> MODULE_PARM_DESC(coalesce, &quot;Enable or Disable interrupt coalescing, 1: Enable, 0</span>
 module_param_array(dynamic_ipg, bool, NULL, 0);
 MODULE_PARM_DESC(dynamic_ipg, &quot;Enable or Disable dynamic IPG, 1: Enable, 0: Disable&quot;);
 
<span class="p_del">-static DEFINE_PCI_DEVICE_TABLE(amd8111e_pci_tbl) = {</span>
<span class="p_del">-</span>
<span class="p_del">-	{ PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD8111E_7462,</span>
<span class="p_del">-	 PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },</span>
<span class="p_del">-	{ 0, }</span>
<span class="p_del">-</span>
<span class="p_del">-};</span>
 /*
 This function will read the PHY registers.
 */
<span class="p_chunk">@@ -1970,6 +1962,17 @@</span> <span class="p_context"> static int amd8111e_probe_one(struct pci_dev *pdev,</span>
 
 }
 
<span class="p_add">+static const struct pci_device_id amd8111e_pci_tbl[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 .vendor = PCI_VENDOR_ID_AMD,</span>
<span class="p_add">+	 .device = PCI_DEVICE_ID_AMD8111E_7462,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 .vendor = 0,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+MODULE_DEVICE_TABLE(pci, amd8111e_pci_tbl);</span>
<span class="p_add">+</span>
 static struct pci_driver amd8111e_driver = {
 	.name   	= MODULE_NAME,
 	.id_table	= amd8111e_pci_tbl,
<span class="p_header">diff --git a/drivers/net/ethernet/amd/nmclan_cs.c b/drivers/net/ethernet/amd/nmclan_cs.c</span>
<span class="p_header">index abf3b1581c82..27245efe9f50 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/nmclan_cs.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/nmclan_cs.c</span>
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> static int nmclan_config(struct pcmcia_device *link)</span>
   ret = pcmcia_request_io(link);
   if (ret)
 	  goto failed;
<span class="p_del">-  ret = pcmcia_request_exclusive_irq(link, mace_interrupt);</span>
<span class="p_add">+  ret = pcmcia_request_irq(link, mace_interrupt);</span>
   if (ret)
 	  goto failed;
   ret = pcmcia_enable_device(link);
<span class="p_chunk">@@ -952,6 +952,8 @@</span> <span class="p_context"> static irqreturn_t mace_interrupt(int irq, void *dev_id)</span>
   do {
     /* WARNING: MACE_IR is a READ/CLEAR port! */
     status = inb(ioaddr + AM2150_MACE_BASE + MACE_IR);
<span class="p_add">+    if (!(status &amp; ~MACE_IMR_DEFAULT) &amp;&amp; IntrCnt == MACE_MAX_IR_ITERATIONS)</span>
<span class="p_add">+      return IRQ_NONE;</span>
 
     pr_debug(&quot;mace_interrupt: irq 0x%X status 0x%X.\n&quot;, irq, status);
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/b44.c b/drivers/net/ethernet/broadcom/b44.c</span>
<span class="p_header">index ca5a20a48b14..0a89c66c0264 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/b44.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/b44.c</span>
<span class="p_chunk">@@ -2372,6 +2372,7 @@</span> <span class="p_context"> static int b44_init_one(struct ssb_device *sdev,</span>
 	bp-&gt;msg_enable = netif_msg_init(b44_debug, B44_DEF_MSG_ENABLE);
 
 	spin_lock_init(&amp;bp-&gt;lock);
<span class="p_add">+	u64_stats_init(&amp;bp-&gt;hw_stats.syncp);</span>
 
 	bp-&gt;rx_pending = B44_DEF_RX_RING_PENDING;
 	bp-&gt;tx_pending = B44_DEF_TX_RING_PENDING;
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">index 4d762138eb39..c2b5d3b74c5f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static void bcm_sysport_get_stats(struct net_device *dev,</span>
 
 static void bcm_sysport_free_cb(struct bcm_sysport_cb *cb)
 {
<span class="p_del">-	dev_kfree_skb_any(cb-&gt;skb);</span>
<span class="p_add">+	dev_consume_skb_any(cb-&gt;skb);</span>
 	cb-&gt;skb = NULL;
 	dma_unmap_addr_set(cb, dma_addr, 0);
 }
<span class="p_chunk">@@ -1024,6 +1024,8 @@</span> <span class="p_context"> static int bcm_sysport_init_tx_ring(struct bcm_sysport_priv *priv,</span>
 
 	ring-&gt;cbs = kzalloc(sizeof(struct bcm_sysport_cb) * size, GFP_KERNEL);
 	if (!ring-&gt;cbs) {
<span class="p_add">+		dma_free_coherent(kdev, sizeof(struct dma_desc),</span>
<span class="p_add">+				  ring-&gt;desc_cpu, ring-&gt;desc_dma);</span>
 		netif_err(priv, hw, priv-&gt;netdev, &quot;CB allocation failed\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">index 18ef92e2d5dd..f22654e2060d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_chunk">@@ -900,12 +900,21 @@</span> <span class="p_context"> static struct enet_cb *bcmgenet_get_txcb(struct bcmgenet_priv *priv,</span>
 	return tx_cb_ptr;
 }
 
<span class="p_del">-/* Simple helper to free a control block&#39;s resources */</span>
<span class="p_del">-static void bcmgenet_free_cb(struct enet_cb *cb)</span>
<span class="p_add">+static struct enet_cb *bcmgenet_put_txcb(struct bcmgenet_priv *priv,</span>
<span class="p_add">+					 struct bcmgenet_tx_ring *ring)</span>
 {
<span class="p_del">-	dev_kfree_skb_any(cb-&gt;skb);</span>
<span class="p_del">-	cb-&gt;skb = NULL;</span>
<span class="p_del">-	dma_unmap_addr_set(cb, dma_addr, 0);</span>
<span class="p_add">+	struct enet_cb *tx_cb_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	tx_cb_ptr = ring-&gt;cbs;</span>
<span class="p_add">+	tx_cb_ptr += ring-&gt;write_ptr - ring-&gt;cb_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Rewinding local write pointer */</span>
<span class="p_add">+	if (ring-&gt;write_ptr == ring-&gt;cb_ptr)</span>
<span class="p_add">+		ring-&gt;write_ptr = ring-&gt;end_ptr;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ring-&gt;write_ptr--;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tx_cb_ptr;</span>
 }
 
 static inline void bcmgenet_tx_ring16_int_disable(struct bcmgenet_priv *priv,
<span class="p_chunk">@@ -940,69 +949,116 @@</span> <span class="p_context"> static inline void bcmgenet_tx_ring_int_disable(struct bcmgenet_priv *priv,</span>
 	priv-&gt;int1_mask |= (1 &lt;&lt; ring-&gt;index);
 }
 
<span class="p_add">+/* Simple helper to free a transmit control block&#39;s resources</span>
<span class="p_add">+ * Returns an skb when the last transmit control block associated with the</span>
<span class="p_add">+ * skb is freed.  The skb should be freed by the caller if necessary.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct sk_buff *bcmgenet_free_tx_cb(struct device *dev,</span>
<span class="p_add">+					   struct enet_cb *cb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb = cb-&gt;skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb) {</span>
<span class="p_add">+		cb-&gt;skb = NULL;</span>
<span class="p_add">+		if (cb == GENET_CB(skb)-&gt;first_cb)</span>
<span class="p_add">+			dma_unmap_single(dev, dma_unmap_addr(cb, dma_addr),</span>
<span class="p_add">+					 dma_unmap_len(cb, dma_len),</span>
<span class="p_add">+					 DMA_TO_DEVICE);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dma_unmap_page(dev, dma_unmap_addr(cb, dma_addr),</span>
<span class="p_add">+				       dma_unmap_len(cb, dma_len),</span>
<span class="p_add">+				       DMA_TO_DEVICE);</span>
<span class="p_add">+		dma_unmap_addr_set(cb, dma_addr, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (cb == GENET_CB(skb)-&gt;last_cb)</span>
<span class="p_add">+			return skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (dma_unmap_addr(cb, dma_addr)) {</span>
<span class="p_add">+		dma_unmap_page(dev,</span>
<span class="p_add">+			       dma_unmap_addr(cb, dma_addr),</span>
<span class="p_add">+			       dma_unmap_len(cb, dma_len),</span>
<span class="p_add">+			       DMA_TO_DEVICE);</span>
<span class="p_add">+		dma_unmap_addr_set(cb, dma_addr, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Simple helper to free a receive control block&#39;s resources */</span>
<span class="p_add">+static struct sk_buff *bcmgenet_free_rx_cb(struct device *dev,</span>
<span class="p_add">+					   struct enet_cb *cb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb = cb-&gt;skb;</span>
<span class="p_add">+	cb-&gt;skb = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dma_unmap_addr(cb, dma_addr)) {</span>
<span class="p_add">+		dma_unmap_single(dev, dma_unmap_addr(cb, dma_addr),</span>
<span class="p_add">+				 dma_unmap_len(cb, dma_len), DMA_FROM_DEVICE);</span>
<span class="p_add">+		dma_unmap_addr_set(cb, dma_addr, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return skb;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Unlocked version of the reclaim routine */
 static void __bcmgenet_tx_reclaim(struct net_device *dev,
 				struct bcmgenet_tx_ring *ring)
 {
 	struct bcmgenet_priv *priv = netdev_priv(dev);
<span class="p_del">-	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
<span class="p_del">-	int last_tx_cn, last_c_index, num_tx_bds;</span>
<span class="p_del">-	struct enet_cb *tx_cb_ptr;</span>
 	struct netdev_queue *txq;
<span class="p_add">+	unsigned int txbds_processed = 0;</span>
<span class="p_add">+	unsigned int bytes_compl = 0;</span>
<span class="p_add">+	unsigned int pkts_compl = 0;</span>
<span class="p_add">+	unsigned int txbds_ready;</span>
 	unsigned int c_index;
<span class="p_add">+	struct sk_buff *skb;</span>
 
 	/* Compute how many buffers are transmited since last xmit call */
 	c_index = bcmgenet_tdma_ring_readl(priv, ring-&gt;index, TDMA_CONS_INDEX);
<span class="p_del">-	txq = netdev_get_tx_queue(dev, ring-&gt;queue);</span>
<span class="p_del">-</span>
<span class="p_del">-	last_c_index = ring-&gt;c_index;</span>
<span class="p_del">-	num_tx_bds = ring-&gt;size;</span>
<span class="p_del">-</span>
<span class="p_del">-	c_index &amp;= (num_tx_bds - 1);</span>
<span class="p_add">+	c_index &amp;= DMA_C_INDEX_MASK;</span>
 
<span class="p_del">-	if (c_index &gt;= last_c_index)</span>
<span class="p_del">-		last_tx_cn = c_index - last_c_index;</span>
<span class="p_add">+	if (likely(c_index &gt;= ring-&gt;c_index))</span>
<span class="p_add">+		txbds_ready = c_index - ring-&gt;c_index;</span>
 	else
<span class="p_del">-		last_tx_cn = num_tx_bds - last_c_index + c_index;</span>
<span class="p_add">+		txbds_ready = (DMA_C_INDEX_MASK + 1) - ring-&gt;c_index + c_index;</span>
 
 	netif_dbg(priv, tx_done, dev,
<span class="p_del">-			&quot;%s ring=%d index=%d last_tx_cn=%d last_index=%d\n&quot;,</span>
<span class="p_del">-			__func__, ring-&gt;index,</span>
<span class="p_del">-			c_index, last_tx_cn, last_c_index);</span>
<span class="p_add">+		  &quot;%s ring=%d old_c_index=%u c_index=%u txbds_ready=%u\n&quot;,</span>
<span class="p_add">+		  __func__, ring-&gt;index, ring-&gt;c_index, c_index, txbds_ready);</span>
 
 	/* Reclaim transmitted buffers */
<span class="p_del">-	while (last_tx_cn-- &gt; 0) {</span>
<span class="p_del">-		tx_cb_ptr = ring-&gt;cbs + last_c_index;</span>
<span class="p_del">-		if (tx_cb_ptr-&gt;skb) {</span>
<span class="p_del">-			dev-&gt;stats.tx_bytes += tx_cb_ptr-&gt;skb-&gt;len;</span>
<span class="p_del">-			dma_unmap_single(kdev,</span>
<span class="p_del">-					dma_unmap_addr(tx_cb_ptr, dma_addr),</span>
<span class="p_del">-					dma_unmap_len(tx_cb_ptr, dma_len),</span>
<span class="p_del">-					DMA_TO_DEVICE);</span>
<span class="p_del">-			bcmgenet_free_cb(tx_cb_ptr);</span>
<span class="p_del">-		} else if (dma_unmap_addr(tx_cb_ptr, dma_addr)) {</span>
<span class="p_del">-			dev-&gt;stats.tx_bytes +=</span>
<span class="p_del">-				dma_unmap_len(tx_cb_ptr, dma_len);</span>
<span class="p_del">-			dma_unmap_page(kdev,</span>
<span class="p_del">-					dma_unmap_addr(tx_cb_ptr, dma_addr),</span>
<span class="p_del">-					dma_unmap_len(tx_cb_ptr, dma_len),</span>
<span class="p_del">-					DMA_TO_DEVICE);</span>
<span class="p_del">-			dma_unmap_addr_set(tx_cb_ptr, dma_addr, 0);</span>
<span class="p_add">+	while (txbds_processed &lt; txbds_ready) {</span>
<span class="p_add">+		skb = bcmgenet_free_tx_cb(&amp;priv-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					  &amp;priv-&gt;tx_cbs[ring-&gt;clean_ptr]);</span>
<span class="p_add">+		if (skb) {</span>
<span class="p_add">+			pkts_compl++;</span>
<span class="p_add">+			bytes_compl += GENET_CB(skb)-&gt;bytes_sent;</span>
<span class="p_add">+			dev_consume_skb_any(skb);</span>
 		}
<span class="p_del">-		dev-&gt;stats.tx_packets++;</span>
<span class="p_del">-		ring-&gt;free_bds += 1;</span>
 
<span class="p_del">-		last_c_index++;</span>
<span class="p_del">-		last_c_index &amp;= (num_tx_bds - 1);</span>
<span class="p_add">+		txbds_processed++;</span>
<span class="p_add">+		if (likely(ring-&gt;clean_ptr &lt; ring-&gt;end_ptr))</span>
<span class="p_add">+			ring-&gt;clean_ptr++;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ring-&gt;clean_ptr = ring-&gt;cb_ptr;</span>
 	}
 
<span class="p_add">+	ring-&gt;free_bds += txbds_processed;</span>
<span class="p_add">+	ring-&gt;c_index = (ring-&gt;c_index + txbds_processed) &amp; DMA_C_INDEX_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;stats.tx_packets += pkts_compl;</span>
<span class="p_add">+	dev-&gt;stats.tx_bytes += bytes_compl;</span>
<span class="p_add">+</span>
 	if (ring-&gt;free_bds &gt; (MAX_SKB_FRAGS + 1))
 		ring-&gt;int_disable(priv, ring);
 
<span class="p_add">+	txq = netdev_get_tx_queue(dev, ring-&gt;queue);</span>
 	if (netif_tx_queue_stopped(txq))
 		netif_tx_wake_queue(txq);
<span class="p_del">-</span>
<span class="p_del">-	ring-&gt;c_index = c_index;</span>
 }
 
 static void bcmgenet_tx_reclaim(struct net_device *dev,
<span class="p_chunk">@@ -1028,100 +1084,6 @@</span> <span class="p_context"> static void bcmgenet_tx_reclaim_all(struct net_device *dev)</span>
 	bcmgenet_tx_reclaim(dev, &amp;priv-&gt;tx_rings[DESC_INDEX]);
 }
 
<span class="p_del">-/* Transmits a single SKB (either head of a fragment or a single SKB)</span>
<span class="p_del">- * caller must hold priv-&gt;lock</span>
<span class="p_del">- */</span>
<span class="p_del">-static int bcmgenet_xmit_single(struct net_device *dev,</span>
<span class="p_del">-				struct sk_buff *skb,</span>
<span class="p_del">-				u16 dma_desc_flags,</span>
<span class="p_del">-				struct bcmgenet_tx_ring *ring)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct bcmgenet_priv *priv = netdev_priv(dev);</span>
<span class="p_del">-	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
<span class="p_del">-	struct enet_cb *tx_cb_ptr;</span>
<span class="p_del">-	unsigned int skb_len;</span>
<span class="p_del">-	dma_addr_t mapping;</span>
<span class="p_del">-	u32 length_status;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	tx_cb_ptr = bcmgenet_get_txcb(priv, ring);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(!tx_cb_ptr))</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-</span>
<span class="p_del">-	tx_cb_ptr-&gt;skb = skb;</span>
<span class="p_del">-</span>
<span class="p_del">-	skb_len = skb_headlen(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-	mapping = dma_map_single(kdev, skb-&gt;data, skb_len, DMA_TO_DEVICE);</span>
<span class="p_del">-	ret = dma_mapping_error(kdev, mapping);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		netif_err(priv, tx_err, dev, &quot;Tx DMA map failed\n&quot;);</span>
<span class="p_del">-		dev_kfree_skb(skb);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dma_unmap_addr_set(tx_cb_ptr, dma_addr, mapping);</span>
<span class="p_del">-	dma_unmap_len_set(tx_cb_ptr, dma_len, skb_len);</span>
<span class="p_del">-	length_status = (skb_len &lt;&lt; DMA_BUFLENGTH_SHIFT) | dma_desc_flags |</span>
<span class="p_del">-			(priv-&gt;hw_params-&gt;qtag_mask &lt;&lt; DMA_TX_QTAG_SHIFT) |</span>
<span class="p_del">-			DMA_TX_APPEND_CRC;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (skb-&gt;ip_summed == CHECKSUM_PARTIAL)</span>
<span class="p_del">-		length_status |= DMA_TX_DO_CSUM;</span>
<span class="p_del">-</span>
<span class="p_del">-	dmadesc_set(priv, tx_cb_ptr-&gt;bd_addr, mapping, length_status);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Decrement total BD count and advance our write pointer */</span>
<span class="p_del">-	ring-&gt;free_bds -= 1;</span>
<span class="p_del">-	ring-&gt;prod_index += 1;</span>
<span class="p_del">-	ring-&gt;prod_index &amp;= DMA_P_INDEX_MASK;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Transmit a SKB fragement */</span>
<span class="p_del">-static int bcmgenet_xmit_frag(struct net_device *dev,</span>
<span class="p_del">-				skb_frag_t *frag,</span>
<span class="p_del">-				u16 dma_desc_flags,</span>
<span class="p_del">-				struct bcmgenet_tx_ring *ring)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct bcmgenet_priv *priv = netdev_priv(dev);</span>
<span class="p_del">-	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
<span class="p_del">-	struct enet_cb *tx_cb_ptr;</span>
<span class="p_del">-	dma_addr_t mapping;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	tx_cb_ptr = bcmgenet_get_txcb(priv, ring);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(!tx_cb_ptr))</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	tx_cb_ptr-&gt;skb = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	mapping = skb_frag_dma_map(kdev, frag, 0,</span>
<span class="p_del">-		skb_frag_size(frag), DMA_TO_DEVICE);</span>
<span class="p_del">-	ret = dma_mapping_error(kdev, mapping);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		netif_err(priv, tx_err, dev, &quot;%s: Tx DMA map failed\n&quot;,</span>
<span class="p_del">-				__func__);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dma_unmap_addr_set(tx_cb_ptr, dma_addr, mapping);</span>
<span class="p_del">-	dma_unmap_len_set(tx_cb_ptr, dma_len, frag-&gt;size);</span>
<span class="p_del">-</span>
<span class="p_del">-	dmadesc_set(priv, tx_cb_ptr-&gt;bd_addr, mapping,</span>
<span class="p_del">-			(frag-&gt;size &lt;&lt; DMA_BUFLENGTH_SHIFT) | dma_desc_flags |</span>
<span class="p_del">-			(priv-&gt;hw_params-&gt;qtag_mask &lt;&lt; DMA_TX_QTAG_SHIFT));</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-	ring-&gt;free_bds -= 1;</span>
<span class="p_del">-	ring-&gt;prod_index += 1;</span>
<span class="p_del">-	ring-&gt;prod_index &amp;= DMA_P_INDEX_MASK;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Reallocate the SKB to put enough headroom in front of it and insert
  * the transmit checksum offsets in the descriptors
  */
<span class="p_chunk">@@ -1187,11 +1149,16 @@</span> <span class="p_context"> static int bcmgenet_put_tx_csum(struct net_device *dev, struct sk_buff *skb)</span>
 static netdev_tx_t bcmgenet_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct bcmgenet_priv *priv = netdev_priv(dev);
<span class="p_add">+	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
 	struct bcmgenet_tx_ring *ring = NULL;
<span class="p_add">+	struct enet_cb *tx_cb_ptr;</span>
 	struct netdev_queue *txq;
 	unsigned long flags = 0;
 	int nr_frags, index;
<span class="p_del">-	u16 dma_desc_flags;</span>
<span class="p_add">+	dma_addr_t mapping;</span>
<span class="p_add">+	unsigned int size;</span>
<span class="p_add">+	skb_frag_t *frag;</span>
<span class="p_add">+	u32 len_stat;</span>
 	int ret;
 	int i;
 
<span class="p_chunk">@@ -1226,6 +1193,11 @@</span> <span class="p_context"> static netdev_tx_t bcmgenet_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		goto out;
 	}
 
<span class="p_add">+	/* Retain how many bytes will be sent on the wire, without TSB inserted</span>
<span class="p_add">+	 * by transmit checksum offload</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	GENET_CB(skb)-&gt;bytes_sent = skb-&gt;len;</span>
<span class="p_add">+</span>
 	/* set the SKB transmit checksum */
 	if (priv-&gt;desc_64b_en) {
 		ret = bcmgenet_put_tx_csum(dev, skb);
<span class="p_chunk">@@ -1235,33 +1207,59 @@</span> <span class="p_context"> static netdev_tx_t bcmgenet_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		}
 	}
 
<span class="p_del">-	dma_desc_flags = DMA_SOP;</span>
<span class="p_del">-	if (nr_frags == 0)</span>
<span class="p_del">-		dma_desc_flags |= DMA_EOP;</span>
<span class="p_add">+	for (i = 0; i &lt;= nr_frags; i++) {</span>
<span class="p_add">+		tx_cb_ptr = bcmgenet_get_txcb(priv, ring);</span>
 
<span class="p_del">-	/* Transmit single SKB or head of fragment list */</span>
<span class="p_del">-	ret = bcmgenet_xmit_single(dev, skb, dma_desc_flags, ring);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		ret = NETDEV_TX_OK;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+		if (unlikely(!tx_cb_ptr))</span>
<span class="p_add">+			BUG();</span>
 
<span class="p_del">-	/* xmit fragment */</span>
<span class="p_del">-	for (i = 0; i &lt; nr_frags; i++) {</span>
<span class="p_del">-		ret = bcmgenet_xmit_frag(dev,</span>
<span class="p_del">-				&amp;skb_shinfo(skb)-&gt;frags[i],</span>
<span class="p_del">-				(i == nr_frags - 1) ? DMA_EOP : 0, ring);</span>
<span class="p_add">+		if (!i) {</span>
<span class="p_add">+			/* Transmit single SKB or head of fragment list */</span>
<span class="p_add">+			GENET_CB(skb)-&gt;first_cb = tx_cb_ptr;</span>
<span class="p_add">+			size = skb_headlen(skb);</span>
<span class="p_add">+			mapping = dma_map_single(kdev, skb-&gt;data, size,</span>
<span class="p_add">+						 DMA_TO_DEVICE);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* xmit fragment */</span>
<span class="p_add">+			frag = &amp;skb_shinfo(skb)-&gt;frags[i - 1];</span>
<span class="p_add">+			size = skb_frag_size(frag);</span>
<span class="p_add">+			mapping = skb_frag_dma_map(kdev, frag, 0, size,</span>
<span class="p_add">+						   DMA_TO_DEVICE);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = dma_mapping_error(kdev, mapping);</span>
 		if (ret) {
<span class="p_add">+			netif_err(priv, tx_err, dev, &quot;Tx DMA map failed\n&quot;);</span>
 			ret = NETDEV_TX_OK;
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto out_unmap_frags;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		dma_unmap_addr_set(tx_cb_ptr, dma_addr, mapping);</span>
<span class="p_add">+		dma_unmap_len_set(tx_cb_ptr, dma_len, size);</span>
<span class="p_add">+</span>
<span class="p_add">+		tx_cb_ptr-&gt;skb = skb;</span>
<span class="p_add">+</span>
<span class="p_add">+		len_stat = (size &lt;&lt; DMA_BUFLENGTH_SHIFT) |</span>
<span class="p_add">+			   (priv-&gt;hw_params-&gt;qtag_mask &lt;&lt; DMA_TX_QTAG_SHIFT);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!i) {</span>
<span class="p_add">+			len_stat |= DMA_TX_APPEND_CRC | DMA_SOP;</span>
<span class="p_add">+			if (skb-&gt;ip_summed == CHECKSUM_PARTIAL)</span>
<span class="p_add">+				len_stat |= DMA_TX_DO_CSUM;</span>
 		}
<span class="p_add">+		if (i == nr_frags)</span>
<span class="p_add">+			len_stat |= DMA_EOP;</span>
<span class="p_add">+</span>
<span class="p_add">+		dmadesc_set(priv, tx_cb_ptr-&gt;bd_addr, mapping, len_stat);</span>
 	}
 
<span class="p_add">+	GENET_CB(skb)-&gt;last_cb = tx_cb_ptr;</span>
 	skb_tx_timestamp(skb);
 
<span class="p_del">-	/* we kept a software copy of how much we should advance the TDMA</span>
<span class="p_del">-	 * producer index, now write it down to the hardware</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Decrement total BD count and advance our write pointer */</span>
<span class="p_add">+	ring-&gt;free_bds -= nr_frags + 1;</span>
<span class="p_add">+	ring-&gt;prod_index += nr_frags + 1;</span>
<span class="p_add">+	ring-&gt;prod_index &amp;= DMA_P_INDEX_MASK;</span>
<span class="p_add">+</span>
 	bcmgenet_tdma_ring_writel(priv, ring-&gt;index,
 			ring-&gt;prod_index, TDMA_PROD_INDEX);
 
<span class="p_chunk">@@ -1274,36 +1272,55 @@</span> <span class="p_context"> static netdev_tx_t bcmgenet_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	spin_unlock_irqrestore(&amp;ring-&gt;lock, flags);
 
 	return ret;
<span class="p_del">-}</span>
 
<span class="p_add">+out_unmap_frags:</span>
<span class="p_add">+	/* Back up for failed control block mapping */</span>
<span class="p_add">+	bcmgenet_put_txcb(priv, ring);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Unmap successfully mapped control blocks */</span>
<span class="p_add">+	while (i-- &gt; 0) {</span>
<span class="p_add">+		tx_cb_ptr = bcmgenet_put_txcb(priv, ring);</span>
<span class="p_add">+		bcmgenet_free_tx_cb(kdev, tx_cb_ptr);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-static int bcmgenet_rx_refill(struct bcmgenet_priv *priv,</span>
<span class="p_del">-				struct enet_cb *cb)</span>
<span class="p_add">+	dev_kfree_skb(skb);</span>
<span class="p_add">+	goto out;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct sk_buff *bcmgenet_rx_refill(struct bcmgenet_priv *priv,</span>
<span class="p_add">+					  struct enet_cb *cb)</span>
 {
 	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;
 	struct sk_buff *skb;
<span class="p_add">+	struct sk_buff *rx_skb;</span>
 	dma_addr_t mapping;
<span class="p_del">-	int ret;</span>
 
<span class="p_add">+	/* Allocate a new Rx skb */</span>
 	skb = netdev_alloc_skb(priv-&gt;dev,
 				priv-&gt;rx_buf_len + SKB_ALIGNMENT);
<span class="p_del">-	if (!skb)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!skb) {</span>
<span class="p_add">+		netif_err(priv, rx_err, priv-&gt;dev,</span>
<span class="p_add">+			  &quot;%s: Rx skb allocation failed\n&quot;, __func__);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* a caller did not release this control block */</span>
<span class="p_del">-	WARN_ON(cb-&gt;skb != NULL);</span>
<span class="p_del">-	cb-&gt;skb = skb;</span>
<span class="p_del">-	mapping = dma_map_single(kdev, skb-&gt;data,</span>
<span class="p_del">-			priv-&gt;rx_buf_len, DMA_FROM_DEVICE);</span>
<span class="p_del">-	ret = dma_mapping_error(kdev, mapping);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		bcmgenet_free_cb(cb);</span>
<span class="p_add">+	/* DMA-map the new Rx skb */</span>
<span class="p_add">+	mapping = dma_map_single(kdev, skb-&gt;data, priv-&gt;rx_buf_len,</span>
<span class="p_add">+				 DMA_FROM_DEVICE);</span>
<span class="p_add">+	if (dma_mapping_error(kdev, mapping)) {</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 		netif_err(priv, rx_err, priv-&gt;dev,
<span class="p_del">-				&quot;%s DMA map failed\n&quot;, __func__);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+			  &quot;%s: Rx skb DMA mapping failed\n&quot;, __func__);</span>
<span class="p_add">+		return NULL;</span>
 	}
 
<span class="p_add">+	/* Grab the current Rx skb from the ring and DMA-unmap it */</span>
<span class="p_add">+	rx_skb = bcmgenet_free_rx_cb(kdev, cb);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Put the new Rx skb on the ring */</span>
<span class="p_add">+	cb-&gt;skb = skb;</span>
 	dma_unmap_addr_set(cb, dma_addr, mapping);
<span class="p_add">+	dma_unmap_len_set(cb, dma_len, priv-&gt;rx_buf_len);</span>
 	/* assign packet, prepare descriptor, and advance pointer */
 
 	dmadesc_set_addr(priv, priv-&gt;rx_bd_assign_ptr, mapping);
<span class="p_chunk">@@ -1315,7 +1332,8 @@</span> <span class="p_context"> static int bcmgenet_rx_refill(struct bcmgenet_priv *priv,</span>
 	priv-&gt;rx_bd_assign_ptr = priv-&gt;rx_bds +
 		(priv-&gt;rx_bd_assign_index * DMA_DESC_SIZE);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	/* Return the current Rx skb to caller */</span>
<span class="p_add">+	return rx_skb;</span>
 }
 
 /* bcmgenet_desc_rx - descriptor based rx process.
<span class="p_chunk">@@ -1330,7 +1348,7 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 	struct sk_buff *skb;
 	u32 dma_length_status;
 	unsigned long dma_flag;
<span class="p_del">-	int len, err;</span>
<span class="p_add">+	int len;</span>
 	unsigned int rxpktprocessed = 0, rxpkttoprocess;
 	unsigned int p_index;
 	unsigned int chksum_ok = 0;
<span class="p_chunk">@@ -1351,14 +1369,14 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 	while ((rxpktprocessed &lt; rxpkttoprocess) &amp;&amp;
 			(rxpktprocessed &lt; budget)) {
 
<span class="p_del">-		/* Unmap the packet contents such that we can use the</span>
<span class="p_del">-		 * RSV from the 64 bytes descriptor when enabled and save</span>
<span class="p_del">-		 * a 32-bits register read</span>
<span class="p_del">-		 */</span>
 		cb = &amp;priv-&gt;rx_cbs[priv-&gt;rx_read_ptr];
<span class="p_del">-		skb = cb-&gt;skb;</span>
<span class="p_del">-		dma_unmap_single(kdev, dma_unmap_addr(cb, dma_addr),</span>
<span class="p_del">-				priv-&gt;rx_buf_len, DMA_FROM_DEVICE);</span>
<span class="p_add">+		skb = bcmgenet_rx_refill(priv, cb);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (unlikely(!skb)) {</span>
<span class="p_add">+			dev-&gt;stats.rx_dropped++;</span>
<span class="p_add">+			dev-&gt;stats.rx_errors++;</span>
<span class="p_add">+			goto next;</span>
<span class="p_add">+		}</span>
 
 		if (!priv-&gt;desc_64b_en) {
 			dma_length_status = dmadesc_get_length_status(priv,
<span class="p_chunk">@@ -1382,27 +1400,15 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 			__func__, p_index, priv-&gt;rx_c_index, priv-&gt;rx_read_ptr,
 			dma_length_status);
 
<span class="p_del">-		rxpktprocessed++;</span>
<span class="p_del">-</span>
<span class="p_del">-		priv-&gt;rx_read_ptr++;</span>
<span class="p_del">-		priv-&gt;rx_read_ptr &amp;= (priv-&gt;num_rx_bds - 1);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* out of memory, just drop packets at the hardware level */</span>
<span class="p_del">-		if (unlikely(!skb)) {</span>
<span class="p_del">-			dev-&gt;stats.rx_dropped++;</span>
<span class="p_del">-			dev-&gt;stats.rx_errors++;</span>
<span class="p_del">-			goto refill;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		if (unlikely(!(dma_flag &amp; DMA_EOP) || !(dma_flag &amp; DMA_SOP))) {
 			netif_err(priv, rx_status, dev,
 					&quot;Droping fragmented packet!\n&quot;);
 			dev-&gt;stats.rx_dropped++;
 			dev-&gt;stats.rx_errors++;
<span class="p_del">-			dev_kfree_skb_any(cb-&gt;skb);</span>
<span class="p_del">-			cb-&gt;skb = NULL;</span>
<span class="p_del">-			goto refill;</span>
<span class="p_add">+			dev_kfree_skb_any(skb);</span>
<span class="p_add">+			goto next;</span>
 		}
<span class="p_add">+</span>
 		/* report errors */
 		if (unlikely(dma_flag &amp; (DMA_RX_CRC_ERROR |
 						DMA_RX_OV |
<span class="p_chunk">@@ -1421,11 +1427,8 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 				dev-&gt;stats.rx_length_errors++;
 			dev-&gt;stats.rx_dropped++;
 			dev-&gt;stats.rx_errors++;
<span class="p_del">-</span>
<span class="p_del">-			/* discard the packet and advance consumer index.*/</span>
<span class="p_del">-			dev_kfree_skb_any(cb-&gt;skb);</span>
<span class="p_del">-			cb-&gt;skb = NULL;</span>
<span class="p_del">-			goto refill;</span>
<span class="p_add">+			dev_kfree_skb_any(skb);</span>
<span class="p_add">+			goto next;</span>
 		} /* error packet */
 
 		chksum_ok = (dma_flag &amp; priv-&gt;dma_rx_chk_bit) &amp;&amp;
<span class="p_chunk">@@ -1458,14 +1461,12 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 
 		/* Notify kernel */
 		napi_gro_receive(&amp;priv-&gt;napi, skb);
<span class="p_del">-		cb-&gt;skb = NULL;</span>
 		netif_dbg(priv, rx_status, dev, &quot;pushed up to kernel\n&quot;);
 
<span class="p_del">-		/* refill RX path on the current control block */</span>
<span class="p_del">-refill:</span>
<span class="p_del">-		err = bcmgenet_rx_refill(priv, cb);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			netif_err(priv, rx_err, dev, &quot;Rx refill failed\n&quot;);</span>
<span class="p_add">+next:</span>
<span class="p_add">+		rxpktprocessed++;</span>
<span class="p_add">+		priv-&gt;rx_read_ptr++;</span>
<span class="p_add">+		priv-&gt;rx_read_ptr &amp;= (priv-&gt;num_rx_bds - 1);</span>
 	}
 
 	return rxpktprocessed;
<span class="p_chunk">@@ -1475,7 +1476,7 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 static int bcmgenet_alloc_rx_buffers(struct bcmgenet_priv *priv)
 {
 	struct enet_cb *cb;
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	struct sk_buff *skb;</span>
 	int i;
 
 	netif_dbg(priv, hw, priv-&gt;dev, &quot;%s:\n&quot;, __func__);
<span class="p_chunk">@@ -1483,36 +1484,28 @@</span> <span class="p_context"> static int bcmgenet_alloc_rx_buffers(struct bcmgenet_priv *priv)</span>
 	/* loop here for each buffer needing assign */
 	for (i = 0; i &lt; priv-&gt;num_rx_bds; i++) {
 		cb = &amp;priv-&gt;rx_cbs[priv-&gt;rx_bd_assign_index];
<span class="p_del">-		if (cb-&gt;skb)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = bcmgenet_rx_refill(priv, cb);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_add">+		skb = bcmgenet_rx_refill(priv, cb);</span>
<span class="p_add">+		if (skb)</span>
<span class="p_add">+			dev_consume_skb_any(skb);</span>
<span class="p_add">+		if (!cb-&gt;skb)</span>
<span class="p_add">+			return -ENOMEM;</span>
 	}
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void bcmgenet_free_rx_buffers(struct bcmgenet_priv *priv)
 {
<span class="p_del">-	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
<span class="p_add">+	struct sk_buff *skb;</span>
 	struct enet_cb *cb;
 	int i;
 
 	for (i = 0; i &lt; priv-&gt;num_rx_bds; i++) {
 		cb = &amp;priv-&gt;rx_cbs[i];
 
<span class="p_del">-		if (dma_unmap_addr(cb, dma_addr)) {</span>
<span class="p_del">-			dma_unmap_single(kdev,</span>
<span class="p_del">-					dma_unmap_addr(cb, dma_addr),</span>
<span class="p_del">-					priv-&gt;rx_buf_len, DMA_FROM_DEVICE);</span>
<span class="p_del">-			dma_unmap_addr_set(cb, dma_addr, 0);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		if (cb-&gt;skb)</span>
<span class="p_del">-			bcmgenet_free_cb(cb);</span>
<span class="p_add">+		skb = bcmgenet_free_rx_cb(&amp;priv-&gt;pdev-&gt;dev, cb);</span>
<span class="p_add">+		if (skb)</span>
<span class="p_add">+			dev_consume_skb_any(skb);</span>
 	}
 }
 
<span class="p_chunk">@@ -1640,6 +1633,7 @@</span> <span class="p_context"> static void bcmgenet_init_tx_ring(struct bcmgenet_priv *priv,</span>
 	}
 	ring-&gt;cbs = priv-&gt;tx_cbs + write_ptr;
 	ring-&gt;size = size;
<span class="p_add">+	ring-&gt;clean_ptr = write_ptr;</span>
 	ring-&gt;c_index = 0;
 	ring-&gt;free_bds = size;
 	ring-&gt;write_ptr = write_ptr;
<span class="p_chunk">@@ -1788,6 +1782,8 @@</span> <span class="p_context"> static void bcmgenet_init_multiq(struct net_device *dev)</span>
 
 static void bcmgenet_fini_dma(struct bcmgenet_priv *priv)
 {
<span class="p_add">+	struct sk_buff *skb;</span>
<span class="p_add">+	struct enet_cb *cb;</span>
 	int i;
 
 	/* disable DMA */
<span class="p_chunk">@@ -1795,10 +1791,10 @@</span> <span class="p_context"> static void bcmgenet_fini_dma(struct bcmgenet_priv *priv)</span>
 	bcmgenet_tdma_writel(priv, 0, DMA_CTRL);
 
 	for (i = 0; i &lt; priv-&gt;num_tx_bds; i++) {
<span class="p_del">-		if (priv-&gt;tx_cbs[i].skb != NULL) {</span>
<span class="p_del">-			dev_kfree_skb(priv-&gt;tx_cbs[i].skb);</span>
<span class="p_del">-			priv-&gt;tx_cbs[i].skb = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		cb = priv-&gt;tx_cbs + i;</span>
<span class="p_add">+		skb = bcmgenet_free_tx_cb(&amp;priv-&gt;pdev-&gt;dev, cb);</span>
<span class="p_add">+		if (skb)</span>
<span class="p_add">+			dev_kfree_skb(skb);</span>
 	}
 
 	bcmgenet_free_rx_buffers(priv);
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.h b/drivers/net/ethernet/broadcom/genet/bcmgenet.h</span>
<span class="p_header">index 2317e3725859..2e1e2180690f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.h</span>
<span class="p_chunk">@@ -504,12 +504,21 @@</span> <span class="p_context"> struct bcmgenet_hw_params {</span>
 	u32		flags;
 };
 
<span class="p_add">+struct bcmgenet_skb_cb {</span>
<span class="p_add">+	struct enet_cb *first_cb;	/* First control block of SKB */</span>
<span class="p_add">+	struct enet_cb *last_cb;	/* Last control block of SKB */</span>
<span class="p_add">+	unsigned int bytes_sent;	/* bytes on the wire (no TSB) */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define GENET_CB(skb)	((struct bcmgenet_skb_cb *)((skb)-&gt;cb))</span>
<span class="p_add">+</span>
 struct bcmgenet_tx_ring {
 	spinlock_t	lock;		/* ring lock */
 	unsigned int	index;		/* ring index */
 	unsigned int	queue;		/* queue index */
 	struct enet_cb	*cbs;		/* tx ring buffer control block*/
 	unsigned int	size;		/* size of each tx ring */
<span class="p_add">+	unsigned int    clean_ptr;      /* Tx ring clean pointer */</span>
 	unsigned int	c_index;	/* last consumer index of each ring*/
 	unsigned int	free_bds;	/* # of free bds for each ring */
 	unsigned int	write_ptr;	/* Tx ring write pointer SW copy */
<span class="p_header">diff --git a/drivers/net/ethernet/dec/tulip/tulip_core.c b/drivers/net/ethernet/dec/tulip/tulip_core.c</span>
<span class="p_header">index 861660841ce2..eab3142bd795 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/dec/tulip/tulip_core.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/dec/tulip/tulip_core.c</span>
<span class="p_chunk">@@ -98,8 +98,7 @@</span> <span class="p_context"> static int csr0 = 0x01A00000 | 0x4800;</span>
 #elif defined(__mips__)
 static int csr0 = 0x00200000 | 0x4000;
 #else
<span class="p_del">-#warning Processor architecture undefined!</span>
<span class="p_del">-static int csr0 = 0x00A00000 | 0x4800;</span>
<span class="p_add">+static int csr0;</span>
 #endif
 
 /* Operational parameters that usually are not changed. */
<span class="p_chunk">@@ -1982,6 +1981,12 @@</span> <span class="p_context"> static int __init tulip_init (void)</span>
 	pr_info(&quot;%s&quot;, version);
 #endif
 
<span class="p_add">+	if (!csr0) {</span>
<span class="p_add">+		pr_warn(&quot;tulip: unknown CPU architecture, using default csr0\n&quot;);</span>
<span class="p_add">+		/* default to 8 longword cache line alignment */</span>
<span class="p_add">+		csr0 = 0x00A00000 | 0x4800;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* copy module parms into globals */
 	tulip_rx_copybreak = rx_copybreak;
 	tulip_max_interrupt_work = max_interrupt_work;
<span class="p_header">diff --git a/drivers/net/ethernet/dec/tulip/uli526x.c b/drivers/net/ethernet/dec/tulip/uli526x.c</span>
<span class="p_header">index 80afec335a11..f6b8edf6516e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/dec/tulip/uli526x.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/dec/tulip/uli526x.c</span>
<span class="p_chunk">@@ -1115,7 +1115,7 @@</span> <span class="p_context"> static void uli526x_timer(unsigned long data)</span>
 				netif_carrier_off(dev);
 			}
 		}
<span class="p_del">-		db-&gt;init=0;</span>
<span class="p_add">+	db-&gt;init = 0;</span>
 
 	/* Timer active again */
 	db-&gt;timer.expires = ULI526X_TIMER_WUT;
<span class="p_header">diff --git a/drivers/net/ethernet/dec/tulip/winbond-840.c b/drivers/net/ethernet/dec/tulip/winbond-840.c</span>
<span class="p_header">index 62fe512bb216..345f2fe8755c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/dec/tulip/winbond-840.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/dec/tulip/winbond-840.c</span>
<span class="p_chunk">@@ -907,7 +907,7 @@</span> <span class="p_context"> static void init_registers(struct net_device *dev)</span>
 #elif defined(CONFIG_SPARC) || defined (CONFIG_PARISC)
 	i |= 0x4800;
 #else
<span class="p_del">-#warning Processor architecture undefined</span>
<span class="p_add">+	dev_warn(&amp;dev-&gt;dev, &quot;unknown CPU architecture, using default csr0 setting\n&quot;);</span>
 	i |= 0x4800;
 #endif
 	iowrite32(i, ioaddr + PCIBusCfg);
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index 1e187fb760f8..7329ab75afb5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -26,7 +26,6 @@</span> <span class="p_context"></span>
 #include &lt;net/vxlan.h&gt;
 
 MODULE_VERSION(DRV_VER);
<span class="p_del">-MODULE_DEVICE_TABLE(pci, be_dev_ids);</span>
 MODULE_DESCRIPTION(DRV_DESC &quot; &quot; DRV_VER);
 MODULE_AUTHOR(&quot;Emulex Corporation&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/ich8lan.c b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">index 060c5510b0c4..05e42d3d8a63 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_chunk">@@ -984,7 +984,7 @@</span> <span class="p_context"> static s32 e1000_platform_pm_pch_lpt(struct e1000_hw *hw, bool link)</span>
 		u16 max_snoop, max_nosnoop;
 		u16 max_ltr_enc;	/* max LTR latency encoded */
 		s64 lat_ns;	/* latency (ns) */
<span class="p_del">-		s64 value;</span>
<span class="p_add">+		u64 value;</span>
 		u32 rxa;
 
 		if (!hw-&gt;adapter-&gt;max_frame_size) {
<span class="p_chunk">@@ -1011,12 +1011,13 @@</span> <span class="p_context"> static s32 e1000_platform_pm_pch_lpt(struct e1000_hw *hw, bool link)</span>
 		 */
 		lat_ns = ((s64)rxa * 1024 -
 			  (2 * (s64)hw-&gt;adapter-&gt;max_frame_size)) * 8 * 1000;
<span class="p_del">-		if (lat_ns &lt; 0)</span>
<span class="p_del">-			lat_ns = 0;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			do_div(lat_ns, speed);</span>
<span class="p_add">+		if (lat_ns &lt; 0) {</span>
<span class="p_add">+			value = 0;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			value = lat_ns;</span>
<span class="p_add">+			do_div(value, speed);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		value = lat_ns;</span>
 		while (value &gt; PCI_LTR_VALUE_MASK) {
 			scale++;
 			value = DIV_ROUND_UP(value, (1 &lt;&lt; 5));
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c</span>
<span class="p_header">index cffdfc21290f..decf6faaa89d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_debugfs.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_debugfs.c</span>
<span class="p_chunk">@@ -754,7 +754,7 @@</span> <span class="p_context"> static void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n,</span>
 {
 	struct i40e_tx_desc *txd;
 	union i40e_rx_desc *rxd;
<span class="p_del">-	struct i40e_ring ring;</span>
<span class="p_add">+	struct i40e_ring *ring;</span>
 	struct i40e_vsi *vsi;
 	int i;
 
<span class="p_chunk">@@ -773,29 +773,32 @@</span> <span class="p_context"> static void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n,</span>
 			 vsi_seid);
 		return;
 	}
<span class="p_del">-	if (is_rx_ring)</span>
<span class="p_del">-		ring = *vsi-&gt;rx_rings[ring_id];</span>
<span class="p_del">-	else</span>
<span class="p_del">-		ring = *vsi-&gt;tx_rings[ring_id];</span>
<span class="p_add">+</span>
<span class="p_add">+	ring = kmemdup(is_rx_ring</span>
<span class="p_add">+		       ? vsi-&gt;rx_rings[ring_id] : vsi-&gt;tx_rings[ring_id],</span>
<span class="p_add">+		       sizeof(*ring), GFP_KERNEL);</span>
<span class="p_add">+	if (!ring)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (cnt == 2) {
 		dev_info(&amp;pf-&gt;pdev-&gt;dev, &quot;vsi = %02i %s ring = %02i\n&quot;,
 			 vsi_seid, is_rx_ring ? &quot;rx&quot; : &quot;tx&quot;, ring_id);
<span class="p_del">-		for (i = 0; i &lt; ring.count; i++) {</span>
<span class="p_add">+		for (i = 0; i &lt; ring-&gt;count; i++) {</span>
 			if (!is_rx_ring) {
<span class="p_del">-				txd = I40E_TX_DESC(&amp;ring, i);</span>
<span class="p_add">+				txd = I40E_TX_DESC(ring, i);</span>
 				dev_info(&amp;pf-&gt;pdev-&gt;dev,
 					 &quot;   d[%03i] = 0x%016llx 0x%016llx\n&quot;,
 					 i, txd-&gt;buffer_addr,
 					 txd-&gt;cmd_type_offset_bsz);
 			} else if (sizeof(union i40e_rx_desc) ==
 				   sizeof(union i40e_16byte_rx_desc)) {
<span class="p_del">-				rxd = I40E_RX_DESC(&amp;ring, i);</span>
<span class="p_add">+				rxd = I40E_RX_DESC(ring, i);</span>
 				dev_info(&amp;pf-&gt;pdev-&gt;dev,
 					 &quot;   d[%03i] = 0x%016llx 0x%016llx\n&quot;,
 					 i, rxd-&gt;read.pkt_addr,
 					 rxd-&gt;read.hdr_addr);
 			} else {
<span class="p_del">-				rxd = I40E_RX_DESC(&amp;ring, i);</span>
<span class="p_add">+				rxd = I40E_RX_DESC(ring, i);</span>
 				dev_info(&amp;pf-&gt;pdev-&gt;dev,
 					 &quot;   d[%03i] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n&quot;,
 					 i, rxd-&gt;read.pkt_addr,
<span class="p_chunk">@@ -804,26 +807,26 @@</span> <span class="p_context"> static void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n,</span>
 			}
 		}
 	} else if (cnt == 3) {
<span class="p_del">-		if (desc_n &gt;= ring.count || desc_n &lt; 0) {</span>
<span class="p_add">+		if (desc_n &gt;= ring-&gt;count || desc_n &lt; 0) {</span>
 			dev_info(&amp;pf-&gt;pdev-&gt;dev,
 				 &quot;descriptor %d not found\n&quot;, desc_n);
 			return;
 		}
 		if (!is_rx_ring) {
<span class="p_del">-			txd = I40E_TX_DESC(&amp;ring, desc_n);</span>
<span class="p_add">+			txd = I40E_TX_DESC(ring, desc_n);</span>
 			dev_info(&amp;pf-&gt;pdev-&gt;dev,
 				 &quot;vsi = %02i tx ring = %02i d[%03i] = 0x%016llx 0x%016llx\n&quot;,
 				 vsi_seid, ring_id, desc_n,
 				 txd-&gt;buffer_addr, txd-&gt;cmd_type_offset_bsz);
 		} else if (sizeof(union i40e_rx_desc) ==
 			   sizeof(union i40e_16byte_rx_desc)) {
<span class="p_del">-			rxd = I40E_RX_DESC(&amp;ring, desc_n);</span>
<span class="p_add">+			rxd = I40E_RX_DESC(ring, desc_n);</span>
 			dev_info(&amp;pf-&gt;pdev-&gt;dev,
 				 &quot;vsi = %02i rx ring = %02i d[%03i] = 0x%016llx 0x%016llx\n&quot;,
 				 vsi_seid, ring_id, desc_n,
 				 rxd-&gt;read.pkt_addr, rxd-&gt;read.hdr_addr);
 		} else {
<span class="p_del">-			rxd = I40E_RX_DESC(&amp;ring, desc_n);</span>
<span class="p_add">+			rxd = I40E_RX_DESC(ring, desc_n);</span>
 			dev_info(&amp;pf-&gt;pdev-&gt;dev,
 				 &quot;vsi = %02i rx ring = %02i d[%03i] = 0x%016llx 0x%016llx 0x%016llx 0x%016llx\n&quot;,
 				 vsi_seid, ring_id, desc_n,
<span class="p_chunk">@@ -833,6 +836,7 @@</span> <span class="p_context"> static void i40e_dbg_dump_desc(int cnt, int vsi_seid, int ring_id, int desc_n,</span>
 	} else {
 		dev_info(&amp;pf-&gt;pdev-&gt;dev, &quot;dump desc rx/tx &lt;vsi_seid&gt; &lt;ring_id&gt; [&lt;desc_n&gt;]\n&quot;);
 	}
<span class="p_add">+	kfree(ring);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_txrx.c b/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_header">index e49f31dbd5d8..7b1be746dd30 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c</span>
<span class="p_chunk">@@ -914,6 +914,8 @@</span> <span class="p_context"> int i40e_setup_tx_descriptors(struct i40e_ring *tx_ring)</span>
 	if (!tx_ring-&gt;tx_bi)
 		goto err;
 
<span class="p_add">+	u64_stats_init(&amp;tx_ring-&gt;syncp);</span>
<span class="p_add">+</span>
 	/* round up to nearest 4K */
 	tx_ring-&gt;size = tx_ring-&gt;count * sizeof(struct i40e_tx_desc);
 	/* add u32 for head writeback, align after this takes care of
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">index 75467f83772c..e626b73ca00e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbevf/ixgbevf_main.c</span>
<span class="p_chunk">@@ -2535,6 +2535,8 @@</span> <span class="p_context"> int ixgbevf_setup_tx_resources(struct ixgbevf_ring *tx_ring)</span>
 	if (!tx_ring-&gt;tx_buffer_info)
 		goto err;
 
<span class="p_add">+	u64_stats_init(&amp;tx_ring-&gt;syncp);</span>
<span class="p_add">+</span>
 	/* round up to nearest 4K */
 	tx_ring-&gt;size = tx_ring-&gt;count * sizeof(union ixgbe_adv_tx_desc);
 	tx_ring-&gt;size = ALIGN(tx_ring-&gt;size, 4096);
<span class="p_chunk">@@ -2595,6 +2597,8 @@</span> <span class="p_context"> int ixgbevf_setup_rx_resources(struct ixgbevf_ring *rx_ring)</span>
 	if (!rx_ring-&gt;rx_buffer_info)
 		goto err;
 
<span class="p_add">+	u64_stats_init(&amp;rx_ring-&gt;syncp);</span>
<span class="p_add">+</span>
 	/* Round up to nearest 4K */
 	rx_ring-&gt;size = rx_ring-&gt;count * sizeof(union ixgbe_adv_rx_desc);
 	rx_ring-&gt;size = ALIGN(rx_ring-&gt;size, 4096);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_header">index 68d763d2d030..f07b814d717c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> static void mlx4_en_get_wol(struct net_device *netdev,</span>
 			    struct ethtool_wolinfo *wol)
 {
 	struct mlx4_en_priv *priv = netdev_priv(netdev);
<span class="p_add">+	struct mlx4_caps *caps = &amp;priv-&gt;mdev-&gt;dev-&gt;caps;</span>
 	int err = 0;
 	u64 config = 0;
 	u64 mask;
<span class="p_chunk">@@ -154,24 +155,24 @@</span> <span class="p_context"> static void mlx4_en_get_wol(struct net_device *netdev,</span>
 	mask = (priv-&gt;port == 1) ? MLX4_DEV_CAP_FLAG_WOL_PORT1 :
 		MLX4_DEV_CAP_FLAG_WOL_PORT2;
 
<span class="p_del">-	if (!(priv-&gt;mdev-&gt;dev-&gt;caps.flags &amp; mask)) {</span>
<span class="p_add">+	if (!(caps-&gt;flags &amp; mask)) {</span>
 		wol-&gt;supported = 0;
 		wol-&gt;wolopts = 0;
 		return;
 	}
 
<span class="p_add">+	if (caps-&gt;wol_port[priv-&gt;port])</span>
<span class="p_add">+		wol-&gt;supported = WAKE_MAGIC;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		wol-&gt;supported = 0;</span>
<span class="p_add">+</span>
 	err = mlx4_wol_read(priv-&gt;mdev-&gt;dev, &amp;config, priv-&gt;port);
 	if (err) {
 		en_err(priv, &quot;Failed to get WoL information\n&quot;);
 		return;
 	}
 
<span class="p_del">-	if (config &amp; MLX4_EN_WOL_MAGIC)</span>
<span class="p_del">-		wol-&gt;supported = WAKE_MAGIC;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		wol-&gt;supported = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (config &amp; MLX4_EN_WOL_ENABLED)</span>
<span class="p_add">+	if ((config &amp; MLX4_EN_WOL_ENABLED) &amp;&amp; (config &amp; MLX4_EN_WOL_MAGIC))</span>
 		wol-&gt;wolopts = WAKE_MAGIC;
 	else
 		wol-&gt;wolopts = 0;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index 1006e770c109..e2bdd5626fe2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -1535,17 +1535,13 @@</span> <span class="p_context"> static int mlx4_en_init_affinity_hint(struct mlx4_en_priv *priv, int ring_idx)</span>
 {
 	struct mlx4_en_rx_ring *ring = priv-&gt;rx_ring[ring_idx];
 	int numa_node = priv-&gt;mdev-&gt;dev-&gt;numa_node;
<span class="p_del">-	int ret = 0;</span>
 
 	if (!zalloc_cpumask_var(&amp;ring-&gt;affinity_mask, GFP_KERNEL))
 		return -ENOMEM;
 
<span class="p_del">-	ret = cpumask_set_cpu_local_first(ring_idx, numa_node,</span>
<span class="p_del">-					  ring-&gt;affinity_mask);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		free_cpumask_var(ring-&gt;affinity_mask);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	cpumask_set_cpu(cpumask_local_spread(ring_idx, numa_node),</span>
<span class="p_add">+			ring-&gt;affinity_mask);</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void mlx4_en_free_affinity_hint(struct mlx4_en_priv *priv, int ring_idx)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">index c5be6d890e94..a3d86e31f34c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c</span>
<span class="p_chunk">@@ -133,9 +133,9 @@</span> <span class="p_context"> int mlx4_en_create_tx_ring(struct mlx4_en_priv *priv,</span>
 	ring-&gt;queue_index = queue_index;
 
 	if (queue_index &lt; priv-&gt;num_tx_rings_p_up)
<span class="p_del">-		cpumask_set_cpu_local_first(queue_index,</span>
<span class="p_del">-					    priv-&gt;mdev-&gt;dev-&gt;numa_node,</span>
<span class="p_del">-					    &amp;ring-&gt;affinity_mask);</span>
<span class="p_add">+		cpumask_set_cpu(cpumask_local_spread(queue_index,</span>
<span class="p_add">+						     priv-&gt;mdev-&gt;dev-&gt;numa_node),</span>
<span class="p_add">+				&amp;ring-&gt;affinity_mask);</span>
 
 	*pring = ring;
 	return 0;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/fw.c b/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_header">index 688e1eabab29..781e590efe8e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_chunk">@@ -532,6 +532,7 @@</span> <span class="p_context"> int mlx4_QUERY_DEV_CAP(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)</span>
 #define QUERY_DEV_CAP_CQ_TS_SUPPORT_OFFSET	0x3e
 #define QUERY_DEV_CAP_MAX_PKEY_OFFSET		0x3f
 #define QUERY_DEV_CAP_EXT_FLAGS_OFFSET		0x40
<span class="p_add">+#define QUERY_DEV_CAP_WOL_OFFSET		0x43</span>
 #define QUERY_DEV_CAP_FLAGS_OFFSET		0x44
 #define QUERY_DEV_CAP_RSVD_UAR_OFFSET		0x48
 #define QUERY_DEV_CAP_UAR_SZ_OFFSET		0x49
<span class="p_chunk">@@ -658,6 +659,9 @@</span> <span class="p_context"> int mlx4_QUERY_DEV_CAP(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)</span>
 	MLX4_GET(ext_flags, outbox, QUERY_DEV_CAP_EXT_FLAGS_OFFSET);
 	MLX4_GET(flags, outbox, QUERY_DEV_CAP_FLAGS_OFFSET);
 	dev_cap-&gt;flags = flags | (u64)ext_flags &lt;&lt; 32;
<span class="p_add">+	MLX4_GET(field, outbox, QUERY_DEV_CAP_WOL_OFFSET);</span>
<span class="p_add">+	dev_cap-&gt;wol_port[1] = !!(field &amp; 0x20);</span>
<span class="p_add">+	dev_cap-&gt;wol_port[2] = !!(field &amp; 0x40);</span>
 	MLX4_GET(field, outbox, QUERY_DEV_CAP_RSVD_UAR_OFFSET);
 	dev_cap-&gt;reserved_uars = field &gt;&gt; 4;
 	MLX4_GET(field, outbox, QUERY_DEV_CAP_UAR_SZ_OFFSET);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/fw.h b/drivers/net/ethernet/mellanox/mlx4/fw.h</span>
<span class="p_header">index 1fce03ebe5c4..d60c64bda8c2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/fw.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/fw.h</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> struct mlx4_dev_cap {</span>
 	u8  log_max_macs[MLX4_MAX_PORTS + 1];
 	u8  log_max_vlans[MLX4_MAX_PORTS + 1];
 	u32 max_counters;
<span class="p_add">+	bool wol_port[MLX4_MAX_PORTS + 1];</span>
 };
 
 struct mlx4_func_cap {
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/main.c b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">index c1c21231f444..0996af50ad5b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/main.c</span>
<span class="p_chunk">@@ -279,6 +279,8 @@</span> <span class="p_context"> static int mlx4_dev_cap(struct mlx4_dev *dev, struct mlx4_dev_cap *dev_cap)</span>
 	dev-&gt;caps.stat_rate_support  = dev_cap-&gt;stat_rate_support;
 	dev-&gt;caps.max_gso_sz	     = dev_cap-&gt;max_gso_sz;
 	dev-&gt;caps.max_rss_tbl_sz     = dev_cap-&gt;max_rss_tbl_sz;
<span class="p_add">+	dev-&gt;caps.wol_port[1]          = dev_cap-&gt;wol_port[1];</span>
<span class="p_add">+	dev-&gt;caps.wol_port[2]          = dev_cap-&gt;wol_port[2];</span>
 
 	/* Sense port always allowed on supported devices for ConnectX-1 and -2 */
 	if (mlx4_priv(dev)-&gt;pci_dev_data &amp; MLX4_PCI_DEV_FORCE_SENSE_PORT)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">index 3ee3dcedf74a..30fc1de78c0e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_chunk">@@ -547,6 +547,10 @@</span> <span class="p_context"> static void cb_timeout_handler(struct work_struct *work)</span>
 	mlx5_cmd_comp_handler(dev, 1UL &lt;&lt; ent-&gt;idx);
 }
 
<span class="p_add">+static void free_msg(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *msg);</span>
<span class="p_add">+static void mlx5_free_cmd_msg(struct mlx5_core_dev *dev,</span>
<span class="p_add">+			      struct mlx5_cmd_msg *msg);</span>
<span class="p_add">+</span>
 static void cmd_work_handler(struct work_struct *work)
 {
 	struct mlx5_cmd_work_ent *ent = container_of(work, struct mlx5_cmd_work_ent, work);
<span class="p_chunk">@@ -555,16 +559,27 @@</span> <span class="p_context"> static void cmd_work_handler(struct work_struct *work)</span>
 	unsigned long cb_timeout = msecs_to_jiffies(MLX5_CMD_TIMEOUT_MSEC);
 	struct mlx5_cmd_layout *lay;
 	struct semaphore *sem;
<span class="p_add">+	int alloc_ret;</span>
 
 	sem = ent-&gt;page_queue ? &amp;cmd-&gt;pages_sem : &amp;cmd-&gt;sem;
 	down(sem);
 	if (!ent-&gt;page_queue) {
<span class="p_del">-		ent-&gt;idx = alloc_ent(cmd);</span>
<span class="p_del">-		if (ent-&gt;idx &lt; 0) {</span>
<span class="p_add">+		alloc_ret = alloc_ent(cmd);</span>
<span class="p_add">+		if (alloc_ret &lt; 0) {</span>
 			mlx5_core_err(dev, &quot;failed to allocate command entry\n&quot;);
<span class="p_add">+			if (ent-&gt;callback) {</span>
<span class="p_add">+				ent-&gt;callback(-EAGAIN, ent-&gt;context);</span>
<span class="p_add">+				mlx5_free_cmd_msg(dev, ent-&gt;out);</span>
<span class="p_add">+				free_msg(dev, ent-&gt;in);</span>
<span class="p_add">+				free_cmd(ent);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ent-&gt;ret = -EAGAIN;</span>
<span class="p_add">+				complete(&amp;ent-&gt;done);</span>
<span class="p_add">+			}</span>
 			up(sem);
 			return;
 		}
<span class="p_add">+		ent-&gt;idx = alloc_ret;</span>
 	} else {
 		ent-&gt;idx = cmd-&gt;max_reg_cmds;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/debugfs.c b/drivers/net/ethernet/mellanox/mlx5/core/debugfs.c</span>
<span class="p_header">index 10e1f1a18255..4878025e231c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/debugfs.c</span>
<span class="p_chunk">@@ -300,11 +300,11 @@</span> <span class="p_context"> static u64 qp_read_field(struct mlx5_core_dev *dev, struct mlx5_core_qp *qp,</span>
 		param = qp-&gt;pid;
 		break;
 	case QP_STATE:
<span class="p_del">-		param = (u64)mlx5_qp_state_str(be32_to_cpu(ctx-&gt;flags) &gt;&gt; 28);</span>
<span class="p_add">+		param = (unsigned long)mlx5_qp_state_str(be32_to_cpu(ctx-&gt;flags) &gt;&gt; 28);</span>
 		*is_str = 1;
 		break;
 	case QP_XPORT:
<span class="p_del">-		param = (u64)mlx5_qp_type_str((be32_to_cpu(ctx-&gt;flags) &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+		param = (unsigned long)mlx5_qp_type_str((be32_to_cpu(ctx-&gt;flags) &gt;&gt; 16) &amp; 0xff);</span>
 		*is_str = 1;
 		break;
 	case QP_MTU:
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> static ssize_t dbg_read(struct file *filp, char __user *buf, size_t count,</span>
 
 
 	if (is_str)
<span class="p_del">-		ret = snprintf(tbuf, sizeof(tbuf), &quot;%s\n&quot;, (const char *)field);</span>
<span class="p_add">+		ret = snprintf(tbuf, sizeof(tbuf), &quot;%s\n&quot;, (const char *)(unsigned long)field);</span>
 	else
 		ret = snprintf(tbuf, sizeof(tbuf), &quot;0x%llx\n&quot;, field);
 
<span class="p_header">diff --git a/drivers/net/ethernet/neterion/vxge/vxge-main.c b/drivers/net/ethernet/neterion/vxge/vxge-main.c</span>
<span class="p_header">index 7a0deadd53bf..75682df75c89 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/neterion/vxge/vxge-main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/neterion/vxge/vxge-main.c</span>
<span class="p_chunk">@@ -2224,8 +2224,6 @@</span> <span class="p_context"> static irqreturn_t vxge_isr_napi(int irq, void *dev_id)</span>
 	return IRQ_NONE;
 }
 
<span class="p_del">-#ifdef CONFIG_PCI_MSI</span>
<span class="p_del">-</span>
 static irqreturn_t vxge_tx_msix_handle(int irq, void *dev_id)
 {
 	struct vxge_fifo *fifo = (struct vxge_fifo *)dev_id;
<span class="p_chunk">@@ -2443,16 +2441,13 @@</span> <span class="p_context"> static void vxge_rem_msix_isr(struct vxgedev *vdev)</span>
 	if (vdev-&gt;config.intr_type == MSI_X)
 		pci_disable_msix(vdev-&gt;pdev);
 }
<span class="p_del">-#endif</span>
 
 static void vxge_rem_isr(struct vxgedev *vdev)
 {
<span class="p_del">-#ifdef CONFIG_PCI_MSI</span>
<span class="p_del">-	if (vdev-&gt;config.intr_type == MSI_X) {</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_PCI_MSI) &amp;&amp;</span>
<span class="p_add">+	    vdev-&gt;config.intr_type == MSI_X) {</span>
 		vxge_rem_msix_isr(vdev);
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	if (vdev-&gt;config.intr_type == INTA) {</span>
<span class="p_add">+	} else if (vdev-&gt;config.intr_type == INTA) {</span>
 			synchronize_irq(vdev-&gt;pdev-&gt;irq);
 			free_irq(vdev-&gt;pdev-&gt;irq, vdev);
 	}
<span class="p_chunk">@@ -2461,11 +2456,10 @@</span> <span class="p_context"> static void vxge_rem_isr(struct vxgedev *vdev)</span>
 static int vxge_add_isr(struct vxgedev *vdev)
 {
 	int ret = 0;
<span class="p_del">-#ifdef CONFIG_PCI_MSI</span>
 	int vp_idx = 0, intr_idx = 0, intr_cnt = 0, msix_idx = 0, irq_req = 0;
 	int pci_fun = PCI_FUNC(vdev-&gt;pdev-&gt;devfn);
 
<span class="p_del">-	if (vdev-&gt;config.intr_type == MSI_X)</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_PCI_MSI) &amp;&amp; vdev-&gt;config.intr_type == MSI_X)</span>
 		ret = vxge_enable_msix(vdev);
 
 	if (ret) {
<span class="p_chunk">@@ -2476,7 +2470,7 @@</span> <span class="p_context"> static int vxge_add_isr(struct vxgedev *vdev)</span>
 		vdev-&gt;config.intr_type = INTA;
 	}
 
<span class="p_del">-	if (vdev-&gt;config.intr_type == MSI_X) {</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_PCI_MSI) &amp;&amp; vdev-&gt;config.intr_type == MSI_X) {</span>
 		for (intr_idx = 0;
 		     intr_idx &lt; (vdev-&gt;no_of_vpath *
 			VXGE_HW_VPATH_MSIX_ACTIVE); intr_idx++) {
<span class="p_chunk">@@ -2577,9 +2571,8 @@</span> <span class="p_context"> static int vxge_add_isr(struct vxgedev *vdev)</span>
 		vdev-&gt;vxge_entries[intr_cnt].in_use = 1;
 		vdev-&gt;vxge_entries[intr_cnt].arg = &amp;vdev-&gt;vpaths[0];
 	}
<span class="p_del">-INTA_MODE:</span>
<span class="p_del">-#endif</span>
 
<span class="p_add">+INTA_MODE:</span>
 	if (vdev-&gt;config.intr_type == INTA) {
 		snprintf(vdev-&gt;desc[0], VXGE_INTR_STRLEN,
 			&quot;%s:vxge:INTA&quot;, vdev-&gt;ndev-&gt;name);
<span class="p_chunk">@@ -3890,12 +3883,12 @@</span> <span class="p_context"> static void vxge_device_config_init(struct vxge_hw_device_config *device_config,</span>
 	if (max_mac_vpath &gt; VXGE_MAX_MAC_ADDR_COUNT)
 		max_mac_vpath = VXGE_MAX_MAC_ADDR_COUNT;
 
<span class="p_del">-#ifndef CONFIG_PCI_MSI</span>
<span class="p_del">-	vxge_debug_init(VXGE_ERR,</span>
<span class="p_del">-		&quot;%s: This Kernel does not support &quot;</span>
<span class="p_del">-		&quot;MSI-X. Defaulting to INTA&quot;, VXGE_DRIVER_NAME);</span>
<span class="p_del">-	*intr_type = INTA;</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_PCI_MSI)) {</span>
<span class="p_add">+		vxge_debug_init(VXGE_ERR,</span>
<span class="p_add">+			&quot;%s: This Kernel does not support &quot;</span>
<span class="p_add">+			&quot;MSI-X. Defaulting to INTA&quot;, VXGE_DRIVER_NAME);</span>
<span class="p_add">+		*intr_type = INTA;</span>
<span class="p_add">+	}</span>
 
 	/* Configure whether MSI-X or IRQL. */
 	switch (*intr_type) {
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c b/drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c</span>
<span class="p_header">index db4280ce9c09..6adcd25e17df 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_hw.c</span>
<span class="p_chunk">@@ -2332,7 +2332,7 @@</span> <span class="p_context"> netxen_md_rdqueue(struct netxen_adapter *adapter,</span>
 				 loop_cnt++) {
 		NX_WR_DUMP_REG(select_addr, adapter-&gt;ahw.pci_base0, queue_id);
 		read_addr = queueEntry-&gt;read_addr;
<span class="p_del">-		for (k = 0; k &lt; read_cnt; k--) {</span>
<span class="p_add">+		for (k = 0; k &lt; read_cnt; k++) {</span>
 			NX_RD_DUMP_REG(read_addr, adapter-&gt;ahw.pci_base0,
 							&amp;read_value);
 			*data_buff++ = read_value;
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c b/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_header">index 829be21f97b2..be258d90de9e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_chunk">@@ -724,7 +724,7 @@</span> <span class="p_context"> static void ql_build_coredump_seg_header(</span>
 	seg_hdr-&gt;cookie = MPI_COREDUMP_COOKIE;
 	seg_hdr-&gt;segNum = seg_number;
 	seg_hdr-&gt;segSize = seg_size;
<span class="p_del">-	memcpy(seg_hdr-&gt;description, desc, (sizeof(seg_hdr-&gt;description)) - 1);</span>
<span class="p_add">+	strncpy(seg_hdr-&gt;description, desc, (sizeof(seg_hdr-&gt;description)) - 1);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/r8169.c b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">index 61623e9af574..b1f22e199c3e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_chunk">@@ -5860,8 +5860,7 @@</span> <span class="p_context"> static void rtl8169_tx_clear_range(struct rtl8169_private *tp, u32 start,</span>
 			rtl8169_unmap_tx_skb(&amp;tp-&gt;pci_dev-&gt;dev, tx_skb,
 					     tp-&gt;TxDescArray + entry);
 			if (skb) {
<span class="p_del">-				tp-&gt;dev-&gt;stats.tx_dropped++;</span>
<span class="p_del">-				dev_kfree_skb_any(skb);</span>
<span class="p_add">+				dev_consume_skb_any(skb);</span>
 				tx_skb-&gt;skb = NULL;
 			}
 		}
<span class="p_chunk">@@ -6169,7 +6168,7 @@</span> <span class="p_context"> static void rtl_tx(struct net_device *dev, struct rtl8169_private *tp)</span>
 			tp-&gt;tx_stats.packets++;
 			tp-&gt;tx_stats.bytes += tx_skb-&gt;skb-&gt;len;
 			u64_stats_update_end(&amp;tp-&gt;tx_stats.syncp);
<span class="p_del">-			dev_kfree_skb_any(tx_skb-&gt;skb);</span>
<span class="p_add">+			dev_consume_skb_any(tx_skb-&gt;skb);</span>
 			tx_skb-&gt;skb = NULL;
 		}
 		dirty_tx++;
<span class="p_header">diff --git a/drivers/net/ethernet/ti/cpmac.c b/drivers/net/ethernet/ti/cpmac.c</span>
<span class="p_header">index 7399a52f7c26..755ddd586189 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ti/cpmac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ti/cpmac.c</span>
<span class="p_chunk">@@ -543,7 +543,8 @@</span> <span class="p_context"> static int cpmac_poll(struct napi_struct *napi, int budget)</span>
 
 static int cpmac_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
<span class="p_del">-	int queue, len;</span>
<span class="p_add">+	int queue;</span>
<span class="p_add">+	unsigned int len;</span>
 	struct cpmac_desc *desc;
 	struct cpmac_priv *priv = netdev_priv(dev);
 
<span class="p_chunk">@@ -553,7 +554,7 @@</span> <span class="p_context"> static int cpmac_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if (unlikely(skb_padto(skb, ETH_ZLEN)))
 		return NETDEV_TX_OK;
 
<span class="p_del">-	len = max(skb-&gt;len, ETH_ZLEN);</span>
<span class="p_add">+	len = max_t(unsigned int, skb-&gt;len, ETH_ZLEN);</span>
 	queue = skb_get_queue_mapping(skb);
 	netif_stop_subqueue(dev, queue);
 
<span class="p_chunk">@@ -1226,7 +1227,7 @@</span> <span class="p_context"> int cpmac_init(void)</span>
 		goto fail_alloc;
 	}
 
<span class="p_del">-#warning FIXME: unhardcode gpio&amp;reset bits</span>
<span class="p_add">+	/* FIXME: unhardcode gpio&amp;reset bits */</span>
 	ar7_gpio_disable(26);
 	ar7_gpio_disable(27);
 	ar7_device_reset(AR7_RESET_BIT_CPMAC_LO);
<span class="p_header">diff --git a/drivers/net/ethernet/xilinx/ll_temac_main.c b/drivers/net/ethernet/xilinx/ll_temac_main.c</span>
<span class="p_header">index 4ef818a7a6c6..8a6e5c2d6f95 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/xilinx/ll_temac_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/xilinx/ll_temac_main.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> void temac_iow(struct temac_local *lp, int offset, u32 value)</span>
 
 int temac_indirect_busywait(struct temac_local *lp)
 {
<span class="p_del">-	long end = jiffies + 2;</span>
<span class="p_add">+	unsigned long end = jiffies + 2;</span>
 
 	while (!(temac_ior(lp, XTE_RDY0_OFFSET) &amp; XTE_RDY0_HARD_ACS_RDY_MASK)) {
 		if (time_before_eq(end, jiffies)) {
<span class="p_header">diff --git a/drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c b/drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c</span>
<span class="p_header">index d4abf478e2bb..3b67d60d4378 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/xilinx/xilinx_axienet_mdio.c</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"></span>
 /* Wait till MDIO interface is ready to accept a new transaction.*/
 int axienet_mdio_wait_until_ready(struct axienet_local *lp)
 {
<span class="p_del">-	long end = jiffies + 2;</span>
<span class="p_add">+	unsigned long end = jiffies + 2;</span>
 	while (!(axienet_ior(lp, XAE_MDIO_MCR_OFFSET) &amp;
 		 XAE_MDIO_MCR_READY_MASK)) {
 		if (time_before_eq(end, jiffies)) {
<span class="p_header">diff --git a/drivers/net/ethernet/xilinx/xilinx_emaclite.c b/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_header">index 06b5e4132040..af36c7b560df 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/xilinx/xilinx_emaclite.c</span>
<span class="p_chunk">@@ -707,7 +707,7 @@</span> <span class="p_context"> static irqreturn_t xemaclite_interrupt(int irq, void *dev_id)</span>
 
 static int xemaclite_mdio_wait(struct net_local *lp)
 {
<span class="p_del">-	long end = jiffies + 2;</span>
<span class="p_add">+	unsigned long end = jiffies + 2;</span>
 
 	/* wait for the MDIO interface to not be busy or timeout
 	   after some time.
<span class="p_header">diff --git a/drivers/net/hyperv/netvsc_drv.c b/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_header">index ff0e464441d0..ae86b89c9ca4 100644</span>
<span class="p_header">--- a/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_header">+++ b/drivers/net/hyperv/netvsc_drv.c</span>
<span class="p_chunk">@@ -777,9 +777,14 @@</span> <span class="p_context"> static void netvsc_link_change(struct work_struct *w)</span>
 	struct rndis_device *rdev;
 	bool notify;
 
<span class="p_del">-	rtnl_lock();</span>
<span class="p_del">-</span>
 	ndev_ctx = container_of(w, struct net_device_context, dwork.work);
<span class="p_add">+</span>
<span class="p_add">+	/* if changes are happening, comeback later */</span>
<span class="p_add">+	if (!rtnl_trylock()) {</span>
<span class="p_add">+		schedule_delayed_work(&amp;ndev_ctx-&gt;dwork, 2 * HZ);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	net_device = hv_get_drvdata(ndev_ctx-&gt;device_ctx);
 	rdev = net_device-&gt;extension;
 	net = net_device-&gt;ndev;
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c b/drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c</span>
<span class="p_header">index 699908de314a..c9b0586d7b58 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/fwsignal.c</span>
<span class="p_chunk">@@ -607,7 +607,7 @@</span> <span class="p_context"> static int brcmf_fws_hanger_pushpkt(struct brcmf_fws_hanger *h,</span>
 	return 0;
 }
 
<span class="p_del">-static int brcmf_fws_hanger_poppkt(struct brcmf_fws_hanger *h,</span>
<span class="p_add">+static inline int brcmf_fws_hanger_poppkt(struct brcmf_fws_hanger *h,</span>
 					  u32 slot_id, struct sk_buff **pktout,
 					  bool remove_item)
 {
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c b/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_header">index 1d6ff00a4194..26c5f3bdf2c5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/wl_cfg80211.c</span>
<span class="p_chunk">@@ -2692,6 +2692,7 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 	s32 status;
 	s32 err = 0;
 	struct brcmf_escan_result_le *escan_result_le;
<span class="p_add">+	u32 escan_buflen;</span>
 	struct brcmf_bss_info_le *bss_info_le;
 	struct brcmf_bss_info_le *bss = NULL;
 	u32 bi_length;
<span class="p_chunk">@@ -2708,11 +2709,23 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 
 	if (status == BRCMF_E_STATUS_PARTIAL) {
 		brcmf_dbg(SCAN, &quot;ESCAN Partial result\n&quot;);
<span class="p_add">+		if (e-&gt;datalen &lt; sizeof(*escan_result_le)) {</span>
<span class="p_add">+			brcmf_err(&quot;invalid event data length\n&quot;);</span>
<span class="p_add">+			goto exit;</span>
<span class="p_add">+		}</span>
 		escan_result_le = (struct brcmf_escan_result_le *) data;
 		if (!escan_result_le) {
 			brcmf_err(&quot;Invalid escan result (NULL pointer)\n&quot;);
 			goto exit;
 		}
<span class="p_add">+		escan_buflen = le32_to_cpu(escan_result_le-&gt;buflen);</span>
<span class="p_add">+		if (escan_buflen &gt; WL_ESCAN_BUF_SIZE ||</span>
<span class="p_add">+		    escan_buflen &gt; e-&gt;datalen ||</span>
<span class="p_add">+		    escan_buflen &lt; sizeof(*escan_result_le)) {</span>
<span class="p_add">+			brcmf_err(&quot;Invalid escan buffer length: %d\n&quot;,</span>
<span class="p_add">+				  escan_buflen);</span>
<span class="p_add">+			goto exit;</span>
<span class="p_add">+		}</span>
 		if (le16_to_cpu(escan_result_le-&gt;bss_count) != 1) {
 			brcmf_err(&quot;Invalid bss_count %d: ignoring\n&quot;,
 				  escan_result_le-&gt;bss_count);
<span class="p_chunk">@@ -2729,9 +2742,8 @@</span> <span class="p_context"> brcmf_cfg80211_escan_handler(struct brcmf_if *ifp,</span>
 		}
 
 		bi_length = le32_to_cpu(bss_info_le-&gt;length);
<span class="p_del">-		if (bi_length != (le32_to_cpu(escan_result_le-&gt;buflen) -</span>
<span class="p_del">-					WL_ESCAN_RESULTS_FIXED_SIZE)) {</span>
<span class="p_del">-			brcmf_err(&quot;Invalid bss_info length %d: ignoring\n&quot;,</span>
<span class="p_add">+		if (bi_length != escan_buflen -	WL_ESCAN_RESULTS_FIXED_SIZE) {</span>
<span class="p_add">+			brcmf_err(&quot;Ignoring invalid bss_info length: %d\n&quot;,</span>
 				  bi_length);
 			goto exit;
 		}
<span class="p_header">diff --git a/drivers/net/wireless/hostap/hostap_hw.c b/drivers/net/wireless/hostap/hostap_hw.c</span>
<span class="p_header">index 6df3ee561d52..515aa3f993f3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/hostap/hostap_hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/hostap/hostap_hw.c</span>
<span class="p_chunk">@@ -836,25 +836,30 @@</span> <span class="p_context"> static int hfa384x_get_rid(struct net_device *dev, u16 rid, void *buf, int len,</span>
 	spin_lock_bh(&amp;local-&gt;baplock);
 
 	res = hfa384x_setup_bap(dev, BAP0, rid, 0);
<span class="p_del">-	if (!res)</span>
<span class="p_del">-		res = hfa384x_from_bap(dev, BAP0, &amp;rec, sizeof(rec));</span>
<span class="p_add">+	if (res)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = hfa384x_from_bap(dev, BAP0, &amp;rec, sizeof(rec));</span>
<span class="p_add">+	if (res)</span>
<span class="p_add">+		goto unlock;</span>
 
 	if (le16_to_cpu(rec.len) == 0) {
 		/* RID not available */
 		res = -ENODATA;
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rlen = (le16_to_cpu(rec.len) - 1) * 2;
<span class="p_del">-	if (!res &amp;&amp; exact_len &amp;&amp; rlen != len) {</span>
<span class="p_add">+	if (exact_len &amp;&amp; rlen != len) {</span>
 		printk(KERN_DEBUG &quot;%s: hfa384x_get_rid - RID len mismatch: &quot;
 		       &quot;rid=0x%04x, len=%d (expected %d)\n&quot;,
 		       dev-&gt;name, rid, rlen, len);
 		res = -ENODATA;
 	}
 
<span class="p_del">-	if (!res)</span>
<span class="p_del">-		res = hfa384x_from_bap(dev, BAP0, buf, len);</span>
<span class="p_add">+	res = hfa384x_from_bap(dev, BAP0, buf, len);</span>
 
<span class="p_add">+unlock:</span>
 	spin_unlock_bh(&amp;local-&gt;baplock);
 	mutex_unlock(&amp;local-&gt;rid_bap_mtx);
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlegacy/3945.c b/drivers/net/wireless/iwlegacy/3945.c</span>
<span class="p_header">index b598e2803500..fbfd77440049 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlegacy/3945.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlegacy/3945.c</span>
<span class="p_chunk">@@ -1019,12 +1019,13 @@</span> <span class="p_context"> il3945_hw_txq_ctx_free(struct il_priv *il)</span>
 	int txq_id;
 
 	/* Tx queues */
<span class="p_del">-	if (il-&gt;txq)</span>
<span class="p_add">+	if (il-&gt;txq) {</span>
 		for (txq_id = 0; txq_id &lt; il-&gt;hw_params.max_txq_num; txq_id++)
 			if (txq_id == IL39_CMD_QUEUE_NUM)
 				il_cmd_queue_free(il);
 			else
 				il_tx_queue_free(il, txq_id);
<span class="p_add">+	}</span>
 
 	/* free tx queue structure */
 	il_free_txq_mem(il);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/dvm/tx.c b/drivers/net/wireless/iwlwifi/dvm/tx.c</span>
<span class="p_header">index 3255a1723d17..d079b9a4c30c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/dvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/dvm/tx.c</span>
<span class="p_chunk">@@ -1190,11 +1190,11 @@</span> <span class="p_context"> int iwlagn_rx_reply_tx(struct iwl_priv *priv, struct iwl_rx_cmd_buffer *rxb,</span>
 				next_reclaimed;
 			IWL_DEBUG_TX_REPLY(priv, &quot;Next reclaimed packet:%d\n&quot;,
 						  next_reclaimed);
<span class="p_add">+			iwlagn_check_ratid_empty(priv, sta_id, tid);</span>
 		}
 
 		iwl_trans_reclaim(priv-&gt;trans, txq_id, ssn, &amp;skbs);
 
<span class="p_del">-		iwlagn_check_ratid_empty(priv, sta_id, tid);</span>
 		freed = 0;
 
 		/* process frames */
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/sta.c b/drivers/net/wireless/iwlwifi/mvm/sta.c</span>
<span class="p_header">index 1fb01ea2e704..28b783ab04c9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/sta.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/sta.c</span>
<span class="p_chunk">@@ -114,7 +114,8 @@</span> <span class="p_context"> int iwl_mvm_sta_send_to_fw(struct iwl_mvm *mvm, struct ieee80211_sta *sta,</span>
 	add_sta_cmd.add_modify = update ? 1 : 0;
 
 	add_sta_cmd.station_flags_msk |= cpu_to_le32(STA_FLG_FAT_EN_MSK |
<span class="p_del">-						     STA_FLG_MIMO_EN_MSK);</span>
<span class="p_add">+						     STA_FLG_MIMO_EN_MSK |</span>
<span class="p_add">+						     STA_FLG_RTS_MIMO_PROT);</span>
 
 	switch (sta-&gt;bandwidth) {
 	case IEEE80211_STA_RX_BW_160:
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl1251/main.c b/drivers/net/wireless/ti/wl1251/main.c</span>
<span class="p_header">index 4e782f18ae34..293b4e3b6d02 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl1251/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl1251/main.c</span>
<span class="p_chunk">@@ -1571,6 +1571,7 @@</span> <span class="p_context"> struct ieee80211_hw *wl1251_alloc_hw(void)</span>
 
 	wl-&gt;state = WL1251_STATE_OFF;
 	mutex_init(&amp;wl-&gt;mutex);
<span class="p_add">+	spin_lock_init(&amp;wl-&gt;wl_lock);</span>
 
 	wl-&gt;tx_mgmt_frm_rate = DEFAULT_HW_GEN_TX_RATE;
 	wl-&gt;tx_mgmt_frm_mod = DEFAULT_HW_GEN_MODULATION_TYPE;
<span class="p_header">diff --git a/drivers/of/device.c b/drivers/of/device.c</span>
<span class="p_header">index dafb9736ab9b..f659da36cdda 100644</span>
<span class="p_header">--- a/drivers/of/device.c</span>
<span class="p_header">+++ b/drivers/of/device.c</span>
<span class="p_chunk">@@ -128,6 +128,7 @@</span> <span class="p_context"> ssize_t of_device_get_modalias(struct device *dev, char *str, ssize_t len)</span>
 
 	return tsize;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(of_device_get_modalias);</span>
 
 /**
  * of_device_uevent - Display OF related uevent information
<span class="p_chunk">@@ -190,3 +191,4 @@</span> <span class="p_context"> int of_device_uevent_modalias(struct device *dev, struct kobj_uevent_env *env)</span>
 
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(of_device_uevent_modalias);</span>
<span class="p_header">diff --git a/drivers/parisc/dino.c b/drivers/parisc/dino.c</span>
<span class="p_header">index cf77ab14b681..1a5d765b6af6 100644</span>
<span class="p_header">--- a/drivers/parisc/dino.c</span>
<span class="p_header">+++ b/drivers/parisc/dino.c</span>
<span class="p_chunk">@@ -954,7 +954,7 @@</span> <span class="p_context"> static int __init dino_probe(struct parisc_device *dev)</span>
 
 	dino_dev-&gt;hba.dev = dev;
 	dino_dev-&gt;hba.base_addr = ioremap_nocache(hpa, 4096);
<span class="p_del">-	dino_dev-&gt;hba.lmmio_space_offset = 0;	/* CPU addrs == bus addrs */</span>
<span class="p_add">+	dino_dev-&gt;hba.lmmio_space_offset = PCI_F_EXTEND;</span>
 	spin_lock_init(&amp;dino_dev-&gt;dinosaur_pen);
 	dino_dev-&gt;hba.iommu = ccio_get_iommu(dev);
 
<span class="p_header">diff --git a/drivers/pinctrl/sunxi/pinctrl-sun4i-a10.c b/drivers/pinctrl/sunxi/pinctrl-sun4i-a10.c</span>
<span class="p_header">index fa1ff7c7e357..ee6afe52a7d1 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sunxi/pinctrl-sun4i-a10.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sunxi/pinctrl-sun4i-a10.c</span>
<span class="p_chunk">@@ -800,6 +800,7 @@</span> <span class="p_context"> static const struct sunxi_desc_pin sun4i_a10_pins[] = {</span>
 		  SUNXI_FUNCTION(0x2, &quot;lcd1&quot;),		/* D16 */
 		  SUNXI_FUNCTION(0x3, &quot;pata&quot;),		/* ATAD12 */
 		  SUNXI_FUNCTION(0x4, &quot;keypad&quot;),	/* IN6 */
<span class="p_add">+		  SUNXI_FUNCTION(0x5, &quot;sim&quot;),		/* DET */</span>
 		  SUNXI_FUNCTION_IRQ(0x6, 16),		/* EINT16 */
 		  SUNXI_FUNCTION(0x7, &quot;csi1&quot;)),		/* D16 */
 	SUNXI_PIN(SUNXI_PINCTRL_PIN(H, 17),
<span class="p_header">diff --git a/drivers/platform/x86/samsung-laptop.c b/drivers/platform/x86/samsung-laptop.c</span>
<span class="p_header">index ce364a41842a..6c7057aab262 100644</span>
<span class="p_header">--- a/drivers/platform/x86/samsung-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/samsung-laptop.c</span>
<span class="p_chunk">@@ -1347,9 +1347,9 @@</span> <span class="p_context"> static int __init samsung_sabi_init(struct samsung_laptop *samsung)</span>
 	const struct sabi_config *config = NULL;
 	const struct sabi_commands *commands;
 	unsigned int ifaceP;
<span class="p_add">+	int loca = 0xffff;</span>
 	int ret = 0;
 	int i;
<span class="p_del">-	int loca;</span>
 
 	samsung-&gt;f0000_segment = ioremap_nocache(0xf0000, 0xffff);
 	if (!samsung-&gt;f0000_segment) {
<span class="p_header">diff --git a/drivers/power/reset/xgene-reboot.c b/drivers/power/reset/xgene-reboot.c</span>
<span class="p_header">index ecd55f81b9d1..6b49be6867ab 100644</span>
<span class="p_header">--- a/drivers/power/reset/xgene-reboot.c</span>
<span class="p_header">+++ b/drivers/power/reset/xgene-reboot.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct xgene_reboot_context {</span>
 
 static struct xgene_reboot_context *xgene_restart_ctx;
 
<span class="p_del">-static void xgene_restart(char str, const char *cmd)</span>
<span class="p_add">+static void xgene_restart(enum reboot_mode mode, const char *cmd)</span>
 {
 	struct xgene_reboot_context *ctx = xgene_restart_ctx;
 	unsigned long timeout;
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">index 8de493a18d9e..3beb591b8ad8 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_chunk">@@ -2816,7 +2816,7 @@</span> <span class="p_context"> static void qeth_l3_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,</span>
 		struct rtable *rt = (struct rtable *) dst;
 		__be32 *pkey = &amp;ip_hdr(skb)-&gt;daddr;
 
<span class="p_del">-		if (rt-&gt;rt_gateway)</span>
<span class="p_add">+		if (rt &amp;&amp; rt-&gt;rt_gateway)</span>
 			pkey = &amp;rt-&gt;rt_gateway;
 
 		/* IPv4 */
<span class="p_chunk">@@ -2827,7 +2827,7 @@</span> <span class="p_context"> static void qeth_l3_fill_header(struct qeth_card *card, struct qeth_hdr *hdr,</span>
 		struct rt6_info *rt = (struct rt6_info *) dst;
 		struct in6_addr *pkey = &amp;ipv6_hdr(skb)-&gt;daddr;
 
<span class="p_del">-		if (!ipv6_addr_any(&amp;rt-&gt;rt6i_gateway))</span>
<span class="p_add">+		if (rt &amp;&amp; !ipv6_addr_any(&amp;rt-&gt;rt6i_gateway))</span>
 			pkey = &amp;rt-&gt;rt6i_gateway;
 
 		/* IPv6 */
<span class="p_header">diff --git a/drivers/scsi/advansys.c b/drivers/scsi/advansys.c</span>
<span class="p_header">index d8145888e66a..ee00d9e459c8 100644</span>
<span class="p_header">--- a/drivers/scsi/advansys.c</span>
<span class="p_header">+++ b/drivers/scsi/advansys.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"></span>
 #include &lt;scsi/scsi.h&gt;
 #include &lt;scsi/scsi_host.h&gt;
 
<span class="p_del">-/* FIXME:</span>
<span class="p_add">+/* Fixed in linux-4.2, not backported to 3.16:</span>
  *
  *  1. Although all of the necessary command mapping places have the
  *     appropriate dma_map.. APIs, the driver still processes its internal
<span class="p_chunk">@@ -68,7 +68,6 @@</span> <span class="p_context"></span>
  *  7. advansys_info is not safe against multiple simultaneous callers
  *  8. Add module_param to override ISA/VLB ioport array
  */
<span class="p_del">-#warning this driver is still not properly converted to the DMA API</span>
 
 /* Enable driver /proc statistics. */
 #define ADVANSYS_STATS
<span class="p_header">diff --git a/drivers/scsi/aic94xx/aic94xx_sds.c b/drivers/scsi/aic94xx/aic94xx_sds.c</span>
<span class="p_header">index edb43fda9f36..c831e30411fa 100644</span>
<span class="p_header">--- a/drivers/scsi/aic94xx/aic94xx_sds.c</span>
<span class="p_header">+++ b/drivers/scsi/aic94xx/aic94xx_sds.c</span>
<span class="p_chunk">@@ -983,7 +983,7 @@</span> <span class="p_context"> static int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,</span>
 {
 	int err, i;
 	u32 offs, size;
<span class="p_del">-	struct asd_ll_el *el;</span>
<span class="p_add">+	struct asd_ll_el *el = NULL;</span>
 	struct asd_ctrla_phy_settings *ps;
 	struct asd_ctrla_phy_settings dflt_ps;
 
<span class="p_chunk">@@ -1004,6 +1004,7 @@</span> <span class="p_context"> static int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,</span>
 
 		size = sizeof(struct asd_ctrla_phy_settings);
 		ps = &amp;dflt_ps;
<span class="p_add">+		goto out_process;</span>
 	}
 
 	if (size == 0)
<span class="p_chunk">@@ -1028,7 +1029,7 @@</span> <span class="p_context"> static int asd_process_ctrl_a_user(struct asd_ha_struct *asd_ha,</span>
 		ASD_DPRINTK(&quot;couldn&#39;t find ctrla phy settings struct\n&quot;);
 		goto out2;
 	}
<span class="p_del">-</span>
<span class="p_add">+out_process:</span>
 	err = asd_process_ctrla_phy_settings(asd_ha, ps);
 	if (err) {
 		ASD_DPRINTK(&quot;couldn&#39;t process ctrla phy settings\n&quot;);
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">index 803fd64d0966..d5068e43cfc5 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_chunk">@@ -48,7 +48,6 @@</span> <span class="p_context"> static unsigned int be_iopoll_budget = 10;</span>
 static unsigned int be_max_phys_size = 64;
 static unsigned int enable_msix = 1;
 
<span class="p_del">-MODULE_DEVICE_TABLE(pci, beiscsi_pci_id_table);</span>
 MODULE_DESCRIPTION(DRV_DESC &quot; &quot; BUILD_STR);
 MODULE_VERSION(BUILD_STR);
 MODULE_AUTHOR(&quot;Emulex Corporation&quot;);
<span class="p_chunk">@@ -3153,7 +3152,7 @@</span> <span class="p_context"> be_sgl_create_contiguous(void *virtual_address,</span>
 {
 	WARN_ON(!virtual_address);
 	WARN_ON(!physical_address);
<span class="p_del">-	WARN_ON(!length &gt; 0);</span>
<span class="p_add">+	WARN_ON(!length);</span>
 	WARN_ON(!sgl);
 
 	sgl-&gt;va = virtual_address;
<span class="p_header">diff --git a/drivers/scsi/bfa/bfa_ioc.c b/drivers/scsi/bfa/bfa_ioc.c</span>
<span class="p_header">index 315d6d6dcfc8..4e7104461f09 100644</span>
<span class="p_header">--- a/drivers/scsi/bfa/bfa_ioc.c</span>
<span class="p_header">+++ b/drivers/scsi/bfa/bfa_ioc.c</span>
<span class="p_chunk">@@ -3665,19 +3665,19 @@</span> <span class="p_context"> bfa_cb_sfp_state_query(struct bfa_sfp_s *sfp)</span>
 		if (sfp-&gt;state_query_cbfn)
 			sfp-&gt;state_query_cbfn(sfp-&gt;state_query_cbarg,
 					sfp-&gt;status);
<span class="p_del">-			sfp-&gt;media = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		sfp-&gt;media = NULL;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-		if (sfp-&gt;portspeed) {</span>
<span class="p_del">-			sfp-&gt;status = bfa_sfp_speed_valid(sfp, sfp-&gt;portspeed);</span>
<span class="p_del">-			if (sfp-&gt;state_query_cbfn)</span>
<span class="p_del">-				sfp-&gt;state_query_cbfn(sfp-&gt;state_query_cbarg,</span>
<span class="p_del">-						sfp-&gt;status);</span>
<span class="p_del">-				sfp-&gt;portspeed = BFA_PORT_SPEED_UNKNOWN;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (sfp-&gt;portspeed) {</span>
<span class="p_add">+		sfp-&gt;status = bfa_sfp_speed_valid(sfp, sfp-&gt;portspeed);</span>
<span class="p_add">+		if (sfp-&gt;state_query_cbfn)</span>
<span class="p_add">+			sfp-&gt;state_query_cbfn(sfp-&gt;state_query_cbarg,</span>
<span class="p_add">+					sfp-&gt;status);</span>
<span class="p_add">+		sfp-&gt;portspeed = BFA_PORT_SPEED_UNKNOWN;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-		sfp-&gt;state_query_lock = 0;</span>
<span class="p_del">-		sfp-&gt;state_query_cbfn = NULL;</span>
<span class="p_add">+	sfp-&gt;state_query_lock = 0;</span>
<span class="p_add">+	sfp-&gt;state_query_cbfn = NULL;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/scsi/ips.c b/drivers/scsi/ips.c</span>
<span class="p_header">index 52a216f21ae5..946084014316 100644</span>
<span class="p_header">--- a/drivers/scsi/ips.c</span>
<span class="p_header">+++ b/drivers/scsi/ips.c</span>
<span class="p_chunk">@@ -206,10 +206,6 @@</span> <span class="p_context"> module_param(ips, charp, 0);</span>
 #define IPS_VERSION_HIGH        IPS_VER_MAJOR_STRING &quot;.&quot; IPS_VER_MINOR_STRING
 #define IPS_VERSION_LOW         &quot;.&quot; IPS_VER_BUILD_STRING &quot; &quot;
 
<span class="p_del">-#if !defined(__i386__) &amp;&amp; !defined(__ia64__) &amp;&amp; !defined(__x86_64__)</span>
<span class="p_del">-#warning &quot;This driver has only been tested on the x86/ia64/x86_64 platforms&quot;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #define IPS_DMA_DIR(scb) ((!scb-&gt;scsi_cmd || ips_is_passthru(scb-&gt;scsi_cmd) || \
                          DMA_NONE == scb-&gt;scsi_cmd-&gt;sc_data_direction) ? \
                          PCI_DMA_BIDIRECTIONAL : \
<span class="p_chunk">@@ -6789,6 +6785,11 @@</span> <span class="p_context"> ips_remove_device(struct pci_dev *pci_dev)</span>
 static int __init
 ips_module_init(void)
 {
<span class="p_add">+#if !defined(__i386__) &amp;&amp; !defined(__ia64__) &amp;&amp; !defined(__x86_64__)</span>
<span class="p_add">+	printk(KERN_ERR &quot;ips: This driver has only been tested on the x86/ia64/x86_64 platforms\n&quot;);</span>
<span class="p_add">+	add_taint(TAINT_CPU_OUT_OF_SPEC, LOCKDEP_STILL_OK);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	if (pci_register_driver(&amp;ips_pci_driver) &lt; 0)
 		return -ENODEV;
 	ips_driver_template.module = THIS_MODULE;
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index 42b1f3318e59..eab05c5f8b0e 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -737,8 +737,8 @@</span> <span class="p_context"> static int mvs_task_prep(struct sas_task *task, struct mvs_info *mvi, int is_tmf</span>
 			mv_dprintk(&quot;device %016llx not ready.\n&quot;,
 				SAS_ADDR(dev-&gt;sas_addr));
 
<span class="p_del">-			rc = SAS_PHY_DOWN;</span>
<span class="p_del">-			return rc;</span>
<span class="p_add">+		rc = SAS_PHY_DOWN;</span>
<span class="p_add">+		return rc;</span>
 	}
 	tei.port = dev-&gt;port-&gt;lldd_port;
 	if (tei.port &amp;&amp; !tei.port-&gt;port_attached &amp;&amp; !tmf) {
<span class="p_header">diff --git a/drivers/scsi/scsi_tgt_if.c b/drivers/scsi/scsi_tgt_if.c</span>
<span class="p_header">index 6209110f295d..7199753591b2 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_tgt_if.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_tgt_if.c</span>
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> static int uspace_ring_map(struct vm_area_struct *vma, unsigned long addr,</span>
 	int i, err;
 
 	for (i = 0; i &lt; TGT_RING_PAGES; i++) {
<span class="p_del">-		struct page *page = virt_to_page(ring-&gt;tr_pages[i]);</span>
<span class="p_add">+		struct page *page = virt_to_page((void *)ring-&gt;tr_pages[i]);</span>
 		err = vm_insert_page(vma, addr, page);
 		if (err)
 			return err;
<span class="p_header">diff --git a/drivers/scsi/st.c b/drivers/scsi/st.c</span>
<span class="p_header">index daa67f509133..d24de1bb33a5 100644</span>
<span class="p_header">--- a/drivers/scsi/st.c</span>
<span class="p_header">+++ b/drivers/scsi/st.c</span>
<span class="p_chunk">@@ -4115,11 +4115,11 @@</span> <span class="p_context"> static int st_probe(struct device *dev)</span>
 	kref_init(&amp;tpnt-&gt;kref);
 	tpnt-&gt;disk = disk;
 	disk-&gt;private_data = &amp;tpnt-&gt;driver;
<span class="p_del">-	disk-&gt;queue = SDp-&gt;request_queue;</span>
 	/* SCSI tape doesn&#39;t register this gendisk via add_disk().  Manually
 	 * take queue reference that release_disk() expects. */
<span class="p_del">-	if (!blk_get_queue(disk-&gt;queue))</span>
<span class="p_add">+	if (!blk_get_queue(SDp-&gt;request_queue))</span>
 		goto out_put_disk;
<span class="p_add">+	disk-&gt;queue = SDp-&gt;request_queue;</span>
 	tpnt-&gt;driver = &amp;st_template;
 
 	tpnt-&gt;device = SDp;
<span class="p_header">diff --git a/drivers/spi/spi-atmel.c b/drivers/spi/spi-atmel.c</span>
<span class="p_header">index 7bfd64f7d76b..27ebf096e703 100644</span>
<span class="p_header">--- a/drivers/spi/spi-atmel.c</span>
<span class="p_header">+++ b/drivers/spi/spi-atmel.c</span>
<span class="p_chunk">@@ -1020,7 +1020,7 @@</span> <span class="p_context"> static int atmel_spi_setup(struct spi_device *spi)</span>
 	csr |= SPI_BF(DLYBCT, 0);
 
 	/* chipselect must have been muxed as GPIO (e.g. in board setup) */
<span class="p_del">-	npcs_pin = (unsigned int)spi-&gt;controller_data;</span>
<span class="p_add">+	npcs_pin = (unsigned long)spi-&gt;controller_data;</span>
 
 	if (gpio_is_valid(spi-&gt;cs_gpio))
 		npcs_pin = spi-&gt;cs_gpio;
<span class="p_chunk">@@ -1255,7 +1255,7 @@</span> <span class="p_context"> static int atmel_spi_transfer_one_message(struct spi_master *master,</span>
 static void atmel_spi_cleanup(struct spi_device *spi)
 {
 	struct atmel_spi_device	*asd = spi-&gt;controller_state;
<span class="p_del">-	unsigned		gpio = (unsigned) spi-&gt;controller_data;</span>
<span class="p_add">+	unsigned		gpio = (unsigned long) spi-&gt;controller_data;</span>
 
 	if (!asd)
 		return;
<span class="p_header">diff --git a/drivers/spi/spi-pl022.c b/drivers/spi/spi-pl022.c</span>
<span class="p_header">index 02798036df8f..53a908e4219f 100644</span>
<span class="p_header">--- a/drivers/spi/spi-pl022.c</span>
<span class="p_header">+++ b/drivers/spi/spi-pl022.c</span>
<span class="p_chunk">@@ -1417,7 +1417,7 @@</span> <span class="p_context"> static void do_interrupt_dma_transfer(struct pl022 *pl022)</span>
 	 * Default is to enable all interrupts except RX -
 	 * this will be enabled once TX is complete
 	 */
<span class="p_del">-	u32 irqflags = ENABLE_ALL_INTERRUPTS &amp; ~SSP_IMSC_MASK_RXIM;</span>
<span class="p_add">+	u32 irqflags = (u32)(ENABLE_ALL_INTERRUPTS &amp; ~SSP_IMSC_MASK_RXIM);</span>
 
 	/* Enable target chip, if not already active */
 	if (!pl022-&gt;next_msg_cs_active)
<span class="p_header">diff --git a/drivers/spi/spi-rspi.c b/drivers/spi/spi-rspi.c</span>
<span class="p_header">index 10112745bb17..ddee9df1547d 100644</span>
<span class="p_header">--- a/drivers/spi/spi-rspi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-rspi.c</span>
<span class="p_chunk">@@ -630,7 +630,6 @@</span> <span class="p_context"> static int rspi_rz_transfer_one(struct spi_master *master,</span>
 				struct spi_transfer *xfer)
 {
 	struct rspi_data *rspi = spi_master_get_devdata(master);
<span class="p_del">-	int ret;</span>
 
 	rspi_rz_receive_init(rspi);
 
<span class="p_header">diff --git a/drivers/spmi/spmi.c b/drivers/spmi/spmi.c</span>
<span class="p_header">index 3b5780710d50..b93b404f6955 100644</span>
<span class="p_header">--- a/drivers/spmi/spmi.c</span>
<span class="p_header">+++ b/drivers/spmi/spmi.c</span>
<span class="p_chunk">@@ -354,11 +354,23 @@</span> <span class="p_context"> static int spmi_drv_remove(struct device *dev)</span>
 	return 0;
 }
 
<span class="p_add">+static int spmi_drv_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_device_uevent_modalias(dev, env);</span>
<span class="p_add">+	if (ret != -ENODEV)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct bus_type spmi_bus_type = {
 	.name		= &quot;spmi&quot;,
 	.match		= spmi_device_match,
 	.probe		= spmi_drv_probe,
 	.remove		= spmi_drv_remove,
<span class="p_add">+	.uevent		= spmi_drv_uevent,</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/staging/bcm/Kconfig b/drivers/staging/bcm/Kconfig</span>
<span class="p_header">index 8acf4b24a7c9..94e04701e008 100644</span>
<span class="p_header">--- a/drivers/staging/bcm/Kconfig</span>
<span class="p_header">+++ b/drivers/staging/bcm/Kconfig</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 config BCM_WIMAX
        tristate &quot;Beceem BCS200/BCS220-3 and BCSM250 wimax support&quot;
        depends on USB &amp;&amp; NET
<span class="p_add">+	depends on !64BIT</span>
        help
          This is an experimental driver for the Beceem WIMAX chipset used
 	 by Sprint 4G.
<span class="p_header">diff --git a/drivers/staging/dgnc/dgnc_tty.c b/drivers/staging/dgnc/dgnc_tty.c</span>
<span class="p_header">index 4135cb0ed9f5..cd7a6dbdddb8 100644</span>
<span class="p_header">--- a/drivers/staging/dgnc/dgnc_tty.c</span>
<span class="p_header">+++ b/drivers/staging/dgnc/dgnc_tty.c</span>
<span class="p_chunk">@@ -481,13 +481,18 @@</span> <span class="p_context"> void dgnc_sniff_nowait_nolock(struct channel_t *ch, uchar *text, uchar *buf, int</span>
 	int nbuf;
 	int i;
 	int tmpbuflen;
<span class="p_del">-	char tmpbuf[TMPBUFLEN];</span>
<span class="p_del">-	char *p = tmpbuf;</span>
<span class="p_add">+	char *tmpbuf;</span>
<span class="p_add">+	char *p;</span>
 	int too_much_data;
 
<span class="p_add">+	tmpbuf = kzalloc(TMPBUFLEN, GFP_KERNEL);</span>
<span class="p_add">+	if (!tmpbuf)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	p = tmpbuf;</span>
<span class="p_add">+</span>
 	/* Leave if sniff not open */
 	if (!(ch-&gt;ch_sniff_flags &amp; SNIFF_OPEN))
<span class="p_del">-		return;</span>
<span class="p_add">+		goto exit;</span>
 
 	do_gettimeofday(&amp;tv);
 
<span class="p_chunk">@@ -534,7 +539,7 @@</span> <span class="p_context"> void dgnc_sniff_nowait_nolock(struct channel_t *ch, uchar *text, uchar *buf, int</span>
 			 * function was probably called by the interrupt/timer routines!
 			 */
 			if (n == 0)
<span class="p_del">-				return;</span>
<span class="p_add">+				goto exit;</span>
 
 			/*
 			 * Copy as much data as will fit.
<span class="p_chunk">@@ -579,6 +584,9 @@</span> <span class="p_context"> void dgnc_sniff_nowait_nolock(struct channel_t *ch, uchar *text, uchar *buf, int</span>
 		}
 
 	} while (too_much_data);
<span class="p_add">+</span>
<span class="p_add">+exit:</span>
<span class="p_add">+	kfree(tmpbuf);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/staging/iio/adc/ad7192.c b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">index 83bb44b38152..26b2cdca29ad 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_chunk">@@ -236,7 +236,7 @@</span> <span class="p_context"> static int ad7192_setup(struct ad7192_state *st,</span>
 			st-&gt;mclk = pdata-&gt;ext_clk_Hz;
 		else
 			st-&gt;mclk = AD7192_INT_FREQ_MHz;
<span class="p_del">-			break;</span>
<span class="p_add">+		break;</span>
 	default:
 		ret = -EINVAL;
 		goto out;
<span class="p_header">diff --git a/drivers/staging/iio/resolver/ad2s1210.c b/drivers/staging/iio/resolver/ad2s1210.c</span>
<span class="p_header">index 7fbaba41c872..483a8350aa1f 100644</span>
<span class="p_header">--- a/drivers/staging/iio/resolver/ad2s1210.c</span>
<span class="p_header">+++ b/drivers/staging/iio/resolver/ad2s1210.c</span>
<span class="p_chunk">@@ -462,7 +462,7 @@</span> <span class="p_context"> static int ad2s1210_read_raw(struct iio_dev *indio_dev,</span>
 			     long m)
 {
 	struct ad2s1210_state *st = iio_priv(indio_dev);
<span class="p_del">-	bool negative;</span>
<span class="p_add">+	u16 negative;</span>
 	int ret = 0;
 	u16 pos;
 	s16 vel;
<span class="p_header">diff --git a/drivers/staging/imx-drm/imx-hdmi.c b/drivers/staging/imx-drm/imx-hdmi.c</span>
<span class="p_header">index 18c9ccd460b7..6943449a8a48 100644</span>
<span class="p_header">--- a/drivers/staging/imx-drm/imx-hdmi.c</span>
<span class="p_header">+++ b/drivers/staging/imx-drm/imx-hdmi.c</span>
<span class="p_chunk">@@ -968,7 +968,7 @@</span> <span class="p_context"> static void hdmi_config_AVI(struct imx_hdmi *hdmi)</span>
 	else
 		pix_fmt = HDMI_FC_AVICONF0_PIX_FMT_RGB;
 
<span class="p_del">-		under_scan =  HDMI_FC_AVICONF0_SCAN_INFO_NODATA;</span>
<span class="p_add">+	under_scan =  HDMI_FC_AVICONF0_SCAN_INFO_NODATA;</span>
 
 	/*
 	 * Active format identification data is present in the AVI InfoFrame.
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/llite/llite_lib.c b/drivers/staging/lustre/lustre/llite/llite_lib.c</span>
<span class="p_header">index 17cfa99b4fc0..764953089f64 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/llite/llite_lib.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/llite/llite_lib.c</span>
<span class="p_chunk">@@ -1489,7 +1489,7 @@</span> <span class="p_context"> int ll_setattr_raw(struct dentry *dentry, struct iattr *attr, bool hsm_import)</span>
 
 	if (attr-&gt;ia_valid &amp; (ATTR_SIZE |
 			      ATTR_ATIME | ATTR_ATIME_SET |
<span class="p_del">-			      ATTR_MTIME | ATTR_MTIME_SET))</span>
<span class="p_add">+			      ATTR_MTIME | ATTR_MTIME_SET)) {</span>
 		/* For truncate and utimes sending attributes to OSTs, setting
 		 * mtime/atime to the past will be performed under PW [0:EOF]
 		 * extent lock (new_size:EOF for truncate).  It may seem
<span class="p_chunk">@@ -1501,6 +1501,7 @@</span> <span class="p_context"> int ll_setattr_raw(struct dentry *dentry, struct iattr *attr, bool hsm_import)</span>
 		rc = ll_setattr_ost(inode, attr);
 		if (attr-&gt;ia_valid &amp; ATTR_SIZE)
 			up_write(&amp;lli-&gt;lli_trunc_sem);
<span class="p_add">+	}</span>
 out:
 	if (op_data) {
 		if (op_data-&gt;op_ioepoch) {
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/os_dep/usb_intf.c b/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_header">index d9552ba2c15d..208c9ba4e236 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_chunk">@@ -59,7 +59,9 @@</span> <span class="p_context"> static struct usb_device_id rtw_usb_id_tbl[] = {</span>
 	{USB_DEVICE(0x2001, 0x330F)}, /* DLink DWA-125 REV D1 */
 	{USB_DEVICE(0x2001, 0x3310)}, /* Dlink DWA-123 REV D1 */
 	{USB_DEVICE(0x2001, 0x3311)}, /* DLink GO-USB-N150 REV B1 */
<span class="p_add">+	{USB_DEVICE(0x2357, 0x010c)}, /* TP-Link TL-WN722N v2 */</span>
 	{USB_DEVICE(0x0df6, 0x0076)}, /* Sitecom N150 v2 */
<span class="p_add">+	{USB_DEVICE(USB_VENDER_ID_REALTEK, 0xffef)}, /* Rosewill RNX-N150NUB */</span>
 	{}	/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/staging/rtl8192ee/pci.c b/drivers/staging/rtl8192ee/pci.c</span>
<span class="p_header">index 3fe9b7ba01d6..1686b360e088 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8192ee/pci.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8192ee/pci.c</span>
<span class="p_chunk">@@ -882,8 +882,8 @@</span> <span class="p_context"> static void _rtl_pci_rx_interrupt(struct ieee80211_hw *hw)</span>
 
 		} else {
 			if (err_count++ &lt; 10) {
<span class="p_del">-				pr_info(&quot;skb-&gt;end (%d) - skb-&gt;tail (%d) &gt; len (%d)\n&quot;,</span>
<span class="p_del">-					skb-&gt;end, skb-&gt;tail, len);</span>
<span class="p_add">+				pr_info(&quot;skb end: %d) - tailroom (%d) &gt; len (%d)\n&quot;,</span>
<span class="p_add">+					skb_end_offset(skb), skb_tailroom(skb), len);</span>
 				RT_PRINT_DATA(rtlpriv, COMP_CMD, DBG_EMERG,
 					      &quot;RX desc\n&quot;,
 					      (u8 *)pdesc, 32);
<span class="p_header">diff --git a/drivers/staging/rtl8723au/core/rtw_wlan_util.c b/drivers/staging/rtl8723au/core/rtw_wlan_util.c</span>
<span class="p_header">index 579a4a8c8276..013ebd9629f3 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8723au/core/rtw_wlan_util.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8723au/core/rtw_wlan_util.c</span>
<span class="p_chunk">@@ -546,7 +546,7 @@</span> <span class="p_context"> void WMMOnAssocRsp23a(struct rtw_adapter *padapter)</span>
 	else
 		aSifsTime = 16;
 
<span class="p_del">-		for (i = 0; i &lt; 4; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; 4; i++) {</span>
 		ACI = (pmlmeinfo-&gt;WMM_param.ac_param[i].ACI_AIFSN &gt;&gt; 5) &amp; 0x03;
 		ACM = (pmlmeinfo-&gt;WMM_param.ac_param[i].ACI_AIFSN &gt;&gt; 4) &amp; 0x01;
 
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index e3ae2599a2b7..88ffe31053ed 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -2933,11 +2933,13 @@</span> <span class="p_context"> static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {</span>
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO &quot; SIOCSIWSENS \n&quot;);
 		rc = -EOPNOTSUPP;
 		break;
<span class="p_del">-</span>
 	case SIOCGIWAPLIST: {
<span class="p_del">-		char buffer[IW_MAX_AP * (sizeof(struct sockaddr) + sizeof(struct iw_quality))];</span>
<span class="p_add">+		char *buffer = kzalloc(IW_MAX_AP * (sizeof(struct sockaddr) +</span>
<span class="p_add">+				       sizeof(struct iw_quality)), GFP_KERNEL);</span>
 
<span class="p_del">-		if (wrq-&gt;u.data.pointer) {</span>
<span class="p_add">+		if (!buffer) {</span>
<span class="p_add">+			rc = -ENOMEM;</span>
<span class="p_add">+		} else if (wrq-&gt;u.data.pointer) {</span>
 			rc = iwctl_giwaplist(dev, NULL, &amp;(wrq-&gt;u.data), buffer);
 			if (rc == 0) {
 				if (copy_to_user(wrq-&gt;u.data.pointer,
<span class="p_chunk">@@ -2947,6 +2949,7 @@</span> <span class="p_context"> static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {</span>
 					rc = -EFAULT;
 			}
 		}
<span class="p_add">+		kfree(buffer);</span>
 	}
 	break;
 
<span class="p_chunk">@@ -2993,7 +2996,6 @@</span> <span class="p_context"> static int  device_ioctl(struct net_device *dev, struct ifreq *rq, int cmd) {</span>
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO &quot; SIOCGIWGENIE \n&quot;);
 		rc = iwctl_giwgenie(dev, NULL, &amp;(wrq-&gt;u.data), wrq-&gt;u.data.pointer);
 		break;
<span class="p_del">-</span>
 	case SIOCSIWENCODEEXT: {
 		char extra[sizeof(struct iw_encode_ext)+MAX_KEY_LEN+1];
 		DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO &quot; SIOCSIWENCODEEXT \n&quot;);
<span class="p_header">diff --git a/drivers/staging/wlan-ng/prism2fw.c b/drivers/staging/wlan-ng/prism2fw.c</span>
<span class="p_header">index f7870355c69f..45182ea4172f 100644</span>
<span class="p_header">--- a/drivers/staging/wlan-ng/prism2fw.c</span>
<span class="p_header">+++ b/drivers/staging/wlan-ng/prism2fw.c</span>
<span class="p_chunk">@@ -763,30 +763,35 @@</span> <span class="p_context"> static int plugimage(struct imgchunk *fchunk, unsigned int nfchunks,</span>
 static int read_cardpda(struct pda *pda, wlandevice_t *wlandev)
 {
 	int result = 0;
<span class="p_del">-	struct p80211msg_p2req_readpda msg;</span>
<span class="p_add">+	struct p80211msg_p2req_readpda *msg;</span>
<span class="p_add">+</span>
<span class="p_add">+	msg = kzalloc(sizeof(*msg), GFP_KERNEL);</span>
<span class="p_add">+	if (!msg)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	/* set up the msg */
<span class="p_del">-	msg.msgcode = DIDmsg_p2req_readpda;</span>
<span class="p_del">-	msg.msglen = sizeof(msg);</span>
<span class="p_del">-	strcpy(msg.devname, wlandev-&gt;name);</span>
<span class="p_del">-	msg.pda.did = DIDmsg_p2req_readpda_pda;</span>
<span class="p_del">-	msg.pda.len = HFA384x_PDA_LEN_MAX;</span>
<span class="p_del">-	msg.pda.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_del">-	msg.resultcode.did = DIDmsg_p2req_readpda_resultcode;</span>
<span class="p_del">-	msg.resultcode.len = sizeof(u32);</span>
<span class="p_del">-	msg.resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (prism2mgmt_readpda(wlandev, &amp;msg) != 0) {</span>
<span class="p_add">+	msg-&gt;msgcode = DIDmsg_p2req_readpda;</span>
<span class="p_add">+	msg-&gt;msglen = sizeof(msg);</span>
<span class="p_add">+	strcpy(msg-&gt;devname, wlandev-&gt;name);</span>
<span class="p_add">+	msg-&gt;pda.did = DIDmsg_p2req_readpda_pda;</span>
<span class="p_add">+	msg-&gt;pda.len = HFA384x_PDA_LEN_MAX;</span>
<span class="p_add">+	msg-&gt;pda.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_add">+	msg-&gt;resultcode.did = DIDmsg_p2req_readpda_resultcode;</span>
<span class="p_add">+	msg-&gt;resultcode.len = sizeof(u32);</span>
<span class="p_add">+	msg-&gt;resultcode.status = P80211ENUM_msgitem_status_no_value;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (prism2mgmt_readpda(wlandev, msg) != 0) {</span>
 		/* prism2mgmt_readpda prints an errno if appropriate */
 		result = -1;
<span class="p_del">-	} else if (msg.resultcode.data == P80211ENUM_resultcode_success) {</span>
<span class="p_del">-		memcpy(pda-&gt;buf, msg.pda.data, HFA384x_PDA_LEN_MAX);</span>
<span class="p_add">+	} else if (msg-&gt;resultcode.data == P80211ENUM_resultcode_success) {</span>
<span class="p_add">+		memcpy(pda-&gt;buf, msg-&gt;pda.data, HFA384x_PDA_LEN_MAX);</span>
 		result = mkpdrlist(pda);
 	} else {
 		/* resultcode must&#39;ve been something other than success */
 		result = -1;
 	}
 
<span class="p_add">+	kfree(msg);</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 1a4f09ab3866..e137dc7cfc72 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -431,6 +431,7 @@</span> <span class="p_context"> int iscsit_reset_np_thread(</span>
 		return 0;
 	}
 	np-&gt;np_thread_state = ISCSI_NP_THREAD_RESET;
<span class="p_add">+	atomic_inc(&amp;np-&gt;np_reset_count);</span>
 
 	if (np-&gt;np_thread) {
 		spin_unlock_bh(&amp;np-&gt;np_thread_lock);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_core.h b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index f8e14dda29f6..725c682b7692 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -792,6 +792,7 @@</span> <span class="p_context"> struct iscsi_np {</span>
 	int			np_sock_type;
 	enum np_thread_state_table np_thread_state;
 	bool                    enabled;
<span class="p_add">+	atomic_t		np_reset_count;</span>
 	enum iscsi_timer_flags_table np_login_timer_flags;
 	u32			np_exports;
 	enum np_flags_table	np_flags;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 850c977b6df3..2ab8081267f9 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -1277,9 +1277,11 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 	flush_signals(current);
 
 	spin_lock_bh(&amp;np-&gt;np_thread_lock);
<span class="p_del">-	if (np-&gt;np_thread_state == ISCSI_NP_THREAD_RESET) {</span>
<span class="p_add">+	if (atomic_dec_if_positive(&amp;np-&gt;np_reset_count) &gt;= 0) {</span>
 		np-&gt;np_thread_state = ISCSI_NP_THREAD_ACTIVE;
<span class="p_add">+		spin_unlock_bh(&amp;np-&gt;np_thread_lock);</span>
 		complete(&amp;np-&gt;np_restart_comp);
<span class="p_add">+		return 1;</span>
 	} else if (np-&gt;np_thread_state == ISCSI_NP_THREAD_SHUTDOWN) {
 		spin_unlock_bh(&amp;np-&gt;np_thread_lock);
 		goto exit;
<span class="p_chunk">@@ -1312,7 +1314,8 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 		goto exit;
 	} else if (rc &lt; 0) {
 		spin_lock_bh(&amp;np-&gt;np_thread_lock);
<span class="p_del">-		if (np-&gt;np_thread_state == ISCSI_NP_THREAD_RESET) {</span>
<span class="p_add">+		if (atomic_dec_if_positive(&amp;np-&gt;np_reset_count) &gt;= 0) {</span>
<span class="p_add">+			np-&gt;np_thread_state = ISCSI_NP_THREAD_ACTIVE;</span>
 			spin_unlock_bh(&amp;np-&gt;np_thread_lock);
 			complete(&amp;np-&gt;np_restart_comp);
 			iscsit_put_transport(conn-&gt;conn_transport);
<span class="p_header">diff --git a/drivers/tty/isicom.c b/drivers/tty/isicom.c</span>
<span class="p_header">index 858291ca889c..c03ecaa0af7f 100644</span>
<span class="p_header">--- a/drivers/tty/isicom.c</span>
<span class="p_header">+++ b/drivers/tty/isicom.c</span>
<span class="p_chunk">@@ -1055,7 +1055,7 @@</span> <span class="p_context"> static int isicom_send_break(struct tty_struct *tty, int length)</span>
 
 	outw(0x8000 | ((port-&gt;channel) &lt;&lt; (card-&gt;shift_count)) | 0x3, base);
 	outw((length &amp; 0xff) &lt;&lt; 8 | 0x00, base);
<span class="p_del">-	outw((length &amp; 0xff00), base);</span>
<span class="p_add">+	outw((length &amp; 0xff00u), base);</span>
 	InterruptTheCard(base);
 
 	unlock_card(card);
<span class="p_header">diff --git a/drivers/tty/nozomi.c b/drivers/tty/nozomi.c</span>
<span class="p_header">index cd0429369557..b5b1b195ff2c 100644</span>
<span class="p_header">--- a/drivers/tty/nozomi.c</span>
<span class="p_header">+++ b/drivers/tty/nozomi.c</span>
<span class="p_chunk">@@ -823,7 +823,7 @@</span> <span class="p_context"> static int receive_data(enum port_type index, struct nozomi *dc)</span>
 	struct tty_struct *tty = tty_port_tty_get(&amp;port-&gt;port);
 	int i, ret;
 
<span class="p_del">-	read_mem32((u32 *) &amp;size, addr, 4);</span>
<span class="p_add">+	size = __le32_to_cpu(readl(addr));</span>
 	/*  DBG1( &quot;%d bytes port: %d&quot;, size, index); */
 
 	if (tty &amp;&amp; test_bit(TTY_THROTTLED, &amp;tty-&gt;flags)) {
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 2c34b1e444a4..ef71827f92a3 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1772,6 +1772,9 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	{ USB_DEVICE(0x1576, 0x03b1), /* Maretron USB100 */
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
<span class="p_add">+	{ USB_DEVICE(0xfff0, 0x0100), /* DATECS FP-2000 */</span>
<span class="p_add">+	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */</span>
<span class="p_add">+	},</span>
 
 	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */
 	.driver_info = CLEAR_HALT_CONDITIONS,
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 627038883c55..063d9767d6fe 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -607,15 +607,23 @@</span> <span class="p_context"> static int usb_parse_configuration(struct usb_device *dev, int cfgidx,</span>
 
 		} else if (header-&gt;bDescriptorType ==
 				USB_DT_INTERFACE_ASSOCIATION) {
<span class="p_add">+			struct usb_interface_assoc_descriptor *d;</span>
<span class="p_add">+</span>
<span class="p_add">+			d = (struct usb_interface_assoc_descriptor *)header;</span>
<span class="p_add">+			if (d-&gt;bLength &lt; USB_DT_INTERFACE_ASSOCIATION_SIZE) {</span>
<span class="p_add">+				dev_warn(ddev,</span>
<span class="p_add">+					 &quot;config %d has an invalid interface association descriptor of length %d, skipping\n&quot;,</span>
<span class="p_add">+					 cfgno, d-&gt;bLength);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (iad_num == USB_MAXIADS) {
 				dev_warn(ddev, &quot;found more Interface &quot;
 					       &quot;Association Descriptors &quot;
 					       &quot;than allocated for in &quot;
 					       &quot;configuration %d\n&quot;, cfgno);
 			} else {
<span class="p_del">-				config-&gt;intf_assoc[iad_num] =</span>
<span class="p_del">-					(struct usb_interface_assoc_descriptor</span>
<span class="p_del">-					*)header;</span>
<span class="p_add">+				config-&gt;intf_assoc[iad_num] = d;</span>
 				iad_num++;
 			}
 
<span class="p_chunk">@@ -916,10 +924,12 @@</span> <span class="p_context"> int usb_get_bos_descriptor(struct usb_device *dev)</span>
 	for (i = 0; i &lt; num; i++) {
 		buffer += length;
 		cap = (struct usb_dev_cap_header *)buffer;
<span class="p_del">-		length = cap-&gt;bLength;</span>
 
<span class="p_del">-		if (total_len &lt; length)</span>
<span class="p_add">+		if (total_len &lt; sizeof(*cap) || total_len &lt; cap-&gt;bLength) {</span>
<span class="p_add">+			dev-&gt;bos-&gt;desc-&gt;bNumDeviceCaps = i;</span>
 			break;
<span class="p_add">+		}</span>
<span class="p_add">+		length = cap-&gt;bLength;</span>
 		total_len -= length;
 
 		if (cap-&gt;bDescriptorType != USB_DT_DEVICE_CAPABILITY) {
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 495f6949ebf6..865bc662b28c 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -2402,6 +2402,8 @@</span> <span class="p_context"> void usb_hc_died (struct usb_hcd *hcd)</span>
 	}
 	if (usb_hcd_is_primary_hcd(hcd) &amp;&amp; hcd-&gt;shared_hcd) {
 		hcd = hcd-&gt;shared_hcd;
<span class="p_add">+		clear_bit(HCD_FLAG_RH_RUNNING, &amp;hcd-&gt;flags);</span>
<span class="p_add">+		set_bit(HCD_FLAG_DEAD, &amp;hcd-&gt;flags);</span>
 		if (hcd-&gt;rh_registered) {
 			clear_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
 
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 25892de366b4..598e9adf8858 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -4602,7 +4602,8 @@</span> <span class="p_context"> hub_power_remaining (struct usb_hub *hub)</span>
 static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,
 		u16 portchange)
 {
<span class="p_del">-	int status, i;</span>
<span class="p_add">+	int status = -ENODEV;</span>
<span class="p_add">+	int i;</span>
 	unsigned unit_load;
 	struct usb_device *hdev = hub-&gt;hdev;
 	struct usb_hcd *hcd = bus_to_hcd(hdev-&gt;bus);
<span class="p_chunk">@@ -4799,9 +4800,10 @@</span> <span class="p_context"> static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span>
 
 done:
 	hub_port_disable(hub, port1, 1);
<span class="p_del">-	if (hcd-&gt;driver-&gt;relinquish_port &amp;&amp; !hub-&gt;hdev-&gt;parent)</span>
<span class="p_del">-		hcd-&gt;driver-&gt;relinquish_port(hcd, port1);</span>
<span class="p_del">-</span>
<span class="p_add">+	if (hcd-&gt;driver-&gt;relinquish_port &amp;&amp; !hub-&gt;hdev-&gt;parent) {</span>
<span class="p_add">+		if (status != -ENOTCONN &amp;&amp; status != -ENODEV)</span>
<span class="p_add">+			hcd-&gt;driver-&gt;relinquish_port(hcd, port1);</span>
<span class="p_add">+	}</span>
 }
 
 /* Handle physical or logical connection change events.
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 59106b01dc20..88a49b1f8bbb 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -147,6 +147,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* appletouch */
 	{ USB_DEVICE(0x05ac, 0x021a), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_add">+	/* Genesys Logic hub, internally used by Moshi USB to Ethernet Adapter */</span>
<span class="p_add">+	{ USB_DEVICE(0x05e3, 0x0616), .driver_info = USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
 	/* Avision AV600U */
 	{ USB_DEVICE(0x0638, 0x0a13), .driver_info =
 	  USB_QUIRK_STRING_FETCH_255 },
<span class="p_chunk">@@ -246,6 +249,7 @@</span> <span class="p_context"> static const struct usb_device_id usb_amd_resume_quirk_list[] = {</span>
 	{ USB_DEVICE(0x093a, 0x2500), .driver_info = USB_QUIRK_RESET_RESUME },
 	{ USB_DEVICE(0x093a, 0x2510), .driver_info = USB_QUIRK_RESET_RESUME },
 	{ USB_DEVICE(0x093a, 0x2521), .driver_info = USB_QUIRK_RESET_RESUME },
<span class="p_add">+	{ USB_DEVICE(0x03f0, 0x2b4a), .driver_info = USB_QUIRK_RESET_RESUME },</span>
 
 	/* Logitech Optical Mouse M90/M100 */
 	{ USB_DEVICE(0x046d, 0xc05a), .driver_info = USB_QUIRK_RESET_RESUME },
<span class="p_header">diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">index f4e6b945136c..94039dc5de72 100644</span>
<span class="p_header">--- a/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">+++ b/drivers/usb/host/pci-quirks.c</span>
<span class="p_chunk">@@ -78,6 +78,16 @@</span> <span class="p_context"></span>
 #define USB_INTEL_USB3_PSSEN   0xD8
 #define USB_INTEL_USB3PRM      0xDC
 
<span class="p_add">+/* ASMEDIA quirk use */</span>
<span class="p_add">+#define ASMT_DATA_WRITE0_REG	0xF8</span>
<span class="p_add">+#define ASMT_DATA_WRITE1_REG	0xFC</span>
<span class="p_add">+#define ASMT_CONTROL_REG	0xE0</span>
<span class="p_add">+#define ASMT_CONTROL_WRITE_BIT	0x02</span>
<span class="p_add">+#define ASMT_WRITEREG_CMD	0x10423</span>
<span class="p_add">+#define ASMT_FLOWCTL_ADDR	0xFA30</span>
<span class="p_add">+#define ASMT_FLOWCTL_DATA	0xBA</span>
<span class="p_add">+#define ASMT_PSEUDO_DATA	0</span>
<span class="p_add">+</span>
 /*
  * amd_chipset_gen values represent AMD different chipset generations
  */
<span class="p_chunk">@@ -89,6 +99,7 @@</span> <span class="p_context"> enum amd_chipset_gen {</span>
 	AMD_CHIPSET_HUDSON2,
 	AMD_CHIPSET_BOLTON,
 	AMD_CHIPSET_YANGTZE,
<span class="p_add">+	AMD_CHIPSET_TAISHAN,</span>
 	AMD_CHIPSET_UNKNOWN,
 };
 
<span class="p_chunk">@@ -132,6 +143,11 @@</span> <span class="p_context"> static int amd_chipset_sb_type_init(struct amd_chipset_info *pinfo)</span>
 			pinfo-&gt;sb_type.gen = AMD_CHIPSET_SB700;
 		else if (rev &gt;= 0x40 &amp;&amp; rev &lt;= 0x4f)
 			pinfo-&gt;sb_type.gen = AMD_CHIPSET_SB800;
<span class="p_add">+	}</span>
<span class="p_add">+	pinfo-&gt;smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,</span>
<span class="p_add">+					  0x145c, NULL);</span>
<span class="p_add">+	if (pinfo-&gt;smbus_dev) {</span>
<span class="p_add">+		pinfo-&gt;sb_type.gen = AMD_CHIPSET_TAISHAN;</span>
 	} else {
 		pinfo-&gt;smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,
 				PCI_DEVICE_ID_AMD_HUDSON2_SMBUS, NULL);
<span class="p_chunk">@@ -253,11 +269,12 @@</span> <span class="p_context"> int usb_hcd_amd_remote_wakeup_quirk(struct pci_dev *pdev)</span>
 {
 	/* Make sure amd chipset type has already been initialized */
 	usb_amd_find_chipset_info();
<span class="p_del">-	if (amd_chipset.sb_type.gen != AMD_CHIPSET_YANGTZE)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_dbg(&amp;pdev-&gt;dev, &quot;QUIRK: Enable AMD remote wakeup fix\n&quot;);</span>
<span class="p_del">-	return 1;</span>
<span class="p_add">+	if (amd_chipset.sb_type.gen == AMD_CHIPSET_YANGTZE ||</span>
<span class="p_add">+	    amd_chipset.sb_type.gen == AMD_CHIPSET_TAISHAN) {</span>
<span class="p_add">+		dev_dbg(&amp;pdev-&gt;dev, &quot;QUIRK: Enable AMD remote wakeup fix\n&quot;);</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL_GPL(usb_hcd_amd_remote_wakeup_quirk);
 
<span class="p_chunk">@@ -415,6 +432,50 @@</span> <span class="p_context"> void usb_amd_quirk_pll_disable(void)</span>
 }
 EXPORT_SYMBOL_GPL(usb_amd_quirk_pll_disable);
 
<span class="p_add">+static int usb_asmedia_wait_write(struct pci_dev *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long retry_count;</span>
<span class="p_add">+	unsigned char value;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (retry_count = 1000; retry_count &gt; 0; --retry_count) {</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_read_config_byte(pdev, ASMT_CONTROL_REG, &amp;value);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (value == 0xff) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev, &quot;%s: check_ready ERROR&quot;, __func__);</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((value &amp; ASMT_CONTROL_WRITE_BIT) == 0)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		usleep_range(40, 60);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_warn(&amp;pdev-&gt;dev, &quot;%s: check_write_ready timeout&quot;, __func__);</span>
<span class="p_add">+	return -ETIMEDOUT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (usb_asmedia_wait_write(pdev) != 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* send command and address to device */</span>
<span class="p_add">+	pci_write_config_dword(pdev, ASMT_DATA_WRITE0_REG, ASMT_WRITEREG_CMD);</span>
<span class="p_add">+	pci_write_config_dword(pdev, ASMT_DATA_WRITE1_REG, ASMT_FLOWCTL_ADDR);</span>
<span class="p_add">+	pci_write_config_byte(pdev, ASMT_CONTROL_REG, ASMT_CONTROL_WRITE_BIT);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (usb_asmedia_wait_write(pdev) != 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* send data to device */</span>
<span class="p_add">+	pci_write_config_dword(pdev, ASMT_DATA_WRITE0_REG, ASMT_FLOWCTL_DATA);</span>
<span class="p_add">+	pci_write_config_dword(pdev, ASMT_DATA_WRITE1_REG, ASMT_PSEUDO_DATA);</span>
<span class="p_add">+	pci_write_config_byte(pdev, ASMT_CONTROL_REG, ASMT_CONTROL_WRITE_BIT);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(usb_asmedia_modifyflowcontrol);</span>
<span class="p_add">+</span>
 void usb_amd_quirk_pll_enable(void)
 {
 	usb_amd_quirk_pll(0);
<span class="p_header">diff --git a/drivers/usb/host/pci-quirks.h b/drivers/usb/host/pci-quirks.h</span>
<span class="p_header">index c622ddf21c94..6463fdb403c2 100644</span>
<span class="p_header">--- a/drivers/usb/host/pci-quirks.h</span>
<span class="p_header">+++ b/drivers/usb/host/pci-quirks.h</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"> bool usb_amd_prefetch_quirk(void);</span>
 void usb_amd_dev_put(void);
 void usb_amd_quirk_pll_disable(void);
 void usb_amd_quirk_pll_enable(void);
<span class="p_add">+void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev);</span>
 void usb_enable_intel_xhci_ports(struct pci_dev *xhci_pdev);
 void usb_disable_xhci_ports(struct pci_dev *xhci_pdev);
 void sb800_prefetch(struct device *dev, int on);
<span class="p_chunk">@@ -18,6 +19,7 @@</span> <span class="p_context"> void sb800_prefetch(struct device *dev, int on);</span>
 struct pci_dev;
 static inline void usb_amd_quirk_pll_disable(void) {}
 static inline void usb_amd_quirk_pll_enable(void) {}
<span class="p_add">+static inline void usb_asmedia_modifyflowcontrol(struct pci_dev *pdev) {}</span>
 static inline void usb_amd_dev_put(void) {}
 static inline void usb_disable_xhci_ports(struct pci_dev *xhci_pdev) {}
 static inline void sb800_prefetch(struct device *dev, int on) {}
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 48562be0f07f..76628f9e39ba 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -644,6 +644,9 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 			clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);
 
 			set_bit(wIndex, &amp;bus_state-&gt;rexit_ports);
<span class="p_add">+</span>
<span class="p_add">+			xhci_test_and_clear_bit(xhci, port_array, wIndex,</span>
<span class="p_add">+						PORT_PLC);</span>
 			xhci_set_link_state(xhci, port_array, wIndex,
 					XDEV_U0);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 60edc9668935..cc40aa7529e2 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -52,6 +52,8 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_2			0x43bb
 #define PCI_DEVICE_ID_AMD_PROMONTORYA_1			0x43bc
 
<span class="p_add">+#define PCI_DEVICE_ID_ASMEDIA_1042A_XHCI		0x1142</span>
<span class="p_add">+</span>
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
 /* called after powerup, by probe or system-pm &quot;wakeup&quot; */
<span class="p_chunk">@@ -198,6 +200,10 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 			pdev-&gt;device == 0x1142)
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;</span>
<span class="p_add">+		pdev-&gt;device == PCI_DEVICE_ID_ASMEDIA_1042A_XHCI)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_ASMEDIA_MODIFY_FLOWCONTROL;</span>
<span class="p_add">+</span>
 	if (xhci-&gt;quirks &amp; XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
 				&quot;QUIRK: Resetting on resume&quot;);
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 97a3955650c9..e69c7df4b9a9 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -821,13 +821,16 @@</span> <span class="p_context"> static void xhci_kill_endpoint_urbs(struct xhci_hcd *xhci,</span>
 			(ep-&gt;ep_state &amp; EP_GETTING_NO_STREAMS)) {
 		int stream_id;
 
<span class="p_del">-		for (stream_id = 0; stream_id &lt; ep-&gt;stream_info-&gt;num_streams;</span>
<span class="p_add">+		for (stream_id = 1; stream_id &lt; ep-&gt;stream_info-&gt;num_streams;</span>
 				stream_id++) {
<span class="p_add">+			ring = ep-&gt;stream_info-&gt;stream_rings[stream_id];</span>
<span class="p_add">+			if (!ring)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
 			xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 					&quot;Killing URBs for slot ID %u, ep index %u, stream %u&quot;,
<span class="p_del">-					slot_id, ep_index, stream_id + 1);</span>
<span class="p_del">-			xhci_kill_ring_urbs(xhci,</span>
<span class="p_del">-					ep-&gt;stream_info-&gt;stream_rings[stream_id]);</span>
<span class="p_add">+					slot_id, ep_index, stream_id);</span>
<span class="p_add">+			xhci_kill_ring_urbs(xhci, ring);</span>
 		}
 	} else {
 		ring = ep-&gt;ring;
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index af2be1476d8a..45654fffa7a5 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -191,6 +191,9 @@</span> <span class="p_context"> int xhci_reset(struct xhci_hcd *xhci)</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_ASMEDIA_MODIFY_FLOWCONTROL)</span>
<span class="p_add">+		usb_asmedia_modifyflowcontrol(to_pci_dev(xhci_to_hcd(xhci)-&gt;self.controller));</span>
<span class="p_add">+</span>
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
 			 &quot;Wait for controller to be ready for doorbell rings&quot;);
 	/*
<span class="p_chunk">@@ -659,8 +662,10 @@</span> <span class="p_context"> int xhci_run(struct usb_hcd *hcd)</span>
 		command = xhci_alloc_command(xhci, false, false, GFP_KERNEL);
 		if (!command)
 			return -ENOMEM;
<span class="p_del">-		xhci_queue_vendor_command(xhci, command, 0, 0, 0,</span>
<span class="p_add">+		ret = xhci_queue_vendor_command(xhci, command, 0, 0, 0,</span>
 				TRB_TYPE(TRB_NEC_GET_FW));
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			xhci_free_command(xhci, command);</span>
 	}
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
 			&quot;Finished xhci_run for USB2 roothub&quot;);
<span class="p_chunk">@@ -1116,6 +1121,9 @@</span> <span class="p_context"> int xhci_resume(struct xhci_hcd *xhci, bool hibernated)</span>
 	if ((xhci-&gt;quirks &amp; XHCI_COMP_MODE_QUIRK) &amp;&amp; !comp_timer_running)
 		compliance_mode_recovery_timer_init(xhci);
 
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_ASMEDIA_MODIFY_FLOWCONTROL)</span>
<span class="p_add">+		usb_asmedia_modifyflowcontrol(to_pci_dev(hcd-&gt;self.controller));</span>
<span class="p_add">+</span>
 	/* Re-enable port polling. */
 	xhci_dbg(xhci, &quot;%s: starting port polling.\n&quot;, __func__);
 	set_bit(HCD_FLAG_POLL_RH, &amp;hcd-&gt;flags);
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 92e852cc3944..746ffa720ae4 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1570,6 +1570,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define XHCI_PME_STUCK_QUIRK	(1 &lt;&lt; 20)
 #define XHCI_MISSING_CAS	(1 &lt;&lt; 24)
 #define XHCI_U2_DISABLE_WAKE	(1 &lt;&lt; 27)
<span class="p_add">+#define XHCI_ASMEDIA_MODIFY_FLOWCONTROL	(1 &lt;&lt; 28)</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c</span>
<span class="p_header">index 419a5b3cb924..8fc6b8bdd1ba 100644</span>
<span class="p_header">--- a/drivers/usb/misc/usbtest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/usbtest.c</span>
<span class="p_chunk">@@ -164,12 +164,13 @@</span> <span class="p_context"> get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)</span>
 			return tmp;
 	}
 
<span class="p_del">-	if (in) {</span>
<span class="p_add">+	if (in)</span>
 		dev-&gt;in_pipe = usb_rcvbulkpipe(udev,
 			in-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
<span class="p_add">+	if (out)</span>
 		dev-&gt;out_pipe = usb_sndbulkpipe(udev,
 			out-&gt;desc.bEndpointAddress &amp; USB_ENDPOINT_NUMBER_MASK);
<span class="p_del">-	}</span>
<span class="p_add">+</span>
 	if (iso_in) {
 		dev-&gt;iso_in = &amp;iso_in-&gt;desc;
 		dev-&gt;in_iso_pipe = usb_rcvisocpipe(udev,
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/common.c b/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_header">index 17267b0a2e95..e1648e4230ac 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_chunk">@@ -600,8 +600,10 @@</span> <span class="p_context"> static int usbhsc_resume(struct device *dev)</span>
 	struct usbhs_priv *priv = dev_get_drvdata(dev);
 	struct platform_device *pdev = usbhs_priv_to_pdev(priv);
 
<span class="p_del">-	if (!usbhsc_flags_has(priv, USBHSF_RUNTIME_PWCTRL))</span>
<span class="p_add">+	if (!usbhsc_flags_has(priv, USBHSF_RUNTIME_PWCTRL)) {</span>
 		usbhsc_power_ctrl(priv, 1);
<span class="p_add">+		usbhs_mod_autonomy_mode(priv);</span>
<span class="p_add">+	}</span>
 
 	usbhs_platform_call(priv, phy_reset, pdev);
 
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index 6583c04cc35e..5732dd0fbd27 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"> struct usbhsg_gpriv;</span>
 struct usbhsg_uep {
 	struct usb_ep		 ep;
 	struct usbhs_pipe	*pipe;
<span class="p_add">+	spinlock_t		lock;	/* protect the pipe */</span>
 
 	char ep_name[EP_NAME_SIZE];
 
<span class="p_chunk">@@ -126,7 +127,8 @@</span> <span class="p_context"> static void usbhsg_queue_pop(struct usbhsg_uep *uep,</span>
 	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);
 	struct device *dev = usbhsg_gpriv_to_dev(gpriv);
 
<span class="p_del">-	dev_dbg(dev, &quot;pipe %d : queue pop\n&quot;, usbhs_pipe_number(pipe));</span>
<span class="p_add">+	if (pipe)</span>
<span class="p_add">+		dev_dbg(dev, &quot;pipe %d : queue pop\n&quot;, usbhs_pipe_number(pipe));</span>
 
 	ureq-&gt;req.status = status;
 	ureq-&gt;req.complete(&amp;uep-&gt;ep, &amp;ureq-&gt;req);
<span class="p_chunk">@@ -607,15 +609,26 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 static int usbhsg_ep_disable(struct usb_ep *ep)
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
<span class="p_add">+	struct usbhs_pipe *pipe;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int ret = 0;</span>
 
<span class="p_del">-	if (!uep-&gt;pipe)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	spin_lock_irqsave(&amp;uep-&gt;lock, flags);</span>
<span class="p_add">+	pipe = usbhsg_uep_to_pipe(uep);</span>
<span class="p_add">+	if (!pipe) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	usbhsg_pipe_disable(uep);
<span class="p_add">+	usbhs_pipe_free(pipe);</span>
 
 	uep-&gt;pipe-&gt;mod_private	= NULL;
 	uep-&gt;pipe		= NULL;
 
<span class="p_add">+out:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;uep-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -665,10 +678,20 @@</span> <span class="p_context"> static int usbhsg_ep_dequeue(struct usb_ep *ep, struct usb_request *req)</span>
 {
 	struct usbhsg_uep *uep = usbhsg_ep_to_uep(ep);
 	struct usbhsg_request *ureq = usbhsg_req_to_ureq(req);
<span class="p_del">-	struct usbhs_pipe *pipe = usbhsg_uep_to_pipe(uep);</span>
<span class="p_add">+	struct usbhs_pipe *pipe;</span>
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_del">-	usbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));</span>
<span class="p_add">+	spin_lock_irqsave(&amp;uep-&gt;lock, flags);</span>
<span class="p_add">+	pipe = usbhsg_uep_to_pipe(uep);</span>
<span class="p_add">+	if (pipe)</span>
<span class="p_add">+		usbhs_pkt_pop(pipe, usbhsg_ureq_to_pkt(ureq));</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * To dequeue a request, this driver should call the usbhsg_queue_pop()</span>
<span class="p_add">+	 * even if the pipe is NULL.</span>
<span class="p_add">+	 */</span>
 	usbhsg_queue_pop(uep, ureq, -ECONNRESET);
<span class="p_add">+	spin_unlock_irqrestore(&amp;uep-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -795,10 +818,10 @@</span> <span class="p_context"> static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)</span>
 {
 	struct usbhsg_gpriv *gpriv = usbhsg_priv_to_gpriv(priv);
 	struct usbhs_mod *mod = usbhs_mod_get_current(priv);
<span class="p_del">-	struct usbhsg_uep *dcp = usbhsg_gpriv_to_dcp(gpriv);</span>
<span class="p_add">+	struct usbhsg_uep *uep;</span>
 	struct device *dev = usbhs_priv_to_dev(priv);
 	unsigned long flags;
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, i;</span>
 
 	/********************  spin lock ********************/
 	usbhs_lock(priv, flags);
<span class="p_chunk">@@ -830,7 +853,9 @@</span> <span class="p_context"> static int usbhsg_try_stop(struct usbhs_priv *priv, u32 status)</span>
 	usbhs_sys_set_test_mode(priv, 0);
 	usbhs_sys_function_ctrl(priv, 0);
 
<span class="p_del">-	usbhsg_ep_disable(&amp;dcp-&gt;ep);</span>
<span class="p_add">+	/* disable all eps */</span>
<span class="p_add">+	usbhsg_for_each_uep_with_dcp(uep, gpriv, i)</span>
<span class="p_add">+		usbhsg_ep_disable(&amp;uep-&gt;ep);</span>
 
 	dev_dbg(dev, &quot;stop gadget\n&quot;);
 
<span class="p_chunk">@@ -950,6 +975,7 @@</span> <span class="p_context"> int usbhs_mod_gadget_probe(struct usbhs_priv *priv)</span>
 		ret = -ENOMEM;
 		goto usbhs_mod_gadget_probe_err_gpriv;
 	}
<span class="p_add">+	spin_lock_init(&amp;uep-&gt;lock);</span>
 
 	/*
 	 * CAUTION
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/pipe.c b/drivers/usb/renesas_usbhs/pipe.c</span>
<span class="p_header">index 7926e1c700f1..aa611807661a 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/pipe.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/pipe.c</span>
<span class="p_chunk">@@ -640,6 +640,11 @@</span> <span class="p_context"> static struct usbhs_pipe *usbhsp_get_pipe(struct usbhs_priv *priv, u32 type)</span>
 	return pipe;
 }
 
<span class="p_add">+static void usbhsp_put_pipe(struct usbhs_pipe *pipe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	usbhsp_flags_init(pipe);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void usbhs_pipe_init(struct usbhs_priv *priv,
 		     int (*dma_map_ctrl)(struct usbhs_pkt *pkt, int map))
 {
<span class="p_chunk">@@ -726,6 +731,11 @@</span> <span class="p_context"> struct usbhs_pipe *usbhs_pipe_malloc(struct usbhs_priv *priv,</span>
 	return pipe;
 }
 
<span class="p_add">+void usbhs_pipe_free(struct usbhs_pipe *pipe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	usbhsp_put_pipe(pipe);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void usbhs_pipe_select_fifo(struct usbhs_pipe *pipe, struct usbhs_fifo *fifo)
 {
 	if (pipe-&gt;fifo)
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/pipe.h b/drivers/usb/renesas_usbhs/pipe.h</span>
<span class="p_header">index 3e5349879838..406f36d050e4 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/pipe.h</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/pipe.h</span>
<span class="p_chunk">@@ -75,6 +75,7 @@</span> <span class="p_context"> struct usbhs_pipe_info {</span>
 char *usbhs_pipe_name(struct usbhs_pipe *pipe);
 struct usbhs_pipe
 *usbhs_pipe_malloc(struct usbhs_priv *priv, int endpoint_type, int dir_in);
<span class="p_add">+void usbhs_pipe_free(struct usbhs_pipe *pipe);</span>
 int usbhs_pipe_probe(struct usbhs_priv *priv);
 void usbhs_pipe_remove(struct usbhs_priv *priv);
 int usbhs_pipe_is_dir_in(struct usbhs_pipe *pipe);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 0786281108f6..8f8f4aed5fbb 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */
 	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */
 	{ USB_DEVICE(0x10C4, 0x8A5E) }, /* CEL EM3588 ZigBee USB Stick Long Range */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8B34) }, /* Qivicon ZigBee USB Radio Stick */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 475104bb3395..9cd199cbac2e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -2036,6 +2036,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7d04, 0xff) },			/* D-Link DWM-158 */
 	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7e19, 0xff),			/* D-Link DWM-221 B1 */
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7e35, 0xff),			/* D-Link DWM-222 */</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x7e11, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/A3 */
<span class="p_header">diff --git a/drivers/usb/storage/isd200.c b/drivers/usb/storage/isd200.c</span>
<span class="p_header">index 599d8bff26c3..420e096ac09b 100644</span>
<span class="p_header">--- a/drivers/usb/storage/isd200.c</span>
<span class="p_header">+++ b/drivers/usb/storage/isd200.c</span>
<span class="p_chunk">@@ -1522,8 +1522,11 @@</span> <span class="p_context"> static void isd200_ata_command(struct scsi_cmnd *srb, struct us_data *us)</span>
 
 	/* Make sure driver was initialized */
 
<span class="p_del">-	if (us-&gt;extra == NULL)</span>
<span class="p_add">+	if (us-&gt;extra == NULL) {</span>
 		usb_stor_dbg(us, &quot;ERROR Driver not initialized\n&quot;);
<span class="p_add">+		srb-&gt;result = DID_ERROR &lt;&lt; 16;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
 	scsi_set_resid(srb, 0);
 	/* scsi_bufflen might change in protocol translation to ata */
<span class="p_header">diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">index f58caa9e6a27..a155cd02bce2 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">+++ b/drivers/usb/storage/uas-detect.h</span>
<span class="p_chunk">@@ -9,7 +9,8 @@</span> <span class="p_context"> static int uas_is_interface(struct usb_host_interface *intf)</span>
 		intf-&gt;desc.bInterfaceProtocol == USB_PR_UAS);
 }
 
<span class="p_del">-static int uas_find_uas_alt_setting(struct usb_interface *intf)</span>
<span class="p_add">+static struct usb_host_interface *uas_find_uas_alt_setting(</span>
<span class="p_add">+		struct usb_interface *intf)</span>
 {
 	int i;
 
<span class="p_chunk">@@ -17,10 +18,10 @@</span> <span class="p_context"> static int uas_find_uas_alt_setting(struct usb_interface *intf)</span>
 		struct usb_host_interface *alt = &amp;intf-&gt;altsetting[i];
 
 		if (uas_is_interface(alt))
<span class="p_del">-			return alt-&gt;desc.bAlternateSetting;</span>
<span class="p_add">+			return alt;</span>
 	}
 
<span class="p_del">-	return -ENODEV;</span>
<span class="p_add">+	return NULL;</span>
 }
 
 static int uas_find_endpoints(struct usb_host_interface *alt,
<span class="p_chunk">@@ -58,14 +59,14 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);
 	unsigned long flags = id-&gt;driver_info;
<span class="p_del">-	int r, alt;</span>
<span class="p_del">-</span>
<span class="p_add">+	struct usb_host_interface *alt;</span>
<span class="p_add">+	int r;</span>
 
 	alt = uas_find_uas_alt_setting(intf);
<span class="p_del">-	if (alt &lt; 0)</span>
<span class="p_add">+	if (!alt)</span>
 		return 0;
 
<span class="p_del">-	r = uas_find_endpoints(&amp;intf-&gt;altsetting[alt], eps);</span>
<span class="p_add">+	r = uas_find_endpoints(alt, eps);</span>
 	if (r &lt; 0)
 		return 0;
 
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index 88ccb9c6516e..87ecc65fe6e1 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -1034,14 +1034,14 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(usb, uas_usb_ids);</span>
 static int uas_switch_interface(struct usb_device *udev,
 				struct usb_interface *intf)
 {
<span class="p_del">-	int alt;</span>
<span class="p_add">+	struct usb_host_interface *alt;</span>
 
 	alt = uas_find_uas_alt_setting(intf);
<span class="p_del">-	if (alt &lt; 0)</span>
<span class="p_del">-		return alt;</span>
<span class="p_add">+	if (!alt)</span>
<span class="p_add">+		return -ENODEV;</span>
 
<span class="p_del">-	return usb_set_interface(udev,</span>
<span class="p_del">-			intf-&gt;altsetting[0].desc.bInterfaceNumber, alt);</span>
<span class="p_add">+	return usb_set_interface(udev, alt-&gt;desc.bInterfaceNumber,</span>
<span class="p_add">+			alt-&gt;desc.bAlternateSetting);</span>
 }
 
 static int uas_configure_endpoints(struct uas_dev_info *devinfo)
<span class="p_header">diff --git a/drivers/usb/storage/unusual_uas.h b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">index d696eaf71cf9..8be79bef37af 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_uas.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_uas.h</span>
<span class="p_chunk">@@ -113,9 +113,9 @@</span> <span class="p_context"> UNUSUAL_DEV(0x0bc2, 0xab2a, 0x0000, 0x9999,</span>
 /* Reported-by: Benjamin Tissoires &lt;benjamin.tissoires@redhat.com&gt; */
 UNUSUAL_DEV(0x13fd, 0x3940, 0x0000, 0x9999,
 		&quot;Initio Corporation&quot;,
<span class="p_del">-		&quot;&quot;,</span>
<span class="p_add">+		&quot;INIC-3069&quot;,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
<span class="p_del">-		US_FL_NO_ATA_1X),</span>
<span class="p_add">+		US_FL_NO_ATA_1X | US_FL_IGNORE_RESIDUE),</span>
 
 /* Reported-by: Tom Arild Naess &lt;tanaess@gmail.com&gt; */
 UNUSUAL_DEV(0x152d, 0x0539, 0x0000, 0x9999,
<span class="p_header">diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig</span>
<span class="p_header">index 81ff9b68da3e..9ba9e285c4e5 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/Kconfig</span>
<span class="p_header">+++ b/drivers/video/fbdev/Kconfig</span>
<span class="p_chunk">@@ -2330,10 +2330,11 @@</span> <span class="p_context"> config FB_MSM</span>
 config FB_MX3
 	tristate &quot;MX3 Framebuffer support&quot;
 	depends on FB &amp;&amp; MX3_IPU
<span class="p_add">+	select BACKLIGHT_CLASS_DEVICE</span>
<span class="p_add">+	select BACKLIGHT_LCD_SUPPORT</span>
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
<span class="p_del">-	select BACKLIGHT_CLASS_DEVICE</span>
 	default y
 	help
 	  This is a framebuffer device for the i.MX31 LCD Controller. So
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index 619e30f103d0..a30006636796 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -183,15 +183,21 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 }
 
 /*
<span class="p_add">+ * Don&#39;t allow path components longer than the server max.</span>
  * Don&#39;t allow the separator character in a path component.
  * The VFS will not allow &quot;/&quot;, but &quot;\&quot; is allowed by posix.
  */
 static int
<span class="p_del">-check_name(struct dentry *direntry)</span>
<span class="p_add">+check_name(struct dentry *direntry, struct cifs_tcon *tcon)</span>
 {
 	struct cifs_sb_info *cifs_sb = CIFS_SB(direntry-&gt;d_sb);
 	int i;
 
<span class="p_add">+	if (unlikely(tcon-&gt;fsAttrInfo.MaxPathNameComponentLength &amp;&amp;</span>
<span class="p_add">+		     direntry-&gt;d_name.len &gt;</span>
<span class="p_add">+		     le32_to_cpu(tcon-&gt;fsAttrInfo.MaxPathNameComponentLength)))</span>
<span class="p_add">+		return -ENAMETOOLONG;</span>
<span class="p_add">+</span>
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_POSIX_PATHS)) {
 		for (i = 0; i &lt; direntry-&gt;d_name.len; i++) {
 			if (direntry-&gt;d_name.name[i] == &#39;\\&#39;) {
<span class="p_chunk">@@ -489,10 +495,6 @@</span> <span class="p_context"> cifs_atomic_open(struct inode *inode, struct dentry *direntry,</span>
 		return finish_no_open(file, res);
 	}
 
<span class="p_del">-	rc = check_name(direntry);</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
 	xid = get_xid();
 
 	cifs_dbg(FYI, &quot;parent inode = 0x%p name is: %s and dentry = 0x%p\n&quot;,
<span class="p_chunk">@@ -505,6 +507,11 @@</span> <span class="p_context"> cifs_atomic_open(struct inode *inode, struct dentry *direntry,</span>
 	}
 
 	tcon = tlink_tcon(tlink);
<span class="p_add">+</span>
<span class="p_add">+	rc = check_name(direntry, tcon);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	server = tcon-&gt;ses-&gt;server;
 
 	if (server-&gt;ops-&gt;new_lease_key)
<span class="p_chunk">@@ -752,7 +759,7 @@</span> <span class="p_context"> cifs_lookup(struct inode *parent_dir_inode, struct dentry *direntry,</span>
 	}
 	pTcon = tlink_tcon(tlink);
 
<span class="p_del">-	rc = check_name(direntry);</span>
<span class="p_add">+	rc = check_name(direntry, pTcon);</span>
 	if (rc)
 		goto lookup_out;
 
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index caa38395ec83..8add863a81fd 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -2486,8 +2486,8 @@</span> <span class="p_context"> copy_fs_info_to_kstatfs(struct smb2_fs_full_size_info *pfs_inf,</span>
 	kst-&gt;f_bsize = le32_to_cpu(pfs_inf-&gt;BytesPerSector) *
 			  le32_to_cpu(pfs_inf-&gt;SectorsPerAllocationUnit);
 	kst-&gt;f_blocks = le64_to_cpu(pfs_inf-&gt;TotalAllocationUnits);
<span class="p_del">-	kst-&gt;f_bfree  = le64_to_cpu(pfs_inf-&gt;ActualAvailableAllocationUnits);</span>
<span class="p_del">-	kst-&gt;f_bavail = le64_to_cpu(pfs_inf-&gt;CallerAvailableAllocationUnits);</span>
<span class="p_add">+	kst-&gt;f_bfree  = kst-&gt;f_bavail =</span>
<span class="p_add">+			le64_to_cpu(pfs_inf-&gt;CallerAvailableAllocationUnits);</span>
 	return;
 }
 
<span class="p_header">diff --git a/fs/cifs/smb2pdu.h b/fs/cifs/smb2pdu.h</span>
<span class="p_header">index 0de9d257fd92..2d5c6b4b840e 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.h</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.h</span>
<span class="p_chunk">@@ -82,8 +82,8 @@</span> <span class="p_context"></span>
 
 #define NUMBER_OF_SMB2_COMMANDS	0x0013
 
<span class="p_del">-/* BB FIXME - analyze following length BB */</span>
<span class="p_del">-#define MAX_SMB2_HDR_SIZE 0x78 /* 4 len + 64 hdr + (2*24 wct) + 2 bct + 2 pad */</span>
<span class="p_add">+/* 4 len + 52 transform hdr + 64 hdr + 56 create rsp */</span>
<span class="p_add">+#define MAX_SMB2_HDR_SIZE 0x00b0</span>
 
 #define SMB2_PROTO_NUMBER __constant_cpu_to_le32(0x424d53fe)
 
<span class="p_header">diff --git a/fs/eventpoll.c b/fs/eventpoll.c</span>
<span class="p_header">index 7bcfff900f05..feaa4cebeca8 100644</span>
<span class="p_header">--- a/fs/eventpoll.c</span>
<span class="p_header">+++ b/fs/eventpoll.c</span>
<span class="p_chunk">@@ -518,8 +518,13 @@</span> <span class="p_context"> static void ep_remove_wait_queue(struct eppoll_entry *pwq)</span>
 	wait_queue_head_t *whead;
 
 	rcu_read_lock();
<span class="p_del">-	/* If it is cleared by POLLFREE, it should be rcu-safe */</span>
<span class="p_del">-	whead = rcu_dereference(pwq-&gt;whead);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If it is cleared by POLLFREE, it should be rcu-safe.</span>
<span class="p_add">+	 * If we read NULL we need a barrier paired with</span>
<span class="p_add">+	 * smp_store_release() in ep_poll_callback(), otherwise</span>
<span class="p_add">+	 * we rely on whead-&gt;lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	whead = smp_load_acquire(&amp;pwq-&gt;whead);</span>
 	if (whead)
 		remove_wait_queue(whead, &amp;pwq-&gt;wait);
 	rcu_read_unlock();
<span class="p_chunk">@@ -1006,17 +1011,6 @@</span> <span class="p_context"> static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *k</span>
 	struct epitem *epi = ep_item_from_wait(wait);
 	struct eventpoll *ep = epi-&gt;ep;
 
<span class="p_del">-	if ((unsigned long)key &amp; POLLFREE) {</span>
<span class="p_del">-		ep_pwq_from_wait(wait)-&gt;whead = NULL;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * whead = NULL above can race with ep_remove_wait_queue()</span>
<span class="p_del">-		 * which can do another remove_wait_queue() after us, so we</span>
<span class="p_del">-		 * can&#39;t use __remove_wait_queue(). whead-&gt;lock is held by</span>
<span class="p_del">-		 * the caller.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		list_del_init(&amp;wait-&gt;task_list);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	spin_lock_irqsave(&amp;ep-&gt;lock, flags);
 
 	/*
<span class="p_chunk">@@ -1081,6 +1075,22 @@</span> <span class="p_context"> static int ep_poll_callback(wait_queue_t *wait, unsigned mode, int sync, void *k</span>
 	if (pwake)
 		ep_poll_safewake(&amp;ep-&gt;poll_wait);
 
<span class="p_add">+	if ((unsigned long)key &amp; POLLFREE) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we race with ep_remove_wait_queue() it can miss</span>
<span class="p_add">+		 * -&gt;whead = NULL and do another remove_wait_queue() after</span>
<span class="p_add">+		 * us, so we can&#39;t use __remove_wait_queue().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		list_del_init(&amp;wait-&gt;task_list);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * -&gt;whead != NULL protects us from the race with ep_free()</span>
<span class="p_add">+		 * or ep_remove(), ep_remove_wait_queue() takes whead-&gt;lock</span>
<span class="p_add">+		 * held by the caller. Once we nullify it, nothing protects</span>
<span class="p_add">+		 * ep/epi or even wait.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;ep_pwq_from_wait(wait)-&gt;whead, NULL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/fs/ext4/file.c b/fs/ext4/file.c</span>
<span class="p_header">index 9493a9fef2e1..c81044f51785 100644</span>
<span class="p_header">--- a/fs/ext4/file.c</span>
<span class="p_header">+++ b/fs/ext4/file.c</span>
<span class="p_chunk">@@ -344,6 +344,8 @@</span> <span class="p_context"> static int ext4_find_unwritten_pgoff(struct inode *inode,</span>
 				lastoff = page_offset(page);
 				bh = head = page_buffers(page);
 				do {
<span class="p_add">+					if (lastoff + bh-&gt;b_size &lt;= startoff)</span>
<span class="p_add">+						goto next;</span>
 					if (buffer_uptodate(bh) ||
 					    buffer_unwritten(bh)) {
 						if (whence == SEEK_DATA)
<span class="p_chunk">@@ -358,6 +360,7 @@</span> <span class="p_context"> static int ext4_find_unwritten_pgoff(struct inode *inode,</span>
 						unlock_page(page);
 						goto out;
 					}
<span class="p_add">+next:</span>
 					lastoff += bh-&gt;b_size;
 					bh = bh-&gt;b_this_page;
 				} while (bh != head);
<span class="p_header">diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c</span>
<span class="p_header">index d534e589949b..74db6d94bc55 100644</span>
<span class="p_header">--- a/fs/ext4/resize.c</span>
<span class="p_header">+++ b/fs/ext4/resize.c</span>
<span class="p_chunk">@@ -1929,7 +1929,8 @@</span> <span class="p_context"> int ext4_resize_fs(struct super_block *sb, ext4_fsblk_t n_blocks_count)</span>
 			n_desc_blocks = o_desc_blocks +
 				le16_to_cpu(es-&gt;s_reserved_gdt_blocks);
 			n_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);
<span class="p_del">-			n_blocks_count = n_group * EXT4_BLOCKS_PER_GROUP(sb);</span>
<span class="p_add">+			n_blocks_count = (ext4_fsblk_t)n_group *</span>
<span class="p_add">+				EXT4_BLOCKS_PER_GROUP(sb);</span>
 			n_group--; /* set to last group number */
 		}
 
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index d583c976fff2..ab9fad6fb6b1 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> struct fuse_file *fuse_file_alloc(struct fuse_conn *fc)</span>
 {
 	struct fuse_file *ff;
 
<span class="p_del">-	ff = kmalloc(sizeof(struct fuse_file), GFP_KERNEL);</span>
<span class="p_add">+	ff = kzalloc(sizeof(struct fuse_file), GFP_KERNEL);</span>
 	if (unlikely(!ff))
 		return NULL;
 
<span class="p_header">diff --git a/fs/gfs2/dir.c b/fs/gfs2/dir.c</span>
<span class="p_header">index 5d4261ff5d23..f3508f4583d5 100644</span>
<span class="p_header">--- a/fs/gfs2/dir.c</span>
<span class="p_header">+++ b/fs/gfs2/dir.c</span>
<span class="p_chunk">@@ -749,12 +749,15 @@</span> <span class="p_context"> static int get_leaf_nr(struct gfs2_inode *dip, u32 index,</span>
 		       u64 *leaf_out)
 {
 	__be64 *hash;
<span class="p_add">+	int error;</span>
 
 	hash = gfs2_dir_get_hash_table(dip);
<span class="p_del">-	if (IS_ERR(hash))</span>
<span class="p_del">-		return PTR_ERR(hash);</span>
<span class="p_del">-	*leaf_out = be64_to_cpu(*(hash + index));</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	error = PTR_ERR_OR_ZERO(hash);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!error)</span>
<span class="p_add">+		*leaf_out = be64_to_cpu(*(hash + index));</span>
<span class="p_add">+</span>
<span class="p_add">+	return error;</span>
 }
 
 static int get_first_leaf(struct gfs2_inode *dip, u32 index,
<span class="p_header">diff --git a/fs/nfs/client.c b/fs/nfs/client.c</span>
<span class="p_header">index a6bb3486841a..9f2d8afaa34b 100644</span>
<span class="p_header">--- a/fs/nfs/client.c</span>
<span class="p_header">+++ b/fs/nfs/client.c</span>
<span class="p_chunk">@@ -931,6 +931,7 @@</span> <span class="p_context"> void nfs_server_copy_userdata(struct nfs_server *target, struct nfs_server *sour</span>
 	target-&gt;caps = source-&gt;caps;
 	target-&gt;options = source-&gt;options;
 	target-&gt;auth_info = source-&gt;auth_info;
<span class="p_add">+	target-&gt;port = source-&gt;port;</span>
 }
 EXPORT_SYMBOL_GPL(nfs_server_copy_userdata);
 
<span class="p_header">diff --git a/fs/nfsd/nfs4xdr.c b/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">index bc0b674c2a68..2a89aea2fb85 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4xdr.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> static void next_decode_page(struct nfsd4_compoundargs *argp)</span>
 	argp-&gt;p = page_address(argp-&gt;pagelist[0]);
 	argp-&gt;pagelist++;
 	if (argp-&gt;pagelen &lt; PAGE_SIZE) {
<span class="p_del">-		argp-&gt;end = argp-&gt;p + (argp-&gt;pagelen&gt;&gt;2);</span>
<span class="p_add">+		argp-&gt;end = argp-&gt;p + XDR_QUADLEN(argp-&gt;pagelen);</span>
 		argp-&gt;pagelen = 0;
 	} else {
 		argp-&gt;end = argp-&gt;p + (PAGE_SIZE&gt;&gt;2);
<span class="p_chunk">@@ -1246,9 +1246,7 @@</span> <span class="p_context"> nfsd4_decode_write(struct nfsd4_compoundargs *argp, struct nfsd4_write *write)</span>
 		argp-&gt;pagelen -= pages * PAGE_SIZE;
 		len -= pages * PAGE_SIZE;
 
<span class="p_del">-		argp-&gt;p = (__be32 *)page_address(argp-&gt;pagelist[0]);</span>
<span class="p_del">-		argp-&gt;pagelist++;</span>
<span class="p_del">-		argp-&gt;end = argp-&gt;p + XDR_QUADLEN(PAGE_SIZE);</span>
<span class="p_add">+		next_decode_page(argp);</span>
 	}
 	argp-&gt;p += XDR_QUADLEN(len);
 
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index 090d8ce25bd1..250db0862ca6 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -1797,7 +1797,7 @@</span> <span class="p_context"> int nilfs_btree_convert_and_insert(struct nilfs_bmap *btree,</span>
 				   __u64 key, __u64 ptr,
 				   const __u64 *keys, const __u64 *ptrs, int n)
 {
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	union nilfs_bmap_ptr_req dreq, nreq, *di, *ni;
 	struct nilfs_bmap_stats stats;
 	int ret;
<span class="p_header">diff --git a/fs/nilfs2/recovery.c b/fs/nilfs2/recovery.c</span>
<span class="p_header">index ff00a0b7acb9..9b4f205d1173 100644</span>
<span class="p_header">--- a/fs/nilfs2/recovery.c</span>
<span class="p_header">+++ b/fs/nilfs2/recovery.c</span>
<span class="p_chunk">@@ -582,7 +582,7 @@</span> <span class="p_context"> static int nilfs_do_roll_forward(struct the_nilfs *nilfs,</span>
 				 struct nilfs_recovery_info *ri)
 {
 	struct buffer_head *bh_sum = NULL;
<span class="p_del">-	struct nilfs_segment_summary *sum;</span>
<span class="p_add">+	struct nilfs_segment_summary *sum = NULL;</span>
 	sector_t pseg_start;
 	sector_t seg_start, seg_end;  /* Starting/ending DBN of full segment */
 	unsigned long nsalvaged_blocks = 0;
<span class="p_chunk">@@ -814,7 +814,7 @@</span> <span class="p_context"> int nilfs_search_super_root(struct the_nilfs *nilfs,</span>
 			    struct nilfs_recovery_info *ri)
 {
 	struct buffer_head *bh_sum = NULL;
<span class="p_del">-	struct nilfs_segment_summary *sum;</span>
<span class="p_add">+	struct nilfs_segment_summary *sum = NULL;</span>
 	sector_t pseg_start, pseg_end, sr_pseg_start = 0;
 	sector_t seg_start, seg_end; /* range of full segment (block number) */
 	sector_t b, end;
<span class="p_header">diff --git a/fs/nilfs2/super.c b/fs/nilfs2/super.c</span>
<span class="p_header">index 8c532b2ca3ab..f635ccfc3bdf 100644</span>
<span class="p_header">--- a/fs/nilfs2/super.c</span>
<span class="p_header">+++ b/fs/nilfs2/super.c</span>
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> static int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)</span>
 	struct nilfs_super_block *nsbp;
 	sector_t blocknr, newblocknr;
 	unsigned long offset;
<span class="p_del">-	int sb2i = -1;  /* array index of the secondary superblock */</span>
<span class="p_add">+	int sb2i;  /* array index of the secondary superblock */</span>
 	int ret = 0;
 
 	/* nilfs-&gt;ns_sem must be locked by the caller. */
<span class="p_chunk">@@ -369,6 +369,9 @@</span> <span class="p_context"> static int nilfs_move_2nd_super(struct super_block *sb, loff_t sb2off)</span>
 	} else if (nilfs-&gt;ns_sbh[0]-&gt;b_blocknr &gt; nilfs-&gt;ns_first_data_block) {
 		sb2i = 0;
 		blocknr = nilfs-&gt;ns_sbh[0]-&gt;b_blocknr;
<span class="p_add">+	} else {</span>
<span class="p_add">+		sb2i = -1;</span>
<span class="p_add">+		blocknr = 0;</span>
 	}
 	if (sb2i &gt;= 0 &amp;&amp; (u64)blocknr &lt;&lt; nilfs-&gt;ns_blocksize_bits == sb2off)
 		goto out;  /* super block location is unchanged */
<span class="p_header">diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c</span>
<span class="p_header">index 293ab80f3fe2..776aa6cfb6e2 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.c</span>
<span class="p_header">+++ b/fs/ocfs2/acl.c</span>
<span class="p_chunk">@@ -240,19 +240,6 @@</span> <span class="p_context"> int ocfs2_set_acl(handle_t *handle,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			umode_t mode;</span>
<span class="p_del">-			ret = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				return ret;</span>
<span class="p_del">-			else {</span>
<span class="p_del">-				ret = ocfs2_acl_set_mode(inode, di_bh,</span>
<span class="p_del">-							 handle, mode);</span>
<span class="p_del">-				if (ret)</span>
<span class="p_del">-					return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_DEFAULT;
<span class="p_chunk">@@ -283,6 +270,20 @@</span> <span class="p_context"> int ocfs2_set_acl(handle_t *handle,</span>
 
 int ocfs2_iop_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
<span class="p_add">+	int status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (status)</span>
<span class="p_add">+			return status;</span>
<span class="p_add">+</span>
<span class="p_add">+		status = ocfs2_acl_set_mode(inode, NULL, NULL, mode);</span>
<span class="p_add">+		if (status)</span>
<span class="p_add">+			return status;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return ocfs2_set_acl(NULL, inode, NULL, type, acl, NULL, NULL);
 }
 
<span class="p_header">diff --git a/fs/xfs/xfs_ialloc.c b/fs/xfs/xfs_ialloc.c</span>
<span class="p_header">index 5960e5593fe0..d64a18db9bef 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_ialloc.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_ialloc.c</span>
<span class="p_chunk">@@ -854,13 +854,13 @@</span> <span class="p_context"> xfs_dialloc_ag_inobt(</span>
 
 			/* free inodes to the left? */
 			if (useleft &amp;&amp; trec.ir_freecount) {
<span class="p_del">-				rec = trec;</span>
 				xfs_btree_del_cursor(cur, XFS_BTREE_NOERROR);
 				cur = tcur;
 
 				pag-&gt;pagl_leftrec = trec.ir_startino;
 				pag-&gt;pagl_rightrec = rec.ir_startino;
 				pag-&gt;pagl_pagino = pagino;
<span class="p_add">+				rec = trec;</span>
 				goto alloc_inode;
 			}
 
<span class="p_header">diff --git a/include/asm-generic/topology.h b/include/asm-generic/topology.h</span>
<span class="p_header">index fc824e2828f3..5d2add1a6c96 100644</span>
<span class="p_header">--- a/include/asm-generic/topology.h</span>
<span class="p_header">+++ b/include/asm-generic/topology.h</span>
<span class="p_chunk">@@ -48,7 +48,11 @@</span> <span class="p_context"></span>
 #define parent_node(node)	((void)(node),0)
 #endif
 #ifndef cpumask_of_node
<span class="p_del">-#define cpumask_of_node(node)	((void)node, cpu_online_mask)</span>
<span class="p_add">+  #ifdef CONFIG_NEED_MULTIPLE_NODES</span>
<span class="p_add">+    #define cpumask_of_node(node)	((node) == 0 ? cpu_online_mask : cpu_none_mask)</span>
<span class="p_add">+  #else</span>
<span class="p_add">+    #define cpumask_of_node(node)	((void)node, cpu_online_mask)</span>
<span class="p_add">+  #endif</span>
 #endif
 #ifndef pcibus_to_node
 #define pcibus_to_node(bus)	((void)(bus), -1)
<span class="p_header">diff --git a/include/linux/cpumask.h b/include/linux/cpumask.h</span>
<span class="p_header">index 0e0f3a4e8844..c1028e67c5dc 100644</span>
<span class="p_header">--- a/include/linux/cpumask.h</span>
<span class="p_header">+++ b/include/linux/cpumask.h</span>
<span class="p_chunk">@@ -142,10 +142,8 @@</span> <span class="p_context"> static inline unsigned int cpumask_any_but(const struct cpumask *mask,</span>
 	return 1;
 }
 
<span class="p_del">-static inline int cpumask_set_cpu_local_first(int i, int numa_node, cpumask_t *dstp)</span>
<span class="p_add">+static inline unsigned int cpumask_local_spread(unsigned int i, int node)</span>
 {
<span class="p_del">-	set_bit(0, cpumask_bits(dstp));</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -199,7 +197,7 @@</span> <span class="p_context"> static inline unsigned int cpumask_next_zero(int n, const struct cpumask *srcp)</span>
 
 int cpumask_next_and(int n, const struct cpumask *, const struct cpumask *);
 int cpumask_any_but(const struct cpumask *mask, unsigned int cpu);
<span class="p_del">-int cpumask_set_cpu_local_first(int i, int numa_node, cpumask_t *dstp);</span>
<span class="p_add">+unsigned int cpumask_local_spread(unsigned int i, int node);</span>
 
 /**
  * for_each_cpu - iterate over every cpu in a mask
<span class="p_header">diff --git a/include/linux/device-mapper.h b/include/linux/device-mapper.h</span>
<span class="p_header">index c51706b7a36e..3d1c67b63d68 100644</span>
<span class="p_header">--- a/include/linux/device-mapper.h</span>
<span class="p_header">+++ b/include/linux/device-mapper.h</span>
<span class="p_chunk">@@ -481,56 +481,32 @@</span> <span class="p_context"> void *dm_vcalloc(unsigned long nmemb, unsigned long elem_size);</span>
  *---------------------------------------------------------------*/
 #define DM_NAME &quot;device-mapper&quot;
 
<span class="p_del">-#ifdef CONFIG_PRINTK</span>
<span class="p_del">-extern struct ratelimit_state dm_ratelimit_state;</span>
<span class="p_del">-</span>
<span class="p_del">-#define dm_ratelimit()	__ratelimit(&amp;dm_ratelimit_state)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define dm_ratelimit()	0</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMCRIT(f, arg...) \</span>
<span class="p_del">-	printk(KERN_CRIT DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMERR(f, arg...) \</span>
<span class="p_del">-	printk(KERN_ERR DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#define DMERR_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_ERR DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; \</span>
<span class="p_del">-			       f &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMWARN(f, arg...) \</span>
<span class="p_del">-	printk(KERN_WARNING DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#define DMWARN_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_WARNING DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; \</span>
<span class="p_del">-			       f &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-#define DMINFO(f, arg...) \</span>
<span class="p_del">-	printk(KERN_INFO DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#define DMINFO_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_INFO DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f \</span>
<span class="p_del">-			       &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_add">+#define DM_RATELIMIT(pr_func, fmt, ...)					\</span>
<span class="p_add">+do {									\</span>
<span class="p_add">+	static DEFINE_RATELIMIT_STATE(rs, DEFAULT_RATELIMIT_INTERVAL,	\</span>
<span class="p_add">+				      DEFAULT_RATELIMIT_BURST);		\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	if (__ratelimit(&amp;rs))						\</span>
<span class="p_add">+		pr_func(DM_FMT(fmt), ##__VA_ARGS__);			\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DM_FMT(fmt) DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; fmt &quot;\n&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DMCRIT(fmt, ...) pr_crit(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+#define DMERR(fmt, ...) pr_err(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMERR_LIMIT(fmt, ...) DM_RATELIMIT(pr_err, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DMWARN(fmt, ...) pr_warn(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMWARN_LIMIT(fmt, ...) DM_RATELIMIT(pr_warn, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DMINFO(fmt, ...) pr_info(DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMINFO_LIMIT(fmt, ...) DM_RATELIMIT(pr_info, fmt, ##__VA_ARGS__)</span>
 
 #ifdef CONFIG_DM_DEBUG
<span class="p_del">-#  define DMDEBUG(f, arg...) \</span>
<span class="p_del">-	printk(KERN_DEBUG DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot; DEBUG: &quot; f &quot;\n&quot;, ## arg)</span>
<span class="p_del">-#  define DMDEBUG_LIMIT(f, arg...) \</span>
<span class="p_del">-	do { \</span>
<span class="p_del">-		if (dm_ratelimit())	\</span>
<span class="p_del">-			printk(KERN_DEBUG DM_NAME &quot;: &quot; DM_MSG_PREFIX &quot;: &quot; f \</span>
<span class="p_del">-			       &quot;\n&quot;, ## arg); \</span>
<span class="p_del">-	} while (0)</span>
<span class="p_add">+#define DMDEBUG(fmt, ...) printk(KERN_DEBUG DM_FMT(fmt), ##__VA_ARGS__)</span>
<span class="p_add">+#define DMDEBUG_LIMIT(fmt, ...) DM_RATELIMIT(pr_debug, fmt, ##__VA_ARGS__)</span>
 #else
<span class="p_del">-#  define DMDEBUG(f, arg...) do {} while (0)</span>
<span class="p_del">-#  define DMDEBUG_LIMIT(f, arg...) do {} while (0)</span>
<span class="p_add">+#define DMDEBUG(fmt, ...) no_printk(fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define DMDEBUG_LIMIT(fmt, ...) no_printk(fmt, ##__VA_ARGS__)</span>
 #endif
 
 #define DMEMIT(x...) sz += ((sz &gt;= maxlen) ? \
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index da912e6cd2ea..d594f0fbc41a 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -809,9 +809,9 @@</span> <span class="p_context"> static inline struct file *get_file(struct file *f)</span>
 /* Page cache limit. The filesystems should put that into their s_maxbytes 
    limits, otherwise bad things can happen in VM. */ 
 #if BITS_PER_LONG==32
<span class="p_del">-#define MAX_LFS_FILESIZE	(((loff_t)PAGE_CACHE_SIZE &lt;&lt; (BITS_PER_LONG-1))-1) </span>
<span class="p_add">+#define MAX_LFS_FILESIZE	((loff_t)ULONG_MAX &lt;&lt; PAGE_SHIFT)</span>
 #elif BITS_PER_LONG==64
<span class="p_del">-#define MAX_LFS_FILESIZE 	((loff_t)0x7fffffffffffffffLL)</span>
<span class="p_add">+#define MAX_LFS_FILESIZE 	((loff_t)LLONG_MAX)</span>
 #endif
 
 #define FL_POSIX	1
<span class="p_header">diff --git a/include/linux/ftrace_event.h b/include/linux/ftrace_event.h</span>
<span class="p_header">index cff3106ffe2c..c817d7938b4b 100644</span>
<span class="p_header">--- a/include/linux/ftrace_event.h</span>
<span class="p_header">+++ b/include/linux/ftrace_event.h</span>
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> extern int  ftrace_profile_set_filter(struct perf_event *event, int event_id,</span>
 				     char *filter_str);
 extern void ftrace_profile_free_filter(struct perf_event *event);
 extern void *perf_trace_buf_prepare(int size, unsigned short type,
<span class="p_del">-				    struct pt_regs *regs, int *rctxp);</span>
<span class="p_add">+				    struct pt_regs **regs, int *rctxp);</span>
 
 static inline void
 perf_trace_buf_submit(void *raw_data, int size, int rctx, u64 addr,
<span class="p_header">diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h</span>
<span class="p_header">index 573e4f3243d0..ca3024554a2d 100644</span>
<span class="p_header">--- a/include/linux/gpio/driver.h</span>
<span class="p_header">+++ b/include/linux/gpio/driver.h</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> extern const char *gpiochip_is_requested(struct gpio_chip *chip,</span>
 
 /* add/remove chips */
 extern int gpiochip_add(struct gpio_chip *chip);
<span class="p_del">-extern int __must_check gpiochip_remove(struct gpio_chip *chip);</span>
<span class="p_add">+extern int gpiochip_remove(struct gpio_chip *chip);</span>
 extern struct gpio_chip *gpiochip_find(void *data,
 			      int (*match)(struct gpio_chip *chip, void *data));
 
<span class="p_header">diff --git a/include/linux/mlx4/device.h b/include/linux/mlx4/device.h</span>
<span class="p_header">index 48ddabb261bc..61c043c449cb 100644</span>
<span class="p_header">--- a/include/linux/mlx4/device.h</span>
<span class="p_header">+++ b/include/linux/mlx4/device.h</span>
<span class="p_chunk">@@ -467,6 +467,7 @@</span> <span class="p_context"> struct mlx4_caps {</span>
 	u16			hca_core_clock;
 	u64			phys_port_id[MLX4_MAX_PORTS + 1];
 	int			tunnel_offload_mode;
<span class="p_add">+	bool			wol_port[MLX4_MAX_PORTS + 1];</span>
 };
 
 struct mlx4_buf_list {
<span class="p_header">diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h</span>
<span class="p_header">index 96c5750e3110..761fc630f150 100644</span>
<span class="p_header">--- a/include/linux/mm_types.h</span>
<span class="p_header">+++ b/include/linux/mm_types.h</span>
<span class="p_chunk">@@ -451,7 +451,7 @@</span> <span class="p_context"> struct mm_struct {</span>
 	 * can move process memory needs to flush the TLB when moving a
 	 * PROT_NONE or PROT_NUMA mapped page.
 	 */
<span class="p_del">-	bool tlb_flush_pending;</span>
<span class="p_add">+	atomic_t tlb_flush_pending;</span>
 #endif
 	struct uprobes_state uprobes_state;
 };
<span class="p_chunk">@@ -479,33 +479,46 @@</span> <span class="p_context"> static inline cpumask_t *mm_cpumask(struct mm_struct *mm)</span>
 static inline bool mm_tlb_flush_pending(struct mm_struct *mm)
 {
 	barrier();
<span class="p_del">-	return mm-&gt;tlb_flush_pending;</span>
<span class="p_add">+	return atomic_read(&amp;mm-&gt;tlb_flush_pending) &gt; 0;</span>
 }
<span class="p_del">-static inline void set_tlb_flush_pending(struct mm_struct *mm)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void init_tlb_flush_pending(struct mm_struct *mm)</span>
 {
<span class="p_del">-	mm-&gt;tlb_flush_pending = true;</span>
<span class="p_add">+	atomic_set(&amp;mm-&gt;tlb_flush_pending, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void inc_tlb_flush_pending(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_inc(&amp;mm-&gt;tlb_flush_pending);</span>
 
 	/*
<span class="p_del">-	 * Guarantee that the tlb_flush_pending store does not leak into the</span>
<span class="p_add">+	 * Guarantee that the tlb_flush_pending increase does not leak into the</span>
 	 * critical section updating the page tables
 	 */
 	smp_mb__before_spinlock();
 }
<span class="p_add">+</span>
 /* Clearing is done after a TLB flush, which also provides a barrier. */
<span class="p_del">-static inline void clear_tlb_flush_pending(struct mm_struct *mm)</span>
<span class="p_add">+static inline void dec_tlb_flush_pending(struct mm_struct *mm)</span>
 {
 	barrier();
<span class="p_del">-	mm-&gt;tlb_flush_pending = false;</span>
<span class="p_add">+	atomic_dec(&amp;mm-&gt;tlb_flush_pending);</span>
 }
 #else
 static inline bool mm_tlb_flush_pending(struct mm_struct *mm)
 {
 	return false;
 }
<span class="p_del">-static inline void set_tlb_flush_pending(struct mm_struct *mm)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void init_tlb_flush_pending(struct mm_struct *mm)</span>
 {
 }
<span class="p_del">-static inline void clear_tlb_flush_pending(struct mm_struct *mm)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void inc_tlb_flush_pending(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void dec_tlb_flush_pending(struct mm_struct *mm)</span>
 {
 }
 #endif
<span class="p_header">diff --git a/include/linux/module.h b/include/linux/module.h</span>
<span class="p_header">index f520a767c86c..ac1e65afc5a1 100644</span>
<span class="p_header">--- a/include/linux/module.h</span>
<span class="p_header">+++ b/include/linux/module.h</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> void trim_init_extable(struct module *m);</span>
 #ifdef MODULE
 /* Creates an alias so file2alias.c can find device table. */
 #define MODULE_DEVICE_TABLE(type, name)					\
<span class="p_del">-  extern const struct type##_device_id __mod_##type##__##name##_device_table \</span>
<span class="p_add">+extern const typeof(name) __mod_##type##__##name##_device_table		\</span>
   __attribute__ ((unused, alias(__stringify(name))))
 #else  /* !MODULE */
 #define MODULE_DEVICE_TABLE(type, name)
<span class="p_header">diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h</span>
<span class="p_header">index b501e9cd7d3e..db1dba23aed2 100644</span>
<span class="p_header">--- a/include/linux/mtd/map.h</span>
<span class="p_header">+++ b/include/linux/mtd/map.h</span>
<span class="p_chunk">@@ -317,7 +317,17 @@</span> <span class="p_context"> static inline map_word map_word_or(struct map_info *map, map_word val1, map_word</span>
 	return r;
 }
 
<span class="p_del">-#define map_word_andequal(m, a, b, z) map_word_equal(m, z, map_word_and(m, a, b))</span>
<span class="p_add">+static inline int map_word_andequal(struct map_info *map, map_word val1, map_word val2, map_word val3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; map_words(map); i++) {</span>
<span class="p_add">+		if ((val1.x[i] &amp; val2.x[i]) != val3.x[i])</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
 
 static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word val2)
 {
<span class="p_header">diff --git a/include/linux/perf_event.h b/include/linux/perf_event.h</span>
<span class="p_header">index 7e8445e9dcbf..d86153fef0e0 100644</span>
<span class="p_header">--- a/include/linux/perf_event.h</span>
<span class="p_header">+++ b/include/linux/perf_event.h</span>
<span class="p_chunk">@@ -642,6 +642,7 @@</span> <span class="p_context"> static inline int is_software_event(struct perf_event *event)</span>
 
 extern struct static_key perf_swevent_enabled[PERF_COUNT_SW_MAX];
 
<span class="p_add">+extern void ___perf_sw_event(u32, u64, struct pt_regs *, u64);</span>
 extern void __perf_sw_event(u32, u64, struct pt_regs *, u64);
 
 #ifndef perf_arch_fetch_caller_regs
<span class="p_chunk">@@ -666,14 +667,25 @@</span> <span class="p_context"> static inline void perf_fetch_caller_regs(struct pt_regs *regs)</span>
 static __always_inline void
 perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)
 {
<span class="p_del">-	struct pt_regs hot_regs;</span>
<span class="p_add">+	if (static_key_false(&amp;perf_swevent_enabled[event_id]))</span>
<span class="p_add">+		__perf_sw_event(event_id, nr, regs, addr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DECLARE_PER_CPU(struct pt_regs, __perf_regs[4]);</span>
 
<span class="p_add">+/*</span>
<span class="p_add">+ * &#39;Special&#39; version for the scheduler, it hard assumes no recursion,</span>
<span class="p_add">+ * which is guaranteed by us not actually scheduling inside other swevents</span>
<span class="p_add">+ * because those disable preemption.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static __always_inline void</span>
<span class="p_add">+perf_sw_event_sched(u32 event_id, u64 nr, u64 addr)</span>
<span class="p_add">+{</span>
 	if (static_key_false(&amp;perf_swevent_enabled[event_id])) {
<span class="p_del">-		if (!regs) {</span>
<span class="p_del">-			perf_fetch_caller_regs(&amp;hot_regs);</span>
<span class="p_del">-			regs = &amp;hot_regs;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		__perf_sw_event(event_id, nr, regs, addr);</span>
<span class="p_add">+		struct pt_regs *regs = this_cpu_ptr(&amp;__perf_regs[0]);</span>
<span class="p_add">+</span>
<span class="p_add">+		perf_fetch_caller_regs(regs);</span>
<span class="p_add">+		___perf_sw_event(event_id, nr, regs, addr);</span>
 	}
 }
 
<span class="p_chunk">@@ -689,7 +701,7 @@</span> <span class="p_context"> static inline void perf_event_task_sched_in(struct task_struct *prev,</span>
 static inline void perf_event_task_sched_out(struct task_struct *prev,
 					     struct task_struct *next)
 {
<span class="p_del">-	perf_sw_event(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, NULL, 0);</span>
<span class="p_add">+	perf_sw_event_sched(PERF_COUNT_SW_CONTEXT_SWITCHES, 1, 0);</span>
 
 	if (static_key_false(&amp;perf_sched_events.key))
 		__perf_event_task_sched_out(prev, next);
<span class="p_chunk">@@ -800,6 +812,8 @@</span> <span class="p_context"> static inline int perf_event_refresh(struct perf_event *event, int refresh)</span>
 static inline void
 perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)	{ }
 static inline void
<span class="p_add">+perf_sw_event_sched(u32 event_id, u64 nr, u64 addr)			{ }</span>
<span class="p_add">+static inline void</span>
 perf_bp_event(struct perf_event *event, void *data)			{ }
 
 static inline int perf_register_guest_info_callbacks
<span class="p_header">diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h</span>
<span class="p_header">index 9eb54f41623e..fa25f353f985 100644</span>
<span class="p_header">--- a/include/linux/workqueue.h</span>
<span class="p_header">+++ b/include/linux/workqueue.h</span>
<span class="p_chunk">@@ -315,6 +315,7 @@</span> <span class="p_context"> enum {</span>
 
 	__WQ_DRAINING		= 1 &lt;&lt; 16, /* internal: workqueue is draining */
 	__WQ_ORDERED		= 1 &lt;&lt; 17, /* internal: workqueue is ordered */
<span class="p_add">+	__WQ_ORDERED_EXPLICIT	= 1 &lt;&lt; 18, /* internal: alloc_ordered_workqueue() */</span>
 
 	WQ_MAX_ACTIVE		= 512,	  /* I like 512, better ideas? */
 	WQ_MAX_UNBOUND_PER_CPU	= 4,	  /* 4 * #cpus for unbound wq */
<span class="p_chunk">@@ -412,7 +413,8 @@</span> <span class="p_context"> __alloc_workqueue_key(const char *fmt, unsigned int flags, int max_active,</span>
  * Pointer to the allocated workqueue on success, %NULL on failure.
  */
 #define alloc_ordered_workqueue(fmt, flags, args...)			\
<span class="p_del">-	alloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED | (flags), 1, ##args)</span>
<span class="p_add">+	alloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED |		\</span>
<span class="p_add">+			__WQ_ORDERED_EXPLICIT | (flags), 1, ##args)</span>
 
 #define create_workqueue(name)						\
 	alloc_workqueue(&quot;%s&quot;, WQ_MEM_RECLAIM, 1, (name))
<span class="p_header">diff --git a/include/net/dst.h b/include/net/dst.h</span>
<span class="p_header">index 0fb99a26e973..673e69d1d7be 100644</span>
<span class="p_header">--- a/include/net/dst.h</span>
<span class="p_header">+++ b/include/net/dst.h</span>
<span class="p_chunk">@@ -105,16 +105,25 @@</span> <span class="p_context"> struct dst_entry {</span>
 	};
 };
 
<span class="p_add">+void *dst_alloc_metrics(gfp_t flags);</span>
<span class="p_add">+void dst_free_metrics(void *metrics);</span>
 u32 *dst_cow_metrics_generic(struct dst_entry *dst, unsigned long old);
<span class="p_del">-extern const u32 dst_default_metrics[];</span>
 
 #define DST_METRICS_READ_ONLY		0x1UL
 #define DST_METRICS_FORCE_OVERWRITE	0x2UL
<span class="p_del">-#define DST_METRICS_FLAGS		0x3UL</span>
<span class="p_add">+#define DST_METRICS_REFCOUNTED		0x4UL</span>
<span class="p_add">+#define DST_METRICS_FLAGS		0x7UL</span>
<span class="p_add">+#define DST_METRICS_ALIGNMENT		0x8UL</span>
 #define __DST_METRICS_PTR(Y)	\
 	((u32 *)((Y) &amp; ~DST_METRICS_FLAGS))
 #define DST_METRICS_PTR(X)	__DST_METRICS_PTR((X)-&gt;_metrics)
 
<span class="p_add">+struct dst_metrics {</span>
<span class="p_add">+	u32		metrics[RTAX_MAX];</span>
<span class="p_add">+	atomic_t	refcnt;</span>
<span class="p_add">+} __aligned(DST_METRICS_ALIGNMENT);</span>
<span class="p_add">+extern const struct dst_metrics dst_default_metrics;</span>
<span class="p_add">+</span>
 static inline bool dst_metrics_read_only(const struct dst_entry *dst)
 {
 	return dst-&gt;_metrics &amp; DST_METRICS_READ_ONLY;
<span class="p_header">diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h</span>
<span class="p_header">index cf485f9aa563..c09a71789868 100644</span>
<span class="p_header">--- a/include/net/ip6_fib.h</span>
<span class="p_header">+++ b/include/net/ip6_fib.h</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> struct fib6_node {</span>
 	__u16			fn_flags;
 	__u32			fn_sernum;
 	struct rt6_info		*rr_ptr;
<span class="p_add">+	struct rcu_head		rcu;</span>
 };
 
 #ifndef CONFIG_IPV6_SUBTREES
<span class="p_chunk">@@ -95,7 +96,7 @@</span> <span class="p_context"> struct rt6_info {</span>
 	 * the same cache line.
 	 */
 	struct fib6_table		*rt6i_table;
<span class="p_del">-	struct fib6_node		*rt6i_node;</span>
<span class="p_add">+	struct fib6_node __rcu		*rt6i_node;</span>
 
 	struct in6_addr			rt6i_gateway;
 
<span class="p_chunk">@@ -193,6 +194,38 @@</span> <span class="p_context"> static inline void rt6_set_from(struct rt6_info *rt, struct rt6_info *from)</span>
 	rt-&gt;dst.from = new;
 }
 
<span class="p_add">+/* Function to safely get fn-&gt;sernum for passed in rt</span>
<span class="p_add">+ * and store result in passed in cookie.</span>
<span class="p_add">+ * Return true if we can get cookie safely</span>
<span class="p_add">+ * Return false if not</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool rt6_get_cookie_safe(const struct rt6_info *rt,</span>
<span class="p_add">+				       u32 *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fib6_node *fn;</span>
<span class="p_add">+	bool status = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	fn = rcu_dereference(rt-&gt;rt6i_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fn) {</span>
<span class="p_add">+		*cookie = fn-&gt;fn_sernum;</span>
<span class="p_add">+		status = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline u32 rt6_get_cookie(const struct rt6_info *rt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 cookie = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	rt6_get_cookie_safe(rt, &amp;cookie);</span>
<span class="p_add">+</span>
<span class="p_add">+	return cookie;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void ip6_rt_put(struct rt6_info *rt)
 {
 	/* dst_release() accepts a NULL parameter.
<span class="p_header">diff --git a/include/net/ip6_route.h b/include/net/ip6_route.h</span>
<span class="p_header">index 2e765849ccd6..cea379c35a06 100644</span>
<span class="p_header">--- a/include/net/ip6_route.h</span>
<span class="p_header">+++ b/include/net/ip6_route.h</span>
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> static inline void __ip6_dst_store(struct sock *sk, struct dst_entry *dst,</span>
 #ifdef CONFIG_IPV6_SUBTREES
 	np-&gt;saddr_cache = saddr;
 #endif
<span class="p_del">-	np-&gt;dst_cookie = rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+	np-&gt;dst_cookie = rt6_get_cookie(rt);</span>
 }
 
 static inline void ip6_dst_store(struct sock *sk, struct dst_entry *dst,
<span class="p_header">diff --git a/include/net/ip_fib.h b/include/net/ip_fib.h</span>
<span class="p_header">index fac652dc6852..fc7014fe8ee3 100644</span>
<span class="p_header">--- a/include/net/ip_fib.h</span>
<span class="p_header">+++ b/include/net/ip_fib.h</span>
<span class="p_chunk">@@ -108,11 +108,11 @@</span> <span class="p_context"> struct fib_info {</span>
 	unsigned char		fib_type;
 	__be32			fib_prefsrc;
 	u32			fib_priority;
<span class="p_del">-	u32			*fib_metrics;</span>
<span class="p_del">-#define fib_mtu fib_metrics[RTAX_MTU-1]</span>
<span class="p_del">-#define fib_window fib_metrics[RTAX_WINDOW-1]</span>
<span class="p_del">-#define fib_rtt fib_metrics[RTAX_RTT-1]</span>
<span class="p_del">-#define fib_advmss fib_metrics[RTAX_ADVMSS-1]</span>
<span class="p_add">+	struct dst_metrics	*fib_metrics;</span>
<span class="p_add">+#define fib_mtu fib_metrics-&gt;metrics[RTAX_MTU-1]</span>
<span class="p_add">+#define fib_window fib_metrics-&gt;metrics[RTAX_WINDOW-1]</span>
<span class="p_add">+#define fib_rtt fib_metrics-&gt;metrics[RTAX_RTT-1]</span>
<span class="p_add">+#define fib_advmss fib_metrics-&gt;metrics[RTAX_ADVMSS-1]</span>
 	int			fib_nhs;
 #ifdef CONFIG_IP_ROUTE_MULTIPATH
 	int			fib_power;
<span class="p_header">diff --git a/include/net/sch_generic.h b/include/net/sch_generic.h</span>
<span class="p_header">index ee2060f507b7..513aecb66565 100644</span>
<span class="p_header">--- a/include/net/sch_generic.h</span>
<span class="p_header">+++ b/include/net/sch_generic.h</span>
<span class="p_chunk">@@ -618,8 +618,11 @@</span> <span class="p_context"> static inline struct Qdisc *qdisc_replace(struct Qdisc *sch, struct Qdisc *new,</span>
 	old = *pold;
 	*pold = new;
 	if (old != NULL) {
<span class="p_del">-		qdisc_tree_reduce_backlog(old, old-&gt;q.qlen, old-&gt;qstats.backlog);</span>
<span class="p_add">+		unsigned int qlen = old-&gt;q.qlen;</span>
<span class="p_add">+		unsigned int backlog = old-&gt;qstats.backlog;</span>
<span class="p_add">+</span>
 		qdisc_reset(old);
<span class="p_add">+		qdisc_tree_reduce_backlog(old, qlen, backlog);</span>
 	}
 	sch_tree_unlock(sch);
 
<span class="p_header">diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h</span>
<span class="p_header">index a95d237579d6..6c9979b24eba 100644</span>
<span class="p_header">--- a/include/net/sctp/sctp.h</span>
<span class="p_header">+++ b/include/net/sctp/sctp.h</span>
<span class="p_chunk">@@ -448,6 +448,8 @@</span> <span class="p_context"> _sctp_walk_params((pos), (chunk), ntohs((chunk)-&gt;chunk_hdr.length), member)</span>
 
 #define _sctp_walk_params(pos, chunk, end, member)\
 for (pos.v = chunk-&gt;member;\
<span class="p_add">+     (pos.v + offsetof(struct sctp_paramhdr, length) + sizeof(pos.p-&gt;length) &lt;=\</span>
<span class="p_add">+      (void *)chunk + end) &amp;&amp;\</span>
      pos.v &lt;= (void *)chunk + end - ntohs(pos.p-&gt;length) &amp;&amp;\
      ntohs(pos.p-&gt;length) &gt;= sizeof(sctp_paramhdr_t);\
      pos.v += WORD_ROUND(ntohs(pos.p-&gt;length)))
<span class="p_chunk">@@ -458,6 +460,8 @@</span> <span class="p_context"> _sctp_walk_errors((err), (chunk_hdr), ntohs((chunk_hdr)-&gt;length))</span>
 #define _sctp_walk_errors(err, chunk_hdr, end)\
 for (err = (sctp_errhdr_t *)((void *)chunk_hdr + \
 	    sizeof(sctp_chunkhdr_t));\
<span class="p_add">+     ((void *)err + offsetof(sctp_errhdr_t, length) + sizeof(err-&gt;length) &lt;=\</span>
<span class="p_add">+      (void *)chunk_hdr + end) &amp;&amp;\</span>
      (void *)err &lt;= (void *)chunk_hdr + end - ntohs(err-&gt;length) &amp;&amp;\
      ntohs(err-&gt;length) &gt;= sizeof(sctp_errhdr_t); \
      err = (sctp_errhdr_t *)((void *)err + WORD_ROUND(ntohs(err-&gt;length))))
<span class="p_header">diff --git a/include/rdma/ib_addr.h b/include/rdma/ib_addr.h</span>
<span class="p_header">index ce55906b54a0..bc45acc195b1 100644</span>
<span class="p_header">--- a/include/rdma/ib_addr.h</span>
<span class="p_header">+++ b/include/rdma/ib_addr.h</span>
<span class="p_chunk">@@ -184,10 +184,14 @@</span> <span class="p_context"> static inline void iboe_addr_get_sgid(struct rdma_dev_addr *dev_addr,</span>
 
 	dev = dev_get_by_index(&amp;init_net, dev_addr-&gt;bound_dev_if);
 	if (dev) {
<span class="p_del">-		ip4 = (struct in_device *)dev-&gt;ip_ptr;</span>
<span class="p_add">+		ip4 = in_dev_get(dev);</span>
 		if (ip4 &amp;&amp; ip4-&gt;ifa_list &amp;&amp; ip4-&gt;ifa_list-&gt;ifa_address)
 			ipv6_addr_set_v4mapped(ip4-&gt;ifa_list-&gt;ifa_address,
 					       (struct in6_addr *)gid);
<span class="p_add">+</span>
<span class="p_add">+		if (ip4)</span>
<span class="p_add">+			in_dev_put(ip4);</span>
<span class="p_add">+</span>
 		dev_put(dev);
 	}
 }
<span class="p_header">diff --git a/include/trace/ftrace.h b/include/trace/ftrace.h</span>
<span class="p_header">index 26b4f2e13275..bb1f5d82ad49 100644</span>
<span class="p_header">--- a/include/trace/ftrace.h</span>
<span class="p_header">+++ b/include/trace/ftrace.h</span>
<span class="p_chunk">@@ -765,7 +765,7 @@</span> <span class="p_context"> perf_trace_##call(void *__data, proto)					\</span>
 	struct ftrace_event_call *event_call = __data;			\
 	struct ftrace_data_offsets_##call __maybe_unused __data_offsets;\
 	struct ftrace_raw_##call *entry;				\
<span class="p_del">-	struct pt_regs __regs;						\</span>
<span class="p_add">+	struct pt_regs *__regs;						\</span>
 	u64 __addr = 0, __count = 1;					\
 	struct task_struct *__task = NULL;				\
 	struct hlist_head *head;					\
<span class="p_chunk">@@ -784,18 +784,19 @@</span> <span class="p_context"> perf_trace_##call(void *__data, proto)					\</span>
 			     sizeof(u64));				\
 	__entry_size -= sizeof(u32);					\
 									\
<span class="p_del">-	perf_fetch_caller_regs(&amp;__regs);				\</span>
 	entry = perf_trace_buf_prepare(__entry_size,			\
 			event_call-&gt;event.type, &amp;__regs, &amp;rctx);	\
 	if (!entry)							\
 		return;							\
 									\
<span class="p_add">+	perf_fetch_caller_regs(__regs);					\</span>
<span class="p_add">+									\</span>
 	tstruct								\
 									\
 	{ assign; }							\
 									\
 	perf_trace_buf_submit(entry, __entry_size, rctx, __addr,	\
<span class="p_del">-		__count, &amp;__regs, head, __task);			\</span>
<span class="p_add">+		__count, __regs, head, __task);				\</span>
 }
 
 /*
<span class="p_header">diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">index a81f5473a801..21c1871c6d23 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch9.h</span>
<span class="p_chunk">@@ -724,6 +724,7 @@</span> <span class="p_context"> struct usb_interface_assoc_descriptor {</span>
 	__u8  iFunction;
 } __attribute__ ((packed));
 
<span class="p_add">+#define USB_DT_INTERFACE_ASSOCIATION_SIZE	8</span>
 
 /*-------------------------------------------------------------------------*/
 
<span class="p_header">diff --git a/kernel/audit_watch.c b/kernel/audit_watch.c</span>
<span class="p_header">index 70b4554d2fbe..4593b56339e4 100644</span>
<span class="p_header">--- a/kernel/audit_watch.c</span>
<span class="p_header">+++ b/kernel/audit_watch.c</span>
<span class="p_chunk">@@ -455,13 +455,15 @@</span> <span class="p_context"> void audit_remove_watch_rule(struct audit_krule *krule)</span>
 	list_del(&amp;krule-&gt;rlist);
 
 	if (list_empty(&amp;watch-&gt;rules)) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * audit_remove_watch() drops our reference to &#39;parent&#39; which</span>
<span class="p_add">+		 * can get freed. Grab our own reference to be safe.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		audit_get_parent(parent);</span>
 		audit_remove_watch(watch);
<span class="p_del">-</span>
<span class="p_del">-		if (list_empty(&amp;parent-&gt;watches)) {</span>
<span class="p_del">-			audit_get_parent(parent);</span>
<span class="p_add">+		if (list_empty(&amp;parent-&gt;watches))</span>
 			fsnotify_destroy_mark(&amp;parent-&gt;mark, audit_watch_group);
<span class="p_del">-			audit_put_parent(parent);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		audit_put_parent(parent);</span>
 	}
 }
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index c1c6d24b5275..3598754bfab3 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3565,50 +3565,77 @@</span> <span class="p_context"> u64 perf_event_read_value(struct perf_event *event, u64 *enabled, u64 *running)</span>
 }
 EXPORT_SYMBOL_GPL(perf_event_read_value);
 
<span class="p_del">-static int perf_event_read_group(struct perf_event *event,</span>
<span class="p_del">-				   u64 read_format, char __user *buf)</span>
<span class="p_add">+static void __perf_read_group_add(struct perf_event *leader,</span>
<span class="p_add">+					u64 read_format, u64 *values)</span>
 {
<span class="p_del">-	struct perf_event *leader = event-&gt;group_leader, *sub;</span>
 	struct perf_event_context *ctx = leader-&gt;ctx;
<span class="p_del">-	int n = 0, size = 0, ret;</span>
<span class="p_add">+	struct perf_event *sub;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int n = 1; /* skip @nr */</span>
 	u64 count, enabled, running;
<span class="p_del">-	u64 values[5];</span>
<span class="p_del">-</span>
<span class="p_del">-	lockdep_assert_held(&amp;ctx-&gt;mutex);</span>
 
 	count = perf_event_read_value(leader, &amp;enabled, &amp;running);
 
<span class="p_del">-	values[n++] = 1 + leader-&gt;nr_siblings;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Since we co-schedule groups, {enabled,running} times of siblings</span>
<span class="p_add">+	 * will be identical to those of the leader, so we only publish one</span>
<span class="p_add">+	 * set.</span>
<span class="p_add">+	 */</span>
 	if (read_format &amp; PERF_FORMAT_TOTAL_TIME_ENABLED)
 		values[n++] = enabled;
 	if (read_format &amp; PERF_FORMAT_TOTAL_TIME_RUNNING)
 		values[n++] = running;
<span class="p_del">-	values[n++] = count;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Write {count,id} tuples for every sibling.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	values[n++] += count;</span>
 	if (read_format &amp; PERF_FORMAT_ID)
 		values[n++] = primary_event_id(leader);
 
<span class="p_del">-	size = n * sizeof(u64);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_to_user(buf, values, size))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = size;</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;ctx-&gt;lock, flags);</span>
 
 	list_for_each_entry(sub, &amp;leader-&gt;sibling_list, group_entry) {
<span class="p_del">-		n = 0;</span>
<span class="p_del">-</span>
 		values[n++] = perf_event_read_value(sub, &amp;enabled, &amp;running);
 		if (read_format &amp; PERF_FORMAT_ID)
 			values[n++] = primary_event_id(sub);
<span class="p_add">+	}</span>
 
<span class="p_del">-		size = n * sizeof(u64);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;ctx-&gt;lock, flags);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-		if (copy_to_user(buf + ret, values, size)) {</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		}</span>
<span class="p_add">+static int perf_event_read_group(struct perf_event *event,</span>
<span class="p_add">+				   u64 read_format, char __user *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event *leader = event-&gt;group_leader, *child;</span>
<span class="p_add">+	struct perf_event_context *ctx = leader-&gt;ctx;</span>
<span class="p_add">+	int ret = event-&gt;read_size;</span>
<span class="p_add">+	u64 *values;</span>
 
<span class="p_del">-		ret += size;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	lockdep_assert_held(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	values = kzalloc(event-&gt;read_size, GFP_KERNEL);</span>
<span class="p_add">+	if (!values)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	values[0] = 1 + leader-&gt;nr_siblings;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * By locking the child_mutex of the leader we effectively</span>
<span class="p_add">+	 * lock the child list of all siblings.. XXX explain how.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock(&amp;leader-&gt;child_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	__perf_read_group_add(leader, read_format, values);</span>
<span class="p_add">+	list_for_each_entry(child, &amp;leader-&gt;child_list, child_list)</span>
<span class="p_add">+		__perf_read_group_add(child, read_format, values);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;leader-&gt;child_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_to_user(buf, values, event-&gt;read_size))</span>
<span class="p_add">+		ret = -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(values);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -5938,6 +5965,8 @@</span> <span class="p_context"> static void do_perf_sw_event(enum perf_type_id type, u32 event_id,</span>
 	rcu_read_unlock();
 }
 
<span class="p_add">+DEFINE_PER_CPU(struct pt_regs, __perf_regs[4]);</span>
<span class="p_add">+</span>
 int perf_swevent_get_recursion_context(void)
 {
 	struct swevent_htable *swhash = &amp;__get_cpu_var(swevent_htable);
<span class="p_chunk">@@ -5953,21 +5982,30 @@</span> <span class="p_context"> inline void perf_swevent_put_recursion_context(int rctx)</span>
 	put_recursion_context(swhash-&gt;recursion, rctx);
 }
 
<span class="p_del">-void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)</span>
<span class="p_add">+void ___perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)</span>
 {
 	struct perf_sample_data data;
<span class="p_del">-	int rctx;</span>
 
<span class="p_del">-	preempt_disable_notrace();</span>
<span class="p_del">-	rctx = perf_swevent_get_recursion_context();</span>
<span class="p_del">-	if (rctx &lt; 0)</span>
<span class="p_add">+	if (WARN_ON_ONCE(!regs))</span>
 		return;
 
 	perf_sample_data_init(&amp;data, addr, 0);
<span class="p_del">-</span>
 	do_perf_sw_event(PERF_TYPE_SOFTWARE, event_id, nr, &amp;data, regs);
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rctx;</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable_notrace();</span>
<span class="p_add">+	rctx = perf_swevent_get_recursion_context();</span>
<span class="p_add">+	if (unlikely(rctx &lt; 0))</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+</span>
<span class="p_add">+	___perf_sw_event(event_id, nr, regs, addr);</span>
 
 	perf_swevent_put_recursion_context(rctx);
<span class="p_add">+fail:</span>
 	preempt_enable_notrace();
 }
 
<span class="p_chunk">@@ -7514,28 +7552,27 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 		if (group_leader-&gt;group_leader != group_leader)
 			goto err_context;
 		/*
<span class="p_del">-		 * Do not allow to attach to a group in a different</span>
<span class="p_del">-		 * task or CPU context:</span>
<span class="p_add">+		 * Make sure we&#39;re both events for the same CPU;</span>
<span class="p_add">+		 * grouping events for different CPUs is broken; since</span>
<span class="p_add">+		 * you can never concurrently schedule them anyhow.</span>
 		 */
<span class="p_del">-		if (move_group) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Make sure we&#39;re both on the same task, or both</span>
<span class="p_del">-			 * per-cpu events.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (group_leader-&gt;ctx-&gt;task != ctx-&gt;task)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_add">+		if (group_leader-&gt;cpu != event-&gt;cpu)</span>
<span class="p_add">+			goto err_context;</span>
 
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Make sure we&#39;re both events for the same CPU;</span>
<span class="p_del">-			 * grouping events for different CPUs is broken; since</span>
<span class="p_del">-			 * you can never concurrently schedule them anyhow.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (group_leader-&gt;cpu != event-&gt;cpu)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			if (group_leader-&gt;ctx != ctx)</span>
<span class="p_del">-				goto err_context;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Make sure we&#39;re both on the same task, or both</span>
<span class="p_add">+		 * per-CPU events.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (group_leader-&gt;ctx-&gt;task != ctx-&gt;task)</span>
<span class="p_add">+			goto err_context;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do not allow to attach to a group in a different task</span>
<span class="p_add">+		 * or CPU context. If we&#39;re moving SW events, we&#39;ll fix</span>
<span class="p_add">+		 * this up later, so allow that.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!move_group &amp;&amp; group_leader-&gt;ctx != ctx)</span>
<span class="p_add">+			goto err_context;</span>
 
 		/*
 		 * Only a group leader can be exclusive or pinned
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 0e1f602b8f47..f6422f07d133 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -539,7 +539,7 @@</span> <span class="p_context"> static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)</span>
 	spin_lock_init(&amp;mm-&gt;page_table_lock);
 	mm_init_aio(mm);
 	mm_init_owner(mm, p);
<span class="p_del">-	clear_tlb_flush_pending(mm);</span>
<span class="p_add">+	init_tlb_flush_pending(mm);</span>
 
 	if (current-&gt;mm) {
 		mm-&gt;flags = current-&gt;mm-&gt;flags &amp; MMF_INIT_MASK;
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index d6d34bbf921a..0940ee9603ae 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1083,7 +1083,7 @@</span> <span class="p_context"> void set_task_cpu(struct task_struct *p, unsigned int new_cpu)</span>
 		if (p-&gt;sched_class-&gt;migrate_task_rq)
 			p-&gt;sched_class-&gt;migrate_task_rq(p, new_cpu);
 		p-&gt;se.nr_migrations++;
<span class="p_del">-		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);</span>
<span class="p_add">+		perf_sw_event_sched(PERF_COUNT_SW_CPU_MIGRATIONS, 1, 0);</span>
 
 		tmn.task = p;
 		tmn.from_cpu = task_cpu(p);
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index b86ee4effa02..4df317cb0e9a 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -6373,6 +6373,7 @@</span> <span class="p_context"> static int instance_delete(const char *name)</span>
 	debugfs_remove_recursive(tr-&gt;dir);
 	free_trace_buffers(tr);
 
<span class="p_add">+	free_cpumask_var(tr-&gt;tracing_cpumask);</span>
 	kfree(tr-&gt;name);
 	kfree(tr);
 
<span class="p_header">diff --git a/kernel/trace/trace_event_perf.c b/kernel/trace/trace_event_perf.c</span>
<span class="p_header">index 5d12bb407b44..a818e5601f89 100644</span>
<span class="p_header">--- a/kernel/trace/trace_event_perf.c</span>
<span class="p_header">+++ b/kernel/trace/trace_event_perf.c</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> void perf_trace_del(struct perf_event *p_event, int flags)</span>
 }
 
 void *perf_trace_buf_prepare(int size, unsigned short type,
<span class="p_del">-			     struct pt_regs *regs, int *rctxp)</span>
<span class="p_add">+			     struct pt_regs **regs, int *rctxp)</span>
 {
 	struct trace_entry *entry;
 	unsigned long flags;
<span class="p_chunk">@@ -268,6 +268,8 @@</span> <span class="p_context"> void *perf_trace_buf_prepare(int size, unsigned short type,</span>
 	if (*rctxp &lt; 0)
 		return NULL;
 
<span class="p_add">+	if (regs)</span>
<span class="p_add">+		*regs = this_cpu_ptr(&amp;__perf_regs[*rctxp]);</span>
 	raw_data = this_cpu_ptr(perf_trace_buf[*rctxp]);
 
 	/* zero the dead bytes from align to not leak stack to user */
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index 7b244d004d68..ebbb24147d51 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1950,6 +1950,10 @@</span> <span class="p_context"> static int create_filter(struct ftrace_event_call *call,</span>
 		if (err &amp;&amp; set_str)
 			append_filter_err(ps, filter);
 	}
<span class="p_add">+	if (err &amp;&amp; !set_str) {</span>
<span class="p_add">+		free_event_filter(filter);</span>
<span class="p_add">+		filter = NULL;</span>
<span class="p_add">+	}</span>
 	create_filter_finish(ps);
 
 	*filterp = filter;
<span class="p_header">diff --git a/kernel/trace/trace_kprobe.c b/kernel/trace/trace_kprobe.c</span>
<span class="p_header">index 94b253911a2a..562cbf747622 100644</span>
<span class="p_header">--- a/kernel/trace/trace_kprobe.c</span>
<span class="p_header">+++ b/kernel/trace/trace_kprobe.c</span>
<span class="p_chunk">@@ -1155,7 +1155,7 @@</span> <span class="p_context"> kprobe_perf_func(struct trace_kprobe *tk, struct pt_regs *regs)</span>
 	size = ALIGN(__size + sizeof(u32), sizeof(u64));
 	size -= sizeof(u32);
 
<span class="p_del">-	entry = perf_trace_buf_prepare(size, call-&gt;event.type, regs, &amp;rctx);</span>
<span class="p_add">+	entry = perf_trace_buf_prepare(size, call-&gt;event.type, NULL, &amp;rctx);</span>
 	if (!entry)
 		return;
 
<span class="p_chunk">@@ -1186,7 +1186,7 @@</span> <span class="p_context"> kretprobe_perf_func(struct trace_kprobe *tk, struct kretprobe_instance *ri,</span>
 	size = ALIGN(__size + sizeof(u32), sizeof(u64));
 	size -= sizeof(u32);
 
<span class="p_del">-	entry = perf_trace_buf_prepare(size, call-&gt;event.type, regs, &amp;rctx);</span>
<span class="p_add">+	entry = perf_trace_buf_prepare(size, call-&gt;event.type, NULL, &amp;rctx);</span>
 	if (!entry)
 		return;
 
<span class="p_header">diff --git a/kernel/trace/trace_syscalls.c b/kernel/trace/trace_syscalls.c</span>
<span class="p_header">index 7e3cd7aaec83..ba78f0e3477d 100644</span>
<span class="p_header">--- a/kernel/trace/trace_syscalls.c</span>
<span class="p_header">+++ b/kernel/trace/trace_syscalls.c</span>
<span class="p_chunk">@@ -586,7 +586,7 @@</span> <span class="p_context"> static void perf_syscall_enter(void *ignore, struct pt_regs *regs, long id)</span>
 	size -= sizeof(u32);
 
 	rec = (struct syscall_trace_enter *)perf_trace_buf_prepare(size,
<span class="p_del">-				sys_data-&gt;enter_event-&gt;event.type, regs, &amp;rctx);</span>
<span class="p_add">+				sys_data-&gt;enter_event-&gt;event.type, NULL, &amp;rctx);</span>
 	if (!rec)
 		return;
 
<span class="p_chunk">@@ -659,7 +659,7 @@</span> <span class="p_context"> static void perf_syscall_exit(void *ignore, struct pt_regs *regs, long ret)</span>
 	size -= sizeof(u32);
 
 	rec = (struct syscall_trace_exit *)perf_trace_buf_prepare(size,
<span class="p_del">-				sys_data-&gt;exit_event-&gt;event.type, regs, &amp;rctx);</span>
<span class="p_add">+				sys_data-&gt;exit_event-&gt;event.type, NULL, &amp;rctx);</span>
 	if (!rec)
 		return;
 
<span class="p_header">diff --git a/kernel/trace/trace_uprobe.c b/kernel/trace/trace_uprobe.c</span>
<span class="p_header">index 3c9b97e6b1f4..5224e836acde 100644</span>
<span class="p_header">--- a/kernel/trace/trace_uprobe.c</span>
<span class="p_header">+++ b/kernel/trace/trace_uprobe.c</span>
<span class="p_chunk">@@ -1116,7 +1116,7 @@</span> <span class="p_context"> static void __uprobe_perf_func(struct trace_uprobe *tu,</span>
 	if (hlist_empty(head))
 		goto out;
 
<span class="p_del">-	entry = perf_trace_buf_prepare(size, call-&gt;event.type, regs, &amp;rctx);</span>
<span class="p_add">+	entry = perf_trace_buf_prepare(size, call-&gt;event.type, NULL, &amp;rctx);</span>
 	if (!entry)
 		goto out;
 
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 5e6cafeeb048..146fb7784900 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -3324,7 +3324,7 @@</span> <span class="p_context"> int workqueue_sysfs_register(struct workqueue_struct *wq)</span>
 	 * attributes breaks ordering guarantee.  Disallow exposing ordered
 	 * workqueues.
 	 */
<span class="p_del">-	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED))</span>
<span class="p_add">+	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED_EXPLICIT))</span>
 		return -EINVAL;
 
 	wq-&gt;wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);
<span class="p_chunk">@@ -3907,8 +3907,12 @@</span> <span class="p_context"> int apply_workqueue_attrs(struct workqueue_struct *wq,</span>
 		return -EINVAL;
 
 	/* creating multiple pwqs breaks ordering guarantee */
<span class="p_del">-	if (WARN_ON((wq-&gt;flags &amp; __WQ_ORDERED) &amp;&amp; !list_empty(&amp;wq-&gt;pwqs)))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (!list_empty(&amp;wq-&gt;pwqs)) {</span>
<span class="p_add">+		if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED_EXPLICIT))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		wq-&gt;flags &amp;= ~__WQ_ORDERED;</span>
<span class="p_add">+	}</span>
 
 	pwq_tbl = kzalloc(wq_numa_tbl_len * sizeof(pwq_tbl[0]), GFP_KERNEL);
 	new_attrs = alloc_workqueue_attrs(GFP_KERNEL);
<span class="p_chunk">@@ -4152,6 +4156,16 @@</span> <span class="p_context"> struct workqueue_struct *__alloc_workqueue_key(const char *fmt,</span>
 	struct workqueue_struct *wq;
 	struct pool_workqueue *pwq;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Unbound &amp;&amp; max_active == 1 used to imply ordered, which is no</span>
<span class="p_add">+	 * longer the case on NUMA machines due to per-node pools.  While</span>
<span class="p_add">+	 * alloc_ordered_workqueue() is the right way to create an ordered</span>
<span class="p_add">+	 * workqueue, keep the previous behavior to avoid subtle breakages</span>
<span class="p_add">+	 * on NUMA.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((flags &amp; WQ_UNBOUND) &amp;&amp; max_active == 1)</span>
<span class="p_add">+		flags |= __WQ_ORDERED;</span>
<span class="p_add">+</span>
 	/* see the comment above the definition of WQ_POWER_EFFICIENT */
 	if ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)
 		flags |= WQ_UNBOUND;
<span class="p_chunk">@@ -4344,13 +4358,14 @@</span> <span class="p_context"> void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)</span>
 	struct pool_workqueue *pwq;
 
 	/* disallow meddling with max_active for ordered workqueues */
<span class="p_del">-	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED))</span>
<span class="p_add">+	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED_EXPLICIT))</span>
 		return;
 
 	max_active = wq_clamp_max_active(max_active, wq-&gt;flags, wq-&gt;name);
 
 	mutex_lock(&amp;wq-&gt;mutex);
 
<span class="p_add">+	wq-&gt;flags &amp;= ~__WQ_ORDERED;</span>
 	wq-&gt;saved_max_active = max_active;
 
 	for_each_pwq(pwq, wq)
<span class="p_header">diff --git a/lib/assoc_array.c b/lib/assoc_array.c</span>
<span class="p_header">index 03a77f4740c1..0d122543bd63 100644</span>
<span class="p_header">--- a/lib/assoc_array.c</span>
<span class="p_header">+++ b/lib/assoc_array.c</span>
<span class="p_chunk">@@ -597,21 +597,31 @@</span> <span class="p_context"> static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,</span>
 		if ((edit-&gt;segment_cache[ASSOC_ARRAY_FAN_OUT] ^ base_seg) == 0)
 			goto all_leaves_cluster_together;
 
<span class="p_del">-		/* Otherwise we can just insert a new node ahead of the old</span>
<span class="p_del">-		 * one.</span>
<span class="p_add">+		/* Otherwise all the old leaves cluster in the same slot, but</span>
<span class="p_add">+		 * the new leaf wants to go into a different slot - so we</span>
<span class="p_add">+		 * create a new node (n0) to hold the new leaf and a pointer to</span>
<span class="p_add">+		 * a new node (n1) holding all the old leaves.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This can be done by falling through to the node splitting</span>
<span class="p_add">+		 * path.</span>
 		 */
<span class="p_del">-		goto present_leaves_cluster_but_not_new_leaf;</span>
<span class="p_add">+		pr_devel(&quot;present leaves cluster but not new leaf\n&quot;);</span>
 	}
 
 split_node:
 	pr_devel(&quot;split node\n&quot;);
 
<span class="p_del">-	/* We need to split the current node; we know that the node doesn&#39;t</span>
<span class="p_del">-	 * simply contain a full set of leaves that cluster together (it</span>
<span class="p_del">-	 * contains meta pointers and/or non-clustering leaves).</span>
<span class="p_add">+	/* We need to split the current node.  The node must contain anything</span>
<span class="p_add">+	 * from a single leaf (in the one leaf case, this leaf will cluster</span>
<span class="p_add">+	 * with the new leaf) and the rest meta-pointers, to all leaves, some</span>
<span class="p_add">+	 * of which may cluster.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * It won&#39;t contain the case in which all the current leaves plus the</span>
<span class="p_add">+	 * new leaves want to cluster in the same slot.</span>
 	 *
 	 * We need to expel at least two leaves out of a set consisting of the
<span class="p_del">-	 * leaves in the node and the new leaf.</span>
<span class="p_add">+	 * leaves in the node and the new leaf.  The current meta pointers can</span>
<span class="p_add">+	 * just be copied as they shouldn&#39;t cluster with any of the leaves.</span>
 	 *
 	 * We need a new node (n0) to replace the current one and a new node to
 	 * take the expelled nodes (n1).
<span class="p_chunk">@@ -716,33 +726,6 @@</span> <span class="p_context"> static bool assoc_array_insert_into_terminal_node(struct assoc_array_edit *edit,</span>
 	pr_devel(&quot;&lt;--%s() = ok [split node]\n&quot;, __func__);
 	return true;
 
<span class="p_del">-present_leaves_cluster_but_not_new_leaf:</span>
<span class="p_del">-	/* All the old leaves cluster in the same slot, but the new leaf wants</span>
<span class="p_del">-	 * to go into a different slot, so we create a new node to hold the new</span>
<span class="p_del">-	 * leaf and a pointer to a new node holding all the old leaves.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pr_devel(&quot;present leaves cluster but not new leaf\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	new_n0-&gt;back_pointer = node-&gt;back_pointer;</span>
<span class="p_del">-	new_n0-&gt;parent_slot = node-&gt;parent_slot;</span>
<span class="p_del">-	new_n0-&gt;nr_leaves_on_branch = node-&gt;nr_leaves_on_branch;</span>
<span class="p_del">-	new_n1-&gt;back_pointer = assoc_array_node_to_ptr(new_n0);</span>
<span class="p_del">-	new_n1-&gt;parent_slot = edit-&gt;segment_cache[0];</span>
<span class="p_del">-	new_n1-&gt;nr_leaves_on_branch = node-&gt;nr_leaves_on_branch;</span>
<span class="p_del">-	edit-&gt;adjust_count_on = new_n0;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; ASSOC_ARRAY_FAN_OUT; i++)</span>
<span class="p_del">-		new_n1-&gt;slots[i] = node-&gt;slots[i];</span>
<span class="p_del">-</span>
<span class="p_del">-	new_n0-&gt;slots[edit-&gt;segment_cache[0]] = assoc_array_node_to_ptr(new_n0);</span>
<span class="p_del">-	edit-&gt;leaf_p = &amp;new_n0-&gt;slots[edit-&gt;segment_cache[ASSOC_ARRAY_FAN_OUT]];</span>
<span class="p_del">-</span>
<span class="p_del">-	edit-&gt;set[0].ptr = &amp;assoc_array_ptr_to_node(node-&gt;back_pointer)-&gt;slots[node-&gt;parent_slot];</span>
<span class="p_del">-	edit-&gt;set[0].to = assoc_array_node_to_ptr(new_n0);</span>
<span class="p_del">-	edit-&gt;excised_meta[0] = assoc_array_node_to_ptr(node);</span>
<span class="p_del">-	pr_devel(&quot;&lt;--%s() = ok [insert node before]\n&quot;, __func__);</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-</span>
 all_leaves_cluster_together:
 	/* All the leaves, new and old, want to cluster together in this node
 	 * in the same slot, so we have to replace this node with a shortcut to
<span class="p_header">diff --git a/lib/cpumask.c b/lib/cpumask.c</span>
<span class="p_header">index 78c13985a0a3..317867e0a03f 100644</span>
<span class="p_header">--- a/lib/cpumask.c</span>
<span class="p_header">+++ b/lib/cpumask.c</span>
<span class="p_chunk">@@ -198,64 +198,42 @@</span> <span class="p_context"> void __init free_bootmem_cpumask_var(cpumask_var_t mask)</span>
 #endif
 
 /**
<span class="p_del">- * cpumask_set_cpu_local_first - set i&#39;th cpu with local numa cpu&#39;s first</span>
<span class="p_del">- *</span>
<span class="p_add">+ * cpumask_local_spread - select the i&#39;th cpu with local numa cpu&#39;s first</span>
  * @i: index number
<span class="p_del">- * @numa_node: local numa_node</span>
<span class="p_del">- * @dstp: cpumask with the relevant cpu bit set according to the policy</span>
<span class="p_add">+ * @node: local numa_node</span>
  *
<span class="p_del">- * This function sets the cpumask according to a numa aware policy.</span>
<span class="p_del">- * cpumask could be used as an affinity hint for the IRQ related to a</span>
<span class="p_del">- * queue. When the policy is to spread queues across cores - local cores</span>
<span class="p_del">- * first.</span>
<span class="p_add">+ * This function selects an online CPU according to a numa aware policy;</span>
<span class="p_add">+ * local cpus are returned first, followed by non-local ones, then it</span>
<span class="p_add">+ * wraps around.</span>
  *
<span class="p_del">- * Returns 0 on success, -ENOMEM for no memory, and -EAGAIN when failed to set</span>
<span class="p_del">- * the cpu bit and need to re-call the function.</span>
<span class="p_add">+ * It&#39;s not very efficient, but useful for setup.</span>
  */
<span class="p_del">-int cpumask_set_cpu_local_first(int i, int numa_node, cpumask_t *dstp)</span>
<span class="p_add">+unsigned int cpumask_local_spread(unsigned int i, int node)</span>
 {
<span class="p_del">-	cpumask_var_t mask;</span>
 	int cpu;
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!zalloc_cpumask_var(&amp;mask, GFP_KERNEL))</span>
<span class="p_del">-		return -ENOMEM;</span>
 
<span class="p_add">+	/* Wrap: we always want a cpu. */</span>
 	i %= num_online_cpus();
 
<span class="p_del">-	if (numa_node == -1 || !cpumask_of_node(numa_node)) {</span>
<span class="p_del">-		/* Use all online cpu&#39;s for non numa aware system */</span>
<span class="p_del">-		cpumask_copy(mask, cpu_online_mask);</span>
<span class="p_add">+	if (node == -1) {</span>
<span class="p_add">+		for_each_cpu(cpu, cpu_online_mask)</span>
<span class="p_add">+			if (i-- == 0)</span>
<span class="p_add">+				return cpu;</span>
 	} else {
<span class="p_del">-		int n;</span>
<span class="p_del">-</span>
<span class="p_del">-		cpumask_and(mask,</span>
<span class="p_del">-			    cpumask_of_node(numa_node), cpu_online_mask);</span>
<span class="p_del">-</span>
<span class="p_del">-		n = cpumask_weight(mask);</span>
<span class="p_del">-		if (i &gt;= n) {</span>
<span class="p_del">-			i -= n;</span>
<span class="p_del">-</span>
<span class="p_del">-			/* If index &gt; number of local cpu&#39;s, mask out local</span>
<span class="p_del">-			 * cpu&#39;s</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			cpumask_andnot(mask, cpu_online_mask, mask);</span>
<span class="p_add">+		/* NUMA first. */</span>
<span class="p_add">+		for_each_cpu_and(cpu, cpumask_of_node(node), cpu_online_mask)</span>
<span class="p_add">+			if (i-- == 0)</span>
<span class="p_add">+				return cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+		for_each_cpu(cpu, cpu_online_mask) {</span>
<span class="p_add">+			/* Skip NUMA nodes, done above. */</span>
<span class="p_add">+			if (cpumask_test_cpu(cpu, cpumask_of_node(node)))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (i-- == 0)</span>
<span class="p_add">+				return cpu;</span>
 		}
 	}
<span class="p_del">-</span>
<span class="p_del">-	for_each_cpu(cpu, mask) {</span>
<span class="p_del">-		if (--i &lt; 0)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	free_cpumask_var(mask);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ret)</span>
<span class="p_del">-		cpumask_set_cpu(cpu, dstp);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	BUG();</span>
 }
<span class="p_del">-EXPORT_SYMBOL(cpumask_set_cpu_local_first);</span>
<span class="p_add">+EXPORT_SYMBOL(cpumask_local_spread);</span>
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 467d04b62948..c892a6b51e8e 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1105,14 +1105,20 @@</span> <span class="p_context"> static int dissolve_free_huge_page(struct page *page)</span>
 int dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
 {
 	unsigned long pfn;
<span class="p_add">+	struct page *page;</span>
 	int rc = 0;
 
 	if (!hugepages_supported())
 		return rc;
 
<span class="p_del">-	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)</span>
<span class="p_del">-		if (rc = dissolve_free_huge_page(pfn_to_page(pfn)))</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order) {</span>
<span class="p_add">+		page = pfn_to_page(pfn);</span>
<span class="p_add">+		if (PageHuge(page) &amp;&amp; !page_count(page)) {</span>
<span class="p_add">+			rc = dissolve_free_huge_page(page);</span>
<span class="p_add">+			if (rc)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	return rc;
 }
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index ca088a55b902..fffff2a6677a 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -957,11 +957,6 @@</span> <span class="p_context"> static long do_get_mempolicy(int *policy, nodemask_t *nmask,</span>
 		*policy |= (pol-&gt;flags &amp; MPOL_MODE_FLAGS);
 	}
 
<span class="p_del">-	if (vma) {</span>
<span class="p_del">-		up_read(&amp;current-&gt;mm-&gt;mmap_sem);</span>
<span class="p_del">-		vma = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	err = 0;
 	if (nmask) {
 		if (mpol_store_user_nodemask(pol)) {
<span class="p_header">diff --git a/mm/mprotect.c b/mm/mprotect.c</span>
<span class="p_header">index c43d557941f8..24607a31259e 100644</span>
<span class="p_header">--- a/mm/mprotect.c</span>
<span class="p_header">+++ b/mm/mprotect.c</span>
<span class="p_chunk">@@ -225,7 +225,7 @@</span> <span class="p_context"> static unsigned long change_protection_range(struct vm_area_struct *vma,</span>
 	BUG_ON(addr &gt;= end);
 	pgd = pgd_offset(mm, addr);
 	flush_cache_range(vma, addr, end);
<span class="p_del">-	set_tlb_flush_pending(mm);</span>
<span class="p_add">+	inc_tlb_flush_pending(mm);</span>
 	do {
 		next = pgd_addr_end(addr, end);
 		if (pgd_none_or_clear_bad(pgd))
<span class="p_chunk">@@ -237,7 +237,7 @@</span> <span class="p_context"> static unsigned long change_protection_range(struct vm_area_struct *vma,</span>
 	/* Only flush the TLB if we actually modified any entries: */
 	if (pages)
 		flush_tlb_range(vma, start, end);
<span class="p_del">-	clear_tlb_flush_pending(mm);</span>
<span class="p_add">+	dec_tlb_flush_pending(mm);</span>
 
 	return pages;
 }
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index ab7938d2248e..2c1d0eec78ba 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/page-debug-flags.h&gt;
 #include &lt;linux/hugetlb.h&gt;
 #include &lt;linux/sched/rt.h&gt;
<span class="p_add">+#include &lt;linux/nmi.h&gt;</span>
 
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/tlbflush.h&gt;
<span class="p_chunk">@@ -1354,9 +1355,14 @@</span> <span class="p_context"> void drain_all_pages(void)</span>
 
 #ifdef CONFIG_HIBERNATION
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Touch the watchdog for every WD_PAGE_COUNT pages.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define WD_PAGE_COUNT	(128*1024)</span>
<span class="p_add">+</span>
 void mark_free_pages(struct zone *zone)
 {
<span class="p_del">-	unsigned long pfn, max_zone_pfn;</span>
<span class="p_add">+	unsigned long pfn, max_zone_pfn, page_count = WD_PAGE_COUNT;</span>
 	unsigned long flags;
 	unsigned int order, t;
 	struct list_head *curr;
<span class="p_chunk">@@ -1371,6 +1377,11 @@</span> <span class="p_context"> void mark_free_pages(struct zone *zone)</span>
 		if (pfn_valid(pfn)) {
 			struct page *page = pfn_to_page(pfn);
 
<span class="p_add">+			if (!--page_count) {</span>
<span class="p_add">+				touch_nmi_watchdog();</span>
<span class="p_add">+				page_count = WD_PAGE_COUNT;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (!swsusp_page_is_forbidden(page))
 				swsusp_unset_page_free(page);
 		}
<span class="p_chunk">@@ -1380,8 +1391,13 @@</span> <span class="p_context"> void mark_free_pages(struct zone *zone)</span>
 			unsigned long i;
 
 			pfn = page_to_pfn(list_entry(curr, struct page, lru));
<span class="p_del">-			for (i = 0; i &lt; (1UL &lt;&lt; order); i++)</span>
<span class="p_add">+			for (i = 0; i &lt; (1UL &lt;&lt; order); i++) {</span>
<span class="p_add">+				if (!--page_count) {</span>
<span class="p_add">+					touch_nmi_watchdog();</span>
<span class="p_add">+					page_count = WD_PAGE_COUNT;</span>
<span class="p_add">+				}</span>
 				swsusp_set_page_free(pfn_to_page(pfn + i));
<span class="p_add">+			}</span>
 		}
 	}
 	spin_unlock_irqrestore(&amp;zone-&gt;lock, flags);
<span class="p_chunk">@@ -5319,15 +5335,18 @@</span> <span class="p_context"> void __init free_area_init_nodes(unsigned long *max_zone_pfn)</span>
 				sizeof(arch_zone_lowest_possible_pfn));
 	memset(arch_zone_highest_possible_pfn, 0,
 				sizeof(arch_zone_highest_possible_pfn));
<span class="p_del">-	arch_zone_lowest_possible_pfn[0] = find_min_pfn_with_active_regions();</span>
<span class="p_del">-	arch_zone_highest_possible_pfn[0] = max_zone_pfn[0];</span>
<span class="p_del">-	for (i = 1; i &lt; MAX_NR_ZONES; i++) {</span>
<span class="p_add">+</span>
<span class="p_add">+	start_pfn = find_min_pfn_with_active_regions();</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_NR_ZONES; i++) {</span>
 		if (i == ZONE_MOVABLE)
 			continue;
<span class="p_del">-		arch_zone_lowest_possible_pfn[i] =</span>
<span class="p_del">-			arch_zone_highest_possible_pfn[i-1];</span>
<span class="p_del">-		arch_zone_highest_possible_pfn[i] =</span>
<span class="p_del">-			max(max_zone_pfn[i], arch_zone_lowest_possible_pfn[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		end_pfn = max(max_zone_pfn[i], start_pfn);</span>
<span class="p_add">+		arch_zone_lowest_possible_pfn[i] = start_pfn;</span>
<span class="p_add">+		arch_zone_highest_possible_pfn[i] = end_pfn;</span>
<span class="p_add">+</span>
<span class="p_add">+		start_pfn = end_pfn;</span>
 	}
 	arch_zone_lowest_possible_pfn[ZONE_MOVABLE] = 0;
 	arch_zone_highest_possible_pfn[ZONE_MOVABLE] = 0;
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index c93007d9c403..118eba81620e 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -1233,9 +1233,41 @@</span> <span class="p_context"> batadv_tt_global_entry_has_orig(const struct batadv_tt_global_entry *entry,</span>
 	return found;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_tt_global_sync_flags - update TT sync flags</span>
<span class="p_add">+ * @tt_global: the TT global entry to update sync flags in</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Updates the sync flag bits in the tt_global flag attribute with a logical</span>
<span class="p_add">+ * OR of all sync flags from any of its TT orig entries.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+batadv_tt_global_sync_flags(struct batadv_tt_global_entry *tt_global)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct batadv_tt_orig_list_entry *orig_entry;</span>
<span class="p_add">+	const struct hlist_head *head;</span>
<span class="p_add">+	u16 flags = BATADV_NO_FLAGS;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	head = &amp;tt_global-&gt;orig_list;</span>
<span class="p_add">+	hlist_for_each_entry_rcu(orig_entry, head, list)</span>
<span class="p_add">+		flags |= orig_entry-&gt;flags;</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	flags |= tt_global-&gt;common.flags &amp; (~BATADV_TT_SYNC_MASK);</span>
<span class="p_add">+	tt_global-&gt;common.flags = flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * batadv_tt_global_orig_entry_add - add or update a TT orig entry</span>
<span class="p_add">+ * @tt_global: the TT global entry to add an orig entry in</span>
<span class="p_add">+ * @orig_node: the originator to add an orig entry for</span>
<span class="p_add">+ * @ttvn: translation table version number of this changeset</span>
<span class="p_add">+ * @flags: TT sync flags</span>
<span class="p_add">+ */</span>
 static void
 batadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,
<span class="p_del">-				struct batadv_orig_node *orig_node, int ttvn)</span>
<span class="p_add">+				struct batadv_orig_node *orig_node, int ttvn,</span>
<span class="p_add">+				u8 flags)</span>
 {
 	struct batadv_tt_orig_list_entry *orig_entry;
 
<span class="p_chunk">@@ -1245,7 +1277,8 @@</span> <span class="p_context"> batadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,</span>
 		 * was added during a &quot;temporary client detection&quot;
 		 */
 		orig_entry-&gt;ttvn = ttvn;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		orig_entry-&gt;flags = flags;</span>
<span class="p_add">+		goto sync_flags;</span>
 	}
 
 	orig_entry = kzalloc(sizeof(*orig_entry), GFP_ATOMIC);
<span class="p_chunk">@@ -1257,6 +1290,7 @@</span> <span class="p_context"> batadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,</span>
 	batadv_tt_global_size_inc(orig_node, tt_global-&gt;common.vid);
 	orig_entry-&gt;orig_node = orig_node;
 	orig_entry-&gt;ttvn = ttvn;
<span class="p_add">+	orig_entry-&gt;flags = flags;</span>
 	atomic_set(&amp;orig_entry-&gt;refcount, 2);
 
 	spin_lock_bh(&amp;tt_global-&gt;list_lock);
<span class="p_chunk">@@ -1265,6 +1299,8 @@</span> <span class="p_context"> batadv_tt_global_orig_entry_add(struct batadv_tt_global_entry *tt_global,</span>
 	spin_unlock_bh(&amp;tt_global-&gt;list_lock);
 	atomic_inc(&amp;tt_global-&gt;orig_list_count);
 
<span class="p_add">+sync_flags:</span>
<span class="p_add">+	batadv_tt_global_sync_flags(tt_global);</span>
 out:
 	if (orig_entry)
 		batadv_tt_orig_list_entry_free_ref(orig_entry);
<span class="p_chunk">@@ -1379,10 +1415,10 @@</span> <span class="p_context"> static bool batadv_tt_global_add(struct batadv_priv *bat_priv,</span>
 		common-&gt;flags &amp;= ~BATADV_TT_CLIENT_TEMP;
 
 		/* the change can carry possible &quot;attribute&quot; flags like the
<span class="p_del">-		 * TT_CLIENT_WIFI, therefore they have to be copied in the</span>
<span class="p_add">+		 * TT_CLIENT_TEMP, therefore they have to be copied in the</span>
 		 * client entry
 		 */
<span class="p_del">-		tt_global_entry-&gt;common.flags |= flags;</span>
<span class="p_add">+		tt_global_entry-&gt;common.flags |= flags &amp; (~BATADV_TT_SYNC_MASK);</span>
 
 		/* If there is the BATADV_TT_CLIENT_ROAM flag set, there is only
 		 * one originator left in the list and we previously received a
<span class="p_chunk">@@ -1399,7 +1435,8 @@</span> <span class="p_context"> static bool batadv_tt_global_add(struct batadv_priv *bat_priv,</span>
 	}
 add_orig_entry:
 	/* add the new orig_entry (if needed) or update it */
<span class="p_del">-	batadv_tt_global_orig_entry_add(tt_global_entry, orig_node, ttvn);</span>
<span class="p_add">+	batadv_tt_global_orig_entry_add(tt_global_entry, orig_node, ttvn,</span>
<span class="p_add">+					flags &amp; BATADV_TT_SYNC_MASK);</span>
 
 	batadv_dbg(BATADV_DBG_TT, bat_priv,
 		   &quot;Creating new global tt entry: %pM (vid: %d, via %pM)\n&quot;,
<span class="p_chunk">@@ -2045,6 +2082,7 @@</span> <span class="p_context"> static uint32_t batadv_tt_global_crc(struct batadv_priv *bat_priv,</span>
 				     unsigned short vid)
 {
 	struct batadv_hashtable *hash = bat_priv-&gt;tt.global_hash;
<span class="p_add">+	struct batadv_tt_orig_list_entry *tt_orig;</span>
 	struct batadv_tt_common_entry *tt_common;
 	struct batadv_tt_global_entry *tt_global;
 	struct hlist_head *head;
<span class="p_chunk">@@ -2083,8 +2121,9 @@</span> <span class="p_context"> static uint32_t batadv_tt_global_crc(struct batadv_priv *bat_priv,</span>
 			/* find out if this global entry is announced by this
 			 * originator
 			 */
<span class="p_del">-			if (!batadv_tt_global_entry_has_orig(tt_global,</span>
<span class="p_del">-							     orig_node))</span>
<span class="p_add">+			tt_orig = batadv_tt_global_orig_entry_find(tt_global,</span>
<span class="p_add">+								   orig_node);</span>
<span class="p_add">+			if (!tt_orig)</span>
 				continue;
 
 			/* use network order to read the VID: this ensures that
<span class="p_chunk">@@ -2096,10 +2135,12 @@</span> <span class="p_context"> static uint32_t batadv_tt_global_crc(struct batadv_priv *bat_priv,</span>
 			/* compute the CRC on flags that have to be kept in sync
 			 * among nodes
 			 */
<span class="p_del">-			flags = tt_common-&gt;flags &amp; BATADV_TT_SYNC_MASK;</span>
<span class="p_add">+			flags = tt_orig-&gt;flags;</span>
 			crc_tmp = crc32c(crc_tmp, &amp;flags, sizeof(flags));
 
 			crc ^= crc32c(crc_tmp, tt_common-&gt;addr, ETH_ALEN);
<span class="p_add">+</span>
<span class="p_add">+			batadv_tt_orig_list_entry_free_ref(tt_orig);</span>
 		}
 		rcu_read_unlock();
 	}
<span class="p_header">diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h</span>
<span class="p_header">index 61f34f889555..9161e3e62a55 100644</span>
<span class="p_header">--- a/net/batman-adv/types.h</span>
<span class="p_header">+++ b/net/batman-adv/types.h</span>
<span class="p_chunk">@@ -968,6 +968,7 @@</span> <span class="p_context"> struct batadv_tt_global_entry {</span>
  * struct batadv_tt_orig_list_entry - orig node announcing a non-mesh client
  * @orig_node: pointer to orig node announcing this non-mesh client
  * @ttvn: translation table version number which added the non-mesh client
<span class="p_add">+ * @flags: per orig entry TT sync flags</span>
  * @list: list node for batadv_tt_global_entry::orig_list
  * @refcount: number of contexts the object is used
  * @rcu: struct used for freeing in an RCU-safe manner
<span class="p_chunk">@@ -975,6 +976,7 @@</span> <span class="p_context"> struct batadv_tt_global_entry {</span>
 struct batadv_tt_orig_list_entry {
 	struct batadv_orig_node *orig_node;
 	uint8_t ttvn;
<span class="p_add">+	u8 flags;</span>
 	struct hlist_node list;
 	atomic_t refcount;
 	struct rcu_head rcu;
<span class="p_header">diff --git a/net/bridge/br_device.c b/net/bridge/br_device.c</span>
<span class="p_header">index f3526464bded..f6c9fb8e7449 100644</span>
<span class="p_header">--- a/net/bridge/br_device.c</span>
<span class="p_header">+++ b/net/bridge/br_device.c</span>
<span class="p_chunk">@@ -31,10 +31,10 @@</span> <span class="p_context"> static struct lock_class_key bridge_netdev_addr_lock_key;</span>
 netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct net_bridge *br = netdev_priv(dev);
<span class="p_del">-	const unsigned char *dest = skb-&gt;data;</span>
 	struct net_bridge_fdb_entry *dst;
 	struct net_bridge_mdb_entry *mdst;
 	struct pcpu_sw_netstats *brstats = this_cpu_ptr(br-&gt;stats);
<span class="p_add">+	const unsigned char *dest;</span>
 	u16 vid = 0;
 
 	rcu_read_lock();
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"> netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if (!br_allowed_ingress(br, br_get_vlan_info(br), skb, &amp;vid))
 		goto out;
 
<span class="p_add">+	dest = eth_hdr(skb)-&gt;h_dest;</span>
 	if (is_broadcast_ether_addr(dest))
 		br_flood_deliver(br, skb, false);
 	else if (is_multicast_ether_addr(dest)) {
<span class="p_header">diff --git a/net/bridge/br_input.c b/net/bridge/br_input.c</span>
<span class="p_header">index 366c43649079..c0123c31f787 100644</span>
<span class="p_header">--- a/net/bridge/br_input.c</span>
<span class="p_header">+++ b/net/bridge/br_input.c</span>
<span class="p_chunk">@@ -60,11 +60,11 @@</span> <span class="p_context"> static int br_pass_frame_up(struct sk_buff *skb)</span>
 /* note: already called with rcu_read_lock */
 int br_handle_frame_finish(struct sk_buff *skb)
 {
<span class="p_del">-	const unsigned char *dest = eth_hdr(skb)-&gt;h_dest;</span>
 	struct net_bridge_port *p = br_port_get_rcu(skb-&gt;dev);
 	struct net_bridge *br;
 	struct net_bridge_fdb_entry *dst;
 	struct net_bridge_mdb_entry *mdst;
<span class="p_add">+	const unsigned char *dest;</span>
 	struct sk_buff *skb2;
 	bool unicast = true;
 	u16 vid = 0;
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> int br_handle_frame_finish(struct sk_buff *skb)</span>
 	if (p-&gt;flags &amp; BR_LEARNING)
 		br_fdb_update(br, p, eth_hdr(skb)-&gt;h_source, vid, false);
 
<span class="p_add">+	dest = eth_hdr(skb)-&gt;h_dest;</span>
 	if (!is_broadcast_ether_addr(dest) &amp;&amp; is_multicast_ether_addr(dest) &amp;&amp;
 	    br_multicast_rcv(br, p, skb, vid))
 		goto drop;
<span class="p_header">diff --git a/net/bridge/br_netfilter.c b/net/bridge/br_netfilter.c</span>
<span class="p_header">index a615264cf01a..2cf4e30ac41a 100644</span>
<span class="p_header">--- a/net/bridge/br_netfilter.c</span>
<span class="p_header">+++ b/net/bridge/br_netfilter.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> static struct dst_ops fake_dst_ops = {</span>
  * ipt_REJECT needs it.  Future netfilter modules might
  * require us to fill additional fields.
  */
<span class="p_del">-static const u32 br_dst_default_metrics[RTAX_MAX] = {</span>
<span class="p_add">+static const u32 br_dst_default_metrics[RTAX_MAX] __aligned(DST_METRICS_ALIGNMENT) = {</span>
 	[RTAX_MTU - 1] = 1500,
 };
 
<span class="p_header">diff --git a/net/caif/cfpkt_skbuff.c b/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">index 1be0b521ac49..5add8e75759d 100644</span>
<span class="p_header">--- a/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">+++ b/net/caif/cfpkt_skbuff.c</span>
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> int cfpkt_setlen(struct cfpkt *pkt, u16 len)</span>
 		else
 			skb_trim(skb, len);
 
<span class="p_del">-			return cfpkt_getlen(pkt);</span>
<span class="p_add">+		return cfpkt_getlen(pkt);</span>
 	}
 
 	/* Need to expand SKB */
<span class="p_header">diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c</span>
<span class="p_header">index 8e0ed8de3216..6a2236aee1ce 100644</span>
<span class="p_header">--- a/net/ceph/messenger.c</span>
<span class="p_header">+++ b/net/ceph/messenger.c</span>
<span class="p_chunk">@@ -3075,8 +3075,10 @@</span> <span class="p_context"> static struct ceph_msg_data *ceph_msg_data_create(enum ceph_msg_data_type type)</span>
 		return NULL;
 
 	data = kmem_cache_zalloc(ceph_msg_data_cache, GFP_NOFS);
<span class="p_del">-	if (data)</span>
<span class="p_del">-		data-&gt;type = type;</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;type = type;</span>
 	INIT_LIST_HEAD(&amp;data-&gt;links);
 
 	return data;
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 869a04d5558d..ee2177c0b186 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2413,9 +2413,10 @@</span> <span class="p_context"> EXPORT_SYMBOL(skb_mac_gso_segment);</span>
 static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)
 {
 	if (tx_path)
<span class="p_del">-		return skb-&gt;ip_summed != CHECKSUM_PARTIAL;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return skb-&gt;ip_summed == CHECKSUM_NONE;</span>
<span class="p_add">+		return skb-&gt;ip_summed != CHECKSUM_PARTIAL &amp;&amp;</span>
<span class="p_add">+		       skb-&gt;ip_summed != CHECKSUM_UNNECESSARY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skb-&gt;ip_summed == CHECKSUM_NONE;</span>
 }
 
 /**
<span class="p_chunk">@@ -2432,13 +2433,14 @@</span> <span class="p_context"> static inline bool skb_needs_check(struct sk_buff *skb, bool tx_path)</span>
 struct sk_buff *__skb_gso_segment(struct sk_buff *skb,
 				  netdev_features_t features, bool tx_path)
 {
<span class="p_add">+	struct sk_buff *segs;</span>
<span class="p_add">+</span>
 	if (unlikely(skb_needs_check(skb, tx_path))) {
 		int err;
 
<span class="p_del">-		skb_warn_bad_offload(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (skb_header_cloned(skb) &amp;&amp;</span>
<span class="p_del">-		    (err = pskb_expand_head(skb, 0, 0, GFP_ATOMIC)))</span>
<span class="p_add">+		/* We&#39;re going to init -&gt;check field in TCP or UDP header */</span>
<span class="p_add">+		err = skb_cow_head(skb, 0);</span>
<span class="p_add">+		if (err &lt; 0)</span>
 			return ERR_PTR(err);
 	}
 
<span class="p_chunk">@@ -2448,7 +2450,12 @@</span> <span class="p_context"> struct sk_buff *__skb_gso_segment(struct sk_buff *skb,</span>
 	skb_reset_mac_header(skb);
 	skb_reset_mac_len(skb);
 
<span class="p_del">-	return skb_mac_gso_segment(skb, features);</span>
<span class="p_add">+	segs = skb_mac_gso_segment(skb, features);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(skb_needs_check(skb, tx_path)))</span>
<span class="p_add">+		skb_warn_bad_offload(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	return segs;</span>
 }
 EXPORT_SYMBOL(__skb_gso_segment);
 
<span class="p_header">diff --git a/net/core/dst.c b/net/core/dst.c</span>
<span class="p_header">index 57746a18c957..52e900047f89 100644</span>
<span class="p_header">--- a/net/core/dst.c</span>
<span class="p_header">+++ b/net/core/dst.c</span>
<span class="p_chunk">@@ -149,13 +149,13 @@</span> <span class="p_context"> int dst_discard_sk(struct sock *sk, struct sk_buff *skb)</span>
 }
 EXPORT_SYMBOL(dst_discard_sk);
 
<span class="p_del">-const u32 dst_default_metrics[RTAX_MAX + 1] = {</span>
<span class="p_add">+const struct dst_metrics dst_default_metrics = {</span>
 	/* This initializer is needed to force linker to place this variable
 	 * into const section. Otherwise it might end into bss section.
 	 * We really want to avoid false sharing on this variable, and catch
 	 * any writes on it.
 	 */
<span class="p_del">-	[RTAX_MAX] = 0xdeadbeef,</span>
<span class="p_add">+	.refcnt = ATOMIC_INIT(1),</span>
 };
 
 
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> void *dst_alloc(struct dst_ops *ops, struct net_device *dev,</span>
 	if (dev)
 		dev_hold(dev);
 	dst-&gt;ops = ops;
<span class="p_del">-	dst_init_metrics(dst, dst_default_metrics, true);</span>
<span class="p_add">+	dst_init_metrics(dst, dst_default_metrics.metrics, true);</span>
 	dst-&gt;expires = 0UL;
 	dst-&gt;path = dst;
 	dst-&gt;from = NULL;
<span class="p_chunk">@@ -292,27 +292,46 @@</span> <span class="p_context"> void dst_release(struct dst_entry *dst)</span>
 }
 EXPORT_SYMBOL(dst_release);
 
<span class="p_add">+static struct kmem_cache *metrics_cache;</span>
<span class="p_add">+</span>
<span class="p_add">+void *dst_alloc_metrics(gfp_t flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kmem_cache_alloc(metrics_cache, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(dst_alloc_metrics);</span>
<span class="p_add">+</span>
<span class="p_add">+void dst_free_metrics(void *metrics)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kmem_cache_free(metrics_cache, metrics);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(dst_free_metrics);</span>
<span class="p_add">+</span>
 u32 *dst_cow_metrics_generic(struct dst_entry *dst, unsigned long old)
 {
<span class="p_del">-	u32 *p = kmalloc(sizeof(u32) * RTAX_MAX, GFP_ATOMIC);</span>
<span class="p_add">+	struct dst_metrics *p = dst_alloc_metrics(GFP_ATOMIC);</span>
 
 	if (p) {
<span class="p_del">-		u32 *old_p = __DST_METRICS_PTR(old);</span>
<span class="p_add">+		struct dst_metrics *old_p = (struct dst_metrics *)__DST_METRICS_PTR(old);</span>
 		unsigned long prev, new;
 
<span class="p_del">-		memcpy(p, old_p, sizeof(u32) * RTAX_MAX);</span>
<span class="p_add">+		atomic_set(&amp;p-&gt;refcnt, 1);</span>
<span class="p_add">+		memcpy(p-&gt;metrics, old_p-&gt;metrics, sizeof(p-&gt;metrics));</span>
 
 		new = (unsigned long) p;
 		prev = cmpxchg(&amp;dst-&gt;_metrics, old, new);
 
 		if (prev != old) {
<span class="p_del">-			kfree(p);</span>
<span class="p_del">-			p = __DST_METRICS_PTR(prev);</span>
<span class="p_add">+			dst_free_metrics(p);</span>
<span class="p_add">+			p = (struct dst_metrics *)__DST_METRICS_PTR(prev);</span>
 			if (prev &amp; DST_METRICS_READ_ONLY)
 				p = NULL;
<span class="p_add">+		} else if (prev &amp; DST_METRICS_REFCOUNTED) {</span>
<span class="p_add">+			if (atomic_dec_and_test(&amp;old_p-&gt;refcnt))</span>
<span class="p_add">+				dst_free_metrics(old_p);</span>
 		}
 	}
<span class="p_del">-	return p;</span>
<span class="p_add">+	BUILD_BUG_ON(offsetof(struct dst_metrics, metrics) != 0);</span>
<span class="p_add">+	return (u32 *)p;</span>
 }
 EXPORT_SYMBOL(dst_cow_metrics_generic);
 
<span class="p_chunk">@@ -321,10 +340,10 @@</span> <span class="p_context"> void __dst_destroy_metrics_generic(struct dst_entry *dst, unsigned long old)</span>
 {
 	unsigned long prev, new;
 
<span class="p_del">-	new = ((unsigned long) dst_default_metrics) | DST_METRICS_READ_ONLY;</span>
<span class="p_add">+	new = ((unsigned long) &amp;dst_default_metrics) | DST_METRICS_READ_ONLY;</span>
 	prev = cmpxchg(&amp;dst-&gt;_metrics, old, new);
 	if (prev == old)
<span class="p_del">-		kfree(__DST_METRICS_PTR(old));</span>
<span class="p_add">+		dst_free_metrics(__DST_METRICS_PTR(old));</span>
 }
 EXPORT_SYMBOL(__dst_destroy_metrics_generic);
 
<span class="p_chunk">@@ -419,4 +438,8 @@</span> <span class="p_context"> static struct notifier_block dst_dev_notifier = {</span>
 void __init dst_init(void)
 {
 	register_netdevice_notifier(&amp;dst_dev_notifier);
<span class="p_add">+	metrics_cache = kmem_cache_create(&quot;dst_metrics&quot;,</span>
<span class="p_add">+					  sizeof(struct dst_metrics),</span>
<span class="p_add">+					  DST_METRICS_ALIGNMENT,</span>
<span class="p_add">+					  SLAB_PANIC, NULL);</span>
 }
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 0234ae038a62..d585bc9109b4 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -2502,7 +2502,7 @@</span> <span class="p_context"> static void mod_cur_headers(struct pktgen_dev *pkt_dev)</span>
 
 
 #ifdef CONFIG_XFRM
<span class="p_del">-static u32 pktgen_dst_metrics[RTAX_MAX + 1] = {</span>
<span class="p_add">+static u32 pktgen_dst_metrics[RTAX_MAX + 1] __aligned(DST_METRICS_ALIGNMENT) = {</span>
 
 	[RTAX_HOPLIMIT] = 0x5, /* Set a static hoplimit */
 };
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index c232ededeaa2..d04e56fb7be2 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -1175,13 +1175,14 @@</span> <span class="p_context"> static struct pernet_operations fib_net_ops = {</span>
 
 void __init ip_fib_init(void)
 {
<span class="p_del">-	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);</span>
<span class="p_del">-	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);</span>
<span class="p_del">-	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);</span>
<span class="p_add">+	fib_trie_init();</span>
 
 	register_pernet_subsys(&amp;fib_net_ops);
<span class="p_add">+</span>
 	register_netdevice_notifier(&amp;fib_netdev_notifier);
 	register_inetaddr_notifier(&amp;fib_inetaddr_notifier);
 
<span class="p_del">-	fib_trie_init();</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);</span>
 }
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index b77a181cd450..df875ec5c243 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -201,6 +201,7 @@</span> <span class="p_context"> static void rt_fibinfo_free_cpus(struct rtable __rcu * __percpu *rtp)</span>
 static void free_fib_info_rcu(struct rcu_head *head)
 {
 	struct fib_info *fi = container_of(head, struct fib_info, rcu);
<span class="p_add">+	struct dst_metrics *m;</span>
 
 	change_nexthops(fi) {
 		if (nexthop_nh-&gt;nh_dev)
<span class="p_chunk">@@ -212,8 +213,9 @@</span> <span class="p_context"> static void free_fib_info_rcu(struct rcu_head *head)</span>
 	} endfor_nexthops(fi);
 
 	release_net(fi-&gt;fib_net);
<span class="p_del">-	if (fi-&gt;fib_metrics != (u32 *) dst_default_metrics)</span>
<span class="p_del">-		kfree(fi-&gt;fib_metrics);</span>
<span class="p_add">+	m = fi-&gt;fib_metrics;</span>
<span class="p_add">+	if (m != &amp;dst_default_metrics &amp;&amp; atomic_dec_and_test(&amp;m-&gt;refcnt))</span>
<span class="p_add">+		dst_free_metrics(m);</span>
 	kfree(fi);
 }
 
<span class="p_chunk">@@ -821,14 +823,17 @@</span> <span class="p_context"> struct fib_info *fib_create_info(struct fib_config *cfg)</span>
 	fi = kzalloc(sizeof(*fi)+nhs*sizeof(struct fib_nh), GFP_KERNEL);
 	if (fi == NULL)
 		goto failure;
<span class="p_del">-	fib_info_cnt++;</span>
 	if (cfg-&gt;fc_mx) {
<span class="p_del">-		fi-&gt;fib_metrics = kzalloc(sizeof(u32) * RTAX_MAX, GFP_KERNEL);</span>
<span class="p_del">-		if (!fi-&gt;fib_metrics)</span>
<span class="p_del">-			goto failure;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		fi-&gt;fib_metrics = (u32 *) dst_default_metrics;</span>
<span class="p_del">-</span>
<span class="p_add">+		fi-&gt;fib_metrics = dst_alloc_metrics(GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+		if (unlikely(!fi-&gt;fib_metrics)) {</span>
<span class="p_add">+			kfree(fi);</span>
<span class="p_add">+			return ERR_PTR(err);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		atomic_set(&amp;fi-&gt;fib_metrics-&gt;refcnt, 1);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		fi-&gt;fib_metrics = (struct dst_metrics *)&amp;dst_default_metrics;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	fib_info_cnt++;</span>
 	fi-&gt;fib_net = hold_net(net);
 	fi-&gt;fib_protocol = cfg-&gt;fc_protocol;
 	fi-&gt;fib_scope = cfg-&gt;fc_scope;
<span class="p_chunk">@@ -864,7 +869,7 @@</span> <span class="p_context"> struct fib_info *fib_create_info(struct fib_config *cfg)</span>
 					val = 65535 - 15;
 				if (type == RTAX_HOPLIMIT &amp;&amp; val &gt; 255)
 					val = 255;
<span class="p_del">-				fi-&gt;fib_metrics[type - 1] = val;</span>
<span class="p_add">+				fi-&gt;fib_metrics-&gt;metrics[type - 1] = val;</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1029,7 +1034,7 @@</span> <span class="p_context"> int fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,</span>
 	if (fi-&gt;fib_priority &amp;&amp;
 	    nla_put_u32(skb, RTA_PRIORITY, fi-&gt;fib_priority))
 		goto nla_put_failure;
<span class="p_del">-	if (rtnetlink_put_metrics(skb, fi-&gt;fib_metrics) &lt; 0)</span>
<span class="p_add">+	if (rtnetlink_put_metrics(skb, fi-&gt;fib_metrics-&gt;metrics) &lt; 0)</span>
 		goto nla_put_failure;
 
 	if (fi-&gt;fib_prefsrc &amp;&amp;
<span class="p_header">diff --git a/net/ipv4/netfilter/ipt_CLUSTERIP.c b/net/ipv4/netfilter/ipt_CLUSTERIP.c</span>
<span class="p_header">index 2510c02c2d21..0b6a54b9bdeb 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/ipt_CLUSTERIP.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/ipt_CLUSTERIP.c</span>
<span class="p_chunk">@@ -115,7 +115,8 @@</span> <span class="p_context"> clusterip_config_entry_put(struct clusterip_config *c)</span>
 		 * functions are also incrementing the refcount on their own,
 		 * so it&#39;s safe to remove the entry even if it&#39;s in use. */
 #ifdef CONFIG_PROC_FS
<span class="p_del">-		proc_remove(c-&gt;pde);</span>
<span class="p_add">+		if (cn-&gt;procdir)</span>
<span class="p_add">+			proc_remove(c-&gt;pde);</span>
 #endif
 		return;
 	}
<span class="p_chunk">@@ -735,6 +736,7 @@</span> <span class="p_context"> static void clusterip_net_exit(struct net *net)</span>
 #ifdef CONFIG_PROC_FS
 	struct clusterip_net *cn = net_generic(net, clusterip_net_id);
 	proc_remove(cn-&gt;procdir);
<span class="p_add">+	cn-&gt;procdir = NULL;</span>
 #endif
 }
 
<span class="p_header">diff --git a/net/ipv4/netfilter/nft_reject_ipv4.c b/net/ipv4/netfilter/nft_reject_ipv4.c</span>
<span class="p_header">index e79718a382f2..292783018da5 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nft_reject_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nft_reject_ipv4.c</span>
<span class="p_chunk">@@ -33,6 +33,8 @@</span> <span class="p_context"> void nft_reject_ipv4_eval(const struct nft_expr *expr,</span>
 	case NFT_REJECT_TCP_RST:
 		nf_send_reset(pkt-&gt;skb, pkt-&gt;ops-&gt;hooknum);
 		break;
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 
 	data[NFT_REG_VERDICT].verdict = NF_DROP;
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index b8dc5d8cdedf..75b122645188 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -1344,8 +1344,12 @@</span> <span class="p_context"> static void rt_add_uncached_list(struct rtable *rt)</span>
 
 static void ipv4_dst_destroy(struct dst_entry *dst)
 {
<span class="p_add">+	struct dst_metrics *p = (struct dst_metrics *)DST_METRICS_PTR(dst);</span>
 	struct rtable *rt = (struct rtable *) dst;
 
<span class="p_add">+	if (p != &amp;dst_default_metrics &amp;&amp; atomic_dec_and_test(&amp;p-&gt;refcnt))</span>
<span class="p_add">+		dst_free_metrics(p);</span>
<span class="p_add">+</span>
 	if (!list_empty(&amp;rt-&gt;rt_uncached)) {
 		spin_lock_bh(&amp;rt_uncached_lock);
 		list_del(&amp;rt-&gt;rt_uncached);
<span class="p_chunk">@@ -1392,7 +1396,11 @@</span> <span class="p_context"> static void rt_set_nexthop(struct rtable *rt, __be32 daddr,</span>
 			rt-&gt;rt_gateway = nh-&gt;nh_gw;
 			rt-&gt;rt_uses_gateway = 1;
 		}
<span class="p_del">-		dst_init_metrics(&amp;rt-&gt;dst, fi-&gt;fib_metrics, true);</span>
<span class="p_add">+		dst_init_metrics(&amp;rt-&gt;dst, fi-&gt;fib_metrics-&gt;metrics, true);</span>
<span class="p_add">+		if (fi-&gt;fib_metrics != &amp;dst_default_metrics) {</span>
<span class="p_add">+			rt-&gt;dst._metrics |= DST_METRICS_REFCOUNTED;</span>
<span class="p_add">+			atomic_inc(&amp;fi-&gt;fib_metrics-&gt;refcnt);</span>
<span class="p_add">+		}</span>
 #ifdef CONFIG_IP_ROUTE_CLASSID
 		rt-&gt;dst.tclassid = nh-&gt;nh_tclassid;
 #endif
<span class="p_header">diff --git a/net/ipv4/udp_offload.c b/net/ipv4/udp_offload.c</span>
<span class="p_header">index ca41bcbea39c..15659166c8f2 100644</span>
<span class="p_header">--- a/net/ipv4/udp_offload.c</span>
<span class="p_header">+++ b/net/ipv4/udp_offload.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static struct sk_buff *udp4_ufo_fragment(struct sk_buff *skb,</span>
 	csum = skb_checksum(skb, offset, skb-&gt;len - offset, 0);
 	offset += skb-&gt;csum_offset;
 	*(__sum16 *)(skb-&gt;data + offset) = csum_fold(csum);
<span class="p_del">-	skb-&gt;ip_summed = CHECKSUM_NONE;</span>
<span class="p_add">+	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
 
 	/* Fragment the skb. IP headers of the fragments are updated in
 	 * inet_gso_segment()
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 9f48905cac9c..22773519912b 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4737,7 +4737,7 @@</span> <span class="p_context"> static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)</span>
 		 * our DAD process, so we don&#39;t need
 		 * to do it again
 		 */
<span class="p_del">-		if (!(ifp-&gt;rt-&gt;rt6i_node))</span>
<span class="p_add">+		if (!rcu_access_pointer(ifp-&gt;rt-&gt;rt6i_node))</span>
 			ip6_ins_rt(ifp-&gt;rt);
 		if (ifp-&gt;idev-&gt;cnf.forwarding)
 			addrconf_join_anycast(ifp);
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index 36aadaeb7f44..9f6024f0821d 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -151,11 +151,23 @@</span> <span class="p_context"> static __inline__ struct fib6_node *node_alloc(void)</span>
 	return fn;
 }
 
<span class="p_del">-static __inline__ void node_free(struct fib6_node *fn)</span>
<span class="p_add">+static void node_free_immediate(struct fib6_node *fn)</span>
 {
 	kmem_cache_free(fib6_node_kmem, fn);
 }
 
<span class="p_add">+static void node_free_rcu(struct rcu_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fib6_node *fn = container_of(head, struct fib6_node, rcu);</span>
<span class="p_add">+</span>
<span class="p_add">+	kmem_cache_free(fib6_node_kmem, fn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void node_free(struct fib6_node *fn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	call_rcu(&amp;fn-&gt;rcu, node_free_rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __inline__ void rt6_release(struct rt6_info *rt)
 {
 	if (atomic_dec_and_test(&amp;rt-&gt;rt6i_ref))
<span class="p_chunk">@@ -551,9 +563,9 @@</span> <span class="p_context"> static struct fib6_node *fib6_add_1(struct fib6_node *root,</span>
 
 		if (!in || !ln) {
 			if (in)
<span class="p_del">-				node_free(in);</span>
<span class="p_add">+				node_free_immediate(in);</span>
 			if (ln)
<span class="p_del">-				node_free(ln);</span>
<span class="p_add">+				node_free_immediate(ln);</span>
 			return ERR_PTR(-ENOMEM);
 		}
 
<span class="p_chunk">@@ -643,7 +655,7 @@</span> <span class="p_context"> static int fib6_commit_metrics(struct dst_entry *dst,</span>
 	if (dst-&gt;flags &amp; DST_HOST) {
 		mp = dst_metrics_write_ptr(dst);
 	} else {
<span class="p_del">-		mp = kzalloc(sizeof(u32) * RTAX_MAX, GFP_ATOMIC);</span>
<span class="p_add">+		mp = dst_alloc_metrics(GFP_ATOMIC | __GFP_ZERO);</span>
 		if (!mp)
 			return -ENOMEM;
 		dst_init_metrics(dst, mp, 0);
<span class="p_chunk">@@ -824,7 +836,7 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 		}
 		rt-&gt;dst.rt6_next = iter;
 		*ins = rt;
<span class="p_del">-		rt-&gt;rt6i_node = fn;</span>
<span class="p_add">+		rcu_assign_pointer(rt-&gt;rt6i_node, fn);</span>
 		atomic_inc(&amp;rt-&gt;rt6i_ref);
 		inet6_rt_notify(RTM_NEWROUTE, rt, info);
 		info-&gt;nl_net-&gt;ipv6.rt6_stats-&gt;fib_rt_entries++;
<span class="p_chunk">@@ -849,7 +861,7 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 				return err;
 		}
 		*ins = rt;
<span class="p_del">-		rt-&gt;rt6i_node = fn;</span>
<span class="p_add">+		rcu_assign_pointer(rt-&gt;rt6i_node, fn);</span>
 		rt-&gt;dst.rt6_next = iter-&gt;dst.rt6_next;
 		atomic_inc(&amp;rt-&gt;rt6i_ref);
 		inet6_rt_notify(RTM_NEWROUTE, rt, info);
<span class="p_chunk">@@ -859,6 +871,8 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 		}
 		nsiblings = iter-&gt;rt6i_nsiblings;
 		fib6_purge_rt(iter, fn, info-&gt;nl_net);
<span class="p_add">+		if (fn-&gt;rr_ptr == iter)</span>
<span class="p_add">+			fn-&gt;rr_ptr = NULL;</span>
 		rt6_release(iter);
 
 		if (nsiblings) {
<span class="p_chunk">@@ -871,6 +885,8 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 				if (rt6_qualify_for_ecmp(iter)) {
 					*ins = iter-&gt;dst.rt6_next;
 					fib6_purge_rt(iter, fn, info-&gt;nl_net);
<span class="p_add">+					if (fn-&gt;rr_ptr == iter)</span>
<span class="p_add">+						fn-&gt;rr_ptr = NULL;</span>
 					rt6_release(iter);
 					nsiblings--;
 				} else {
<span class="p_chunk">@@ -973,7 +989,7 @@</span> <span class="p_context"> int fib6_add(struct fib6_node *root, struct rt6_info *rt, struct nl_info *info,</span>
 				   root, and then (in st_failure) stale node
 				   in main tree.
 				 */
<span class="p_del">-				node_free(sfn);</span>
<span class="p_add">+				node_free_immediate(sfn);</span>
 				err = PTR_ERR(sn);
 				goto st_failure;
 			}
<span class="p_chunk">@@ -1397,8 +1413,9 @@</span> <span class="p_context"> static void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,</span>
 
 int fib6_del(struct rt6_info *rt, struct nl_info *info)
 {
<span class="p_add">+	struct fib6_node *fn = rcu_dereference_protected(rt-&gt;rt6i_node,</span>
<span class="p_add">+				    lockdep_is_held(&amp;rt-&gt;rt6i_table-&gt;tb6_lock));</span>
 	struct net *net = info-&gt;nl_net;
<span class="p_del">-	struct fib6_node *fn = rt-&gt;rt6i_node;</span>
 	struct rt6_info **rtp;
 
 #if RT6_DEBUG &gt;= 2
<span class="p_chunk">@@ -1577,7 +1594,9 @@</span> <span class="p_context"> static int fib6_clean_node(struct fib6_walker_t *w)</span>
 			if (res) {
 #if RT6_DEBUG &gt;= 2
 				pr_debug(&quot;%s: del failed: rt=%p@%p err=%d\n&quot;,
<span class="p_del">-					 __func__, rt, rt-&gt;rt6i_node, res);</span>
<span class="p_add">+					 __func__, rt,</span>
<span class="p_add">+					 rcu_access_pointer(rt-&gt;rt6i_node),</span>
<span class="p_add">+					 res);</span>
 #endif
 				continue;
 			}
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index c36764006d94..88a2d0ce326e 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ip6_tnl_dst_reset);</span>
 void ip6_tnl_dst_store(struct ip6_tnl *t, struct dst_entry *dst)
 {
 	struct rt6_info *rt = (struct rt6_info *) dst;
<span class="p_del">-	t-&gt;dst_cookie = rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+	t-&gt;dst_cookie = rt6_get_cookie(rt);</span>
 	dst_release(t-&gt;dst_cache);
 	t-&gt;dst_cache = dst;
 }
<span class="p_header">diff --git a/net/ipv6/netfilter/nft_reject_ipv6.c b/net/ipv6/netfilter/nft_reject_ipv6.c</span>
<span class="p_header">index 0bc19fa87821..367bd4841a0c 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/nft_reject_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/nft_reject_ipv6.c</span>
<span class="p_chunk">@@ -34,6 +34,8 @@</span> <span class="p_context"> void nft_reject_ipv6_eval(const struct nft_expr *expr,</span>
 	case NFT_REJECT_TCP_RST:
 		nf_send_reset6(net, pkt-&gt;skb, pkt-&gt;ops-&gt;hooknum);
 		break;
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 
 	data[NFT_REG_VERDICT].verdict = NF_DROP;
<span class="p_header">diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c</span>
<span class="p_header">index 19f9a4a339b5..e32c1ff35f78 100644</span>
<span class="p_header">--- a/net/ipv6/output_core.c</span>
<span class="p_header">+++ b/net/ipv6/output_core.c</span>
<span class="p_chunk">@@ -52,7 +52,6 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 	while (offset &lt;= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
<span class="p_del">-		unsigned int len;</span>
 
 		switch (**nexthdr) {
 
<span class="p_chunk">@@ -78,10 +77,9 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
<span class="p_del">-		len = ipv6_optlen(exthdr);</span>
<span class="p_del">-		if (len + offset &gt;= IPV6_MAXPLEN)</span>
<span class="p_add">+		offset += ipv6_optlen(exthdr);</span>
<span class="p_add">+		if (offset &gt; IPV6_MAXPLEN)</span>
 			return -EINVAL;
<span class="p_del">-		offset += len;</span>
 		*nexthdr = &amp;exthdr-&gt;nexthdr;
 	}
 
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index af2bc34cb81f..d791d769d858 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -247,7 +247,7 @@</span> <span class="p_context"> static struct dst_ops ip6_dst_blackhole_ops = {</span>
 	.neigh_lookup		=	ip6_neigh_lookup,
 };
 
<span class="p_del">-static const u32 ip6_template_metrics[RTAX_MAX] = {</span>
<span class="p_add">+static const u32 ip6_template_metrics[RTAX_MAX] __aligned(DST_METRICS_ALIGNMENT) = {</span>
 	[RTAX_HOPLIMIT - 1] = 0,
 };
 
<span class="p_chunk">@@ -1090,6 +1090,7 @@</span> <span class="p_context"> struct dst_entry *ip6_blackhole_route(struct net *net, struct dst_entry *dst_ori</span>
 static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)
 {
 	struct rt6_info *rt;
<span class="p_add">+	u32 rt_cookie = 0;</span>
 
 	rt = (struct rt6_info *) dst;
 
<span class="p_chunk">@@ -1097,7 +1098,7 @@</span> <span class="p_context"> static struct dst_entry *ip6_dst_check(struct dst_entry *dst, u32 cookie)</span>
 	 * DST_OBSOLETE_FORCE_CHK which forces validation calls down
 	 * into this function always.
 	 */
<span class="p_del">-	if (!rt-&gt;rt6i_node || (rt-&gt;rt6i_node-&gt;fn_sernum != cookie))</span>
<span class="p_add">+	if (!rt6_get_cookie_safe(rt, &amp;rt_cookie) || rt_cookie != cookie)</span>
 		return NULL;
 
 	if (rt6_check_expired(rt))
<span class="p_chunk">@@ -1136,8 +1137,14 @@</span> <span class="p_context"> static void ip6_link_failure(struct sk_buff *skb)</span>
 			dst_hold(&amp;rt-&gt;dst);
 			if (ip6_del_rt(rt))
 				dst_free(&amp;rt-&gt;dst);
<span class="p_del">-		} else if (rt-&gt;rt6i_node &amp;&amp; (rt-&gt;rt6i_flags &amp; RTF_DEFAULT)) {</span>
<span class="p_del">-			rt-&gt;rt6i_node-&gt;fn_sernum = -1;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			struct fib6_node *fn;</span>
<span class="p_add">+</span>
<span class="p_add">+			rcu_read_lock();</span>
<span class="p_add">+			fn = rcu_dereference(rt-&gt;rt6i_node);</span>
<span class="p_add">+			if (fn &amp;&amp; (rt-&gt;rt6i_flags &amp; RTF_DEFAULT))</span>
<span class="p_add">+				fn-&gt;fn_sernum = -1;</span>
<span class="p_add">+			rcu_read_unlock();</span>
 		}
 	}
 }
<span class="p_chunk">@@ -1843,6 +1850,7 @@</span> <span class="p_context"> static void rt6_do_redirect(struct dst_entry *dst, struct sock *sk, struct sk_bu</span>
 	if (on_link)
 		nrt-&gt;rt6i_flags &amp;= ~RTF_GATEWAY;
 
<span class="p_add">+	nrt-&gt;rt6i_protocol = RTPROT_REDIRECT;</span>
 	nrt-&gt;rt6i_gateway = *(struct in6_addr *)neigh-&gt;primary_key;
 
 	if (ip6_ins_rt(nrt))
<span class="p_chunk">@@ -1950,6 +1958,7 @@</span> <span class="p_context"> static struct rt6_info *rt6_add_route_info(struct net *net,</span>
 		.fc_dst_len	= prefixlen,
 		.fc_flags	= RTF_GATEWAY | RTF_ADDRCONF | RTF_ROUTEINFO |
 				  RTF_UP | RTF_PREF(pref),
<span class="p_add">+		.fc_protocol = RTPROT_RA,</span>
 		.fc_nlinfo.portid = 0,
 		.fc_nlinfo.nlh = NULL,
 		.fc_nlinfo.nl_net = net,
<span class="p_chunk">@@ -2000,6 +2009,7 @@</span> <span class="p_context"> struct rt6_info *rt6_add_dflt_router(const struct in6_addr *gwaddr,</span>
 		.fc_ifindex	= dev-&gt;ifindex,
 		.fc_flags	= RTF_GATEWAY | RTF_ADDRCONF | RTF_DEFAULT |
 				  RTF_UP | RTF_EXPIRES | RTF_PREF(pref),
<span class="p_add">+		.fc_protocol = RTPROT_RA,</span>
 		.fc_nlinfo.portid = 0,
 		.fc_nlinfo.nlh = NULL,
 		.fc_nlinfo.nl_net = dev_net(dev),
<span class="p_chunk">@@ -2591,14 +2601,6 @@</span> <span class="p_context"> static int rt6_fill_node(struct net *net,</span>
 	rtm-&gt;rtm_flags = 0;
 	rtm-&gt;rtm_scope = RT_SCOPE_UNIVERSE;
 	rtm-&gt;rtm_protocol = rt-&gt;rt6i_protocol;
<span class="p_del">-	if (rt-&gt;rt6i_flags &amp; RTF_DYNAMIC)</span>
<span class="p_del">-		rtm-&gt;rtm_protocol = RTPROT_REDIRECT;</span>
<span class="p_del">-	else if (rt-&gt;rt6i_flags &amp; RTF_ADDRCONF) {</span>
<span class="p_del">-		if (rt-&gt;rt6i_flags &amp; (RTF_DEFAULT | RTF_ROUTEINFO))</span>
<span class="p_del">-			rtm-&gt;rtm_protocol = RTPROT_RA;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			rtm-&gt;rtm_protocol = RTPROT_KERNEL;</span>
<span class="p_del">-	}</span>
 
 	if (rt-&gt;rt6i_flags &amp; RTF_CACHE)
 		rtm-&gt;rtm_flags |= RTM_F_CLONED;
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 4098243f6589..7d901c77a80e 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -98,8 +98,7 @@</span> <span class="p_context"> static void inet6_sk_rx_dst_set(struct sock *sk, const struct sk_buff *skb)</span>
 	dst_hold(dst);
 	sk-&gt;sk_rx_dst = dst;
 	inet_sk(sk)-&gt;rx_dst_ifindex = skb-&gt;skb_iif;
<span class="p_del">-	if (rt-&gt;rt6i_node)</span>
<span class="p_del">-		inet6_sk(sk)-&gt;rx_dst_cookie = rt-&gt;rt6i_node-&gt;fn_sernum;</span>
<span class="p_add">+	inet6_sk(sk)-&gt;rx_dst_cookie = rt6_get_cookie(rt);</span>
 }
 
 static void tcp_v6_hash(struct sock *sk)
<span class="p_header">diff --git a/net/ipv6/udp_offload.c b/net/ipv6/udp_offload.c</span>
<span class="p_header">index 3dd9891cfa77..fa9ea1a72f99 100644</span>
<span class="p_header">--- a/net/ipv6/udp_offload.c</span>
<span class="p_header">+++ b/net/ipv6/udp_offload.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> static struct sk_buff *udp6_ufo_fragment(struct sk_buff *skb,</span>
 		csum = skb_checksum(skb, offset, skb-&gt;len - offset, 0);
 		offset += skb-&gt;csum_offset;
 		*(__sum16 *)(skb-&gt;data + offset) = csum_fold(csum);
<span class="p_del">-		skb-&gt;ip_summed = CHECKSUM_NONE;</span>
<span class="p_add">+		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
 
 		/* Check if there is enough headroom to insert fragment header. */
 		tnl_hlen = skb_tnl_header_len(skb);
<span class="p_header">diff --git a/net/ipv6/xfrm6_policy.c b/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">index 28af4e66d87a..b7a06749fa11 100644</span>
<span class="p_header">--- a/net/ipv6/xfrm6_policy.c</span>
<span class="p_header">+++ b/net/ipv6/xfrm6_policy.c</span>
<span class="p_chunk">@@ -85,8 +85,7 @@</span> <span class="p_context"> static int xfrm6_init_path(struct xfrm_dst *path, struct dst_entry *dst,</span>
 {
 	if (dst-&gt;ops-&gt;family == AF_INET6) {
 		struct rt6_info *rt = (struct rt6_info*)dst;
<span class="p_del">-		if (rt-&gt;rt6i_node)</span>
<span class="p_del">-			path-&gt;path_cookie = rt-&gt;rt6i_node-&gt;fn_sernum;</span>
<span class="p_add">+		path-&gt;path_cookie = rt6_get_cookie(rt);</span>
 	}
 
 	path-&gt;u.rt6.rt6i_nfheader_len = nfheader_len;
<span class="p_chunk">@@ -116,8 +115,7 @@</span> <span class="p_context"> static int xfrm6_fill_dst(struct xfrm_dst *xdst, struct net_device *dev,</span>
 						   RTF_LOCAL);
 	xdst-&gt;u.rt6.rt6i_metric = rt-&gt;rt6i_metric;
 	xdst-&gt;u.rt6.rt6i_node = rt-&gt;rt6i_node;
<span class="p_del">-	if (rt-&gt;rt6i_node)</span>
<span class="p_del">-		xdst-&gt;route_cookie = rt-&gt;rt6i_node-&gt;fn_sernum;</span>
<span class="p_add">+	xdst-&gt;route_cookie = rt6_get_cookie(rt);</span>
 	xdst-&gt;u.rt6.rt6i_gateway = rt-&gt;rt6i_gateway;
 	xdst-&gt;u.rt6.rt6i_dst = rt-&gt;rt6i_dst;
 	xdst-&gt;u.rt6.rt6i_src = rt-&gt;rt6i_src;
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index eac22fe84c4a..e33e850b5b3f 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -224,7 +224,7 @@</span> <span class="p_context"> static int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,</span>
 #define BROADCAST_ONE		1
 #define BROADCAST_REGISTERED	2
 #define BROADCAST_PROMISC_ONLY	4
<span class="p_del">-static int pfkey_broadcast(struct sk_buff *skb,</span>
<span class="p_add">+static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 			   int broadcast_flags, struct sock *one_sk,
 			   struct net *net)
 {
<span class="p_chunk">@@ -274,7 +274,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb,</span>
 	rcu_read_unlock();
 
 	if (one_sk != NULL)
<span class="p_del">-		err = pfkey_broadcast_one(skb, &amp;skb2, GFP_KERNEL, one_sk);</span>
<span class="p_add">+		err = pfkey_broadcast_one(skb, &amp;skb2, allocation, one_sk);</span>
 
 	kfree_skb(skb2);
 	kfree_skb(skb);
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> static int pfkey_do_dump(struct pfkey_sock *pfk)</span>
 		hdr = (struct sadb_msg *) pfk-&gt;dump.skb-&gt;data;
 		hdr-&gt;sadb_msg_seq = 0;
 		hdr-&gt;sadb_msg_errno = rc;
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 		pfk-&gt;dump.skb = NULL;
 	}
<span class="p_chunk">@@ -351,7 +351,7 @@</span> <span class="p_context"> static int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) /
 			     sizeof(uint64_t));
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1394,7 +1394,7 @@</span> <span class="p_context"> static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_</span>
 
 	xfrm_state_put(x);
 
<span class="p_del">-	pfkey_broadcast(resp_skb, BROADCAST_ONE, sk, net);</span>
<span class="p_add">+	pfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1481,7 +1481,7 @@</span> <span class="p_context"> static int key_notify_sa(struct xfrm_state *x, const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	hdr-&gt;sadb_msg_pid = c-&gt;portid;
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1594,7 +1594,7 @@</span> <span class="p_context"> static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg</span>
 	out_hdr-&gt;sadb_msg_reserved = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1699,8 +1699,8 @@</span> <span class="p_context"> static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad</span>
 		return -ENOBUFS;
 	}
 
<span class="p_del">-	pfkey_broadcast(supp_skb, BROADCAST_REGISTERED, sk, sock_net(sk));</span>
<span class="p_del">-</span>
<span class="p_add">+	pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk,</span>
<span class="p_add">+			sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1718,7 +1718,8 @@</span> <span class="p_context"> static int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)</span>
 	hdr-&gt;sadb_msg_errno = (uint8_t) 0;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk,</span>
<span class="p_add">+			       sock_net(sk));</span>
 }
 
 static int key_notify_sa_flush(const struct km_event *c)
<span class="p_chunk">@@ -1739,7 +1740,7 @@</span> <span class="p_context"> static int key_notify_sa_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1796,7 +1797,7 @@</span> <span class="p_context"> static int dump_sa(struct xfrm_state *x, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_portid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -1884,7 +1885,7 @@</span> <span class="p_context"> static int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 		new_hdr-&gt;sadb_msg_errno = 0;
 	}
 
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2218,7 +2219,7 @@</span> <span class="p_context"> static int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_ev</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	out_hdr-&gt;sadb_msg_pid = c-&gt;portid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ALL, NULL, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2438,7 +2439,7 @@</span> <span class="p_context"> static int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struc</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));</span>
 	err = 0;
 
 out:
<span class="p_chunk">@@ -2692,7 +2693,7 @@</span> <span class="p_context"> static int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_portid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -2749,7 +2750,7 @@</span> <span class="p_context"> static int key_notify_policy_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_satype = SADB_SATYPE_UNSPEC;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
<span class="p_del">-	pfkey_broadcast(skb_out, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2811,7 +2812,7 @@</span> <span class="p_context"> static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 	void *ext_hdrs[SADB_EXT_MAX];
 	int err;
 
<span class="p_del">-	pfkey_broadcast(skb_clone(skb, GFP_KERNEL),</span>
<span class="p_add">+	pfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,</span>
 			BROADCAST_PROMISC_ONLY, NULL, sock_net(sk));
 
 	memset(ext_hdrs, 0, sizeof(ext_hdrs));
<span class="p_chunk">@@ -3033,7 +3034,8 @@</span> <span class="p_context"> static int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)</span>
 	out_hdr-&gt;sadb_msg_seq = 0;
 	out_hdr-&gt;sadb_msg_pid = 0;
 
<span class="p_del">-	pfkey_broadcast(out_skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			xs_net(x));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3223,7 +3225,8 @@</span> <span class="p_context"> static int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct</span>
 		       xfrm_ctx-&gt;ctx_len);
 	}
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			       xs_net(x));</span>
 }
 
 static struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,
<span class="p_chunk">@@ -3421,7 +3424,8 @@</span> <span class="p_context"> static int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,</span>
 	n_port-&gt;sadb_x_nat_t_port_port = sport;
 	n_port-&gt;sadb_x_nat_t_port_reserved = 0;
 
<span class="p_del">-	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL,</span>
<span class="p_add">+			       xs_net(x));</span>
 }
 
 #ifdef CONFIG_NET_KEY_MIGRATE
<span class="p_chunk">@@ -3613,7 +3617,7 @@</span> <span class="p_context"> static int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,</span>
 	}
 
 	/* broadcast migrate message to sockets */
<span class="p_del">-	pfkey_broadcast(skb, BROADCAST_ALL, NULL, &amp;init_net);</span>
<span class="p_add">+	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &amp;init_net);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 384d92ecd26a..45374242d19a 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -112,53 +112,19 @@</span> <span class="p_context"> struct l2tp_net {</span>
 	spinlock_t l2tp_session_hlist_lock;
 };
 
<span class="p_del">-static void l2tp_tunnel_free(struct l2tp_tunnel *tunnel);</span>
 
 static inline struct l2tp_tunnel *l2tp_tunnel(struct sock *sk)
 {
 	return sk-&gt;sk_user_data;
 }
 
<span class="p_del">-static inline struct l2tp_net *l2tp_pernet(struct net *net)</span>
<span class="p_add">+static inline struct l2tp_net *l2tp_pernet(const struct net *net)</span>
 {
 	BUG_ON(!net);
 
 	return net_generic(net, l2tp_net_id);
 }
 
<span class="p_del">-/* Tunnel reference counts. Incremented per session that is added to</span>
<span class="p_del">- * the tunnel.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void l2tp_tunnel_inc_refcount_1(struct l2tp_tunnel *tunnel)</span>
<span class="p_del">-{</span>
<span class="p_del">-	atomic_inc(&amp;tunnel-&gt;ref_count);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void l2tp_tunnel_dec_refcount_1(struct l2tp_tunnel *tunnel)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (atomic_dec_and_test(&amp;tunnel-&gt;ref_count))</span>
<span class="p_del">-		l2tp_tunnel_free(tunnel);</span>
<span class="p_del">-}</span>
<span class="p_del">-#ifdef L2TP_REFCNT_DEBUG</span>
<span class="p_del">-#define l2tp_tunnel_inc_refcount(_t)					\</span>
<span class="p_del">-do {									\</span>
<span class="p_del">-	pr_debug(&quot;l2tp_tunnel_inc_refcount: %s:%d %s: cnt=%d\n&quot;,	\</span>
<span class="p_del">-		 __func__, __LINE__, (_t)-&gt;name,			\</span>
<span class="p_del">-		 atomic_read(&amp;_t-&gt;ref_count));				\</span>
<span class="p_del">-	l2tp_tunnel_inc_refcount_1(_t);					\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-#define l2tp_tunnel_dec_refcount(_t)</span>
<span class="p_del">-do {									\</span>
<span class="p_del">-	pr_debug(&quot;l2tp_tunnel_dec_refcount: %s:%d %s: cnt=%d\n&quot;,	\</span>
<span class="p_del">-		 __func__, __LINE__, (_t)-&gt;name,			\</span>
<span class="p_del">-		 atomic_read(&amp;_t-&gt;ref_count));				\</span>
<span class="p_del">-	l2tp_tunnel_dec_refcount_1(_t);					\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define l2tp_tunnel_inc_refcount(t) l2tp_tunnel_inc_refcount_1(t)</span>
<span class="p_del">-#define l2tp_tunnel_dec_refcount(t) l2tp_tunnel_dec_refcount_1(t)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /* Session hash global list for L2TPv3.
  * The session_id SHOULD be random according to RFC3931, but several
  * L2TP implementations use incrementing session_ids.  So we do a real
<span class="p_chunk">@@ -277,10 +243,31 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunn</span>
 }
 EXPORT_SYMBOL_GPL(l2tp_session_find);
 
<span class="p_add">+/* Lookup a tunnel. A new reference is held on the returned tunnel. */</span>
<span class="p_add">+struct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct l2tp_net *pn = l2tp_pernet(net);</span>
<span class="p_add">+	struct l2tp_tunnel *tunnel;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock_bh();</span>
<span class="p_add">+	list_for_each_entry_rcu(tunnel, &amp;pn-&gt;l2tp_tunnel_list, list) {</span>
<span class="p_add">+		if (tunnel-&gt;tunnel_id == tunnel_id) {</span>
<span class="p_add">+			l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_add">+			rcu_read_unlock_bh();</span>
<span class="p_add">+</span>
<span class="p_add">+			return tunnel;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock_bh();</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(l2tp_tunnel_get);</span>
<span class="p_add">+</span>
 /* Like l2tp_session_find() but takes a reference on the returned session.
  * Optionally calls session-&gt;ref() too if do_ref is true.
  */
<span class="p_del">-struct l2tp_session *l2tp_session_get(struct net *net,</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get(const struct net *net,</span>
 				      struct l2tp_tunnel *tunnel,
 				      u32 session_id, bool do_ref)
 {
<span class="p_chunk">@@ -355,7 +342,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_session_get_nth);</span>
 /* Lookup a session by interface name.
  * This is very inefficient but is only used by management interfaces.
  */
<span class="p_del">-struct l2tp_session *l2tp_session_get_by_ifname(struct net *net, char *ifname,</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,</span>
<span class="p_add">+						const char *ifname,</span>
 						bool do_ref)
 {
 	struct l2tp_net *pn = l2tp_pernet(net);
<span class="p_chunk">@@ -1395,17 +1383,6 @@</span> <span class="p_context"> static void l2tp_udp_encap_destroy(struct sock *sk)</span>
 	}
 }
 
<span class="p_del">-/* Really kill the tunnel.</span>
<span class="p_del">- * Come here only when all sessions have been cleared from the tunnel.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)</span>
<span class="p_del">-{</span>
<span class="p_del">-	BUG_ON(atomic_read(&amp;tunnel-&gt;ref_count) != 0);</span>
<span class="p_del">-	BUG_ON(tunnel-&gt;sock != NULL);</span>
<span class="p_del">-	l2tp_info(tunnel, L2TP_MSG_CONTROL, &quot;%s: free...\n&quot;, tunnel-&gt;name);</span>
<span class="p_del">-	kfree_rcu(tunnel, rcu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Workqueue tunnel deletion function */
 static void l2tp_tunnel_del_work(struct work_struct *work)
 {
<span class="p_chunk">@@ -1929,6 +1906,8 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 
 		l2tp_session_set_header_len(session, tunnel-&gt;version);
 
<span class="p_add">+		l2tp_session_inc_refcount(session);</span>
<span class="p_add">+</span>
 		err = l2tp_session_add_to_tunnel(tunnel, session);
 		if (err) {
 			kfree(session);
<span class="p_chunk">@@ -1936,10 +1915,6 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 			return ERR_PTR(err);
 		}
 
<span class="p_del">-		/* Bump the reference count. The session context is deleted</span>
<span class="p_del">-		 * only when this drops to zero.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		l2tp_session_inc_refcount(session);</span>
 		l2tp_tunnel_inc_refcount(tunnel);
 
 		/* Ensure tunnel socket isn&#39;t deleted */
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index 12b08016a312..2219f9d8d961 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -240,7 +240,9 @@</span> <span class="p_context"> static inline struct l2tp_tunnel *l2tp_sock_to_tunnel(struct sock *sk)</span>
 	return tunnel;
 }
 
<span class="p_del">-struct l2tp_session *l2tp_session_get(struct net *net,</span>
<span class="p_add">+struct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id);</span>
<span class="p_add">+</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get(const struct net *net,</span>
 				      struct l2tp_tunnel *tunnel,
 				      u32 session_id, bool do_ref);
 struct l2tp_session *l2tp_session_find(struct net *net,
<span class="p_chunk">@@ -248,7 +250,8 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_find(struct net *net,</span>
 				       u32 session_id);
 struct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth,
 					  bool do_ref);
<span class="p_del">-struct l2tp_session *l2tp_session_get_by_ifname(struct net *net, char *ifname,</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get_by_ifname(const struct net *net,</span>
<span class="p_add">+						const char *ifname,</span>
 						bool do_ref);
 struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
<span class="p_chunk">@@ -280,6 +283,17 @@</span> <span class="p_context"> int l2tp_nl_register_ops(enum l2tp_pwtype pw_type,</span>
 void l2tp_nl_unregister_ops(enum l2tp_pwtype pw_type);
 int l2tp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 
<span class="p_add">+static inline void l2tp_tunnel_inc_refcount(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_inc(&amp;tunnel-&gt;ref_count);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void l2tp_tunnel_dec_refcount(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;tunnel-&gt;ref_count))</span>
<span class="p_add">+		kfree_rcu(tunnel, rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Session reference counts. Incremented when code obtains a reference
  * to a session.
  */
<span class="p_header">diff --git a/net/l2tp/l2tp_netlink.c b/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">index a492a781ce9e..6727f16afd44 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_netlink.c</span>
<span class="p_chunk">@@ -60,10 +60,12 @@</span> <span class="p_context"> static struct l2tp_session *l2tp_nl_session_get(struct genl_info *info,</span>
 		   (info-&gt;attrs[L2TP_ATTR_CONN_ID])) {
 		tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 		session_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_SESSION_ID]);
<span class="p_del">-		tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-		if (tunnel)</span>
<span class="p_add">+		tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+		if (tunnel) {</span>
 			session = l2tp_session_get(net, tunnel, session_id,
 						   do_ref);
<span class="p_add">+			l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+		}</span>
 	}
 
 	return session;
<span class="p_chunk">@@ -207,14 +209,16 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_delete(struct sk_buff *skb, struct genl_info *info</span>
 	}
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+	if (!tunnel) {</span>
 		ret = -ENODEV;
 		goto out;
 	}
 
 	(void) l2tp_tunnel_delete(tunnel);
 
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+</span>
 out:
 	return ret;
 }
<span class="p_chunk">@@ -232,8 +236,8 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_modify(struct sk_buff *skb, struct genl_info *info</span>
 	}
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+	if (!tunnel) {</span>
 		ret = -ENODEV;
 		goto out;
 	}
<span class="p_chunk">@@ -241,6 +245,8 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_modify(struct sk_buff *skb, struct genl_info *info</span>
 	if (info-&gt;attrs[L2TP_ATTR_DEBUG])
 		tunnel-&gt;debug = nla_get_u32(info-&gt;attrs[L2TP_ATTR_DEBUG]);
 
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+</span>
 out:
 	return ret;
 }
<span class="p_chunk">@@ -343,34 +349,37 @@</span> <span class="p_context"> static int l2tp_nl_cmd_tunnel_get(struct sk_buff *skb, struct genl_info *info)</span>
 
 	if (!info-&gt;attrs[L2TP_ATTR_CONN_ID]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_del">-		ret = -ENODEV;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!msg) {
 		ret = -ENOMEM;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
<span class="p_add">+	if (!tunnel) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto err_nlmsg;</span>
 	}
 
 	ret = l2tp_nl_tunnel_send(msg, info-&gt;snd_portid, info-&gt;snd_seq,
 				  NLM_F_ACK, tunnel);
 	if (ret &lt; 0)
<span class="p_del">-		goto err_out;</span>
<span class="p_add">+		goto err_nlmsg_tunnel;</span>
<span class="p_add">+</span>
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
 
 	return genlmsg_unicast(net, msg, info-&gt;snd_portid);
 
<span class="p_del">-err_out:</span>
<span class="p_add">+err_nlmsg_tunnel:</span>
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+err_nlmsg:</span>
 	nlmsg_free(msg);
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_add">+err:</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -406,7 +415,6 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 	u32 peer_session_id;
 	int ret = 0;
 	struct l2tp_tunnel *tunnel;
<span class="p_del">-	struct l2tp_session *session;</span>
 	struct l2tp_session_cfg cfg = { 0, };
 	struct net *net = genl_info_net(info);
 
<span class="p_chunk">@@ -414,8 +422,9 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_add">+</span>
 	tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_add">+	tunnel = l2tp_tunnel_get(net, tunnel_id);</span>
 	if (!tunnel) {
 		ret = -ENODEV;
 		goto out;
<span class="p_chunk">@@ -423,29 +432,24 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 
 	if (!info-&gt;attrs[L2TP_ATTR_SESSION_ID]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 	session_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_SESSION_ID]);
<span class="p_del">-	session = l2tp_session_find(net, tunnel, session_id);</span>
<span class="p_del">-	if (session) {</span>
<span class="p_del">-		ret = -EEXIST;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
 
 	if (!info-&gt;attrs[L2TP_ATTR_PEER_SESSION_ID]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 	peer_session_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_PEER_SESSION_ID]);
 
 	if (!info-&gt;attrs[L2TP_ATTR_PW_TYPE]) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 	cfg.pw_type = nla_get_u16(info-&gt;attrs[L2TP_ATTR_PW_TYPE]);
 	if (cfg.pw_type &gt;= __L2TP_PWTYPE_MAX) {
 		ret = -EINVAL;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 
 	if (tunnel-&gt;version &gt; 2) {
<span class="p_chunk">@@ -467,7 +471,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 			u16 len = nla_len(info-&gt;attrs[L2TP_ATTR_COOKIE]);
 			if (len &gt; 8) {
 				ret = -EINVAL;
<span class="p_del">-				goto out;</span>
<span class="p_add">+				goto out_tunnel;</span>
 			}
 			cfg.cookie_len = len;
 			memcpy(&amp;cfg.cookie[0], nla_data(info-&gt;attrs[L2TP_ATTR_COOKIE]), len);
<span class="p_chunk">@@ -476,7 +480,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 			u16 len = nla_len(info-&gt;attrs[L2TP_ATTR_PEER_COOKIE]);
 			if (len &gt; 8) {
 				ret = -EINVAL;
<span class="p_del">-				goto out;</span>
<span class="p_add">+				goto out_tunnel;</span>
 			}
 			cfg.peer_cookie_len = len;
 			memcpy(&amp;cfg.peer_cookie[0], nla_data(info-&gt;attrs[L2TP_ATTR_PEER_COOKIE]), len);
<span class="p_chunk">@@ -512,7 +516,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 	if ((l2tp_nl_cmd_ops[cfg.pw_type] == NULL) ||
 	    (l2tp_nl_cmd_ops[cfg.pw_type]-&gt;session_create == NULL)) {
 		ret = -EPROTONOSUPPORT;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_tunnel;</span>
 	}
 
 	/* Check that pseudowire-specific params are present */
<span class="p_chunk">@@ -522,7 +526,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 	case L2TP_PWTYPE_ETH_VLAN:
 		if (!info-&gt;attrs[L2TP_ATTR_VLAN_ID]) {
 			ret = -EINVAL;
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto out_tunnel;</span>
 		}
 		break;
 	case L2TP_PWTYPE_ETH:
<span class="p_chunk">@@ -541,6 +545,8 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 		ret = (*l2tp_nl_cmd_ops[cfg.pw_type]-&gt;session_create)(net, tunnel_id,
 			session_id, peer_session_id, &amp;cfg);
 
<span class="p_add">+out_tunnel:</span>
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
 out:
 	return ret;
 }
<span class="p_header">diff --git a/net/mac80211/key.c b/net/mac80211/key.c</span>
<span class="p_header">index 947daa9d3346..398cc91aff65 100644</span>
<span class="p_header">--- a/net/mac80211/key.c</span>
<span class="p_header">+++ b/net/mac80211/key.c</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
  * Copyright 2005-2006, Devicescape Software, Inc.
  * Copyright 2006-2007	Jiri Benc &lt;jbenc@suse.cz&gt;
  * Copyright 2007-2008	Johannes Berg &lt;johannes@sipsolutions.net&gt;
<span class="p_add">+ * Copyright 2017	Intel Deutschland GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
<span class="p_chunk">@@ -487,9 +488,6 @@</span> <span class="p_context"> int ieee80211_key_link(struct ieee80211_key *key,</span>
 
 	pairwise = key-&gt;conf.flags &amp; IEEE80211_KEY_FLAG_PAIRWISE;
 	idx = key-&gt;conf.keyidx;
<span class="p_del">-	key-&gt;local = sdata-&gt;local;</span>
<span class="p_del">-	key-&gt;sdata = sdata;</span>
<span class="p_del">-	key-&gt;sta = sta;</span>
 
 	mutex_lock(&amp;sdata-&gt;local-&gt;key_mtx);
 
<span class="p_chunk">@@ -500,6 +498,21 @@</span> <span class="p_context"> int ieee80211_key_link(struct ieee80211_key *key,</span>
 	else
 		old_key = key_mtx_dereference(sdata-&gt;local, sdata-&gt;keys[idx]);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Silently accept key re-installation without really installing the</span>
<span class="p_add">+	 * new version of the key to avoid nonce reuse or replay issues.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (old_key &amp;&amp; key-&gt;conf.keylen == old_key-&gt;conf.keylen &amp;&amp;</span>
<span class="p_add">+	    !memcmp(key-&gt;conf.key, old_key-&gt;conf.key, key-&gt;conf.keylen)) {</span>
<span class="p_add">+		ieee80211_key_free_unused(key);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	key-&gt;local = sdata-&gt;local;</span>
<span class="p_add">+	key-&gt;sdata = sdata;</span>
<span class="p_add">+	key-&gt;sta = sta;</span>
<span class="p_add">+</span>
 	increment_tailroom_need_count(sdata);
 
 	ieee80211_key_replace(sdata, sta, pairwise, old_key, key);
<span class="p_chunk">@@ -515,6 +528,7 @@</span> <span class="p_context"> int ieee80211_key_link(struct ieee80211_key *key,</span>
 		ret = 0;
 	}
 
<span class="p_add">+ out:</span>
 	mutex_unlock(&amp;sdata-&gt;local-&gt;key_mtx);
 
 	return ret;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_xmit.c b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">index 180f7624bcd4..7abd786d9d89 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_xmit.c</span>
<span class="p_chunk">@@ -373,7 +373,7 @@</span> <span class="p_context"> __ip_vs_get_out_rt_v6(struct sk_buff *skb, struct ip_vs_dest *dest,</span>
 				goto err_unreach;
 			}
 			rt = (struct rt6_info *) dst;
<span class="p_del">-			cookie = rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+			cookie = rt6_get_cookie(rt);</span>
 			__ip_vs_dst_set(dest, dest_dst, &amp;rt-&gt;dst, cookie);
 			spin_unlock_bh(&amp;dest-&gt;dst_lock);
 			IP_VS_DBG(10, &quot;new dst %pI6, src %pI6, refcnt=%d\n&quot;,
<span class="p_header">diff --git a/net/netfilter/nft_compat.c b/net/netfilter/nft_compat.c</span>
<span class="p_header">index 62097fda49dc..55be1e0a4a7f 100644</span>
<span class="p_header">--- a/net/netfilter/nft_compat.c</span>
<span class="p_header">+++ b/net/netfilter/nft_compat.c</span>
<span class="p_chunk">@@ -295,11 +295,11 @@</span> <span class="p_context"> static void nft_match_eval(const struct nft_expr *expr,</span>
 		return;
 	}
 
<span class="p_del">-	switch(ret) {</span>
<span class="p_del">-	case true:</span>
<span class="p_add">+	switch (ret ? 1 : 0) {</span>
<span class="p_add">+	case 1:</span>
 		data[NFT_REG_VERDICT].verdict = NFT_CONTINUE;
 		break;
<span class="p_del">-	case false:</span>
<span class="p_add">+	case 0:</span>
 		data[NFT_REG_VERDICT].verdict = NFT_BREAK;
 		break;
 	}
<span class="p_header">diff --git a/net/netfilter/nft_ct.c b/net/netfilter/nft_ct.c</span>
<span class="p_header">index cc5603016242..18d520e0ca0a 100644</span>
<span class="p_header">--- a/net/netfilter/nft_ct.c</span>
<span class="p_header">+++ b/net/netfilter/nft_ct.c</span>
<span class="p_chunk">@@ -56,6 +56,8 @@</span> <span class="p_context"> static void nft_ct_get_eval(const struct nft_expr *expr,</span>
 			state = NF_CT_STATE_BIT(ctinfo);
 		dest-&gt;data[0] = state;
 		return;
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 
 	if (ct == NULL)
<span class="p_chunk">@@ -117,6 +119,8 @@</span> <span class="p_context"> static void nft_ct_get_eval(const struct nft_expr *expr,</span>
 		return;
 	}
 #endif
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 
 	tuple = &amp;ct-&gt;tuplehash[priv-&gt;dir].tuple;
<span class="p_chunk">@@ -141,6 +145,8 @@</span> <span class="p_context"> static void nft_ct_get_eval(const struct nft_expr *expr,</span>
 	case NFT_CT_PROTO_DST:
 		dest-&gt;data[0] = (__force __u16)tuple-&gt;dst.u.all;
 		return;
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 	return;
 err:
<span class="p_chunk">@@ -172,6 +178,8 @@</span> <span class="p_context"> static void nft_ct_set_eval(const struct nft_expr *expr,</span>
 		}
 		break;
 #endif
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 }
 
<span class="p_header">diff --git a/net/netfilter/nft_reject.c b/net/netfilter/nft_reject.c</span>
<span class="p_header">index f3448c296446..5d5d1df34f77 100644</span>
<span class="p_header">--- a/net/netfilter/nft_reject.c</span>
<span class="p_header">+++ b/net/netfilter/nft_reject.c</span>
<span class="p_chunk">@@ -61,6 +61,8 @@</span> <span class="p_context"> int nft_reject_dump(struct sk_buff *skb, const struct nft_expr *expr)</span>
 		if (nla_put_u8(skb, NFTA_REJECT_ICMP_CODE, priv-&gt;icmp_code))
 			goto nla_put_failure;
 		break;
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index d798c2fcd114..f5bf29c033bd 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -214,6 +214,7 @@</span> <span class="p_context"> static void prb_clear_rxhash(struct tpacket_kbdq_core *,</span>
 static void prb_fill_vlan_info(struct tpacket_kbdq_core *,
 		struct tpacket3_hdr *);
 static void packet_flush_mclist(struct sock *sk);
<span class="p_add">+static void packet_pick_tx_queue(struct net_device *dev, struct sk_buff *skb);</span>
 
 struct packet_skb_cb {
 	unsigned int origlen;
<span class="p_chunk">@@ -266,6 +267,7 @@</span> <span class="p_context"> static int packet_direct_xmit(struct sk_buff *skb)</span>
 			goto drop;
 	}
 
<span class="p_add">+	packet_pick_tx_queue(dev, skb);</span>
 	queue_map = skb_get_queue_mapping(skb);
 	txq = netdev_get_tx_queue(dev, queue_map);
 
<span class="p_chunk">@@ -1457,10 +1459,6 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 
 	mutex_lock(&amp;fanout_mutex);
 
<span class="p_del">-	err = -EINVAL;</span>
<span class="p_del">-	if (!po-&gt;running)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	err = -EALREADY;
 	if (po-&gt;fanout)
 		goto out;
<span class="p_chunk">@@ -1497,7 +1495,10 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 		list_add(&amp;match-&gt;list, &amp;fanout_list);
 	}
 	err = -EINVAL;
<span class="p_del">-	if (match-&gt;type == type &amp;&amp;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;po-&gt;bind_lock);</span>
<span class="p_add">+	if (po-&gt;running &amp;&amp;</span>
<span class="p_add">+	    match-&gt;type == type &amp;&amp;</span>
 	    match-&gt;prot_hook.type == po-&gt;prot_hook.type &amp;&amp;
 	    match-&gt;prot_hook.dev == po-&gt;prot_hook.dev) {
 		err = -ENOSPC;
<span class="p_chunk">@@ -1509,6 +1510,13 @@</span> <span class="p_context"> static int fanout_add(struct sock *sk, u16 id, u16 type_flags)</span>
 			err = 0;
 		}
 	}
<span class="p_add">+	spin_unlock(&amp;po-&gt;bind_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err &amp;&amp; !atomic_read(&amp;match-&gt;sk_ref)) {</span>
<span class="p_add">+		list_del(&amp;match-&gt;list);</span>
<span class="p_add">+		kfree(match);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 out:
 	mutex_unlock(&amp;fanout_mutex);
 	return err;
<span class="p_chunk">@@ -2343,8 +2351,6 @@</span> <span class="p_context"> static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)</span>
 			}
 		}
 
<span class="p_del">-		packet_pick_tx_queue(dev, skb);</span>
<span class="p_del">-</span>
 		skb-&gt;destructor = tpacket_destruct_skb;
 		__packet_set_status(po, ph, TP_STATUS_SENDING);
 		packet_inc_pending(&amp;po-&gt;tx_ring);
<span class="p_chunk">@@ -2551,8 +2557,6 @@</span> <span class="p_context"> static int packet_snd(struct socket *sock, struct msghdr *msg, size_t len)</span>
 	skb-&gt;priority = sk-&gt;sk_priority;
 	skb-&gt;mark = sk-&gt;sk_mark;
 
<span class="p_del">-	packet_pick_tx_queue(dev, skb);</span>
<span class="p_del">-</span>
 	if (po-&gt;has_vnet_hdr) {
 		if (vnet_hdr.flags &amp; VIRTIO_NET_HDR_F_NEEDS_CSUM) {
 			if (!skb_partial_csum_set(skb, vnet_hdr.csum_start,
<span class="p_chunk">@@ -2692,13 +2696,15 @@</span> <span class="p_context"> static int packet_do_bind(struct sock *sk, const char *name, int ifindex,</span>
 	int ret = 0;
 	bool unlisted = false;
 
<span class="p_del">-	if (po-&gt;fanout)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	lock_sock(sk);
 	spin_lock(&amp;po-&gt;bind_lock);
 	rcu_read_lock();
 
<span class="p_add">+	if (po-&gt;fanout) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (name) {
 		dev = dev_get_by_name_rcu(sock_net(sk), name);
 		if (!dev) {
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index 8b7e7e25bd72..2403a7b126f6 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -978,6 +978,8 @@</span> <span class="p_context"> qdisc_create(struct net_device *dev, struct netdev_queue *dev_queue,</span>
 
 		return sch;
 	}
<span class="p_add">+	/* ops-&gt;init() failed, we call -&gt;destroy() like qdisc_create_dflt() */</span>
<span class="p_add">+	ops-&gt;destroy(sch);</span>
 err_out3:
 	dev_put(dev);
 	kfree((char *) sch - sch-&gt;padded);
<span class="p_header">diff --git a/net/sched/sch_cbq.c b/net/sched/sch_cbq.c</span>
<span class="p_header">index fc0ea5c63521..56d1262d8593 100644</span>
<span class="p_header">--- a/net/sched/sch_cbq.c</span>
<span class="p_header">+++ b/net/sched/sch_cbq.c</span>
<span class="p_chunk">@@ -1364,6 +1364,13 @@</span> <span class="p_context"> static int cbq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct tc_ratespec *r;
 	int err;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+	hrtimer_init(&amp;q-&gt;delay_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS_PINNED);</span>
<span class="p_add">+	q-&gt;delay_timer.function = cbq_undelay;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!opt)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	err = nla_parse_nested(tb, TCA_CBQ_MAX, opt, cbq_policy);
 	if (err &lt; 0)
 		return err;
<span class="p_chunk">@@ -1402,9 +1409,6 @@</span> <span class="p_context"> static int cbq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	q-&gt;link.avpkt = q-&gt;link.allot/2;
 	q-&gt;link.minidle = -0x7FFFFFFF;
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-	hrtimer_init(&amp;q-&gt;delay_timer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);</span>
<span class="p_del">-	q-&gt;delay_timer.function = cbq_undelay;</span>
 	q-&gt;toplevel = TC_CBQ_MAXLEVEL;
 	q-&gt;now = psched_get_time();
 	q-&gt;now_rt = q-&gt;now;
<span class="p_header">diff --git a/net/sched/sch_fq_codel.c b/net/sched/sch_fq_codel.c</span>
<span class="p_header">index 633be4b72e20..3de2fd89e7fe 100644</span>
<span class="p_header">--- a/net/sched/sch_fq_codel.c</span>
<span class="p_header">+++ b/net/sched/sch_fq_codel.c</span>
<span class="p_chunk">@@ -411,10 +411,8 @@</span> <span class="p_context"> static int fq_codel_init(struct Qdisc *sch, struct nlattr *opt)</span>
 		if (!q-&gt;flows)
 			return -ENOMEM;
 		q-&gt;backlogs = fq_codel_zalloc(q-&gt;flows_cnt * sizeof(u32));
<span class="p_del">-		if (!q-&gt;backlogs) {</span>
<span class="p_del">-			fq_codel_free(q-&gt;flows);</span>
<span class="p_add">+		if (!q-&gt;backlogs)</span>
 			return -ENOMEM;
<span class="p_del">-		}</span>
 		for (i = 0; i &lt; q-&gt;flows_cnt; i++) {
 			struct fq_codel_flow *flow = q-&gt;flows + i;
 
<span class="p_header">diff --git a/net/sched/sch_hfsc.c b/net/sched/sch_hfsc.c</span>
<span class="p_header">index 90bc6e56f112..4cbcf532e55b 100644</span>
<span class="p_header">--- a/net/sched/sch_hfsc.c</span>
<span class="p_header">+++ b/net/sched/sch_hfsc.c</span>
<span class="p_chunk">@@ -1432,6 +1432,8 @@</span> <span class="p_context"> hfsc_init_qdisc(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct tc_hfsc_qopt *qopt;
 	int err;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+</span>
 	if (opt == NULL || nla_len(opt) &lt; sizeof(*qopt))
 		return -EINVAL;
 	qopt = nla_data(opt);
<span class="p_chunk">@@ -1457,8 +1459,6 @@</span> <span class="p_context"> hfsc_init_qdisc(struct Qdisc *sch, struct nlattr *opt)</span>
 	qdisc_class_hash_insert(&amp;q-&gt;clhash, &amp;q-&gt;root.cl_common);
 	qdisc_class_hash_grow(sch, &amp;q-&gt;clhash);
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/sched/sch_hhf.c b/net/sched/sch_hhf.c</span>
<span class="p_header">index cdc1836810c2..33cf9e5ae352 100644</span>
<span class="p_header">--- a/net/sched/sch_hhf.c</span>
<span class="p_header">+++ b/net/sched/sch_hhf.c</span>
<span class="p_chunk">@@ -509,6 +509,9 @@</span> <span class="p_context"> static void hhf_destroy(struct Qdisc *sch)</span>
 		hhf_free(q-&gt;hhf_valid_bits[i]);
 	}
 
<span class="p_add">+	if (!q-&gt;hh_flows)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; HH_FLOWS_CNT; i++) {
 		struct hh_flow_state *flow, *next;
 		struct list_head *head = &amp;q-&gt;hh_flows[i];
<span class="p_chunk">@@ -644,7 +647,9 @@</span> <span class="p_context"> static int hhf_init(struct Qdisc *sch, struct nlattr *opt)</span>
 			q-&gt;hhf_arrays[i] = hhf_zalloc(HHF_ARRAYS_LEN *
 						      sizeof(u32));
 			if (!q-&gt;hhf_arrays[i]) {
<span class="p_del">-				hhf_destroy(sch);</span>
<span class="p_add">+				/* Note: hhf_destroy() will be called</span>
<span class="p_add">+				 * by our caller.</span>
<span class="p_add">+				 */</span>
 				return -ENOMEM;
 			}
 		}
<span class="p_chunk">@@ -655,7 +660,9 @@</span> <span class="p_context"> static int hhf_init(struct Qdisc *sch, struct nlattr *opt)</span>
 			q-&gt;hhf_valid_bits[i] = hhf_zalloc(HHF_ARRAYS_LEN /
 							  BITS_PER_BYTE);
 			if (!q-&gt;hhf_valid_bits[i]) {
<span class="p_del">-				hhf_destroy(sch);</span>
<span class="p_add">+				/* Note: hhf_destroy() will be called</span>
<span class="p_add">+				 * by our caller.</span>
<span class="p_add">+				 */</span>
 				return -ENOMEM;
 			}
 		}
<span class="p_header">diff --git a/net/sched/sch_htb.c b/net/sched/sch_htb.c</span>
<span class="p_header">index b169a8a05a5d..ac0e30dd1ed9 100644</span>
<span class="p_header">--- a/net/sched/sch_htb.c</span>
<span class="p_header">+++ b/net/sched/sch_htb.c</span>
<span class="p_chunk">@@ -1025,6 +1025,9 @@</span> <span class="p_context"> static int htb_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	int err;
 	int i;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+	INIT_WORK(&amp;q-&gt;work, htb_work_func);</span>
<span class="p_add">+</span>
 	if (!opt)
 		return -EINVAL;
 
<span class="p_chunk">@@ -1045,8 +1048,6 @@</span> <span class="p_context"> static int htb_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	for (i = 0; i &lt; TC_HTB_NUMPRIO; i++)
 		INIT_LIST_HEAD(q-&gt;drops + i);
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-	INIT_WORK(&amp;q-&gt;work, htb_work_func);</span>
 	skb_queue_head_init(&amp;q-&gt;direct_queue);
 
 	if (tb[TCA_HTB_DIRECT_QLEN])
<span class="p_header">diff --git a/net/sched/sch_mq.c b/net/sched/sch_mq.c</span>
<span class="p_header">index a8b2864a696b..0c6db36b6a82 100644</span>
<span class="p_header">--- a/net/sched/sch_mq.c</span>
<span class="p_header">+++ b/net/sched/sch_mq.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> static int mq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	/* pre-allocate qdiscs, attachment can&#39;t fail */
 	priv-&gt;qdiscs = kcalloc(dev-&gt;num_tx_queues, sizeof(priv-&gt;qdiscs[0]),
 			       GFP_KERNEL);
<span class="p_del">-	if (priv-&gt;qdiscs == NULL)</span>
<span class="p_add">+	if (!priv-&gt;qdiscs)</span>
 		return -ENOMEM;
 
 	for (ntx = 0; ntx &lt; dev-&gt;num_tx_queues; ntx++) {
<span class="p_chunk">@@ -60,18 +60,14 @@</span> <span class="p_context"> static int mq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
 					  TC_H_MAKE(TC_H_MAJ(sch-&gt;handle),
 						    TC_H_MIN(ntx + 1)));
<span class="p_del">-		if (qdisc == NULL)</span>
<span class="p_del">-			goto err;</span>
<span class="p_add">+		if (!qdisc)</span>
<span class="p_add">+			return -ENOMEM;</span>
 		priv-&gt;qdiscs[ntx] = qdisc;
 		qdisc-&gt;flags |= TCQ_F_ONETXQUEUE;
 	}
 
 	sch-&gt;flags |= TCQ_F_MQROOT;
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_del">-	mq_destroy(sch);</span>
<span class="p_del">-	return -ENOMEM;</span>
 }
 
 static void mq_attach(struct Qdisc *sch)
<span class="p_header">diff --git a/net/sched/sch_mqprio.c b/net/sched/sch_mqprio.c</span>
<span class="p_header">index 6749e2f540d0..626170d568ce 100644</span>
<span class="p_header">--- a/net/sched/sch_mqprio.c</span>
<span class="p_header">+++ b/net/sched/sch_mqprio.c</span>
<span class="p_chunk">@@ -117,20 +117,17 @@</span> <span class="p_context"> static int mqprio_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	/* pre-allocate qdisc, attachment can&#39;t fail */
 	priv-&gt;qdiscs = kcalloc(dev-&gt;num_tx_queues, sizeof(priv-&gt;qdiscs[0]),
 			       GFP_KERNEL);
<span class="p_del">-	if (priv-&gt;qdiscs == NULL) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!priv-&gt;qdiscs)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	for (i = 0; i &lt; dev-&gt;num_tx_queues; i++) {
 		dev_queue = netdev_get_tx_queue(dev, i);
 		qdisc = qdisc_create_dflt(dev_queue, default_qdisc_ops,
 					  TC_H_MAKE(TC_H_MAJ(sch-&gt;handle),
 						    TC_H_MIN(i + 1)));
<span class="p_del">-		if (qdisc == NULL) {</span>
<span class="p_del">-			err = -ENOMEM;</span>
<span class="p_del">-			goto err;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!qdisc)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
 		priv-&gt;qdiscs[i] = qdisc;
 		qdisc-&gt;flags |= TCQ_F_ONETXQUEUE;
 	}
<span class="p_chunk">@@ -143,7 +140,7 @@</span> <span class="p_context"> static int mqprio_init(struct Qdisc *sch, struct nlattr *opt)</span>
 		priv-&gt;hw_owned = 1;
 		err = dev-&gt;netdev_ops-&gt;ndo_setup_tc(dev, qopt-&gt;num_tc);
 		if (err)
<span class="p_del">-			goto err;</span>
<span class="p_add">+			return err;</span>
 	} else {
 		netdev_set_num_tc(dev, qopt-&gt;num_tc);
 		for (i = 0; i &lt; qopt-&gt;num_tc; i++)
<span class="p_chunk">@@ -157,10 +154,6 @@</span> <span class="p_context"> static int mqprio_init(struct Qdisc *sch, struct nlattr *opt)</span>
 
 	sch-&gt;flags |= TCQ_F_MQROOT;
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_del">-	mqprio_destroy(sch);</span>
<span class="p_del">-	return err;</span>
 }
 
 static void mqprio_attach(struct Qdisc *sch)
<span class="p_header">diff --git a/net/sched/sch_multiq.c b/net/sched/sch_multiq.c</span>
<span class="p_header">index 946392276385..e70f51863e01 100644</span>
<span class="p_header">--- a/net/sched/sch_multiq.c</span>
<span class="p_header">+++ b/net/sched/sch_multiq.c</span>
<span class="p_chunk">@@ -253,7 +253,7 @@</span> <span class="p_context"> static int multiq_tune(struct Qdisc *sch, struct nlattr *opt)</span>
 static int multiq_init(struct Qdisc *sch, struct nlattr *opt)
 {
 	struct multiq_sched_data *q = qdisc_priv(sch);
<span class="p_del">-	int i, err;</span>
<span class="p_add">+	int i;</span>
 
 	q-&gt;queues = NULL;
 
<span class="p_chunk">@@ -268,12 +268,7 @@</span> <span class="p_context"> static int multiq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	for (i = 0; i &lt; q-&gt;max_bands; i++)
 		q-&gt;queues[i] = &amp;noop_qdisc;
 
<span class="p_del">-	err = multiq_tune(sch, opt);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		kfree(q-&gt;queues);</span>
<span class="p_del">-</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return multiq_tune(sch, opt);</span>
 }
 
 static int multiq_dump(struct Qdisc *sch, struct sk_buff *skb)
<span class="p_header">diff --git a/net/sched/sch_netem.c b/net/sched/sch_netem.c</span>
<span class="p_header">index aa9e07816feb..cbf402451c20 100644</span>
<span class="p_header">--- a/net/sched/sch_netem.c</span>
<span class="p_header">+++ b/net/sched/sch_netem.c</span>
<span class="p_chunk">@@ -956,11 +956,11 @@</span> <span class="p_context"> static int netem_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	struct netem_sched_data *q = qdisc_priv(sch);
 	int ret;
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+</span>
 	if (!opt)
 		return -EINVAL;
 
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-</span>
 	q-&gt;loss_model = CLG_RANDOM;
 	ret = netem_change(sch, opt);
 	if (ret)
<span class="p_header">diff --git a/net/sched/sch_sfq.c b/net/sched/sch_sfq.c</span>
<span class="p_header">index 78a5d7d43634..baebaaa995c1 100644</span>
<span class="p_header">--- a/net/sched/sch_sfq.c</span>
<span class="p_header">+++ b/net/sched/sch_sfq.c</span>
<span class="p_chunk">@@ -460,6 +460,7 @@</span> <span class="p_context"> sfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 		qdisc_drop(head, sch);
 
 		slot_queue_add(slot, skb);
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, 0, delta);</span>
 		return NET_XMIT_CN;
 	}
 
<span class="p_chunk">@@ -491,8 +492,10 @@</span> <span class="p_context"> sfq_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	/* Return Congestion Notification only if we dropped a packet
 	 * from this flow.
 	 */
<span class="p_del">-	if (qlen != slot-&gt;qlen)</span>
<span class="p_add">+	if (qlen != slot-&gt;qlen) {</span>
<span class="p_add">+		qdisc_tree_reduce_backlog(sch, 0, dropped - qdisc_pkt_len(skb));</span>
 		return NET_XMIT_CN;
<span class="p_add">+	}</span>
 
 	/* As we dropped a packet, better let upper stack know this */
 	qdisc_tree_reduce_backlog(sch, 1, dropped);
<span class="p_chunk">@@ -767,9 +770,10 @@</span> <span class="p_context"> static int sfq_init(struct Qdisc *sch, struct nlattr *opt)</span>
 	q-&gt;ht = sfq_alloc(sizeof(q-&gt;ht[0]) * q-&gt;divisor);
 	q-&gt;slots = sfq_alloc(sizeof(q-&gt;slots[0]) * q-&gt;maxflows);
 	if (!q-&gt;ht || !q-&gt;slots) {
<span class="p_del">-		sfq_destroy(sch);</span>
<span class="p_add">+		/* Note: sfq_destroy() will be called by our caller */</span>
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
 	for (i = 0; i &lt; q-&gt;divisor; i++)
 		q-&gt;ht[i] = SFQ_EMPTY_SLOT;
 
<span class="p_header">diff --git a/net/sched/sch_tbf.c b/net/sched/sch_tbf.c</span>
<span class="p_header">index 7c9545f1a391..8e7b508914c5 100644</span>
<span class="p_header">--- a/net/sched/sch_tbf.c</span>
<span class="p_header">+++ b/net/sched/sch_tbf.c</span>
<span class="p_chunk">@@ -431,12 +431,13 @@</span> <span class="p_context"> static int tbf_init(struct Qdisc *sch, struct nlattr *opt)</span>
 {
 	struct tbf_sched_data *q = qdisc_priv(sch);
 
<span class="p_add">+	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_add">+	q-&gt;qdisc = &amp;noop_qdisc;</span>
<span class="p_add">+</span>
 	if (opt == NULL)
 		return -EINVAL;
 
 	q-&gt;t_c = ktime_to_ns(ktime_get());
<span class="p_del">-	qdisc_watchdog_init(&amp;q-&gt;watchdog, sch);</span>
<span class="p_del">-	q-&gt;qdisc = &amp;noop_qdisc;</span>
 
 	return tbf_change(sch, opt);
 }
<span class="p_header">diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c</span>
<span class="p_header">index 8ad13ba731b9..7f47fbdeb414 100644</span>
<span class="p_header">--- a/net/sctp/ipv6.c</span>
<span class="p_header">+++ b/net/sctp/ipv6.c</span>
<span class="p_chunk">@@ -331,7 +331,7 @@</span> <span class="p_context"> static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,</span>
 
 		rt = (struct rt6_info *)dst;
 		t-&gt;dst = dst;
<span class="p_del">-		t-&gt;dst_cookie = rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+		t-&gt;dst_cookie = rt6_get_cookie(rt);</span>
 		pr_debug(&quot;rt6_dst:%pI6 rt6_src:%pI6\n&quot;, &amp;rt-&gt;rt6i_dst.addr,
 			 &amp;fl6-&gt;saddr);
 	} else {
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index a6d54a9a1133..c28716452211 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -1752,6 +1752,7 @@</span> <span class="p_context"> static int build_aevent(struct sk_buff *skb, struct xfrm_state *x, const struct</span>
 		return -EMSGSIZE;
 
 	id = nlmsg_data(nlh);
<span class="p_add">+	memset(&amp;id-&gt;sa_id, 0, sizeof(id-&gt;sa_id));</span>
 	memcpy(&amp;id-&gt;sa_id.daddr, &amp;x-&gt;id.daddr, sizeof(x-&gt;id.daddr));
 	id-&gt;sa_id.spi = x-&gt;id.spi;
 	id-&gt;sa_id.family = x-&gt;props.family;
<span class="p_chunk">@@ -2552,6 +2553,7 @@</span> <span class="p_context"> static int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)</span>
 		struct nlattr *attr;
 
 		id = nlmsg_data(nlh);
<span class="p_add">+		memset(id, 0, sizeof(*id));</span>
 		memcpy(&amp;id-&gt;daddr, &amp;x-&gt;id.daddr, sizeof(id-&gt;daddr));
 		id-&gt;spi = x-&gt;id.spi;
 		id-&gt;family = x-&gt;props.family;
<span class="p_header">diff --git a/scripts/mod/modpost.c b/scripts/mod/modpost.c</span>
<span class="p_header">index 9d9c5b905b35..2241d036b63a 100644</span>
<span class="p_header">--- a/scripts/mod/modpost.c</span>
<span class="p_header">+++ b/scripts/mod/modpost.c</span>
<span class="p_chunk">@@ -798,6 +798,7 @@</span> <span class="p_context"> static int number_prefix(const char *sym)</span>
  *   where the &#39;1&#39; can be any number including several digits.
  *   The $ syntax is for sections where ld append a dot number
  *   to make section name unique.
<span class="p_add">+ * &quot;*foo*&quot; will match a string that contains &quot;foo&quot;</span>
  */
 static int match(const char *sym, const char * const pat[])
 {
<span class="p_chunk">@@ -806,8 +807,17 @@</span> <span class="p_context"> static int match(const char *sym, const char * const pat[])</span>
 		p = *pat++;
 		const char *endp = p + strlen(p) - 1;
 
<span class="p_add">+		/* &quot;*foo*&quot; */</span>
<span class="p_add">+		if (*p == &#39;*&#39; &amp;&amp; *endp == &#39;*&#39;) {</span>
<span class="p_add">+			char *here, *bare = strndup(p + 1, strlen(p) - 2);</span>
<span class="p_add">+</span>
<span class="p_add">+			here = strstr(sym, bare);</span>
<span class="p_add">+			free(bare);</span>
<span class="p_add">+			if (here != NULL)</span>
<span class="p_add">+				return 1;</span>
<span class="p_add">+		}</span>
 		/* &quot;*foo&quot; */
<span class="p_del">-		if (*p == &#39;*&#39;) {</span>
<span class="p_add">+		else if (*p == &#39;*&#39;) {</span>
 			if (strrcmp(sym, p + 1) == 0)
 				return 1;
 		}
<span class="p_chunk">@@ -920,6 +930,10 @@</span> <span class="p_context"> static const char *init_sections[] = { ALL_INIT_SECTIONS, NULL };</span>
 static const char *init_exit_sections[] =
 	{ALL_INIT_SECTIONS, ALL_EXIT_SECTIONS, NULL };
 
<span class="p_add">+/* all text sections */</span>
<span class="p_add">+static const char *const text_sections[] = { ALL_INIT_TEXT_SECTIONS,</span>
<span class="p_add">+				ALL_EXIT_TEXT_SECTIONS, TEXT_SECTIONS, NULL };</span>
<span class="p_add">+</span>
 /* data section */
 static const char *data_sections[] = { DATA_SECTIONS, NULL };
 
<span class="p_chunk">@@ -938,6 +952,7 @@</span> <span class="p_context"> static const char *data_sections[] = { DATA_SECTIONS, NULL };</span>
 static const char *head_sections[] = { &quot;.head.text*&quot;, NULL };
 static const char *linker_symbols[] =
 	{ &quot;__init_begin&quot;, &quot;_sinittext&quot;, &quot;_einittext&quot;, NULL };
<span class="p_add">+static const char *const optim_symbols[] = { &quot;*.constprop.*&quot;, NULL };</span>
 
 enum mismatch {
 	TEXT_TO_ANY_INIT,
<span class="p_chunk">@@ -1095,6 +1110,17 @@</span> <span class="p_context"> static const struct sectioncheck *section_mismatch(</span>
  *   This pattern is identified by
  *   refsymname = __init_begin, _sinittext, _einittext
  *
<span class="p_add">+ * Pattern 5:</span>
<span class="p_add">+ *   GCC may optimize static inlines when fed constant arg(s) resulting</span>
<span class="p_add">+ *   in functions like cpumask_empty() -- generating an associated symbol</span>
<span class="p_add">+ *   cpumask_empty.constprop.3 that appears in the audit.  If the const that</span>
<span class="p_add">+ *   is passed in comes from __init, like say nmi_ipi_mask, we get a</span>
<span class="p_add">+ *   meaningless section warning.  May need to add isra symbols too...</span>
<span class="p_add">+ *   This pattern is identified by</span>
<span class="p_add">+ *   tosec   = init section</span>
<span class="p_add">+ *   fromsec = text section</span>
<span class="p_add">+ *   refsymname = *.constprop.*</span>
<span class="p_add">+ *</span>
  **/
 static int secref_whitelist(const struct sectioncheck *mismatch,
 			    const char *fromsec, const char *fromsym,
<span class="p_chunk">@@ -1127,6 +1153,12 @@</span> <span class="p_context"> static int secref_whitelist(const struct sectioncheck *mismatch,</span>
 	if (match(tosym, linker_symbols))
 		return 0;
 
<span class="p_add">+	/* Check for pattern 5 */</span>
<span class="p_add">+	if (match(fromsec, text_sections) &amp;&amp;</span>
<span class="p_add">+	    match(tosec, init_sections) &amp;&amp;</span>
<span class="p_add">+	    match(fromsym, optim_symbols))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/security/keys/key.c b/security/keys/key.c</span>
<span class="p_header">index 07cd1fe2a496..58ebea254519 100644</span>
<span class="p_header">--- a/security/keys/key.c</span>
<span class="p_header">+++ b/security/keys/key.c</span>
<span class="p_chunk">@@ -901,6 +901,16 @@</span> <span class="p_context"> key_ref_t key_create_or_update(key_ref_t keyring_ref,</span>
 	 */
 	__key_link_end(keyring, &amp;index_key, edit);
 
<span class="p_add">+	key = key_ref_to_ptr(key_ref);</span>
<span class="p_add">+	if (test_bit(KEY_FLAG_USER_CONSTRUCT, &amp;key-&gt;flags)) {</span>
<span class="p_add">+		ret = wait_for_key_construction(key, true);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			key_ref_put(key_ref);</span>
<span class="p_add">+			key_ref = ERR_PTR(ret);</span>
<span class="p_add">+			goto error_free_prep;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	key_ref = __key_update(key_ref, &amp;prep);
 	goto error_free_prep;
 }
<span class="p_header">diff --git a/security/keys/keyctl.c b/security/keys/keyctl.c</span>
<span class="p_header">index edc3f3c32324..4598617c66de 100644</span>
<span class="p_header">--- a/security/keys/keyctl.c</span>
<span class="p_header">+++ b/security/keys/keyctl.c</span>
<span class="p_chunk">@@ -735,6 +735,11 @@</span> <span class="p_context"> long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)</span>
 
 	key = key_ref_to_ptr(key_ref);
 
<span class="p_add">+	if (test_bit(KEY_FLAG_NEGATIVE, &amp;key-&gt;flags)) {</span>
<span class="p_add">+		ret = -ENOKEY;</span>
<span class="p_add">+		goto error2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* see if we can read it directly */
 	ret = key_permission(key_ref, KEY_NEED_READ);
 	if (ret == 0)
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 665020b7c82e..fdffe37d40b8 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1087,7 +1087,7 @@</span> <span class="p_context"> static int snd_ctl_elem_user_tlv(struct snd_kcontrol *kcontrol,</span>
 		mutex_lock(&amp;ue-&gt;card-&gt;user_ctl_lock);
 		change = ue-&gt;tlv_data_size != size;
 		if (!change)
<span class="p_del">-			change = memcmp(ue-&gt;tlv_data, new_data, size);</span>
<span class="p_add">+			change = memcmp(ue-&gt;tlv_data, new_data, size) != 0;</span>
 		kfree(ue-&gt;tlv_data);
 		ue-&gt;tlv_data = new_data;
 		ue-&gt;tlv_data_size = size;
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index 7825e7e69ab4..a3988a4bcfd6 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1260,6 +1260,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_info info;
 	struct snd_seq_port_callback *callback;
<span class="p_add">+	int port_idx;</span>
 
 	if (copy_from_user(&amp;info, arg, sizeof(info)))
 		return -EFAULT;
<span class="p_chunk">@@ -1273,7 +1274,9 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 		return -ENOMEM;
 
 	if (client-&gt;type == USER_CLIENT &amp;&amp; info.kernel) {
<span class="p_del">-		snd_seq_delete_port(client, port-&gt;addr.port);</span>
<span class="p_add">+		port_idx = port-&gt;addr.port;</span>
<span class="p_add">+		snd_seq_port_unlock(port);</span>
<span class="p_add">+		snd_seq_delete_port(client, port_idx);</span>
 		return -EINVAL;
 	}
 	if (client-&gt;type == KERNEL_CLIENT) {
<span class="p_chunk">@@ -1295,6 +1298,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client,</span>
 
 	snd_seq_set_port_info(port, &amp;info);
 	snd_seq_system_client_ev_port_start(port-&gt;addr.client, port-&gt;addr.port);
<span class="p_add">+	snd_seq_port_unlock(port);</span>
 
 	if (copy_to_user(arg, &amp;info, sizeof(info)))
 		return -EFAULT;
<span class="p_header">diff --git a/sound/core/seq/seq_lock.c b/sound/core/seq/seq_lock.c</span>
<span class="p_header">index 12ba83367b1b..ba5752ee9af3 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_lock.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_lock.c</span>
<span class="p_chunk">@@ -23,8 +23,6 @@</span> <span class="p_context"></span>
 #include &lt;sound/core.h&gt;
 #include &quot;seq_lock.h&quot;
 
<span class="p_del">-#if defined(CONFIG_SMP) || defined(CONFIG_SND_DEBUG)</span>
<span class="p_del">-</span>
 /* wait until all locks are released */
 void snd_use_lock_sync_helper(snd_use_lock_t *lockp, const char *file, int line)
 {
<span class="p_chunk">@@ -42,5 +40,3 @@</span> <span class="p_context"> void snd_use_lock_sync_helper(snd_use_lock_t *lockp, const char *file, int line)</span>
 }
 
 EXPORT_SYMBOL(snd_use_lock_sync_helper);
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_header">diff --git a/sound/core/seq/seq_lock.h b/sound/core/seq/seq_lock.h</span>
<span class="p_header">index 54044bc2c9ef..ac38031c370e 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_lock.h</span>
<span class="p_header">+++ b/sound/core/seq/seq_lock.h</span>
<span class="p_chunk">@@ -3,8 +3,6 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/sched.h&gt;
 
<span class="p_del">-#if defined(CONFIG_SMP) || defined(CONFIG_SND_DEBUG)</span>
<span class="p_del">-</span>
 typedef atomic_t snd_use_lock_t;
 
 /* initialize lock */
<span class="p_chunk">@@ -20,14 +18,4 @@</span> <span class="p_context"> typedef atomic_t snd_use_lock_t;</span>
 void snd_use_lock_sync_helper(snd_use_lock_t *lock, const char *file, int line);
 #define snd_use_lock_sync(lockp) snd_use_lock_sync_helper(lockp, __BASE_FILE__, __LINE__)
 
<span class="p_del">-#else /* SMP || CONFIG_SND_DEBUG */</span>
<span class="p_del">-</span>
<span class="p_del">-typedef spinlock_t snd_use_lock_t;	/* dummy */</span>
<span class="p_del">-#define snd_use_lock_init(lockp) /**/</span>
<span class="p_del">-#define snd_use_lock_use(lockp) /**/</span>
<span class="p_del">-#define snd_use_lock_free(lockp) /**/</span>
<span class="p_del">-#define snd_use_lock_sync(lockp) /**/</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* SMP || CONFIG_SND_DEBUG */</span>
<span class="p_del">-</span>
 #endif /* __SND_SEQ_LOCK_H */
<span class="p_header">diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c</span>
<span class="p_header">index 9c1c8d50f593..1ddae911255c 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_ports.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_ports.c</span>
<span class="p_chunk">@@ -122,7 +122,9 @@</span> <span class="p_context"> static void port_subs_info_init(struct snd_seq_port_subs_info *grp)</span>
 }
 
 
<span class="p_del">-/* create a port, port number is returned (-1 on failure) */</span>
<span class="p_add">+/* create a port, port number is returned (-1 on failure);</span>
<span class="p_add">+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately</span>
<span class="p_add">+ */</span>
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
<span class="p_chunk">@@ -151,6 +153,7 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	snd_use_lock_init(&amp;new_port-&gt;use_lock);
 	port_subs_info_init(&amp;new_port-&gt;c_src);
 	port_subs_info_init(&amp;new_port-&gt;c_dest);
<span class="p_add">+	snd_use_lock_use(&amp;new_port-&gt;use_lock);</span>
 
 	num = port &gt;= 0 ? port : 0;
 	mutex_lock(&amp;client-&gt;ports_mutex);
<span class="p_chunk">@@ -165,9 +168,9 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	list_add_tail(&amp;new_port-&gt;list, &amp;p-&gt;list);
 	client-&gt;num_ports++;
 	new_port-&gt;addr.port = num;	/* store the port number in the port */
<span class="p_add">+	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 	write_unlock_irqrestore(&amp;client-&gt;ports_lock, flags);
 	mutex_unlock(&amp;client-&gt;ports_mutex);
<span class="p_del">-	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 
 	return new_port;
 }
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index ced54249c171..2086353ec6af 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -3438,6 +3438,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x390b, &quot;Lenovo G50-80&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3975, &quot;Lenovo U300s&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;Lenovo IdeaPad U310&quot;, CXT_FIXUP_STEREO_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x3978, &quot;Lenovo G50-70&quot;, CXT_FIXUP_STEREO_DMIC),</span>
 	SND_PCI_QUIRK(0x17aa, 0x397b, &quot;Lenovo S205&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK_VENDOR(0x17aa, &quot;Thinkpad&quot;, CXT_FIXUP_THINKPAD_ACPI),
 	SND_PCI_QUIRK(0x1c06, 0x2011, &quot;Lemote A1004&quot;, CXT_PINCFG_LEMOTE_A1004),
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 1b8fa72a6302..5c2b5c949c78 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2285,6 +2285,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1043, 0x8691, &quot;ASUS ROG Ranger VIII&quot;, ALC882_FIXUP_GPIO3),
 	SND_PCI_QUIRK(0x104d, 0x9047, &quot;Sony Vaio TT&quot;, ALC889_FIXUP_VAIO_TT),
 	SND_PCI_QUIRK(0x104d, 0x905a, &quot;Sony Vaio Z&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
<span class="p_add">+	SND_PCI_QUIRK(0x104d, 0x9060, &quot;Sony Vaio VPCL14M1R&quot;, ALC882_FIXUP_NO_PRIMARY_HP),</span>
 	SND_PCI_QUIRK(0x104d, 0x9043, &quot;Sony Vaio VGC-LN51JGB&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 	SND_PCI_QUIRK(0x104d, 0x9044, &quot;Sony VAIO AiO&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 
<span class="p_header">diff --git a/sound/soc/codecs/adau1977.c b/sound/soc/codecs/adau1977.c</span>
<span class="p_header">index fd55da7cb9d4..70ab35744aba 100644</span>
<span class="p_header">--- a/sound/soc/codecs/adau1977.c</span>
<span class="p_header">+++ b/sound/soc/codecs/adau1977.c</span>
<span class="p_chunk">@@ -968,7 +968,7 @@</span> <span class="p_context"> int adau1977_probe(struct device *dev, struct regmap *regmap,</span>
 	if (adau1977-&gt;dvdd_reg)
 		power_off_mask = ~0;
 	else
<span class="p_del">-		power_off_mask = ~ADAU1977_BLOCK_POWER_SAI_LDO_EN;</span>
<span class="p_add">+		power_off_mask = (unsigned int)~ADAU1977_BLOCK_POWER_SAI_LDO_EN;</span>
 
 	ret = regmap_update_bits(adau1977-&gt;regmap, ADAU1977_REG_BLOCK_POWER_SAI,
 				power_off_mask, 0x00);
<span class="p_header">diff --git a/sound/soc/fsl/fsl_sai.c b/sound/soc/fsl/fsl_sai.c</span>
<span class="p_header">index c5a0e8af8226..60465646fed8 100644</span>
<span class="p_header">--- a/sound/soc/fsl/fsl_sai.c</span>
<span class="p_header">+++ b/sound/soc/fsl/fsl_sai.c</span>
<span class="p_chunk">@@ -333,8 +333,7 @@</span> <span class="p_context"> static int fsl_sai_trigger(struct snd_pcm_substream *substream, int cmd,</span>
 	 * The transmitter bit clock and frame sync are to be
 	 * used by both the transmitter and receiver.
 	 */
<span class="p_del">-	regmap_update_bits(sai-&gt;regmap, FSL_SAI_TCR2, FSL_SAI_CR2_SYNC,</span>
<span class="p_del">-			   ~FSL_SAI_CR2_SYNC);</span>
<span class="p_add">+	regmap_update_bits(sai-&gt;regmap, FSL_SAI_TCR2, FSL_SAI_CR2_SYNC, 0);</span>
 	regmap_update_bits(sai-&gt;regmap, FSL_SAI_RCR2, FSL_SAI_CR2_SYNC,
 			   FSL_SAI_CR2_SYNC);
 
<span class="p_header">diff --git a/sound/soc/fsl/fsl_ssi.c b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">index 9bfef55d77d1..3043d576856b 100644</span>
<span class="p_header">--- a/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_header">+++ b/sound/soc/fsl/fsl_ssi.c</span>
<span class="p_chunk">@@ -590,8 +590,8 @@</span> <span class="p_context"> static int fsl_ssi_set_bclk(struct snd_pcm_substream *substream,</span>
 		else
 			clkrate = clk_round_rate(ssi_private-&gt;baudclk, tmprate);
 
<span class="p_del">-		do_div(clkrate, factor);</span>
<span class="p_del">-		afreq = (u32)clkrate / (i + 1);</span>
<span class="p_add">+		clkrate /= factor;</span>
<span class="p_add">+		afreq = clkrate / (i + 1);</span>
 
 		if (freq == afreq)
 			sub = 0;
<span class="p_header">diff --git a/sound/soc/fsl/imx-audmux.c b/sound/soc/fsl/imx-audmux.c</span>
<span class="p_header">index 267717aa96c1..46f9beb6b273 100644</span>
<span class="p_header">--- a/sound/soc/fsl/imx-audmux.c</span>
<span class="p_header">+++ b/sound/soc/fsl/imx-audmux.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> static ssize_t audmux_read_file(struct file *file, char __user *user_buf,</span>
 {
 	ssize_t ret;
 	char *buf;
<span class="p_del">-	int port = (int)file-&gt;private_data;</span>
<span class="p_add">+	uintptr_t port = (uintptr_t)file-&gt;private_data;</span>
 	u32 pdcr, ptcr;
 
 	if (audmux_clk) {
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> static const struct file_operations audmux_debugfs_fops = {</span>
 
 static void audmux_debugfs_init(void)
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	uintptr_t i;</span>
 	char buf[20];
 
 	audmux_debugfs_root = debugfs_create_dir(&quot;audmux&quot;, NULL);
<span class="p_chunk">@@ -157,10 +157,10 @@</span> <span class="p_context"> static void audmux_debugfs_init(void)</span>
 	}
 
 	for (i = 0; i &lt; MX31_AUDMUX_PORT7_SSI_PINS_7 + 1; i++) {
<span class="p_del">-		snprintf(buf, sizeof(buf), &quot;ssi%d&quot;, i);</span>
<span class="p_add">+		snprintf(buf, sizeof(buf), &quot;ssi%lu&quot;, i);</span>
 		if (!debugfs_create_file(buf, 0444, audmux_debugfs_root,
 					 (void *)i, &amp;audmux_debugfs_fops))
<span class="p_del">-			pr_warning(&quot;Failed to create AUDMUX port %d debugfs file\n&quot;,</span>
<span class="p_add">+			pr_warning(&quot;Failed to create AUDMUX port %lu debugfs file\n&quot;,</span>
 				   i);
 	}
 }
<span class="p_header">diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c</span>
<span class="p_header">index 9fa664de8580..0b44e605c1d2 100644</span>
<span class="p_header">--- a/sound/soc/soc-pcm.c</span>
<span class="p_header">+++ b/sound/soc/soc-pcm.c</span>
<span class="p_chunk">@@ -150,6 +150,10 @@</span> <span class="p_context"> int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,</span>
 		dev_dbg(be-&gt;dev, &quot;ASoC: BE %s event %d dir %d\n&quot;,
 				be-&gt;dai_link-&gt;name, event, dir);
 
<span class="p_add">+		if ((event == SND_SOC_DAPM_STREAM_STOP) &amp;&amp;</span>
<span class="p_add">+		    (be-&gt;dpcm[dir].users &gt;= 1))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		snd_soc_dapm_stream_event(be, dir, event);
 	}
 
<span class="p_header">diff --git a/sound/usb/card.c b/sound/usb/card.c</span>
<span class="p_header">index 8887f4e19956..32ed66722c54 100644</span>
<span class="p_header">--- a/sound/usb/card.c</span>
<span class="p_header">+++ b/sound/usb/card.c</span>
<span class="p_chunk">@@ -219,6 +219,7 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 	struct usb_interface_descriptor *altsd;
 	void *control_header;
 	int i, protocol;
<span class="p_add">+	int rest_bytes;</span>
 
 	/* find audiocontrol interface */
 	host_iface = &amp;usb_ifnum_to_if(dev, ctrlif)-&gt;altsetting[0];
<span class="p_chunk">@@ -233,6 +234,15 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	rest_bytes = (void *)(host_iface-&gt;extra + host_iface-&gt;extralen) -</span>
<span class="p_add">+		control_header;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* just to be sure -- this shouldn&#39;t hit at all */</span>
<span class="p_add">+	if (rest_bytes &lt;= 0) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;invalid control header\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	switch (protocol) {
 	default:
 		dev_warn(&amp;dev-&gt;dev,
<span class="p_chunk">@@ -243,11 +253,21 @@</span> <span class="p_context"> static int snd_usb_create_streams(struct snd_usb_audio *chip, int ctrlif)</span>
 	case UAC_VERSION_1: {
 		struct uac1_ac_header_descriptor *h1 = control_header;
 
<span class="p_add">+		if (rest_bytes &lt; sizeof(*h1)) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;too short v1 buffer descriptor\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (!h1-&gt;bInCollection) {
 			dev_info(&amp;dev-&gt;dev, &quot;skipping empty audio interface (v1)\n&quot;);
 			return -EINVAL;
 		}
 
<span class="p_add">+		if (rest_bytes &lt; h1-&gt;bLength) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;invalid buffer length (v1)\n&quot;);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (h1-&gt;bLength &lt; sizeof(*h1) + h1-&gt;bInCollection) {
 			dev_err(&amp;dev-&gt;dev, &quot;invalid UAC_HEADER (v1)\n&quot;);
 			return -EINVAL;
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index 5d249caf3349..6d7605db36d0 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -533,6 +533,8 @@</span> <span class="p_context"> int snd_usb_mixer_vol_tlv(struct snd_kcontrol *kcontrol, int op_flag,</span>
 
 	if (size &lt; sizeof(scale))
 		return -ENOMEM;
<span class="p_add">+	if (cval-&gt;min_mute)</span>
<span class="p_add">+		scale[0] = SNDRV_CTL_TLVT_DB_MINMAX_MUTE;</span>
 	scale[2] = cval-&gt;dBmin;
 	scale[3] = cval-&gt;dBmax;
 	if (copy_to_user(_tlv, scale, sizeof(scale)))
<span class="p_chunk">@@ -2156,6 +2158,9 @@</span> <span class="p_context"> static int parse_audio_unit(struct mixer_build *state, int unitid)</span>
 
 static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)
 {
<span class="p_add">+	/* kill pending URBs */</span>
<span class="p_add">+	snd_usb_mixer_disconnect(&amp;mixer-&gt;list);</span>
<span class="p_add">+</span>
 	kfree(mixer-&gt;id_elems);
 	if (mixer-&gt;urb) {
 		kfree(mixer-&gt;urb-&gt;transfer_buffer);
<span class="p_chunk">@@ -2492,8 +2497,13 @@</span> <span class="p_context"> void snd_usb_mixer_disconnect(struct list_head *p)</span>
 	struct usb_mixer_interface *mixer;
 
 	mixer = list_entry(p, struct usb_mixer_interface, list);
<span class="p_del">-	usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_del">-	usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	if (mixer-&gt;disconnected)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (mixer-&gt;urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_add">+	if (mixer-&gt;rc_urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	mixer-&gt;disconnected = true;</span>
 }
 
 #ifdef CONFIG_PM
<span class="p_header">diff --git a/sound/usb/mixer.h b/sound/usb/mixer.h</span>
<span class="p_header">index 73b1f649447b..483cbe89430a 100644</span>
<span class="p_header">--- a/sound/usb/mixer.h</span>
<span class="p_header">+++ b/sound/usb/mixer.h</span>
<span class="p_chunk">@@ -23,6 +23,8 @@</span> <span class="p_context"> struct usb_mixer_interface {</span>
 
 	u8 audigy2nx_leds[3];
 	u8 xonar_u1_status;
<span class="p_add">+</span>
<span class="p_add">+	bool disconnected;</span>
 };
 
 #define MAX_CHANNELS	16	/* max logical channels */
<span class="p_chunk">@@ -53,6 +55,7 @@</span> <span class="p_context"> struct usb_mixer_elem_info {</span>
 	int cached;
 	int cache_val[MAX_CHANNELS];
 	u8 initialized;
<span class="p_add">+	u8 min_mute;</span>
 };
 
 int snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 10ef6ce8f8bb..89d32f066561 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -1759,6 +1759,12 @@</span> <span class="p_context"> void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
 		if (unitid == 7 &amp;&amp; cval-&gt;control == UAC_FU_VOLUME)
 			snd_dragonfly_quirk_db_scale(mixer, cval, kctl);
 		break;
<span class="p_add">+	/* lowest playback value is muted on C-Media devices */</span>
<span class="p_add">+	case USB_ID(0x0d8c, 0x000c):</span>
<span class="p_add">+	case USB_ID(0x0d8c, 0x0014):</span>
<span class="p_add">+		if (strstr(kctl-&gt;id.name, &quot;Playback&quot;))</span>
<span class="p_add">+			cval-&gt;min_mute = 1;</span>
<span class="p_add">+		break;</span>
 	}
 }
 
<span class="p_header">diff --git a/tools/perf/ui/browser.c b/tools/perf/ui/browser.c</span>
<span class="p_header">index 3ccf6e14f89b..8c8ac8c255a9 100644</span>
<span class="p_header">--- a/tools/perf/ui/browser.c</span>
<span class="p_header">+++ b/tools/perf/ui/browser.c</span>
<span class="p_chunk">@@ -670,7 +670,7 @@</span> <span class="p_context"> static void __ui_browser__line_arrow_down(struct ui_browser *browser,</span>
 		ui_browser__gotorc(browser, row, column + 1);
 		SLsmg_draw_hline(2);
 
<span class="p_del">-		if (row++ == 0)</span>
<span class="p_add">+		if (++row == 0)</span>
 			goto out;
 	} else
 		row = 0;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



