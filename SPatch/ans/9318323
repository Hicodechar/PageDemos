
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.20 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.20</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 7, 2016, 7:16 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160907071626.GB32509@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9318323/mbox/"
   >mbox</a>
|
   <a href="/patch/9318323/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9318323/">/patch/9318323/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D19AC601C0 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:16:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B06BF28D5B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:16:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A1532290B7; Wed,  7 Sep 2016 07:16:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9B65F28D5B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:16:46 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756198AbcIGHQc (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 7 Sep 2016 03:16:32 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:46455 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1755664AbcIGHQW (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 7 Sep 2016 03:16:22 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 2B506951;
	Wed,  7 Sep 2016 07:16:19 +0000 (UTC)
Date: Wed, 7 Sep 2016 09:16:26 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.20
Message-ID: &lt;20160907071626.GB32509@kroah.com&gt;
References: &lt;20160907071620.GA32509@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160907071620.GA32509@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 7, 2016, 7:16 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 695c64ec160c..b74d60081a16 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 19</span>
<span class="p_add">+SUBLEVEL = 20</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arc/Makefile b/arch/arc/Makefile</span>
<span class="p_header">index 209d8451e23d..c05ea2b54276 100644</span>
<span class="p_header">--- a/arch/arc/Makefile</span>
<span class="p_header">+++ b/arch/arc/Makefile</span>
<span class="p_chunk">@@ -18,6 +18,20 @@</span> <span class="p_context"> cflags-y	+= -fno-common -pipe -fno-builtin -D__linux__</span>
 cflags-$(CONFIG_ISA_ARCOMPACT)	+= -mA7
 cflags-$(CONFIG_ISA_ARCV2)	+= -mcpu=archs
 
<span class="p_add">+is_700 = $(shell $(CC) -dM -E - &lt; /dev/null | grep -q &quot;ARC700&quot; &amp;&amp; echo 1 || echo 0)</span>
<span class="p_add">+</span>
<span class="p_add">+ifdef CONFIG_ISA_ARCOMPACT</span>
<span class="p_add">+ifeq ($(is_700), 0)</span>
<span class="p_add">+    $(error Toolchain not configured for ARCompact builds)</span>
<span class="p_add">+endif</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
<span class="p_add">+ifdef CONFIG_ISA_ARCV2</span>
<span class="p_add">+ifeq ($(is_700), 1)</span>
<span class="p_add">+    $(error Toolchain not configured for ARCv2 builds)</span>
<span class="p_add">+endif</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 ifdef CONFIG_ARC_CURR_IN_REG
 # For a global register defintion, make sure it gets passed to every file
 # We had a customer reported bug where some code built in kernel was NOT using
<span class="p_header">diff --git a/arch/arc/include/asm/arcregs.h b/arch/arc/include/asm/arcregs.h</span>
<span class="p_header">index 7fac7d85ed6a..2c30a016cf15 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/arcregs.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/arcregs.h</span>
<span class="p_chunk">@@ -374,12 +374,6 @@</span> <span class="p_context"> static inline int is_isa_arcompact(void)</span>
 	return IS_ENABLED(CONFIG_ISA_ARCOMPACT);
 }
 
<span class="p_del">-#if defined(CONFIG_ISA_ARCOMPACT) &amp;&amp; !defined(_CPU_DEFAULT_A7)</span>
<span class="p_del">-#error &quot;Toolchain not configured for ARCompact builds&quot;</span>
<span class="p_del">-#elif defined(CONFIG_ISA_ARCV2) &amp;&amp; !defined(_CPU_DEFAULT_HS)</span>
<span class="p_del">-#error &quot;Toolchain not configured for ARCv2 builds&quot;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #endif /* __ASEMBLY__ */
 
 #endif /* _ASM_ARC_ARCREGS_H */
<span class="p_header">diff --git a/arch/arc/include/asm/entry.h b/arch/arc/include/asm/entry.h</span>
<span class="p_header">index ad7860c5ce15..51597f344a62 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/entry.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/entry.h</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"></span>
 
 #ifdef CONFIG_ARC_CURR_IN_REG
 	; Retrieve orig r25 and save it with rest of callee_regs
<span class="p_del">-	ld.as   r12, [r12, PT_user_r25]</span>
<span class="p_add">+	ld	r12, [r12, PT_user_r25]</span>
 	PUSH	r12
 #else
 	PUSH	r25
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"></span>
 
 	; SP is back to start of pt_regs
 #ifdef CONFIG_ARC_CURR_IN_REG
<span class="p_del">-	st.as   r12, [sp, PT_user_r25]</span>
<span class="p_add">+	st	r12, [sp, PT_user_r25]</span>
 #endif
 .endm
 
<span class="p_header">diff --git a/arch/arc/include/asm/irqflags-compact.h b/arch/arc/include/asm/irqflags-compact.h</span>
<span class="p_header">index c1d36458bfb7..4c6eed80cd8b 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/irqflags-compact.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/irqflags-compact.h</span>
<span class="p_chunk">@@ -188,10 +188,10 @@</span> <span class="p_context"> static inline int arch_irqs_disabled(void)</span>
 .endm
 
 .macro IRQ_ENABLE  scratch
<span class="p_add">+	TRACE_ASM_IRQ_ENABLE</span>
 	lr	\scratch, [status32]
 	or	\scratch, \scratch, (STATUS_E1_MASK | STATUS_E2_MASK)
 	flag	\scratch
<span class="p_del">-	TRACE_ASM_IRQ_ENABLE</span>
 .endm
 
 #endif	/* __ASSEMBLY__ */
<span class="p_header">diff --git a/arch/arc/mm/cache.c b/arch/arc/mm/cache.c</span>
<span class="p_header">index ff7ff6cbb811..aaf1e2d1d900 100644</span>
<span class="p_header">--- a/arch/arc/mm/cache.c</span>
<span class="p_header">+++ b/arch/arc/mm/cache.c</span>
<span class="p_chunk">@@ -914,6 +914,15 @@</span> <span class="p_context"> void arc_cache_init(void)</span>
 
 	printk(arc_cache_mumbojumbo(0, str, sizeof(str)));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only master CPU needs to execute rest of function:</span>
<span class="p_add">+	 *  - Assume SMP so all cores will have same cache config so</span>
<span class="p_add">+	 *    any geomtry checks will be same for all</span>
<span class="p_add">+	 *  - IOC setup / dma callbacks only need to be setup once</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpu)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (IS_ENABLED(CONFIG_ARC_HAS_ICACHE)) {
 		struct cpuinfo_arc_cache *ic = &amp;cpuinfo_arc700[cpu].icache;
 
<span class="p_header">diff --git a/arch/arm64/boot/dts/rockchip/rk3368.dtsi b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">index 8fe39e1b680e..e0ee2b00d573 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_chunk">@@ -262,6 +262,8 @@</span> <span class="p_context"></span>
 		#io-channel-cells = &lt;1&gt;;
 		clocks = &lt;&amp;cru SCLK_SARADC&gt;, &lt;&amp;cru PCLK_SARADC&gt;;
 		clock-names = &quot;saradc&quot;, &quot;apb_pclk&quot;;
<span class="p_add">+		resets = &lt;&amp;cru SRST_SARADC&gt;;</span>
<span class="p_add">+		reset-names = &quot;saradc-apb&quot;;</span>
 		status = &quot;disabled&quot;;
 	};
 
<span class="p_header">diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h</span>
<span class="p_header">index bc6492b9a924..44dd892a4bbe 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/elf.h</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> typedef struct user_fpsimd_state elf_fpregset_t;</span>
 
 #define SET_PERSONALITY(ex)		clear_thread_flag(TIF_32BIT);
 
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO							\
 do {									\
 	NEW_AUX_ENT(AT_SYSINFO_EHDR,					\
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/auxvec.h b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">index 22d6d8885854..4cf0c17787a8 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -19,4 +19,6 @@</span> <span class="p_context"></span>
 /* vDSO location */
 #define AT_SYSINFO_EHDR	33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">index c0ae62520d15..274d5bc6ecce 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_chunk">@@ -97,10 +97,10 @@</span> <span class="p_context"></span>
 #define	ENOTCONN	235	/* Transport endpoint is not connected */
 #define	ESHUTDOWN	236	/* Cannot send after transport endpoint shutdown */
 #define	ETOOMANYREFS	237	/* Too many references: cannot splice */
<span class="p_del">-#define EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
 #define	ETIMEDOUT	238	/* Connection timed out */
 #define	ECONNREFUSED	239	/* Connection refused */
<span class="p_del">-#define EREMOTERELEASE	240	/* Remote peer released connection */</span>
<span class="p_add">+#define	EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
<span class="p_add">+#define	EREMOTERELEASE	240	/* Remote peer released connection */</span>
 #define	EHOSTDOWN	241	/* Host is down */
 #define	EHOSTUNREACH	242	/* No route to host */
 
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">index b34e8a54f7db..98949b0df00a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh.c</span>
<span class="p_chunk">@@ -677,7 +677,7 @@</span> <span class="p_context"> int eeh_pci_enable(struct eeh_pe *pe, int function)</span>
 	/* Check if the request is finished successfully */
 	if (active_flag) {
 		rc = eeh_ops-&gt;wait_state(pe, PCI_BUS_RESET_WAIT_MSEC);
<span class="p_del">-		if (rc &lt;= 0)</span>
<span class="p_add">+		if (rc &lt; 0)</span>
 			return rc;
 
 		if (rc &amp; active_flag)
<span class="p_header">diff --git a/arch/um/include/asm/common.lds.S b/arch/um/include/asm/common.lds.S</span>
<span class="p_header">index 1dd5bd8a8c59..133055311dce 100644</span>
<span class="p_header">--- a/arch/um/include/asm/common.lds.S</span>
<span class="p_header">+++ b/arch/um/include/asm/common.lds.S</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"></span>
   .altinstr_replacement : { *(.altinstr_replacement) }
   /* .exit.text is discard at runtime, not link time, to deal with references
      from .altinstructions and .eh_frame */
<span class="p_del">-  .exit.text : { *(.exit.text) }</span>
<span class="p_add">+  .exit.text : { EXIT_TEXT }</span>
   .exit.data : { *(.exit.data) }
 
   .preinit_array : {
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 6df2029405a3..3142218e546f 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -86,7 +86,14 @@</span> <span class="p_context"> static inline void cr4_set_bits_and_update_boot(unsigned long mask)</span>
 
 static inline void __native_flush_tlb(void)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If current-&gt;mm == NULL then we borrow a mm which may change during a</span>
<span class="p_add">+	 * task switch and therefore we must not be preempted while we write CR3</span>
<span class="p_add">+	 * back:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
 	native_write_cr3(native_read_cr3());
<span class="p_add">+	preempt_enable();</span>
 }
 
 static inline void __native_flush_tlb_global_irq_disabled(void)
<span class="p_header">diff --git a/arch/x86/kernel/uprobes.c b/arch/x86/kernel/uprobes.c</span>
<span class="p_header">index bf4db6eaec8f..c6aace2bbe08 100644</span>
<span class="p_header">--- a/arch/x86/kernel/uprobes.c</span>
<span class="p_header">+++ b/arch/x86/kernel/uprobes.c</span>
<span class="p_chunk">@@ -357,20 +357,22 @@</span> <span class="p_context"> static void riprel_analyze(struct arch_uprobe *auprobe, struct insn *insn)</span>
 		*cursor &amp;= 0xfe;
 	}
 	/*
<span class="p_del">-	 * Similar treatment for VEX3 prefix.</span>
<span class="p_del">-	 * TODO: add XOP/EVEX treatment when insn decoder supports them</span>
<span class="p_add">+	 * Similar treatment for VEX3/EVEX prefix.</span>
<span class="p_add">+	 * TODO: add XOP treatment when insn decoder supports them</span>
 	 */
<span class="p_del">-	if (insn-&gt;vex_prefix.nbytes == 3) {</span>
<span class="p_add">+	if (insn-&gt;vex_prefix.nbytes &gt;= 3) {</span>
 		/*
 		 * vex2:     c5    rvvvvLpp   (has no b bit)
 		 * vex3/xop: c4/8f rxbmmmmm wvvvvLpp
 		 * evex:     62    rxbR00mm wvvvv1pp zllBVaaa
<span class="p_del">-		 *   (evex will need setting of both b and x since</span>
<span class="p_del">-		 *   in non-sib encoding evex.x is 4th bit of MODRM.rm)</span>
<span class="p_del">-		 * Setting VEX3.b (setting because it has inverted meaning):</span>
<span class="p_add">+		 * Setting VEX3.b (setting because it has inverted meaning).</span>
<span class="p_add">+		 * Setting EVEX.x since (in non-SIB encoding) EVEX.x</span>
<span class="p_add">+		 * is the 4th bit of MODRM.rm, and needs the same treatment.</span>
<span class="p_add">+		 * For VEX3-encoded insns, VEX3.x value has no effect in</span>
<span class="p_add">+		 * non-SIB encoding, the change is superfluous but harmless.</span>
 		 */
 		cursor = auprobe-&gt;insn + insn_offset_vex_prefix(insn) + 1;
<span class="p_del">-		*cursor |= 0x20;</span>
<span class="p_add">+		*cursor |= 0x60;</span>
 	}
 
 	/*
<span class="p_chunk">@@ -415,12 +417,10 @@</span> <span class="p_context"> static void riprel_analyze(struct arch_uprobe *auprobe, struct insn *insn)</span>
 
 	reg = MODRM_REG(insn);	/* Fetch modrm.reg */
 	reg2 = 0xff;		/* Fetch vex.vvvv */
<span class="p_del">-	if (insn-&gt;vex_prefix.nbytes == 2)</span>
<span class="p_del">-		reg2 = insn-&gt;vex_prefix.bytes[1];</span>
<span class="p_del">-	else if (insn-&gt;vex_prefix.nbytes == 3)</span>
<span class="p_add">+	if (insn-&gt;vex_prefix.nbytes)</span>
 		reg2 = insn-&gt;vex_prefix.bytes[2];
 	/*
<span class="p_del">-	 * TODO: add XOP, EXEV vvvv reading.</span>
<span class="p_add">+	 * TODO: add XOP vvvv reading.</span>
 	 *
 	 * vex.vvvv field is in bits 6-3, bits are inverted.
 	 * But in 32-bit mode, high-order bit may be ignored.
<span class="p_header">diff --git a/drivers/acpi/cppc_acpi.c b/drivers/acpi/cppc_acpi.c</span>
<span class="p_header">index 6730f965b379..0afd1981e350 100644</span>
<span class="p_header">--- a/drivers/acpi/cppc_acpi.c</span>
<span class="p_header">+++ b/drivers/acpi/cppc_acpi.c</span>
<span class="p_chunk">@@ -216,8 +216,10 @@</span> <span class="p_context"> int acpi_get_psd_map(struct cpudata **all_cpu_data)</span>
 			continue;
 
 		cpc_ptr = per_cpu(cpc_desc_ptr, i);
<span class="p_del">-		if (!cpc_ptr)</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+		if (!cpc_ptr) {</span>
<span class="p_add">+			retval = -EFAULT;</span>
<span class="p_add">+			goto err_ret;</span>
<span class="p_add">+		}</span>
 
 		pdomain = &amp;(cpc_ptr-&gt;domain_info);
 		cpumask_set_cpu(i, pr-&gt;shared_cpu_map);
<span class="p_chunk">@@ -239,8 +241,10 @@</span> <span class="p_context"> int acpi_get_psd_map(struct cpudata **all_cpu_data)</span>
 				continue;
 
 			match_cpc_ptr = per_cpu(cpc_desc_ptr, j);
<span class="p_del">-			if (!match_cpc_ptr)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (!match_cpc_ptr) {</span>
<span class="p_add">+				retval = -EFAULT;</span>
<span class="p_add">+				goto err_ret;</span>
<span class="p_add">+			}</span>
 
 			match_pdomain = &amp;(match_cpc_ptr-&gt;domain_info);
 			if (match_pdomain-&gt;domain != pdomain-&gt;domain)
<span class="p_chunk">@@ -270,8 +274,10 @@</span> <span class="p_context"> int acpi_get_psd_map(struct cpudata **all_cpu_data)</span>
 				continue;
 
 			match_cpc_ptr = per_cpu(cpc_desc_ptr, j);
<span class="p_del">-			if (!match_cpc_ptr)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (!match_cpc_ptr) {</span>
<span class="p_add">+				retval = -EFAULT;</span>
<span class="p_add">+				goto err_ret;</span>
<span class="p_add">+			}</span>
 
 			match_pdomain = &amp;(match_cpc_ptr-&gt;domain_info);
 			if (match_pdomain-&gt;domain != pdomain-&gt;domain)
<span class="p_chunk">@@ -502,9 +508,6 @@</span> <span class="p_context"> int acpi_cppc_processor_probe(struct acpi_processor *pr)</span>
 	/* Store CPU Logical ID */
 	cpc_ptr-&gt;cpu_id = pr-&gt;id;
 
<span class="p_del">-	/* Plug it into this CPUs CPC descriptor. */</span>
<span class="p_del">-	per_cpu(cpc_desc_ptr, pr-&gt;id) = cpc_ptr;</span>
<span class="p_del">-</span>
 	/* Parse PSD data for this CPU */
 	ret = acpi_get_psd(cpc_ptr, handle);
 	if (ret)
<span class="p_chunk">@@ -517,6 +520,9 @@</span> <span class="p_context"> int acpi_cppc_processor_probe(struct acpi_processor *pr)</span>
 			goto out_free;
 	}
 
<span class="p_add">+	/* Plug PSD data into this CPUs CPC descriptor. */</span>
<span class="p_add">+	per_cpu(cpc_desc_ptr, pr-&gt;id) = cpc_ptr;</span>
<span class="p_add">+</span>
 	/* Everything looks okay */
 	pr_debug(&quot;Parsed CPC struct for CPU: %d\n&quot;, pr-&gt;id);
 
<span class="p_header">diff --git a/drivers/acpi/nfit.c b/drivers/acpi/nfit.c</span>
<span class="p_header">index 11d8209e6e5d..5230e8449d30 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit.c</span>
<span class="p_chunk">@@ -1072,11 +1072,12 @@</span> <span class="p_context"> static u32 read_blk_stat(struct nfit_blk *nfit_blk, unsigned int bw)</span>
 {
 	struct nfit_blk_mmio *mmio = &amp;nfit_blk-&gt;mmio[DCR];
 	u64 offset = nfit_blk-&gt;stat_offset + mmio-&gt;size * bw;
<span class="p_add">+	const u32 STATUS_MASK = 0x80000037;</span>
 
 	if (mmio-&gt;num_lines)
 		offset = to_interleave_offset(offset, mmio);
 
<span class="p_del">-	return readl(mmio-&gt;addr.base + offset);</span>
<span class="p_add">+	return readl(mmio-&gt;addr.base + offset) &amp; STATUS_MASK;</span>
 }
 
 static void write_blk_ctl(struct nfit_blk *nfit_blk, unsigned int bw,
<span class="p_header">diff --git a/drivers/acpi/numa.c b/drivers/acpi/numa.c</span>
<span class="p_header">index 72b6e9ef0ae9..d176e0ece470 100644</span>
<span class="p_header">--- a/drivers/acpi/numa.c</span>
<span class="p_header">+++ b/drivers/acpi/numa.c</span>
<span class="p_chunk">@@ -327,10 +327,18 @@</span> <span class="p_context"> int __init acpi_numa_init(void)</span>
 
 	/* SRAT: Static Resource Affinity Table */
 	if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {
<span class="p_del">-		acpi_table_parse_srat(ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY,</span>
<span class="p_del">-				     acpi_parse_x2apic_affinity, 0);</span>
<span class="p_del">-		acpi_table_parse_srat(ACPI_SRAT_TYPE_CPU_AFFINITY,</span>
<span class="p_del">-				     acpi_parse_processor_affinity, 0);</span>
<span class="p_add">+		struct acpi_subtable_proc srat_proc[2];</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(srat_proc, 0, sizeof(srat_proc));</span>
<span class="p_add">+		srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;</span>
<span class="p_add">+		srat_proc[0].handler = acpi_parse_processor_affinity;</span>
<span class="p_add">+		srat_proc[1].id = ACPI_SRAT_TYPE_X2APIC_CPU_AFFINITY;</span>
<span class="p_add">+		srat_proc[1].handler = acpi_parse_x2apic_affinity;</span>
<span class="p_add">+</span>
<span class="p_add">+		acpi_table_parse_entries_array(ACPI_SIG_SRAT,</span>
<span class="p_add">+					sizeof(struct acpi_table_srat),</span>
<span class="p_add">+					srat_proc, ARRAY_SIZE(srat_proc), 0);</span>
<span class="p_add">+</span>
 		cnt = acpi_table_parse_srat(ACPI_SRAT_TYPE_MEMORY_AFFINITY,
 					    acpi_parse_memory_affinity,
 					    NR_NODE_MEMBLKS);
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index 78d5f02a073b..dcb3d6245ca5 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -1958,7 +1958,7 @@</span> <span class="p_context"> int __init acpi_scan_init(void)</span>
 
 static struct acpi_probe_entry *ape;
 static int acpi_probe_count;
<span class="p_del">-static DEFINE_SPINLOCK(acpi_probe_lock);</span>
<span class="p_add">+static DEFINE_MUTEX(acpi_probe_mutex);</span>
 
 static int __init acpi_match_madt(struct acpi_subtable_header *header,
 				  const unsigned long end)
<span class="p_chunk">@@ -1977,7 +1977,7 @@</span> <span class="p_context"> int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)</span>
 	if (acpi_disabled)
 		return 0;
 
<span class="p_del">-	spin_lock(&amp;acpi_probe_lock);</span>
<span class="p_add">+	mutex_lock(&amp;acpi_probe_mutex);</span>
 	for (ape = ap_head; nr; ape++, nr--) {
 		if (ACPI_COMPARE_NAME(ACPI_SIG_MADT, ape-&gt;id)) {
 			acpi_probe_count = 0;
<span class="p_chunk">@@ -1990,7 +1990,7 @@</span> <span class="p_context"> int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)</span>
 				count++;
 		}
 	}
<span class="p_del">-	spin_unlock(&amp;acpi_probe_lock);</span>
<span class="p_add">+	mutex_unlock(&amp;acpi_probe_mutex);</span>
 
 	return count;
 }
<span class="p_header">diff --git a/drivers/acpi/sysfs.c b/drivers/acpi/sysfs.c</span>
<span class="p_header">index 0243d375c6fd..4b3a9e27f1b6 100644</span>
<span class="p_header">--- a/drivers/acpi/sysfs.c</span>
<span class="p_header">+++ b/drivers/acpi/sysfs.c</span>
<span class="p_chunk">@@ -555,23 +555,22 @@</span> <span class="p_context"> static void acpi_global_event_handler(u32 event_type, acpi_handle device,</span>
 static int get_status(u32 index, acpi_event_status *status,
 		      acpi_handle *handle)
 {
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	int result;</span>
 
 	if (index &gt;= num_gpes + ACPI_NUM_FIXED_EVENTS)
<span class="p_del">-		goto end;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (index &lt; num_gpes) {
 		result = acpi_get_gpe_device(index, handle);
 		if (result) {
 			ACPI_EXCEPTION((AE_INFO, AE_NOT_FOUND,
 					&quot;Invalid GPE 0x%x&quot;, index));
<span class="p_del">-			goto end;</span>
<span class="p_add">+			return result;</span>
 		}
 		result = acpi_get_gpe_status(*handle, index, status);
 	} else if (index &lt; (num_gpes + ACPI_NUM_FIXED_EVENTS))
 		result = acpi_get_event_status(index - num_gpes, status);
 
<span class="p_del">-end:</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c</span>
<span class="p_header">index ea8189f4b021..6dc597126b79 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamalg.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamalg.c</span>
<span class="p_chunk">@@ -441,6 +441,9 @@</span> <span class="p_context"> static int aead_set_sh_desc(struct crypto_aead *aead)</span>
 			       OP_ALG_AAI_CTR_MOD128);
 	const bool is_rfc3686 = alg-&gt;caam.rfc3686;
 
<span class="p_add">+	if (!ctx-&gt;authsize)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/* NULL encryption / decryption */
 	if (!ctx-&gt;enckeylen)
 		return aead_null_set_sh_desc(aead);
<span class="p_chunk">@@ -614,7 +617,7 @@</span> <span class="p_context"> skip_enc:</span>
 		keys_fit_inline = true;
 
 	/* aead_givencrypt shared descriptor */
<span class="p_del">-	desc = ctx-&gt;sh_desc_givenc;</span>
<span class="p_add">+	desc = ctx-&gt;sh_desc_enc;</span>
 
 	/* Note: Context registers are saved. */
 	init_sh_desc_key_aead(desc, ctx, keys_fit_inline, is_rfc3686);
<span class="p_chunk">@@ -645,13 +648,13 @@</span> <span class="p_context"> copy_iv:</span>
 	append_operation(desc, ctx-&gt;class2_alg_type |
 			 OP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);
 
<span class="p_del">-	/* ivsize + cryptlen = seqoutlen - authsize */</span>
<span class="p_del">-	append_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx-&gt;authsize);</span>
<span class="p_del">-</span>
 	/* Read and write assoclen bytes */
 	append_math_add(desc, VARSEQINLEN, ZERO, REG3, CAAM_CMD_SZ);
 	append_math_add(desc, VARSEQOUTLEN, ZERO, REG3, CAAM_CMD_SZ);
 
<span class="p_add">+	/* ivsize + cryptlen = seqoutlen - authsize */</span>
<span class="p_add">+	append_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx-&gt;authsize);</span>
<span class="p_add">+</span>
 	/* Skip assoc data */
 	append_seq_fifo_store(desc, 0, FIFOST_TYPE_SKIP | FIFOLDST_VLF);
 
<span class="p_chunk">@@ -697,7 +700,7 @@</span> <span class="p_context"> copy_iv:</span>
 	ctx-&gt;sh_desc_enc_dma = dma_map_single(jrdev, desc,
 					      desc_bytes(desc),
 					      DMA_TO_DEVICE);
<span class="p_del">-	if (dma_mapping_error(jrdev, ctx-&gt;sh_desc_givenc_dma)) {</span>
<span class="p_add">+	if (dma_mapping_error(jrdev, ctx-&gt;sh_desc_enc_dma)) {</span>
 		dev_err(jrdev, &quot;unable to map shared descriptor\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_header">diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">index 49106ea42887..99d5e11db194 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamhash.c</span>
<span class="p_chunk">@@ -1873,6 +1873,7 @@</span> <span class="p_context"> caam_hash_alloc(struct caam_hash_template *template,</span>
 			 template-&gt;name);
 		snprintf(alg-&gt;cra_driver_name, CRYPTO_MAX_ALG_NAME, &quot;%s&quot;,
 			 template-&gt;driver_name);
<span class="p_add">+		t_alg-&gt;ahash_alg.setkey = NULL;</span>
 	}
 	alg-&gt;cra_module = THIS_MODULE;
 	alg-&gt;cra_init = caam_hash_cra_init;
<span class="p_header">diff --git a/drivers/crypto/nx/nx.c b/drivers/crypto/nx/nx.c</span>
<span class="p_header">index 0794f1cc0018..42f0f229f7f7 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx.c</span>
<span class="p_chunk">@@ -392,7 +392,7 @@</span> <span class="p_context"> static void nx_of_update_msc(struct device   *dev,</span>
 		     ((bytes_so_far + sizeof(struct msc_triplet)) &lt;= lenp) &amp;&amp;
 		     i &lt; msc-&gt;triplets;
 		     i++) {
<span class="p_del">-			if (msc-&gt;fc &gt; NX_MAX_FC || msc-&gt;mode &gt; NX_MAX_MODE) {</span>
<span class="p_add">+			if (msc-&gt;fc &gt;= NX_MAX_FC || msc-&gt;mode &gt;= NX_MAX_MODE) {</span>
 				dev_err(dev, &quot;unknown function code/mode &quot;
 					&quot;combo: %d/%d (ignored)\n&quot;, msc-&gt;fc,
 					msc-&gt;mode);
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/qat_algs.c b/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_header">index 59e4c3af15ed..367b6661ee04 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_chunk">@@ -1262,8 +1262,8 @@</span> <span class="p_context"> static struct crypto_alg qat_algs[] = { {</span>
 			.setkey = qat_alg_ablkcipher_xts_setkey,
 			.decrypt = qat_alg_ablkcipher_decrypt,
 			.encrypt = qat_alg_ablkcipher_encrypt,
<span class="p_del">-			.min_keysize = AES_MIN_KEY_SIZE,</span>
<span class="p_del">-			.max_keysize = AES_MAX_KEY_SIZE,</span>
<span class="p_add">+			.min_keysize = 2 * AES_MIN_KEY_SIZE,</span>
<span class="p_add">+			.max_keysize = 2 * AES_MAX_KEY_SIZE,</span>
 			.ivsize = AES_BLOCK_SIZE,
 		},
 	},
<span class="p_header">diff --git a/drivers/dma/sh/usb-dmac.c b/drivers/dma/sh/usb-dmac.c</span>
<span class="p_header">index f1bcc2a163b3..b1bc945f008f 100644</span>
<span class="p_header">--- a/drivers/dma/sh/usb-dmac.c</span>
<span class="p_header">+++ b/drivers/dma/sh/usb-dmac.c</span>
<span class="p_chunk">@@ -600,27 +600,30 @@</span> <span class="p_context"> static irqreturn_t usb_dmac_isr_channel(int irq, void *dev)</span>
 {
 	struct usb_dmac_chan *chan = dev;
 	irqreturn_t ret = IRQ_NONE;
<span class="p_del">-	u32 mask = USB_DMACHCR_TE;</span>
<span class="p_del">-	u32 check_bits = USB_DMACHCR_TE | USB_DMACHCR_SP;</span>
<span class="p_add">+	u32 mask = 0;</span>
 	u32 chcr;
<span class="p_add">+	bool xfer_end = false;</span>
 
 	spin_lock(&amp;chan-&gt;vc.lock);
 
 	chcr = usb_dmac_chan_read(chan, USB_DMACHCR);
<span class="p_del">-	if (chcr &amp; check_bits)</span>
<span class="p_del">-		mask |= USB_DMACHCR_DE | check_bits;</span>
<span class="p_add">+	if (chcr &amp; (USB_DMACHCR_TE | USB_DMACHCR_SP)) {</span>
<span class="p_add">+		mask |= USB_DMACHCR_DE | USB_DMACHCR_TE | USB_DMACHCR_SP;</span>
<span class="p_add">+		if (chcr &amp; USB_DMACHCR_DE)</span>
<span class="p_add">+			xfer_end = true;</span>
<span class="p_add">+		ret |= IRQ_HANDLED;</span>
<span class="p_add">+	}</span>
 	if (chcr &amp; USB_DMACHCR_NULL) {
 		/* An interruption of TE will happen after we set FTE */
 		mask |= USB_DMACHCR_NULL;
 		chcr |= USB_DMACHCR_FTE;
 		ret |= IRQ_HANDLED;
 	}
<span class="p_del">-	usb_dmac_chan_write(chan, USB_DMACHCR, chcr &amp; ~mask);</span>
<span class="p_add">+	if (mask)</span>
<span class="p_add">+		usb_dmac_chan_write(chan, USB_DMACHCR, chcr &amp; ~mask);</span>
 
<span class="p_del">-	if (chcr &amp; check_bits) {</span>
<span class="p_add">+	if (xfer_end)</span>
 		usb_dmac_isr_transfer_end(chan);
<span class="p_del">-		ret |= IRQ_HANDLED;</span>
<span class="p_del">-	}</span>
 
 	spin_unlock(&amp;chan-&gt;vc.lock);
 
<span class="p_header">diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c</span>
<span class="p_header">index 1b2c2187b347..dc68394da682 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc.c</span>
<span class="p_chunk">@@ -966,7 +966,7 @@</span> <span class="p_context"> static void edac_inc_ue_error(struct mem_ctl_info *mci,</span>
 	mci-&gt;ue_mc += count;
 
 	if (!enable_per_layer_report) {
<span class="p_del">-		mci-&gt;ce_noinfo_count += count;</span>
<span class="p_add">+		mci-&gt;ue_noinfo_count += count;</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig</span>
<span class="p_header">index b18bea08ff25..469dc378adeb 100644</span>
<span class="p_header">--- a/drivers/gpio/Kconfig</span>
<span class="p_header">+++ b/drivers/gpio/Kconfig</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> config GPIO_DEVRES</span>
 config OF_GPIO
 	def_bool y
 	depends on OF
<span class="p_add">+	depends on HAS_IOMEM</span>
 
 config GPIO_ACPI
 	def_bool y
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">index 053fc2f465df..ff5566c69f7d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_chunk">@@ -710,9 +710,9 @@</span> <span class="p_context"> int amdgpu_gart_table_vram_pin(struct amdgpu_device *adev);</span>
 void amdgpu_gart_table_vram_unpin(struct amdgpu_device *adev);
 int amdgpu_gart_init(struct amdgpu_device *adev);
 void amdgpu_gart_fini(struct amdgpu_device *adev);
<span class="p_del">-void amdgpu_gart_unbind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+void amdgpu_gart_unbind(struct amdgpu_device *adev, uint64_t offset,</span>
 			int pages);
<span class="p_del">-int amdgpu_gart_bind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+int amdgpu_gart_bind(struct amdgpu_device *adev, uint64_t offset,</span>
 		     int pages, struct page **pagelist,
 		     dma_addr_t *dma_addr, uint32_t flags);
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index 0aaa457a1710..51a9942cdb40 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -331,6 +331,19 @@</span> <span class="p_context"> bool amdgpu_atombios_get_connector_info_from_object_table(struct amdgpu_device *</span>
 			    (le16_to_cpu(path-&gt;usConnObjectId) &amp;
 			     OBJECT_TYPE_MASK) &gt;&gt; OBJECT_TYPE_SHIFT;
 
<span class="p_add">+			/* Skip TV/CV support */</span>
<span class="p_add">+			if ((le16_to_cpu(path-&gt;usDeviceTag) ==</span>
<span class="p_add">+			     ATOM_DEVICE_TV1_SUPPORT) ||</span>
<span class="p_add">+			    (le16_to_cpu(path-&gt;usDeviceTag) ==</span>
<span class="p_add">+			     ATOM_DEVICE_CV_SUPPORT))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (con_obj_id &gt;= ARRAY_SIZE(object_connector_convert)) {</span>
<span class="p_add">+				DRM_ERROR(&quot;invalid con_obj_id %d for device tag 0x%04x\n&quot;,</span>
<span class="p_add">+					  con_obj_id, le16_to_cpu(path-&gt;usDeviceTag));</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			connector_type =
 				object_connector_convert[con_obj_id];
 			connector_object_id = con_obj_id;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c</span>
<span class="p_header">index 7312d729d300..22a613a95bf0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c</span>
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> void amdgpu_gart_table_vram_free(struct amdgpu_device *adev)</span>
  * Unbinds the requested pages from the gart page table and
  * replaces them with the dummy page (all asics).
  */
<span class="p_del">-void amdgpu_gart_unbind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+void amdgpu_gart_unbind(struct amdgpu_device *adev, uint64_t offset,</span>
 			int pages)
 {
 	unsigned t;
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"> void amdgpu_gart_unbind(struct amdgpu_device *adev, unsigned offset,</span>
  * (all asics).
  * Returns 0 for success, -EINVAL for failure.
  */
<span class="p_del">-int amdgpu_gart_bind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+int amdgpu_gart_bind(struct amdgpu_device *adev, uint64_t offset,</span>
 		     int pages, struct page **pagelist, dma_addr_t *dma_addr,
 		     uint32_t flags)
 {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c</span>
<span class="p_header">index 9e25edafa721..c77a1ebfc632 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c</span>
<span class="p_chunk">@@ -288,7 +288,7 @@</span> <span class="p_context"> void amdgpu_ib_pool_fini(struct amdgpu_device *adev)</span>
 int amdgpu_ib_ring_tests(struct amdgpu_device *adev)
 {
 	unsigned i;
<span class="p_del">-	int r;</span>
<span class="p_add">+	int r, ret = 0;</span>
 
 	for (i = 0; i &lt; AMDGPU_MAX_RINGS; ++i) {
 		struct amdgpu_ring *ring = adev-&gt;rings[i];
<span class="p_chunk">@@ -309,10 +309,11 @@</span> <span class="p_context"> int amdgpu_ib_ring_tests(struct amdgpu_device *adev)</span>
 			} else {
 				/* still not good, but we can live with it */
 				DRM_ERROR(&quot;amdgpu: failed testing IB on ring %d (%d).\n&quot;, i, r);
<span class="p_add">+				ret = r;</span>
 			}
 		}
 	}
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c</span>
<span class="p_header">index 1cbb16e15307..475c38fe9245 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c</span>
<span class="p_chunk">@@ -233,8 +233,8 @@</span> <span class="p_context"> static int amdgpu_move_blit(struct ttm_buffer_object *bo,</span>
 
 	adev = amdgpu_get_adev(bo-&gt;bdev);
 	ring = adev-&gt;mman.buffer_funcs_ring;
<span class="p_del">-	old_start = old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-	new_start = new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	old_start = (u64)old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	new_start = (u64)new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
 
 	switch (old_mem-&gt;mem_type) {
 	case TTM_PL_VRAM:
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c</span>
<span class="p_header">index 5f712ceddf08..c568293cb6c1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c</span>
<span class="p_chunk">@@ -52,6 +52,7 @@</span> <span class="p_context"> static void cik_sdma_set_ring_funcs(struct amdgpu_device *adev);</span>
 static void cik_sdma_set_irq_funcs(struct amdgpu_device *adev);
 static void cik_sdma_set_buffer_funcs(struct amdgpu_device *adev);
 static void cik_sdma_set_vm_pte_funcs(struct amdgpu_device *adev);
<span class="p_add">+static int cik_sdma_soft_reset(void *handle);</span>
 
 MODULE_FIRMWARE(&quot;radeon/bonaire_sdma.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/bonaire_sdma1.bin&quot;);
<span class="p_chunk">@@ -1030,6 +1031,8 @@</span> <span class="p_context"> static int cik_sdma_resume(void *handle)</span>
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
<span class="p_add">+	cik_sdma_soft_reset(handle);</span>
<span class="p_add">+</span>
 	return cik_sdma_hw_init(adev);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_gtt.c b/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_header">index 86c7500454b4..b37fe0df743e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_chunk">@@ -2747,6 +2747,7 @@</span> <span class="p_context"> void i915_global_gtt_cleanup(struct drm_device *dev)</span>
 		struct i915_hw_ppgtt *ppgtt = dev_priv-&gt;mm.aliasing_ppgtt;
 
 		ppgtt-&gt;base.cleanup(&amp;ppgtt-&gt;base);
<span class="p_add">+		kfree(ppgtt);</span>
 	}
 
 	if (drm_mm_initialized(&amp;vm-&gt;mm)) {
<span class="p_header">diff --git a/drivers/hwmon/iio_hwmon.c b/drivers/hwmon/iio_hwmon.c</span>
<span class="p_header">index 17ae2eb26ce2..d5c06f2764f4 100644</span>
<span class="p_header">--- a/drivers/hwmon/iio_hwmon.c</span>
<span class="p_header">+++ b/drivers/hwmon/iio_hwmon.c</span>
<span class="p_chunk">@@ -109,24 +109,24 @@</span> <span class="p_context"> static int iio_hwmon_probe(struct platform_device *pdev)</span>
 
 		switch (type) {
 		case IIO_VOLTAGE:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;in%d_input&quot;,</span>
<span class="p_del">-							  in_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;in%d_input&quot;,</span>
<span class="p_add">+							       in_i++);</span>
 			break;
 		case IIO_TEMP:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;temp%d_input&quot;,</span>
<span class="p_del">-							  temp_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;temp%d_input&quot;,</span>
<span class="p_add">+							       temp_i++);</span>
 			break;
 		case IIO_CURRENT:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;curr%d_input&quot;,</span>
<span class="p_del">-							  curr_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;curr%d_input&quot;,</span>
<span class="p_add">+							       curr_i++);</span>
 			break;
 		case IIO_HUMIDITYRELATIVE:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;humidity%d_input&quot;,</span>
<span class="p_del">-							  humidity_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;humidity%d_input&quot;,</span>
<span class="p_add">+							       humidity_i++);</span>
 			break;
 		default:
 			ret = -EINVAL;
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-cros-ec-tunnel.c b/drivers/i2c/busses/i2c-cros-ec-tunnel.c</span>
<span class="p_header">index a0d95ff682ae..2d5ff86398d0 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-cros-ec-tunnel.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-cros-ec-tunnel.c</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> static int ec_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg i2c_msgs[],</span>
 	msg-&gt;outsize = request_len;
 	msg-&gt;insize = response_len;
 
<span class="p_del">-	result = cros_ec_cmd_xfer(bus-&gt;ec, msg);</span>
<span class="p_add">+	result = cros_ec_cmd_xfer_status(bus-&gt;ec, msg);</span>
 	if (result &lt; 0) {
 		dev_err(dev, &quot;Error transferring EC i2c message %d\n&quot;, result);
 		goto exit;
<span class="p_header">diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">index 0f6f63b20263..7afd226a3321 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-buffer.c</span>
<span class="p_chunk">@@ -107,6 +107,7 @@</span> <span class="p_context"> ssize_t iio_buffer_read_first_n_outer(struct file *filp, char __user *buf,</span>
 {
 	struct iio_dev *indio_dev = filp-&gt;private_data;
 	struct iio_buffer *rb = indio_dev-&gt;buffer;
<span class="p_add">+	DEFINE_WAIT_FUNC(wait, woken_wake_function);</span>
 	size_t datum_size;
 	size_t to_wait;
 	int ret;
<span class="p_chunk">@@ -131,19 +132,29 @@</span> <span class="p_context"> ssize_t iio_buffer_read_first_n_outer(struct file *filp, char __user *buf,</span>
 	else
 		to_wait = min_t(size_t, n / datum_size, rb-&gt;watermark);
 
<span class="p_add">+	add_wait_queue(&amp;rb-&gt;pollq, &amp;wait);</span>
 	do {
<span class="p_del">-		ret = wait_event_interruptible(rb-&gt;pollq,</span>
<span class="p_del">-		      iio_buffer_ready(indio_dev, rb, to_wait, n / datum_size));</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+		if (!indio_dev-&gt;info) {</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		if (!indio_dev-&gt;info)</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+		if (!iio_buffer_ready(indio_dev, rb, to_wait, n / datum_size)) {</span>
<span class="p_add">+			if (signal_pending(current)) {</span>
<span class="p_add">+				ret = -ERESTARTSYS;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span>
<span class="p_add">+				   MAX_SCHEDULE_TIMEOUT);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
 		ret = rb-&gt;access-&gt;read_first_n(rb, n, buf);
 		if (ret == 0 &amp;&amp; (filp-&gt;f_flags &amp; O_NONBLOCK))
 			ret = -EAGAIN;
 	 } while (ret == 0);
<span class="p_add">+	remove_wait_queue(&amp;rb-&gt;pollq, &amp;wait);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/input/keyboard/tegra-kbc.c b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">index acc5394afb03..29485bc4221c 100644</span>
<span class="p_header">--- a/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">+++ b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> static int tegra_kbc_start(struct tegra_kbc *kbc)</span>
 	/* Reset the KBC controller to clear all previous status.*/
 	reset_control_assert(kbc-&gt;rst);
 	udelay(100);
<span class="p_del">-	reset_control_assert(kbc-&gt;rst);</span>
<span class="p_add">+	reset_control_deassert(kbc-&gt;rst);</span>
 	udelay(100);
 
 	tegra_kbc_config_pins(kbc);
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index 454195709a82..405252a884dd 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -1277,6 +1277,7 @@</span> <span class="p_context"> static int __init i8042_create_kbd_port(void)</span>
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
 	serio-&gt;close		= i8042_port_close;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	strlcpy(serio-&gt;name, &quot;i8042 KBD port&quot;, sizeof(serio-&gt;name));
<span class="p_chunk">@@ -1304,6 +1305,7 @@</span> <span class="p_context"> static int __init i8042_create_aux_port(int idx)</span>
 	serio-&gt;write		= i8042_aux_write;
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	if (idx &lt; 0) {
<span class="p_chunk">@@ -1373,21 +1375,6 @@</span> <span class="p_context"> static void i8042_unregister_ports(void)</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Checks whether port belongs to i8042 controller.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool i8042_check_port_owner(const struct serio *port)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; I8042_NUM_PORTS; i++)</span>
<span class="p_del">-		if (i8042_ports[i].serio == port)</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(i8042_check_port_owner);</span>
<span class="p_del">-</span>
 static void i8042_free_irqs(void)
 {
 	if (i8042_aux_irq_registered)
<span class="p_header">diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c</span>
<span class="p_header">index 316f2c897101..83e9c663aa67 100644</span>
<span class="p_header">--- a/drivers/input/serio/libps2.c</span>
<span class="p_header">+++ b/drivers/input/serio/libps2.c</span>
<span class="p_chunk">@@ -56,19 +56,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(ps2_sendbyte);</span>
 
 void ps2_begin_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	mutex_lock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_lock_chip();</span>
<span class="p_add">+	mutex_lock(m);</span>
 }
 EXPORT_SYMBOL(ps2_begin_command);
 
 void ps2_end_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_unlock_chip();</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	mutex_unlock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	mutex_unlock(m);</span>
 }
 EXPORT_SYMBOL(ps2_end_command);
 
<span class="p_header">diff --git a/drivers/iommu/arm-smmu-v3.c b/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_header">index 8487987458a1..00df3832faab 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_chunk">@@ -870,7 +870,7 @@</span> <span class="p_context"> static void arm_smmu_cmdq_skip_err(struct arm_smmu_device *smmu)</span>
 	 * We may have concurrent producers, so we need to be careful
 	 * not to touch any of the shadow cmdq state.
 	 */
<span class="p_del">-	queue_read(cmd, Q_ENT(q, idx), q-&gt;ent_dwords);</span>
<span class="p_add">+	queue_read(cmd, Q_ENT(q, cons), q-&gt;ent_dwords);</span>
 	dev_err(smmu-&gt;dev, &quot;skipping command in error state:\n&quot;);
 	for (i = 0; i &lt; ARRAY_SIZE(cmd); ++i)
 		dev_err(smmu-&gt;dev, &quot;\t0x%016llx\n&quot;, (unsigned long long)cmd[i]);
<span class="p_chunk">@@ -881,7 +881,7 @@</span> <span class="p_context"> static void arm_smmu_cmdq_skip_err(struct arm_smmu_device *smmu)</span>
 		return;
 	}
 
<span class="p_del">-	queue_write(cmd, Q_ENT(q, idx), q-&gt;ent_dwords);</span>
<span class="p_add">+	queue_write(Q_ENT(q, cons), cmd, q-&gt;ent_dwords);</span>
 }
 
 static void arm_smmu_cmdq_issue_cmd(struct arm_smmu_device *smmu,
<span class="p_chunk">@@ -1025,6 +1025,9 @@</span> <span class="p_context"> static void arm_smmu_write_strtab_ent(struct arm_smmu_device *smmu, u32 sid,</span>
 		case STRTAB_STE_0_CFG_S2_TRANS:
 			ste_live = true;
 			break;
<span class="p_add">+		case STRTAB_STE_0_CFG_ABORT:</span>
<span class="p_add">+			if (disable_bypass)</span>
<span class="p_add">+				break;</span>
 		default:
 			BUG(); /* STE corruption */
 		}
<span class="p_header">diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c</span>
<span class="p_header">index 58f2fe687a24..347a3c17f73a 100644</span>
<span class="p_header">--- a/drivers/iommu/dma-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/dma-iommu.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> void iommu_put_dma_cookie(struct iommu_domain *domain)</span>
 	if (!iovad)
 		return;
 
<span class="p_del">-	put_iova_domain(iovad);</span>
<span class="p_add">+	if (iovad-&gt;granule)</span>
<span class="p_add">+		put_iova_domain(iovad);</span>
 	kfree(iovad);
 	domain-&gt;iova_cookie = NULL;
 }
<span class="p_header">diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig</span>
<span class="p_header">index 1dee533634c9..2e6d2fff1096 100644</span>
<span class="p_header">--- a/drivers/mmc/host/Kconfig</span>
<span class="p_header">+++ b/drivers/mmc/host/Kconfig</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> config MMC_RICOH_MMC</span>
 config MMC_SDHCI_ACPI
 	tristate &quot;SDHCI support for ACPI enumerated SDHCI controllers&quot;
 	depends on MMC_SDHCI &amp;&amp; ACPI
<span class="p_add">+	select IOSF_MBI if X86</span>
 	help
 	  This selects support for ACPI enumerated SDHCI controllers,
 	  identified by ACPI Compatibility ID PNP0D40 or specific
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-acpi.c b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">index 8aea3fa6938b..5a05bf400ca8 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-acpi.c</span>
<span class="p_chunk">@@ -41,6 +41,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/mmc/pm.h&gt;
 #include &lt;linux/mmc/slot-gpio.h&gt;
 
<span class="p_add">+#ifdef CONFIG_X86</span>
<span class="p_add">+#include &lt;asm/cpu_device_id.h&gt;</span>
<span class="p_add">+#include &lt;asm/iosf_mbi.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #include &quot;sdhci.h&quot;
 
 enum {
<span class="p_chunk">@@ -146,6 +151,75 @@</span> <span class="p_context"> static const struct sdhci_acpi_chip sdhci_acpi_chip_int = {</span>
 	.ops = &amp;sdhci_acpi_ops_int,
 };
 
<span class="p_add">+#ifdef CONFIG_X86</span>
<span class="p_add">+</span>
<span class="p_add">+static bool sdhci_acpi_byt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static const struct x86_cpu_id byt[] = {</span>
<span class="p_add">+		{ X86_VENDOR_INTEL, 6, 0x37 },</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	return x86_match_cpu(byt);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define BYT_IOSF_SCCEP			0x63</span>
<span class="p_add">+#define BYT_IOSF_OCP_NETCTRL0		0x1078</span>
<span class="p_add">+#define BYT_IOSF_OCP_TIMEOUT_BASE	GENMASK(10, 8)</span>
<span class="p_add">+</span>
<span class="p_add">+static void sdhci_acpi_byt_setting(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!sdhci_acpi_byt())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iosf_mbi_read(BYT_IOSF_SCCEP, 0x06, BYT_IOSF_OCP_NETCTRL0,</span>
<span class="p_add">+			  &amp;val)) {</span>
<span class="p_add">+		dev_err(dev, &quot;%s read error\n&quot;, __func__);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(val &amp; BYT_IOSF_OCP_TIMEOUT_BASE))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	val &amp;= ~BYT_IOSF_OCP_TIMEOUT_BASE;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iosf_mbi_write(BYT_IOSF_SCCEP, 0x07, BYT_IOSF_OCP_NETCTRL0,</span>
<span class="p_add">+			   val)) {</span>
<span class="p_add">+		dev_err(dev, &quot;%s write error\n&quot;, __func__);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(dev, &quot;%s completed\n&quot;, __func__);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool sdhci_acpi_byt_defer(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!sdhci_acpi_byt())</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iosf_mbi_available())</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	sdhci_acpi_byt_setting(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#else</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void sdhci_acpi_byt_setting(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool sdhci_acpi_byt_defer(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int bxt_get_cd(struct mmc_host *mmc)
 {
 	int gpio_cd = mmc_gpio_get_cd(mmc);
<span class="p_chunk">@@ -337,6 +411,9 @@</span> <span class="p_context"> static int sdhci_acpi_probe(struct platform_device *pdev)</span>
 	if (acpi_bus_get_status(device) || !device-&gt;status.present)
 		return -ENODEV;
 
<span class="p_add">+	if (sdhci_acpi_byt_defer(dev))</span>
<span class="p_add">+		return -EPROBE_DEFER;</span>
<span class="p_add">+</span>
 	hid = acpi_device_hid(device);
 	uid = device-&gt;pnp.unique_id;
 
<span class="p_chunk">@@ -460,6 +537,8 @@</span> <span class="p_context"> static int sdhci_acpi_resume(struct device *dev)</span>
 {
 	struct sdhci_acpi_host *c = dev_get_drvdata(dev);
 
<span class="p_add">+	sdhci_acpi_byt_setting(&amp;c-&gt;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	return sdhci_resume_host(c-&gt;host);
 }
 
<span class="p_chunk">@@ -483,6 +562,8 @@</span> <span class="p_context"> static int sdhci_acpi_runtime_resume(struct device *dev)</span>
 {
 	struct sdhci_acpi_host *c = dev_get_drvdata(dev);
 
<span class="p_add">+	sdhci_acpi_byt_setting(&amp;c-&gt;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	return sdhci_runtime_resume_host(c-&gt;host);
 }
 
<span class="p_header">diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c</span>
<span class="p_header">index 0c67b57be83c..289a5df0d44a 100644</span>
<span class="p_header">--- a/drivers/nvme/host/pci.c</span>
<span class="p_header">+++ b/drivers/nvme/host/pci.c</span>
<span class="p_chunk">@@ -2672,10 +2672,10 @@</span> <span class="p_context"> static int nvme_dev_add(struct nvme_dev *dev)</span>
 	return 0;
 }
 
<span class="p_del">-static int nvme_dev_map(struct nvme_dev *dev)</span>
<span class="p_add">+static int nvme_pci_enable(struct nvme_dev *dev)</span>
 {
 	u64 cap;
<span class="p_del">-	int bars, result = -ENOMEM;</span>
<span class="p_add">+	int result = -ENOMEM;</span>
 	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
 
 	if (pci_enable_device_mem(pdev))
<span class="p_chunk">@@ -2683,24 +2683,14 @@</span> <span class="p_context"> static int nvme_dev_map(struct nvme_dev *dev)</span>
 
 	dev-&gt;entry[0].vector = pdev-&gt;irq;
 	pci_set_master(pdev);
<span class="p_del">-	bars = pci_select_bars(pdev, IORESOURCE_MEM);</span>
<span class="p_del">-	if (!bars)</span>
<span class="p_del">-		goto disable_pci;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pci_request_selected_regions(pdev, bars, &quot;nvme&quot;))</span>
<span class="p_del">-		goto disable_pci;</span>
 
 	if (dma_set_mask_and_coherent(dev-&gt;dev, DMA_BIT_MASK(64)) &amp;&amp;
 	    dma_set_mask_and_coherent(dev-&gt;dev, DMA_BIT_MASK(32)))
 		goto disable;
 
<span class="p_del">-	dev-&gt;bar = ioremap(pci_resource_start(pdev, 0), 8192);</span>
<span class="p_del">-	if (!dev-&gt;bar)</span>
<span class="p_del">-		goto disable;</span>
<span class="p_del">-</span>
 	if (readl(&amp;dev-&gt;bar-&gt;csts) == -1) {
 		result = -ENODEV;
<span class="p_del">-		goto unmap;</span>
<span class="p_add">+		goto disable;</span>
 	}
 
 	/*
<span class="p_chunk">@@ -2710,7 +2700,7 @@</span> <span class="p_context"> static int nvme_dev_map(struct nvme_dev *dev)</span>
 	if (!pdev-&gt;irq) {
 		result = pci_enable_msix(pdev, dev-&gt;entry, 1);
 		if (result &lt; 0)
<span class="p_del">-			goto unmap;</span>
<span class="p_add">+			goto disable;</span>
 	}
 
 	cap = lo_hi_readq(&amp;dev-&gt;bar-&gt;cap);
<span class="p_chunk">@@ -2734,18 +2724,21 @@</span> <span class="p_context"> static int nvme_dev_map(struct nvme_dev *dev)</span>
 
 	return 0;
 
<span class="p_del">- unmap:</span>
<span class="p_del">-	iounmap(dev-&gt;bar);</span>
<span class="p_del">-	dev-&gt;bar = NULL;</span>
  disable:
 	pci_release_regions(pdev);
<span class="p_del">- disable_pci:</span>
<span class="p_del">-	pci_disable_device(pdev);</span>
<span class="p_add">+</span>
 	return result;
 }
 
 static void nvme_dev_unmap(struct nvme_dev *dev)
 {
<span class="p_add">+	if (dev-&gt;bar)</span>
<span class="p_add">+		iounmap(dev-&gt;bar);</span>
<span class="p_add">+	pci_release_regions(to_pci_dev(dev-&gt;dev));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void nvme_pci_disable(struct nvme_dev *dev)</span>
<span class="p_add">+{</span>
 	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);
 
 	if (pdev-&gt;msi_enabled)
<span class="p_chunk">@@ -2753,12 +2746,6 @@</span> <span class="p_context"> static void nvme_dev_unmap(struct nvme_dev *dev)</span>
 	else if (pdev-&gt;msix_enabled)
 		pci_disable_msix(pdev);
 
<span class="p_del">-	if (dev-&gt;bar) {</span>
<span class="p_del">-		iounmap(dev-&gt;bar);</span>
<span class="p_del">-		dev-&gt;bar = NULL;</span>
<span class="p_del">-		pci_release_regions(pdev);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (pci_is_enabled(pdev))
 		pci_disable_device(pdev);
 }
<span class="p_chunk">@@ -2962,7 +2949,7 @@</span> <span class="p_context"> static void nvme_dev_shutdown(struct nvme_dev *dev)</span>
 
 	nvme_dev_list_remove(dev);
 
<span class="p_del">-	if (dev-&gt;bar) {</span>
<span class="p_add">+	if (pci_is_enabled(to_pci_dev(dev-&gt;dev))) {</span>
 		nvme_freeze_queues(dev);
 		csts = readl(&amp;dev-&gt;bar-&gt;csts);
 	}
<span class="p_chunk">@@ -2976,7 +2963,7 @@</span> <span class="p_context"> static void nvme_dev_shutdown(struct nvme_dev *dev)</span>
 		nvme_shutdown_ctrl(dev);
 		nvme_disable_queue(dev, 0);
 	}
<span class="p_del">-	nvme_dev_unmap(dev);</span>
<span class="p_add">+	nvme_pci_disable(dev);</span>
 
 	for (i = dev-&gt;queue_count - 1; i &gt;= 0; i--)
 		nvme_clear_queue(dev-&gt;queues[i]);
<span class="p_chunk">@@ -3136,7 +3123,7 @@</span> <span class="p_context"> static void nvme_probe_work(struct work_struct *work)</span>
 	bool start_thread = false;
 	int result;
 
<span class="p_del">-	result = nvme_dev_map(dev);</span>
<span class="p_add">+	result = nvme_pci_enable(dev);</span>
 	if (result)
 		goto out;
 
<span class="p_chunk">@@ -3292,6 +3279,27 @@</span> <span class="p_context"> static ssize_t nvme_sysfs_reset(struct device *dev,</span>
 }
 static DEVICE_ATTR(reset_controller, S_IWUSR, NULL, nvme_sysfs_reset);
 
<span class="p_add">+static int nvme_dev_map(struct nvme_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int bars;</span>
<span class="p_add">+	struct pci_dev *pdev = to_pci_dev(dev-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	bars = pci_select_bars(pdev, IORESOURCE_MEM);</span>
<span class="p_add">+	if (!bars)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	if (pci_request_selected_regions(pdev, bars, &quot;nvme&quot;))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;bar = ioremap(pci_resource_start(pdev, 0), 8192);</span>
<span class="p_add">+	if (!dev-&gt;bar)</span>
<span class="p_add">+		goto release;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+release:</span>
<span class="p_add">+	pci_release_regions(pdev);</span>
<span class="p_add">+	return -ENODEV;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	int node, result = -ENOMEM;
<span class="p_chunk">@@ -3317,6 +3325,11 @@</span> <span class="p_context"> static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 	INIT_WORK(&amp;dev-&gt;reset_work, nvme_reset_work);
 	dev-&gt;dev = get_device(&amp;pdev-&gt;dev);
 	pci_set_drvdata(pdev, dev);
<span class="p_add">+</span>
<span class="p_add">+	result = nvme_dev_map(dev);</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		goto free;</span>
<span class="p_add">+</span>
 	result = nvme_set_instance(dev);
 	if (result)
 		goto put_pci;
<span class="p_chunk">@@ -3355,6 +3368,7 @@</span> <span class="p_context"> static int nvme_probe(struct pci_dev *pdev, const struct pci_device_id *id)</span>
 	nvme_release_instance(dev);
  put_pci:
 	put_device(dev-&gt;dev);
<span class="p_add">+	nvme_dev_unmap(dev);</span>
  free:
 	kfree(dev-&gt;queues);
 	kfree(dev-&gt;entry);
<span class="p_chunk">@@ -3398,6 +3412,7 @@</span> <span class="p_context"> static void nvme_remove(struct pci_dev *pdev)</span>
 	nvme_free_queues(dev, 0);
 	nvme_release_cmb(dev);
 	nvme_release_prp_pools(dev);
<span class="p_add">+	nvme_dev_unmap(dev);</span>
 	kref_put(&amp;dev-&gt;kref, nvme_free_dev);
 }
 
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 942461f36616..31341290cd91 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -2253,20 +2253,13 @@</span> <span class="p_context"> struct device_node *of_graph_get_endpoint_by_regs(</span>
 	const struct device_node *parent, int port_reg, int reg)
 {
 	struct of_endpoint endpoint;
<span class="p_del">-	struct device_node *node, *prev_node = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (1) {</span>
<span class="p_del">-		node = of_graph_get_next_endpoint(parent, prev_node);</span>
<span class="p_del">-		of_node_put(prev_node);</span>
<span class="p_del">-		if (!node)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	struct device_node *node = NULL;</span>
 
<span class="p_add">+	for_each_endpoint_of_node(parent, node) {</span>
 		of_graph_parse_endpoint(node, &amp;endpoint);
 		if (((port_reg == -1) || (endpoint.port == port_reg)) &amp;&amp;
 			((reg == -1) || (endpoint.id == reg)))
 			return node;
<span class="p_del">-</span>
<span class="p_del">-		prev_node = node;</span>
 	}
 
 	return NULL;
<span class="p_header">diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c</span>
<span class="p_header">index 7eaa4c87fec7..10a6a8e5db88 100644</span>
<span class="p_header">--- a/drivers/pci/msi.c</span>
<span class="p_header">+++ b/drivers/pci/msi.c</span>
<span class="p_chunk">@@ -1278,6 +1278,8 @@</span> <span class="p_context"> struct irq_domain *pci_msi_create_irq_domain(struct fwnode_handle *fwnode,</span>
 	if (info-&gt;flags &amp; MSI_FLAG_USE_DEF_CHIP_OPS)
 		pci_msi_domain_update_chip_ops(info);
 
<span class="p_add">+	info-&gt;flags |= MSI_FLAG_ACTIVATE_EARLY;</span>
<span class="p_add">+</span>
 	domain = msi_create_irq_domain(fwnode, info, parent);
 	if (!domain)
 		return NULL;
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index eead54cd01b2..d7508704c992 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -1372,10 +1372,10 @@</span> <span class="p_context"> int __must_check pci_create_sysfs_dev_files(struct pci_dev *pdev)</span>
 	if (!sysfs_initialized)
 		return -EACCES;
 
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		retval = sysfs_create_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 	if (retval)
 		goto err;
 
<span class="p_chunk">@@ -1427,10 +1427,10 @@</span> <span class="p_context"> err_rom_file:</span>
 err_resource_files:
 	pci_remove_resource_files(pdev);
 err_config_file:
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 err:
 	return retval;
 }
<span class="p_chunk">@@ -1464,10 +1464,10 @@</span> <span class="p_context"> void pci_remove_sysfs_dev_files(struct pci_dev *pdev)</span>
 
 	pci_remove_capabilities_sysfs(pdev);
 
<span class="p_del">-	if (pdev-&gt;cfg_size &lt; PCI_CFG_SPACE_EXP_SIZE)</span>
<span class="p_del">-		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (pdev-&gt;cfg_size &gt; PCI_CFG_SPACE_SIZE)</span>
 		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pcie_config_attr);
<span class="p_add">+	else</span>
<span class="p_add">+		sysfs_remove_bin_file(&amp;pdev-&gt;dev.kobj, &amp;pci_config_attr);</span>
 
 	pci_remove_resource_files(pdev);
 
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 3c4752a288e2..42774bc39786 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -287,6 +287,18 @@</span> <span class="p_context"> static void quirk_citrine(struct pci_dev *dev)</span>
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_IBM,	PCI_DEVICE_ID_IBM_CITRINE,	quirk_citrine);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This chip can cause bus lockups if config addresses above 0x600</span>
<span class="p_add">+ * are read or written.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void quirk_nfp6000(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dev-&gt;cfg_size = 0x600;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP4000,	quirk_nfp6000);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000,	quirk_nfp6000);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETRONOME,	PCI_DEVICE_ID_NETRONOME_NFP6000_VF,	quirk_nfp6000);</span>
<span class="p_add">+</span>
 /*  On IBM Crocodile ipr SAS adapters, expand BAR to system page size */
 static void quirk_extend_bar_to_page(struct pci_dev *dev)
 {
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-amd.c b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">index 3318f1d6193c..7340ff78839a 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_chunk">@@ -48,17 +48,6 @@</span> <span class="p_context"> static int amd_gpio_direction_input(struct gpio_chip *gc, unsigned offset)</span>
 
 	spin_lock_irqsave(&amp;gpio_dev-&gt;lock, flags);
 	pin_reg = readl(gpio_dev-&gt;base + offset * 4);
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Suppose BIOS or Bootloader sets specific debounce for the</span>
<span class="p_del">-	 * GPIO. if not, set debounce to be  2.75ms and remove glitch.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	if ((pin_reg &amp; DB_TMR_OUT_MASK) == 0) {</span>
<span class="p_del">-		pin_reg |= 0xf;</span>
<span class="p_del">-		pin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);</span>
<span class="p_del">-		pin_reg |= DB_TYPE_REMOVE_GLITCH &lt;&lt; DB_CNTRL_OFF;</span>
<span class="p_del">-		pin_reg &amp;= ~BIT(DB_TMR_LARGE_OFF);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	pin_reg &amp;= ~BIT(OUTPUT_ENABLE_OFF);
 	writel(pin_reg, gpio_dev-&gt;base + offset * 4);
 	spin_unlock_irqrestore(&amp;gpio_dev-&gt;lock, flags);
<span class="p_chunk">@@ -331,15 +320,6 @@</span> <span class="p_context"> static void amd_gpio_irq_enable(struct irq_data *d)</span>
 
 	spin_lock_irqsave(&amp;gpio_dev-&gt;lock, flags);
 	pin_reg = readl(gpio_dev-&gt;base + (d-&gt;hwirq)*4);
<span class="p_del">-	/*</span>
<span class="p_del">-		Suppose BIOS or Bootloader sets specific debounce for the</span>
<span class="p_del">-		GPIO. if not, set debounce to be  2.75ms.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	if ((pin_reg &amp; DB_TMR_OUT_MASK) == 0) {</span>
<span class="p_del">-		pin_reg |= 0xf;</span>
<span class="p_del">-		pin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);</span>
<span class="p_del">-		pin_reg &amp;= ~BIT(DB_TMR_LARGE_OFF);</span>
<span class="p_del">-	}</span>
 	pin_reg |= BIT(INTERRUPT_ENABLE_OFF);
 	pin_reg |= BIT(INTERRUPT_MASK_OFF);
 	writel(pin_reg, gpio_dev-&gt;base + (d-&gt;hwirq)*4);
<span class="p_header">diff --git a/drivers/platform/chrome/cros_ec_proto.c b/drivers/platform/chrome/cros_ec_proto.c</span>
<span class="p_header">index 990308ca384f..92430f781eb7 100644</span>
<span class="p_header">--- a/drivers/platform/chrome/cros_ec_proto.c</span>
<span class="p_header">+++ b/drivers/platform/chrome/cros_ec_proto.c</span>
<span class="p_chunk">@@ -380,3 +380,20 @@</span> <span class="p_context"> int cros_ec_cmd_xfer(struct cros_ec_device *ec_dev,</span>
 	return ret;
 }
 EXPORT_SYMBOL(cros_ec_cmd_xfer);
<span class="p_add">+</span>
<span class="p_add">+int cros_ec_cmd_xfer_status(struct cros_ec_device *ec_dev,</span>
<span class="p_add">+			    struct cros_ec_command *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = cros_ec_cmd_xfer(ec_dev, msg);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_err(ec_dev-&gt;dev, &quot;Command xfer error (err:%d)\n&quot;, ret);</span>
<span class="p_add">+	} else if (msg-&gt;result != EC_RES_SUCCESS) {</span>
<span class="p_add">+		dev_dbg(ec_dev-&gt;dev, &quot;Command result (err: %d)\n&quot;, msg-&gt;result);</span>
<span class="p_add">+		return -EPROTO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(cros_ec_cmd_xfer_status);</span>
<span class="p_header">diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c</span>
<span class="p_header">index 4abfbdb285ec..84c13dffa3a8 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd.c</span>
<span class="p_chunk">@@ -1584,9 +1584,18 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	unsigned long long now;
 	int expires;
 
<span class="p_add">+	cqr = (struct dasd_ccw_req *) intparm;</span>
 	if (IS_ERR(irb)) {
 		switch (PTR_ERR(irb)) {
 		case -EIO:
<span class="p_add">+			if (cqr &amp;&amp; cqr-&gt;status == DASD_CQR_CLEAR_PENDING) {</span>
<span class="p_add">+				device = (struct dasd_device *) cqr-&gt;startdev;</span>
<span class="p_add">+				cqr-&gt;status = DASD_CQR_CLEARED;</span>
<span class="p_add">+				dasd_device_clear_timer(device);</span>
<span class="p_add">+				wake_up(&amp;dasd_flush_wq);</span>
<span class="p_add">+				dasd_schedule_device_bh(device);</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			}</span>
 			break;
 		case -ETIMEDOUT:
 			DBF_EVENT_DEVID(DBF_WARNING, cdev, &quot;%s: &quot;
<span class="p_chunk">@@ -1602,7 +1611,6 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	}
 
 	now = get_tod_clock();
<span class="p_del">-	cqr = (struct dasd_ccw_req *) intparm;</span>
 	/* check for conditions that should be handled immediately */
 	if (!cqr ||
 	    !(scsw_dstat(&amp;irb-&gt;scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &amp;&amp;
<span class="p_header">diff --git a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">index 54195a117f72..f78cc943d230 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	struct fib *fibptr;
 	struct hw_fib * hw_fib = (struct hw_fib *)0;
 	dma_addr_t hw_fib_pa = (dma_addr_t)0LL;
<span class="p_del">-	unsigned size;</span>
<span class="p_add">+	unsigned int size, osize;</span>
 	int retval;
 
 	if (dev-&gt;in_reset) {
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	 *	will not overrun the buffer when we copy the memory. Return
 	 *	an error if we would.
 	 */
<span class="p_del">-	size = le16_to_cpu(kfib-&gt;header.Size) + sizeof(struct aac_fibhdr);</span>
<span class="p_add">+	osize = size = le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr);</span>
 	if (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))
 		size = le16_to_cpu(kfib-&gt;header.SenderSize);
 	if (size &gt; dev-&gt;max_fib_size) {
<span class="p_chunk">@@ -118,6 +119,14 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	/* Sanity check the second copy */</span>
<span class="p_add">+	if ((osize != le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr))</span>
<span class="p_add">+		|| (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))) {</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+		goto cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (kfib-&gt;header.Command == cpu_to_le16(TakeABreakPt)) {
 		aac_adapter_interrupt(dev);
 		/*
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 00ce3e269a43..e994ff944091 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -4669,7 +4669,7 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 	/* Find first memory bar */
 	bar_list = pci_select_bars(instance-&gt;pdev, IORESOURCE_MEM);
 	instance-&gt;bar = find_first_bit(&amp;bar_list, sizeof(unsigned long));
<span class="p_del">-	if (pci_request_selected_regions(instance-&gt;pdev, instance-&gt;bar,</span>
<span class="p_add">+	if (pci_request_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar,</span>
 					 &quot;megasas: LSI&quot;)) {
 		dev_printk(KERN_DEBUG, &amp;instance-&gt;pdev-&gt;dev, &quot;IO memory region busy!\n&quot;);
 		return -EBUSY;
<span class="p_chunk">@@ -4960,7 +4960,7 @@</span> <span class="p_context"> fail_ready_state:</span>
 	iounmap(instance-&gt;reg_set);
 
       fail_ioremap:
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 
 	return -EINVAL;
 }
<span class="p_chunk">@@ -4981,7 +4981,7 @@</span> <span class="p_context"> static void megasas_release_mfi(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 8d630a552b07..4f391e747be2 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -2437,7 +2437,7 @@</span> <span class="p_context"> megasas_release_fusion(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">index 11393ebf1a68..356233f86064 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_chunk">@@ -2155,6 +2155,17 @@</span> <span class="p_context"> mpt3sas_base_map_resources(struct MPT3SAS_ADAPTER *ioc)</span>
 	} else
 		ioc-&gt;msix96_vector = 0;
 
<span class="p_add">+	if (ioc-&gt;is_warpdrive) {</span>
<span class="p_add">+		ioc-&gt;reply_post_host_index[0] = (resource_size_t __iomem *)</span>
<span class="p_add">+		    &amp;ioc-&gt;chip-&gt;ReplyPostHostIndex;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 1; i &lt; ioc-&gt;cpu_msix_table_sz; i++)</span>
<span class="p_add">+			ioc-&gt;reply_post_host_index[i] =</span>
<span class="p_add">+			(resource_size_t __iomem *)</span>
<span class="p_add">+			((u8 __iomem *)&amp;ioc-&gt;chip-&gt;Doorbell + (0x4000 + ((i - 1)</span>
<span class="p_add">+			* 4)));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_for_each_entry(reply_q, &amp;ioc-&gt;reply_queue_list, list)
 		pr_info(MPT3SAS_FMT &quot;%s: IRQ %d\n&quot;,
 		    reply_q-&gt;name,  ((ioc-&gt;msix_enable) ? &quot;PCI-MSI-X enabled&quot; :
<span class="p_chunk">@@ -5201,17 +5212,6 @@</span> <span class="p_context"> mpt3sas_base_attach(struct MPT3SAS_ADAPTER *ioc)</span>
 	if (r)
 		goto out_free_resources;
 
<span class="p_del">-	if (ioc-&gt;is_warpdrive) {</span>
<span class="p_del">-		ioc-&gt;reply_post_host_index[0] = (resource_size_t __iomem *)</span>
<span class="p_del">-		    &amp;ioc-&gt;chip-&gt;ReplyPostHostIndex;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (i = 1; i &lt; ioc-&gt;cpu_msix_table_sz; i++)</span>
<span class="p_del">-			ioc-&gt;reply_post_host_index[i] =</span>
<span class="p_del">-			(resource_size_t __iomem *)</span>
<span class="p_del">-			((u8 __iomem *)&amp;ioc-&gt;chip-&gt;Doorbell + (0x4000 + ((i - 1)</span>
<span class="p_del">-			* 4)));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	pci_set_drvdata(ioc-&gt;pdev, ioc-&gt;shost);
 	r = _base_get_ioc_facts(ioc, CAN_SLEEP);
 	if (r)
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/comedi_test.c b/drivers/staging/comedi/drivers/comedi_test.c</span>
<span class="p_header">index 4ab186669f0c..ec5b9a23494d 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/comedi_test.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/comedi_test.c</span>
<span class="p_chunk">@@ -56,11 +56,6 @@</span> <span class="p_context"></span>
 
 #define N_CHANS 8
 
<span class="p_del">-enum waveform_state_bits {</span>
<span class="p_del">-	WAVEFORM_AI_RUNNING,</span>
<span class="p_del">-	WAVEFORM_AO_RUNNING</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /* Data unique to this driver */
 struct waveform_private {
 	struct timer_list ai_timer;	/* timer for AI commands */
<span class="p_chunk">@@ -68,7 +63,6 @@</span> <span class="p_context"> struct waveform_private {</span>
 	unsigned int wf_amplitude;	/* waveform amplitude in microvolts */
 	unsigned int wf_period;		/* waveform period in microseconds */
 	unsigned int wf_current;	/* current time in waveform period */
<span class="p_del">-	unsigned long state_bits;</span>
 	unsigned int ai_scan_period;	/* AI scan period in usec */
 	unsigned int ai_convert_period;	/* AI conversion period in usec */
 	struct timer_list ao_timer;	/* timer for AO commands */
<span class="p_chunk">@@ -191,10 +185,6 @@</span> <span class="p_context"> static void waveform_ai_timer(unsigned long arg)</span>
 	unsigned int nsamples;
 	unsigned int time_increment;
 
<span class="p_del">-	/* check command is still active */</span>
<span class="p_del">-	if (!test_bit(WAVEFORM_AI_RUNNING, &amp;devpriv-&gt;state_bits))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	now = ktime_to_us(ktime_get());
 	nsamples = comedi_nsamples_left(s, UINT_MAX);
 
<span class="p_chunk">@@ -386,11 +376,6 @@</span> <span class="p_context"> static int waveform_ai_cmd(struct comedi_device *dev,</span>
 	 */
 	devpriv-&gt;ai_timer.expires =
 		jiffies + usecs_to_jiffies(devpriv-&gt;ai_convert_period) + 1;
<span class="p_del">-</span>
<span class="p_del">-	/* mark command as active */</span>
<span class="p_del">-	smp_mb__before_atomic();</span>
<span class="p_del">-	set_bit(WAVEFORM_AI_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
 	add_timer(&amp;devpriv-&gt;ai_timer);
 	return 0;
 }
<span class="p_chunk">@@ -400,11 +385,12 @@</span> <span class="p_context"> static int waveform_ai_cancel(struct comedi_device *dev,</span>
 {
 	struct waveform_private *devpriv = dev-&gt;private;
 
<span class="p_del">-	/* mark command as no longer active */</span>
<span class="p_del">-	clear_bit(WAVEFORM_AI_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
<span class="p_del">-	/* cannot call del_timer_sync() as may be called from timer routine */</span>
<span class="p_del">-	del_timer(&amp;devpriv-&gt;ai_timer);</span>
<span class="p_add">+	if (in_softirq()) {</span>
<span class="p_add">+		/* Assume we were called from the timer routine itself. */</span>
<span class="p_add">+		del_timer(&amp;devpriv-&gt;ai_timer);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		del_timer_sync(&amp;devpriv-&gt;ai_timer);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -436,10 +422,6 @@</span> <span class="p_context"> static void waveform_ao_timer(unsigned long arg)</span>
 	u64 scans_since;
 	unsigned int scans_avail = 0;
 
<span class="p_del">-	/* check command is still active */</span>
<span class="p_del">-	if (!test_bit(WAVEFORM_AO_RUNNING, &amp;devpriv-&gt;state_bits))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	/* determine number of scan periods since last time */
 	now = ktime_to_us(ktime_get());
 	scans_since = now - devpriv-&gt;ao_last_scan_time;
<span class="p_chunk">@@ -518,11 +500,6 @@</span> <span class="p_context"> static int waveform_ao_inttrig_start(struct comedi_device *dev,</span>
 	devpriv-&gt;ao_last_scan_time = ktime_to_us(ktime_get());
 	devpriv-&gt;ao_timer.expires =
 		jiffies + usecs_to_jiffies(devpriv-&gt;ao_scan_period);
<span class="p_del">-</span>
<span class="p_del">-	/* mark command as active */</span>
<span class="p_del">-	smp_mb__before_atomic();</span>
<span class="p_del">-	set_bit(WAVEFORM_AO_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
 	add_timer(&amp;devpriv-&gt;ao_timer);
 
 	return 1;
<span class="p_chunk">@@ -608,11 +585,12 @@</span> <span class="p_context"> static int waveform_ao_cancel(struct comedi_device *dev,</span>
 	struct waveform_private *devpriv = dev-&gt;private;
 
 	s-&gt;async-&gt;inttrig = NULL;
<span class="p_del">-	/* mark command as no longer active */</span>
<span class="p_del">-	clear_bit(WAVEFORM_AO_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
<span class="p_del">-	/* cannot call del_timer_sync() as may be called from timer routine */</span>
<span class="p_del">-	del_timer(&amp;devpriv-&gt;ao_timer);</span>
<span class="p_add">+	if (in_softirq()) {</span>
<span class="p_add">+		/* Assume we were called from the timer routine itself. */</span>
<span class="p_add">+		del_timer(&amp;devpriv-&gt;ao_timer);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		del_timer_sync(&amp;devpriv-&gt;ao_timer);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/daqboard2000.c b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">index 57ab6680e3ae..e5fee6e0fb47 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_chunk">@@ -636,7 +636,7 @@</span> <span class="p_context"> static const void *daqboard2000_find_boardinfo(struct comedi_device *dev,</span>
 	const struct daq200_boardtype *board;
 	int i;
 
<span class="p_del">-	if (pcidev-&gt;subsystem_device != PCI_VENDOR_ID_IOTECH)</span>
<span class="p_add">+	if (pcidev-&gt;subsystem_vendor != PCI_VENDOR_ID_IOTECH)</span>
 		return NULL;
 
 	for (i = 0; i &lt; ARRAY_SIZE(boardtypes); i++) {
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">index 27fbf1a81097..35ab4a9ef95d 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_chunk">@@ -2823,7 +2823,15 @@</span> <span class="p_context"> static int ni_ao_inttrig(struct comedi_device *dev,</span>
 	int i;
 	static const int timeout = 1000;
 
<span class="p_del">-	if (trig_num != cmd-&gt;start_arg)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Require trig_num == cmd-&gt;start_arg when cmd-&gt;start_src == TRIG_INT.</span>
<span class="p_add">+	 * For backwards compatibility, also allow trig_num == 0 when</span>
<span class="p_add">+	 * cmd-&gt;start_src != TRIG_INT (i.e. when cmd-&gt;start_src == TRIG_EXT);</span>
<span class="p_add">+	 * in that case, the internal trigger is being used as a pre-trigger</span>
<span class="p_add">+	 * before the external trigger.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(trig_num == cmd-&gt;start_arg ||</span>
<span class="p_add">+	      (trig_num == 0 &amp;&amp; cmd-&gt;start_src != TRIG_INT)))</span>
 		return -EINVAL;
 
 	/* Null trig at beginning prevent ao start trigger from executing more than
<span class="p_chunk">@@ -5346,7 +5354,7 @@</span> <span class="p_context"> static int ni_E_init(struct comedi_device *dev,</span>
 		s-&gt;maxdata	= (devpriv-&gt;is_m_series) ? 0xffffffff
 							 : 0x00ffffff;
 		s-&gt;insn_read	= ni_tio_insn_read;
<span class="p_del">-		s-&gt;insn_write	= ni_tio_insn_read;</span>
<span class="p_add">+		s-&gt;insn_write	= ni_tio_insn_write;</span>
 		s-&gt;insn_config	= ni_tio_insn_config;
 #ifdef PCIDMA
 		if (dev-&gt;irq &amp;&amp; devpriv-&gt;mite) {
<span class="p_header">diff --git a/drivers/usb/chipidea/udc.c b/drivers/usb/chipidea/udc.c</span>
<span class="p_header">index 391a1225b0ba..ca367b05e440 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/udc.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/udc.c</span>
<span class="p_chunk">@@ -1585,8 +1585,11 @@</span> <span class="p_context"> static int ci_udc_pullup(struct usb_gadget *_gadget, int is_on)</span>
 {
 	struct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);
 
<span class="p_del">-	/* Data+ pullup controlled by OTG state machine in OTG fsm mode */</span>
<span class="p_del">-	if (ci_otg_is_fsm_mode(ci))</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Data+ pullup controlled by OTG state machine in OTG fsm mode;</span>
<span class="p_add">+	 * and don&#39;t touch Data+ in host mode for dual role config.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ci_otg_is_fsm_mode(ci) || ci-&gt;role == CI_ROLE_HOST)</span>
 		return 0;
 
 	pm_runtime_get_sync(&amp;ci-&gt;gadget.dev);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index d37fdcc3143c..7f374369e539 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1336,7 +1336,6 @@</span> <span class="p_context"> made_compressed_probe:</span>
 	spin_lock_init(&amp;acm-&gt;write_lock);
 	spin_lock_init(&amp;acm-&gt;read_lock);
 	mutex_init(&amp;acm-&gt;mutex);
<span class="p_del">-	acm-&gt;rx_endpoint = usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress);</span>
 	acm-&gt;is_int_ep = usb_endpoint_xfer_int(epread);
 	if (acm-&gt;is_int_ep)
 		acm-&gt;bInterval = epread-&gt;bInterval;
<span class="p_chunk">@@ -1376,14 +1375,14 @@</span> <span class="p_context"> made_compressed_probe:</span>
 		urb-&gt;transfer_dma = rb-&gt;dma;
 		if (acm-&gt;is_int_ep) {
 			usb_fill_int_urb(urb, acm-&gt;dev,
<span class="p_del">-					 acm-&gt;rx_endpoint,</span>
<span class="p_add">+					 usb_rcvintpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					 rb-&gt;base,
 					 acm-&gt;readsize,
 					 acm_read_bulk_callback, rb,
 					 acm-&gt;bInterval);
 		} else {
 			usb_fill_bulk_urb(urb, acm-&gt;dev,
<span class="p_del">-					  acm-&gt;rx_endpoint,</span>
<span class="p_add">+					  usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					  rb-&gt;base,
 					  acm-&gt;readsize,
 					  acm_read_bulk_callback, rb);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index ccfaba9ab4e4..b30ac5fcde68 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -95,7 +95,6 @@</span> <span class="p_context"> struct acm {</span>
 	struct urb *read_urbs[ACM_NR];
 	struct acm_rb read_buffers[ACM_NR];
 	int rx_buflimit;
<span class="p_del">-	int rx_endpoint;</span>
 	spinlock_t read_lock;
 	int write_used;					/* number of non-empty write buffers */
 	int transmitting;
<span class="p_header">diff --git a/drivers/usb/common/common.c b/drivers/usb/common/common.c</span>
<span class="p_header">index 673d53038ed2..a00bfb93acc3 100644</span>
<span class="p_header">--- a/drivers/usb/common/common.c</span>
<span class="p_header">+++ b/drivers/usb/common/common.c</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> static const char *const speed_names[] = {</span>
 	[USB_SPEED_HIGH] = &quot;high-speed&quot;,
 	[USB_SPEED_WIRELESS] = &quot;wireless&quot;,
 	[USB_SPEED_SUPER] = &quot;super-speed&quot;,
<span class="p_add">+	[USB_SPEED_SUPER_PLUS] = &quot;super-speed-plus&quot;,</span>
 };
 
 const char *usb_speed_string(enum usb_device_speed speed)
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 5050760f5e17..80c8d90d8b75 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -142,6 +142,31 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 	}
 }
 
<span class="p_add">+static const unsigned short low_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 8,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 8,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short full_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1023,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 64,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short high_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short super_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
     int asnum, struct usb_host_interface *ifp, int num_ep,
     unsigned char *buffer, int size)
<span class="p_chunk">@@ -150,6 +175,8 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
<span class="p_add">+	unsigned int maxp;</span>
<span class="p_add">+	const unsigned short *maxpacket_maxes;</span>
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
<span class="p_chunk">@@ -191,6 +218,7 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	if (usb_endpoint_xfer_int(d)) {
 		i = 1;
 		switch (to_usb_device(ddev)-&gt;speed) {
<span class="p_add">+		case USB_SPEED_SUPER_PLUS:</span>
 		case USB_SPEED_SUPER:
 		case USB_SPEED_HIGH:
 			/* Many device manufacturers are using full-speed
<span class="p_chunk">@@ -256,6 +284,42 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
<span class="p_add">+	/* Validate the wMaxPacketSize field */</span>
<span class="p_add">+	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the highest legal maxpacket size for this endpoint */</span>
<span class="p_add">+	i = 0;		/* additional transactions per microframe */</span>
<span class="p_add">+	switch (to_usb_device(ddev)-&gt;speed) {</span>
<span class="p_add">+	case USB_SPEED_LOW:</span>
<span class="p_add">+		maxpacket_maxes = low_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_FULL:</span>
<span class="p_add">+		maxpacket_maxes = full_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_HIGH:</span>
<span class="p_add">+		/* Bits 12..11 are allowed only for HS periodic endpoints */</span>
<span class="p_add">+		if (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {</span>
<span class="p_add">+			i = maxp &amp; (BIT(12) | BIT(11));</span>
<span class="p_add">+			maxp &amp;= ~i;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* fallthrough */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		maxpacket_maxes = high_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_SUPER:</span>
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
<span class="p_add">+		maxpacket_maxes = super_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (maxp &gt; j) {</span>
<span class="p_add">+		dev_warn(ddev, &quot;config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n&quot;,</span>
<span class="p_add">+		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);</span>
<span class="p_add">+		maxp = j;</span>
<span class="p_add">+		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Some buggy high speed devices have bulk endpoints using
 	 * maxpacket sizes other than 512.  High speed HCDs may not
<span class="p_chunk">@@ -263,9 +327,6 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	 */
 	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_HIGH
 			&amp;&amp; usb_endpoint_xfer_bulk(d)) {
<span class="p_del">-		unsigned maxp;</span>
<span class="p_del">-</span>
<span class="p_del">-		maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc) &amp; 0x07ff;</span>
 		if (maxp != 512)
 			dev_warn(ddev, &quot;config %d interface %d altsetting %d &quot;
 				&quot;bulk endpoint 0x%X has invalid maxpacket %d\n&quot;,
<span class="p_chunk">@@ -274,7 +335,7 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	}
 
 	/* Parse a possible SuperSpeed endpoint companion descriptor */
<span class="p_del">-	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (to_usb_device(ddev)-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		usb_parse_ss_endpoint_companion(ddev, cfgno,
 				inum, asnum, endpoint, buffer, size);
 
<span class="p_header">diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c</span>
<span class="p_header">index 2a3bbdf7eb94..332ed277a06c 100644</span>
<span class="p_header">--- a/drivers/usb/core/devices.c</span>
<span class="p_header">+++ b/drivers/usb/core/devices.c</span>
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> static char *usb_dump_endpoint_descriptor(int speed, char *start, char *end,</span>
 		break;
 	case USB_ENDPOINT_XFER_INT:
 		type = &quot;Int.&quot;;
<span class="p_del">-		if (speed == USB_SPEED_HIGH || speed == USB_SPEED_SUPER)</span>
<span class="p_add">+		if (speed == USB_SPEED_HIGH || speed &gt;= USB_SPEED_SUPER)</span>
 			interval = 1 &lt;&lt; (desc-&gt;bInterval - 1);
 		else
 			interval = desc-&gt;bInterval;
<span class="p_chunk">@@ -230,7 +230,7 @@</span> <span class="p_context"> static char *usb_dump_endpoint_descriptor(int speed, char *start, char *end,</span>
 		return start;
 	}
 	interval *= (speed == USB_SPEED_HIGH ||
<span class="p_del">-		     speed == USB_SPEED_SUPER) ? 125 : 1000;</span>
<span class="p_add">+		     speed &gt;= USB_SPEED_SUPER) ? 125 : 1000;</span>
 	if (interval % 1000)
 		unit = &#39;u&#39;;
 	else {
<span class="p_chunk">@@ -322,7 +322,7 @@</span> <span class="p_context"> static char *usb_dump_config_descriptor(char *start, char *end,</span>
 
 	if (start &gt; end)
 		return start;
<span class="p_del">-	if (speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (speed &gt;= USB_SPEED_SUPER)</span>
 		mul = 8;
 	else
 		mul = 2;
<span class="p_chunk">@@ -534,6 +534,8 @@</span> <span class="p_context"> static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,</span>
 		speed = &quot;480&quot;; break;
 	case USB_SPEED_SUPER:
 		speed = &quot;5000&quot;; break;
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
<span class="p_add">+		speed = &quot;10000&quot;; break;</span>
 	default:
 		speed = &quot;??&quot;;
 	}
<span class="p_chunk">@@ -553,7 +555,7 @@</span> <span class="p_context"> static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,</span>
 
 		/* super/high speed reserves 80%, full/low reserves 90% */
 		if (usbdev-&gt;speed == USB_SPEED_HIGH ||
<span class="p_del">-		    usbdev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+		    usbdev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 			max = 800;
 		else
 			max = FRAME_TIME_MAX_USECS_ALLOC;
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 3ffb01ff6549..f5c92d904ded 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1530,11 +1530,17 @@</span> <span class="p_context"> static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb</span>
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = number_of_packets;
 	as-&gt;urb-&gt;stream_id = stream_id;
<span class="p_del">-	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_del">-			ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ep-&gt;desc.bInterval) {</span>
<span class="p_add">+		if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed == USB_SPEED_HIGH ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = 1 &lt;&lt;</span>
<span class="p_add">+					min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	as-&gt;urb-&gt;context = as;
 	as-&gt;urb-&gt;complete = async_completed;
 	for (totlen = u = 0; u &lt; number_of_packets; u++) {
<span class="p_header">diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">index b8b580e5ae6e..40378487e023 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd-pci.c</span>
<span class="p_chunk">@@ -206,7 +206,7 @@</span> <span class="p_context"> int usb_hcd_pci_probe(struct pci_dev *dev, const struct pci_device_id *id)</span>
 	 * The xHCI driver has its own irq management
 	 * make sure irq setup is not touched for xhci in generic hcd code
 	 */
<span class="p_del">-	if ((driver-&gt;flags &amp; HCD_MASK) != HCD_USB3) {</span>
<span class="p_add">+	if ((driver-&gt;flags &amp; HCD_MASK) &lt; HCD_USB3) {</span>
 		if (!dev-&gt;irq) {
 			dev_err(&amp;dev-&gt;dev,
 			&quot;Found HC with no IRQ. Check BIOS/PCI %s setup!\n&quot;,
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 1c102d60cd9f..f44ce09367bc 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -1078,7 +1078,7 @@</span> <span class="p_context"> static int register_root_hub(struct usb_hcd *hcd)</span>
 		retval = usb_get_bos_descriptor(usb_dev);
 		if (!retval) {
 			usb_dev-&gt;lpm_capable = usb_device_supports_lpm(usb_dev);
<span class="p_del">-		} else if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+		} else if (usb_dev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 			mutex_unlock(&amp;usb_bus_list_lock);
 			dev_dbg(parent_dev, &quot;can&#39;t read %s bos descriptor %d\n&quot;,
 					dev_name(&amp;usb_dev-&gt;dev), retval);
<span class="p_chunk">@@ -2112,7 +2112,7 @@</span> <span class="p_context"> int usb_alloc_streams(struct usb_interface *interface,</span>
 	hcd = bus_to_hcd(dev-&gt;bus);
 	if (!hcd-&gt;driver-&gt;alloc_streams || !hcd-&gt;driver-&gt;free_streams)
 		return -EINVAL;
<span class="p_del">-	if (dev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (dev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return -EINVAL;
 	if (dev-&gt;state &lt; USB_STATE_CONFIGURED)
 		return -ENODEV;
<span class="p_chunk">@@ -2160,7 +2160,7 @@</span> <span class="p_context"> int usb_free_streams(struct usb_interface *interface,</span>
 
 	dev = interface_to_usbdev(interface);
 	hcd = bus_to_hcd(dev-&gt;bus);
<span class="p_del">-	if (dev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (dev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return -EINVAL;
 
 	/* Double-free is not allowed */
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 84df093639ac..bcc1e1b729ad 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static void usb_set_lpm_parameters(struct usb_device *udev)</span>
 	unsigned int hub_u1_del;
 	unsigned int hub_u2_del;
 
<span class="p_del">-	if (!udev-&gt;lpm_capable || udev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (!udev-&gt;lpm_capable || udev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return;
 
 	hub = usb_hub_to_struct_hub(udev-&gt;parent);
<span class="p_chunk">@@ -1036,14 +1036,11 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 
 	/* Continue a partial initialization */
 	if (type == HUB_INIT2 || type == HUB_INIT3) {
<span class="p_del">-		device_lock(hub-&gt;intfdev);</span>
<span class="p_add">+		device_lock(&amp;hdev-&gt;dev);</span>
 
 		/* Was the hub disconnected while we were waiting? */
<span class="p_del">-		if (hub-&gt;disconnected) {</span>
<span class="p_del">-			device_unlock(hub-&gt;intfdev);</span>
<span class="p_del">-			kref_put(&amp;hub-&gt;kref, hub_release);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (hub-&gt;disconnected)</span>
<span class="p_add">+			goto disconnected;</span>
 		if (type == HUB_INIT2)
 			goto init2;
 		goto init3;
<span class="p_chunk">@@ -1246,7 +1243,7 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 			queue_delayed_work(system_power_efficient_wq,
 					&amp;hub-&gt;init_work,
 					msecs_to_jiffies(delay));
<span class="p_del">-			device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+			device_unlock(&amp;hdev-&gt;dev);</span>
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
<span class="p_chunk">@@ -1265,12 +1262,12 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	/* Scan all ports that need attention */
 	kick_hub_wq(hub);
 
<span class="p_del">-	/* Allow autosuspend if it was suppressed */</span>
<span class="p_del">-	if (type &lt;= HUB_INIT3)</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3) {</span>
<span class="p_add">+		/* Allow autosuspend if it was suppressed */</span>
<span class="p_add">+ disconnected:</span>
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
<span class="p_del">-</span>
<span class="p_del">-	if (type == HUB_INIT2 || type == HUB_INIT3)</span>
<span class="p_del">-		device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+		device_unlock(&amp;hdev-&gt;dev);</span>
<span class="p_add">+	}</span>
 
 	kref_put(&amp;hub-&gt;kref, hub_release);
 }
<span class="p_chunk">@@ -1299,8 +1296,6 @@</span> <span class="p_context"> static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)</span>
 	struct usb_device *hdev = hub-&gt;hdev;
 	int i;
 
<span class="p_del">-	cancel_delayed_work_sync(&amp;hub-&gt;init_work);</span>
<span class="p_del">-</span>
 	/* hub_wq and related activity won&#39;t re-trigger */
 	hub-&gt;quiescing = 1;
 
<span class="p_chunk">@@ -2645,7 +2640,7 @@</span> <span class="p_context"> static unsigned hub_is_wusb(struct usb_hub *hub)</span>
  */
 static bool use_new_scheme(struct usb_device *udev, int retry)
 {
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		return false;
 
 	return USE_NEW_SCHEME(retry);
<span class="p_chunk">@@ -3985,7 +3980,7 @@</span> <span class="p_context"> int usb_disable_lpm(struct usb_device *udev)</span>
 	struct usb_hcd *hcd;
 
 	if (!udev || !udev-&gt;parent ||
<span class="p_del">-			udev-&gt;speed != USB_SPEED_SUPER ||</span>
<span class="p_add">+			udev-&gt;speed &lt; USB_SPEED_SUPER ||</span>
 			!udev-&gt;lpm_capable ||
 			udev-&gt;state &lt; USB_STATE_DEFAULT)
 		return 0;
<span class="p_chunk">@@ -4042,7 +4037,7 @@</span> <span class="p_context"> void usb_enable_lpm(struct usb_device *udev)</span>
 	struct usb_hcd *hcd;
 
 	if (!udev || !udev-&gt;parent ||
<span class="p_del">-			udev-&gt;speed != USB_SPEED_SUPER ||</span>
<span class="p_add">+			udev-&gt;speed &lt; USB_SPEED_SUPER ||</span>
 			!udev-&gt;lpm_capable ||
 			udev-&gt;state &lt; USB_STATE_DEFAULT)
 		return;
<span class="p_chunk">@@ -4308,7 +4303,9 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 
 	retval = -ENODEV;
 
<span class="p_del">-	if (oldspeed != USB_SPEED_UNKNOWN &amp;&amp; oldspeed != udev-&gt;speed) {</span>
<span class="p_add">+	/* Don&#39;t allow speed changes at reset, except usb 3.0 to faster */</span>
<span class="p_add">+	if (oldspeed != USB_SPEED_UNKNOWN &amp;&amp; oldspeed != udev-&gt;speed &amp;&amp;</span>
<span class="p_add">+	    !(oldspeed == USB_SPEED_SUPER &amp;&amp; udev-&gt;speed &gt; oldspeed)) {</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;device reset changed speed!\n&quot;);
 		goto fail;
 	}
<span class="p_chunk">@@ -4320,6 +4317,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	 * reported as 0xff in the device descriptor). WUSB1.0[4.8.1].
 	 */
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 	case USB_SPEED_WIRELESS:	/* fixed at 512 */
 		udev-&gt;ep0.desc.wMaxPacketSize = cpu_to_le16(512);
<span class="p_chunk">@@ -4346,7 +4344,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	else
 		speed = usb_speed_string(udev-&gt;speed);
 
<span class="p_del">-	if (udev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		dev_info(&amp;udev-&gt;dev,
 				&quot;%s %s USB device number %d using %s\n&quot;,
 				(udev-&gt;config) ? &quot;reset&quot; : &quot;new&quot;, speed,
<span class="p_chunk">@@ -4476,11 +4474,12 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 							devnum, retval);
 				goto fail;
 			}
<span class="p_del">-			if (udev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+			if (udev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 				devnum = udev-&gt;devnum;
 				dev_info(&amp;udev-&gt;dev,
<span class="p_del">-						&quot;%s SuperSpeed USB device number %d using %s\n&quot;,</span>
<span class="p_add">+						&quot;%s SuperSpeed%s USB device number %d using %s\n&quot;,</span>
 						(udev-&gt;config) ? &quot;reset&quot; : &quot;new&quot;,
<span class="p_add">+					 (udev-&gt;speed == USB_SPEED_SUPER_PLUS) ? &quot;Plus&quot; : &quot;&quot;,</span>
 						devnum, udev-&gt;bus-&gt;controller-&gt;driver-&gt;name);
 			}
 
<span class="p_chunk">@@ -4519,7 +4518,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	 * got from those devices show they aren&#39;t superspeed devices. Warm
 	 * reset the port attached by the devices can fix them.
 	 */
<span class="p_del">-	if ((udev-&gt;speed == USB_SPEED_SUPER) &amp;&amp;</span>
<span class="p_add">+	if ((udev-&gt;speed &gt;= USB_SPEED_SUPER) &amp;&amp;</span>
 			(le16_to_cpu(udev-&gt;descriptor.bcdUSB) &lt; 0x0300)) {
 		dev_err(&amp;udev-&gt;dev, &quot;got a wrong device descriptor, &quot;
 				&quot;warm reset device\n&quot;);
<span class="p_chunk">@@ -4530,7 +4529,7 @@</span> <span class="p_context"> hub_port_init(struct usb_hub *hub, struct usb_device *udev, int port1,</span>
 	}
 
 	if (udev-&gt;descriptor.bMaxPacketSize0 == 0xff ||
<span class="p_del">-			udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+			udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		i = 512;
 	else
 		i = udev-&gt;descriptor.bMaxPacketSize0;
<span class="p_chunk">@@ -4740,7 +4739,7 @@</span> <span class="p_context"> static void hub_port_connect(struct usb_hub *hub, int port1, u16 portstatus,</span>
 		udev-&gt;level = hdev-&gt;level + 1;
 		udev-&gt;wusb = hub_is_wusb(hub);
 
<span class="p_del">-		/* Only USB 3.0 devices are connected to SuperSpeed hubs. */</span>
<span class="p_add">+		/* Devices connected to SuperSpeed hubs are USB 3.0 or later */</span>
 		if (hub_is_superspeed(hub-&gt;hdev))
 			udev-&gt;speed = USB_SPEED_SUPER;
 		else
<span class="p_header">diff --git a/drivers/usb/core/urb.c b/drivers/usb/core/urb.c</span>
<span class="p_header">index 3d274778caaf..c601e25b609f 100644</span>
<span class="p_header">--- a/drivers/usb/core/urb.c</span>
<span class="p_header">+++ b/drivers/usb/core/urb.c</span>
<span class="p_chunk">@@ -401,7 +401,7 @@</span> <span class="p_context"> int usb_submit_urb(struct urb *urb, gfp_t mem_flags)</span>
 		/* SuperSpeed isoc endpoints have up to 16 bursts of up to
 		 * 3 packets each
 		 */
<span class="p_del">-		if (dev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+		if (dev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 			int     burst = 1 + ep-&gt;ss_ep_comp.bMaxBurst;
 			int     mult = USB_SS_MULT(ep-&gt;ss_ep_comp.bmAttributes);
 			max *= burst;
<span class="p_chunk">@@ -499,6 +499,7 @@</span> <span class="p_context"> int usb_submit_urb(struct urb *urb, gfp_t mem_flags)</span>
 		}
 		/* too big? */
 		switch (dev-&gt;speed) {
<span class="p_add">+		case USB_SPEED_SUPER_PLUS:</span>
 		case USB_SPEED_SUPER:	/* units are 125us */
 			/* Handle up to 2^(16-1) microframes */
 			if (urb-&gt;interval &gt; (1 &lt;&lt; 15))
<span class="p_header">diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h</span>
<span class="p_header">index 05b5e17abf92..53318126ed91 100644</span>
<span class="p_header">--- a/drivers/usb/core/usb.h</span>
<span class="p_header">+++ b/drivers/usb/core/usb.h</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> static inline unsigned usb_get_max_power(struct usb_device *udev,</span>
 		struct usb_host_config *c)
 {
 	/* SuperSpeed power is in 8 mA units; others are in 2 mA units */
<span class="p_del">-	unsigned mul = (udev-&gt;speed == USB_SPEED_SUPER ? 8 : 2);</span>
<span class="p_add">+	unsigned mul = (udev-&gt;speed &gt;= USB_SPEED_SUPER ? 8 : 2);</span>
 
 	return c-&gt;desc.bMaxPower * mul;
 }
<span class="p_header">diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_header">index 009d83048c8c..3d731d1b5c60 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_SPTH		0xa130
 #define PCI_DEVICE_ID_INTEL_BXT			0x0aaa
 #define PCI_DEVICE_ID_INTEL_APL			0x5aaa
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_KBP			0xa2b0</span>
 
 static const struct acpi_gpio_params reset_gpios = { 0, 0, false };
 static const struct acpi_gpio_params cs_gpios = { 1, 0, false };
<span class="p_chunk">@@ -214,6 +215,7 @@</span> <span class="p_context"> static const struct pci_device_id dwc3_pci_id_table[] = {</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_SPTH), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BXT), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_APL), },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_KBP), },</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_NL_USB), },
 	{  }	/* Terminating Entry */
 };
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 70900e6ca9bc..fb79dca9484b 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1892,14 +1892,6 @@</span> <span class="p_context"> static int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 			s_pkt = 1;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We assume here we will always receive the entire data block</span>
<span class="p_del">-	 * which we should receive. Meaning, if we program RX to</span>
<span class="p_del">-	 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_del">-	 * should receive and we simply bounce the request back to the</span>
<span class="p_del">-	 * gadget driver for further processing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	req-&gt;request.actual += req-&gt;request.length - count;</span>
 	if (s_pkt)
 		return 1;
 	if ((event-&gt;status &amp; DEPEVT_STATUS_LST) &amp;&amp;
<span class="p_chunk">@@ -1919,6 +1911,7 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 	struct dwc3_trb		*trb;
 	unsigned int		slot;
 	unsigned int		i;
<span class="p_add">+	int			count = 0;</span>
 	int			ret;
 
 	do {
<span class="p_chunk">@@ -1935,6 +1928,8 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 				slot++;
 			slot %= DWC3_TRB_NUM;
 			trb = &amp;dep-&gt;trb_pool[slot];
<span class="p_add">+			count += trb-&gt;size &amp; DWC3_TRB_SIZE_MASK;</span>
<span class="p_add">+</span>
 
 			ret = __dwc3_cleanup_done_trbs(dwc, dep, req, trb,
 					event, status);
<span class="p_chunk">@@ -1942,6 +1937,14 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 				break;
 		} while (++i &lt; req-&gt;request.num_mapped_sgs);
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We assume here we will always receive the entire data block</span>
<span class="p_add">+		 * which we should receive. Meaning, if we program RX to</span>
<span class="p_add">+		 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_add">+		 * should receive and we simply bounce the request back to the</span>
<span class="p_add">+		 * gadget driver for further processing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		req-&gt;request.actual += req-&gt;request.length - count;</span>
 		dwc3_gadget_giveback(dep, req, status);
 
 		if (ret)
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index 55386619a0f1..e57f48f9528f 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -541,7 +541,7 @@</span> <span class="p_context"> static ssize_t ep_aio(struct kiocb *iocb,</span>
 	 */
 	spin_lock_irq(&amp;epdata-&gt;dev-&gt;lock);
 	value = -ENODEV;
<span class="p_del">-	if (unlikely(epdata-&gt;ep))</span>
<span class="p_add">+	if (unlikely(epdata-&gt;ep == NULL))</span>
 		goto fail;
 
 	req = usb_ep_alloc_request(epdata-&gt;ep, GFP_ATOMIC);
<span class="p_header">diff --git a/drivers/usb/gadget/udc/fsl_qe_udc.c b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">index 5fb6f8b4f0b4..c73689b72f95 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_chunk">@@ -2053,7 +2053,7 @@</span> <span class="p_context"> static void setup_received_handle(struct qe_udc *udc,</span>
 			struct qe_ep *ep;
 
 			if (wValue != 0 || wLength != 0
<span class="p_del">-				|| pipe &gt; USB_MAX_ENDPOINTS)</span>
<span class="p_add">+				|| pipe &gt;= USB_MAX_ENDPOINTS)</span>
 				break;
 			ep = &amp;udc-&gt;eps[pipe];
 
<span class="p_header">diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">index 48c92bf78bd0..f7661d9750fd 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_chunk">@@ -332,11 +332,11 @@</span> <span class="p_context"> static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)</span>
 	int	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 
 	while (port--) {
<span class="p_del">-		ehci_writel(ehci, PORT_RWC_BITS,</span>
<span class="p_del">-				&amp;ehci-&gt;regs-&gt;port_status[port]);</span>
 		spin_unlock_irq(&amp;ehci-&gt;lock);
 		ehci_port_power(ehci, port, false);
 		spin_lock_irq(&amp;ehci-&gt;lock);
<span class="p_add">+		ehci_writel(ehci, PORT_RWC_BITS,</span>
<span class="p_add">+				&amp;ehci-&gt;regs-&gt;port_status[port]);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index f980c239eded..1da876605e4d 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -377,6 +377,9 @@</span> <span class="p_context"> static int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)</span>
 
 	ret = 0;
 	virt_dev = xhci-&gt;devs[slot_id];
<span class="p_add">+	if (!virt_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	cmd = xhci_alloc_command(xhci, false, true, GFP_NOIO);
 	if (!cmd) {
 		xhci_dbg(xhci, &quot;Couldn&#39;t allocate command structure.\n&quot;);
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index d8dbd7e5194b..8ea2c05beca2 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1072,7 +1072,7 @@</span> <span class="p_context"> static u32 xhci_find_real_port_number(struct xhci_hcd *xhci,</span>
 	struct usb_device *top_dev;
 	struct usb_hcd *hcd;
 
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		hcd = xhci-&gt;shared_hcd;
 	else
 		hcd = xhci-&gt;main_hcd;
<span class="p_chunk">@@ -1107,6 +1107,7 @@</span> <span class="p_context"> int xhci_setup_addressable_virt_dev(struct xhci_hcd *xhci, struct usb_device *ud</span>
 	/* 3) Only the control endpoint is valid - one endpoint context */
 	slot_ctx-&gt;dev_info |= cpu_to_le32(LAST_CTX(1) | udev-&gt;route);
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		slot_ctx-&gt;dev_info |= cpu_to_le32(SLOT_SPEED_SS);
 		max_packets = MAX_PACKET(512);
<span class="p_chunk">@@ -1294,6 +1295,7 @@</span> <span class="p_context"> static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,</span>
 		}
 		/* Fall through - SS and HS isoc/int have same decoding */
 
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		if (usb_endpoint_xfer_int(&amp;ep-&gt;desc) ||
 		    usb_endpoint_xfer_isoc(&amp;ep-&gt;desc)) {
<span class="p_chunk">@@ -1334,7 +1336,7 @@</span> <span class="p_context"> static unsigned int xhci_get_endpoint_interval(struct usb_device *udev,</span>
 static u32 xhci_get_endpoint_mult(struct usb_device *udev,
 		struct usb_host_endpoint *ep)
 {
<span class="p_del">-	if (udev-&gt;speed != USB_SPEED_SUPER ||</span>
<span class="p_add">+	if (udev-&gt;speed &lt; USB_SPEED_SUPER ||</span>
 			!usb_endpoint_xfer_isoc(&amp;ep-&gt;desc))
 		return 0;
 	return ep-&gt;ss_ep_comp.bmAttributes;
<span class="p_chunk">@@ -1384,7 +1386,7 @@</span> <span class="p_context"> static u32 xhci_get_max_esit_payload(struct usb_device *udev,</span>
 			usb_endpoint_xfer_bulk(&amp;ep-&gt;desc))
 		return 0;
 
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		return le16_to_cpu(ep-&gt;ss_ep_comp.wBytesPerInterval);
 
 	max_packet = GET_MAX_PACKET(usb_endpoint_maxp(&amp;ep-&gt;desc));
<span class="p_chunk">@@ -1455,6 +1457,7 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 	max_packet = GET_MAX_PACKET(usb_endpoint_maxp(&amp;ep-&gt;desc));
 	max_burst = 0;
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		/* dig out max burst from ep companion desc */
 		max_burst = ep-&gt;ss_ep_comp.bMaxBurst;
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index de644e56aa3b..963867c2c1d5 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -311,11 +311,12 @@</span> <span class="p_context"> static void xhci_pci_remove(struct pci_dev *dev)</span>
 		usb_remove_hcd(xhci-&gt;shared_hcd);
 		usb_put_hcd(xhci-&gt;shared_hcd);
 	}
<span class="p_del">-	usb_hcd_pci_remove(dev);</span>
 
 	/* Workaround for spurious wakeups at shutdown with HSW */
 	if (xhci-&gt;quirks &amp; XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(dev, PCI_D3hot);
<span class="p_add">+</span>
<span class="p_add">+	usb_hcd_pci_remove(dev);</span>
 }
 
 #ifdef CONFIG_PM
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 34cd23724bed..1f37b89e7267 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1331,12 +1331,6 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 
 	cmd = list_entry(xhci-&gt;cmd_list.next, struct xhci_command, cmd_list);
 
<span class="p_del">-	if (cmd-&gt;command_trb != xhci-&gt;cmd_ring-&gt;dequeue) {</span>
<span class="p_del">-		xhci_err(xhci,</span>
<span class="p_del">-			 &quot;Command completion event does not match command\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	del_timer(&amp;xhci-&gt;cmd_timer);
 
 	trace_xhci_cmd_completion(cmd_trb, (struct xhci_generic_trb *) event);
<span class="p_chunk">@@ -1348,6 +1342,13 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 		xhci_handle_stopped_cmd_ring(xhci, cmd);
 		return;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (cmd-&gt;command_trb != xhci-&gt;cmd_ring-&gt;dequeue) {</span>
<span class="p_add">+		xhci_err(xhci,</span>
<span class="p_add">+			 &quot;Command completion event does not match command\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Host aborted the command ring, check if the current command was
 	 * supposed to be aborted, otherwise continue normally.
<span class="p_chunk">@@ -3575,7 +3576,7 @@</span> <span class="p_context"> static unsigned int xhci_get_burst_count(struct xhci_hcd *xhci,</span>
 {
 	unsigned int max_burst;
 
<span class="p_del">-	if (xhci-&gt;hci_version &lt; 0x100 || udev-&gt;speed != USB_SPEED_SUPER)</span>
<span class="p_add">+	if (xhci-&gt;hci_version &lt; 0x100 || udev-&gt;speed &lt; USB_SPEED_SUPER)</span>
 		return 0;
 
 	max_burst = urb-&gt;ep-&gt;ss_ep_comp.bMaxBurst;
<span class="p_chunk">@@ -3601,6 +3602,7 @@</span> <span class="p_context"> static unsigned int xhci_get_last_burst_packet_count(struct xhci_hcd *xhci,</span>
 		return 0;
 
 	switch (udev-&gt;speed) {
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_SUPER:
 		/* bMaxBurst is zero based: 0 means 1 packet per burst */
 		max_burst = urb-&gt;ep-&gt;ss_ep_comp.bMaxBurst;
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 6fe0174da226..adc169d2fd76 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -2073,6 +2073,7 @@</span> <span class="p_context"> static unsigned int xhci_get_block_size(struct usb_device *udev)</span>
 	case USB_SPEED_HIGH:
 		return HS_BLOCK;
 	case USB_SPEED_SUPER:
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 		return SS_BLOCK;
 	case USB_SPEED_UNKNOWN:
 	case USB_SPEED_WIRELESS:
<span class="p_chunk">@@ -2198,7 +2199,7 @@</span> <span class="p_context"> static int xhci_check_bw_table(struct xhci_hcd *xhci,</span>
 	unsigned int packets_remaining = 0;
 	unsigned int i;
 
<span class="p_del">-	if (virt_dev-&gt;udev-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+	if (virt_dev-&gt;udev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
 		return xhci_check_ss_bw(xhci, virt_dev);
 
 	if (virt_dev-&gt;udev-&gt;speed == USB_SPEED_HIGH) {
<span class="p_chunk">@@ -2399,7 +2400,7 @@</span> <span class="p_context"> void xhci_drop_ep_from_interval_table(struct xhci_hcd *xhci,</span>
 	if (xhci_is_async_ep(ep_bw-&gt;type))
 		return;
 
<span class="p_del">-	if (udev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+	if (udev-&gt;speed &gt;= USB_SPEED_SUPER) {</span>
 		if (xhci_is_sync_in_ep(ep_bw-&gt;type))
 			xhci-&gt;devs[udev-&gt;slot_id]-&gt;bw_table-&gt;ss_bw_in -=
 				xhci_get_ss_bw_consumed(ep_bw);
<span class="p_chunk">@@ -2437,6 +2438,7 @@</span> <span class="p_context"> void xhci_drop_ep_from_interval_table(struct xhci_hcd *xhci,</span>
 		interval_bw-&gt;overhead[HS_OVERHEAD_TYPE] -= 1;
 		break;
 	case USB_SPEED_SUPER:
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_UNKNOWN:
 	case USB_SPEED_WIRELESS:
 		/* Should never happen because only LS/FS/HS endpoints will get
<span class="p_chunk">@@ -2496,6 +2498,7 @@</span> <span class="p_context"> static void xhci_add_ep_to_interval_table(struct xhci_hcd *xhci,</span>
 		interval_bw-&gt;overhead[HS_OVERHEAD_TYPE] += 1;
 		break;
 	case USB_SPEED_SUPER:
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
 	case USB_SPEED_UNKNOWN:
 	case USB_SPEED_WIRELESS:
 		/* Should never happen because only LS/FS/HS endpoints will get
<span class="p_header">diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c</span>
<span class="p_header">index 1a812eafe670..1624b09d9748 100644</span>
<span class="p_header">--- a/drivers/usb/misc/usbtest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/usbtest.c</span>
<span class="p_chunk">@@ -558,7 +558,6 @@</span> <span class="p_context"> static void sg_timeout(unsigned long _req)</span>
 {
 	struct usb_sg_request	*req = (struct usb_sg_request *) _req;
 
<span class="p_del">-	req-&gt;status = -ETIMEDOUT;</span>
 	usb_sg_cancel(req);
 }
 
<span class="p_chunk">@@ -589,8 +588,10 @@</span> <span class="p_context"> static int perform_sglist(</span>
 		mod_timer(&amp;sg_timer, jiffies +
 				msecs_to_jiffies(SIMPLE_IO_TIMEOUT));
 		usb_sg_wait(req);
<span class="p_del">-		del_timer_sync(&amp;sg_timer);</span>
<span class="p_del">-		retval = req-&gt;status;</span>
<span class="p_add">+		if (!del_timer_sync(&amp;sg_timer))</span>
<span class="p_add">+			retval = -ETIMEDOUT;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			retval = req-&gt;status;</span>
 
 		/* FIXME check resulting data pattern */
 
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index db565f620f82..36e5b5c530bd 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -869,7 +869,7 @@</span> <span class="p_context"> static int usbhsf_dma_prepare_push(struct usbhs_pkt *pkt, int *is_done)</span>
 
 	/* use PIO if packet is less than pio_dma_border or pipe is DCP */
 	if ((len &lt; usbhs_get_dparam(priv, pio_dma_border)) ||
<span class="p_del">-	    usbhs_pipe_is_dcp(pipe))</span>
<span class="p_add">+	    usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC))</span>
 		goto usbhsf_pio_prepare_push;
 
 	/* check data length if this driver don&#39;t use USB-DMAC */
<span class="p_chunk">@@ -974,7 +974,7 @@</span> <span class="p_context"> static int usbhsf_dma_prepare_pop_with_usb_dmac(struct usbhs_pkt *pkt,</span>
 
 	/* use PIO if packet is less than pio_dma_border or pipe is DCP */
 	if ((pkt-&gt;length &lt; usbhs_get_dparam(priv, pio_dma_border)) ||
<span class="p_del">-	    usbhs_pipe_is_dcp(pipe))</span>
<span class="p_add">+	    usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC))</span>
 		goto usbhsf_pio_prepare_pop;
 
 	fifo = usbhsf_get_dma_fifo(priv, pkt);
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index 5a3abf56d56b..efc4fae123a4 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -618,10 +618,13 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 		 * use dmaengine if possible.
 		 * It will use pio handler if impossible.
 		 */
<span class="p_del">-		if (usb_endpoint_dir_in(desc))</span>
<span class="p_add">+		if (usb_endpoint_dir_in(desc)) {</span>
 			pipe-&gt;handler = &amp;usbhs_fifo_dma_push_handler;
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			pipe-&gt;handler = &amp;usbhs_fifo_dma_pop_handler;
<span class="p_add">+			usbhs_xxxsts_clear(priv, BRDYSTS,</span>
<span class="p_add">+					   usbhs_pipe_number(pipe));</span>
<span class="p_add">+		}</span>
 
 		ret = 0;
 	}
<span class="p_chunk">@@ -1072,7 +1075,7 @@</span> <span class="p_context"> int usbhs_mod_gadget_probe(struct usbhs_priv *priv)</span>
 
 	gpriv-&gt;transceiver = usb_get_phy(USB_PHY_TYPE_UNDEFINED);
 	dev_info(dev, &quot;%stransceiver found\n&quot;,
<span class="p_del">-		 gpriv-&gt;transceiver ? &quot;&quot; : &quot;no &quot;);</span>
<span class="p_add">+		 !IS_ERR(gpriv-&gt;transceiver) ? &quot;&quot; : &quot;no &quot;);</span>
 
 	/*
 	 * CAUTION
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index b61f12160d37..8c48c9d83d48 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -648,6 +648,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_TFD128_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_FM3RX_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS777_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_PALMSENS_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_IVIUM_XSTAT_PID) },</span>
 	{ USB_DEVICE(FTDI_VID, LINX_SDMUSBQSS_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_MASTERDEVEL2_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_FUTURE_0_PID) },
<span class="p_chunk">@@ -1008,6 +1010,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7560U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },
<span class="p_add">+	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index c5d6c1e73e8e..f87a938cf005 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -406,6 +406,12 @@</span> <span class="p_context"></span>
 #define FTDI_4N_GALAXY_DE_3_PID	0xF3C2
 
 /*
<span class="p_add">+ * Ivium Technologies product IDs</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_PALMSENS_PID	0xf440</span>
<span class="p_add">+#define FTDI_IVIUM_XSTAT_PID	0xf441</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Linx Technologies product ids
  */
 #define LINX_SDMUSBQSS_PID	0xF448	/* Linx SDM-USB-QS-S */
<span class="p_chunk">@@ -673,6 +679,12 @@</span> <span class="p_context"></span>
 #define INTREPID_NEOVI_PID	0x0701
 
 /*
<span class="p_add">+ * WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define WICED_VID		0x0A5C</span>
<span class="p_add">+#define WICED_USB20706V2_PID	0x6422</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Definitions for ID TECH (www.idt-net.com) devices
  */
 #define IDTECH_VID		0x0ACD	/* ID TECH Vendor ID */
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index 06c7dbc1c802..63db004af21f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -1252,7 +1252,7 @@</span> <span class="p_context"> static int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 
 	if (urb-&gt;transfer_buffer == NULL) {
 		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,
<span class="p_del">-					       GFP_KERNEL);</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index 8ac9b55f05af..7f3ddd7ba2ce 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -1340,8 +1340,8 @@</span> <span class="p_context"> static int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 	}
 
 	if (urb-&gt;transfer_buffer == NULL) {
<span class="p_del">-		urb-&gt;transfer_buffer =</span>
<span class="p_del">-		    kmalloc(URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 8e07536c233a..9894e341c6ac 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -274,6 +274,12 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
 #define TELIT_PRODUCT_LE910_USBCFG4		0x1206
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1207		0x1207</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1208		0x1208</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1211		0x1211</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1212		0x1212</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1213		0x1213</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1214		0x1214</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -519,6 +525,12 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define VIATELECOM_VENDOR_ID			0x15eb
 #define VIATELECOM_PRODUCT_CDS7			0x0001
 
<span class="p_add">+/* WeTelecom products */</span>
<span class="p_add">+#define WETELECOM_VENDOR_ID			0x22de</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD200		0x6801</span>
<span class="p_add">+#define WETELECOM_PRODUCT_6802			0x6802</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD300		0x6803</span>
<span class="p_add">+</span>
 struct option_blacklist_info {
 	/* bitmask of interface numbers blacklisted for send_setup */
 	const unsigned long sendsetup;
<span class="p_chunk">@@ -628,6 +640,11 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le920_blacklist = {</span>
 	.reserved = BIT(1) | BIT(5),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_le920a4_blacklist_1 = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(1),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le922_blacklist_usbcfg0 = {
 	.sendsetup = BIT(2),
 	.reserved = BIT(0) | BIT(1) | BIT(3),
<span class="p_chunk">@@ -1203,6 +1220,16 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1207) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1208),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1211),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1212),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1213, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1214),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t)&amp;net_intf1_blacklist },
<span class="p_chunk">@@ -1966,9 +1993,13 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x7e11, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/A3 */</span>
 	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD200, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_6802, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD300, 0xff, 0xff, 0xff) },</span>
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index 46f1f13b41f1..a0ca291bc07f 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1432,7 +1432,7 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 
 	rc = usb_register(udriver);
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_add">+		goto failed_usb_register;</span>
 
 	for (sd = serial_drivers; *sd; ++sd) {
 		(*sd)-&gt;usb_driver = udriver;
<span class="p_chunk">@@ -1450,6 +1450,8 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 	while (sd-- &gt; serial_drivers)
 		usb_serial_deregister(*sd);
 	usb_deregister(udriver);
<span class="p_add">+failed_usb_register:</span>
<span class="p_add">+	kfree(udriver);</span>
 	return rc;
 }
 EXPORT_SYMBOL_GPL(usb_serial_register_drivers);
<span class="p_header">diff --git a/drivers/vfio/pci/vfio_pci_intrs.c b/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_header">index 3b3ba15558b7..20e9a86d2dcf 100644</span>
<span class="p_header">--- a/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_header">+++ b/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_chunk">@@ -563,67 +563,80 @@</span> <span class="p_context"> static int vfio_pci_set_msi_trigger(struct vfio_pci_device *vdev,</span>
 }
 
 static int vfio_pci_set_ctx_trigger_single(struct eventfd_ctx **ctx,
<span class="p_del">-					   uint32_t flags, void *data)</span>
<span class="p_add">+					   unsigned int count, uint32_t flags,</span>
<span class="p_add">+					   void *data)</span>
 {
<span class="p_del">-	int32_t fd = *(int32_t *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(flags &amp; VFIO_IRQ_SET_DATA_TYPE_MASK))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DATA_NONE/DATA_BOOL enables loopback testing */
 	if (flags &amp; VFIO_IRQ_SET_DATA_NONE) {
<span class="p_del">-		if (*ctx)</span>
<span class="p_del">-			eventfd_signal(*ctx, 1);</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		if (*ctx) {</span>
<span class="p_add">+			if (count) {</span>
<span class="p_add">+				eventfd_signal(*ctx, 1);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				eventfd_ctx_put(*ctx);</span>
<span class="p_add">+				*ctx = NULL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	} else if (flags &amp; VFIO_IRQ_SET_DATA_BOOL) {
<span class="p_del">-		uint8_t trigger = *(uint8_t *)data;</span>
<span class="p_add">+		uint8_t trigger;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		trigger = *(uint8_t *)data;</span>
 		if (trigger &amp;&amp; *ctx)
 			eventfd_signal(*ctx, 1);
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	/* Handle SET_DATA_EVENTFD */</span>
<span class="p_del">-	if (fd == -1) {</span>
<span class="p_del">-		if (*ctx)</span>
<span class="p_del">-			eventfd_ctx_put(*ctx);</span>
<span class="p_del">-		*ctx = NULL;</span>
 		return 0;
<span class="p_del">-	} else if (fd &gt;= 0) {</span>
<span class="p_del">-		struct eventfd_ctx *efdctx;</span>
<span class="p_del">-		efdctx = eventfd_ctx_fdget(fd);</span>
<span class="p_del">-		if (IS_ERR(efdctx))</span>
<span class="p_del">-			return PTR_ERR(efdctx);</span>
<span class="p_del">-		if (*ctx)</span>
<span class="p_del">-			eventfd_ctx_put(*ctx);</span>
<span class="p_del">-		*ctx = efdctx;</span>
<span class="p_add">+	} else if (flags &amp; VFIO_IRQ_SET_DATA_EVENTFD) {</span>
<span class="p_add">+		int32_t fd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		fd = *(int32_t *)data;</span>
<span class="p_add">+		if (fd == -1) {</span>
<span class="p_add">+			if (*ctx)</span>
<span class="p_add">+				eventfd_ctx_put(*ctx);</span>
<span class="p_add">+			*ctx = NULL;</span>
<span class="p_add">+		} else if (fd &gt;= 0) {</span>
<span class="p_add">+			struct eventfd_ctx *efdctx;</span>
<span class="p_add">+</span>
<span class="p_add">+			efdctx = eventfd_ctx_fdget(fd);</span>
<span class="p_add">+			if (IS_ERR(efdctx))</span>
<span class="p_add">+				return PTR_ERR(efdctx);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (*ctx)</span>
<span class="p_add">+				eventfd_ctx_put(*ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+			*ctx = efdctx;</span>
<span class="p_add">+		}</span>
 		return 0;
<span class="p_del">-	} else</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int vfio_pci_set_err_trigger(struct vfio_pci_device *vdev,
 				    unsigned index, unsigned start,
 				    unsigned count, uint32_t flags, void *data)
 {
<span class="p_del">-	if (index != VFIO_PCI_ERR_IRQ_INDEX)</span>
<span class="p_add">+	if (index != VFIO_PCI_ERR_IRQ_INDEX || start != 0 || count &gt; 1)</span>
 		return -EINVAL;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We should sanitize start &amp; count, but that wasn&#39;t caught</span>
<span class="p_del">-	 * originally, so this IRQ index must forever ignore them :-(</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;err_trigger, flags, data);</span>
<span class="p_add">+	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;err_trigger,</span>
<span class="p_add">+					       count, flags, data);</span>
 }
 
 static int vfio_pci_set_req_trigger(struct vfio_pci_device *vdev,
 				    unsigned index, unsigned start,
 				    unsigned count, uint32_t flags, void *data)
 {
<span class="p_del">-	if (index != VFIO_PCI_REQ_IRQ_INDEX || start != 0 || count != 1)</span>
<span class="p_add">+	if (index != VFIO_PCI_REQ_IRQ_INDEX || start != 0 || count &gt; 1)</span>
 		return -EINVAL;
 
<span class="p_del">-	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;req_trigger, flags, data);</span>
<span class="p_add">+	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;req_trigger,</span>
<span class="p_add">+					       count, flags, data);</span>
 }
 
 int vfio_pci_set_irqs_ioctl(struct vfio_pci_device *vdev, uint32_t flags,
<span class="p_header">diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c</span>
<span class="p_header">index ee663c458b20..dc2b94142f53 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_ring.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_ring.c</span>
<span class="p_chunk">@@ -202,6 +202,8 @@</span> <span class="p_context"> static inline int virtqueue_add(struct virtqueue *_vq,</span>
 		 * host should service the ring ASAP. */
 		if (out_sgs)
 			vq-&gt;notify(&amp;vq-&gt;vq);
<span class="p_add">+		if (indirect)</span>
<span class="p_add">+			kfree(desc);</span>
 		END_USE(vq);
 		return -ENOSPC;
 	}
<span class="p_header">diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h</span>
<span class="p_header">index 385b449fd7ed..1391f72c28c3 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.h</span>
<span class="p_header">+++ b/fs/btrfs/ctree.h</span>
<span class="p_chunk">@@ -1770,6 +1770,7 @@</span> <span class="p_context"> struct btrfs_fs_info {</span>
 	struct btrfs_workqueue *qgroup_rescan_workers;
 	struct completion qgroup_rescan_completion;
 	struct btrfs_work qgroup_rescan_work;
<span class="p_add">+	bool qgroup_rescan_running;	/* protected by qgroup_rescan_lock */</span>
 
 	/* filesystem state */
 	unsigned long fs_state;
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index 41fb43183406..85b207d19aa5 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -2276,6 +2276,7 @@</span> <span class="p_context"> static void btrfs_init_qgroup(struct btrfs_fs_info *fs_info)</span>
 	fs_info-&gt;quota_enabled = 0;
 	fs_info-&gt;pending_quota_state = 0;
 	fs_info-&gt;qgroup_ulist = NULL;
<span class="p_add">+	fs_info-&gt;qgroup_rescan_running = false;</span>
 	mutex_init(&amp;fs_info-&gt;qgroup_rescan_lock);
 }
 
<span class="p_chunk">@@ -3811,7 +3812,7 @@</span> <span class="p_context"> void close_ctree(struct btrfs_root *root)</span>
 	smp_mb();
 
 	/* wait for the qgroup rescan worker to stop */
<span class="p_del">-	btrfs_qgroup_wait_for_completion(fs_info);</span>
<span class="p_add">+	btrfs_qgroup_wait_for_completion(fs_info, false);</span>
 
 	/* wait for the uuid_scan task to finish */
 	down(&amp;fs_info-&gt;uuid_tree_rescan_sem);
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index bfcd87ee8ff5..65f30b3b04f9 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -5121,7 +5121,7 @@</span> <span class="p_context"> static long btrfs_ioctl_quota_rescan_wait(struct file *file, void __user *arg)</span>
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
<span class="p_del">-	return btrfs_qgroup_wait_for_completion(root-&gt;fs_info);</span>
<span class="p_add">+	return btrfs_qgroup_wait_for_completion(root-&gt;fs_info, true);</span>
 }
 
 static long _btrfs_ioctl_set_received_subvol(struct file *file,
<span class="p_header">diff --git a/fs/btrfs/qgroup.c b/fs/btrfs/qgroup.c</span>
<span class="p_header">index 5279fdae7142..bcc965ed5fa1 100644</span>
<span class="p_header">--- a/fs/btrfs/qgroup.c</span>
<span class="p_header">+++ b/fs/btrfs/qgroup.c</span>
<span class="p_chunk">@@ -995,7 +995,7 @@</span> <span class="p_context"> int btrfs_quota_disable(struct btrfs_trans_handle *trans,</span>
 		goto out;
 	fs_info-&gt;quota_enabled = 0;
 	fs_info-&gt;pending_quota_state = 0;
<span class="p_del">-	btrfs_qgroup_wait_for_completion(fs_info);</span>
<span class="p_add">+	btrfs_qgroup_wait_for_completion(fs_info, false);</span>
 	spin_lock(&amp;fs_info-&gt;qgroup_lock);
 	quota_root = fs_info-&gt;quota_root;
 	fs_info-&gt;quota_root = NULL;
<span class="p_chunk">@@ -2283,6 +2283,10 @@</span> <span class="p_context"> static void btrfs_qgroup_rescan_worker(struct btrfs_work *work)</span>
 	int err = -ENOMEM;
 	int ret = 0;
 
<span class="p_add">+	mutex_lock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
<span class="p_add">+	fs_info-&gt;qgroup_rescan_running = true;</span>
<span class="p_add">+	mutex_unlock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
<span class="p_add">+</span>
 	path = btrfs_alloc_path();
 	if (!path)
 		goto out;
<span class="p_chunk">@@ -2349,6 +2353,9 @@</span> <span class="p_context"> out:</span>
 	}
 
 done:
<span class="p_add">+	mutex_lock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
<span class="p_add">+	fs_info-&gt;qgroup_rescan_running = false;</span>
<span class="p_add">+	mutex_unlock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
 	complete_all(&amp;fs_info-&gt;qgroup_rescan_completion);
 }
 
<span class="p_chunk">@@ -2467,20 +2474,26 @@</span> <span class="p_context"> btrfs_qgroup_rescan(struct btrfs_fs_info *fs_info)</span>
 	return 0;
 }
 
<span class="p_del">-int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)</span>
<span class="p_add">+int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info,</span>
<span class="p_add">+				     bool interruptible)</span>
 {
 	int running;
 	int ret = 0;
 
 	mutex_lock(&amp;fs_info-&gt;qgroup_rescan_lock);
 	spin_lock(&amp;fs_info-&gt;qgroup_lock);
<span class="p_del">-	running = fs_info-&gt;qgroup_flags &amp; BTRFS_QGROUP_STATUS_FLAG_RESCAN;</span>
<span class="p_add">+	running = fs_info-&gt;qgroup_rescan_running;</span>
 	spin_unlock(&amp;fs_info-&gt;qgroup_lock);
 	mutex_unlock(&amp;fs_info-&gt;qgroup_rescan_lock);
 
<span class="p_del">-	if (running)</span>
<span class="p_add">+	if (!running)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (interruptible)</span>
 		ret = wait_for_completion_interruptible(
 					&amp;fs_info-&gt;qgroup_rescan_completion);
<span class="p_add">+	else</span>
<span class="p_add">+		wait_for_completion(&amp;fs_info-&gt;qgroup_rescan_completion);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/fs/btrfs/qgroup.h b/fs/btrfs/qgroup.h</span>
<span class="p_header">index ecb2c143ef75..3d73e4c9c7df 100644</span>
<span class="p_header">--- a/fs/btrfs/qgroup.h</span>
<span class="p_header">+++ b/fs/btrfs/qgroup.h</span>
<span class="p_chunk">@@ -46,7 +46,8 @@</span> <span class="p_context"> int btrfs_quota_disable(struct btrfs_trans_handle *trans,</span>
 			struct btrfs_fs_info *fs_info);
 int btrfs_qgroup_rescan(struct btrfs_fs_info *fs_info);
 void btrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info);
<span class="p_del">-int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info);</span>
<span class="p_add">+int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info,</span>
<span class="p_add">+				     bool interruptible);</span>
 int btrfs_add_qgroup_relation(struct btrfs_trans_handle *trans,
 			      struct btrfs_fs_info *fs_info, u64 src, u64 dst);
 int btrfs_del_qgroup_relation(struct btrfs_trans_handle *trans,
<span class="p_header">diff --git a/fs/seq_file.c b/fs/seq_file.c</span>
<span class="p_header">index e85664b7c7d9..d672e2fec459 100644</span>
<span class="p_header">--- a/fs/seq_file.c</span>
<span class="p_header">+++ b/fs/seq_file.c</span>
<span class="p_chunk">@@ -222,8 +222,10 @@</span> <span class="p_context"> ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</span>
 		size -= n;
 		buf += n;
 		copied += n;
<span class="p_del">-		if (!m-&gt;count)</span>
<span class="p_add">+		if (!m-&gt;count) {</span>
<span class="p_add">+			m-&gt;from = 0;</span>
 			m-&gt;index++;
<span class="p_add">+		}</span>
 		if (!size)
 			goto Done;
 	}
<span class="p_header">diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c</span>
<span class="p_header">index f35523d4fa3a..b803213d1307 100644</span>
<span class="p_header">--- a/fs/sysfs/file.c</span>
<span class="p_header">+++ b/fs/sysfs/file.c</span>
<span class="p_chunk">@@ -114,9 +114,15 @@</span> <span class="p_context"> static ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,</span>
 	 * If buf != of-&gt;prealloc_buf, we don&#39;t know how
 	 * large it is, so cannot safely pass it to -&gt;show
 	 */
<span class="p_del">-	if (pos || WARN_ON_ONCE(buf != of-&gt;prealloc_buf))</span>
<span class="p_add">+	if (WARN_ON_ONCE(buf != of-&gt;prealloc_buf))</span>
 		return 0;
 	len = ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);
<span class="p_add">+	if (pos) {</span>
<span class="p_add">+		if (len &lt;= pos)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		len -= pos;</span>
<span class="p_add">+		memmove(buf, buf + pos, len);</span>
<span class="p_add">+	}</span>
 	return min(count, len);
 }
 
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index 1991aea2ec4c..3672893b275e 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -920,7 +920,7 @@</span> <span class="p_context"> static inline struct fwnode_handle *acpi_get_next_subnode(struct device *dev,</span>
 	return NULL;
 }
 
<span class="p_del">-#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable, validate, data, fn) \</span>
<span class="p_add">+#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable, valid, data, fn) \</span>
 	static const void * __acpi_table_##name[]			\
 		__attribute__((unused))					\
 		 = { (void *) table_id,					\
<span class="p_header">diff --git a/include/linux/i8042.h b/include/linux/i8042.h</span>
<span class="p_header">index 0f9bafa17a02..d98780ca9604 100644</span>
<span class="p_header">--- a/include/linux/i8042.h</span>
<span class="p_header">+++ b/include/linux/i8042.h</span>
<span class="p_chunk">@@ -62,7 +62,6 @@</span> <span class="p_context"> struct serio;</span>
 void i8042_lock_chip(void);
 void i8042_unlock_chip(void);
 int i8042_command(unsigned char *param, int command);
<span class="p_del">-bool i8042_check_port_owner(const struct serio *);</span>
 int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio));
 int i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,
<span class="p_chunk">@@ -83,11 +82,6 @@</span> <span class="p_context"> static inline int i8042_command(unsigned char *param, int command)</span>
 	return -ENODEV;
 }
 
<span class="p_del">-static inline bool i8042_check_port_owner(const struct serio *serio)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio))
 {
<span class="p_header">diff --git a/include/linux/mfd/cros_ec.h b/include/linux/mfd/cros_ec.h</span>
<span class="p_header">index 494682ce4bf3..3ab3cede28ea 100644</span>
<span class="p_header">--- a/include/linux/mfd/cros_ec.h</span>
<span class="p_header">+++ b/include/linux/mfd/cros_ec.h</span>
<span class="p_chunk">@@ -224,6 +224,21 @@</span> <span class="p_context"> int cros_ec_cmd_xfer(struct cros_ec_device *ec_dev,</span>
 		     struct cros_ec_command *msg);
 
 /**
<span class="p_add">+ * cros_ec_cmd_xfer_status - Send a command to the ChromeOS EC</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function is identical to cros_ec_cmd_xfer, except it returns success</span>
<span class="p_add">+ * status only if both the command was transmitted successfully and the EC</span>
<span class="p_add">+ * replied with success status. It&#39;s not necessary to check msg-&gt;result when</span>
<span class="p_add">+ * using this function.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @ec_dev: EC device</span>
<span class="p_add">+ * @msg: Message to write</span>
<span class="p_add">+ * @return: Num. of bytes transferred on success, &lt;0 on failure</span>
<span class="p_add">+ */</span>
<span class="p_add">+int cros_ec_cmd_xfer_status(struct cros_ec_device *ec_dev,</span>
<span class="p_add">+			    struct cros_ec_command *msg);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * cros_ec_remove - Remove a ChromeOS EC
  *
  * Call this to deregister a ChromeOS EC, then clean up any private data.
<span class="p_header">diff --git a/include/linux/msi.h b/include/linux/msi.h</span>
<span class="p_header">index f71a25e5fd25..f0f43ec45ee7 100644</span>
<span class="p_header">--- a/include/linux/msi.h</span>
<span class="p_header">+++ b/include/linux/msi.h</span>
<span class="p_chunk">@@ -254,12 +254,12 @@</span> <span class="p_context"> enum {</span>
 	 * callbacks.
 	 */
 	MSI_FLAG_USE_DEF_CHIP_OPS	= (1 &lt;&lt; 1),
<span class="p_del">-	/* Build identity map between hwirq and irq */</span>
<span class="p_del">-	MSI_FLAG_IDENTITY_MAP		= (1 &lt;&lt; 2),</span>
 	/* Support multiple PCI MSI interrupts */
<span class="p_del">-	MSI_FLAG_MULTI_PCI_MSI		= (1 &lt;&lt; 3),</span>
<span class="p_add">+	MSI_FLAG_MULTI_PCI_MSI		= (1 &lt;&lt; 2),</span>
 	/* Support PCI MSIX interrupts */
<span class="p_del">-	MSI_FLAG_PCI_MSIX		= (1 &lt;&lt; 4),</span>
<span class="p_add">+	MSI_FLAG_PCI_MSIX		= (1 &lt;&lt; 3),</span>
<span class="p_add">+	/* Needs early activate, required for PCI */</span>
<span class="p_add">+	MSI_FLAG_ACTIVATE_EARLY		= (1 &lt;&lt; 4),</span>
 };
 
 int msi_domain_set_affinity(struct irq_data *data, const struct cpumask *mask,
<span class="p_header">diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h</span>
<span class="p_header">index d9ba49cedc5d..37f05cb1dfd6 100644</span>
<span class="p_header">--- a/include/linux/pci_ids.h</span>
<span class="p_header">+++ b/include/linux/pci_ids.h</span>
<span class="p_chunk">@@ -2495,6 +2495,13 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_KORENIX_JETCARDF2	0x1700
 #define PCI_DEVICE_ID_KORENIX_JETCARDF3	0x17ff
 
<span class="p_add">+#define PCI_VENDOR_ID_NETRONOME		0x19ee</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP3200	0x3200</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP3240	0x3240</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP4000	0x4000</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP6000	0x6000</span>
<span class="p_add">+#define PCI_DEVICE_ID_NETRONOME_NFP6000_VF	0x6003</span>
<span class="p_add">+</span>
 #define PCI_VENDOR_ID_QMI		0x1a32
 
 #define PCI_VENDOR_ID_AZWAVE		0x1a3b
<span class="p_header">diff --git a/include/linux/serio.h b/include/linux/serio.h</span>
<span class="p_header">index df4ab5de1586..c733cff44e18 100644</span>
<span class="p_header">--- a/include/linux/serio.h</span>
<span class="p_header">+++ b/include/linux/serio.h</span>
<span class="p_chunk">@@ -31,7 +31,8 @@</span> <span class="p_context"> struct serio {</span>
 
 	struct serio_device_id id;
 
<span class="p_del">-	spinlock_t lock;		/* protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	/* Protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	spinlock_t lock;</span>
 
 	int (*write)(struct serio *, unsigned char);
 	int (*open)(struct serio *);
<span class="p_chunk">@@ -40,16 +41,29 @@</span> <span class="p_context"> struct serio {</span>
 	void (*stop)(struct serio *);
 
 	struct serio *parent;
<span class="p_del">-	struct list_head child_node;	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	struct list_head child_node;</span>
 	struct list_head children;
<span class="p_del">-	unsigned int depth;		/* level of nesting in serio hierarchy */</span>
<span class="p_add">+	/* Level of nesting in serio hierarchy */</span>
<span class="p_add">+	unsigned int depth;</span>
 
<span class="p_del">-	struct serio_driver *drv;	/* accessed from interrupt, must be protected by serio-&gt;lock and serio-&gt;sem */</span>
<span class="p_del">-	struct mutex drv_mutex;		/* protects serio-&gt;drv so attributes can pin driver */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * serio-&gt;drv is accessed from interrupt handlers; when modifying</span>
<span class="p_add">+	 * caller should acquire serio-&gt;drv_mutex and serio-&gt;lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct serio_driver *drv;</span>
<span class="p_add">+	/* Protects serio-&gt;drv so attributes can pin current driver */</span>
<span class="p_add">+	struct mutex drv_mutex;</span>
 
 	struct device dev;
 
 	struct list_head node;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For use by PS/2 layer when several ports share hardware and</span>
<span class="p_add">+	 * may get indigestion when exposed to concurrent access (i8042).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct mutex *ps2_cmd_mutex;</span>
 };
 #define to_serio_port(d)	container_of(d, struct serio, dev)
 
<span class="p_header">diff --git a/include/uapi/linux/usb/ch9.h b/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">index 4338eb7b09b3..779a62aafafe 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch9.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch9.h</span>
<span class="p_chunk">@@ -954,6 +954,7 @@</span> <span class="p_context"> enum usb_device_speed {</span>
 	USB_SPEED_HIGH,				/* usb 2.0 */
 	USB_SPEED_WIRELESS,			/* wireless (usb 2.5) */
 	USB_SPEED_SUPER,			/* usb 3.0 */
<span class="p_add">+	USB_SPEED_SUPER_PLUS,			/* usb 3.1 */</span>
 };
 
 
<span class="p_header">diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c</span>
<span class="p_header">index 6b0c0b74a2a1..4b21779d5163 100644</span>
<span class="p_header">--- a/kernel/irq/msi.c</span>
<span class="p_header">+++ b/kernel/irq/msi.c</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,</span>
 	struct msi_domain_ops *ops = info-&gt;ops;
 	msi_alloc_info_t arg;
 	struct msi_desc *desc;
<span class="p_del">-	int i, ret, virq = -1;</span>
<span class="p_add">+	int i, ret, virq;</span>
 
 	ret = ops-&gt;msi_check(domain, info, dev);
 	if (ret == 0)
<span class="p_chunk">@@ -278,12 +278,8 @@</span> <span class="p_context"> int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,</span>
 
 	for_each_msi_entry(desc, dev) {
 		ops-&gt;set_desc(&amp;arg, desc);
<span class="p_del">-		if (info-&gt;flags &amp; MSI_FLAG_IDENTITY_MAP)</span>
<span class="p_del">-			virq = (int)ops-&gt;get_hwirq(info, &amp;arg);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			virq = -1;</span>
 
<span class="p_del">-		virq = __irq_domain_alloc_irqs(domain, virq, desc-&gt;nvec_used,</span>
<span class="p_add">+		virq = __irq_domain_alloc_irqs(domain, -1, desc-&gt;nvec_used,</span>
 					       dev_to_node(dev), &amp;arg, false);
 		if (virq &lt; 0) {
 			ret = -ENOSPC;
<span class="p_chunk">@@ -307,6 +303,17 @@</span> <span class="p_context"> int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,</span>
 		else
 			dev_dbg(dev, &quot;irq [%d-%d] for MSI\n&quot;,
 				virq, virq + desc-&gt;nvec_used - 1);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This flag is set by the PCI layer as we need to activate</span>
<span class="p_add">+		 * the MSI entries before the PCI layer enables MSI in the</span>
<span class="p_add">+		 * card. Otherwise the card latches a random msi message.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (info-&gt;flags &amp; MSI_FLAG_ACTIVATE_EARLY) {</span>
<span class="p_add">+			struct irq_data *irq_data;</span>
<span class="p_add">+</span>
<span class="p_add">+			irq_data = irq_domain_get_irq_data(domain, desc-&gt;irq);</span>
<span class="p_add">+			irq_domain_activate_irq(irq_data);</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 67d1e1597d9c..ea863bc22caf 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -627,7 +627,10 @@</span> <span class="p_context"> int get_nohz_timer_target(void)</span>
 	rcu_read_lock();
 	for_each_domain(cpu, sd) {
 		for_each_cpu(i, sched_domain_span(sd)) {
<span class="p_del">-			if (!idle_cpu(i) &amp;&amp; is_housekeeping_cpu(cpu)) {</span>
<span class="p_add">+			if (cpu == i)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!idle_cpu(i) &amp;&amp; is_housekeeping_cpu(i)) {</span>
 				cpu = i;
 				goto unlock;
 			}
<span class="p_header">diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c</span>
<span class="p_header">index f74ea89e77a8..a1aecbedf5b1 100644</span>
<span class="p_header">--- a/kernel/sched/cputime.c</span>
<span class="p_header">+++ b/kernel/sched/cputime.c</span>
<span class="p_chunk">@@ -600,19 +600,25 @@</span> <span class="p_context"> static void cputime_adjust(struct task_cputime *curr,</span>
 	stime = curr-&gt;stime;
 	utime = curr-&gt;utime;
 
<span class="p_del">-	if (utime == 0) {</span>
<span class="p_del">-		stime = rtime;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If either stime or both stime and utime are 0, assume all runtime is</span>
<span class="p_add">+	 * userspace. Once a task gets some ticks, the monotonicy code at</span>
<span class="p_add">+	 * &#39;update&#39; will ensure things converge to the observed ratio.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (stime == 0) {</span>
<span class="p_add">+		utime = rtime;</span>
 		goto update;
 	}
 
<span class="p_del">-	if (stime == 0) {</span>
<span class="p_del">-		utime = rtime;</span>
<span class="p_add">+	if (utime == 0) {</span>
<span class="p_add">+		stime = rtime;</span>
 		goto update;
 	}
 
 	stime = scale_stime((__force u64)stime, (__force u64)rtime,
 			    (__force u64)(stime + utime));
 
<span class="p_add">+update:</span>
 	/*
 	 * Make sure stime doesn&#39;t go backwards; this preserves monotonicity
 	 * for utime because rtime is monotonic.
<span class="p_chunk">@@ -635,7 +641,6 @@</span> <span class="p_context"> static void cputime_adjust(struct task_cputime *curr,</span>
 		stime = rtime - utime;
 	}
 
<span class="p_del">-update:</span>
 	prev-&gt;stime = stime;
 	prev-&gt;utime = utime;
 out:
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 0c31f184daf8..125c7dd55322 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -4213,7 +4213,6 @@</span> <span class="p_context"> pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)</span>
 		if (saddr) {
 			spte = huge_pte_offset(svma-&gt;vm_mm, saddr);
 			if (spte) {
<span class="p_del">-				mm_inc_nr_pmds(mm);</span>
 				get_page(virt_to_page(spte));
 				break;
 			}
<span class="p_chunk">@@ -4228,9 +4227,9 @@</span> <span class="p_context"> pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud)</span>
 	if (pud_none(*pud)) {
 		pud_populate(mm, pud,
 				(pmd_t *)((unsigned long)spte &amp; PAGE_MASK));
<span class="p_add">+		mm_inc_nr_pmds(mm);</span>
 	} else {
 		put_page(virt_to_page(spte));
<span class="p_del">-		mm_inc_nr_pmds(mm);</span>
 	}
 	spin_unlock(ptl);
 out:
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index c12f348138ac..19322c047386 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -865,7 +865,7 @@</span> <span class="p_context"> static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)</span>
 
 	/* free all potentially still buffered bcast frames */
 	local-&gt;total_ps_buffered -= skb_queue_len(&amp;sdata-&gt;u.ap.ps.bc_buf);
<span class="p_del">-	skb_queue_purge(&amp;sdata-&gt;u.ap.ps.bc_buf);</span>
<span class="p_add">+	ieee80211_purge_tx_queue(&amp;local-&gt;hw, &amp;sdata-&gt;u.ap.ps.bc_buf);</span>
 
 	mutex_lock(&amp;local-&gt;mtx);
 	ieee80211_vif_copy_chanctx_to_vlans(sdata, true);
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index bdc224d5053a..e1225b395415 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -365,7 +365,7 @@</span> <span class="p_context"> static void purge_old_ps_buffers(struct ieee80211_local *local)</span>
 		skb = skb_dequeue(&amp;ps-&gt;bc_buf);
 		if (skb) {
 			purged++;
<span class="p_del">-			dev_kfree_skb(skb);</span>
<span class="p_add">+			ieee80211_free_txskb(&amp;local-&gt;hw, skb);</span>
 		}
 		total += skb_queue_len(&amp;ps-&gt;bc_buf);
 	}
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)</span>
 	if (skb_queue_len(&amp;ps-&gt;bc_buf) &gt;= AP_MAX_BC_BUFFER) {
 		ps_dbg(tx-&gt;sdata,
 		       &quot;BC TX buffer full - dropping the oldest frame\n&quot;);
<span class="p_del">-		dev_kfree_skb(skb_dequeue(&amp;ps-&gt;bc_buf));</span>
<span class="p_add">+		ieee80211_free_txskb(&amp;tx-&gt;local-&gt;hw, skb_dequeue(&amp;ps-&gt;bc_buf));</span>
 	} else
 		tx-&gt;local-&gt;total_ps_buffered++;
 
<span class="p_chunk">@@ -3781,7 +3781,7 @@</span> <span class="p_context"> ieee80211_get_buffered_bc(struct ieee80211_hw *hw,</span>
 			sdata = IEEE80211_DEV_TO_SUB_IF(skb-&gt;dev);
 		if (!ieee80211_tx_prepare(sdata, &amp;tx, NULL, skb))
 			break;
<span class="p_del">-		dev_kfree_skb_any(skb);</span>
<span class="p_add">+		ieee80211_free_txskb(hw, skb);</span>
 	}
 
 	info = IEEE80211_SKB_CB(skb);
<span class="p_header">diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_header">index 799e65b944b9..06095cc8815e 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_chunk">@@ -340,12 +340,14 @@</span> <span class="p_context"> gss_release_msg(struct gss_upcall_msg *gss_msg)</span>
 }
 
 static struct gss_upcall_msg *
<span class="p_del">-__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid)</span>
<span class="p_add">+__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid, const struct gss_auth *auth)</span>
 {
 	struct gss_upcall_msg *pos;
 	list_for_each_entry(pos, &amp;pipe-&gt;in_downcall, list) {
 		if (!uid_eq(pos-&gt;uid, uid))
 			continue;
<span class="p_add">+		if (auth &amp;&amp; pos-&gt;auth-&gt;service != auth-&gt;service)</span>
<span class="p_add">+			continue;</span>
 		atomic_inc(&amp;pos-&gt;count);
 		dprintk(&quot;RPC:       %s found msg %p\n&quot;, __func__, pos);
 		return pos;
<span class="p_chunk">@@ -365,7 +367,7 @@</span> <span class="p_context"> gss_add_msg(struct gss_upcall_msg *gss_msg)</span>
 	struct gss_upcall_msg *old;
 
 	spin_lock(&amp;pipe-&gt;lock);
<span class="p_del">-	old = __gss_find_upcall(pipe, gss_msg-&gt;uid);</span>
<span class="p_add">+	old = __gss_find_upcall(pipe, gss_msg-&gt;uid, gss_msg-&gt;auth);</span>
 	if (old == NULL) {
 		atomic_inc(&amp;gss_msg-&gt;count);
 		list_add(&amp;gss_msg-&gt;list, &amp;pipe-&gt;in_downcall);
<span class="p_chunk">@@ -714,7 +716,7 @@</span> <span class="p_context"> gss_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)</span>
 	err = -ENOENT;
 	/* Find a matching upcall */
 	spin_lock(&amp;pipe-&gt;lock);
<span class="p_del">-	gss_msg = __gss_find_upcall(pipe, uid);</span>
<span class="p_add">+	gss_msg = __gss_find_upcall(pipe, uid, NULL);</span>
 	if (gss_msg == NULL) {
 		spin_unlock(&amp;pipe-&gt;lock);
 		goto err_put_ctx;
<span class="p_header">diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c</span>
<span class="p_header">index 027c9ef8a263..1ba417207465 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtsock.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtsock.c</span>
<span class="p_chunk">@@ -2286,6 +2286,10 @@</span> <span class="p_context"> static int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)</span>
 		/* SYN_SENT! */
 		if (xprt-&gt;reestablish_timeout &lt; XS_TCP_INIT_REEST_TO)
 			xprt-&gt;reestablish_timeout = XS_TCP_INIT_REEST_TO;
<span class="p_add">+		break;</span>
<span class="p_add">+	case -EADDRNOTAVAIL:</span>
<span class="p_add">+		/* Source port number is unavailable. Try a new one! */</span>
<span class="p_add">+		transport-&gt;srcport = 0;</span>
 	}
 out:
 	return ret;
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index e769e5764cba..12f7f6fdae4d 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -944,20 +944,23 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip;
 	struct hda_intel *hda;
<span class="p_add">+	struct hdac_bus *bus;</span>
 
 	if (!card)
 		return 0;
 
 	chip = card-&gt;private_data;
 	hda = container_of(chip, struct hda_intel, chip);
<span class="p_add">+	bus = azx_bus(chip);</span>
 	if (chip-&gt;disabled || hda-&gt;init_failed || !chip-&gt;running)
 		return 0;
 
<span class="p_del">-	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL</span>
<span class="p_del">-		&amp;&amp; hda-&gt;need_i915_power) {</span>
<span class="p_del">-		snd_hdac_display_power(azx_bus(chip), true);</span>
<span class="p_del">-		haswell_set_bclk(hda);</span>
<span class="p_add">+	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) {</span>
<span class="p_add">+		snd_hdac_display_power(bus, true);</span>
<span class="p_add">+		if (hda-&gt;need_i915_power)</span>
<span class="p_add">+			haswell_set_bclk(hda);</span>
 	}
<span class="p_add">+</span>
 	if (chip-&gt;msi)
 		if (pci_enable_msi(pci) &lt; 0)
 			chip-&gt;msi = 0;
<span class="p_chunk">@@ -967,6 +970,11 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 
 	hda_intel_init_chip(chip, true);
 
<span class="p_add">+	/* power down again for link-controlled chips */</span>
<span class="p_add">+	if ((chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) &amp;&amp;</span>
<span class="p_add">+	    !hda-&gt;need_i915_power)</span>
<span class="p_add">+		snd_hdac_display_power(bus, false);</span>
<span class="p_add">+</span>
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 
 	trace_azx_resume(chip);
<span class="p_chunk">@@ -1046,6 +1054,7 @@</span> <span class="p_context"> static int azx_runtime_resume(struct device *dev)</span>
 
 	chip = card-&gt;private_data;
 	hda = container_of(chip, struct hda_intel, chip);
<span class="p_add">+	bus = azx_bus(chip);</span>
 	if (chip-&gt;disabled || hda-&gt;init_failed)
 		return 0;
 
<span class="p_chunk">@@ -1053,15 +1062,9 @@</span> <span class="p_context"> static int azx_runtime_resume(struct device *dev)</span>
 		return 0;
 
 	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) {
<span class="p_del">-		bus = azx_bus(chip);</span>
<span class="p_del">-		if (hda-&gt;need_i915_power) {</span>
<span class="p_del">-			snd_hdac_display_power(bus, true);</span>
<span class="p_add">+		snd_hdac_display_power(bus, true);</span>
<span class="p_add">+		if (hda-&gt;need_i915_power)</span>
 			haswell_set_bclk(hda);
<span class="p_del">-		} else {</span>
<span class="p_del">-			/* toggle codec wakeup bit for STATESTS read */</span>
<span class="p_del">-			snd_hdac_set_codec_wakeup(bus, true);</span>
<span class="p_del">-			snd_hdac_set_codec_wakeup(bus, false);</span>
<span class="p_del">-		}</span>
 	}
 
 	/* Read STATESTS before controller reset */
<span class="p_chunk">@@ -1081,6 +1084,11 @@</span> <span class="p_context"> static int azx_runtime_resume(struct device *dev)</span>
 	azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) &amp;
 			~STATESTS_INT_MASK);
 
<span class="p_add">+	/* power down again for link-controlled chips */</span>
<span class="p_add">+	if ((chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) &amp;&amp;</span>
<span class="p_add">+	    !hda-&gt;need_i915_power)</span>
<span class="p_add">+		snd_hdac_display_power(bus, false);</span>
<span class="p_add">+</span>
 	trace_azx_runtime_resume(chip);
 	return 0;
 }
<span class="p_header">diff --git a/sound/usb/line6/pcm.c b/sound/usb/line6/pcm.c</span>
<span class="p_header">index 204cc074adb9..41aa3355e920 100644</span>
<span class="p_header">--- a/sound/usb/line6/pcm.c</span>
<span class="p_header">+++ b/sound/usb/line6/pcm.c</span>
<span class="p_chunk">@@ -55,7 +55,6 @@</span> <span class="p_context"> static int snd_line6_impulse_volume_put(struct snd_kcontrol *kcontrol,</span>
 		err = line6_pcm_acquire(line6pcm, LINE6_STREAM_IMPULSE);
 		if (err &lt; 0) {
 			line6pcm-&gt;impulse_volume = 0;
<span class="p_del">-			line6_pcm_release(line6pcm, LINE6_STREAM_IMPULSE);</span>
 			return err;
 		}
 	} else {
<span class="p_chunk">@@ -211,7 +210,9 @@</span> <span class="p_context"> static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,</span>
 	spin_lock_irqsave(&amp;pstr-&gt;lock, flags);
 	clear_bit(type, &amp;pstr-&gt;running);
 	if (!pstr-&gt;running) {
<span class="p_add">+		spin_unlock_irqrestore(&amp;pstr-&gt;lock, flags);</span>
 		line6_unlink_audio_urbs(line6pcm, pstr);
<span class="p_add">+		spin_lock_irqsave(&amp;pstr-&gt;lock, flags);</span>
 		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
 			line6pcm-&gt;prev_fbuf = NULL;
 			line6pcm-&gt;prev_fsize = 0;
<span class="p_header">diff --git a/sound/usb/line6/pod.c b/sound/usb/line6/pod.c</span>
<span class="p_header">index daf81d169a42..45dd34874f43 100644</span>
<span class="p_header">--- a/sound/usb/line6/pod.c</span>
<span class="p_header">+++ b/sound/usb/line6/pod.c</span>
<span class="p_chunk">@@ -244,8 +244,8 @@</span> <span class="p_context"> static int pod_set_system_param_int(struct usb_line6_pod *pod, int value,</span>
 static ssize_t serial_number_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
<span class="p_del">-	struct usb_interface *interface = to_usb_interface(dev);</span>
<span class="p_del">-	struct usb_line6_pod *pod = usb_get_intfdata(interface);</span>
<span class="p_add">+	struct snd_card *card = dev_to_snd_card(dev);</span>
<span class="p_add">+	struct usb_line6_pod *pod = card-&gt;private_data;</span>
 
 	return sprintf(buf, &quot;%u\n&quot;, pod-&gt;serial_number);
 }
<span class="p_chunk">@@ -256,8 +256,8 @@</span> <span class="p_context"> static ssize_t serial_number_show(struct device *dev,</span>
 static ssize_t firmware_version_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
<span class="p_del">-	struct usb_interface *interface = to_usb_interface(dev);</span>
<span class="p_del">-	struct usb_line6_pod *pod = usb_get_intfdata(interface);</span>
<span class="p_add">+	struct snd_card *card = dev_to_snd_card(dev);</span>
<span class="p_add">+	struct usb_line6_pod *pod = card-&gt;private_data;</span>
 
 	return sprintf(buf, &quot;%d.%02d\n&quot;, pod-&gt;firmware_version / 100,
 		       pod-&gt;firmware_version % 100);
<span class="p_chunk">@@ -269,8 +269,8 @@</span> <span class="p_context"> static ssize_t firmware_version_show(struct device *dev,</span>
 static ssize_t device_id_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
<span class="p_del">-	struct usb_interface *interface = to_usb_interface(dev);</span>
<span class="p_del">-	struct usb_line6_pod *pod = usb_get_intfdata(interface);</span>
<span class="p_add">+	struct snd_card *card = dev_to_snd_card(dev);</span>
<span class="p_add">+	struct usb_line6_pod *pod = card-&gt;private_data;</span>
 
 	return sprintf(buf, &quot;%d\n&quot;, pod-&gt;device_id);
 }
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index db11ecf0b74d..a3e1252ce242 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1129,6 +1129,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 {
 	/* devices which do not support reading the sample rate. */
 	switch (chip-&gt;usb_id) {
<span class="p_add">+	case USB_ID(0x041E, 0x4080): /* Creative Live Cam VF0610 */</span>
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
 	case USB_ID(0x045E, 0x076E): /* MS Lifecam HD-5001 */
<span class="p_chunk">@@ -1139,6 +1140,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
<span class="p_add">+	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */</span>
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */
<span class="p_header">diff --git a/tools/perf/arch/x86/util/intel-pt.c b/tools/perf/arch/x86/util/intel-pt.c</span>
<span class="p_header">index b02af064f0f9..c53f78767568 100644</span>
<span class="p_header">--- a/tools/perf/arch/x86/util/intel-pt.c</span>
<span class="p_header">+++ b/tools/perf/arch/x86/util/intel-pt.c</span>
<span class="p_chunk">@@ -499,7 +499,7 @@</span> <span class="p_context"> static int intel_pt_recording_options(struct auxtrace_record *itr,</span>
 	struct intel_pt_recording *ptr =
 			container_of(itr, struct intel_pt_recording, itr);
 	struct perf_pmu *intel_pt_pmu = ptr-&gt;intel_pt_pmu;
<span class="p_del">-	bool have_timing_info;</span>
<span class="p_add">+	bool have_timing_info, need_immediate = false;</span>
 	struct perf_evsel *evsel, *intel_pt_evsel = NULL;
 	const struct cpu_map *cpus = evlist-&gt;cpus;
 	bool privileged = geteuid() == 0 || perf_event_paranoid() &lt; 0;
<span class="p_chunk">@@ -653,6 +653,7 @@</span> <span class="p_context"> static int intel_pt_recording_options(struct auxtrace_record *itr,</span>
 				ptr-&gt;have_sched_switch = 3;
 			} else {
 				opts-&gt;record_switch_events = true;
<span class="p_add">+				need_immediate = true;</span>
 				if (cpu_wide)
 					ptr-&gt;have_sched_switch = 3;
 				else
<span class="p_chunk">@@ -698,6 +699,9 @@</span> <span class="p_context"> static int intel_pt_recording_options(struct auxtrace_record *itr,</span>
 		tracking_evsel-&gt;attr.freq = 0;
 		tracking_evsel-&gt;attr.sample_period = 1;
 
<span class="p_add">+		if (need_immediate)</span>
<span class="p_add">+			tracking_evsel-&gt;immediate = true;</span>
<span class="p_add">+</span>
 		/* In per-cpu case, always need the time of mmap events etc */
 		if (!cpu_map__empty(cpus)) {
 			perf_evsel__set_sample_bit(tracking_evsel, TIME);
<span class="p_header">diff --git a/tools/testing/nvdimm/test/nfit.c b/tools/testing/nvdimm/test/nfit.c</span>
<span class="p_header">index 51cf8256c6cd..f0d1c8ff8e8a 100644</span>
<span class="p_header">--- a/tools/testing/nvdimm/test/nfit.c</span>
<span class="p_header">+++ b/tools/testing/nvdimm/test/nfit.c</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 #define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/libnvdimm.h&gt;
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/device.h&gt;
<span class="p_chunk">@@ -1246,6 +1247,7 @@</span> <span class="p_context"> static int nfit_test_probe(struct platform_device *pdev)</span>
 	if (nfit_test-&gt;setup != nfit_test0_setup)
 		return 0;
 
<span class="p_add">+	flush_work(&amp;acpi_desc-&gt;work);</span>
 	nfit_test-&gt;setup_hotplug = 1;
 	nfit_test-&gt;setup(nfit_test);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



