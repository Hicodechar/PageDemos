
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>x86/mm/KASLR: Do not adapt the size of the direct mapping section for SGI UV system - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    x86/mm/KASLR: Do not adapt the size of the direct mapping section for SGI UV system</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=73061">Baoquan He</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 18, 2017, 6:52 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1495090323-21679-1-git-send-email-bhe@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9732787/mbox/"
   >mbox</a>
|
   <a href="/patch/9732787/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9732787/">/patch/9732787/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2B8E46022E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 18 May 2017 06:53:11 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id F306A2878C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 18 May 2017 06:53:10 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E7909287C3; Thu, 18 May 2017 06:53:10 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 43D23287C1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 18 May 2017 06:53:10 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753663AbdERGxI (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 18 May 2017 02:53:08 -0400
Received: from mx1.redhat.com ([209.132.183.28]:35924 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1754490AbdERGwP (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 18 May 2017 02:52:15 -0400
Received: from smtp.corp.redhat.com
	(int-mx01.intmail.prod.int.phx2.redhat.com [10.5.11.11])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id 365B2285A0;
	Thu, 18 May 2017 06:52:14 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.3.2 mx1.redhat.com 365B2285A0
Authentication-Results: ext-mx06.extmail.prod.ext.phx2.redhat.com;
	dmarc=none (p=none dis=none) header.from=redhat.com
Authentication-Results: ext-mx06.extmail.prod.ext.phx2.redhat.com;
	spf=pass smtp.mailfrom=bhe@redhat.com
DKIM-Filter: OpenDKIM Filter v2.11.0 mx1.redhat.com 365B2285A0
Received: from x1.redhat.com (ovpn-12-33.pek2.redhat.com [10.72.12.33])
	by smtp.corp.redhat.com (Postfix) with ESMTP id 8F9075C461;
	Thu, 18 May 2017 06:52:06 +0000 (UTC)
From: Baoquan He &lt;bhe@redhat.com&gt;
To: linux-kernel@vger.kernel.org
Cc: Baoquan He &lt;bhe@redhat.com&gt;, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	Ingo Molnar &lt;mingo@redhat.com&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;, x86@kernel.org,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	&quot;travis@sgi.com&quot; &lt;travis@sgi.com&gt;, Dimitri Sivanich &lt;sivanich@hpe.com&gt;,
	Thomas Garnier &lt;thgarnie@google.com&gt;, Kees Cook &lt;keescook@chromium.org&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;,
	Russ Anderson &lt;rja@sgi.com&gt;, Frank Ramsay &lt;frank.ramsay@hpe.com&gt;
Subject: [PATCH] x86/mm/KASLR: Do not adapt the size of the direct mapping
	section for SGI UV system
Date: Thu, 18 May 2017 14:52:03 +0800
Message-Id: &lt;1495090323-21679-1-git-send-email-bhe@redhat.com&gt;
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.11
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.30]);
	Thu, 18 May 2017 06:52:14 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - May 18, 2017, 6:52 a.m.</div>
<pre class="content">
On SGI UV system, kernel casually hang with kaslr enabled.

The back trace is:

kernel BUG at arch/x86/mm/init_64.c:311!
invalid opcode: 0000 [#1] SMP
[...]
RIP: 0010:__init_extra_mapping+0x188/0x196
[...]
Call Trace:
 init_extra_mapping_uc+0x13/0x15
 map_high+0x67/0x75
 map_mmioh_high_uv3+0x20a/0x219
 uv_system_init_hub+0x12d9/0x1496
 uv_system_init+0x27/0x29
 native_smp_prepare_cpus+0x28d/0x2d8
 kernel_init_freeable+0xdd/0x253
 ? rest_init+0x80/0x80
 kernel_init+0xe/0x110
 ret_from_fork+0x2c/0x40

The root cause is SGI UV system needs map its MMIOH region to direct
mapping section.

When kaslr disabled, there are 64TB space for system RAM to do direct
mapping. Both system RAM and SGI UV MMIOH region share this 64TB space.
However with kaslr enabled, mm KASLR only reserves the actual size of
system RAM plus 10TB for direct mapping usage. Then MMIOH mapping of
SGI UV could go beyond the upper bound of direct mapping section to step
into VMALLOC or VMEMMAP area. Then the BUG_ON() in __init_extra_mapping()
will be triggered.

E.g on the SGI UV3 machine where this bug is reported , there are two MMIOH
regions:

[    1.519001] UV: Map MMIOH0_HI 0xffc00000000 - 0x100000000000
[    1.523001] UV: Map MMIOH1_HI 0x100000000000 - 0x200000000000

They are [16TB-16G, 16TB) and [16TB, 32TB). On this machine, 512G ram are
spread out to 1TB regions. Then above two SGI MMIOH regions also will be
mapped into the direct mapping section. The point is that SGI UV maps its
MMIOH regions to the direct mapping section in uv_system_init() which is
called during kernel_init_freeable(). It&#39;s much later than
kernel_randomize_memory(). Mm KASLR has no chance to take it into
consideration.

To fix it, we need detect if it&#39;s SGI UV system early, then do not adapt
the size of the direct mapping section in kernel_randomize_memory() if yes.
According to discussion with SGI developer, &quot;The SGI bios adds UVsystab.
Only systems running SGI bios (and now HPE Hawks2) will have UVsystab.&quot;

Hence check if UVsystab is present, if yes, do not adapt the size of the
direct mapping section in kernel_randomize_memory()
<span class="signed-off-by">
Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
Cc: Ingo Molnar &lt;mingo@redhat.com&gt;
Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;
Cc: x86@kernel.org
Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;
Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;
Cc: &quot;travis@sgi.com&quot; &lt;travis@sgi.com&gt;
Cc: Dimitri Sivanich &lt;sivanich@hpe.com&gt;
Cc: Thomas Garnier &lt;thgarnie@google.com&gt;
Cc: Kees Cook &lt;keescook@chromium.org&gt;
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Cc: Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;
Cc: Russ Anderson &lt;rja@sgi.com&gt;
Cc: Frank Ramsay &lt;frank.ramsay@hpe.com&gt;
linux-efi@vger.kernel.org
---
 arch/x86/include/asm/uv/uv.h | 2 ++
 arch/x86/mm/kaslr.c          | 4 +++-
 arch/x86/platform/efi/efi.c  | 7 +++++++
 3 files changed, 12 insertions(+), 1 deletion(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=173103">Mike Travis</a> - May 18, 2017, 8:26 p.m.</div>
<pre class="content">
Hi Baoquan He,

The concept of the patch is correct (since it is I as sent :),
but I would prefer that the entire is_early_uv_system() be put
into the uv.h file.  Primarily because we may need to change
that in the future so having UV specific code in other places
than under platform/uv is not that desirable.  Plus I think it&#39;s
better to consolidate the logic in one place.

Making it an inline function in uv.h is fine for now.  If we
need to change it, I&#39;ll move it to the UV specific init
function.

And if it&#39;s alright with others, you should add the #include
of the efi.h header file under the part of uv.h that has
#ifdef CONFIG_X86_UV defined.

That would mean the KASLR function would only add an
#include &lt;asm/uv/uv.h&gt; to access that UV specific funtion.

Thanks,
Mike

On 5/17/2017 11:52 PM, Baoquan He wrote:
<span class="quote">&gt; On SGI UV system, kernel casually hang with kaslr enabled.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The back trace is:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; kernel BUG at arch/x86/mm/init_64.c:311!</span>
<span class="quote">&gt; invalid opcode: 0000 [#1] SMP</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; RIP: 0010:__init_extra_mapping+0x188/0x196</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; Call Trace:</span>
<span class="quote">&gt;  init_extra_mapping_uc+0x13/0x15</span>
<span class="quote">&gt;  map_high+0x67/0x75</span>
<span class="quote">&gt;  map_mmioh_high_uv3+0x20a/0x219</span>
<span class="quote">&gt;  uv_system_init_hub+0x12d9/0x1496</span>
<span class="quote">&gt;  uv_system_init+0x27/0x29</span>
<span class="quote">&gt;  native_smp_prepare_cpus+0x28d/0x2d8</span>
<span class="quote">&gt;  kernel_init_freeable+0xdd/0x253</span>
<span class="quote">&gt;  ? rest_init+0x80/0x80</span>
<span class="quote">&gt;  kernel_init+0xe/0x110</span>
<span class="quote">&gt;  ret_from_fork+0x2c/0x40</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The root cause is SGI UV system needs map its MMIOH region to direct</span>
<span class="quote">&gt; mapping section.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When kaslr disabled, there are 64TB space for system RAM to do direct</span>
<span class="quote">&gt; mapping. Both system RAM and SGI UV MMIOH region share this 64TB space.</span>
<span class="quote">&gt; However with kaslr enabled, mm KASLR only reserves the actual size of</span>
<span class="quote">&gt; system RAM plus 10TB for direct mapping usage. Then MMIOH mapping of</span>
<span class="quote">&gt; SGI UV could go beyond the upper bound of direct mapping section to step</span>
<span class="quote">&gt; into VMALLOC or VMEMMAP area. Then the BUG_ON() in __init_extra_mapping()</span>
<span class="quote">&gt; will be triggered.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; E.g on the SGI UV3 machine where this bug is reported , there are two MMIOH</span>
<span class="quote">&gt; regions:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [    1.519001] UV: Map MMIOH0_HI 0xffc00000000 - 0x100000000000</span>
<span class="quote">&gt; [    1.523001] UV: Map MMIOH1_HI 0x100000000000 - 0x200000000000</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; They are [16TB-16G, 16TB) and [16TB, 32TB). On this machine, 512G ram are</span>
<span class="quote">&gt; spread out to 1TB regions. Then above two SGI MMIOH regions also will be</span>
<span class="quote">&gt; mapped into the direct mapping section. The point is that SGI UV maps its</span>
<span class="quote">&gt; MMIOH regions to the direct mapping section in uv_system_init() which is</span>
<span class="quote">&gt; called during kernel_init_freeable(). It&#39;s much later than</span>
<span class="quote">&gt; kernel_randomize_memory(). Mm KASLR has no chance to take it into</span>
<span class="quote">&gt; consideration.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; To fix it, we need detect if it&#39;s SGI UV system early, then do not adapt</span>
<span class="quote">&gt; the size of the direct mapping section in kernel_randomize_memory() if yes.</span>
<span class="quote">&gt; According to discussion with SGI developer, &quot;The SGI bios adds UVsystab.</span>
<span class="quote">&gt; Only systems running SGI bios (and now HPE Hawks2) will have UVsystab.&quot;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hence check if UVsystab is present, if yes, do not adapt the size of the</span>
<span class="quote">&gt; direct mapping section in kernel_randomize_memory()</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt; Cc: Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="quote">&gt; Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="quote">&gt; Cc: x86@kernel.org</span>
<span class="quote">&gt; Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;</span>
<span class="quote">&gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt; Cc: &quot;travis@sgi.com&quot; &lt;travis@sgi.com&gt;</span>
<span class="quote">&gt; Cc: Dimitri Sivanich &lt;sivanich@hpe.com&gt;</span>
<span class="quote">&gt; Cc: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">&gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt; Cc: Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;</span>
<span class="quote">&gt; Cc: Russ Anderson &lt;rja@sgi.com&gt;</span>
<span class="quote">&gt; Cc: Frank Ramsay &lt;frank.ramsay@hpe.com&gt;</span>
<span class="quote">&gt; linux-efi@vger.kernel.org</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/include/asm/uv/uv.h | 2 ++</span>
<span class="quote">&gt;  arch/x86/mm/kaslr.c          | 4 +++-</span>
<span class="quote">&gt;  arch/x86/platform/efi/efi.c  | 7 +++++++</span>
<span class="quote">&gt;  3 files changed, 12 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/x86/include/asm/uv/uv.h b/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt; index 6686820..0275776 100644</span>
<span class="quote">&gt; --- a/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt; +++ b/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt; @@ -11,6 +11,7 @@ struct mm_struct;</span>
<span class="quote">&gt;  extern enum uv_system_type get_uv_system_type(void);</span>
<span class="quote">&gt;  extern int is_uv_system(void);</span>
<span class="quote">&gt;  extern int is_uv_hubless(void);</span>
<span class="quote">&gt; +extern int is_early_uv_system(void);</span>
<span class="quote">&gt;  extern void uv_cpu_init(void);</span>
<span class="quote">&gt;  extern void uv_nmi_init(void);</span>
<span class="quote">&gt;  extern void uv_system_init(void);</span>
<span class="quote">&gt; @@ -25,6 +26,7 @@ extern const struct cpumask *uv_flush_tlb_others(const struct cpumask *cpumask,</span>
<span class="quote">&gt;  static inline enum uv_system_type get_uv_system_type(void) { return UV_NONE; }</span>
<span class="quote">&gt;  static inline int is_uv_system(void)	{ return 0; }</span>
<span class="quote">&gt;  static inline int is_uv_hubless(void)	{ return 0; }</span>
<span class="quote">&gt; +static inline int is_early_uv_system(void)	{ return 0; }</span>
<span class="quote">&gt;  static inline void uv_cpu_init(void)	{ }</span>
<span class="quote">&gt;  static inline void uv_system_init(void)	{ }</span>
<span class="quote">&gt;  static inline const struct cpumask *</span>
<span class="quote">&gt; diff --git a/arch/x86/mm/kaslr.c b/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt; index aed2064..b75e1f5 100644</span>
<span class="quote">&gt; --- a/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt; +++ b/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt; @@ -22,11 +22,13 @@</span>
<span class="quote">&gt;  #include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/init.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/random.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/efi.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/setup.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/kaslr.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/uv/uv.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &quot;mm_internal.h&quot;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -123,7 +125,7 @@ void __init kernel_randomize_memory(void)</span>
<span class="quote">&gt;  		CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* Adapt phyiscal memory region size based on available memory */</span>
<span class="quote">&gt; -	if (memory_tb &lt; kaslr_regions[0].size_tb)</span>
<span class="quote">&gt; +	if (memory_tb &lt; kaslr_regions[0].size_tb &amp;&amp; !is_early_uv_system())</span>
<span class="quote">&gt;  		kaslr_regions[0].size_tb = memory_tb;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* Calculate entropy available between regions */</span>
<span class="quote">&gt; diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt; index 7e76a4d..b71e01d 100644</span>
<span class="quote">&gt; --- a/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt; +++ b/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt; @@ -74,6 +74,13 @@ static int __init setup_add_efi_memmap(char *arg)</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  early_param(&quot;add_efi_memmap&quot;, setup_add_efi_memmap);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#ifdef CONFIG_X86_UV</span>
<span class="quote">&gt; +int is_early_uv_system(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return !((efi.uv_systab == EFI_INVALID_TABLE_ADDR) || !efi.uv_systab);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static efi_status_t __init phys_efi_set_virtual_address_map(</span>
<span class="quote">&gt;  	unsigned long memory_map_size,</span>
<span class="quote">&gt;  	unsigned long descriptor_size,</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=173103">Mike Travis</a> - May 18, 2017, 8:28 p.m.</div>
<pre class="content">
Sorry, I forgot to add that perhaps the adding of the
is_early_uv_system() function be put into a separate
patch as well.

Thanks.

On 5/18/2017 1:26 PM, Mike Travis wrote:
<span class="quote">&gt; Hi Baoquan He,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The concept of the patch is correct (since it is I as sent :),</span>
<span class="quote">&gt; but I would prefer that the entire is_early_uv_system() be put</span>
<span class="quote">&gt; into the uv.h file.  Primarily because we may need to change</span>
<span class="quote">&gt; that in the future so having UV specific code in other places</span>
<span class="quote">&gt; than under platform/uv is not that desirable.  Plus I think it&#39;s</span>
<span class="quote">&gt; better to consolidate the logic in one place.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Making it an inline function in uv.h is fine for now.  If we</span>
<span class="quote">&gt; need to change it, I&#39;ll move it to the UV specific init</span>
<span class="quote">&gt; function.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And if it&#39;s alright with others, you should add the #include</span>
<span class="quote">&gt; of the efi.h header file under the part of uv.h that has</span>
<span class="quote">&gt; #ifdef CONFIG_X86_UV defined.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That would mean the KASLR function would only add an</span>
<span class="quote">&gt; #include &lt;asm/uv/uv.h&gt; to access that UV specific funtion.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Mike</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 5/17/2017 11:52 PM, Baoquan He wrote:</span>
<span class="quote">&gt;&gt; On SGI UV system, kernel casually hang with kaslr enabled.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The back trace is:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; kernel BUG at arch/x86/mm/init_64.c:311!</span>
<span class="quote">&gt;&gt; invalid opcode: 0000 [#1] SMP</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt; RIP: 0010:__init_extra_mapping+0x188/0x196</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt; Call Trace:</span>
<span class="quote">&gt;&gt;  init_extra_mapping_uc+0x13/0x15</span>
<span class="quote">&gt;&gt;  map_high+0x67/0x75</span>
<span class="quote">&gt;&gt;  map_mmioh_high_uv3+0x20a/0x219</span>
<span class="quote">&gt;&gt;  uv_system_init_hub+0x12d9/0x1496</span>
<span class="quote">&gt;&gt;  uv_system_init+0x27/0x29</span>
<span class="quote">&gt;&gt;  native_smp_prepare_cpus+0x28d/0x2d8</span>
<span class="quote">&gt;&gt;  kernel_init_freeable+0xdd/0x253</span>
<span class="quote">&gt;&gt;  ? rest_init+0x80/0x80</span>
<span class="quote">&gt;&gt;  kernel_init+0xe/0x110</span>
<span class="quote">&gt;&gt;  ret_from_fork+0x2c/0x40</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The root cause is SGI UV system needs map its MMIOH region to direct</span>
<span class="quote">&gt;&gt; mapping section.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; When kaslr disabled, there are 64TB space for system RAM to do direct</span>
<span class="quote">&gt;&gt; mapping. Both system RAM and SGI UV MMIOH region share this 64TB space.</span>
<span class="quote">&gt;&gt; However with kaslr enabled, mm KASLR only reserves the actual size of</span>
<span class="quote">&gt;&gt; system RAM plus 10TB for direct mapping usage. Then MMIOH mapping of</span>
<span class="quote">&gt;&gt; SGI UV could go beyond the upper bound of direct mapping section to step</span>
<span class="quote">&gt;&gt; into VMALLOC or VMEMMAP area. Then the BUG_ON() in __init_extra_mapping()</span>
<span class="quote">&gt;&gt; will be triggered.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; E.g on the SGI UV3 machine where this bug is reported , there are two MMIOH</span>
<span class="quote">&gt;&gt; regions:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [    1.519001] UV: Map MMIOH0_HI 0xffc00000000 - 0x100000000000</span>
<span class="quote">&gt;&gt; [    1.523001] UV: Map MMIOH1_HI 0x100000000000 - 0x200000000000</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; They are [16TB-16G, 16TB) and [16TB, 32TB). On this machine, 512G ram are</span>
<span class="quote">&gt;&gt; spread out to 1TB regions. Then above two SGI MMIOH regions also will be</span>
<span class="quote">&gt;&gt; mapped into the direct mapping section. The point is that SGI UV maps its</span>
<span class="quote">&gt;&gt; MMIOH regions to the direct mapping section in uv_system_init() which is</span>
<span class="quote">&gt;&gt; called during kernel_init_freeable(). It&#39;s much later than</span>
<span class="quote">&gt;&gt; kernel_randomize_memory(). Mm KASLR has no chance to take it into</span>
<span class="quote">&gt;&gt; consideration.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; To fix it, we need detect if it&#39;s SGI UV system early, then do not adapt</span>
<span class="quote">&gt;&gt; the size of the direct mapping section in kernel_randomize_memory() if yes.</span>
<span class="quote">&gt;&gt; According to discussion with SGI developer, &quot;The SGI bios adds UVsystab.</span>
<span class="quote">&gt;&gt; Only systems running SGI bios (and now HPE Hawks2) will have UVsystab.&quot;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Hence check if UVsystab is present, if yes, do not adapt the size of the</span>
<span class="quote">&gt;&gt; direct mapping section in kernel_randomize_memory()</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt;&gt; Cc: Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="quote">&gt;&gt; Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="quote">&gt;&gt; Cc: x86@kernel.org</span>
<span class="quote">&gt;&gt; Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;</span>
<span class="quote">&gt;&gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt;&gt; Cc: &quot;travis@sgi.com&quot; &lt;travis@sgi.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Dimitri Sivanich &lt;sivanich@hpe.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt;&gt; Cc: Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Russ Anderson &lt;rja@sgi.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Frank Ramsay &lt;frank.ramsay@hpe.com&gt;</span>
<span class="quote">&gt;&gt; linux-efi@vger.kernel.org</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/x86/include/asm/uv/uv.h | 2 ++</span>
<span class="quote">&gt;&gt;  arch/x86/mm/kaslr.c          | 4 +++-</span>
<span class="quote">&gt;&gt;  arch/x86/platform/efi/efi.c  | 7 +++++++</span>
<span class="quote">&gt;&gt;  3 files changed, 12 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/include/asm/uv/uv.h b/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt;&gt; index 6686820..0275776 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt;&gt; @@ -11,6 +11,7 @@ struct mm_struct;</span>
<span class="quote">&gt;&gt;  extern enum uv_system_type get_uv_system_type(void);</span>
<span class="quote">&gt;&gt;  extern int is_uv_system(void);</span>
<span class="quote">&gt;&gt;  extern int is_uv_hubless(void);</span>
<span class="quote">&gt;&gt; +extern int is_early_uv_system(void);</span>
<span class="quote">&gt;&gt;  extern void uv_cpu_init(void);</span>
<span class="quote">&gt;&gt;  extern void uv_nmi_init(void);</span>
<span class="quote">&gt;&gt;  extern void uv_system_init(void);</span>
<span class="quote">&gt;&gt; @@ -25,6 +26,7 @@ extern const struct cpumask *uv_flush_tlb_others(const struct cpumask *cpumask,</span>
<span class="quote">&gt;&gt;  static inline enum uv_system_type get_uv_system_type(void) { return UV_NONE; }</span>
<span class="quote">&gt;&gt;  static inline int is_uv_system(void)	{ return 0; }</span>
<span class="quote">&gt;&gt;  static inline int is_uv_hubless(void)	{ return 0; }</span>
<span class="quote">&gt;&gt; +static inline int is_early_uv_system(void)	{ return 0; }</span>
<span class="quote">&gt;&gt;  static inline void uv_cpu_init(void)	{ }</span>
<span class="quote">&gt;&gt;  static inline void uv_system_init(void)	{ }</span>
<span class="quote">&gt;&gt;  static inline const struct cpumask *</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/mm/kaslr.c b/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt;&gt; index aed2064..b75e1f5 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt;&gt; @@ -22,11 +22,13 @@</span>
<span class="quote">&gt;&gt;  #include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;linux/init.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;linux/random.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/efi.h&gt;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  #include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/setup.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/kaslr.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/uv/uv.h&gt;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  #include &quot;mm_internal.h&quot;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; @@ -123,7 +125,7 @@ void __init kernel_randomize_memory(void)</span>
<span class="quote">&gt;&gt;  		CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	/* Adapt phyiscal memory region size based on available memory */</span>
<span class="quote">&gt;&gt; -	if (memory_tb &lt; kaslr_regions[0].size_tb)</span>
<span class="quote">&gt;&gt; +	if (memory_tb &lt; kaslr_regions[0].size_tb &amp;&amp; !is_early_uv_system())</span>
<span class="quote">&gt;&gt;  		kaslr_regions[0].size_tb = memory_tb;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  	/* Calculate entropy available between regions */</span>
<span class="quote">&gt;&gt; diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt;&gt; index 7e76a4d..b71e01d 100644</span>
<span class="quote">&gt;&gt; --- a/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt;&gt; +++ b/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt;&gt; @@ -74,6 +74,13 @@ static int __init setup_add_efi_memmap(char *arg)</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;  early_param(&quot;add_efi_memmap&quot;, setup_add_efi_memmap);</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_X86_UV</span>
<span class="quote">&gt;&gt; +int is_early_uv_system(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	return !((efi.uv_systab == EFI_INVALID_TABLE_ADDR) || !efi.uv_systab);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  static efi_status_t __init phys_efi_set_virtual_address_map(</span>
<span class="quote">&gt;&gt;  	unsigned long memory_map_size,</span>
<span class="quote">&gt;&gt;  	unsigned long descriptor_size,</span>
<span class="quote">&gt;&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - May 19, 2017, 11:33 a.m.</div>
<pre class="content">
On 05/18/17 at 01:26pm, Mike Travis wrote:
<span class="quote">&gt; Hi Baoquan He,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The concept of the patch is correct (since it is I as sent :),</span>
<span class="quote">&gt; but I would prefer that the entire is_early_uv_system() be put</span>
<span class="quote">&gt; into the uv.h file.  Primarily because we may need to change</span>
<span class="quote">&gt; that in the future so having UV specific code in other places</span>
<span class="quote">&gt; than under platform/uv is not that desirable.  Plus I think it&#39;s</span>
<span class="quote">&gt; better to consolidate the logic in one place.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Making it an inline function in uv.h is fine for now.  If we</span>
<span class="quote">&gt; need to change it, I&#39;ll move it to the UV specific init</span>
<span class="quote">&gt; function.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And if it&#39;s alright with others, you should add the #include</span>
<span class="quote">&gt; of the efi.h header file under the part of uv.h that has</span>
<span class="quote">&gt; #ifdef CONFIG_X86_UV defined.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That would mean the KASLR function would only add an</span>
<span class="quote">&gt; #include &lt;asm/uv/uv.h&gt; to access that UV specific funtion.</span>

Yes, sounds better. Will change according to your suggestion, and make a
patchset to contain uv part code and kaslr part separately.

Thanks for your reviewing and suggestion, Mike! This is a regression on
rhel7 with kaslr enabled now. I used dmi_match to do the early check of
UV system, your SGI colleagues suggested the UVsystab way.

Thanks
Baoquan
<span class="quote">&gt; </span>
<span class="quote">&gt; On 5/17/2017 11:52 PM, Baoquan He wrote:</span>
<span class="quote">&gt; &gt; On SGI UV system, kernel casually hang with kaslr enabled.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The back trace is:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; kernel BUG at arch/x86/mm/init_64.c:311!</span>
<span class="quote">&gt; &gt; invalid opcode: 0000 [#1] SMP</span>
<span class="quote">&gt; &gt; [...]</span>
<span class="quote">&gt; &gt; RIP: 0010:__init_extra_mapping+0x188/0x196</span>
<span class="quote">&gt; &gt; [...]</span>
<span class="quote">&gt; &gt; Call Trace:</span>
<span class="quote">&gt; &gt;  init_extra_mapping_uc+0x13/0x15</span>
<span class="quote">&gt; &gt;  map_high+0x67/0x75</span>
<span class="quote">&gt; &gt;  map_mmioh_high_uv3+0x20a/0x219</span>
<span class="quote">&gt; &gt;  uv_system_init_hub+0x12d9/0x1496</span>
<span class="quote">&gt; &gt;  uv_system_init+0x27/0x29</span>
<span class="quote">&gt; &gt;  native_smp_prepare_cpus+0x28d/0x2d8</span>
<span class="quote">&gt; &gt;  kernel_init_freeable+0xdd/0x253</span>
<span class="quote">&gt; &gt;  ? rest_init+0x80/0x80</span>
<span class="quote">&gt; &gt;  kernel_init+0xe/0x110</span>
<span class="quote">&gt; &gt;  ret_from_fork+0x2c/0x40</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The root cause is SGI UV system needs map its MMIOH region to direct</span>
<span class="quote">&gt; &gt; mapping section.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; When kaslr disabled, there are 64TB space for system RAM to do direct</span>
<span class="quote">&gt; &gt; mapping. Both system RAM and SGI UV MMIOH region share this 64TB space.</span>
<span class="quote">&gt; &gt; However with kaslr enabled, mm KASLR only reserves the actual size of</span>
<span class="quote">&gt; &gt; system RAM plus 10TB for direct mapping usage. Then MMIOH mapping of</span>
<span class="quote">&gt; &gt; SGI UV could go beyond the upper bound of direct mapping section to step</span>
<span class="quote">&gt; &gt; into VMALLOC or VMEMMAP area. Then the BUG_ON() in __init_extra_mapping()</span>
<span class="quote">&gt; &gt; will be triggered.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; E.g on the SGI UV3 machine where this bug is reported , there are two MMIOH</span>
<span class="quote">&gt; &gt; regions:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; [    1.519001] UV: Map MMIOH0_HI 0xffc00000000 - 0x100000000000</span>
<span class="quote">&gt; &gt; [    1.523001] UV: Map MMIOH1_HI 0x100000000000 - 0x200000000000</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; They are [16TB-16G, 16TB) and [16TB, 32TB). On this machine, 512G ram are</span>
<span class="quote">&gt; &gt; spread out to 1TB regions. Then above two SGI MMIOH regions also will be</span>
<span class="quote">&gt; &gt; mapped into the direct mapping section. The point is that SGI UV maps its</span>
<span class="quote">&gt; &gt; MMIOH regions to the direct mapping section in uv_system_init() which is</span>
<span class="quote">&gt; &gt; called during kernel_init_freeable(). It&#39;s much later than</span>
<span class="quote">&gt; &gt; kernel_randomize_memory(). Mm KASLR has no chance to take it into</span>
<span class="quote">&gt; &gt; consideration.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; To fix it, we need detect if it&#39;s SGI UV system early, then do not adapt</span>
<span class="quote">&gt; &gt; the size of the direct mapping section in kernel_randomize_memory() if yes.</span>
<span class="quote">&gt; &gt; According to discussion with SGI developer, &quot;The SGI bios adds UVsystab.</span>
<span class="quote">&gt; &gt; Only systems running SGI bios (and now HPE Hawks2) will have UVsystab.&quot;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Hence check if UVsystab is present, if yes, do not adapt the size of the</span>
<span class="quote">&gt; &gt; direct mapping section in kernel_randomize_memory()</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt; &gt; Cc: Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="quote">&gt; &gt; Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="quote">&gt; &gt; Cc: x86@kernel.org</span>
<span class="quote">&gt; &gt; Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;</span>
<span class="quote">&gt; &gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt; &gt; Cc: &quot;travis@sgi.com&quot; &lt;travis@sgi.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Dimitri Sivanich &lt;sivanich@hpe.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; &gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt; &gt; Cc: Masahiro Yamada &lt;yamada.masahiro@socionext.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Russ Anderson &lt;rja@sgi.com&gt;</span>
<span class="quote">&gt; &gt; Cc: Frank Ramsay &lt;frank.ramsay@hpe.com&gt;</span>
<span class="quote">&gt; &gt; linux-efi@vger.kernel.org</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  arch/x86/include/asm/uv/uv.h | 2 ++</span>
<span class="quote">&gt; &gt;  arch/x86/mm/kaslr.c          | 4 +++-</span>
<span class="quote">&gt; &gt;  arch/x86/platform/efi/efi.c  | 7 +++++++</span>
<span class="quote">&gt; &gt;  3 files changed, 12 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/arch/x86/include/asm/uv/uv.h b/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt; &gt; index 6686820..0275776 100644</span>
<span class="quote">&gt; &gt; --- a/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt; &gt; +++ b/arch/x86/include/asm/uv/uv.h</span>
<span class="quote">&gt; &gt; @@ -11,6 +11,7 @@ struct mm_struct;</span>
<span class="quote">&gt; &gt;  extern enum uv_system_type get_uv_system_type(void);</span>
<span class="quote">&gt; &gt;  extern int is_uv_system(void);</span>
<span class="quote">&gt; &gt;  extern int is_uv_hubless(void);</span>
<span class="quote">&gt; &gt; +extern int is_early_uv_system(void);</span>
<span class="quote">&gt; &gt;  extern void uv_cpu_init(void);</span>
<span class="quote">&gt; &gt;  extern void uv_nmi_init(void);</span>
<span class="quote">&gt; &gt;  extern void uv_system_init(void);</span>
<span class="quote">&gt; &gt; @@ -25,6 +26,7 @@ extern const struct cpumask *uv_flush_tlb_others(const struct cpumask *cpumask,</span>
<span class="quote">&gt; &gt;  static inline enum uv_system_type get_uv_system_type(void) { return UV_NONE; }</span>
<span class="quote">&gt; &gt;  static inline int is_uv_system(void)	{ return 0; }</span>
<span class="quote">&gt; &gt;  static inline int is_uv_hubless(void)	{ return 0; }</span>
<span class="quote">&gt; &gt; +static inline int is_early_uv_system(void)	{ return 0; }</span>
<span class="quote">&gt; &gt;  static inline void uv_cpu_init(void)	{ }</span>
<span class="quote">&gt; &gt;  static inline void uv_system_init(void)	{ }</span>
<span class="quote">&gt; &gt;  static inline const struct cpumask *</span>
<span class="quote">&gt; &gt; diff --git a/arch/x86/mm/kaslr.c b/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt; &gt; index aed2064..b75e1f5 100644</span>
<span class="quote">&gt; &gt; --- a/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt; &gt; +++ b/arch/x86/mm/kaslr.c</span>
<span class="quote">&gt; &gt; @@ -22,11 +22,13 @@</span>
<span class="quote">&gt; &gt;  #include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt; &gt;  #include &lt;linux/init.h&gt;</span>
<span class="quote">&gt; &gt;  #include &lt;linux/random.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/efi.h&gt;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  #include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt; &gt;  #include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt; &gt;  #include &lt;asm/setup.h&gt;</span>
<span class="quote">&gt; &gt;  #include &lt;asm/kaslr.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;asm/uv/uv.h&gt;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  #include &quot;mm_internal.h&quot;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; @@ -123,7 +125,7 @@ void __init kernel_randomize_memory(void)</span>
<span class="quote">&gt; &gt;  		CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	/* Adapt phyiscal memory region size based on available memory */</span>
<span class="quote">&gt; &gt; -	if (memory_tb &lt; kaslr_regions[0].size_tb)</span>
<span class="quote">&gt; &gt; +	if (memory_tb &lt; kaslr_regions[0].size_tb &amp;&amp; !is_early_uv_system())</span>
<span class="quote">&gt; &gt;  		kaslr_regions[0].size_tb = memory_tb;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	/* Calculate entropy available between regions */</span>
<span class="quote">&gt; &gt; diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt; &gt; index 7e76a4d..b71e01d 100644</span>
<span class="quote">&gt; &gt; --- a/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt; &gt; +++ b/arch/x86/platform/efi/efi.c</span>
<span class="quote">&gt; &gt; @@ -74,6 +74,13 @@ static int __init setup_add_efi_memmap(char *arg)</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  early_param(&quot;add_efi_memmap&quot;, setup_add_efi_memmap);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +#ifdef CONFIG_X86_UV</span>
<span class="quote">&gt; &gt; +int is_early_uv_system(void)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	return !((efi.uv_systab == EFI_INVALID_TABLE_ADDR) || !efi.uv_systab);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  static efi_status_t __init phys_efi_set_virtual_address_map(</span>
<span class="quote">&gt; &gt;  	unsigned long memory_map_size,</span>
<span class="quote">&gt; &gt;  	unsigned long descriptor_size,</span>
<span class="quote">&gt; &gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/uv/uv.h b/arch/x86/include/asm/uv/uv.h</span>
<span class="p_header">index 6686820..0275776 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uv/uv.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uv/uv.h</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"> struct mm_struct;</span>
 extern enum uv_system_type get_uv_system_type(void);
 extern int is_uv_system(void);
 extern int is_uv_hubless(void);
<span class="p_add">+extern int is_early_uv_system(void);</span>
 extern void uv_cpu_init(void);
 extern void uv_nmi_init(void);
 extern void uv_system_init(void);
<span class="p_chunk">@@ -25,6 +26,7 @@</span> <span class="p_context"> extern const struct cpumask *uv_flush_tlb_others(const struct cpumask *cpumask,</span>
 static inline enum uv_system_type get_uv_system_type(void) { return UV_NONE; }
 static inline int is_uv_system(void)	{ return 0; }
 static inline int is_uv_hubless(void)	{ return 0; }
<span class="p_add">+static inline int is_early_uv_system(void)	{ return 0; }</span>
 static inline void uv_cpu_init(void)	{ }
 static inline void uv_system_init(void)	{ }
 static inline const struct cpumask *
<span class="p_header">diff --git a/arch/x86/mm/kaslr.c b/arch/x86/mm/kaslr.c</span>
<span class="p_header">index aed2064..b75e1f5 100644</span>
<span class="p_header">--- a/arch/x86/mm/kaslr.c</span>
<span class="p_header">+++ b/arch/x86/mm/kaslr.c</span>
<span class="p_chunk">@@ -22,11 +22,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/random.h&gt;
<span class="p_add">+#include &lt;linux/efi.h&gt;</span>
 
 #include &lt;asm/pgalloc.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/setup.h&gt;
 #include &lt;asm/kaslr.h&gt;
<span class="p_add">+#include &lt;asm/uv/uv.h&gt;</span>
 
 #include &quot;mm_internal.h&quot;
 
<span class="p_chunk">@@ -123,7 +125,7 @@</span> <span class="p_context"> void __init kernel_randomize_memory(void)</span>
 		CONFIG_RANDOMIZE_MEMORY_PHYSICAL_PADDING;
 
 	/* Adapt phyiscal memory region size based on available memory */
<span class="p_del">-	if (memory_tb &lt; kaslr_regions[0].size_tb)</span>
<span class="p_add">+	if (memory_tb &lt; kaslr_regions[0].size_tb &amp;&amp; !is_early_uv_system())</span>
 		kaslr_regions[0].size_tb = memory_tb;
 
 	/* Calculate entropy available between regions */
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index 7e76a4d..b71e01d 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -74,6 +74,13 @@</span> <span class="p_context"> static int __init setup_add_efi_memmap(char *arg)</span>
 }
 early_param(&quot;add_efi_memmap&quot;, setup_add_efi_memmap);
 
<span class="p_add">+#ifdef CONFIG_X86_UV</span>
<span class="p_add">+int is_early_uv_system(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !((efi.uv_systab == EFI_INVALID_TABLE_ADDR) || !efi.uv_systab);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static efi_status_t __init phys_efi_set_virtual_address_map(
 	unsigned long memory_map_size,
 	unsigned long descriptor_size,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



