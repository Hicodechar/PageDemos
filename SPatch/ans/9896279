
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.81 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.81</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 11, 2017, 4:29 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170811162920.GB10819@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9896279/mbox/"
   >mbox</a>
|
   <a href="/patch/9896279/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9896279/">/patch/9896279/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	87F0060325 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Aug 2017 16:29:33 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6C8AA28C3B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Aug 2017 16:29:33 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 60EF128C4E; Fri, 11 Aug 2017 16:29:33 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B599828C3B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Aug 2017 16:29:29 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753580AbdHKQ31 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 11 Aug 2017 12:29:27 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:54996 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752703AbdHKQ3V (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 11 Aug 2017 12:29:21 -0400
Received: from localhost (unknown [104.132.0.100])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 95417B50;
	Fri, 11 Aug 2017 16:29:20 +0000 (UTC)
Date: Fri, 11 Aug 2017 09:29:20 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.81
Message-ID: &lt;20170811162920.GB10819@kroah.com&gt;
References: &lt;20170811162914.GA10819@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170811162914.GA10819@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 11, 2017, 4:29 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index dddd55adde24..d049e53a6960 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 80</span>
<span class="p_add">+SUBLEVEL = 81</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-388-gp.dts b/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_header">index cd316021d6ce..6c1b45c1af66 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"></span>
 					pinctrl-names = &quot;default&quot;;
 					pinctrl-0 = &lt;&amp;pca0_pins&gt;;
 					interrupt-parent = &lt;&amp;gpio0&gt;;
<span class="p_del">-					interrupts = &lt;18 IRQ_TYPE_EDGE_FALLING&gt;;</span>
<span class="p_add">+					interrupts = &lt;18 IRQ_TYPE_LEVEL_LOW&gt;;</span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 					interrupt-controller;
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"></span>
 					compatible = &quot;nxp,pca9555&quot;;
 					pinctrl-names = &quot;default&quot;;
 					interrupt-parent = &lt;&amp;gpio0&gt;;
<span class="p_del">-					interrupts = &lt;18 IRQ_TYPE_EDGE_FALLING&gt;;</span>
<span class="p_add">+					interrupts = &lt;18 IRQ_TYPE_LEVEL_LOW&gt;;</span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 					interrupt-controller;
<span class="p_header">diff --git a/arch/arm/include/asm/ftrace.h b/arch/arm/include/asm/ftrace.h</span>
<span class="p_header">index bfe2a2f5a644..22b73112b75f 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/ftrace.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/ftrace.h</span>
<span class="p_chunk">@@ -54,6 +54,24 @@</span> <span class="p_context"> static inline void *return_address(unsigned int level)</span>
 
 #define ftrace_return_address(n) return_address(n)
 
<span class="p_add">+#define ARCH_HAS_SYSCALL_MATCH_SYM_NAME</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool arch_syscall_match_sym_name(const char *sym,</span>
<span class="p_add">+					       const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!strcmp(sym, &quot;sys_mmap2&quot;))</span>
<span class="p_add">+		sym = &quot;sys_mmap_pgoff&quot;;</span>
<span class="p_add">+	else if (!strcmp(sym, &quot;sys_statfs64_wrapper&quot;))</span>
<span class="p_add">+		sym = &quot;sys_statfs64&quot;;</span>
<span class="p_add">+	else if (!strcmp(sym, &quot;sys_fstatfs64_wrapper&quot;))</span>
<span class="p_add">+		sym = &quot;sys_fstatfs64&quot;;</span>
<span class="p_add">+	else if (!strcmp(sym, &quot;sys_arm_fadvise64_64&quot;))</span>
<span class="p_add">+		sym = &quot;sys_fadvise64_64&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Ignore case since sym may start with &quot;SyS&quot; instead of &quot;sys&quot; */</span>
<span class="p_add">+	return !strcasecmp(sym, name);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* ifndef __ASSEMBLY__ */
 
 #endif /* _ASM_ARM_FTRACE */
<span class="p_header">diff --git a/arch/sparc/include/asm/trap_block.h b/arch/sparc/include/asm/trap_block.h</span>
<span class="p_header">index ec9c04de3664..ff05992dae7a 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/trap_block.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/trap_block.h</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"> extern struct trap_per_cpu trap_block[NR_CPUS];</span>
 void init_cur_cpu_trap(struct thread_info *);
 void setup_tba(void);
 extern int ncpus_probed;
<span class="p_add">+extern u64 cpu_mondo_counter[NR_CPUS];</span>
 
 unsigned long real_hard_smp_processor_id(void);
 
<span class="p_header">diff --git a/arch/sparc/kernel/smp_64.c b/arch/sparc/kernel/smp_64.c</span>
<span class="p_header">index 95a9fa0d2195..4511caa3b7e9 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/smp_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/smp_64.c</span>
<span class="p_chunk">@@ -617,22 +617,48 @@</span> <span class="p_context"> retry:</span>
 	}
 }
 
<span class="p_del">-/* Multi-cpu list version.  */</span>
<span class="p_add">+#define	CPU_MONDO_COUNTER(cpuid)	(cpu_mondo_counter[cpuid])</span>
<span class="p_add">+#define	MONDO_USEC_WAIT_MIN		2</span>
<span class="p_add">+#define	MONDO_USEC_WAIT_MAX		100</span>
<span class="p_add">+#define	MONDO_RETRY_LIMIT		500000</span>
<span class="p_add">+</span>
<span class="p_add">+/* Multi-cpu list version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Deliver xcalls to &#39;cnt&#39; number of cpus in &#39;cpu_list&#39;.</span>
<span class="p_add">+ * Sometimes not all cpus receive the mondo, requiring us to re-send</span>
<span class="p_add">+ * the mondo until all cpus have received, or cpus are truly stuck</span>
<span class="p_add">+ * unable to receive mondo, and we timeout.</span>
<span class="p_add">+ * Occasionally a target cpu strand is borrowed briefly by hypervisor to</span>
<span class="p_add">+ * perform guest service, such as PCIe error handling. Consider the</span>
<span class="p_add">+ * service time, 1 second overall wait is reasonable for 1 cpu.</span>
<span class="p_add">+ * Here two in-between mondo check wait time are defined: 2 usec for</span>
<span class="p_add">+ * single cpu quick turn around and up to 100usec for large cpu count.</span>
<span class="p_add">+ * Deliver mondo to large number of cpus could take longer, we adjusts</span>
<span class="p_add">+ * the retry count as long as target cpus are making forward progress.</span>
<span class="p_add">+ */</span>
 static void hypervisor_xcall_deliver(struct trap_per_cpu *tb, int cnt)
 {
<span class="p_del">-	int retries, this_cpu, prev_sent, i, saw_cpu_error;</span>
<span class="p_add">+	int this_cpu, tot_cpus, prev_sent, i, rem;</span>
<span class="p_add">+	int usec_wait, retries, tot_retries;</span>
<span class="p_add">+	u16 first_cpu = 0xffff;</span>
<span class="p_add">+	unsigned long xc_rcvd = 0;</span>
 	unsigned long status;
<span class="p_add">+	int ecpuerror_id = 0;</span>
<span class="p_add">+	int enocpu_id = 0;</span>
 	u16 *cpu_list;
<span class="p_add">+	u16 cpu;</span>
 
 	this_cpu = smp_processor_id();
<span class="p_del">-</span>
 	cpu_list = __va(tb-&gt;cpu_list_pa);
<span class="p_del">-</span>
<span class="p_del">-	saw_cpu_error = 0;</span>
<span class="p_del">-	retries = 0;</span>
<span class="p_add">+	usec_wait = cnt * MONDO_USEC_WAIT_MIN;</span>
<span class="p_add">+	if (usec_wait &gt; MONDO_USEC_WAIT_MAX)</span>
<span class="p_add">+		usec_wait = MONDO_USEC_WAIT_MAX;</span>
<span class="p_add">+	retries = tot_retries = 0;</span>
<span class="p_add">+	tot_cpus = cnt;</span>
 	prev_sent = 0;
<span class="p_add">+</span>
 	do {
<span class="p_del">-		int forward_progress, n_sent;</span>
<span class="p_add">+		int n_sent, mondo_delivered, target_cpu_busy;</span>
 
 		status = sun4v_cpu_mondo_send(cnt,
 					      tb-&gt;cpu_list_pa,
<span class="p_chunk">@@ -640,94 +666,113 @@</span> <span class="p_context"> static void hypervisor_xcall_deliver(struct trap_per_cpu *tb, int cnt)</span>
 
 		/* HV_EOK means all cpus received the xcall, we&#39;re done.  */
 		if (likely(status == HV_EOK))
<span class="p_del">-			break;</span>
<span class="p_add">+			goto xcall_done;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* If not these non-fatal errors, panic */</span>
<span class="p_add">+		if (unlikely((status != HV_EWOULDBLOCK) &amp;&amp;</span>
<span class="p_add">+			(status != HV_ECPUERROR) &amp;&amp;</span>
<span class="p_add">+			(status != HV_ENOCPU)))</span>
<span class="p_add">+			goto fatal_errors;</span>
 
 		/* First, see if we made any forward progress.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Go through the cpu_list, count the target cpus that have</span>
<span class="p_add">+		 * received our mondo (n_sent), and those that did not (rem).</span>
<span class="p_add">+		 * Re-pack cpu_list with the cpus remain to be retried in the</span>
<span class="p_add">+		 * front - this simplifies tracking the truly stalled cpus.</span>
 		 *
 		 * The hypervisor indicates successful sends by setting
 		 * cpu list entries to the value 0xffff.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * EWOULDBLOCK means some target cpus did not receive the</span>
<span class="p_add">+		 * mondo and retry usually helps.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * ECPUERROR means at least one target cpu is in error state,</span>
<span class="p_add">+		 * it&#39;s usually safe to skip the faulty cpu and retry.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * ENOCPU means one of the target cpu doesn&#39;t belong to the</span>
<span class="p_add">+		 * domain, perhaps offlined which is unexpected, but not</span>
<span class="p_add">+		 * fatal and it&#39;s okay to skip the offlined cpu.</span>
 		 */
<span class="p_add">+		rem = 0;</span>
 		n_sent = 0;
 		for (i = 0; i &lt; cnt; i++) {
<span class="p_del">-			if (likely(cpu_list[i] == 0xffff))</span>
<span class="p_add">+			cpu = cpu_list[i];</span>
<span class="p_add">+			if (likely(cpu == 0xffff)) {</span>
 				n_sent++;
<span class="p_add">+			} else if ((status == HV_ECPUERROR) &amp;&amp;</span>
<span class="p_add">+				(sun4v_cpu_state(cpu) == HV_CPU_STATE_ERROR)) {</span>
<span class="p_add">+				ecpuerror_id = cpu + 1;</span>
<span class="p_add">+			} else if (status == HV_ENOCPU &amp;&amp; !cpu_online(cpu)) {</span>
<span class="p_add">+				enocpu_id = cpu + 1;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				cpu_list[rem++] = cpu;</span>
<span class="p_add">+			}</span>
 		}
 
<span class="p_del">-		forward_progress = 0;</span>
<span class="p_del">-		if (n_sent &gt; prev_sent)</span>
<span class="p_del">-			forward_progress = 1;</span>
<span class="p_add">+		/* No cpu remained, we&#39;re done. */</span>
<span class="p_add">+		if (rem == 0)</span>
<span class="p_add">+			break;</span>
 
<span class="p_del">-		prev_sent = n_sent;</span>
<span class="p_add">+		/* Otherwise, update the cpu count for retry. */</span>
<span class="p_add">+		cnt = rem;</span>
 
<span class="p_del">-		/* If we get a HV_ECPUERROR, then one or more of the cpus</span>
<span class="p_del">-		 * in the list are in error state.  Use the cpu_state()</span>
<span class="p_del">-		 * hypervisor call to find out which cpus are in error state.</span>
<span class="p_add">+		/* Record the overall number of mondos received by the</span>
<span class="p_add">+		 * first of the remaining cpus.</span>
 		 */
<span class="p_del">-		if (unlikely(status == HV_ECPUERROR)) {</span>
<span class="p_del">-			for (i = 0; i &lt; cnt; i++) {</span>
<span class="p_del">-				long err;</span>
<span class="p_del">-				u16 cpu;</span>
<span class="p_add">+		if (first_cpu != cpu_list[0]) {</span>
<span class="p_add">+			first_cpu = cpu_list[0];</span>
<span class="p_add">+			xc_rcvd = CPU_MONDO_COUNTER(first_cpu);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-				cpu = cpu_list[i];</span>
<span class="p_del">-				if (cpu == 0xffff)</span>
<span class="p_del">-					continue;</span>
<span class="p_add">+		/* Was any mondo delivered successfully? */</span>
<span class="p_add">+		mondo_delivered = (n_sent &gt; prev_sent);</span>
<span class="p_add">+		prev_sent = n_sent;</span>
 
<span class="p_del">-				err = sun4v_cpu_state(cpu);</span>
<span class="p_del">-				if (err == HV_CPU_STATE_ERROR) {</span>
<span class="p_del">-					saw_cpu_error = (cpu + 1);</span>
<span class="p_del">-					cpu_list[i] = 0xffff;</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else if (unlikely(status != HV_EWOULDBLOCK))</span>
<span class="p_del">-			goto fatal_mondo_error;</span>
<span class="p_add">+		/* or, was any target cpu busy processing other mondos? */</span>
<span class="p_add">+		target_cpu_busy = (xc_rcvd &lt; CPU_MONDO_COUNTER(first_cpu));</span>
<span class="p_add">+		xc_rcvd = CPU_MONDO_COUNTER(first_cpu);</span>
 
<span class="p_del">-		/* Don&#39;t bother rewriting the CPU list, just leave the</span>
<span class="p_del">-		 * 0xffff and non-0xffff entries in there and the</span>
<span class="p_del">-		 * hypervisor will do the right thing.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Only advance timeout state if we didn&#39;t make any</span>
<span class="p_del">-		 * forward progress.</span>
<span class="p_add">+		/* Retry count is for no progress. If we&#39;re making progress,</span>
<span class="p_add">+		 * reset the retry count.</span>
 		 */
<span class="p_del">-		if (unlikely(!forward_progress)) {</span>
<span class="p_del">-			if (unlikely(++retries &gt; 10000))</span>
<span class="p_del">-				goto fatal_mondo_timeout;</span>
<span class="p_del">-</span>
<span class="p_del">-			/* Delay a little bit to let other cpus catch up</span>
<span class="p_del">-			 * on their cpu mondo queue work.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			udelay(2 * cnt);</span>
<span class="p_add">+		if (likely(mondo_delivered || target_cpu_busy)) {</span>
<span class="p_add">+			tot_retries += retries;</span>
<span class="p_add">+			retries = 0;</span>
<span class="p_add">+		} else if (unlikely(retries &gt; MONDO_RETRY_LIMIT)) {</span>
<span class="p_add">+			goto fatal_mondo_timeout;</span>
 		}
<span class="p_del">-	} while (1);</span>
 
<span class="p_del">-	if (unlikely(saw_cpu_error))</span>
<span class="p_del">-		goto fatal_mondo_cpu_error;</span>
<span class="p_add">+		/* Delay a little bit to let other cpus catch up on</span>
<span class="p_add">+		 * their cpu mondo queue work.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!mondo_delivered)</span>
<span class="p_add">+			udelay(usec_wait);</span>
 
<span class="p_del">-	return;</span>
<span class="p_add">+		retries++;</span>
<span class="p_add">+	} while (1);</span>
 
<span class="p_del">-fatal_mondo_cpu_error:</span>
<span class="p_del">-	printk(KERN_CRIT &quot;CPU[%d]: SUN4V mondo cpu error, some target cpus &quot;</span>
<span class="p_del">-	       &quot;(including %d) were in error state\n&quot;,</span>
<span class="p_del">-	       this_cpu, saw_cpu_error - 1);</span>
<span class="p_add">+xcall_done:</span>
<span class="p_add">+	if (unlikely(ecpuerror_id &gt; 0)) {</span>
<span class="p_add">+		pr_crit(&quot;CPU[%d]: SUN4V mondo cpu error, target cpu(%d) was in error state\n&quot;,</span>
<span class="p_add">+		       this_cpu, ecpuerror_id - 1);</span>
<span class="p_add">+	} else if (unlikely(enocpu_id &gt; 0)) {</span>
<span class="p_add">+		pr_crit(&quot;CPU[%d]: SUN4V mondo cpu error, target cpu(%d) does not belong to the domain\n&quot;,</span>
<span class="p_add">+		       this_cpu, enocpu_id - 1);</span>
<span class="p_add">+	}</span>
 	return;
 
<span class="p_add">+fatal_errors:</span>
<span class="p_add">+	/* fatal errors include bad alignment, etc */</span>
<span class="p_add">+	pr_crit(&quot;CPU[%d]: Args were cnt(%d) cpulist_pa(%lx) mondo_block_pa(%lx)\n&quot;,</span>
<span class="p_add">+	       this_cpu, tot_cpus, tb-&gt;cpu_list_pa, tb-&gt;cpu_mondo_block_pa);</span>
<span class="p_add">+	panic(&quot;Unexpected SUN4V mondo error %lu\n&quot;, status);</span>
<span class="p_add">+</span>
 fatal_mondo_timeout:
<span class="p_del">-	printk(KERN_CRIT &quot;CPU[%d]: SUN4V mondo timeout, no forward &quot;</span>
<span class="p_del">-	       &quot; progress after %d retries.\n&quot;,</span>
<span class="p_del">-	       this_cpu, retries);</span>
<span class="p_del">-	goto dump_cpu_list_and_out;</span>
<span class="p_del">-</span>
<span class="p_del">-fatal_mondo_error:</span>
<span class="p_del">-	printk(KERN_CRIT &quot;CPU[%d]: Unexpected SUN4V mondo error %lu\n&quot;,</span>
<span class="p_del">-	       this_cpu, status);</span>
<span class="p_del">-	printk(KERN_CRIT &quot;CPU[%d]: Args were cnt(%d) cpulist_pa(%lx) &quot;</span>
<span class="p_del">-	       &quot;mondo_block_pa(%lx)\n&quot;,</span>
<span class="p_del">-	       this_cpu, cnt, tb-&gt;cpu_list_pa, tb-&gt;cpu_mondo_block_pa);</span>
<span class="p_del">-</span>
<span class="p_del">-dump_cpu_list_and_out:</span>
<span class="p_del">-	printk(KERN_CRIT &quot;CPU[%d]: CPU list [ &quot;, this_cpu);</span>
<span class="p_del">-	for (i = 0; i &lt; cnt; i++)</span>
<span class="p_del">-		printk(&quot;%u &quot;, cpu_list[i]);</span>
<span class="p_del">-	printk(&quot;]\n&quot;);</span>
<span class="p_add">+	/* some cpus being non-responsive to the cpu mondo */</span>
<span class="p_add">+	pr_crit(&quot;CPU[%d]: SUN4V mondo timeout, cpu(%d) made no forward progress after %d retries. Total target cpus(%d).\n&quot;,</span>
<span class="p_add">+	       this_cpu, first_cpu, (tot_retries + retries), tot_cpus);</span>
<span class="p_add">+	panic(&quot;SUN4V mondo timeout panic\n&quot;);</span>
 }
 
 static void (*xcall_deliver_impl)(struct trap_per_cpu *, int);
<span class="p_header">diff --git a/arch/sparc/kernel/sun4v_ivec.S b/arch/sparc/kernel/sun4v_ivec.S</span>
<span class="p_header">index 559bc5e9c199..34631995859a 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sun4v_ivec.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/sun4v_ivec.S</span>
<span class="p_chunk">@@ -26,6 +26,21 @@</span> <span class="p_context"> sun4v_cpu_mondo:</span>
 	ldxa	[%g0] ASI_SCRATCHPAD, %g4
 	sub	%g4, TRAP_PER_CPU_FAULT_INFO, %g4
 
<span class="p_add">+	/* Get smp_processor_id() into %g3 */</span>
<span class="p_add">+	sethi	%hi(trap_block), %g5</span>
<span class="p_add">+	or	%g5, %lo(trap_block), %g5</span>
<span class="p_add">+	sub	%g4, %g5, %g3</span>
<span class="p_add">+	srlx	%g3, TRAP_BLOCK_SZ_SHIFT, %g3</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Increment cpu_mondo_counter[smp_processor_id()] */</span>
<span class="p_add">+	sethi	%hi(cpu_mondo_counter), %g5</span>
<span class="p_add">+	or	%g5, %lo(cpu_mondo_counter), %g5</span>
<span class="p_add">+	sllx	%g3, 3, %g3</span>
<span class="p_add">+	add	%g5, %g3, %g5</span>
<span class="p_add">+	ldx	[%g5], %g3</span>
<span class="p_add">+	add	%g3, 1, %g3</span>
<span class="p_add">+	stx	%g3, [%g5]</span>
<span class="p_add">+</span>
 	/* Get CPU mondo queue base phys address into %g7.  */
 	ldx	[%g4 + TRAP_PER_CPU_CPU_MONDO_PA], %g7
 
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index cc97a43268ee..d883c5951e8b 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -2659,6 +2659,7 @@</span> <span class="p_context"> void do_getpsr(struct pt_regs *regs)</span>
 	}
 }
 
<span class="p_add">+u64 cpu_mondo_counter[NR_CPUS] = {0};</span>
 struct trap_per_cpu trap_block[NR_CPUS];
 EXPORT_SYMBOL(trap_block);
 
<span class="p_header">diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c</span>
<span class="p_header">index 318b8465d302..06ceddb3a22e 100644</span>
<span class="p_header">--- a/arch/x86/boot/string.c</span>
<span class="p_header">+++ b/arch/x86/boot/string.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 #include &quot;ctype.h&quot;
<span class="p_add">+#include &quot;string.h&quot;</span>
 
 int memcmp(const void *s1, const void *s2, size_t len)
 {
<span class="p_header">diff --git a/arch/x86/boot/string.h b/arch/x86/boot/string.h</span>
<span class="p_header">index 725e820602b1..113588ddb43f 100644</span>
<span class="p_header">--- a/arch/x86/boot/string.h</span>
<span class="p_header">+++ b/arch/x86/boot/string.h</span>
<span class="p_chunk">@@ -18,4 +18,13 @@</span> <span class="p_context"> int memcmp(const void *s1, const void *s2, size_t len);</span>
 #define memset(d,c,l) __builtin_memset(d,c,l)
 #define memcmp	__builtin_memcmp
 
<span class="p_add">+extern int strcmp(const char *str1, const char *str2);</span>
<span class="p_add">+extern int strncmp(const char *cs, const char *ct, size_t count);</span>
<span class="p_add">+extern size_t strlen(const char *s);</span>
<span class="p_add">+extern char *strstr(const char *s1, const char *s2);</span>
<span class="p_add">+extern size_t strnlen(const char *s, size_t maxlen);</span>
<span class="p_add">+extern unsigned int atou(const char *s);</span>
<span class="p_add">+extern unsigned long long simple_strtoull(const char *cp, char **endp,</span>
<span class="p_add">+					  unsigned int base);</span>
<span class="p_add">+</span>
 #endif /* BOOT_STRING_H */
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index cec49ecf5f31..32187f8a49b4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -151,6 +151,8 @@</span> <span class="p_context"> void kvm_async_pf_task_wait(u32 token)</span>
 		if (hlist_unhashed(&amp;n.link))
 			break;
 
<span class="p_add">+		rcu_irq_exit();</span>
<span class="p_add">+</span>
 		if (!n.halted) {
 			local_irq_enable();
 			schedule();
<span class="p_chunk">@@ -159,11 +161,11 @@</span> <span class="p_context"> void kvm_async_pf_task_wait(u32 token)</span>
 			/*
 			 * We cannot reschedule. So halt.
 			 */
<span class="p_del">-			rcu_irq_exit();</span>
 			native_safe_halt();
 			local_irq_disable();
<span class="p_del">-			rcu_irq_enter();</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		rcu_irq_enter();</span>
 	}
 	if (!n.halted)
 		finish_wait(&amp;n.wq, &amp;wait);
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index e417e1a1d02c..5b2aee83d776 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2832,10 +2832,12 @@</span> <span class="p_context"> static unsigned int atapi_xlat(struct ata_queued_cmd *qc)</span>
 static struct ata_device *ata_find_dev(struct ata_port *ap, int devno)
 {
 	if (!sata_pmp_attached(ap)) {
<span class="p_del">-		if (likely(devno &lt; ata_link_max_devices(&amp;ap-&gt;link)))</span>
<span class="p_add">+		if (likely(devno &gt;= 0 &amp;&amp;</span>
<span class="p_add">+			   devno &lt; ata_link_max_devices(&amp;ap-&gt;link)))</span>
 			return &amp;ap-&gt;link.device[devno];
 	} else {
<span class="p_del">-		if (likely(devno &lt; ap-&gt;nr_pmp_links))</span>
<span class="p_add">+		if (likely(devno &gt;= 0 &amp;&amp;</span>
<span class="p_add">+			   devno &lt; ap-&gt;nr_pmp_links))</span>
 			return &amp;ap-&gt;pmp_link[devno].device[0];
 	}
 
<span class="p_header">diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c</span>
<span class="p_header">index 6ca35495a5be..1e5cd39d0cc2 100644</span>
<span class="p_header">--- a/drivers/block/virtio_blk.c</span>
<span class="p_header">+++ b/drivers/block/virtio_blk.c</span>
<span class="p_chunk">@@ -641,11 +641,12 @@</span> <span class="p_context"> static int virtblk_probe(struct virtio_device *vdev)</span>
 	if (err)
 		goto out_put_disk;
 
<span class="p_del">-	q = vblk-&gt;disk-&gt;queue = blk_mq_init_queue(&amp;vblk-&gt;tag_set);</span>
<span class="p_add">+	q = blk_mq_init_queue(&amp;vblk-&gt;tag_set);</span>
 	if (IS_ERR(q)) {
 		err = -ENOMEM;
 		goto out_free_tags;
 	}
<span class="p_add">+	vblk-&gt;disk-&gt;queue = q;</span>
 
 	q-&gt;queuedata = vblk;
 
<span class="p_header">diff --git a/drivers/gpu/drm/rcar-du/rcar_du_drv.c b/drivers/gpu/drm/rcar-du/rcar_du_drv.c</span>
<span class="p_header">index bf4674aa6405..bb9cd35d7fdf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rcar-du/rcar_du_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rcar-du/rcar_du_drv.c</span>
<span class="p_chunk">@@ -296,7 +296,7 @@</span> <span class="p_context"> static int rcar_du_probe(struct platform_device *pdev)</span>
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	rcdu-&gt;mmio = devm_ioremap_resource(&amp;pdev-&gt;dev, mem);
 	if (IS_ERR(rcdu-&gt;mmio))
<span class="p_del">-		ret = PTR_ERR(rcdu-&gt;mmio);</span>
<span class="p_add">+		return PTR_ERR(rcdu-&gt;mmio);</span>
 
 	/* DRM/KMS objects */
 	ddev = drm_dev_alloc(&amp;rcar_du_driver, &amp;pdev-&gt;dev);
<span class="p_header">diff --git a/drivers/gpu/drm/virtio/virtgpu_fb.c b/drivers/gpu/drm/virtio/virtgpu_fb.c</span>
<span class="p_header">index 6a81e084593b..2b59d80a09b8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/virtio/virtgpu_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/virtio/virtgpu_fb.c</span>
<span class="p_chunk">@@ -338,7 +338,7 @@</span> <span class="p_context"> static int virtio_gpufb_create(struct drm_fb_helper *helper,</span>
 	info-&gt;fbops = &amp;virtio_gpufb_ops;
 	info-&gt;pixmap.flags = FB_PIXMAP_SYSTEM;
 
<span class="p_del">-	info-&gt;screen_base = obj-&gt;vmap;</span>
<span class="p_add">+	info-&gt;screen_buffer = obj-&gt;vmap;</span>
 	info-&gt;screen_size = obj-&gt;gem_base.size;
 	drm_fb_helper_fill_fix(info, fb-&gt;pitches[0], fb-&gt;depth);
 	drm_fb_helper_fill_var(info, &amp;vfbdev-&gt;helper,
<span class="p_header">diff --git a/drivers/infiniband/ulp/isert/ib_isert.c b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">index b0edb66a291b..0b7f5a701c60 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/isert/ib_isert.c</span>
<span class="p_chunk">@@ -1581,7 +1581,7 @@</span> <span class="p_context"> isert_rcv_completion(struct iser_rx_desc *desc,</span>
 		     struct isert_conn *isert_conn,
 		     u32 xfer_len)
 {
<span class="p_del">-	struct ib_device *ib_dev = isert_conn-&gt;cm_id-&gt;device;</span>
<span class="p_add">+	struct ib_device *ib_dev = isert_conn-&gt;device-&gt;ib_device;</span>
 	struct iscsi_hdr *hdr;
 	u64 rx_dma;
 	int rx_buflen;
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-bus.c b/drivers/media/pci/saa7164/saa7164-bus.c</span>
<span class="p_header">index a18fe5d47238..b4857cd7069e 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-bus.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-bus.c</span>
<span class="p_chunk">@@ -393,11 +393,11 @@</span> <span class="p_context"> int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 	msg_tmp.size = le16_to_cpu((__force __le16)msg_tmp.size);
 	msg_tmp.command = le32_to_cpu((__force __le32)msg_tmp.command);
 	msg_tmp.controlselector = le16_to_cpu((__force __le16)msg_tmp.controlselector);
<span class="p_add">+	memcpy(msg, &amp;msg_tmp, sizeof(*msg));</span>
 
 	/* No need to update the read positions, because this was a peek */
 	/* If the caller specifically want to peek, return */
 	if (peekonly) {
<span class="p_del">-		memcpy(msg, &amp;msg_tmp, sizeof(*msg));</span>
 		goto peekout;
 	}
 
<span class="p_chunk">@@ -442,21 +442,15 @@</span> <span class="p_context"> int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 		space_rem = bus-&gt;m_dwSizeGetRing - curr_grp;
 
 		if (space_rem &lt; sizeof(*msg)) {
<span class="p_del">-			/* msg wraps around the ring */</span>
<span class="p_del">-			memcpy_fromio(msg, bus-&gt;m_pdwGetRing + curr_grp, space_rem);</span>
<span class="p_del">-			memcpy_fromio((u8 *)msg + space_rem, bus-&gt;m_pdwGetRing,</span>
<span class="p_del">-				sizeof(*msg) - space_rem);</span>
 			if (buf)
 				memcpy_fromio(buf, bus-&gt;m_pdwGetRing + sizeof(*msg) -
 					space_rem, buf_size);
 
 		} else if (space_rem == sizeof(*msg)) {
<span class="p_del">-			memcpy_fromio(msg, bus-&gt;m_pdwGetRing + curr_grp, sizeof(*msg));</span>
 			if (buf)
 				memcpy_fromio(buf, bus-&gt;m_pdwGetRing, buf_size);
 		} else {
 			/* Additional data wraps around the ring */
<span class="p_del">-			memcpy_fromio(msg, bus-&gt;m_pdwGetRing + curr_grp, sizeof(*msg));</span>
 			if (buf) {
 				memcpy_fromio(buf, bus-&gt;m_pdwGetRing + curr_grp +
 					sizeof(*msg), space_rem - sizeof(*msg));
<span class="p_chunk">@@ -469,15 +463,10 @@</span> <span class="p_context"> int saa7164_bus_get(struct saa7164_dev *dev, struct tmComResInfo* msg,</span>
 
 	} else {
 		/* No wrapping */
<span class="p_del">-		memcpy_fromio(msg, bus-&gt;m_pdwGetRing + curr_grp, sizeof(*msg));</span>
 		if (buf)
 			memcpy_fromio(buf, bus-&gt;m_pdwGetRing + curr_grp + sizeof(*msg),
 				buf_size);
 	}
<span class="p_del">-	/* Convert from little endian to CPU */</span>
<span class="p_del">-	msg-&gt;size = le16_to_cpu((__force __le16)msg-&gt;size);</span>
<span class="p_del">-	msg-&gt;command = le32_to_cpu((__force __le32)msg-&gt;command);</span>
<span class="p_del">-	msg-&gt;controlselector = le16_to_cpu((__force __le16)msg-&gt;controlselector);</span>
 
 	/* Update the read positions, adjusting the ring */
 	saa7164_writel(bus-&gt;m_dwGetReadPos, new_grp);
<span class="p_header">diff --git a/drivers/media/platform/davinci/vpfe_capture.c b/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_header">index 7767e072d623..1f656a3a84b9 100644</span>
<span class="p_header">--- a/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_header">+++ b/drivers/media/platform/davinci/vpfe_capture.c</span>
<span class="p_chunk">@@ -1709,27 +1709,9 @@</span> <span class="p_context"> static long vpfe_param_handler(struct file *file, void *priv,</span>
 
 	switch (cmd) {
 	case VPFE_CMD_S_CCDC_RAW_PARAMS:
<span class="p_add">+		ret = -EINVAL;</span>
 		v4l2_warn(&amp;vpfe_dev-&gt;v4l2_dev,
<span class="p_del">-			  &quot;VPFE_CMD_S_CCDC_RAW_PARAMS: experimental ioctl\n&quot;);</span>
<span class="p_del">-		if (ccdc_dev-&gt;hw_ops.set_params) {</span>
<span class="p_del">-			ret = ccdc_dev-&gt;hw_ops.set_params(param);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				v4l2_dbg(1, debug, &amp;vpfe_dev-&gt;v4l2_dev,</span>
<span class="p_del">-					&quot;Error setting parameters in CCDC\n&quot;);</span>
<span class="p_del">-				goto unlock_out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			ret = vpfe_get_ccdc_image_format(vpfe_dev,</span>
<span class="p_del">-							 &amp;vpfe_dev-&gt;fmt);</span>
<span class="p_del">-			if (ret &lt; 0) {</span>
<span class="p_del">-				v4l2_dbg(1, debug, &amp;vpfe_dev-&gt;v4l2_dev,</span>
<span class="p_del">-					&quot;Invalid image format at CCDC\n&quot;);</span>
<span class="p_del">-				goto unlock_out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			v4l2_dbg(1, debug, &amp;vpfe_dev-&gt;v4l2_dev,</span>
<span class="p_del">-				&quot;VPFE_CMD_S_CCDC_RAW_PARAMS not supported\n&quot;);</span>
<span class="p_del">-		}</span>
<span class="p_add">+			&quot;VPFE_CMD_S_CCDC_RAW_PARAMS not supported\n&quot;);</span>
 		break;
 	default:
 		ret = -ENOTTY;
<span class="p_header">diff --git a/drivers/media/rc/ir-lirc-codec.c b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">index a32659fcd266..efc21b1da211 100644</span>
<span class="p_header">--- a/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_header">+++ b/drivers/media/rc/ir-lirc-codec.c</span>
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> static long ir_lirc_ioctl(struct file *filep, unsigned int cmd,</span>
 		return 0;
 
 	case LIRC_GET_REC_RESOLUTION:
<span class="p_del">-		val = dev-&gt;rx_resolution;</span>
<span class="p_add">+		val = dev-&gt;rx_resolution / 1000;</span>
 		break;
 
 	case LIRC_SET_WIDEBAND_RECEIVER:
<span class="p_header">diff --git a/drivers/net/ethernet/aurora/nb8800.c b/drivers/net/ethernet/aurora/nb8800.c</span>
<span class="p_header">index ecc4a334c507..0a54e7dac0ab 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/aurora/nb8800.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/aurora/nb8800.c</span>
<span class="p_chunk">@@ -608,7 +608,7 @@</span> <span class="p_context"> static void nb8800_mac_config(struct net_device *dev)</span>
 		mac_mode |= HALF_DUPLEX;
 
 	if (gigabit) {
<span class="p_del">-		if (priv-&gt;phy_mode == PHY_INTERFACE_MODE_RGMII)</span>
<span class="p_add">+		if (phy_interface_is_rgmii(dev-&gt;phydev))</span>
 			mac_mode |= RGMII_MODE;
 
 		mac_mode |= GMAC_MODE;
<span class="p_chunk">@@ -1295,11 +1295,10 @@</span> <span class="p_context"> static int nb8800_tangox_init(struct net_device *dev)</span>
 		break;
 
 	case PHY_INTERFACE_MODE_RGMII:
<span class="p_del">-		pad_mode = PAD_MODE_RGMII;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_add">+	case PHY_INTERFACE_MODE_RGMII_ID:</span>
<span class="p_add">+	case PHY_INTERFACE_MODE_RGMII_RXID:</span>
 	case PHY_INTERFACE_MODE_RGMII_TXID:
<span class="p_del">-		pad_mode = PAD_MODE_RGMII | PAD_MODE_GTX_CLK_DELAY;</span>
<span class="p_add">+		pad_mode = PAD_MODE_RGMII;</span>
 		break;
 
 	default:
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">index 21e5b9ed1ead..3613469dc5c6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_chunk">@@ -8722,11 +8722,14 @@</span> <span class="p_context"> static void tg3_free_consistent(struct tg3 *tp)</span>
 	tg3_mem_rx_release(tp);
 	tg3_mem_tx_release(tp);
 
<span class="p_add">+	/* Protect tg3_get_stats64() from reading freed tp-&gt;hw_stats. */</span>
<span class="p_add">+	tg3_full_lock(tp, 0);</span>
 	if (tp-&gt;hw_stats) {
 		dma_free_coherent(&amp;tp-&gt;pdev-&gt;dev, sizeof(struct tg3_hw_stats),
 				  tp-&gt;hw_stats, tp-&gt;stats_mapping);
 		tp-&gt;hw_stats = NULL;
 	}
<span class="p_add">+	tg3_full_unlock(tp);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">index cc199063612a..6c66d2979795 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_chunk">@@ -630,6 +630,10 @@</span> <span class="p_context"> static void dump_command(struct mlx5_core_dev *dev,</span>
 		pr_debug(&quot;\n&quot;);
 }
 
<span class="p_add">+static void free_msg(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *msg);</span>
<span class="p_add">+static void mlx5_free_cmd_msg(struct mlx5_core_dev *dev,</span>
<span class="p_add">+			      struct mlx5_cmd_msg *msg);</span>
<span class="p_add">+</span>
 static void cmd_work_handler(struct work_struct *work)
 {
 	struct mlx5_cmd_work_ent *ent = container_of(work, struct mlx5_cmd_work_ent, work);
<span class="p_chunk">@@ -638,16 +642,27 @@</span> <span class="p_context"> static void cmd_work_handler(struct work_struct *work)</span>
 	struct mlx5_cmd_layout *lay;
 	struct semaphore *sem;
 	unsigned long flags;
<span class="p_add">+	int alloc_ret;</span>
 
 	sem = ent-&gt;page_queue ? &amp;cmd-&gt;pages_sem : &amp;cmd-&gt;sem;
 	down(sem);
 	if (!ent-&gt;page_queue) {
<span class="p_del">-		ent-&gt;idx = alloc_ent(cmd);</span>
<span class="p_del">-		if (ent-&gt;idx &lt; 0) {</span>
<span class="p_add">+		alloc_ret = alloc_ent(cmd);</span>
<span class="p_add">+		if (alloc_ret &lt; 0) {</span>
<span class="p_add">+			if (ent-&gt;callback) {</span>
<span class="p_add">+				ent-&gt;callback(-EAGAIN, ent-&gt;context);</span>
<span class="p_add">+				mlx5_free_cmd_msg(dev, ent-&gt;out);</span>
<span class="p_add">+				free_msg(dev, ent-&gt;in);</span>
<span class="p_add">+				free_cmd(ent);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ent-&gt;ret = -EAGAIN;</span>
<span class="p_add">+				complete(&amp;ent-&gt;done);</span>
<span class="p_add">+			}</span>
 			mlx5_core_err(dev, &quot;failed to allocate command entry\n&quot;);
 			up(sem);
 			return;
 		}
<span class="p_add">+		ent-&gt;idx = alloc_ret;</span>
 	} else {
 		ent-&gt;idx = cmd-&gt;max_reg_cmds;
 		spin_lock_irqsave(&amp;cmd-&gt;alloc_lock, flags);
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">index 4296066a7ad3..479af106aaeb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_chunk">@@ -819,6 +819,7 @@</span> <span class="p_context"> static struct sh_eth_cpu_data r8a7740_data = {</span>
 	.rpadir_value   = 2 &lt;&lt; 16,
 	.no_trimd	= 1,
 	.no_ade		= 1,
<span class="p_add">+	.hw_crc		= 1,</span>
 	.tsu		= 1,
 	.select_mii	= 1,
 	.shift_rd0	= 1,
<span class="p_header">diff --git a/drivers/net/irda/mcs7780.c b/drivers/net/irda/mcs7780.c</span>
<span class="p_header">index bca6a1e72d1d..e1bb802d4a4d 100644</span>
<span class="p_header">--- a/drivers/net/irda/mcs7780.c</span>
<span class="p_header">+++ b/drivers/net/irda/mcs7780.c</span>
<span class="p_chunk">@@ -141,9 +141,19 @@</span> <span class="p_context"> static int mcs_set_reg(struct mcs_cb *mcs, __u16 reg, __u16 val)</span>
 static int mcs_get_reg(struct mcs_cb *mcs, __u16 reg, __u16 * val)
 {
 	struct usb_device *dev = mcs-&gt;usbdev;
<span class="p_del">-	int ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,</span>
<span class="p_del">-				  MCS_RD_RTYPE, 0, reg, val, 2,</span>
<span class="p_del">-				  msecs_to_jiffies(MCS_CTRL_TIMEOUT));</span>
<span class="p_add">+	void *dmabuf;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	dmabuf = kmalloc(sizeof(__u16), GFP_KERNEL);</span>
<span class="p_add">+	if (!dmabuf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,</span>
<span class="p_add">+			      MCS_RD_RTYPE, 0, reg, dmabuf, 2,</span>
<span class="p_add">+			      msecs_to_jiffies(MCS_CTRL_TIMEOUT));</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(val, dmabuf, sizeof(__u16));</span>
<span class="p_add">+	kfree(dmabuf);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/phy/dp83867.c b/drivers/net/phy/dp83867.c</span>
<span class="p_header">index 32f10662f4ac..7242dd4b3238 100644</span>
<span class="p_header">--- a/drivers/net/phy/dp83867.c</span>
<span class="p_header">+++ b/drivers/net/phy/dp83867.c</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"></span>
 #define MII_DP83867_MICR	0x12
 #define MII_DP83867_ISR		0x13
 #define DP83867_CTRL		0x1f
<span class="p_add">+#define DP83867_CFG3		0x1e</span>
 
 /* Extended Registers */
 #define DP83867_RGMIICTL	0x0032
<span class="p_chunk">@@ -89,6 +90,8 @@</span> <span class="p_context"> static int dp83867_config_intr(struct phy_device *phydev)</span>
 		micr_status |=
 			(MII_DP83867_MICR_AN_ERR_INT_EN |
 			MII_DP83867_MICR_SPEED_CHNG_INT_EN |
<span class="p_add">+			MII_DP83867_MICR_AUTONEG_COMP_INT_EN |</span>
<span class="p_add">+			MII_DP83867_MICR_LINK_STS_CHNG_INT_EN |</span>
 			MII_DP83867_MICR_DUP_MODE_CHNG_INT_EN |
 			MII_DP83867_MICR_SLEEP_MODE_CHNG_INT_EN);
 
<span class="p_chunk">@@ -184,6 +187,13 @@</span> <span class="p_context"> static int dp83867_config_init(struct phy_device *phydev)</span>
 				       DP83867_DEVADDR, phydev-&gt;addr, delay);
 	}
 
<span class="p_add">+	/* Enable Interrupt output INT_OE in CFG3 register */</span>
<span class="p_add">+	if (phy_interrupt_is_valid(phydev)) {</span>
<span class="p_add">+		val = phy_read(phydev, DP83867_CFG3);</span>
<span class="p_add">+		val |= BIT(7);</span>
<span class="p_add">+		phy_write(phydev, DP83867_CFG3, val);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index 851c0e121807..49d9f0a789fe 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -541,6 +541,9 @@</span> <span class="p_context"> void phy_stop_machine(struct phy_device *phydev)</span>
 	if (phydev-&gt;state &gt; PHY_UP &amp;&amp; phydev-&gt;state != PHY_HALTED)
 		phydev-&gt;state = PHY_UP;
 	mutex_unlock(&amp;phydev-&gt;lock);
<span class="p_add">+</span>
<span class="p_add">+	/* Now we can run the state machine synchronously */</span>
<span class="p_add">+	phy_state_machine(&amp;phydev-&gt;state_queue.work);</span>
 }
 
 /**
<span class="p_chunk">@@ -918,6 +921,15 @@</span> <span class="p_context"> void phy_state_machine(struct work_struct *work)</span>
 			if (old_link != phydev-&gt;link)
 				phydev-&gt;state = PHY_CHANGELINK;
 		}
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Failsafe: check that nobody set phydev-&gt;link=0 between two</span>
<span class="p_add">+		 * poll cycles, otherwise we won&#39;t leave RUNNING state as long</span>
<span class="p_add">+		 * as link remains down.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!phydev-&gt;link &amp;&amp; phydev-&gt;state == PHY_RUNNING) {</span>
<span class="p_add">+			phydev-&gt;state = PHY_CHANGELINK;</span>
<span class="p_add">+			dev_err(&amp;phydev-&gt;dev, &quot;no link in PHY_RUNNING\n&quot;);</span>
<span class="p_add">+		}</span>
 		break;
 	case PHY_CHANGELINK:
 		err = phy_read_status(phydev);
<span class="p_header">diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c</span>
<span class="p_header">index 1d1e5f7723ab..8179727d3423 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy_device.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy_device.c</span>
<span class="p_chunk">@@ -1368,6 +1368,8 @@</span> <span class="p_context"> static int phy_remove(struct device *dev)</span>
 {
 	struct phy_device *phydev = to_phy_device(dev);
 
<span class="p_add">+	cancel_delayed_work_sync(&amp;phydev-&gt;state_queue);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;phydev-&gt;lock);
 	phydev-&gt;state = PHY_DOWN;
 	mutex_unlock(&amp;phydev-&gt;lock);
<span class="p_header">diff --git a/drivers/net/xen-netback/common.h b/drivers/net/xen-netback/common.h</span>
<span class="p_header">index 0333ab0fd926..34173b5e886f 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/common.h</span>
<span class="p_header">+++ b/drivers/net/xen-netback/common.h</span>
<span class="p_chunk">@@ -201,6 +201,7 @@</span> <span class="p_context"> struct xenvif_queue { /* Per-queue data for xenvif */</span>
 	unsigned long   remaining_credit;
 	struct timer_list credit_timeout;
 	u64 credit_window_start;
<span class="p_add">+	bool rate_limited;</span>
 
 	/* Statistics */
 	struct xenvif_stats stats;
<span class="p_header">diff --git a/drivers/net/xen-netback/interface.c b/drivers/net/xen-netback/interface.c</span>
<span class="p_header">index e7bd63eb2876..60b26f32d31d 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/interface.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/interface.c</span>
<span class="p_chunk">@@ -105,7 +105,11 @@</span> <span class="p_context"> static int xenvif_poll(struct napi_struct *napi, int budget)</span>
 
 	if (work_done &lt; budget) {
 		napi_complete(napi);
<span class="p_del">-		xenvif_napi_schedule_or_enable_events(queue);</span>
<span class="p_add">+		/* If the queue is rate-limited, it shall be</span>
<span class="p_add">+		 * rescheduled in the timer callback.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (likely(!queue-&gt;rate_limited))</span>
<span class="p_add">+			xenvif_napi_schedule_or_enable_events(queue);</span>
 	}
 
 	return work_done;
<span class="p_header">diff --git a/drivers/net/xen-netback/netback.c b/drivers/net/xen-netback/netback.c</span>
<span class="p_header">index 1049c34e7d43..72ee1c305cc4 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/netback.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/netback.c</span>
<span class="p_chunk">@@ -687,6 +687,7 @@</span> <span class="p_context"> static void tx_add_credit(struct xenvif_queue *queue)</span>
 		max_credit = ULONG_MAX; /* wrapped: clamp to ULONG_MAX */
 
 	queue-&gt;remaining_credit = min(max_credit, max_burst);
<span class="p_add">+	queue-&gt;rate_limited = false;</span>
 }
 
 void xenvif_tx_credit_callback(unsigned long data)
<span class="p_chunk">@@ -1184,8 +1185,10 @@</span> <span class="p_context"> static bool tx_credit_exceeded(struct xenvif_queue *queue, unsigned size)</span>
 		msecs_to_jiffies(queue-&gt;credit_usec / 1000);
 
 	/* Timer could already be pending in rare cases. */
<span class="p_del">-	if (timer_pending(&amp;queue-&gt;credit_timeout))</span>
<span class="p_add">+	if (timer_pending(&amp;queue-&gt;credit_timeout)) {</span>
<span class="p_add">+		queue-&gt;rate_limited = true;</span>
 		return true;
<span class="p_add">+	}</span>
 
 	/* Passed the point where we can replenish credit? */
 	if (time_after_eq64(now, next_credit)) {
<span class="p_chunk">@@ -1200,6 +1203,7 @@</span> <span class="p_context"> static bool tx_credit_exceeded(struct xenvif_queue *queue, unsigned size)</span>
 		mod_timer(&amp;queue-&gt;credit_timeout,
 			  next_credit);
 		queue-&gt;credit_window_start = next_credit;
<span class="p_add">+		queue-&gt;rate_limited = true;</span>
 
 		return true;
 	}
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">index 6b942d9e5b74..1ed85dfc008d 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_chunk">@@ -329,12 +329,15 @@</span> <span class="p_context"> qla2x00_sysfs_read_optrom(struct file *filp, struct kobject *kobj,</span>
 	struct qla_hw_data *ha = vha-&gt;hw;
 	ssize_t rval = 0;
 
<span class="p_add">+	mutex_lock(&amp;ha-&gt;optrom_mutex);</span>
<span class="p_add">+</span>
 	if (ha-&gt;optrom_state != QLA_SREADING)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_del">-	mutex_lock(&amp;ha-&gt;optrom_mutex);</span>
 	rval = memory_read_from_buffer(buf, count, &amp;off, ha-&gt;optrom_buffer,
 	    ha-&gt;optrom_region_size);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;ha-&gt;optrom_mutex);
 
 	return rval;
<span class="p_chunk">@@ -349,14 +352,19 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom(struct file *filp, struct kobject *kobj,</span>
 	    struct device, kobj)));
 	struct qla_hw_data *ha = vha-&gt;hw;
 
<span class="p_del">-	if (ha-&gt;optrom_state != QLA_SWRITING)</span>
<span class="p_add">+	mutex_lock(&amp;ha-&gt;optrom_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ha-&gt;optrom_state != QLA_SWRITING) {</span>
<span class="p_add">+		mutex_unlock(&amp;ha-&gt;optrom_mutex);</span>
 		return -EINVAL;
<span class="p_del">-	if (off &gt; ha-&gt;optrom_region_size)</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (off &gt; ha-&gt;optrom_region_size) {</span>
<span class="p_add">+		mutex_unlock(&amp;ha-&gt;optrom_mutex);</span>
 		return -ERANGE;
<span class="p_add">+	}</span>
 	if (off + count &gt; ha-&gt;optrom_region_size)
 		count = ha-&gt;optrom_region_size - off;
 
<span class="p_del">-	mutex_lock(&amp;ha-&gt;optrom_mutex);</span>
 	memcpy(&amp;ha-&gt;optrom_buffer[off], buf, count);
 	mutex_unlock(&amp;ha-&gt;optrom_mutex);
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index a180c000e246..31d5d9c0e10b 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -3965,6 +3965,8 @@</span> <span class="p_context"> int iscsi_target_tx_thread(void *arg)</span>
 {
 	int ret = 0;
 	struct iscsi_conn *conn = arg;
<span class="p_add">+	bool conn_freed = false;</span>
<span class="p_add">+</span>
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
<span class="p_chunk">@@ -3990,12 +3992,14 @@</span> <span class="p_context"> get_immediate:</span>
 			goto transport_err;
 
 		ret = iscsit_handle_response_queue(conn);
<span class="p_del">-		if (ret == 1)</span>
<span class="p_add">+		if (ret == 1) {</span>
 			goto get_immediate;
<span class="p_del">-		else if (ret == -ECONNRESET)</span>
<span class="p_add">+		} else if (ret == -ECONNRESET) {</span>
<span class="p_add">+			conn_freed = true;</span>
 			goto out;
<span class="p_del">-		else if (ret &lt; 0)</span>
<span class="p_add">+		} else if (ret &lt; 0) {</span>
 			goto transport_err;
<span class="p_add">+		}</span>
 	}
 
 transport_err:
<span class="p_chunk">@@ -4005,8 +4009,13 @@</span> <span class="p_context"> transport_err:</span>
 	 * responsible for cleaning up the early connection failure.
 	 */
 	if (conn-&gt;conn_state != TARG_CONN_STATE_IN_LOGIN)
<span class="p_del">-		iscsit_take_action_for_connection_exit(conn);</span>
<span class="p_add">+		iscsit_take_action_for_connection_exit(conn, &amp;conn_freed);</span>
 out:
<span class="p_add">+	if (!conn_freed) {</span>
<span class="p_add">+		while (!kthread_should_stop()) {</span>
<span class="p_add">+			msleep(100);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4105,6 +4114,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	u32 checksum = 0, digest = 0;
 	struct iscsi_conn *conn = arg;
 	struct kvec iov;
<span class="p_add">+	bool conn_freed = false;</span>
 	/*
 	 * Allow ourselves to be interrupted by SIGINT so that a
 	 * connection recovery / failure event can be triggered externally.
<span class="p_chunk">@@ -4116,7 +4126,7 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 	 */
 	rc = wait_for_completion_interruptible(&amp;conn-&gt;rx_login_comp);
 	if (rc &lt; 0 || iscsi_target_check_conn_state(conn))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto out;</span>
 
 	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_INFINIBAND) {
 		struct completion comp;
<span class="p_chunk">@@ -4201,7 +4211,13 @@</span> <span class="p_context"> int iscsi_target_rx_thread(void *arg)</span>
 transport_err:
 	if (!signal_pending(current))
 		atomic_set(&amp;conn-&gt;transport_failed, 1);
<span class="p_del">-	iscsit_take_action_for_connection_exit(conn);</span>
<span class="p_add">+	iscsit_take_action_for_connection_exit(conn, &amp;conn_freed);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	if (!conn_freed) {</span>
<span class="p_add">+		while (!kthread_should_stop()) {</span>
<span class="p_add">+			msleep(100);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4575,8 +4591,11 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	 * always sleep waiting for RX/TX thread shutdown to complete
 	 * within iscsit_close_connection().
 	 */
<span class="p_del">-	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP) {</span>
 		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);
<span class="p_add">+		if (!sleep)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_chunk">@@ -4592,8 +4611,11 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_samecid(</span>
 {
 	int sleep = 1;
 
<span class="p_del">-	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP)</span>
<span class="p_add">+	if (conn-&gt;conn_transport-&gt;transport_type == ISCSI_TCP) {</span>
 		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);
<span class="p_add">+		if (!sleep)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_erl0.c b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">index 210f6e4830e3..6c88fb021444 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_erl0.c</span>
<span class="p_chunk">@@ -930,8 +930,10 @@</span> <span class="p_context"> static void iscsit_handle_connection_cleanup(struct iscsi_conn *conn)</span>
 	}
 }
 
<span class="p_del">-void iscsit_take_action_for_connection_exit(struct iscsi_conn *conn)</span>
<span class="p_add">+void iscsit_take_action_for_connection_exit(struct iscsi_conn *conn, bool *conn_freed)</span>
 {
<span class="p_add">+	*conn_freed = false;</span>
<span class="p_add">+</span>
 	spin_lock_bh(&amp;conn-&gt;state_lock);
 	if (atomic_read(&amp;conn-&gt;connection_exit)) {
 		spin_unlock_bh(&amp;conn-&gt;state_lock);
<span class="p_chunk">@@ -942,6 +944,7 @@</span> <span class="p_context"> void iscsit_take_action_for_connection_exit(struct iscsi_conn *conn)</span>
 	if (conn-&gt;conn_state == TARG_CONN_STATE_IN_LOGOUT) {
 		spin_unlock_bh(&amp;conn-&gt;state_lock);
 		iscsit_close_connection(conn);
<span class="p_add">+		*conn_freed = true;</span>
 		return;
 	}
 
<span class="p_chunk">@@ -955,4 +958,5 @@</span> <span class="p_context"> void iscsit_take_action_for_connection_exit(struct iscsi_conn *conn)</span>
 	spin_unlock_bh(&amp;conn-&gt;state_lock);
 
 	iscsit_handle_connection_cleanup(conn);
<span class="p_add">+	*conn_freed = true;</span>
 }
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_erl0.h b/drivers/target/iscsi/iscsi_target_erl0.h</span>
<span class="p_header">index a9e2f9497fb2..fbc1d84a63c3 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_erl0.h</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_erl0.h</span>
<span class="p_chunk">@@ -9,6 +9,6 @@</span> <span class="p_context"> extern int iscsit_stop_time2retain_timer(struct iscsi_session *);</span>
 extern void iscsit_connection_reinstatement_rcfr(struct iscsi_conn *);
 extern void iscsit_cause_connection_reinstatement(struct iscsi_conn *, int);
 extern void iscsit_fall_back_to_erl0(struct iscsi_session *);
<span class="p_del">-extern void iscsit_take_action_for_connection_exit(struct iscsi_conn *);</span>
<span class="p_add">+extern void iscsit_take_action_for_connection_exit(struct iscsi_conn *, bool *);</span>
 
 #endif   /*** ISCSI_TARGET_ERL0_H ***/
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 4a137b0ae3dc..b19edffa7d98 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -1436,5 +1436,9 @@</span> <span class="p_context"> int iscsi_target_login_thread(void *arg)</span>
 			break;
 	}
 
<span class="p_add">+	while (!kthread_should_stop()) {</span>
<span class="p_add">+		msleep(100);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_nego.c b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">index 549a2bbbf4df..58c629aec73c 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_nego.c</span>
<span class="p_chunk">@@ -489,14 +489,60 @@</span> <span class="p_context"> static void iscsi_target_restore_sock_callbacks(struct iscsi_conn *conn)</span>
 
 static int iscsi_target_do_login(struct iscsi_conn *, struct iscsi_login *);
 
<span class="p_del">-static bool iscsi_target_sk_state_check(struct sock *sk)</span>
<span class="p_add">+static bool __iscsi_target_sk_check_close(struct sock *sk)</span>
 {
 	if (sk-&gt;sk_state == TCP_CLOSE_WAIT || sk-&gt;sk_state == TCP_CLOSE) {
<span class="p_del">-		pr_debug(&quot;iscsi_target_sk_state_check: TCP_CLOSE_WAIT|TCP_CLOSE,&quot;</span>
<span class="p_add">+		pr_debug(&quot;__iscsi_target_sk_check_close: TCP_CLOSE_WAIT|TCP_CLOSE,&quot;</span>
 			&quot;returning FALSE\n&quot;);
<span class="p_del">-		return false;</span>
<span class="p_add">+		return true;</span>
 	}
<span class="p_del">-	return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool iscsi_target_sk_check_close(struct iscsi_conn *conn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool state = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;sock) {</span>
<span class="p_add">+		struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_add">+</span>
<span class="p_add">+		read_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+		state = (__iscsi_target_sk_check_close(sk) ||</span>
<span class="p_add">+			 test_bit(LOGIN_FLAGS_CLOSED, &amp;conn-&gt;login_flags));</span>
<span class="p_add">+		read_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return state;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool iscsi_target_sk_check_flag(struct iscsi_conn *conn, unsigned int flag)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool state = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;sock) {</span>
<span class="p_add">+		struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_add">+</span>
<span class="p_add">+		read_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+		state = test_bit(flag, &amp;conn-&gt;login_flags);</span>
<span class="p_add">+		read_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return state;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool iscsi_target_sk_check_and_clear(struct iscsi_conn *conn, unsigned int flag)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool state = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (conn-&gt;sock) {</span>
<span class="p_add">+		struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_add">+</span>
<span class="p_add">+		write_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+		state = (__iscsi_target_sk_check_close(sk) ||</span>
<span class="p_add">+			 test_bit(LOGIN_FLAGS_CLOSED, &amp;conn-&gt;login_flags));</span>
<span class="p_add">+		if (!state)</span>
<span class="p_add">+			clear_bit(flag, &amp;conn-&gt;login_flags);</span>
<span class="p_add">+		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return state;</span>
 }
 
 static void iscsi_target_login_drop(struct iscsi_conn *conn, struct iscsi_login *login)
<span class="p_chunk">@@ -536,6 +582,20 @@</span> <span class="p_context"> static void iscsi_target_do_login_rx(struct work_struct *work)</span>
 
 	pr_debug(&quot;entering iscsi_target_do_login_rx, conn: %p, %s:%d\n&quot;,
 			conn, current-&gt;comm, current-&gt;pid);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If iscsi_target_do_login_rx() has been invoked by -&gt;sk_data_ready()</span>
<span class="p_add">+	 * before initial PDU processing in iscsi_target_start_negotiation()</span>
<span class="p_add">+	 * has completed, go ahead and retry until it&#39;s cleared.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Otherwise if the TCP connection drops while this is occuring,</span>
<span class="p_add">+	 * iscsi_target_start_negotiation() will detect the failure, call</span>
<span class="p_add">+	 * cancel_delayed_work_sync(&amp;conn-&gt;login_work), and cleanup the</span>
<span class="p_add">+	 * remaining iscsi connection resources from iscsi_np process context.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (iscsi_target_sk_check_flag(conn, LOGIN_FLAGS_INITIAL_PDU)) {</span>
<span class="p_add">+		schedule_delayed_work(&amp;conn-&gt;login_work, msecs_to_jiffies(10));</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
 	spin_lock(&amp;tpg-&gt;tpg_state_lock);
 	state = (tpg-&gt;tpg_state == TPG_STATE_ACTIVE);
<span class="p_chunk">@@ -543,26 +603,12 @@</span> <span class="p_context"> static void iscsi_target_do_login_rx(struct work_struct *work)</span>
 
 	if (!state) {
 		pr_debug(&quot;iscsi_target_do_login_rx: tpg_state != TPG_STATE_ACTIVE\n&quot;);
<span class="p_del">-		iscsi_target_restore_sock_callbacks(conn);</span>
<span class="p_del">-		iscsi_target_login_drop(conn, login);</span>
<span class="p_del">-		iscsit_deaccess_np(np, tpg, tpg_np);</span>
<span class="p_del">-		return;</span>
<span class="p_add">+		goto err;</span>
 	}
 
<span class="p_del">-	if (conn-&gt;sock) {</span>
<span class="p_del">-		struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_del">-</span>
<span class="p_del">-		read_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-		state = iscsi_target_sk_state_check(sk);</span>
<span class="p_del">-		read_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!state) {</span>
<span class="p_del">-			pr_debug(&quot;iscsi_target_do_login_rx, TCP state CLOSE\n&quot;);</span>
<span class="p_del">-			iscsi_target_restore_sock_callbacks(conn);</span>
<span class="p_del">-			iscsi_target_login_drop(conn, login);</span>
<span class="p_del">-			iscsit_deaccess_np(np, tpg, tpg_np);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (iscsi_target_sk_check_close(conn)) {</span>
<span class="p_add">+		pr_debug(&quot;iscsi_target_do_login_rx, TCP state CLOSE\n&quot;);</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	conn-&gt;login_kworker = current;
<span class="p_chunk">@@ -580,34 +626,29 @@</span> <span class="p_context"> static void iscsi_target_do_login_rx(struct work_struct *work)</span>
 	flush_signals(current);
 	conn-&gt;login_kworker = NULL;
 
<span class="p_del">-	if (rc &lt; 0) {</span>
<span class="p_del">-		iscsi_target_restore_sock_callbacks(conn);</span>
<span class="p_del">-		iscsi_target_login_drop(conn, login);</span>
<span class="p_del">-		iscsit_deaccess_np(np, tpg, tpg_np);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (rc &lt; 0)</span>
<span class="p_add">+		goto err;</span>
 
 	pr_debug(&quot;iscsi_target_do_login_rx after rx_login_io, %p, %s:%d\n&quot;,
 			conn, current-&gt;comm, current-&gt;pid);
 
 	rc = iscsi_target_do_login(conn, login);
 	if (rc &lt; 0) {
<span class="p_del">-		iscsi_target_restore_sock_callbacks(conn);</span>
<span class="p_del">-		iscsi_target_login_drop(conn, login);</span>
<span class="p_del">-		iscsit_deaccess_np(np, tpg, tpg_np);</span>
<span class="p_add">+		goto err;</span>
 	} else if (!rc) {
<span class="p_del">-		if (conn-&gt;sock) {</span>
<span class="p_del">-			struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_del">-</span>
<span class="p_del">-			write_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-			clear_bit(LOGIN_FLAGS_READ_ACTIVE, &amp;conn-&gt;login_flags);</span>
<span class="p_del">-			write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (iscsi_target_sk_check_and_clear(conn, LOGIN_FLAGS_READ_ACTIVE))</span>
<span class="p_add">+			goto err;</span>
 	} else if (rc == 1) {
 		iscsi_target_nego_release(conn);
 		iscsi_post_login_handler(np, conn, zero_tsih);
 		iscsit_deaccess_np(np, tpg, tpg_np);
 	}
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	iscsi_target_restore_sock_callbacks(conn);</span>
<span class="p_add">+	iscsi_target_login_drop(conn, login);</span>
<span class="p_add">+	iscsit_deaccess_np(np, tpg, tpg_np);</span>
 }
 
 static void iscsi_target_do_cleanup(struct work_struct *work)
<span class="p_chunk">@@ -655,31 +696,54 @@</span> <span class="p_context"> static void iscsi_target_sk_state_change(struct sock *sk)</span>
 		orig_state_change(sk);
 		return;
 	}
<span class="p_add">+	state = __iscsi_target_sk_check_close(sk);</span>
<span class="p_add">+	pr_debug(&quot;__iscsi_target_sk_close_change: state: %d\n&quot;, state);</span>
<span class="p_add">+</span>
 	if (test_bit(LOGIN_FLAGS_READ_ACTIVE, &amp;conn-&gt;login_flags)) {
 		pr_debug(&quot;Got LOGIN_FLAGS_READ_ACTIVE=1 sk_state_change&quot;
 			 &quot; conn: %p\n&quot;, conn);
<span class="p_add">+		if (state)</span>
<span class="p_add">+			set_bit(LOGIN_FLAGS_CLOSED, &amp;conn-&gt;login_flags);</span>
 		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 		orig_state_change(sk);
 		return;
 	}
<span class="p_del">-	if (test_and_set_bit(LOGIN_FLAGS_CLOSED, &amp;conn-&gt;login_flags)) {</span>
<span class="p_add">+	if (test_bit(LOGIN_FLAGS_CLOSED, &amp;conn-&gt;login_flags)) {</span>
 		pr_debug(&quot;Got LOGIN_FLAGS_CLOSED=1 sk_state_change conn: %p\n&quot;,
 			 conn);
 		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 		orig_state_change(sk);
 		return;
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the TCP connection has dropped, go ahead and set LOGIN_FLAGS_CLOSED,</span>
<span class="p_add">+	 * but only queue conn-&gt;login_work -&gt; iscsi_target_do_login_rx()</span>
<span class="p_add">+	 * processing if LOGIN_FLAGS_INITIAL_PDU has already been cleared.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * When iscsi_target_do_login_rx() runs, iscsi_target_sk_check_close()</span>
<span class="p_add">+	 * will detect the dropped TCP connection from delayed workqueue context.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If LOGIN_FLAGS_INITIAL_PDU is still set, which means the initial</span>
<span class="p_add">+	 * iscsi_target_start_negotiation() is running, iscsi_target_do_login()</span>
<span class="p_add">+	 * via iscsi_target_sk_check_close() or iscsi_target_start_negotiation()</span>
<span class="p_add">+	 * via iscsi_target_sk_check_and_clear() is responsible for detecting the</span>
<span class="p_add">+	 * dropped TCP connection in iscsi_np process context, and cleaning up</span>
<span class="p_add">+	 * the remaining iscsi connection resources.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (state) {</span>
<span class="p_add">+		pr_debug(&quot;iscsi_target_sk_state_change got failed state\n&quot;);</span>
<span class="p_add">+		set_bit(LOGIN_FLAGS_CLOSED, &amp;conn-&gt;login_flags);</span>
<span class="p_add">+		state = test_bit(LOGIN_FLAGS_INITIAL_PDU, &amp;conn-&gt;login_flags);</span>
<span class="p_add">+		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
 
<span class="p_del">-	state = iscsi_target_sk_state_check(sk);</span>
<span class="p_del">-	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_debug(&quot;iscsi_target_sk_state_change: state: %d\n&quot;, state);</span>
<span class="p_add">+		orig_state_change(sk);</span>
 
<span class="p_del">-	if (!state) {</span>
<span class="p_del">-		pr_debug(&quot;iscsi_target_sk_state_change got failed state\n&quot;);</span>
<span class="p_del">-		schedule_delayed_work(&amp;conn-&gt;login_cleanup_work, 0);</span>
<span class="p_add">+		if (!state)</span>
<span class="p_add">+			schedule_delayed_work(&amp;conn-&gt;login_work, 0);</span>
 		return;
 	}
<span class="p_add">+	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+</span>
 	orig_state_change(sk);
 }
 
<span class="p_chunk">@@ -944,6 +1008,15 @@</span> <span class="p_context"> static int iscsi_target_do_login(struct iscsi_conn *conn, struct iscsi_login *lo</span>
 			if (iscsi_target_handle_csg_one(conn, login) &lt; 0)
 				return -1;
 			if (login_rsp-&gt;flags &amp; ISCSI_FLAG_LOGIN_TRANSIT) {
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Check to make sure the TCP connection has not</span>
<span class="p_add">+				 * dropped asynchronously while session reinstatement</span>
<span class="p_add">+				 * was occuring in this kthread context, before</span>
<span class="p_add">+				 * transitioning to full feature phase operation.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (iscsi_target_sk_check_close(conn))</span>
<span class="p_add">+					return -1;</span>
<span class="p_add">+</span>
 				login-&gt;tsih = conn-&gt;sess-&gt;tsih;
 				login-&gt;login_complete = 1;
 				iscsi_target_restore_sock_callbacks(conn);
<span class="p_chunk">@@ -970,21 +1043,6 @@</span> <span class="p_context"> static int iscsi_target_do_login(struct iscsi_conn *conn, struct iscsi_login *lo</span>
 		break;
 	}
 
<span class="p_del">-	if (conn-&gt;sock) {</span>
<span class="p_del">-		struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_del">-		bool state;</span>
<span class="p_del">-</span>
<span class="p_del">-		read_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-		state = iscsi_target_sk_state_check(sk);</span>
<span class="p_del">-		read_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!state) {</span>
<span class="p_del">-			pr_debug(&quot;iscsi_target_do_login() failed state for&quot;</span>
<span class="p_del">-				 &quot; conn: %p\n&quot;, conn);</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1248,16 +1306,28 @@</span> <span class="p_context"> int iscsi_target_start_negotiation(</span>
 {
 	int ret;
 
<span class="p_add">+       if (conn-&gt;sock) {</span>
<span class="p_add">+               struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_add">+</span>
<span class="p_add">+		write_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+		set_bit(LOGIN_FLAGS_READY, &amp;conn-&gt;login_flags);</span>
<span class="p_add">+		set_bit(LOGIN_FLAGS_INITIAL_PDU, &amp;conn-&gt;login_flags);</span>
<span class="p_add">+		write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If iscsi_target_do_login returns zero to signal more PDU</span>
<span class="p_add">+	 * exchanges are required to complete the login, go ahead and</span>
<span class="p_add">+	 * clear LOGIN_FLAGS_INITIAL_PDU but only if the TCP connection</span>
<span class="p_add">+	 * is still active.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Otherwise if TCP connection dropped asynchronously, go ahead</span>
<span class="p_add">+	 * and perform connection cleanup now.</span>
<span class="p_add">+	 */</span>
 	ret = iscsi_target_do_login(conn, login);
<span class="p_del">-	if (!ret) {</span>
<span class="p_del">-		if (conn-&gt;sock) {</span>
<span class="p_del">-			struct sock *sk = conn-&gt;sock-&gt;sk;</span>
<span class="p_add">+	if (!ret &amp;&amp; iscsi_target_sk_check_and_clear(conn, LOGIN_FLAGS_INITIAL_PDU))</span>
<span class="p_add">+		ret = -1;</span>
 
<span class="p_del">-			write_lock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-			set_bit(LOGIN_FLAGS_READY, &amp;conn-&gt;login_flags);</span>
<span class="p_del">-			write_unlock_bh(&amp;sk-&gt;sk_callback_lock);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	} else if (ret &lt; 0) {</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
 		cancel_delayed_work_sync(&amp;conn-&gt;login_work);
 		cancel_delayed_work_sync(&amp;conn-&gt;login_cleanup_work);
 		iscsi_target_restore_sock_callbacks(conn);
<span class="p_header">diff --git a/drivers/target/target_core_fabric_configfs.c b/drivers/target/target_core_fabric_configfs.c</span>
<span class="p_header">index f916d18ccb48..b070ddf1dc37 100644</span>
<span class="p_header">--- a/drivers/target/target_core_fabric_configfs.c</span>
<span class="p_header">+++ b/drivers/target/target_core_fabric_configfs.c</span>
<span class="p_chunk">@@ -92,6 +92,11 @@</span> <span class="p_context"> static int target_fabric_mappedlun_link(</span>
 		pr_err(&quot;Source se_lun-&gt;lun_se_dev does not exist\n&quot;);
 		return -EINVAL;
 	}
<span class="p_add">+	if (lun-&gt;lun_shutdown) {</span>
<span class="p_add">+		pr_err(&quot;Unable to create mappedlun symlink because&quot;</span>
<span class="p_add">+			&quot; lun-&gt;lun_shutdown=true\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
 	se_tpg = lun-&gt;lun_tpg;
 
 	nacl_ci = &amp;lun_acl_ci-&gt;ci_parent-&gt;ci_group-&gt;cg_item;
<span class="p_header">diff --git a/drivers/target/target_core_tpg.c b/drivers/target/target_core_tpg.c</span>
<span class="p_header">index 899c33b3c734..f69f4902dc07 100644</span>
<span class="p_header">--- a/drivers/target/target_core_tpg.c</span>
<span class="p_header">+++ b/drivers/target/target_core_tpg.c</span>
<span class="p_chunk">@@ -673,6 +673,8 @@</span> <span class="p_context"> void core_tpg_remove_lun(</span>
 	 */
 	struct se_device *dev = rcu_dereference_raw(lun-&gt;lun_se_dev);
 
<span class="p_add">+	lun-&gt;lun_shutdown = true;</span>
<span class="p_add">+</span>
 	core_clear_lun_from_tpg(lun, tpg);
 	/*
 	 * Wait for any active I/O references to percpu se_lun-&gt;lun_ref to
<span class="p_chunk">@@ -694,6 +696,8 @@</span> <span class="p_context"> void core_tpg_remove_lun(</span>
 	}
 	if (!(dev-&gt;se_hba-&gt;hba_flags &amp; HBA_FLAGS_INTERNAL_USE))
 		hlist_del_rcu(&amp;lun-&gt;link);
<span class="p_add">+</span>
<span class="p_add">+	lun-&gt;lun_shutdown = false;</span>
 	mutex_unlock(&amp;tpg-&gt;tpg_lun_mutex);
 
 	percpu_ref_exit(&amp;lun-&gt;lun_ref);
<span class="p_header">diff --git a/fs/ext4/file.c b/fs/ext4/file.c</span>
<span class="p_header">index 8772bfc3415b..45ef9975caec 100644</span>
<span class="p_header">--- a/fs/ext4/file.c</span>
<span class="p_header">+++ b/fs/ext4/file.c</span>
<span class="p_chunk">@@ -500,6 +500,8 @@</span> <span class="p_context"> static int ext4_find_unwritten_pgoff(struct inode *inode,</span>
 				lastoff = page_offset(page);
 				bh = head = page_buffers(page);
 				do {
<span class="p_add">+					if (lastoff + bh-&gt;b_size &lt;= startoff)</span>
<span class="p_add">+						goto next;</span>
 					if (buffer_uptodate(bh) ||
 					    buffer_unwritten(bh)) {
 						if (whence == SEEK_DATA)
<span class="p_chunk">@@ -514,6 +516,7 @@</span> <span class="p_context"> static int ext4_find_unwritten_pgoff(struct inode *inode,</span>
 						unlock_page(page);
 						goto out;
 					}
<span class="p_add">+next:</span>
 					lastoff += bh-&gt;b_size;
 					bh = bh-&gt;b_this_page;
 				} while (bh != head);
<span class="p_header">diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c</span>
<span class="p_header">index 34038e3598d5..74516efd874c 100644</span>
<span class="p_header">--- a/fs/ext4/resize.c</span>
<span class="p_header">+++ b/fs/ext4/resize.c</span>
<span class="p_chunk">@@ -1926,7 +1926,8 @@</span> <span class="p_context"> retry:</span>
 			n_desc_blocks = o_desc_blocks +
 				le16_to_cpu(es-&gt;s_reserved_gdt_blocks);
 			n_group = n_desc_blocks * EXT4_DESC_PER_BLOCK(sb);
<span class="p_del">-			n_blocks_count = n_group * EXT4_BLOCKS_PER_GROUP(sb);</span>
<span class="p_add">+			n_blocks_count = (ext4_fsblk_t)n_group *</span>
<span class="p_add">+				EXT4_BLOCKS_PER_GROUP(sb);</span>
 			n_group--; /* set to last group number */
 		}
 
<span class="p_header">diff --git a/fs/f2fs/super.c b/fs/f2fs/super.c</span>
<span class="p_header">index 86e1cb899957..4f666368aa85 100644</span>
<span class="p_header">--- a/fs/f2fs/super.c</span>
<span class="p_header">+++ b/fs/f2fs/super.c</span>
<span class="p_chunk">@@ -1078,6 +1078,8 @@</span> <span class="p_context"> static int sanity_check_ckpt(struct f2fs_sb_info *sbi)</span>
 	unsigned int total, fsmeta;
 	struct f2fs_super_block *raw_super = F2FS_RAW_SUPER(sbi);
 	struct f2fs_checkpoint *ckpt = F2FS_CKPT(sbi);
<span class="p_add">+	unsigned int main_segs, blocks_per_seg;</span>
<span class="p_add">+	int i;</span>
 
 	total = le32_to_cpu(raw_super-&gt;segment_count);
 	fsmeta = le32_to_cpu(raw_super-&gt;segment_count_ckpt);
<span class="p_chunk">@@ -1089,6 +1091,20 @@</span> <span class="p_context"> static int sanity_check_ckpt(struct f2fs_sb_info *sbi)</span>
 	if (unlikely(fsmeta &gt;= total))
 		return 1;
 
<span class="p_add">+	main_segs = le32_to_cpu(raw_super-&gt;segment_count_main);</span>
<span class="p_add">+	blocks_per_seg = sbi-&gt;blocks_per_seg;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; NR_CURSEG_NODE_TYPE; i++) {</span>
<span class="p_add">+		if (le32_to_cpu(ckpt-&gt;cur_node_segno[i]) &gt;= main_segs ||</span>
<span class="p_add">+			le16_to_cpu(ckpt-&gt;cur_node_blkoff[i]) &gt;= blocks_per_seg)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	for (i = 0; i &lt; NR_CURSEG_DATA_TYPE; i++) {</span>
<span class="p_add">+		if (le32_to_cpu(ckpt-&gt;cur_data_segno[i]) &gt;= main_segs ||</span>
<span class="p_add">+			le16_to_cpu(ckpt-&gt;cur_data_blkoff[i]) &gt;= blocks_per_seg)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (unlikely(f2fs_cp_error(sbi))) {
 		f2fs_msg(sbi-&gt;sb, KERN_ERR, &quot;A bug case: need to run fsck&quot;);
 		return 1;
<span class="p_header">diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h</span>
<span class="p_header">index 2ccccbfcd532..36f4695aa604 100644</span>
<span class="p_header">--- a/include/linux/mm_types.h</span>
<span class="p_header">+++ b/include/linux/mm_types.h</span>
<span class="p_chunk">@@ -503,6 +503,10 @@</span> <span class="p_context"> struct mm_struct {</span>
 	 * PROT_NONE or PROT_NUMA mapped page.
 	 */
 	bool tlb_flush_pending;
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span>
<span class="p_add">+	/* See flush_tlb_batched_pending() */</span>
<span class="p_add">+	bool tlb_flush_batched;</span>
 #endif
 	struct uprobes_state uprobes_state;
 #ifdef CONFIG_X86_INTEL_MPX
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 352213b360d7..eff7c1fad26f 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -801,6 +801,16 @@</span> <span class="p_context"> struct signal_struct {</span>
 
 #define SIGNAL_UNKILLABLE	0x00000040 /* for init: ignore fatal signals */
 
<span class="p_add">+#define SIGNAL_STOP_MASK (SIGNAL_CLD_MASK | SIGNAL_STOP_STOPPED | \</span>
<span class="p_add">+			  SIGNAL_STOP_CONTINUED)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void signal_set_stop_flags(struct signal_struct *sig,</span>
<span class="p_add">+					 unsigned int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	WARN_ON(sig-&gt;flags &amp; (SIGNAL_GROUP_EXIT|SIGNAL_GROUP_COREDUMP));</span>
<span class="p_add">+	sig-&gt;flags = (sig-&gt;flags &amp; ~SIGNAL_STOP_MASK) | flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* If true, all threads except -&gt;group_exit_task have pending SIGKILL */
 static inline int signal_group_exit(const struct signal_struct *sig)
 {
<span class="p_header">diff --git a/include/linux/slab.h b/include/linux/slab.h</span>
<span class="p_header">index 2037a861e367..8a2a9ffaf5de 100644</span>
<span class="p_header">--- a/include/linux/slab.h</span>
<span class="p_header">+++ b/include/linux/slab.h</span>
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> size_t ksize(const void *);</span>
  * (PAGE_SIZE*2).  Larger requests are passed to the page allocator.
  */
 #define KMALLOC_SHIFT_HIGH	(PAGE_SHIFT + 1)
<span class="p_del">-#define KMALLOC_SHIFT_MAX	(MAX_ORDER + PAGE_SHIFT)</span>
<span class="p_add">+#define KMALLOC_SHIFT_MAX	(MAX_ORDER + PAGE_SHIFT - 1)</span>
 #ifndef KMALLOC_SHIFT_LOW
 #define KMALLOC_SHIFT_LOW	3
 #endif
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> size_t ksize(const void *);</span>
  * be allocated from the same page.
  */
 #define KMALLOC_SHIFT_HIGH	PAGE_SHIFT
<span class="p_del">-#define KMALLOC_SHIFT_MAX	30</span>
<span class="p_add">+#define KMALLOC_SHIFT_MAX	(MAX_ORDER + PAGE_SHIFT - 1)</span>
 #ifndef KMALLOC_SHIFT_LOW
 #define KMALLOC_SHIFT_LOW	3
 #endif
<span class="p_header">diff --git a/include/linux/workqueue.h b/include/linux/workqueue.h</span>
<span class="p_header">index 0197358f1e81..262d5c95dfc8 100644</span>
<span class="p_header">--- a/include/linux/workqueue.h</span>
<span class="p_header">+++ b/include/linux/workqueue.h</span>
<span class="p_chunk">@@ -311,6 +311,7 @@</span> <span class="p_context"> enum {</span>
 
 	__WQ_DRAINING		= 1 &lt;&lt; 16, /* internal: workqueue is draining */
 	__WQ_ORDERED		= 1 &lt;&lt; 17, /* internal: workqueue is ordered */
<span class="p_add">+	__WQ_ORDERED_EXPLICIT	= 1 &lt;&lt; 18, /* internal: alloc_ordered_workqueue() */</span>
 
 	WQ_MAX_ACTIVE		= 512,	  /* I like 512, better ideas? */
 	WQ_MAX_UNBOUND_PER_CPU	= 4,	  /* 4 * #cpus for unbound wq */
<span class="p_chunk">@@ -408,7 +409,8 @@</span> <span class="p_context"> __alloc_workqueue_key(const char *fmt, unsigned int flags, int max_active,</span>
  * Pointer to the allocated workqueue on success, %NULL on failure.
  */
 #define alloc_ordered_workqueue(fmt, flags, args...)			\
<span class="p_del">-	alloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED | (flags), 1, ##args)</span>
<span class="p_add">+	alloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED |		\</span>
<span class="p_add">+			__WQ_ORDERED_EXPLICIT | (flags), 1, ##args)</span>
 
 #define create_workqueue(name)						\
 	alloc_workqueue(&quot;%s&quot;, WQ_MEM_RECLAIM, 1, (name))
<span class="p_header">diff --git a/include/net/iw_handler.h b/include/net/iw_handler.h</span>
<span class="p_header">index e0f4109e64c6..c2aa73e5e6bb 100644</span>
<span class="p_header">--- a/include/net/iw_handler.h</span>
<span class="p_header">+++ b/include/net/iw_handler.h</span>
<span class="p_chunk">@@ -556,7 +556,8 @@</span> <span class="p_context"> iwe_stream_add_point(struct iw_request_info *info, char *stream, char *ends,</span>
 		memcpy(stream + lcp_len,
 		       ((char *) &amp;iwe-&gt;u) + IW_EV_POINT_OFF,
 		       IW_EV_POINT_PK_LEN - IW_EV_LCP_PK_LEN);
<span class="p_del">-		memcpy(stream + point_len, extra, iwe-&gt;u.data.length);</span>
<span class="p_add">+		if (iwe-&gt;u.data.length &amp;&amp; extra)</span>
<span class="p_add">+			memcpy(stream + point_len, extra, iwe-&gt;u.data.length);</span>
 		stream += event_len;
 	}
 	return stream;
<span class="p_header">diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h</span>
<span class="p_header">index ce13cf20f625..d33b17ba51d2 100644</span>
<span class="p_header">--- a/include/net/sctp/sctp.h</span>
<span class="p_header">+++ b/include/net/sctp/sctp.h</span>
<span class="p_chunk">@@ -444,6 +444,8 @@</span> <span class="p_context"> _sctp_walk_params((pos), (chunk), ntohs((chunk)-&gt;chunk_hdr.length), member)</span>
 
 #define _sctp_walk_params(pos, chunk, end, member)\
 for (pos.v = chunk-&gt;member;\
<span class="p_add">+     (pos.v + offsetof(struct sctp_paramhdr, length) + sizeof(pos.p-&gt;length) &lt;=\</span>
<span class="p_add">+      (void *)chunk + end) &amp;&amp;\</span>
      pos.v &lt;= (void *)chunk + end - ntohs(pos.p-&gt;length) &amp;&amp;\
      ntohs(pos.p-&gt;length) &gt;= sizeof(sctp_paramhdr_t);\
      pos.v += WORD_ROUND(ntohs(pos.p-&gt;length)))
<span class="p_chunk">@@ -454,6 +456,8 @@</span> <span class="p_context"> _sctp_walk_errors((err), (chunk_hdr), ntohs((chunk_hdr)-&gt;length))</span>
 #define _sctp_walk_errors(err, chunk_hdr, end)\
 for (err = (sctp_errhdr_t *)((void *)chunk_hdr + \
 	    sizeof(sctp_chunkhdr_t));\
<span class="p_add">+     ((void *)err + offsetof(sctp_errhdr_t, length) + sizeof(err-&gt;length) &lt;=\</span>
<span class="p_add">+      (void *)chunk_hdr + end) &amp;&amp;\</span>
      (void *)err &lt;= (void *)chunk_hdr + end - ntohs(err-&gt;length) &amp;&amp;\
      ntohs(err-&gt;length) &gt;= sizeof(sctp_errhdr_t); \
      err = (sctp_errhdr_t *)((void *)err + WORD_ROUND(ntohs(err-&gt;length))))
<span class="p_header">diff --git a/include/target/iscsi/iscsi_target_core.h b/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">index e0efe3fcf739..fdda45f26f75 100644</span>
<span class="p_header">--- a/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_header">+++ b/include/target/iscsi/iscsi_target_core.h</span>
<span class="p_chunk">@@ -562,6 +562,7 @@</span> <span class="p_context"> struct iscsi_conn {</span>
 #define LOGIN_FLAGS_READ_ACTIVE		1
 #define LOGIN_FLAGS_CLOSED		2
 #define LOGIN_FLAGS_READY		4
<span class="p_add">+#define LOGIN_FLAGS_INITIAL_PDU		8</span>
 	unsigned long		login_flags;
 	struct delayed_work	login_work;
 	struct delayed_work	login_cleanup_work;
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index ed66414b91f0..1adf8739980c 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -714,6 +714,7 @@</span> <span class="p_context"> struct se_lun {</span>
 #define SE_LUN_LINK_MAGIC			0xffff7771
 	u32			lun_link_magic;
 	u32			lun_access;
<span class="p_add">+	bool			lun_shutdown;</span>
 	u32			lun_index;
 
 	/* RELATIVE TARGET PORT IDENTIFER */
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index b92a047ddc82..5d50ea899b6d 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static bool task_participate_group_stop(struct task_struct *task)</span>
 	 * fresh group stop.  Read comment in do_signal_stop() for details.
 	 */
 	if (!sig-&gt;group_stop_count &amp;&amp; !(sig-&gt;flags &amp; SIGNAL_STOP_STOPPED)) {
<span class="p_del">-		sig-&gt;flags = SIGNAL_STOP_STOPPED;</span>
<span class="p_add">+		signal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);</span>
 		return true;
 	}
 	return false;
<span class="p_chunk">@@ -845,7 +845,7 @@</span> <span class="p_context"> static bool prepare_signal(int sig, struct task_struct *p, bool force)</span>
 			 * will take -&gt;siglock, notice SIGNAL_CLD_MASK, and
 			 * notify its parent. See get_signal_to_deliver().
 			 */
<span class="p_del">-			signal-&gt;flags = why | SIGNAL_STOP_CONTINUED;</span>
<span class="p_add">+			signal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);</span>
 			signal-&gt;group_stop_count = 0;
 			signal-&gt;group_exit_code = 0;
 		}
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 2c2f971f3e75..23231237f2e2 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -3647,8 +3647,12 @@</span> <span class="p_context"> static int apply_workqueue_attrs_locked(struct workqueue_struct *wq,</span>
 		return -EINVAL;
 
 	/* creating multiple pwqs breaks ordering guarantee */
<span class="p_del">-	if (WARN_ON((wq-&gt;flags &amp; __WQ_ORDERED) &amp;&amp; !list_empty(&amp;wq-&gt;pwqs)))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (!list_empty(&amp;wq-&gt;pwqs)) {</span>
<span class="p_add">+		if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED_EXPLICIT))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		wq-&gt;flags &amp;= ~__WQ_ORDERED;</span>
<span class="p_add">+	}</span>
 
 	ctx = apply_wqattrs_prepare(wq, attrs);
 
<span class="p_chunk">@@ -3834,6 +3838,16 @@</span> <span class="p_context"> struct workqueue_struct *__alloc_workqueue_key(const char *fmt,</span>
 	struct workqueue_struct *wq;
 	struct pool_workqueue *pwq;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Unbound &amp;&amp; max_active == 1 used to imply ordered, which is no</span>
<span class="p_add">+	 * longer the case on NUMA machines due to per-node pools.  While</span>
<span class="p_add">+	 * alloc_ordered_workqueue() is the right way to create an ordered</span>
<span class="p_add">+	 * workqueue, keep the previous behavior to avoid subtle breakages</span>
<span class="p_add">+	 * on NUMA.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((flags &amp; WQ_UNBOUND) &amp;&amp; max_active == 1)</span>
<span class="p_add">+		flags |= __WQ_ORDERED;</span>
<span class="p_add">+</span>
 	/* see the comment above the definition of WQ_POWER_EFFICIENT */
 	if ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)
 		flags |= WQ_UNBOUND;
<span class="p_chunk">@@ -4022,13 +4036,14 @@</span> <span class="p_context"> void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)</span>
 	struct pool_workqueue *pwq;
 
 	/* disallow meddling with max_active for ordered workqueues */
<span class="p_del">-	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED))</span>
<span class="p_add">+	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED_EXPLICIT))</span>
 		return;
 
 	max_active = wq_clamp_max_active(max_active, wq-&gt;flags, wq-&gt;name);
 
 	mutex_lock(&amp;wq-&gt;mutex);
 
<span class="p_add">+	wq-&gt;flags &amp;= ~__WQ_ORDERED;</span>
 	wq-&gt;saved_max_active = max_active;
 
 	for_each_pwq(pwq, wq)
<span class="p_chunk">@@ -5154,7 +5169,7 @@</span> <span class="p_context"> int workqueue_sysfs_register(struct workqueue_struct *wq)</span>
 	 * attributes breaks ordering guarantee.  Disallow exposing ordered
 	 * workqueues.
 	 */
<span class="p_del">-	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED))</span>
<span class="p_add">+	if (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED_EXPLICIT))</span>
 		return -EINVAL;
 
 	wq-&gt;wq_dev = wq_dev = kzalloc(sizeof(*wq_dev), GFP_KERNEL);
<span class="p_header">diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug</span>
<span class="p_header">index 8c15b29d5adc..b53b375e14bd 100644</span>
<span class="p_header">--- a/lib/Kconfig.debug</span>
<span class="p_header">+++ b/lib/Kconfig.debug</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> config DEBUG_INFO_REDUCED</span>
 
 config DEBUG_INFO_SPLIT
 	bool &quot;Produce split debuginfo in .dwo files&quot;
<span class="p_del">-	depends on DEBUG_INFO</span>
<span class="p_add">+	depends on DEBUG_INFO &amp;&amp; !FRV</span>
 	help
 	  Generate debug info into separate .dwo files. This significantly
 	  reduces the build directory size for builds with DEBUG_INFO,
<span class="p_header">diff --git a/mm/internal.h b/mm/internal.h</span>
<span class="p_header">index 6979b2bd3227..f63f4393d633 100644</span>
<span class="p_header">--- a/mm/internal.h</span>
<span class="p_header">+++ b/mm/internal.h</span>
<span class="p_chunk">@@ -453,6 +453,7 @@</span> <span class="p_context"> struct tlbflush_unmap_batch;</span>
 #ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH
 void try_to_unmap_flush(void);
 void try_to_unmap_flush_dirty(void);
<span class="p_add">+void flush_tlb_batched_pending(struct mm_struct *mm);</span>
 #else
 static inline void try_to_unmap_flush(void)
 {
<span class="p_chunk">@@ -460,6 +461,8 @@</span> <span class="p_context"> static inline void try_to_unmap_flush(void)</span>
 static inline void try_to_unmap_flush_dirty(void)
 {
 }
<span class="p_del">-</span>
<span class="p_add">+static inline void flush_tlb_batched_pending(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 #endif /* CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH */
 #endif	/* __MM_INTERNAL_H */
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index e6fa13484447..9ac55172aa7b 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -1127,6 +1127,7 @@</span> <span class="p_context"> again:</span>
 	init_rss_vec(rss);
 	start_pte = pte_offset_map_lock(mm, pmd, addr, &amp;ptl);
 	pte = start_pte;
<span class="p_add">+	flush_tlb_batched_pending(mm);</span>
 	arch_enter_lazy_mmu_mode();
 	do {
 		pte_t ptent = *pte;
<span class="p_header">diff --git a/mm/mprotect.c b/mm/mprotect.c</span>
<span class="p_header">index ef5be8eaab00..c0b4b2a49462 100644</span>
<span class="p_header">--- a/mm/mprotect.c</span>
<span class="p_header">+++ b/mm/mprotect.c</span>
<span class="p_chunk">@@ -72,6 +72,7 @@</span> <span class="p_context"> static unsigned long change_pte_range(struct vm_area_struct *vma, pmd_t *pmd,</span>
 	if (!pte)
 		return 0;
 
<span class="p_add">+	flush_tlb_batched_pending(vma-&gt;vm_mm);</span>
 	arch_enter_lazy_mmu_mode();
 	do {
 		oldpte = *pte;
<span class="p_header">diff --git a/mm/mremap.c b/mm/mremap.c</span>
<span class="p_header">index c25bc6268e46..fe7b7f65f4f4 100644</span>
<span class="p_header">--- a/mm/mremap.c</span>
<span class="p_header">+++ b/mm/mremap.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,</span>
 	new_ptl = pte_lockptr(mm, new_pmd);
 	if (new_ptl != old_ptl)
 		spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);
<span class="p_add">+	flush_tlb_batched_pending(vma-&gt;vm_mm);</span>
 	arch_enter_lazy_mmu_mode();
 
 	for (; old_addr &lt; old_end; old_pte++, old_addr += PAGE_SIZE,
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index bd17a6bdf131..f9d648fce8cd 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -1527,14 +1527,14 @@</span> <span class="p_context"> int move_freepages(struct zone *zone,</span>
 #endif
 
 	for (page = start_page; page &lt;= end_page;) {
<span class="p_del">-		/* Make sure we are not inadvertently changing nodes */</span>
<span class="p_del">-		VM_BUG_ON_PAGE(page_to_nid(page) != zone_to_nid(zone), page);</span>
<span class="p_del">-</span>
 		if (!pfn_valid_within(page_to_pfn(page))) {
 			page++;
 			continue;
 		}
 
<span class="p_add">+		/* Make sure we are not inadvertently changing nodes */</span>
<span class="p_add">+		VM_BUG_ON_PAGE(page_to_nid(page) != zone_to_nid(zone), page);</span>
<span class="p_add">+</span>
 		if (!PageBuddy(page)) {
 			page++;
 			continue;
<span class="p_chunk">@@ -5847,8 +5847,8 @@</span> <span class="p_context"> unsigned long free_reserved_area(void *start, void *end, int poison, char *s)</span>
 	}
 
 	if (pages &amp;&amp; s)
<span class="p_del">-		pr_info(&quot;Freeing %s memory: %ldK (%p - %p)\n&quot;,</span>
<span class="p_del">-			s, pages &lt;&lt; (PAGE_SHIFT - 10), start, end);</span>
<span class="p_add">+		pr_info(&quot;Freeing %s memory: %ldK\n&quot;,</span>
<span class="p_add">+			s, pages &lt;&lt; (PAGE_SHIFT - 10));</span>
 
 	return pages;
 }
<span class="p_header">diff --git a/mm/rmap.c b/mm/rmap.c</span>
<span class="p_header">index b577fbb98d4b..ede183c32f45 100644</span>
<span class="p_header">--- a/mm/rmap.c</span>
<span class="p_header">+++ b/mm/rmap.c</span>
<span class="p_chunk">@@ -648,6 +648,13 @@</span> <span class="p_context"> static void set_tlb_ubc_flush_pending(struct mm_struct *mm,</span>
 	cpumask_or(&amp;tlb_ubc-&gt;cpumask, &amp;tlb_ubc-&gt;cpumask, mm_cpumask(mm));
 	tlb_ubc-&gt;flush_required = true;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure compiler does not re-order the setting of tlb_flush_batched</span>
<span class="p_add">+	 * before the PTE is cleared.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	barrier();</span>
<span class="p_add">+	mm-&gt;tlb_flush_batched = true;</span>
<span class="p_add">+</span>
 	/*
 	 * If the PTE was dirty then it&#39;s best to assume it&#39;s writable. The
 	 * caller must use try_to_unmap_flush_dirty() or try_to_unmap_flush()
<span class="p_chunk">@@ -675,6 +682,35 @@</span> <span class="p_context"> static bool should_defer_flush(struct mm_struct *mm, enum ttu_flags flags)</span>
 
 	return should_defer;
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Reclaim unmaps pages under the PTL but do not flush the TLB prior to</span>
<span class="p_add">+ * releasing the PTL if TLB flushes are batched. It&#39;s possible for a parallel</span>
<span class="p_add">+ * operation such as mprotect or munmap to race between reclaim unmapping</span>
<span class="p_add">+ * the page and flushing the page. If this race occurs, it potentially allows</span>
<span class="p_add">+ * access to data via a stale TLB entry. Tracking all mm&#39;s that have TLB</span>
<span class="p_add">+ * batching in flight would be expensive during reclaim so instead track</span>
<span class="p_add">+ * whether TLB batching occurred in the past and if so then do a flush here</span>
<span class="p_add">+ * if required. This will cost one additional flush per reclaim cycle paid</span>
<span class="p_add">+ * by the first operation at risk such as mprotect and mumap.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This must be called under the PTL so that an access to tlb_flush_batched</span>
<span class="p_add">+ * that is potentially a &quot;reclaim vs mprotect/munmap/etc&quot; race will synchronise</span>
<span class="p_add">+ * via the PTL.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void flush_tlb_batched_pending(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (mm-&gt;tlb_flush_batched) {</span>
<span class="p_add">+		flush_tlb_mm(mm);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do not allow the compiler to re-order the clearing of</span>
<span class="p_add">+		 * tlb_flush_batched before the tlb is flushed.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		barrier();</span>
<span class="p_add">+		mm-&gt;tlb_flush_batched = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 #else
 static void set_tlb_ubc_flush_pending(struct mm_struct *mm,
 		struct page *page, bool writable)
<span class="p_header">diff --git a/net/core/dev_ioctl.c b/net/core/dev_ioctl.c</span>
<span class="p_header">index b94b1d293506..151e047ce072 100644</span>
<span class="p_header">--- a/net/core/dev_ioctl.c</span>
<span class="p_header">+++ b/net/core/dev_ioctl.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"> static int dev_ifname(struct net *net, struct ifreq __user *arg)</span>
 
 	if (copy_from_user(&amp;ifr, arg, sizeof(struct ifreq)))
 		return -EFAULT;
<span class="p_add">+	ifr.ifr_name[IFNAMSIZ-1] = 0;</span>
 
 	error = netdev_get_name(net, ifr.ifr_name, ifr.ifr_ifindex);
 	if (error)
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 2ec5324a7ff7..5b3d611d8b5f 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1742,7 +1742,8 @@</span> <span class="p_context"> static int do_setlink(const struct sk_buff *skb,</span>
 		struct sockaddr *sa;
 		int len;
 
<span class="p_del">-		len = sizeof(sa_family_t) + dev-&gt;addr_len;</span>
<span class="p_add">+		len = sizeof(sa_family_t) + max_t(size_t, dev-&gt;addr_len,</span>
<span class="p_add">+						  sizeof(*sa));</span>
 		sa = kmalloc(len, GFP_KERNEL);
 		if (!sa) {
 			err = -ENOMEM;
<span class="p_header">diff --git a/net/dccp/feat.c b/net/dccp/feat.c</span>
<span class="p_header">index 1704948e6a12..f227f002c73d 100644</span>
<span class="p_header">--- a/net/dccp/feat.c</span>
<span class="p_header">+++ b/net/dccp/feat.c</span>
<span class="p_chunk">@@ -1471,9 +1471,12 @@</span> <span class="p_context"> int dccp_feat_init(struct sock *sk)</span>
 	 * singleton values (which always leads to failure).
 	 * These settings can still (later) be overridden via sockopts.
 	 */
<span class="p_del">-	if (ccid_get_builtin_ccids(&amp;tx.val, &amp;tx.len) ||</span>
<span class="p_del">-	    ccid_get_builtin_ccids(&amp;rx.val, &amp;rx.len))</span>
<span class="p_add">+	if (ccid_get_builtin_ccids(&amp;tx.val, &amp;tx.len))</span>
 		return -ENOBUFS;
<span class="p_add">+	if (ccid_get_builtin_ccids(&amp;rx.val, &amp;rx.len)) {</span>
<span class="p_add">+		kfree(tx.val);</span>
<span class="p_add">+		return -ENOBUFS;</span>
<span class="p_add">+	}</span>
 
 	if (!dccp_feat_prefer(sysctl_dccp_tx_ccid, tx.val, tx.len) ||
 	    !dccp_feat_prefer(sysctl_dccp_rx_ccid, rx.val, rx.len))
<span class="p_header">diff --git a/net/dccp/ipv4.c b/net/dccp/ipv4.c</span>
<span class="p_header">index 6467bf392e1b..e217f17997a4 100644</span>
<span class="p_header">--- a/net/dccp/ipv4.c</span>
<span class="p_header">+++ b/net/dccp/ipv4.c</span>
<span class="p_chunk">@@ -635,6 +635,7 @@</span> <span class="p_context"> int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb)</span>
 		goto drop_and_free;
 
 	inet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);
<span class="p_add">+	reqsk_put(req);</span>
 	return 0;
 
 drop_and_free:
<span class="p_header">diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c</span>
<span class="p_header">index 3470ad1843bb..09a9ab65f4e1 100644</span>
<span class="p_header">--- a/net/dccp/ipv6.c</span>
<span class="p_header">+++ b/net/dccp/ipv6.c</span>
<span class="p_chunk">@@ -376,6 +376,7 @@</span> <span class="p_context"> static int dccp_v6_conn_request(struct sock *sk, struct sk_buff *skb)</span>
 		goto drop_and_free;
 
 	inet_csk_reqsk_queue_hash_add(sk, req, DCCP_TIMEOUT_INIT);
<span class="p_add">+	reqsk_put(req);</span>
 	return 0;
 
 drop_and_free:
<span class="p_header">diff --git a/net/ipv4/fib_frontend.c b/net/ipv4/fib_frontend.c</span>
<span class="p_header">index 66dcb529fd9c..0cb240c749bf 100644</span>
<span class="p_header">--- a/net/ipv4/fib_frontend.c</span>
<span class="p_header">+++ b/net/ipv4/fib_frontend.c</span>
<span class="p_chunk">@@ -1319,13 +1319,14 @@</span> <span class="p_context"> static struct pernet_operations fib_net_ops = {</span>
 
 void __init ip_fib_init(void)
 {
<span class="p_del">-	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);</span>
<span class="p_del">-	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);</span>
<span class="p_del">-	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);</span>
<span class="p_add">+	fib_trie_init();</span>
 
 	register_pernet_subsys(&amp;fib_net_ops);
<span class="p_add">+</span>
 	register_netdevice_notifier(&amp;fib_netdev_notifier);
 	register_inetaddr_notifier(&amp;fib_inetaddr_notifier);
 
<span class="p_del">-	fib_trie_init();</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_NEWROUTE, inet_rtm_newroute, NULL, NULL);</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_DELROUTE, inet_rtm_delroute, NULL, NULL);</span>
<span class="p_add">+	rtnl_register(PF_INET, RTM_GETROUTE, NULL, inet_dump_fib, NULL);</span>
 }
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index 2b7283303650..5d58a6703a43 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -922,7 +922,8 @@</span> <span class="p_context"> static int __ip_append_data(struct sock *sk,</span>
 		csummode = CHECKSUM_PARTIAL;
 
 	cork-&gt;length += length;
<span class="p_del">-	if (((length &gt; mtu) || (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;</span>
<span class="p_add">+	if ((((length + (skb ? skb-&gt;len : fragheaderlen)) &gt; mtu) ||</span>
<span class="p_add">+	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;</span>
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len &amp;&amp;
 	    (sk-&gt;sk_type == SOCK_DGRAM) &amp;&amp; !sk-&gt;sk_no_check_tx) {
<span class="p_header">diff --git a/net/ipv4/syncookies.c b/net/ipv4/syncookies.c</span>
<span class="p_header">index 4cbe9f0a4281..731b91409625 100644</span>
<span class="p_header">--- a/net/ipv4/syncookies.c</span>
<span class="p_header">+++ b/net/ipv4/syncookies.c</span>
<span class="p_chunk">@@ -337,6 +337,7 @@</span> <span class="p_context"> struct sock *cookie_v4_check(struct sock *sk, struct sk_buff *skb)</span>
 	treq = tcp_rsk(req);
 	treq-&gt;rcv_isn		= ntohl(th-&gt;seq) - 1;
 	treq-&gt;snt_isn		= cookie;
<span class="p_add">+	treq-&gt;txhash		= net_tx_rndhash();</span>
 	req-&gt;mss		= mss;
 	ireq-&gt;ir_num		= ntohs(th-&gt;dest);
 	ireq-&gt;ir_rmt_port	= th-&gt;source;
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 150b4923fb72..0de3245ea42f 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -647,8 +647,6 @@</span> <span class="p_context"> int ip6_fragment(struct net *net, struct sock *sk, struct sk_buff *skb,</span>
 		*prevhdr = NEXTHDR_FRAGMENT;
 		tmp_hdr = kmemdup(skb_network_header(skb), hlen, GFP_ATOMIC);
 		if (!tmp_hdr) {
<span class="p_del">-			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),</span>
<span class="p_del">-				      IPSTATS_MIB_FRAGFAILS);</span>
 			err = -ENOMEM;
 			goto fail;
 		}
<span class="p_chunk">@@ -767,8 +765,6 @@</span> <span class="p_context"> slow_path:</span>
 		frag = alloc_skb(len + hlen + sizeof(struct frag_hdr) +
 				 hroom + troom, GFP_ATOMIC);
 		if (!frag) {
<span class="p_del">-			IP6_INC_STATS(net, ip6_dst_idev(skb_dst(skb)),</span>
<span class="p_del">-				      IPSTATS_MIB_FRAGFAILS);</span>
 			err = -ENOMEM;
 			goto fail;
 		}
<span class="p_chunk">@@ -1361,7 +1357,7 @@</span> <span class="p_context"> emsgsize:</span>
 	 */
 
 	cork-&gt;length += length;
<span class="p_del">-	if ((((length + fragheaderlen) &gt; mtu) ||</span>
<span class="p_add">+	if ((((length + (skb ? skb-&gt;len : headersize)) &gt; mtu) ||</span>
 	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp;
<span class="p_header">diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c</span>
<span class="p_header">index 8b56c5240429..f9f02581c4ca 100644</span>
<span class="p_header">--- a/net/ipv6/output_core.c</span>
<span class="p_header">+++ b/net/ipv6/output_core.c</span>
<span class="p_chunk">@@ -78,7 +78,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(ipv6_select_ident);</span>
 
 int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
<span class="p_del">-	u16 offset = sizeof(struct ipv6hdr);</span>
<span class="p_add">+	unsigned int offset = sizeof(struct ipv6hdr);</span>
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 	while (offset &lt;= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
<span class="p_add">+		unsigned int len;</span>
 
 		switch (**nexthdr) {
 
<span class="p_chunk">@@ -111,7 +112,10 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
<span class="p_del">-		offset += ipv6_optlen(exthdr);</span>
<span class="p_add">+		len = ipv6_optlen(exthdr);</span>
<span class="p_add">+		if (len + offset &gt;= IPV6_MAXPLEN)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		offset += len;</span>
 		*nexthdr = &amp;exthdr-&gt;nexthdr;
 	}
 
<span class="p_header">diff --git a/net/ipv6/syncookies.c b/net/ipv6/syncookies.c</span>
<span class="p_header">index eaf7ac496d50..aee87282d352 100644</span>
<span class="p_header">--- a/net/ipv6/syncookies.c</span>
<span class="p_header">+++ b/net/ipv6/syncookies.c</span>
<span class="p_chunk">@@ -210,6 +210,7 @@</span> <span class="p_context"> struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)</span>
 	treq-&gt;snt_synack.v64	= 0;
 	treq-&gt;rcv_isn = ntohl(th-&gt;seq) - 1;
 	treq-&gt;snt_isn = cookie;
<span class="p_add">+	treq-&gt;txhash = net_tx_rndhash();</span>
 
 	/*
 	 * We need to lookup the dst_entry to get the correct window size.
<span class="p_header">diff --git a/net/openvswitch/conntrack.c b/net/openvswitch/conntrack.c</span>
<span class="p_header">index ad58d2a6284e..6a2507f24b0f 100644</span>
<span class="p_header">--- a/net/openvswitch/conntrack.c</span>
<span class="p_header">+++ b/net/openvswitch/conntrack.c</span>
<span class="p_chunk">@@ -577,8 +577,8 @@</span> <span class="p_context"> static int parse_ct(const struct nlattr *attr, struct ovs_conntrack_info *info,</span>
 
 	nla_for_each_nested(a, attr, rem) {
 		int type = nla_type(a);
<span class="p_del">-		int maxlen = ovs_ct_attr_lens[type].maxlen;</span>
<span class="p_del">-		int minlen = ovs_ct_attr_lens[type].minlen;</span>
<span class="p_add">+		int maxlen;</span>
<span class="p_add">+		int minlen;</span>
 
 		if (type &gt; OVS_CT_ATTR_MAX) {
 			OVS_NLERR(log,
<span class="p_chunk">@@ -586,6 +586,9 @@</span> <span class="p_context"> static int parse_ct(const struct nlattr *attr, struct ovs_conntrack_info *info,</span>
 				  type, OVS_CT_ATTR_MAX);
 			return -EINVAL;
 		}
<span class="p_add">+</span>
<span class="p_add">+		maxlen = ovs_ct_attr_lens[type].maxlen;</span>
<span class="p_add">+		minlen = ovs_ct_attr_lens[type].minlen;</span>
 		if (nla_len(a) &lt; minlen || nla_len(a) &gt; maxlen) {
 			OVS_NLERR(log,
 				  &quot;Conntrack attr type has unexpected length (type=%d, length=%d, expected=%d)&quot;,
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index f8d6a0ca9c03..061771ca2582 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -4225,7 +4225,7 @@</span> <span class="p_context"> static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,</span>
 		register_prot_hook(sk);
 	}
 	spin_unlock(&amp;po-&gt;bind_lock);
<span class="p_del">-	if (closing &amp;&amp; (po-&gt;tp_version &gt; TPACKET_V2)) {</span>
<span class="p_add">+	if (pg_vec &amp;&amp; (po-&gt;tp_version &gt; TPACKET_V2)) {</span>
 		/* Because we don&#39;t support block-based V3 on tx-ring */
 		if (!tx_ring)
 			prb_shutdown_retire_blk_timer(po, rb_queue);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 46a34039ecdc..5cab24f52825 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -2233,6 +2233,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1043, 0x8691, &quot;ASUS ROG Ranger VIII&quot;, ALC882_FIXUP_GPIO3),
 	SND_PCI_QUIRK(0x104d, 0x9047, &quot;Sony Vaio TT&quot;, ALC889_FIXUP_VAIO_TT),
 	SND_PCI_QUIRK(0x104d, 0x905a, &quot;Sony Vaio Z&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
<span class="p_add">+	SND_PCI_QUIRK(0x104d, 0x9060, &quot;Sony Vaio VPCL14M1R&quot;, ALC882_FIXUP_NO_PRIMARY_HP),</span>
 	SND_PCI_QUIRK(0x104d, 0x9043, &quot;Sony Vaio VGC-LN51JGB&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 	SND_PCI_QUIRK(0x104d, 0x9044, &quot;Sony VAIO AiO&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 
<span class="p_header">diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c</span>
<span class="p_header">index a1e605bbc465..977066ba1769 100644</span>
<span class="p_header">--- a/sound/soc/soc-pcm.c</span>
<span class="p_header">+++ b/sound/soc/soc-pcm.c</span>
<span class="p_chunk">@@ -181,6 +181,10 @@</span> <span class="p_context"> int dpcm_dapm_stream_event(struct snd_soc_pcm_runtime *fe, int dir,</span>
 		dev_dbg(be-&gt;dev, &quot;ASoC: BE %s event %d dir %d\n&quot;,
 				be-&gt;dai_link-&gt;name, event, dir);
 
<span class="p_add">+		if ((event == SND_SOC_DAPM_STREAM_STOP) &amp;&amp;</span>
<span class="p_add">+		    (be-&gt;dpcm[dir].users &gt;= 1))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		snd_soc_dapm_stream_event(be, dir, event);
 	}
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



