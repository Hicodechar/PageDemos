
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.3.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.3.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 19, 2016, 11:02 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160219230213.GB30189@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8364931/mbox/"
   >mbox</a>
|
   <a href="/patch/8364931/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8364931/">/patch/8364931/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 0157B9F2F0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 19 Feb 2016 23:03:14 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 76D8D204DE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 19 Feb 2016 23:03:01 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 9D044204A0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 19 Feb 2016 23:02:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1428797AbcBSXCe (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 19 Feb 2016 18:02:34 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:55596 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1428780AbcBSXCP (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 19 Feb 2016 18:02:15 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 0658CF7F;
	Fri, 19 Feb 2016 23:02:14 +0000 (UTC)
Date: Fri, 19 Feb 2016 15:02:13 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.3.6
Message-ID: &lt;20160219230213.GB30189@kroah.com&gt;
References: &lt;20160219230207.GA30189@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160219230207.GA30189@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Feb. 19, 2016, 11:02 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index efc7a766c470..95568cb1f5c6 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 3
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index 9317974c9b8e..326564386cfa 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -301,6 +301,7 @@</span> <span class="p_context"> static void create_mapping_late(phys_addr_t phys, unsigned long virt,</span>
 }
 
 #ifdef CONFIG_DEBUG_RODATA
<span class="p_add">+#define SWAPPER_BLOCK_SIZE	(PAGE_SHIFT == 12 ? SECTION_SIZE : PAGE_SIZE)</span>
 static void __init __map_memblock(phys_addr_t start, phys_addr_t end)
 {
 	/*
<span class="p_chunk">@@ -308,8 +309,8 @@</span> <span class="p_context"> static void __init __map_memblock(phys_addr_t start, phys_addr_t end)</span>
 	 * for now. This will get more fine grained later once all memory
 	 * is mapped
 	 */
<span class="p_del">-	unsigned long kernel_x_start = round_down(__pa(_stext), SECTION_SIZE);</span>
<span class="p_del">-	unsigned long kernel_x_end = round_up(__pa(__init_end), SECTION_SIZE);</span>
<span class="p_add">+	unsigned long kernel_x_start = round_down(__pa(_stext), SWAPPER_BLOCK_SIZE);</span>
<span class="p_add">+	unsigned long kernel_x_end = round_up(__pa(__init_end), SWAPPER_BLOCK_SIZE);</span>
 
 	if (end &lt; kernel_x_start) {
 		create_mapping(start, __phys_to_virt(start),
<span class="p_chunk">@@ -397,18 +398,18 @@</span> <span class="p_context"> void __init fixup_executable(void)</span>
 {
 #ifdef CONFIG_DEBUG_RODATA
 	/* now that we are actually fully mapped, make the start/end more fine grained */
<span class="p_del">-	if (!IS_ALIGNED((unsigned long)_stext, SECTION_SIZE)) {</span>
<span class="p_add">+	if (!IS_ALIGNED((unsigned long)_stext, SWAPPER_BLOCK_SIZE)) {</span>
 		unsigned long aligned_start = round_down(__pa(_stext),
<span class="p_del">-							SECTION_SIZE);</span>
<span class="p_add">+							 SWAPPER_BLOCK_SIZE);</span>
 
 		create_mapping(aligned_start, __phys_to_virt(aligned_start),
 				__pa(_stext) - aligned_start,
 				PAGE_KERNEL);
 	}
 
<span class="p_del">-	if (!IS_ALIGNED((unsigned long)__init_end, SECTION_SIZE)) {</span>
<span class="p_add">+	if (!IS_ALIGNED((unsigned long)__init_end, SWAPPER_BLOCK_SIZE)) {</span>
 		unsigned long aligned_end = round_up(__pa(__init_end),
<span class="p_del">-							SECTION_SIZE);</span>
<span class="p_add">+							  SWAPPER_BLOCK_SIZE);</span>
 		create_mapping(__pa(__init_end), (unsigned long)__init_end,
 				aligned_end - __pa(__init_end),
 				PAGE_KERNEL);
<span class="p_header">diff --git a/arch/parisc/include/asm/compat.h b/arch/parisc/include/asm/compat.h</span>
<span class="p_header">index 94710cfc1ce8..0448a2c8eafb 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/compat.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/compat.h</span>
<span class="p_chunk">@@ -206,10 +206,10 @@</span> <span class="p_context"> struct compat_ipc64_perm {</span>
 
 struct compat_semid64_ds {
 	struct compat_ipc64_perm sem_perm;
<span class="p_del">-	compat_time_t sem_otime;</span>
 	unsigned int __unused1;
<span class="p_del">-	compat_time_t sem_ctime;</span>
<span class="p_add">+	compat_time_t sem_otime;</span>
 	unsigned int __unused2;
<span class="p_add">+	compat_time_t sem_ctime;</span>
 	compat_ulong_t sem_nsems;
 	compat_ulong_t __unused3;
 	compat_ulong_t __unused4;
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/ipcbuf.h b/arch/parisc/include/uapi/asm/ipcbuf.h</span>
<span class="p_header">index bd956c425785..790c4119f647 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/ipcbuf.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/ipcbuf.h</span>
<span class="p_chunk">@@ -1,6 +1,9 @@</span> <span class="p_context"></span>
 #ifndef __PARISC_IPCBUF_H__
 #define __PARISC_IPCBUF_H__
 
<span class="p_add">+#include &lt;asm/bitsperlong.h&gt;</span>
<span class="p_add">+#include &lt;linux/posix_types.h&gt;</span>
<span class="p_add">+</span>
 /*
  * The ipc64_perm structure for PA-RISC is almost identical to
  * kern_ipc_perm as we have always had 32-bit UIDs and GIDs in the kernel.
<span class="p_chunk">@@ -10,16 +13,18 @@</span> <span class="p_context"></span>
 
 struct ipc64_perm
 {
<span class="p_del">-	key_t           key;</span>
<span class="p_del">-	uid_t           uid;</span>
<span class="p_del">-	gid_t           gid;</span>
<span class="p_del">-	uid_t           cuid;</span>
<span class="p_del">-	gid_t           cgid;</span>
<span class="p_add">+	__kernel_key_t		key;</span>
<span class="p_add">+	__kernel_uid_t		uid;</span>
<span class="p_add">+	__kernel_gid_t		gid;</span>
<span class="p_add">+	__kernel_uid_t		cuid;</span>
<span class="p_add">+	__kernel_gid_t		cgid;</span>
<span class="p_add">+#if __BITS_PER_LONG != 64</span>
 	unsigned short int	__pad1;
<span class="p_del">-	mode_t          mode;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	__kernel_mode_t		mode;</span>
 	unsigned short int	__pad2;
 	unsigned short int	seq;
<span class="p_del">-	unsigned int	__pad3;</span>
<span class="p_add">+	unsigned int		__pad3;</span>
 	unsigned long long int __unused1;
 	unsigned long long int __unused2;
 };
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/mman.h b/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_header">index 294d251ca7b2..2ae13ce592e8 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/mman.h</span>
<span class="p_chunk">@@ -46,16 +46,6 @@</span> <span class="p_context"></span>
 #define MADV_DONTFORK	10		/* don&#39;t inherit across fork */
 #define MADV_DOFORK	11		/* do inherit across fork */
 
<span class="p_del">-/* The range 12-64 is reserved for page size specification. */</span>
<span class="p_del">-#define MADV_4K_PAGES   12              /* Use 4K pages  */</span>
<span class="p_del">-#define MADV_16K_PAGES  14              /* Use 16K pages */</span>
<span class="p_del">-#define MADV_64K_PAGES  16              /* Use 64K pages */</span>
<span class="p_del">-#define MADV_256K_PAGES 18              /* Use 256K pages */</span>
<span class="p_del">-#define MADV_1M_PAGES   20              /* Use 1 Megabyte pages */</span>
<span class="p_del">-#define MADV_4M_PAGES   22              /* Use 4 Megabyte pages */</span>
<span class="p_del">-#define MADV_16M_PAGES  24              /* Use 16 Megabyte pages */</span>
<span class="p_del">-#define MADV_64M_PAGES  26              /* Use 64 Megabyte pages */</span>
<span class="p_del">-</span>
 #define MADV_MERGEABLE   65		/* KSM may merge identical pages */
 #define MADV_UNMERGEABLE 66		/* KSM may not merge identical pages */
 
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/msgbuf.h b/arch/parisc/include/uapi/asm/msgbuf.h</span>
<span class="p_header">index 342138983914..2e83ac758e19 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/msgbuf.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/msgbuf.h</span>
<span class="p_chunk">@@ -27,13 +27,13 @@</span> <span class="p_context"> struct msqid64_ds {</span>
 	unsigned int   __pad3;
 #endif
 	__kernel_time_t msg_ctime;	/* last change time */
<span class="p_del">-	unsigned int  msg_cbytes;	/* current number of bytes on queue */</span>
<span class="p_del">-	unsigned int  msg_qnum;	/* number of messages in queue */</span>
<span class="p_del">-	unsigned int  msg_qbytes;	/* max number of bytes on queue */</span>
<span class="p_add">+	unsigned long msg_cbytes;	/* current number of bytes on queue */</span>
<span class="p_add">+	unsigned long msg_qnum;		/* number of messages in queue */</span>
<span class="p_add">+	unsigned long msg_qbytes;	/* max number of bytes on queue */</span>
 	__kernel_pid_t msg_lspid;	/* pid of last msgsnd */
 	__kernel_pid_t msg_lrpid;	/* last receive pid */
<span class="p_del">-	unsigned int  __unused1;</span>
<span class="p_del">-	unsigned int  __unused2;</span>
<span class="p_add">+	unsigned long __unused1;</span>
<span class="p_add">+	unsigned long __unused2;</span>
 };
 
 #endif /* _PARISC_MSGBUF_H */
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/posix_types.h b/arch/parisc/include/uapi/asm/posix_types.h</span>
<span class="p_header">index b9344256f76b..f3b5f70b9a5f 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/posix_types.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/posix_types.h</span>
<span class="p_chunk">@@ -7,8 +7,10 @@</span> <span class="p_context"></span>
  * assume GCC is being used.
  */
 
<span class="p_add">+#ifndef __LP64__</span>
 typedef unsigned short		__kernel_mode_t;
 #define __kernel_mode_t __kernel_mode_t
<span class="p_add">+#endif</span>
 
 typedef unsigned short		__kernel_ipc_pid_t;
 #define __kernel_ipc_pid_t __kernel_ipc_pid_t
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/sembuf.h b/arch/parisc/include/uapi/asm/sembuf.h</span>
<span class="p_header">index f01d89e30d73..c20971bf520f 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/sembuf.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/sembuf.h</span>
<span class="p_chunk">@@ -23,9 +23,9 @@</span> <span class="p_context"> struct semid64_ds {</span>
 	unsigned int	__pad2;
 #endif
 	__kernel_time_t	sem_ctime;		/* last change time */
<span class="p_del">-	unsigned int	sem_nsems;		/* no. of semaphores in array */</span>
<span class="p_del">-	unsigned int	__unused1;</span>
<span class="p_del">-	unsigned int	__unused2;</span>
<span class="p_add">+	unsigned long 	sem_nsems;		/* no. of semaphores in array */</span>
<span class="p_add">+	unsigned long	__unused1;</span>
<span class="p_add">+	unsigned long	__unused2;</span>
 };
 
 #endif /* _PARISC_SEMBUF_H */
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/shmbuf.h b/arch/parisc/include/uapi/asm/shmbuf.h</span>
<span class="p_header">index 8496c38560c6..750e13e77991 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/shmbuf.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/shmbuf.h</span>
<span class="p_chunk">@@ -30,12 +30,12 @@</span> <span class="p_context"> struct shmid64_ds {</span>
 #if __BITS_PER_LONG != 64
 	unsigned int		__pad4;
 #endif
<span class="p_del">-	size_t			shm_segsz;	/* size of segment (bytes) */</span>
<span class="p_add">+	__kernel_size_t		shm_segsz;	/* size of segment (bytes) */</span>
 	__kernel_pid_t		shm_cpid;	/* pid of creator */
 	__kernel_pid_t		shm_lpid;	/* pid of last operator */
<span class="p_del">-	unsigned int		shm_nattch;	/* no. of current attaches */</span>
<span class="p_del">-	unsigned int		__unused1;</span>
<span class="p_del">-	unsigned int		__unused2;</span>
<span class="p_add">+	unsigned long		shm_nattch;	/* no. of current attaches */</span>
<span class="p_add">+	unsigned long		__unused1;</span>
<span class="p_add">+	unsigned long		__unused2;</span>
 };
 
 struct shminfo64 {
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/siginfo.h b/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_header">index d7034728f377..1c75565d984b 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_chunk">@@ -1,6 +1,10 @@</span> <span class="p_context"></span>
 #ifndef _PARISC_SIGINFO_H
 #define _PARISC_SIGINFO_H
 
<span class="p_add">+#if defined(__LP64__)</span>
<span class="p_add">+#define __ARCH_SI_PREAMBLE_SIZE   (4 * sizeof(int))</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #include &lt;asm-generic/siginfo.h&gt;
 
 #undef NSIGTRAP
<span class="p_header">diff --git a/arch/parisc/kernel/signal.c b/arch/parisc/kernel/signal.c</span>
<span class="p_header">index dc1ea796fd60..2264f68f3c2f 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/signal.c</span>
<span class="p_chunk">@@ -435,6 +435,55 @@</span> <span class="p_context"> handle_signal(struct ksignal *ksig, struct pt_regs *regs, int in_syscall)</span>
 		regs-&gt;gr[28]);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Check how the syscall number gets loaded into %r20 within</span>
<span class="p_add">+ * the delay branch in userspace and adjust as needed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void check_syscallno_in_delay_branch(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 opcode, source_reg;</span>
<span class="p_add">+	u32 __user *uaddr;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Usually we don&#39;t have to restore %r20 (the system call number)</span>
<span class="p_add">+	 * because it gets loaded in the delay slot of the branch external</span>
<span class="p_add">+	 * instruction via the ldi instruction.</span>
<span class="p_add">+	 * In some cases a register-to-register copy instruction might have</span>
<span class="p_add">+	 * been used instead, in which case we need to copy the syscall</span>
<span class="p_add">+	 * number into the source register before returning to userspace.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* A syscall is just a branch, so all we have to do is fiddle the</span>
<span class="p_add">+	 * return pointer so that the ble instruction gets executed again.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;gr[31] -= 8; /* delayed branching */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get assembler opcode of code in delay branch */</span>
<span class="p_add">+	uaddr = (unsigned int *) ((regs-&gt;gr[31] &amp; ~3) + 4);</span>
<span class="p_add">+	err = get_user(opcode, uaddr);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;ldi int,%r20&quot; */</span>
<span class="p_add">+	if ((opcode &amp; 0xffff0000) == 0x34140000)</span>
<span class="p_add">+		return;	/* everything ok, just return */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;nop&quot; */</span>
<span class="p_add">+	if (opcode == INSN_NOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if delay branch uses &quot;copy %rX,%r20&quot; */</span>
<span class="p_add">+	if ((opcode &amp; 0xffe0ffff) == 0x08000254) {</span>
<span class="p_add">+		source_reg = (opcode &gt;&gt; 16) &amp; 31;</span>
<span class="p_add">+		regs-&gt;gr[source_reg] = regs-&gt;gr[20];</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_warn(&quot;syscall restart: %s (pid %d): unexpected opcode 0x%08x\n&quot;,</span>
<span class="p_add">+		current-&gt;comm, task_pid_nr(current), opcode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void
 syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)
 {
<span class="p_chunk">@@ -457,10 +506,7 @@</span> <span class="p_context"> syscall_restart(struct pt_regs *regs, struct k_sigaction *ka)</span>
 		}
 		/* fallthrough */
 	case -ERESTARTNOINTR:
<span class="p_del">-		/* A syscall is just a branch, so all</span>
<span class="p_del">-		 * we have to do is fiddle the return pointer.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		regs-&gt;gr[31] -= 8; /* delayed branching */</span>
<span class="p_add">+		check_syscallno_in_delay_branch(regs);</span>
 		break;
 	}
 }
<span class="p_chunk">@@ -510,15 +556,9 @@</span> <span class="p_context"> insert_restart_trampoline(struct pt_regs *regs)</span>
 	}
 	case -ERESTARTNOHAND:
 	case -ERESTARTSYS:
<span class="p_del">-	case -ERESTARTNOINTR: {</span>
<span class="p_del">-		/* Hooray for delayed branching.  We don&#39;t</span>
<span class="p_del">-		 * have to restore %r20 (the system call</span>
<span class="p_del">-		 * number) because it gets loaded in the delay</span>
<span class="p_del">-		 * slot of the branch external instruction.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		regs-&gt;gr[31] -= 8;</span>
<span class="p_add">+	case -ERESTARTNOINTR:</span>
<span class="p_add">+		check_syscallno_in_delay_branch(regs);</span>
 		return;
<span class="p_del">-	}</span>
 	default:
 		break;
 	}
<span class="p_header">diff --git a/arch/parisc/mm/init.c b/arch/parisc/mm/init.c</span>
<span class="p_header">index c229427fa546..c5fec4890fdf 100644</span>
<span class="p_header">--- a/arch/parisc/mm/init.c</span>
<span class="p_header">+++ b/arch/parisc/mm/init.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/unistd.h&gt;
 #include &lt;linux/nodemask.h&gt;	/* for node_online_map */
 #include &lt;linux/pagemap.h&gt;	/* for release_pages and page_cache_release */
<span class="p_add">+#include &lt;linux/compat.h&gt;</span>
 
 #include &lt;asm/pgalloc.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_chunk">@@ -30,6 +31,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/pdc_chassis.h&gt;
 #include &lt;asm/mmzone.h&gt;
 #include &lt;asm/sections.h&gt;
<span class="p_add">+#include &lt;asm/msgbuf.h&gt;</span>
 
 extern int  data_start;
 extern void parisc_kernel_start(void);	/* Kernel entry point in head.S */
<span class="p_chunk">@@ -590,6 +592,20 @@</span> <span class="p_context"> unsigned long pcxl_dma_start __read_mostly;</span>
 
 void __init mem_init(void)
 {
<span class="p_add">+	/* Do sanity checks on IPC (compat) structures */</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct ipc64_perm) != 48);</span>
<span class="p_add">+#ifndef CONFIG_64BIT</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct semid64_ds) != 80);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct msqid64_ds) != 104);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct shmid64_ds) != 104);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct compat_ipc64_perm) != sizeof(struct ipc64_perm));</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct compat_semid64_ds) != 80);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct compat_msqid64_ds) != 104);</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct compat_shmid64_ds) != 104);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/* Do sanity checks on page table constants */
 	BUILD_BUG_ON(PTE_ENTRY_SIZE != sizeof(pte_t));
 	BUILD_BUG_ON(PMD_ENTRY_SIZE != sizeof(pmd_t));
<span class="p_header">diff --git a/arch/sh/include/uapi/asm/unistd_64.h b/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_header">index e6820c86e8c7..47ebd5b5ed55 100644</span>
<span class="p_header">--- a/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_header">+++ b/arch/sh/include/uapi/asm/unistd_64.h</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"></span>
 #define __NR_fsetxattr		256
 #define __NR_getxattr		257
 #define __NR_lgetxattr		258
<span class="p_del">-#define __NR_fgetxattr		269</span>
<span class="p_add">+#define __NR_fgetxattr		259</span>
 #define __NR_listxattr		260
 #define __NR_llistxattr		261
 #define __NR_flistxattr		262
<span class="p_header">diff --git a/arch/x86/crypto/chacha20-ssse3-x86_64.S b/arch/x86/crypto/chacha20-ssse3-x86_64.S</span>
<span class="p_header">index 712b13047b41..3a33124e9112 100644</span>
<span class="p_header">--- a/arch/x86/crypto/chacha20-ssse3-x86_64.S</span>
<span class="p_header">+++ b/arch/x86/crypto/chacha20-ssse3-x86_64.S</span>
<span class="p_chunk">@@ -157,7 +157,9 @@</span> <span class="p_context"> ENTRY(chacha20_4block_xor_ssse3)</span>
 	# done with the slightly better performing SSSE3 byte shuffling,
 	# 7/12-bit word rotation uses traditional shift+OR.
 
<span class="p_del">-	sub		$0x40,%rsp</span>
<span class="p_add">+	mov		%rsp,%r11</span>
<span class="p_add">+	sub		$0x80,%rsp</span>
<span class="p_add">+	and		$~63,%rsp</span>
 
 	# x0..15[0-3] = s0..3[0..3]
 	movq		0x00(%rdi),%xmm1
<span class="p_chunk">@@ -620,6 +622,6 @@</span> <span class="p_context"> ENTRY(chacha20_4block_xor_ssse3)</span>
 	pxor		%xmm1,%xmm15
 	movdqu		%xmm15,0xf0(%rsi)
 
<span class="p_del">-	add		$0x40,%rsp</span>
<span class="p_add">+	mov		%r11,%rsp</span>
 	ret
 ENDPROC(chacha20_4block_xor_ssse3)
<span class="p_header">diff --git a/arch/x86/crypto/crc32c-pcl-intel-asm_64.S b/arch/x86/crypto/crc32c-pcl-intel-asm_64.S</span>
<span class="p_header">index 225be06edc80..4fe27e074194 100644</span>
<span class="p_header">--- a/arch/x86/crypto/crc32c-pcl-intel-asm_64.S</span>
<span class="p_header">+++ b/arch/x86/crypto/crc32c-pcl-intel-asm_64.S</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> ENDPROC(crc_pcl)</span>
 	## PCLMULQDQ tables
 	## Table is 128 entries x 2 words (8 bytes) each
 	################################################################
<span class="p_del">-.section	.rotata, &quot;a&quot;, %progbits</span>
<span class="p_add">+.section	.rodata, &quot;a&quot;, %progbits</span>
 .align 8
 K_table:
 	.long 0x493c7d27, 0x00000001
<span class="p_header">diff --git a/arch/xtensa/include/asm/asmmacro.h b/arch/xtensa/include/asm/asmmacro.h</span>
<span class="p_header">index 755320f6e0bc..746dcc8b5abc 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/asmmacro.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/asmmacro.h</span>
<span class="p_chunk">@@ -35,9 +35,10 @@</span> <span class="p_context"></span>
  * __loop  as
  *	   restart loop. &#39;as&#39; register must not have been modified!
  *
<span class="p_del">- * __endla ar, at, incr</span>
<span class="p_add">+ * __endla ar, as, incr</span>
  *	   ar	start address (modified)
<span class="p_del">- *	   as	scratch register used by macro</span>
<span class="p_add">+ *	   as	scratch register used by __loops/__loopi macros or</span>
<span class="p_add">+ *		end address used by __loopt macro</span>
  *	   inc	increment
  */
 
<span class="p_chunk">@@ -97,7 +98,7 @@</span> <span class="p_context"></span>
 	.endm
 
 /*
<span class="p_del">- * loop from ar to ax</span>
<span class="p_add">+ * loop from ar to as</span>
  */
 
 	.macro	__loopt	ar, as, at, incr_log2
<span class="p_header">diff --git a/arch/xtensa/include/asm/vectors.h b/arch/xtensa/include/asm/vectors.h</span>
<span class="p_header">index a46c53f36113..986b5d0cb9e0 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/vectors.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/vectors.h</span>
<span class="p_chunk">@@ -48,6 +48,9 @@</span> <span class="p_context"></span>
   #define LOAD_MEMORY_ADDRESS		0xD0003000
 #endif
 
<span class="p_add">+#define RESET_VECTOR1_VADDR		(VIRTUAL_MEMORY_ADDRESS + \</span>
<span class="p_add">+					 XCHAL_RESET_VECTOR1_PADDR)</span>
<span class="p_add">+</span>
 #else /* !defined(CONFIG_MMU) */
   /* MMU Not being used - Virtual == Physical */
 
<span class="p_chunk">@@ -60,6 +63,8 @@</span> <span class="p_context"></span>
   /* Loaded just above possibly live vectors */
   #define LOAD_MEMORY_ADDRESS		(PLATFORM_DEFAULT_MEM_START + 0x3000)
 
<span class="p_add">+#define RESET_VECTOR1_VADDR		(XCHAL_RESET_VECTOR1_VADDR)</span>
<span class="p_add">+</span>
 #endif /* CONFIG_MMU */
 
 #define XC_VADDR(offset)		(VIRTUAL_MEMORY_ADDRESS  + offset)
<span class="p_chunk">@@ -71,10 +76,6 @@</span> <span class="p_context"></span>
 						VECBASE_RESET_VADDR)
 #define RESET_VECTOR_VADDR		XC_VADDR(RESET_VECTOR_VECOFS)
 
<span class="p_del">-#define RESET_VECTOR1_VECOFS		(XCHAL_RESET_VECTOR1_VADDR - \</span>
<span class="p_del">-						VECBASE_RESET_VADDR)</span>
<span class="p_del">-#define RESET_VECTOR1_VADDR		XC_VADDR(RESET_VECTOR1_VECOFS)</span>
<span class="p_del">-</span>
 #if defined(XCHAL_HAVE_VECBASE) &amp;&amp; XCHAL_HAVE_VECBASE
 
 #define USER_VECTOR_VADDR		XC_VADDR(XCHAL_USER_VECOFS)
<span class="p_header">diff --git a/arch/xtensa/kernel/Makefile b/arch/xtensa/kernel/Makefile</span>
<span class="p_header">index 50137bc9e150..4db730290d2d 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/Makefile</span>
<span class="p_header">+++ b/arch/xtensa/kernel/Makefile</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"> obj-$(CONFIG_SMP) += smp.o mxhead.o</span>
 obj-$(CONFIG_XTENSA_VARIANT_HAVE_PERF_EVENTS) += perf_event.o
 
 AFLAGS_head.o += -mtext-section-literals
<span class="p_add">+AFLAGS_mxhead.o += -mtext-section-literals</span>
 
 # In the Xtensa architecture, assembly generates literals which must always
 # precede the L32R instruction with a relative offset less than 256 kB.
<span class="p_header">diff --git a/arch/xtensa/kernel/entry.S b/arch/xtensa/kernel/entry.S</span>
<span class="p_header">index 504130357597..db5c1765b413 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/entry.S</span>
<span class="p_header">+++ b/arch/xtensa/kernel/entry.S</span>
<span class="p_chunk">@@ -367,8 +367,10 @@</span> <span class="p_context"> common_exception:</span>
 	s32i	a2, a1, PT_SYSCALL
 	movi	a2, 0
 	s32i	a3, a1, PT_EXCVADDR
<span class="p_add">+#if XCHAL_HAVE_LOOPS</span>
 	xsr	a2, lcount
 	s32i	a2, a1, PT_LCOUNT
<span class="p_add">+#endif</span>
 
 	/* It is now save to restore the EXC_TABLE_FIXUP variable. */
 
<span class="p_chunk">@@ -429,11 +431,12 @@</span> <span class="p_context"> common_exception:</span>
 	rsync				# PS.WOE =&gt; rsync =&gt; overflow
 
 	/* Save lbeg, lend */
<span class="p_del">-</span>
<span class="p_add">+#if XCHAL_HAVE_LOOPS</span>
 	rsr	a4, lbeg
 	rsr	a3, lend
 	s32i	a4, a1, PT_LBEG
 	s32i	a3, a1, PT_LEND
<span class="p_add">+#endif</span>
 
 	/* Save SCOMPARE1 */
 
<span class="p_chunk">@@ -724,13 +727,14 @@</span> <span class="p_context"> common_exception_exit:</span>
 	wsr	a3, sar
 
 	/* Restore LBEG, LEND, LCOUNT */
<span class="p_del">-</span>
<span class="p_add">+#if XCHAL_HAVE_LOOPS</span>
 	l32i	a2, a1, PT_LBEG
 	l32i	a3, a1, PT_LEND
 	wsr	a2, lbeg
 	l32i	a2, a1, PT_LCOUNT
 	wsr	a3, lend
 	wsr	a2, lcount
<span class="p_add">+#endif</span>
 
 	/* We control single stepping through the ICOUNTLEVEL register. */
 
<span class="p_header">diff --git a/arch/xtensa/kernel/head.S b/arch/xtensa/kernel/head.S</span>
<span class="p_header">index 15a461e2a0ed..9ed55649ac8e 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/head.S</span>
<span class="p_header">+++ b/arch/xtensa/kernel/head.S</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> ENTRY(_startup)</span>
 
 	__loopt	a2, a3, a4, 2
 	s32i	a0, a2, 0
<span class="p_del">-	__endla	a2, a4, 4</span>
<span class="p_add">+	__endla	a2, a3, 4</span>
 
 #if XCHAL_DCACHE_IS_WRITEBACK
 
<span class="p_header">diff --git a/arch/xtensa/kernel/setup.c b/arch/xtensa/kernel/setup.c</span>
<span class="p_header">index 28fc57ef5b86..4e06ec9769d1 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/setup.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/setup.c</span>
<span class="p_chunk">@@ -334,7 +334,10 @@</span> <span class="p_context"> extern char _Level5InterruptVector_text_end;</span>
 extern char _Level6InterruptVector_text_start;
 extern char _Level6InterruptVector_text_end;
 #endif
<span class="p_del">-</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+extern char _SecondaryResetVector_text_start;</span>
<span class="p_add">+extern char _SecondaryResetVector_text_end;</span>
<span class="p_add">+#endif</span>
 
 
 #ifdef CONFIG_S32C1I_SELFTEST
<span class="p_chunk">@@ -506,6 +509,10 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 		    __pa(&amp;_Level6InterruptVector_text_end), 0);
 #endif
 
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	mem_reserve(__pa(&amp;_SecondaryResetVector_text_start),</span>
<span class="p_add">+		    __pa(&amp;_SecondaryResetVector_text_end), 0);</span>
<span class="p_add">+#endif</span>
 	parse_early_param();
 	bootmem_init();
 
<span class="p_header">diff --git a/arch/xtensa/kernel/vectors.S b/arch/xtensa/kernel/vectors.S</span>
<span class="p_header">index abcdb527f18a..fc25318e75ad 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/vectors.S</span>
<span class="p_header">+++ b/arch/xtensa/kernel/vectors.S</span>
<span class="p_chunk">@@ -478,6 +478,9 @@</span> <span class="p_context"> _DoubleExceptionVector_handle_exception:</span>
 
 ENDPROC(_DoubleExceptionVector)
 
<span class="p_add">+	.end literal_prefix</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
 /*
  * Fixup handler for TLB miss in double exception handler for window owerflow.
  * We get here with windowbase set to the window that was being spilled and
<span class="p_chunk">@@ -587,7 +590,6 @@</span> <span class="p_context"> ENTRY(window_overflow_restore_a0_fixup)</span>
 
 ENDPROC(window_overflow_restore_a0_fixup)
 
<span class="p_del">-	.end literal_prefix</span>
 /*
  * Debug interrupt vector
  *
<span class="p_header">diff --git a/arch/xtensa/kernel/vmlinux.lds.S b/arch/xtensa/kernel/vmlinux.lds.S</span>
<span class="p_header">index fc1bc2ba8d5d..d66cd408be13 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/xtensa/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -166,8 +166,6 @@</span> <span class="p_context"> SECTIONS</span>
     RELOCATE_ENTRY(_DebugInterruptVector_text,
 		   .DebugInterruptVector.text);
 #if defined(CONFIG_SMP)
<span class="p_del">-    RELOCATE_ENTRY(_SecondaryResetVector_literal,</span>
<span class="p_del">-		   .SecondaryResetVector.literal);</span>
     RELOCATE_ENTRY(_SecondaryResetVector_text,
 		   .SecondaryResetVector.text);
 #endif
<span class="p_chunk">@@ -282,17 +280,11 @@</span> <span class="p_context"> SECTIONS</span>
 
 #if defined(CONFIG_SMP)
 
<span class="p_del">-  SECTION_VECTOR (_SecondaryResetVector_literal,</span>
<span class="p_del">-		  .SecondaryResetVector.literal,</span>
<span class="p_del">-		  RESET_VECTOR1_VADDR - 4,</span>
<span class="p_del">-		  SIZEOF(.DoubleExceptionVector.text),</span>
<span class="p_del">-		  .DoubleExceptionVector.text)</span>
<span class="p_del">-</span>
   SECTION_VECTOR (_SecondaryResetVector_text,
 		  .SecondaryResetVector.text,
 		  RESET_VECTOR1_VADDR,
<span class="p_del">-		  4,</span>
<span class="p_del">-		  .SecondaryResetVector.literal)</span>
<span class="p_add">+		  SIZEOF(.DoubleExceptionVector.text),</span>
<span class="p_add">+		  .DoubleExceptionVector.text)</span>
 
   . = LOADADDR(.SecondaryResetVector.text)+SIZEOF(.SecondaryResetVector.text);
 
<span class="p_header">diff --git a/arch/xtensa/lib/usercopy.S b/arch/xtensa/lib/usercopy.S</span>
<span class="p_header">index ace1892a875e..7ea4dd68893e 100644</span>
<span class="p_header">--- a/arch/xtensa/lib/usercopy.S</span>
<span class="p_header">+++ b/arch/xtensa/lib/usercopy.S</span>
<span class="p_chunk">@@ -222,8 +222,8 @@</span> <span class="p_context"> __xtensa_copy_user:</span>
 	loopnez	a7, .Loop2done
 #else /* !XCHAL_HAVE_LOOPS */
 	beqz	a7, .Loop2done
<span class="p_del">-	slli	a10, a7, 4</span>
<span class="p_del">-	add	a10, a10, a3	# a10 = end of last 16B source chunk</span>
<span class="p_add">+	slli	a12, a7, 4</span>
<span class="p_add">+	add	a12, a12, a3	# a12 = end of last 16B source chunk</span>
 #endif /* !XCHAL_HAVE_LOOPS */
 .Loop2:
 	EX(l32i, a7, a3,  4, l_fixup)
<span class="p_chunk">@@ -241,7 +241,7 @@</span> <span class="p_context"> __xtensa_copy_user:</span>
 	EX(s32i, a9, a5, 12, s_fixup)
 	addi	a5, a5, 16
 #if !XCHAL_HAVE_LOOPS
<span class="p_del">-	blt	a3, a10, .Loop2</span>
<span class="p_add">+	blt	a3, a12, .Loop2</span>
 #endif /* !XCHAL_HAVE_LOOPS */
 .Loop2done:
 	bbci.l	a4, 3, .L12
<span class="p_header">diff --git a/arch/xtensa/platforms/iss/setup.c b/arch/xtensa/platforms/iss/setup.c</span>
<span class="p_header">index da7d18240866..391820539f0a 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/iss/setup.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/iss/setup.c</span>
<span class="p_chunk">@@ -61,7 +61,9 @@</span> <span class="p_context"> void platform_restart(void)</span>
 #if XCHAL_NUM_IBREAK &gt; 0
 			     &quot;wsr	a2, ibreakenable\n\t&quot;
 #endif
<span class="p_add">+#if XCHAL_HAVE_LOOPS</span>
 			     &quot;wsr	a2, lcount\n\t&quot;
<span class="p_add">+#endif</span>
 			     &quot;movi	a2, 0x1f\n\t&quot;
 			     &quot;wsr	a2, ps\n\t&quot;
 			     &quot;isync\n\t&quot;
<span class="p_header">diff --git a/arch/xtensa/platforms/xt2000/setup.c b/arch/xtensa/platforms/xt2000/setup.c</span>
<span class="p_header">index b90555cb8089..87678961a8c8 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xt2000/setup.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xt2000/setup.c</span>
<span class="p_chunk">@@ -72,7 +72,9 @@</span> <span class="p_context"> void platform_restart(void)</span>
 #if XCHAL_NUM_IBREAK &gt; 0
 			      &quot;wsr	a2, ibreakenable\n\t&quot;
 #endif
<span class="p_add">+#if XCHAL_HAVE_LOOPS</span>
 			      &quot;wsr	a2, lcount\n\t&quot;
<span class="p_add">+#endif</span>
 			      &quot;movi	a2, 0x1f\n\t&quot;
 			      &quot;wsr	a2, ps\n\t&quot;
 			      &quot;isync\n\t&quot;
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/setup.c b/arch/xtensa/platforms/xtfpga/setup.c</span>
<span class="p_header">index b4cf70e535ab..e9f65f79cf2e 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/setup.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/setup.c</span>
<span class="p_chunk">@@ -63,7 +63,9 @@</span> <span class="p_context"> void platform_restart(void)</span>
 #if XCHAL_NUM_IBREAK &gt; 0
 			      &quot;wsr	a2, ibreakenable\n\t&quot;
 #endif
<span class="p_add">+#if XCHAL_HAVE_LOOPS</span>
 			      &quot;wsr	a2, lcount\n\t&quot;
<span class="p_add">+#endif</span>
 			      &quot;movi	a2, 0x1f\n\t&quot;
 			      &quot;wsr	a2, ps\n\t&quot;
 			      &quot;isync\n\t&quot;
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 18e92a6645e2..b128c1609347 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -1616,8 +1616,6 @@</span> <span class="p_context"> static void blk_queue_bio(struct request_queue *q, struct bio *bio)</span>
 	struct request *req;
 	unsigned int request_count = 0;
 
<span class="p_del">-	blk_queue_split(q, &amp;bio, q-&gt;bio_split);</span>
<span class="p_del">-</span>
 	/*
 	 * low level driver can indicate that it wants pages above a
 	 * certain limit bounced to low memory (ie for highmem, or even
<span class="p_chunk">@@ -1625,6 +1623,8 @@</span> <span class="p_context"> static void blk_queue_bio(struct request_queue *q, struct bio *bio)</span>
 	 */
 	blk_queue_bounce(q, &amp;bio);
 
<span class="p_add">+	blk_queue_split(q, &amp;bio, q-&gt;bio_split);</span>
<span class="p_add">+</span>
 	if (bio_integrity_enabled(bio) &amp;&amp; bio_integrity_prep(bio)) {
 		bio-&gt;bi_error = -EIO;
 		bio_endio(bio);
<span class="p_chunk">@@ -2023,7 +2023,8 @@</span> <span class="p_context"> void submit_bio(int rw, struct bio *bio)</span>
 EXPORT_SYMBOL(submit_bio);
 
 /**
<span class="p_del">- * blk_rq_check_limits - Helper function to check a request for the queue limit</span>
<span class="p_add">+ * blk_cloned_rq_check_limits - Helper function to check a cloned request</span>
<span class="p_add">+ *                              for new the queue limits</span>
  * @q:  the queue
  * @rq: the request being checked
  *
<span class="p_chunk">@@ -2034,20 +2035,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(submit_bio);</span>
  *    after it is inserted to @q, it should be checked against @q before
  *    the insertion using this generic function.
  *
<span class="p_del">- *    This function should also be useful for request stacking drivers</span>
<span class="p_del">- *    in some cases below, so export this function.</span>
  *    Request stacking drivers like request-based dm may change the queue
<span class="p_del">- *    limits while requests are in the queue (e.g. dm&#39;s table swapping).</span>
<span class="p_del">- *    Such request stacking drivers should check those requests against</span>
<span class="p_del">- *    the new queue limits again when they dispatch those requests,</span>
<span class="p_del">- *    although such checkings are also done against the old queue limits</span>
<span class="p_del">- *    when submitting requests.</span>
<span class="p_add">+ *    limits when retrying requests on other queues. Those requests need</span>
<span class="p_add">+ *    to be checked against the new queue limits again during dispatch.</span>
  */
<span class="p_del">-int blk_rq_check_limits(struct request_queue *q, struct request *rq)</span>
<span class="p_add">+static int blk_cloned_rq_check_limits(struct request_queue *q,</span>
<span class="p_add">+				      struct request *rq)</span>
 {
<span class="p_del">-	if (!rq_mergeable(rq))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	if (blk_rq_sectors(rq) &gt; blk_queue_get_max_sectors(q, rq-&gt;cmd_flags)) {
 		printk(KERN_ERR &quot;%s: over max size limit.\n&quot;, __func__);
 		return -EIO;
<span class="p_chunk">@@ -2067,7 +2061,6 @@</span> <span class="p_context"> int blk_rq_check_limits(struct request_queue *q, struct request *rq)</span>
 
 	return 0;
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(blk_rq_check_limits);</span>
 
 /**
  * blk_insert_cloned_request - Helper for stacking drivers to submit a request
<span class="p_chunk">@@ -2079,7 +2072,7 @@</span> <span class="p_context"> int blk_insert_cloned_request(struct request_queue *q, struct request *rq)</span>
 	unsigned long flags;
 	int where = ELEVATOR_INSERT_BACK;
 
<span class="p_del">-	if (blk_rq_check_limits(q, rq))</span>
<span class="p_add">+	if (blk_cloned_rq_check_limits(q, rq))</span>
 		return -EIO;
 
 	if (rq-&gt;rq_disk &amp;&amp;
<span class="p_header">diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c</span>
<span class="p_header">index b4ffc5be1a93..e5b5721809e2 100644</span>
<span class="p_header">--- a/crypto/ablkcipher.c</span>
<span class="p_header">+++ b/crypto/ablkcipher.c</span>
<span class="p_chunk">@@ -277,12 +277,12 @@</span> <span class="p_context"> static int ablkcipher_walk_first(struct ablkcipher_request *req,</span>
 	if (WARN_ON_ONCE(in_irq()))
 		return -EDEADLK;
 
<span class="p_add">+	walk-&gt;iv = req-&gt;info;</span>
 	walk-&gt;nbytes = walk-&gt;total;
 	if (unlikely(!walk-&gt;total))
 		return 0;
 
 	walk-&gt;iv_buffer = NULL;
<span class="p_del">-	walk-&gt;iv = req-&gt;info;</span>
 	if (unlikely(((unsigned long)walk-&gt;iv &amp; alignmask))) {
 		int err = ablkcipher_copy_iv(walk, tfm, alignmask);
 
<span class="p_header">diff --git a/crypto/af_alg.c b/crypto/af_alg.c</span>
<span class="p_header">index a8e7aa3e257b..f5e18c2a4852 100644</span>
<span class="p_header">--- a/crypto/af_alg.c</span>
<span class="p_header">+++ b/crypto/af_alg.c</span>
<span class="p_chunk">@@ -76,6 +76,8 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type)</span>
 		goto unlock;
 
 	type-&gt;ops-&gt;owner = THIS_MODULE;
<span class="p_add">+	if (type-&gt;ops_nokey)</span>
<span class="p_add">+		type-&gt;ops_nokey-&gt;owner = THIS_MODULE;</span>
 	node-&gt;type = type;
 	list_add(&amp;node-&gt;list, &amp;alg_types);
 	err = 0;
<span class="p_chunk">@@ -125,6 +127,26 @@</span> <span class="p_context"> int af_alg_release(struct socket *sock)</span>
 }
 EXPORT_SYMBOL_GPL(af_alg_release);
 
<span class="p_add">+void af_alg_release_parent(struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+	unsigned int nokey = ask-&gt;nokey_refcnt;</span>
<span class="p_add">+	bool last = nokey &amp;&amp; !ask-&gt;refcnt;</span>
<span class="p_add">+</span>
<span class="p_add">+	sk = ask-&gt;parent;</span>
<span class="p_add">+	ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt -= nokey;</span>
<span class="p_add">+	if (!last)</span>
<span class="p_add">+		last = !--ask-&gt;refcnt;</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last)</span>
<span class="p_add">+		sock_put(sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(af_alg_release_parent);</span>
<span class="p_add">+</span>
 static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	const u32 forbidden = CRYPTO_ALG_INTERNAL;
<span class="p_chunk">@@ -133,6 +155,7 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct sockaddr_alg *sa = (void *)uaddr;
 	const struct af_alg_type *type;
 	void *private;
<span class="p_add">+	int err;</span>
 
 	if (sock-&gt;state == SS_CONNECTED)
 		return -EINVAL;
<span class="p_chunk">@@ -160,16 +183,22 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 		return PTR_ERR(private);
 	}
 
<span class="p_add">+	err = -EBUSY;</span>
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt | ask-&gt;nokey_refcnt)</span>
<span class="p_add">+		goto unlock;</span>
 
 	swap(ask-&gt;type, type);
 	swap(ask-&gt;private, private);
 
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
 	release_sock(sk);
 
 	alg_do_release(type, private);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 static int alg_setkey(struct sock *sk, char __user *ukey,
<span class="p_chunk">@@ -202,11 +231,15 @@</span> <span class="p_context"> static int alg_setsockopt(struct socket *sock, int level, int optname,</span>
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
<span class="p_del">-	int err = -ENOPROTOOPT;</span>
<span class="p_add">+	int err = -EBUSY;</span>
 
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
 	type = ask-&gt;type;
 
<span class="p_add">+	err = -ENOPROTOOPT;</span>
 	if (level != SOL_ALG || !type)
 		goto unlock;
 
<span class="p_chunk">@@ -238,6 +271,7 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
 	struct sock *sk2;
<span class="p_add">+	unsigned int nokey;</span>
 	int err;
 
 	lock_sock(sk);
<span class="p_chunk">@@ -257,20 +291,29 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	security_sk_clone(sk, sk2);
 
 	err = type-&gt;accept(ask-&gt;private, sk2);
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		sk_free(sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	nokey = err == -ENOKEY;</span>
<span class="p_add">+	if (nokey &amp;&amp; type-&gt;accept_nokey)</span>
<span class="p_add">+		err = type-&gt;accept_nokey(ask-&gt;private, sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
 		goto unlock;
<span class="p_del">-	}</span>
 
 	sk2-&gt;sk_family = PF_ALG;
 
<span class="p_del">-	sock_hold(sk);</span>
<span class="p_add">+	if (nokey || !ask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt += nokey;</span>
 	alg_sk(sk2)-&gt;parent = sk;
 	alg_sk(sk2)-&gt;type = type;
<span class="p_add">+	alg_sk(sk2)-&gt;nokey_refcnt = nokey;</span>
 
 	newsock-&gt;ops = type-&gt;ops;
 	newsock-&gt;state = SS_CONNECTED;
 
<span class="p_add">+	if (nokey)</span>
<span class="p_add">+		newsock-&gt;ops = type-&gt;ops_nokey;</span>
<span class="p_add">+</span>
 	err = 0;
 
 unlock:
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index 9c1dc8d6106a..d19b52324cf5 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -451,6 +451,7 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	struct ahash_alg *alg = crypto_ahash_alg(hash);
 
 	hash-&gt;setkey = ahash_nosetkey;
<span class="p_add">+	hash-&gt;has_setkey = false;</span>
 	hash-&gt;export = ahash_no_export;
 	hash-&gt;import = ahash_no_import;
 
<span class="p_chunk">@@ -463,8 +464,10 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	hash-&gt;finup = alg-&gt;finup ?: ahash_def_finup;
 	hash-&gt;digest = alg-&gt;digest;
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_add">+	if (alg-&gt;setkey) {</span>
 		hash-&gt;setkey = alg-&gt;setkey;
<span class="p_add">+		hash-&gt;has_setkey = true;</span>
<span class="p_add">+	}</span>
 	if (alg-&gt;export)
 		hash-&gt;export = alg-&gt;export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c</span>
<span class="p_header">index 1396ad0787fc..68a5ceaa04c8 100644</span>
<span class="p_header">--- a/crypto/algif_hash.c</span>
<span class="p_header">+++ b/crypto/algif_hash.c</span>
<span class="p_chunk">@@ -34,6 +34,11 @@</span> <span class="p_context"> struct hash_ctx {</span>
 	struct ahash_request req;
 };
 
<span class="p_add">+struct algif_hash_tfm {</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int hash_sendmsg(struct socket *sock, struct msghdr *msg,
 			size_t ignored)
 {
<span class="p_chunk">@@ -49,7 +54,8 @@</span> <span class="p_context"> static int hash_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 
 	lock_sock(sk);
 	if (!ctx-&gt;more) {
<span class="p_del">-		err = crypto_ahash_init(&amp;ctx-&gt;req);</span>
<span class="p_add">+		err = af_alg_wait_for_completion(crypto_ahash_init(&amp;ctx-&gt;req),</span>
<span class="p_add">+						&amp;ctx-&gt;completion);</span>
 		if (err)
 			goto unlock;
 	}
<span class="p_chunk">@@ -120,6 +126,7 @@</span> <span class="p_context"> static ssize_t hash_sendpage(struct socket *sock, struct page *page,</span>
 	} else {
 		if (!ctx-&gt;more) {
 			err = crypto_ahash_init(&amp;ctx-&gt;req);
<span class="p_add">+			err = af_alg_wait_for_completion(err, &amp;ctx-&gt;completion);</span>
 			if (err)
 				goto unlock;
 		}
<span class="p_chunk">@@ -181,9 +188,14 @@</span> <span class="p_context"> static int hash_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	struct sock *sk2;
 	struct alg_sock *ask2;
 	struct hash_ctx *ctx2;
<span class="p_add">+	bool more;</span>
 	int err;
 
<span class="p_del">-	err = crypto_ahash_export(req, state);</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	more = ctx-&gt;more;</span>
<span class="p_add">+	err = more ? crypto_ahash_export(req, state) : 0;</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -194,7 +206,10 @@</span> <span class="p_context"> static int hash_accept(struct socket *sock, struct socket *newsock, int flags)</span>
 	sk2 = newsock-&gt;sk;
 	ask2 = alg_sk(sk2);
 	ctx2 = ask2-&gt;private;
<span class="p_del">-	ctx2-&gt;more = 1;</span>
<span class="p_add">+	ctx2-&gt;more = more;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!more)</span>
<span class="p_add">+		return err;</span>
 
 	err = crypto_ahash_import(&amp;ctx2-&gt;req, state);
 	if (err) {
<span class="p_chunk">@@ -227,19 +242,151 @@</span> <span class="p_context"> static struct proto_ops algif_hash_ops = {</span>
 	.accept		=	hash_accept,
 };
 
<span class="p_add">+static int hash_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_sendmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+			      size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendmsg(sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t hash_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				   int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_recvmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+			      size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_recvmsg(sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_accept_nokey(struct socket *sock, struct socket *newsock,</span>
<span class="p_add">+			     int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept(sock, newsock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_hash_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+	.poll		=	sock_no_poll,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	hash_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	hash_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	hash_recvmsg_nokey,</span>
<span class="p_add">+	.accept		=	hash_accept_nokey,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *hash_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	hash = crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(hash)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(hash);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;hash = hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void hash_release(void *private)
 {
<span class="p_del">-	crypto_free_ahash(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_ahash(tfm-&gt;hash);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_ahash_setkey(private, key, keylen);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_ahash_setkey(tfm-&gt;hash, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void hash_sock_destruct(struct sock *sk)
<span class="p_chunk">@@ -253,12 +400,14 @@</span> <span class="p_context"> static void hash_sock_destruct(struct sock *sk)</span>
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int hash_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct hash_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);</span>
<span class="p_del">-	unsigned ds = crypto_ahash_digestsize(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_ahash *hash = tfm-&gt;hash;</span>
<span class="p_add">+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(hash);</span>
<span class="p_add">+	unsigned ds = crypto_ahash_digestsize(hash);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
<span class="p_chunk">@@ -278,7 +427,7 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ahash_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_add">+	ahash_request_set_tfm(&amp;ctx-&gt;req, hash);</span>
 	ahash_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				   af_alg_complete, &amp;ctx-&gt;completion);
 
<span class="p_chunk">@@ -287,12 +436,24 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 	return 0;
 }
 
<span class="p_add">+static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key &amp;&amp; crypto_ahash_has_setkey(tfm-&gt;hash))</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_hash = {
 	.bind		=	hash_bind,
 	.release	=	hash_release,
 	.setkey		=	hash_setkey,
 	.accept		=	hash_accept_parent,
<span class="p_add">+	.accept_nokey	=	hash_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_hash_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_hash_ops_nokey,</span>
 	.name		=	&quot;hash&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index af31a0ee4057..8ea54ac958ac 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -31,6 +31,11 @@</span> <span class="p_context"> struct skcipher_sg_list {</span>
 	struct scatterlist sg[0];
 };
 
<span class="p_add">+struct skcipher_tfm {</span>
<span class="p_add">+	struct crypto_skcipher *skcipher;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
<span class="p_chunk">@@ -47,7 +52,7 @@</span> <span class="p_context"> struct skcipher_ctx {</span>
 	bool merge;
 	bool enc;
 
<span class="p_del">-	struct ablkcipher_request req;</span>
<span class="p_add">+	struct skcipher_request req;</span>
 };
 
 struct skcipher_async_rsgl {
<span class="p_chunk">@@ -60,18 +65,10 @@</span> <span class="p_context"> struct skcipher_async_req {</span>
 	struct skcipher_async_rsgl first_sgl;
 	struct list_head list;
 	struct scatterlist *tsg;
<span class="p_del">-	char iv[];</span>
<span class="p_add">+	atomic_t *inflight;</span>
<span class="p_add">+	struct skcipher_request req;</span>
 };
 
<span class="p_del">-#define GET_SREQ(areq, ctx) (struct skcipher_async_req *)((char *)areq + \</span>
<span class="p_del">-	crypto_ablkcipher_reqsize(crypto_ablkcipher_reqtfm(&amp;ctx-&gt;req)))</span>
<span class="p_del">-</span>
<span class="p_del">-#define GET_REQ_SIZE(ctx) \</span>
<span class="p_del">-	crypto_ablkcipher_reqsize(crypto_ablkcipher_reqtfm(&amp;ctx-&gt;req))</span>
<span class="p_del">-</span>
<span class="p_del">-#define GET_IV_SIZE(ctx) \</span>
<span class="p_del">-	crypto_ablkcipher_ivsize(crypto_ablkcipher_reqtfm(&amp;ctx-&gt;req))</span>
<span class="p_del">-</span>
 #define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \
 		      sizeof(struct scatterlist) - 1)
 
<span class="p_chunk">@@ -97,15 +94,12 @@</span> <span class="p_context"> static void skcipher_free_async_sgls(struct skcipher_async_req *sreq)</span>
 
 static void skcipher_async_cb(struct crypto_async_request *req, int err)
 {
<span class="p_del">-	struct sock *sk = req-&gt;data;</span>
<span class="p_del">-	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_del">-	struct skcipher_ctx *ctx = ask-&gt;private;</span>
<span class="p_del">-	struct skcipher_async_req *sreq = GET_SREQ(req, ctx);</span>
<span class="p_add">+	struct skcipher_async_req *sreq = req-&gt;data;</span>
 	struct kiocb *iocb = sreq-&gt;iocb;
 
<span class="p_del">-	atomic_dec(&amp;ctx-&gt;inflight);</span>
<span class="p_add">+	atomic_dec(sreq-&gt;inflight);</span>
 	skcipher_free_async_sgls(sreq);
<span class="p_del">-	kfree(req);</span>
<span class="p_add">+	kzfree(sreq);</span>
 	iocb-&gt;ki_complete(iocb, err, err);
 }
 
<span class="p_chunk">@@ -301,9 +295,12 @@</span> <span class="p_context"> static int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_add">+	struct sock *psk = ask-&gt;parent;</span>
<span class="p_add">+	struct alg_sock *pask = alg_sk(psk);</span>
 	struct skcipher_ctx *ctx = ask-&gt;private;
<span class="p_del">-	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&amp;ctx-&gt;req);</span>
<span class="p_del">-	unsigned ivsize = crypto_ablkcipher_ivsize(tfm);</span>
<span class="p_add">+	struct skcipher_tfm *skc = pask-&gt;private;</span>
<span class="p_add">+	struct crypto_skcipher *tfm = skc-&gt;skcipher;</span>
<span class="p_add">+	unsigned ivsize = crypto_skcipher_ivsize(tfm);</span>
 	struct skcipher_sg_list *sgl;
 	struct af_alg_control con = {};
 	long copied = 0;
<span class="p_chunk">@@ -387,7 +384,8 @@</span> <span class="p_context"> static int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 
 		sgl = list_entry(ctx-&gt;tsgl.prev, struct skcipher_sg_list, list);
 		sg = sgl-&gt;sg;
<span class="p_del">-		sg_unmark_end(sg + sgl-&gt;cur);</span>
<span class="p_add">+		if (sgl-&gt;cur)</span>
<span class="p_add">+			sg_unmark_end(sg + sgl-&gt;cur - 1);</span>
 		do {
 			i = sgl-&gt;cur;
 			plen = min_t(int, len, PAGE_SIZE);
<span class="p_chunk">@@ -503,37 +501,43 @@</span> <span class="p_context"> static int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_add">+	struct sock *psk = ask-&gt;parent;</span>
<span class="p_add">+	struct alg_sock *pask = alg_sk(psk);</span>
 	struct skcipher_ctx *ctx = ask-&gt;private;
<span class="p_add">+	struct skcipher_tfm *skc = pask-&gt;private;</span>
<span class="p_add">+	struct crypto_skcipher *tfm = skc-&gt;skcipher;</span>
 	struct skcipher_sg_list *sgl;
 	struct scatterlist *sg;
 	struct skcipher_async_req *sreq;
<span class="p_del">-	struct ablkcipher_request *req;</span>
<span class="p_add">+	struct skcipher_request *req;</span>
 	struct skcipher_async_rsgl *last_rsgl = NULL;
<span class="p_del">-	unsigned int txbufs = 0, len = 0, tx_nents = skcipher_all_sg_nents(ctx);</span>
<span class="p_del">-	unsigned int reqlen = sizeof(struct skcipher_async_req) +</span>
<span class="p_del">-				GET_REQ_SIZE(ctx) + GET_IV_SIZE(ctx);</span>
<span class="p_add">+	unsigned int txbufs = 0, len = 0, tx_nents;</span>
<span class="p_add">+	unsigned int reqsize = crypto_skcipher_reqsize(tfm);</span>
<span class="p_add">+	unsigned int ivsize = crypto_skcipher_ivsize(tfm);</span>
 	int err = -ENOMEM;
 	bool mark = false;
<span class="p_add">+	char *iv;</span>
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_del">-	req = kmalloc(reqlen, GFP_KERNEL);</span>
<span class="p_del">-	if (unlikely(!req))</span>
<span class="p_del">-		goto unlock;</span>
<span class="p_add">+	sreq = kzalloc(sizeof(*sreq) + reqsize + ivsize, GFP_KERNEL);</span>
<span class="p_add">+	if (unlikely(!sreq))</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_del">-	sreq = GET_SREQ(req, ctx);</span>
<span class="p_add">+	req = &amp;sreq-&gt;req;</span>
<span class="p_add">+	iv = (char *)(req + 1) + reqsize;</span>
 	sreq-&gt;iocb = msg-&gt;msg_iocb;
<span class="p_del">-	memset(&amp;sreq-&gt;first_sgl, &#39;\0&#39;, sizeof(struct skcipher_async_rsgl));</span>
 	INIT_LIST_HEAD(&amp;sreq-&gt;list);
<span class="p_add">+	sreq-&gt;inflight = &amp;ctx-&gt;inflight;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	tx_nents = skcipher_all_sg_nents(ctx);</span>
 	sreq-&gt;tsg = kcalloc(tx_nents, sizeof(*sg), GFP_KERNEL);
<span class="p_del">-	if (unlikely(!sreq-&gt;tsg)) {</span>
<span class="p_del">-		kfree(req);</span>
<span class="p_add">+	if (unlikely(!sreq-&gt;tsg))</span>
 		goto unlock;
<span class="p_del">-	}</span>
 	sg_init_table(sreq-&gt;tsg, tx_nents);
<span class="p_del">-	memcpy(sreq-&gt;iv, ctx-&gt;iv, GET_IV_SIZE(ctx));</span>
<span class="p_del">-	ablkcipher_request_set_tfm(req, crypto_ablkcipher_reqtfm(&amp;ctx-&gt;req));</span>
<span class="p_del">-	ablkcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span>
<span class="p_del">-					skcipher_async_cb, sk);</span>
<span class="p_add">+	memcpy(iv, ctx-&gt;iv, ivsize);</span>
<span class="p_add">+	skcipher_request_set_tfm(req, tfm);</span>
<span class="p_add">+	skcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,</span>
<span class="p_add">+				      skcipher_async_cb, sreq);</span>
 
 	while (iov_iter_count(&amp;msg-&gt;msg_iter)) {
 		struct skcipher_async_rsgl *rsgl;
<span class="p_chunk">@@ -608,21 +612,23 @@</span> <span class="p_context"> static int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,</span>
 	if (mark)
 		sg_mark_end(sreq-&gt;tsg + txbufs - 1);
 
<span class="p_del">-	ablkcipher_request_set_crypt(req, sreq-&gt;tsg, sreq-&gt;first_sgl.sgl.sg,</span>
<span class="p_del">-				     len, sreq-&gt;iv);</span>
<span class="p_del">-	err = ctx-&gt;enc ? crypto_ablkcipher_encrypt(req) :</span>
<span class="p_del">-			 crypto_ablkcipher_decrypt(req);</span>
<span class="p_add">+	skcipher_request_set_crypt(req, sreq-&gt;tsg, sreq-&gt;first_sgl.sgl.sg,</span>
<span class="p_add">+				   len, iv);</span>
<span class="p_add">+	err = ctx-&gt;enc ? crypto_skcipher_encrypt(req) :</span>
<span class="p_add">+			 crypto_skcipher_decrypt(req);</span>
 	if (err == -EINPROGRESS) {
 		atomic_inc(&amp;ctx-&gt;inflight);
 		err = -EIOCBQUEUED;
<span class="p_add">+		sreq = NULL;</span>
 		goto unlock;
 	}
 free:
 	skcipher_free_async_sgls(sreq);
<span class="p_del">-	kfree(req);</span>
 unlock:
 	skcipher_wmem_wakeup(sk);
 	release_sock(sk);
<span class="p_add">+	kzfree(sreq);</span>
<span class="p_add">+out:</span>
 	return err;
 }
 
<span class="p_chunk">@@ -631,9 +637,12 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_add">+	struct sock *psk = ask-&gt;parent;</span>
<span class="p_add">+	struct alg_sock *pask = alg_sk(psk);</span>
 	struct skcipher_ctx *ctx = ask-&gt;private;
<span class="p_del">-	unsigned bs = crypto_ablkcipher_blocksize(crypto_ablkcipher_reqtfm(</span>
<span class="p_del">-		&amp;ctx-&gt;req));</span>
<span class="p_add">+	struct skcipher_tfm *skc = pask-&gt;private;</span>
<span class="p_add">+	struct crypto_skcipher *tfm = skc-&gt;skcipher;</span>
<span class="p_add">+	unsigned bs = crypto_skcipher_blocksize(tfm);</span>
 	struct skcipher_sg_list *sgl;
 	struct scatterlist *sg;
 	int err = -EAGAIN;
<span class="p_chunk">@@ -642,13 +651,6 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 
 	lock_sock(sk);
 	while (msg_data_left(msg)) {
<span class="p_del">-		sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_del">-				       struct skcipher_sg_list, list);</span>
<span class="p_del">-		sg = sgl-&gt;sg;</span>
<span class="p_del">-</span>
<span class="p_del">-		while (!sg-&gt;length)</span>
<span class="p_del">-			sg++;</span>
<span class="p_del">-</span>
 		if (!ctx-&gt;used) {
 			err = skcipher_wait_for_data(sk, flags);
 			if (err)
<span class="p_chunk">@@ -669,14 +671,20 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 		if (!used)
 			goto free;
 
<span class="p_del">-		ablkcipher_request_set_crypt(&amp;ctx-&gt;req, sg,</span>
<span class="p_del">-					     ctx-&gt;rsgl.sg, used,</span>
<span class="p_del">-					     ctx-&gt;iv);</span>
<span class="p_add">+		sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_add">+				       struct skcipher_sg_list, list);</span>
<span class="p_add">+		sg = sgl-&gt;sg;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (!sg-&gt;length)</span>
<span class="p_add">+			sg++;</span>
<span class="p_add">+</span>
<span class="p_add">+		skcipher_request_set_crypt(&amp;ctx-&gt;req, sg, ctx-&gt;rsgl.sg, used,</span>
<span class="p_add">+					   ctx-&gt;iv);</span>
 
 		err = af_alg_wait_for_completion(
 				ctx-&gt;enc ?
<span class="p_del">-					crypto_ablkcipher_encrypt(&amp;ctx-&gt;req) :</span>
<span class="p_del">-					crypto_ablkcipher_decrypt(&amp;ctx-&gt;req),</span>
<span class="p_add">+					crypto_skcipher_encrypt(&amp;ctx-&gt;req) :</span>
<span class="p_add">+					crypto_skcipher_decrypt(&amp;ctx-&gt;req),</span>
 				&amp;ctx-&gt;completion);
 
 free:
<span class="p_chunk">@@ -749,19 +757,139 @@</span> <span class="p_context"> static struct proto_ops algif_skcipher_ops = {</span>
 	.poll		=	skcipher_poll,
 };
 
<span class="p_add">+static int skcipher_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_sendmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+				  size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendmsg(sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t skcipher_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				       int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+				  size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_recvmsg(sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_skcipher_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.accept		=	sock_no_accept,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	skcipher_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	skcipher_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	skcipher_recvmsg_nokey,</span>
<span class="p_add">+	.poll		=	skcipher_poll,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_ablkcipher(name, type, mask);</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct crypto_skcipher *skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	skcipher = crypto_alloc_skcipher(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(skcipher)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(skcipher);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;skcipher = skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void skcipher_release(void *private)
 {
<span class="p_del">-	crypto_free_ablkcipher(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_skcipher(tfm-&gt;skcipher);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_ablkcipher_setkey(private, key, keylen);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_skcipher_setkey(tfm-&gt;skcipher, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void skcipher_wait(struct sock *sk)
<span class="p_chunk">@@ -778,35 +906,37 @@</span> <span class="p_context"> static void skcipher_sock_destruct(struct sock *sk)</span>
 {
 	struct alg_sock *ask = alg_sk(sk);
 	struct skcipher_ctx *ctx = ask-&gt;private;
<span class="p_del">-	struct crypto_ablkcipher *tfm = crypto_ablkcipher_reqtfm(&amp;ctx-&gt;req);</span>
<span class="p_add">+	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&amp;ctx-&gt;req);</span>
 
 	if (atomic_read(&amp;ctx-&gt;inflight))
 		skcipher_wait(sk);
 
 	skcipher_free_sgl(sk);
<span class="p_del">-	sock_kzfree_s(sk, ctx-&gt;iv, crypto_ablkcipher_ivsize(tfm));</span>
<span class="p_add">+	sock_kzfree_s(sk, ctx-&gt;iv, crypto_skcipher_ivsize(tfm));</span>
 	sock_kfree_s(sk, ctx, ctx-&gt;len);
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int skcipher_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned int len = sizeof(*ctx) + crypto_ablkcipher_reqsize(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_skcipher *skcipher = tfm-&gt;skcipher;</span>
<span class="p_add">+	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
<span class="p_del">-	ctx-&gt;iv = sock_kmalloc(sk, crypto_ablkcipher_ivsize(private),</span>
<span class="p_add">+	ctx-&gt;iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),</span>
 			       GFP_KERNEL);
 	if (!ctx-&gt;iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
<span class="p_del">-	memset(ctx-&gt;iv, 0, crypto_ablkcipher_ivsize(private));</span>
<span class="p_add">+	memset(ctx-&gt;iv, 0, crypto_skcipher_ivsize(skcipher));</span>
 
 	INIT_LIST_HEAD(&amp;ctx-&gt;tsgl);
 	ctx-&gt;len = len;
<span class="p_chunk">@@ -819,21 +949,34 @@</span> <span class="p_context"> static int skcipher_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ablkcipher_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_del">-	ablkcipher_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span>
<span class="p_del">-					af_alg_complete, &amp;ctx-&gt;completion);</span>
<span class="p_add">+	skcipher_request_set_tfm(&amp;ctx-&gt;req, skcipher);</span>
<span class="p_add">+	skcipher_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_SLEEP |</span>
<span class="p_add">+						 CRYPTO_TFM_REQ_MAY_BACKLOG,</span>
<span class="p_add">+				      af_alg_complete, &amp;ctx-&gt;completion);</span>
 
 	sk-&gt;sk_destruct = skcipher_sock_destruct;
 
 	return 0;
 }
 
<span class="p_add">+static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key &amp;&amp; crypto_skcipher_has_setkey(tfm-&gt;skcipher))</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_skcipher = {
 	.bind		=	skcipher_bind,
 	.release	=	skcipher_release,
 	.setkey		=	skcipher_setkey,
 	.accept		=	skcipher_accept_parent,
<span class="p_add">+	.accept_nokey	=	skcipher_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_skcipher_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_skcipher_ops_nokey,</span>
 	.name		=	&quot;skcipher&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c</span>
<span class="p_header">index 11b981492031..8cc1622b2ee0 100644</span>
<span class="p_header">--- a/crypto/blkcipher.c</span>
<span class="p_header">+++ b/crypto/blkcipher.c</span>
<span class="p_chunk">@@ -326,12 +326,12 @@</span> <span class="p_context"> static int blkcipher_walk_first(struct blkcipher_desc *desc,</span>
 	if (WARN_ON_ONCE(in_irq()))
 		return -EDEADLK;
 
<span class="p_add">+	walk-&gt;iv = desc-&gt;info;</span>
 	walk-&gt;nbytes = walk-&gt;total;
 	if (unlikely(!walk-&gt;total))
 		return 0;
 
 	walk-&gt;buffer = NULL;
<span class="p_del">-	walk-&gt;iv = desc-&gt;info;</span>
 	if (unlikely(((unsigned long)walk-&gt;iv &amp; walk-&gt;alignmask))) {
 		int err = blkcipher_copy_iv(walk);
 		if (err)
<span class="p_header">diff --git a/crypto/crc32c_generic.c b/crypto/crc32c_generic.c</span>
<span class="p_header">index 06f1b60f02b2..4c0a0e271876 100644</span>
<span class="p_header">--- a/crypto/crc32c_generic.c</span>
<span class="p_header">+++ b/crypto/crc32c_generic.c</span>
<span class="p_chunk">@@ -172,4 +172,3 @@</span> <span class="p_context"> MODULE_DESCRIPTION(&quot;CRC32c (Castagnoli) calculations wrapper for lib/crc32c&quot;);</span>
 MODULE_LICENSE(&quot;GPL&quot;);
 MODULE_ALIAS_CRYPTO(&quot;crc32c&quot;);
 MODULE_ALIAS_CRYPTO(&quot;crc32c-generic&quot;);
<span class="p_del">-MODULE_SOFTDEP(&quot;pre: crc32c&quot;);</span>
<span class="p_header">diff --git a/crypto/crypto_user.c b/crypto/crypto_user.c</span>
<span class="p_header">index 237f3795cfaa..43fe85f20d57 100644</span>
<span class="p_header">--- a/crypto/crypto_user.c</span>
<span class="p_header">+++ b/crypto/crypto_user.c</span>
<span class="p_chunk">@@ -499,6 +499,7 @@</span> <span class="p_context"> static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 		if (link-&gt;dump == NULL)
 			return -EINVAL;
 
<span class="p_add">+		down_read(&amp;crypto_alg_sem);</span>
 		list_for_each_entry(alg, &amp;crypto_alg_list, cra_list)
 			dump_alloc += CRYPTO_REPORT_MAXSIZE;
 
<span class="p_chunk">@@ -508,8 +509,11 @@</span> <span class="p_context"> static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 				.done = link-&gt;done,
 				.min_dump_alloc = dump_alloc,
 			};
<span class="p_del">-			return netlink_dump_start(crypto_nlsk, skb, nlh, &amp;c);</span>
<span class="p_add">+			err = netlink_dump_start(crypto_nlsk, skb, nlh, &amp;c);</span>
 		}
<span class="p_add">+		up_read(&amp;crypto_alg_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+		return err;</span>
 	}
 
 	err = nlmsg_parse(nlh, crypto_msg_min[type], attrs, CRYPTOCFGA_MAX,
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index ecb1e3d39bf0..359754591653 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -354,9 +354,10 @@</span> <span class="p_context"> int crypto_init_shash_ops_async(struct crypto_tfm *tfm)</span>
 	crt-&gt;final = shash_async_final;
 	crt-&gt;finup = shash_async_finup;
 	crt-&gt;digest = shash_async_digest;
<span class="p_add">+	crt-&gt;setkey = shash_async_setkey;</span>
<span class="p_add">+</span>
<span class="p_add">+	crt-&gt;has_setkey = alg-&gt;setkey != shash_no_setkey;</span>
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_del">-		crt-&gt;setkey = shash_async_setkey;</span>
 	if (alg-&gt;export)
 		crt-&gt;export = shash_async_export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/crypto/skcipher.c b/crypto/skcipher.c</span>
<span class="p_header">index dd5fc1bf6447..bb7d44d2c843 100644</span>
<span class="p_header">--- a/crypto/skcipher.c</span>
<span class="p_header">+++ b/crypto/skcipher.c</span>
<span class="p_chunk">@@ -118,6 +118,7 @@</span> <span class="p_context"> int crypto_init_skcipher_ops_blkcipher(struct crypto_tfm *tfm)</span>
 	skcipher-&gt;decrypt = skcipher_decrypt_blkcipher;
 
 	skcipher-&gt;ivsize = crypto_blkcipher_ivsize(blkcipher);
<span class="p_add">+	skcipher-&gt;has_setkey = calg-&gt;cra_blkcipher.max_keysize;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -210,6 +211,7 @@</span> <span class="p_context"> int crypto_init_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)</span>
 	skcipher-&gt;ivsize = crypto_ablkcipher_ivsize(ablkcipher);
 	skcipher-&gt;reqsize = crypto_ablkcipher_reqsize(ablkcipher) +
 			    sizeof(struct ablkcipher_request);
<span class="p_add">+	skcipher-&gt;has_setkey = calg-&gt;cra_ablkcipher.max_keysize;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/crypto/testmgr.h b/crypto/testmgr.h</span>
<span class="p_header">index 64b8a8082645..450f30e2c8e4 100644</span>
<span class="p_header">--- a/crypto/testmgr.h</span>
<span class="p_header">+++ b/crypto/testmgr.h</span>
<span class="p_chunk">@@ -270,7 +270,7 @@</span> <span class="p_context"> static struct akcipher_testvec rsa_tv_template[] = {</span>
 	.c_size = 256,
 	}, {
 	.key =
<span class="p_del">-	&quot;\x30\x82\x01\x09&quot; /* sequence of 265 bytes */</span>
<span class="p_add">+	&quot;\x30\x82\x01\x0C&quot; /* sequence of 268 bytes */</span>
 	&quot;\x02\x82\x01\x00&quot; /* modulus - integer of 256 bytes */
 	&quot;\xDB\x10\x1A\xC2\xA3\xF1\xDC\xFF\x13\x6B\xED\x44\xDF\xF0\x02\x6D&quot;
 	&quot;\x13\xC7\x88\xDA\x70\x6B\x54\xF1\xE8\x27\xDC\xC3\x0F\x99\x6A\xFA&quot;
<span class="p_chunk">@@ -288,8 +288,9 @@</span> <span class="p_context"> static struct akcipher_testvec rsa_tv_template[] = {</span>
 	&quot;\x55\xE6\x29\x69\xD1\xC2\xE8\xB9\x78\x59\xF6\x79\x10\xC6\x4E\xEB&quot;
 	&quot;\x6A\x5E\xB9\x9A\xC7\xC4\x5B\x63\xDA\xA3\x3F\x5E\x92\x7A\x81\x5E&quot;
 	&quot;\xD6\xB0\xE2\x62\x8F\x74\x26\xC2\x0C\xD3\x9A\x17\x47\xE6\x8E\xAB&quot;
<span class="p_del">-	&quot;\x02\x03\x01\x00\x01&quot;, /* public key - integer of 3 bytes */</span>
<span class="p_del">-	.key_len = 269,</span>
<span class="p_add">+	&quot;\x02\x03\x01\x00\x01&quot; /* public key - integer of 3 bytes */</span>
<span class="p_add">+	&quot;\x02\x01\x00&quot;, /* private key - integer of 1 byte */</span>
<span class="p_add">+	.key_len = 272,</span>
 	.m = &quot;\x54\x85\x9b\x34\x2c\x49\xea\x2a&quot;,
 	.c =
 	&quot;\xb2\x97\x76\xb4\xae\x3e\x38\x3c\x7e\x64\x1f\xcc\xa2\x7f\xf6\xbe&quot;
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index a46660204e3a..bbd472cadc98 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -264,6 +264,26 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x3b2b), board_ahci }, /* PCH RAID */
 	{ PCI_VDEVICE(INTEL, 0x3b2c), board_ahci }, /* PCH RAID */
 	{ PCI_VDEVICE(INTEL, 0x3b2f), board_ahci }, /* PCH AHCI */
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b0), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b1), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b2), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b3), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b4), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b5), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b6), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b7), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19bE), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19bF), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c0), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c1), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c2), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c3), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c4), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c5), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c6), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c7), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19cE), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19cF), board_ahci }, /* DNV AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0x1c02), board_ahci }, /* CPT AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c03), board_ahci }, /* CPT AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c04), board_ahci }, /* CPT RAID */
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index d256a66158be..317f85dfd39a 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -495,8 +495,8 @@</span> <span class="p_context"> void ahci_save_initial_config(struct device *dev, struct ahci_host_priv *hpriv)</span>
 		}
 	}
 
<span class="p_del">-	/* fabricate port_map from cap.nr_ports */</span>
<span class="p_del">-	if (!port_map) {</span>
<span class="p_add">+	/* fabricate port_map from cap.nr_ports for &lt; AHCI 1.3 */</span>
<span class="p_add">+	if (!port_map &amp;&amp; vers &lt; 0x10300) {</span>
 		port_map = (1 &lt;&lt; ahci_nr_ports(cap)) - 1;
 		dev_warn(dev, &quot;forcing PORTS_IMPL to 0x%x\n&quot;, port_map);
 
<span class="p_chunk">@@ -1266,6 +1266,15 @@</span> <span class="p_context"> static int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,</span>
 	ata_tf_to_fis(tf, pmp, is_cmd, fis);
 	ahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp &lt;&lt; 12));
 
<span class="p_add">+	/* set port value for softreset of Port Multiplier */</span>
<span class="p_add">+	if (pp-&gt;fbs_enabled &amp;&amp; pp-&gt;fbs_last_dev != pmp) {</span>
<span class="p_add">+		tmp = readl(port_mmio + PORT_FBS);</span>
<span class="p_add">+		tmp &amp;= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);</span>
<span class="p_add">+		tmp |= pmp &lt;&lt; PORT_FBS_DEV_OFFSET;</span>
<span class="p_add">+		writel(tmp, port_mmio + PORT_FBS);</span>
<span class="p_add">+		pp-&gt;fbs_last_dev = pmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* issue &amp; wait */
 	writel(1, port_mmio + PORT_CMD_ISSUE);
 
<span class="p_header">diff --git a/drivers/base/memory.c b/drivers/base/memory.c</span>
<span class="p_header">index 2804aed3f416..25425d3f2575 100644</span>
<span class="p_header">--- a/drivers/base/memory.c</span>
<span class="p_header">+++ b/drivers/base/memory.c</span>
<span class="p_chunk">@@ -303,6 +303,10 @@</span> <span class="p_context"> static int memory_subsys_offline(struct device *dev)</span>
 	if (mem-&gt;state == MEM_OFFLINE)
 		return 0;
 
<span class="p_add">+	/* Can&#39;t offline block with non-present sections */</span>
<span class="p_add">+	if (mem-&gt;section_count != sections_per_block)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	return memory_block_change_state(mem, MEM_OFFLINE, MEM_ONLINE);
 }
 
<span class="p_header">diff --git a/drivers/block/zram/zcomp.c b/drivers/block/zram/zcomp.c</span>
<span class="p_header">index 5cb13ca3a3ac..c53617752b93 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static void zcomp_strm_free(struct zcomp *comp, struct zcomp_strm *zstrm)</span>
  */
 static struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)
 {
<span class="p_del">-	struct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_KERNEL);</span>
<span class="p_add">+	struct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_NOIO);</span>
 	if (!zstrm)
 		return NULL;
 
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)</span>
 	 * allocate 2 pages. 1 for compressed data, plus 1 extra for the
 	 * case when compressed size is larger than the original one
 	 */
<span class="p_del">-	zstrm-&gt;buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);</span>
<span class="p_add">+	zstrm-&gt;buffer = (void *)__get_free_pages(GFP_NOIO | __GFP_ZERO, 1);</span>
 	if (!zstrm-&gt;private || !zstrm-&gt;buffer) {
 		zcomp_strm_free(comp, zstrm);
 		zstrm = NULL;
<span class="p_header">diff --git a/drivers/block/zram/zcomp_lz4.c b/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_header">index f2afb7e988c3..dd6083124276 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_chunk">@@ -10,17 +10,36 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/lz4.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &quot;zcomp_lz4.h&quot;
 
 static void *zcomp_lz4_create(void)
 {
<span class="p_del">-	return kzalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);</span>
<span class="p_add">+	void *ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This function can be called in swapout/fs write path</span>
<span class="p_add">+	 * so we can&#39;t use GFP_FS|IO. And it assumes we already</span>
<span class="p_add">+	 * have at least one stream in zram initialization so we</span>
<span class="p_add">+	 * don&#39;t do best effort to allocate more stream in here.</span>
<span class="p_add">+	 * A default stream will work well without further multiple</span>
<span class="p_add">+	 * streams. That&#39;s why we use NORETRY | NOWARN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = kzalloc(LZ4_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span>
<span class="p_add">+					__GFP_NOWARN);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = __vmalloc(LZ4_MEM_COMPRESS,</span>
<span class="p_add">+				GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span>
<span class="p_add">+				__GFP_ZERO | __GFP_HIGHMEM,</span>
<span class="p_add">+				PAGE_KERNEL);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void zcomp_lz4_destroy(void *private)
 {
<span class="p_del">-	kfree(private);</span>
<span class="p_add">+	kvfree(private);</span>
 }
 
 static int zcomp_lz4_compress(const unsigned char *src, unsigned char *dst,
<span class="p_header">diff --git a/drivers/block/zram/zcomp_lzo.c b/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_header">index da1bc47d588e..edc549920fa0 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_chunk">@@ -10,17 +10,36 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/lzo.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &quot;zcomp_lzo.h&quot;
 
 static void *lzo_create(void)
 {
<span class="p_del">-	return kzalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL);</span>
<span class="p_add">+	void *ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This function can be called in swapout/fs write path</span>
<span class="p_add">+	 * so we can&#39;t use GFP_FS|IO. And it assumes we already</span>
<span class="p_add">+	 * have at least one stream in zram initialization so we</span>
<span class="p_add">+	 * don&#39;t do best effort to allocate more stream in here.</span>
<span class="p_add">+	 * A default stream will work well without further multiple</span>
<span class="p_add">+	 * streams. That&#39;s why we use NORETRY | NOWARN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = kzalloc(LZO1X_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span>
<span class="p_add">+					__GFP_NOWARN);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = __vmalloc(LZO1X_MEM_COMPRESS,</span>
<span class="p_add">+				GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span>
<span class="p_add">+				__GFP_ZERO | __GFP_HIGHMEM,</span>
<span class="p_add">+				PAGE_KERNEL);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void lzo_destroy(void *private)
 {
<span class="p_del">-	kfree(private);</span>
<span class="p_add">+	kvfree(private);</span>
 }
 
 static int lzo_compress(const unsigned char *src, unsigned char *dst,
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 9fa15bb9d118..8022c0a96b36 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -1324,7 +1324,6 @@</span> <span class="p_context"> static int zram_remove(struct zram *zram)</span>
 
 	pr_info(&quot;Removed device: %s\n&quot;, zram-&gt;disk-&gt;disk_name);
 
<span class="p_del">-	idr_remove(&amp;zram_index_idr, zram-&gt;disk-&gt;first_minor);</span>
 	blk_cleanup_queue(zram-&gt;disk-&gt;queue);
 	del_gendisk(zram-&gt;disk);
 	put_disk(zram-&gt;disk);
<span class="p_chunk">@@ -1366,10 +1365,12 @@</span> <span class="p_context"> static ssize_t hot_remove_store(struct class *class,</span>
 	mutex_lock(&amp;zram_index_mutex);
 
 	zram = idr_find(&amp;zram_index_idr, dev_id);
<span class="p_del">-	if (zram)</span>
<span class="p_add">+	if (zram) {</span>
 		ret = zram_remove(zram);
<span class="p_del">-	else</span>
<span class="p_add">+		idr_remove(&amp;zram_index_idr, dev_id);</span>
<span class="p_add">+	} else {</span>
 		ret = -ENODEV;
<span class="p_add">+	}</span>
 
 	mutex_unlock(&amp;zram_index_mutex);
 	return ret ? ret : count;
<span class="p_header">diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c</span>
<span class="p_header">index 1082d4bb016a..0f8623d88b84 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-chip.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-chip.c</span>
<span class="p_chunk">@@ -231,7 +231,7 @@</span> <span class="p_context"> int tpm_chip_register(struct tpm_chip *chip)</span>
 
 	/* Make the chip available. */
 	spin_lock(&amp;driver_lock);
<span class="p_del">-	list_add_rcu(&amp;chip-&gt;list, &amp;tpm_chip_list);</span>
<span class="p_add">+	list_add_tail_rcu(&amp;chip-&gt;list, &amp;tpm_chip_list);</span>
 	spin_unlock(&amp;driver_lock);
 
 	chip-&gt;flags |= TPM_CHIP_FLAG_REGISTERED;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index 2b971b3e5c1c..4bb9727c1047 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> struct crb_control_area {</span>
 	u32 int_enable;
 	u32 int_sts;
 	u32 cmd_size;
<span class="p_del">-	u64 cmd_pa;</span>
<span class="p_add">+	u32 cmd_pa_low;</span>
<span class="p_add">+	u32 cmd_pa_high;</span>
 	u32 rsp_size;
 	u64 rsp_pa;
 } __packed;
<span class="p_chunk">@@ -263,8 +264,8 @@</span> <span class="p_context"> static int crb_acpi_add(struct acpi_device *device)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	memcpy_fromio(&amp;pa, &amp;priv-&gt;cca-&gt;cmd_pa, 8);</span>
<span class="p_del">-	pa = le64_to_cpu(pa);</span>
<span class="p_add">+	pa = ((u64) le32_to_cpu(ioread32(&amp;priv-&gt;cca-&gt;cmd_pa_high)) &lt;&lt; 32) |</span>
<span class="p_add">+		(u64) le32_to_cpu(ioread32(&amp;priv-&gt;cca-&gt;cmd_pa_low));</span>
 	priv-&gt;cmd = devm_ioremap_nocache(dev, pa,
 					 ioread32(&amp;priv-&gt;cca-&gt;cmd_size));
 	if (!priv-&gt;cmd) {
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 27ebf9511cb4..3e6a22658b63 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -491,7 +491,7 @@</span> <span class="p_context"> static void ibmvtpm_crq_process(struct ibmvtpm_crq *crq,</span>
 			}
 			ibmvtpm-&gt;rtce_size = be16_to_cpu(crq-&gt;len);
 			ibmvtpm-&gt;rtce_buf = kmalloc(ibmvtpm-&gt;rtce_size,
<span class="p_del">-						    GFP_KERNEL);</span>
<span class="p_add">+						    GFP_ATOMIC);</span>
 			if (!ibmvtpm-&gt;rtce_buf) {
 				dev_err(ibmvtpm-&gt;dev, &quot;Failed to allocate memory for rtce buffer\n&quot;);
 				return;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">index 696ef1d56b4f..19f9c7dc7bc0 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_chunk">@@ -805,6 +805,8 @@</span> <span class="p_context"> static int tpm_tis_init(struct device *dev, struct tpm_info *tpm_info,</span>
 			iowrite32(intmask,
 				  chip-&gt;vendor.iobase +
 				  TPM_INT_ENABLE(chip-&gt;vendor.locality));
<span class="p_add">+</span>
<span class="p_add">+			devm_free_irq(dev, i, chip);</span>
 		}
 	}
 	if (chip-&gt;vendor.irq) {
<span class="p_header">diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">index 94433b9fc200..3b70354b0d4b 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamhash.c</span>
<span class="p_chunk">@@ -829,7 +829,7 @@</span> <span class="p_context"> static int ahash_update_ctx(struct ahash_request *req)</span>
 		state-&gt;buf_dma = try_buf_map_to_sec4_sg(jrdev,
 							edesc-&gt;sec4_sg + 1,
 							buf, state-&gt;buf_dma,
<span class="p_del">-							*next_buflen, *buflen);</span>
<span class="p_add">+							*buflen, last_buflen);</span>
 
 		if (src_nents) {
 			src_map_to_sec4_sg(jrdev, req-&gt;src, src_nents,
<span class="p_header">diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">index 8abb4bc548cc..69d4a1326fee 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/ctrl.c</span>
<span class="p_chunk">@@ -534,8 +534,8 @@</span> <span class="p_context"> static int caam_probe(struct platform_device *pdev)</span>
 	 * long pointers in master configuration register
 	 */
 	clrsetbits_32(&amp;ctrl-&gt;mcr, MCFGR_AWCACHE_MASK, MCFGR_AWCACHE_CACH |
<span class="p_del">-		      MCFGR_WDENABLE | (sizeof(dma_addr_t) == sizeof(u64) ?</span>
<span class="p_del">-					MCFGR_LONG_PTR : 0));</span>
<span class="p_add">+		      MCFGR_AWCACHE_BUFF | MCFGR_WDENABLE |</span>
<span class="p_add">+		      (sizeof(dma_addr_t) == sizeof(u64) ? MCFGR_LONG_PTR : 0));</span>
 
 	/*
 	 *  Read the Compile Time paramters and SCFGR to determine
<span class="p_header">diff --git a/drivers/crypto/marvell/cesa.c b/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">index 0643e3366e33..c0656e7f37b5 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/cesa.c</span>
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static int mv_cesa_dev_dma_init(struct mv_cesa_dev *cesa)</span>
 		return -ENOMEM;
 
 	dma-&gt;padding_pool = dmam_pool_create(&quot;cesa_padding&quot;, dev, 72, 1, 0);
<span class="p_del">-	if (!dma-&gt;cache_pool)</span>
<span class="p_add">+	if (!dma-&gt;padding_pool)</span>
 		return -ENOMEM;
 
 	cesa-&gt;dma = dma;
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-ccm.c b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">index 73ef49922788..7038f364acb5 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-ccm.c</span>
<span class="p_chunk">@@ -409,7 +409,7 @@</span> <span class="p_context"> static int ccm_nx_decrypt(struct aead_request   *req,</span>
 		processed += to_process;
 	} while (processed &lt; nbytes);
 
<span class="p_del">-	rc = memcmp(csbcpb-&gt;cpb.aes_ccm.out_pat_or_mac, priv-&gt;oauth_tag,</span>
<span class="p_add">+	rc = crypto_memneq(csbcpb-&gt;cpb.aes_ccm.out_pat_or_mac, priv-&gt;oauth_tag,</span>
 		    authsize) ? -EBADMSG : 0;
 out:
 	spin_unlock_irqrestore(&amp;nx_ctx-&gt;lock, irq_flags);
<span class="p_header">diff --git a/drivers/crypto/nx/nx-aes-gcm.c b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">index eee624f589b6..abd465f479c4 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx-aes-gcm.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 
 #include &lt;crypto/internal/aead.h&gt;
 #include &lt;crypto/aes.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 #include &lt;crypto/scatterwalk.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/types.h&gt;
<span class="p_chunk">@@ -418,7 +419,7 @@</span> <span class="p_context"> mac:</span>
 			itag, req-&gt;src, req-&gt;assoclen + nbytes,
 			crypto_aead_authsize(crypto_aead_reqtfm(req)),
 			SCATTERWALK_FROM_SG);
<span class="p_del">-		rc = memcmp(itag, otag,</span>
<span class="p_add">+		rc = crypto_memneq(itag, otag,</span>
 			    crypto_aead_authsize(crypto_aead_reqtfm(req))) ?
 		     -EBADMSG : 0;
 	}
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/adf_ctl_drv.c b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">index cd8a12af8ec5..35bada05608a 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/adf_ctl_drv.c</span>
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"> static int adf_copy_key_value_data(struct adf_accel_dev *accel_dev,</span>
 			goto out_err;
 		}
 
<span class="p_del">-		params_head = section_head-&gt;params;</span>
<span class="p_add">+		params_head = section.params;</span>
 
 		while (params_head) {
 			if (copy_from_user(&amp;key_val, (void __user *)params_head,
<span class="p_header">diff --git a/drivers/crypto/sunxi-ss/sun4i-ss-core.c b/drivers/crypto/sunxi-ss/sun4i-ss-core.c</span>
<span class="p_header">index eab6fe227fa0..107cd2a41cae 100644</span>
<span class="p_header">--- a/drivers/crypto/sunxi-ss/sun4i-ss-core.c</span>
<span class="p_header">+++ b/drivers/crypto/sunxi-ss/sun4i-ss-core.c</span>
<span class="p_chunk">@@ -39,6 +39,7 @@</span> <span class="p_context"> static struct sun4i_ss_alg_template ss_algs[] = {</span>
 		.import = sun4i_hash_import_md5,
 		.halg = {
 			.digestsize = MD5_DIGEST_SIZE,
<span class="p_add">+			.statesize = sizeof(struct md5_state),</span>
 			.base = {
 				.cra_name = &quot;md5&quot;,
 				.cra_driver_name = &quot;md5-sun4i-ss&quot;,
<span class="p_chunk">@@ -66,6 +67,7 @@</span> <span class="p_context"> static struct sun4i_ss_alg_template ss_algs[] = {</span>
 		.import = sun4i_hash_import_sha1,
 		.halg = {
 			.digestsize = SHA1_DIGEST_SIZE,
<span class="p_add">+			.statesize = sizeof(struct sha1_state),</span>
 			.base = {
 				.cra_name = &quot;sha1&quot;,
 				.cra_driver_name = &quot;sha1-sun4i-ss&quot;,
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 3b20a1bce703..8b327d89a8fc 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -1015,7 +1015,7 @@</span> <span class="p_context"> static void ipsec_esp_decrypt_swauth_done(struct device *dev,</span>
 		} else
 			oicv = (char *)&amp;edesc-&gt;link_tbl[0];
 
<span class="p_del">-		err = memcmp(oicv, icv, authsize) ? -EBADMSG : 0;</span>
<span class="p_add">+		err = crypto_memneq(oicv, icv, authsize) ? -EBADMSG : 0;</span>
 	}
 
 	kfree(edesc);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/base.c b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/base.c</span>
<span class="p_header">index 27a79c0c3888..d95eb8659d1b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/base.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/pmu/base.c</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"></span>
 void
 nvkm_pmu_pgob(struct nvkm_pmu *pmu, bool enable)
 {
<span class="p_del">-	if (pmu-&gt;func-&gt;pgob)</span>
<span class="p_add">+	if (pmu &amp;&amp; pmu-&gt;func-&gt;pgob)</span>
 		pmu-&gt;func-&gt;pgob(pmu, enable);
 }
 
<span class="p_header">diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c</span>
<span class="p_header">index 426b2f1a3450..33dfcea5fbc9 100644</span>
<span class="p_header">--- a/drivers/hid/hid-multitouch.c</span>
<span class="p_header">+++ b/drivers/hid/hid-multitouch.c</span>
<span class="p_chunk">@@ -309,6 +309,41 @@</span> <span class="p_context"> static struct attribute_group mt_attribute_group = {</span>
 	.attrs = sysfs_attrs
 };
 
<span class="p_add">+static void mt_get_feature(struct hid_device *hdev, struct hid_report *report)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mt_device *td = hid_get_drvdata(hdev);</span>
<span class="p_add">+	int ret, size = hid_report_len(report);</span>
<span class="p_add">+	u8 *buf;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only fetch the feature report if initial reports are not already</span>
<span class="p_add">+	 * been retrieved. Currently this is only done for Windows 8 touch</span>
<span class="p_add">+	 * devices.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(hdev-&gt;quirks &amp; HID_QUIRK_NO_INIT_REPORTS))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (td-&gt;mtclass.name != MT_CLS_WIN_8)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	buf = hid_alloc_report_buf(report, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hid_hw_raw_request(hdev, report-&gt;id, buf, size,</span>
<span class="p_add">+				 HID_FEATURE_REPORT, HID_REQ_GET_REPORT);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_warn(&amp;hdev-&gt;dev, &quot;failed to fetch feature %d\n&quot;,</span>
<span class="p_add">+			 report-&gt;id);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret = hid_report_raw_event(hdev, HID_FEATURE_REPORT, buf,</span>
<span class="p_add">+					   size, 0);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			dev_warn(&amp;hdev-&gt;dev, &quot;failed to report feature\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(buf);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void mt_feature_mapping(struct hid_device *hdev,
 		struct hid_field *field, struct hid_usage *usage)
 {
<span class="p_chunk">@@ -322,11 +357,24 @@</span> <span class="p_context"> static void mt_feature_mapping(struct hid_device *hdev,</span>
 			break;
 		}
 
<span class="p_del">-		td-&gt;inputmode = field-&gt;report-&gt;id;</span>
<span class="p_del">-		td-&gt;inputmode_index = usage-&gt;usage_index;</span>
<span class="p_add">+		if (td-&gt;inputmode &lt; 0) {</span>
<span class="p_add">+			td-&gt;inputmode = field-&gt;report-&gt;id;</span>
<span class="p_add">+			td-&gt;inputmode_index = usage-&gt;usage_index;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Some elan panels wrongly declare 2 input mode</span>
<span class="p_add">+			 * features, and silently ignore when we set the</span>
<span class="p_add">+			 * value in the second field. Skip the second feature</span>
<span class="p_add">+			 * and hope for the best.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dev_info(&amp;hdev-&gt;dev,</span>
<span class="p_add">+				 &quot;Ignoring the extra HID_DG_INPUTMODE\n&quot;);</span>
<span class="p_add">+		}</span>
 
 		break;
 	case HID_DG_CONTACTMAX:
<span class="p_add">+		mt_get_feature(hdev, field-&gt;report);</span>
<span class="p_add">+</span>
 		td-&gt;maxcontact_report_id = field-&gt;report-&gt;id;
 		td-&gt;maxcontacts = field-&gt;value[0];
 		if (!td-&gt;maxcontacts &amp;&amp;
<span class="p_chunk">@@ -343,6 +391,7 @@</span> <span class="p_context"> static void mt_feature_mapping(struct hid_device *hdev,</span>
 			break;
 		}
 
<span class="p_add">+		mt_get_feature(hdev, field-&gt;report);</span>
 		if (field-&gt;value[usage-&gt;usage_index] == MT_BUTTONTYPE_CLICKPAD)
 			td-&gt;is_buttonpad = true;
 
<span class="p_chunk">@@ -1026,8 +1075,13 @@</span> <span class="p_context"> static int mt_probe(struct hid_device *hdev, const struct hid_device_id *id)</span>
 		 * reports. Fortunately, the Win8 spec says that all touches
 		 * should be sent during each report, making the initialization
 		 * of input reports unnecessary.
<span class="p_add">+		 *</span>
<span class="p_add">+		 * In addition some touchpads do not behave well if we read</span>
<span class="p_add">+		 * all feature reports from them. Instead we prevent</span>
<span class="p_add">+		 * initial report fetching and then selectively fetch each</span>
<span class="p_add">+		 * report we are interested in.</span>
 		 */
<span class="p_del">-		hdev-&gt;quirks |= HID_QUIRK_NO_INIT_INPUT_REPORTS;</span>
<span class="p_add">+		hdev-&gt;quirks |= HID_QUIRK_NO_INIT_REPORTS;</span>
 
 	td = devm_kzalloc(&amp;hdev-&gt;dev, sizeof(struct mt_device), GFP_KERNEL);
 	if (!td) {
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">index 36712e9f56c2..5dd426fee8cc 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_chunk">@@ -477,8 +477,6 @@</span> <span class="p_context"> static void hid_ctrl(struct urb *urb)</span>
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int unplug = 0, status = urb-&gt;status;
 
<span class="p_del">-	spin_lock(&amp;usbhid-&gt;lock);</span>
<span class="p_del">-</span>
 	switch (status) {
 	case 0:			/* success */
 		if (usbhid-&gt;ctrl[usbhid-&gt;ctrltail].dir == USB_DIR_IN)
<span class="p_chunk">@@ -498,6 +496,8 @@</span> <span class="p_context"> static void hid_ctrl(struct urb *urb)</span>
 		hid_warn(urb-&gt;dev, &quot;ctrl urb status %d received\n&quot;, status);
 	}
 
<span class="p_add">+	spin_lock(&amp;usbhid-&gt;lock);</span>
<span class="p_add">+</span>
 	if (unplug) {
 		usbhid-&gt;ctrltail = usbhid-&gt;ctrlhead;
 	} else {
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">index 1c758cd1e1ba..10835d1f559b 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_chunk">@@ -347,8 +347,14 @@</span> <span class="p_context"> error:</span>
 
 static void at91_twi_read_next_byte(struct at91_twi_dev *dev)
 {
<span class="p_del">-	if (!dev-&gt;buf_len)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are in this case, it means there is garbage data in RHR, so</span>
<span class="p_add">+	 * delete them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!dev-&gt;buf_len) {</span>
<span class="p_add">+		at91_twi_read(dev, AT91_TWI_RHR);</span>
 		return;
<span class="p_add">+	}</span>
 
 	/* 8bit read works with and without FIFO */
 	*dev-&gt;buf = readb_relaxed(dev-&gt;base + AT91_TWI_RHR);
<span class="p_chunk">@@ -465,19 +471,73 @@</span> <span class="p_context"> static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)</span>
 
 	if (!irqstatus)
 		return IRQ_NONE;
<span class="p_del">-	else if (irqstatus &amp; AT91_TWI_RXRDY)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In reception, the behavior of the twi device (before sama5d2) is</span>
<span class="p_add">+	 * weird. There is some magic about RXRDY flag! When a data has been</span>
<span class="p_add">+	 * almost received, the reception of a new one is anticipated if there</span>
<span class="p_add">+	 * is no stop command to send. That is the reason why ask for sending</span>
<span class="p_add">+	 * the stop command not on the last data but on the second last one.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Unfortunately, we could still have the RXRDY flag set even if the</span>
<span class="p_add">+	 * transfer is done and we have read the last data. It might happen</span>
<span class="p_add">+	 * when the i2c slave device sends too quickly data after receiving the</span>
<span class="p_add">+	 * ack from the master. The data has been almost received before having</span>
<span class="p_add">+	 * the order to send stop. In this case, sending the stop command could</span>
<span class="p_add">+	 * cause a RXRDY interrupt with a TXCOMP one. It is better to manage</span>
<span class="p_add">+	 * the RXRDY interrupt first in order to not keep garbage data in the</span>
<span class="p_add">+	 * Receive Holding Register for the next transfer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (irqstatus &amp; AT91_TWI_RXRDY)</span>
 		at91_twi_read_next_byte(dev);
<span class="p_del">-	else if (irqstatus &amp; AT91_TWI_TXRDY)</span>
<span class="p_del">-		at91_twi_write_next_byte(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* catch error flags */</span>
<span class="p_del">-	dev-&gt;transfer_status |= status;</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When a NACK condition is detected, the I2C controller sets the NACK,</span>
<span class="p_add">+	 * TXCOMP and TXRDY bits all together in the Status Register (SR).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 1 - Handling NACK errors with CPU write transfer.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * In such case, we should not write the next byte into the Transmit</span>
<span class="p_add">+	 * Holding Register (THR) otherwise the I2C controller would start a new</span>
<span class="p_add">+	 * transfer and the I2C slave is likely to reply by another NACK.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 2 - Handling NACK errors with DMA write transfer.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * By setting the TXRDY bit in the SR, the I2C controller also triggers</span>
<span class="p_add">+	 * the DMA controller to write the next data into the THR. Then the</span>
<span class="p_add">+	 * result depends on the hardware version of the I2C controller.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 2a - Without support of the Alternative Command mode.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This is the worst case: the DMA controller is triggered to write the</span>
<span class="p_add">+	 * next data into the THR, hence starting a new transfer: the I2C slave</span>
<span class="p_add">+	 * is likely to reply by another NACK.</span>
<span class="p_add">+	 * Concurrently, this interrupt handler is likely to be called to manage</span>
<span class="p_add">+	 * the first NACK before the I2C controller detects the second NACK and</span>
<span class="p_add">+	 * sets once again the NACK bit into the SR.</span>
<span class="p_add">+	 * When handling the first NACK, this interrupt handler disables the I2C</span>
<span class="p_add">+	 * controller interruptions, especially the NACK interrupt.</span>
<span class="p_add">+	 * Hence, the NACK bit is pending into the SR. This is why we should</span>
<span class="p_add">+	 * read the SR to clear all pending interrupts at the beginning of</span>
<span class="p_add">+	 * at91_do_twi_transfer() before actually starting a new transfer.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * 2b - With support of the Alternative Command mode.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * When a NACK condition is detected, the I2C controller also locks the</span>
<span class="p_add">+	 * THR (and sets the LOCK bit in the SR): even though the DMA controller</span>
<span class="p_add">+	 * is triggered by the TXRDY bit to write the next data into the THR,</span>
<span class="p_add">+	 * this data actually won&#39;t go on the I2C bus hence a second NACK is not</span>
<span class="p_add">+	 * generated.</span>
<span class="p_add">+	 */</span>
 	if (irqstatus &amp; (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {
 		at91_disable_twi_interrupts(dev);
 		complete(&amp;dev-&gt;cmd_complete);
<span class="p_add">+	} else if (irqstatus &amp; AT91_TWI_TXRDY) {</span>
<span class="p_add">+		at91_twi_write_next_byte(dev);</span>
 	}
 
<span class="p_add">+	/* catch error flags */</span>
<span class="p_add">+	dev-&gt;transfer_status |= status;</span>
<span class="p_add">+</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_chunk">@@ -537,6 +597,9 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	reinit_completion(&amp;dev-&gt;cmd_complete);
 	dev-&gt;transfer_status = 0;
 
<span class="p_add">+	/* Clear pending interrupts, such as NACK. */</span>
<span class="p_add">+	at91_twi_read(dev, AT91_TWI_SR);</span>
<span class="p_add">+</span>
 	if (dev-&gt;fifo_size) {
 		unsigned fifo_mr = at91_twi_read(dev, AT91_TWI_FMR);
 
<span class="p_chunk">@@ -558,11 +621,6 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	} else if (dev-&gt;msg-&gt;flags &amp; I2C_M_RD) {
 		unsigned start_flags = AT91_TWI_START;
 
<span class="p_del">-		if (at91_twi_read(dev, AT91_TWI_SR) &amp; AT91_TWI_RXRDY) {</span>
<span class="p_del">-			dev_err(dev-&gt;dev, &quot;RXRDY still set!&quot;);</span>
<span class="p_del">-			at91_twi_read(dev, AT91_TWI_RHR);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		/* if only one byte is to be read, immediately stop transfer */
 		if (!has_alt_cmd &amp;&amp; dev-&gt;buf_len &lt;= 1 &amp;&amp;
 		    !(dev-&gt;msg-&gt;flags &amp; I2C_M_RECV_LEN))
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">index 5801227b97ab..43207f52e5a3 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_chunk">@@ -146,6 +146,8 @@</span> <span class="p_context"> struct mv64xxx_i2c_data {</span>
 	bool			errata_delay;
 	struct reset_control	*rstc;
 	bool			irq_clear_inverted;
<span class="p_add">+	/* Clk div is 2 to the power n, not 2 to the power n + 1 */</span>
<span class="p_add">+	bool			clk_n_base_0;</span>
 };
 
 static struct mv64xxx_i2c_regs mv64xxx_i2c_regs_mv64xxx = {
<span class="p_chunk">@@ -757,25 +759,29 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, mv64xxx_i2c_of_match_table);</span>
 #ifdef CONFIG_OF
 #ifdef CONFIG_HAVE_CLK
 static int
<span class="p_del">-mv64xxx_calc_freq(const int tclk, const int n, const int m)</span>
<span class="p_add">+mv64xxx_calc_freq(struct mv64xxx_i2c_data *drv_data,</span>
<span class="p_add">+		  const int tclk, const int n, const int m)</span>
 {
<span class="p_del">-	return tclk / (10 * (m + 1) * (2 &lt;&lt; n));</span>
<span class="p_add">+	if (drv_data-&gt;clk_n_base_0)</span>
<span class="p_add">+		return tclk / (10 * (m + 1) * (1 &lt;&lt; n));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return tclk / (10 * (m + 1) * (2 &lt;&lt; n));</span>
 }
 
 static bool
<span class="p_del">-mv64xxx_find_baud_factors(const u32 req_freq, const u32 tclk, u32 *best_n,</span>
<span class="p_del">-			  u32 *best_m)</span>
<span class="p_add">+mv64xxx_find_baud_factors(struct mv64xxx_i2c_data *drv_data,</span>
<span class="p_add">+			  const u32 req_freq, const u32 tclk)</span>
 {
 	int freq, delta, best_delta = INT_MAX;
 	int m, n;
 
 	for (n = 0; n &lt;= 7; n++)
 		for (m = 0; m &lt;= 15; m++) {
<span class="p_del">-			freq = mv64xxx_calc_freq(tclk, n, m);</span>
<span class="p_add">+			freq = mv64xxx_calc_freq(drv_data, tclk, n, m);</span>
 			delta = req_freq - freq;
 			if (delta &gt;= 0 &amp;&amp; delta &lt; best_delta) {
<span class="p_del">-				*best_m = m;</span>
<span class="p_del">-				*best_n = n;</span>
<span class="p_add">+				drv_data-&gt;freq_m = m;</span>
<span class="p_add">+				drv_data-&gt;freq_n = n;</span>
 				best_delta = delta;
 			}
 			if (best_delta == 0)
<span class="p_chunk">@@ -813,8 +819,11 @@</span> <span class="p_context"> mv64xxx_of_config(struct mv64xxx_i2c_data *drv_data,</span>
 	if (of_property_read_u32(np, &quot;clock-frequency&quot;, &amp;bus_freq))
 		bus_freq = 100000; /* 100kHz by default */
 
<span class="p_del">-	if (!mv64xxx_find_baud_factors(bus_freq, tclk,</span>
<span class="p_del">-				       &amp;drv_data-&gt;freq_n, &amp;drv_data-&gt;freq_m)) {</span>
<span class="p_add">+	if (of_device_is_compatible(np, &quot;allwinner,sun4i-a10-i2c&quot;) ||</span>
<span class="p_add">+	    of_device_is_compatible(np, &quot;allwinner,sun6i-a31-i2c&quot;))</span>
<span class="p_add">+		drv_data-&gt;clk_n_base_0 = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mv64xxx_find_baud_factors(drv_data, bus_freq, tclk)) {</span>
 		rc = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-rcar.c b/drivers/i2c/busses/i2c-rcar.c</span>
<span class="p_header">index d8b5a8fee1e6..3191dd9984dc 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-rcar.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-rcar.c</span>
<span class="p_chunk">@@ -575,7 +575,7 @@</span> <span class="p_context"> static int rcar_reg_slave(struct i2c_client *slave)</span>
 	if (slave-&gt;flags &amp; I2C_CLIENT_TEN)
 		return -EAFNOSUPPORT;
 
<span class="p_del">-	pm_runtime_forbid(rcar_i2c_priv_to_dev(priv));</span>
<span class="p_add">+	pm_runtime_get_sync(rcar_i2c_priv_to_dev(priv));</span>
 
 	priv-&gt;slave = slave;
 	rcar_i2c_write(priv, ICSAR, slave-&gt;addr);
<span class="p_chunk">@@ -597,7 +597,7 @@</span> <span class="p_context"> static int rcar_unreg_slave(struct i2c_client *slave)</span>
 
 	priv-&gt;slave = NULL;
 
<span class="p_del">-	pm_runtime_allow(rcar_i2c_priv_to_dev(priv));</span>
<span class="p_add">+	pm_runtime_put(rcar_i2c_priv_to_dev(priv));</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">index 72e97e306bd9..9c4efd308f10 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_chunk">@@ -907,7 +907,7 @@</span> <span class="p_context"> static int rk3x_i2c_probe(struct platform_device *pdev)</span>
 				 &amp;i2c-&gt;scl_fall_ns))
 		i2c-&gt;scl_fall_ns = 300;
 	if (of_property_read_u32(pdev-&gt;dev.of_node, &quot;i2c-sda-falling-time-ns&quot;,
<span class="p_del">-				 &amp;i2c-&gt;scl_fall_ns))</span>
<span class="p_add">+				 &amp;i2c-&gt;sda_fall_ns))</span>
 		i2c-&gt;sda_fall_ns = i2c-&gt;scl_fall_ns;
 
 	strlcpy(i2c-&gt;adap.name, &quot;rk3x-i2c&quot;, sizeof(i2c-&gt;adap.name));
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index a59c3111f7fb..a4347ba78a51 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -679,7 +679,7 @@</span> <span class="p_context"> static int i2c_device_probe(struct device *dev)</span>
 		if (wakeirq &gt; 0 &amp;&amp; wakeirq != client-&gt;irq)
 			status = dev_pm_set_dedicated_wake_irq(dev, wakeirq);
 		else if (client-&gt;irq &gt; 0)
<span class="p_del">-			status = dev_pm_set_wake_irq(dev, wakeirq);</span>
<span class="p_add">+			status = dev_pm_set_wake_irq(dev, client-&gt;irq);</span>
 		else
 			status = 0;
 
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">index 7df97777662d..dad768caa9c5 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_chunk">@@ -405,17 +405,18 @@</span> <span class="p_context"> static void __arm_lpae_free_pgtable(struct arm_lpae_io_pgtable *data, int lvl,</span>
 	arm_lpae_iopte *start, *end;
 	unsigned long table_size;
 
<span class="p_del">-	/* Only leaf entries at the last level */</span>
<span class="p_del">-	if (lvl == ARM_LPAE_MAX_LEVELS - 1)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	if (lvl == ARM_LPAE_START_LVL(data))
 		table_size = data-&gt;pgd_size;
 	else
 		table_size = 1UL &lt;&lt; data-&gt;pg_shift;
 
 	start = ptep;
<span class="p_del">-	end = (void *)ptep + table_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only leaf entries at the last level */</span>
<span class="p_add">+	if (lvl == ARM_LPAE_MAX_LEVELS - 1)</span>
<span class="p_add">+		end = ptep;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		end = (void *)ptep + table_size;</span>
 
 	while (ptep != end) {
 		arm_lpae_iopte pte = *ptep++;
<span class="p_header">diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c</span>
<span class="p_header">index 5a67671a3973..bdc96cd838b8 100644</span>
<span class="p_header">--- a/drivers/md/dm-mpath.c</span>
<span class="p_header">+++ b/drivers/md/dm-mpath.c</span>
<span class="p_chunk">@@ -1569,11 +1569,8 @@</span> <span class="p_context"> static int multipath_ioctl(struct dm_target *ti, unsigned int cmd,</span>
 	/*
 	 * Only pass ioctls through if the device sizes match exactly.
 	 */
<span class="p_del">-	if (!bdev || ti-&gt;len != i_size_read(bdev-&gt;bd_inode) &gt;&gt; SECTOR_SHIFT) {</span>
<span class="p_del">-		int err = scsi_verify_blk_ioctl(NULL, cmd);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			r = err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!r &amp;&amp; ti-&gt;len != i_size_read(bdev-&gt;bd_inode) &gt;&gt; SECTOR_SHIFT)</span>
<span class="p_add">+		r = scsi_verify_blk_ioctl(NULL, cmd);</span>
 
 	if (r == -ENOTCONN &amp;&amp; !fatal_signal_pending(current)) {
 		spin_lock_irqsave(&amp;m-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 1b5c6047e4f1..8af4750f20bf 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -2198,6 +2198,13 @@</span> <span class="p_context"> static void dm_init_md_queue(struct mapped_device *md)</span>
 	 * This queue is new, so no concurrency on the queue_flags.
 	 */
 	queue_flag_clear_unlocked(QUEUE_FLAG_STACKABLE, md-&gt;queue);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initialize data that will only be used by a non-blk-mq DM queue</span>
<span class="p_add">+	 * - must do so here (in alloc_dev callchain) before queue is used</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	md-&gt;queue-&gt;queuedata = md;</span>
<span class="p_add">+	md-&gt;queue-&gt;backing_dev_info.congested_data = md;</span>
 }
 
 static void dm_init_old_md_queue(struct mapped_device *md)
<span class="p_chunk">@@ -2208,10 +2215,7 @@</span> <span class="p_context"> static void dm_init_old_md_queue(struct mapped_device *md)</span>
 	/*
 	 * Initialize aspects of queue that aren&#39;t relevant for blk-mq
 	 */
<span class="p_del">-	md-&gt;queue-&gt;queuedata = md;</span>
 	md-&gt;queue-&gt;backing_dev_info.congested_fn = dm_any_congested;
<span class="p_del">-	md-&gt;queue-&gt;backing_dev_info.congested_data = md;</span>
<span class="p_del">-</span>
 	blk_queue_bounce_limit(md-&gt;queue, BLK_BOUNCE_ANY);
 }
 
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 0e09aef43998..88c287db3bde 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -471,8 +471,10 @@</span> <span class="p_context"> static int btree_split_sibling(struct shadow_spine *s, unsigned parent_index,</span>
 
 	r = insert_at(sizeof(__le64), pn, parent_index + 1,
 		      le64_to_cpu(rn-&gt;keys[0]), &amp;location);
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		unlock_block(s-&gt;info, right);</span>
 		return r;
<span class="p_add">+	}</span>
 
 	if (key &lt; le64_to_cpu(rn-&gt;keys[0])) {
 		unlock_block(s-&gt;info, right);
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 96f365968306..23bbe61f9ac0 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -1944,6 +1944,8 @@</span> <span class="p_context"> static void sync_request_write(struct mddev *mddev, struct r10bio *r10_bio)</span>
 
 	first = i;
 	fbio = r10_bio-&gt;devs[i].bio;
<span class="p_add">+	fbio-&gt;bi_iter.bi_size = r10_bio-&gt;sectors &lt;&lt; 9;</span>
<span class="p_add">+	fbio-&gt;bi_iter.bi_idx = 0;</span>
 
 	vcnt = (r10_bio-&gt;sectors + (PAGE_SIZE &gt;&gt; 9) - 1) &gt;&gt; (PAGE_SHIFT - 9);
 	/* now find blocks with errors */
<span class="p_chunk">@@ -1987,7 +1989,7 @@</span> <span class="p_context"> static void sync_request_write(struct mddev *mddev, struct r10bio *r10_bio)</span>
 		bio_reset(tbio);
 
 		tbio-&gt;bi_vcnt = vcnt;
<span class="p_del">-		tbio-&gt;bi_iter.bi_size = r10_bio-&gt;sectors &lt;&lt; 9;</span>
<span class="p_add">+		tbio-&gt;bi_iter.bi_size = fbio-&gt;bi_iter.bi_size;</span>
 		tbio-&gt;bi_rw = WRITE;
 		tbio-&gt;bi_private = r10_bio;
 		tbio-&gt;bi_iter.bi_sector = r10_bio-&gt;devs[i].addr;
<span class="p_header">diff --git a/drivers/media/i2c/ir-kbd-i2c.c b/drivers/media/i2c/ir-kbd-i2c.c</span>
<span class="p_header">index 728d2cc8a3e7..175a76114953 100644</span>
<span class="p_header">--- a/drivers/media/i2c/ir-kbd-i2c.c</span>
<span class="p_header">+++ b/drivers/media/i2c/ir-kbd-i2c.c</span>
<span class="p_chunk">@@ -478,7 +478,6 @@</span> <span class="p_context"> static const struct i2c_device_id ir_kbd_id[] = {</span>
 	{ &quot;ir_rx_z8f0811_hdpvr&quot;, 0 },
 	{ }
 };
<span class="p_del">-MODULE_DEVICE_TABLE(i2c, ir_kbd_id);</span>
 
 static struct i2c_driver ir_kbd_driver = {
 	.driver = {
<span class="p_header">diff --git a/drivers/media/pci/ivtv/ivtv-driver.c b/drivers/media/pci/ivtv/ivtv-driver.c</span>
<span class="p_header">index 8616fa8193bc..c2e60b4f292d 100644</span>
<span class="p_header">--- a/drivers/media/pci/ivtv/ivtv-driver.c</span>
<span class="p_header">+++ b/drivers/media/pci/ivtv/ivtv-driver.c</span>
<span class="p_chunk">@@ -805,11 +805,11 @@</span> <span class="p_context"> static void ivtv_init_struct2(struct ivtv *itv)</span>
 {
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; IVTV_CARD_MAX_VIDEO_INPUTS - 1; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; IVTV_CARD_MAX_VIDEO_INPUTS; i++)</span>
 		if (itv-&gt;card-&gt;video_inputs[i].video_type == 0)
 			break;
 	itv-&gt;nof_inputs = i;
<span class="p_del">-	for (i = 0; i &lt; IVTV_CARD_MAX_AUDIO_INPUTS - 1; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; IVTV_CARD_MAX_AUDIO_INPUTS; i++)</span>
 		if (itv-&gt;card-&gt;audio_inputs[i].audio_type == 0)
 			break;
 	itv-&gt;nof_audio_inputs = i;
<span class="p_header">diff --git a/drivers/media/pci/saa7134/saa7134-alsa.c b/drivers/media/pci/saa7134/saa7134-alsa.c</span>
<span class="p_header">index 1d2c310ce838..94f816244407 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7134/saa7134-alsa.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7134/saa7134-alsa.c</span>
<span class="p_chunk">@@ -1211,6 +1211,8 @@</span> <span class="p_context"> static int alsa_device_init(struct saa7134_dev *dev)</span>
 
 static int alsa_device_exit(struct saa7134_dev *dev)
 {
<span class="p_add">+	if (!snd_saa7134_cards[dev-&gt;nr])</span>
<span class="p_add">+		return 1;</span>
 
 	snd_card_free(snd_saa7134_cards[dev-&gt;nr]);
 	snd_saa7134_cards[dev-&gt;nr] = NULL;
<span class="p_chunk">@@ -1260,7 +1262,8 @@</span> <span class="p_context"> static void saa7134_alsa_exit(void)</span>
 	int idx;
 
 	for (idx = 0; idx &lt; SNDRV_CARDS; idx++) {
<span class="p_del">-		snd_card_free(snd_saa7134_cards[idx]);</span>
<span class="p_add">+		if (snd_saa7134_cards[idx])</span>
<span class="p_add">+			snd_card_free(snd_saa7134_cards[idx]);</span>
 	}
 
 	saa7134_dmasound_init = NULL;
<span class="p_header">diff --git a/drivers/media/platform/sti/c8sectpfe/Kconfig b/drivers/media/platform/sti/c8sectpfe/Kconfig</span>
<span class="p_header">index 641ad8f34956..7420a50572d3 100644</span>
<span class="p_header">--- a/drivers/media/platform/sti/c8sectpfe/Kconfig</span>
<span class="p_header">+++ b/drivers/media/platform/sti/c8sectpfe/Kconfig</span>
<span class="p_chunk">@@ -3,7 +3,6 @@</span> <span class="p_context"> config DVB_C8SECTPFE</span>
 	depends on PINCTRL &amp;&amp; DVB_CORE &amp;&amp; I2C
 	depends on ARCH_STI || ARCH_MULTIPLATFORM || COMPILE_TEST
 	select FW_LOADER
<span class="p_del">-	select FW_LOADER_USER_HELPER_FALLBACK</span>
 	select DEBUG_FS
 	select DVB_LNBP21 if MEDIA_SUBDRV_AUTOSELECT
 	select DVB_STV090x if MEDIA_SUBDRV_AUTOSELECT
<span class="p_header">diff --git a/drivers/media/platform/vivid/vivid-core.c b/drivers/media/platform/vivid/vivid-core.c</span>
<span class="p_header">index a047b4716741..0f5e9143cc7e 100644</span>
<span class="p_header">--- a/drivers/media/platform/vivid/vivid-core.c</span>
<span class="p_header">+++ b/drivers/media/platform/vivid/vivid-core.c</span>
<span class="p_chunk">@@ -1341,8 +1341,11 @@</span> <span class="p_context"> static int vivid_remove(struct platform_device *pdev)</span>
 	struct vivid_dev *dev;
 	unsigned i;
 
<span class="p_del">-	for (i = 0; vivid_devs[i]; i++) {</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; n_devs; i++) {</span>
 		dev = vivid_devs[i];
<span class="p_add">+		if (!dev)</span>
<span class="p_add">+			continue;</span>
 
 		if (dev-&gt;has_vid_cap) {
 			v4l2_info(&amp;dev-&gt;v4l2_dev, &quot;unregistering %s\n&quot;,
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">index af635430524e..788b31c91330 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static int put_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_</span>
 
 struct v4l2_standard32 {
 	__u32		     index;
<span class="p_del">-	__u32		     id[2]; /* __u64 would get the alignment wrong */</span>
<span class="p_add">+	compat_u64	     id;</span>
 	__u8		     name[24];
 	struct v4l2_fract    frameperiod; /* Frames, not fields */
 	__u32		     framelines;
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> static int put_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32</span>
 {
 	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_standard32)) ||
 		put_user(kp-&gt;index, &amp;up-&gt;index) ||
<span class="p_del">-		copy_to_user(up-&gt;id, &amp;kp-&gt;id, sizeof(__u64)) ||</span>
<span class="p_add">+		put_user(kp-&gt;id, &amp;up-&gt;id) ||</span>
 		copy_to_user(up-&gt;name, kp-&gt;name, 24) ||
 		copy_to_user(&amp;up-&gt;frameperiod, &amp;kp-&gt;frameperiod, sizeof(kp-&gt;frameperiod)) ||
 		put_user(kp-&gt;framelines, &amp;up-&gt;framelines) ||
<span class="p_chunk">@@ -587,10 +587,10 @@</span> <span class="p_context"> struct v4l2_input32 {</span>
 	__u32	     type;		/*  Type of input */
 	__u32	     audioset;		/*  Associated audios (bitfield) */
 	__u32        tuner;             /*  Associated tuner */
<span class="p_del">-	v4l2_std_id  std;</span>
<span class="p_add">+	compat_u64   std;</span>
 	__u32	     status;
 	__u32	     reserved[4];
<span class="p_del">-} __attribute__ ((packed));</span>
<span class="p_add">+};</span>
 
 /* The 64-bit v4l2_input struct has extra padding at the end of the struct.
    Otherwise it is identical to the 32-bit version. */
<span class="p_chunk">@@ -738,6 +738,7 @@</span> <span class="p_context"> static int put_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext</span>
 struct v4l2_event32 {
 	__u32				type;
 	union {
<span class="p_add">+		compat_s64		value64;</span>
 		__u8			data[64];
 	} u;
 	__u32				pending;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-ctrls.c b/drivers/media/v4l2-core/v4l2-ctrls.c</span>
<span class="p_header">index b6b7dcc1b77d..e1e70b8694a8 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-ctrls.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-ctrls.c</span>
<span class="p_chunk">@@ -2498,7 +2498,7 @@</span> <span class="p_context"> int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctr</span>
 			/* We found a control with the given ID, so just get
 			   the next valid one in the list. */
 			list_for_each_entry_continue(ref, &amp;hdl-&gt;ctrl_refs, node) {
<span class="p_del">-				is_compound =</span>
<span class="p_add">+				is_compound = ref-&gt;ctrl-&gt;is_array ||</span>
 					ref-&gt;ctrl-&gt;type &gt;= V4L2_CTRL_COMPOUND_TYPES;
 				if (id &lt; ref-&gt;ctrl-&gt;id &amp;&amp;
 				    (is_compound &amp; mask) == match)
<span class="p_chunk">@@ -2512,7 +2512,7 @@</span> <span class="p_context"> int v4l2_query_ext_ctrl(struct v4l2_ctrl_handler *hdl, struct v4l2_query_ext_ctr</span>
 			   is one, otherwise the first &#39;if&#39; above would have
 			   been true. */
 			list_for_each_entry(ref, &amp;hdl-&gt;ctrl_refs, node) {
<span class="p_del">-				is_compound =</span>
<span class="p_add">+				is_compound = ref-&gt;ctrl-&gt;is_array ||</span>
 					ref-&gt;ctrl-&gt;type &gt;= V4L2_CTRL_COMPOUND_TYPES;
 				if (id &lt; ref-&gt;ctrl-&gt;id &amp;&amp;
 				    (is_compound &amp; mask) == match)
<span class="p_chunk">@@ -2884,7 +2884,7 @@</span> <span class="p_context"> static int get_ctrl(struct v4l2_ctrl *ctrl, struct v4l2_ext_control *c)</span>
 	 * cur_to_user() calls below would need to be modified not to access
 	 * userspace memory when called from get_ctrl().
 	 */
<span class="p_del">-	if (!ctrl-&gt;is_int)</span>
<span class="p_add">+	if (!ctrl-&gt;is_int &amp;&amp; ctrl-&gt;type != V4L2_CTRL_TYPE_INTEGER64)</span>
 		return -EINVAL;
 
 	if (ctrl-&gt;flags &amp; V4L2_CTRL_FLAG_WRITE_ONLY)
<span class="p_chunk">@@ -2942,9 +2942,9 @@</span> <span class="p_context"> s64 v4l2_ctrl_g_ctrl_int64(struct v4l2_ctrl *ctrl)</span>
 
 	/* It&#39;s a driver bug if this happens. */
 	WARN_ON(ctrl-&gt;is_ptr || ctrl-&gt;type != V4L2_CTRL_TYPE_INTEGER64);
<span class="p_del">-	c.value = 0;</span>
<span class="p_add">+	c.value64 = 0;</span>
 	get_ctrl(ctrl, &amp;c);
<span class="p_del">-	return c.value;</span>
<span class="p_add">+	return c.value64;</span>
 }
 EXPORT_SYMBOL(v4l2_ctrl_g_ctrl_int64);
 
<span class="p_chunk">@@ -3043,7 +3043,7 @@</span> <span class="p_context"> static void update_from_auto_cluster(struct v4l2_ctrl *master)</span>
 {
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; master-&gt;ncontrols; i++)</span>
<span class="p_add">+	for (i = 1; i &lt; master-&gt;ncontrols; i++)</span>
 		cur_to_new(master-&gt;cluster[i]);
 	if (!call_op(master, g_volatile_ctrl))
 		for (i = 1; i &lt; master-&gt;ncontrols; i++)
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-dma-contig.c b/drivers/media/v4l2-core/videobuf2-dma-contig.c</span>
<span class="p_header">index 2397ceb1dc6b..f42e66624734 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-dma-contig.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-dma-contig.c</span>
<span class="p_chunk">@@ -100,7 +100,8 @@</span> <span class="p_context"> static void vb2_dc_prepare(void *buf_priv)</span>
 	if (!sgt || buf-&gt;db_attach)
 		return;
 
<span class="p_del">-	dma_sync_sg_for_device(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;nents, buf-&gt;dma_dir);</span>
<span class="p_add">+	dma_sync_sg_for_device(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;orig_nents,</span>
<span class="p_add">+			       buf-&gt;dma_dir);</span>
 }
 
 static void vb2_dc_finish(void *buf_priv)
<span class="p_chunk">@@ -112,7 +113,7 @@</span> <span class="p_context"> static void vb2_dc_finish(void *buf_priv)</span>
 	if (!sgt || buf-&gt;db_attach)
 		return;
 
<span class="p_del">-	dma_sync_sg_for_cpu(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;nents, buf-&gt;dma_dir);</span>
<span class="p_add">+	dma_sync_sg_for_cpu(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;orig_nents, buf-&gt;dma_dir);</span>
 }
 
 /*********************************************/
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-dma-sg.c b/drivers/media/v4l2-core/videobuf2-dma-sg.c</span>
<span class="p_header">index be7bd6535c9d..07bd2605c2b1 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-dma-sg.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-dma-sg.c</span>
<span class="p_chunk">@@ -210,7 +210,8 @@</span> <span class="p_context"> static void vb2_dma_sg_prepare(void *buf_priv)</span>
 	if (buf-&gt;db_attach)
 		return;
 
<span class="p_del">-	dma_sync_sg_for_device(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;nents, buf-&gt;dma_dir);</span>
<span class="p_add">+	dma_sync_sg_for_device(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;orig_nents,</span>
<span class="p_add">+			       buf-&gt;dma_dir);</span>
 }
 
 static void vb2_dma_sg_finish(void *buf_priv)
<span class="p_chunk">@@ -222,7 +223,7 @@</span> <span class="p_context"> static void vb2_dma_sg_finish(void *buf_priv)</span>
 	if (buf-&gt;db_attach)
 		return;
 
<span class="p_del">-	dma_sync_sg_for_cpu(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;nents, buf-&gt;dma_dir);</span>
<span class="p_add">+	dma_sync_sg_for_cpu(buf-&gt;dev, sgt-&gt;sgl, sgt-&gt;orig_nents, buf-&gt;dma_dir);</span>
 }
 
 static void *vb2_dma_sg_get_userptr(void *alloc_ctx, unsigned long vaddr,
<span class="p_header">diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">index 44dc965a2f7c..e7a02ed9fba8 100644</span>
<span class="p_header">--- a/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">+++ b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_chunk">@@ -192,8 +192,8 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 	if (!dev)
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
<span class="p_del">-	mutex_lock(&amp;dev-&gt;lock);</span>
 	mutex_lock(&amp;mtd_table_mutex);
<span class="p_add">+	mutex_lock(&amp;dev-&gt;lock);</span>
 
 	if (dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -217,8 +217,8 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 
 unlock:
 	dev-&gt;open++;
<span class="p_del">-	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	blktrans_dev_put(dev);
 	return ret;
 
<span class="p_chunk">@@ -228,8 +228,8 @@</span> <span class="p_context"> error_release:</span>
 error_put:
 	module_put(dev-&gt;tr-&gt;owner);
 	kref_put(&amp;dev-&gt;ref, blktrans_dev_release);
<span class="p_del">-	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	blktrans_dev_put(dev);
 	return ret;
 }
<span class="p_chunk">@@ -241,8 +241,8 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 	if (!dev)
 		return;
 
<span class="p_del">-	mutex_lock(&amp;dev-&gt;lock);</span>
 	mutex_lock(&amp;mtd_table_mutex);
<span class="p_add">+	mutex_lock(&amp;dev-&gt;lock);</span>
 
 	if (--dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -256,8 +256,8 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		__put_mtd_device(dev-&gt;mtd);
 	}
 unlock:
<span class="p_del">-	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	blktrans_dev_put(dev);
 }
 
<span class="p_header">diff --git a/drivers/mtd/mtdpart.c b/drivers/mtd/mtdpart.c</span>
<span class="p_header">index cafdb8855a79..919a936abc42 100644</span>
<span class="p_header">--- a/drivers/mtd/mtdpart.c</span>
<span class="p_header">+++ b/drivers/mtd/mtdpart.c</span>
<span class="p_chunk">@@ -664,8 +664,10 @@</span> <span class="p_context"> int add_mtd_partitions(struct mtd_info *master,</span>
 
 	for (i = 0; i &lt; nbparts; i++) {
 		slave = allocate_partition(master, parts + i, i, cur_offset);
<span class="p_del">-		if (IS_ERR(slave))</span>
<span class="p_add">+		if (IS_ERR(slave)) {</span>
<span class="p_add">+			del_mtd_partitions(master);</span>
 			return PTR_ERR(slave);
<span class="p_add">+		}</span>
 
 		mutex_lock(&amp;mtd_partitions_mutex);
 		list_add(&amp;slave-&gt;list, &amp;mtd_partitions);
<span class="p_header">diff --git a/drivers/mtd/nand/jz4740_nand.c b/drivers/mtd/nand/jz4740_nand.c</span>
<span class="p_header">index ebf2cce04cba..ca3270b1299c 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/jz4740_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/jz4740_nand.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/gpio.h&gt;
 
<span class="p_add">+#include &lt;asm/mach-jz4740/gpio.h&gt;</span>
 #include &lt;asm/mach-jz4740/jz4740_nand.h&gt;
 
 #define JZ_REG_NAND_CTRL	0x50
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index ceb68ca8277a..066f967e03b1 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2964,7 +2964,7 @@</span> <span class="p_context"> static void nand_resume(struct mtd_info *mtd)</span>
  */
 static void nand_shutdown(struct mtd_info *mtd)
 {
<span class="p_del">-	nand_get_device(mtd, FL_SHUTDOWN);</span>
<span class="p_add">+	nand_get_device(mtd, FL_PM_SUSPENDED);</span>
 }
 
 /* Set default functions */
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index eb4489f9082f..56065632a5b8 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -603,6 +603,7 @@</span> <span class="p_context"> static int schedule_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,</span>
 	return 0;
 }
 
<span class="p_add">+static int __erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk);</span>
 /**
  * do_sync_erase - run the erase worker synchronously.
  * @ubi: UBI device description object
<span class="p_chunk">@@ -615,20 +616,16 @@</span> <span class="p_context"> static int schedule_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,</span>
 static int do_sync_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,
 			 int vol_id, int lnum, int torture)
 {
<span class="p_del">-	struct ubi_work *wl_wrk;</span>
<span class="p_add">+	struct ubi_work wl_wrk;</span>
 
 	dbg_wl(&quot;sync erase of PEB %i&quot;, e-&gt;pnum);
 
<span class="p_del">-	wl_wrk = kmalloc(sizeof(struct ubi_work), GFP_NOFS);</span>
<span class="p_del">-	if (!wl_wrk)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	wl_wrk-&gt;e = e;</span>
<span class="p_del">-	wl_wrk-&gt;vol_id = vol_id;</span>
<span class="p_del">-	wl_wrk-&gt;lnum = lnum;</span>
<span class="p_del">-	wl_wrk-&gt;torture = torture;</span>
<span class="p_add">+	wl_wrk.e = e;</span>
<span class="p_add">+	wl_wrk.vol_id = vol_id;</span>
<span class="p_add">+	wl_wrk.lnum = lnum;</span>
<span class="p_add">+	wl_wrk.torture = torture;</span>
 
<span class="p_del">-	return erase_worker(ubi, wl_wrk, 0);</span>
<span class="p_add">+	return __erase_worker(ubi, &amp;wl_wrk);</span>
 }
 
 /**
<span class="p_chunk">@@ -1014,7 +1011,7 @@</span> <span class="p_context"> out_unlock:</span>
 }
 
 /**
<span class="p_del">- * erase_worker - physical eraseblock erase worker function.</span>
<span class="p_add">+ * __erase_worker - physical eraseblock erase worker function.</span>
  * @ubi: UBI device description object
  * @wl_wrk: the work object
  * @shutdown: non-zero if the worker has to free memory and exit
<span class="p_chunk">@@ -1025,8 +1022,7 @@</span> <span class="p_context"> out_unlock:</span>
  * needed. Returns zero in case of success and a negative error code in case of
  * failure.
  */
<span class="p_del">-static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
<span class="p_del">-			int shutdown)</span>
<span class="p_add">+static int __erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk)</span>
 {
 	struct ubi_wl_entry *e = wl_wrk-&gt;e;
 	int pnum = e-&gt;pnum;
<span class="p_chunk">@@ -1034,21 +1030,11 @@</span> <span class="p_context"> static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
 	int lnum = wl_wrk-&gt;lnum;
 	int err, available_consumed = 0;
 
<span class="p_del">-	if (shutdown) {</span>
<span class="p_del">-		dbg_wl(&quot;cancel erasure of PEB %d EC %d&quot;, pnum, e-&gt;ec);</span>
<span class="p_del">-		kfree(wl_wrk);</span>
<span class="p_del">-		wl_entry_destroy(ubi, e);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	dbg_wl(&quot;erase PEB %d EC %d LEB %d:%d&quot;,
 	       pnum, e-&gt;ec, wl_wrk-&gt;vol_id, wl_wrk-&gt;lnum);
 
 	err = sync_erase(ubi, e, wl_wrk-&gt;torture);
 	if (!err) {
<span class="p_del">-		/* Fine, we&#39;ve erased it successfully */</span>
<span class="p_del">-		kfree(wl_wrk);</span>
<span class="p_del">-</span>
 		spin_lock(&amp;ubi-&gt;wl_lock);
 		wl_tree_add(e, &amp;ubi-&gt;free);
 		ubi-&gt;free_count++;
<span class="p_chunk">@@ -1066,7 +1052,6 @@</span> <span class="p_context"> static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
 	}
 
 	ubi_err(ubi, &quot;failed to erase PEB %d, error %d&quot;, pnum, err);
<span class="p_del">-	kfree(wl_wrk);</span>
 
 	if (err == -EINTR || err == -ENOMEM || err == -EAGAIN ||
 	    err == -EBUSY) {
<span class="p_chunk">@@ -1075,6 +1060,7 @@</span> <span class="p_context"> static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
 		/* Re-schedule the LEB for erasure */
 		err1 = schedule_erase(ubi, e, vol_id, lnum, 0);
 		if (err1) {
<span class="p_add">+			wl_entry_destroy(ubi, e);</span>
 			err = err1;
 			goto out_ro;
 		}
<span class="p_chunk">@@ -1150,6 +1136,25 @@</span> <span class="p_context"> out_ro:</span>
 	return err;
 }
 
<span class="p_add">+static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
<span class="p_add">+			  int shutdown)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (shutdown) {</span>
<span class="p_add">+		struct ubi_wl_entry *e = wl_wrk-&gt;e;</span>
<span class="p_add">+</span>
<span class="p_add">+		dbg_wl(&quot;cancel erasure of PEB %d EC %d&quot;, e-&gt;pnum, e-&gt;ec);</span>
<span class="p_add">+		kfree(wl_wrk);</span>
<span class="p_add">+		wl_entry_destroy(ubi, e);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = __erase_worker(ubi, wl_wrk);</span>
<span class="p_add">+	kfree(wl_wrk);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * ubi_wl_put_peb - return a PEB to the wear-leveling sub-system.
  * @ubi: UBI device description object
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 6e9418ed90c2..bbb789f8990b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -2272,7 +2272,7 @@</span> <span class="p_context"> void rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)</span>
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	if (!rtlpci-&gt;int_clear)</span>
<span class="p_add">+	if (rtlpci-&gt;int_clear)</span>
 		rtl8821ae_clear_interrupt(hw);/*clear it here first*/
 
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">index 8ee141a55bc5..142bdff4ed60 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
 MODULE_PARM_DESC(msi, &quot;Set to 1 to use MSI interrupts mode (default 1)\n&quot;);
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 MODULE_PARM_DESC(disable_watchdog, &quot;Set to 1 to disable the watchdog (default 0)\n&quot;);
<span class="p_del">-MODULE_PARM_DESC(int_clear, &quot;Set to 1 to disable interrupt clear before set (default 0)\n&quot;);</span>
<span class="p_add">+MODULE_PARM_DESC(int_clear, &quot;Set to 0 to disable interrupt clear before set (default 1)\n&quot;);</span>
 
 static SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
 
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/io.h b/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_header">index 0305729d0986..10cf3747694d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_chunk">@@ -207,19 +207,23 @@</span> <span class="p_context"> static inline int __must_check wlcore_write_reg(struct wl1271 *wl, int reg,</span>
 
 static inline void wl1271_power_off(struct wl1271 *wl)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	if (!test_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags))
 		return;
 
<span class="p_del">-	ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, false);</span>
<span class="p_add">+	if (wl-&gt;if_ops-&gt;power)</span>
<span class="p_add">+		ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, false);</span>
 	if (!ret)
 		clear_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags);
 }
 
 static inline int wl1271_power_on(struct wl1271 *wl)
 {
<span class="p_del">-	int ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, true);</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wl-&gt;if_ops-&gt;power)</span>
<span class="p_add">+		ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, true);</span>
 	if (ret == 0)
 		set_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags);
 
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/spi.c b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">index f1ac2839d97c..720e4e4b5a3c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_chunk">@@ -73,7 +73,10 @@</span> <span class="p_context"></span>
  */
 #define SPI_AGGR_BUFFER_SIZE (4 * PAGE_SIZE)
 
<span class="p_del">-#define WSPI_MAX_NUM_OF_CHUNKS (SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE)</span>
<span class="p_add">+/* Maximum number of SPI write chunks */</span>
<span class="p_add">+#define WSPI_MAX_NUM_OF_CHUNKS \</span>
<span class="p_add">+	((SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE) + 1)</span>
<span class="p_add">+</span>
 
 struct wl12xx_spi_glue {
 	struct device *dev;
<span class="p_chunk">@@ -268,9 +271,10 @@</span> <span class="p_context"> static int __must_check wl12xx_spi_raw_write(struct device *child, int addr,</span>
 					     void *buf, size_t len, bool fixed)
 {
 	struct wl12xx_spi_glue *glue = dev_get_drvdata(child-&gt;parent);
<span class="p_del">-	struct spi_transfer t[2 * (WSPI_MAX_NUM_OF_CHUNKS + 1)];</span>
<span class="p_add">+	/* SPI write buffers - 2 for each chunk */</span>
<span class="p_add">+	struct spi_transfer t[2 * WSPI_MAX_NUM_OF_CHUNKS];</span>
 	struct spi_message m;
<span class="p_del">-	u32 commands[WSPI_MAX_NUM_OF_CHUNKS];</span>
<span class="p_add">+	u32 commands[WSPI_MAX_NUM_OF_CHUNKS]; /* 1 command per chunk */</span>
 	u32 *cmd;
 	u32 chunk_len;
 	int i;
<span class="p_header">diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c</span>
<span class="p_header">index d3346d23963b..89b3befc7155 100644</span>
<span class="p_header">--- a/drivers/pci/bus.c</span>
<span class="p_header">+++ b/drivers/pci/bus.c</span>
<span class="p_chunk">@@ -140,6 +140,8 @@</span> <span class="p_context"> static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,</span>
 	type_mask |= IORESOURCE_TYPE_BITS;
 
 	pci_bus_for_each_resource(bus, r, i) {
<span class="p_add">+		resource_size_t min_used = min;</span>
<span class="p_add">+</span>
 		if (!r)
 			continue;
 
<span class="p_chunk">@@ -163,12 +165,12 @@</span> <span class="p_context"> static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,</span>
 		 * overrides &quot;min&quot;.
 		 */
 		if (avail.start)
<span class="p_del">-			min = avail.start;</span>
<span class="p_add">+			min_used = avail.start;</span>
 
 		max = avail.end;
 
 		/* Ok, try it out.. */
<span class="p_del">-		ret = allocate_resource(r, res, size, min, max,</span>
<span class="p_add">+		ret = allocate_resource(r, res, size, min_used, max,</span>
 					align, alignf, alignf_data);
 		if (ret == 0)
 			return 0;
<span class="p_header">diff --git a/drivers/pci/host/pci-dra7xx.c b/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_header">index 199e29a044cd..ee978705a6f5 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_chunk">@@ -295,7 +295,8 @@</span> <span class="p_context"> static int __init dra7xx_add_pcie_port(struct dra7xx_pcie *dra7xx,</span>
 	}
 
 	ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;irq,
<span class="p_del">-			       dra7xx_pcie_msi_irq_handler, IRQF_SHARED,</span>
<span class="p_add">+			       dra7xx_pcie_msi_irq_handler,</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
 			       &quot;dra7-pcie-msi&quot;,	pp);
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request irq\n&quot;);
<span class="p_header">diff --git a/drivers/pci/host/pci-exynos.c b/drivers/pci/host/pci-exynos.c</span>
<span class="p_header">index f9f468d9a819..7b6be7791d33 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-exynos.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-exynos.c</span>
<span class="p_chunk">@@ -523,7 +523,8 @@</span> <span class="p_context"> static int __init exynos_add_pcie_port(struct pcie_port *pp,</span>
 
 		ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;msi_irq,
 					exynos_pcie_msi_irq_handler,
<span class="p_del">-					IRQF_SHARED, &quot;exynos-pcie&quot;, pp);</span>
<span class="p_add">+					IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+					&quot;exynos-pcie&quot;, pp);</span>
 		if (ret) {
 			dev_err(&amp;pdev-&gt;dev, &quot;failed to request msi irq\n&quot;);
 			return ret;
<span class="p_header">diff --git a/drivers/pci/host/pci-imx6.c b/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">index 8f3a9813c4e5..58713d57c426 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-imx6.c</span>
<span class="p_chunk">@@ -536,7 +536,8 @@</span> <span class="p_context"> static int __init imx6_add_pcie_port(struct pcie_port *pp,</span>
 
 		ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;msi_irq,
 				       imx6_pcie_msi_handler,
<span class="p_del">-				       IRQF_SHARED, &quot;mx6-pcie-msi&quot;, pp);</span>
<span class="p_add">+				       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+				       &quot;mx6-pcie-msi&quot;, pp);</span>
 		if (ret) {
 			dev_err(&amp;pdev-&gt;dev, &quot;failed to request MSI irq\n&quot;);
 			return -ENODEV;
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index 81df0c1fe063..46d5e07dbdfe 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -1288,7 +1288,7 @@</span> <span class="p_context"> static int tegra_pcie_enable_msi(struct tegra_pcie *pcie)</span>
 
 	msi-&gt;irq = err;
 
<span class="p_del">-	err = request_irq(msi-&gt;irq, tegra_pcie_msi_irq, 0,</span>
<span class="p_add">+	err = request_irq(msi-&gt;irq, tegra_pcie_msi_irq, IRQF_NO_THREAD,</span>
 			  tegra_msi_irq_chip.name, pcie);
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
<span class="p_header">diff --git a/drivers/pci/host/pcie-rcar.c b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">index 7678fe0820d7..b86e42fcf19f 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_chunk">@@ -694,14 +694,16 @@</span> <span class="p_context"> static int rcar_pcie_enable_msi(struct rcar_pcie *pcie)</span>
 
 	/* Two irqs are for MSI, but they are also used for non-MSI irqs */
 	err = devm_request_irq(&amp;pdev-&gt;dev, msi-&gt;irq1, rcar_pcie_msi_irq,
<span class="p_del">-			       IRQF_SHARED, rcar_msi_irq_chip.name, pcie);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       rcar_msi_irq_chip.name, pcie);</span>
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
 		goto err;
 	}
 
 	err = devm_request_irq(&amp;pdev-&gt;dev, msi-&gt;irq2, rcar_pcie_msi_irq,
<span class="p_del">-			       IRQF_SHARED, rcar_msi_irq_chip.name, pcie);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       rcar_msi_irq_chip.name, pcie);</span>
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
 		goto err;
<span class="p_header">diff --git a/drivers/pci/host/pcie-spear13xx.c b/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_header">index 98d2683181bc..4aca7167ed95 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_chunk">@@ -163,34 +163,36 @@</span> <span class="p_context"> static int spear13xx_pcie_establish_link(struct pcie_port *pp)</span>
 	 * default value in capability register is 512 bytes. So force
 	 * it to 128 here.
 	 */
<span class="p_del">-	dw_pcie_cfg_read(pp-&gt;dbi_base, exp_cap_off + PCI_EXP_DEVCTL, 4, &amp;val);</span>
<span class="p_add">+	dw_pcie_cfg_read(pp-&gt;dbi_base + exp_cap_off + PCI_EXP_DEVCTL,</span>
<span class="p_add">+				0, 2, &amp;val);</span>
 	val &amp;= ~PCI_EXP_DEVCTL_READRQ;
<span class="p_del">-	dw_pcie_cfg_write(pp-&gt;dbi_base, exp_cap_off + PCI_EXP_DEVCTL, 4, val);</span>
<span class="p_add">+	dw_pcie_cfg_write(pp-&gt;dbi_base + exp_cap_off + PCI_EXP_DEVCTL,</span>
<span class="p_add">+				0, 2, val);</span>
 
<span class="p_del">-	dw_pcie_cfg_write(pp-&gt;dbi_base, PCI_VENDOR_ID, 2, 0x104A);</span>
<span class="p_del">-	dw_pcie_cfg_write(pp-&gt;dbi_base, PCI_DEVICE_ID, 2, 0xCD80);</span>
<span class="p_add">+	dw_pcie_cfg_write(pp-&gt;dbi_base + PCI_VENDOR_ID, 0, 2, 0x104A);</span>
<span class="p_add">+	dw_pcie_cfg_write(pp-&gt;dbi_base + PCI_VENDOR_ID, 2, 2, 0xCD80);</span>
 
 	/*
 	 * if is_gen1 is set then handle it, so that some buggy card
 	 * also works
 	 */
 	if (spear13xx_pcie-&gt;is_gen1) {
<span class="p_del">-		dw_pcie_cfg_read(pp-&gt;dbi_base, exp_cap_off + PCI_EXP_LNKCAP, 4,</span>
<span class="p_del">-				 &amp;val);</span>
<span class="p_add">+		dw_pcie_cfg_read(pp-&gt;dbi_base + exp_cap_off + PCI_EXP_LNKCAP,</span>
<span class="p_add">+					0, 4, &amp;val);</span>
 		if ((val &amp; PCI_EXP_LNKCAP_SLS) != PCI_EXP_LNKCAP_SLS_2_5GB) {
 			val &amp;= ~((u32)PCI_EXP_LNKCAP_SLS);
 			val |= PCI_EXP_LNKCAP_SLS_2_5GB;
<span class="p_del">-			dw_pcie_cfg_write(pp-&gt;dbi_base, exp_cap_off +</span>
<span class="p_del">-					  PCI_EXP_LNKCAP, 4, val);</span>
<span class="p_add">+			dw_pcie_cfg_write(pp-&gt;dbi_base + exp_cap_off +</span>
<span class="p_add">+						PCI_EXP_LNKCAP, 0, 4, val);</span>
 		}
 
<span class="p_del">-		dw_pcie_cfg_read(pp-&gt;dbi_base, exp_cap_off + PCI_EXP_LNKCTL2, 4,</span>
<span class="p_del">-				 &amp;val);</span>
<span class="p_add">+		dw_pcie_cfg_read(pp-&gt;dbi_base + exp_cap_off + PCI_EXP_LNKCTL2,</span>
<span class="p_add">+					0, 2, &amp;val);</span>
 		if ((val &amp; PCI_EXP_LNKCAP_SLS) != PCI_EXP_LNKCAP_SLS_2_5GB) {
 			val &amp;= ~((u32)PCI_EXP_LNKCAP_SLS);
 			val |= PCI_EXP_LNKCAP_SLS_2_5GB;
<span class="p_del">-			dw_pcie_cfg_write(pp-&gt;dbi_base, exp_cap_off +</span>
<span class="p_del">-					  PCI_EXP_LNKCTL2, 4, val);</span>
<span class="p_add">+			dw_pcie_cfg_write(pp-&gt;dbi_base + exp_cap_off +</span>
<span class="p_add">+						PCI_EXP_LNKCTL2, 0, 2, val);</span>
 		}
 	}
 
<span class="p_chunk">@@ -279,7 +281,8 @@</span> <span class="p_context"> static int spear13xx_add_pcie_port(struct pcie_port *pp,</span>
 		return -ENODEV;
 	}
 	ret = devm_request_irq(dev, pp-&gt;irq, spear13xx_pcie_irq_handler,
<span class="p_del">-			       IRQF_SHARED, &quot;spear1340-pcie&quot;, pp);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       &quot;spear1340-pcie&quot;, pp);</span>
 	if (ret) {
 		dev_err(dev, &quot;failed to request irq %d\n&quot;, pp-&gt;irq);
 		return ret;
<span class="p_header">diff --git a/drivers/pci/host/pcie-xilinx.c b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">index 3c7a0d580b1e..4cfa46360d12 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_chunk">@@ -781,7 +781,8 @@</span> <span class="p_context"> static int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)</span>
 
 	port-&gt;irq = irq_of_parse_and_map(node, 0);
 	err = devm_request_irq(dev, port-&gt;irq, xilinx_pcie_intr_handler,
<span class="p_del">-			       IRQF_SHARED, &quot;xilinx-pcie&quot;, port);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       &quot;xilinx-pcie&quot;, port);</span>
 	if (err) {
 		dev_err(dev, &quot;unable to request irq %d\n&quot;, port-&gt;irq);
 		return err;
<span class="p_header">diff --git a/drivers/pci/iov.c b/drivers/pci/iov.c</span>
<span class="p_header">index ee0ebff103a4..1eadc74d88b4 100644</span>
<span class="p_header">--- a/drivers/pci/iov.c</span>
<span class="p_header">+++ b/drivers/pci/iov.c</span>
<span class="p_chunk">@@ -54,24 +54,29 @@</span> <span class="p_context"> static inline void pci_iov_set_numvfs(struct pci_dev *dev, int nr_virtfn)</span>
  * The PF consumes one bus number.  NumVFs, First VF Offset, and VF Stride
  * determine how many additional bus numbers will be consumed by VFs.
  *
<span class="p_del">- * Iterate over all valid NumVFs and calculate the maximum number of bus</span>
<span class="p_del">- * numbers that could ever be required.</span>
<span class="p_add">+ * Iterate over all valid NumVFs, validate offset and stride, and calculate</span>
<span class="p_add">+ * the maximum number of bus numbers that could ever be required.</span>
  */
<span class="p_del">-static inline u8 virtfn_max_buses(struct pci_dev *dev)</span>
<span class="p_add">+static int compute_max_vf_buses(struct pci_dev *dev)</span>
 {
 	struct pci_sriov *iov = dev-&gt;sriov;
<span class="p_del">-	int nr_virtfn;</span>
<span class="p_del">-	u8 max = 0;</span>
<span class="p_del">-	int busnr;</span>
<span class="p_add">+	int nr_virtfn, busnr, rc = 0;</span>
 
<span class="p_del">-	for (nr_virtfn = 1; nr_virtfn &lt;= iov-&gt;total_VFs; nr_virtfn++) {</span>
<span class="p_add">+	for (nr_virtfn = iov-&gt;total_VFs; nr_virtfn; nr_virtfn--) {</span>
 		pci_iov_set_numvfs(dev, nr_virtfn);
<span class="p_add">+		if (!iov-&gt;offset || (nr_virtfn &gt; 1 &amp;&amp; !iov-&gt;stride)) {</span>
<span class="p_add">+			rc = -EIO;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		busnr = pci_iov_virtfn_bus(dev, nr_virtfn - 1);
<span class="p_del">-		if (busnr &gt; max)</span>
<span class="p_del">-			max = busnr;</span>
<span class="p_add">+		if (busnr &gt; iov-&gt;max_VF_buses)</span>
<span class="p_add">+			iov-&gt;max_VF_buses = busnr;</span>
 	}
 
<span class="p_del">-	return max;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	pci_iov_set_numvfs(dev, 0);</span>
<span class="p_add">+	return rc;</span>
 }
 
 static struct pci_bus *virtfn_add_bus(struct pci_bus *bus, int busnr)
<span class="p_chunk">@@ -384,7 +389,7 @@</span> <span class="p_context"> static int sriov_init(struct pci_dev *dev, int pos)</span>
 	int rc;
 	int nres;
 	u32 pgsz;
<span class="p_del">-	u16 ctrl, total, offset, stride;</span>
<span class="p_add">+	u16 ctrl, total;</span>
 	struct pci_sriov *iov;
 	struct resource *res;
 	struct pci_dev *pdev;
<span class="p_chunk">@@ -414,11 +419,6 @@</span> <span class="p_context"> static int sriov_init(struct pci_dev *dev, int pos)</span>
 
 found:
 	pci_write_config_word(dev, pos + PCI_SRIOV_CTRL, ctrl);
<span class="p_del">-	pci_write_config_word(dev, pos + PCI_SRIOV_NUM_VF, 0);</span>
<span class="p_del">-	pci_read_config_word(dev, pos + PCI_SRIOV_VF_OFFSET, &amp;offset);</span>
<span class="p_del">-	pci_read_config_word(dev, pos + PCI_SRIOV_VF_STRIDE, &amp;stride);</span>
<span class="p_del">-	if (!offset || (total &gt; 1 &amp;&amp; !stride))</span>
<span class="p_del">-		return -EIO;</span>
 
 	pci_read_config_dword(dev, pos + PCI_SRIOV_SUP_PGSIZE, &amp;pgsz);
 	i = PAGE_SHIFT &gt; 12 ? PAGE_SHIFT - 12 : 0;
<span class="p_chunk">@@ -456,8 +456,6 @@</span> <span class="p_context"> found:</span>
 	iov-&gt;nres = nres;
 	iov-&gt;ctrl = ctrl;
 	iov-&gt;total_VFs = total;
<span class="p_del">-	iov-&gt;offset = offset;</span>
<span class="p_del">-	iov-&gt;stride = stride;</span>
 	iov-&gt;pgsz = pgsz;
 	iov-&gt;self = dev;
 	pci_read_config_dword(dev, pos + PCI_SRIOV_CAP, &amp;iov-&gt;cap);
<span class="p_chunk">@@ -474,10 +472,15 @@</span> <span class="p_context"> found:</span>
 
 	dev-&gt;sriov = iov;
 	dev-&gt;is_physfn = 1;
<span class="p_del">-	iov-&gt;max_VF_buses = virtfn_max_buses(dev);</span>
<span class="p_add">+	rc = compute_max_vf_buses(dev);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		goto fail_max_buses;</span>
 
 	return 0;
 
<span class="p_add">+fail_max_buses:</span>
<span class="p_add">+	dev-&gt;sriov = NULL;</span>
<span class="p_add">+	dev-&gt;is_physfn = 0;</span>
 failed:
 	for (i = 0; i &lt; PCI_SRIOV_NUM_BARS; i++) {
 		res = &amp;dev-&gt;resource[i + PCI_IOV_RESOURCES];
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 92618686604c..eead54cd01b2 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -216,7 +216,10 @@</span> <span class="p_context"> static ssize_t numa_node_store(struct device *dev,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (node &gt;= MAX_NUMNODES || !node_online(node))</span>
<span class="p_add">+	if ((node &lt; 0 &amp;&amp; node != NUMA_NO_NODE) || node &gt;= MAX_NUMNODES)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (node != NUMA_NO_NODE &amp;&amp; !node_online(node))</span>
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);
<span class="p_header">diff --git a/drivers/remoteproc/remoteproc_debugfs.c b/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_header">index 9d30809bb407..916af5096f57 100644</span>
<span class="p_header">--- a/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_header">+++ b/drivers/remoteproc/remoteproc_debugfs.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> rproc_recovery_write(struct file *filp, const char __user *user_buf,</span>
 	char buf[10];
 	int ret;
 
<span class="p_del">-	if (count &gt; sizeof(buf))</span>
<span class="p_add">+	if (count &lt; 1 || count &gt; sizeof(buf))</span>
 		return count;
 
 	ret = copy_from_user(buf, user_buf, count);
<span class="p_header">diff --git a/drivers/spi/spi-atmel.c b/drivers/spi/spi-atmel.c</span>
<span class="p_header">index 63318e2afba1..3fff59ce065f 100644</span>
<span class="p_header">--- a/drivers/spi/spi-atmel.c</span>
<span class="p_header">+++ b/drivers/spi/spi-atmel.c</span>
<span class="p_chunk">@@ -773,7 +773,8 @@</span> <span class="p_context"> static int atmel_spi_next_xfer_dma_submit(struct spi_master *master,</span>
 
 	*plen = len;
 
<span class="p_del">-	if (atmel_spi_dma_slave_config(as, &amp;slave_config, 8))</span>
<span class="p_add">+	if (atmel_spi_dma_slave_config(as, &amp;slave_config,</span>
<span class="p_add">+				       xfer-&gt;bits_per_word))</span>
 		goto err_exit;
 
 	/* Send both scatterlists */
<span class="p_header">diff --git a/drivers/spi/spi-omap2-mcspi.c b/drivers/spi/spi-omap2-mcspi.c</span>
<span class="p_header">index 3d09e0b69b73..1f8903d356e5 100644</span>
<span class="p_header">--- a/drivers/spi/spi-omap2-mcspi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-omap2-mcspi.c</span>
<span class="p_chunk">@@ -1217,6 +1217,33 @@</span> <span class="p_context"> out:</span>
 	return status;
 }
 
<span class="p_add">+static int omap2_mcspi_prepare_message(struct spi_master *master,</span>
<span class="p_add">+				       struct spi_message *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct omap2_mcspi	*mcspi = spi_master_get_devdata(master);</span>
<span class="p_add">+	struct omap2_mcspi_regs	*ctx = &amp;mcspi-&gt;ctx;</span>
<span class="p_add">+	struct omap2_mcspi_cs	*cs;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only a single channel can have the FORCE bit enabled</span>
<span class="p_add">+	 * in its chconf0 register.</span>
<span class="p_add">+	 * Scan all channels and disable them except the current one.</span>
<span class="p_add">+	 * A FORCE can remain from a last transfer having cs_change enabled</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	list_for_each_entry(cs, &amp;ctx-&gt;cs, node) {</span>
<span class="p_add">+		if (msg-&gt;spi-&gt;controller_state == cs)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((cs-&gt;chconf0 &amp; OMAP2_MCSPI_CHCONF_FORCE)) {</span>
<span class="p_add">+			cs-&gt;chconf0 &amp;= ~OMAP2_MCSPI_CHCONF_FORCE;</span>
<span class="p_add">+			writel_relaxed(cs-&gt;chconf0,</span>
<span class="p_add">+					cs-&gt;base + OMAP2_MCSPI_CHCONF0);</span>
<span class="p_add">+			readl_relaxed(cs-&gt;base + OMAP2_MCSPI_CHCONF0);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int omap2_mcspi_transfer_one(struct spi_master *master,
 		struct spi_device *spi, struct spi_transfer *t)
 {
<span class="p_chunk">@@ -1344,6 +1371,7 @@</span> <span class="p_context"> static int omap2_mcspi_probe(struct platform_device *pdev)</span>
 	master-&gt;bits_per_word_mask = SPI_BPW_RANGE_MASK(4, 32);
 	master-&gt;setup = omap2_mcspi_setup;
 	master-&gt;auto_runtime_pm = true;
<span class="p_add">+	master-&gt;prepare_message = omap2_mcspi_prepare_message;</span>
 	master-&gt;transfer_one = omap2_mcspi_transfer_one;
 	master-&gt;set_cs = omap2_mcspi_set_cs;
 	master-&gt;cleanup = omap2_mcspi_cleanup;
<span class="p_header">diff --git a/drivers/spi/spi-ti-qspi.c b/drivers/spi/spi-ti-qspi.c</span>
<span class="p_header">index aa6d284131e0..81b84858cfee 100644</span>
<span class="p_header">--- a/drivers/spi/spi-ti-qspi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-ti-qspi.c</span>
<span class="p_chunk">@@ -410,11 +410,10 @@</span> <span class="p_context"> static int ti_qspi_start_transfer_one(struct spi_master *master,</span>
 
 	mutex_unlock(&amp;qspi-&gt;list_lock);
 
<span class="p_add">+	ti_qspi_write(qspi, qspi-&gt;cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);</span>
 	m-&gt;status = status;
 	spi_finalize_current_message(master);
 
<span class="p_del">-	ti_qspi_write(qspi, qspi-&gt;cmd | QSPI_INVAL, QSPI_SPI_CMD_REG);</span>
<span class="p_del">-</span>
 	return status;
 }
 
<span class="p_header">diff --git a/drivers/spi/spi-xilinx.c b/drivers/spi/spi-xilinx.c</span>
<span class="p_header">index a339c1e9997a..3009121173cd 100644</span>
<span class="p_header">--- a/drivers/spi/spi-xilinx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-xilinx.c</span>
<span class="p_chunk">@@ -270,6 +270,7 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 
 	while (remaining_words) {
 		int n_words, tx_words, rx_words;
<span class="p_add">+		u32 sr;</span>
 
 		n_words = min(remaining_words, xspi-&gt;buffer_size);
 
<span class="p_chunk">@@ -284,24 +285,33 @@</span> <span class="p_context"> static int xilinx_spi_txrx_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 		if (use_irq) {
 			xspi-&gt;write_fn(cr, xspi-&gt;regs + XSPI_CR_OFFSET);
 			wait_for_completion(&amp;xspi-&gt;done);
<span class="p_del">-		} else</span>
<span class="p_del">-			while (!(xspi-&gt;read_fn(xspi-&gt;regs + XSPI_SR_OFFSET) &amp;</span>
<span class="p_del">-						XSPI_SR_TX_EMPTY_MASK))</span>
<span class="p_del">-				;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* A transmit has just completed. Process received data and</span>
<span class="p_del">-		 * check for more data to transmit. Always inhibit the</span>
<span class="p_del">-		 * transmitter while the Isr refills the transmit register/FIFO,</span>
<span class="p_del">-		 * or make sure it is stopped if we&#39;re done.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (use_irq)</span>
<span class="p_add">+			/* A transmit has just completed. Process received data</span>
<span class="p_add">+			 * and check for more data to transmit. Always inhibit</span>
<span class="p_add">+			 * the transmitter while the Isr refills the transmit</span>
<span class="p_add">+			 * register/FIFO, or make sure it is stopped if we&#39;re</span>
<span class="p_add">+			 * done.</span>
<span class="p_add">+			 */</span>
 			xspi-&gt;write_fn(cr | XSPI_CR_TRANS_INHIBIT,
<span class="p_del">-			       xspi-&gt;regs + XSPI_CR_OFFSET);</span>
<span class="p_add">+				       xspi-&gt;regs + XSPI_CR_OFFSET);</span>
<span class="p_add">+			sr = XSPI_SR_TX_EMPTY_MASK;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			sr = xspi-&gt;read_fn(xspi-&gt;regs + XSPI_SR_OFFSET);</span>
 
 		/* Read out all the data from the Rx FIFO */
 		rx_words = n_words;
<span class="p_del">-		while (rx_words--)</span>
<span class="p_del">-			xilinx_spi_rx(xspi);</span>
<span class="p_add">+		while (rx_words) {</span>
<span class="p_add">+			if ((sr &amp; XSPI_SR_TX_EMPTY_MASK) &amp;&amp; (rx_words &gt; 1)) {</span>
<span class="p_add">+				xilinx_spi_rx(xspi);</span>
<span class="p_add">+				rx_words--;</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			sr = xspi-&gt;read_fn(xspi-&gt;regs + XSPI_SR_OFFSET);</span>
<span class="p_add">+			if (!(sr &amp; XSPI_SR_RX_EMPTY_MASK)) {</span>
<span class="p_add">+				xilinx_spi_rx(xspi);</span>
<span class="p_add">+				rx_words--;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 
 		remaining_words -= n_words;
 	}
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index a5f53de813d3..a83d9d07df58 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -1627,7 +1627,7 @@</span> <span class="p_context"> struct spi_master *spi_alloc_master(struct device *dev, unsigned size)</span>
 	master-&gt;bus_num = -1;
 	master-&gt;num_chipselect = 1;
 	master-&gt;dev.class = &amp;spi_master_class;
<span class="p_del">-	master-&gt;dev.parent = get_device(dev);</span>
<span class="p_add">+	master-&gt;dev.parent = dev;</span>
 	spi_master_set_devdata(master, &amp;master[1]);
 
 	return master;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index a0285da0244c..1fc7a84a2ded 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -258,16 +258,13 @@</span> <span class="p_context"> static void n_tty_check_throttle(struct tty_struct *tty)</span>
 
 static void n_tty_check_unthrottle(struct tty_struct *tty)
 {
<span class="p_del">-	if (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY &amp;&amp;</span>
<span class="p_del">-	    tty-&gt;link-&gt;ldisc-&gt;ops-&gt;write_wakeup == n_tty_write_wakeup) {</span>
<span class="p_add">+	if (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY) {</span>
 		if (chars_in_buffer(tty) &gt; TTY_THRESHOLD_UNTHROTTLE)
 			return;
 		if (!tty-&gt;count)
 			return;
 		n_tty_kick_worker(tty);
<span class="p_del">-		n_tty_write_wakeup(tty-&gt;link);</span>
<span class="p_del">-		if (waitqueue_active(&amp;tty-&gt;link-&gt;write_wait))</span>
<span class="p_del">-			wake_up_interruptible_poll(&amp;tty-&gt;link-&gt;write_wait, POLLOUT);</span>
<span class="p_add">+		tty_wakeup(tty-&gt;link);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -2058,13 +2055,13 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 	size_t eol;
 	size_t tail;
 	int ret, found = 0;
<span class="p_del">-	bool eof_push = 0;</span>
 
 	/* N.B. avoid overrun if nr == 0 */
<span class="p_del">-	n = min(*nr, smp_load_acquire(&amp;ldata-&gt;canon_head) - ldata-&gt;read_tail);</span>
<span class="p_del">-	if (!n)</span>
<span class="p_add">+	if (!*nr)</span>
 		return 0;
 
<span class="p_add">+	n = min(*nr + 1, smp_load_acquire(&amp;ldata-&gt;canon_head) - ldata-&gt;read_tail);</span>
<span class="p_add">+</span>
 	tail = ldata-&gt;read_tail &amp; (N_TTY_BUF_SIZE - 1);
 	size = min_t(size_t, tail + n, N_TTY_BUF_SIZE);
 
<span class="p_chunk">@@ -2085,12 +2082,11 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 	n = eol - tail;
 	if (n &gt; N_TTY_BUF_SIZE)
 		n += N_TTY_BUF_SIZE;
<span class="p_del">-	n += found;</span>
<span class="p_del">-	c = n;</span>
<span class="p_add">+	c = n + found;</span>
 
<span class="p_del">-	if (found &amp;&amp; !ldata-&gt;push &amp;&amp; read_buf(ldata, eol) == __DISABLED_CHAR) {</span>
<span class="p_del">-		n--;</span>
<span class="p_del">-		eof_push = !n &amp;&amp; ldata-&gt;read_tail != ldata-&gt;line_start;</span>
<span class="p_add">+	if (!found || read_buf(ldata, eol) != __DISABLED_CHAR) {</span>
<span class="p_add">+		c = min(*nr, c);</span>
<span class="p_add">+		n = c;</span>
 	}
 
 	n_tty_trace(&quot;%s: eol:%zu found:%d n:%zu c:%zu size:%zu more:%zu\n&quot;,
<span class="p_chunk">@@ -2120,7 +2116,7 @@</span> <span class="p_context"> static int canon_copy_from_read_buf(struct tty_struct *tty,</span>
 			ldata-&gt;push = 0;
 		tty_audit_push(tty);
 	}
<span class="p_del">-	return eof_push ? -EAGAIN : 0;</span>
<span class="p_add">+	return 0;</span>
 }
 
 extern ssize_t redirected_tty_write(struct file *, const char __user *,
<span class="p_chunk">@@ -2299,10 +2295,7 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 
 		if (ldata-&gt;icanon &amp;&amp; !L_EXTPROC(tty)) {
 			retval = canon_copy_from_read_buf(tty, &amp;b, &amp;nr);
<span class="p_del">-			if (retval == -EAGAIN) {</span>
<span class="p_del">-				retval = 0;</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			} else if (retval)</span>
<span class="p_add">+			if (retval)</span>
 				break;
 		} else {
 			int uncopied;
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index a660ab181cca..bcf2de080471 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -450,7 +450,7 @@</span> <span class="p_context"> receive_buf(struct tty_struct *tty, struct tty_buffer *head, int count)</span>
 		count = disc-&gt;ops-&gt;receive_buf2(tty, p, f, count);
 	else {
 		count = min_t(int, count, tty-&gt;receive_room);
<span class="p_del">-		if (count)</span>
<span class="p_add">+		if (count &amp;&amp; disc-&gt;ops-&gt;receive_buf)</span>
 			disc-&gt;ops-&gt;receive_buf(tty, p, f, count);
 	}
 	return count;
<span class="p_header">diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c</span>
<span class="p_header">index f435977de740..ff7f15f0f1fb 100644</span>
<span class="p_header">--- a/drivers/tty/tty_io.c</span>
<span class="p_header">+++ b/drivers/tty/tty_io.c</span>
<span class="p_chunk">@@ -1462,13 +1462,13 @@</span> <span class="p_context"> static int tty_reopen(struct tty_struct *tty)</span>
 {
 	struct tty_driver *driver = tty-&gt;driver;
 
<span class="p_del">-	if (!tty-&gt;count)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	if (driver-&gt;type == TTY_DRIVER_TYPE_PTY &amp;&amp;
 	    driver-&gt;subtype == PTY_TYPE_MASTER)
 		return -EIO;
 
<span class="p_add">+	if (!tty-&gt;count)</span>
<span class="p_add">+		return -EAGAIN;</span>
<span class="p_add">+</span>
 	if (test_bit(TTY_EXCLUSIVE, &amp;tty-&gt;flags) &amp;&amp; !capable(CAP_SYS_ADMIN))
 		return -EBUSY;
 
<span class="p_chunk">@@ -2087,7 +2087,11 @@</span> <span class="p_context"> retry_open:</span>
 
 	if (IS_ERR(tty)) {
 		retval = PTR_ERR(tty);
<span class="p_del">-		goto err_file;</span>
<span class="p_add">+		if (retval != -EAGAIN || signal_pending(current))</span>
<span class="p_add">+			goto err_file;</span>
<span class="p_add">+		tty_free_file(filp);</span>
<span class="p_add">+		schedule();</span>
<span class="p_add">+		goto retry_open;</span>
 	}
 
 	tty_add_file(tty, filp);
<span class="p_chunk">@@ -2654,6 +2658,28 @@</span> <span class="p_context"> static int tiocsetd(struct tty_struct *tty, int __user *p)</span>
 }
 
 /**
<span class="p_add">+ *	tiocgetd	-	get line discipline</span>
<span class="p_add">+ *	@tty: tty device</span>
<span class="p_add">+ *	@p: pointer to user data</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Retrieves the line discipline id directly from the ldisc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Locking: waits for ldisc reference (in case the line discipline</span>
<span class="p_add">+ *		is changing or the tty is being hungup)</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static int tiocgetd(struct tty_struct *tty, int __user *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct tty_ldisc *ld;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ld = tty_ldisc_ref_wait(tty);</span>
<span class="p_add">+	ret = put_user(ld-&gt;ops-&gt;num, p);</span>
<span class="p_add">+	tty_ldisc_deref(ld);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  *	send_break	-	performed time break
  *	@tty: device to break on
  *	@duration: timeout in mS
<span class="p_chunk">@@ -2879,7 +2905,7 @@</span> <span class="p_context"> long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 	case TIOCGSID:
 		return tiocgsid(tty, real_tty, p);
 	case TIOCGETD:
<span class="p_del">-		return put_user(tty-&gt;ldisc-&gt;ops-&gt;num, (int __user *)p);</span>
<span class="p_add">+		return tiocgetd(tty, p);</span>
 	case TIOCSETD:
 		return tiocsetd(tty, p);
 	case TIOCVHANGUP:
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 26ca4f910cb0..e4c70dce3e7c 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -428,7 +428,8 @@</span> <span class="p_context"> static void acm_read_bulk_callback(struct urb *urb)</span>
 		set_bit(rb-&gt;index, &amp;acm-&gt;read_urbs_free);
 		dev_dbg(&amp;acm-&gt;data-&gt;dev, &quot;%s - non-zero urb status: %d\n&quot;,
 							__func__, status);
<span class="p_del">-		return;</span>
<span class="p_add">+		if ((status != -ENOENT) || (urb-&gt;actual_length == 0))</span>
<span class="p_add">+			return;</span>
 	}
 
 	usb_mark_last_busy(acm-&gt;dev);
<span class="p_chunk">@@ -1404,6 +1405,8 @@</span> <span class="p_context"> made_compressed_probe:</span>
 				usb_sndbulkpipe(usb_dev, epwrite-&gt;bEndpointAddress),
 				NULL, acm-&gt;writesize, acm_write_bulk, snd);
 		snd-&gt;urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
<span class="p_add">+		if (quirks &amp; SEND_ZERO_PACKET)</span>
<span class="p_add">+			snd-&gt;urb-&gt;transfer_flags |= URB_ZERO_PACKET;</span>
 		snd-&gt;instance = acm;
 	}
 
<span class="p_chunk">@@ -1861,6 +1864,10 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
 		USB_CDC_ACM_PROTO_AT_CDMA) },
 
<span class="p_add">+	{ USB_DEVICE(0x1519, 0x0452), /* Intel 7260 modem */</span>
<span class="p_add">+	.driver_info = SEND_ZERO_PACKET,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index dd9af38e7cda..ccfaba9ab4e4 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -134,3 +134,4 @@</span> <span class="p_context"> struct acm {</span>
 #define IGNORE_DEVICE			BIT(5)
 #define QUIRK_CONTROL_LINE_STATE	BIT(6)
 #define CLEAR_HALT_CONDITIONS		BIT(7)
<span class="p_add">+#define SEND_ZERO_PACKET		BIT(8)</span>
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 62084335a608..a2fef797d553 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -5377,7 +5377,6 @@</span> <span class="p_context"> static int usb_reset_and_verify_device(struct usb_device *udev)</span>
 	}
 
 	bos = udev-&gt;bos;
<span class="p_del">-	udev-&gt;bos = NULL;</span>
 
 	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
 
<span class="p_chunk">@@ -5470,8 +5469,11 @@</span> <span class="p_context"> done:</span>
 	usb_set_usb2_hardware_lpm(udev, 1);
 	usb_unlocked_enable_lpm(udev);
 	usb_enable_ltm(udev);
<span class="p_del">-	usb_release_bos_descriptor(udev);</span>
<span class="p_del">-	udev-&gt;bos = bos;</span>
<span class="p_add">+	/* release the new BOS descriptor allocated  by hub_port_init() */</span>
<span class="p_add">+	if (udev-&gt;bos != bos) {</span>
<span class="p_add">+		usb_release_bos_descriptor(udev);</span>
<span class="p_add">+		udev-&gt;bos = bos;</span>
<span class="p_add">+	}</span>
 	return 0;
 
 re_enumerate:
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 78241b5550df..1018f563465b 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -616,8 +616,30 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		if ((raw_port_status &amp; PORT_RESET) ||
 				!(raw_port_status &amp; PORT_PE))
 			return 0xffffffff;
<span class="p_del">-		if (time_after_eq(jiffies,</span>
<span class="p_del">-					bus_state-&gt;resume_done[wIndex])) {</span>
<span class="p_add">+		/* did port event handler already start resume timing? */</span>
<span class="p_add">+		if (!bus_state-&gt;resume_done[wIndex]) {</span>
<span class="p_add">+			/* If not, maybe we are in a host initated resume? */</span>
<span class="p_add">+			if (test_bit(wIndex, &amp;bus_state-&gt;resuming_ports)) {</span>
<span class="p_add">+				/* Host initated resume doesn&#39;t time the resume</span>
<span class="p_add">+				 * signalling using resume_done[].</span>
<span class="p_add">+				 * It manually sets RESUME state, sleeps 20ms</span>
<span class="p_add">+				 * and sets U0 state. This should probably be</span>
<span class="p_add">+				 * changed, but not right now.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/* port resume was discovered now and here,</span>
<span class="p_add">+				 * start resume timing</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				unsigned long timeout = jiffies +</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
<span class="p_add">+</span>
<span class="p_add">+				set_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
<span class="p_add">+				bus_state-&gt;resume_done[wIndex] = timeout;</span>
<span class="p_add">+				mod_timer(&amp;hcd-&gt;rh_timer, timeout);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		/* Has resume been signalled for USB_RESUME_TIME yet? */</span>
<span class="p_add">+		} else if (time_after_eq(jiffies,</span>
<span class="p_add">+					 bus_state-&gt;resume_done[wIndex])) {</span>
 			int time_left;
 
 			xhci_dbg(xhci, &quot;Resume USB2 port %d\n&quot;,
<span class="p_chunk">@@ -658,13 +680,24 @@</span> <span class="p_context"> static u32 xhci_get_port_status(struct usb_hcd *hcd,</span>
 		} else {
 			/*
 			 * The resume has been signaling for less than
<span class="p_del">-			 * 20ms. Report the port status as SUSPEND,</span>
<span class="p_del">-			 * let the usbcore check port status again</span>
<span class="p_del">-			 * and clear resume signaling later.</span>
<span class="p_add">+			 * USB_RESUME_TIME. Report the port status as SUSPEND,</span>
<span class="p_add">+			 * let the usbcore check port status again and clear</span>
<span class="p_add">+			 * resume signaling later.</span>
 			 */
 			status |= USB_PORT_STAT_SUSPEND;
 		}
 	}
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear stale usb2 resume signalling variables in case port changed</span>
<span class="p_add">+	 * state during resume signalling. For example on error</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((bus_state-&gt;resume_done[wIndex] ||</span>
<span class="p_add">+	     test_bit(wIndex, &amp;bus_state-&gt;resuming_ports)) &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_PLS_MASK) != XDEV_U3 &amp;&amp;</span>
<span class="p_add">+	    (raw_port_status &amp; PORT_PLS_MASK) != XDEV_RESUME) {</span>
<span class="p_add">+		bus_state-&gt;resume_done[wIndex] = 0;</span>
<span class="p_add">+		clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
<span class="p_add">+	}</span>
 	if ((raw_port_status &amp; PORT_PLS_MASK) == XDEV_U0
 			&amp;&amp; (raw_port_status &amp; PORT_POWER)
 			&amp;&amp; (bus_state-&gt;suspended_ports &amp; (1 &lt;&lt; wIndex))) {
<span class="p_chunk">@@ -995,6 +1028,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				if ((temp &amp; PORT_PE) == 0)
 					goto error;
 
<span class="p_add">+				set_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_RESUME);
 				spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_chunk">@@ -1002,6 +1036,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_U0);
<span class="p_add">+				clear_bit(wIndex, &amp;bus_state-&gt;resuming_ports);</span>
 			}
 			bus_state-&gt;port_c_suspend |= 1 &lt;&lt; wIndex;
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c47d3e480586..a22c430faea7 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -28,7 +28,9 @@</span> <span class="p_context"></span>
 #include &quot;xhci.h&quot;
 #include &quot;xhci-trace.h&quot;
 
<span class="p_del">-#define PORT2_SSIC_CONFIG_REG2	0x883c</span>
<span class="p_add">+#define SSIC_PORT_NUM		2</span>
<span class="p_add">+#define SSIC_PORT_CFG2		0x880c</span>
<span class="p_add">+#define SSIC_PORT_CFG2_OFFSET	0x30</span>
 #define PROG_DONE		(1 &lt;&lt; 30)
 #define SSIC_PORT_UNUSED	(1 &lt;&lt; 31)
 
<span class="p_chunk">@@ -45,6 +47,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -152,7 +155,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
<span class="p_del">-		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)) {</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
<span class="p_chunk">@@ -316,28 +320,36 @@</span> <span class="p_context"> static void xhci_pme_quirk(struct usb_hcd *hcd, bool suspend)</span>
 	struct pci_dev		*pdev = to_pci_dev(hcd-&gt;self.controller);
 	u32 val;
 	void __iomem *reg;
<span class="p_add">+	int i;</span>
 
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
 
<span class="p_del">-		reg = (void __iomem *) xhci-&gt;cap_regs + PORT2_SSIC_CONFIG_REG2;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Notify SSIC that SSIC profile programming is not done */</span>
<span class="p_del">-		val = readl(reg) &amp; ~PROG_DONE;</span>
<span class="p_del">-		writel(val, reg);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Mark SSIC port as unused(suspend) or used(resume) */</span>
<span class="p_del">-		val = readl(reg);</span>
<span class="p_del">-		if (suspend)</span>
<span class="p_del">-			val |= SSIC_PORT_UNUSED;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			val &amp;= ~SSIC_PORT_UNUSED;</span>
<span class="p_del">-		writel(val, reg);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Notify SSIC that SSIC profile programming is done */</span>
<span class="p_del">-		val = readl(reg) | PROG_DONE;</span>
<span class="p_del">-		writel(val, reg);</span>
<span class="p_del">-		readl(reg);</span>
<span class="p_add">+		for (i = 0; i &lt; SSIC_PORT_NUM; i++) {</span>
<span class="p_add">+			reg = (void __iomem *) xhci-&gt;cap_regs +</span>
<span class="p_add">+					SSIC_PORT_CFG2 +</span>
<span class="p_add">+					i * SSIC_PORT_CFG2_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Notify SSIC that SSIC profile programming</span>
<span class="p_add">+			 * is not done.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			val = readl(reg) &amp; ~PROG_DONE;</span>
<span class="p_add">+			writel(val, reg);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Mark SSIC port as unused(suspend) or used(resume) */</span>
<span class="p_add">+			val = readl(reg);</span>
<span class="p_add">+			if (suspend)</span>
<span class="p_add">+				val |= SSIC_PORT_UNUSED;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				val &amp;= ~SSIC_PORT_UNUSED;</span>
<span class="p_add">+			writel(val, reg);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Notify SSIC that SSIC profile programming is done */</span>
<span class="p_add">+			val = readl(reg) | PROG_DONE;</span>
<span class="p_add">+			writel(val, reg);</span>
<span class="p_add">+			readl(reg);</span>
<span class="p_add">+		}</span>
 	}
 
 	reg = (void __iomem *) xhci-&gt;cap_regs + 0x80a4;
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index fe9e2d3a223c..23c712ec7541 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1583,7 +1583,8 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 			 */
 			bogus_port_status = true;
 			goto cleanup;
<span class="p_del">-		} else {</span>
<span class="p_add">+		} else if (!test_bit(faked_port_index,</span>
<span class="p_add">+				     &amp;bus_state-&gt;resuming_ports)) {</span>
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
 				msecs_to_jiffies(USB_RESUME_TIMEOUT);
<span class="p_header">diff --git a/drivers/usb/phy/phy-msm-usb.c b/drivers/usb/phy/phy-msm-usb.c</span>
<span class="p_header">index c58c3c0dbe35..260e510578e7 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy-msm-usb.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy-msm-usb.c</span>
<span class="p_chunk">@@ -1599,6 +1599,8 @@</span> <span class="p_context"> static int msm_otg_read_dt(struct platform_device *pdev, struct msm_otg *motg)</span>
 						&amp;motg-&gt;id.nb);
 		if (ret &lt; 0) {
 			dev_err(&amp;pdev-&gt;dev, &quot;register ID notifier failed\n&quot;);
<span class="p_add">+			extcon_unregister_notifier(motg-&gt;vbus.extcon,</span>
<span class="p_add">+						   EXTCON_USB, &amp;motg-&gt;vbus.nb);</span>
 			return ret;
 		}
 
<span class="p_chunk">@@ -1660,15 +1662,6 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	if (!motg)
 		return -ENOMEM;
 
<span class="p_del">-	pdata = dev_get_platdata(&amp;pdev-&gt;dev);</span>
<span class="p_del">-	if (!pdata) {</span>
<span class="p_del">-		if (!np)</span>
<span class="p_del">-			return -ENXIO;</span>
<span class="p_del">-		ret = msm_otg_read_dt(pdev, motg);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	motg-&gt;phy.otg = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct usb_otg),
 				     GFP_KERNEL);
 	if (!motg-&gt;phy.otg)
<span class="p_chunk">@@ -1710,6 +1703,15 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	if (!motg-&gt;regs)
 		return -ENOMEM;
 
<span class="p_add">+	pdata = dev_get_platdata(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (!pdata) {</span>
<span class="p_add">+		if (!np)</span>
<span class="p_add">+			return -ENXIO;</span>
<span class="p_add">+		ret = msm_otg_read_dt(pdev, motg);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * NOTE: The PHYs can be multiplexed between the chipidea controller
 	 * and the dwc3 controller, using a single bit. It is important that
<span class="p_chunk">@@ -1717,8 +1719,10 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	 */
 	if (motg-&gt;phy_number) {
 		phy_select = devm_ioremap_nocache(&amp;pdev-&gt;dev, USB2_PHY_SEL, 4);
<span class="p_del">-		if (!phy_select)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_add">+		if (!phy_select) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto unregister_extcon;</span>
<span class="p_add">+		}</span>
 		/* Enable second PHY with the OTG port */
 		writel(0x1, phy_select);
 	}
<span class="p_chunk">@@ -1728,7 +1732,8 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	motg-&gt;irq = platform_get_irq(pdev, 0);
 	if (motg-&gt;irq &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;platform_get_irq failed\n&quot;);
<span class="p_del">-		return motg-&gt;irq;</span>
<span class="p_add">+		ret = motg-&gt;irq;</span>
<span class="p_add">+		goto unregister_extcon;</span>
 	}
 
 	regs[0].supply = &quot;vddcx&quot;;
<span class="p_chunk">@@ -1737,7 +1742,7 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 
 	ret = devm_regulator_bulk_get(motg-&gt;phy.dev, ARRAY_SIZE(regs), regs);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto unregister_extcon;</span>
 
 	motg-&gt;vddcx = regs[0].consumer;
 	motg-&gt;v3p3  = regs[1].consumer;
<span class="p_chunk">@@ -1834,6 +1839,12 @@</span> <span class="p_context"> disable_clks:</span>
 	clk_disable_unprepare(motg-&gt;clk);
 	if (!IS_ERR(motg-&gt;core_clk))
 		clk_disable_unprepare(motg-&gt;core_clk);
<span class="p_add">+unregister_extcon:</span>
<span class="p_add">+	extcon_unregister_notifier(motg-&gt;id.extcon,</span>
<span class="p_add">+				   EXTCON_USB_HOST, &amp;motg-&gt;id.nb);</span>
<span class="p_add">+	extcon_unregister_notifier(motg-&gt;vbus.extcon,</span>
<span class="p_add">+				   EXTCON_USB, &amp;motg-&gt;vbus.nb);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 59b2126b21a3..1dd9919081f8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -98,6 +98,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x81AC) }, /* MSD Dash Hawk */
 	{ USB_DEVICE(0x10C4, 0x81AD) }, /* INSYS USB Modem */
 	{ USB_DEVICE(0x10C4, 0x81C8) }, /* Lipowsky Industrie Elektronik GmbH, Baby-JTAG */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x81D7) }, /* IAI Corp. RCB-CV-USB USB to RS485 Adaptor */</span>
 	{ USB_DEVICE(0x10C4, 0x81E2) }, /* Lipowsky Industrie Elektronik GmbH, Baby-LIN */
 	{ USB_DEVICE(0x10C4, 0x81E7) }, /* Aerocomm Radio */
 	{ USB_DEVICE(0x10C4, 0x81E8) }, /* Zephyr Bioharness */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index a5a0376bbd48..8c660ae401d8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -824,6 +824,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_TURTELIZER_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_USB60F) },
<span class="p_add">+	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_SCU18) },</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_REU_TINY_PID) },
 
 	/* Papouch devices based on FTDI chip */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 67c6d4469730..a84df2513994 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -615,6 +615,7 @@</span> <span class="p_context"></span>
  */
 #define RATOC_VENDOR_ID		0x0584
 #define RATOC_PRODUCT_ID_USB60F	0xb020
<span class="p_add">+#define RATOC_PRODUCT_ID_SCU18	0xb03a</span>
 
 /*
  * Infineon Technologies
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index e945b5195258..35622fba4305 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -271,6 +271,8 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_CC864_SINGLE		0x1006
 #define TELIT_PRODUCT_DE910_DUAL		0x1010
 #define TELIT_PRODUCT_UE910_V2			0x1012
<span class="p_add">+#define TELIT_PRODUCT_LE922_USBCFG0		0x1042</span>
<span class="p_add">+#define TELIT_PRODUCT_LE922_USBCFG3		0x1043</span>
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
 
<span class="p_chunk">@@ -623,6 +625,16 @@</span> <span class="p_context"> static const struct option_blacklist_info sierra_mc73xx_blacklist = {</span>
 	.reserved = BIT(8) | BIT(10) | BIT(11),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_le922_blacklist_usbcfg0 = {</span>
<span class="p_add">+	.sendsetup = BIT(2),</span>
<span class="p_add">+	.reserved = BIT(0) | BIT(1) | BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct option_blacklist_info telit_le922_blacklist_usbcfg3 = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(1) | BIT(2) | BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1172,6 +1184,10 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_CC864_SINGLE) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_DE910_DUAL) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UE910_V2) },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG0),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG3),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
<span class="p_chunk">@@ -1691,7 +1707,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_EU3_P) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_del">-	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX, 0xff) },</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PLXX),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, 
<span class="p_header">diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c</span>
<span class="p_header">index 60afb39eb73c..337a0be89fcf 100644</span>
<span class="p_header">--- a/drivers/usb/serial/visor.c</span>
<span class="p_header">+++ b/drivers/usb/serial/visor.c</span>
<span class="p_chunk">@@ -544,6 +544,11 @@</span> <span class="p_context"> static int treo_attach(struct usb_serial *serial)</span>
 		(serial-&gt;num_interrupt_in == 0))
 		return 0;
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; 2 || serial-&gt;num_interrupt_in &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	* It appears that Treos and Kyoceras want to use the
 	* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,
<span class="p_chunk">@@ -597,8 +602,10 @@</span> <span class="p_context"> static int clie_5_attach(struct usb_serial *serial)</span>
 	 */
 
 	/* some sanity check */
<span class="p_del">-	if (serial-&gt;num_ports &lt; 2)</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing bulk out endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
 
 	/* port 0 now uses the modified endpoint Address */
 	port = serial-&gt;port[0];
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 6b659967898e..e6572a665b2e 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -759,16 +759,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 			 */
 			would_dump(bprm, interpreter);
 
<span class="p_del">-			retval = kernel_read(interpreter, 0, bprm-&gt;buf,</span>
<span class="p_del">-					     BINPRM_BUF_SIZE);</span>
<span class="p_del">-			if (retval != BINPRM_BUF_SIZE) {</span>
<span class="p_add">+			/* Get the exec headers */</span>
<span class="p_add">+			retval = kernel_read(interpreter, 0,</span>
<span class="p_add">+					     (void *)&amp;loc-&gt;interp_elf_ex,</span>
<span class="p_add">+					     sizeof(loc-&gt;interp_elf_ex));</span>
<span class="p_add">+			if (retval != sizeof(loc-&gt;interp_elf_ex)) {</span>
 				if (retval &gt;= 0)
 					retval = -EIO;
 				goto out_free_dentry;
 			}
 
<span class="p_del">-			/* Get the exec headers */</span>
<span class="p_del">-			loc-&gt;interp_elf_ex = *((struct elfhdr *)bprm-&gt;buf);</span>
 			break;
 		}
 		elf_ppnt++;
<span class="p_header">diff --git a/fs/cachefiles/rdwr.c b/fs/cachefiles/rdwr.c</span>
<span class="p_header">index 3cbb0e834694..3ce646792c7e 100644</span>
<span class="p_header">--- a/fs/cachefiles/rdwr.c</span>
<span class="p_header">+++ b/fs/cachefiles/rdwr.c</span>
<span class="p_chunk">@@ -885,7 +885,7 @@</span> <span class="p_context"> int cachefiles_write_page(struct fscache_storage *op, struct page *page)</span>
 	loff_t pos, eof;
 	size_t len;
 	void *data;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENOBUFS;</span>
 
 	ASSERT(op != NULL);
 	ASSERT(page != NULL);
<span class="p_chunk">@@ -905,6 +905,15 @@</span> <span class="p_context"> int cachefiles_write_page(struct fscache_storage *op, struct page *page)</span>
 	cache = container_of(object-&gt;fscache.cache,
 			     struct cachefiles_cache, cache);
 
<span class="p_add">+	pos = (loff_t)page-&gt;index &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We mustn&#39;t write more data than we have, so we have to beware of a</span>
<span class="p_add">+	 * partial page at EOF.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	eof = object-&gt;fscache.store_limit_l;</span>
<span class="p_add">+	if (pos &gt;= eof)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+</span>
 	/* write the page to the backing filesystem and let it store it in its
 	 * own time */
 	path.mnt = cache-&gt;mnt;
<span class="p_chunk">@@ -912,40 +921,38 @@</span> <span class="p_context"> int cachefiles_write_page(struct fscache_storage *op, struct page *page)</span>
 	file = dentry_open(&amp;path, O_RDWR | O_LARGEFILE, cache-&gt;cache_cred);
 	if (IS_ERR(file)) {
 		ret = PTR_ERR(file);
<span class="p_del">-	} else {</span>
<span class="p_del">-		pos = (loff_t) page-&gt;index &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* we mustn&#39;t write more data than we have, so we have</span>
<span class="p_del">-		 * to beware of a partial page at EOF */</span>
<span class="p_del">-		eof = object-&gt;fscache.store_limit_l;</span>
<span class="p_del">-		len = PAGE_SIZE;</span>
<span class="p_del">-		if (eof &amp; ~PAGE_MASK) {</span>
<span class="p_del">-			ASSERTCMP(pos, &lt;, eof);</span>
<span class="p_del">-			if (eof - pos &lt; PAGE_SIZE) {</span>
<span class="p_del">-				_debug(&quot;cut short %llx to %llx&quot;,</span>
<span class="p_del">-				       pos, eof);</span>
<span class="p_del">-				len = eof - pos;</span>
<span class="p_del">-				ASSERTCMP(pos + len, ==, eof);</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		data = kmap(page);</span>
<span class="p_del">-		ret = __kernel_write(file, data, len, &amp;pos);</span>
<span class="p_del">-		kunmap(page);</span>
<span class="p_del">-		if (ret != len)</span>
<span class="p_del">-			ret = -EIO;</span>
<span class="p_del">-		fput(file);</span>
<span class="p_add">+		goto error_2;</span>
 	}
 
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		if (ret == -EIO)</span>
<span class="p_del">-			cachefiles_io_error_obj(</span>
<span class="p_del">-				object, &quot;Write page to backing file failed&quot;);</span>
<span class="p_del">-		ret = -ENOBUFS;</span>
<span class="p_add">+	len = PAGE_SIZE;</span>
<span class="p_add">+	if (eof &amp; ~PAGE_MASK) {</span>
<span class="p_add">+		if (eof - pos &lt; PAGE_SIZE) {</span>
<span class="p_add">+			_debug(&quot;cut short %llx to %llx&quot;,</span>
<span class="p_add">+			       pos, eof);</span>
<span class="p_add">+			len = eof - pos;</span>
<span class="p_add">+			ASSERTCMP(pos + len, ==, eof);</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	_leave(&quot; = %d&quot;, ret);</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	data = kmap(page);</span>
<span class="p_add">+	ret = __kernel_write(file, data, len, &amp;pos);</span>
<span class="p_add">+	kunmap(page);</span>
<span class="p_add">+	fput(file);</span>
<span class="p_add">+	if (ret != len)</span>
<span class="p_add">+		goto error_eio;</span>
<span class="p_add">+</span>
<span class="p_add">+	_leave(&quot; = 0&quot;);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+error_eio:</span>
<span class="p_add">+	ret = -EIO;</span>
<span class="p_add">+error_2:</span>
<span class="p_add">+	if (ret == -EIO)</span>
<span class="p_add">+		cachefiles_io_error_obj(object,</span>
<span class="p_add">+					&quot;Write page to backing file failed&quot;);</span>
<span class="p_add">+error:</span>
<span class="p_add">+	_leave(&quot; = -ENOBUFS [%d]&quot;, ret);</span>
<span class="p_add">+	return -ENOBUFS;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/ext2/super.c b/fs/ext2/super.c</span>
<span class="p_header">index 900e19cf9ef6..2597b0663bf2 100644</span>
<span class="p_header">--- a/fs/ext2/super.c</span>
<span class="p_header">+++ b/fs/ext2/super.c</span>
<span class="p_chunk">@@ -566,6 +566,8 @@</span> <span class="p_context"> static int parse_options(char *options, struct super_block *sb)</span>
 			/* Fall through */
 		case Opt_dax:
 #ifdef CONFIG_FS_DAX
<span class="p_add">+			ext2_msg(sb, KERN_WARNING,</span>
<span class="p_add">+		&quot;DAX enabled. Warning: EXPERIMENTAL, use at your own risk&quot;);</span>
 			set_opt(sbi-&gt;s_mount_opt, DAX);
 #else
 			ext2_msg(sb, KERN_INFO, &quot;dax option not supported&quot;);
<span class="p_header">diff --git a/fs/ext4/crypto.c b/fs/ext4/crypto.c</span>
<span class="p_header">index 2fab243a4c9e..7d6cda4738a4 100644</span>
<span class="p_header">--- a/fs/ext4/crypto.c</span>
<span class="p_header">+++ b/fs/ext4/crypto.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> int ext4_encrypted_zeroout(struct inode *inode, struct ext4_extent *ex)</span>
 	struct ext4_crypto_ctx	*ctx;
 	struct page		*ciphertext_page = NULL;
 	struct bio		*bio;
<span class="p_del">-	ext4_lblk_t		lblk = ex-&gt;ee_block;</span>
<span class="p_add">+	ext4_lblk_t		lblk = le32_to_cpu(ex-&gt;ee_block);</span>
 	ext4_fsblk_t		pblk = ext4_ext_pblock(ex);
 	unsigned int		len = ext4_ext_get_actual_len(ex);
 	int			ret, err = 0;
<span class="p_header">diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h</span>
<span class="p_header">index fd1f28be5296..eb897089fbd0 100644</span>
<span class="p_header">--- a/fs/ext4/ext4.h</span>
<span class="p_header">+++ b/fs/ext4/ext4.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/seqlock.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/timer.h&gt;
<span class="p_add">+#include &lt;linux/version.h&gt;</span>
 #include &lt;linux/wait.h&gt;
 #include &lt;linux/blockgroup_lock.h&gt;
 #include &lt;linux/percpu_counter.h&gt;
<span class="p_chunk">@@ -723,19 +724,55 @@</span> <span class="p_context"> struct move_extent {</span>
 	&lt;= (EXT4_GOOD_OLD_INODE_SIZE +			\
 	    (einode)-&gt;i_extra_isize))			\
 
<span class="p_add">+/*</span>
<span class="p_add">+ * We use an encoding that preserves the times for extra epoch &quot;00&quot;:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * extra  msb of                         adjust for signed</span>
<span class="p_add">+ * epoch  32-bit                         32-bit tv_sec to</span>
<span class="p_add">+ * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range</span>
<span class="p_add">+ * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31</span>
<span class="p_add">+ * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19</span>
<span class="p_add">+ * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07</span>
<span class="p_add">+ * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25</span>
<span class="p_add">+ * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16</span>
<span class="p_add">+ * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04</span>
<span class="p_add">+ * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22</span>
<span class="p_add">+ * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that previous versions of the kernel on 64-bit systems would</span>
<span class="p_add">+ * incorrectly use extra epoch bits 1,1 for dates between 1901 and</span>
<span class="p_add">+ * 1970.  e2fsck will correct this, assuming that it is run on the</span>
<span class="p_add">+ * affected filesystem before 2242.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 static inline __le32 ext4_encode_extra_time(struct timespec *time)
 {
<span class="p_del">-       return cpu_to_le32((sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_del">-			   (time-&gt;tv_sec &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0) |</span>
<span class="p_del">-                          ((time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS) &amp; EXT4_NSEC_MASK));</span>
<span class="p_add">+	u32 extra = sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_add">+		((time-&gt;tv_sec - (s32)time-&gt;tv_sec) &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0;</span>
<span class="p_add">+	return cpu_to_le32(extra | (time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS));</span>
 }
 
 static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)
 {
<span class="p_del">-       if (sizeof(time-&gt;tv_sec) &gt; 4)</span>
<span class="p_del">-	       time-&gt;tv_sec |= (__u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK)</span>
<span class="p_del">-			       &lt;&lt; 32;</span>
<span class="p_del">-       time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
<span class="p_add">+	if (unlikely(sizeof(time-&gt;tv_sec) &gt; 4 &amp;&amp;</span>
<span class="p_add">+			(extra &amp; cpu_to_le32(EXT4_EPOCH_MASK)))) {</span>
<span class="p_add">+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,20,0)</span>
<span class="p_add">+		/* Handle legacy encoding of pre-1970 dates with epoch</span>
<span class="p_add">+		 * bits 1,1.  We assume that by kernel version 4.20,</span>
<span class="p_add">+		 * everyone will have run fsck over the affected</span>
<span class="p_add">+		 * filesystems to correct the problem.  (This</span>
<span class="p_add">+		 * backwards compatibility may be removed before this</span>
<span class="p_add">+		 * time, at the discretion of the ext4 developers.)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u64 extra_bits = le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK;</span>
<span class="p_add">+		if (extra_bits == 3 &amp;&amp; ((time-&gt;tv_sec) &amp; 0x80000000) != 0)</span>
<span class="p_add">+			extra_bits = 0;</span>
<span class="p_add">+		time-&gt;tv_sec += extra_bits &lt;&lt; 32;</span>
<span class="p_add">+#else</span>
<span class="p_add">+		time-&gt;tv_sec += (u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK) &lt;&lt; 32;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+	time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
 }
 
 #define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)			       \
<span class="p_header">diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c</span>
<span class="p_header">index cf0c472047e3..c7c53fd46a41 100644</span>
<span class="p_header">--- a/fs/ext4/resize.c</span>
<span class="p_header">+++ b/fs/ext4/resize.c</span>
<span class="p_chunk">@@ -1040,7 +1040,7 @@</span> <span class="p_context"> exit_free:</span>
  * do not copy the full number of backups at this time.  The resize
  * which changed s_groups_count will backup again.
  */
<span class="p_del">-static void update_backups(struct super_block *sb, int blk_off, char *data,</span>
<span class="p_add">+static void update_backups(struct super_block *sb, sector_t blk_off, char *data,</span>
 			   int size, int meta_bg)
 {
 	struct ext4_sb_info *sbi = EXT4_SB(sb);
<span class="p_chunk">@@ -1065,7 +1065,7 @@</span> <span class="p_context"> static void update_backups(struct super_block *sb, int blk_off, char *data,</span>
 		group = ext4_list_backups(sb, &amp;three, &amp;five, &amp;seven);
 		last = sbi-&gt;s_groups_count;
 	} else {
<span class="p_del">-		group = ext4_meta_bg_first_group(sb, group) + 1;</span>
<span class="p_add">+		group = ext4_get_group_number(sb, blk_off) + 1;</span>
 		last = (ext4_group_t)(group + EXT4_DESC_PER_BLOCK(sb) - 2);
 	}
 
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index df84bd256c9f..7683892d855c 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -1664,8 +1664,12 @@</span> <span class="p_context"> static int handle_mount_opt(struct super_block *sb, char *opt, int token,</span>
 		}
 		sbi-&gt;s_jquota_fmt = m-&gt;mount_opt;
 #endif
<span class="p_del">-#ifndef CONFIG_FS_DAX</span>
 	} else if (token == Opt_dax) {
<span class="p_add">+#ifdef CONFIG_FS_DAX</span>
<span class="p_add">+		ext4_msg(sb, KERN_WARNING,</span>
<span class="p_add">+		&quot;DAX enabled. Warning: EXPERIMENTAL, use at your own risk&quot;);</span>
<span class="p_add">+			sbi-&gt;s_mount_opt |= m-&gt;mount_opt;</span>
<span class="p_add">+#else</span>
 		ext4_msg(sb, KERN_INFO, &quot;dax option not supported&quot;);
 		return -1;
 #endif
<span class="p_header">diff --git a/fs/ext4/symlink.c b/fs/ext4/symlink.c</span>
<span class="p_header">index c677f2c1044b..3627fd7cf4a0 100644</span>
<span class="p_header">--- a/fs/ext4/symlink.c</span>
<span class="p_header">+++ b/fs/ext4/symlink.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> static const char *ext4_encrypted_follow_link(struct dentry *dentry, void **cook</span>
 	/* Symlink is encrypted */
 	sd = (struct ext4_encrypted_symlink_data *)caddr;
 	cstr.name = sd-&gt;encrypted_path;
<span class="p_del">-	cstr.len  = le32_to_cpu(sd-&gt;len);</span>
<span class="p_add">+	cstr.len  = le16_to_cpu(sd-&gt;len);</span>
 	if ((cstr.len +
 	     sizeof(struct ext4_encrypted_symlink_data) - 1) &gt;
 	    max_size) {
<span class="p_header">diff --git a/fs/f2fs/dir.c b/fs/f2fs/dir.c</span>
<span class="p_header">index 8f15fc134040..6726c4a5efa2 100644</span>
<span class="p_header">--- a/fs/f2fs/dir.c</span>
<span class="p_header">+++ b/fs/f2fs/dir.c</span>
<span class="p_chunk">@@ -787,7 +787,6 @@</span> <span class="p_context"> bool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,</span>
 		else
 			d_type = DT_UNKNOWN;
 
<span class="p_del">-		/* encrypted case */</span>
 		de_name.name = d-&gt;filename[bit_pos];
 		de_name.len = le16_to_cpu(de-&gt;name_len);
 
<span class="p_chunk">@@ -795,12 +794,20 @@</span> <span class="p_context"> bool f2fs_fill_dentries(struct dir_context *ctx, struct f2fs_dentry_ptr *d,</span>
 			int save_len = fstr-&gt;len;
 			int ret;
 
<span class="p_add">+			de_name.name = kmalloc(de_name.len, GFP_NOFS);</span>
<span class="p_add">+			if (!de_name.name)</span>
<span class="p_add">+				return false;</span>
<span class="p_add">+</span>
<span class="p_add">+			memcpy(de_name.name, d-&gt;filename[bit_pos], de_name.len);</span>
<span class="p_add">+</span>
 			ret = f2fs_fname_disk_to_usr(d-&gt;inode, &amp;de-&gt;hash_code,
 							&amp;de_name, fstr);
<span class="p_del">-			de_name = *fstr;</span>
<span class="p_del">-			fstr-&gt;len = save_len;</span>
<span class="p_add">+			kfree(de_name.name);</span>
 			if (ret &lt; 0)
 				return true;
<span class="p_add">+</span>
<span class="p_add">+			de_name = *fstr;</span>
<span class="p_add">+			fstr-&gt;len = save_len;</span>
 		}
 
 		if (!dir_emit(ctx, de_name.name, de_name.len,
<span class="p_header">diff --git a/fs/f2fs/namei.c b/fs/f2fs/namei.c</span>
<span class="p_header">index a680bf38e4f0..dfa01c88b34b 100644</span>
<span class="p_header">--- a/fs/f2fs/namei.c</span>
<span class="p_header">+++ b/fs/f2fs/namei.c</span>
<span class="p_chunk">@@ -947,8 +947,13 @@</span> <span class="p_context"> static const char *f2fs_encrypted_follow_link(struct dentry *dentry, void **cook</span>
 
 	/* Symlink is encrypted */
 	sd = (struct f2fs_encrypted_symlink_data *)caddr;
<span class="p_del">-	cstr.name = sd-&gt;encrypted_path;</span>
 	cstr.len = le16_to_cpu(sd-&gt;len);
<span class="p_add">+	cstr.name = kmalloc(cstr.len, GFP_NOFS);</span>
<span class="p_add">+	if (!cstr.name) {</span>
<span class="p_add">+		res = -ENOMEM;</span>
<span class="p_add">+		goto errout;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	memcpy(cstr.name, sd-&gt;encrypted_path, cstr.len);</span>
 
 	/* this is broken symlink case */
 	if (cstr.name[0] == 0 &amp;&amp; cstr.len == 0) {
<span class="p_chunk">@@ -970,6 +975,8 @@</span> <span class="p_context"> static const char *f2fs_encrypted_follow_link(struct dentry *dentry, void **cook</span>
 	if (res &lt; 0)
 		goto errout;
 
<span class="p_add">+	kfree(cstr.name);</span>
<span class="p_add">+</span>
 	paddr = pstr.name;
 
 	/* Null-terminate the name */
<span class="p_chunk">@@ -979,6 +986,7 @@</span> <span class="p_context"> static const char *f2fs_encrypted_follow_link(struct dentry *dentry, void **cook</span>
 	page_cache_release(cpage);
 	return *cookie = paddr;
 errout:
<span class="p_add">+	kfree(cstr.name);</span>
 	f2fs_fname_crypto_free_buffer(&amp;pstr);
 	kunmap(cpage);
 	page_cache_release(cpage);
<span class="p_header">diff --git a/fs/fat/dir.c b/fs/fat/dir.c</span>
<span class="p_header">index 4afc4d9d2e41..8b2127ffb226 100644</span>
<span class="p_header">--- a/fs/fat/dir.c</span>
<span class="p_header">+++ b/fs/fat/dir.c</span>
<span class="p_chunk">@@ -610,9 +610,9 @@</span> <span class="p_context"> parse_record:</span>
 		int status = fat_parse_long(inode, &amp;cpos, &amp;bh, &amp;de,
 					    &amp;unicode, &amp;nr_slots);
 		if (status &lt; 0) {
<span class="p_del">-			ctx-&gt;pos = cpos;</span>
<span class="p_add">+			bh = NULL;</span>
 			ret = status;
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto end_of_dir;</span>
 		} else if (status == PARSE_INVALID)
 			goto record_end;
 		else if (status == PARSE_NOT_LONGNAME)
<span class="p_chunk">@@ -654,8 +654,9 @@</span> <span class="p_context"> parse_record:</span>
 	fill_len = short_len;
 
 start_filldir:
<span class="p_del">-	if (!fake_offset)</span>
<span class="p_del">-		ctx-&gt;pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);</span>
<span class="p_add">+	ctx-&gt;pos = cpos - (nr_slots + 1) * sizeof(struct msdos_dir_entry);</span>
<span class="p_add">+	if (fake_offset &amp;&amp; ctx-&gt;pos &lt; 2)</span>
<span class="p_add">+		ctx-&gt;pos = 2;</span>
 
 	if (!memcmp(de-&gt;name, MSDOS_DOT, MSDOS_NAME)) {
 		if (!dir_emit_dot(file, ctx))
<span class="p_chunk">@@ -681,14 +682,19 @@</span> <span class="p_context"> record_end:</span>
 	fake_offset = 0;
 	ctx-&gt;pos = cpos;
 	goto get_new;
<span class="p_add">+</span>
 end_of_dir:
<span class="p_del">-	ctx-&gt;pos = cpos;</span>
<span class="p_add">+	if (fake_offset &amp;&amp; cpos &lt; 2)</span>
<span class="p_add">+		ctx-&gt;pos = 2;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ctx-&gt;pos = cpos;</span>
 fill_failed:
 	brelse(bh);
 	if (unicode)
 		__putname(unicode);
 out:
 	mutex_unlock(&amp;sbi-&gt;s_lock);
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/fs/fscache/netfs.c b/fs/fscache/netfs.c</span>
<span class="p_header">index 6d941f56faf4..9b28649df3a1 100644</span>
<span class="p_header">--- a/fs/fscache/netfs.c</span>
<span class="p_header">+++ b/fs/fscache/netfs.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"> static LIST_HEAD(fscache_netfs_list);</span>
 int __fscache_register_netfs(struct fscache_netfs *netfs)
 {
 	struct fscache_netfs *ptr;
<span class="p_add">+	struct fscache_cookie *cookie;</span>
 	int ret;
 
 	_enter(&quot;{%s}&quot;, netfs-&gt;name);
<span class="p_chunk">@@ -29,29 +30,25 @@</span> <span class="p_context"> int __fscache_register_netfs(struct fscache_netfs *netfs)</span>
 	INIT_LIST_HEAD(&amp;netfs-&gt;link);
 
 	/* allocate a cookie for the primary index */
<span class="p_del">-	netfs-&gt;primary_index =</span>
<span class="p_del">-		kmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);</span>
<span class="p_add">+	cookie = kmem_cache_zalloc(fscache_cookie_jar, GFP_KERNEL);</span>
 
<span class="p_del">-	if (!netfs-&gt;primary_index) {</span>
<span class="p_add">+	if (!cookie) {</span>
 		_leave(&quot; = -ENOMEM&quot;);
 		return -ENOMEM;
 	}
 
 	/* initialise the primary index cookie */
<span class="p_del">-	atomic_set(&amp;netfs-&gt;primary_index-&gt;usage, 1);</span>
<span class="p_del">-	atomic_set(&amp;netfs-&gt;primary_index-&gt;n_children, 0);</span>
<span class="p_del">-	atomic_set(&amp;netfs-&gt;primary_index-&gt;n_active, 1);</span>
<span class="p_add">+	atomic_set(&amp;cookie-&gt;usage, 1);</span>
<span class="p_add">+	atomic_set(&amp;cookie-&gt;n_children, 0);</span>
<span class="p_add">+	atomic_set(&amp;cookie-&gt;n_active, 1);</span>
 
<span class="p_del">-	netfs-&gt;primary_index-&gt;def		= &amp;fscache_fsdef_netfs_def;</span>
<span class="p_del">-	netfs-&gt;primary_index-&gt;parent		= &amp;fscache_fsdef_index;</span>
<span class="p_del">-	netfs-&gt;primary_index-&gt;netfs_data	= netfs;</span>
<span class="p_del">-	netfs-&gt;primary_index-&gt;flags		= 1 &lt;&lt; FSCACHE_COOKIE_ENABLED;</span>
<span class="p_add">+	cookie-&gt;def		= &amp;fscache_fsdef_netfs_def;</span>
<span class="p_add">+	cookie-&gt;parent		= &amp;fscache_fsdef_index;</span>
<span class="p_add">+	cookie-&gt;netfs_data	= netfs;</span>
<span class="p_add">+	cookie-&gt;flags		= 1 &lt;&lt; FSCACHE_COOKIE_ENABLED;</span>
 
<span class="p_del">-	atomic_inc(&amp;netfs-&gt;primary_index-&gt;parent-&gt;usage);</span>
<span class="p_del">-	atomic_inc(&amp;netfs-&gt;primary_index-&gt;parent-&gt;n_children);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_init(&amp;netfs-&gt;primary_index-&gt;lock);</span>
<span class="p_del">-	INIT_HLIST_HEAD(&amp;netfs-&gt;primary_index-&gt;backing_objects);</span>
<span class="p_add">+	spin_lock_init(&amp;cookie-&gt;lock);</span>
<span class="p_add">+	INIT_HLIST_HEAD(&amp;cookie-&gt;backing_objects);</span>
 
 	/* check the netfs type is not already present */
 	down_write(&amp;fscache_addremove_sem);
<span class="p_chunk">@@ -62,6 +59,10 @@</span> <span class="p_context"> int __fscache_register_netfs(struct fscache_netfs *netfs)</span>
 			goto already_registered;
 	}
 
<span class="p_add">+	atomic_inc(&amp;cookie-&gt;parent-&gt;usage);</span>
<span class="p_add">+	atomic_inc(&amp;cookie-&gt;parent-&gt;n_children);</span>
<span class="p_add">+</span>
<span class="p_add">+	netfs-&gt;primary_index = cookie;</span>
 	list_add(&amp;netfs-&gt;link, &amp;fscache_netfs_list);
 	ret = 0;
 
<span class="p_chunk">@@ -70,11 +71,8 @@</span> <span class="p_context"> int __fscache_register_netfs(struct fscache_netfs *netfs)</span>
 already_registered:
 	up_write(&amp;fscache_addremove_sem);
 
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		netfs-&gt;primary_index-&gt;parent = NULL;</span>
<span class="p_del">-		__fscache_cookie_put(netfs-&gt;primary_index);</span>
<span class="p_del">-		netfs-&gt;primary_index = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		kmem_cache_free(fscache_cookie_jar, cookie);</span>
 
 	_leave(&quot; = %d&quot;, ret);
 	return ret;
<span class="p_header">diff --git a/fs/fscache/page.c b/fs/fscache/page.c</span>
<span class="p_header">index 483bbc613bf0..ca916af5a7c4 100644</span>
<span class="p_header">--- a/fs/fscache/page.c</span>
<span class="p_header">+++ b/fs/fscache/page.c</span>
<span class="p_chunk">@@ -816,7 +816,7 @@</span> <span class="p_context"> static void fscache_write_op(struct fscache_operation *_op)</span>
 		goto superseded;
 	page = results[0];
 	_debug(&quot;gang %d [%lx]&quot;, n, page-&gt;index);
<span class="p_del">-	if (page-&gt;index &gt; op-&gt;store_limit) {</span>
<span class="p_add">+	if (page-&gt;index &gt;= op-&gt;store_limit) {</span>
 		fscache_stat(&amp;fscache_n_store_pages_over_limit);
 		goto superseded;
 	}
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 316adb968b65..de4bdfac0cec 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -332,12 +332,17 @@</span> <span class="p_context"> static void remove_huge_page(struct page *page)</span>
  * truncation is indicated by end of range being LLONG_MAX
  *	In this case, we first scan the range and release found pages.
  *	After releasing pages, hugetlb_unreserve_pages cleans up region/reserv
<span class="p_del">- *	maps and global counts.</span>
<span class="p_add">+ *	maps and global counts.  Page faults can not race with truncation</span>
<span class="p_add">+ *	in this routine.  hugetlb_no_page() prevents page faults in the</span>
<span class="p_add">+ *	truncated range.  It checks i_size before allocation, and again after</span>
<span class="p_add">+ *	with the page table lock for the page held.  The same lock must be</span>
<span class="p_add">+ *	acquired to unmap a page.</span>
  * hole punch is indicated if end is not LLONG_MAX
  *	In the hole punch case we scan the range and release found pages.
  *	Only when releasing a page is the associated region/reserv map
  *	deleted.  The region/reserv map for ranges without associated
<span class="p_del">- *	pages are not modified.</span>
<span class="p_add">+ *	pages are not modified.  Page faults can race with hole punch.</span>
<span class="p_add">+ *	This is indicated if we find a mapped page.</span>
  * Note: If the passed end of range value is beyond the end of file, but
  * not LLONG_MAX this routine still performs a hole punch operation.
  */
<span class="p_chunk">@@ -361,46 +366,37 @@</span> <span class="p_context"> static void remove_inode_hugepages(struct inode *inode, loff_t lstart,</span>
 	next = start;
 	while (next &lt; end) {
 		/*
<span class="p_del">-		 * Make sure to never grab more pages that we</span>
<span class="p_del">-		 * might possibly need.</span>
<span class="p_add">+		 * Don&#39;t grab more pages than the number left in the range.</span>
 		 */
 		if (end - next &lt; lookup_nr)
 			lookup_nr = end - next;
 
 		/*
<span class="p_del">-		 * This pagevec_lookup() may return pages past &#39;end&#39;,</span>
<span class="p_del">-		 * so we must check for page-&gt;index &gt; end.</span>
<span class="p_add">+		 * When no more pages are found, we are done.</span>
 		 */
<span class="p_del">-		if (!pagevec_lookup(&amp;pvec, mapping, next, lookup_nr)) {</span>
<span class="p_del">-			if (next == start)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			next = start;</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!pagevec_lookup(&amp;pvec, mapping, next, lookup_nr))</span>
<span class="p_add">+			break;</span>
 
 		for (i = 0; i &lt; pagevec_count(&amp;pvec); ++i) {
 			struct page *page = pvec.pages[i];
 			u32 hash;
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The page (index) could be beyond end.  This is</span>
<span class="p_add">+			 * only possible in the punch hole case as end is</span>
<span class="p_add">+			 * max page offset in the truncate case.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			next = page-&gt;index;</span>
<span class="p_add">+			if (next &gt;= end)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+</span>
 			hash = hugetlb_fault_mutex_hash(h, current-&gt;mm,
 							&amp;pseudo_vma,
 							mapping, next, 0);
 			mutex_lock(&amp;hugetlb_fault_mutex_table[hash]);
 
 			lock_page(page);
<span class="p_del">-			if (page-&gt;index &gt;= end) {</span>
<span class="p_del">-				unlock_page(page);</span>
<span class="p_del">-				mutex_unlock(&amp;hugetlb_fault_mutex_table[hash]);</span>
<span class="p_del">-				next = end;	/* we are done */</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * If page is mapped, it was faulted in after being</span>
<span class="p_del">-			 * unmapped.  Do nothing in this race case.  In the</span>
<span class="p_del">-			 * normal case page is not mapped.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (!page_mapped(page)) {</span>
<span class="p_add">+			if (likely(!page_mapped(page))) {</span>
 				bool rsv_on_error = !PagePrivate(page);
 				/*
 				 * We must free the huge page and remove
<span class="p_chunk">@@ -421,17 +417,23 @@</span> <span class="p_context"> static void remove_inode_hugepages(struct inode *inode, loff_t lstart,</span>
 						hugetlb_fix_reserve_counts(
 							inode, rsv_on_error);
 				}
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * If page is mapped, it was faulted in after</span>
<span class="p_add">+				 * being unmapped.  It indicates a race between</span>
<span class="p_add">+				 * hole punch and page fault.  Do nothing in</span>
<span class="p_add">+				 * this case.  Getting here in a truncate</span>
<span class="p_add">+				 * operation is a bug.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				BUG_ON(truncate_op);</span>
 			}
 
<span class="p_del">-			if (page-&gt;index &gt; next)</span>
<span class="p_del">-				next = page-&gt;index;</span>
<span class="p_del">-</span>
<span class="p_del">-			++next;</span>
 			unlock_page(page);
<span class="p_del">-</span>
 			mutex_unlock(&amp;hugetlb_fault_mutex_table[hash]);
 		}
<span class="p_add">+		++next;</span>
 		huge_pagevec_release(&amp;pvec);
<span class="p_add">+		cond_resched();</span>
 	}
 
 	if (truncate_op)
<span class="p_chunk">@@ -647,9 +649,6 @@</span> <span class="p_context"> static long hugetlbfs_fallocate(struct file *file, int mode, loff_t offset,</span>
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp; offset + len &gt; inode-&gt;i_size)
 		i_size_write(inode, offset + len);
 	inode-&gt;i_ctime = CURRENT_TIME;
<span class="p_del">-	spin_lock(&amp;inode-&gt;i_lock);</span>
<span class="p_del">-	inode-&gt;i_private = NULL;</span>
<span class="p_del">-	spin_unlock(&amp;inode-&gt;i_lock);</span>
 out:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 	return error;
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 8c44654ce274..684996c8a3a4 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -427,7 +427,6 @@</span> <span class="p_context"> static int journal_clean_one_cp_list(struct journal_head *jh, bool destroy)</span>
 	struct journal_head *last_jh;
 	struct journal_head *next_jh = jh;
 	int ret;
<span class="p_del">-	int freed = 0;</span>
 
 	if (!jh)
 		return 0;
<span class="p_chunk">@@ -441,10 +440,9 @@</span> <span class="p_context"> static int journal_clean_one_cp_list(struct journal_head *jh, bool destroy)</span>
 		else
 			ret = __jbd2_journal_remove_checkpoint(jh) + 1;
 		if (!ret)
<span class="p_del">-			return freed;</span>
<span class="p_add">+			return 0;</span>
 		if (ret == 2)
 			return 1;
<span class="p_del">-		freed = 1;</span>
 		/*
 		 * This function only frees up some memory
 		 * if possible so we dont have an obligation
<span class="p_chunk">@@ -452,10 +450,10 @@</span> <span class="p_context"> static int journal_clean_one_cp_list(struct journal_head *jh, bool destroy)</span>
 		 * requested:
 		 */
 		if (need_resched())
<span class="p_del">-			return freed;</span>
<span class="p_add">+			return 0;</span>
 	} while (jh != last_jh);
 
<span class="p_del">-	return freed;</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 6b8338ec2464..1498ad9f731a 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -1009,7 +1009,8 @@</span> <span class="p_context"> out:</span>
 }
 
 /* Fast check whether buffer is already attached to the required transaction */
<span class="p_del">-static bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh)</span>
<span class="p_add">+static bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh,</span>
<span class="p_add">+							bool undo)</span>
 {
 	struct journal_head *jh;
 	bool ret = false;
<span class="p_chunk">@@ -1036,6 +1037,9 @@</span> <span class="p_context"> static bool jbd2_write_access_granted(handle_t *handle, struct buffer_head *bh)</span>
 	jh = READ_ONCE(bh-&gt;b_private);
 	if (!jh)
 		goto out;
<span class="p_add">+	/* For undo access buffer must have data copied */</span>
<span class="p_add">+	if (undo &amp;&amp; !jh-&gt;b_committed_data)</span>
<span class="p_add">+		goto out;</span>
 	if (jh-&gt;b_transaction != handle-&gt;h_transaction &amp;&amp;
 	    jh-&gt;b_next_transaction != handle-&gt;h_transaction)
 		goto out;
<span class="p_chunk">@@ -1073,7 +1077,7 @@</span> <span class="p_context"> int jbd2_journal_get_write_access(handle_t *handle, struct buffer_head *bh)</span>
 	struct journal_head *jh;
 	int rc;
 
<span class="p_del">-	if (jbd2_write_access_granted(handle, bh))</span>
<span class="p_add">+	if (jbd2_write_access_granted(handle, bh, false))</span>
 		return 0;
 
 	jh = jbd2_journal_add_journal_head(bh);
<span class="p_chunk">@@ -1210,7 +1214,7 @@</span> <span class="p_context"> int jbd2_journal_get_undo_access(handle_t *handle, struct buffer_head *bh)</span>
 	char *committed_data = NULL;
 
 	JBUFFER_TRACE(jh, &quot;entry&quot;);
<span class="p_del">-	if (jbd2_write_access_granted(handle, bh))</span>
<span class="p_add">+	if (jbd2_write_access_granted(handle, bh, true))</span>
 		return 0;
 
 	jh = jbd2_journal_add_journal_head(bh);
<span class="p_chunk">@@ -2152,6 +2156,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,</span>
 
 		if (!buffer_dirty(bh)) {
 			/* bdflush has written it.  We can drop it now */
<span class="p_add">+			__jbd2_journal_remove_checkpoint(jh);</span>
 			goto zap_buffer;
 		}
 
<span class="p_chunk">@@ -2181,6 +2186,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh,</span>
 				/* The orphan record&#39;s transaction has
 				 * committed.  We can cleanse this buffer */
 				clear_buffer_jbddirty(bh);
<span class="p_add">+				__jbd2_journal_remove_checkpoint(jh);</span>
 				goto zap_buffer;
 			}
 		}
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 5133bb18830e..c8bd1ddb7df8 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -8060,7 +8060,6 @@</span> <span class="p_context"> static void nfs4_layoutreturn_release(void *calldata)</span>
 		pnfs_set_layout_stateid(lo, &amp;lrp-&gt;res.stateid, true);
 	pnfs_mark_matching_lsegs_invalid(lo, &amp;freeme, &amp;lrp-&gt;args.range);
 	pnfs_clear_layoutreturn_waitbit(lo);
<span class="p_del">-	lo-&gt;plh_block_lgets--;</span>
 	spin_unlock(&amp;lo-&gt;plh_inode-&gt;i_lock);
 	pnfs_free_lseg_list(&amp;freeme);
 	pnfs_put_layout_hdr(lrp-&gt;args.layout);
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index ce38b4ccc9ab..5e355650eea0 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -2519,6 +2519,11 @@</span> <span class="p_context"> static int dlm_migrate_lockres(struct dlm_ctxt *dlm,</span>
 	spin_lock(&amp;dlm-&gt;master_lock);
 	ret = dlm_add_migration_mle(dlm, res, mle, &amp;oldmle, name,
 				    namelen, target, dlm-&gt;node_num);
<span class="p_add">+	/* get an extra reference on the mle.</span>
<span class="p_add">+	 * otherwise the assert_master from the new</span>
<span class="p_add">+	 * master will destroy this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dlm_get_mle_inuse(mle);</span>
 	spin_unlock(&amp;dlm-&gt;master_lock);
 	spin_unlock(&amp;dlm-&gt;spinlock);
 
<span class="p_chunk">@@ -2554,6 +2559,7 @@</span> <span class="p_context"> fail:</span>
 		if (mle_added) {
 			dlm_mle_detach_hb_events(dlm, mle);
 			dlm_put_mle(mle);
<span class="p_add">+			dlm_put_mle_inuse(mle);</span>
 		} else if (mle) {
 			kmem_cache_free(dlm_mle_cache, mle);
 			mle = NULL;
<span class="p_chunk">@@ -2571,17 +2577,6 @@</span> <span class="p_context"> fail:</span>
 	 * ensure that all assert_master work is flushed. */
 	flush_workqueue(dlm-&gt;dlm_worker);
 
<span class="p_del">-	/* get an extra reference on the mle.</span>
<span class="p_del">-	 * otherwise the assert_master from the new</span>
<span class="p_del">-	 * master will destroy this.</span>
<span class="p_del">-	 * also, make sure that all callers of dlm_get_mle</span>
<span class="p_del">-	 * take both dlm-&gt;spinlock and dlm-&gt;master_lock */</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	dlm_get_mle_inuse(mle);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-</span>
 	/* notify new node and send all lock state */
 	/* call send_one_lockres with migration flag.
 	 * this serves as notice to the target node that a
<span class="p_chunk">@@ -3310,6 +3305,15 @@</span> <span class="p_context"> top:</span>
 			    mle-&gt;new_master != dead_node)
 				continue;
 
<span class="p_add">+			if (mle-&gt;new_master == dead_node &amp;&amp; mle-&gt;inuse) {</span>
<span class="p_add">+				mlog(ML_NOTICE, &quot;%s: target %u died during &quot;</span>
<span class="p_add">+						&quot;migration from %u, the MLE is &quot;</span>
<span class="p_add">+						&quot;still keep used, ignore it!\n&quot;,</span>
<span class="p_add">+						dlm-&gt;name, dead_node,</span>
<span class="p_add">+						mle-&gt;master);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			/* If we have reached this point, this mle needs to be
 			 * removed from the list and freed. */
 			dlm_clean_migration_mle(dlm, mle);
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmrecovery.c b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">index 58eaa5c0d387..572a3dc4861f 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_chunk">@@ -2360,6 +2360,8 @@</span> <span class="p_context"> static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)</span>
 						break;
 					}
 				}
<span class="p_add">+				dlm_lockres_clear_refmap_bit(dlm, res,</span>
<span class="p_add">+						dead_node);</span>
 				spin_unlock(&amp;res-&gt;spinlock);
 				continue;
 			}
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 1c91103c1333..9a894aecc960 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -1390,6 +1390,7 @@</span> <span class="p_context"> static int __ocfs2_cluster_lock(struct ocfs2_super *osb,</span>
 	unsigned int gen;
 	int noqueue_attempted = 0;
 	int dlm_locked = 0;
<span class="p_add">+	int kick_dc = 0;</span>
 
 	if (!(lockres-&gt;l_flags &amp; OCFS2_LOCK_INITIALIZED)) {
 		mlog_errno(-EINVAL);
<span class="p_chunk">@@ -1524,7 +1525,12 @@</span> <span class="p_context"> update_holders:</span>
 unlock:
 	lockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);
 
<span class="p_add">+	/* ocfs2_unblock_lock reques on seeing OCFS2_LOCK_UPCONVERT_FINISHING */</span>
<span class="p_add">+	kick_dc = (lockres-&gt;l_flags &amp; OCFS2_LOCK_BLOCKED);</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;lockres-&gt;l_lock, flags);
<span class="p_add">+	if (kick_dc)</span>
<span class="p_add">+		ocfs2_wake_downconvert_thread(osb);</span>
 out:
 	/*
 	 * This is helping work around a lock inversion between the page lock
<span class="p_header">diff --git a/fs/ocfs2/namei.c b/fs/ocfs2/namei.c</span>
<span class="p_header">index 12bfa9ca5583..c0356c18cdf5 100644</span>
<span class="p_header">--- a/fs/ocfs2/namei.c</span>
<span class="p_header">+++ b/fs/ocfs2/namei.c</span>
<span class="p_chunk">@@ -369,13 +369,11 @@</span> <span class="p_context"> static int ocfs2_mknod(struct inode *dir,</span>
 		goto leave;
 	}
 
<span class="p_del">-	status = posix_acl_create(dir, &amp;mode, &amp;default_acl, &amp;acl);</span>
<span class="p_add">+	status = posix_acl_create(dir, &amp;inode-&gt;i_mode, &amp;default_acl, &amp;acl);</span>
 	if (status) {
 		mlog_errno(status);
 		goto leave;
 	}
<span class="p_del">-	/* update inode-&gt;i_mode after mask with &quot;umask&quot;. */</span>
<span class="p_del">-	inode-&gt;i_mode = mode;</span>
 
 	handle = ocfs2_start_trans(osb, ocfs2_mknod_credits(osb-&gt;sb,
 							    S_ISDIR(mode),
<span class="p_header">diff --git a/fs/ocfs2/resize.c b/fs/ocfs2/resize.c</span>
<span class="p_header">index d5da6f624142..79b8021302b3 100644</span>
<span class="p_header">--- a/fs/ocfs2/resize.c</span>
<span class="p_header">+++ b/fs/ocfs2/resize.c</span>
<span class="p_chunk">@@ -54,11 +54,12 @@</span> <span class="p_context"></span>
 static u16 ocfs2_calc_new_backup_super(struct inode *inode,
 				       struct ocfs2_group_desc *gd,
 				       u16 cl_cpg,
<span class="p_add">+				       u16 old_bg_clusters,</span>
 				       int set)
 {
 	int i;
 	u16 backups = 0;
<span class="p_del">-	u32 cluster;</span>
<span class="p_add">+	u32 cluster, lgd_cluster;</span>
 	u64 blkno, gd_blkno, lgd_blkno = le64_to_cpu(gd-&gt;bg_blkno);
 
 	for (i = 0; i &lt; OCFS2_MAX_BACKUP_SUPERBLOCKS; i++) {
<span class="p_chunk">@@ -71,6 +72,12 @@</span> <span class="p_context"> static u16 ocfs2_calc_new_backup_super(struct inode *inode,</span>
 		else if (gd_blkno &gt; lgd_blkno)
 			break;
 
<span class="p_add">+		/* check if already done backup super */</span>
<span class="p_add">+		lgd_cluster = ocfs2_blocks_to_clusters(inode-&gt;i_sb, lgd_blkno);</span>
<span class="p_add">+		lgd_cluster += old_bg_clusters;</span>
<span class="p_add">+		if (lgd_cluster &gt;= cluster)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		if (set)
 			ocfs2_set_bit(cluster % cl_cpg,
 				      (unsigned long *)gd-&gt;bg_bitmap);
<span class="p_chunk">@@ -99,6 +106,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 	u16 chain, num_bits, backups = 0;
 	u16 cl_bpc = le16_to_cpu(cl-&gt;cl_bpc);
 	u16 cl_cpg = le16_to_cpu(cl-&gt;cl_cpg);
<span class="p_add">+	u16 old_bg_clusters;</span>
 
 	trace_ocfs2_update_last_group_and_inode(new_clusters,
 						first_new_cluster);
<span class="p_chunk">@@ -112,6 +120,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 
 	group = (struct ocfs2_group_desc *)group_bh-&gt;b_data;
 
<span class="p_add">+	old_bg_clusters = le16_to_cpu(group-&gt;bg_bits) / cl_bpc;</span>
 	/* update the group first. */
 	num_bits = new_clusters * cl_bpc;
 	le16_add_cpu(&amp;group-&gt;bg_bits, num_bits);
<span class="p_chunk">@@ -125,7 +134,7 @@</span> <span class="p_context"> static int ocfs2_update_last_group_and_inode(handle_t *handle,</span>
 				     OCFS2_FEATURE_COMPAT_BACKUP_SB)) {
 		backups = ocfs2_calc_new_backup_super(bm_inode,
 						     group,
<span class="p_del">-						     cl_cpg, 1);</span>
<span class="p_add">+						     cl_cpg, old_bg_clusters, 1);</span>
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, -1 * backups);
 	}
 
<span class="p_chunk">@@ -163,7 +172,7 @@</span> <span class="p_context"> out_rollback:</span>
 	if (ret &lt; 0) {
 		ocfs2_calc_new_backup_super(bm_inode,
 					    group,
<span class="p_del">-					    cl_cpg, 0);</span>
<span class="p_add">+					    cl_cpg, old_bg_clusters, 0);</span>
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, backups);
 		le16_add_cpu(&amp;group-&gt;bg_bits, -1 * num_bits);
 		le16_add_cpu(&amp;group-&gt;bg_free_bits_count, -1 * num_bits);
<span class="p_header">diff --git a/fs/pipe.c b/fs/pipe.c</span>
<span class="p_header">index 8865f7963700..14788ddcd3f3 100644</span>
<span class="p_header">--- a/fs/pipe.c</span>
<span class="p_header">+++ b/fs/pipe.c</span>
<span class="p_chunk">@@ -366,18 +366,17 @@</span> <span class="p_context"> pipe_write(struct kiocb *iocb, struct iov_iter *from)</span>
 		int offset = buf-&gt;offset + buf-&gt;len;
 
 		if (ops-&gt;can_merge &amp;&amp; offset + chars &lt;= PAGE_SIZE) {
<span class="p_del">-			int error = ops-&gt;confirm(pipe, buf);</span>
<span class="p_del">-			if (error)</span>
<span class="p_add">+			ret = ops-&gt;confirm(pipe, buf);</span>
<span class="p_add">+			if (ret)</span>
 				goto out;
 
 			ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);
 			if (unlikely(ret &lt; chars)) {
<span class="p_del">-				error = -EFAULT;</span>
<span class="p_add">+				ret = -EFAULT;</span>
 				goto out;
 			}
 			do_wakeup = 1;
<span class="p_del">-			buf-&gt;len += chars;</span>
<span class="p_del">-			ret = chars;</span>
<span class="p_add">+			buf-&gt;len += ret;</span>
 			if (!iov_iter_count(from))
 				goto out;
 		}
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 29595af32866..4b6fb2cbd928 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -2484,6 +2484,7 @@</span> <span class="p_context"> static ssize_t proc_coredump_filter_write(struct file *file,</span>
 	mm = get_task_mm(task);
 	if (!mm)
 		goto out_no_mm;
<span class="p_add">+	ret = 0;</span>
 
 	for (i = 0, mask = 1; i &lt; MMF_DUMP_FILTER_BITS; i++, mask &lt;&lt;= 1) {
 		if (val &amp; mask)
<span class="p_header">diff --git a/fs/proc/fd.c b/fs/proc/fd.c</span>
<span class="p_header">index 6e5fcd00733e..3c2a915c695a 100644</span>
<span class="p_header">--- a/fs/proc/fd.c</span>
<span class="p_header">+++ b/fs/proc/fd.c</span>
<span class="p_chunk">@@ -291,11 +291,19 @@</span> <span class="p_context"> static struct dentry *proc_lookupfd(struct inode *dir, struct dentry *dentry,</span>
  */
 int proc_fd_permission(struct inode *inode, int mask)
 {
<span class="p_del">-	int rv = generic_permission(inode, mask);</span>
<span class="p_add">+	struct task_struct *p;</span>
<span class="p_add">+	int rv;</span>
<span class="p_add">+</span>
<span class="p_add">+	rv = generic_permission(inode, mask);</span>
 	if (rv == 0)
<span class="p_del">-		return 0;</span>
<span class="p_del">-	if (task_tgid(current) == proc_pid(inode))</span>
<span class="p_add">+		return rv;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	p = pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="p_add">+	if (p &amp;&amp; same_thread_group(p, current))</span>
 		rv = 0;
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	return rv;
 }
 
<span class="p_header">diff --git a/fs/seq_file.c b/fs/seq_file.c</span>
<span class="p_header">index 225586e141ca..a8e288755f24 100644</span>
<span class="p_header">--- a/fs/seq_file.c</span>
<span class="p_header">+++ b/fs/seq_file.c</span>
<span class="p_chunk">@@ -25,12 +25,17 @@</span> <span class="p_context"> static void seq_set_overflow(struct seq_file *m)</span>
 static void *seq_buf_alloc(unsigned long size)
 {
 	void *buf;
<span class="p_add">+	gfp_t gfp = GFP_KERNEL;</span>
 
 	/*
<span class="p_del">-	 * __GFP_NORETRY to avoid oom-killings with high-order allocations -</span>
<span class="p_del">-	 * it&#39;s better to fall back to vmalloc() than to kill things.</span>
<span class="p_add">+	 * For high order allocations, use __GFP_NORETRY to avoid oom-killing -</span>
<span class="p_add">+	 * it&#39;s better to fall back to vmalloc() than to kill things.  For small</span>
<span class="p_add">+	 * allocations, just use GFP_KERNEL which will oom kill, thus no need</span>
<span class="p_add">+	 * for vmalloc fallback.</span>
 	 */
<span class="p_del">-	buf = kmalloc(size, GFP_KERNEL | __GFP_NORETRY | __GFP_NOWARN);</span>
<span class="p_add">+	if (size &gt; PAGE_SIZE)</span>
<span class="p_add">+		gfp |= __GFP_NORETRY | __GFP_NOWARN;</span>
<span class="p_add">+	buf = kmalloc(size, gfp);</span>
 	if (!buf &amp;&amp; size &gt; PAGE_SIZE)
 		buf = vmalloc(size);
 	return buf;
<span class="p_header">diff --git a/fs/sysv/inode.c b/fs/sysv/inode.c</span>
<span class="p_header">index 590ad9206e3f..02fa1dcc5969 100644</span>
<span class="p_header">--- a/fs/sysv/inode.c</span>
<span class="p_header">+++ b/fs/sysv/inode.c</span>
<span class="p_chunk">@@ -162,15 +162,8 @@</span> <span class="p_context"> void sysv_set_inode(struct inode *inode, dev_t rdev)</span>
 		inode-&gt;i_fop = &amp;sysv_dir_operations;
 		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;
 	} else if (S_ISLNK(inode-&gt;i_mode)) {
<span class="p_del">-		if (inode-&gt;i_blocks) {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_del">-			inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;simple_symlink_inode_operations;</span>
<span class="p_del">-			inode-&gt;i_link = (char *)SYSV_I(inode)-&gt;i_data;</span>
<span class="p_del">-			nd_terminate_link(inode-&gt;i_link, inode-&gt;i_size,</span>
<span class="p_del">-				sizeof(SYSV_I(inode)-&gt;i_data) - 1);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_add">+		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
 	} else
 		init_special_inode(inode, inode-&gt;i_mode, rdev);
 }
<span class="p_header">diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.c</span>
<span class="p_header">index cbc8d5d2755a..c66f2423e1f5 100644</span>
<span class="p_header">--- a/fs/tracefs/inode.c</span>
<span class="p_header">+++ b/fs/tracefs/inode.c</span>
<span class="p_chunk">@@ -340,8 +340,12 @@</span> <span class="p_context"> static struct dentry *start_creating(const char *name, struct dentry *parent)</span>
 		dput(dentry);
 		dentry = ERR_PTR(-EEXIST);
 	}
<span class="p_del">-	if (IS_ERR(dentry))</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ERR(dentry)) {</span>
 		mutex_unlock(&amp;parent-&gt;d_inode-&gt;i_mutex);
<span class="p_add">+		simple_release_fs(&amp;tracefs_mount, &amp;tracefs_mount_count);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return dentry;
 }
 
<span class="p_header">diff --git a/include/crypto/hash.h b/include/crypto/hash.h</span>
<span class="p_header">index 8e920b44c0ac..da791ac52f13 100644</span>
<span class="p_header">--- a/include/crypto/hash.h</span>
<span class="p_header">+++ b/include/crypto/hash.h</span>
<span class="p_chunk">@@ -204,6 +204,7 @@</span> <span class="p_context"> struct crypto_ahash {</span>
 		      unsigned int keylen);
 
 	unsigned int reqsize;
<span class="p_add">+	bool has_setkey;</span>
 	struct crypto_tfm base;
 };
 
<span class="p_chunk">@@ -361,6 +362,11 @@</span> <span class="p_context"> static inline void *ahash_request_ctx(struct ahash_request *req)</span>
 int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
 			unsigned int keylen);
 
<span class="p_add">+static inline bool crypto_ahash_has_setkey(struct crypto_ahash *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return tfm-&gt;has_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * crypto_ahash_finup() - update and finalize message digest
  * @req: reference to the ahash_request handle that holds all information
<span class="p_header">diff --git a/include/crypto/if_alg.h b/include/crypto/if_alg.h</span>
<span class="p_header">index 018afb264ac2..a2bfd7843f18 100644</span>
<span class="p_header">--- a/include/crypto/if_alg.h</span>
<span class="p_header">+++ b/include/crypto/if_alg.h</span>
<span class="p_chunk">@@ -30,6 +30,9 @@</span> <span class="p_context"> struct alg_sock {</span>
 
 	struct sock *parent;
 
<span class="p_add">+	unsigned int refcnt;</span>
<span class="p_add">+	unsigned int nokey_refcnt;</span>
<span class="p_add">+</span>
 	const struct af_alg_type *type;
 	void *private;
 };
<span class="p_chunk">@@ -50,9 +53,11 @@</span> <span class="p_context"> struct af_alg_type {</span>
 	void (*release)(void *private);
 	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
 	int (*accept)(void *private, struct sock *sk);
<span class="p_add">+	int (*accept_nokey)(void *private, struct sock *sk);</span>
 	int (*setauthsize)(void *private, unsigned int authsize);
 
 	struct proto_ops *ops;
<span class="p_add">+	struct proto_ops *ops_nokey;</span>
 	struct module *owner;
 	char name[14];
 };
<span class="p_chunk">@@ -67,6 +72,7 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type);</span>
 int af_alg_unregister_type(const struct af_alg_type *type);
 
 int af_alg_release(struct socket *sock);
<span class="p_add">+void af_alg_release_parent(struct sock *sk);</span>
 int af_alg_accept(struct sock *sk, struct socket *newsock);
 
 int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len);
<span class="p_chunk">@@ -83,11 +89,6 @@</span> <span class="p_context"> static inline struct alg_sock *alg_sk(struct sock *sk)</span>
 	return (struct alg_sock *)sk;
 }
 
<span class="p_del">-static inline void af_alg_release_parent(struct sock *sk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	sock_put(alg_sk(sk)-&gt;parent);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void af_alg_init_completion(struct af_alg_completion *completion)
 {
 	init_completion(&amp;completion-&gt;completion);
<span class="p_header">diff --git a/include/crypto/skcipher.h b/include/crypto/skcipher.h</span>
<span class="p_header">index d8dd41fb034f..fd8742a40ff3 100644</span>
<span class="p_header">--- a/include/crypto/skcipher.h</span>
<span class="p_header">+++ b/include/crypto/skcipher.h</span>
<span class="p_chunk">@@ -61,6 +61,8 @@</span> <span class="p_context"> struct crypto_skcipher {</span>
 	unsigned int ivsize;
 	unsigned int reqsize;
 
<span class="p_add">+	bool has_setkey;</span>
<span class="p_add">+</span>
 	struct crypto_tfm base;
 };
 
<span class="p_chunk">@@ -305,6 +307,11 @@</span> <span class="p_context"> static inline int crypto_skcipher_setkey(struct crypto_skcipher *tfm,</span>
 	return tfm-&gt;setkey(tfm, key, keylen);
 }
 
<span class="p_add">+static inline bool crypto_skcipher_has_setkey(struct crypto_skcipher *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return tfm-&gt;has_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * crypto_skcipher_reqtfm() - obtain cipher handle from request
  * @req: skcipher_request out of which the cipher handle is to be obtained
<span class="p_header">diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h</span>
<span class="p_header">index 19c2e947d4d1..3a3ff074782f 100644</span>
<span class="p_header">--- a/include/linux/blkdev.h</span>
<span class="p_header">+++ b/include/linux/blkdev.h</span>
<span class="p_chunk">@@ -767,7 +767,6 @@</span> <span class="p_context"> extern void blk_rq_set_block_pc(struct request *);</span>
 extern void blk_requeue_request(struct request_queue *, struct request *);
 extern void blk_add_request_payload(struct request *rq, struct page *page,
 		unsigned int len);
<span class="p_del">-extern int blk_rq_check_limits(struct request_queue *q, struct request *rq);</span>
 extern int blk_lld_busy(struct request_queue *q);
 extern int blk_rq_prep_clone(struct request *rq, struct request *rq_src,
 			     struct bio_set *bs, gfp_t gfp_mask,
<span class="p_header">diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.h</span>
<span class="p_header">index 76dd4f0da5ca..2ead22dd74a0 100644</span>
<span class="p_header">--- a/include/linux/hrtimer.h</span>
<span class="p_header">+++ b/include/linux/hrtimer.h</span>
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> enum hrtimer_restart {</span>
  * @function:	timer expiry callback function
  * @base:	pointer to the timer base (per cpu and per clock)
  * @state:	state information (See bit values above)
<span class="p_del">- * @start_pid: timer statistics field to store the pid of the task which</span>
<span class="p_add">+ * @is_rel:	Set if the timer was armed relative</span>
<span class="p_add">+ * @start_pid:  timer statistics field to store the pid of the task which</span>
  *		started the timer
  * @start_site:	timer statistics field to store the site where the timer
  *		was started
<span class="p_chunk">@@ -101,7 +102,8 @@</span> <span class="p_context"> struct hrtimer {</span>
 	ktime_t				_softexpires;
 	enum hrtimer_restart		(*function)(struct hrtimer *);
 	struct hrtimer_clock_base	*base;
<span class="p_del">-	unsigned long			state;</span>
<span class="p_add">+	u8				state;</span>
<span class="p_add">+	u8				is_rel;</span>
 #ifdef CONFIG_TIMER_STATS
 	int				start_pid;
 	void				*start_site;
<span class="p_chunk">@@ -321,6 +323,27 @@</span> <span class="p_context"> static inline void clock_was_set_delayed(void) { }</span>
 
 #endif
 
<span class="p_add">+static inline ktime_t</span>
<span class="p_add">+__hrtimer_expires_remaining_adjusted(const struct hrtimer *timer, ktime_t now)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ktime_t rem = ktime_sub(timer-&gt;node.expires, now);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Adjust relative timers for the extra we added in</span>
<span class="p_add">+	 * hrtimer_start_range_ns() to prevent short timeouts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_TIME_LOW_RES) &amp;&amp; timer-&gt;is_rel)</span>
<span class="p_add">+		rem.tv64 -= hrtimer_resolution;</span>
<span class="p_add">+	return rem;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline ktime_t</span>
<span class="p_add">+hrtimer_expires_remaining_adjusted(const struct hrtimer *timer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __hrtimer_expires_remaining_adjusted(timer,</span>
<span class="p_add">+						    timer-&gt;base-&gt;get_time());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern void clock_was_set(void);
 #ifdef CONFIG_TIMERFD
 extern void timerfd_clock_was_set(void);
<span class="p_chunk">@@ -390,7 +413,12 @@</span> <span class="p_context"> static inline void hrtimer_restart(struct hrtimer *timer)</span>
 }
 
 /* Query timers: */
<span class="p_del">-extern ktime_t hrtimer_get_remaining(const struct hrtimer *timer);</span>
<span class="p_add">+extern ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline ktime_t hrtimer_get_remaining(const struct hrtimer *timer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __hrtimer_get_remaining(timer, false);</span>
<span class="p_add">+}</span>
 
 extern u64 hrtimer_get_next_event(void);
 
<span class="p_header">diff --git a/include/linux/signal.h b/include/linux/signal.h</span>
<span class="p_header">index ab1e0392b5ac..92557bbce7e7 100644</span>
<span class="p_header">--- a/include/linux/signal.h</span>
<span class="p_header">+++ b/include/linux/signal.h</span>
<span class="p_chunk">@@ -239,7 +239,6 @@</span> <span class="p_context"> extern int sigprocmask(int, sigset_t *, sigset_t *);</span>
 extern void set_current_blocked(sigset_t *);
 extern void __set_current_blocked(const sigset_t *);
 extern int show_unhandled_signals;
<span class="p_del">-extern int sigsuspend(sigset_t *);</span>
 
 struct sigaction {
 #ifndef __ARCH_HAS_IRIX_SIGACTION
<span class="p_header">diff --git a/include/sound/rawmidi.h b/include/sound/rawmidi.h</span>
<span class="p_header">index f6cbef78db62..3b91ad5d5115 100644</span>
<span class="p_header">--- a/include/sound/rawmidi.h</span>
<span class="p_header">+++ b/include/sound/rawmidi.h</span>
<span class="p_chunk">@@ -167,6 +167,10 @@</span> <span class="p_context"> int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count);
 int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream,
 			 unsigned char *buffer, int count);
<span class="p_add">+int __snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+			      unsigned char *buffer, int count);</span>
<span class="p_add">+int __snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+			       int count);</span>
 
 /* main midi functions */
 
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index 8f0324ef72ab..9982616ce712 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -269,6 +269,9 @@</span> <span class="p_context"> static u32 clear_idx;</span>
 #define PREFIX_MAX		32
 #define LOG_LINE_MAX		(1024 - PREFIX_MAX)
 
<span class="p_add">+#define LOG_LEVEL(v)		((v) &amp; 0x07)</span>
<span class="p_add">+#define LOG_FACILITY(v)		((v) &gt;&gt; 3 &amp; 0xff)</span>
<span class="p_add">+</span>
 /* record buffer */
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
 #define LOG_ALIGN 4
<span class="p_chunk">@@ -611,7 +614,6 @@</span> <span class="p_context"> struct devkmsg_user {</span>
 static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)
 {
 	char *buf, *line;
<span class="p_del">-	int i;</span>
 	int level = default_message_loglevel;
 	int facility = 1;	/* LOG_USER */
 	size_t len = iov_iter_count(from);
<span class="p_chunk">@@ -641,12 +643,13 @@</span> <span class="p_context"> static ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)</span>
 	line = buf;
 	if (line[0] == &#39;&lt;&#39;) {
 		char *endp = NULL;
<span class="p_add">+		unsigned int u;</span>
 
<span class="p_del">-		i = simple_strtoul(line+1, &amp;endp, 10);</span>
<span class="p_add">+		u = simple_strtoul(line + 1, &amp;endp, 10);</span>
 		if (endp &amp;&amp; endp[0] == &#39;&gt;&#39;) {
<span class="p_del">-			level = i &amp; 7;</span>
<span class="p_del">-			if (i &gt;&gt; 3)</span>
<span class="p_del">-				facility = i &gt;&gt; 3;</span>
<span class="p_add">+			level = LOG_LEVEL(u);</span>
<span class="p_add">+			if (LOG_FACILITY(u) != 0)</span>
<span class="p_add">+				facility = LOG_FACILITY(u);</span>
 			endp++;
 			len -= endp - line;
 			line = endp;
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index bcd214e4b4d6..9a584b204e85 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -6678,7 +6678,7 @@</span> <span class="p_context"> static void sched_init_numa(void)</span>
 
 			sched_domains_numa_masks[i][j] = mask;
 
<span class="p_del">-			for (k = 0; k &lt; nr_node_ids; k++) {</span>
<span class="p_add">+			for_each_node(k) {</span>
 				if (node_distance(j, k) &gt; sched_domains_numa_distance[i])
 					continue;
 
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index 0f6bbbe77b46..6c863ca42a76 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -3552,7 +3552,7 @@</span> <span class="p_context"> SYSCALL_DEFINE0(pause)</span>
 
 #endif
 
<span class="p_del">-int sigsuspend(sigset_t *set)</span>
<span class="p_add">+static int sigsuspend(sigset_t *set)</span>
 {
 	current-&gt;saved_sigmask = current-&gt;blocked;
 	set_current_blocked(set);
<span class="p_header">diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c</span>
<span class="p_header">index 457a373e2181..8be98288dcbc 100644</span>
<span class="p_header">--- a/kernel/time/hrtimer.c</span>
<span class="p_header">+++ b/kernel/time/hrtimer.c</span>
<span class="p_chunk">@@ -897,10 +897,10 @@</span> <span class="p_context"> static int enqueue_hrtimer(struct hrtimer *timer,</span>
  */
 static void __remove_hrtimer(struct hrtimer *timer,
 			     struct hrtimer_clock_base *base,
<span class="p_del">-			     unsigned long newstate, int reprogram)</span>
<span class="p_add">+			     u8 newstate, int reprogram)</span>
 {
 	struct hrtimer_cpu_base *cpu_base = base-&gt;cpu_base;
<span class="p_del">-	unsigned int state = timer-&gt;state;</span>
<span class="p_add">+	u8 state = timer-&gt;state;</span>
 
 	timer-&gt;state = newstate;
 	if (!(state &amp; HRTIMER_STATE_ENQUEUED))
<span class="p_chunk">@@ -930,7 +930,7 @@</span> <span class="p_context"> static inline int</span>
 remove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)
 {
 	if (hrtimer_is_queued(timer)) {
<span class="p_del">-		unsigned long state = timer-&gt;state;</span>
<span class="p_add">+		u8 state = timer-&gt;state;</span>
 		int reprogram;
 
 		/*
<span class="p_chunk">@@ -954,6 +954,22 @@</span> <span class="p_context"> remove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool rest</span>
 	return 0;
 }
 
<span class="p_add">+static inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,</span>
<span class="p_add">+					    const enum hrtimer_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_TIME_LOW_RES</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * CONFIG_TIME_LOW_RES indicates that the system has no way to return</span>
<span class="p_add">+	 * granular time values. For relative timers we add hrtimer_resolution</span>
<span class="p_add">+	 * (i.e. one jiffie) to prevent short timeouts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	timer-&gt;is_rel = mode &amp; HRTIMER_MODE_REL;</span>
<span class="p_add">+	if (timer-&gt;is_rel)</span>
<span class="p_add">+		tim = ktime_add_safe(tim, ktime_set(0, hrtimer_resolution));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return tim;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * hrtimer_start_range_ns - (re)start an hrtimer on the current CPU
  * @timer:	the timer to be added
<span class="p_chunk">@@ -974,19 +990,10 @@</span> <span class="p_context"> void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,</span>
 	/* Remove an active timer from the queue: */
 	remove_hrtimer(timer, base, true);
 
<span class="p_del">-	if (mode &amp; HRTIMER_MODE_REL) {</span>
<span class="p_add">+	if (mode &amp; HRTIMER_MODE_REL)</span>
 		tim = ktime_add_safe(tim, base-&gt;get_time());
<span class="p_del">-		/*</span>
<span class="p_del">-		 * CONFIG_TIME_LOW_RES is a temporary way for architectures</span>
<span class="p_del">-		 * to signal that they simply return xtime in</span>
<span class="p_del">-		 * do_gettimeoffset(). In this case we want to round up by</span>
<span class="p_del">-		 * resolution when starting a relative timer, to avoid short</span>
<span class="p_del">-		 * timeouts. This will go away with the GTOD framework.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-#ifdef CONFIG_TIME_LOW_RES</span>
<span class="p_del">-		tim = ktime_add_safe(tim, ktime_set(0, hrtimer_resolution));</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tim = hrtimer_update_lowres(timer, tim, mode);</span>
 
 	hrtimer_set_expires_range_ns(timer, tim, delta_ns);
 
<span class="p_chunk">@@ -1074,19 +1081,23 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(hrtimer_cancel);</span>
 /**
  * hrtimer_get_remaining - get remaining time for the timer
  * @timer:	the timer to read
<span class="p_add">+ * @adjust:	adjust relative timers when CONFIG_TIME_LOW_RES=y</span>
  */
<span class="p_del">-ktime_t hrtimer_get_remaining(const struct hrtimer *timer)</span>
<span class="p_add">+ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)</span>
 {
 	unsigned long flags;
 	ktime_t rem;
 
 	lock_hrtimer_base(timer, &amp;flags);
<span class="p_del">-	rem = hrtimer_expires_remaining(timer);</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_TIME_LOW_RES) &amp;&amp; adjust)</span>
<span class="p_add">+		rem = hrtimer_expires_remaining_adjusted(timer);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		rem = hrtimer_expires_remaining(timer);</span>
 	unlock_hrtimer_base(timer, &amp;flags);
 
 	return rem;
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(hrtimer_get_remaining);</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(__hrtimer_get_remaining);</span>
 
 #ifdef CONFIG_NO_HZ_COMMON
 /**
<span class="p_chunk">@@ -1220,6 +1231,14 @@</span> <span class="p_context"> static void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,</span>
 	fn = timer-&gt;function;
 
 	/*
<span class="p_add">+	 * Clear the &#39;is relative&#39; flag for the TIME_LOW_RES case. If the</span>
<span class="p_add">+	 * timer is restarted with a period then it becomes an absolute</span>
<span class="p_add">+	 * timer. If its not restarted it does not matter.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_TIME_LOW_RES))</span>
<span class="p_add">+		timer-&gt;is_rel = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Because we run timers from hardirq context, there is no chance
 	 * they get migrated to another cpu, therefore its safe to unlock
 	 * the timer base.
<span class="p_header">diff --git a/kernel/time/timer_list.c b/kernel/time/timer_list.c</span>
<span class="p_header">index f75e35b60149..ba7d8b288bb3 100644</span>
<span class="p_header">--- a/kernel/time/timer_list.c</span>
<span class="p_header">+++ b/kernel/time/timer_list.c</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,</span>
 	print_name_offset(m, taddr);
 	SEQ_printf(m, &quot;, &quot;);
 	print_name_offset(m, timer-&gt;function);
<span class="p_del">-	SEQ_printf(m, &quot;, S:%02lx&quot;, timer-&gt;state);</span>
<span class="p_add">+	SEQ_printf(m, &quot;, S:%02x&quot;, timer-&gt;state);</span>
 #ifdef CONFIG_TIMER_STATS
 	SEQ_printf(m, &quot;, &quot;);
 	print_name_offset(m, timer-&gt;start_site);
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 6e79408674aa..69f97541ce6e 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -6602,7 +6602,7 @@</span> <span class="p_context"> static int instance_rmdir(const char *name)</span>
 	tracing_set_nop(tr);
 	event_trace_del_tracer(tr);
 	ftrace_destroy_function_files(tr);
<span class="p_del">-	debugfs_remove_recursive(tr-&gt;dir);</span>
<span class="p_add">+	tracefs_remove_recursive(tr-&gt;dir);</span>
 	free_trace_buffers(tr);
 
 	kfree(tr-&gt;name);
<span class="p_header">diff --git a/kernel/trace/trace_printk.c b/kernel/trace/trace_printk.c</span>
<span class="p_header">index 36c1455b7567..2dbffe22cbcf 100644</span>
<span class="p_header">--- a/kernel/trace/trace_printk.c</span>
<span class="p_header">+++ b/kernel/trace/trace_printk.c</span>
<span class="p_chunk">@@ -267,6 +267,7 @@</span> <span class="p_context"> static const char **find_next(void *v, loff_t *pos)</span>
 	if (*pos &lt; last_index + start_index)
 		return __start___tracepoint_str + (*pos - last_index);
 
<span class="p_add">+	start_index += last_index;</span>
 	return find_next_mod_format(start_index, v, fmt, pos);
 }
 
<span class="p_header">diff --git a/lib/hexdump.c b/lib/hexdump.c</span>
<span class="p_header">index 8d74c20d8595..992457b1284c 100644</span>
<span class="p_header">--- a/lib/hexdump.c</span>
<span class="p_header">+++ b/lib/hexdump.c</span>
<span class="p_chunk">@@ -169,11 +169,15 @@</span> <span class="p_context"> int hex_dump_to_buffer(const void *buf, size_t len, int rowsize, int groupsize,</span>
 		}
 	} else {
 		for (j = 0; j &lt; len; j++) {
<span class="p_del">-			if (linebuflen &lt; lx + 3)</span>
<span class="p_add">+			if (linebuflen &lt; lx + 2)</span>
 				goto overflow2;
 			ch = ptr[j];
 			linebuf[lx++] = hex_asc_hi(ch);
<span class="p_add">+			if (linebuflen &lt; lx + 2)</span>
<span class="p_add">+				goto overflow2;</span>
 			linebuf[lx++] = hex_asc_lo(ch);
<span class="p_add">+			if (linebuflen &lt; lx + 2)</span>
<span class="p_add">+				goto overflow2;</span>
 			linebuf[lx++] = &#39; &#39;;
 		}
 		if (j)
<span class="p_header">diff --git a/lib/libcrc32c.c b/lib/libcrc32c.c</span>
<span class="p_header">index 6a08ce7d6adc..acf9da449f81 100644</span>
<span class="p_header">--- a/lib/libcrc32c.c</span>
<span class="p_header">+++ b/lib/libcrc32c.c</span>
<span class="p_chunk">@@ -74,3 +74,4 @@</span> <span class="p_context"> module_exit(libcrc32c_mod_fini);</span>
 MODULE_AUTHOR(&quot;Clay Haapala &lt;chaapala@cisco.com&gt;&quot;);
 MODULE_DESCRIPTION(&quot;CRC32c (Castagnoli) calculations&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_add">+MODULE_SOFTDEP(&quot;pre: crc32c&quot;);</span>
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index 619984fc07ec..4cf30e1ca163 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -957,8 +957,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(congestion_wait);</span>
  * jiffies for either a BDI to exit congestion of the given @sync queue
  * or a write to complete.
  *
<span class="p_del">- * In the absence of zone congestion, cond_resched() is called to yield</span>
<span class="p_del">- * the processor if necessary but otherwise does not sleep.</span>
<span class="p_add">+ * In the absence of zone congestion, a short sleep or a cond_resched is</span>
<span class="p_add">+ * performed to yield the processor and to allow other subsystems to make</span>
<span class="p_add">+ * a forward progress.</span>
  *
  * The return value is 0 if the sleep is for the full timeout. Otherwise,
  * it is the number of jiffies that were still remaining when the function
<span class="p_chunk">@@ -978,7 +979,19 @@</span> <span class="p_context"> long wait_iff_congested(struct zone *zone, int sync, long timeout)</span>
 	 */
 	if (atomic_read(&amp;nr_wb_congested[sync]) == 0 ||
 	    !test_bit(ZONE_CONGESTED, &amp;zone-&gt;flags)) {
<span class="p_del">-		cond_resched();</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Memory allocation/reclaim might be called from a WQ</span>
<span class="p_add">+		 * context and the current implementation of the WQ</span>
<span class="p_add">+		 * concurrency control doesn&#39;t recognize that a particular</span>
<span class="p_add">+		 * WQ is congested if the worker thread is looping without</span>
<span class="p_add">+		 * ever sleeping. Therefore we have to do a short sleep</span>
<span class="p_add">+		 * here rather than calling cond_resched().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (current-&gt;flags &amp; PF_WQ_WORKER)</span>
<span class="p_add">+			schedule_timeout_uninterruptible(1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			cond_resched();</span>
 
 		/* In case we scheduled, work out time remaining */
 		ret = timeout - (jiffies - start);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 9cc773483624..960f0ace6824 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -372,8 +372,10 @@</span> <span class="p_context"> retry_locked:</span>
 		spin_unlock(&amp;resv-&gt;lock);
 
 		trg = kmalloc(sizeof(*trg), GFP_KERNEL);
<span class="p_del">-		if (!trg)</span>
<span class="p_add">+		if (!trg) {</span>
<span class="p_add">+			kfree(nrg);</span>
 			return -ENOMEM;
<span class="p_add">+		}</span>
 
 		spin_lock(&amp;resv-&gt;lock);
 		list_add(&amp;trg-&gt;link, &amp;resv-&gt;region_cache);
<span class="p_chunk">@@ -483,8 +485,16 @@</span> <span class="p_context"> static long region_del(struct resv_map *resv, long f, long t)</span>
 retry:
 	spin_lock(&amp;resv-&gt;lock);
 	list_for_each_entry_safe(rg, trg, head, link) {
<span class="p_del">-		if (rg-&gt;to &lt;= f)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Skip regions before the range to be deleted.  file_region</span>
<span class="p_add">+		 * ranges are normally of the form [from, to).  However, there</span>
<span class="p_add">+		 * may be a &quot;placeholder&quot; entry in the map which is of the form</span>
<span class="p_add">+		 * (from, to) with from == to.  Check for placeholder entries</span>
<span class="p_add">+		 * at the beginning of the range to be deleted.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (rg-&gt;to &lt;= f &amp;&amp; (rg-&gt;to != rg-&gt;from || rg-&gt;to != f))</span>
 			continue;
<span class="p_add">+</span>
 		if (rg-&gt;from &gt;= t)
 			break;
 
<span class="p_chunk">@@ -1790,7 +1800,10 @@</span> <span class="p_context"> struct page *alloc_huge_page(struct vm_area_struct *vma,</span>
 		page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
 		if (!page)
 			goto out_uncharge_cgroup;
<span class="p_del">-</span>
<span class="p_add">+		if (!avoid_reserve &amp;&amp; vma_has_reserves(vma, gbl_chg)) {</span>
<span class="p_add">+			SetPagePrivate(page);</span>
<span class="p_add">+			h-&gt;resv_huge_pages--;</span>
<span class="p_add">+		}</span>
 		spin_lock(&amp;hugetlb_lock);
 		list_move(&amp;page-&gt;lru, &amp;h-&gt;hugepage_activelist);
 		/* Fall through */
<span class="p_chunk">@@ -3587,12 +3600,12 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))
 			return VM_FAULT_HWPOISON_LARGE |
 				VM_FAULT_SET_HINDEX(hstate_index(h));
<span class="p_add">+	} else {</span>
<span class="p_add">+		ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_add">+		if (!ptep)</span>
<span class="p_add">+			return VM_FAULT_OOM;</span>
 	}
 
<span class="p_del">-	ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_del">-	if (!ptep)</span>
<span class="p_del">-		return VM_FAULT_OOM;</span>
<span class="p_del">-</span>
 	mapping = vma-&gt;vm_file-&gt;f_mapping;
 	idx = vma_hugecache_offset(h, vma, address);
 
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index c57c4423c688..2233233282c6 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -902,14 +902,20 @@</span> <span class="p_context"> struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,</span>
 		if (prev &amp;&amp; reclaim-&gt;generation != iter-&gt;generation)
 			goto out_unlock;
 
<span class="p_del">-		do {</span>
<span class="p_add">+		while (1) {</span>
 			pos = READ_ONCE(iter-&gt;position);
<span class="p_add">+			if (!pos || css_tryget(&amp;pos-&gt;css))</span>
<span class="p_add">+				break;</span>
 			/*
<span class="p_del">-			 * A racing update may change the position and</span>
<span class="p_del">-			 * put the last reference, hence css_tryget(),</span>
<span class="p_del">-			 * or retry to see the updated position.</span>
<span class="p_add">+			 * css reference reached zero, so iter-&gt;position will</span>
<span class="p_add">+			 * be cleared by -&gt;css_released. However, we should not</span>
<span class="p_add">+			 * rely on this happening soon, because -&gt;css_released</span>
<span class="p_add">+			 * is called from a work queue, and by busy-waiting we</span>
<span class="p_add">+			 * might block it. So we clear iter-&gt;position right</span>
<span class="p_add">+			 * away.</span>
 			 */
<span class="p_del">-		} while (pos &amp;&amp; !css_tryget(&amp;pos-&gt;css));</span>
<span class="p_add">+			(void)cmpxchg(&amp;iter-&gt;position, pos, NULL);</span>
<span class="p_add">+		}</span>
 	}
 
 	if (pos)
<span class="p_chunk">@@ -955,17 +961,13 @@</span> <span class="p_context"> struct mem_cgroup *mem_cgroup_iter(struct mem_cgroup *root,</span>
 	}
 
 	if (reclaim) {
<span class="p_del">-		if (cmpxchg(&amp;iter-&gt;position, pos, memcg) == pos) {</span>
<span class="p_del">-			if (memcg)</span>
<span class="p_del">-				css_get(&amp;memcg-&gt;css);</span>
<span class="p_del">-			if (pos)</span>
<span class="p_del">-				css_put(&amp;pos-&gt;css);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		/*
<span class="p_del">-		 * pairs with css_tryget when dereferencing iter-&gt;position</span>
<span class="p_del">-		 * above.</span>
<span class="p_add">+		 * The position could have already been updated by a competing</span>
<span class="p_add">+		 * thread, so check that the value hasn&#39;t changed since we read</span>
<span class="p_add">+		 * it to avoid reclaiming from the same cgroup twice.</span>
 		 */
<span class="p_add">+		(void)cmpxchg(&amp;iter-&gt;position, pos, memcg);</span>
<span class="p_add">+</span>
 		if (pos)
 			css_put(&amp;pos-&gt;css);
 
<span class="p_chunk">@@ -998,6 +1000,28 @@</span> <span class="p_context"> void mem_cgroup_iter_break(struct mem_cgroup *root,</span>
 		css_put(&amp;prev-&gt;css);
 }
 
<span class="p_add">+static void invalidate_reclaim_iterators(struct mem_cgroup *dead_memcg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mem_cgroup *memcg = dead_memcg;</span>
<span class="p_add">+	struct mem_cgroup_reclaim_iter *iter;</span>
<span class="p_add">+	struct mem_cgroup_per_zone *mz;</span>
<span class="p_add">+	int nid, zid;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((memcg = parent_mem_cgroup(memcg))) {</span>
<span class="p_add">+		for_each_node(nid) {</span>
<span class="p_add">+			for (zid = 0; zid &lt; MAX_NR_ZONES; zid++) {</span>
<span class="p_add">+				mz = &amp;memcg-&gt;nodeinfo[nid]-&gt;zoneinfo[zid];</span>
<span class="p_add">+				for (i = 0; i &lt;= DEF_PRIORITY; i++) {</span>
<span class="p_add">+					iter = &amp;mz-&gt;iter[i];</span>
<span class="p_add">+					cmpxchg(&amp;iter-&gt;position,</span>
<span class="p_add">+						dead_memcg, NULL);</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Iteration constructs for visiting all cgroups (under a tree).  If
  * loops are exited prematurely (break), mem_cgroup_iter_break() must
<span class="p_chunk">@@ -2836,9 +2860,9 @@</span> <span class="p_context"> static unsigned long tree_stat(struct mem_cgroup *memcg,</span>
 	return val;
 }
 
<span class="p_del">-static inline u64 mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)</span>
<span class="p_add">+static inline unsigned long mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)</span>
 {
<span class="p_del">-	u64 val;</span>
<span class="p_add">+	unsigned long val;</span>
 
 	if (mem_cgroup_is_root(memcg)) {
 		val = tree_stat(memcg, MEM_CGROUP_STAT_CACHE);
<span class="p_chunk">@@ -2851,7 +2875,7 @@</span> <span class="p_context"> static inline u64 mem_cgroup_usage(struct mem_cgroup *memcg, bool swap)</span>
 		else
 			val = page_counter_read(&amp;memcg-&gt;memsw);
 	}
<span class="p_del">-	return val &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	return val;</span>
 }
 
 enum {
<span class="p_chunk">@@ -2885,9 +2909,9 @@</span> <span class="p_context"> static u64 mem_cgroup_read_u64(struct cgroup_subsys_state *css,</span>
 	switch (MEMFILE_ATTR(cft-&gt;private)) {
 	case RES_USAGE:
 		if (counter == &amp;memcg-&gt;memory)
<span class="p_del">-			return mem_cgroup_usage(memcg, false);</span>
<span class="p_add">+			return (u64)mem_cgroup_usage(memcg, false) * PAGE_SIZE;</span>
 		if (counter == &amp;memcg-&gt;memsw)
<span class="p_del">-			return mem_cgroup_usage(memcg, true);</span>
<span class="p_add">+			return (u64)mem_cgroup_usage(memcg, true) * PAGE_SIZE;</span>
 		return (u64)page_counter_read(counter) * PAGE_SIZE;
 	case RES_LIMIT:
 		return (u64)counter-&gt;limit * PAGE_SIZE;
<span class="p_chunk">@@ -3387,7 +3411,6 @@</span> <span class="p_context"> static int __mem_cgroup_usage_register_event(struct mem_cgroup *memcg,</span>
 	ret = page_counter_memparse(args, &quot;-1&quot;, &amp;threshold);
 	if (ret)
 		return ret;
<span class="p_del">-	threshold &lt;&lt;= PAGE_SHIFT;</span>
 
 	mutex_lock(&amp;memcg-&gt;thresholds_lock);
 
<span class="p_chunk">@@ -4361,6 +4384,13 @@</span> <span class="p_context"> static void mem_cgroup_css_offline(struct cgroup_subsys_state *css)</span>
 	wb_memcg_offline(memcg);
 }
 
<span class="p_add">+static void mem_cgroup_css_released(struct cgroup_subsys_state *css)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mem_cgroup *memcg = mem_cgroup_from_css(css);</span>
<span class="p_add">+</span>
<span class="p_add">+	invalidate_reclaim_iterators(memcg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void mem_cgroup_css_free(struct cgroup_subsys_state *css)
 {
 	struct mem_cgroup *memcg = mem_cgroup_from_css(css);
<span class="p_chunk">@@ -5217,6 +5247,7 @@</span> <span class="p_context"> struct cgroup_subsys memory_cgrp_subsys = {</span>
 	.css_alloc = mem_cgroup_css_alloc,
 	.css_online = mem_cgroup_css_online,
 	.css_offline = mem_cgroup_css_offline,
<span class="p_add">+	.css_released = mem_cgroup_css_released,</span>
 	.css_free = mem_cgroup_css_free,
 	.css_reset = mem_cgroup_css_reset,
 	.can_attach = mem_cgroup_can_attach,
<span class="p_header">diff --git a/mm/oom_kill.c b/mm/oom_kill.c</span>
<span class="p_header">index 1ecc0bcaecc5..8ad35aa45436 100644</span>
<span class="p_header">--- a/mm/oom_kill.c</span>
<span class="p_header">+++ b/mm/oom_kill.c</span>
<span class="p_chunk">@@ -554,6 +554,12 @@</span> <span class="p_context"> void oom_kill_process(struct oom_control *oc, struct task_struct *p,</span>
 
 	/* mm cannot safely be dereferenced after task_unlock(victim) */
 	mm = victim-&gt;mm;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We should send SIGKILL before setting TIF_MEMDIE in order to prevent</span>
<span class="p_add">+	 * the OOM victim from depleting the memory reserves from the user</span>
<span class="p_add">+	 * space under its control.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);</span>
 	mark_oom_victim(victim);
 	pr_err(&quot;Killed process %d (%s) total-vm:%lukB, anon-rss:%lukB, file-rss:%lukB\n&quot;,
 		task_pid_nr(victim), victim-&gt;comm, K(victim-&gt;mm-&gt;total_vm),
<span class="p_chunk">@@ -585,7 +591,6 @@</span> <span class="p_context"> void oom_kill_process(struct oom_control *oc, struct task_struct *p,</span>
 		}
 	rcu_read_unlock();
 
<span class="p_del">-	do_send_sig_info(SIGKILL, SEND_SIG_FORCED, victim, true);</span>
 	put_task_struct(victim);
 }
 #undef K
<span class="p_header">diff --git a/mm/slab.c b/mm/slab.c</span>
<span class="p_header">index 4fcc5dd8d5a6..461935bab9ef 100644</span>
<span class="p_header">--- a/mm/slab.c</span>
<span class="p_header">+++ b/mm/slab.c</span>
<span class="p_chunk">@@ -282,6 +282,7 @@</span> <span class="p_context"> static void kmem_cache_node_init(struct kmem_cache_node *parent)</span>
 
 #define CFLGS_OFF_SLAB		(0x80000000UL)
 #define	OFF_SLAB(x)	((x)-&gt;flags &amp; CFLGS_OFF_SLAB)
<span class="p_add">+#define OFF_SLAB_MIN_SIZE (max_t(size_t, PAGE_SIZE &gt;&gt; 5, KMALLOC_MIN_SIZE + 1))</span>
 
 #define BATCHREFILL_LIMIT	16
 /*
<span class="p_chunk">@@ -2212,7 +2213,7 @@</span> <span class="p_context"> __kmem_cache_create (struct kmem_cache *cachep, unsigned long flags)</span>
 	 * it too early on. Always use on-slab management when
 	 * SLAB_NOLEAKTRACE to avoid recursive calls into kmemleak)
 	 */
<span class="p_del">-	if ((size &gt;= (PAGE_SIZE &gt;&gt; 5)) &amp;&amp; !slab_early_init &amp;&amp;</span>
<span class="p_add">+	if (size &gt;= OFF_SLAB_MIN_SIZE &amp;&amp; !slab_early_init &amp;&amp;</span>
 	    !(flags &amp; SLAB_NOLEAKTRACE))
 		/*
 		 * Size is large, assume best to place the slab management obj
<span class="p_chunk">@@ -2276,7 +2277,7 @@</span> <span class="p_context"> __kmem_cache_create (struct kmem_cache *cachep, unsigned long flags)</span>
 		/*
 		 * This is a possibility for one of the kmalloc_{dma,}_caches.
 		 * But since we go off slab only for object size greater than
<span class="p_del">-		 * PAGE_SIZE/8, and kmalloc_{dma,}_caches get created</span>
<span class="p_add">+		 * OFF_SLAB_MIN_SIZE, and kmalloc_{dma,}_caches get created</span>
 		 * in ascending order,this should not happen at all.
 		 * But leave a BUG_ON for some lucky dude.
 		 */
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index fbf14485a049..34444706a3a7 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -1357,6 +1357,7 @@</span> <span class="p_context"> static const struct file_operations proc_vmstat_file_operations = {</span>
 #endif /* CONFIG_PROC_FS */
 
 #ifdef CONFIG_SMP
<span class="p_add">+static struct workqueue_struct *vmstat_wq;</span>
 static DEFINE_PER_CPU(struct delayed_work, vmstat_work);
 int sysctl_stat_interval __read_mostly = HZ;
 static cpumask_var_t cpu_stat_off;
<span class="p_chunk">@@ -1369,7 +1370,7 @@</span> <span class="p_context"> static void vmstat_update(struct work_struct *w)</span>
 		 * to occur in the future. Keep on running the
 		 * update worker thread.
 		 */
<span class="p_del">-		schedule_delayed_work_on(smp_processor_id(),</span>
<span class="p_add">+		queue_delayed_work_on(smp_processor_id(), vmstat_wq,</span>
 			this_cpu_ptr(&amp;vmstat_work),
 			round_jiffies_relative(sysctl_stat_interval));
 	} else {
<span class="p_chunk">@@ -1438,7 +1439,7 @@</span> <span class="p_context"> static void vmstat_shepherd(struct work_struct *w)</span>
 		if (need_update(cpu) &amp;&amp;
 			cpumask_test_and_clear_cpu(cpu, cpu_stat_off))
 
<span class="p_del">-			schedule_delayed_work_on(cpu,</span>
<span class="p_add">+			queue_delayed_work_on(cpu, vmstat_wq,</span>
 				&amp;per_cpu(vmstat_work, cpu), 0);
 
 	put_online_cpus();
<span class="p_chunk">@@ -1527,6 +1528,7 @@</span> <span class="p_context"> static int __init setup_vmstat(void)</span>
 
 	start_shepherd_timer();
 	cpu_notifier_register_done();
<span class="p_add">+	vmstat_wq = alloc_workqueue(&quot;vmstat&quot;, WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);</span>
 #endif
 #ifdef CONFIG_PROC_FS
 	proc_create(&quot;buddyinfo&quot;, S_IRUGO, NULL, &amp;fragmentation_file_operations);
<span class="p_header">diff --git a/mm/zsmalloc.c b/mm/zsmalloc.c</span>
<span class="p_header">index f135b1b6fcdc..3734fc4d2e74 100644</span>
<span class="p_header">--- a/mm/zsmalloc.c</span>
<span class="p_header">+++ b/mm/zsmalloc.c</span>
<span class="p_chunk">@@ -304,7 +304,12 @@</span> <span class="p_context"> static void free_handle(struct zs_pool *pool, unsigned long handle)</span>
 
 static void record_obj(unsigned long handle, unsigned long obj)
 {
<span class="p_del">-	*(unsigned long *)handle = obj;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * lsb of @obj represents handle lock while other bits</span>
<span class="p_add">+	 * represent object value the handle is pointing so</span>
<span class="p_add">+	 * updating shouldn&#39;t do store tearing.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WRITE_ONCE(*(unsigned long *)handle, obj);</span>
 }
 
 /* zpool driver */
<span class="p_chunk">@@ -1629,6 +1634,13 @@</span> <span class="p_context"> static int migrate_zspage(struct zs_pool *pool, struct size_class *class,</span>
 		free_obj = obj_malloc(d_page, class, handle);
 		zs_object_copy(free_obj, used_obj, class);
 		index++;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * record_obj updates handle&#39;s value to free_obj and it will</span>
<span class="p_add">+		 * invalidate lock bit(ie, HANDLE_PIN_BIT) of handle, which</span>
<span class="p_add">+		 * breaks synchronization using pin_tag(e,g, zs_free) so</span>
<span class="p_add">+		 * let&#39;s keep the lock bit.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		free_obj |= BIT(HANDLE_PIN_BIT);</span>
 		record_obj(handle, free_obj);
 		unpin_tag(handle);
 		obj_free(pool, class, used_obj);
<span class="p_header">diff --git a/security/integrity/digsig.c b/security/integrity/digsig.c</span>
<span class="p_header">index 36fb6b527829..5be9ffbe90ba 100644</span>
<span class="p_header">--- a/security/integrity/digsig.c</span>
<span class="p_header">+++ b/security/integrity/digsig.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> int __init integrity_load_x509(const unsigned int id, const char *path)</span>
 				   rc,
 				   ((KEY_POS_ALL &amp; ~KEY_POS_SETATTR) |
 				    KEY_USR_VIEW | KEY_USR_READ),
<span class="p_del">-				   KEY_ALLOC_NOT_IN_QUOTA | KEY_ALLOC_TRUSTED);</span>
<span class="p_add">+				   KEY_ALLOC_NOT_IN_QUOTA);</span>
 	if (IS_ERR(key)) {
 		rc = PTR_ERR(key);
 		pr_err(&quot;Problem loading X.509 certificate (%d): %s\n&quot;,
<span class="p_header">diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c</span>
<span class="p_header">index 1334e02ae8f4..3d145a3ffccf 100644</span>
<span class="p_header">--- a/security/integrity/evm/evm_main.c</span>
<span class="p_header">+++ b/security/integrity/evm/evm_main.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/integrity.h&gt;
 #include &lt;linux/evm.h&gt;
 #include &lt;crypto/hash.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 #include &quot;evm.h&quot;
 
 int evm_initialized;
<span class="p_chunk">@@ -148,7 +149,7 @@</span> <span class="p_context"> static enum integrity_status evm_verify_hmac(struct dentry *dentry,</span>
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
<span class="p_del">-		rc = memcmp(xattr_data-&gt;digest, calc.digest,</span>
<span class="p_add">+		rc = crypto_memneq(xattr_data-&gt;digest, calc.digest,</span>
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;
<span class="p_header">diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c</span>
<span class="p_header">index b123c42e7dc8..b554d7f9e3be 100644</span>
<span class="p_header">--- a/sound/core/compress_offload.c</span>
<span class="p_header">+++ b/sound/core/compress_offload.c</span>
<span class="p_chunk">@@ -44,6 +44,13 @@</span> <span class="p_context"></span>
 #include &lt;sound/compress_offload.h&gt;
 #include &lt;sound/compress_driver.h&gt;
 
<span class="p_add">+/* struct snd_compr_codec_caps overflows the ioctl bit size for some</span>
<span class="p_add">+ * architectures, so we need to disable the relevant ioctls.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#if _IOC_SIZEBITS &lt; 14</span>
<span class="p_add">+#define COMPR_CODEC_CAPS_OVERFLOW</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /* TODO:
  * - add substream support for multiple devices in case of
  *	SND_DYNAMIC_MINORS is not used
<span class="p_chunk">@@ -438,6 +445,7 @@</span> <span class="p_context"> out:</span>
 	return retval;
 }
 
<span class="p_add">+#ifndef COMPR_CODEC_CAPS_OVERFLOW</span>
 static int
 snd_compr_get_codec_caps(struct snd_compr_stream *stream, unsigned long arg)
 {
<span class="p_chunk">@@ -461,6 +469,7 @@</span> <span class="p_context"> out:</span>
 	kfree(caps);
 	return retval;
 }
<span class="p_add">+#endif /* !COMPR_CODEC_CAPS_OVERFLOW */</span>
 
 /* revisit this with snd_pcm_preallocate_xxx */
 static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,
<span class="p_chunk">@@ -799,9 +808,11 @@</span> <span class="p_context"> static long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)</span>
 	case _IOC_NR(SNDRV_COMPRESS_GET_CAPS):
 		retval = snd_compr_get_caps(stream, arg);
 		break;
<span class="p_add">+#ifndef COMPR_CODEC_CAPS_OVERFLOW</span>
 	case _IOC_NR(SNDRV_COMPRESS_GET_CODEC_CAPS):
 		retval = snd_compr_get_codec_caps(stream, arg);
 		break;
<span class="p_add">+#endif</span>
 	case _IOC_NR(SNDRV_COMPRESS_SET_PARAMS):
 		retval = snd_compr_set_params(stream, arg);
 		break;
<span class="p_header">diff --git a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c</span>
<span class="p_header">index 58550cc93f28..33e72c809e50 100644</span>
<span class="p_header">--- a/sound/core/oss/pcm_oss.c</span>
<span class="p_header">+++ b/sound/core/oss/pcm_oss.c</span>
<span class="p_chunk">@@ -834,7 +834,8 @@</span> <span class="p_context"> static int choose_rate(struct snd_pcm_substream *substream,</span>
 	return snd_pcm_hw_param_near(substream, params, SNDRV_PCM_HW_PARAM_RATE, best_rate, NULL);
 }
 
<span class="p_del">-static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)</span>
<span class="p_add">+static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream,</span>
<span class="p_add">+				     bool trylock)</span>
 {
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
 	struct snd_pcm_hw_params *params, *sparams;
<span class="p_chunk">@@ -848,7 +849,10 @@</span> <span class="p_context"> static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)</span>
 	struct snd_mask sformat_mask;
 	struct snd_mask mask;
 
<span class="p_del">-	if (mutex_lock_interruptible(&amp;runtime-&gt;oss.params_lock))</span>
<span class="p_add">+	if (trylock) {</span>
<span class="p_add">+		if (!(mutex_trylock(&amp;runtime-&gt;oss.params_lock)))</span>
<span class="p_add">+			return -EAGAIN;</span>
<span class="p_add">+	} else if (mutex_lock_interruptible(&amp;runtime-&gt;oss.params_lock))</span>
 		return -EINTR;
 	sw_params = kmalloc(sizeof(*sw_params), GFP_KERNEL);
 	params = kmalloc(sizeof(*params), GFP_KERNEL);
<span class="p_chunk">@@ -1092,7 +1096,7 @@</span> <span class="p_context"> static int snd_pcm_oss_get_active_substream(struct snd_pcm_oss_file *pcm_oss_fil</span>
 		if (asubstream == NULL)
 			asubstream = substream;
 		if (substream-&gt;runtime-&gt;oss.params) {
<span class="p_del">-			err = snd_pcm_oss_change_params(substream);</span>
<span class="p_add">+			err = snd_pcm_oss_change_params(substream, false);</span>
 			if (err &lt; 0)
 				return err;
 		}
<span class="p_chunk">@@ -1132,7 +1136,7 @@</span> <span class="p_context"> static int snd_pcm_oss_make_ready(struct snd_pcm_substream *substream)</span>
 		return 0;
 	runtime = substream-&gt;runtime;
 	if (runtime-&gt;oss.params) {
<span class="p_del">-		err = snd_pcm_oss_change_params(substream);</span>
<span class="p_add">+		err = snd_pcm_oss_change_params(substream, false);</span>
 		if (err &lt; 0)
 			return err;
 	}
<span class="p_chunk">@@ -2163,7 +2167,7 @@</span> <span class="p_context"> static int snd_pcm_oss_get_space(struct snd_pcm_oss_file *pcm_oss_file, int stre</span>
 	runtime = substream-&gt;runtime;
 
 	if (runtime-&gt;oss.params &amp;&amp;
<span class="p_del">-	    (err = snd_pcm_oss_change_params(substream)) &lt; 0)</span>
<span class="p_add">+	    (err = snd_pcm_oss_change_params(substream, false)) &lt; 0)</span>
 		return err;
 
 	info.fragsize = runtime-&gt;oss.period_bytes;
<span class="p_chunk">@@ -2800,7 +2804,12 @@</span> <span class="p_context"> static int snd_pcm_oss_mmap(struct file *file, struct vm_area_struct *area)</span>
 		return -EIO;
 	
 	if (runtime-&gt;oss.params) {
<span class="p_del">-		if ((err = snd_pcm_oss_change_params(substream)) &lt; 0)</span>
<span class="p_add">+		/* use mutex_trylock() for params_lock for avoiding a deadlock</span>
<span class="p_add">+		 * between mmap_sem and params_lock taken by</span>
<span class="p_add">+		 * copy_from/to_user() in snd_pcm_oss_write/read()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		err = snd_pcm_oss_change_params(substream, true);</span>
<span class="p_add">+		if (err &lt; 0)</span>
 			return err;
 	}
 #ifdef CONFIG_SND_PCM_OSS_PLUGINS
<span class="p_header">diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c</span>
<span class="p_header">index a7759846fbaa..795437b10082 100644</span>
<span class="p_header">--- a/sound/core/rawmidi.c</span>
<span class="p_header">+++ b/sound/core/rawmidi.c</span>
<span class="p_chunk">@@ -942,31 +942,36 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,</span>
 	unsigned long flags;
 	long result = 0, count1;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
<span class="p_add">+	unsigned long appl_ptr;</span>
 
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	while (count &gt; 0 &amp;&amp; runtime-&gt;avail) {
 		count1 = runtime-&gt;buffer_size - runtime-&gt;appl_ptr;
 		if (count1 &gt; count)
 			count1 = count;
<span class="p_del">-		spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 		if (count1 &gt; (int)runtime-&gt;avail)
 			count1 = runtime-&gt;avail;
<span class="p_add">+</span>
<span class="p_add">+		/* update runtime-&gt;appl_ptr before unlocking for userbuf */</span>
<span class="p_add">+		appl_ptr = runtime-&gt;appl_ptr;</span>
<span class="p_add">+		runtime-&gt;appl_ptr += count1;</span>
<span class="p_add">+		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_add">+		runtime-&gt;avail -= count1;</span>
<span class="p_add">+</span>
 		if (kernelbuf)
<span class="p_del">-			memcpy(kernelbuf + result, runtime-&gt;buffer + runtime-&gt;appl_ptr, count1);</span>
<span class="p_add">+			memcpy(kernelbuf + result, runtime-&gt;buffer + appl_ptr, count1);</span>
 		if (userbuf) {
 			spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
 			if (copy_to_user(userbuf + result,
<span class="p_del">-					 runtime-&gt;buffer + runtime-&gt;appl_ptr, count1)) {</span>
<span class="p_add">+					 runtime-&gt;buffer + appl_ptr, count1)) {</span>
 				return result &gt; 0 ? result : -EFAULT;
 			}
 			spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
 		}
<span class="p_del">-		runtime-&gt;appl_ptr += count1;</span>
<span class="p_del">-		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_del">-		runtime-&gt;avail -= count1;</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
 		result += count1;
 		count -= count1;
 	}
<span class="p_add">+	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
 	return result;
 }
 
<span class="p_chunk">@@ -1055,23 +1060,16 @@</span> <span class="p_context"> int snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream)</span>
 EXPORT_SYMBOL(snd_rawmidi_transmit_empty);
 
 /**
<span class="p_del">- * snd_rawmidi_transmit_peek - copy data from the internal buffer</span>
<span class="p_add">+ * __snd_rawmidi_transmit_peek - copy data from the internal buffer</span>
  * @substream: the rawmidi substream
  * @buffer: the buffer pointer
  * @count: data size to transfer
  *
<span class="p_del">- * Copies data from the internal output buffer to the given buffer.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Call this in the interrupt handler when the midi output is ready,</span>
<span class="p_del">- * and call snd_rawmidi_transmit_ack() after the transmission is</span>
<span class="p_del">- * finished.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Return: The size of copied data, or a negative error code on failure.</span>
<span class="p_add">+ * This is a variant of snd_rawmidi_transmit_peek() without spinlock.</span>
  */
<span class="p_del">-int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+int __snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 			      unsigned char *buffer, int count)
 {
<span class="p_del">-	unsigned long flags;</span>
 	int result, count1;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 
<span class="p_chunk">@@ -1081,7 +1079,6 @@</span> <span class="p_context"> int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 		return -EINVAL;
 	}
 	result = 0;
<span class="p_del">-	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	if (runtime-&gt;avail &gt;= runtime-&gt;buffer_size) {
 		/* warning: lowlevel layer MUST trigger down the hardware */
 		goto __skip;
<span class="p_chunk">@@ -1106,25 +1103,47 @@</span> <span class="p_context"> int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 		}
 	}
       __skip:
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__snd_rawmidi_transmit_peek);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * snd_rawmidi_transmit_peek - copy data from the internal buffer</span>
<span class="p_add">+ * @substream: the rawmidi substream</span>
<span class="p_add">+ * @buffer: the buffer pointer</span>
<span class="p_add">+ * @count: data size to transfer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copies data from the internal output buffer to the given buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Call this in the interrupt handler when the midi output is ready,</span>
<span class="p_add">+ * and call snd_rawmidi_transmit_ack() after the transmission is</span>
<span class="p_add">+ * finished.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: The size of copied data, or a negative error code on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+			      unsigned char *buffer, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	result = __snd_rawmidi_transmit_peek(substream, buffer, count);</span>
 	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
 	return result;
 }
 EXPORT_SYMBOL(snd_rawmidi_transmit_peek);
 
 /**
<span class="p_del">- * snd_rawmidi_transmit_ack - acknowledge the transmission</span>
<span class="p_add">+ * __snd_rawmidi_transmit_ack - acknowledge the transmission</span>
  * @substream: the rawmidi substream
  * @count: the transferred count
  *
<span class="p_del">- * Advances the hardware pointer for the internal output buffer with</span>
<span class="p_del">- * the given size and updates the condition.</span>
<span class="p_del">- * Call after the transmission is finished.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Return: The advanced size if successful, or a negative error code on failure.</span>
<span class="p_add">+ * This is a variant of __snd_rawmidi_transmit_ack() without spinlock.</span>
  */
<span class="p_del">-int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
<span class="p_add">+int __snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
 {
<span class="p_del">-	unsigned long flags;</span>
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 
 	if (runtime-&gt;buffer == NULL) {
<span class="p_chunk">@@ -1132,7 +1151,6 @@</span> <span class="p_context"> int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
 			  &quot;snd_rawmidi_transmit_ack: output is not active!!!\n&quot;);
 		return -EINVAL;
 	}
<span class="p_del">-	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	snd_BUG_ON(runtime-&gt;avail + count &gt; runtime-&gt;buffer_size);
 	runtime-&gt;hw_ptr += count;
 	runtime-&gt;hw_ptr %= runtime-&gt;buffer_size;
<span class="p_chunk">@@ -1142,9 +1160,32 @@</span> <span class="p_context"> int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
 		if (runtime-&gt;drain || snd_rawmidi_ready(substream))
 			wake_up(&amp;runtime-&gt;sleep);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
 	return count;
 }
<span class="p_add">+EXPORT_SYMBOL(__snd_rawmidi_transmit_ack);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * snd_rawmidi_transmit_ack - acknowledge the transmission</span>
<span class="p_add">+ * @substream: the rawmidi substream</span>
<span class="p_add">+ * @count: the transferred count</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Advances the hardware pointer for the internal output buffer with</span>
<span class="p_add">+ * the given size and updates the condition.</span>
<span class="p_add">+ * Call after the transmission is finished.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: The advanced size if successful, or a negative error code on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	result = __snd_rawmidi_transmit_ack(substream, count);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(snd_rawmidi_transmit_ack);
 
 /**
<span class="p_chunk">@@ -1160,12 +1201,22 @@</span> <span class="p_context"> EXPORT_SYMBOL(snd_rawmidi_transmit_ack);</span>
 int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream,
 			 unsigned char *buffer, int count)
 {
<span class="p_add">+	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	if (!substream-&gt;opened)
<span class="p_del">-		return -EBADFD;</span>
<span class="p_del">-	count = snd_rawmidi_transmit_peek(substream, buffer, count);</span>
<span class="p_del">-	if (count &lt; 0)</span>
<span class="p_del">-		return count;</span>
<span class="p_del">-	return snd_rawmidi_transmit_ack(substream, count);</span>
<span class="p_add">+		result = -EBADFD;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		count = __snd_rawmidi_transmit_peek(substream, buffer, count);</span>
<span class="p_add">+		if (count &lt;= 0)</span>
<span class="p_add">+			result = count;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			result = __snd_rawmidi_transmit_ack(substream, count);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	return result;</span>
 }
 EXPORT_SYMBOL(snd_rawmidi_transmit);
 
<span class="p_chunk">@@ -1177,8 +1228,9 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,</span>
 	unsigned long flags;
 	long count1, result;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
<span class="p_add">+	unsigned long appl_ptr;</span>
 
<span class="p_del">-	if (snd_BUG_ON(!kernelbuf &amp;&amp; !userbuf))</span>
<span class="p_add">+	if (!kernelbuf &amp;&amp; !userbuf)</span>
 		return -EINVAL;
 	if (snd_BUG_ON(!runtime-&gt;buffer))
 		return -EINVAL;
<span class="p_chunk">@@ -1197,12 +1249,19 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,</span>
 			count1 = count;
 		if (count1 &gt; (long)runtime-&gt;avail)
 			count1 = runtime-&gt;avail;
<span class="p_add">+</span>
<span class="p_add">+		/* update runtime-&gt;appl_ptr before unlocking for userbuf */</span>
<span class="p_add">+		appl_ptr = runtime-&gt;appl_ptr;</span>
<span class="p_add">+		runtime-&gt;appl_ptr += count1;</span>
<span class="p_add">+		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_add">+		runtime-&gt;avail -= count1;</span>
<span class="p_add">+</span>
 		if (kernelbuf)
<span class="p_del">-			memcpy(runtime-&gt;buffer + runtime-&gt;appl_ptr,</span>
<span class="p_add">+			memcpy(runtime-&gt;buffer + appl_ptr,</span>
 			       kernelbuf + result, count1);
 		else if (userbuf) {
 			spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
<span class="p_del">-			if (copy_from_user(runtime-&gt;buffer + runtime-&gt;appl_ptr,</span>
<span class="p_add">+			if (copy_from_user(runtime-&gt;buffer + appl_ptr,</span>
 					   userbuf + result, count1)) {
 				spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
 				result = result &gt; 0 ? result : -EFAULT;
<span class="p_chunk">@@ -1210,9 +1269,6 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,</span>
 			}
 			spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
 		}
<span class="p_del">-		runtime-&gt;appl_ptr += count1;</span>
<span class="p_del">-		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_del">-		runtime-&gt;avail -= count1;</span>
 		result += count1;
 		count -= count1;
 	}
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c</span>
<span class="p_header">index b1221b29728e..6779e82b46dd 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_init.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_init.c</span>
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> snd_seq_oss_open(struct file *file, int level)</span>
 
 	dp-&gt;index = i;
 	if (i &gt;= SNDRV_SEQ_OSS_MAX_CLIENTS) {
<span class="p_del">-		pr_err(&quot;ALSA: seq_oss: too many applications\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;ALSA: seq_oss: too many applications\n&quot;);</span>
 		rc = -ENOMEM;
 		goto _error;
 	}
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c</span>
<span class="p_header">index 0f3b38184fe5..b16dbef04174 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_synth.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_synth.c</span>
<span class="p_chunk">@@ -308,7 +308,7 @@</span> <span class="p_context"> snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)</span>
 	struct seq_oss_synth *rec;
 	struct seq_oss_synthinfo *info;
 
<span class="p_del">-	if (snd_BUG_ON(dp-&gt;max_synthdev &gt;= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))</span>
<span class="p_add">+	if (snd_BUG_ON(dp-&gt;max_synthdev &gt; SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))</span>
 		return;
 	for (i = 0; i &lt; dp-&gt;max_synthdev; i++) {
 		info = &amp;dp-&gt;synths[i];
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index 13cfa815732d..58e79e02f217 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -678,6 +678,9 @@</span> <span class="p_context"> static int deliver_to_subscribers(struct snd_seq_client *client,</span>
 	else
 		down_read(&amp;grp-&gt;list_mutex);
 	list_for_each_entry(subs, &amp;grp-&gt;list_head, src_list) {
<span class="p_add">+		/* both ports ready? */</span>
<span class="p_add">+		if (atomic_read(&amp;subs-&gt;ref_count) != 2)</span>
<span class="p_add">+			continue;</span>
 		event-&gt;dest = subs-&gt;info.dest;
 		if (subs-&gt;info.flags &amp; SNDRV_SEQ_PORT_SUBS_TIMESTAMP)
 			/* convert time according to flag with subscription */
<span class="p_header">diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c</span>
<span class="p_header">index 55170a20ae72..921fb2bd8fad 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_ports.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_ports.c</span>
<span class="p_chunk">@@ -173,10 +173,6 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 }
 
 /* */
<span class="p_del">-enum group_type {</span>
<span class="p_del">-	SRC_LIST, DEST_LIST</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static int subscribe_port(struct snd_seq_client *client,
 			  struct snd_seq_client_port *port,
 			  struct snd_seq_port_subs_info *grp,
<span class="p_chunk">@@ -203,6 +199,20 @@</span> <span class="p_context"> static struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,</span>
 	return NULL;
 }
 
<span class="p_add">+static void delete_and_unsubscribe_port(struct snd_seq_client *client,</span>
<span class="p_add">+					struct snd_seq_client_port *port,</span>
<span class="p_add">+					struct snd_seq_subscribers *subs,</span>
<span class="p_add">+					bool is_src, bool ack);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct snd_seq_subscribers *</span>
<span class="p_add">+get_subscriber(struct list_head *p, bool is_src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (is_src)</span>
<span class="p_add">+		return list_entry(p, struct snd_seq_subscribers, src_list);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return list_entry(p, struct snd_seq_subscribers, dest_list);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * remove all subscribers on the list
  * this is called from port_delete, for each src and dest list.
<span class="p_chunk">@@ -210,7 +220,7 @@</span> <span class="p_context"> static struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,</span>
 static void clear_subscriber_list(struct snd_seq_client *client,
 				  struct snd_seq_client_port *port,
 				  struct snd_seq_port_subs_info *grp,
<span class="p_del">-				  int grptype)</span>
<span class="p_add">+				  int is_src)</span>
 {
 	struct list_head *p, *n;
 
<span class="p_chunk">@@ -219,15 +229,13 @@</span> <span class="p_context"> static void clear_subscriber_list(struct snd_seq_client *client,</span>
 		struct snd_seq_client *c;
 		struct snd_seq_client_port *aport;
 
<span class="p_del">-		if (grptype == SRC_LIST) {</span>
<span class="p_del">-			subs = list_entry(p, struct snd_seq_subscribers, src_list);</span>
<span class="p_add">+		subs = get_subscriber(p, is_src);</span>
<span class="p_add">+		if (is_src)</span>
 			aport = get_client_port(&amp;subs-&gt;info.dest, &amp;c);
<span class="p_del">-		} else {</span>
<span class="p_del">-			subs = list_entry(p, struct snd_seq_subscribers, dest_list);</span>
<span class="p_add">+		else</span>
 			aport = get_client_port(&amp;subs-&gt;info.sender, &amp;c);
<span class="p_del">-		}</span>
<span class="p_del">-		list_del(p);</span>
<span class="p_del">-		unsubscribe_port(client, port, grp, &amp;subs-&gt;info, 0);</span>
<span class="p_add">+		delete_and_unsubscribe_port(client, port, subs, is_src, false);</span>
<span class="p_add">+</span>
 		if (!aport) {
 			/* looks like the connected port is being deleted.
 			 * we decrease the counter, and when both ports are deleted
<span class="p_chunk">@@ -235,21 +243,14 @@</span> <span class="p_context"> static void clear_subscriber_list(struct snd_seq_client *client,</span>
 			 */
 			if (atomic_dec_and_test(&amp;subs-&gt;ref_count))
 				kfree(subs);
<span class="p_del">-		} else {</span>
<span class="p_del">-			/* ok we got the connected port */</span>
<span class="p_del">-			struct snd_seq_port_subs_info *agrp;</span>
<span class="p_del">-			agrp = (grptype == SRC_LIST) ? &amp;aport-&gt;c_dest : &amp;aport-&gt;c_src;</span>
<span class="p_del">-			down_write(&amp;agrp-&gt;list_mutex);</span>
<span class="p_del">-			if (grptype == SRC_LIST)</span>
<span class="p_del">-				list_del(&amp;subs-&gt;dest_list);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				list_del(&amp;subs-&gt;src_list);</span>
<span class="p_del">-			up_write(&amp;agrp-&gt;list_mutex);</span>
<span class="p_del">-			unsubscribe_port(c, aport, agrp, &amp;subs-&gt;info, 1);</span>
<span class="p_del">-			kfree(subs);</span>
<span class="p_del">-			snd_seq_port_unlock(aport);</span>
<span class="p_del">-			snd_seq_client_unlock(c);</span>
<span class="p_add">+			continue;</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* ok we got the connected port */</span>
<span class="p_add">+		delete_and_unsubscribe_port(c, aport, subs, !is_src, true);</span>
<span class="p_add">+		kfree(subs);</span>
<span class="p_add">+		snd_seq_port_unlock(aport);</span>
<span class="p_add">+		snd_seq_client_unlock(c);</span>
 	}
 }
 
<span class="p_chunk">@@ -262,8 +263,8 @@</span> <span class="p_context"> static int port_delete(struct snd_seq_client *client,</span>
 	snd_use_lock_sync(&amp;port-&gt;use_lock); 
 
 	/* clear subscribers info */
<span class="p_del">-	clear_subscriber_list(client, port, &amp;port-&gt;c_src, SRC_LIST);</span>
<span class="p_del">-	clear_subscriber_list(client, port, &amp;port-&gt;c_dest, DEST_LIST);</span>
<span class="p_add">+	clear_subscriber_list(client, port, &amp;port-&gt;c_src, true);</span>
<span class="p_add">+	clear_subscriber_list(client, port, &amp;port-&gt;c_dest, false);</span>
 
 	if (port-&gt;private_free)
 		port-&gt;private_free(port-&gt;private_data);
<span class="p_chunk">@@ -479,85 +480,120 @@</span> <span class="p_context"> static int match_subs_info(struct snd_seq_port_subscribe *r,</span>
 	return 0;
 }
 
<span class="p_del">-</span>
<span class="p_del">-/* connect two ports */</span>
<span class="p_del">-int snd_seq_port_connect(struct snd_seq_client *connector,</span>
<span class="p_del">-			 struct snd_seq_client *src_client,</span>
<span class="p_del">-			 struct snd_seq_client_port *src_port,</span>
<span class="p_del">-			 struct snd_seq_client *dest_client,</span>
<span class="p_del">-			 struct snd_seq_client_port *dest_port,</span>
<span class="p_del">-			 struct snd_seq_port_subscribe *info)</span>
<span class="p_add">+static int check_and_subscribe_port(struct snd_seq_client *client,</span>
<span class="p_add">+				    struct snd_seq_client_port *port,</span>
<span class="p_add">+				    struct snd_seq_subscribers *subs,</span>
<span class="p_add">+				    bool is_src, bool exclusive, bool ack)</span>
 {
<span class="p_del">-	struct snd_seq_port_subs_info *src = &amp;src_port-&gt;c_src;</span>
<span class="p_del">-	struct snd_seq_port_subs_info *dest = &amp;dest_port-&gt;c_dest;</span>
<span class="p_del">-	struct snd_seq_subscribers *subs, *s;</span>
<span class="p_del">-	int err, src_called = 0;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	int exclusive;</span>
<span class="p_add">+	struct snd_seq_port_subs_info *grp;</span>
<span class="p_add">+	struct list_head *p;</span>
<span class="p_add">+	struct snd_seq_subscribers *s;</span>
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	subs = kzalloc(sizeof(*subs), GFP_KERNEL);</span>
<span class="p_del">-	if (! subs)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	subs-&gt;info = *info;</span>
<span class="p_del">-	atomic_set(&amp;subs-&gt;ref_count, 2);</span>
<span class="p_del">-</span>
<span class="p_del">-	down_write(&amp;src-&gt;list_mutex);</span>
<span class="p_del">-	down_write_nested(&amp;dest-&gt;list_mutex, SINGLE_DEPTH_NESTING);</span>
<span class="p_del">-</span>
<span class="p_del">-	exclusive = info-&gt;flags &amp; SNDRV_SEQ_PORT_SUBS_EXCLUSIVE ? 1 : 0;</span>
<span class="p_add">+	grp = is_src ? &amp;port-&gt;c_src : &amp;port-&gt;c_dest;</span>
 	err = -EBUSY;
<span class="p_add">+	down_write(&amp;grp-&gt;list_mutex);</span>
 	if (exclusive) {
<span class="p_del">-		if (! list_empty(&amp;src-&gt;list_head) || ! list_empty(&amp;dest-&gt;list_head))</span>
<span class="p_add">+		if (!list_empty(&amp;grp-&gt;list_head))</span>
 			goto __error;
 	} else {
<span class="p_del">-		if (src-&gt;exclusive || dest-&gt;exclusive)</span>
<span class="p_add">+		if (grp-&gt;exclusive)</span>
 			goto __error;
 		/* check whether already exists */
<span class="p_del">-		list_for_each_entry(s, &amp;src-&gt;list_head, src_list) {</span>
<span class="p_del">-			if (match_subs_info(info, &amp;s-&gt;info))</span>
<span class="p_del">-				goto __error;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		list_for_each_entry(s, &amp;dest-&gt;list_head, dest_list) {</span>
<span class="p_del">-			if (match_subs_info(info, &amp;s-&gt;info))</span>
<span class="p_add">+		list_for_each(p, &amp;grp-&gt;list_head) {</span>
<span class="p_add">+			s = get_subscriber(p, is_src);</span>
<span class="p_add">+			if (match_subs_info(&amp;subs-&gt;info, &amp;s-&gt;info))</span>
 				goto __error;
 		}
 	}
 
<span class="p_del">-	if ((err = subscribe_port(src_client, src_port, src, info,</span>
<span class="p_del">-				  connector-&gt;number != src_client-&gt;number)) &lt; 0)</span>
<span class="p_del">-		goto __error;</span>
<span class="p_del">-	src_called = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((err = subscribe_port(dest_client, dest_port, dest, info,</span>
<span class="p_del">-				  connector-&gt;number != dest_client-&gt;number)) &lt; 0)</span>
<span class="p_add">+	err = subscribe_port(client, port, grp, &amp;subs-&gt;info, ack);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		grp-&gt;exclusive = 0;</span>
 		goto __error;
<span class="p_add">+	}</span>
 
 	/* add to list */
<span class="p_del">-	write_lock_irqsave(&amp;src-&gt;list_lock, flags);</span>
<span class="p_del">-	// write_lock(&amp;dest-&gt;list_lock); // no other lock yet</span>
<span class="p_del">-	list_add_tail(&amp;subs-&gt;src_list, &amp;src-&gt;list_head);</span>
<span class="p_del">-	list_add_tail(&amp;subs-&gt;dest_list, &amp;dest-&gt;list_head);</span>
<span class="p_del">-	// write_unlock(&amp;dest-&gt;list_lock); // no other lock yet</span>
<span class="p_del">-	write_unlock_irqrestore(&amp;src-&gt;list_lock, flags);</span>
<span class="p_add">+	write_lock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	if (is_src)</span>
<span class="p_add">+		list_add_tail(&amp;subs-&gt;src_list, &amp;grp-&gt;list_head);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		list_add_tail(&amp;subs-&gt;dest_list, &amp;grp-&gt;list_head);</span>
<span class="p_add">+	grp-&gt;exclusive = exclusive;</span>
<span class="p_add">+	atomic_inc(&amp;subs-&gt;ref_count);</span>
<span class="p_add">+	write_unlock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ __error:</span>
<span class="p_add">+	up_write(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	src-&gt;exclusive = dest-&gt;exclusive = exclusive;</span>
<span class="p_add">+static void delete_and_unsubscribe_port(struct snd_seq_client *client,</span>
<span class="p_add">+					struct snd_seq_client_port *port,</span>
<span class="p_add">+					struct snd_seq_subscribers *subs,</span>
<span class="p_add">+					bool is_src, bool ack)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_seq_port_subs_info *grp;</span>
<span class="p_add">+</span>
<span class="p_add">+	grp = is_src ? &amp;port-&gt;c_src : &amp;port-&gt;c_dest;</span>
<span class="p_add">+	down_write(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+	write_lock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	if (is_src)</span>
<span class="p_add">+		list_del(&amp;subs-&gt;src_list);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		list_del(&amp;subs-&gt;dest_list);</span>
<span class="p_add">+	grp-&gt;exclusive = 0;</span>
<span class="p_add">+	write_unlock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	up_write(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	unsubscribe_port(client, port, grp, &amp;subs-&gt;info, ack);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* connect two ports */</span>
<span class="p_add">+int snd_seq_port_connect(struct snd_seq_client *connector,</span>
<span class="p_add">+			 struct snd_seq_client *src_client,</span>
<span class="p_add">+			 struct snd_seq_client_port *src_port,</span>
<span class="p_add">+			 struct snd_seq_client *dest_client,</span>
<span class="p_add">+			 struct snd_seq_client_port *dest_port,</span>
<span class="p_add">+			 struct snd_seq_port_subscribe *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_seq_subscribers *subs;</span>
<span class="p_add">+	bool exclusive;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	subs = kzalloc(sizeof(*subs), GFP_KERNEL);</span>
<span class="p_add">+	if (!subs)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	subs-&gt;info = *info;</span>
<span class="p_add">+	atomic_set(&amp;subs-&gt;ref_count, 0);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;subs-&gt;src_list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;subs-&gt;dest_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	exclusive = !!(info-&gt;flags &amp; SNDRV_SEQ_PORT_SUBS_EXCLUSIVE);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = check_and_subscribe_port(src_client, src_port, subs, true,</span>
<span class="p_add">+				       exclusive,</span>
<span class="p_add">+				       connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	err = check_and_subscribe_port(dest_client, dest_port, subs, false,</span>
<span class="p_add">+				       exclusive,</span>
<span class="p_add">+				       connector-&gt;number != dest_client-&gt;number);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error_dest;</span>
 
<span class="p_del">-	up_write(&amp;dest-&gt;list_mutex);</span>
<span class="p_del">-	up_write(&amp;src-&gt;list_mutex);</span>
 	return 0;
 
<span class="p_del">- __error:</span>
<span class="p_del">-	if (src_called)</span>
<span class="p_del">-		unsubscribe_port(src_client, src_port, src, info,</span>
<span class="p_del">-				 connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+ error_dest:</span>
<span class="p_add">+	delete_and_unsubscribe_port(src_client, src_port, subs, true,</span>
<span class="p_add">+				    connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+ error:</span>
 	kfree(subs);
<span class="p_del">-	up_write(&amp;dest-&gt;list_mutex);</span>
<span class="p_del">-	up_write(&amp;src-&gt;list_mutex);</span>
 	return err;
 }
 
<span class="p_del">-</span>
 /* remove the connection */
 int snd_seq_port_disconnect(struct snd_seq_client *connector,
 			    struct snd_seq_client *src_client,
<span class="p_chunk">@@ -567,37 +603,28 @@</span> <span class="p_context"> int snd_seq_port_disconnect(struct snd_seq_client *connector,</span>
 			    struct snd_seq_port_subscribe *info)
 {
 	struct snd_seq_port_subs_info *src = &amp;src_port-&gt;c_src;
<span class="p_del">-	struct snd_seq_port_subs_info *dest = &amp;dest_port-&gt;c_dest;</span>
 	struct snd_seq_subscribers *subs;
 	int err = -ENOENT;
<span class="p_del">-	unsigned long flags;</span>
 
 	down_write(&amp;src-&gt;list_mutex);
<span class="p_del">-	down_write_nested(&amp;dest-&gt;list_mutex, SINGLE_DEPTH_NESTING);</span>
<span class="p_del">-</span>
 	/* look for the connection */
 	list_for_each_entry(subs, &amp;src-&gt;list_head, src_list) {
 		if (match_subs_info(info, &amp;subs-&gt;info)) {
<span class="p_del">-			write_lock_irqsave(&amp;src-&gt;list_lock, flags);</span>
<span class="p_del">-			// write_lock(&amp;dest-&gt;list_lock);  // no lock yet</span>
<span class="p_del">-			list_del(&amp;subs-&gt;src_list);</span>
<span class="p_del">-			list_del(&amp;subs-&gt;dest_list);</span>
<span class="p_del">-			// write_unlock(&amp;dest-&gt;list_lock);</span>
<span class="p_del">-			write_unlock_irqrestore(&amp;src-&gt;list_lock, flags);</span>
<span class="p_del">-			src-&gt;exclusive = dest-&gt;exclusive = 0;</span>
<span class="p_del">-			unsubscribe_port(src_client, src_port, src, info,</span>
<span class="p_del">-					 connector-&gt;number != src_client-&gt;number);</span>
<span class="p_del">-			unsubscribe_port(dest_client, dest_port, dest, info,</span>
<span class="p_del">-					 connector-&gt;number != dest_client-&gt;number);</span>
<span class="p_del">-			kfree(subs);</span>
<span class="p_add">+			atomic_dec(&amp;subs-&gt;ref_count); /* mark as not ready */</span>
 			err = 0;
 			break;
 		}
 	}
<span class="p_del">-</span>
<span class="p_del">-	up_write(&amp;dest-&gt;list_mutex);</span>
 	up_write(&amp;src-&gt;list_mutex);
<span class="p_del">-	return err;</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	delete_and_unsubscribe_port(src_client, src_port, subs, true,</span>
<span class="p_add">+				    connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+	delete_and_unsubscribe_port(dest_client, dest_port, subs, false,</span>
<span class="p_add">+				    connector-&gt;number != dest_client-&gt;number);</span>
<span class="p_add">+	kfree(subs);</span>
<span class="p_add">+	return 0;</span>
 }
 
 
<span class="p_header">diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c</span>
<span class="p_header">index 82b220c769c1..293104926098 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_timer.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_timer.c</span>
<span class="p_chunk">@@ -90,6 +90,9 @@</span> <span class="p_context"> void snd_seq_timer_delete(struct snd_seq_timer **tmr)</span>
 
 void snd_seq_timer_defaults(struct snd_seq_timer * tmr)
 {
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
 	/* setup defaults */
 	tmr-&gt;ppq = 96;		/* 96 PPQ */
 	tmr-&gt;tempo = 500000;	/* 120 BPM */
<span class="p_chunk">@@ -105,21 +108,25 @@</span> <span class="p_context"> void snd_seq_timer_defaults(struct snd_seq_timer * tmr)</span>
 	tmr-&gt;preferred_resolution = seq_default_timer_resolution;
 
 	tmr-&gt;skew = tmr-&gt;skew_base = SKEW_BASE;
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
 }
 
<span class="p_del">-void snd_seq_timer_reset(struct snd_seq_timer * tmr)</span>
<span class="p_add">+static void seq_timer_reset(struct snd_seq_timer *tmr)</span>
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	/* reset time &amp; songposition */
 	tmr-&gt;cur_time.tv_sec = 0;
 	tmr-&gt;cur_time.tv_nsec = 0;
 
 	tmr-&gt;tick.cur_tick = 0;
 	tmr-&gt;tick.fraction = 0;
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void snd_seq_timer_reset(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	seq_timer_reset(tmr);</span>
 	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);
 }
 
<span class="p_chunk">@@ -138,8 +145,11 @@</span> <span class="p_context"> static void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,</span>
 	tmr = q-&gt;timer;
 	if (tmr == NULL)
 		return;
<span class="p_del">-	if (!tmr-&gt;running)</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	if (!tmr-&gt;running) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
 		return;
<span class="p_add">+	}</span>
 
 	resolution *= ticks;
 	if (tmr-&gt;skew != tmr-&gt;skew_base) {
<span class="p_chunk">@@ -148,8 +158,6 @@</span> <span class="p_context"> static void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,</span>
 			(((resolution &amp; 0xffff) * tmr-&gt;skew) &gt;&gt; 16);
 	}
 
<span class="p_del">-	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	/* update timer */
 	snd_seq_inc_time_nsec(&amp;tmr-&gt;cur_time, resolution);
 
<span class="p_chunk">@@ -296,26 +304,30 @@</span> <span class="p_context"> int snd_seq_timer_open(struct snd_seq_queue *q)</span>
 	t-&gt;callback = snd_seq_timer_interrupt;
 	t-&gt;callback_data = q;
 	t-&gt;flags |= SNDRV_TIMER_IFLG_AUTO;
<span class="p_add">+	spin_lock_irq(&amp;tmr-&gt;lock);</span>
 	tmr-&gt;timeri = t;
<span class="p_add">+	spin_unlock_irq(&amp;tmr-&gt;lock);</span>
 	return 0;
 }
 
 int snd_seq_timer_close(struct snd_seq_queue *q)
 {
 	struct snd_seq_timer *tmr;
<span class="p_add">+	struct snd_timer_instance *t;</span>
 	
 	tmr = q-&gt;timer;
 	if (snd_BUG_ON(!tmr))
 		return -EINVAL;
<span class="p_del">-	if (tmr-&gt;timeri) {</span>
<span class="p_del">-		snd_timer_stop(tmr-&gt;timeri);</span>
<span class="p_del">-		snd_timer_close(tmr-&gt;timeri);</span>
<span class="p_del">-		tmr-&gt;timeri = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	spin_lock_irq(&amp;tmr-&gt;lock);</span>
<span class="p_add">+	t = tmr-&gt;timeri;</span>
<span class="p_add">+	tmr-&gt;timeri = NULL;</span>
<span class="p_add">+	spin_unlock_irq(&amp;tmr-&gt;lock);</span>
<span class="p_add">+	if (t)</span>
<span class="p_add">+		snd_timer_close(t);</span>
 	return 0;
 }
 
<span class="p_del">-int snd_seq_timer_stop(struct snd_seq_timer * tmr)</span>
<span class="p_add">+static int seq_timer_stop(struct snd_seq_timer *tmr)</span>
 {
 	if (! tmr-&gt;timeri)
 		return -EINVAL;
<span class="p_chunk">@@ -326,6 +338,17 @@</span> <span class="p_context"> int snd_seq_timer_stop(struct snd_seq_timer * tmr)</span>
 	return 0;
 }
 
<span class="p_add">+int snd_seq_timer_stop(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	err = seq_timer_stop(tmr);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int initialize_timer(struct snd_seq_timer *tmr)
 {
 	struct snd_timer *t;
<span class="p_chunk">@@ -358,13 +381,13 @@</span> <span class="p_context"> static int initialize_timer(struct snd_seq_timer *tmr)</span>
 	return 0;
 }
 
<span class="p_del">-int snd_seq_timer_start(struct snd_seq_timer * tmr)</span>
<span class="p_add">+static int seq_timer_start(struct snd_seq_timer *tmr)</span>
 {
 	if (! tmr-&gt;timeri)
 		return -EINVAL;
 	if (tmr-&gt;running)
<span class="p_del">-		snd_seq_timer_stop(tmr);</span>
<span class="p_del">-	snd_seq_timer_reset(tmr);</span>
<span class="p_add">+		seq_timer_stop(tmr);</span>
<span class="p_add">+	seq_timer_reset(tmr);</span>
 	if (initialize_timer(tmr) &lt; 0)
 		return -EINVAL;
 	snd_timer_start(tmr-&gt;timeri, tmr-&gt;ticks);
<span class="p_chunk">@@ -373,14 +396,25 @@</span> <span class="p_context"> int snd_seq_timer_start(struct snd_seq_timer * tmr)</span>
 	return 0;
 }
 
<span class="p_del">-int snd_seq_timer_continue(struct snd_seq_timer * tmr)</span>
<span class="p_add">+int snd_seq_timer_start(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	err = seq_timer_start(tmr);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int seq_timer_continue(struct snd_seq_timer *tmr)</span>
 {
 	if (! tmr-&gt;timeri)
 		return -EINVAL;
 	if (tmr-&gt;running)
 		return -EBUSY;
 	if (! tmr-&gt;initialized) {
<span class="p_del">-		snd_seq_timer_reset(tmr);</span>
<span class="p_add">+		seq_timer_reset(tmr);</span>
 		if (initialize_timer(tmr) &lt; 0)
 			return -EINVAL;
 	}
<span class="p_chunk">@@ -390,11 +424,24 @@</span> <span class="p_context"> int snd_seq_timer_continue(struct snd_seq_timer * tmr)</span>
 	return 0;
 }
 
<span class="p_add">+int snd_seq_timer_continue(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	err = seq_timer_continue(tmr);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* return current &#39;real&#39; time. use timeofday() to get better granularity. */
 snd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)
 {
 	snd_seq_real_time_t cur_time;
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
 	cur_time = tmr-&gt;cur_time;
 	if (tmr-&gt;running) { 
 		struct timeval tm;
<span class="p_chunk">@@ -410,7 +457,7 @@</span> <span class="p_context"> snd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)</span>
 		}
 		snd_seq_sanity_real_time(&amp;cur_time);
 	}
<span class="p_del">-                </span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
 	return cur_time;	
 }
 
<span class="p_header">diff --git a/sound/core/seq/seq_virmidi.c b/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">index 56e0f4cd3f82..81134e067184 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_virmidi.c</span>
<span class="p_chunk">@@ -155,21 +155,26 @@</span> <span class="p_context"> static void snd_virmidi_output_trigger(struct snd_rawmidi_substream *substream,</span>
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
 	int count, res;
 	unsigned char buf[32], *pbuf;
<span class="p_add">+	unsigned long flags;</span>
 
 	if (up) {
 		vmidi-&gt;trigger = 1;
 		if (vmidi-&gt;seq_mode == SNDRV_VIRMIDI_SEQ_DISPATCH &amp;&amp;
 		    !(vmidi-&gt;rdev-&gt;flags &amp; SNDRV_VIRMIDI_SUBSCRIBE)) {
<span class="p_del">-			snd_rawmidi_transmit_ack(substream, substream-&gt;runtime-&gt;buffer_size - substream-&gt;runtime-&gt;avail);</span>
<span class="p_del">-			return;		/* ignored */</span>
<span class="p_add">+			while (snd_rawmidi_transmit(substream, buf,</span>
<span class="p_add">+						    sizeof(buf)) &gt; 0) {</span>
<span class="p_add">+				/* ignored */</span>
<span class="p_add">+			}</span>
<span class="p_add">+			return;</span>
 		}
 		if (vmidi-&gt;event.type != SNDRV_SEQ_EVENT_NONE) {
 			if (snd_seq_kernel_client_dispatch(vmidi-&gt;client, &amp;vmidi-&gt;event, in_atomic(), 0) &lt; 0)
 				return;
 			vmidi-&gt;event.type = SNDRV_SEQ_EVENT_NONE;
 		}
<span class="p_add">+		spin_lock_irqsave(&amp;substream-&gt;runtime-&gt;lock, flags);</span>
 		while (1) {
<span class="p_del">-			count = snd_rawmidi_transmit_peek(substream, buf, sizeof(buf));</span>
<span class="p_add">+			count = __snd_rawmidi_transmit_peek(substream, buf, sizeof(buf));</span>
 			if (count &lt;= 0)
 				break;
 			pbuf = buf;
<span class="p_chunk">@@ -179,16 +184,18 @@</span> <span class="p_context"> static void snd_virmidi_output_trigger(struct snd_rawmidi_substream *substream,</span>
 					snd_midi_event_reset_encode(vmidi-&gt;parser);
 					continue;
 				}
<span class="p_del">-				snd_rawmidi_transmit_ack(substream, res);</span>
<span class="p_add">+				__snd_rawmidi_transmit_ack(substream, res);</span>
 				pbuf += res;
 				count -= res;
 				if (vmidi-&gt;event.type != SNDRV_SEQ_EVENT_NONE) {
 					if (snd_seq_kernel_client_dispatch(vmidi-&gt;client, &amp;vmidi-&gt;event, in_atomic(), 0) &lt; 0)
<span class="p_del">-						return;</span>
<span class="p_add">+						goto out;</span>
 					vmidi-&gt;event.type = SNDRV_SEQ_EVENT_NONE;
 				}
 			}
 		}
<span class="p_add">+	out:</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;substream-&gt;runtime-&gt;lock, flags);</span>
 	} else {
 		vmidi-&gt;trigger = 0;
 	}
<span class="p_chunk">@@ -254,9 +261,13 @@</span> <span class="p_context"> static int snd_virmidi_output_open(struct snd_rawmidi_substream *substream)</span>
  */
 static int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)
 {
<span class="p_add">+	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;</span>
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
<span class="p_del">-	snd_midi_event_free(vmidi-&gt;parser);</span>
<span class="p_add">+</span>
<span class="p_add">+	write_lock_irq(&amp;rdev-&gt;filelist_lock);</span>
 	list_del(&amp;vmidi-&gt;list);
<span class="p_add">+	write_unlock_irq(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	snd_midi_event_free(vmidi-&gt;parser);</span>
 	substream-&gt;runtime-&gt;private_data = NULL;
 	kfree(vmidi);
 	return 0;
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 0a049c4578f1..f24c9fccf008 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -305,8 +305,7 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 	return 0;
 }
 
<span class="p_del">-static int _snd_timer_stop(struct snd_timer_instance *timeri,</span>
<span class="p_del">-			   int keep_flag, int event);</span>
<span class="p_add">+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);</span>
 
 /*
  * close a timer instance
<span class="p_chunk">@@ -348,7 +347,7 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		spin_unlock_irq(&amp;timer-&gt;lock);
 		mutex_lock(&amp;register_mutex);
 		list_del(&amp;timeri-&gt;open_list);
<span class="p_del">-		if (timer &amp;&amp; list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
<span class="p_add">+		if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
 		    timer-&gt;hw.close)
 			timer-&gt;hw.close(timer);
 		/* remove slave links */
<span class="p_chunk">@@ -423,7 +422,7 @@</span> <span class="p_context"> static void snd_timer_notify1(struct snd_timer_instance *ti, int event)</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	list_for_each_entry(ts, &amp;ti-&gt;slave_active_head, active_list)
 		if (ts-&gt;ccallback)
<span class="p_del">-			ts-&gt;ccallback(ti, event + 100, &amp;tstamp, resolution);</span>
<span class="p_add">+			ts-&gt;ccallback(ts, event + 100, &amp;tstamp, resolution);</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
 }
 
<span class="p_chunk">@@ -452,6 +451,10 @@</span> <span class="p_context"> static int snd_timer_start_slave(struct snd_timer_instance *timeri)</span>
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;slave_active_lock, flags);
<span class="p_add">+	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;slave_active_lock, flags);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
 	timeri-&gt;flags |= SNDRV_TIMER_IFLG_RUNNING;
 	if (timeri-&gt;master &amp;&amp; timeri-&gt;timer) {
 		spin_lock(&amp;timeri-&gt;timer-&gt;lock);
<span class="p_chunk">@@ -476,7 +479,8 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 		return -EINVAL;
 	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE) {
 		result = snd_timer_start_slave(timeri);
<span class="p_del">-		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
<span class="p_add">+		if (result &gt;= 0)</span>
<span class="p_add">+			snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
 		return result;
 	}
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -485,16 +489,22 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)
 		return -ENODEV;
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
<span class="p_add">+	if (timeri-&gt;flags &amp; (SNDRV_TIMER_IFLG_RUNNING |</span>
<span class="p_add">+			     SNDRV_TIMER_IFLG_START)) {</span>
<span class="p_add">+		result = -EBUSY;</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+	}</span>
 	timeri-&gt;ticks = timeri-&gt;cticks = ticks;
 	timeri-&gt;pticks = 0;
 	result = snd_timer_start1(timer, timeri, ticks);
<span class="p_add">+ unlock:</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
<span class="p_del">-	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
<span class="p_add">+	if (result &gt;= 0)</span>
<span class="p_add">+		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
 	return result;
 }
 
<span class="p_del">-static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
<span class="p_del">-			   int keep_flag, int event)</span>
<span class="p_add">+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)</span>
 {
 	struct snd_timer *timer;
 	unsigned long flags;
<span class="p_chunk">@@ -503,19 +513,30 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 		return -ENXIO;
 
 	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE) {
<span class="p_del">-		if (!keep_flag) {</span>
<span class="p_del">-			spin_lock_irqsave(&amp;slave_active_lock, flags);</span>
<span class="p_del">-			timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;</span>
<span class="p_del">-			list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_del">-			list_del_init(&amp;timeri-&gt;active_list);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;slave_active_lock, flags);</span>
<span class="p_add">+		if (!(timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)) {</span>
 			spin_unlock_irqrestore(&amp;slave_active_lock, flags);
<span class="p_add">+			return -EBUSY;</span>
 		}
<span class="p_add">+		if (timeri-&gt;timer)</span>
<span class="p_add">+			spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+		timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;</span>
<span class="p_add">+		list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_add">+		list_del_init(&amp;timeri-&gt;active_list);</span>
<span class="p_add">+		if (timeri-&gt;timer)</span>
<span class="p_add">+			spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;slave_active_lock, flags);</span>
 		goto __end;
 	}
 	timer = timeri-&gt;timer;
 	if (!timer)
 		return -EINVAL;
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
<span class="p_add">+	if (!(timeri-&gt;flags &amp; (SNDRV_TIMER_IFLG_RUNNING |</span>
<span class="p_add">+			       SNDRV_TIMER_IFLG_START))) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
 	list_del_init(&amp;timeri-&gt;ack_list);
 	list_del_init(&amp;timeri-&gt;active_list);
 	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown) {
<span class="p_chunk">@@ -534,9 +555,7 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 			}
 		}
 	}
<span class="p_del">-	if (!keep_flag)</span>
<span class="p_del">-		timeri-&gt;flags &amp;=</span>
<span class="p_del">-			~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);</span>
<span class="p_add">+	timeri-&gt;flags &amp;= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
       __end:
 	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
<span class="p_chunk">@@ -555,7 +574,7 @@</span> <span class="p_context"> int snd_timer_stop(struct snd_timer_instance *timeri)</span>
 	unsigned long flags;
 	int err;
 
<span class="p_del">-	err = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);</span>
<span class="p_add">+	err = _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_STOP);</span>
 	if (err &lt; 0)
 		return err;
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -587,10 +606,15 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
 	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)
 		return -ENODEV;
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
<span class="p_add">+	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING) {</span>
<span class="p_add">+		result = -EBUSY;</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+	}</span>
 	if (!timeri-&gt;cticks)
 		timeri-&gt;cticks = 1;
 	timeri-&gt;pticks = 0;
 	result = snd_timer_start1(timer, timeri, timer-&gt;sticks);
<span class="p_add">+ unlock:</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
 	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);
 	return result;
<span class="p_chunk">@@ -601,7 +625,7 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
  */
 int snd_timer_pause(struct snd_timer_instance * timeri)
 {
<span class="p_del">-	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);</span>
<span class="p_add">+	return _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_PAUSE);</span>
 }
 
 /*
<span class="p_chunk">@@ -724,8 +748,8 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 			ti-&gt;cticks = ti-&gt;ticks;
 		} else {
 			ti-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
<span class="p_del">-			if (--timer-&gt;running)</span>
<span class="p_del">-				list_del_init(&amp;ti-&gt;active_list);</span>
<span class="p_add">+			--timer-&gt;running;</span>
<span class="p_add">+			list_del_init(&amp;ti-&gt;active_list);</span>
 		}
 		if ((timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_TASKLET) ||
 		    (ti-&gt;flags &amp; SNDRV_TIMER_IFLG_FAST))
<span class="p_chunk">@@ -1900,6 +1924,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 {
 	struct snd_timer_user *tu;
 	long result = 0, unit;
<span class="p_add">+	int qhead;</span>
 	int err = 0;
 
 	tu = file-&gt;private_data;
<span class="p_chunk">@@ -1911,7 +1936,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 			if ((file-&gt;f_flags &amp; O_NONBLOCK) != 0 || result &gt; 0) {
 				err = -EAGAIN;
<span class="p_del">-				break;</span>
<span class="p_add">+				goto _error;</span>
 			}
 
 			set_current_state(TASK_INTERRUPTIBLE);
<span class="p_chunk">@@ -1926,42 +1951,37 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 			if (tu-&gt;disconnected) {
 				err = -ENODEV;
<span class="p_del">-				break;</span>
<span class="p_add">+				goto _error;</span>
 			}
 			if (signal_pending(current)) {
 				err = -ERESTARTSYS;
<span class="p_del">-				break;</span>
<span class="p_add">+				goto _error;</span>
 			}
 		}
 
<span class="p_add">+		qhead = tu-&gt;qhead++;</span>
<span class="p_add">+		tu-&gt;qhead %= tu-&gt;queue_size;</span>
 		spin_unlock_irq(&amp;tu-&gt;qlock);
<span class="p_del">-		if (err &lt; 0)</span>
<span class="p_del">-			goto _error;</span>
 
 		if (tu-&gt;tread) {
<span class="p_del">-			if (copy_to_user(buffer, &amp;tu-&gt;tqueue[tu-&gt;qhead++],</span>
<span class="p_del">-					 sizeof(struct snd_timer_tread))) {</span>
<span class="p_add">+			if (copy_to_user(buffer, &amp;tu-&gt;tqueue[qhead],</span>
<span class="p_add">+					 sizeof(struct snd_timer_tread)))</span>
 				err = -EFAULT;
<span class="p_del">-				goto _error;</span>
<span class="p_del">-			}</span>
 		} else {
<span class="p_del">-			if (copy_to_user(buffer, &amp;tu-&gt;queue[tu-&gt;qhead++],</span>
<span class="p_del">-					 sizeof(struct snd_timer_read))) {</span>
<span class="p_add">+			if (copy_to_user(buffer, &amp;tu-&gt;queue[qhead],</span>
<span class="p_add">+					 sizeof(struct snd_timer_read)))</span>
 				err = -EFAULT;
<span class="p_del">-				goto _error;</span>
<span class="p_del">-			}</span>
 		}
 
<span class="p_del">-		tu-&gt;qhead %= tu-&gt;queue_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		result += unit;</span>
<span class="p_del">-		buffer += unit;</span>
<span class="p_del">-</span>
 		spin_lock_irq(&amp;tu-&gt;qlock);
 		tu-&gt;qused--;
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto _error;</span>
<span class="p_add">+		result += unit;</span>
<span class="p_add">+		buffer += unit;</span>
 	}
<span class="p_del">-	spin_unlock_irq(&amp;tu-&gt;qlock);</span>
  _error:
<span class="p_add">+	spin_unlock_irq(&amp;tu-&gt;qlock);</span>
 	return result &gt; 0 ? result : err;
 }
 
<span class="p_header">diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c</span>
<span class="p_header">index 016e451ed506..a9f7a75702d2 100644</span>
<span class="p_header">--- a/sound/drivers/dummy.c</span>
<span class="p_header">+++ b/sound/drivers/dummy.c</span>
<span class="p_chunk">@@ -109,6 +109,9 @@</span> <span class="p_context"> struct dummy_timer_ops {</span>
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
 };
 
<span class="p_add">+#define get_dummy_ops(substream) \</span>
<span class="p_add">+	(*(const struct dummy_timer_ops **)(substream)-&gt;runtime-&gt;private_data)</span>
<span class="p_add">+</span>
 struct dummy_model {
 	const char *name;
 	int (*playback_constraints)(struct snd_pcm_runtime *runtime);
<span class="p_chunk">@@ -137,7 +140,6 @@</span> <span class="p_context"> struct snd_dummy {</span>
 	int iobox;
 	struct snd_kcontrol *cd_volume_ctl;
 	struct snd_kcontrol *cd_switch_ctl;
<span class="p_del">-	const struct dummy_timer_ops *timer_ops;</span>
 };
 
 /*
<span class="p_chunk">@@ -231,6 +233,8 @@</span> <span class="p_context"> static struct dummy_model *dummy_models[] = {</span>
  */
 
 struct dummy_systimer_pcm {
<span class="p_add">+	/* ops must be the first item */</span>
<span class="p_add">+	const struct dummy_timer_ops *timer_ops;</span>
 	spinlock_t lock;
 	struct timer_list timer;
 	unsigned long base_time;
<span class="p_chunk">@@ -366,6 +370,8 @@</span> <span class="p_context"> static struct dummy_timer_ops dummy_systimer_ops = {</span>
  */
 
 struct dummy_hrtimer_pcm {
<span class="p_add">+	/* ops must be the first item */</span>
<span class="p_add">+	const struct dummy_timer_ops *timer_ops;</span>
 	ktime_t base_time;
 	ktime_t period_time;
 	atomic_t running;
<span class="p_chunk">@@ -492,31 +498,25 @@</span> <span class="p_context"> static struct dummy_timer_ops dummy_hrtimer_ops = {</span>
 
 static int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-</span>
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
<span class="p_del">-		return dummy-&gt;timer_ops-&gt;start(substream);</span>
<span class="p_add">+		return get_dummy_ops(substream)-&gt;start(substream);</span>
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
<span class="p_del">-		return dummy-&gt;timer_ops-&gt;stop(substream);</span>
<span class="p_add">+		return get_dummy_ops(substream)-&gt;stop(substream);</span>
 	}
 	return -EINVAL;
 }
 
 static int dummy_pcm_prepare(struct snd_pcm_substream *substream)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-</span>
<span class="p_del">-	return dummy-&gt;timer_ops-&gt;prepare(substream);</span>
<span class="p_add">+	return get_dummy_ops(substream)-&gt;prepare(substream);</span>
 }
 
 static snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-</span>
<span class="p_del">-	return dummy-&gt;timer_ops-&gt;pointer(substream);</span>
<span class="p_add">+	return get_dummy_ops(substream)-&gt;pointer(substream);</span>
 }
 
 static struct snd_pcm_hardware dummy_pcm_hardware = {
<span class="p_chunk">@@ -562,17 +562,19 @@</span> <span class="p_context"> static int dummy_pcm_open(struct snd_pcm_substream *substream)</span>
 	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
 	struct dummy_model *model = dummy-&gt;model;
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
<span class="p_add">+	const struct dummy_timer_ops *ops;</span>
 	int err;
 
<span class="p_del">-	dummy-&gt;timer_ops = &amp;dummy_systimer_ops;</span>
<span class="p_add">+	ops = &amp;dummy_systimer_ops;</span>
 #ifdef CONFIG_HIGH_RES_TIMERS
 	if (hrtimer)
<span class="p_del">-		dummy-&gt;timer_ops = &amp;dummy_hrtimer_ops;</span>
<span class="p_add">+		ops = &amp;dummy_hrtimer_ops;</span>
 #endif
 
<span class="p_del">-	err = dummy-&gt;timer_ops-&gt;create(substream);</span>
<span class="p_add">+	err = ops-&gt;create(substream);</span>
 	if (err &lt; 0)
 		return err;
<span class="p_add">+	get_dummy_ops(substream) = ops;</span>
 
 	runtime-&gt;hw = dummy-&gt;pcm_hw;
 	if (substream-&gt;pcm-&gt;device &amp; 1) {
<span class="p_chunk">@@ -594,7 +596,7 @@</span> <span class="p_context"> static int dummy_pcm_open(struct snd_pcm_substream *substream)</span>
 			err = model-&gt;capture_constraints(substream-&gt;runtime);
 	}
 	if (err &lt; 0) {
<span class="p_del">-		dummy-&gt;timer_ops-&gt;free(substream);</span>
<span class="p_add">+		get_dummy_ops(substream)-&gt;free(substream);</span>
 		return err;
 	}
 	return 0;
<span class="p_chunk">@@ -602,8 +604,7 @@</span> <span class="p_context"> static int dummy_pcm_open(struct snd_pcm_substream *substream)</span>
 
 static int dummy_pcm_close(struct snd_pcm_substream *substream)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-	dummy-&gt;timer_ops-&gt;free(substream);</span>
<span class="p_add">+	get_dummy_ops(substream)-&gt;free(substream);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c</span>
<span class="p_header">index 5be5242e1ed8..7fdf34e80d5e 100644</span>
<span class="p_header">--- a/sound/firewire/bebob/bebob_stream.c</span>
<span class="p_header">+++ b/sound/firewire/bebob/bebob_stream.c</span>
<span class="p_chunk">@@ -47,14 +47,16 @@</span> <span class="p_context"> static const unsigned int bridgeco_freq_table[] = {</span>
 	[6] = 0x07,
 };
 
<span class="p_del">-static unsigned int</span>
<span class="p_del">-get_formation_index(unsigned int rate)</span>
<span class="p_add">+static int</span>
<span class="p_add">+get_formation_index(unsigned int rate, unsigned int *index)</span>
 {
 	unsigned int i;
 
 	for (i = 0; i &lt; ARRAY_SIZE(snd_bebob_rate_table); i++) {
<span class="p_del">-		if (snd_bebob_rate_table[i] == rate)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (snd_bebob_rate_table[i] == rate) {</span>
<span class="p_add">+			*index = i;</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	}
 	return -EINVAL;
 }
<span class="p_chunk">@@ -424,7 +426,9 @@</span> <span class="p_context"> make_both_connections(struct snd_bebob *bebob, unsigned int rate)</span>
 		goto end;
 
 	/* confirm params for both streams */
<span class="p_del">-	index = get_formation_index(rate);</span>
<span class="p_add">+	err = get_formation_index(rate, &amp;index);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto end;</span>
 	pcm_channels = bebob-&gt;tx_stream_formations[index].pcm;
 	midi_channels = bebob-&gt;tx_stream_formations[index].midi;
 	amdtp_stream_set_parameters(&amp;bebob-&gt;tx_stream,
<span class="p_header">diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c</span>
<span class="p_header">index 24f91114a32c..98fe629c1f86 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_generic.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_generic.c</span>
<span class="p_chunk">@@ -771,9 +771,6 @@</span> <span class="p_context"> static void activate_amp(struct hda_codec *codec, hda_nid_t nid, int dir,</span>
 	unsigned int caps;
 	unsigned int mask, val;
 
<span class="p_del">-	if (!enable &amp;&amp; is_active_nid(codec, nid, dir, idx_to_check))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	caps = query_amp_caps(codec, nid, dir);
 	val = get_amp_val_to_activate(codec, nid, dir, caps, enable);
 	mask = get_amp_mask_to_modify(codec, nid, dir, idx_to_check, caps);
<span class="p_chunk">@@ -784,12 +781,22 @@</span> <span class="p_context"> static void activate_amp(struct hda_codec *codec, hda_nid_t nid, int dir,</span>
 	update_amp(codec, nid, dir, idx, mask, val);
 }
 
<span class="p_add">+static void check_and_activate_amp(struct hda_codec *codec, hda_nid_t nid,</span>
<span class="p_add">+				   int dir, int idx, int idx_to_check,</span>
<span class="p_add">+				   bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* check whether the given amp is still used by others */</span>
<span class="p_add">+	if (!enable &amp;&amp; is_active_nid(codec, nid, dir, idx_to_check))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	activate_amp(codec, nid, dir, idx, idx_to_check, enable);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void activate_amp_out(struct hda_codec *codec, struct nid_path *path,
 			     int i, bool enable)
 {
 	hda_nid_t nid = path-&gt;path[i];
 	init_amp(codec, nid, HDA_OUTPUT, 0);
<span class="p_del">-	activate_amp(codec, nid, HDA_OUTPUT, 0, 0, enable);</span>
<span class="p_add">+	check_and_activate_amp(codec, nid, HDA_OUTPUT, 0, 0, enable);</span>
 }
 
 static void activate_amp_in(struct hda_codec *codec, struct nid_path *path,
<span class="p_chunk">@@ -817,9 +824,16 @@</span> <span class="p_context"> static void activate_amp_in(struct hda_codec *codec, struct nid_path *path,</span>
 	 * when aa-mixer is available, we need to enable the path as well
 	 */
 	for (n = 0; n &lt; nums; n++) {
<span class="p_del">-		if (n != idx &amp;&amp; (!add_aamix || conn[n] != spec-&gt;mixer_merge_nid))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		activate_amp(codec, nid, HDA_INPUT, n, idx, enable);</span>
<span class="p_add">+		if (n != idx) {</span>
<span class="p_add">+			if (conn[n] != spec-&gt;mixer_merge_nid)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			/* when aamix is disabled, force to off */</span>
<span class="p_add">+			if (!add_aamix) {</span>
<span class="p_add">+				activate_amp(codec, nid, HDA_INPUT, n, n, false);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		check_and_activate_amp(codec, nid, HDA_INPUT, n, idx, enable);</span>
 	}
 }
 
<span class="p_chunk">@@ -1580,6 +1594,12 @@</span> <span class="p_context"> static bool map_singles(struct hda_codec *codec, int outs,</span>
 	return found;
 }
 
<span class="p_add">+static inline bool has_aamix_out_paths(struct hda_gen_spec *spec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return spec-&gt;aamix_out_paths[0] || spec-&gt;aamix_out_paths[1] ||</span>
<span class="p_add">+		spec-&gt;aamix_out_paths[2];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* create a new path including aamix if available, and return its index */
 static int check_aamix_out_path(struct hda_codec *codec, int path_idx)
 {
<span class="p_chunk">@@ -2422,25 +2442,51 @@</span> <span class="p_context"> static void update_aamix_paths(struct hda_codec *codec, bool do_mix,</span>
 	}
 }
 
<span class="p_add">+/* re-initialize the output paths; only called from loopback_mixing_put() */</span>
<span class="p_add">+static void update_output_paths(struct hda_codec *codec, int num_outs,</span>
<span class="p_add">+				const int *paths)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hda_gen_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+	struct nid_path *path;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_outs; i++) {</span>
<span class="p_add">+		path = snd_hda_get_path_from_idx(codec, paths[i]);</span>
<span class="p_add">+		if (path)</span>
<span class="p_add">+			snd_hda_activate_path(codec, path, path-&gt;active,</span>
<span class="p_add">+					      spec-&gt;aamix_mode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int loopback_mixing_put(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct hda_gen_spec *spec = codec-&gt;spec;
<span class="p_add">+	const struct auto_pin_cfg *cfg = &amp;spec-&gt;autocfg;</span>
 	unsigned int val = ucontrol-&gt;value.enumerated.item[0];
 
 	if (val == spec-&gt;aamix_mode)
 		return 0;
 	spec-&gt;aamix_mode = val;
<span class="p_del">-	update_aamix_paths(codec, val, spec-&gt;out_paths[0],</span>
<span class="p_del">-			   spec-&gt;aamix_out_paths[0],</span>
<span class="p_del">-			   spec-&gt;autocfg.line_out_type);</span>
<span class="p_del">-	update_aamix_paths(codec, val, spec-&gt;hp_paths[0],</span>
<span class="p_del">-			   spec-&gt;aamix_out_paths[1],</span>
<span class="p_del">-			   AUTO_PIN_HP_OUT);</span>
<span class="p_del">-	update_aamix_paths(codec, val, spec-&gt;speaker_paths[0],</span>
<span class="p_del">-			   spec-&gt;aamix_out_paths[2],</span>
<span class="p_del">-			   AUTO_PIN_SPEAKER_OUT);</span>
<span class="p_add">+	if (has_aamix_out_paths(spec)) {</span>
<span class="p_add">+		update_aamix_paths(codec, val, spec-&gt;out_paths[0],</span>
<span class="p_add">+				   spec-&gt;aamix_out_paths[0],</span>
<span class="p_add">+				   cfg-&gt;line_out_type);</span>
<span class="p_add">+		update_aamix_paths(codec, val, spec-&gt;hp_paths[0],</span>
<span class="p_add">+				   spec-&gt;aamix_out_paths[1],</span>
<span class="p_add">+				   AUTO_PIN_HP_OUT);</span>
<span class="p_add">+		update_aamix_paths(codec, val, spec-&gt;speaker_paths[0],</span>
<span class="p_add">+				   spec-&gt;aamix_out_paths[2],</span>
<span class="p_add">+				   AUTO_PIN_SPEAKER_OUT);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		update_output_paths(codec, cfg-&gt;line_outs, spec-&gt;out_paths);</span>
<span class="p_add">+		if (cfg-&gt;line_out_type != AUTO_PIN_HP_OUT)</span>
<span class="p_add">+			update_output_paths(codec, cfg-&gt;hp_outs, spec-&gt;hp_paths);</span>
<span class="p_add">+		if (cfg-&gt;line_out_type != AUTO_PIN_SPEAKER_OUT)</span>
<span class="p_add">+			update_output_paths(codec, cfg-&gt;speaker_outs,</span>
<span class="p_add">+					    spec-&gt;speaker_paths);</span>
<span class="p_add">+	}</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -2458,12 +2504,13 @@</span> <span class="p_context"> static int create_loopback_mixing_ctl(struct hda_codec *codec)</span>
 
 	if (!spec-&gt;mixer_nid)
 		return 0;
<span class="p_del">-	if (!(spec-&gt;aamix_out_paths[0] || spec-&gt;aamix_out_paths[1] ||</span>
<span class="p_del">-	      spec-&gt;aamix_out_paths[2]))</span>
<span class="p_del">-		return 0;</span>
 	if (!snd_hda_gen_add_kctl(spec, NULL, &amp;loopback_mixing_enum))
 		return -ENOMEM;
 	spec-&gt;have_aamix_ctl = 1;
<span class="p_add">+	/* if no explicit aamix path is present (e.g. for Realtek codecs),</span>
<span class="p_add">+	 * enable aamix as default -- just for compatibility</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spec-&gt;aamix_mode = !has_aamix_out_paths(spec);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3998,9 +4045,9 @@</span> <span class="p_context"> static void pin_power_callback(struct hda_codec *codec,</span>
 			       struct hda_jack_callback *jack,
 			       bool on)
 {
<span class="p_del">-	if (jack &amp;&amp; jack-&gt;tbl-&gt;nid)</span>
<span class="p_add">+	if (jack &amp;&amp; jack-&gt;nid)</span>
 		sync_power_state_change(codec,
<span class="p_del">-					set_pin_power_jack(codec, jack-&gt;tbl-&gt;nid, on));</span>
<span class="p_add">+					set_pin_power_jack(codec, jack-&gt;nid, on));</span>
 }
 
 /* callback only doing power up -- called at first */
<span class="p_chunk">@@ -5664,6 +5711,8 @@</span> <span class="p_context"> static void init_aamix_paths(struct hda_codec *codec)</span>
 
 	if (!spec-&gt;have_aamix_ctl)
 		return;
<span class="p_add">+	if (!has_aamix_out_paths(spec))</span>
<span class="p_add">+		return;</span>
 	update_aamix_paths(codec, spec-&gt;aamix_mode, spec-&gt;out_paths[0],
 			   spec-&gt;aamix_out_paths[0],
 			   spec-&gt;autocfg.line_out_type);
<span class="p_header">diff --git a/sound/pci/hda/hda_jack.c b/sound/pci/hda/hda_jack.c</span>
<span class="p_header">index 366efbf87d41..b6dbe653b74f 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_jack.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_jack.c</span>
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> snd_hda_jack_detect_enable_callback(struct hda_codec *codec, hda_nid_t nid,</span>
 		if (!callback)
 			return ERR_PTR(-ENOMEM);
 		callback-&gt;func = func;
<span class="p_del">-		callback-&gt;tbl = jack;</span>
<span class="p_add">+		callback-&gt;nid = jack-&gt;nid;</span>
 		callback-&gt;next = jack-&gt;callback;
 		jack-&gt;callback = callback;
 	}
<span class="p_header">diff --git a/sound/pci/hda/hda_jack.h b/sound/pci/hda/hda_jack.h</span>
<span class="p_header">index 387d30984dfe..1009909ea158 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_jack.h</span>
<span class="p_header">+++ b/sound/pci/hda/hda_jack.h</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"> struct hda_jack_callback;</span>
 typedef void (*hda_jack_callback_fn) (struct hda_codec *, struct hda_jack_callback *);
 
 struct hda_jack_callback {
<span class="p_del">-	struct hda_jack_tbl *tbl;</span>
<span class="p_add">+	hda_nid_t nid;</span>
 	hda_jack_callback_fn func;
 	unsigned int private_data;	/* arbitrary data */
 	struct hda_jack_callback *next;
<span class="p_header">diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">index 5b8a5b84a03c..304a0d7a6481 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_chunk">@@ -4427,13 +4427,16 @@</span> <span class="p_context"> static void ca0132_process_dsp_response(struct hda_codec *codec,</span>
 static void hp_callback(struct hda_codec *codec, struct hda_jack_callback *cb)
 {
 	struct ca0132_spec *spec = codec-&gt;spec;
<span class="p_add">+	struct hda_jack_tbl *tbl;</span>
 
 	/* Delay enabling the HP amp, to let the mic-detection
 	 * state machine run.
 	 */
 	cancel_delayed_work_sync(&amp;spec-&gt;unsol_hp_work);
 	schedule_delayed_work(&amp;spec-&gt;unsol_hp_work, msecs_to_jiffies(500));
<span class="p_del">-	cb-&gt;tbl-&gt;block_report = 1;</span>
<span class="p_add">+	tbl = snd_hda_jack_tbl_get(codec, cb-&gt;nid);</span>
<span class="p_add">+	if (tbl)</span>
<span class="p_add">+		tbl-&gt;block_report = 1;</span>
 }
 
 static void amic_callback(struct hda_codec *codec, struct hda_jack_callback *cb)
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index 85813de26da8..ac38222cce49 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -613,6 +613,7 @@</span> <span class="p_context"> enum {</span>
 	CS4208_MAC_AUTO,
 	CS4208_MBA6,
 	CS4208_MBP11,
<span class="p_add">+	CS4208_MACMINI,</span>
 	CS4208_GPIO0,
 };
 
<span class="p_chunk">@@ -620,6 +621,7 @@</span> <span class="p_context"> static const struct hda_model_fixup cs4208_models[] = {</span>
 	{ .id = CS4208_GPIO0, .name = &quot;gpio0&quot; },
 	{ .id = CS4208_MBA6, .name = &quot;mba6&quot; },
 	{ .id = CS4208_MBP11, .name = &quot;mbp11&quot; },
<span class="p_add">+	{ .id = CS4208_MACMINI, .name = &quot;macmini&quot; },</span>
 	{}
 };
 
<span class="p_chunk">@@ -631,6 +633,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cs4208_fixup_tbl[] = {</span>
 /* codec SSID matching */
 static const struct snd_pci_quirk cs4208_mac_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x106b, 0x5e00, &quot;MacBookPro 11,2&quot;, CS4208_MBP11),
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x6c00, &quot;MacMini 7,1&quot;, CS4208_MACMINI),</span>
 	SND_PCI_QUIRK(0x106b, 0x7100, &quot;MacBookAir 6,1&quot;, CS4208_MBA6),
 	SND_PCI_QUIRK(0x106b, 0x7200, &quot;MacBookAir 6,2&quot;, CS4208_MBA6),
 	SND_PCI_QUIRK(0x106b, 0x7b00, &quot;MacBookPro 12,1&quot;, CS4208_MBP11),
<span class="p_chunk">@@ -665,6 +668,24 @@</span> <span class="p_context"> static void cs4208_fixup_mac(struct hda_codec *codec,</span>
 	snd_hda_apply_fixup(codec, action);
 }
 
<span class="p_add">+/* MacMini 7,1 has the inverted jack detection */</span>
<span class="p_add">+static void cs4208_fixup_macmini(struct hda_codec *codec,</span>
<span class="p_add">+				 const struct hda_fixup *fix, int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static const struct hda_pintbl pincfgs[] = {</span>
<span class="p_add">+		{ 0x18, 0x00ab9150 }, /* mic (audio-in) jack: disable detect */</span>
<span class="p_add">+		{ 0x21, 0x004be140 }, /* SPDIF: disable detect */</span>
<span class="p_add">+		{ }</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {</span>
<span class="p_add">+		/* HP pin (0x10) has an inverted detection */</span>
<span class="p_add">+		codec-&gt;inv_jack_detect = 1;</span>
<span class="p_add">+		/* disable the bogus Mic and SPDIF jack detections */</span>
<span class="p_add">+		snd_hda_apply_pincfgs(codec, pincfgs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cs4208_spdif_sw_put(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
<span class="p_chunk">@@ -708,6 +729,12 @@</span> <span class="p_context"> static const struct hda_fixup cs4208_fixups[] = {</span>
 		.chained = true,
 		.chain_id = CS4208_GPIO0,
 	},
<span class="p_add">+	[CS4208_MACMINI] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = cs4208_fixup_macmini,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = CS4208_GPIO0,</span>
<span class="p_add">+	},</span>
 	[CS4208_GPIO0] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cs4208_fixup_gpio0,
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index d1c74295a362..57d4cce06ab6 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -438,7 +438,8 @@</span> <span class="p_context"> static int hdmi_eld_ctl_get(struct snd_kcontrol *kcontrol,</span>
 	eld = &amp;per_pin-&gt;sink_eld;
 
 	mutex_lock(&amp;per_pin-&gt;lock);
<span class="p_del">-	if (eld-&gt;eld_size &gt; ARRAY_SIZE(ucontrol-&gt;value.bytes.data)) {</span>
<span class="p_add">+	if (eld-&gt;eld_size &gt; ARRAY_SIZE(ucontrol-&gt;value.bytes.data) ||</span>
<span class="p_add">+	    eld-&gt;eld_size &gt; ELD_MAX_SIZE) {</span>
 		mutex_unlock(&amp;per_pin-&gt;lock);
 		snd_BUG();
 		return -EINVAL;
<span class="p_chunk">@@ -1183,7 +1184,7 @@</span> <span class="p_context"> static void check_presence_and_report(struct hda_codec *codec, hda_nid_t nid)</span>
 static void jack_callback(struct hda_codec *codec,
 			  struct hda_jack_callback *jack)
 {
<span class="p_del">-	check_presence_and_report(codec, jack-&gt;tbl-&gt;nid);</span>
<span class="p_add">+	check_presence_and_report(codec, jack-&gt;nid);</span>
 }
 
 static void hdmi_intrinsic_event(struct hda_codec *codec, unsigned int res)
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 887f37761f18..f33c58d3850e 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static void alc_update_knob_master(struct hda_codec *codec,</span>
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (!uctl)
 		return;
<span class="p_del">-	val = snd_hda_codec_read(codec, jack-&gt;tbl-&gt;nid, 0,</span>
<span class="p_add">+	val = snd_hda_codec_read(codec, jack-&gt;nid, 0,</span>
 				 AC_VERB_GET_VOLUME_KNOB_CONTROL, 0);
 	val &amp;= HDA_AMP_VOLMASK;
 	uctl-&gt;value.integer.value[0] = val;
<span class="p_chunk">@@ -1795,7 +1795,6 @@</span> <span class="p_context"> enum {</span>
 	ALC882_FIXUP_NO_PRIMARY_HP,
 	ALC887_FIXUP_ASUS_BASS,
 	ALC887_FIXUP_BASS_CHMAP,
<span class="p_del">-	ALC882_FIXUP_DISABLE_AAMIX,</span>
 };
 
 static void alc889_fixup_coef(struct hda_codec *codec,
<span class="p_chunk">@@ -1957,8 +1956,6 @@</span> <span class="p_context"> static void alc882_fixup_no_primary_hp(struct hda_codec *codec,</span>
 
 static void alc_fixup_bass_chmap(struct hda_codec *codec,
 				 const struct hda_fixup *fix, int action);
<span class="p_del">-static void alc_fixup_disable_aamix(struct hda_codec *codec,</span>
<span class="p_del">-				    const struct hda_fixup *fix, int action);</span>
 
 static const struct hda_fixup alc882_fixups[] = {
 	[ALC882_FIXUP_ABIT_AW9D_MAX] = {
<span class="p_chunk">@@ -2196,10 +2193,6 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_bass_chmap,
 	},
<span class="p_del">-	[ALC882_FIXUP_DISABLE_AAMIX] = {</span>
<span class="p_del">-		.type = HDA_FIXUP_FUNC,</span>
<span class="p_del">-		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_del">-	},</span>
 };
 
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
<span class="p_chunk">@@ -2238,6 +2231,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9047, &quot;Sony Vaio TT&quot;, ALC889_FIXUP_VAIO_TT),
 	SND_PCI_QUIRK(0x104d, 0x905a, &quot;Sony Vaio Z&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 	SND_PCI_QUIRK(0x104d, 0x9043, &quot;Sony Vaio VGC-LN51JGB&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
<span class="p_add">+	SND_PCI_QUIRK(0x104d, 0x9044, &quot;Sony VAIO AiO&quot;, ALC882_FIXUP_NO_PRIMARY_HP),</span>
 
 	/* All Apple entries are in codec SSIDs */
 	SND_PCI_QUIRK(0x106b, 0x00a0, &quot;MacBookPro 3,1&quot;, ALC889_FIXUP_MBP_VREF),
<span class="p_chunk">@@ -2267,7 +2261,6 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
 	SND_PCI_QUIRK_VENDOR(0x1462, &quot;MSI&quot;, ALC882_FIXUP_GPIO3),
 	SND_PCI_QUIRK(0x1458, 0xa002, &quot;Gigabyte EP45-DS3/Z87X-UD3H&quot;, ALC889_FIXUP_FRONT_HP_NO_PRESENCE),
<span class="p_del">-	SND_PCI_QUIRK(0x1458, 0xa182, &quot;Gigabyte Z170X-UD3&quot;, ALC882_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x147b, 0x107a, &quot;Abit AW9D-MAX&quot;, ALC882_FIXUP_ABIT_AW9D_MAX),
 	SND_PCI_QUIRK_VENDOR(0x1558, &quot;Clevo laptop&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x161f, 0x2054, &quot;Medion laptop&quot;, ALC883_FIXUP_EAPD),
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index 14a62b8117fd..79f78989a7b6 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -493,9 +493,9 @@</span> <span class="p_context"> static void jack_update_power(struct hda_codec *codec,</span>
 	if (!spec-&gt;num_pwrs)
 		return;
 
<span class="p_del">-	if (jack &amp;&amp; jack-&gt;tbl-&gt;nid) {</span>
<span class="p_del">-		stac_toggle_power_map(codec, jack-&gt;tbl-&gt;nid,</span>
<span class="p_del">-				      snd_hda_jack_detect(codec, jack-&gt;tbl-&gt;nid),</span>
<span class="p_add">+	if (jack &amp;&amp; jack-&gt;nid) {</span>
<span class="p_add">+		stac_toggle_power_map(codec, jack-&gt;nid,</span>
<span class="p_add">+				      snd_hda_jack_detect(codec, jack-&gt;nid),</span>
 				      true);
 		return;
 	}
<span class="p_header">diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c</span>
<span class="p_header">index 5c101af0ac63..a06cdcfffd2a 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5645.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5645.c</span>
<span class="p_chunk">@@ -500,7 +500,7 @@</span> <span class="p_context"> static const struct snd_kcontrol_new rt5645_snd_controls[] = {</span>
 
 	/* IN1/IN2 Control */
 	SOC_SINGLE_TLV(&quot;IN1 Boost&quot;, RT5645_IN1_CTRL1,
<span class="p_del">-		RT5645_BST_SFT1, 8, 0, bst_tlv),</span>
<span class="p_add">+		RT5645_BST_SFT1, 12, 0, bst_tlv),</span>
 	SOC_SINGLE_TLV(&quot;IN2 Boost&quot;, RT5645_IN2_CTRL,
 		RT5645_BST_SFT2, 8, 0, bst_tlv),
 
<span class="p_header">diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c</span>
<span class="p_header">index 70e4b9d8bdcd..81133fe5f2d0 100644</span>
<span class="p_header">--- a/sound/soc/soc-pcm.c</span>
<span class="p_header">+++ b/sound/soc/soc-pcm.c</span>
<span class="p_chunk">@@ -1696,7 +1696,8 @@</span> <span class="p_context"> int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)</span>
 		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &amp;&amp;
 		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &amp;&amp;
 		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED) &amp;&amp;
<span class="p_del">-		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))</span>
<span class="p_add">+		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &amp;&amp;</span>
<span class="p_add">+		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))</span>
 			continue;
 
 		dev_dbg(be-&gt;dev, &quot;ASoC: hw_free BE %s\n&quot;,
<span class="p_header">diff --git a/sound/usb/midi.c b/sound/usb/midi.c</span>
<span class="p_header">index bec63e0d2605..f059326a4914 100644</span>
<span class="p_header">--- a/sound/usb/midi.c</span>
<span class="p_header">+++ b/sound/usb/midi.c</span>
<span class="p_chunk">@@ -2451,7 +2451,6 @@</span> <span class="p_context"> int snd_usbmidi_create(struct snd_card *card,</span>
 	else
 		err = snd_usbmidi_create_endpoints(umidi, endpoints);
 	if (err &lt; 0) {
<span class="p_del">-		snd_usbmidi_free(umidi);</span>
 		return err;
 	}
 
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index fb9a8a5787a6..37d8ababfc04 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1118,6 +1118,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	switch (chip-&gt;usb_id) {
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
<span class="p_add">+	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */</span>
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
<span class="p_chunk">@@ -1202,8 +1203,12 @@</span> <span class="p_context"> void snd_usb_set_interface_quirk(struct usb_device *dev)</span>
 	 * &quot;Playback Design&quot; products need a 50ms delay after setting the
 	 * USB interface.
 	 */
<span class="p_del">-	if (le16_to_cpu(dev-&gt;descriptor.idVendor) == 0x23ba)</span>
<span class="p_add">+	switch (le16_to_cpu(dev-&gt;descriptor.idVendor)) {</span>
<span class="p_add">+	case 0x23ba: /* Playback Design */</span>
<span class="p_add">+	case 0x0644: /* TEAC Corp. */</span>
 		mdelay(50);
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
<span class="p_chunk">@@ -1218,6 +1223,14 @@</span> <span class="p_context"> void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,</span>
 	    (requesttype &amp; USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * &quot;TEAC Corp.&quot; products need a 20ms delay after each</span>
<span class="p_add">+	 * class compliant request</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((le16_to_cpu(dev-&gt;descriptor.idVendor) == 0x0644) &amp;&amp;</span>
<span class="p_add">+	    (requesttype &amp; USB_TYPE_MASK) == USB_TYPE_CLASS)</span>
<span class="p_add">+		mdelay(20);</span>
<span class="p_add">+</span>
 	/* Marantz/Denon devices with USB DAC functionality need a delay
 	 * after each class compliant request
 	 */
<span class="p_chunk">@@ -1266,7 +1279,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
<span class="p_del">-	case USB_ID(0x22d8, 0x0416): /* OPPO HA-1*/</span>
<span class="p_add">+	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */</span>
 		if (fp-&gt;altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
<span class="p_chunk">@@ -1275,6 +1288,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
 	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
 	case USB_ID(0x20b1, 0x3023): /* Aune X1S 32BIT/384 DSD DAC */
<span class="p_add">+	case USB_ID(0x2616, 0x0106): /* PS Audio NuWave DAC */</span>
 		if (fp-&gt;altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



