
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[tip:x86/asm] x86/mm: Add DMA support for SEV memory encryption - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [tip:x86/asm] x86/mm: Add DMA support for SEV memory encryption</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=60001">tip-bot for Jacob Shin</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 7, 2017, 2:46 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;tip-d7b417fa08d1187923c270bc33a3555c2fcff8b9@git.kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10046835/mbox/"
   >mbox</a>
|
   <a href="/patch/10046835/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10046835/">/patch/10046835/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2D04060247 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  7 Nov 2017 14:54:22 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1B61B29CCC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  7 Nov 2017 14:54:22 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 0FAE32A15F; Tue,  7 Nov 2017 14:54:22 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5DA6E29CCC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  7 Nov 2017 14:54:21 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934450AbdKGOyR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 7 Nov 2017 09:54:17 -0500
Received: from terminus.zytor.com ([65.50.211.136]:52783 &quot;EHLO
	terminus.zytor.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S934155AbdKGOyQ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 7 Nov 2017 09:54:16 -0500
Received: from terminus.zytor.com (localhost [127.0.0.1])
	by terminus.zytor.com (8.15.2/8.15.2) with ESMTP id vA7Ekt56027878;
	Tue, 7 Nov 2017 06:46:55 -0800
Received: (from tipbot@localhost)
	by terminus.zytor.com (8.15.2/8.15.2/Submit) id vA7EkslU027870;
	Tue, 7 Nov 2017 06:46:54 -0800
Date: Tue, 7 Nov 2017 06:46:54 -0800
X-Authentication-Warning: terminus.zytor.com: tipbot set sender to
	tipbot@zytor.com using -f
From: tip-bot for Tom Lendacky &lt;tipbot@zytor.com&gt;
Message-ID: &lt;tip-d7b417fa08d1187923c270bc33a3555c2fcff8b9@git.kernel.org&gt;
Cc: bp@suse.de, hpa@zytor.com, linux-kernel@vger.kernel.org,
	mingo@kernel.org, tglx@linutronix.de, konrad.wilk@oracle.com,
	brijesh.singh@amd.com, bp@alien8.de, thomas.lendacky@amd.com
Reply-To: linux-kernel@vger.kernel.org, hpa@zytor.com, bp@suse.de,
	mingo@kernel.org, tglx@linutronix.de, konrad.wilk@oracle.com,
	bp@alien8.de, brijesh.singh@amd.com, thomas.lendacky@amd.com
In-Reply-To: &lt;20171020143059.3291-12-brijesh.singh@amd.com&gt;
References: &lt;20171020143059.3291-12-brijesh.singh@amd.com&gt;
To: linux-tip-commits@vger.kernel.org
Subject: [tip:x86/asm] x86/mm: Add DMA support for SEV memory encryption
Git-Commit-ID: d7b417fa08d1187923c270bc33a3555c2fcff8b9
X-Mailer: tip-git-log-daemon
Robot-ID: &lt;tip-bot.git.kernel.org&gt;
Robot-Unsubscribe: Contact &lt;mailto:hpa@kernel.org&gt; to get blacklisted from
	these emails
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
Content-Type: text/plain; charset=UTF-8
Content-Disposition: inline
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=60001">tip-bot for Jacob Shin</a> - Nov. 7, 2017, 2:46 p.m.</div>
<pre class="content">
Commit-ID:  d7b417fa08d1187923c270bc33a3555c2fcff8b9
Gitweb:     https://git.kernel.org/tip/d7b417fa08d1187923c270bc33a3555c2fcff8b9
Author:     Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
AuthorDate: Fri, 20 Oct 2017 09:30:53 -0500
Committer:  Thomas Gleixner &lt;tglx@linutronix.de&gt;
CommitDate: Tue, 7 Nov 2017 15:35:58 +0100

x86/mm: Add DMA support for SEV memory encryption

DMA access to encrypted memory cannot be performed when SEV is active.
In order for DMA to properly work when SEV is active, the SWIOTLB bounce
buffers must be used.
<span class="signed-off-by">
Signed-off-by: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Brijesh Singh &lt;brijesh.singh@amd.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="reviewed-by">Reviewed-by: Borislav Petkov &lt;bp@suse.de&gt;C</span>
<span class="tested-by">Tested-by: Borislav Petkov &lt;bp@suse.de&gt;</span>
Cc: kvm@vger.kernel.org
Cc: Konrad Rzeszutek Wilk &lt;konrad.wilk@oracle.com&gt;
Cc: Borislav Petkov &lt;bp@alien8.de&gt;
Link: https://lkml.kernel.org/r/20171020143059.3291-12-brijesh.singh@amd.com

---
 arch/x86/mm/mem_encrypt.c | 86 +++++++++++++++++++++++++++++++++++++++++++++++
 lib/swiotlb.c             |  5 +--
 2 files changed, 89 insertions(+), 2 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index add836d..e8bfad7 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -192,6 +192,70 @@</span> <span class="p_context"> void __init sme_early_init(void)</span>
 	/* Update the protection map with memory encryption mask */
 	for (i = 0; i &lt; ARRAY_SIZE(protection_map); i++)
 		protection_map[i] = pgprot_encrypted(protection_map[i]);
<span class="p_add">+</span>
<span class="p_add">+	if (sev_active())</span>
<span class="p_add">+		swiotlb_force = SWIOTLB_FORCE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *sev_alloc(struct device *dev, size_t size, dma_addr_t *dma_handle,</span>
<span class="p_add">+		       gfp_t gfp, unsigned long attrs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long dma_mask;</span>
<span class="p_add">+	unsigned int order;</span>
<span class="p_add">+	struct page *page;</span>
<span class="p_add">+	void *vaddr = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	dma_mask = dma_alloc_coherent_mask(dev, gfp);</span>
<span class="p_add">+	order = get_order(size);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Memory will be memset to zero after marking decrypted, so don&#39;t</span>
<span class="p_add">+	 * bother clearing it before.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	gfp &amp;= ~__GFP_ZERO;</span>
<span class="p_add">+</span>
<span class="p_add">+	page = alloc_pages_node(dev_to_node(dev), gfp, order);</span>
<span class="p_add">+	if (page) {</span>
<span class="p_add">+		dma_addr_t addr;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Since we will be clearing the encryption bit, check the</span>
<span class="p_add">+		 * mask with it already cleared.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		addr = __sme_clr(phys_to_dma(dev, page_to_phys(page)));</span>
<span class="p_add">+		if ((addr + size) &gt; dma_mask) {</span>
<span class="p_add">+			__free_pages(page, get_order(size));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			vaddr = page_address(page);</span>
<span class="p_add">+			*dma_handle = addr;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!vaddr)</span>
<span class="p_add">+		vaddr = swiotlb_alloc_coherent(dev, size, dma_handle, gfp);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!vaddr)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear the SME encryption bit for DMA use if not swiotlb area */</span>
<span class="p_add">+	if (!is_swiotlb_buffer(dma_to_phys(dev, *dma_handle))) {</span>
<span class="p_add">+		set_memory_decrypted((unsigned long)vaddr, 1 &lt;&lt; order);</span>
<span class="p_add">+		memset(vaddr, 0, PAGE_SIZE &lt;&lt; order);</span>
<span class="p_add">+		*dma_handle = __sme_clr(*dma_handle);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return vaddr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void sev_free(struct device *dev, size_t size, void *vaddr,</span>
<span class="p_add">+		     dma_addr_t dma_handle, unsigned long attrs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Set the SME encryption bit for re-use if not swiotlb area */</span>
<span class="p_add">+	if (!is_swiotlb_buffer(dma_to_phys(dev, dma_handle)))</span>
<span class="p_add">+		set_memory_encrypted((unsigned long)vaddr,</span>
<span class="p_add">+				     1 &lt;&lt; get_order(size));</span>
<span class="p_add">+</span>
<span class="p_add">+	swiotlb_free_coherent(dev, size, vaddr, dma_handle);</span>
 }
 
 /*
<span class="p_chunk">@@ -218,6 +282,20 @@</span> <span class="p_context"> bool sev_active(void)</span>
 }
 EXPORT_SYMBOL_GPL(sev_active);
 
<span class="p_add">+static const struct dma_map_ops sev_dma_ops = {</span>
<span class="p_add">+	.alloc                  = sev_alloc,</span>
<span class="p_add">+	.free                   = sev_free,</span>
<span class="p_add">+	.map_page               = swiotlb_map_page,</span>
<span class="p_add">+	.unmap_page             = swiotlb_unmap_page,</span>
<span class="p_add">+	.map_sg                 = swiotlb_map_sg_attrs,</span>
<span class="p_add">+	.unmap_sg               = swiotlb_unmap_sg_attrs,</span>
<span class="p_add">+	.sync_single_for_cpu    = swiotlb_sync_single_for_cpu,</span>
<span class="p_add">+	.sync_single_for_device = swiotlb_sync_single_for_device,</span>
<span class="p_add">+	.sync_sg_for_cpu        = swiotlb_sync_sg_for_cpu,</span>
<span class="p_add">+	.sync_sg_for_device     = swiotlb_sync_sg_for_device,</span>
<span class="p_add">+	.mapping_error          = swiotlb_dma_mapping_error,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /* Architecture __weak replacement functions */
 void __init mem_encrypt_init(void)
 {
<span class="p_chunk">@@ -227,6 +305,14 @@</span> <span class="p_context"> void __init mem_encrypt_init(void)</span>
 	/* Call into SWIOTLB to update the SWIOTLB DMA buffers */
 	swiotlb_update_mem_attributes();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * With SEV, DMA operations cannot use encryption. New DMA ops</span>
<span class="p_add">+	 * are required in order to mark the DMA areas as decrypted or</span>
<span class="p_add">+	 * to use bounce buffers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (sev_active())</span>
<span class="p_add">+		dma_ops = &amp;sev_dma_ops;</span>
<span class="p_add">+</span>
 	pr_info(&quot;AMD Secure Memory Encryption (SME) active\n&quot;);
 }
 
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index 8c6c83e..cea19aa 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -507,8 +507,9 @@</span> <span class="p_context"> phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,</span>
 	if (no_iotlb_memory)
 		panic(&quot;Can not allocate SWIOTLB buffer earlier and can&#39;t now provide you with the DMA bounce buffer&quot;);
 
<span class="p_del">-	if (sme_active())</span>
<span class="p_del">-		pr_warn_once(&quot;SME is active and system is using DMA bounce buffers\n&quot;);</span>
<span class="p_add">+	if (mem_encrypt_active())</span>
<span class="p_add">+		pr_warn_once(&quot;%s is active and system is using DMA bounce buffers\n&quot;,</span>
<span class="p_add">+			     sme_active() ? &quot;SME&quot; : &quot;SEV&quot;);</span>
 
 	mask = dma_get_seg_boundary(hwdev);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



