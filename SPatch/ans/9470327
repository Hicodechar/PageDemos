
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] x86/idle changes for v4.10 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] x86/idle changes for v4.10</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 12, 2016, 10:01 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161212100124.GA22483@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9470327/mbox/"
   >mbox</a>
|
   <a href="/patch/9470327/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9470327/">/patch/9470327/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9F51F60476 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 12 Dec 2016 10:01:45 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 93C2E283F8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 12 Dec 2016 10:01:45 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 880032845A; Mon, 12 Dec 2016 10:01:45 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.3 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D5F50283F8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 12 Dec 2016 10:01:42 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932383AbcLLKBd (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 12 Dec 2016 05:01:33 -0500
Received: from mail-wm0-f66.google.com ([74.125.82.66]:34316 &quot;EHLO
	mail-wm0-f66.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932123AbcLLKB3 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 12 Dec 2016 05:01:29 -0500
Received: by mail-wm0-f66.google.com with SMTP id g23so10139706wme.1
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 12 Dec 2016 02:01:28 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=keS26euc/KCewcvQAS0e1uX17NFCJ2+aY2S7lFnidvY=;
	b=KpV0MZOn+tWf5WrHvduXzPGSDl+e6FmnFKT1dxFkEI9AMJNOlUDHszUO7FMIj7ZuZL
	KRzR6fHaYg4txjc3GDNaWlzmB6PFJkqB1r2886ewjGsqi21zntBuS+9RHVZVZFN3Syjx
	JYpjKsmKwUnFecD8DttWezybQv2aDEo3BBhhx084hvVFDxLFvO7BSu6s3V+Xtgjx3EnN
	7IpFlrjzX3IXzI4BqLaT3Un5lCRRgqUElrx7uzEEEo5b9+9WKF5H0a+zAU4EmWw6IHeH
	IxAEZgNW76R+BfuVsz5+wy4IqbDyftEPZDCvNDffFEbtZsT1rWCvtJ6m+wjKXrTogb4O
	RNag==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20130820;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=keS26euc/KCewcvQAS0e1uX17NFCJ2+aY2S7lFnidvY=;
	b=EZEZGRfmSSDJJUHpbzW28uYCcDM94c9Q5ee38g5A/5O0d4jQf2GZu0EgFd+TMbpLU1
	U+TxlNvIWR0XGMoJOxHKPuiEVJ8YcwDWA8LEY/f30dUV6paHOtqrFPXj+SetRdpJS8Bv
	ZBwR+AgAGGBtfRrJF2shzHmtpxRzcnpbE2V0MABrQRz/VfotXGABk5vpnIUUJZy/73xM
	mIy1AcOK4snafvU72pqCB6V/swkI1azFHD6SB+NYLEuiQQ48gcHQ85lvDWCdtVkK+2WG
	Q+SjnPTuwsKszM/o3plJqW65YZNjzY/Tp5VxCOrdxqsuDrGHfAQ9paCTMESV4lppHP/x
	/HtA==
X-Gm-Message-State: AKaTC02obsPZb0tt6BgHlFpQm/7iStCXWB27CAEZdFzYIqaC9O3GWiZkHnAEcVwpD22JNg==
X-Received: by 10.28.13.9 with SMTP id 9mr15891883wmn.50.1481536887383;
	Mon, 12 Dec 2016 02:01:27 -0800 (PST)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	l6sm34625758wmd.5.2016.12.12.02.01.26
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 12 Dec 2016 02:01:26 -0800 (PST)
Date: Mon, 12 Dec 2016 11:01:24 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;, Borislav Petkov &lt;bp@alien8.de&gt;,
	Len Brown &lt;lenb@kernel.org&gt;, Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [GIT PULL] x86/idle changes for v4.10
Message-ID: &lt;20161212100124.GA22483@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Dec. 12, 2016, 10:01 a.m.</div>
<pre class="content">
Linus,

Please pull the latest x86-idle-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-idle-for-linus

   # HEAD: 34bc3560c657d3d4fb17367ed9bfda803166dce0 x86: Remove empty idle.h header

There were two bigger changes in this development cycle:

 - Remove idle notifiers:

     32 files changed, 74 insertions(+), 803 deletions(-)

   These notifiers were of questionable value and the main usecase, the i7300 
   driver, was essentially unmaintained and can be removed, plus modern
   power management concepts don&#39;t need the callback - so use this golden
   opportunity and get rid of this opaque and fragile callback from a latency
   sensitive code path.

   (Len Brown, Thomas Gleixner)

 - Improve the AMD Erratum 400 workaround that used high overhead MSR polling in
   the idle loop. (Borisla Petkov, Thomas Gleixner)

  out-of-topic modifications in x86-idle-for-linus:
  ---------------------------------------------------
  MAINTAINERS                        # b65ce83f2a60: i7300_idle: Remove this driv
  drivers/acpi/processor_idle.c      # 07c94a381253: x86/amd: Simplify AMD E400 a
  drivers/dma/ioat/registers.h       # b65ce83f2a60: i7300_idle: Remove this driv
  drivers/idle/Kconfig               # b65ce83f2a60: i7300_idle: Remove this driv
  drivers/idle/Makefile              # b65ce83f2a60: i7300_idle: Remove this driv
  drivers/idle/i7300_idle.c          # b65ce83f2a60: i7300_idle: Remove this driv
  drivers/thermal/intel_powerclamp.c # 34bc3560c657: x86: Remove empty idle.h hea

 Thanks,

	Ingo

------------------&gt;
Borislav Petkov (2):
      x86/cpufeature: Provide helper to set bugs bits
      x86/amd: Simplify AMD E400 aware idle routine

Len Brown (5):
      i7300_idle: Remove this driver
      x86/idle: Remove idle_notifier
      x86/idle: Remove is_idle flag
      x86: Remove x86_test_and_clear_bit_percpu()
      x86/idle: Remove enter_idle(), exit_idle()

Thomas Gleixner (3):
      x86/bugs: Separate AMD E400 erratum and C1E bug
      x86/amd: Check for the C1E bug post ACPI subsystem init
      x86: Remove empty idle.h header


 MAINTAINERS                              |   6 -
 arch/x86/include/asm/acpi.h              |   2 +-
 arch/x86/include/asm/apic.h              |   2 -
 arch/x86/include/asm/cpufeature.h        |   1 +
 arch/x86/include/asm/cpufeatures.h       |   2 +
 arch/x86/include/asm/idle.h              |  22 --
 arch/x86/include/asm/percpu.h            |  11 -
 arch/x86/include/asm/processor.h         |   3 +-
 arch/x86/kernel/apic/apic.c              |   3 +-
 arch/x86/kernel/apic/io_apic.c           |   1 -
 arch/x86/kernel/cpu/amd.c                |  20 +-
 arch/x86/kernel/cpu/common.c             |   1 -
 arch/x86/kernel/cpu/mcheck/mce_amd.c     |   1 -
 arch/x86/kernel/cpu/mcheck/therm_throt.c |   1 -
 arch/x86/kernel/cpu/mcheck/threshold.c   |   1 -
 arch/x86/kernel/cpu/mshyperv.c           |   1 -
 arch/x86/kernel/irq.c                    |   1 -
 arch/x86/kernel/irq_64.c                 |   1 -
 arch/x86/kernel/kvm.c                    |   3 -
 arch/x86/kernel/process.c                | 149 +++-----
 arch/x86/kernel/process_32.c             |   1 -
 arch/x86/kernel/process_64.c             |   1 -
 arch/x86/kernel/smpboot.c                |   2 -
 arch/x86/platform/uv/tlb_uv.c            |   1 -
 drivers/acpi/processor_idle.c            |   2 +-
 drivers/dma/ioat/registers.h             |   2 -
 drivers/idle/Kconfig                     |  17 -
 drivers/idle/Makefile                    |   1 -
 drivers/idle/i7300_idle.c                | 612 -------------------------------
 drivers/thermal/intel_powerclamp.c       |   1 -
 drivers/xen/events/events_base.c         |   2 -
 init/main.c                              |   3 +
 32 files changed, 74 insertions(+), 803 deletions(-)
 delete mode 100644 arch/x86/include/asm/idle.h
 delete mode 100644 drivers/idle/i7300_idle.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 851b89b9edcb..80db20008488 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -6087,12 +6087,6 @@</span> <span class="p_context"> S:	Maintained</span>
 F:	Documentation/cdrom/ide-cd
 F:	drivers/ide/ide-cd*
 
<span class="p_del">-IDLE-I7300</span>
<span class="p_del">-M:	Andy Henroid &lt;andrew.d.henroid@intel.com&gt;</span>
<span class="p_del">-L:	linux-pm@vger.kernel.org</span>
<span class="p_del">-S:	Supported</span>
<span class="p_del">-F:	drivers/idle/i7300_idle.c</span>
<span class="p_del">-</span>
 IEEE 802.15.4 SUBSYSTEM
 M:	Alexander Aring &lt;aar@pengutronix.de&gt;
 L:	linux-wpan@vger.kernel.org
<span class="p_header">diff --git a/arch/x86/include/asm/acpi.h b/arch/x86/include/asm/acpi.h</span>
<span class="p_header">index 5391b0ae7cc3..395b69551fce 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/acpi.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/acpi.h</span>
<span class="p_chunk">@@ -94,7 +94,7 @@</span> <span class="p_context"> static inline unsigned int acpi_processor_cstate_check(unsigned int max_cstate)</span>
 	    boot_cpu_data.x86_model &lt;= 0x05 &amp;&amp;
 	    boot_cpu_data.x86_mask &lt; 0x0A)
 		return 1;
<span class="p_del">-	else if (amd_e400_c1e_detected)</span>
<span class="p_add">+	else if (boot_cpu_has(X86_BUG_AMD_APIC_C1E))</span>
 		return 1;
 	else
 		return max_cstate;
<span class="p_header">diff --git a/arch/x86/include/asm/apic.h b/arch/x86/include/asm/apic.h</span>
<span class="p_header">index f5aaf6c83222..30a5642eb405 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/apic.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/apic.h</span>
<span class="p_chunk">@@ -11,7 +11,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/mpspec.h&gt;
 #include &lt;asm/msr.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 
 #define ARCH_APICTIMER_STOPS_ON_C3	1
 
<span class="p_chunk">@@ -639,7 +638,6 @@</span> <span class="p_context"> extern void irq_exit(void);</span>
 static inline void entering_irq(void)
 {
 	irq_enter();
<span class="p_del">-	exit_idle();</span>
 }
 
 static inline void entering_ack_irq(void)
<span class="p_header">diff --git a/arch/x86/include/asm/cpufeature.h b/arch/x86/include/asm/cpufeature.h</span>
<span class="p_header">index 1d2b69fc0ceb..d59c15c3defd 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/cpufeature.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpufeature.h</span>
<span class="p_chunk">@@ -204,6 +204,7 @@</span> <span class="p_context"> static __always_inline __pure bool _static_cpu_has(u16 bit)</span>
 
 #define static_cpu_has_bug(bit)		static_cpu_has((bit))
 #define boot_cpu_has_bug(bit)		cpu_has_bug(&amp;boot_cpu_data, (bit))
<span class="p_add">+#define boot_cpu_set_bug(bit)		set_cpu_cap(&amp;boot_cpu_data, (bit))</span>
 
 #define MAX_CPU_FEATURES		(NCAPINTS * 32)
 #define cpu_have_feature		boot_cpu_has
<span class="p_header">diff --git a/arch/x86/include/asm/cpufeatures.h b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">index a39629206864..ed10b5bf9b93 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/cpufeatures.h</span>
<span class="p_chunk">@@ -311,4 +311,6 @@</span> <span class="p_context"></span>
 #define X86_BUG_NULL_SEG	X86_BUG(10) /* Nulling a selector preserves the base */
 #define X86_BUG_SWAPGS_FENCE	X86_BUG(11) /* SWAPGS without input dep on GS */
 #define X86_BUG_MONITOR		X86_BUG(12) /* IPI required to wake up remote CPU */
<span class="p_add">+#define X86_BUG_AMD_E400	X86_BUG(13) /* CPU is among the affected by Erratum 400 */</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_CPUFEATURES_H */
<span class="p_header">diff --git a/arch/x86/include/asm/idle.h b/arch/x86/include/asm/idle.h</span>
deleted file mode 100644
<span class="p_header">index c5d1785373ed..000000000000</span>
<span class="p_header">--- a/arch/x86/include/asm/idle.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,22 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _ASM_X86_IDLE_H</span>
<span class="p_del">-#define _ASM_X86_IDLE_H</span>
<span class="p_del">-</span>
<span class="p_del">-#define IDLE_START 1</span>
<span class="p_del">-#define IDLE_END 2</span>
<span class="p_del">-</span>
<span class="p_del">-struct notifier_block;</span>
<span class="p_del">-void idle_notifier_register(struct notifier_block *n);</span>
<span class="p_del">-void idle_notifier_unregister(struct notifier_block *n);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-void enter_idle(void);</span>
<span class="p_del">-void exit_idle(void);</span>
<span class="p_del">-#else /* !CONFIG_X86_64 */</span>
<span class="p_del">-static inline void enter_idle(void) { }</span>
<span class="p_del">-static inline void exit_idle(void) { }</span>
<span class="p_del">-static inline void __exit_idle(void) { }</span>
<span class="p_del">-#endif /* CONFIG_X86_64 */</span>
<span class="p_del">-</span>
<span class="p_del">-void amd_e400_remove_cpu(int cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _ASM_X86_IDLE_H */</span>
<span class="p_header">diff --git a/arch/x86/include/asm/percpu.h b/arch/x86/include/asm/percpu.h</span>
<span class="p_header">index 84f58de08c2b..9fa03604b2b3 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/percpu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/percpu.h</span>
<span class="p_chunk">@@ -507,17 +507,6 @@</span> <span class="p_context"> do {									\</span>
 
 #endif
 
<span class="p_del">-/* This is not atomic against other CPUs -- CPU preemption needs to be off */</span>
<span class="p_del">-#define x86_test_and_clear_bit_percpu(bit, var)				\</span>
<span class="p_del">-({									\</span>
<span class="p_del">-	bool old__;							\</span>
<span class="p_del">-	asm volatile(&quot;btr %2,&quot;__percpu_arg(1)&quot;\n\t&quot;			\</span>
<span class="p_del">-		     CC_SET(c)						\</span>
<span class="p_del">-		     : CC_OUT(c) (old__), &quot;+m&quot; (var)			\</span>
<span class="p_del">-		     : &quot;dIr&quot; (bit));					\</span>
<span class="p_del">-	old__;								\</span>
<span class="p_del">-})</span>
<span class="p_del">-</span>
 static __always_inline bool x86_this_cpu_constant_test_bit(unsigned int nr,
                         const unsigned long __percpu *addr)
 {
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index 984a7bf17f6a..fa609c6f6ba9 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -621,10 +621,9 @@</span> <span class="p_context"> static inline void sync_core(void)</span>
 }
 
 extern void select_idle_routine(const struct cpuinfo_x86 *c);
<span class="p_del">-extern void init_amd_e400_c1e_mask(void);</span>
<span class="p_add">+extern void amd_e400_c1e_apic_setup(void);</span>
 
 extern unsigned long		boot_option_idle_override;
<span class="p_del">-extern bool			amd_e400_c1e_detected;</span>
 
 enum idle_boot_override {IDLE_NO_OVERRIDE=0, IDLE_HALT, IDLE_NOMWAIT,
 			 IDLE_POLL};
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index 88c657b057e2..2ab0ff0f1dbe 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -48,7 +48,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/io_apic.h&gt;
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/hpet.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/mtrr.h&gt;
 #include &lt;asm/time.h&gt;
 #include &lt;asm/smp.h&gt;
<span class="p_chunk">@@ -894,11 +893,13 @@</span> <span class="p_context"> void __init setup_boot_APIC_clock(void)</span>
 
 	/* Setup the lapic or request the broadcast */
 	setup_APIC_timer();
<span class="p_add">+	amd_e400_c1e_apic_setup();</span>
 }
 
 void setup_secondary_APIC_clock(void)
 {
 	setup_APIC_timer();
<span class="p_add">+	amd_e400_c1e_apic_setup();</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index 48e6d84f173e..945e512a112a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -48,7 +48,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/bootmem.h&gt;
 
 #include &lt;asm/irqdomain.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/io.h&gt;
 #include &lt;asm/smp.h&gt;
 #include &lt;asm/cpu.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">index b81fe2d63e15..ae26c282f5d3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_chunk">@@ -20,6 +20,10 @@</span> <span class="p_context"></span>
 
 #include &quot;cpu.h&quot;
 
<span class="p_add">+static const int amd_erratum_383[];</span>
<span class="p_add">+static const int amd_erratum_400[];</span>
<span class="p_add">+static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);</span>
<span class="p_add">+</span>
 /*
  * nodes_per_socket: Stores the number of nodes per socket.
  * Refer to Fam15h Models 00-0fh BKDG - CPUID Fn8000_001E_ECX
<span class="p_chunk">@@ -589,11 +593,16 @@</span> <span class="p_context"> static void early_init_amd(struct cpuinfo_x86 *c)</span>
 	/* F16h erratum 793, CVE-2013-6885 */
 	if (c-&gt;x86 == 0x16 &amp;&amp; c-&gt;x86_model &lt;= 0xf)
 		msr_set_bit(MSR_AMD64_LS_CFG, 15);
<span class="p_del">-}</span>
 
<span class="p_del">-static const int amd_erratum_383[];</span>
<span class="p_del">-static const int amd_erratum_400[];</span>
<span class="p_del">-static bool cpu_has_amd_erratum(struct cpuinfo_x86 *cpu, const int *erratum);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check whether the machine is affected by erratum 400. This is</span>
<span class="p_add">+	 * used to select the proper idle routine and to enable the check</span>
<span class="p_add">+	 * whether the machine is affected in arch_post_acpi_init(), which</span>
<span class="p_add">+	 * sets the X86_BUG_AMD_APIC_C1E bug depending on the MSR check.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpu_has_amd_erratum(c, amd_erratum_400))</span>
<span class="p_add">+		set_cpu_bug(c, X86_BUG_AMD_E400);</span>
<span class="p_add">+}</span>
 
 static void init_amd_k8(struct cpuinfo_x86 *c)
 {
<span class="p_chunk">@@ -774,9 +783,6 @@</span> <span class="p_context"> static void init_amd(struct cpuinfo_x86 *c)</span>
 	if (c-&gt;x86 &gt; 0x11)
 		set_cpu_cap(c, X86_FEATURE_ARAT);
 
<span class="p_del">-	if (cpu_has_amd_erratum(c, amd_erratum_400))</span>
<span class="p_del">-		set_cpu_bug(c, X86_BUG_AMD_APIC_C1E);</span>
<span class="p_del">-</span>
 	rdmsr_safe(MSR_AMD64_PATCH_LEVEL, &amp;c-&gt;microcode, &amp;dummy);
 
 	/* 3DNow or LM implies PREFETCHW */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 9bd910a7dd0a..e1f98ff9a3f0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1144,7 +1144,6 @@</span> <span class="p_context"> void enable_sep_cpu(void)</span>
 void __init identify_boot_cpu(void)
 {
 	identify_cpu(&amp;boot_cpu_data);
<span class="p_del">-	init_amd_e400_c1e_mask();</span>
 #ifdef CONFIG_X86_32
 	sysenter_setup();
 	enable_sep_cpu();
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce_amd.c b/arch/x86/kernel/cpu/mcheck/mce_amd.c</span>
<span class="p_header">index 9b5403462936..832f634fdf47 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce_amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce_amd.c</span>
<span class="p_chunk">@@ -24,7 +24,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/amd_nb.h&gt;
 #include &lt;asm/apic.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/mce.h&gt;
 #include &lt;asm/msr.h&gt;
 #include &lt;asm/trace/irq_vectors.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/therm_throt.c b/arch/x86/kernel/cpu/mcheck/therm_throt.c</span>
<span class="p_header">index 6b9dc4d18ccc..2f5c3418b18b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/therm_throt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/therm_throt.c</span>
<span class="p_chunk">@@ -26,7 +26,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/apic.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/mce.h&gt;
 #include &lt;asm/msr.h&gt;
 #include &lt;asm/trace/irq_vectors.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/threshold.c b/arch/x86/kernel/cpu/mcheck/threshold.c</span>
<span class="p_header">index fcf9ae9384f4..9beb092d68a5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/threshold.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/threshold.c</span>
<span class="p_chunk">@@ -6,7 +6,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/irq_vectors.h&gt;
 #include &lt;asm/apic.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/mce.h&gt;
 #include &lt;asm/trace/irq_vectors.h&gt;
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mshyperv.c b/arch/x86/kernel/cpu/mshyperv.c</span>
<span class="p_header">index 8f44c5a50ab8..6c044543545e 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mshyperv.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mshyperv.c</span>
<span class="p_chunk">@@ -25,7 +25,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/hyperv.h&gt;
 #include &lt;asm/mshyperv.h&gt;
 #include &lt;asm/desc.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/irq_regs.h&gt;
 #include &lt;asm/i8259.h&gt;
 #include &lt;asm/apic.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c</span>
<span class="p_header">index 9f669fdd2010..7c6e9ffe4424 100644</span>
<span class="p_header">--- a/arch/x86/kernel/irq.c</span>
<span class="p_header">+++ b/arch/x86/kernel/irq.c</span>
<span class="p_chunk">@@ -14,7 +14,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/io_apic.h&gt;
 #include &lt;asm/irq.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/mce.h&gt;
 #include &lt;asm/hw_irq.h&gt;
 #include &lt;asm/desc.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/irq_64.c b/arch/x86/kernel/irq_64.c</span>
<span class="p_header">index 9ebd0b0e73d9..6b0678a541e2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/irq_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/irq_64.c</span>
<span class="p_chunk">@@ -16,7 +16,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/smp.h&gt;
 #include &lt;asm/io_apic.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/apic.h&gt;
 
 int sysctl_panic_on_stackoverflow;
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index edbbfc854e39..05fe50e5f42c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -42,7 +42,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/traps.h&gt;
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/tlbflush.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/apicdef.h&gt;
 #include &lt;asm/hypervisor.h&gt;
<span class="p_chunk">@@ -267,13 +266,11 @@</span> <span class="p_context"> do_async_page_fault(struct pt_regs *regs, unsigned long error_code)</span>
 	case KVM_PV_REASON_PAGE_NOT_PRESENT:
 		/* page is swapped out by the host. */
 		prev_state = exception_enter();
<span class="p_del">-		exit_idle();</span>
 		kvm_async_pf_task_wait((u32)read_cr2());
 		exception_exit(prev_state);
 		break;
 	case KVM_PV_REASON_PAGE_READY:
 		rcu_irq_enter();
<span class="p_del">-		exit_idle();</span>
 		kvm_async_pf_task_wake((u32)read_cr2());
 		rcu_irq_exit();
 		break;
<span class="p_header">diff --git a/arch/x86/kernel/process.c b/arch/x86/kernel/process.c</span>
<span class="p_header">index 0888a879120f..43c36d8a6ae2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process.c</span>
<span class="p_chunk">@@ -23,7 +23,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/cpu.h&gt;
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/syscalls.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/uaccess.h&gt;
 #include &lt;asm/mwait.h&gt;
 #include &lt;asm/fpu/internal.h&gt;
<span class="p_chunk">@@ -65,23 +64,6 @@</span> <span class="p_context"> __visible DEFINE_PER_CPU_SHARED_ALIGNED(struct tss_struct, cpu_tss) = {</span>
 };
 EXPORT_PER_CPU_SYMBOL(cpu_tss);
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-static DEFINE_PER_CPU(unsigned char, is_idle);</span>
<span class="p_del">-static ATOMIC_NOTIFIER_HEAD(idle_notifier);</span>
<span class="p_del">-</span>
<span class="p_del">-void idle_notifier_register(struct notifier_block *n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	atomic_notifier_chain_register(&amp;idle_notifier, n);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(idle_notifier_register);</span>
<span class="p_del">-</span>
<span class="p_del">-void idle_notifier_unregister(struct notifier_block *n)</span>
<span class="p_del">-{</span>
<span class="p_del">-	atomic_notifier_chain_unregister(&amp;idle_notifier, n);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(idle_notifier_unregister);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 /*
  * this gets called so that we can store lazy state into memory and copy the
  * current task into the new thread.
<span class="p_chunk">@@ -251,39 +233,9 @@</span> <span class="p_context"> static inline void play_dead(void)</span>
 }
 #endif
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-void enter_idle(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	this_cpu_write(is_idle, 1);</span>
<span class="p_del">-	atomic_notifier_call_chain(&amp;idle_notifier, IDLE_START, NULL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __exit_idle(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (x86_test_and_clear_bit_percpu(0, is_idle) == 0)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	atomic_notifier_call_chain(&amp;idle_notifier, IDLE_END, NULL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Called from interrupts to signify idle end */</span>
<span class="p_del">-void exit_idle(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* idle loop has pid 0 */</span>
<span class="p_del">-	if (current-&gt;pid)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	__exit_idle();</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 void arch_cpu_idle_enter(void)
 {
 	local_touch_nmi();
<span class="p_del">-	enter_idle();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void arch_cpu_idle_exit(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__exit_idle();</span>
 }
 
 void arch_cpu_idle_dead(void)
<span class="p_chunk">@@ -336,59 +288,33 @@</span> <span class="p_context"> void stop_this_cpu(void *dummy)</span>
 		halt();
 }
 
<span class="p_del">-bool amd_e400_c1e_detected;</span>
<span class="p_del">-EXPORT_SYMBOL(amd_e400_c1e_detected);</span>
<span class="p_del">-</span>
<span class="p_del">-static cpumask_var_t amd_e400_c1e_mask;</span>
<span class="p_del">-</span>
<span class="p_del">-void amd_e400_remove_cpu(int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (amd_e400_c1e_mask != NULL)</span>
<span class="p_del">-		cpumask_clear_cpu(cpu, amd_e400_c1e_mask);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
<span class="p_del">- * AMD Erratum 400 aware idle routine. We check for C1E active in the interrupt</span>
<span class="p_del">- * pending message MSR. If we detect C1E, then we handle it the same</span>
<span class="p_del">- * way as C3 power states (local apic timer and TSC stop)</span>
<span class="p_add">+ * AMD Erratum 400 aware idle routine. We handle it the same way as C3 power</span>
<span class="p_add">+ * states (local apic timer and TSC stop).</span>
  */
 static void amd_e400_idle(void)
 {
<span class="p_del">-	if (!amd_e400_c1e_detected) {</span>
<span class="p_del">-		u32 lo, hi;</span>
<span class="p_del">-</span>
<span class="p_del">-		rdmsr(MSR_K8_INT_PENDING_MSG, lo, hi);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (lo &amp; K8_INTP_C1E_ACTIVE_MASK) {</span>
<span class="p_del">-			amd_e400_c1e_detected = true;</span>
<span class="p_del">-			if (!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))</span>
<span class="p_del">-				mark_tsc_unstable(&quot;TSC halt in AMD C1E&quot;);</span>
<span class="p_del">-			pr_info(&quot;System has AMD C1E enabled\n&quot;);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We cannot use static_cpu_has_bug() here because X86_BUG_AMD_APIC_C1E</span>
<span class="p_add">+	 * gets set after static_cpu_has() places have been converted via</span>
<span class="p_add">+	 * alternatives.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!boot_cpu_has_bug(X86_BUG_AMD_APIC_C1E)) {</span>
<span class="p_add">+		default_idle();</span>
<span class="p_add">+		return;</span>
 	}
 
<span class="p_del">-	if (amd_e400_c1e_detected) {</span>
<span class="p_del">-		int cpu = smp_processor_id();</span>
<span class="p_add">+	tick_broadcast_enter();</span>
 
<span class="p_del">-		if (!cpumask_test_cpu(cpu, amd_e400_c1e_mask)) {</span>
<span class="p_del">-			cpumask_set_cpu(cpu, amd_e400_c1e_mask);</span>
<span class="p_del">-			/* Force broadcast so ACPI can not interfere. */</span>
<span class="p_del">-			tick_broadcast_force();</span>
<span class="p_del">-			pr_info(&quot;Switch to broadcast mode on CPU%d\n&quot;, cpu);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		tick_broadcast_enter();</span>
<span class="p_del">-</span>
<span class="p_del">-		default_idle();</span>
<span class="p_add">+	default_idle();</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The switch back from broadcast mode needs to be</span>
<span class="p_del">-		 * called with interrupts disabled.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		local_irq_disable();</span>
<span class="p_del">-		tick_broadcast_exit();</span>
<span class="p_del">-		local_irq_enable();</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		default_idle();</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The switch back from broadcast mode needs to be called with</span>
<span class="p_add">+	 * interrupts disabled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	local_irq_disable();</span>
<span class="p_add">+	tick_broadcast_exit();</span>
<span class="p_add">+	local_irq_enable();</span>
 }
 
 /*
<span class="p_chunk">@@ -448,8 +374,7 @@</span> <span class="p_context"> void select_idle_routine(const struct cpuinfo_x86 *c)</span>
 	if (x86_idle || boot_option_idle_override == IDLE_POLL)
 		return;
 
<span class="p_del">-	if (cpu_has_bug(c, X86_BUG_AMD_APIC_C1E)) {</span>
<span class="p_del">-		/* E400: APIC timer interrupt does not wake up CPU from C1e */</span>
<span class="p_add">+	if (boot_cpu_has_bug(X86_BUG_AMD_E400)) {</span>
 		pr_info(&quot;using AMD E400 aware idle routine\n&quot;);
 		x86_idle = amd_e400_idle;
 	} else if (prefer_mwait_c1_over_halt(c)) {
<span class="p_chunk">@@ -459,11 +384,37 @@</span> <span class="p_context"> void select_idle_routine(const struct cpuinfo_x86 *c)</span>
 		x86_idle = default_idle;
 }
 
<span class="p_del">-void __init init_amd_e400_c1e_mask(void)</span>
<span class="p_add">+void amd_e400_c1e_apic_setup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (boot_cpu_has_bug(X86_BUG_AMD_APIC_C1E)) {</span>
<span class="p_add">+		pr_info(&quot;Switch to broadcast mode on CPU%d\n&quot;, smp_processor_id());</span>
<span class="p_add">+		local_irq_disable();</span>
<span class="p_add">+		tick_broadcast_force();</span>
<span class="p_add">+		local_irq_enable();</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init arch_post_acpi_subsys_init(void)</span>
 {
<span class="p_del">-	/* If we&#39;re using amd_e400_idle, we need to allocate amd_e400_c1e_mask. */</span>
<span class="p_del">-	if (x86_idle == amd_e400_idle)</span>
<span class="p_del">-		zalloc_cpumask_var(&amp;amd_e400_c1e_mask, GFP_KERNEL);</span>
<span class="p_add">+	u32 lo, hi;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!boot_cpu_has_bug(X86_BUG_AMD_E400))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * AMD E400 detection needs to happen after ACPI has been enabled. If</span>
<span class="p_add">+	 * the machine is affected K8_INTP_C1E_ACTIVE_MASK bits are set in</span>
<span class="p_add">+	 * MSR_K8_INT_PENDING_MSG.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rdmsr(MSR_K8_INT_PENDING_MSG, lo, hi);</span>
<span class="p_add">+	if (!(lo &amp; K8_INTP_C1E_ACTIVE_MASK))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	boot_cpu_set_bug(X86_BUG_AMD_APIC_C1E);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!boot_cpu_has(X86_FEATURE_NONSTOP_TSC))</span>
<span class="p_add">+		mark_tsc_unstable(&quot;TSC halt in AMD C1E&quot;);</span>
<span class="p_add">+	pr_info(&quot;System has AMD C1E enabled\n&quot;);</span>
 }
 
 static int __init idle_setup(char *str)
<span class="p_header">diff --git a/arch/x86/kernel/process_32.c b/arch/x86/kernel/process_32.c</span>
<span class="p_header">index bd7be8efdc4c..3e4ff92597ff 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_32.c</span>
<span class="p_chunk">@@ -49,7 +49,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/cpu.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/syscalls.h&gt;
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/switch_to.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index b3760b3c1ca0..bb1517106ec1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -44,7 +44,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/proto.h&gt;
 #include &lt;asm/ia32.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/syscalls.h&gt;
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/switch_to.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 42f5eb7b4f6c..352ddd560d19 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -58,7 +58,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/nmi.h&gt;
 #include &lt;asm/irq.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/realmode.h&gt;
 #include &lt;asm/cpu.h&gt;
 #include &lt;asm/numa.h&gt;
<span class="p_chunk">@@ -1575,7 +1574,6 @@</span> <span class="p_context"> void play_dead_common(void)</span>
 {
 	idle_task_exit();
 	reset_lazy_tlbstate();
<span class="p_del">-	amd_e400_remove_cpu(raw_smp_processor_id());</span>
 
 	/* Ack it */
 	(void)cpu_report_death();
<span class="p_header">diff --git a/arch/x86/platform/uv/tlb_uv.c b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">index 9e42842e924a..766d4d3529a1 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_chunk">@@ -19,7 +19,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/uv/uv_hub.h&gt;
 #include &lt;asm/uv/uv_bau.h&gt;
 #include &lt;asm/apic.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/tsc.h&gt;
 #include &lt;asm/irq_vectors.h&gt;
 #include &lt;asm/timer.h&gt;
<span class="p_header">diff --git a/drivers/acpi/processor_idle.c b/drivers/acpi/processor_idle.c</span>
<span class="p_header">index 2237d3f24f0e..5c8aa9cf62d7 100644</span>
<span class="p_header">--- a/drivers/acpi/processor_idle.c</span>
<span class="p_header">+++ b/drivers/acpi/processor_idle.c</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> static void lapic_timer_check_state(int state, struct acpi_processor *pr,</span>
 	if (cpu_has(&amp;cpu_data(pr-&gt;id), X86_FEATURE_ARAT))
 		return;
 
<span class="p_del">-	if (amd_e400_c1e_detected)</span>
<span class="p_add">+	if (boot_cpu_has_bug(X86_BUG_AMD_APIC_C1E))</span>
 		type = ACPI_STATE_C1;
 
 	/*
<span class="p_header">diff --git a/drivers/dma/ioat/registers.h b/drivers/dma/ioat/registers.h</span>
<span class="p_header">index 48fa4cf9f64a..2f3bbc88ff2a 100644</span>
<span class="p_header">--- a/drivers/dma/ioat/registers.h</span>
<span class="p_header">+++ b/drivers/dma/ioat/registers.h</span>
<span class="p_chunk">@@ -106,8 +106,6 @@</span> <span class="p_context"></span>
 #define IOAT_DMA_COMP_V1			0x0001	/* Compatibility with DMA version 1 */
 #define IOAT_DMA_COMP_V2			0x0002	/* Compatibility with DMA version 2 */
 
<span class="p_del">-/* IOAT1 define left for i7300_idle driver to not fail compiling */</span>
<span class="p_del">-#define IOAT1_CHANSTS_OFFSET		0x04</span>
 #define IOAT_CHANSTS_OFFSET		0x08	/* 64-bit Channel Status Register */
 #define IOAT_CHANSTS_COMPLETED_DESCRIPTOR_ADDR	(~0x3fULL)
 #define IOAT_CHANSTS_SOFT_ERR			0x10ULL
<span class="p_header">diff --git a/drivers/idle/Kconfig b/drivers/idle/Kconfig</span>
<span class="p_header">index 4732dfc15447..55bcf803841e 100644</span>
<span class="p_header">--- a/drivers/idle/Kconfig</span>
<span class="p_header">+++ b/drivers/idle/Kconfig</span>
<span class="p_chunk">@@ -8,20 +8,3 @@</span> <span class="p_context"> config INTEL_IDLE</span>
 	  native Intel hardware idle features.  The acpi_idle driver
 	  can be configured at the same time, in order to handle
 	  processors intel_idle does not support.
<span class="p_del">-</span>
<span class="p_del">-menu &quot;Memory power savings&quot;</span>
<span class="p_del">-depends on X86_64</span>
<span class="p_del">-</span>
<span class="p_del">-config I7300_IDLE_IOAT_CHANNEL</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
<span class="p_del">-config I7300_IDLE</span>
<span class="p_del">-	tristate &quot;Intel chipset idle memory power saving driver&quot;</span>
<span class="p_del">-	select I7300_IDLE_IOAT_CHANNEL</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Enable memory power savings when idle with certain Intel server</span>
<span class="p_del">-	  chipsets. The chipset must have I/O AT support, such as the</span>
<span class="p_del">-	  Intel 7300. The power savings depends on the type and quantity of</span>
<span class="p_del">-	  DRAM devices.</span>
<span class="p_del">-</span>
<span class="p_del">-endmenu</span>
<span class="p_header">diff --git a/drivers/idle/Makefile b/drivers/idle/Makefile</span>
<span class="p_header">index 23d295cf10f2..0007111d73e9 100644</span>
<span class="p_header">--- a/drivers/idle/Makefile</span>
<span class="p_header">+++ b/drivers/idle/Makefile</span>
<span class="p_chunk">@@ -1,3 +1,2 @@</span> <span class="p_context"></span>
<span class="p_del">-obj-$(CONFIG_I7300_IDLE)			+= i7300_idle.o</span>
 obj-$(CONFIG_INTEL_IDLE)			+= intel_idle.o
 
<span class="p_header">diff --git a/drivers/idle/i7300_idle.c b/drivers/idle/i7300_idle.c</span>
deleted file mode 100644
<span class="p_header">index ffeebc7e9f1c..000000000000</span>
<span class="p_header">--- a/drivers/idle/i7300_idle.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,612 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * (C) Copyright 2008 Intel Corporation</span>
<span class="p_del">- * Authors:</span>
<span class="p_del">- * Andy Henroid &lt;andrew.d.henroid@intel.com&gt;</span>
<span class="p_del">- * Venkatesh Pallipadi &lt;venkatesh.pallipadi@intel.com&gt;</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Save DIMM power on Intel 7300-based platforms when all CPUs/cores</span>
<span class="p_del">- * are idle, using the DIMM thermal throttling capability.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This driver depends on the Intel integrated DMA controller (I/O AT).</span>
<span class="p_del">- * If the driver for I/O AT (drivers/dma/ioatdma*) is also enabled,</span>
<span class="p_del">- * this driver should work cooperatively.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/* #define DEBUG */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/pci.h&gt;</span>
<span class="p_del">-#include &lt;linux/gfp.h&gt;</span>
<span class="p_del">-#include &lt;linux/sched.h&gt;</span>
<span class="p_del">-#include &lt;linux/notifier.h&gt;</span>
<span class="p_del">-#include &lt;linux/cpumask.h&gt;</span>
<span class="p_del">-#include &lt;linux/ktime.h&gt;</span>
<span class="p_del">-#include &lt;linux/delay.h&gt;</span>
<span class="p_del">-#include &lt;linux/debugfs.h&gt;</span>
<span class="p_del">-#include &lt;linux/stop_machine.h&gt;</span>
<span class="p_del">-#include &lt;linux/i7300_idle.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &quot;../dma/ioat/hw.h&quot;</span>
<span class="p_del">-#include &quot;../dma/ioat/registers.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-#define I7300_IDLE_DRIVER_VERSION	&quot;1.55&quot;</span>
<span class="p_del">-#define I7300_PRINT			&quot;i7300_idle:&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-#define MAX_STOP_RETRIES	10</span>
<span class="p_del">-</span>
<span class="p_del">-static int debug;</span>
<span class="p_del">-module_param_named(debug, debug, uint, 0644);</span>
<span class="p_del">-MODULE_PARM_DESC(debug, &quot;Enable debug printks in this driver&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-static int forceload;</span>
<span class="p_del">-module_param_named(forceload, forceload, uint, 0644);</span>
<span class="p_del">-MODULE_PARM_DESC(debug, &quot;Enable driver testing on unvalidated i5000&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-#define dprintk(fmt, arg...) \</span>
<span class="p_del">-	do { if (debug) printk(KERN_INFO I7300_PRINT fmt, ##arg); } while (0)</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Value to set THRTLOW to when initiating throttling</span>
<span class="p_del">- *  0 = No throttling</span>
<span class="p_del">- *  1 = Throttle when &gt; 4 activations per eval window (Maximum throttling)</span>
<span class="p_del">- *  2 = Throttle when &gt; 8 activations</span>
<span class="p_del">- *  168 = Throttle when &gt; 672 activations (Minimum throttling)</span>
<span class="p_del">- */</span>
<span class="p_del">-#define MAX_THROTTLE_LOW_LIMIT		168</span>
<span class="p_del">-static uint throttle_low_limit = 1;</span>
<span class="p_del">-module_param_named(throttle_low_limit, throttle_low_limit, uint, 0644);</span>
<span class="p_del">-MODULE_PARM_DESC(throttle_low_limit,</span>
<span class="p_del">-		&quot;Value for THRTLOWLM activation field &quot;</span>
<span class="p_del">-		&quot;(0 = disable throttle, 1 = Max throttle, 168 = Min throttle)&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * simple invocation and duration statistics</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long total_starts;</span>
<span class="p_del">-static unsigned long total_us;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef DEBUG</span>
<span class="p_del">-static unsigned long past_skip;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static struct pci_dev *fbd_dev;</span>
<span class="p_del">-</span>
<span class="p_del">-static raw_spinlock_t i7300_idle_lock;</span>
<span class="p_del">-static int i7300_idle_active;</span>
<span class="p_del">-</span>
<span class="p_del">-static u8 i7300_idle_thrtctl_saved;</span>
<span class="p_del">-static u8 i7300_idle_thrtlow_saved;</span>
<span class="p_del">-static u32 i7300_idle_mc_saved;</span>
<span class="p_del">-</span>
<span class="p_del">-static cpumask_var_t idle_cpumask;</span>
<span class="p_del">-static ktime_t start_ktime;</span>
<span class="p_del">-static unsigned long avg_idle_us;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct dentry *debugfs_dir;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Begin: I/O AT Helper routines */</span>
<span class="p_del">-</span>
<span class="p_del">-#define IOAT_CHANBASE(ioat_ctl, chan) (ioat_ctl + 0x80 + 0x80 * chan)</span>
<span class="p_del">-/* Snoop control (disable snoops when coherency is not important) */</span>
<span class="p_del">-#define IOAT_DESC_SADDR_SNP_CTL (1UL &lt;&lt; 1)</span>
<span class="p_del">-#define IOAT_DESC_DADDR_SNP_CTL (1UL &lt;&lt; 2)</span>
<span class="p_del">-</span>
<span class="p_del">-static struct pci_dev *ioat_dev;</span>
<span class="p_del">-static struct ioat_dma_descriptor *ioat_desc; /* I/O AT desc &amp; data (1 page) */</span>
<span class="p_del">-static unsigned long ioat_desc_phys;</span>
<span class="p_del">-static u8 *ioat_iomap; /* I/O AT memory-mapped control regs (aka CB_BAR) */</span>
<span class="p_del">-static u8 *ioat_chanbase;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Start I/O AT memory copy */</span>
<span class="p_del">-static int i7300_idle_ioat_start(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 err;</span>
<span class="p_del">-	/* Clear error (due to circular descriptor pointer) */</span>
<span class="p_del">-	err = readl(ioat_chanbase + IOAT_CHANERR_OFFSET);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		writel(err, ioat_chanbase + IOAT_CHANERR_OFFSET);</span>
<span class="p_del">-</span>
<span class="p_del">-	writeb(IOAT_CHANCMD_START, ioat_chanbase + IOAT1_CHANCMD_OFFSET);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Stop I/O AT memory copy */</span>
<span class="p_del">-static void i7300_idle_ioat_stop(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-	u64 sts;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; MAX_STOP_RETRIES; i++) {</span>
<span class="p_del">-		writeb(IOAT_CHANCMD_RESET,</span>
<span class="p_del">-			ioat_chanbase + IOAT1_CHANCMD_OFFSET);</span>
<span class="p_del">-</span>
<span class="p_del">-		udelay(10);</span>
<span class="p_del">-</span>
<span class="p_del">-		sts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &amp;</span>
<span class="p_del">-			IOAT_CHANSTS_STATUS;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (sts != IOAT_CHANSTS_ACTIVE)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i == MAX_STOP_RETRIES) {</span>
<span class="p_del">-		dprintk(&quot;failed to stop I/O AT after %d retries\n&quot;,</span>
<span class="p_del">-			MAX_STOP_RETRIES);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Test I/O AT by copying 1024 byte from 2k to 1k */</span>
<span class="p_del">-static int __init i7300_idle_ioat_selftest(u8 *ctl,</span>
<span class="p_del">-		struct ioat_dma_descriptor *desc, unsigned long desc_phys)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u64 chan_sts;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(desc, 0, 2048);</span>
<span class="p_del">-	memset((u8 *) desc + 2048, 0xab, 1024);</span>
<span class="p_del">-</span>
<span class="p_del">-	desc[0].size = 1024;</span>
<span class="p_del">-	desc[0].ctl = 0;</span>
<span class="p_del">-	desc[0].src_addr = desc_phys + 2048;</span>
<span class="p_del">-	desc[0].dst_addr = desc_phys + 1024;</span>
<span class="p_del">-	desc[0].next = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	writeb(IOAT_CHANCMD_RESET, ioat_chanbase + IOAT1_CHANCMD_OFFSET);</span>
<span class="p_del">-	writeb(IOAT_CHANCMD_START, ioat_chanbase + IOAT1_CHANCMD_OFFSET);</span>
<span class="p_del">-</span>
<span class="p_del">-	udelay(1000);</span>
<span class="p_del">-</span>
<span class="p_del">-	chan_sts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &amp;</span>
<span class="p_del">-			IOAT_CHANSTS_STATUS;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (chan_sts != IOAT_CHANSTS_DONE) {</span>
<span class="p_del">-		/* Not complete, reset the channel */</span>
<span class="p_del">-		writeb(IOAT_CHANCMD_RESET,</span>
<span class="p_del">-		       ioat_chanbase + IOAT1_CHANCMD_OFFSET);</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (*(u32 *) ((u8 *) desc + 3068) != 0xabababab ||</span>
<span class="p_del">-	    *(u32 *) ((u8 *) desc + 2044) != 0xabababab) {</span>
<span class="p_del">-		dprintk(&quot;Data values src 0x%x, dest 0x%x, memset 0x%x\n&quot;,</span>
<span class="p_del">-			*(u32 *) ((u8 *) desc + 2048),</span>
<span class="p_del">-			*(u32 *) ((u8 *) desc + 1024),</span>
<span class="p_del">-			*(u32 *) ((u8 *) desc + 3072));</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct device dummy_dma_dev = {</span>
<span class="p_del">-	.init_name = &quot;fallback device&quot;,</span>
<span class="p_del">-	.coherent_dma_mask = DMA_BIT_MASK(64),</span>
<span class="p_del">-	.dma_mask = &amp;dummy_dma_dev.coherent_dma_mask,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* Setup and initialize I/O AT */</span>
<span class="p_del">-/* This driver needs I/O AT as the throttling takes effect only when there is</span>
<span class="p_del">- * some memory activity. We use I/O AT to set up a dummy copy, while all CPUs</span>
<span class="p_del">- * go idle and memory is throttled.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int __init i7300_idle_ioat_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 ver, chan_count, ioat_chan;</span>
<span class="p_del">-	u16 chan_ctl;</span>
<span class="p_del">-</span>
<span class="p_del">-	ioat_iomap = (u8 *) ioremap_nocache(pci_resource_start(ioat_dev, 0),</span>
<span class="p_del">-					    pci_resource_len(ioat_dev, 0));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ioat_iomap) {</span>
<span class="p_del">-		printk(KERN_ERR I7300_PRINT &quot;failed to map I/O AT registers\n&quot;);</span>
<span class="p_del">-		goto err_ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ver = readb(ioat_iomap + IOAT_VER_OFFSET);</span>
<span class="p_del">-	if (ver != IOAT_VER_1_2) {</span>
<span class="p_del">-		printk(KERN_ERR I7300_PRINT &quot;unknown I/O AT version (%u.%u)\n&quot;,</span>
<span class="p_del">-			ver &gt;&gt; 4, ver &amp; 0xf);</span>
<span class="p_del">-		goto err_unmap;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	chan_count = readb(ioat_iomap + IOAT_CHANCNT_OFFSET);</span>
<span class="p_del">-	if (!chan_count) {</span>
<span class="p_del">-		printk(KERN_ERR I7300_PRINT &quot;unexpected # of I/O AT channels &quot;</span>
<span class="p_del">-			&quot;(%u)\n&quot;,</span>
<span class="p_del">-			chan_count);</span>
<span class="p_del">-		goto err_unmap;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ioat_chan = chan_count - 1;</span>
<span class="p_del">-	ioat_chanbase = IOAT_CHANBASE(ioat_iomap, ioat_chan);</span>
<span class="p_del">-</span>
<span class="p_del">-	chan_ctl = readw(ioat_chanbase + IOAT_CHANCTRL_OFFSET);</span>
<span class="p_del">-	if (chan_ctl &amp; IOAT_CHANCTRL_CHANNEL_IN_USE) {</span>
<span class="p_del">-		printk(KERN_ERR I7300_PRINT &quot;channel %d in use\n&quot;, ioat_chan);</span>
<span class="p_del">-		goto err_unmap;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	writew(IOAT_CHANCTRL_CHANNEL_IN_USE,</span>
<span class="p_del">-		ioat_chanbase + IOAT_CHANCTRL_OFFSET);</span>
<span class="p_del">-</span>
<span class="p_del">-	ioat_desc = (struct ioat_dma_descriptor *)dma_alloc_coherent(</span>
<span class="p_del">-			&amp;dummy_dma_dev, 4096,</span>
<span class="p_del">-			(dma_addr_t *)&amp;ioat_desc_phys, GFP_KERNEL);</span>
<span class="p_del">-	if (!ioat_desc) {</span>
<span class="p_del">-		printk(KERN_ERR I7300_PRINT &quot;failed to allocate I/O AT desc\n&quot;);</span>
<span class="p_del">-		goto err_mark_unused;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	writel(ioat_desc_phys &amp; 0xffffffffUL,</span>
<span class="p_del">-	       ioat_chanbase + IOAT1_CHAINADDR_OFFSET_LOW);</span>
<span class="p_del">-	writel(ioat_desc_phys &gt;&gt; 32,</span>
<span class="p_del">-	       ioat_chanbase + IOAT1_CHAINADDR_OFFSET_HIGH);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i7300_idle_ioat_selftest(ioat_iomap, ioat_desc, ioat_desc_phys)) {</span>
<span class="p_del">-		printk(KERN_ERR I7300_PRINT &quot;I/O AT self-test failed\n&quot;);</span>
<span class="p_del">-		goto err_free;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Setup circular I/O AT descriptor chain */</span>
<span class="p_del">-	ioat_desc[0].ctl = IOAT_DESC_SADDR_SNP_CTL | IOAT_DESC_DADDR_SNP_CTL;</span>
<span class="p_del">-	ioat_desc[0].src_addr = ioat_desc_phys + 2048;</span>
<span class="p_del">-	ioat_desc[0].dst_addr = ioat_desc_phys + 3072;</span>
<span class="p_del">-	ioat_desc[0].size = 128;</span>
<span class="p_del">-	ioat_desc[0].next = ioat_desc_phys + sizeof(struct ioat_dma_descriptor);</span>
<span class="p_del">-</span>
<span class="p_del">-	ioat_desc[1].ctl = ioat_desc[0].ctl;</span>
<span class="p_del">-	ioat_desc[1].src_addr = ioat_desc[0].src_addr;</span>
<span class="p_del">-	ioat_desc[1].dst_addr = ioat_desc[0].dst_addr;</span>
<span class="p_del">-	ioat_desc[1].size = ioat_desc[0].size;</span>
<span class="p_del">-	ioat_desc[1].next = ioat_desc_phys;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-err_free:</span>
<span class="p_del">-	dma_free_coherent(&amp;dummy_dma_dev, 4096, (void *)ioat_desc, 0);</span>
<span class="p_del">-err_mark_unused:</span>
<span class="p_del">-	writew(0, ioat_chanbase + IOAT_CHANCTRL_OFFSET);</span>
<span class="p_del">-err_unmap:</span>
<span class="p_del">-	iounmap(ioat_iomap);</span>
<span class="p_del">-err_ret:</span>
<span class="p_del">-	return -ENODEV;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Cleanup I/O AT */</span>
<span class="p_del">-static void __exit i7300_idle_ioat_exit(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-	u64 chan_sts;</span>
<span class="p_del">-</span>
<span class="p_del">-	i7300_idle_ioat_stop();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Wait for a while for the channel to halt before releasing */</span>
<span class="p_del">-	for (i = 0; i &lt; MAX_STOP_RETRIES; i++) {</span>
<span class="p_del">-		writeb(IOAT_CHANCMD_RESET,</span>
<span class="p_del">-		       ioat_chanbase + IOAT1_CHANCMD_OFFSET);</span>
<span class="p_del">-</span>
<span class="p_del">-		chan_sts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &amp;</span>
<span class="p_del">-			IOAT_CHANSTS_STATUS;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (chan_sts != IOAT_CHANSTS_ACTIVE) {</span>
<span class="p_del">-			writew(0, ioat_chanbase + IOAT_CHANCTRL_OFFSET);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		udelay(1000);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	chan_sts = readq(ioat_chanbase + IOAT1_CHANSTS_OFFSET) &amp;</span>
<span class="p_del">-			IOAT_CHANSTS_STATUS;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We tried to reset multiple times. If IO A/T channel is still active</span>
<span class="p_del">-	 * flag an error and return without cleanup. Memory leak is better</span>
<span class="p_del">-	 * than random corruption in that extreme error situation.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (chan_sts == IOAT_CHANSTS_ACTIVE) {</span>
<span class="p_del">-		printk(KERN_ERR I7300_PRINT &quot;Unable to stop IO A/T channels.&quot;</span>
<span class="p_del">-			&quot; Not freeing resources\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dma_free_coherent(&amp;dummy_dma_dev, 4096, (void *)ioat_desc, 0);</span>
<span class="p_del">-	iounmap(ioat_iomap);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* End: I/O AT Helper routines */</span>
<span class="p_del">-</span>
<span class="p_del">-#define DIMM_THRTLOW 0x64</span>
<span class="p_del">-#define DIMM_THRTCTL 0x67</span>
<span class="p_del">-#define DIMM_THRTCTL_THRMHUNT (1UL &lt;&lt; 0)</span>
<span class="p_del">-#define DIMM_MC 0x40</span>
<span class="p_del">-#define DIMM_GTW_MODE (1UL &lt;&lt; 17)</span>
<span class="p_del">-#define DIMM_GBLACT 0x60</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Keep track of an exponential-decaying average of recent idle durations.</span>
<span class="p_del">- * The latest duration gets DURATION_WEIGHT_PCT percentage weight</span>
<span class="p_del">- * in this average, with the old average getting the remaining weight.</span>
<span class="p_del">- *</span>
<span class="p_del">- * High weights emphasize recent history, low weights include long history.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define DURATION_WEIGHT_PCT 55</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * When the decaying average of recent durations or the predicted duration</span>
<span class="p_del">- * of the next timer interrupt is shorter than duration_threshold, the</span>
<span class="p_del">- * driver will decline to throttle.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define DURATION_THRESHOLD_US 100</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-/* Store DIMM thermal throttle configuration */</span>
<span class="p_del">-static int i7300_idle_thrt_save(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 new_mc_val;</span>
<span class="p_del">-	u8 gblactlm;</span>
<span class="p_del">-</span>
<span class="p_del">-	pci_read_config_byte(fbd_dev, DIMM_THRTCTL, &amp;i7300_idle_thrtctl_saved);</span>
<span class="p_del">-	pci_read_config_byte(fbd_dev, DIMM_THRTLOW, &amp;i7300_idle_thrtlow_saved);</span>
<span class="p_del">-	pci_read_config_dword(fbd_dev, DIMM_MC, &amp;i7300_idle_mc_saved);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Make sure we have Global Throttling Window Mode set to have a</span>
<span class="p_del">-	 * &quot;short&quot; window. This (mostly) works around an issue where</span>
<span class="p_del">-	 * throttling persists until the end of the global throttling window</span>
<span class="p_del">-	 * size. On the tested system, this was resulting in a maximum of</span>
<span class="p_del">-	 * 64 ms to exit throttling (average 32 ms). The actual numbers</span>
<span class="p_del">-	 * depends on system frequencies. Setting the short window reduces</span>
<span class="p_del">-	 * this by a factor of 4096.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We will only do this only if the system is set for</span>
<span class="p_del">-	 * unlimited-activations while in open-loop throttling (i.e., when</span>
<span class="p_del">-	 * Global Activation Throttle Limit is zero).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pci_read_config_byte(fbd_dev, DIMM_GBLACT, &amp;gblactlm);</span>
<span class="p_del">-	dprintk(&quot;thrtctl_saved = 0x%02x, thrtlow_saved = 0x%02x\n&quot;,</span>
<span class="p_del">-		i7300_idle_thrtctl_saved,</span>
<span class="p_del">-		i7300_idle_thrtlow_saved);</span>
<span class="p_del">-	dprintk(&quot;mc_saved = 0x%08x, gblactlm = 0x%02x\n&quot;,</span>
<span class="p_del">-		i7300_idle_mc_saved,</span>
<span class="p_del">-		gblactlm);</span>
<span class="p_del">-	if (gblactlm == 0) {</span>
<span class="p_del">-		new_mc_val = i7300_idle_mc_saved | DIMM_GTW_MODE;</span>
<span class="p_del">-		pci_write_config_dword(fbd_dev, DIMM_MC, new_mc_val);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		dprintk(&quot;could not set GTW_MODE = 1 (OLTT enabled)\n&quot;);</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Restore DIMM thermal throttle configuration */</span>
<span class="p_del">-static void i7300_idle_thrt_restore(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pci_write_config_dword(fbd_dev, DIMM_MC, i7300_idle_mc_saved);</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTLOW, i7300_idle_thrtlow_saved);</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTCTL, i7300_idle_thrtctl_saved);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Enable DIMM thermal throttling */</span>
<span class="p_del">-static void i7300_idle_start(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 new_ctl;</span>
<span class="p_del">-	u8 limit;</span>
<span class="p_del">-</span>
<span class="p_del">-	new_ctl = i7300_idle_thrtctl_saved &amp; ~DIMM_THRTCTL_THRMHUNT;</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTCTL, new_ctl);</span>
<span class="p_del">-</span>
<span class="p_del">-	limit = throttle_low_limit;</span>
<span class="p_del">-	if (unlikely(limit &gt; MAX_THROTTLE_LOW_LIMIT))</span>
<span class="p_del">-		limit = MAX_THROTTLE_LOW_LIMIT;</span>
<span class="p_del">-</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTLOW, limit);</span>
<span class="p_del">-</span>
<span class="p_del">-	new_ctl = i7300_idle_thrtctl_saved | DIMM_THRTCTL_THRMHUNT;</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTCTL, new_ctl);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Disable DIMM thermal throttling */</span>
<span class="p_del">-static void i7300_idle_stop(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 new_ctl;</span>
<span class="p_del">-	u8 got_ctl;</span>
<span class="p_del">-</span>
<span class="p_del">-	new_ctl = i7300_idle_thrtctl_saved &amp; ~DIMM_THRTCTL_THRMHUNT;</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTCTL, new_ctl);</span>
<span class="p_del">-</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTLOW, i7300_idle_thrtlow_saved);</span>
<span class="p_del">-	pci_write_config_byte(fbd_dev, DIMM_THRTCTL, i7300_idle_thrtctl_saved);</span>
<span class="p_del">-	pci_read_config_byte(fbd_dev, DIMM_THRTCTL, &amp;got_ctl);</span>
<span class="p_del">-	WARN_ON_ONCE(got_ctl != i7300_idle_thrtctl_saved);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * i7300_avg_duration_check()</span>
<span class="p_del">- * return 0 if the decaying average of recent idle durations is</span>
<span class="p_del">- * more than DURATION_THRESHOLD_US</span>
<span class="p_del">- */</span>
<span class="p_del">-static int i7300_avg_duration_check(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (avg_idle_us &gt;= DURATION_THRESHOLD_US)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef DEBUG</span>
<span class="p_del">-	past_skip++;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Idle notifier to look at idle CPUs */</span>
<span class="p_del">-static int i7300_idle_notifier(struct notifier_block *nb, unsigned long val,</span>
<span class="p_del">-				void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	ktime_t now_ktime;</span>
<span class="p_del">-	static ktime_t idle_begin_time;</span>
<span class="p_del">-	static int time_init = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!throttle_low_limit)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(time_init)) {</span>
<span class="p_del">-		time_init = 0;</span>
<span class="p_del">-		idle_begin_time = ktime_get();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	raw_spin_lock_irqsave(&amp;i7300_idle_lock, flags);</span>
<span class="p_del">-	if (val == IDLE_START) {</span>
<span class="p_del">-</span>
<span class="p_del">-		cpumask_set_cpu(smp_processor_id(), idle_cpumask);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (cpumask_weight(idle_cpumask) != num_online_cpus())</span>
<span class="p_del">-			goto end;</span>
<span class="p_del">-</span>
<span class="p_del">-		now_ktime = ktime_get();</span>
<span class="p_del">-		idle_begin_time = now_ktime;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (i7300_avg_duration_check())</span>
<span class="p_del">-			goto end;</span>
<span class="p_del">-</span>
<span class="p_del">-		i7300_idle_active = 1;</span>
<span class="p_del">-		total_starts++;</span>
<span class="p_del">-		start_ktime = now_ktime;</span>
<span class="p_del">-</span>
<span class="p_del">-		i7300_idle_start();</span>
<span class="p_del">-		i7300_idle_ioat_start();</span>
<span class="p_del">-</span>
<span class="p_del">-	} else if (val == IDLE_END) {</span>
<span class="p_del">-		cpumask_clear_cpu(smp_processor_id(), idle_cpumask);</span>
<span class="p_del">-		if (cpumask_weight(idle_cpumask) == (num_online_cpus() - 1)) {</span>
<span class="p_del">-			/* First CPU coming out of idle */</span>
<span class="p_del">-			u64 idle_duration_us;</span>
<span class="p_del">-</span>
<span class="p_del">-			now_ktime = ktime_get();</span>
<span class="p_del">-</span>
<span class="p_del">-			idle_duration_us = ktime_to_us(ktime_sub</span>
<span class="p_del">-						(now_ktime, idle_begin_time));</span>
<span class="p_del">-</span>
<span class="p_del">-			avg_idle_us =</span>
<span class="p_del">-				((100 - DURATION_WEIGHT_PCT) * avg_idle_us +</span>
<span class="p_del">-				 DURATION_WEIGHT_PCT * idle_duration_us) / 100;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (i7300_idle_active) {</span>
<span class="p_del">-				ktime_t idle_ktime;</span>
<span class="p_del">-</span>
<span class="p_del">-				idle_ktime = ktime_sub(now_ktime, start_ktime);</span>
<span class="p_del">-				total_us += ktime_to_us(idle_ktime);</span>
<span class="p_del">-</span>
<span class="p_del">-				i7300_idle_ioat_stop();</span>
<span class="p_del">-				i7300_idle_stop();</span>
<span class="p_del">-				i7300_idle_active = 0;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-end:</span>
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;i7300_idle_lock, flags);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct notifier_block i7300_idle_nb = {</span>
<span class="p_del">-	.notifier_call = i7300_idle_notifier,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-MODULE_DEVICE_TABLE(pci, pci_tbl);</span>
<span class="p_del">-</span>
<span class="p_del">-static ssize_t stats_read_ul(struct file *fp, char __user *ubuf, size_t count,</span>
<span class="p_del">-				loff_t *off)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long *p = fp-&gt;private_data;</span>
<span class="p_del">-	char buf[32];</span>
<span class="p_del">-	int len;</span>
<span class="p_del">-</span>
<span class="p_del">-	len = snprintf(buf, 32, &quot;%lu\n&quot;, *p);</span>
<span class="p_del">-	return simple_read_from_buffer(ubuf, count, off, buf, len);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct file_operations idle_fops = {</span>
<span class="p_del">-	.open	= simple_open,</span>
<span class="p_del">-	.read	= stats_read_ul,</span>
<span class="p_del">-	.llseek = default_llseek,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct debugfs_file_info {</span>
<span class="p_del">-	void *ptr;</span>
<span class="p_del">-	char name[32];</span>
<span class="p_del">-	struct dentry *file;</span>
<span class="p_del">-} debugfs_file_list[] = {</span>
<span class="p_del">-				{&amp;total_starts, &quot;total_starts&quot;, NULL},</span>
<span class="p_del">-				{&amp;total_us, &quot;total_us&quot;, NULL},</span>
<span class="p_del">-#ifdef DEBUG</span>
<span class="p_del">-				{&amp;past_skip, &quot;past_skip&quot;, NULL},</span>
<span class="p_del">-#endif</span>
<span class="p_del">-				{NULL, &quot;&quot;, NULL}</span>
<span class="p_del">-			};</span>
<span class="p_del">-</span>
<span class="p_del">-static int __init i7300_idle_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	raw_spin_lock_init(&amp;i7300_idle_lock);</span>
<span class="p_del">-	total_us = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i7300_idle_platform_probe(&amp;fbd_dev, &amp;ioat_dev, forceload))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i7300_idle_thrt_save())</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (i7300_idle_ioat_init())</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!zalloc_cpumask_var(&amp;idle_cpumask, GFP_KERNEL))</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	debugfs_dir = debugfs_create_dir(&quot;i7300_idle&quot;, NULL);</span>
<span class="p_del">-	if (debugfs_dir) {</span>
<span class="p_del">-		int i = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		while (debugfs_file_list[i].ptr != NULL) {</span>
<span class="p_del">-			debugfs_file_list[i].file = debugfs_create_file(</span>
<span class="p_del">-					debugfs_file_list[i].name,</span>
<span class="p_del">-					S_IRUSR,</span>
<span class="p_del">-					debugfs_dir,</span>
<span class="p_del">-					debugfs_file_list[i].ptr,</span>
<span class="p_del">-					&amp;idle_fops);</span>
<span class="p_del">-			i++;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	idle_notifier_register(&amp;i7300_idle_nb);</span>
<span class="p_del">-</span>
<span class="p_del">-	printk(KERN_INFO &quot;i7300_idle: loaded v%s\n&quot;, I7300_IDLE_DRIVER_VERSION);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __exit i7300_idle_exit(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	idle_notifier_unregister(&amp;i7300_idle_nb);</span>
<span class="p_del">-	free_cpumask_var(idle_cpumask);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (debugfs_dir) {</span>
<span class="p_del">-		int i = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		while (debugfs_file_list[i].file != NULL) {</span>
<span class="p_del">-			debugfs_remove(debugfs_file_list[i].file);</span>
<span class="p_del">-			i++;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		debugfs_remove(debugfs_dir);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	i7300_idle_thrt_restore();</span>
<span class="p_del">-	i7300_idle_ioat_exit();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-module_init(i7300_idle_init);</span>
<span class="p_del">-module_exit(i7300_idle_exit);</span>
<span class="p_del">-</span>
<span class="p_del">-MODULE_AUTHOR(&quot;Andy Henroid &lt;andrew.d.henroid@intel.com&gt;&quot;);</span>
<span class="p_del">-MODULE_DESCRIPTION(&quot;Intel Chipset DIMM Idle Power Saving Driver v&quot;</span>
<span class="p_del">-			I7300_IDLE_DRIVER_VERSION);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_header">diff --git a/drivers/thermal/intel_powerclamp.c b/drivers/thermal/intel_powerclamp.c</span>
<span class="p_header">index 7a223074df3d..bfc5a142667b 100644</span>
<span class="p_header">--- a/drivers/thermal/intel_powerclamp.c</span>
<span class="p_header">+++ b/drivers/thermal/intel_powerclamp.c</span>
<span class="p_chunk">@@ -56,7 +56,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/msr.h&gt;
 #include &lt;asm/mwait.h&gt;
 #include &lt;asm/cpu_device_id.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/hardirq.h&gt;
 
 #define MAX_TARGET_RATIO (50U)
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index 9ecfcdcdd6d6..adc19ce3cc66 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -37,7 +37,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/desc.h&gt;
 #include &lt;asm/ptrace.h&gt;
 #include &lt;asm/irq.h&gt;
<span class="p_del">-#include &lt;asm/idle.h&gt;</span>
 #include &lt;asm/io_apic.h&gt;
 #include &lt;asm/i8259.h&gt;
 #include &lt;asm/xen/pci.h&gt;
<span class="p_chunk">@@ -1256,7 +1255,6 @@</span> <span class="p_context"> void xen_evtchn_do_upcall(struct pt_regs *regs)</span>
 
 	irq_enter();
 #ifdef CONFIG_X86
<span class="p_del">-	exit_idle();</span>
 	inc_irq_stat(irq_hv_callback_count);
 #endif
 
<span class="p_header">diff --git a/init/main.c b/init/main.c</span>
<span class="p_header">index 2858be732f6d..1d7038c1ee19 100644</span>
<span class="p_header">--- a/init/main.c</span>
<span class="p_header">+++ b/init/main.c</span>
<span class="p_chunk">@@ -448,6 +448,8 @@</span> <span class="p_context"> void __init parse_early_param(void)</span>
 	done = 1;
 }
 
<span class="p_add">+void __init __weak arch_post_acpi_subsys_init(void) { }</span>
<span class="p_add">+</span>
 void __init __weak smp_setup_processor_id(void)
 {
 }
<span class="p_chunk">@@ -649,6 +651,7 @@</span> <span class="p_context"> asmlinkage __visible void __init start_kernel(void)</span>
 	check_bugs();
 
 	acpi_subsystem_init();
<span class="p_add">+	arch_post_acpi_subsys_init();</span>
 	sfi_init_late();
 
 	if (efi_enabled(EFI_RUNTIME_SERVICES)) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



