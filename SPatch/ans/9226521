
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[45/66] tools: Copy the header files needed by perf tools - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [45/66] tools: Copy the header files needed by perf tools</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=91481">Arnaldo Carvalho de Melo</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 12, 2016, 10:40 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1468363241-14555-46-git-send-email-acme@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9226521/mbox/"
   >mbox</a>
|
   <a href="/patch/9226521/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9226521/">/patch/9226521/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	29B5860868 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 Jul 2016 22:50:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 132EB27DCD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 Jul 2016 22:50:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 06D4227F94; Tue, 12 Jul 2016 22:50:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7BFCA27FA3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 12 Jul 2016 22:50:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753452AbcGLWuk (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 12 Jul 2016 18:50:40 -0400
Received: from bombadil.infradead.org ([198.137.202.9]:45287 &quot;EHLO
	bombadil.infradead.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752701AbcGLWlY (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 12 Jul 2016 18:41:24 -0400
Received: from [179.235.155.208] (helo=jouet.infradead.org)
	by bombadil.infradead.org with esmtpsa (Exim 4.85_2 #1 (Red Hat
	Linux)) id 1bN6MM-0001Nm-BB; Tue, 12 Jul 2016 22:40:58 +0000
Received: by jouet.infradead.org (Postfix, from userid 1000)
	id 48A1C143C68; Tue, 12 Jul 2016 19:40:47 -0300 (BRT)
From: Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;
To: Ingo Molnar &lt;mingo@kernel.org&gt;
Cc: linux-kernel@vger.kernel.org, Arnaldo Carvalho de Melo &lt;acme@redhat.com&gt;,
	Adrian Hunter &lt;adrian.hunter@intel.com&gt;,
	Alexander Yarygin &lt;yarygin@linux.vnet.ibm.com&gt;,
	Christoffer Dall &lt;christoffer.dall@linaro.org&gt;,
	David Ahern &lt;dsahern@gmail.com&gt;, Eric Auger &lt;eric.auger@linaro.org&gt;,
	Hemant Kumar &lt;hemant@linux.vnet.ibm.com&gt;, Jiri Olsa &lt;jolsa@kernel.org&gt;,
	Marc Zyngier &lt;marc.zyngier@arm.com&gt;, Namhyung Kim &lt;namhyung@kernel.org&gt;,
	&quot;Naveen N . Rao&quot; &lt;naveen.n.rao@linux.vnet.ibm.com&gt;,
	Srikar Dronamraju &lt;srikar@linux.vnet.ibm.com&gt;,
	Wang Nan &lt;wangnan0@huawei.com&gt;, Yunlong Song &lt;yunlong.song@huawei.com&gt;
Subject: [PATCH 45/66] tools: Copy the header files needed by perf tools
Date: Tue, 12 Jul 2016 19:40:20 -0300
Message-Id: &lt;1468363241-14555-46-git-send-email-acme@kernel.org&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1468363241-14555-1-git-send-email-acme@kernel.org&gt;
References: &lt;1468363241-14555-1-git-send-email-acme@kernel.org&gt;
X-SRS-Rewrite: SMTP reverse-path rewritten from &lt;acme@infradead.org&gt; by
	bombadil.infradead.org. See http://www.infradead.org/rpr.html
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=91481">Arnaldo Carvalho de Melo</a> - July 12, 2016, 10:40 p.m.</div>
<pre class="content">
<span class="from">From: Arnaldo Carvalho de Melo &lt;acme@redhat.com&gt;</span>

Those kernel files were being directly accessed, which we&#39;re not
allowing anymore to avoid that changes in the kernel side break tooling.

Warn if these copies drift from the original files.

Cc: Adrian Hunter &lt;adrian.hunter@intel.com&gt;
Cc: Alexander Yarygin &lt;yarygin@linux.vnet.ibm.com&gt;
Cc: Christoffer Dall &lt;christoffer.dall@linaro.org&gt;
Cc: David Ahern &lt;dsahern@gmail.com&gt;
Cc: Eric Auger &lt;eric.auger@linaro.org&gt;
Cc: Hemant Kumar &lt;hemant@linux.vnet.ibm.com&gt;
Cc: Jiri Olsa &lt;jolsa@kernel.org&gt;
Cc: Marc Zyngier &lt;marc.zyngier@arm.com&gt;
Cc: Namhyung Kim &lt;namhyung@kernel.org&gt;
Cc: Naveen N. Rao &lt;naveen.n.rao@linux.vnet.ibm.com&gt;
Cc: Srikar Dronamraju &lt;srikar@linux.vnet.ibm.com&gt;
Cc: Wang Nan &lt;wangnan0@huawei.com&gt;
Cc: Yunlong Song &lt;yunlong.song@huawei.com&gt;
Link: http://lkml.kernel.org/n/tip-mnopguymhnwzjhw3mowllvsy@git.kernel.org
<span class="signed-off-by">Signed-off-by: Arnaldo Carvalho de Melo &lt;acme@redhat.com&gt;</span>
---
 tools/arch/arm/include/uapi/asm/kvm.h       | 224 ++++++++++
 tools/arch/arm64/include/uapi/asm/kvm.h     | 258 ++++++++++++
 tools/arch/mips/include/uapi/asm/kvm.h      | 208 ++++++++++
 tools/arch/powerpc/include/uapi/asm/kvm.h   | 612 ++++++++++++++++++++++++++++
 tools/arch/s390/include/uapi/asm/kvm.h      | 192 +++++++++
 tools/arch/s390/include/uapi/asm/kvm_perf.h |  25 ++
 tools/arch/s390/include/uapi/asm/sie.h      | 250 ++++++++++++
 tools/arch/x86/include/uapi/asm/kvm.h       | 360 ++++++++++++++++
 tools/arch/x86/include/uapi/asm/kvm_perf.h  |  16 +
 tools/arch/x86/include/uapi/asm/svm.h       | 178 ++++++++
 tools/arch/x86/include/uapi/asm/vmx.h       | 136 +++++++
 tools/perf/MANIFEST                         |  15 +-
 tools/perf/Makefile.perf                    |  30 ++
 13 files changed, 2495 insertions(+), 9 deletions(-)
 create mode 100644 tools/arch/arm/include/uapi/asm/kvm.h
 create mode 100644 tools/arch/arm64/include/uapi/asm/kvm.h
 create mode 100644 tools/arch/mips/include/uapi/asm/kvm.h
 create mode 100644 tools/arch/powerpc/include/uapi/asm/kvm.h
 create mode 100644 tools/arch/s390/include/uapi/asm/kvm.h
 create mode 100644 tools/arch/s390/include/uapi/asm/kvm_perf.h
 create mode 100644 tools/arch/s390/include/uapi/asm/sie.h
 create mode 100644 tools/arch/x86/include/uapi/asm/kvm.h
 create mode 100644 tools/arch/x86/include/uapi/asm/kvm_perf.h
 create mode 100644 tools/arch/x86/include/uapi/asm/svm.h
 create mode 100644 tools/arch/x86/include/uapi/asm/vmx.h
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/tools/arch/arm/include/uapi/asm/kvm.h b/tools/arch/arm/include/uapi/asm/kvm.h</span>
new file mode 100644
<span class="p_header">index 000000000000..a2b3eb313a25</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/arm/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -0,0 +1,224 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 - Virtual Open Systems and Columbia University</span>
<span class="p_add">+ * Author: Christoffer Dall &lt;c.dall@virtualopensystems.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License, version 2, as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ARM_KVM_H__</span>
<span class="p_add">+#define __ARM_KVM_H__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;linux/psci.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define __KVM_HAVE_GUEST_DEBUG</span>
<span class="p_add">+#define __KVM_HAVE_IRQ_LINE</span>
<span class="p_add">+#define __KVM_HAVE_READONLY_MEM</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_SIZE(id)						\</span>
<span class="p_add">+	(1U &lt;&lt; (((id) &amp; KVM_REG_SIZE_MASK) &gt;&gt; KVM_REG_SIZE_SHIFT))</span>
<span class="p_add">+</span>
<span class="p_add">+/* Valid for svc_regs, abt_regs, und_regs, irq_regs in struct kvm_regs */</span>
<span class="p_add">+#define KVM_ARM_SVC_sp		svc_regs[0]</span>
<span class="p_add">+#define KVM_ARM_SVC_lr		svc_regs[1]</span>
<span class="p_add">+#define KVM_ARM_SVC_spsr	svc_regs[2]</span>
<span class="p_add">+#define KVM_ARM_ABT_sp		abt_regs[0]</span>
<span class="p_add">+#define KVM_ARM_ABT_lr		abt_regs[1]</span>
<span class="p_add">+#define KVM_ARM_ABT_spsr	abt_regs[2]</span>
<span class="p_add">+#define KVM_ARM_UND_sp		und_regs[0]</span>
<span class="p_add">+#define KVM_ARM_UND_lr		und_regs[1]</span>
<span class="p_add">+#define KVM_ARM_UND_spsr	und_regs[2]</span>
<span class="p_add">+#define KVM_ARM_IRQ_sp		irq_regs[0]</span>
<span class="p_add">+#define KVM_ARM_IRQ_lr		irq_regs[1]</span>
<span class="p_add">+#define KVM_ARM_IRQ_spsr	irq_regs[2]</span>
<span class="p_add">+</span>
<span class="p_add">+/* Valid only for fiq_regs in struct kvm_regs */</span>
<span class="p_add">+#define KVM_ARM_FIQ_r8		fiq_regs[0]</span>
<span class="p_add">+#define KVM_ARM_FIQ_r9		fiq_regs[1]</span>
<span class="p_add">+#define KVM_ARM_FIQ_r10		fiq_regs[2]</span>
<span class="p_add">+#define KVM_ARM_FIQ_fp		fiq_regs[3]</span>
<span class="p_add">+#define KVM_ARM_FIQ_ip		fiq_regs[4]</span>
<span class="p_add">+#define KVM_ARM_FIQ_sp		fiq_regs[5]</span>
<span class="p_add">+#define KVM_ARM_FIQ_lr		fiq_regs[6]</span>
<span class="p_add">+#define KVM_ARM_FIQ_spsr	fiq_regs[7]</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_regs {</span>
<span class="p_add">+	struct pt_regs usr_regs;	/* R0_usr - R14_usr, PC, CPSR */</span>
<span class="p_add">+	unsigned long svc_regs[3];	/* SP_svc, LR_svc, SPSR_svc */</span>
<span class="p_add">+	unsigned long abt_regs[3];	/* SP_abt, LR_abt, SPSR_abt */</span>
<span class="p_add">+	unsigned long und_regs[3];	/* SP_und, LR_und, SPSR_und */</span>
<span class="p_add">+	unsigned long irq_regs[3];	/* SP_irq, LR_irq, SPSR_irq */</span>
<span class="p_add">+	unsigned long fiq_regs[8];	/* R8_fiq - R14_fiq, SPSR_fiq */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Supported Processor Types */</span>
<span class="p_add">+#define KVM_ARM_TARGET_CORTEX_A15	0</span>
<span class="p_add">+#define KVM_ARM_TARGET_CORTEX_A7	1</span>
<span class="p_add">+#define KVM_ARM_NUM_TARGETS		2</span>
<span class="p_add">+</span>
<span class="p_add">+/* KVM_ARM_SET_DEVICE_ADDR ioctl id encoding */</span>
<span class="p_add">+#define KVM_ARM_DEVICE_TYPE_SHIFT	0</span>
<span class="p_add">+#define KVM_ARM_DEVICE_TYPE_MASK	(0xffff &lt;&lt; KVM_ARM_DEVICE_TYPE_SHIFT)</span>
<span class="p_add">+#define KVM_ARM_DEVICE_ID_SHIFT		16</span>
<span class="p_add">+#define KVM_ARM_DEVICE_ID_MASK		(0xffff &lt;&lt; KVM_ARM_DEVICE_ID_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Supported device IDs */</span>
<span class="p_add">+#define KVM_ARM_DEVICE_VGIC_V2		0</span>
<span class="p_add">+</span>
<span class="p_add">+/* Supported VGIC address types  */</span>
<span class="p_add">+#define KVM_VGIC_V2_ADDR_TYPE_DIST	0</span>
<span class="p_add">+#define KVM_VGIC_V2_ADDR_TYPE_CPU	1</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_VGIC_V2_DIST_SIZE		0x1000</span>
<span class="p_add">+#define KVM_VGIC_V2_CPU_SIZE		0x2000</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_ARM_VCPU_POWER_OFF		0 /* CPU is started in OFF state */</span>
<span class="p_add">+#define KVM_ARM_VCPU_PSCI_0_2		1 /* CPU uses PSCI v0.2 */</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_vcpu_init {</span>
<span class="p_add">+	__u32 target;</span>
<span class="p_add">+	__u32 features[7];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sregs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_fpu {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_guest_debug_arch {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_debug_exit_arch {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sync_regs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_arch_memory_slot {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* If you need to interpret the index values, here is the key: */</span>
<span class="p_add">+#define KVM_REG_ARM_COPROC_MASK		0x000000000FFF0000</span>
<span class="p_add">+#define KVM_REG_ARM_COPROC_SHIFT	16</span>
<span class="p_add">+#define KVM_REG_ARM_32_OPC2_MASK	0x0000000000000007</span>
<span class="p_add">+#define KVM_REG_ARM_32_OPC2_SHIFT	0</span>
<span class="p_add">+#define KVM_REG_ARM_OPC1_MASK		0x0000000000000078</span>
<span class="p_add">+#define KVM_REG_ARM_OPC1_SHIFT		3</span>
<span class="p_add">+#define KVM_REG_ARM_CRM_MASK		0x0000000000000780</span>
<span class="p_add">+#define KVM_REG_ARM_CRM_SHIFT		7</span>
<span class="p_add">+#define KVM_REG_ARM_32_CRN_MASK		0x0000000000007800</span>
<span class="p_add">+#define KVM_REG_ARM_32_CRN_SHIFT	11</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_CP15_REG_SHIFT_MASK(x,n) \</span>
<span class="p_add">+	(((x) &lt;&lt; KVM_REG_ARM_ ## n ## _SHIFT) &amp; KVM_REG_ARM_ ## n ## _MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __ARM_CP15_REG(op1,crn,crm,op2) \</span>
<span class="p_add">+	(KVM_REG_ARM | (15 &lt;&lt; KVM_REG_ARM_COPROC_SHIFT) | \</span>
<span class="p_add">+	ARM_CP15_REG_SHIFT_MASK(op1, OPC1) | \</span>
<span class="p_add">+	ARM_CP15_REG_SHIFT_MASK(crn, 32_CRN) | \</span>
<span class="p_add">+	ARM_CP15_REG_SHIFT_MASK(crm, CRM) | \</span>
<span class="p_add">+	ARM_CP15_REG_SHIFT_MASK(op2, 32_OPC2))</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_CP15_REG32(...) (__ARM_CP15_REG(__VA_ARGS__) | KVM_REG_SIZE_U32)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __ARM_CP15_REG64(op1,crm) \</span>
<span class="p_add">+	(__ARM_CP15_REG(op1, 0, crm, 0) | KVM_REG_SIZE_U64)</span>
<span class="p_add">+#define ARM_CP15_REG64(...) __ARM_CP15_REG64(__VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_ARM_TIMER_CTL		ARM_CP15_REG32(0, 14, 3, 1)</span>
<span class="p_add">+#define KVM_REG_ARM_TIMER_CNT		ARM_CP15_REG64(1, 14)</span>
<span class="p_add">+#define KVM_REG_ARM_TIMER_CVAL		ARM_CP15_REG64(3, 14)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Normal registers are mapped as coprocessor 16. */</span>
<span class="p_add">+#define KVM_REG_ARM_CORE		(0x0010 &lt;&lt; KVM_REG_ARM_COPROC_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM_CORE_REG(name)	(offsetof(struct kvm_regs, name) / 4)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Some registers need more space to represent values. */</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX		(0x0011 &lt;&lt; KVM_REG_ARM_COPROC_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_ID_MASK	0x000000000000FF00</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_ID_SHIFT	8</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_ID_CCSIDR	(0x00 &lt;&lt; KVM_REG_ARM_DEMUX_ID_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_VAL_MASK	0x00000000000000FF</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_VAL_SHIFT	0</span>
<span class="p_add">+</span>
<span class="p_add">+/* VFP registers: we could overload CP10 like ARM does, but that&#39;s ugly. */</span>
<span class="p_add">+#define KVM_REG_ARM_VFP			(0x0012 &lt;&lt; KVM_REG_ARM_COPROC_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_MASK		0x000000000000FFFF</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_BASE_REG	0x0</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_FPSID		0x1000</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_FPSCR		0x1001</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_MVFR1		0x1006</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_MVFR0		0x1007</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_FPEXC		0x1008</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_FPINST		0x1009</span>
<span class="p_add">+#define KVM_REG_ARM_VFP_FPINST2		0x100A</span>
<span class="p_add">+</span>
<span class="p_add">+/* Device Control API: ARM VGIC */</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_ADDR	0</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_DIST_REGS	1</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_CPU_REGS	2</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_CPUID_SHIFT	32</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_CPUID_MASK	(0xffULL &lt;&lt; KVM_DEV_ARM_VGIC_CPUID_SHIFT)</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_OFFSET_SHIFT	0</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_OFFSET_MASK	(0xffffffffULL &lt;&lt; KVM_DEV_ARM_VGIC_OFFSET_SHIFT)</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_NR_IRQS	3</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_CTRL       4</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_CTRL_INIT    0</span>
<span class="p_add">+</span>
<span class="p_add">+/* KVM_IRQ_LINE irq field index values */</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_SHIFT		24</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_MASK		0xff</span>
<span class="p_add">+#define KVM_ARM_IRQ_VCPU_SHIFT		16</span>
<span class="p_add">+#define KVM_ARM_IRQ_VCPU_MASK		0xff</span>
<span class="p_add">+#define KVM_ARM_IRQ_NUM_SHIFT		0</span>
<span class="p_add">+#define KVM_ARM_IRQ_NUM_MASK		0xffff</span>
<span class="p_add">+</span>
<span class="p_add">+/* irq_type field */</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_CPU		0</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_SPI		1</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_PPI		2</span>
<span class="p_add">+</span>
<span class="p_add">+/* out-of-kernel GIC cpu interrupt injection irq_number field */</span>
<span class="p_add">+#define KVM_ARM_IRQ_CPU_IRQ		0</span>
<span class="p_add">+#define KVM_ARM_IRQ_CPU_FIQ		1</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This used to hold the highest supported SPI, but it is now obsolete</span>
<span class="p_add">+ * and only here to provide source code level compatibility with older</span>
<span class="p_add">+ * userland. The highest SPI number can be set via KVM_DEV_ARM_VGIC_GRP_NR_IRQS.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef __KERNEL__</span>
<span class="p_add">+#define KVM_ARM_IRQ_GIC_MAX		127</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/* One single KVM irqchip, ie. the VGIC */</span>
<span class="p_add">+#define KVM_NR_IRQCHIPS          1</span>
<span class="p_add">+</span>
<span class="p_add">+/* PSCI interface */</span>
<span class="p_add">+#define KVM_PSCI_FN_BASE		0x95c1ba5e</span>
<span class="p_add">+#define KVM_PSCI_FN(n)			(KVM_PSCI_FN_BASE + (n))</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_PSCI_FN_CPU_SUSPEND		KVM_PSCI_FN(0)</span>
<span class="p_add">+#define KVM_PSCI_FN_CPU_OFF		KVM_PSCI_FN(1)</span>
<span class="p_add">+#define KVM_PSCI_FN_CPU_ON		KVM_PSCI_FN(2)</span>
<span class="p_add">+#define KVM_PSCI_FN_MIGRATE		KVM_PSCI_FN(3)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_PSCI_RET_SUCCESS		PSCI_RET_SUCCESS</span>
<span class="p_add">+#define KVM_PSCI_RET_NI			PSCI_RET_NOT_SUPPORTED</span>
<span class="p_add">+#define KVM_PSCI_RET_INVAL		PSCI_RET_INVALID_PARAMS</span>
<span class="p_add">+#define KVM_PSCI_RET_DENIED		PSCI_RET_DENIED</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ARM_KVM_H__ */</span>
<span class="p_header">diff --git a/tools/arch/arm64/include/uapi/asm/kvm.h b/tools/arch/arm64/include/uapi/asm/kvm.h</span>
new file mode 100644
<span class="p_header">index 000000000000..f209ea151dca</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/arm64/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -0,0 +1,258 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012,2013 - ARM Ltd</span>
<span class="p_add">+ * Author: Marc Zyngier &lt;marc.zyngier@arm.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Derived from arch/arm/include/uapi/asm/kvm.h:</span>
<span class="p_add">+ * Copyright (C) 2012 - Virtual Open Systems and Columbia University</span>
<span class="p_add">+ * Author: Christoffer Dall &lt;c.dall@virtualopensystems.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ARM_KVM_H__</span>
<span class="p_add">+#define __ARM_KVM_H__</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_SPSR_EL1	0</span>
<span class="p_add">+#define KVM_SPSR_SVC	KVM_SPSR_EL1</span>
<span class="p_add">+#define KVM_SPSR_ABT	1</span>
<span class="p_add">+#define KVM_SPSR_UND	2</span>
<span class="p_add">+#define KVM_SPSR_IRQ	3</span>
<span class="p_add">+#define KVM_SPSR_FIQ	4</span>
<span class="p_add">+#define KVM_NR_SPSR	5</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#include &lt;linux/psci.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define __KVM_HAVE_GUEST_DEBUG</span>
<span class="p_add">+#define __KVM_HAVE_IRQ_LINE</span>
<span class="p_add">+#define __KVM_HAVE_READONLY_MEM</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_SIZE(id)						\</span>
<span class="p_add">+	(1U &lt;&lt; (((id) &amp; KVM_REG_SIZE_MASK) &gt;&gt; KVM_REG_SIZE_SHIFT))</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_regs {</span>
<span class="p_add">+	struct user_pt_regs regs;	/* sp = sp_el0 */</span>
<span class="p_add">+</span>
<span class="p_add">+	__u64	sp_el1;</span>
<span class="p_add">+	__u64	elr_el1;</span>
<span class="p_add">+</span>
<span class="p_add">+	__u64	spsr[KVM_NR_SPSR];</span>
<span class="p_add">+</span>
<span class="p_add">+	struct user_fpsimd_state fp_regs;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Supported CPU Targets - Adding a new target type is not recommended,</span>
<span class="p_add">+ * unless there are some special registers not supported by the</span>
<span class="p_add">+ * genericv8 syreg table.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_ARM_TARGET_AEM_V8		0</span>
<span class="p_add">+#define KVM_ARM_TARGET_FOUNDATION_V8	1</span>
<span class="p_add">+#define KVM_ARM_TARGET_CORTEX_A57	2</span>
<span class="p_add">+#define KVM_ARM_TARGET_XGENE_POTENZA	3</span>
<span class="p_add">+#define KVM_ARM_TARGET_CORTEX_A53	4</span>
<span class="p_add">+/* Generic ARM v8 target */</span>
<span class="p_add">+#define KVM_ARM_TARGET_GENERIC_V8	5</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_ARM_NUM_TARGETS		6</span>
<span class="p_add">+</span>
<span class="p_add">+/* KVM_ARM_SET_DEVICE_ADDR ioctl id encoding */</span>
<span class="p_add">+#define KVM_ARM_DEVICE_TYPE_SHIFT	0</span>
<span class="p_add">+#define KVM_ARM_DEVICE_TYPE_MASK	(0xffff &lt;&lt; KVM_ARM_DEVICE_TYPE_SHIFT)</span>
<span class="p_add">+#define KVM_ARM_DEVICE_ID_SHIFT		16</span>
<span class="p_add">+#define KVM_ARM_DEVICE_ID_MASK		(0xffff &lt;&lt; KVM_ARM_DEVICE_ID_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Supported device IDs */</span>
<span class="p_add">+#define KVM_ARM_DEVICE_VGIC_V2		0</span>
<span class="p_add">+</span>
<span class="p_add">+/* Supported VGIC address types  */</span>
<span class="p_add">+#define KVM_VGIC_V2_ADDR_TYPE_DIST	0</span>
<span class="p_add">+#define KVM_VGIC_V2_ADDR_TYPE_CPU	1</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_VGIC_V2_DIST_SIZE		0x1000</span>
<span class="p_add">+#define KVM_VGIC_V2_CPU_SIZE		0x2000</span>
<span class="p_add">+</span>
<span class="p_add">+/* Supported VGICv3 address types  */</span>
<span class="p_add">+#define KVM_VGIC_V3_ADDR_TYPE_DIST	2</span>
<span class="p_add">+#define KVM_VGIC_V3_ADDR_TYPE_REDIST	3</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_VGIC_V3_DIST_SIZE		SZ_64K</span>
<span class="p_add">+#define KVM_VGIC_V3_REDIST_SIZE		(2 * SZ_64K)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_ARM_VCPU_POWER_OFF		0 /* CPU is started in OFF state */</span>
<span class="p_add">+#define KVM_ARM_VCPU_EL1_32BIT		1 /* CPU running a 32bit VM */</span>
<span class="p_add">+#define KVM_ARM_VCPU_PSCI_0_2		2 /* CPU uses PSCI v0.2 */</span>
<span class="p_add">+#define KVM_ARM_VCPU_PMU_V3		3 /* Support guest PMUv3 */</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_vcpu_init {</span>
<span class="p_add">+	__u32 target;</span>
<span class="p_add">+	__u32 features[7];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sregs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_fpu {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * See v8 ARM ARM D7.3: Debug Registers</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The architectural limit is 16 debug registers of each type although</span>
<span class="p_add">+ * in practice there are usually less (see ID_AA64DFR0_EL1).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Although the control registers are architecturally defined as 32</span>
<span class="p_add">+ * bits wide we use a 64 bit structure here to keep parity with</span>
<span class="p_add">+ * KVM_GET/SET_ONE_REG behaviour which treats all system registers as</span>
<span class="p_add">+ * 64 bit values. It also allows for the possibility of the</span>
<span class="p_add">+ * architecture expanding the control registers without having to</span>
<span class="p_add">+ * change the userspace ABI.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_ARM_MAX_DBG_REGS 16</span>
<span class="p_add">+struct kvm_guest_debug_arch {</span>
<span class="p_add">+	__u64 dbg_bcr[KVM_ARM_MAX_DBG_REGS];</span>
<span class="p_add">+	__u64 dbg_bvr[KVM_ARM_MAX_DBG_REGS];</span>
<span class="p_add">+	__u64 dbg_wcr[KVM_ARM_MAX_DBG_REGS];</span>
<span class="p_add">+	__u64 dbg_wvr[KVM_ARM_MAX_DBG_REGS];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_debug_exit_arch {</span>
<span class="p_add">+	__u32 hsr;</span>
<span class="p_add">+	__u64 far;	/* used for watchpoints */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Architecture specific defines for kvm_guest_debug-&gt;control</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_GUESTDBG_USE_SW_BP		(1 &lt;&lt; 16)</span>
<span class="p_add">+#define KVM_GUESTDBG_USE_HW		(1 &lt;&lt; 17)</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_sync_regs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_arch_memory_slot {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* If you need to interpret the index values, here is the key: */</span>
<span class="p_add">+#define KVM_REG_ARM_COPROC_MASK		0x000000000FFF0000</span>
<span class="p_add">+#define KVM_REG_ARM_COPROC_SHIFT	16</span>
<span class="p_add">+</span>
<span class="p_add">+/* Normal registers are mapped as coprocessor 16. */</span>
<span class="p_add">+#define KVM_REG_ARM_CORE		(0x0010 &lt;&lt; KVM_REG_ARM_COPROC_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM_CORE_REG(name)	(offsetof(struct kvm_regs, name) / sizeof(__u32))</span>
<span class="p_add">+</span>
<span class="p_add">+/* Some registers need more space to represent values. */</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX		(0x0011 &lt;&lt; KVM_REG_ARM_COPROC_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_ID_MASK	0x000000000000FF00</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_ID_SHIFT	8</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_ID_CCSIDR	(0x00 &lt;&lt; KVM_REG_ARM_DEMUX_ID_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_VAL_MASK	0x00000000000000FF</span>
<span class="p_add">+#define KVM_REG_ARM_DEMUX_VAL_SHIFT	0</span>
<span class="p_add">+</span>
<span class="p_add">+/* AArch64 system registers */</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG		(0x0013 &lt;&lt; KVM_REG_ARM_COPROC_SHIFT)</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_OP0_MASK	0x000000000000c000</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_OP0_SHIFT	14</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_OP1_MASK	0x0000000000003800</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_OP1_SHIFT	11</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_CRN_MASK	0x0000000000000780</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_CRN_SHIFT	7</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_CRM_MASK	0x0000000000000078</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_CRM_SHIFT	3</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_OP2_MASK	0x0000000000000007</span>
<span class="p_add">+#define KVM_REG_ARM64_SYSREG_OP2_SHIFT	0</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM64_SYS_REG_SHIFT_MASK(x,n) \</span>
<span class="p_add">+	(((x) &lt;&lt; KVM_REG_ARM64_SYSREG_ ## n ## _SHIFT) &amp; \</span>
<span class="p_add">+	KVM_REG_ARM64_SYSREG_ ## n ## _MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __ARM64_SYS_REG(op0,op1,crn,crm,op2) \</span>
<span class="p_add">+	(KVM_REG_ARM64 | KVM_REG_ARM64_SYSREG | \</span>
<span class="p_add">+	ARM64_SYS_REG_SHIFT_MASK(op0, OP0) | \</span>
<span class="p_add">+	ARM64_SYS_REG_SHIFT_MASK(op1, OP1) | \</span>
<span class="p_add">+	ARM64_SYS_REG_SHIFT_MASK(crn, CRN) | \</span>
<span class="p_add">+	ARM64_SYS_REG_SHIFT_MASK(crm, CRM) | \</span>
<span class="p_add">+	ARM64_SYS_REG_SHIFT_MASK(op2, OP2))</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM64_SYS_REG(...) (__ARM64_SYS_REG(__VA_ARGS__) | KVM_REG_SIZE_U64)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_ARM_TIMER_CTL		ARM64_SYS_REG(3, 3, 14, 3, 1)</span>
<span class="p_add">+#define KVM_REG_ARM_TIMER_CNT		ARM64_SYS_REG(3, 3, 14, 3, 2)</span>
<span class="p_add">+#define KVM_REG_ARM_TIMER_CVAL		ARM64_SYS_REG(3, 3, 14, 0, 2)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Device Control API: ARM VGIC */</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_ADDR	0</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_DIST_REGS	1</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_CPU_REGS	2</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_CPUID_SHIFT	32</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_CPUID_MASK	(0xffULL &lt;&lt; KVM_DEV_ARM_VGIC_CPUID_SHIFT)</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_OFFSET_SHIFT	0</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_OFFSET_MASK	(0xffffffffULL &lt;&lt; KVM_DEV_ARM_VGIC_OFFSET_SHIFT)</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_NR_IRQS	3</span>
<span class="p_add">+#define KVM_DEV_ARM_VGIC_GRP_CTRL	4</span>
<span class="p_add">+#define   KVM_DEV_ARM_VGIC_CTRL_INIT	0</span>
<span class="p_add">+</span>
<span class="p_add">+/* Device Control API on vcpu fd */</span>
<span class="p_add">+#define KVM_ARM_VCPU_PMU_V3_CTRL	0</span>
<span class="p_add">+#define   KVM_ARM_VCPU_PMU_V3_IRQ	0</span>
<span class="p_add">+#define   KVM_ARM_VCPU_PMU_V3_INIT	1</span>
<span class="p_add">+</span>
<span class="p_add">+/* KVM_IRQ_LINE irq field index values */</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_SHIFT		24</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_MASK		0xff</span>
<span class="p_add">+#define KVM_ARM_IRQ_VCPU_SHIFT		16</span>
<span class="p_add">+#define KVM_ARM_IRQ_VCPU_MASK		0xff</span>
<span class="p_add">+#define KVM_ARM_IRQ_NUM_SHIFT		0</span>
<span class="p_add">+#define KVM_ARM_IRQ_NUM_MASK		0xffff</span>
<span class="p_add">+</span>
<span class="p_add">+/* irq_type field */</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_CPU		0</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_SPI		1</span>
<span class="p_add">+#define KVM_ARM_IRQ_TYPE_PPI		2</span>
<span class="p_add">+</span>
<span class="p_add">+/* out-of-kernel GIC cpu interrupt injection irq_number field */</span>
<span class="p_add">+#define KVM_ARM_IRQ_CPU_IRQ		0</span>
<span class="p_add">+#define KVM_ARM_IRQ_CPU_FIQ		1</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This used to hold the highest supported SPI, but it is now obsolete</span>
<span class="p_add">+ * and only here to provide source code level compatibility with older</span>
<span class="p_add">+ * userland. The highest SPI number can be set via KVM_DEV_ARM_VGIC_GRP_NR_IRQS.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef __KERNEL__</span>
<span class="p_add">+#define KVM_ARM_IRQ_GIC_MAX		127</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/* One single KVM irqchip, ie. the VGIC */</span>
<span class="p_add">+#define KVM_NR_IRQCHIPS          1</span>
<span class="p_add">+</span>
<span class="p_add">+/* PSCI interface */</span>
<span class="p_add">+#define KVM_PSCI_FN_BASE		0x95c1ba5e</span>
<span class="p_add">+#define KVM_PSCI_FN(n)			(KVM_PSCI_FN_BASE + (n))</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_PSCI_FN_CPU_SUSPEND		KVM_PSCI_FN(0)</span>
<span class="p_add">+#define KVM_PSCI_FN_CPU_OFF		KVM_PSCI_FN(1)</span>
<span class="p_add">+#define KVM_PSCI_FN_CPU_ON		KVM_PSCI_FN(2)</span>
<span class="p_add">+#define KVM_PSCI_FN_MIGRATE		KVM_PSCI_FN(3)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_PSCI_RET_SUCCESS		PSCI_RET_SUCCESS</span>
<span class="p_add">+#define KVM_PSCI_RET_NI			PSCI_RET_NOT_SUPPORTED</span>
<span class="p_add">+#define KVM_PSCI_RET_INVAL		PSCI_RET_INVALID_PARAMS</span>
<span class="p_add">+#define KVM_PSCI_RET_DENIED		PSCI_RET_DENIED</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ARM_KVM_H__ */</span>
<span class="p_header">diff --git a/tools/arch/mips/include/uapi/asm/kvm.h b/tools/arch/mips/include/uapi/asm/kvm.h</span>
new file mode 100644
<span class="p_header">index 000000000000..6985eb59b085</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/mips/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -0,0 +1,208 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="p_add">+ * License.  See the file &quot;COPYING&quot; in the main directory of this archive</span>
<span class="p_add">+ * for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012  MIPS Technologies, Inc.  All rights reserved.</span>
<span class="p_add">+ * Copyright (C) 2013 Cavium, Inc.</span>
<span class="p_add">+ * Authors: Sanjay Lal &lt;sanjayl@kymasys.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __LINUX_KVM_MIPS_H</span>
<span class="p_add">+#define __LINUX_KVM_MIPS_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM MIPS specific structures and definitions.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some parts derived from the x86 version of this file.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * for KVM_GET_REGS and KVM_SET_REGS</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If Config[AT] is zero (32-bit CPU), the register contents are</span>
<span class="p_add">+ * stored in the lower 32-bits of the struct kvm_regs fields and sign</span>
<span class="p_add">+ * extended to 64-bits.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct kvm_regs {</span>
<span class="p_add">+	/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */</span>
<span class="p_add">+	__u64 gpr[32];</span>
<span class="p_add">+	__u64 hi;</span>
<span class="p_add">+	__u64 lo;</span>
<span class="p_add">+	__u64 pc;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * for KVM_GET_FPU and KVM_SET_FPU</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct kvm_fpu {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * For MIPS, we use KVM_SET_ONE_REG and KVM_GET_ONE_REG to access various</span>
<span class="p_add">+ * registers.  The id field is broken down as follows:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  bits[63..52] - As per linux/kvm.h</span>
<span class="p_add">+ *  bits[51..32] - Must be zero.</span>
<span class="p_add">+ *  bits[31..16] - Register set.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Register set = 0: GP registers from kvm_regs (see definitions below).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Register set = 1: CP0 registers.</span>
<span class="p_add">+ *  bits[15..8]  - Must be zero.</span>
<span class="p_add">+ *  bits[7..3]   - Register &#39;rd&#39;  index.</span>
<span class="p_add">+ *  bits[2..0]   - Register &#39;sel&#39; index.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Register set = 2: KVM specific registers (see definitions below).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Register set = 3: FPU / MSA registers (see definitions below).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Other sets registers may be added in the future.  Each set would</span>
<span class="p_add">+ * have its own identifier in bits[31..16].</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_MIPS_GP		(KVM_REG_MIPS | 0x0000000000000000ULL)</span>
<span class="p_add">+#define KVM_REG_MIPS_CP0	(KVM_REG_MIPS | 0x0000000000010000ULL)</span>
<span class="p_add">+#define KVM_REG_MIPS_KVM	(KVM_REG_MIPS | 0x0000000000020000ULL)</span>
<span class="p_add">+#define KVM_REG_MIPS_FPU	(KVM_REG_MIPS | 0x0000000000030000ULL)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM_REG_MIPS_GP - General purpose registers from kvm_regs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_MIPS_R0		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  0)</span>
<span class="p_add">+#define KVM_REG_MIPS_R1		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  1)</span>
<span class="p_add">+#define KVM_REG_MIPS_R2		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  2)</span>
<span class="p_add">+#define KVM_REG_MIPS_R3		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  3)</span>
<span class="p_add">+#define KVM_REG_MIPS_R4		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  4)</span>
<span class="p_add">+#define KVM_REG_MIPS_R5		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  5)</span>
<span class="p_add">+#define KVM_REG_MIPS_R6		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  6)</span>
<span class="p_add">+#define KVM_REG_MIPS_R7		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  7)</span>
<span class="p_add">+#define KVM_REG_MIPS_R8		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  8)</span>
<span class="p_add">+#define KVM_REG_MIPS_R9		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 |  9)</span>
<span class="p_add">+#define KVM_REG_MIPS_R10	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 10)</span>
<span class="p_add">+#define KVM_REG_MIPS_R11	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 11)</span>
<span class="p_add">+#define KVM_REG_MIPS_R12	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 12)</span>
<span class="p_add">+#define KVM_REG_MIPS_R13	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 13)</span>
<span class="p_add">+#define KVM_REG_MIPS_R14	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 14)</span>
<span class="p_add">+#define KVM_REG_MIPS_R15	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 15)</span>
<span class="p_add">+#define KVM_REG_MIPS_R16	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 16)</span>
<span class="p_add">+#define KVM_REG_MIPS_R17	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 17)</span>
<span class="p_add">+#define KVM_REG_MIPS_R18	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 18)</span>
<span class="p_add">+#define KVM_REG_MIPS_R19	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 19)</span>
<span class="p_add">+#define KVM_REG_MIPS_R20	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 20)</span>
<span class="p_add">+#define KVM_REG_MIPS_R21	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 21)</span>
<span class="p_add">+#define KVM_REG_MIPS_R22	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 22)</span>
<span class="p_add">+#define KVM_REG_MIPS_R23	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 23)</span>
<span class="p_add">+#define KVM_REG_MIPS_R24	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 24)</span>
<span class="p_add">+#define KVM_REG_MIPS_R25	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 25)</span>
<span class="p_add">+#define KVM_REG_MIPS_R26	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 26)</span>
<span class="p_add">+#define KVM_REG_MIPS_R27	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 27)</span>
<span class="p_add">+#define KVM_REG_MIPS_R28	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 28)</span>
<span class="p_add">+#define KVM_REG_MIPS_R29	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 29)</span>
<span class="p_add">+#define KVM_REG_MIPS_R30	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 30)</span>
<span class="p_add">+#define KVM_REG_MIPS_R31	(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 31)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_MIPS_HI		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 32)</span>
<span class="p_add">+#define KVM_REG_MIPS_LO		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 33)</span>
<span class="p_add">+#define KVM_REG_MIPS_PC		(KVM_REG_MIPS_GP | KVM_REG_SIZE_U64 | 34)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM_REG_MIPS_KVM - KVM specific control registers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * CP0_Count control</span>
<span class="p_add">+ * DC:    Set 0: Master disable CP0_Count and set COUNT_RESUME to now</span>
<span class="p_add">+ *        Set 1: Master re-enable CP0_Count with unchanged bias, handling timer</span>
<span class="p_add">+ *               interrupts since COUNT_RESUME</span>
<span class="p_add">+ *        This can be used to freeze the timer to get a consistent snapshot of</span>
<span class="p_add">+ *        the CP0_Count and timer interrupt pending state, while also resuming</span>
<span class="p_add">+ *        safely without losing time or guest timer interrupts.</span>
<span class="p_add">+ * Other: Reserved, do not change.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_MIPS_COUNT_CTL	    (KVM_REG_MIPS_KVM | KVM_REG_SIZE_U64 | 0)</span>
<span class="p_add">+#define KVM_REG_MIPS_COUNT_CTL_DC	0x00000001</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * CP0_Count resume monotonic nanoseconds</span>
<span class="p_add">+ * The monotonic nanosecond time of the last set of COUNT_CTL.DC (master</span>
<span class="p_add">+ * disable). Any reads and writes of Count related registers while</span>
<span class="p_add">+ * COUNT_CTL.DC=1 will appear to occur at this time. When COUNT_CTL.DC is</span>
<span class="p_add">+ * cleared again (master enable) any timer interrupts since this time will be</span>
<span class="p_add">+ * emulated.</span>
<span class="p_add">+ * Modifications to times in the future are rejected.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_MIPS_COUNT_RESUME   (KVM_REG_MIPS_KVM | KVM_REG_SIZE_U64 | 1)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * CP0_Count rate in Hz</span>
<span class="p_add">+ * Specifies the rate of the CP0_Count timer in Hz. Modifications occur without</span>
<span class="p_add">+ * discontinuities in CP0_Count.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_MIPS_COUNT_HZ	    (KVM_REG_MIPS_KVM | KVM_REG_SIZE_U64 | 2)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM_REG_MIPS_FPU - Floating Point and MIPS SIMD Architecture (MSA) registers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  bits[15..8]  - Register subset (see definitions below).</span>
<span class="p_add">+ *  bits[7..5]   - Must be zero.</span>
<span class="p_add">+ *  bits[4..0]   - Register number within register subset.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_MIPS_FPR	(KVM_REG_MIPS_FPU | 0x0000000000000000ULL)</span>
<span class="p_add">+#define KVM_REG_MIPS_FCR	(KVM_REG_MIPS_FPU | 0x0000000000000100ULL)</span>
<span class="p_add">+#define KVM_REG_MIPS_MSACR	(KVM_REG_MIPS_FPU | 0x0000000000000200ULL)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM_REG_MIPS_FPR - Floating point / Vector registers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_MIPS_FPR_32(n)	(KVM_REG_MIPS_FPR | KVM_REG_SIZE_U32  | (n))</span>
<span class="p_add">+#define KVM_REG_MIPS_FPR_64(n)	(KVM_REG_MIPS_FPR | KVM_REG_SIZE_U64  | (n))</span>
<span class="p_add">+#define KVM_REG_MIPS_VEC_128(n)	(KVM_REG_MIPS_FPR | KVM_REG_SIZE_U128 | (n))</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM_REG_MIPS_FCR - Floating point control registers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_MIPS_FCR_IR	(KVM_REG_MIPS_FCR | KVM_REG_SIZE_U32 |  0)</span>
<span class="p_add">+#define KVM_REG_MIPS_FCR_CSR	(KVM_REG_MIPS_FCR | KVM_REG_SIZE_U32 | 31)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM_REG_MIPS_MSACR - MIPS SIMD Architecture (MSA) control registers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_MIPS_MSA_IR	 (KVM_REG_MIPS_MSACR | KVM_REG_SIZE_U32 |  0)</span>
<span class="p_add">+#define KVM_REG_MIPS_MSA_CSR	 (KVM_REG_MIPS_MSACR | KVM_REG_SIZE_U32 |  1)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM MIPS specific structures and definitions</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct kvm_debug_exit_arch {</span>
<span class="p_add">+	__u64 epc;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_SET_GUEST_DEBUG */</span>
<span class="p_add">+struct kvm_guest_debug_arch {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* definition of registers in kvm_run */</span>
<span class="p_add">+struct kvm_sync_regs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* dummy definition */</span>
<span class="p_add">+struct kvm_sregs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_mips_interrupt {</span>
<span class="p_add">+	/* in */</span>
<span class="p_add">+	__u32 cpu;</span>
<span class="p_add">+	__u32 irq;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __LINUX_KVM_MIPS_H */</span>
<span class="p_header">diff --git a/tools/arch/powerpc/include/uapi/asm/kvm.h b/tools/arch/powerpc/include/uapi/asm/kvm.h</span>
new file mode 100644
<span class="p_header">index 000000000000..c93cf35ce379</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/powerpc/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -0,0 +1,612 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License, version 2, as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright IBM Corp. 2007</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Authors: Hollis Blanchard &lt;hollisb@us.ibm.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __LINUX_KVM_POWERPC_H</span>
<span class="p_add">+#define __LINUX_KVM_POWERPC_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Select powerpc specific features in &lt;linux/kvm.h&gt; */</span>
<span class="p_add">+#define __KVM_HAVE_SPAPR_TCE</span>
<span class="p_add">+#define __KVM_HAVE_PPC_SMT</span>
<span class="p_add">+#define __KVM_HAVE_IRQCHIP</span>
<span class="p_add">+#define __KVM_HAVE_IRQ_LINE</span>
<span class="p_add">+#define __KVM_HAVE_GUEST_DEBUG</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_regs {</span>
<span class="p_add">+	__u64 pc;</span>
<span class="p_add">+	__u64 cr;</span>
<span class="p_add">+	__u64 ctr;</span>
<span class="p_add">+	__u64 lr;</span>
<span class="p_add">+	__u64 xer;</span>
<span class="p_add">+	__u64 msr;</span>
<span class="p_add">+	__u64 srr0;</span>
<span class="p_add">+	__u64 srr1;</span>
<span class="p_add">+	__u64 pid;</span>
<span class="p_add">+</span>
<span class="p_add">+	__u64 sprg0;</span>
<span class="p_add">+	__u64 sprg1;</span>
<span class="p_add">+	__u64 sprg2;</span>
<span class="p_add">+	__u64 sprg3;</span>
<span class="p_add">+	__u64 sprg4;</span>
<span class="p_add">+	__u64 sprg5;</span>
<span class="p_add">+	__u64 sprg6;</span>
<span class="p_add">+	__u64 sprg7;</span>
<span class="p_add">+</span>
<span class="p_add">+	__u64 gpr[32];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_SREGS_E_IMPL_NONE	0</span>
<span class="p_add">+#define KVM_SREGS_E_IMPL_FSL	1</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_SREGS_E_FSL_PIDn	(1 &lt;&lt; 0) /* PID1/PID2 */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Feature bits indicate which sections of the sregs struct are valid,</span>
<span class="p_add">+ * both in KVM_GET_SREGS and KVM_SET_SREGS.  On KVM_SET_SREGS, registers</span>
<span class="p_add">+ * corresponding to unset feature bits will not be modified.  This allows</span>
<span class="p_add">+ * restoring a checkpoint made without that feature, while keeping the</span>
<span class="p_add">+ * default values of the new registers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * KVM_SREGS_E_BASE contains:</span>
<span class="p_add">+ * CSRR0/1 (refers to SRR2/3 on 40x)</span>
<span class="p_add">+ * ESR</span>
<span class="p_add">+ * DEAR</span>
<span class="p_add">+ * MCSR</span>
<span class="p_add">+ * TSR</span>
<span class="p_add">+ * TCR</span>
<span class="p_add">+ * DEC</span>
<span class="p_add">+ * TB</span>
<span class="p_add">+ * VRSAVE (USPRG0)</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_SREGS_E_BASE		(1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM_SREGS_E_ARCH206 contains:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * PIR</span>
<span class="p_add">+ * MCSRR0/1</span>
<span class="p_add">+ * DECAR</span>
<span class="p_add">+ * IVPR</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_SREGS_E_ARCH206		(1 &lt;&lt; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Contains EPCR, plus the upper half of 64-bit registers</span>
<span class="p_add">+ * that are 32-bit on 32-bit implementations.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_SREGS_E_64			(1 &lt;&lt; 2)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_SREGS_E_SPRG8		(1 &lt;&lt; 3)</span>
<span class="p_add">+#define KVM_SREGS_E_MCIVPR		(1 &lt;&lt; 4)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * IVORs are used -- contains IVOR0-15, plus additional IVORs</span>
<span class="p_add">+ * in combination with an appropriate feature bit.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_SREGS_E_IVOR		(1 &lt;&lt; 5)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Contains MAS0-4, MAS6-7, TLBnCFG, MMUCFG.</span>
<span class="p_add">+ * Also TLBnPS if MMUCFG[MAVN] = 1.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_SREGS_E_ARCH206_MMU		(1 &lt;&lt; 6)</span>
<span class="p_add">+</span>
<span class="p_add">+/* DBSR, DBCR, IAC, DAC, DVC */</span>
<span class="p_add">+#define KVM_SREGS_E_DEBUG		(1 &lt;&lt; 7)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Enhanced debug -- DSRR0/1, SPRG9 */</span>
<span class="p_add">+#define KVM_SREGS_E_ED			(1 &lt;&lt; 8)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Embedded Floating Point (SPE) -- IVOR32-34 if KVM_SREGS_E_IVOR */</span>
<span class="p_add">+#define KVM_SREGS_E_SPE			(1 &lt;&lt; 9)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * DEPRECATED! USE ONE_REG FOR THIS ONE!</span>
<span class="p_add">+ * External Proxy (EXP) -- EPR</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_SREGS_EXP			(1 &lt;&lt; 10)</span>
<span class="p_add">+</span>
<span class="p_add">+/* External PID (E.PD) -- EPSC/EPLC */</span>
<span class="p_add">+#define KVM_SREGS_E_PD			(1 &lt;&lt; 11)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Processor Control (E.PC) -- IVOR36-37 if KVM_SREGS_E_IVOR */</span>
<span class="p_add">+#define KVM_SREGS_E_PC			(1 &lt;&lt; 12)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Page table (E.PT) -- EPTCFG */</span>
<span class="p_add">+#define KVM_SREGS_E_PT			(1 &lt;&lt; 13)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Embedded Performance Monitor (E.PM) -- IVOR35 if KVM_SREGS_E_IVOR */</span>
<span class="p_add">+#define KVM_SREGS_E_PM			(1 &lt;&lt; 14)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Special updates:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some registers may change even while a vcpu is not running.</span>
<span class="p_add">+ * To avoid losing these changes, by default these registers are</span>
<span class="p_add">+ * not updated by KVM_SET_SREGS.  To force an update, set the bit</span>
<span class="p_add">+ * in u.e.update_special corresponding to the register to be updated.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The update_special field is zero on return from KVM_GET_SREGS.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * When restoring a checkpoint, the caller can set update_special</span>
<span class="p_add">+ * to 0xffffffff to ensure that everything is restored, even new features</span>
<span class="p_add">+ * that the caller doesn&#39;t know about.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_SREGS_E_UPDATE_MCSR		(1 &lt;&lt; 0)</span>
<span class="p_add">+#define KVM_SREGS_E_UPDATE_TSR		(1 &lt;&lt; 1)</span>
<span class="p_add">+#define KVM_SREGS_E_UPDATE_DEC		(1 &lt;&lt; 2)</span>
<span class="p_add">+#define KVM_SREGS_E_UPDATE_DBSR		(1 &lt;&lt; 3)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * In KVM_SET_SREGS, reserved/pad fields must be left untouched from a</span>
<span class="p_add">+ * previous KVM_GET_REGS.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Unless otherwise indicated, setting any register with KVM_SET_SREGS</span>
<span class="p_add">+ * directly sets its value.  It does not trigger any special semantics such</span>
<span class="p_add">+ * as write-one-to-clear.  Calling KVM_SET_SREGS on an unmodified struct</span>
<span class="p_add">+ * just received from KVM_GET_SREGS is always a no-op.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct kvm_sregs {</span>
<span class="p_add">+	__u32 pvr;</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			__u64 sdr1;</span>
<span class="p_add">+			struct {</span>
<span class="p_add">+				struct {</span>
<span class="p_add">+					__u64 slbe;</span>
<span class="p_add">+					__u64 slbv;</span>
<span class="p_add">+				} slb[64];</span>
<span class="p_add">+			} ppc64;</span>
<span class="p_add">+			struct {</span>
<span class="p_add">+				__u32 sr[16];</span>
<span class="p_add">+				__u64 ibat[8];</span>
<span class="p_add">+				__u64 dbat[8];</span>
<span class="p_add">+			} ppc32;</span>
<span class="p_add">+		} s;</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			union {</span>
<span class="p_add">+				struct { /* KVM_SREGS_E_IMPL_FSL */</span>
<span class="p_add">+					__u32 features; /* KVM_SREGS_E_FSL_ */</span>
<span class="p_add">+					__u32 svr;</span>
<span class="p_add">+					__u64 mcar;</span>
<span class="p_add">+					__u32 hid0;</span>
<span class="p_add">+</span>
<span class="p_add">+					/* KVM_SREGS_E_FSL_PIDn */</span>
<span class="p_add">+					__u32 pid1, pid2;</span>
<span class="p_add">+				} fsl;</span>
<span class="p_add">+				__u8 pad[256];</span>
<span class="p_add">+			} impl;</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 features; /* KVM_SREGS_E_ */</span>
<span class="p_add">+			__u32 impl_id;	/* KVM_SREGS_E_IMPL_ */</span>
<span class="p_add">+			__u32 update_special; /* KVM_SREGS_E_UPDATE_ */</span>
<span class="p_add">+			__u32 pir;	/* read-only */</span>
<span class="p_add">+			__u64 sprg8;</span>
<span class="p_add">+			__u64 sprg9;	/* E.ED */</span>
<span class="p_add">+			__u64 csrr0;</span>
<span class="p_add">+			__u64 dsrr0;	/* E.ED */</span>
<span class="p_add">+			__u64 mcsrr0;</span>
<span class="p_add">+			__u32 csrr1;</span>
<span class="p_add">+			__u32 dsrr1;	/* E.ED */</span>
<span class="p_add">+			__u32 mcsrr1;</span>
<span class="p_add">+			__u32 esr;</span>
<span class="p_add">+			__u64 dear;</span>
<span class="p_add">+			__u64 ivpr;</span>
<span class="p_add">+			__u64 mcivpr;</span>
<span class="p_add">+			__u64 mcsr;	/* KVM_SREGS_E_UPDATE_MCSR */</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 tsr;	/* KVM_SREGS_E_UPDATE_TSR */</span>
<span class="p_add">+			__u32 tcr;</span>
<span class="p_add">+			__u32 decar;</span>
<span class="p_add">+			__u32 dec;	/* KVM_SREGS_E_UPDATE_DEC */</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Userspace can read TB directly, but the</span>
<span class="p_add">+			 * value reported here is consistent with &quot;dec&quot;.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * Read-only.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			__u64 tb;</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 dbsr;	/* KVM_SREGS_E_UPDATE_DBSR */</span>
<span class="p_add">+			__u32 dbcr[3];</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * iac/dac registers are 64bit wide, while this API</span>
<span class="p_add">+			 * interface provides only lower 32 bits on 64 bit</span>
<span class="p_add">+			 * processors. ONE_REG interface is added for 64bit</span>
<span class="p_add">+			 * iac/dac registers.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			__u32 iac[4];</span>
<span class="p_add">+			__u32 dac[2];</span>
<span class="p_add">+			__u32 dvc[2];</span>
<span class="p_add">+			__u8 num_iac;	/* read-only */</span>
<span class="p_add">+			__u8 num_dac;	/* read-only */</span>
<span class="p_add">+			__u8 num_dvc;	/* read-only */</span>
<span class="p_add">+			__u8 pad;</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 epr;	/* EXP */</span>
<span class="p_add">+			__u32 vrsave;	/* a.k.a. USPRG0 */</span>
<span class="p_add">+			__u32 epcr;	/* KVM_SREGS_E_64 */</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 mas0;</span>
<span class="p_add">+			__u32 mas1;</span>
<span class="p_add">+			__u64 mas2;</span>
<span class="p_add">+			__u64 mas7_3;</span>
<span class="p_add">+			__u32 mas4;</span>
<span class="p_add">+			__u32 mas6;</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 ivor_low[16]; /* IVOR0-15 */</span>
<span class="p_add">+			__u32 ivor_high[18]; /* IVOR32+, plus room to expand */</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 mmucfg;	/* read-only */</span>
<span class="p_add">+			__u32 eptcfg;	/* E.PT, read-only */</span>
<span class="p_add">+			__u32 tlbcfg[4];/* read-only */</span>
<span class="p_add">+			__u32 tlbps[4]; /* read-only */</span>
<span class="p_add">+</span>
<span class="p_add">+			__u32 eplc, epsc; /* E.PD */</span>
<span class="p_add">+		} e;</span>
<span class="p_add">+		__u8 pad[1020];</span>
<span class="p_add">+	} u;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_fpu {</span>
<span class="p_add">+	__u64 fpr[32];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Defines for h/w breakpoint, watchpoint (read, write or both) and</span>
<span class="p_add">+ * software breakpoint.</span>
<span class="p_add">+ * These are used as &quot;type&quot; in KVM_SET_GUEST_DEBUG ioctl and &quot;status&quot;</span>
<span class="p_add">+ * for KVM_DEBUG_EXIT.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVMPPC_DEBUG_NONE		0x0</span>
<span class="p_add">+#define KVMPPC_DEBUG_BREAKPOINT		(1UL &lt;&lt; 1)</span>
<span class="p_add">+#define KVMPPC_DEBUG_WATCH_WRITE	(1UL &lt;&lt; 2)</span>
<span class="p_add">+#define KVMPPC_DEBUG_WATCH_READ		(1UL &lt;&lt; 3)</span>
<span class="p_add">+struct kvm_debug_exit_arch {</span>
<span class="p_add">+	__u64 address;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * exiting to userspace because of h/w breakpoint, watchpoint</span>
<span class="p_add">+	 * (read, write or both) and software breakpoint.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__u32 status;</span>
<span class="p_add">+	__u32 reserved;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_SET_GUEST_DEBUG */</span>
<span class="p_add">+struct kvm_guest_debug_arch {</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		/* H/W breakpoint/watchpoint address */</span>
<span class="p_add">+		__u64 addr;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Type denotes h/w breakpoint, read watchpoint, write</span>
<span class="p_add">+		 * watchpoint or watchpoint (both read and write).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		__u32 type;</span>
<span class="p_add">+		__u32 reserved;</span>
<span class="p_add">+	} bp[16];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Debug related defines */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * kvm_guest_debug-&gt;control is a 32 bit field. The lower 16 bits are generic</span>
<span class="p_add">+ * and upper 16 bits are architecture specific. Architecture specific defines</span>
<span class="p_add">+ * that ioctl is for setting hardware breakpoint or software breakpoint.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_GUESTDBG_USE_SW_BP		0x00010000</span>
<span class="p_add">+#define KVM_GUESTDBG_USE_HW_BP		0x00020000</span>
<span class="p_add">+</span>
<span class="p_add">+/* definition of registers in kvm_run */</span>
<span class="p_add">+struct kvm_sync_regs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_INTERRUPT_SET	-1U</span>
<span class="p_add">+#define KVM_INTERRUPT_UNSET	-2U</span>
<span class="p_add">+#define KVM_INTERRUPT_SET_LEVEL	-3U</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_CPU_440		1</span>
<span class="p_add">+#define KVM_CPU_E500V2		2</span>
<span class="p_add">+#define KVM_CPU_3S_32		3</span>
<span class="p_add">+#define KVM_CPU_3S_64		4</span>
<span class="p_add">+#define KVM_CPU_E500MC		5</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_CAP_SPAPR_TCE */</span>
<span class="p_add">+struct kvm_create_spapr_tce {</span>
<span class="p_add">+	__u64 liobn;</span>
<span class="p_add">+	__u32 window_size;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_CAP_SPAPR_TCE_64 */</span>
<span class="p_add">+struct kvm_create_spapr_tce_64 {</span>
<span class="p_add">+	__u64 liobn;</span>
<span class="p_add">+	__u32 page_shift;</span>
<span class="p_add">+	__u32 flags;</span>
<span class="p_add">+	__u64 offset;	/* in pages */</span>
<span class="p_add">+	__u64 size;	/* in pages */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_ALLOCATE_RMA */</span>
<span class="p_add">+struct kvm_allocate_rma {</span>
<span class="p_add">+	__u64 rma_size;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_CAP_PPC_RTAS */</span>
<span class="p_add">+struct kvm_rtas_token_args {</span>
<span class="p_add">+	char name[120];</span>
<span class="p_add">+	__u64 token;	/* Use a token of 0 to undefine a mapping */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_book3e_206_tlb_entry {</span>
<span class="p_add">+	__u32 mas8;</span>
<span class="p_add">+	__u32 mas1;</span>
<span class="p_add">+	__u64 mas2;</span>
<span class="p_add">+	__u64 mas7_3;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_book3e_206_tlb_params {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For mmu types KVM_MMU_FSL_BOOKE_NOHV and KVM_MMU_FSL_BOOKE_HV:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * - The number of ways of TLB0 must be a power of two between 2 and</span>
<span class="p_add">+	 *   16.</span>
<span class="p_add">+	 * - TLB1 must be fully associative.</span>
<span class="p_add">+	 * - The size of TLB0 must be a multiple of the number of ways, and</span>
<span class="p_add">+	 *   the number of sets must be a power of two.</span>
<span class="p_add">+	 * - The size of TLB1 may not exceed 64 entries.</span>
<span class="p_add">+	 * - TLB0 supports 4 KiB pages.</span>
<span class="p_add">+	 * - The page sizes supported by TLB1 are as indicated by</span>
<span class="p_add">+	 *   TLB1CFG (if MMUCFG[MAVN] = 0) or TLB1PS (if MMUCFG[MAVN] = 1)</span>
<span class="p_add">+	 *   as returned by KVM_GET_SREGS.</span>
<span class="p_add">+	 * - TLB2 and TLB3 are reserved, and their entries in tlb_sizes[]</span>
<span class="p_add">+	 *   and tlb_ways[] must be zero.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * tlb_ways[n] = tlb_sizes[n] means the array is fully associative.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * KVM will adjust TLBnCFG based on the sizes configured here,</span>
<span class="p_add">+	 * though arrays greater than 2048 entries will have TLBnCFG[NENTRY]</span>
<span class="p_add">+	 * set to zero.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__u32 tlb_sizes[4];</span>
<span class="p_add">+	__u32 tlb_ways[4];</span>
<span class="p_add">+	__u32 reserved[8];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* For KVM_PPC_GET_HTAB_FD */</span>
<span class="p_add">+struct kvm_get_htab_fd {</span>
<span class="p_add">+	__u64	flags;</span>
<span class="p_add">+	__u64	start_index;</span>
<span class="p_add">+	__u64	reserved[2];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Values for kvm_get_htab_fd.flags */</span>
<span class="p_add">+#define KVM_GET_HTAB_BOLTED_ONLY	((__u64)0x1)</span>
<span class="p_add">+#define KVM_GET_HTAB_WRITE		((__u64)0x2)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Data read on the file descriptor is formatted as a series of</span>
<span class="p_add">+ * records, each consisting of a header followed by a series of</span>
<span class="p_add">+ * `n_valid&#39; HPTEs (16 bytes each), which are all valid.  Following</span>
<span class="p_add">+ * those valid HPTEs there are `n_invalid&#39; invalid HPTEs, which</span>
<span class="p_add">+ * are not represented explicitly in the stream.  The same format</span>
<span class="p_add">+ * is used for writing.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct kvm_get_htab_header {</span>
<span class="p_add">+	__u32	index;</span>
<span class="p_add">+	__u16	n_valid;</span>
<span class="p_add">+	__u16	n_invalid;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Per-vcpu XICS interrupt controller state */</span>
<span class="p_add">+#define KVM_REG_PPC_ICP_STATE	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x8c)</span>
<span class="p_add">+</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_CPPR_SHIFT	56	/* current proc priority */</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_CPPR_MASK	0xff</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_XISR_SHIFT	32	/* interrupt status field */</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_XISR_MASK	0xffffff</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_MFRR_SHIFT	24	/* pending IPI priority */</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_MFRR_MASK	0xff</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_PPRI_SHIFT	16	/* pending irq priority */</span>
<span class="p_add">+#define  KVM_REG_PPC_ICP_PPRI_MASK	0xff</span>
<span class="p_add">+</span>
<span class="p_add">+/* Device control API: PPC-specific devices */</span>
<span class="p_add">+#define KVM_DEV_MPIC_GRP_MISC		1</span>
<span class="p_add">+#define   KVM_DEV_MPIC_BASE_ADDR	0	/* 64-bit */</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_DEV_MPIC_GRP_REGISTER	2	/* 32-bit */</span>
<span class="p_add">+#define KVM_DEV_MPIC_GRP_IRQ_ACTIVE	3	/* 32-bit */</span>
<span class="p_add">+</span>
<span class="p_add">+/* One-Reg API: PPC-specific registers */</span>
<span class="p_add">+#define KVM_REG_PPC_HIOR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x1)</span>
<span class="p_add">+#define KVM_REG_PPC_IAC1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x2)</span>
<span class="p_add">+#define KVM_REG_PPC_IAC2	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x3)</span>
<span class="p_add">+#define KVM_REG_PPC_IAC3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x4)</span>
<span class="p_add">+#define KVM_REG_PPC_IAC4	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x5)</span>
<span class="p_add">+#define KVM_REG_PPC_DAC1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x6)</span>
<span class="p_add">+#define KVM_REG_PPC_DAC2	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x7)</span>
<span class="p_add">+#define KVM_REG_PPC_DABR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x8)</span>
<span class="p_add">+#define KVM_REG_PPC_DSCR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x9)</span>
<span class="p_add">+#define KVM_REG_PPC_PURR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa)</span>
<span class="p_add">+#define KVM_REG_PPC_SPURR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb)</span>
<span class="p_add">+#define KVM_REG_PPC_DAR		(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xc)</span>
<span class="p_add">+#define KVM_REG_PPC_DSISR	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0xd)</span>
<span class="p_add">+#define KVM_REG_PPC_AMR		(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xe)</span>
<span class="p_add">+#define KVM_REG_PPC_UAMOR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xf)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_PPC_MMCR0	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x10)</span>
<span class="p_add">+#define KVM_REG_PPC_MMCR1	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x11)</span>
<span class="p_add">+#define KVM_REG_PPC_MMCRA	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x12)</span>
<span class="p_add">+#define KVM_REG_PPC_MMCR2	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x13)</span>
<span class="p_add">+#define KVM_REG_PPC_MMCRS	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x14)</span>
<span class="p_add">+#define KVM_REG_PPC_SIAR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x15)</span>
<span class="p_add">+#define KVM_REG_PPC_SDAR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x16)</span>
<span class="p_add">+#define KVM_REG_PPC_SIER	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x17)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_PPC_PMC1	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x18)</span>
<span class="p_add">+#define KVM_REG_PPC_PMC2	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x19)</span>
<span class="p_add">+#define KVM_REG_PPC_PMC3	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x1a)</span>
<span class="p_add">+#define KVM_REG_PPC_PMC4	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x1b)</span>
<span class="p_add">+#define KVM_REG_PPC_PMC5	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x1c)</span>
<span class="p_add">+#define KVM_REG_PPC_PMC6	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x1d)</span>
<span class="p_add">+#define KVM_REG_PPC_PMC7	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x1e)</span>
<span class="p_add">+#define KVM_REG_PPC_PMC8	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x1f)</span>
<span class="p_add">+</span>
<span class="p_add">+/* 32 floating-point registers */</span>
<span class="p_add">+#define KVM_REG_PPC_FPR0	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x20)</span>
<span class="p_add">+#define KVM_REG_PPC_FPR(n)	(KVM_REG_PPC_FPR0 + (n))</span>
<span class="p_add">+#define KVM_REG_PPC_FPR31	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x3f)</span>
<span class="p_add">+</span>
<span class="p_add">+/* 32 VMX/Altivec vector registers */</span>
<span class="p_add">+#define KVM_REG_PPC_VR0		(KVM_REG_PPC | KVM_REG_SIZE_U128 | 0x40)</span>
<span class="p_add">+#define KVM_REG_PPC_VR(n)	(KVM_REG_PPC_VR0 + (n))</span>
<span class="p_add">+#define KVM_REG_PPC_VR31	(KVM_REG_PPC | KVM_REG_SIZE_U128 | 0x5f)</span>
<span class="p_add">+</span>
<span class="p_add">+/* 32 double-width FP registers for VSX */</span>
<span class="p_add">+/* High-order halves overlap with FP regs */</span>
<span class="p_add">+#define KVM_REG_PPC_VSR0	(KVM_REG_PPC | KVM_REG_SIZE_U128 | 0x60)</span>
<span class="p_add">+#define KVM_REG_PPC_VSR(n)	(KVM_REG_PPC_VSR0 + (n))</span>
<span class="p_add">+#define KVM_REG_PPC_VSR31	(KVM_REG_PPC | KVM_REG_SIZE_U128 | 0x7f)</span>
<span class="p_add">+</span>
<span class="p_add">+/* FP and vector status/control registers */</span>
<span class="p_add">+#define KVM_REG_PPC_FPSCR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x80)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * VSCR register is documented as a 32-bit register in the ISA, but it can</span>
<span class="p_add">+ * only be accesses via a vector register. Expose VSCR as a 32-bit register</span>
<span class="p_add">+ * even though the kernel represents it as a 128-bit vector.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_PPC_VSCR	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x81)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Virtual processor areas */</span>
<span class="p_add">+/* For SLB &amp; DTL, address in high (first) half, length in low half */</span>
<span class="p_add">+#define KVM_REG_PPC_VPA_ADDR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x82)</span>
<span class="p_add">+#define KVM_REG_PPC_VPA_SLB	(KVM_REG_PPC | KVM_REG_SIZE_U128 | 0x83)</span>
<span class="p_add">+#define KVM_REG_PPC_VPA_DTL	(KVM_REG_PPC | KVM_REG_SIZE_U128 | 0x84)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_PPC_EPCR	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x85)</span>
<span class="p_add">+#define KVM_REG_PPC_EPR		(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x86)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Timer Status Register OR/CLEAR interface */</span>
<span class="p_add">+#define KVM_REG_PPC_OR_TSR	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x87)</span>
<span class="p_add">+#define KVM_REG_PPC_CLEAR_TSR	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x88)</span>
<span class="p_add">+#define KVM_REG_PPC_TCR		(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x89)</span>
<span class="p_add">+#define KVM_REG_PPC_TSR		(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x8a)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Debugging: Special instruction for software breakpoint */</span>
<span class="p_add">+#define KVM_REG_PPC_DEBUG_INST	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x8b)</span>
<span class="p_add">+</span>
<span class="p_add">+/* MMU registers */</span>
<span class="p_add">+#define KVM_REG_PPC_MAS0	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x8c)</span>
<span class="p_add">+#define KVM_REG_PPC_MAS1	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x8d)</span>
<span class="p_add">+#define KVM_REG_PPC_MAS2	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x8e)</span>
<span class="p_add">+#define KVM_REG_PPC_MAS7_3	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x8f)</span>
<span class="p_add">+#define KVM_REG_PPC_MAS4	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x90)</span>
<span class="p_add">+#define KVM_REG_PPC_MAS6	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x91)</span>
<span class="p_add">+#define KVM_REG_PPC_MMUCFG	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x92)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * TLBnCFG fields TLBnCFG_N_ENTRY and TLBnCFG_ASSOC can be changed only using</span>
<span class="p_add">+ * KVM_CAP_SW_TLB ioctl</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_PPC_TLB0CFG	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x93)</span>
<span class="p_add">+#define KVM_REG_PPC_TLB1CFG	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x94)</span>
<span class="p_add">+#define KVM_REG_PPC_TLB2CFG	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x95)</span>
<span class="p_add">+#define KVM_REG_PPC_TLB3CFG	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x96)</span>
<span class="p_add">+#define KVM_REG_PPC_TLB0PS	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x97)</span>
<span class="p_add">+#define KVM_REG_PPC_TLB1PS	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x98)</span>
<span class="p_add">+#define KVM_REG_PPC_TLB2PS	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x99)</span>
<span class="p_add">+#define KVM_REG_PPC_TLB3PS	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x9a)</span>
<span class="p_add">+#define KVM_REG_PPC_EPTCFG	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x9b)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Timebase offset */</span>
<span class="p_add">+#define KVM_REG_PPC_TB_OFFSET	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x9c)</span>
<span class="p_add">+</span>
<span class="p_add">+/* POWER8 registers */</span>
<span class="p_add">+#define KVM_REG_PPC_SPMC1	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x9d)</span>
<span class="p_add">+#define KVM_REG_PPC_SPMC2	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0x9e)</span>
<span class="p_add">+#define KVM_REG_PPC_IAMR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0x9f)</span>
<span class="p_add">+#define KVM_REG_PPC_TFHAR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa0)</span>
<span class="p_add">+#define KVM_REG_PPC_TFIAR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa1)</span>
<span class="p_add">+#define KVM_REG_PPC_TEXASR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa2)</span>
<span class="p_add">+#define KVM_REG_PPC_FSCR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa3)</span>
<span class="p_add">+#define KVM_REG_PPC_PSPB	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0xa4)</span>
<span class="p_add">+#define KVM_REG_PPC_EBBHR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa5)</span>
<span class="p_add">+#define KVM_REG_PPC_EBBRR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa6)</span>
<span class="p_add">+#define KVM_REG_PPC_BESCR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa7)</span>
<span class="p_add">+#define KVM_REG_PPC_TAR		(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa8)</span>
<span class="p_add">+#define KVM_REG_PPC_DPDES	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xa9)</span>
<span class="p_add">+#define KVM_REG_PPC_DAWR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xaa)</span>
<span class="p_add">+#define KVM_REG_PPC_DAWRX	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xab)</span>
<span class="p_add">+#define KVM_REG_PPC_CIABR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xac)</span>
<span class="p_add">+#define KVM_REG_PPC_IC		(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xad)</span>
<span class="p_add">+#define KVM_REG_PPC_VTB		(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xae)</span>
<span class="p_add">+#define KVM_REG_PPC_CSIGR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xaf)</span>
<span class="p_add">+#define KVM_REG_PPC_TACR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb0)</span>
<span class="p_add">+#define KVM_REG_PPC_TCSCR	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb1)</span>
<span class="p_add">+#define KVM_REG_PPC_PID		(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb2)</span>
<span class="p_add">+#define KVM_REG_PPC_ACOP	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb3)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_PPC_VRSAVE	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0xb4)</span>
<span class="p_add">+#define KVM_REG_PPC_LPCR	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0xb5)</span>
<span class="p_add">+#define KVM_REG_PPC_LPCR_64	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb5)</span>
<span class="p_add">+#define KVM_REG_PPC_PPR		(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb6)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Architecture compatibility level */</span>
<span class="p_add">+#define KVM_REG_PPC_ARCH_COMPAT	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0xb7)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_PPC_DABRX	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0xb8)</span>
<span class="p_add">+#define KVM_REG_PPC_WORT	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xb9)</span>
<span class="p_add">+#define KVM_REG_PPC_SPRG9	(KVM_REG_PPC | KVM_REG_SIZE_U64 | 0xba)</span>
<span class="p_add">+#define KVM_REG_PPC_DBSR	(KVM_REG_PPC | KVM_REG_SIZE_U32 | 0xbb)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Transactional Memory checkpointed state:</span>
<span class="p_add">+ * This is all GPRs, all VSX regs and a subset of SPRs</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_REG_PPC_TM		(KVM_REG_PPC | 0x80000000)</span>
<span class="p_add">+/* TM GPRs */</span>
<span class="p_add">+#define KVM_REG_PPC_TM_GPR0	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_GPR(n)	(KVM_REG_PPC_TM_GPR0 + (n))</span>
<span class="p_add">+#define KVM_REG_PPC_TM_GPR31	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x1f)</span>
<span class="p_add">+/* TM VSX */</span>
<span class="p_add">+#define KVM_REG_PPC_TM_VSR0	(KVM_REG_PPC_TM | KVM_REG_SIZE_U128 | 0x20)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_VSR(n)	(KVM_REG_PPC_TM_VSR0 + (n))</span>
<span class="p_add">+#define KVM_REG_PPC_TM_VSR63	(KVM_REG_PPC_TM | KVM_REG_SIZE_U128 | 0x5f)</span>
<span class="p_add">+/* TM SPRS */</span>
<span class="p_add">+#define KVM_REG_PPC_TM_CR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x60)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_LR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x61)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_CTR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x62)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_FPSCR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x63)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_AMR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x64)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_PPR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x65)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_VRSAVE	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x66)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_VSCR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U32 | 0x67)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_DSCR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x68)</span>
<span class="p_add">+#define KVM_REG_PPC_TM_TAR	(KVM_REG_PPC_TM | KVM_REG_SIZE_U64 | 0x69)</span>
<span class="p_add">+</span>
<span class="p_add">+/* PPC64 eXternal Interrupt Controller Specification */</span>
<span class="p_add">+#define KVM_DEV_XICS_GRP_SOURCES	1	/* 64-bit source attributes */</span>
<span class="p_add">+</span>
<span class="p_add">+/* Layout of 64-bit source attribute values */</span>
<span class="p_add">+#define  KVM_XICS_DESTINATION_SHIFT	0</span>
<span class="p_add">+#define  KVM_XICS_DESTINATION_MASK	0xffffffffULL</span>
<span class="p_add">+#define  KVM_XICS_PRIORITY_SHIFT	32</span>
<span class="p_add">+#define  KVM_XICS_PRIORITY_MASK		0xff</span>
<span class="p_add">+#define  KVM_XICS_LEVEL_SENSITIVE	(1ULL &lt;&lt; 40)</span>
<span class="p_add">+#define  KVM_XICS_MASKED		(1ULL &lt;&lt; 41)</span>
<span class="p_add">+#define  KVM_XICS_PENDING		(1ULL &lt;&lt; 42)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __LINUX_KVM_POWERPC_H */</span>
<span class="p_header">diff --git a/tools/arch/s390/include/uapi/asm/kvm.h b/tools/arch/s390/include/uapi/asm/kvm.h</span>
new file mode 100644
<span class="p_header">index 000000000000..3b8e99ef9d58</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/s390/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -0,0 +1,192 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __LINUX_KVM_S390_H</span>
<span class="p_add">+#define __LINUX_KVM_S390_H</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM s390 specific structures and definitions</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright IBM Corp. 2008</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License (version 2 only)</span>
<span class="p_add">+ * as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *    Author(s): Carsten Otte &lt;cotte@de.ibm.com&gt;</span>
<span class="p_add">+ *               Christian Borntraeger &lt;borntraeger@de.ibm.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define __KVM_S390</span>
<span class="p_add">+#define __KVM_HAVE_GUEST_DEBUG</span>
<span class="p_add">+</span>
<span class="p_add">+/* Device control API: s390-specific devices */</span>
<span class="p_add">+#define KVM_DEV_FLIC_GET_ALL_IRQS	1</span>
<span class="p_add">+#define KVM_DEV_FLIC_ENQUEUE		2</span>
<span class="p_add">+#define KVM_DEV_FLIC_CLEAR_IRQS		3</span>
<span class="p_add">+#define KVM_DEV_FLIC_APF_ENABLE		4</span>
<span class="p_add">+#define KVM_DEV_FLIC_APF_DISABLE_WAIT	5</span>
<span class="p_add">+#define KVM_DEV_FLIC_ADAPTER_REGISTER	6</span>
<span class="p_add">+#define KVM_DEV_FLIC_ADAPTER_MODIFY	7</span>
<span class="p_add">+#define KVM_DEV_FLIC_CLEAR_IO_IRQ	8</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We can have up to 4*64k pending subchannels + 8 adapter interrupts,</span>
<span class="p_add">+ * as well as up  to ASYNC_PF_PER_VCPU*KVM_MAX_VCPUS pfault done interrupts.</span>
<span class="p_add">+ * There are also sclp and machine checks. This gives us</span>
<span class="p_add">+ * sizeof(kvm_s390_irq)*(4*65536+8+64*64+1+1) = 72 * 266250 = 19170000</span>
<span class="p_add">+ * Lets round up to 8192 pages.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define KVM_S390_MAX_FLOAT_IRQS	266250</span>
<span class="p_add">+#define KVM_S390_FLIC_MAX_BUFFER	0x2000000</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_s390_io_adapter {</span>
<span class="p_add">+	__u32 id;</span>
<span class="p_add">+	__u8 isc;</span>
<span class="p_add">+	__u8 maskable;</span>
<span class="p_add">+	__u8 swap;</span>
<span class="p_add">+	__u8 pad;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_S390_IO_ADAPTER_MASK 1</span>
<span class="p_add">+#define KVM_S390_IO_ADAPTER_MAP 2</span>
<span class="p_add">+#define KVM_S390_IO_ADAPTER_UNMAP 3</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_s390_io_adapter_req {</span>
<span class="p_add">+	__u32 id;</span>
<span class="p_add">+	__u8 type;</span>
<span class="p_add">+	__u8 mask;</span>
<span class="p_add">+	__u16 pad0;</span>
<span class="p_add">+	__u64 addr;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* kvm attr_group  on vm fd */</span>
<span class="p_add">+#define KVM_S390_VM_MEM_CTRL		0</span>
<span class="p_add">+#define KVM_S390_VM_TOD			1</span>
<span class="p_add">+#define KVM_S390_VM_CRYPTO		2</span>
<span class="p_add">+#define KVM_S390_VM_CPU_MODEL		3</span>
<span class="p_add">+</span>
<span class="p_add">+/* kvm attributes for mem_ctrl */</span>
<span class="p_add">+#define KVM_S390_VM_MEM_ENABLE_CMMA	0</span>
<span class="p_add">+#define KVM_S390_VM_MEM_CLR_CMMA	1</span>
<span class="p_add">+#define KVM_S390_VM_MEM_LIMIT_SIZE	2</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_S390_NO_MEM_LIMIT		U64_MAX</span>
<span class="p_add">+</span>
<span class="p_add">+/* kvm attributes for KVM_S390_VM_TOD */</span>
<span class="p_add">+#define KVM_S390_VM_TOD_LOW		0</span>
<span class="p_add">+#define KVM_S390_VM_TOD_HIGH		1</span>
<span class="p_add">+</span>
<span class="p_add">+/* kvm attributes for KVM_S390_VM_CPU_MODEL */</span>
<span class="p_add">+/* processor related attributes are r/w */</span>
<span class="p_add">+#define KVM_S390_VM_CPU_PROCESSOR	0</span>
<span class="p_add">+struct kvm_s390_vm_cpu_processor {</span>
<span class="p_add">+	__u64 cpuid;</span>
<span class="p_add">+	__u16 ibc;</span>
<span class="p_add">+	__u8  pad[6];</span>
<span class="p_add">+	__u64 fac_list[256];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* machine related attributes are r/o */</span>
<span class="p_add">+#define KVM_S390_VM_CPU_MACHINE		1</span>
<span class="p_add">+struct kvm_s390_vm_cpu_machine {</span>
<span class="p_add">+	__u64 cpuid;</span>
<span class="p_add">+	__u32 ibc;</span>
<span class="p_add">+	__u8  pad[4];</span>
<span class="p_add">+	__u64 fac_mask[256];</span>
<span class="p_add">+	__u64 fac_list[256];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* kvm attributes for crypto */</span>
<span class="p_add">+#define KVM_S390_VM_CRYPTO_ENABLE_AES_KW	0</span>
<span class="p_add">+#define KVM_S390_VM_CRYPTO_ENABLE_DEA_KW	1</span>
<span class="p_add">+#define KVM_S390_VM_CRYPTO_DISABLE_AES_KW	2</span>
<span class="p_add">+#define KVM_S390_VM_CRYPTO_DISABLE_DEA_KW	3</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_REGS and KVM_SET_REGS */</span>
<span class="p_add">+struct kvm_regs {</span>
<span class="p_add">+	/* general purpose regs for s390 */</span>
<span class="p_add">+	__u64 gprs[16];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_SREGS and KVM_SET_SREGS */</span>
<span class="p_add">+struct kvm_sregs {</span>
<span class="p_add">+	__u32 acrs[16];</span>
<span class="p_add">+	__u64 crs[16];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_FPU and KVM_SET_FPU */</span>
<span class="p_add">+struct kvm_fpu {</span>
<span class="p_add">+	__u32 fpc;</span>
<span class="p_add">+	__u64 fprs[16];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_GUESTDBG_USE_HW_BP		0x00010000</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_HW_BP			1</span>
<span class="p_add">+#define KVM_HW_WP_WRITE			2</span>
<span class="p_add">+#define KVM_SINGLESTEP			4</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_debug_exit_arch {</span>
<span class="p_add">+	__u64 addr;</span>
<span class="p_add">+	__u8 type;</span>
<span class="p_add">+	__u8 pad[7]; /* Should be set to 0 */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_hw_breakpoint {</span>
<span class="p_add">+	__u64 addr;</span>
<span class="p_add">+	__u64 phys_addr;</span>
<span class="p_add">+	__u64 len;</span>
<span class="p_add">+	__u8 type;</span>
<span class="p_add">+	__u8 pad[7]; /* Should be set to 0 */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_SET_GUEST_DEBUG */</span>
<span class="p_add">+struct kvm_guest_debug_arch {</span>
<span class="p_add">+	__u32 nr_hw_bp;</span>
<span class="p_add">+	__u32 pad; /* Should be set to 0 */</span>
<span class="p_add">+	struct kvm_hw_breakpoint __user *hw_bp;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_SYNC_PFAULT and KVM_REG_S390_PFTOKEN */</span>
<span class="p_add">+#define KVM_S390_PFAULT_TOKEN_INVALID	0xffffffffffffffffULL</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_SYNC_PREFIX (1UL &lt;&lt; 0)</span>
<span class="p_add">+#define KVM_SYNC_GPRS   (1UL &lt;&lt; 1)</span>
<span class="p_add">+#define KVM_SYNC_ACRS   (1UL &lt;&lt; 2)</span>
<span class="p_add">+#define KVM_SYNC_CRS    (1UL &lt;&lt; 3)</span>
<span class="p_add">+#define KVM_SYNC_ARCH0  (1UL &lt;&lt; 4)</span>
<span class="p_add">+#define KVM_SYNC_PFAULT (1UL &lt;&lt; 5)</span>
<span class="p_add">+#define KVM_SYNC_VRS    (1UL &lt;&lt; 6)</span>
<span class="p_add">+#define KVM_SYNC_RICCB  (1UL &lt;&lt; 7)</span>
<span class="p_add">+#define KVM_SYNC_FPRS   (1UL &lt;&lt; 8)</span>
<span class="p_add">+/* definition of registers in kvm_run */</span>
<span class="p_add">+struct kvm_sync_regs {</span>
<span class="p_add">+	__u64 prefix;	/* prefix register */</span>
<span class="p_add">+	__u64 gprs[16];	/* general purpose registers */</span>
<span class="p_add">+	__u32 acrs[16];	/* access registers */</span>
<span class="p_add">+	__u64 crs[16];	/* control registers */</span>
<span class="p_add">+	__u64 todpr;	/* tod programmable register [ARCH0] */</span>
<span class="p_add">+	__u64 cputm;	/* cpu timer [ARCH0] */</span>
<span class="p_add">+	__u64 ckc;	/* clock comparator [ARCH0] */</span>
<span class="p_add">+	__u64 pp;	/* program parameter [ARCH0] */</span>
<span class="p_add">+	__u64 gbea;	/* guest breaking-event address [ARCH0] */</span>
<span class="p_add">+	__u64 pft;	/* pfault token [PFAULT] */</span>
<span class="p_add">+	__u64 pfs;	/* pfault select [PFAULT] */</span>
<span class="p_add">+	__u64 pfc;	/* pfault compare [PFAULT] */</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		__u64 vrs[32][2];	/* vector registers (KVM_SYNC_VRS) */</span>
<span class="p_add">+		__u64 fprs[16];		/* fp registers (KVM_SYNC_FPRS) */</span>
<span class="p_add">+	};</span>
<span class="p_add">+	__u8  reserved[512];	/* for future vector expansion */</span>
<span class="p_add">+	__u32 fpc;		/* valid on KVM_SYNC_VRS or KVM_SYNC_FPRS */</span>
<span class="p_add">+	__u8 padding[52];	/* riccb needs to be 64byte aligned */</span>
<span class="p_add">+	__u8 riccb[64];		/* runtime instrumentation controls block */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_REG_S390_TODPR	(KVM_REG_S390 | KVM_REG_SIZE_U32 | 0x1)</span>
<span class="p_add">+#define KVM_REG_S390_EPOCHDIFF	(KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x2)</span>
<span class="p_add">+#define KVM_REG_S390_CPU_TIMER  (KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x3)</span>
<span class="p_add">+#define KVM_REG_S390_CLOCK_COMP (KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x4)</span>
<span class="p_add">+#define KVM_REG_S390_PFTOKEN	(KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x5)</span>
<span class="p_add">+#define KVM_REG_S390_PFCOMPARE	(KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x6)</span>
<span class="p_add">+#define KVM_REG_S390_PFSELECT	(KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x7)</span>
<span class="p_add">+#define KVM_REG_S390_PP		(KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x8)</span>
<span class="p_add">+#define KVM_REG_S390_GBEA	(KVM_REG_S390 | KVM_REG_SIZE_U64 | 0x9)</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/tools/arch/s390/include/uapi/asm/kvm_perf.h b/tools/arch/s390/include/uapi/asm/kvm_perf.h</span>
new file mode 100644
<span class="p_header">index 000000000000..397282727e21</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/s390/include/uapi/asm/kvm_perf.h</span>
<span class="p_chunk">@@ -0,0 +1,25 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Definitions for perf-kvm on s390</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright 2014 IBM Corp.</span>
<span class="p_add">+ * Author(s): Alexander Yarygin &lt;yarygin@linux.vnet.ibm.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License (version 2 only)</span>
<span class="p_add">+ * as published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __LINUX_KVM_PERF_S390_H</span>
<span class="p_add">+#define __LINUX_KVM_PERF_S390_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sie.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DECODE_STR_LEN 40</span>
<span class="p_add">+</span>
<span class="p_add">+#define VCPU_ID &quot;id&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_ENTRY_TRACE &quot;kvm:kvm_s390_sie_enter&quot;</span>
<span class="p_add">+#define KVM_EXIT_TRACE &quot;kvm:kvm_s390_sie_exit&quot;</span>
<span class="p_add">+#define KVM_EXIT_REASON &quot;icptcode&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/tools/arch/s390/include/uapi/asm/sie.h b/tools/arch/s390/include/uapi/asm/sie.h</span>
new file mode 100644
<span class="p_header">index 000000000000..8fb5d4a6dd25</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/s390/include/uapi/asm/sie.h</span>
<span class="p_chunk">@@ -0,0 +1,250 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _UAPI_ASM_S390_SIE_H</span>
<span class="p_add">+#define _UAPI_ASM_S390_SIE_H</span>
<span class="p_add">+</span>
<span class="p_add">+#define diagnose_codes						\</span>
<span class="p_add">+	{ 0x10, &quot;DIAG (0x10) release pages&quot; },			\</span>
<span class="p_add">+	{ 0x44, &quot;DIAG (0x44) time slice end&quot; },			\</span>
<span class="p_add">+	{ 0x9c, &quot;DIAG (0x9c) time slice end directed&quot; },	\</span>
<span class="p_add">+	{ 0x204, &quot;DIAG (0x204) logical-cpu utilization&quot; },	\</span>
<span class="p_add">+	{ 0x258, &quot;DIAG (0x258) page-reference services&quot; },	\</span>
<span class="p_add">+	{ 0x288, &quot;DIAG (0x288) watchdog functions&quot; },		\</span>
<span class="p_add">+	{ 0x308, &quot;DIAG (0x308) ipl functions&quot; },		\</span>
<span class="p_add">+	{ 0x500, &quot;DIAG (0x500) KVM virtio functions&quot; },		\</span>
<span class="p_add">+	{ 0x501, &quot;DIAG (0x501) KVM breakpoint&quot; }</span>
<span class="p_add">+</span>
<span class="p_add">+#define sigp_order_codes					\</span>
<span class="p_add">+	{ 0x01, &quot;SIGP sense&quot; },					\</span>
<span class="p_add">+	{ 0x02, &quot;SIGP external call&quot; },				\</span>
<span class="p_add">+	{ 0x03, &quot;SIGP emergency signal&quot; },			\</span>
<span class="p_add">+	{ 0x04, &quot;SIGP start&quot; },					\</span>
<span class="p_add">+	{ 0x05, &quot;SIGP stop&quot; },					\</span>
<span class="p_add">+	{ 0x06, &quot;SIGP restart&quot; },				\</span>
<span class="p_add">+	{ 0x09, &quot;SIGP stop and store status&quot; },			\</span>
<span class="p_add">+	{ 0x0b, &quot;SIGP initial cpu reset&quot; },			\</span>
<span class="p_add">+	{ 0x0c, &quot;SIGP cpu reset&quot; },				\</span>
<span class="p_add">+	{ 0x0d, &quot;SIGP set prefix&quot; },				\</span>
<span class="p_add">+	{ 0x0e, &quot;SIGP store status at address&quot; },		\</span>
<span class="p_add">+	{ 0x12, &quot;SIGP set architecture&quot; },			\</span>
<span class="p_add">+	{ 0x13, &quot;SIGP conditional emergency signal&quot; },		\</span>
<span class="p_add">+	{ 0x15, &quot;SIGP sense running&quot; },				\</span>
<span class="p_add">+	{ 0x16, &quot;SIGP set multithreading&quot;},			\</span>
<span class="p_add">+	{ 0x17, &quot;SIGP store additional status ait address&quot;}</span>
<span class="p_add">+</span>
<span class="p_add">+#define icpt_prog_codes						\</span>
<span class="p_add">+	{ 0x0001, &quot;Prog Operation&quot; },				\</span>
<span class="p_add">+	{ 0x0002, &quot;Prog Privileged Operation&quot; },		\</span>
<span class="p_add">+	{ 0x0003, &quot;Prog Execute&quot; },				\</span>
<span class="p_add">+	{ 0x0004, &quot;Prog Protection&quot; },				\</span>
<span class="p_add">+	{ 0x0005, &quot;Prog Addressing&quot; },				\</span>
<span class="p_add">+	{ 0x0006, &quot;Prog Specification&quot; },			\</span>
<span class="p_add">+	{ 0x0007, &quot;Prog Data&quot; },				\</span>
<span class="p_add">+	{ 0x0008, &quot;Prog Fixedpoint overflow&quot; },			\</span>
<span class="p_add">+	{ 0x0009, &quot;Prog Fixedpoint divide&quot; },			\</span>
<span class="p_add">+	{ 0x000A, &quot;Prog Decimal overflow&quot; },			\</span>
<span class="p_add">+	{ 0x000B, &quot;Prog Decimal divide&quot; },			\</span>
<span class="p_add">+	{ 0x000C, &quot;Prog HFP exponent overflow&quot; },		\</span>
<span class="p_add">+	{ 0x000D, &quot;Prog HFP exponent underflow&quot; },		\</span>
<span class="p_add">+	{ 0x000E, &quot;Prog HFP significance&quot; },			\</span>
<span class="p_add">+	{ 0x000F, &quot;Prog HFP divide&quot; },				\</span>
<span class="p_add">+	{ 0x0010, &quot;Prog Segment translation&quot; },			\</span>
<span class="p_add">+	{ 0x0011, &quot;Prog Page translation&quot; },			\</span>
<span class="p_add">+	{ 0x0012, &quot;Prog Translation specification&quot; },		\</span>
<span class="p_add">+	{ 0x0013, &quot;Prog Special operation&quot; },			\</span>
<span class="p_add">+	{ 0x0015, &quot;Prog Operand&quot; },				\</span>
<span class="p_add">+	{ 0x0016, &quot;Prog Trace table&quot; },				\</span>
<span class="p_add">+	{ 0x0017, &quot;Prog ASNtranslation specification&quot; },	\</span>
<span class="p_add">+	{ 0x001C, &quot;Prog Spaceswitch event&quot; },			\</span>
<span class="p_add">+	{ 0x001D, &quot;Prog HFP square root&quot; },			\</span>
<span class="p_add">+	{ 0x001F, &quot;Prog PCtranslation specification&quot; },		\</span>
<span class="p_add">+	{ 0x0020, &quot;Prog AFX translation&quot; },			\</span>
<span class="p_add">+	{ 0x0021, &quot;Prog ASX translation&quot; },			\</span>
<span class="p_add">+	{ 0x0022, &quot;Prog LX translation&quot; },			\</span>
<span class="p_add">+	{ 0x0023, &quot;Prog EX translation&quot; },			\</span>
<span class="p_add">+	{ 0x0024, &quot;Prog Primary authority&quot; },			\</span>
<span class="p_add">+	{ 0x0025, &quot;Prog Secondary authority&quot; },			\</span>
<span class="p_add">+	{ 0x0026, &quot;Prog LFXtranslation exception&quot; },		\</span>
<span class="p_add">+	{ 0x0027, &quot;Prog LSXtranslation exception&quot; },		\</span>
<span class="p_add">+	{ 0x0028, &quot;Prog ALET specification&quot; },			\</span>
<span class="p_add">+	{ 0x0029, &quot;Prog ALEN translation&quot; },			\</span>
<span class="p_add">+	{ 0x002A, &quot;Prog ALE sequence&quot; },			\</span>
<span class="p_add">+	{ 0x002B, &quot;Prog ASTE validity&quot; },			\</span>
<span class="p_add">+	{ 0x002C, &quot;Prog ASTE sequence&quot; },			\</span>
<span class="p_add">+	{ 0x002D, &quot;Prog Extended authority&quot; },			\</span>
<span class="p_add">+	{ 0x002E, &quot;Prog LSTE sequence&quot; },			\</span>
<span class="p_add">+	{ 0x002F, &quot;Prog ASTE instance&quot; },			\</span>
<span class="p_add">+	{ 0x0030, &quot;Prog Stack full&quot; },				\</span>
<span class="p_add">+	{ 0x0031, &quot;Prog Stack empty&quot; },				\</span>
<span class="p_add">+	{ 0x0032, &quot;Prog Stack specification&quot; },			\</span>
<span class="p_add">+	{ 0x0033, &quot;Prog Stack type&quot; },				\</span>
<span class="p_add">+	{ 0x0034, &quot;Prog Stack operation&quot; },			\</span>
<span class="p_add">+	{ 0x0039, &quot;Prog Region first translation&quot; },		\</span>
<span class="p_add">+	{ 0x003A, &quot;Prog Region second translation&quot; },		\</span>
<span class="p_add">+	{ 0x003B, &quot;Prog Region third translation&quot; },		\</span>
<span class="p_add">+	{ 0x0040, &quot;Prog Monitor event&quot; },			\</span>
<span class="p_add">+	{ 0x0080, &quot;Prog PER event&quot; },				\</span>
<span class="p_add">+	{ 0x0119, &quot;Prog Crypto operation&quot; }</span>
<span class="p_add">+</span>
<span class="p_add">+#define exit_code_ipa0(ipa0, opcode, mnemonic)		\</span>
<span class="p_add">+	{ (ipa0 &lt;&lt; 8 | opcode), #ipa0 &quot; &quot; mnemonic }</span>
<span class="p_add">+#define exit_code(opcode, mnemonic)			\</span>
<span class="p_add">+	{ opcode, mnemonic }</span>
<span class="p_add">+</span>
<span class="p_add">+#define icpt_insn_codes				\</span>
<span class="p_add">+	exit_code_ipa0(0x01, 0x01, &quot;PR&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0x01, 0x04, &quot;PTFF&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0x01, 0x07, &quot;SCKPF&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xAA, 0x00, &quot;RINEXT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xAA, 0x01, &quot;RION&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xAA, 0x02, &quot;TRIC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xAA, 0x03, &quot;RIOFF&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xAA, 0x04, &quot;RIEMIT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x02, &quot;STIDP&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x04, &quot;SCK&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x05, &quot;STCK&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x06, &quot;SCKC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x07, &quot;STCKC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x08, &quot;SPT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x09, &quot;STPT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x0d, &quot;PTLB&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x10, &quot;SPX&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x11, &quot;STPX&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x12, &quot;STAP&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x14, &quot;SIE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x16, &quot;SETR&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x17, &quot;STETR&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x18, &quot;PC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x20, &quot;SERVC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x21, &quot;IPTE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x28, &quot;PT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x29, &quot;ISKE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x2a, &quot;RRBE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x2b, &quot;SSKE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x2c, &quot;TB&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x2e, &quot;PGIN&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x2f, &quot;PGOUT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x30, &quot;CSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x31, &quot;HSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x32, &quot;MSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x33, &quot;SSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x34, &quot;STSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x35, &quot;TSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x36, &quot;TPI&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x37, &quot;SAL&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x38, &quot;RSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x39, &quot;STCRW&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x3a, &quot;STCPS&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x3b, &quot;RCHP&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x3c, &quot;SCHM&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x40, &quot;BAKR&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x48, &quot;PALB&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x4c, &quot;TAR&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x50, &quot;CSP&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x54, &quot;MVPG&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x58, &quot;BSG&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x5a, &quot;BSA&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x5f, &quot;CHSC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x74, &quot;SIGA&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x76, &quot;XSCH&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x78, &quot;STCKE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x7c, &quot;STCKF&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0x7d, &quot;STSI&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0xb0, &quot;STFLE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0xb1, &quot;STFL&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0xb2, &quot;LPSWE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0xf8, &quot;TEND&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB2, 0xfc, &quot;TABORT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x1e, &quot;KMAC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x28, &quot;PCKMO&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x2a, &quot;KMF&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x2b, &quot;KMO&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x2d, &quot;KMCTR&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x2e, &quot;KM&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x2f, &quot;KMC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x3e, &quot;KIMD&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x3f, &quot;KLMD&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x8a, &quot;CSPG&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x8d, &quot;EPSW&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x8e, &quot;IDTE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x8f, &quot;CRDTE&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0x9c, &quot;EQBS&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0xa2, &quot;PTF&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0xab, &quot;ESSA&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0xae, &quot;RRBM&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xB9, 0xaf, &quot;PFMF&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xE3, 0x03, &quot;LRAG&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xE3, 0x13, &quot;LRAY&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xE3, 0x25, &quot;NTSTG&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xE5, 0x00, &quot;LASP&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xE5, 0x01, &quot;TPROT&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xE5, 0x60, &quot;TBEGIN&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xE5, 0x61, &quot;TBEGINC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xEB, 0x25, &quot;STCTG&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xEB, 0x2f, &quot;LCTLG&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xEB, 0x60, &quot;LRIC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xEB, 0x61, &quot;STRIC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xEB, 0x62, &quot;MRIC&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xEB, 0x8a, &quot;SQBS&quot;),	\</span>
<span class="p_add">+	exit_code_ipa0(0xC8, 0x01, &quot;ECTG&quot;),	\</span>
<span class="p_add">+	exit_code(0x0a, &quot;SVC&quot;),			\</span>
<span class="p_add">+	exit_code(0x80, &quot;SSM&quot;),			\</span>
<span class="p_add">+	exit_code(0x82, &quot;LPSW&quot;),		\</span>
<span class="p_add">+	exit_code(0x83, &quot;DIAG&quot;),		\</span>
<span class="p_add">+	exit_code(0xae, &quot;SIGP&quot;),		\</span>
<span class="p_add">+	exit_code(0xac, &quot;STNSM&quot;),		\</span>
<span class="p_add">+	exit_code(0xad, &quot;STOSM&quot;),		\</span>
<span class="p_add">+	exit_code(0xb1, &quot;LRA&quot;),			\</span>
<span class="p_add">+	exit_code(0xb6, &quot;STCTL&quot;),		\</span>
<span class="p_add">+	exit_code(0xb7, &quot;LCTL&quot;),		\</span>
<span class="p_add">+	exit_code(0xee, &quot;PLO&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+#define sie_intercept_code					\</span>
<span class="p_add">+	{ 0x00, &quot;Host interruption&quot; },				\</span>
<span class="p_add">+	{ 0x04, &quot;Instruction&quot; },				\</span>
<span class="p_add">+	{ 0x08, &quot;Program interruption&quot; },			\</span>
<span class="p_add">+	{ 0x0c, &quot;Instruction and program interruption&quot; },	\</span>
<span class="p_add">+	{ 0x10, &quot;External request&quot; },				\</span>
<span class="p_add">+	{ 0x14, &quot;External interruption&quot; },			\</span>
<span class="p_add">+	{ 0x18, &quot;I/O request&quot; },				\</span>
<span class="p_add">+	{ 0x1c, &quot;Wait state&quot; },					\</span>
<span class="p_add">+	{ 0x20, &quot;Validity&quot; },					\</span>
<span class="p_add">+	{ 0x28, &quot;Stop request&quot; },				\</span>
<span class="p_add">+	{ 0x2c, &quot;Operation exception&quot; },			\</span>
<span class="p_add">+	{ 0x38, &quot;Partial-execution&quot; },				\</span>
<span class="p_add">+	{ 0x3c, &quot;I/O interruption&quot; },				\</span>
<span class="p_add">+	{ 0x40, &quot;I/O instruction&quot; },				\</span>
<span class="p_add">+	{ 0x48, &quot;Timing subset&quot; }</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is the simple interceptable instructions decoder.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It will be used as userspace interface and it can be used in places</span>
<span class="p_add">+ * that does not allow to use general decoder functions,</span>
<span class="p_add">+ * such as trace events declarations.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Some userspace tools may want to parse this code</span>
<span class="p_add">+ * and would be confused by switch(), if() and other statements,</span>
<span class="p_add">+ * but they can understand conditional operator.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define INSN_DECODE_IPA0(ipa0, insn, rshift, mask)		\</span>
<span class="p_add">+	(insn &gt;&gt; 56) == (ipa0) ?				\</span>
<span class="p_add">+		((ipa0 &lt;&lt; 8) | ((insn &gt;&gt; rshift) &amp; mask)) :</span>
<span class="p_add">+</span>
<span class="p_add">+#define INSN_DECODE(insn) (insn &gt;&gt; 56)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The macro icpt_insn_decoder() takes an intercepted instruction</span>
<span class="p_add">+ * and returns a key, which can be used to find a mnemonic name</span>
<span class="p_add">+ * of the instruction in the icpt_insn_codes table.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define icpt_insn_decoder(insn) (		\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0x01, insn, 48, 0xff)	\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0xaa, insn, 48, 0x0f)	\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0xb2, insn, 48, 0xff)	\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0xb9, insn, 48, 0xff)	\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0xe3, insn, 48, 0xff)	\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0xe5, insn, 48, 0xff)	\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0xeb, insn, 16, 0xff)	\</span>
<span class="p_add">+	INSN_DECODE_IPA0(0xc8, insn, 48, 0x0f)	\</span>
<span class="p_add">+	INSN_DECODE(insn))</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _UAPI_ASM_S390_SIE_H */</span>
<span class="p_header">diff --git a/tools/arch/x86/include/uapi/asm/kvm.h b/tools/arch/x86/include/uapi/asm/kvm.h</span>
new file mode 100644
<span class="p_header">index 000000000000..739c0c594022</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/x86/include/uapi/asm/kvm.h</span>
<span class="p_chunk">@@ -0,0 +1,360 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_X86_KVM_H</span>
<span class="p_add">+#define _ASM_X86_KVM_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * KVM x86 specific structures and definitions</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;linux/ioctl.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DE_VECTOR 0</span>
<span class="p_add">+#define DB_VECTOR 1</span>
<span class="p_add">+#define BP_VECTOR 3</span>
<span class="p_add">+#define OF_VECTOR 4</span>
<span class="p_add">+#define BR_VECTOR 5</span>
<span class="p_add">+#define UD_VECTOR 6</span>
<span class="p_add">+#define NM_VECTOR 7</span>
<span class="p_add">+#define DF_VECTOR 8</span>
<span class="p_add">+#define TS_VECTOR 10</span>
<span class="p_add">+#define NP_VECTOR 11</span>
<span class="p_add">+#define SS_VECTOR 12</span>
<span class="p_add">+#define GP_VECTOR 13</span>
<span class="p_add">+#define PF_VECTOR 14</span>
<span class="p_add">+#define MF_VECTOR 16</span>
<span class="p_add">+#define AC_VECTOR 17</span>
<span class="p_add">+#define MC_VECTOR 18</span>
<span class="p_add">+#define XM_VECTOR 19</span>
<span class="p_add">+#define VE_VECTOR 20</span>
<span class="p_add">+</span>
<span class="p_add">+/* Select x86 specific features in &lt;linux/kvm.h&gt; */</span>
<span class="p_add">+#define __KVM_HAVE_PIT</span>
<span class="p_add">+#define __KVM_HAVE_IOAPIC</span>
<span class="p_add">+#define __KVM_HAVE_IRQ_LINE</span>
<span class="p_add">+#define __KVM_HAVE_MSI</span>
<span class="p_add">+#define __KVM_HAVE_USER_NMI</span>
<span class="p_add">+#define __KVM_HAVE_GUEST_DEBUG</span>
<span class="p_add">+#define __KVM_HAVE_MSIX</span>
<span class="p_add">+#define __KVM_HAVE_MCE</span>
<span class="p_add">+#define __KVM_HAVE_PIT_STATE2</span>
<span class="p_add">+#define __KVM_HAVE_XEN_HVM</span>
<span class="p_add">+#define __KVM_HAVE_VCPU_EVENTS</span>
<span class="p_add">+#define __KVM_HAVE_DEBUGREGS</span>
<span class="p_add">+#define __KVM_HAVE_XSAVE</span>
<span class="p_add">+#define __KVM_HAVE_XCRS</span>
<span class="p_add">+#define __KVM_HAVE_READONLY_MEM</span>
<span class="p_add">+</span>
<span class="p_add">+/* Architectural interrupt line count. */</span>
<span class="p_add">+#define KVM_NR_INTERRUPTS 256</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_memory_alias {</span>
<span class="p_add">+	__u32 slot;  /* this has a different namespace than memory slots */</span>
<span class="p_add">+	__u32 flags;</span>
<span class="p_add">+	__u64 guest_phys_addr;</span>
<span class="p_add">+	__u64 memory_size;</span>
<span class="p_add">+	__u64 target_phys_addr;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_IRQCHIP and KVM_SET_IRQCHIP */</span>
<span class="p_add">+struct kvm_pic_state {</span>
<span class="p_add">+	__u8 last_irr;	/* edge detection */</span>
<span class="p_add">+	__u8 irr;		/* interrupt request register */</span>
<span class="p_add">+	__u8 imr;		/* interrupt mask register */</span>
<span class="p_add">+	__u8 isr;		/* interrupt service register */</span>
<span class="p_add">+	__u8 priority_add;	/* highest irq priority */</span>
<span class="p_add">+	__u8 irq_base;</span>
<span class="p_add">+	__u8 read_reg_select;</span>
<span class="p_add">+	__u8 poll;</span>
<span class="p_add">+	__u8 special_mask;</span>
<span class="p_add">+	__u8 init_state;</span>
<span class="p_add">+	__u8 auto_eoi;</span>
<span class="p_add">+	__u8 rotate_on_auto_eoi;</span>
<span class="p_add">+	__u8 special_fully_nested_mode;</span>
<span class="p_add">+	__u8 init4;		/* true if 4 byte init */</span>
<span class="p_add">+	__u8 elcr;		/* PIIX edge/trigger selection */</span>
<span class="p_add">+	__u8 elcr_mask;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_IOAPIC_NUM_PINS  24</span>
<span class="p_add">+struct kvm_ioapic_state {</span>
<span class="p_add">+	__u64 base_address;</span>
<span class="p_add">+	__u32 ioregsel;</span>
<span class="p_add">+	__u32 id;</span>
<span class="p_add">+	__u32 irr;</span>
<span class="p_add">+	__u32 pad;</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		__u64 bits;</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			__u8 vector;</span>
<span class="p_add">+			__u8 delivery_mode:3;</span>
<span class="p_add">+			__u8 dest_mode:1;</span>
<span class="p_add">+			__u8 delivery_status:1;</span>
<span class="p_add">+			__u8 polarity:1;</span>
<span class="p_add">+			__u8 remote_irr:1;</span>
<span class="p_add">+			__u8 trig_mode:1;</span>
<span class="p_add">+			__u8 mask:1;</span>
<span class="p_add">+			__u8 reserve:7;</span>
<span class="p_add">+			__u8 reserved[4];</span>
<span class="p_add">+			__u8 dest_id;</span>
<span class="p_add">+		} fields;</span>
<span class="p_add">+	} redirtbl[KVM_IOAPIC_NUM_PINS];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_IRQCHIP_PIC_MASTER   0</span>
<span class="p_add">+#define KVM_IRQCHIP_PIC_SLAVE    1</span>
<span class="p_add">+#define KVM_IRQCHIP_IOAPIC       2</span>
<span class="p_add">+#define KVM_NR_IRQCHIPS          3</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_RUN_X86_SMM		 (1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_REGS and KVM_SET_REGS */</span>
<span class="p_add">+struct kvm_regs {</span>
<span class="p_add">+	/* out (KVM_GET_REGS) / in (KVM_SET_REGS) */</span>
<span class="p_add">+	__u64 rax, rbx, rcx, rdx;</span>
<span class="p_add">+	__u64 rsi, rdi, rsp, rbp;</span>
<span class="p_add">+	__u64 r8,  r9,  r10, r11;</span>
<span class="p_add">+	__u64 r12, r13, r14, r15;</span>
<span class="p_add">+	__u64 rip, rflags;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_LAPIC and KVM_SET_LAPIC */</span>
<span class="p_add">+#define KVM_APIC_REG_SIZE 0x400</span>
<span class="p_add">+struct kvm_lapic_state {</span>
<span class="p_add">+	char regs[KVM_APIC_REG_SIZE];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_segment {</span>
<span class="p_add">+	__u64 base;</span>
<span class="p_add">+	__u32 limit;</span>
<span class="p_add">+	__u16 selector;</span>
<span class="p_add">+	__u8  type;</span>
<span class="p_add">+	__u8  present, dpl, db, s, l, g, avl;</span>
<span class="p_add">+	__u8  unusable;</span>
<span class="p_add">+	__u8  padding;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_dtable {</span>
<span class="p_add">+	__u64 base;</span>
<span class="p_add">+	__u16 limit;</span>
<span class="p_add">+	__u16 padding[3];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_SREGS and KVM_SET_SREGS */</span>
<span class="p_add">+struct kvm_sregs {</span>
<span class="p_add">+	/* out (KVM_GET_SREGS) / in (KVM_SET_SREGS) */</span>
<span class="p_add">+	struct kvm_segment cs, ds, es, fs, gs, ss;</span>
<span class="p_add">+	struct kvm_segment tr, ldt;</span>
<span class="p_add">+	struct kvm_dtable gdt, idt;</span>
<span class="p_add">+	__u64 cr0, cr2, cr3, cr4, cr8;</span>
<span class="p_add">+	__u64 efer;</span>
<span class="p_add">+	__u64 apic_base;</span>
<span class="p_add">+	__u64 interrupt_bitmap[(KVM_NR_INTERRUPTS + 63) / 64];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_FPU and KVM_SET_FPU */</span>
<span class="p_add">+struct kvm_fpu {</span>
<span class="p_add">+	__u8  fpr[8][16];</span>
<span class="p_add">+	__u16 fcw;</span>
<span class="p_add">+	__u16 fsw;</span>
<span class="p_add">+	__u8  ftwx;  /* in fxsave format */</span>
<span class="p_add">+	__u8  pad1;</span>
<span class="p_add">+	__u16 last_opcode;</span>
<span class="p_add">+	__u64 last_ip;</span>
<span class="p_add">+	__u64 last_dp;</span>
<span class="p_add">+	__u8  xmm[16][16];</span>
<span class="p_add">+	__u32 mxcsr;</span>
<span class="p_add">+	__u32 pad2;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_msr_entry {</span>
<span class="p_add">+	__u32 index;</span>
<span class="p_add">+	__u32 reserved;</span>
<span class="p_add">+	__u64 data;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_MSRS and KVM_SET_MSRS */</span>
<span class="p_add">+struct kvm_msrs {</span>
<span class="p_add">+	__u32 nmsrs; /* number of msrs in entries */</span>
<span class="p_add">+	__u32 pad;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct kvm_msr_entry entries[0];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_MSR_INDEX_LIST */</span>
<span class="p_add">+struct kvm_msr_list {</span>
<span class="p_add">+	__u32 nmsrs; /* number of msrs in entries */</span>
<span class="p_add">+	__u32 indices[0];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_cpuid_entry {</span>
<span class="p_add">+	__u32 function;</span>
<span class="p_add">+	__u32 eax;</span>
<span class="p_add">+	__u32 ebx;</span>
<span class="p_add">+	__u32 ecx;</span>
<span class="p_add">+	__u32 edx;</span>
<span class="p_add">+	__u32 padding;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_SET_CPUID */</span>
<span class="p_add">+struct kvm_cpuid {</span>
<span class="p_add">+	__u32 nent;</span>
<span class="p_add">+	__u32 padding;</span>
<span class="p_add">+	struct kvm_cpuid_entry entries[0];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_cpuid_entry2 {</span>
<span class="p_add">+	__u32 function;</span>
<span class="p_add">+	__u32 index;</span>
<span class="p_add">+	__u32 flags;</span>
<span class="p_add">+	__u32 eax;</span>
<span class="p_add">+	__u32 ebx;</span>
<span class="p_add">+	__u32 ecx;</span>
<span class="p_add">+	__u32 edx;</span>
<span class="p_add">+	__u32 padding[3];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_CPUID_FLAG_SIGNIFCANT_INDEX		(1 &lt;&lt; 0)</span>
<span class="p_add">+#define KVM_CPUID_FLAG_STATEFUL_FUNC		(1 &lt;&lt; 1)</span>
<span class="p_add">+#define KVM_CPUID_FLAG_STATE_READ_NEXT		(1 &lt;&lt; 2)</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_SET_CPUID2 */</span>
<span class="p_add">+struct kvm_cpuid2 {</span>
<span class="p_add">+	__u32 nent;</span>
<span class="p_add">+	__u32 padding;</span>
<span class="p_add">+	struct kvm_cpuid_entry2 entries[0];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET_PIT and KVM_SET_PIT */</span>
<span class="p_add">+struct kvm_pit_channel_state {</span>
<span class="p_add">+	__u32 count; /* can be 65536 */</span>
<span class="p_add">+	__u16 latched_count;</span>
<span class="p_add">+	__u8 count_latched;</span>
<span class="p_add">+	__u8 status_latched;</span>
<span class="p_add">+	__u8 status;</span>
<span class="p_add">+	__u8 read_state;</span>
<span class="p_add">+	__u8 write_state;</span>
<span class="p_add">+	__u8 write_latch;</span>
<span class="p_add">+	__u8 rw_mode;</span>
<span class="p_add">+	__u8 mode;</span>
<span class="p_add">+	__u8 bcd;</span>
<span class="p_add">+	__u8 gate;</span>
<span class="p_add">+	__s64 count_load_time;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_debug_exit_arch {</span>
<span class="p_add">+	__u32 exception;</span>
<span class="p_add">+	__u32 pad;</span>
<span class="p_add">+	__u64 pc;</span>
<span class="p_add">+	__u64 dr6;</span>
<span class="p_add">+	__u64 dr7;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_GUESTDBG_USE_SW_BP		0x00010000</span>
<span class="p_add">+#define KVM_GUESTDBG_USE_HW_BP		0x00020000</span>
<span class="p_add">+#define KVM_GUESTDBG_INJECT_DB		0x00040000</span>
<span class="p_add">+#define KVM_GUESTDBG_INJECT_BP		0x00080000</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_SET_GUEST_DEBUG */</span>
<span class="p_add">+struct kvm_guest_debug_arch {</span>
<span class="p_add">+	__u64 debugreg[8];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_pit_state {</span>
<span class="p_add">+	struct kvm_pit_channel_state channels[3];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_PIT_FLAGS_HPET_LEGACY  0x00000001</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_pit_state2 {</span>
<span class="p_add">+	struct kvm_pit_channel_state channels[3];</span>
<span class="p_add">+	__u32 flags;</span>
<span class="p_add">+	__u32 reserved[9];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_reinject_control {</span>
<span class="p_add">+	__u8 pit_reinject;</span>
<span class="p_add">+	__u8 reserved[31];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* When set in flags, include corresponding fields on KVM_SET_VCPU_EVENTS */</span>
<span class="p_add">+#define KVM_VCPUEVENT_VALID_NMI_PENDING	0x00000001</span>
<span class="p_add">+#define KVM_VCPUEVENT_VALID_SIPI_VECTOR	0x00000002</span>
<span class="p_add">+#define KVM_VCPUEVENT_VALID_SHADOW	0x00000004</span>
<span class="p_add">+#define KVM_VCPUEVENT_VALID_SMM		0x00000008</span>
<span class="p_add">+</span>
<span class="p_add">+/* Interrupt shadow states */</span>
<span class="p_add">+#define KVM_X86_SHADOW_INT_MOV_SS	0x01</span>
<span class="p_add">+#define KVM_X86_SHADOW_INT_STI		0x02</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET/SET_VCPU_EVENTS */</span>
<span class="p_add">+struct kvm_vcpu_events {</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		__u8 injected;</span>
<span class="p_add">+		__u8 nr;</span>
<span class="p_add">+		__u8 has_error_code;</span>
<span class="p_add">+		__u8 pad;</span>
<span class="p_add">+		__u32 error_code;</span>
<span class="p_add">+	} exception;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		__u8 injected;</span>
<span class="p_add">+		__u8 nr;</span>
<span class="p_add">+		__u8 soft;</span>
<span class="p_add">+		__u8 shadow;</span>
<span class="p_add">+	} interrupt;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		__u8 injected;</span>
<span class="p_add">+		__u8 pending;</span>
<span class="p_add">+		__u8 masked;</span>
<span class="p_add">+		__u8 pad;</span>
<span class="p_add">+	} nmi;</span>
<span class="p_add">+	__u32 sipi_vector;</span>
<span class="p_add">+	__u32 flags;</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		__u8 smm;</span>
<span class="p_add">+		__u8 pending;</span>
<span class="p_add">+		__u8 smm_inside_nmi;</span>
<span class="p_add">+		__u8 latched_init;</span>
<span class="p_add">+	} smi;</span>
<span class="p_add">+	__u32 reserved[9];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_GET/SET_DEBUGREGS */</span>
<span class="p_add">+struct kvm_debugregs {</span>
<span class="p_add">+	__u64 db[4];</span>
<span class="p_add">+	__u64 dr6;</span>
<span class="p_add">+	__u64 dr7;</span>
<span class="p_add">+	__u64 flags;</span>
<span class="p_add">+	__u64 reserved[9];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* for KVM_CAP_XSAVE */</span>
<span class="p_add">+struct kvm_xsave {</span>
<span class="p_add">+	__u32 region[1024];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_MAX_XCRS	16</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_xcr {</span>
<span class="p_add">+	__u32 xcr;</span>
<span class="p_add">+	__u32 reserved;</span>
<span class="p_add">+	__u64 value;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct kvm_xcrs {</span>
<span class="p_add">+	__u32 nr_xcrs;</span>
<span class="p_add">+	__u32 flags;</span>
<span class="p_add">+	struct kvm_xcr xcrs[KVM_MAX_XCRS];</span>
<span class="p_add">+	__u64 padding[16];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* definition of registers in kvm_run */</span>
<span class="p_add">+struct kvm_sync_regs {</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_X86_QUIRK_LINT0_REENABLED	(1 &lt;&lt; 0)</span>
<span class="p_add">+#define KVM_X86_QUIRK_CD_NW_CLEARED	(1 &lt;&lt; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_X86_KVM_H */</span>
<span class="p_header">diff --git a/tools/arch/x86/include/uapi/asm/kvm_perf.h b/tools/arch/x86/include/uapi/asm/kvm_perf.h</span>
new file mode 100644
<span class="p_header">index 000000000000..3bb964f88aa1</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/x86/include/uapi/asm/kvm_perf.h</span>
<span class="p_chunk">@@ -0,0 +1,16 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_X86_KVM_PERF_H</span>
<span class="p_add">+#define _ASM_X86_KVM_PERF_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/svm.h&gt;</span>
<span class="p_add">+#include &lt;asm/vmx.h&gt;</span>
<span class="p_add">+#include &lt;asm/kvm.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DECODE_STR_LEN 20</span>
<span class="p_add">+</span>
<span class="p_add">+#define VCPU_ID &quot;vcpu_id&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_ENTRY_TRACE &quot;kvm:kvm_entry&quot;</span>
<span class="p_add">+#define KVM_EXIT_TRACE &quot;kvm:kvm_exit&quot;</span>
<span class="p_add">+#define KVM_EXIT_REASON &quot;exit_reason&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_X86_KVM_PERF_H */</span>
<span class="p_header">diff --git a/tools/arch/x86/include/uapi/asm/svm.h b/tools/arch/x86/include/uapi/asm/svm.h</span>
new file mode 100644
<span class="p_header">index 000000000000..3725e145aa58</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/x86/include/uapi/asm/svm.h</span>
<span class="p_chunk">@@ -0,0 +1,178 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _UAPI__SVM_H</span>
<span class="p_add">+#define _UAPI__SVM_H</span>
<span class="p_add">+</span>
<span class="p_add">+#define SVM_EXIT_READ_CR0      0x000</span>
<span class="p_add">+#define SVM_EXIT_READ_CR2      0x002</span>
<span class="p_add">+#define SVM_EXIT_READ_CR3      0x003</span>
<span class="p_add">+#define SVM_EXIT_READ_CR4      0x004</span>
<span class="p_add">+#define SVM_EXIT_READ_CR8      0x008</span>
<span class="p_add">+#define SVM_EXIT_WRITE_CR0     0x010</span>
<span class="p_add">+#define SVM_EXIT_WRITE_CR2     0x012</span>
<span class="p_add">+#define SVM_EXIT_WRITE_CR3     0x013</span>
<span class="p_add">+#define SVM_EXIT_WRITE_CR4     0x014</span>
<span class="p_add">+#define SVM_EXIT_WRITE_CR8     0x018</span>
<span class="p_add">+#define SVM_EXIT_READ_DR0      0x020</span>
<span class="p_add">+#define SVM_EXIT_READ_DR1      0x021</span>
<span class="p_add">+#define SVM_EXIT_READ_DR2      0x022</span>
<span class="p_add">+#define SVM_EXIT_READ_DR3      0x023</span>
<span class="p_add">+#define SVM_EXIT_READ_DR4      0x024</span>
<span class="p_add">+#define SVM_EXIT_READ_DR5      0x025</span>
<span class="p_add">+#define SVM_EXIT_READ_DR6      0x026</span>
<span class="p_add">+#define SVM_EXIT_READ_DR7      0x027</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR0     0x030</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR1     0x031</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR2     0x032</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR3     0x033</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR4     0x034</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR5     0x035</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR6     0x036</span>
<span class="p_add">+#define SVM_EXIT_WRITE_DR7     0x037</span>
<span class="p_add">+#define SVM_EXIT_EXCP_BASE     0x040</span>
<span class="p_add">+#define SVM_EXIT_INTR          0x060</span>
<span class="p_add">+#define SVM_EXIT_NMI           0x061</span>
<span class="p_add">+#define SVM_EXIT_SMI           0x062</span>
<span class="p_add">+#define SVM_EXIT_INIT          0x063</span>
<span class="p_add">+#define SVM_EXIT_VINTR         0x064</span>
<span class="p_add">+#define SVM_EXIT_CR0_SEL_WRITE 0x065</span>
<span class="p_add">+#define SVM_EXIT_IDTR_READ     0x066</span>
<span class="p_add">+#define SVM_EXIT_GDTR_READ     0x067</span>
<span class="p_add">+#define SVM_EXIT_LDTR_READ     0x068</span>
<span class="p_add">+#define SVM_EXIT_TR_READ       0x069</span>
<span class="p_add">+#define SVM_EXIT_IDTR_WRITE    0x06a</span>
<span class="p_add">+#define SVM_EXIT_GDTR_WRITE    0x06b</span>
<span class="p_add">+#define SVM_EXIT_LDTR_WRITE    0x06c</span>
<span class="p_add">+#define SVM_EXIT_TR_WRITE      0x06d</span>
<span class="p_add">+#define SVM_EXIT_RDTSC         0x06e</span>
<span class="p_add">+#define SVM_EXIT_RDPMC         0x06f</span>
<span class="p_add">+#define SVM_EXIT_PUSHF         0x070</span>
<span class="p_add">+#define SVM_EXIT_POPF          0x071</span>
<span class="p_add">+#define SVM_EXIT_CPUID         0x072</span>
<span class="p_add">+#define SVM_EXIT_RSM           0x073</span>
<span class="p_add">+#define SVM_EXIT_IRET          0x074</span>
<span class="p_add">+#define SVM_EXIT_SWINT         0x075</span>
<span class="p_add">+#define SVM_EXIT_INVD          0x076</span>
<span class="p_add">+#define SVM_EXIT_PAUSE         0x077</span>
<span class="p_add">+#define SVM_EXIT_HLT           0x078</span>
<span class="p_add">+#define SVM_EXIT_INVLPG        0x079</span>
<span class="p_add">+#define SVM_EXIT_INVLPGA       0x07a</span>
<span class="p_add">+#define SVM_EXIT_IOIO          0x07b</span>
<span class="p_add">+#define SVM_EXIT_MSR           0x07c</span>
<span class="p_add">+#define SVM_EXIT_TASK_SWITCH   0x07d</span>
<span class="p_add">+#define SVM_EXIT_FERR_FREEZE   0x07e</span>
<span class="p_add">+#define SVM_EXIT_SHUTDOWN      0x07f</span>
<span class="p_add">+#define SVM_EXIT_VMRUN         0x080</span>
<span class="p_add">+#define SVM_EXIT_VMMCALL       0x081</span>
<span class="p_add">+#define SVM_EXIT_VMLOAD        0x082</span>
<span class="p_add">+#define SVM_EXIT_VMSAVE        0x083</span>
<span class="p_add">+#define SVM_EXIT_STGI          0x084</span>
<span class="p_add">+#define SVM_EXIT_CLGI          0x085</span>
<span class="p_add">+#define SVM_EXIT_SKINIT        0x086</span>
<span class="p_add">+#define SVM_EXIT_RDTSCP        0x087</span>
<span class="p_add">+#define SVM_EXIT_ICEBP         0x088</span>
<span class="p_add">+#define SVM_EXIT_WBINVD        0x089</span>
<span class="p_add">+#define SVM_EXIT_MONITOR       0x08a</span>
<span class="p_add">+#define SVM_EXIT_MWAIT         0x08b</span>
<span class="p_add">+#define SVM_EXIT_MWAIT_COND    0x08c</span>
<span class="p_add">+#define SVM_EXIT_XSETBV        0x08d</span>
<span class="p_add">+#define SVM_EXIT_NPF           0x400</span>
<span class="p_add">+#define SVM_EXIT_AVIC_INCOMPLETE_IPI		0x401</span>
<span class="p_add">+#define SVM_EXIT_AVIC_UNACCELERATED_ACCESS	0x402</span>
<span class="p_add">+</span>
<span class="p_add">+#define SVM_EXIT_ERR           -1</span>
<span class="p_add">+</span>
<span class="p_add">+#define SVM_EXIT_REASONS \</span>
<span class="p_add">+	{ SVM_EXIT_READ_CR0,    &quot;read_cr0&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_CR2,    &quot;read_cr2&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_CR3,    &quot;read_cr3&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_CR4,    &quot;read_cr4&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_CR8,    &quot;read_cr8&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_CR0,   &quot;write_cr0&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_CR2,   &quot;write_cr2&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_CR3,   &quot;write_cr3&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_CR4,   &quot;write_cr4&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_CR8,   &quot;write_cr8&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR0,    &quot;read_dr0&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR1,    &quot;read_dr1&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR2,    &quot;read_dr2&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR3,    &quot;read_dr3&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR4,    &quot;read_dr4&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR5,    &quot;read_dr5&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR6,    &quot;read_dr6&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_READ_DR7,    &quot;read_dr7&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR0,   &quot;write_dr0&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR1,   &quot;write_dr1&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR2,   &quot;write_dr2&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR3,   &quot;write_dr3&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR4,   &quot;write_dr4&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR5,   &quot;write_dr5&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR6,   &quot;write_dr6&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WRITE_DR7,   &quot;write_dr7&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + DE_VECTOR,       &quot;DE excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + DB_VECTOR,       &quot;DB excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + BP_VECTOR,       &quot;BP excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + OF_VECTOR,       &quot;OF excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + BR_VECTOR,       &quot;BR excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + UD_VECTOR,       &quot;UD excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + NM_VECTOR,       &quot;NM excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + DF_VECTOR,       &quot;DF excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + TS_VECTOR,       &quot;TS excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + NP_VECTOR,       &quot;NP excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + SS_VECTOR,       &quot;SS excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + GP_VECTOR,       &quot;GP excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + PF_VECTOR,       &quot;PF excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + MF_VECTOR,       &quot;MF excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + AC_VECTOR,       &quot;AC excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + MC_VECTOR,       &quot;MC excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_EXCP_BASE + XM_VECTOR,       &quot;XF excp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_INTR,        &quot;interrupt&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_NMI,         &quot;nmi&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_SMI,         &quot;smi&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_INIT,        &quot;init&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_VINTR,       &quot;vintr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_CR0_SEL_WRITE, &quot;cr0_sel_write&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_IDTR_READ,   &quot;read_idtr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_GDTR_READ,   &quot;read_gdtr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_LDTR_READ,   &quot;read_ldtr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_TR_READ,     &quot;read_rt&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_IDTR_WRITE,  &quot;write_idtr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_GDTR_WRITE,  &quot;write_gdtr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_LDTR_WRITE,  &quot;write_ldtr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_TR_WRITE,    &quot;write_rt&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_RDTSC,       &quot;rdtsc&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_RDPMC,       &quot;rdpmc&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_PUSHF,       &quot;pushf&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_POPF,        &quot;popf&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_CPUID,       &quot;cpuid&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_RSM,         &quot;rsm&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_IRET,        &quot;iret&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_SWINT,       &quot;swint&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_INVD,        &quot;invd&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_PAUSE,       &quot;pause&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_HLT,         &quot;hlt&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_INVLPG,      &quot;invlpg&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_INVLPGA,     &quot;invlpga&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_IOIO,        &quot;io&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_MSR,         &quot;msr&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_TASK_SWITCH, &quot;task_switch&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_FERR_FREEZE, &quot;ferr_freeze&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_SHUTDOWN,    &quot;shutdown&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_VMRUN,       &quot;vmrun&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_VMMCALL,     &quot;hypercall&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_VMLOAD,      &quot;vmload&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_VMSAVE,      &quot;vmsave&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_STGI,        &quot;stgi&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_CLGI,        &quot;clgi&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_SKINIT,      &quot;skinit&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_RDTSCP,      &quot;rdtscp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_ICEBP,       &quot;icebp&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_WBINVD,      &quot;wbinvd&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_MONITOR,     &quot;monitor&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_MWAIT,       &quot;mwait&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_XSETBV,      &quot;xsetbv&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_NPF,         &quot;npf&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_AVIC_INCOMPLETE_IPI,		&quot;avic_incomplete_ipi&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_AVIC_UNACCELERATED_ACCESS,   &quot;avic_unaccelerated_access&quot; }, \</span>
<span class="p_add">+	{ SVM_EXIT_ERR,         &quot;invalid_guest_state&quot; }</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _UAPI__SVM_H */</span>
<span class="p_header">diff --git a/tools/arch/x86/include/uapi/asm/vmx.h b/tools/arch/x86/include/uapi/asm/vmx.h</span>
new file mode 100644
<span class="p_header">index 000000000000..5b15d94a33f8</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/arch/x86/include/uapi/asm/vmx.h</span>
<span class="p_chunk">@@ -0,0 +1,136 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * vmx.h: VMX Architecture related definitions</span>
<span class="p_add">+ * Copyright (c) 2004, Intel Corporation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify it</span>
<span class="p_add">+ * under the terms and conditions of the GNU General Public License,</span>
<span class="p_add">+ * version 2, as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="p_add">+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="p_add">+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="p_add">+ * more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License along with</span>
<span class="p_add">+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple</span>
<span class="p_add">+ * Place - Suite 330, Boston, MA 02111-1307 USA.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A few random additions are:</span>
<span class="p_add">+ * Copyright (C) 2006 Qumranet</span>
<span class="p_add">+ *    Avi Kivity &lt;avi@qumranet.com&gt;</span>
<span class="p_add">+ *    Yaniv Kamay &lt;yaniv@qumranet.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef _UAPIVMX_H</span>
<span class="p_add">+#define _UAPIVMX_H</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define VMX_EXIT_REASONS_FAILED_VMENTRY         0x80000000</span>
<span class="p_add">+</span>
<span class="p_add">+#define EXIT_REASON_EXCEPTION_NMI       0</span>
<span class="p_add">+#define EXIT_REASON_EXTERNAL_INTERRUPT  1</span>
<span class="p_add">+#define EXIT_REASON_TRIPLE_FAULT        2</span>
<span class="p_add">+</span>
<span class="p_add">+#define EXIT_REASON_PENDING_INTERRUPT   7</span>
<span class="p_add">+#define EXIT_REASON_NMI_WINDOW          8</span>
<span class="p_add">+#define EXIT_REASON_TASK_SWITCH         9</span>
<span class="p_add">+#define EXIT_REASON_CPUID               10</span>
<span class="p_add">+#define EXIT_REASON_HLT                 12</span>
<span class="p_add">+#define EXIT_REASON_INVD                13</span>
<span class="p_add">+#define EXIT_REASON_INVLPG              14</span>
<span class="p_add">+#define EXIT_REASON_RDPMC               15</span>
<span class="p_add">+#define EXIT_REASON_RDTSC               16</span>
<span class="p_add">+#define EXIT_REASON_VMCALL              18</span>
<span class="p_add">+#define EXIT_REASON_VMCLEAR             19</span>
<span class="p_add">+#define EXIT_REASON_VMLAUNCH            20</span>
<span class="p_add">+#define EXIT_REASON_VMPTRLD             21</span>
<span class="p_add">+#define EXIT_REASON_VMPTRST             22</span>
<span class="p_add">+#define EXIT_REASON_VMREAD              23</span>
<span class="p_add">+#define EXIT_REASON_VMRESUME            24</span>
<span class="p_add">+#define EXIT_REASON_VMWRITE             25</span>
<span class="p_add">+#define EXIT_REASON_VMOFF               26</span>
<span class="p_add">+#define EXIT_REASON_VMON                27</span>
<span class="p_add">+#define EXIT_REASON_CR_ACCESS           28</span>
<span class="p_add">+#define EXIT_REASON_DR_ACCESS           29</span>
<span class="p_add">+#define EXIT_REASON_IO_INSTRUCTION      30</span>
<span class="p_add">+#define EXIT_REASON_MSR_READ            31</span>
<span class="p_add">+#define EXIT_REASON_MSR_WRITE           32</span>
<span class="p_add">+#define EXIT_REASON_INVALID_STATE       33</span>
<span class="p_add">+#define EXIT_REASON_MSR_LOAD_FAIL       34</span>
<span class="p_add">+#define EXIT_REASON_MWAIT_INSTRUCTION   36</span>
<span class="p_add">+#define EXIT_REASON_MONITOR_TRAP_FLAG   37</span>
<span class="p_add">+#define EXIT_REASON_MONITOR_INSTRUCTION 39</span>
<span class="p_add">+#define EXIT_REASON_PAUSE_INSTRUCTION   40</span>
<span class="p_add">+#define EXIT_REASON_MCE_DURING_VMENTRY  41</span>
<span class="p_add">+#define EXIT_REASON_TPR_BELOW_THRESHOLD 43</span>
<span class="p_add">+#define EXIT_REASON_APIC_ACCESS         44</span>
<span class="p_add">+#define EXIT_REASON_EOI_INDUCED         45</span>
<span class="p_add">+#define EXIT_REASON_EPT_VIOLATION       48</span>
<span class="p_add">+#define EXIT_REASON_EPT_MISCONFIG       49</span>
<span class="p_add">+#define EXIT_REASON_INVEPT              50</span>
<span class="p_add">+#define EXIT_REASON_RDTSCP              51</span>
<span class="p_add">+#define EXIT_REASON_PREEMPTION_TIMER    52</span>
<span class="p_add">+#define EXIT_REASON_INVVPID             53</span>
<span class="p_add">+#define EXIT_REASON_WBINVD              54</span>
<span class="p_add">+#define EXIT_REASON_XSETBV              55</span>
<span class="p_add">+#define EXIT_REASON_APIC_WRITE          56</span>
<span class="p_add">+#define EXIT_REASON_INVPCID             58</span>
<span class="p_add">+#define EXIT_REASON_PML_FULL            62</span>
<span class="p_add">+#define EXIT_REASON_XSAVES              63</span>
<span class="p_add">+#define EXIT_REASON_XRSTORS             64</span>
<span class="p_add">+#define EXIT_REASON_PCOMMIT             65</span>
<span class="p_add">+</span>
<span class="p_add">+#define VMX_EXIT_REASONS \</span>
<span class="p_add">+	{ EXIT_REASON_EXCEPTION_NMI,         &quot;EXCEPTION_NMI&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_EXTERNAL_INTERRUPT,    &quot;EXTERNAL_INTERRUPT&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_TRIPLE_FAULT,          &quot;TRIPLE_FAULT&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_PENDING_INTERRUPT,     &quot;PENDING_INTERRUPT&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_NMI_WINDOW,            &quot;NMI_WINDOW&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_TASK_SWITCH,           &quot;TASK_SWITCH&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_CPUID,                 &quot;CPUID&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_HLT,                   &quot;HLT&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_INVLPG,                &quot;INVLPG&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_RDPMC,                 &quot;RDPMC&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_RDTSC,                 &quot;RDTSC&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMCALL,                &quot;VMCALL&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMCLEAR,               &quot;VMCLEAR&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMLAUNCH,              &quot;VMLAUNCH&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMPTRLD,               &quot;VMPTRLD&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMPTRST,               &quot;VMPTRST&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMREAD,                &quot;VMREAD&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMRESUME,              &quot;VMRESUME&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMWRITE,               &quot;VMWRITE&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMOFF,                 &quot;VMOFF&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_VMON,                  &quot;VMON&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_CR_ACCESS,             &quot;CR_ACCESS&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_DR_ACCESS,             &quot;DR_ACCESS&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_IO_INSTRUCTION,        &quot;IO_INSTRUCTION&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_MSR_READ,              &quot;MSR_READ&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_MSR_WRITE,             &quot;MSR_WRITE&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_MWAIT_INSTRUCTION,     &quot;MWAIT_INSTRUCTION&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_MONITOR_TRAP_FLAG,     &quot;MONITOR_TRAP_FLAG&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_MONITOR_INSTRUCTION,   &quot;MONITOR_INSTRUCTION&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_PAUSE_INSTRUCTION,     &quot;PAUSE_INSTRUCTION&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_MCE_DURING_VMENTRY,    &quot;MCE_DURING_VMENTRY&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_TPR_BELOW_THRESHOLD,   &quot;TPR_BELOW_THRESHOLD&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_APIC_ACCESS,           &quot;APIC_ACCESS&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_EPT_VIOLATION,         &quot;EPT_VIOLATION&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_EPT_MISCONFIG,         &quot;EPT_MISCONFIG&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_INVEPT,                &quot;INVEPT&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_PREEMPTION_TIMER,      &quot;PREEMPTION_TIMER&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_WBINVD,                &quot;WBINVD&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_APIC_WRITE,            &quot;APIC_WRITE&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_EOI_INDUCED,           &quot;EOI_INDUCED&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_INVALID_STATE,         &quot;INVALID_STATE&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_MSR_LOAD_FAIL,         &quot;MSR_LOAD_FAIL&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_INVD,                  &quot;INVD&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_INVVPID,               &quot;INVVPID&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_INVPCID,               &quot;INVPCID&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_XSAVES,                &quot;XSAVES&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_XRSTORS,               &quot;XRSTORS&quot; }, \</span>
<span class="p_add">+	{ EXIT_REASON_PCOMMIT,               &quot;PCOMMIT&quot; }</span>
<span class="p_add">+</span>
<span class="p_add">+#define VMX_ABORT_SAVE_GUEST_MSR_FAIL        1</span>
<span class="p_add">+#define VMX_ABORT_LOAD_HOST_MSR_FAIL         4</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _UAPIVMX_H */</span>
<span class="p_header">diff --git a/tools/perf/MANIFEST b/tools/perf/MANIFEST</span>
<span class="p_header">index a4aefaeff355..db7cfb42a675 100644</span>
<span class="p_header">--- a/tools/perf/MANIFEST</span>
<span class="p_header">+++ b/tools/perf/MANIFEST</span>
<span class="p_chunk">@@ -15,8 +15,14 @@</span> <span class="p_context"> tools/arch/x86/include/asm/barrier.h</span>
 tools/arch/x86/include/asm/cpufeatures.h
 tools/arch/x86/include/asm/disabled-features.h
 tools/arch/x86/include/asm/required-features.h
<span class="p_add">+tools/arch/x86/include/uapi/asm/svm.h</span>
<span class="p_add">+tools/arch/x86/include/uapi/asm/vmx.h</span>
<span class="p_add">+tools/arch/x86/include/uapi/asm/kvm.h</span>
<span class="p_add">+tools/arch/x86/include/uapi/asm/kvm_perf.h</span>
 tools/arch/x86/lib/memcpy_64.S
 tools/arch/x86/lib/memset_64.S
<span class="p_add">+tools/arch/s390/include/uapi/asm/kvm_perf.h</span>
<span class="p_add">+tools/arch/s390/include/uapi/asm/sie.h</span>
 tools/arch/xtensa/include/asm/barrier.h
 tools/scripts
 tools/build
<span class="p_chunk">@@ -85,12 +91,3 @@</span> <span class="p_context"> tools/arch/*/include/uapi/asm/perf_regs.h</span>
 include/linux/poison.h
 include/uapi/linux/const.h
 include/uapi/linux/swab.h
<span class="p_del">-arch/x86/include/asm/svm.h</span>
<span class="p_del">-arch/x86/include/asm/vmx.h</span>
<span class="p_del">-arch/x86/include/asm/kvm_host.h</span>
<span class="p_del">-arch/x86/include/uapi/asm/svm.h</span>
<span class="p_del">-arch/x86/include/uapi/asm/vmx.h</span>
<span class="p_del">-arch/x86/include/uapi/asm/kvm.h</span>
<span class="p_del">-arch/x86/include/uapi/asm/kvm_perf.h</span>
<span class="p_del">-arch/s390/include/uapi/asm/sie.h</span>
<span class="p_del">-arch/s390/include/uapi/asm/kvm_perf.h</span>
<span class="p_header">diff --git a/tools/perf/Makefile.perf b/tools/perf/Makefile.perf</span>
<span class="p_header">index 0d07672c3af7..feb2c66b110b 100644</span>
<span class="p_header">--- a/tools/perf/Makefile.perf</span>
<span class="p_header">+++ b/tools/perf/Makefile.perf</span>
<span class="p_chunk">@@ -378,6 +378,36 @@</span> <span class="p_context"> $(PERF_IN): prepare FORCE</span>
 	@(test -f ../../arch/x86/include/uapi/asm/perf_regs.h &amp;&amp; ( \
         (diff -B ../arch/x86/include/uapi/asm/perf_regs.h ../../arch/x86/include/uapi/asm/perf_regs.h &gt;/dev/null) \
         || echo &quot;Warning: tools/arch/x86/include/uapi/asm/perf_regs.h differs from kernel&quot; &gt;&amp;2 )) || true
<span class="p_add">+	@(test -f ../../arch/x86/include/uapi/asm/kvm.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/x86/include/uapi/asm/kvm.h ../../arch/x86/include/uapi/asm/kvm.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/x86/include/uapi/asm/kvm.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/x86/include/uapi/asm/kvm_perf.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/x86/include/uapi/asm/kvm_perf.h ../../arch/x86/include/uapi/asm/kvm_perf.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/x86/include/uapi/asm/kvm_perf.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/x86/include/uapi/asm/svm.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/x86/include/uapi/asm/svm.h ../../arch/x86/include/uapi/asm/svm.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/x86/include/uapi/asm/svm.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/x86/include/uapi/asm/vmx.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/x86/include/uapi/asm/vmx.h ../../arch/x86/include/uapi/asm/vmx.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/x86/include/uapi/asm/vmx.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/powerpc/include/uapi/asm/kvm.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/powerpc/include/uapi/asm/kvm.h ../../arch/powerpc/include/uapi/asm/kvm.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/powerpc/include/uapi/asm/kvm.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/s390/include/uapi/asm/kvm.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/s390/include/uapi/asm/kvm.h ../../arch/s390/include/uapi/asm/kvm.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/s390/include/uapi/asm/kvm.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/s390/include/uapi/asm/kvm_perf.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/s390/include/uapi/asm/kvm_perf.h ../../arch/s390/include/uapi/asm/kvm_perf.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/s390/include/uapi/asm/kvm_perf.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/s390/include/uapi/asm/sie.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/s390/include/uapi/asm/sie.h ../../arch/s390/include/uapi/asm/sie.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/s390/include/uapi/asm/sie.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/arm/include/uapi/asm/kvm.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/arm/include/uapi/asm/kvm.h ../../arch/arm/include/uapi/asm/kvm.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/arm/include/uapi/asm/kvm.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
<span class="p_add">+	@(test -f ../../arch/arm64/include/uapi/asm/kvm.h &amp;&amp; ( \</span>
<span class="p_add">+        (diff -B ../arch/arm64/include/uapi/asm/kvm.h ../../arch/arm64/include/uapi/asm/kvm.h &gt;/dev/null) \</span>
<span class="p_add">+        || echo &quot;Warning: tools/arch/arm64/include/uapi/asm/kvm.h differs from kernel&quot; &gt;&amp;2 )) || true</span>
 	$(Q)$(MAKE) $(build)=perf
 
 $(OUTPUT)perf: $(PERFLIBS) $(PERF_IN) $(LIBTRACEEVENT_DYNAMIC_LIST)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



