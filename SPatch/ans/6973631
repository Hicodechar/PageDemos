
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[4/9] perf, tools, stat: Add computation of TopDown formulas - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [4/9] perf, tools, stat: Add computation of TopDown formulas</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=104">Andi Kleen</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 8, 2015, 1:06 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438995985-13631-5-git-send-email-andi@firstfloor.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6973631/mbox/"
   >mbox</a>
|
   <a href="/patch/6973631/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6973631/">/patch/6973631/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 5853BC05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  8 Aug 2015 01:07:03 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 36F212068E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  8 Aug 2015 01:07:02 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id B91202069A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat,  8 Aug 2015 01:06:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S2992453AbbHHBGw (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 7 Aug 2015 21:06:52 -0400
Received: from mga01.intel.com ([192.55.52.88]:5589 &quot;EHLO mga01.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1946680AbbHHBGs (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 7 Aug 2015 21:06:48 -0400
Received: from orsmga001.jf.intel.com ([10.7.209.18])
	by fmsmga101.fm.intel.com with ESMTP; 07 Aug 2015 18:06:36 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.15,632,1432623600&quot;; d=&quot;scan&#39;208&quot;;a=&quot;744481559&quot;
Received: from tassilo.jf.intel.com (HELO tassilo.localdomain)
	([10.7.201.36])
	by orsmga001.jf.intel.com with ESMTP; 07 Aug 2015 18:06:36 -0700
Received: by tassilo.localdomain (Postfix, from userid 1000)
	id 56C24301F23; Fri,  7 Aug 2015 18:06:36 -0700 (PDT)
From: Andi Kleen &lt;andi@firstfloor.org&gt;
To: acme@kernel.org
Cc: jolsa@kernel.org, linux-kernel@vger.kernel.org, eranian@google.com,
	namhyung@kernel.org, peterz@infradead.org, mingo@kernel.org,
	Andi Kleen &lt;ak@linux.intel.com&gt;
Subject: [PATCH 4/9] perf, tools, stat: Add computation of TopDown formulas
Date: Fri,  7 Aug 2015 18:06:20 -0700
Message-Id: &lt;1438995985-13631-5-git-send-email-andi@firstfloor.org&gt;
X-Mailer: git-send-email 2.4.3
In-Reply-To: &lt;1438995985-13631-1-git-send-email-andi@firstfloor.org&gt;
References: &lt;1438995985-13631-1-git-send-email-andi@firstfloor.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.0 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=104">Andi Kleen</a> - Aug. 8, 2015, 1:06 a.m.</div>
<pre class="content">
<span class="from">From: Andi Kleen &lt;ak@linux.intel.com&gt;</span>

Implement the TopDown formulas in perf stat. The topdown basic metrics
reported by the kernel are collected, and the formulas are computed
and output as normal metrics.

See the kernel commit exporting the events for details on the used
metrics.
<span class="signed-off-by">
Signed-off-by: Andi Kleen &lt;ak@linux.intel.com&gt;</span>
---
 tools/perf/util/stat-shadow.c | 119 +++++++++++++++++++++++++++++++++++++++++-
 tools/perf/util/stat.c        |   5 ++
 tools/perf/util/stat.h        |   8 ++-
 3 files changed, 130 insertions(+), 2 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/tools/perf/util/stat-shadow.c b/tools/perf/util/stat-shadow.c</span>
<span class="p_header">index 073e66f7..2158a0e 100644</span>
<span class="p_header">--- a/tools/perf/util/stat-shadow.c</span>
<span class="p_header">+++ b/tools/perf/util/stat-shadow.c</span>
<span class="p_chunk">@@ -28,6 +28,11 @@</span> <span class="p_context"> static struct stats runtime_dtlb_cache_stats[NUM_CTX][MAX_NR_CPUS];</span>
 static struct stats runtime_cycles_in_tx_stats[NUM_CTX][MAX_NR_CPUS];
 static struct stats runtime_transaction_stats[NUM_CTX][MAX_NR_CPUS];
 static struct stats runtime_elision_stats[NUM_CTX][MAX_NR_CPUS];
<span class="p_add">+static struct stats runtime_topdown_total_slots[NUM_CTX][MAX_NR_CPUS];</span>
<span class="p_add">+static struct stats runtime_topdown_slots_issued[NUM_CTX][MAX_NR_CPUS];</span>
<span class="p_add">+static struct stats runtime_topdown_slots_retired[NUM_CTX][MAX_NR_CPUS];</span>
<span class="p_add">+static struct stats runtime_topdown_fetch_bubbles[NUM_CTX][MAX_NR_CPUS];</span>
<span class="p_add">+static struct stats runtime_topdown_recovery_bubbles[NUM_CTX][MAX_NR_CPUS];</span>
 
 struct stats walltime_nsecs_stats;
 
<span class="p_chunk">@@ -68,6 +73,11 @@</span> <span class="p_context"> void perf_stat__reset_shadow_stats(void)</span>
 		sizeof(runtime_transaction_stats));
 	memset(runtime_elision_stats, 0, sizeof(runtime_elision_stats));
 	memset(&amp;walltime_nsecs_stats, 0, sizeof(walltime_nsecs_stats));
<span class="p_add">+	memset(runtime_topdown_total_slots, 0, sizeof(runtime_topdown_total_slots));</span>
<span class="p_add">+	memset(runtime_topdown_slots_retired, 0, sizeof(runtime_topdown_slots_retired));</span>
<span class="p_add">+	memset(runtime_topdown_slots_issued, 0, sizeof(runtime_topdown_slots_issued));</span>
<span class="p_add">+	memset(runtime_topdown_fetch_bubbles, 0, sizeof(runtime_topdown_fetch_bubbles));</span>
<span class="p_add">+	memset(runtime_topdown_recovery_bubbles, 0, sizeof(runtime_topdown_recovery_bubbles));</span>
 }
 
 /*
<span class="p_chunk">@@ -90,6 +100,16 @@</span> <span class="p_context"> void perf_stat__update_shadow_stats(struct perf_evsel *counter, u64 *count,</span>
 		update_stats(&amp;runtime_transaction_stats[ctx][cpu], count[0]);
 	else if (perf_stat_evsel__is(counter, ELISION_START))
 		update_stats(&amp;runtime_elision_stats[ctx][cpu], count[0]);
<span class="p_add">+	else if (perf_stat_evsel__is(counter, TOPDOWN_TOTAL_SLOTS))</span>
<span class="p_add">+		update_stats(&amp;runtime_topdown_total_slots[ctx][cpu], count[0]);</span>
<span class="p_add">+	else if (perf_stat_evsel__is(counter, TOPDOWN_SLOTS_ISSUED))</span>
<span class="p_add">+		update_stats(&amp;runtime_topdown_slots_issued[ctx][cpu], count[0]);</span>
<span class="p_add">+	else if (perf_stat_evsel__is(counter, TOPDOWN_SLOTS_RETIRED))</span>
<span class="p_add">+		update_stats(&amp;runtime_topdown_slots_retired[ctx][cpu], count[0]);</span>
<span class="p_add">+	else if (perf_stat_evsel__is(counter, TOPDOWN_FETCH_BUBBLES))</span>
<span class="p_add">+		update_stats(&amp;runtime_topdown_fetch_bubbles[ctx][cpu],count[0]);</span>
<span class="p_add">+	else if (perf_stat_evsel__is(counter, TOPDOWN_RECOVERY_BUBBLES))</span>
<span class="p_add">+		update_stats(&amp;runtime_topdown_recovery_bubbles[ctx][cpu], count[0]);</span>
 	else if (perf_evsel__match(counter, HARDWARE, HW_STALLED_CYCLES_FRONTEND))
 		update_stats(&amp;runtime_stalled_cycles_front_stats[ctx][cpu], count[0]);
 	else if (perf_evsel__match(counter, HARDWARE, HW_STALLED_CYCLES_BACKEND))
<span class="p_chunk">@@ -293,11 +313,70 @@</span> <span class="p_context"> static void print_ll_cache_misses(int cpu,</span>
 	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;of all LL-cache hits&quot;, ratio);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * For an explanation of the formulas see:</span>
<span class="p_add">+ * Yasin, A Top Down Method for Performance analysis and Counter architecture</span>
<span class="p_add">+ * ISPASS14</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static double td_total_slots(int ctx, int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return avg_stats(&amp;runtime_topdown_total_slots[ctx][cpu]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static double td_bad_spec(int ctx, int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	double bad_spec = 0;</span>
<span class="p_add">+	double total_slots;</span>
<span class="p_add">+	double total;</span>
<span class="p_add">+</span>
<span class="p_add">+	total = avg_stats(&amp;runtime_topdown_slots_issued[ctx][cpu]) -</span>
<span class="p_add">+		avg_stats(&amp;runtime_topdown_slots_retired[ctx][cpu]) +</span>
<span class="p_add">+		avg_stats(&amp;runtime_topdown_recovery_bubbles[ctx][cpu]);</span>
<span class="p_add">+	total_slots = td_total_slots(ctx, cpu);</span>
<span class="p_add">+	if (total_slots)</span>
<span class="p_add">+		bad_spec = total / total_slots;</span>
<span class="p_add">+	return bad_spec;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static double td_retiring(int ctx, int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	double retiring = 0;</span>
<span class="p_add">+	double total_slots = td_total_slots(ctx, cpu);</span>
<span class="p_add">+	double ret_slots = avg_stats(&amp;runtime_topdown_slots_retired[ctx][cpu]);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (total_slots)</span>
<span class="p_add">+		retiring = ret_slots / total_slots;</span>
<span class="p_add">+	return retiring;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static double td_fe_bound(int ctx, int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	double fe_bound = 0;</span>
<span class="p_add">+	double total_slots = td_total_slots(ctx, cpu);</span>
<span class="p_add">+	double fetch_bub = avg_stats(&amp;runtime_topdown_fetch_bubbles[ctx][cpu]);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (total_slots)</span>
<span class="p_add">+		fe_bound = fetch_bub / total_slots;</span>
<span class="p_add">+	return fe_bound;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static double td_be_bound(int ctx, int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	double sum = (td_fe_bound(ctx, cpu) +</span>
<span class="p_add">+		      td_bad_spec(ctx, cpu) +</span>
<span class="p_add">+		      td_retiring(ctx, cpu));</span>
<span class="p_add">+	if (sum == 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return 1.0 - sum;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void perf_stat__print_shadow_stats(struct perf_evsel *evsel,
 				   double avg, int cpu,
 				   print_metric_t print_metric,
 				   void (*new_line)(void *ctx),
<span class="p_del">-				   void *ctxp)</span>
<span class="p_add">+				   void *ctxp,</span>
<span class="p_add">+				   int topdown_run)</span>
 {
 	double total, ratio = 0.0, total2;
 	int ctx = evsel_context(evsel);
<span class="p_chunk">@@ -422,6 +501,44 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(struct perf_evsel *evsel,</span>
 	} else if (perf_evsel__match(evsel, SOFTWARE, SW_TASK_CLOCK) &amp;&amp;
 		   (ratio = avg_stats(&amp;walltime_nsecs_stats)) != 0) {
 		print_metric(ctxp, NULL, &quot;%8.3f&quot;, &quot;CPUs utilized&quot;, avg / ratio);
<span class="p_add">+	} else if (perf_stat_evsel__is(evsel, TOPDOWN_FETCH_BUBBLES)) {</span>
<span class="p_add">+		double fe_bound = td_fe_bound(ctx, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (fe_bound &gt; 0.2 || topdown_run &gt; 1)</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%8.2f%%&quot;, &quot;frontend bound&quot;,</span>
<span class="p_add">+					fe_bound * 100.);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
<span class="p_add">+	} else if (perf_stat_evsel__is(evsel, TOPDOWN_SLOTS_RETIRED)) {</span>
<span class="p_add">+		double retiring = td_retiring(ctx, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (retiring &gt; 0.7 || topdown_run &gt; 1)</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%8.2f%%&quot;, &quot;retiring&quot;,</span>
<span class="p_add">+					retiring * 100.);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
<span class="p_add">+	} else if (perf_stat_evsel__is(evsel, TOPDOWN_RECOVERY_BUBBLES)) {</span>
<span class="p_add">+		double bad_spec = td_bad_spec(ctx, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (bad_spec &gt; 0.1 || topdown_run &gt; 1)</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%8.2f%%&quot;, &quot;bad speculation&quot;,</span>
<span class="p_add">+					bad_spec * 100.);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
<span class="p_add">+	} else if (perf_stat_evsel__is(evsel, TOPDOWN_SLOTS_ISSUED)) {</span>
<span class="p_add">+		double be_bound = td_be_bound(ctx, cpu);</span>
<span class="p_add">+		const char *name = &quot;backend bound&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* In case the CPU does not support topdown-recovery-bubbles */</span>
<span class="p_add">+		if (avg_stats(&amp;runtime_topdown_recovery_bubbles[ctx][cpu]) == 0)</span>
<span class="p_add">+			name = &quot;backend bound/bad spec&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (td_total_slots(ctx, cpu) &gt; 0 &amp;&amp;</span>
<span class="p_add">+			(be_bound &gt; 0.2 || topdown_run &gt; 1))</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%8.2f%%&quot;, name,</span>
<span class="p_add">+					be_bound * 100.);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
 	} else if (runtime_nsecs_stats[cpu].n != 0) {
 		char unit = &#39;M&#39;;
 		char unit_buf[10];
<span class="p_header">diff --git a/tools/perf/util/stat.c b/tools/perf/util/stat.c</span>
<span class="p_header">index c5c709c..f700b81 100644</span>
<span class="p_header">--- a/tools/perf/util/stat.c</span>
<span class="p_header">+++ b/tools/perf/util/stat.c</span>
<span class="p_chunk">@@ -79,6 +79,11 @@</span> <span class="p_context"> static const char *id_str[PERF_STAT_EVSEL_ID__MAX] = {</span>
 	ID(TRANSACTION_START,	cpu/tx-start/),
 	ID(ELISION_START,	cpu/el-start/),
 	ID(CYCLES_IN_TX_CP,	cpu/cycles-ct/),
<span class="p_add">+	ID(TOPDOWN_TOTAL_SLOTS, topdown-total-slots),</span>
<span class="p_add">+	ID(TOPDOWN_SLOTS_ISSUED, topdown-slots-issued),</span>
<span class="p_add">+	ID(TOPDOWN_SLOTS_RETIRED, topdown-slots-retired),</span>
<span class="p_add">+	ID(TOPDOWN_FETCH_BUBBLES, topdown-fetch-bubbles),</span>
<span class="p_add">+	ID(TOPDOWN_RECOVERY_BUBBLES, topdown-recovery-bubbles),</span>
 };
 #undef ID
 
<span class="p_header">diff --git a/tools/perf/util/stat.h b/tools/perf/util/stat.h</span>
<span class="p_header">index a492e64..b907a31 100644</span>
<span class="p_header">--- a/tools/perf/util/stat.h</span>
<span class="p_header">+++ b/tools/perf/util/stat.h</span>
<span class="p_chunk">@@ -17,6 +17,11 @@</span> <span class="p_context"> enum perf_stat_evsel_id {</span>
 	PERF_STAT_EVSEL_ID__TRANSACTION_START,
 	PERF_STAT_EVSEL_ID__ELISION_START,
 	PERF_STAT_EVSEL_ID__CYCLES_IN_TX_CP,
<span class="p_add">+	PERF_STAT_EVSEL_ID__TOPDOWN_TOTAL_SLOTS,</span>
<span class="p_add">+	PERF_STAT_EVSEL_ID__TOPDOWN_SLOTS_ISSUED,</span>
<span class="p_add">+	PERF_STAT_EVSEL_ID__TOPDOWN_SLOTS_RETIRED,</span>
<span class="p_add">+	PERF_STAT_EVSEL_ID__TOPDOWN_FETCH_BUBBLES,</span>
<span class="p_add">+	PERF_STAT_EVSEL_ID__TOPDOWN_RECOVERY_BUBBLES,</span>
 	PERF_STAT_EVSEL_ID__MAX,
 };
 
<span class="p_chunk">@@ -100,7 +105,8 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(struct perf_evsel *evsel,</span>
 				   double avg, int cpu,
 				   print_metric_t print_metric,
 				   void (*new_line)(void *ctx),
<span class="p_del">-				   void *ctx);</span>
<span class="p_add">+				   void *ctx,</span>
<span class="p_add">+				   int topdown_run);</span>
 
 struct perf_counts *perf_counts__new(int ncpus, int nthreads);
 void perf_counts__delete(struct perf_counts *counts);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



