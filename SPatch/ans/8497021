
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.63 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.63</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 3, 2016, 11:33 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160303233335.GB28854@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8497021/mbox/"
   >mbox</a>
|
   <a href="/patch/8497021/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8497021/">/patch/8497021/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 3CA10C0553
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Mar 2016 23:34:17 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id BE1182039E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Mar 2016 23:34:09 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 1F1F620396
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  3 Mar 2016 23:34:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932379AbcCCXdm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 3 Mar 2016 18:33:42 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:36025 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932183AbcCCXdh (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 3 Mar 2016 18:33:37 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 11B12B9F;
	Thu,  3 Mar 2016 23:33:36 +0000 (UTC)
Date: Thu, 3 Mar 2016 15:33:35 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.63
Message-ID: &lt;20160303233335.GB28854@kroah.com&gt;
References: &lt;20160303233329.GA28854@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160303233329.GA28854@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - March 3, 2016, 11:33 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b738f644c71e..0843ef4cc0a4 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 62</span>
<span class="p_add">+SUBLEVEL = 63</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arc/kernel/unwind.c b/arch/arc/kernel/unwind.c</span>
<span class="p_header">index e550b117ec4f..2d6a36ea8aaf 100644</span>
<span class="p_header">--- a/arch/arc/kernel/unwind.c</span>
<span class="p_header">+++ b/arch/arc/kernel/unwind.c</span>
<span class="p_chunk">@@ -986,42 +986,13 @@</span> <span class="p_context"> int arc_unwind(struct unwind_frame_info *frame)</span>
 							    (const u8 *)(fde +
 									 1) +
 							    *fde, ptrType);
<span class="p_del">-				if (pc &gt;= endLoc)</span>
<span class="p_add">+				if (pc &gt;= endLoc) {</span>
 					fde = NULL;
<span class="p_del">-			} else</span>
<span class="p_del">-				fde = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (fde == NULL) {</span>
<span class="p_del">-			for (fde = table-&gt;address, tableSize = table-&gt;size;</span>
<span class="p_del">-			     cie = NULL, tableSize &gt; sizeof(*fde)</span>
<span class="p_del">-			     &amp;&amp; tableSize - sizeof(*fde) &gt;= *fde;</span>
<span class="p_del">-			     tableSize -= sizeof(*fde) + *fde,</span>
<span class="p_del">-			     fde += 1 + *fde / sizeof(*fde)) {</span>
<span class="p_del">-				cie = cie_for_fde(fde, table);</span>
<span class="p_del">-				if (cie == &amp;bad_cie) {</span>
 					cie = NULL;
<span class="p_del">-					break;</span>
 				}
<span class="p_del">-				if (cie == NULL</span>
<span class="p_del">-				    || cie == &amp;not_fde</span>
<span class="p_del">-				    || (ptrType = fde_pointer_type(cie)) &lt; 0)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				ptr = (const u8 *)(fde + 2);</span>
<span class="p_del">-				startLoc = read_pointer(&amp;ptr,</span>
<span class="p_del">-							(const u8 *)(fde + 1) +</span>
<span class="p_del">-							*fde, ptrType);</span>
<span class="p_del">-				if (!startLoc)</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-				if (!(ptrType &amp; DW_EH_PE_indirect))</span>
<span class="p_del">-					ptrType &amp;=</span>
<span class="p_del">-					    DW_EH_PE_FORM | DW_EH_PE_signed;</span>
<span class="p_del">-				endLoc =</span>
<span class="p_del">-				    startLoc + read_pointer(&amp;ptr,</span>
<span class="p_del">-							    (const u8 *)(fde +</span>
<span class="p_del">-									 1) +</span>
<span class="p_del">-							    *fde, ptrType);</span>
<span class="p_del">-				if (pc &gt;= startLoc &amp;&amp; pc &lt; endLoc)</span>
<span class="p_del">-					break;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				fde = NULL;</span>
<span class="p_add">+				cie = NULL;</span>
 			}
 		}
 	}
<span class="p_header">diff --git a/arch/arm/boot/dts/wm8650.dtsi b/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_header">index 7525982262ac..2897c1ac47d8 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/wm8650.dtsi</span>
<span class="p_chunk">@@ -187,6 +187,15 @@</span> <span class="p_context"></span>
 			interrupts = &lt;43&gt;;
 		};
 
<span class="p_add">+		sdhc@d800a000 {</span>
<span class="p_add">+			compatible = &quot;wm,wm8505-sdhc&quot;;</span>
<span class="p_add">+			reg = &lt;0xd800a000 0x400&gt;;</span>
<span class="p_add">+			interrupts = &lt;20&gt;, &lt;21&gt;;</span>
<span class="p_add">+			clocks = &lt;&amp;clksdhc&gt;;</span>
<span class="p_add">+			bus-width = &lt;4&gt;;</span>
<span class="p_add">+			sdon-inverted;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		fb: fb@d8050800 {
 			compatible = &quot;wm,wm8505-fb&quot;;
 			reg = &lt;0xd8050800 0x200&gt;;
<span class="p_header">diff --git a/arch/mips/kvm/kvm_locore.S b/arch/mips/kvm/kvm_locore.S</span>
<span class="p_header">index 03a2db58b22d..ba5ce99c021d 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_locore.S</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_locore.S</span>
<span class="p_chunk">@@ -159,9 +159,11 @@</span> <span class="p_context"> FEXPORT(__kvm_mips_vcpu_run)</span>
 
 FEXPORT(__kvm_mips_load_asid)
 	/* Set the ASID for the Guest Kernel */
<span class="p_del">-	INT_SLL	t0, t0, 1	/* with kseg0 @ 0x40000000, kernel */</span>
<span class="p_del">-			        /* addresses shift to 0x80000000 */</span>
<span class="p_del">-	bltz	t0, 1f		/* If kernel */</span>
<span class="p_add">+	PTR_L	t0, VCPU_COP0(k1)</span>
<span class="p_add">+	LONG_L	t0, COP0_STATUS(t0)</span>
<span class="p_add">+	andi	t0, KSU_USER | ST0_ERL | ST0_EXL</span>
<span class="p_add">+	xori	t0, KSU_USER</span>
<span class="p_add">+	bnez	t0, 1f		/* If kernel */</span>
 	 INT_ADDIU t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
 	INT_ADDIU t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
<span class="p_chunk">@@ -438,9 +440,11 @@</span> <span class="p_context"> __kvm_mips_return_to_guest:</span>
 	mtc0	t0, CP0_EPC
 
 	/* Set the ASID for the Guest Kernel */
<span class="p_del">-	INT_SLL	t0, t0, 1	/* with kseg0 @ 0x40000000, kernel */</span>
<span class="p_del">-				/* addresses shift to 0x80000000 */</span>
<span class="p_del">-	bltz	t0, 1f		/* If kernel */</span>
<span class="p_add">+	PTR_L	t0, VCPU_COP0(k1)</span>
<span class="p_add">+	LONG_L	t0, COP0_STATUS(t0)</span>
<span class="p_add">+	andi	t0, KSU_USER | ST0_ERL | ST0_EXL</span>
<span class="p_add">+	xori	t0, KSU_USER</span>
<span class="p_add">+	bnez	t0, 1f		/* If kernel */</span>
 	 INT_ADDIU t1, k1, VCPU_GUEST_KERNEL_ASID  /* (BD)  */
 	INT_ADDIU t1, k1, VCPU_GUEST_USER_ASID    /* else user */
 1:
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index 897c605263f2..12d850b68763 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 
 	if (!gebase) {
 		err = -ENOMEM;
<span class="p_del">-		goto out_free_cpu;</span>
<span class="p_add">+		goto out_uninit_cpu;</span>
 	}
 	kvm_info(&quot;Allocated %d bytes for KVM Exception Handlers @ %p\n&quot;,
 		 ALIGN(size, PAGE_SIZE), gebase);
<span class="p_chunk">@@ -373,6 +373,9 @@</span> <span class="p_context"> struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm, unsigned int id)</span>
 out_free_gebase:
 	kfree(gebase);
 
<span class="p_add">+out_uninit_cpu:</span>
<span class="p_add">+	kvm_vcpu_uninit(vcpu);</span>
<span class="p_add">+</span>
 out_free_cpu:
 	kfree(vcpu);
 
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index c76f297b7149..33085819cd89 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -935,7 +935,7 @@</span> <span class="p_context"> kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc, uint32_t cause,</span>
 
 	base = (inst &gt;&gt; 21) &amp; 0x1f;
 	op_inst = (inst &gt;&gt; 16) &amp; 0x1f;
<span class="p_del">-	offset = inst &amp; 0xffff;</span>
<span class="p_add">+	offset = (int16_t)inst;</span>
 	cache = (inst &gt;&gt; 16) &amp; 0x3;
 	op = (inst &gt;&gt; 18) &amp; 0x7;
 
<span class="p_header">diff --git a/arch/s390/mm/extable.c b/arch/s390/mm/extable.c</span>
<span class="p_header">index 4d1ee88864e8..18c8b819b0aa 100644</span>
<span class="p_header">--- a/arch/s390/mm/extable.c</span>
<span class="p_header">+++ b/arch/s390/mm/extable.c</span>
<span class="p_chunk">@@ -52,12 +52,16 @@</span> <span class="p_context"> void sort_extable(struct exception_table_entry *start,</span>
 	int i;
 
 	/* Normalize entries to being relative to the start of the section */
<span class="p_del">-	for (p = start, i = 0; p &lt; finish; p++, i += 8)</span>
<span class="p_add">+	for (p = start, i = 0; p &lt; finish; p++, i += 8) {</span>
 		p-&gt;insn += i;
<span class="p_add">+		p-&gt;fixup += i + 4;</span>
<span class="p_add">+	}</span>
 	sort(start, finish - start, sizeof(*start), cmp_ex, NULL);
 	/* Denormalize all entries */
<span class="p_del">-	for (p = start, i = 0; p &lt; finish; p++, i += 8)</span>
<span class="p_add">+	for (p = start, i = 0; p &lt; finish; p++, i += 8) {</span>
 		p-&gt;insn -= i;
<span class="p_add">+		p-&gt;fixup -= i + 4;</span>
<span class="p_add">+	}</span>
 }
 
 #ifdef CONFIG_MODULES
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index 25db14a33d03..47ae8d757773 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -412,7 +412,7 @@</span> <span class="p_context"> out:</span>
 
 SYSCALL_DEFINE1(sparc64_personality, unsigned long, personality)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	long ret;</span>
 
 	if (personality(current-&gt;personality) == PER_LINUX32 &amp;&amp;
 	    personality(personality) == PER_LINUX)
<span class="p_header">diff --git a/arch/um/os-Linux/start_up.c b/arch/um/os-Linux/start_up.c</span>
<span class="p_header">index 337518c5042a..b412c62486f0 100644</span>
<span class="p_header">--- a/arch/um/os-Linux/start_up.c</span>
<span class="p_header">+++ b/arch/um/os-Linux/start_up.c</span>
<span class="p_chunk">@@ -95,6 +95,8 @@</span> <span class="p_context"> static int start_ptraced_child(void)</span>
 {
 	int pid, n, status;
 
<span class="p_add">+	fflush(stdout);</span>
<span class="p_add">+</span>
 	pid = fork();
 	if (pid == 0)
 		ptrace_child();
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index ae7d543f23ed..8894f5bc4620 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -248,12 +248,19 @@</span> <span class="p_context"> static efi_status_t __init phys_efi_set_virtual_address_map(</span>
 	efi_memory_desc_t *virtual_map)
 {
 	efi_status_t status;
<span class="p_add">+	unsigned long flags;</span>
 
 	efi_call_phys_prelog();
<span class="p_add">+</span>
<span class="p_add">+	/* Disable interrupts around EFI calls: */</span>
<span class="p_add">+	local_irq_save(flags);</span>
 	status = efi_call_phys4(efi_phys.set_virtual_address_map,
 				memory_map_size, descriptor_size,
 				descriptor_version, virtual_map);
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
 	efi_call_phys_epilog();
<span class="p_add">+</span>
 	return status;
 }
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">index 9ee3491e31fb..be4e7eb41674 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_chunk">@@ -33,11 +33,10 @@</span> <span class="p_context"></span>
 
 /*
  * To make EFI call EFI runtime service in physical addressing mode we need
<span class="p_del">- * prelog/epilog before/after the invocation to disable interrupt, to</span>
<span class="p_del">- * claim EFI runtime service handler exclusively and to duplicate a memory in</span>
<span class="p_del">- * low memory space say 0 - 3G.</span>
<span class="p_add">+ * prolog/epilog before/after the invocation to claim the EFI runtime service</span>
<span class="p_add">+ * handler exclusively and to duplicate a memory mapping in low memory space,</span>
<span class="p_add">+ * say 0 - 3G.</span>
  */
<span class="p_del">-static unsigned long efi_rt_eflags;</span>
 
 void efi_sync_low_kernel_mappings(void) {}
 void __init efi_dump_pagetable(void) {}
<span class="p_chunk">@@ -59,8 +58,6 @@</span> <span class="p_context"> void efi_call_phys_prelog(void)</span>
 {
 	struct desc_ptr gdt_descr;
 
<span class="p_del">-	local_irq_save(efi_rt_eflags);</span>
<span class="p_del">-</span>
 	load_cr3(initial_page_table);
 	__flush_tlb_all();
 
<span class="p_chunk">@@ -79,8 +76,6 @@</span> <span class="p_context"> void efi_call_phys_epilog(void)</span>
 
 	load_cr3(swapper_pg_dir);
 	__flush_tlb_all();
<span class="p_del">-</span>
<span class="p_del">-	local_irq_restore(efi_rt_eflags);</span>
 }
 
 void __init efi_runtime_mkexec(void)
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index 666b74a09092..b1be0425c686 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -41,7 +41,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/realmode.h&gt;
 
 static pgd_t *save_pgd __initdata;
<span class="p_del">-static unsigned long efi_flags __initdata;</span>
 
 /*
  * We allocate runtime services regions bottom-up, starting from -4G, i.e.
<span class="p_chunk">@@ -87,7 +86,6 @@</span> <span class="p_context"> void __init efi_call_phys_prelog(void)</span>
 		return;
 
 	early_code_mapping_set_exec(1);
<span class="p_del">-	local_irq_save(efi_flags);</span>
 
 	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc(n_pgds * sizeof(pgd_t), GFP_KERNEL);
<span class="p_chunk">@@ -115,7 +113,6 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(void)</span>
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), save_pgd[pgd]);
 	kfree(save_pgd);
 	__flush_tlb_all();
<span class="p_del">-	local_irq_restore(efi_flags);</span>
 	early_code_mapping_set_exec(0);
 }
 
<span class="p_header">diff --git a/block/partitions/mac.c b/block/partitions/mac.c</span>
<span class="p_header">index 76d8ba6379a9..bd5b91465230 100644</span>
<span class="p_header">--- a/block/partitions/mac.c</span>
<span class="p_header">+++ b/block/partitions/mac.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	Sector sect;
 	unsigned char *data;
 	int slot, blocks_in_map;
<span class="p_del">-	unsigned secsize;</span>
<span class="p_add">+	unsigned secsize, datasize, partoffset;</span>
 #ifdef CONFIG_PPC_PMAC
 	int found_root = 0;
 	int found_root_goodness = 0;
<span class="p_chunk">@@ -50,10 +50,14 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	}
 	secsize = be16_to_cpu(md-&gt;block_size);
 	put_dev_sector(sect);
<span class="p_del">-	data = read_part_sector(state, secsize/512, &amp;sect);</span>
<span class="p_add">+	datasize = round_down(secsize, 512);</span>
<span class="p_add">+	data = read_part_sector(state, datasize / 512, &amp;sect);</span>
 	if (!data)
 		return -1;
<span class="p_del">-	part = (struct mac_partition *) (data + secsize%512);</span>
<span class="p_add">+	partoffset = secsize % 512;</span>
<span class="p_add">+	if (partoffset + sizeof(*part) &gt; datasize)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	part = (struct mac_partition *) (data + partoffset);</span>
 	if (be16_to_cpu(part-&gt;signature) != MAC_PARTITION_MAGIC) {
 		put_dev_sector(sect);
 		return 0;		/* not a MacOS disk */
<span class="p_header">diff --git a/crypto/async_tx/async_memcpy.c b/crypto/async_tx/async_memcpy.c</span>
<span class="p_header">index f8c0b8dbeb75..88bc8e6b2a54 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_memcpy.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_memcpy.c</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> async_memcpy(struct page *dest, struct page *src, unsigned int dest_offset,</span>
 	struct dmaengine_unmap_data *unmap = NULL;
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, 2, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, 2, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; is_dma_copy_aligned(device, src_offset, dest_offset, len)) {
 		unsigned long dma_prep_flags = 0;
<span class="p_header">diff --git a/crypto/async_tx/async_pq.c b/crypto/async_tx/async_pq.c</span>
<span class="p_header">index d05327caf69d..7eb264e65267 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_pq.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_pq.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> async_gen_syndrome(struct page **blocks, unsigned int offset, int disks,</span>
 	BUG_ON(disks &gt; 255 || !(P(blocks, disks) || Q(blocks, disks)));
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp;
 	    (src_cnt &lt;= dma_maxpq(device, 0) ||
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> async_syndrome_val(struct page **blocks, unsigned int offset, int disks,</span>
 	BUG_ON(disks &lt; 4);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, disks, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; disks &lt;= dma_maxpq(device, 0) &amp;&amp;
 	    is_dma_pq_aligned(device, offset, 0, len)) {
<span class="p_header">diff --git a/crypto/async_tx/async_raid6_recov.c b/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_header">index 934a84981495..8fab6275ea1f 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_raid6_recov.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> async_sum_product(struct page *dest, struct page **srcs, unsigned char *coef,</span>
 	u8 *a, *b, *c;
 
 	if (dma)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOWAIT);</span>
 
 	if (unmap) {
 		struct device *dev = dma-&gt;dev;
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> async_mult(struct page *dest, struct page *src, u8 coef, size_t len,</span>
 	u8 *d, *s;
 
 	if (dma)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(dma-&gt;dev, 3, GFP_NOWAIT);</span>
 
 	if (unmap) {
 		dma_addr_t dma_dest[2];
<span class="p_header">diff --git a/crypto/async_tx/async_xor.c b/crypto/async_tx/async_xor.c</span>
<span class="p_header">index e1bce26cd4f9..da75777f2b3f 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_xor.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_xor.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> async_xor(struct page *dest, struct page **src_list, unsigned int offset,</span>
 	BUG_ON(src_cnt &lt;= 1);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt+1, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt+1, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; is_dma_xor_aligned(device, offset, 0, len)) {
 		struct dma_async_tx_descriptor *tx;
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> async_xor_val(struct page *dest, struct page **src_list, unsigned int offset,</span>
 	BUG_ON(src_cnt &lt;= 1);
 
 	if (device)
<span class="p_del">-		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt, GFP_NOIO);</span>
<span class="p_add">+		unmap = dmaengine_get_unmap_data(device-&gt;dev, src_cnt, GFP_NOWAIT);</span>
 
 	if (unmap &amp;&amp; src_cnt &lt;= device-&gt;max_xor &amp;&amp;
 	    is_dma_xor_aligned(device, offset, 0, len)) {
<span class="p_header">diff --git a/drivers/ata/libata-sff.c b/drivers/ata/libata-sff.c</span>
<span class="p_header">index 136803c47cdb..96e5ed188636 100644</span>
<span class="p_header">--- a/drivers/ata/libata-sff.c</span>
<span class="p_header">+++ b/drivers/ata/libata-sff.c</span>
<span class="p_chunk">@@ -997,12 +997,9 @@</span> <span class="p_context"> static inline int ata_hsm_ok_in_wq(struct ata_port *ap,</span>
 static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)
 {
 	struct ata_port *ap = qc-&gt;ap;
<span class="p_del">-	unsigned long flags;</span>
 
 	if (ap-&gt;ops-&gt;error_handler) {
 		if (in_wq) {
<span class="p_del">-			spin_lock_irqsave(ap-&gt;lock, flags);</span>
<span class="p_del">-</span>
 			/* EH might have kicked in while host lock is
 			 * released.
 			 */
<span class="p_chunk">@@ -1014,8 +1011,6 @@</span> <span class="p_context"> static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)</span>
 				} else
 					ata_port_freeze(ap);
 			}
<span class="p_del">-</span>
<span class="p_del">-			spin_unlock_irqrestore(ap-&gt;lock, flags);</span>
 		} else {
 			if (likely(!(qc-&gt;err_mask &amp; AC_ERR_HSM)))
 				ata_qc_complete(qc);
<span class="p_chunk">@@ -1024,10 +1019,8 @@</span> <span class="p_context"> static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)</span>
 		}
 	} else {
 		if (in_wq) {
<span class="p_del">-			spin_lock_irqsave(ap-&gt;lock, flags);</span>
 			ata_sff_irq_on(ap);
 			ata_qc_complete(qc);
<span class="p_del">-			spin_unlock_irqrestore(ap-&gt;lock, flags);</span>
 		} else
 			ata_qc_complete(qc);
 	}
<span class="p_chunk">@@ -1048,9 +1041,10 @@</span> <span class="p_context"> int ata_sff_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,</span>
 {
 	struct ata_link *link = qc-&gt;dev-&gt;link;
 	struct ata_eh_info *ehi = &amp;link-&gt;eh_info;
<span class="p_del">-	unsigned long flags = 0;</span>
 	int poll_next;
 
<span class="p_add">+	lockdep_assert_held(ap-&gt;lock);</span>
<span class="p_add">+</span>
 	WARN_ON_ONCE((qc-&gt;flags &amp; ATA_QCFLAG_ACTIVE) == 0);
 
 	/* Make sure ata_sff_qc_issue() does not throw things
<span class="p_chunk">@@ -1112,14 +1106,6 @@</span> <span class="p_context"> fsm_start:</span>
 			}
 		}
 
<span class="p_del">-		/* Send the CDB (atapi) or the first data block (ata pio out).</span>
<span class="p_del">-		 * During the state transition, interrupt handler shouldn&#39;t</span>
<span class="p_del">-		 * be invoked before the data transfer is complete and</span>
<span class="p_del">-		 * hsm_task_state is changed. Hence, the following locking.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (in_wq)</span>
<span class="p_del">-			spin_lock_irqsave(ap-&gt;lock, flags);</span>
<span class="p_del">-</span>
 		if (qc-&gt;tf.protocol == ATA_PROT_PIO) {
 			/* PIO data out protocol.
 			 * send first data block.
<span class="p_chunk">@@ -1135,9 +1121,6 @@</span> <span class="p_context"> fsm_start:</span>
 			/* send CDB */
 			atapi_send_cdb(ap, qc);
 
<span class="p_del">-		if (in_wq)</span>
<span class="p_del">-			spin_unlock_irqrestore(ap-&gt;lock, flags);</span>
<span class="p_del">-</span>
 		/* if polling, ata_sff_pio_task() handles the rest.
 		 * otherwise, interrupt handler takes over from here.
 		 */
<span class="p_chunk">@@ -1361,12 +1344,14 @@</span> <span class="p_context"> static void ata_sff_pio_task(struct work_struct *work)</span>
 	u8 status;
 	int poll_next;
 
<span class="p_add">+	spin_lock_irq(ap-&gt;lock);</span>
<span class="p_add">+</span>
 	BUG_ON(ap-&gt;sff_pio_task_link == NULL);
 	/* qc can be NULL if timeout occurred */
 	qc = ata_qc_from_tag(ap, link-&gt;active_tag);
 	if (!qc) {
 		ap-&gt;sff_pio_task_link = NULL;
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
 
 fsm_start:
<span class="p_chunk">@@ -1381,11 +1366,14 @@</span> <span class="p_context"> fsm_start:</span>
 	 */
 	status = ata_sff_busy_wait(ap, ATA_BUSY, 5);
 	if (status &amp; ATA_BUSY) {
<span class="p_add">+		spin_unlock_irq(ap-&gt;lock);</span>
 		ata_msleep(ap, 2);
<span class="p_add">+		spin_lock_irq(ap-&gt;lock);</span>
<span class="p_add">+</span>
 		status = ata_sff_busy_wait(ap, ATA_BUSY, 10);
 		if (status &amp; ATA_BUSY) {
 			ata_sff_queue_pio_task(link, ATA_SHORT_PAUSE);
<span class="p_del">-			return;</span>
<span class="p_add">+			goto out_unlock;</span>
 		}
 	}
 
<span class="p_chunk">@@ -1402,6 +1390,8 @@</span> <span class="p_context"> fsm_start:</span>
 	 */
 	if (poll_next)
 		goto fsm_start;
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	spin_unlock_irq(ap-&gt;lock);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/ata/sata_sil.c b/drivers/ata/sata_sil.c</span>
<span class="p_header">index b7695e804635..fa94fba8fa21 100644</span>
<span class="p_header">--- a/drivers/ata/sata_sil.c</span>
<span class="p_header">+++ b/drivers/ata/sata_sil.c</span>
<span class="p_chunk">@@ -631,6 +631,9 @@</span> <span class="p_context"> static void sil_dev_config(struct ata_device *dev)</span>
 	unsigned int n, quirks = 0;
 	unsigned char model_num[ATA_ID_PROD_LEN + 1];
 
<span class="p_add">+	/* This controller doesn&#39;t support trim */</span>
<span class="p_add">+	dev-&gt;horkage |= ATA_HORKAGE_NOTRIM;</span>
<span class="p_add">+</span>
 	ata_id_c_string(dev-&gt;id, model_num, ATA_ID_PROD, sizeof(model_num));
 
 	for (n = 0; sil_blacklist[n].product; n++)
<span class="p_header">diff --git a/drivers/clocksource/vt8500_timer.c b/drivers/clocksource/vt8500_timer.c</span>
<span class="p_header">index 1098ed3b9b89..dc45ddb36117 100644</span>
<span class="p_header">--- a/drivers/clocksource/vt8500_timer.c</span>
<span class="p_header">+++ b/drivers/clocksource/vt8500_timer.c</span>
<span class="p_chunk">@@ -50,6 +50,8 @@</span> <span class="p_context"></span>
 
 #define msecs_to_loops(t) (loops_per_jiffy / 1000 * HZ * t)
 
<span class="p_add">+#define MIN_OSCR_DELTA		16</span>
<span class="p_add">+</span>
 static void __iomem *regbase;
 
 static cycle_t vt8500_timer_read(struct clocksource *cs)
<span class="p_chunk">@@ -80,7 +82,7 @@</span> <span class="p_context"> static int vt8500_timer_set_next_event(unsigned long cycles,</span>
 		cpu_relax();
 	writel((unsigned long)alarm, regbase + TIMER_MATCH_VAL);
 
<span class="p_del">-	if ((signed)(alarm - clocksource.read(&amp;clocksource)) &lt;= 16)</span>
<span class="p_add">+	if ((signed)(alarm - clocksource.read(&amp;clocksource)) &lt;= MIN_OSCR_DELTA)</span>
 		return -ETIME;
 
 	writel(1, regbase + TIMER_IER_VAL);
<span class="p_chunk">@@ -160,7 +162,7 @@</span> <span class="p_context"> static void __init vt8500_timer_init(struct device_node *np)</span>
 		pr_err(&quot;%s: setup_irq failed for %s\n&quot;, __func__,
 							clockevent.name);
 	clockevents_config_and_register(&amp;clockevent, VT8500_TIMER_HZ,
<span class="p_del">-					4, 0xf0000000);</span>
<span class="p_add">+					MIN_OSCR_DELTA * 2, 0xf0000000);</span>
 }
 
 CLOCKSOURCE_OF_DECLARE(vt8500, &quot;via,vt8500-timer&quot;, vt8500_timer_init);
<span class="p_header">diff --git a/drivers/dma/dw/core.c b/drivers/dma/dw/core.c</span>
<span class="p_header">index 3ae48ee2f488..df79cb0bf04e 100644</span>
<span class="p_header">--- a/drivers/dma/dw/core.c</span>
<span class="p_header">+++ b/drivers/dma/dw/core.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> static void dwc_initialize(struct dw_dma_chan *dwc)</span>
 
 /*----------------------------------------------------------------------*/
 
<span class="p_del">-static inline unsigned int dwc_fast_fls(unsigned long long v)</span>
<span class="p_add">+static inline unsigned int dwc_fast_ffs(unsigned long long v)</span>
 {
 	/*
 	 * We can be a lot more clever here, but this should take care
<span class="p_chunk">@@ -720,7 +720,7 @@</span> <span class="p_context"> dwc_prep_dma_memcpy(struct dma_chan *chan, dma_addr_t dest, dma_addr_t src,</span>
 			   dw-&gt;data_width[dwc-&gt;dst_master]);
 
 	src_width = dst_width = min_t(unsigned int, data_width,
<span class="p_del">-				      dwc_fast_fls(src | dest | len));</span>
<span class="p_add">+				      dwc_fast_ffs(src | dest | len));</span>
 
 	ctllo = DWC_DEFAULT_CTLLO(chan)
 			| DWC_CTLL_DST_WIDTH(dst_width)
<span class="p_chunk">@@ -799,7 +799,7 @@</span> <span class="p_context"> dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 
 	switch (direction) {
 	case DMA_MEM_TO_DEV:
<span class="p_del">-		reg_width = __fls(sconfig-&gt;dst_addr_width);</span>
<span class="p_add">+		reg_width = __ffs(sconfig-&gt;dst_addr_width);</span>
 		reg = sconfig-&gt;dst_addr;
 		ctllo = (DWC_DEFAULT_CTLLO(chan)
 				| DWC_CTLL_DST_WIDTH(reg_width)
<span class="p_chunk">@@ -819,7 +819,7 @@</span> <span class="p_context"> dwc_prep_slave_sg(struct dma_chan *chan, struct scatterlist *sgl,</span>
 			len = sg_dma_len(sg);
 
 			mem_width = min_t(unsigned int,
<span class="p_del">-					  data_width, dwc_fast_fls(mem | len));</span>
<span class="p_add">+					  data_width, dwc_fast_ffs(mem | len));</span>
 
 slave_sg_todev_fill_desc:
 			desc = dwc_desc_get(dwc);
<span class="p_chunk">@@ -859,7 +859,7 @@</span> <span class="p_context"> slave_sg_todev_fill_desc:</span>
 		}
 		break;
 	case DMA_DEV_TO_MEM:
<span class="p_del">-		reg_width = __fls(sconfig-&gt;src_addr_width);</span>
<span class="p_add">+		reg_width = __ffs(sconfig-&gt;src_addr_width);</span>
 		reg = sconfig-&gt;src_addr;
 		ctllo = (DWC_DEFAULT_CTLLO(chan)
 				| DWC_CTLL_SRC_WIDTH(reg_width)
<span class="p_chunk">@@ -879,7 +879,7 @@</span> <span class="p_context"> slave_sg_todev_fill_desc:</span>
 			len = sg_dma_len(sg);
 
 			mem_width = min_t(unsigned int,
<span class="p_del">-					  data_width, dwc_fast_fls(mem | len));</span>
<span class="p_add">+					  data_width, dwc_fast_ffs(mem | len));</span>
 
 slave_sg_fromdev_fill_desc:
 			desc = dwc_desc_get(dwc);
<span class="p_header">diff --git a/drivers/edac/edac_device.c b/drivers/edac/edac_device.c</span>
<span class="p_header">index 592af5f0cf39..53587377e672 100644</span>
<span class="p_header">--- a/drivers/edac/edac_device.c</span>
<span class="p_header">+++ b/drivers/edac/edac_device.c</span>
<span class="p_chunk">@@ -435,16 +435,13 @@</span> <span class="p_context"> void edac_device_workq_setup(struct edac_device_ctl_info *edac_dev,</span>
  */
 void edac_device_workq_teardown(struct edac_device_ctl_info *edac_dev)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
 	if (!edac_dev-&gt;edac_check)
 		return;
 
<span class="p_del">-	status = cancel_delayed_work(&amp;edac_dev-&gt;work);</span>
<span class="p_del">-	if (status == 0) {</span>
<span class="p_del">-		/* workq instance might be running, wait for it */</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	edac_dev-&gt;op_state = OP_OFFLINE;</span>
<span class="p_add">+</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;edac_dev-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/edac/edac_mc.c b/drivers/edac/edac_mc.c</span>
<span class="p_header">index 33edd6766344..19dc0bc9b136 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc.c</span>
<span class="p_chunk">@@ -584,18 +584,10 @@</span> <span class="p_context"> static void edac_mc_workq_setup(struct mem_ctl_info *mci, unsigned msec,</span>
  */
 static void edac_mc_workq_teardown(struct mem_ctl_info *mci)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mci-&gt;op_state != OP_RUNNING_POLL)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	status = cancel_delayed_work(&amp;mci-&gt;work);</span>
<span class="p_del">-	if (status == 0) {</span>
<span class="p_del">-		edac_dbg(0, &quot;not canceled, flush the queue\n&quot;);</span>
<span class="p_add">+	mci-&gt;op_state = OP_OFFLINE;</span>
 
<span class="p_del">-		/* workq instance might be running, wait for it */</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;mci-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/edac/edac_pci.c b/drivers/edac/edac_pci.c</span>
<span class="p_header">index 2cf44b4db80c..b4b38603b804 100644</span>
<span class="p_header">--- a/drivers/edac/edac_pci.c</span>
<span class="p_header">+++ b/drivers/edac/edac_pci.c</span>
<span class="p_chunk">@@ -274,13 +274,12 @@</span> <span class="p_context"> static void edac_pci_workq_setup(struct edac_pci_ctl_info *pci,</span>
  */
 static void edac_pci_workq_teardown(struct edac_pci_ctl_info *pci)
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
 	edac_dbg(0, &quot;\n&quot;);
 
<span class="p_del">-	status = cancel_delayed_work(&amp;pci-&gt;work);</span>
<span class="p_del">-	if (status == 0)</span>
<span class="p_del">-		flush_workqueue(edac_workqueue);</span>
<span class="p_add">+	pci-&gt;op_state = OP_OFFLINE;</span>
<span class="p_add">+</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pci-&gt;work);</span>
<span class="p_add">+	flush_workqueue(edac_workqueue);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_drv.h b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">index 9833a1b1acc1..3fc122306f1f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_chunk">@@ -296,6 +296,7 @@</span> <span class="p_context"> int ast_framebuffer_init(struct drm_device *dev,</span>
 int ast_fbdev_init(struct drm_device *dev);
 void ast_fbdev_fini(struct drm_device *dev);
 void ast_fbdev_set_suspend(struct drm_device *dev, int state);
<span class="p_add">+void ast_fbdev_set_base(struct ast_private *ast, unsigned long gpu_addr);</span>
 
 struct ast_bo {
 	struct ttm_buffer_object bo;
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_fb.c b/drivers/gpu/drm/ast/ast_fb.c</span>
<span class="p_header">index a28640f47c27..b55b6b1c9fe2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_fb.c</span>
<span class="p_chunk">@@ -367,3 +367,10 @@</span> <span class="p_context"> void ast_fbdev_set_suspend(struct drm_device *dev, int state)</span>
 
 	fb_set_suspend(ast-&gt;fbdev-&gt;helper.fbdev, state);
 }
<span class="p_add">+</span>
<span class="p_add">+void ast_fbdev_set_base(struct ast_private *ast, unsigned long gpu_addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ast-&gt;fbdev-&gt;helper.fbdev-&gt;fix.smem_start =</span>
<span class="p_add">+		ast-&gt;fbdev-&gt;helper.fbdev-&gt;apertures-&gt;ranges[0].base + gpu_addr;</span>
<span class="p_add">+	ast-&gt;fbdev-&gt;helper.fbdev-&gt;fix.smem_len = ast-&gt;vram_size - gpu_addr;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">index d830b38e54f6..c0f284230a39 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_chunk">@@ -312,6 +312,7 @@</span> <span class="p_context"> int ast_driver_load(struct drm_device *dev, unsigned long flags)</span>
 	dev-&gt;mode_config.min_height = 0;
 	dev-&gt;mode_config.preferred_depth = 24;
 	dev-&gt;mode_config.prefer_shadow = 1;
<span class="p_add">+	dev-&gt;mode_config.fb_base = pci_resource_start(ast-&gt;dev-&gt;pdev, 0);</span>
 
 	if (ast-&gt;chip == AST2100 ||
 	    ast-&gt;chip == AST2200 ||
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_mode.c b/drivers/gpu/drm/ast/ast_mode.c</span>
<span class="p_header">index d2e56e95d886..cea916fa164b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_mode.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_mode.c</span>
<span class="p_chunk">@@ -509,6 +509,8 @@</span> <span class="p_context"> static int ast_crtc_do_set_base(struct drm_crtc *crtc,</span>
 		ret = ttm_bo_kmap(&amp;bo-&gt;bo, 0, bo-&gt;bo.num_pages, &amp;bo-&gt;kmap);
 		if (ret)
 			DRM_ERROR(&quot;failed to kmap fbcon\n&quot;);
<span class="p_add">+		else</span>
<span class="p_add">+			ast_fbdev_set_base(ast, gpu_addr);</span>
 	}
 	ast_bo_unreserve(bo);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 958b26dcac8a..0a9d1fd32994 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -8821,11 +8821,21 @@</span> <span class="p_context"> connected_sink_compute_bpp(struct intel_connector * connector,</span>
 		pipe_config-&gt;pipe_bpp = connector-&gt;base.display_info.bpc*3;
 	}
 
<span class="p_del">-	/* Clamp bpp to 8 on screens without EDID 1.4 */</span>
<span class="p_del">-	if (connector-&gt;base.display_info.bpc == 0 &amp;&amp; bpp &gt; 24) {</span>
<span class="p_del">-		DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of 24\n&quot;,</span>
<span class="p_del">-			      bpp);</span>
<span class="p_del">-		pipe_config-&gt;pipe_bpp = 24;</span>
<span class="p_add">+	/* Clamp bpp to default limit on screens without EDID 1.4 */</span>
<span class="p_add">+	if (connector-&gt;base.display_info.bpc == 0) {</span>
<span class="p_add">+		int type = connector-&gt;base.connector_type;</span>
<span class="p_add">+		int clamp_bpp = 24;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Fall back to 18 bpp when DP sink capability is unknown. */</span>
<span class="p_add">+		if (type == DRM_MODE_CONNECTOR_DisplayPort ||</span>
<span class="p_add">+		    type == DRM_MODE_CONNECTOR_eDP)</span>
<span class="p_add">+			clamp_bpp = 18;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (bpp &gt; clamp_bpp) {</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of %d\n&quot;,</span>
<span class="p_add">+				      bpp, clamp_bpp);</span>
<span class="p_add">+			pipe_config-&gt;pipe_bpp = clamp_bpp;</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">index 56a13a915155..0928c5e2bafd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_chunk">@@ -168,7 +168,8 @@</span> <span class="p_context"> static int qxl_process_single_command(struct qxl_device *qdev,</span>
 		       cmd-&gt;command_size))
 		return -EFAULT;
 
<span class="p_del">-	reloc_info = kmalloc(sizeof(struct qxl_reloc_info) * cmd-&gt;relocs_num, GFP_KERNEL);</span>
<span class="p_add">+	reloc_info = kmalloc_array(cmd-&gt;relocs_num,</span>
<span class="p_add">+				   sizeof(struct qxl_reloc_info), GFP_KERNEL);</span>
 	if (!reloc_info)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index 2fa3cf615a67..6a3b5f92219f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -436,7 +436,9 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 	}
 
 	/* Fujitsu D3003-S2 board lists DVI-I as DVI-D and VGA */
<span class="p_del">-	if (((dev-&gt;pdev-&gt;device == 0x9802) || (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
<span class="p_add">+	if (((dev-&gt;pdev-&gt;device == 0x9802) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9805) ||</span>
<span class="p_add">+	     (dev-&gt;pdev-&gt;device == 0x9806)) &amp;&amp;</span>
 	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;
 	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {
 		if (*connector_type == DRM_MODE_CONNECTOR_VGA) {
<span class="p_chunk">@@ -447,14 +449,6 @@</span> <span class="p_context"> static bool radeon_atom_apply_quirks(struct drm_device *dev,</span>
 		}
 	}
 
<span class="p_del">-	/* Fujitsu D3003-S2 board lists DVI-I as DVI-I and VGA */</span>
<span class="p_del">-	if ((dev-&gt;pdev-&gt;device == 0x9805) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_vendor == 0x1734) &amp;&amp;</span>
<span class="p_del">-	    (dev-&gt;pdev-&gt;subsystem_device == 0x11bd)) {</span>
<span class="p_del">-		if (*connector_type == DRM_MODE_CONNECTOR_VGA)</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return true;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index f8b20e1c0820..614144d34aea 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -79,6 +79,11 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	/* we can race here at startup, some boards seem to trigger</span>
<span class="p_add">+	 * hotplug irqs when they shouldn&#39;t. */</span>
<span class="p_add">+	if (!rdev-&gt;mode_info.mode_config_initialized)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;mode_config-&gt;mutex);
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">index 0b00de55b2a4..9a559140e4a3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_chunk">@@ -915,8 +915,6 @@</span> <span class="p_context"> static void radeon_dpm_change_power_state_locked(struct radeon_device *rdev)</span>
 
 	/* update display watermarks based on new power state */
 	radeon_bandwidth_update(rdev);
<span class="p_del">-	/* update displays */</span>
<span class="p_del">-	radeon_dpm_display_configuration_changed(rdev);</span>
 
 	rdev-&gt;pm.dpm.current_active_crtcs = rdev-&gt;pm.dpm.new_active_crtcs;
 	rdev-&gt;pm.dpm.current_active_crtc_count = rdev-&gt;pm.dpm.new_active_crtc_count;
<span class="p_chunk">@@ -936,6 +934,9 @@</span> <span class="p_context"> static void radeon_dpm_change_power_state_locked(struct radeon_device *rdev)</span>
 
 	radeon_dpm_post_set_power_state(rdev);
 
<span class="p_add">+	/* update displays */</span>
<span class="p_add">+	radeon_dpm_display_configuration_changed(rdev);</span>
<span class="p_add">+</span>
 	if (rdev-&gt;asic-&gt;dpm.force_performance_level) {
 		if (rdev-&gt;pm.dpm.thermal_active) {
 			enum radeon_dpm_forced_level level = rdev-&gt;pm.dpm.forced_level;
<span class="p_chunk">@@ -1364,8 +1365,7 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);
 				if (ret)
 					DRM_ERROR(&quot;failed to create device file for power method\n&quot;);
<span class="p_del">-				if (!ret)</span>
<span class="p_del">-					rdev-&gt;pm.sysfs_initialized = true;</span>
<span class="p_add">+				rdev-&gt;pm.sysfs_initialized = true;</span>
 			}
 
 			mutex_lock(&amp;rdev-&gt;pm.mutex);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_sa.c b/drivers/gpu/drm/radeon/radeon_sa.c</span>
<span class="p_header">index c0625805cdd7..a1d684266549 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_sa.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_sa.c</span>
<span class="p_chunk">@@ -349,8 +349,13 @@</span> <span class="p_context"> int radeon_sa_bo_new(struct radeon_device *rdev,</span>
 			/* see if we can skip over some allocations */
 		} while (radeon_sa_bo_next_hole(sa_manager, fences, tries));
 
<span class="p_add">+		for (i = 0; i &lt; RADEON_NUM_RINGS; ++i)</span>
<span class="p_add">+			radeon_fence_ref(fences[i]);</span>
<span class="p_add">+</span>
 		spin_unlock(&amp;sa_manager-&gt;wq.lock);
 		r = radeon_fence_wait_any(rdev, fences, false);
<span class="p_add">+		for (i = 0; i &lt; RADEON_NUM_RINGS; ++i)</span>
<span class="p_add">+			radeon_fence_unref(&amp;fences[i]);</span>
 		spin_lock(&amp;sa_manager-&gt;wq.lock);
 		/* if we have nothing to wait for block */
 		if (r == -ENOENT &amp;&amp; block) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index 45a9a03efc06..2d50433b8c72 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -623,7 +623,7 @@</span> <span class="p_context"> static int radeon_ttm_tt_populate(struct ttm_tt *ttm)</span>
 						       0, PAGE_SIZE,
 						       PCI_DMA_BIDIRECTIONAL);
 		if (pci_dma_mapping_error(rdev-&gt;pdev, gtt-&gt;ttm.dma_address[i])) {
<span class="p_del">-			while (--i) {</span>
<span class="p_add">+			while (i--) {</span>
 				pci_unmap_page(rdev-&gt;pdev, gtt-&gt;ttm.dma_address[i],
 					       PAGE_SIZE, PCI_DMA_BIDIRECTIONAL);
 				gtt-&gt;ttm.dma_address[i] = 0;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv770_dpm.c b/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_header">index 8fcb932a3a55..aaefb10aa09e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv770_dpm.c</span>
<span class="p_chunk">@@ -1415,7 +1415,7 @@</span> <span class="p_context"> int rv770_resume_smc(struct radeon_device *rdev)</span>
 int rv770_set_sw_state(struct radeon_device *rdev)
 {
 	if (rv770_send_msg_to_smc(rdev, PPSMC_MSG_SwitchToSwState) != PPSMC_Result_OK)
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		DRM_ERROR(&quot;rv770_set_sw_state failed\n&quot;);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">index 0771dcbf9ed0..7c48070cf9d8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
  *
  **************************************************************************/
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
 
 #include &lt;drm/drmP.h&gt;
 #include &quot;vmwgfx_drv.h&quot;
<span class="p_chunk">@@ -1383,6 +1384,12 @@</span> <span class="p_context"> static int vmw_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 static int __init vmwgfx_init(void)
 {
 	int ret;
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_VGA_CONSOLE</span>
<span class="p_add">+	if (vgacon_text_force())</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	ret = drm_pci_init(&amp;driver, &amp;vmw_pci_driver);
 	if (ret)
 		DRM_ERROR(&quot;Failed initializing DRM.\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">index af0259708358..bbb554d586d4 100644</span>
<span class="p_header">--- a/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">+++ b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_chunk">@@ -392,8 +392,10 @@</span> <span class="p_context"> int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)</span>
 		set_current_state(interruptible ?
 				  TASK_INTERRUPTIBLE :
 				  TASK_UNINTERRUPTIBLE);
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_del">-			rc = -EINTR;</span>
<span class="p_add">+		if (interruptible &amp;&amp; signal_pending(current)) {</span>
<span class="p_add">+			__set_current_state(TASK_RUNNING);</span>
<span class="p_add">+			remove_wait_queue(&amp;vga_wait_queue, &amp;wait);</span>
<span class="p_add">+			rc = -ERESTARTSYS;</span>
 			break;
 		}
 		schedule();
<span class="p_header">diff --git a/drivers/hwmon/ads1015.c b/drivers/hwmon/ads1015.c</span>
<span class="p_header">index 126516414c11..44223f5d92d8 100644</span>
<span class="p_header">--- a/drivers/hwmon/ads1015.c</span>
<span class="p_header">+++ b/drivers/hwmon/ads1015.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> static int ads1015_reg_to_mv(struct i2c_client *client, unsigned int channel,</span>
 	struct ads1015_data *data = i2c_get_clientdata(client);
 	unsigned int pga = data-&gt;channel_data[channel].pga;
 	int fullscale = fullscale_table[pga];
<span class="p_del">-	const unsigned mask = data-&gt;id == ads1115 ? 0x7fff : 0x7ff0;</span>
<span class="p_add">+	const int mask = data-&gt;id == ads1115 ? 0x7fff : 0x7ff0;</span>
 
 	return DIV_ROUND_CLOSEST(reg * fullscale, mask);
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb3/iwch_cm.c b/drivers/infiniband/hw/cxgb3/iwch_cm.c</span>
<span class="p_header">index 095bb046e2c8..875348699e6e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb3/iwch_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb3/iwch_cm.c</span>
<span class="p_chunk">@@ -149,7 +149,7 @@</span> <span class="p_context"> static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_en</span>
 	error = l2t_send(tdev, skb, l2e);
 	if (error &lt; 0)
 		kfree_skb(skb);
<span class="p_del">-	return error;</span>
<span class="p_add">+	return error &lt; 0 ? error : 0;</span>
 }
 
 int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> int iwch_cxgb3_ofld_send(struct t3cdev *tdev, struct sk_buff *skb)</span>
 	error = cxgb3_ofld_send(tdev, skb);
 	if (error &lt; 0)
 		kfree_skb(skb);
<span class="p_del">-	return error;</span>
<span class="p_add">+	return error &lt; 0 ? error : 0;</span>
 }
 
 static void release_tid(struct t3cdev *tdev, u32 hwtid, struct sk_buff *skb)
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs_mcast.c b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">index dabb697b1c2a..48ba1c3e945a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs_mcast.c</span>
<span class="p_chunk">@@ -286,15 +286,13 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	struct qib_ibdev *dev = to_idev(ibqp-&gt;device);
 	struct qib_ibport *ibp = to_iport(ibqp-&gt;device, qp-&gt;port_num);
 	struct qib_mcast *mcast = NULL;
<span class="p_del">-	struct qib_mcast_qp *p, *tmp;</span>
<span class="p_add">+	struct qib_mcast_qp *p, *tmp, *delp = NULL;</span>
 	struct rb_node *n;
 	int last = 0;
 	int ret;
 
<span class="p_del">-	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET) {</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ibqp-&gt;qp_num &lt;= 1 || qp-&gt;state == IB_QPS_RESET)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	spin_lock_irq(&amp;ibp-&gt;lock);
 
<span class="p_chunk">@@ -303,8 +301,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	while (1) {
 		if (n == NULL) {
 			spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			goto bail;</span>
<span class="p_add">+			return -EINVAL;</span>
 		}
 
 		mcast = rb_entry(n, struct qib_mcast, rb_node);
<span class="p_chunk">@@ -328,6 +325,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		 */
 		list_del_rcu(&amp;p-&gt;list);
 		mcast-&gt;n_attached--;
<span class="p_add">+		delp = p;</span>
 
 		/* If this was the last attached QP, remove the GID too. */
 		if (list_empty(&amp;mcast-&gt;qp_list)) {
<span class="p_chunk">@@ -338,15 +336,16 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 	}
 
 	spin_unlock_irq(&amp;ibp-&gt;lock);
<span class="p_add">+	/* QP not attached */</span>
<span class="p_add">+	if (!delp)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Wait for any list walkers to finish before freeing the</span>
<span class="p_add">+	 * list element.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_add">+	qib_mcast_qp_free(delp);</span>
 
<span class="p_del">-	if (p) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Wait for any list walkers to finish before freeing the</span>
<span class="p_del">-		 * list element.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		wait_event(mcast-&gt;wait, atomic_read(&amp;mcast-&gt;refcount) &lt;= 1);</span>
<span class="p_del">-		qib_mcast_qp_free(p);</span>
<span class="p_del">-	}</span>
 	if (last) {
 		atomic_dec(&amp;mcast-&gt;refcount);
 		wait_event(mcast-&gt;wait, !atomic_read(&amp;mcast-&gt;refcount));
<span class="p_chunk">@@ -355,11 +354,7 @@</span> <span class="p_context"> int qib_multicast_detach(struct ib_qp *ibqp, union ib_gid *gid, u16 lid)</span>
 		dev-&gt;n_mcast_grps_allocated--;
 		spin_unlock_irq(&amp;dev-&gt;n_mcast_grps_lock);
 	}
<span class="p_del">-</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-bail:</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int qib_mcast_tree_empty(struct qib_ibport *ibp)
<span class="p_header">diff --git a/drivers/irqchip/irq-versatile-fpga.c b/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_header">index 3ae2bb8d9cf2..21a44b168d46 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-versatile-fpga.c</span>
<span class="p_chunk">@@ -204,7 +204,12 @@</span> <span class="p_context"> int __init fpga_irq_of_init(struct device_node *node,</span>
 	if (!parent_irq)
 		parent_irq = -1;
 
<span class="p_add">+#ifdef CONFIG_ARCH_VERSATILE</span>
<span class="p_add">+	fpga_irq_init(base, node-&gt;name, IRQ_SIC_START, parent_irq, valid_mask,</span>
<span class="p_add">+				  node);</span>
<span class="p_add">+#else</span>
 	fpga_irq_init(base, node-&gt;name, 0, parent_irq, valid_mask, node);
<span class="p_add">+#endif</span>
 
 	writel(clear_mask, base + IRQ_ENABLE_CLEAR);
 	writel(clear_mask, base + FIQ_ENABLE_CLEAR);
<span class="p_header">diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.c</span>
<span class="p_header">index fbcb6225f794..74a5786ddcce 100644</span>
<span class="p_header">--- a/drivers/md/bcache/btree.c</span>
<span class="p_header">+++ b/drivers/md/bcache/btree.c</span>
<span class="p_chunk">@@ -1641,6 +1641,7 @@</span> <span class="p_context"> static void bch_btree_gc(struct cache_set *c)</span>
 	do {
 		ret = btree_root(gc_root, c, &amp;op, &amp;writes, &amp;stats);
 		closure_sync(&amp;writes);
<span class="p_add">+		cond_resched();</span>
 
 		if (ret &amp;&amp; ret != -EAGAIN)
 			pr_warn(&quot;gc failed!&quot;);
<span class="p_chunk">@@ -2037,8 +2038,10 @@</span> <span class="p_context"> int bch_btree_insert_check_key(struct btree *b, struct btree_op *op,</span>
 		rw_lock(true, b, b-&gt;level);
 
 		if (b-&gt;key.ptr[0] != btree_ptr ||
<span class="p_del">-		    b-&gt;seq != seq + 1)</span>
<span class="p_add">+                   b-&gt;seq != seq + 1) {</span>
<span class="p_add">+                       op-&gt;lock = b-&gt;level;</span>
 			goto out;
<span class="p_add">+               }</span>
 	}
 
 	SET_KEY_PTRS(check_key, 1);
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index 24a3a1546caa..1b6beb1e3142 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -712,6 +712,8 @@</span> <span class="p_context"> static void bcache_device_link(struct bcache_device *d, struct cache_set *c,</span>
 	WARN(sysfs_create_link(&amp;d-&gt;kobj, &amp;c-&gt;kobj, &quot;cache&quot;) ||
 	     sysfs_create_link(&amp;c-&gt;kobj, &amp;d-&gt;kobj, d-&gt;name),
 	     &quot;Couldn&#39;t create device &lt;-&gt; cache set symlinks&quot;);
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(BCACHE_DEV_UNLINK_DONE, &amp;d-&gt;flags);</span>
 }
 
 static void bcache_device_detach(struct bcache_device *d)
<span class="p_chunk">@@ -882,8 +884,11 @@</span> <span class="p_context"> void bch_cached_dev_run(struct cached_dev *dc)</span>
 	buf[SB_LABEL_SIZE] = &#39;\0&#39;;
 	env[2] = kasprintf(GFP_KERNEL, &quot;CACHED_LABEL=%s&quot;, buf);
 
<span class="p_del">-	if (atomic_xchg(&amp;dc-&gt;running, 1))</span>
<span class="p_add">+	if (atomic_xchg(&amp;dc-&gt;running, 1)) {</span>
<span class="p_add">+		kfree(env[1]);</span>
<span class="p_add">+		kfree(env[2]);</span>
 		return;
<span class="p_add">+	}</span>
 
 	if (!d-&gt;c &amp;&amp;
 	    BDEV_STATE(&amp;dc-&gt;sb) != BDEV_STATE_NONE) {
<span class="p_chunk">@@ -2081,8 +2086,10 @@</span> <span class="p_context"> static int __init bcache_init(void)</span>
 	closure_debug_init();
 
 	bcache_major = register_blkdev(0, &quot;bcache&quot;);
<span class="p_del">-	if (bcache_major &lt; 0)</span>
<span class="p_add">+	if (bcache_major &lt; 0) {</span>
<span class="p_add">+		unregister_reboot_notifier(&amp;reboot);</span>
 		return bcache_major;
<span class="p_add">+	}</span>
 
 	if (!(bcache_wq = create_workqueue(&quot;bcache&quot;)) ||
 	    !(bcache_kobj = kobject_create_and_add(&quot;bcache&quot;, fs_kobj)) ||
<span class="p_header">diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.c</span>
<span class="p_header">index f4300e4c0114..d6525c12c8d8 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.c</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.c</span>
<span class="p_chunk">@@ -323,6 +323,10 @@</span> <span class="p_context"> void bcache_dev_sectors_dirty_add(struct cache_set *c, unsigned inode,</span>
 
 static bool dirty_pred(struct keybuf *buf, struct bkey *k)
 {
<span class="p_add">+	struct cached_dev *dc = container_of(buf, struct cached_dev, writeback_keys);</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(KEY_INODE(k) != dc-&gt;disk.id);</span>
<span class="p_add">+</span>
 	return KEY_DIRTY(k);
 }
 
<span class="p_chunk">@@ -372,11 +376,24 @@</span> <span class="p_context"> next:</span>
 	}
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Returns true if we scanned the entire disk</span>
<span class="p_add">+ */</span>
 static bool refill_dirty(struct cached_dev *dc)
 {
 	struct keybuf *buf = &amp;dc-&gt;writeback_keys;
<span class="p_add">+	struct bkey start = KEY(dc-&gt;disk.id, 0, 0);</span>
 	struct bkey end = KEY(dc-&gt;disk.id, MAX_KEY_OFFSET, 0);
<span class="p_del">-	bool searched_from_start = false;</span>
<span class="p_add">+	struct bkey start_pos;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure keybuf pos is inside the range for this disk - at bringup</span>
<span class="p_add">+	 * we might not be attached yet so this disk&#39;s inode nr isn&#39;t</span>
<span class="p_add">+	 * initialized then</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bkey_cmp(&amp;buf-&gt;last_scanned, &amp;start) &lt; 0 ||</span>
<span class="p_add">+	    bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &gt; 0)</span>
<span class="p_add">+		buf-&gt;last_scanned = start;</span>
 
 	if (dc-&gt;partial_stripes_expensive) {
 		refill_full_stripes(dc);
<span class="p_chunk">@@ -384,14 +401,20 @@</span> <span class="p_context"> static bool refill_dirty(struct cached_dev *dc)</span>
 			return false;
 	}
 
<span class="p_del">-	if (bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &gt;= 0) {</span>
<span class="p_del">-		buf-&gt;last_scanned = KEY(dc-&gt;disk.id, 0, 0);</span>
<span class="p_del">-		searched_from_start = true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_add">+	start_pos = buf-&gt;last_scanned;</span>
 	bch_refill_keybuf(dc-&gt;disk.c, buf, &amp;end, dirty_pred);
 
<span class="p_del">-	return bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &gt;= 0 &amp;&amp; searched_from_start;</span>
<span class="p_add">+	if (bkey_cmp(&amp;buf-&gt;last_scanned, &amp;end) &lt; 0)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we get to the end start scanning again from the beginning, and</span>
<span class="p_add">+	 * only scan up to where we initially started scanning from:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	buf-&gt;last_scanned = start;</span>
<span class="p_add">+	bch_refill_keybuf(dc-&gt;disk.c, buf, &amp;start_pos, dirty_pred);</span>
<span class="p_add">+</span>
<span class="p_add">+	return bkey_cmp(&amp;buf-&gt;last_scanned, &amp;start_pos) &gt;= 0;</span>
 }
 
 static int bch_writeback_thread(void *arg)
<span class="p_header">diff --git a/drivers/md/bcache/writeback.h b/drivers/md/bcache/writeback.h</span>
<span class="p_header">index e2f8598937ac..afe7ecada503 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.h</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.h</span>
<span class="p_chunk">@@ -63,7 +63,8 @@</span> <span class="p_context"> static inline bool should_writeback(struct cached_dev *dc, struct bio *bio,</span>
 
 static inline void bch_writeback_queue(struct cached_dev *dc)
 {
<span class="p_del">-	wake_up_process(dc-&gt;writeback_thread);</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(dc-&gt;writeback_thread))</span>
<span class="p_add">+		wake_up_process(dc-&gt;writeback_thread);</span>
 }
 
 static inline void bch_writeback_add(struct cached_dev *dc)
<span class="p_header">diff --git a/drivers/md/dm-exception-store.h b/drivers/md/dm-exception-store.h</span>
<span class="p_header">index 0b2536247cf5..84e27708ad97 100644</span>
<span class="p_header">--- a/drivers/md/dm-exception-store.h</span>
<span class="p_header">+++ b/drivers/md/dm-exception-store.h</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> struct dm_exception_store_type {</span>
 	 * Update the metadata with this exception.
 	 */
 	void (*commit_exception) (struct dm_exception_store *store,
<span class="p_del">-				  struct dm_exception *e,</span>
<span class="p_add">+				  struct dm_exception *e, int valid,</span>
 				  void (*callback) (void *, int success),
 				  void *callback_context);
 
<span class="p_header">diff --git a/drivers/md/dm-snap-persistent.c b/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">index d6e88178d22c..d3272acc0f0e 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-persistent.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-persistent.c</span>
<span class="p_chunk">@@ -700,7 +700,7 @@</span> <span class="p_context"> static int persistent_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void persistent_commit_exception(struct dm_exception_store *store,
<span class="p_del">-					struct dm_exception *e,</span>
<span class="p_add">+					struct dm_exception *e, int valid,</span>
 					void (*callback) (void *, int success),
 					void *callback_context)
 {
<span class="p_chunk">@@ -709,6 +709,9 @@</span> <span class="p_context"> static void persistent_commit_exception(struct dm_exception_store *store,</span>
 	struct core_exception ce;
 	struct commit_callback *cb;
 
<span class="p_add">+	if (!valid)</span>
<span class="p_add">+		ps-&gt;valid = 0;</span>
<span class="p_add">+</span>
 	ce.old_chunk = e-&gt;old_chunk;
 	ce.new_chunk = e-&gt;new_chunk;
 	write_exception(ps, ps-&gt;current_committed++, &amp;ce);
<span class="p_header">diff --git a/drivers/md/dm-snap-transient.c b/drivers/md/dm-snap-transient.c</span>
<span class="p_header">index 1ce9a2586e41..31439d53cf7e 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap-transient.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap-transient.c</span>
<span class="p_chunk">@@ -52,12 +52,12 @@</span> <span class="p_context"> static int transient_prepare_exception(struct dm_exception_store *store,</span>
 }
 
 static void transient_commit_exception(struct dm_exception_store *store,
<span class="p_del">-				       struct dm_exception *e,</span>
<span class="p_add">+				       struct dm_exception *e, int valid,</span>
 				       void (*callback) (void *, int success),
 				       void *callback_context)
 {
 	/* Just succeed */
<span class="p_del">-	callback(callback_context, 1);</span>
<span class="p_add">+	callback(callback_context, valid);</span>
 }
 
 static void transient_usage(struct dm_exception_store *store,
<span class="p_header">diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c</span>
<span class="p_header">index c356a10b9ba5..2e9117630dbe 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap.c</span>
<span class="p_chunk">@@ -1388,8 +1388,9 @@</span> <span class="p_context"> static void __invalidate_snapshot(struct dm_snapshot *s, int err)</span>
 	dm_table_event(s-&gt;ti-&gt;table);
 }
 
<span class="p_del">-static void pending_complete(struct dm_snap_pending_exception *pe, int success)</span>
<span class="p_add">+static void pending_complete(void *context, int success)</span>
 {
<span class="p_add">+	struct dm_snap_pending_exception *pe = context;</span>
 	struct dm_exception *e;
 	struct dm_snapshot *s = pe-&gt;snap;
 	struct bio *origin_bios = NULL;
<span class="p_chunk">@@ -1460,24 +1461,13 @@</span> <span class="p_context"> out:</span>
 	free_pending_exception(pe);
 }
 
<span class="p_del">-static void commit_callback(void *context, int success)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dm_snap_pending_exception *pe = context;</span>
<span class="p_del">-</span>
<span class="p_del">-	pending_complete(pe, success);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void complete_exception(struct dm_snap_pending_exception *pe)
 {
 	struct dm_snapshot *s = pe-&gt;snap;
 
<span class="p_del">-	if (unlikely(pe-&gt;copy_error))</span>
<span class="p_del">-		pending_complete(pe, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	else</span>
<span class="p_del">-		/* Update the metadata if we are persistent */</span>
<span class="p_del">-		s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e,</span>
<span class="p_del">-						 commit_callback, pe);</span>
<span class="p_add">+	/* Update the metadata if we are persistent */</span>
<span class="p_add">+	s-&gt;store-&gt;type-&gt;commit_exception(s-&gt;store, &amp;pe-&gt;e, !pe-&gt;copy_error,</span>
<span class="p_add">+					 pending_complete, pe);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/dm-thin-metadata.c b/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">index 3412b86e79fd..7768de60f699 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin-metadata.c</span>
<span class="p_chunk">@@ -1205,6 +1205,12 @@</span> <span class="p_context"> static int __reserve_metadata_snap(struct dm_pool_metadata *pmd)</span>
 	dm_block_t held_root;
 
 	/*
<span class="p_add">+	 * We commit to ensure the btree roots which we increment in a</span>
<span class="p_add">+	 * moment are up to date.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__commit_transaction(pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Copy the superblock.
 	 */
 	dm_sm_inc_block(pmd-&gt;metadata_sm, THIN_SUPERBLOCK_LOCATION);
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index b94e4648c199..d633a3921b3c 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -1619,6 +1619,7 @@</span> <span class="p_context"> static void set_pool_mode(struct pool *pool, enum pool_mode new_mode)</span>
 	case PM_WRITE:
 		if (old_mode != new_mode)
 			notify_of_pool_mode_change(pool, &quot;write&quot;);
<span class="p_add">+		pool-&gt;pf.error_if_no_space = pt-&gt;requested_pf.error_if_no_space;</span>
 		dm_pool_metadata_read_write(pool-&gt;pmd);
 		pool-&gt;process_bio = process_bio;
 		pool-&gt;process_discard = process_discard;
<span class="p_chunk">@@ -2567,8 +2568,8 @@</span> <span class="p_context"> static void pool_postsuspend(struct dm_target *ti)</span>
 	struct pool_c *pt = ti-&gt;private;
 	struct pool *pool = pt-&gt;pool;
 
<span class="p_del">-	cancel_delayed_work(&amp;pool-&gt;waker);</span>
<span class="p_del">-	cancel_delayed_work(&amp;pool-&gt;no_space_timeout);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pool-&gt;waker);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;pool-&gt;no_space_timeout);</span>
 	flush_workqueue(pool-&gt;wq);
 	(void) commit(pool);
 }
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 7ba85e2b146b..7b4bb1f09b01 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -250,6 +250,16 @@</span> <span class="p_context"> static void pop_frame(struct del_stack *s)</span>
 	dm_tm_unlock(s-&gt;tm, f-&gt;b);
 }
 
<span class="p_add">+static void unlock_all_frames(struct del_stack *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct frame *f;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (unprocessed_frames(s)) {</span>
<span class="p_add">+		f = s-&gt;spine + s-&gt;top--;</span>
<span class="p_add">+		dm_tm_unlock(s-&gt;tm, f-&gt;b);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int dm_btree_del(struct dm_btree_info *info, dm_block_t root)
 {
 	int r;
<span class="p_chunk">@@ -306,9 +316,13 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 			pop_frame(s);
 		}
 	}
<span class="p_del">-</span>
 out:
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		/* cleanup all frames of del_stack */</span>
<span class="p_add">+		unlock_all_frames(s);</span>
<span class="p_add">+	}</span>
 	kfree(s);
<span class="p_add">+</span>
 	return r;
 }
 EXPORT_SYMBOL_GPL(dm_btree_del);
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index 199c9ccd1f5d..032ee39a0e9b 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> static int brb_push(struct bop_ring_buffer *brb,</span>
 	return 0;
 }
 
<span class="p_del">-static int brb_pop(struct bop_ring_buffer *brb, struct block_op *result)</span>
<span class="p_add">+static int brb_peek(struct bop_ring_buffer *brb, struct block_op *result)</span>
 {
 	struct block_op *bop;
 
<span class="p_chunk">@@ -147,6 +147,14 @@</span> <span class="p_context"> static int brb_pop(struct bop_ring_buffer *brb, struct block_op *result)</span>
 	result-&gt;type = bop-&gt;type;
 	result-&gt;block = bop-&gt;block;
 
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int brb_pop(struct bop_ring_buffer *brb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (brb_empty(brb))</span>
<span class="p_add">+		return -ENODATA;</span>
<span class="p_add">+</span>
 	brb-&gt;begin = brb_next(brb, brb-&gt;begin);
 
 	return 0;
<span class="p_chunk">@@ -211,7 +219,7 @@</span> <span class="p_context"> static int apply_bops(struct sm_metadata *smm)</span>
 	while (!brb_empty(&amp;smm-&gt;uncommitted)) {
 		struct block_op bop;
 
<span class="p_del">-		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		r = brb_peek(&amp;smm-&gt;uncommitted, &amp;bop);</span>
 		if (r) {
 			DMERR(&quot;bug in bop ring buffer&quot;);
 			break;
<span class="p_chunk">@@ -220,6 +228,8 @@</span> <span class="p_context"> static int apply_bops(struct sm_metadata *smm)</span>
 		r = commit_bop(smm, &amp;bop);
 		if (r)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		brb_pop(&amp;smm-&gt;uncommitted);</span>
 	}
 
 	return r;
<span class="p_chunk">@@ -681,7 +691,6 @@</span> <span class="p_context"> static struct dm_space_map bootstrap_ops = {</span>
 static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)
 {
 	int r, i;
<span class="p_del">-	enum allocation_event ev;</span>
 	struct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);
 	dm_block_t old_len = smm-&gt;ll.nr_blocks;
 
<span class="p_chunk">@@ -703,11 +712,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 	 * allocate any new blocks.
 	 */
 	do {
<span class="p_del">-		for (i = old_len; !r &amp;&amp; i &lt; smm-&gt;begin; i++) {</span>
<span class="p_del">-			r = sm_ll_inc(&amp;smm-&gt;ll, i, &amp;ev);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		for (i = old_len; !r &amp;&amp; i &lt; smm-&gt;begin; i++)</span>
<span class="p_add">+			r = add_bop(smm, BOP_INC, i);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		old_len = smm-&gt;begin;
 
 		r = apply_bops(smm);
<span class="p_chunk">@@ -752,7 +762,6 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 {
 	int r;
 	dm_block_t i;
<span class="p_del">-	enum allocation_event ev;</span>
 	struct sm_metadata *smm = container_of(sm, struct sm_metadata, sm);
 
 	smm-&gt;begin = superblock + 1;
<span class="p_chunk">@@ -780,7 +789,7 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	 * allocated blocks that they were built from.
 	 */
 	for (i = superblock; !r &amp;&amp; i &lt; smm-&gt;begin; i++)
<span class="p_del">-		r = sm_ll_inc(&amp;smm-&gt;ll, i, &amp;ev);</span>
<span class="p_add">+		r = add_bop(smm, BOP_INC, i);</span>
 
 	if (r)
 		return r;
<span class="p_header">diff --git a/drivers/media/dvb-core/dvb_frontend.c b/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_header">index 1f925e856974..46a984291b7d 100644</span>
<span class="p_header">--- a/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_header">+++ b/drivers/media/dvb-core/dvb_frontend.c</span>
<span class="p_chunk">@@ -2195,9 +2195,9 @@</span> <span class="p_context"> static int dvb_frontend_ioctl_legacy(struct file *file,</span>
 		dev_dbg(fe-&gt;dvb-&gt;device, &quot;%s: current delivery system on cache: %d, V3 type: %d\n&quot;,
 				 __func__, c-&gt;delivery_system, fe-&gt;ops.info.type);
 
<span class="p_del">-		/* Force the CAN_INVERSION_AUTO bit on. If the frontend doesn&#39;t</span>
<span class="p_del">-		 * do it, it is done for it. */</span>
<span class="p_del">-		info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
<span class="p_add">+		/* Set CAN_INVERSION_AUTO bit on in other than oneshot mode */</span>
<span class="p_add">+		if (!(fepriv-&gt;tune_mode_flags &amp; FE_TUNE_MODE_ONESHOT))</span>
<span class="p_add">+			info-&gt;caps |= FE_CAN_INVERSION_AUTO;</span>
 		err = 0;
 		break;
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/tda1004x.c b/drivers/media/dvb-frontends/tda1004x.c</span>
<span class="p_header">index a2631be7ffac..08e0f0dd8728 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/tda1004x.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/tda1004x.c</span>
<span class="p_chunk">@@ -903,9 +903,18 @@</span> <span class="p_context"> static int tda1004x_get_fe(struct dvb_frontend *fe)</span>
 {
 	struct dtv_frontend_properties *fe_params = &amp;fe-&gt;dtv_property_cache;
 	struct tda1004x_state* state = fe-&gt;demodulator_priv;
<span class="p_add">+	int status;</span>
 
 	dprintk(&quot;%s\n&quot;, __func__);
 
<span class="p_add">+	status = tda1004x_read_byte(state, TDA1004X_STATUS_CD);</span>
<span class="p_add">+	if (status == -1)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only update the properties cache if device is locked */</span>
<span class="p_add">+	if (!(status &amp; 8))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	// inversion status
 	fe_params-&gt;inversion = INVERSION_OFF;
 	if (tda1004x_read_byte(state, TDA1004X_CONFC1) &amp; 0x20)
<span class="p_header">diff --git a/drivers/media/usb/gspca/ov534.c b/drivers/media/usb/gspca/ov534.c</span>
<span class="p_header">index 90f0d637cd9d..cd05840abc91 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/ov534.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/ov534.c</span>
<span class="p_chunk">@@ -1490,8 +1490,13 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	struct sd *sd = (struct sd *) gspca_dev;
 
<span class="p_del">-	/* Set requested framerate */</span>
<span class="p_del">-	sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		/* Set default framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/* Set requested framerate */</span>
<span class="p_add">+		sd-&gt;frame_rate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		set_frame_rate(gspca_dev);
 
<span class="p_header">diff --git a/drivers/media/usb/gspca/topro.c b/drivers/media/usb/gspca/topro.c</span>
<span class="p_header">index 640c2fe760b3..a6fbb2a07979 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/topro.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/topro.c</span>
<span class="p_chunk">@@ -4792,7 +4792,11 @@</span> <span class="p_context"> static void sd_set_streamparm(struct gspca_dev *gspca_dev,</span>
 	struct v4l2_fract *tpf = &amp;cp-&gt;timeperframe;
 	int fr, i;
 
<span class="p_del">-	sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+	if (tpf-&gt;numerator == 0 || tpf-&gt;denominator == 0)</span>
<span class="p_add">+		sd-&gt;framerate = 30;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sd-&gt;framerate = tpf-&gt;denominator / tpf-&gt;numerator;</span>
<span class="p_add">+</span>
 	if (gspca_dev-&gt;streaming)
 		setframerate(gspca_dev, v4l2_ctrl_g_ctrl(gspca_dev-&gt;exposure));
 
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index d71f5ef036e0..92aeb1d2b41b 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -62,8 +62,7 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;mmc:block&quot;);</span>
 #define MMC_SANITIZE_REQ_TIMEOUT 240000
 #define MMC_EXTRACT_INDEX_FROM_ARG(x) ((x &amp; 0x00FF0000) &gt;&gt; 16)
 
<span class="p_del">-#define mmc_req_rel_wr(req)	(((req-&gt;cmd_flags &amp; REQ_FUA) || \</span>
<span class="p_del">-				  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp; \</span>
<span class="p_add">+#define mmc_req_rel_wr(req)	((req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp; \</span>
 				  (rq_data_dir(req) == WRITE))
 #define PACKED_CMD_VER	0x01
 #define PACKED_CMD_WR	0x02
<span class="p_chunk">@@ -1328,13 +1327,9 @@</span> <span class="p_context"> static void mmc_blk_rw_rq_prep(struct mmc_queue_req *mqrq,</span>
 
 	/*
 	 * Reliable writes are used to implement Forced Unit Access and
<span class="p_del">-	 * REQ_META accesses, and are supported only on MMCs.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * XXX: this really needs a good explanation of why REQ_META</span>
<span class="p_del">-	 * is treated special.</span>
<span class="p_add">+	 * are supported only on MMCs.</span>
 	 */
<span class="p_del">-	bool do_rel_wr = ((req-&gt;cmd_flags &amp; REQ_FUA) ||</span>
<span class="p_del">-			  (req-&gt;cmd_flags &amp; REQ_META)) &amp;&amp;</span>
<span class="p_add">+	bool do_rel_wr = (req-&gt;cmd_flags &amp; REQ_FUA) &amp;&amp;</span>
 		(rq_data_dir(req) == WRITE) &amp;&amp;
 		(md-&gt;flags &amp; MMC_BLK_REL_WR);
 
<span class="p_header">diff --git a/drivers/mmc/core/sdio.c b/drivers/mmc/core/sdio.c</span>
<span class="p_header">index 4d721c6e2af0..ae360b3b4fda 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sdio.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sdio.c</span>
<span class="p_chunk">@@ -670,7 +670,7 @@</span> <span class="p_context"> try_again:</span>
 	 */
 	if (!powered_resume &amp;&amp; (rocr &amp; ocr &amp; R4_18V_PRESENT)) {
 		err = mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180,
<span class="p_del">-					ocr);</span>
<span class="p_add">+					ocr_card);</span>
 		if (err == -EAGAIN) {
 			sdio_reset(host);
 			mmc_go_idle(host);
<span class="p_header">diff --git a/drivers/mmc/host/mmci.c b/drivers/mmc/host/mmci.c</span>
<span class="p_header">index b93122636531..8103db25db69 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mmci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mmci.c</span>
<span class="p_chunk">@@ -1860,7 +1860,7 @@</span> <span class="p_context"> static struct amba_id mmci_ids[] = {</span>
 	{
 		.id     = 0x00280180,
 		.mask   = 0x00ffffff,
<span class="p_del">-		.data	= &amp;variant_u300,</span>
<span class="p_add">+		.data	= &amp;variant_nomadik,</span>
 	},
 	{
 		.id     = 0x00480180,
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 881bf89acfcc..75d3c28940f1 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -2663,7 +2663,7 @@</span> <span class="p_context"> static int sdhci_runtime_pm_put(struct sdhci_host *host)</span>
 
 static void sdhci_runtime_pm_bus_on(struct sdhci_host *host)
 {
<span class="p_del">-	if (host-&gt;runtime_suspended || host-&gt;bus_on)</span>
<span class="p_add">+	if (host-&gt;bus_on)</span>
 		return;
 	host-&gt;bus_on = true;
 	pm_runtime_get_noresume(host-&gt;mmc-&gt;parent);
<span class="p_chunk">@@ -2671,7 +2671,7 @@</span> <span class="p_context"> static void sdhci_runtime_pm_bus_on(struct sdhci_host *host)</span>
 
 static void sdhci_runtime_pm_bus_off(struct sdhci_host *host)
 {
<span class="p_del">-	if (host-&gt;runtime_suspended || !host-&gt;bus_on)</span>
<span class="p_add">+	if (!host-&gt;bus_on)</span>
 		return;
 	host-&gt;bus_on = false;
 	pm_runtime_put_noidle(host-&gt;mmc-&gt;parent);
<span class="p_header">diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">index c2d0559115d3..732a8ed571c2 100644</span>
<span class="p_header">--- a/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">+++ b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_chunk">@@ -187,6 +187,9 @@</span> <span class="p_context"> static void sja1000_start(struct net_device *dev)</span>
 	/* clear interrupt flags */
 	priv-&gt;read_reg(priv, SJA1000_IR);
 
<span class="p_add">+	/* clear interrupt flags */</span>
<span class="p_add">+	priv-&gt;read_reg(priv, SJA1000_IR);</span>
<span class="p_add">+</span>
 	/* leave reset mode */
 	set_normal_mode(dev);
 }
<span class="p_header">diff --git a/drivers/net/can/usb/ems_usb.c b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">index 52c42fd49510..a5735a7797f8 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/ems_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/ems_usb.c</span>
<span class="p_chunk">@@ -117,6 +117,9 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL v2&quot;);</span>
  */
 #define EMS_USB_ARM7_CLOCK 8000000
 
<span class="p_add">+#define CPC_TX_QUEUE_TRIGGER_LOW	25</span>
<span class="p_add">+#define CPC_TX_QUEUE_TRIGGER_HIGH	35</span>
<span class="p_add">+</span>
 /*
  * CAN-Message representation in a CPC_MSG. Message object type is
  * CPC_MSG_TYPE_CAN_FRAME or CPC_MSG_TYPE_RTR_FRAME or
<span class="p_chunk">@@ -278,6 +281,11 @@</span> <span class="p_context"> static void ems_usb_read_interrupt_callback(struct urb *urb)</span>
 	switch (urb-&gt;status) {
 	case 0:
 		dev-&gt;free_slots = dev-&gt;intr_in_buffer[1];
<span class="p_add">+		if(dev-&gt;free_slots &gt; CPC_TX_QUEUE_TRIGGER_HIGH){</span>
<span class="p_add">+			if (netif_queue_stopped(netdev)){</span>
<span class="p_add">+				netif_wake_queue(netdev);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 		break;
 
 	case -ECONNRESET: /* unlink */
<span class="p_chunk">@@ -529,8 +537,6 @@</span> <span class="p_context"> static void ems_usb_write_bulk_callback(struct urb *urb)</span>
 	/* Release context */
 	context-&gt;echo_index = MAX_TX_URBS;
 
<span class="p_del">-	if (netif_queue_stopped(netdev))</span>
<span class="p_del">-		netif_wake_queue(netdev);</span>
 }
 
 /*
<span class="p_chunk">@@ -590,7 +596,7 @@</span> <span class="p_context"> static int ems_usb_start(struct ems_usb *dev)</span>
 	int err, i;
 
 	dev-&gt;intr_in_buffer[0] = 0;
<span class="p_del">-	dev-&gt;free_slots = 15; /* initial size */</span>
<span class="p_add">+	dev-&gt;free_slots = 50; /* initial size */</span>
 
 	for (i = 0; i &lt; MAX_RX_URBS; i++) {
 		struct urb *urb = NULL;
<span class="p_chunk">@@ -841,7 +847,7 @@</span> <span class="p_context"> static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *ne</span>
 
 		/* Slow down tx path */
 		if (atomic_read(&amp;dev-&gt;active_tx_urbs) &gt;= MAX_TX_URBS ||
<span class="p_del">-		    dev-&gt;free_slots &lt; 5) {</span>
<span class="p_add">+		    dev-&gt;free_slots &lt; CPC_TX_QUEUE_TRIGGER_LOW) {</span>
 			netif_stop_queue(netdev);
 		}
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h</span>
<span class="p_header">index 1fbeaa9dd202..6ef93562c6b7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x.h</span>
<span class="p_chunk">@@ -2401,10 +2401,13 @@</span> <span class="p_context"> void bnx2x_igu_clear_sb_gen(struct bnx2x *bp, u8 func, u8 idu_sb_id,</span>
 				 AEU_INPUTS_ATTN_BITS_IGU_PARITY_ERROR | \
 				 AEU_INPUTS_ATTN_BITS_MISC_PARITY_ERROR)
 
<span class="p_del">-#define HW_PRTY_ASSERT_SET_3 (AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY | \</span>
<span class="p_del">-		AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY | \</span>
<span class="p_del">-		AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY | \</span>
<span class="p_del">-		AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY)</span>
<span class="p_add">+#define HW_PRTY_ASSERT_SET_3_WITHOUT_SCPAD \</span>
<span class="p_add">+		(AEU_INPUTS_ATTN_BITS_MCP_LATCHED_ROM_PARITY | \</span>
<span class="p_add">+		 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_RX_PARITY | \</span>
<span class="p_add">+		 AEU_INPUTS_ATTN_BITS_MCP_LATCHED_UMP_TX_PARITY)</span>
<span class="p_add">+</span>
<span class="p_add">+#define HW_PRTY_ASSERT_SET_3 (HW_PRTY_ASSERT_SET_3_WITHOUT_SCPAD | \</span>
<span class="p_add">+			      AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY)</span>
 
 #define HW_PRTY_ASSERT_SET_4 (AEU_INPUTS_ATTN_BITS_PGLUE_PARITY_ERROR | \
 			      AEU_INPUTS_ATTN_BITS_ATC_PARITY_ERROR)
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">index 242874041ba4..e157adb85b2a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_chunk">@@ -4631,9 +4631,7 @@</span> <span class="p_context"> static bool bnx2x_check_blocks_with_parity3(struct bnx2x *bp, u32 sig,</span>
 				res |= true;
 				break;
 			case AEU_INPUTS_ATTN_BITS_MCP_LATCHED_SCPAD_PARITY:
<span class="p_del">-				if (print)</span>
<span class="p_del">-					_print_next_block((*par_num)++,</span>
<span class="p_del">-							  &quot;MCP SCPAD&quot;);</span>
<span class="p_add">+				(*par_num)++;</span>
 				/* clear latched SCPAD PATIRY from MCP */
 				REG_WR(bp, MISC_REG_AEU_CLR_LATCH_SIGNAL,
 				       1UL &lt;&lt; 10);
<span class="p_chunk">@@ -4695,6 +4693,7 @@</span> <span class="p_context"> static bool bnx2x_parity_attn(struct bnx2x *bp, bool *global, bool print,</span>
 	    (sig[3] &amp; HW_PRTY_ASSERT_SET_3) ||
 	    (sig[4] &amp; HW_PRTY_ASSERT_SET_4)) {
 		int par_num = 0;
<span class="p_add">+</span>
 		DP(NETIF_MSG_HW, &quot;Was parity error: HW block parity attention:\n&quot;
 				 &quot;[0]:0x%08x [1]:0x%08x [2]:0x%08x [3]:0x%08x [4]:0x%08x\n&quot;,
 			  sig[0] &amp; HW_PRTY_ASSERT_SET_0,
<span class="p_chunk">@@ -4702,9 +4701,18 @@</span> <span class="p_context"> static bool bnx2x_parity_attn(struct bnx2x *bp, bool *global, bool print,</span>
 			  sig[2] &amp; HW_PRTY_ASSERT_SET_2,
 			  sig[3] &amp; HW_PRTY_ASSERT_SET_3,
 			  sig[4] &amp; HW_PRTY_ASSERT_SET_4);
<span class="p_del">-		if (print)</span>
<span class="p_del">-			netdev_err(bp-&gt;dev,</span>
<span class="p_del">-				   &quot;Parity errors detected in blocks: &quot;);</span>
<span class="p_add">+		if (print) {</span>
<span class="p_add">+			if (((sig[0] &amp; HW_PRTY_ASSERT_SET_0) ||</span>
<span class="p_add">+			     (sig[1] &amp; HW_PRTY_ASSERT_SET_1) ||</span>
<span class="p_add">+			     (sig[2] &amp; HW_PRTY_ASSERT_SET_2) ||</span>
<span class="p_add">+			     (sig[4] &amp; HW_PRTY_ASSERT_SET_4)) ||</span>
<span class="p_add">+			     (sig[3] &amp; HW_PRTY_ASSERT_SET_3_WITHOUT_SCPAD)) {</span>
<span class="p_add">+				netdev_err(bp-&gt;dev,</span>
<span class="p_add">+					   &quot;Parity errors detected in blocks: &quot;);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				print = false;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 		res |= bnx2x_check_blocks_with_parity0(bp,
 			sig[0] &amp; HW_PRTY_ASSERT_SET_0, &amp;par_num, print);
 		res |= bnx2x_check_blocks_with_parity1(bp,
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/drv.c b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">index 988f9fec0bff..d8c1b69d0f66 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_chunk">@@ -367,6 +367,7 @@</span> <span class="p_context"> static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {</span>
 	{IWL_PCI_DEVICE(0x095B, 0x5310, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095B, 0x5302, iwl7265_n_cfg)},
 	{IWL_PCI_DEVICE(0x095B, 0x5210, iwl7265_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x5C10, iwl7265_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x095A, 0x5012, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5412, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5410, iwl7265_2ac_cfg)},
<span class="p_chunk">@@ -383,10 +384,10 @@</span> <span class="p_context"> static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {</span>
 	{IWL_PCI_DEVICE(0x095A, 0x9012, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9110, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9112, iwl7265_2ac_cfg)},
<span class="p_del">-	{IWL_PCI_DEVICE(0x095A, 0x9210, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x9210, iwl7265_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x095B, 0x9200, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9510, iwl7265_2ac_cfg)},
<span class="p_del">-	{IWL_PCI_DEVICE(0x095A, 0x9310, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x9310, iwl7265_2ac_cfg)},</span>
 	{IWL_PCI_DEVICE(0x095A, 0x9410, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5020, iwl7265_2n_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x502A, iwl7265_2n_cfg)},
<span class="p_header">diff --git a/drivers/pci/hotplug/acpiphp_glue.c b/drivers/pci/hotplug/acpiphp_glue.c</span>
<span class="p_header">index 7c7a388c85ab..126f641a9582 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/acpiphp_glue.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/acpiphp_glue.c</span>
<span class="p_chunk">@@ -1133,8 +1133,10 @@</span> <span class="p_context"> int acpiphp_enable_slot(struct acpiphp_slot *slot)</span>
 {
 	pci_lock_rescan_remove();
 
<span class="p_del">-	if (slot-&gt;flags &amp; SLOT_IS_GOING_AWAY)</span>
<span class="p_add">+	if (slot-&gt;flags &amp; SLOT_IS_GOING_AWAY) {</span>
<span class="p_add">+		pci_unlock_rescan_remove();</span>
 		return -ENODEV;
<span class="p_add">+	}</span>
 
 	mutex_lock(&amp;slot-&gt;crit_sect);
 	/* configure all functions */
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv.c b/drivers/pci/pcie/aer/aerdrv.c</span>
<span class="p_header">index 0bf82a20a0fb..48d21e0edd56 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv.c</span>
<span class="p_chunk">@@ -262,7 +262,6 @@</span> <span class="p_context"> static struct aer_rpc *aer_alloc_rpc(struct pcie_device *dev)</span>
 	rpc-&gt;rpd = dev;
 	INIT_WORK(&amp;rpc-&gt;dpc_handler, aer_isr);
 	mutex_init(&amp;rpc-&gt;rpc_mutex);
<span class="p_del">-	init_waitqueue_head(&amp;rpc-&gt;wait_release);</span>
 
 	/* Use PCIe bus function to store rpc into PCIe device */
 	set_service_data(dev, rpc);
<span class="p_chunk">@@ -285,8 +284,7 @@</span> <span class="p_context"> static void aer_remove(struct pcie_device *dev)</span>
 		if (rpc-&gt;isr)
 			free_irq(dev-&gt;irq, dev);
 
<span class="p_del">-		wait_event(rpc-&gt;wait_release, rpc-&gt;prod_idx == rpc-&gt;cons_idx);</span>
<span class="p_del">-</span>
<span class="p_add">+		flush_work(&amp;rpc-&gt;dpc_handler);</span>
 		aer_disable_rootport(rpc);
 		kfree(rpc);
 		set_service_data(dev, NULL);
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv.h b/drivers/pci/pcie/aer/aerdrv.h</span>
<span class="p_header">index 84420b7c9456..945c939a86c5 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv.h</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv.h</span>
<span class="p_chunk">@@ -72,7 +72,6 @@</span> <span class="p_context"> struct aer_rpc {</span>
 					 * recovery on the same
 					 * root port hierarchy
 					 */
<span class="p_del">-	wait_queue_head_t wait_release;</span>
 };
 
 struct aer_broadcast_data {
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">index b2c8881da764..777edcc4aab6 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_chunk">@@ -785,8 +785,6 @@</span> <span class="p_context"> void aer_isr(struct work_struct *work)</span>
 	while (get_e_source(rpc, &amp;e_src))
 		aer_isr_one_error(p_device, &amp;e_src);
 	mutex_unlock(&amp;rpc-&gt;rpc_mutex);
<span class="p_del">-</span>
<span class="p_del">-	wake_up(&amp;rpc-&gt;wait_release);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/pci/xen-pcifront.c b/drivers/pci/xen-pcifront.c</span>
<span class="p_header">index 179b8edc2262..318d535e337d 100644</span>
<span class="p_header">--- a/drivers/pci/xen-pcifront.c</span>
<span class="p_header">+++ b/drivers/pci/xen-pcifront.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> struct pcifront_device {</span>
 };
 
 struct pcifront_sd {
<span class="p_del">-	int domain;</span>
<span class="p_add">+	struct pci_sysdata sd;</span>
 	struct pcifront_device *pdev;
 };
 
<span class="p_chunk">@@ -66,7 +66,9 @@</span> <span class="p_context"> static inline void pcifront_init_sd(struct pcifront_sd *sd,</span>
 				    unsigned int domain, unsigned int bus,
 				    struct pcifront_device *pdev)
 {
<span class="p_del">-	sd-&gt;domain = domain;</span>
<span class="p_add">+	/* Because we do not expose that information via XenBus. */</span>
<span class="p_add">+	sd-&gt;sd.node = first_online_node;</span>
<span class="p_add">+	sd-&gt;sd.domain = domain;</span>
 	sd-&gt;pdev = pdev;
 }
 
<span class="p_chunk">@@ -464,8 +466,8 @@</span> <span class="p_context"> static int pcifront_scan_root(struct pcifront_device *pdev,</span>
 	dev_info(&amp;pdev-&gt;xdev-&gt;dev, &quot;Creating PCI Frontend Bus %04x:%02x\n&quot;,
 		 domain, bus);
 
<span class="p_del">-	bus_entry = kmalloc(sizeof(*bus_entry), GFP_KERNEL);</span>
<span class="p_del">-	sd = kmalloc(sizeof(*sd), GFP_KERNEL);</span>
<span class="p_add">+	bus_entry = kzalloc(sizeof(*bus_entry), GFP_KERNEL);</span>
<span class="p_add">+	sd = kzalloc(sizeof(*sd), GFP_KERNEL);</span>
 	if (!bus_entry || !sd) {
 		err = -ENOMEM;
 		goto err_out;
<span class="p_header">diff --git a/drivers/power/wm831x_power.c b/drivers/power/wm831x_power.c</span>
<span class="p_header">index 3bed2f55cf7d..3ccadf631d45 100644</span>
<span class="p_header">--- a/drivers/power/wm831x_power.c</span>
<span class="p_header">+++ b/drivers/power/wm831x_power.c</span>
<span class="p_chunk">@@ -567,7 +567,7 @@</span> <span class="p_context"> static int wm831x_power_probe(struct platform_device *pdev)</span>
 
 	irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, &quot;SYSLO&quot;));
 	ret = request_threaded_irq(irq, NULL, wm831x_syslo_irq,
<span class="p_del">-				   IRQF_TRIGGER_RISING, &quot;System power low&quot;,</span>
<span class="p_add">+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT, &quot;System power low&quot;,</span>
 				   power);
 	if (ret != 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to request SYSLO IRQ %d: %d\n&quot;,
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> static int wm831x_power_probe(struct platform_device *pdev)</span>
 
 	irq = wm831x_irq(wm831x, platform_get_irq_byname(pdev, &quot;PWR SRC&quot;));
 	ret = request_threaded_irq(irq, NULL, wm831x_pwr_src_irq,
<span class="p_del">-				   IRQF_TRIGGER_RISING, &quot;Power source&quot;,</span>
<span class="p_add">+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT, &quot;Power source&quot;,</span>
 				   power);
 	if (ret != 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to request PWR SRC IRQ %d: %d\n&quot;,
<span class="p_chunk">@@ -590,7 +590,7 @@</span> <span class="p_context"> static int wm831x_power_probe(struct platform_device *pdev)</span>
 				 platform_get_irq_byname(pdev,
 							 wm831x_bat_irqs[i]));
 		ret = request_threaded_irq(irq, NULL, wm831x_bat_irq,
<span class="p_del">-					   IRQF_TRIGGER_RISING,</span>
<span class="p_add">+					   IRQF_TRIGGER_RISING | IRQF_ONESHOT,</span>
 					   wm831x_bat_irqs[i],
 					   power);
 		if (ret != 0) {
<span class="p_header">diff --git a/drivers/powercap/intel_rapl.c b/drivers/powercap/intel_rapl.c</span>
<span class="p_header">index 3c6768378a94..4048d7f5babd 100644</span>
<span class="p_header">--- a/drivers/powercap/intel_rapl.c</span>
<span class="p_header">+++ b/drivers/powercap/intel_rapl.c</span>
<span class="p_chunk">@@ -1194,10 +1194,13 @@</span> <span class="p_context"> static int rapl_detect_domains(struct rapl_package *rp, int cpu)</span>
 
 	for (rd = rp-&gt;domains; rd &lt; rp-&gt;domains + rp-&gt;nr_domains; rd++) {
 		/* check if the domain is locked by BIOS */
<span class="p_del">-		if (rapl_read_data_raw(rd, FW_LOCK, false, &amp;locked)) {</span>
<span class="p_add">+		ret = rapl_read_data_raw(rd, FW_LOCK, false, &amp;locked);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		if (locked) {</span>
 			pr_info(&quot;RAPL package %d domain %s locked by BIOS\n&quot;,
 				rp-&gt;id, rd-&gt;name);
<span class="p_del">-				rd-&gt;state |= DOMAIN_STATE_BIOS_LOCKED;</span>
<span class="p_add">+			rd-&gt;state |= DOMAIN_STATE_BIOS_LOCKED;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/s390/block/dasd_alias.c b/drivers/s390/block/dasd_alias.c</span>
<span class="p_header">index a2597e683e79..6a64e86e8ccd 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd_alias.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd_alias.c</span>
<span class="p_chunk">@@ -264,8 +264,10 @@</span> <span class="p_context"> void dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)</span>
 		spin_unlock_irqrestore(&amp;lcu-&gt;lock, flags);
 		cancel_work_sync(&amp;lcu-&gt;suc_data.worker);
 		spin_lock_irqsave(&amp;lcu-&gt;lock, flags);
<span class="p_del">-		if (device == lcu-&gt;suc_data.device)</span>
<span class="p_add">+		if (device == lcu-&gt;suc_data.device) {</span>
<span class="p_add">+			dasd_put_device(device);</span>
 			lcu-&gt;suc_data.device = NULL;
<span class="p_add">+		}</span>
 	}
 	was_pending = 0;
 	if (device == lcu-&gt;ruac_data.device) {
<span class="p_chunk">@@ -273,8 +275,10 @@</span> <span class="p_context"> void dasd_alias_disconnect_device_from_lcu(struct dasd_device *device)</span>
 		was_pending = 1;
 		cancel_delayed_work_sync(&amp;lcu-&gt;ruac_data.dwork);
 		spin_lock_irqsave(&amp;lcu-&gt;lock, flags);
<span class="p_del">-		if (device == lcu-&gt;ruac_data.device)</span>
<span class="p_add">+		if (device == lcu-&gt;ruac_data.device) {</span>
<span class="p_add">+			dasd_put_device(device);</span>
 			lcu-&gt;ruac_data.device = NULL;
<span class="p_add">+		}</span>
 	}
 	private-&gt;lcu = NULL;
 	spin_unlock_irqrestore(&amp;lcu-&gt;lock, flags);
<span class="p_chunk">@@ -549,8 +553,10 @@</span> <span class="p_context"> static void lcu_update_work(struct work_struct *work)</span>
 	if ((rc &amp;&amp; (rc != -EOPNOTSUPP)) || (lcu-&gt;flags &amp; NEED_UAC_UPDATE)) {
 		DBF_DEV_EVENT(DBF_WARNING, device, &quot;could not update&quot;
 			    &quot; alias data in lcu (rc = %d), retry later&quot;, rc);
<span class="p_del">-		schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 30*HZ);</span>
<span class="p_add">+		if (!schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 30*HZ))</span>
<span class="p_add">+			dasd_put_device(device);</span>
 	} else {
<span class="p_add">+		dasd_put_device(device);</span>
 		lcu-&gt;ruac_data.device = NULL;
 		lcu-&gt;flags &amp;= ~UPDATE_PENDING;
 	}
<span class="p_chunk">@@ -593,8 +599,10 @@</span> <span class="p_context"> static int _schedule_lcu_update(struct alias_lcu *lcu,</span>
 	 */
 	if (!usedev)
 		return -EINVAL;
<span class="p_add">+	dasd_get_device(usedev);</span>
 	lcu-&gt;ruac_data.device = usedev;
<span class="p_del">-	schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 0);</span>
<span class="p_add">+	if (!schedule_delayed_work(&amp;lcu-&gt;ruac_data.dwork, 0))</span>
<span class="p_add">+		dasd_put_device(usedev);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -722,7 +730,7 @@</span> <span class="p_context"> static int reset_summary_unit_check(struct alias_lcu *lcu,</span>
 	ASCEBC((char *) &amp;cqr-&gt;magic, 4);
 	ccw = cqr-&gt;cpaddr;
 	ccw-&gt;cmd_code = DASD_ECKD_CCW_RSCK;
<span class="p_del">-	ccw-&gt;flags = 0 ;</span>
<span class="p_add">+	ccw-&gt;flags = CCW_FLAG_SLI;</span>
 	ccw-&gt;count = 16;
 	ccw-&gt;cda = (__u32)(addr_t) cqr-&gt;data;
 	((char *)cqr-&gt;data)[0] = reason;
<span class="p_chunk">@@ -926,6 +934,7 @@</span> <span class="p_context"> static void summary_unit_check_handling_work(struct work_struct *work)</span>
 	/* 3. read new alias configuration */
 	_schedule_lcu_update(lcu, device);
 	lcu-&gt;suc_data.device = NULL;
<span class="p_add">+	dasd_put_device(device);</span>
 	spin_unlock_irqrestore(&amp;lcu-&gt;lock, flags);
 }
 
<span class="p_chunk">@@ -985,6 +994,8 @@</span> <span class="p_context"> void dasd_alias_handle_summary_unit_check(struct dasd_device *device,</span>
 	}
 	lcu-&gt;suc_data.reason = reason;
 	lcu-&gt;suc_data.device = device;
<span class="p_add">+	dasd_get_device(device);</span>
 	spin_unlock(&amp;lcu-&gt;lock);
<span class="p_del">-	schedule_work(&amp;lcu-&gt;suc_data.worker);</span>
<span class="p_add">+	if (!schedule_work(&amp;lcu-&gt;suc_data.worker))</span>
<span class="p_add">+		dasd_put_device(device);</span>
 };
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">index 34452ea386ac..52636cfbab8f 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_chunk">@@ -334,6 +334,8 @@</span> <span class="p_context"> enum MR_EVT_ARGS {</span>
 	MR_EVT_ARGS_GENERIC,
 };
 
<span class="p_add">+</span>
<span class="p_add">+#define SGE_BUFFER_SIZE	4096</span>
 /*
  * define constants for device list query options
  */
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index c80afde97e96..9f833f1504cc 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -3821,7 +3821,7 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 		}
 	}
 	instance-&gt;max_sectors_per_req = instance-&gt;max_num_sge *
<span class="p_del">-						PAGE_SIZE / 512;</span>
<span class="p_add">+						SGE_BUFFER_SIZE / 512;</span>
 	if (tmp_sectors &amp;&amp; (instance-&gt;max_sectors_per_req &gt; tmp_sectors))
 		instance-&gt;max_sectors_per_req = tmp_sectors;
 
<span class="p_chunk">@@ -5281,6 +5281,9 @@</span> <span class="p_context"> static int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)</span>
 	int i;
 	int error = 0;
 	compat_uptr_t ptr;
<span class="p_add">+	unsigned long local_raw_ptr;</span>
<span class="p_add">+	u32 local_sense_off;</span>
<span class="p_add">+	u32 local_sense_len;</span>
 
 	if (clear_user(ioc, sizeof(*ioc)))
 		return -EFAULT;
<span class="p_chunk">@@ -5298,9 +5301,15 @@</span> <span class="p_context"> static int megasas_mgmt_compat_ioctl_fw(struct file *file, unsigned long arg)</span>
 	 * sense_len is not null, so prepare the 64bit value under
 	 * the same condition.
 	 */
<span class="p_del">-	if (ioc-&gt;sense_len) {</span>
<span class="p_add">+	if (get_user(local_raw_ptr, ioc-&gt;frame.raw) ||</span>
<span class="p_add">+		get_user(local_sense_off, &amp;ioc-&gt;sense_off) ||</span>
<span class="p_add">+		get_user(local_sense_len, &amp;ioc-&gt;sense_len))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	if (local_sense_len) {</span>
 		void __user **sense_ioc_ptr =
<span class="p_del">-			(void __user **)(ioc-&gt;frame.raw + ioc-&gt;sense_off);</span>
<span class="p_add">+			(void __user **)((u8*)local_raw_ptr + local_sense_off);</span>
 		compat_uptr_t *sense_cioc_ptr =
 			(compat_uptr_t *)(cioc-&gt;frame.raw + cioc-&gt;sense_off);
 		if (get_user(ptr, sense_cioc_ptr) ||
<span class="p_header">diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c</span>
<span class="p_header">index eba183c428cf..3643bbf5456d 100644</span>
<span class="p_header">--- a/drivers/scsi/ses.c</span>
<span class="p_header">+++ b/drivers/scsi/ses.c</span>
<span class="p_chunk">@@ -70,6 +70,7 @@</span> <span class="p_context"> static int ses_probe(struct device *dev)</span>
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
<span class="p_add">+	int ret;</span>
 	unsigned char cmd[] = {
 		RECEIVE_DIAGNOSTIC,
 		1,		/* Set PCV bit */
<span class="p_chunk">@@ -78,9 +79,26 @@</span> <span class="p_context"> static int ses_recv_diag(struct scsi_device *sdev, int page_code,</span>
 		bufflen &amp; 0xff,
 		0
 	};
<span class="p_add">+	unsigned char recv_page_code;</span>
 
<span class="p_del">-	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
<span class="p_add">+	ret =  scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,</span>
 				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
<span class="p_add">+	if (unlikely(!ret))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	recv_page_code = ((unsigned char *)buf)[0];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(recv_page_code == page_code))</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* successful diagnostic but wrong page code.  This happens to some</span>
<span class="p_add">+	 * USB devices, just print a message and pretend there was an error */</span>
<span class="p_add">+</span>
<span class="p_add">+	sdev_printk(KERN_ERR, sdev,</span>
<span class="p_add">+		    &quot;Wrong diagnostic page; asked for %d got %u\n&quot;,</span>
<span class="p_add">+		    page_code, recv_page_code);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int ses_send_diag(struct scsi_device *sdev, int page_code,
<span class="p_chunk">@@ -436,7 +454,15 @@</span> <span class="p_context"> static void ses_enclosure_data_process(struct enclosure_device *edev,</span>
 			if (desc_ptr)
 				desc_ptr += len;
 
<span class="p_del">-			if (addl_desc_ptr)</span>
<span class="p_add">+			if (addl_desc_ptr &amp;&amp;</span>
<span class="p_add">+			    /* only find additional descriptions for specific devices */</span>
<span class="p_add">+			    (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||</span>
<span class="p_add">+			     /* these elements are optional */</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||</span>
<span class="p_add">+			     type_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS))</span>
 				addl_desc_ptr += addl_desc_ptr[1] + 2;
 
 		}
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 3bb6646bb406..f9da66fa850b 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -1610,8 +1610,7 @@</span> <span class="p_context"> static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)</span>
 	vm_srb-&gt;win8_extension.time_out_value = 60;
 
 	vm_srb-&gt;win8_extension.srb_flags |=
<span class="p_del">-		(SRB_FLAGS_QUEUE_ACTION_ENABLE |</span>
<span class="p_del">-		SRB_FLAGS_DISABLE_SYNCH_TRANSFER);</span>
<span class="p_add">+		SRB_FLAGS_DISABLE_SYNCH_TRANSFER;</span>
 
 	/* Build the SRB */
 	switch (scmnd-&gt;sc_data_direction) {
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index f89b24a09b19..231d63caa663 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -314,7 +314,8 @@</span> <span class="p_context"> sbc_setup_write_same(struct se_cmd *cmd, unsigned char *flags, struct sbc_ops *o</span>
 	return 0;
 }
 
<span class="p_del">-static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t xdreadwrite_callback(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+					   int *post_ret)</span>
 {
 	unsigned char *buf, *addr;
 	struct scatterlist *sg;
<span class="p_chunk">@@ -378,7 +379,8 @@</span> <span class="p_context"> sbc_execute_rw(struct se_cmd *cmd)</span>
 			       cmd-&gt;data_direction);
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+					     int *post_ret)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 
<span class="p_chunk">@@ -388,8 +390,10 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 	 * sent to the backend driver.
 	 */
 	spin_lock_irq(&amp;cmd-&gt;t_state_lock);
<span class="p_del">-	if ((cmd-&gt;transport_state &amp; CMD_T_SENT) &amp;&amp; !cmd-&gt;scsi_status)</span>
<span class="p_add">+	if ((cmd-&gt;transport_state &amp; CMD_T_SENT) &amp;&amp; !cmd-&gt;scsi_status) {</span>
 		cmd-&gt;se_cmd_flags |= SCF_COMPARE_AND_WRITE_POST;
<span class="p_add">+		*post_ret = 1;</span>
<span class="p_add">+	}</span>
 	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);
 
 	/*
<span class="p_chunk">@@ -401,7 +405,8 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_post(struct se_cmd *cmd, bool success)</span>
 	return TCM_NO_SENSE;
 }
 
<span class="p_del">-static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success)</span>
<span class="p_add">+static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool success,</span>
<span class="p_add">+						 int *post_ret)</span>
 {
 	struct se_device *dev = cmd-&gt;se_dev;
 	struct scatterlist *write_sg = NULL, *sg;
<span class="p_chunk">@@ -497,11 +502,11 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool succes</span>
 
 		if (block_size &lt; PAGE_SIZE) {
 			sg_set_page(&amp;write_sg[i], m.page, block_size,
<span class="p_del">-				    block_size);</span>
<span class="p_add">+				    m.piter.sg-&gt;offset + block_size);</span>
 		} else {
 			sg_miter_next(&amp;m);
 			sg_set_page(&amp;write_sg[i], m.page, block_size,
<span class="p_del">-				    0);</span>
<span class="p_add">+				    m.piter.sg-&gt;offset);</span>
 		}
 		len -= block_size;
 		i++;
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 6fc38903046c..7afea9b59e2c 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1581,7 +1581,7 @@</span> <span class="p_context"> bool target_stop_cmd(struct se_cmd *cmd, unsigned long *flags)</span>
 void transport_generic_request_failure(struct se_cmd *cmd,
 		sense_reason_t sense_reason)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret = 0, post_ret = 0;</span>
 
 	pr_debug(&quot;-----[ Storage Engine Exception for cmd: %p ITT: 0x%08x&quot;
 		&quot; CDB: 0x%02x\n&quot;, cmd, cmd-&gt;se_tfo-&gt;get_task_tag(cmd),
<span class="p_chunk">@@ -1604,7 +1604,7 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	 */
 	if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;
 	     cmd-&gt;transport_complete_callback)
<span class="p_del">-		cmd-&gt;transport_complete_callback(cmd, false);</span>
<span class="p_add">+		cmd-&gt;transport_complete_callback(cmd, false, &amp;post_ret);</span>
 
 	switch (sense_reason) {
 	case TCM_NON_EXISTENT_LUN:
<span class="p_chunk">@@ -1940,11 +1940,13 @@</span> <span class="p_context"> static void target_complete_ok_work(struct work_struct *work)</span>
 	 */
 	if (cmd-&gt;transport_complete_callback) {
 		sense_reason_t rc;
<span class="p_add">+		bool caw = (cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE);</span>
<span class="p_add">+		bool zero_dl = !(cmd-&gt;data_length);</span>
<span class="p_add">+		int post_ret = 0;</span>
 
<span class="p_del">-		rc = cmd-&gt;transport_complete_callback(cmd, true);</span>
<span class="p_del">-		if (!rc &amp;&amp; !(cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE_POST)) {</span>
<span class="p_del">-			if ((cmd-&gt;se_cmd_flags &amp; SCF_COMPARE_AND_WRITE) &amp;&amp;</span>
<span class="p_del">-			    !cmd-&gt;data_length)</span>
<span class="p_add">+		rc = cmd-&gt;transport_complete_callback(cmd, true, &amp;post_ret);</span>
<span class="p_add">+		if (!rc &amp;&amp; !post_ret) {</span>
<span class="p_add">+			if (caw &amp;&amp; zero_dl)</span>
 				goto queue_rsp;
 
 			return;
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 2aca88715632..584514c7ed1f 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1810,6 +1810,11 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	},
 #endif
 
<span class="p_add">+	/*Samsung phone in firmware update mode */</span>
<span class="p_add">+	{ USB_DEVICE(0x04e8, 0x685d),</span>
<span class="p_add">+	.driver_info = IGNORE_DEVICE,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* Exclude Infineon Flash Loader utility */
 	{ USB_DEVICE(0x058b, 0x0041),
 	.driver_info = IGNORE_DEVICE,
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 02e6fe228a63..21bf168981f9 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -162,6 +162,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
 	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
<span class="p_add">+	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */</span>
<span class="p_add">+	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */</span>
 	{ USB_DEVICE(0x1ADB, 0x0001) }, /* Schweitzer Engineering C662 Cable */
 	{ USB_DEVICE(0x1B1C, 0x1C00) }, /* Corsair USB Dongle */
 	{ USB_DEVICE(0x1BA4, 0x0002) },	/* Silicon Labs 358x factory default */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 81f6a572f016..9bab34cf01d4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -315,6 +315,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TOSHIBA_PRODUCT_G450			0x0d45
 
 #define ALINK_VENDOR_ID				0x1e0e
<span class="p_add">+#define SIMCOM_PRODUCT_SIM7100E			0x9001 /* Yes, ALINK_VENDOR_ID */</span>
 #define ALINK_PRODUCT_PH300			0x9100
 #define ALINK_PRODUCT_3GU			0x9200
 
<span class="p_chunk">@@ -615,6 +616,10 @@</span> <span class="p_context"> static const struct option_blacklist_info zte_1255_blacklist = {</span>
 	.reserved = BIT(3) | BIT(4),
 };
 
<span class="p_add">+static const struct option_blacklist_info simcom_sim7100e_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(5) | BIT(6),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le910_blacklist = {
 	.sendsetup = BIT(0),
 	.reserved = BIT(1) | BIT(2),
<span class="p_chunk">@@ -1130,6 +1135,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC650) },
 	{ USB_DEVICE(KYOCERA_VENDOR_ID, KYOCERA_PRODUCT_KPC680) },
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6000)}, /* ZTE AC8700 */
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(QUALCOMM_VENDOR_ID, 0x6001, 0xff, 0xff, 0xff), /* 4G LTE usb-modem U901 */</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;net_intf3_blacklist },</span>
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x6613)}, /* Onda H600/ZTE MF330 */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x0023)}, /* ONYX 3G device */
 	{ USB_DEVICE(QUALCOMM_VENDOR_ID, 0x9000)}, /* SIMCom SIM5218 */
<span class="p_chunk">@@ -1645,6 +1652,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(ALINK_VENDOR_ID, 0x9000) },
 	{ USB_DEVICE(ALINK_VENDOR_ID, ALINK_PRODUCT_PH300) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ALINK_VENDOR_ID, ALINK_PRODUCT_3GU, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE(ALINK_VENDOR_ID, SIMCOM_PRODUCT_SIM7100E),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;simcom_sim7100e_blacklist },</span>
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_X060S_X200),
 	  .driver_info = (kernel_ulong_t)&amp;alcatel_x200_blacklist
 	},
<span class="p_header">diff --git a/drivers/virtio/virtio.c b/drivers/virtio/virtio.c</span>
<span class="p_header">index fed0ce198ae3..64eba4f51f71 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio.c</span>
<span class="p_chunk">@@ -249,6 +249,7 @@</span> <span class="p_context"> static int virtio_init(void)</span>
 static void __exit virtio_exit(void)
 {
 	bus_unregister(&amp;virtio_bus);
<span class="p_add">+	ida_destroy(&amp;virtio_index_ida);</span>
 }
 core_initcall(virtio_init);
 module_exit(virtio_exit);
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index f48d5fc352a9..469051b01fbf 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -2336,6 +2336,7 @@</span> <span class="p_context"> int open_ctree(struct super_block *sb,</span>
 	if (btrfs_check_super_csum(bh-&gt;b_data)) {
 		printk(KERN_ERR &quot;BTRFS: superblock checksum mismatch\n&quot;);
 		err = -EINVAL;
<span class="p_add">+		brelse(bh);</span>
 		goto fail_alloc;
 	}
 
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 08824fe6ef44..fb37441a592f 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -7511,15 +7511,28 @@</span> <span class="p_context"> int btrfs_readpage(struct file *file, struct page *page)</span>
 static int btrfs_writepage(struct page *page, struct writeback_control *wbc)
 {
 	struct extent_io_tree *tree;
<span class="p_del">-</span>
<span class="p_add">+	struct inode *inode = page-&gt;mapping-&gt;host;</span>
<span class="p_add">+	int ret;</span>
 
 	if (current-&gt;flags &amp; PF_MEMALLOC) {
 		redirty_page_for_writepage(wbc, page);
 		unlock_page(page);
 		return 0;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are under memory pressure we will call this directly from the</span>
<span class="p_add">+	 * VM, we need to make sure we have the inode referenced for the ordered</span>
<span class="p_add">+	 * extent.  If not just return like we didn&#39;t do anything.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!igrab(inode)) {</span>
<span class="p_add">+		redirty_page_for_writepage(wbc, page);</span>
<span class="p_add">+		return AOP_WRITEPAGE_ACTIVATE;</span>
<span class="p_add">+	}</span>
 	tree = &amp;BTRFS_I(page-&gt;mapping-&gt;host)-&gt;io_tree;
<span class="p_del">-	return extent_write_full_page(tree, page, btrfs_get_extent, wbc);</span>
<span class="p_add">+	ret = extent_write_full_page(tree, page, btrfs_get_extent, wbc);</span>
<span class="p_add">+	btrfs_add_delayed_iput(inode);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int btrfs_writepages(struct address_space *mapping,
<span class="p_chunk">@@ -8612,9 +8625,11 @@</span> <span class="p_context"> static int btrfs_symlink(struct inode *dir, struct dentry *dentry,</span>
 	/*
 	 * 2 items for inode item and ref
 	 * 2 items for dir items
<span class="p_add">+	 * 1 item for updating parent inode item</span>
<span class="p_add">+	 * 1 item for the inline extent item</span>
 	 * 1 item for xattr if selinux is on
 	 */
<span class="p_del">-	trans = btrfs_start_transaction(root, 5);</span>
<span class="p_add">+	trans = btrfs_start_transaction(root, 7);</span>
 	if (IS_ERR(trans))
 		return PTR_ERR(trans);
 
<span class="p_header">diff --git a/fs/btrfs/send.c b/fs/btrfs/send.c</span>
<span class="p_header">index 20d793542096..0fd23ab3b4ad 100644</span>
<span class="p_header">--- a/fs/btrfs/send.c</span>
<span class="p_header">+++ b/fs/btrfs/send.c</span>
<span class="p_chunk">@@ -1377,7 +1377,21 @@</span> <span class="p_context"> static int read_symlink(struct btrfs_root *root,</span>
 	ret = btrfs_search_slot(NULL, root, &amp;key, path, 0, 0);
 	if (ret &lt; 0)
 		goto out;
<span class="p_del">-	BUG_ON(ret);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * An empty symlink inode. Can happen in rare error paths when</span>
<span class="p_add">+		 * creating a symlink (transaction committed before the inode</span>
<span class="p_add">+		 * eviction handler removed the symlink inode items and a crash</span>
<span class="p_add">+		 * happened in between or the subvol was snapshoted in between).</span>
<span class="p_add">+		 * Print an informative message to dmesg/syslog so that the user</span>
<span class="p_add">+		 * can delete the symlink.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		btrfs_err(root-&gt;fs_info,</span>
<span class="p_add">+			  &quot;Found empty symlink inode %llu at root %llu&quot;,</span>
<span class="p_add">+			  ino, root-&gt;root_key.objectid);</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	ei = btrfs_item_ptr(path-&gt;nodes[0], path-&gt;slots[0],
 			struct btrfs_file_extent_item);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 65ccdf0e2854..9b235362efcd 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -439,42 +439,12 @@</span> <span class="p_context"> void d_drop(struct dentry *dentry)</span>
 }
 EXPORT_SYMBOL(d_drop);
 
<span class="p_del">-/*</span>
<span class="p_del">- * Finish off a dentry we&#39;ve decided to kill.</span>
<span class="p_del">- * dentry-&gt;d_lock must be held, returns with it unlocked.</span>
<span class="p_del">- * If ref is non-zero, then decrement the refcount too.</span>
<span class="p_del">- * Returns dentry requiring refcount drop, or NULL if we&#39;re done.</span>
<span class="p_del">- */</span>
<span class="p_del">-static struct dentry *</span>
<span class="p_del">-dentry_kill(struct dentry *dentry, int unlock_on_failure)</span>
<span class="p_del">-	__releases(dentry-&gt;d_lock)</span>
<span class="p_add">+static void __dentry_kill(struct dentry *dentry)</span>
 {
<span class="p_del">-	struct inode *inode;</span>
 	struct dentry *parent = NULL;
 	bool can_free = true;
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_del">-		can_free = dentry-&gt;d_flags &amp; DCACHE_MAY_FREE;</span>
<span class="p_del">-		spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	inode = dentry-&gt;d_inode;</span>
<span class="p_del">-	if (inode &amp;&amp; !spin_trylock(&amp;inode-&gt;i_lock)) {</span>
<span class="p_del">-relock:</span>
<span class="p_del">-		if (unlock_on_failure) {</span>
<span class="p_del">-			spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_del">-			cpu_relax();</span>
<span class="p_del">-		}</span>
<span class="p_del">-		return dentry; /* try again with same dentry */</span>
<span class="p_del">-	}</span>
 	if (!IS_ROOT(dentry))
 		parent = dentry-&gt;d_parent;
<span class="p_del">-	if (parent &amp;&amp; !spin_trylock(&amp;parent-&gt;d_lock)) {</span>
<span class="p_del">-		if (inode)</span>
<span class="p_del">-			spin_unlock(&amp;inode-&gt;i_lock);</span>
<span class="p_del">-		goto relock;</span>
<span class="p_del">-	}</span>
 
 	/*
 	 * The dentry is now unrecoverably dead to the world.
<span class="p_chunk">@@ -518,9 +488,74 @@</span> <span class="p_context"> relock:</span>
 		can_free = false;
 	}
 	spin_unlock(&amp;dentry-&gt;d_lock);
<span class="p_del">-out:</span>
 	if (likely(can_free))
 		dentry_free(dentry);
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Finish off a dentry we&#39;ve decided to kill.</span>
<span class="p_add">+ * dentry-&gt;d_lock must be held, returns with it unlocked.</span>
<span class="p_add">+ * If ref is non-zero, then decrement the refcount too.</span>
<span class="p_add">+ * Returns dentry requiring refcount drop, or NULL if we&#39;re done.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct dentry *dentry_kill(struct dentry *dentry)</span>
<span class="p_add">+	__releases(dentry-&gt;d_lock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = dentry-&gt;d_inode;</span>
<span class="p_add">+	struct dentry *parent = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock)))</span>
<span class="p_add">+		goto failed;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ROOT(dentry)) {</span>
<span class="p_add">+		parent = dentry-&gt;d_parent;</span>
<span class="p_add">+		if (unlikely(!spin_trylock(&amp;parent-&gt;d_lock))) {</span>
<span class="p_add">+			if (inode)</span>
<span class="p_add">+				spin_unlock(&amp;inode-&gt;i_lock);</span>
<span class="p_add">+			goto failed;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	__dentry_kill(dentry);</span>
<span class="p_add">+	return parent;</span>
<span class="p_add">+</span>
<span class="p_add">+failed:</span>
<span class="p_add">+	spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+	cpu_relax();</span>
<span class="p_add">+	return dentry; /* try again with same dentry */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct dentry *lock_parent(struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dentry *parent = dentry-&gt;d_parent;</span>
<span class="p_add">+	if (IS_ROOT(dentry))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	if (unlikely((int)dentry-&gt;d_lockref.count &lt; 0))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	if (likely(spin_trylock(&amp;parent-&gt;d_lock)))</span>
<span class="p_add">+		return parent;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+again:</span>
<span class="p_add">+	parent = ACCESS_ONCE(dentry-&gt;d_parent);</span>
<span class="p_add">+	spin_lock(&amp;parent-&gt;d_lock);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We can&#39;t blindly lock dentry until we are sure</span>
<span class="p_add">+	 * that we won&#39;t violate the locking order.</span>
<span class="p_add">+	 * Any changes of dentry-&gt;d_parent must have</span>
<span class="p_add">+	 * been done with parent-&gt;d_lock held, so</span>
<span class="p_add">+	 * spin_lock() above is enough of a barrier</span>
<span class="p_add">+	 * for checking if it&#39;s still our child.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(parent != dentry-&gt;d_parent)) {</span>
<span class="p_add">+		spin_unlock(&amp;parent-&gt;d_lock);</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	if (parent != dentry)</span>
<span class="p_add">+		spin_lock_nested(&amp;dentry-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		parent = NULL;</span>
 	return parent;
 }
 
<span class="p_chunk">@@ -580,7 +615,7 @@</span> <span class="p_context"> repeat:</span>
 	return;
 
 kill_it:
<span class="p_del">-	dentry = dentry_kill(dentry, 1);</span>
<span class="p_add">+	dentry = dentry_kill(dentry);</span>
 	if (dentry)
 		goto repeat;
 }
<span class="p_chunk">@@ -798,8 +833,11 @@</span> <span class="p_context"> static void shrink_dentry_list(struct list_head *list)</span>
 	struct dentry *dentry, *parent;
 
 	while (!list_empty(list)) {
<span class="p_add">+		struct inode *inode;</span>
 		dentry = list_entry(list-&gt;prev, struct dentry, d_lru);
 		spin_lock(&amp;dentry-&gt;d_lock);
<span class="p_add">+		parent = lock_parent(dentry);</span>
<span class="p_add">+</span>
 		/*
 		 * The dispose list is isolated and dentries are not accounted
 		 * to the LRU here, so we can simply remove it from the list
<span class="p_chunk">@@ -813,26 +851,33 @@</span> <span class="p_context"> static void shrink_dentry_list(struct list_head *list)</span>
 		 */
 		if ((int)dentry-&gt;d_lockref.count &gt; 0) {
 			spin_unlock(&amp;dentry-&gt;d_lock);
<span class="p_add">+			if (parent)</span>
<span class="p_add">+				spin_unlock(&amp;parent-&gt;d_lock);</span>
 			continue;
 		}
 
<span class="p_del">-		parent = dentry_kill(dentry, 0);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If dentry_kill returns NULL, we have nothing more to do.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!parent)</span>
<span class="p_add">+</span>
<span class="p_add">+		if (unlikely(dentry-&gt;d_flags &amp; DCACHE_DENTRY_KILLED)) {</span>
<span class="p_add">+			bool can_free = dentry-&gt;d_flags &amp; DCACHE_MAY_FREE;</span>
<span class="p_add">+			spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+			if (parent)</span>
<span class="p_add">+				spin_unlock(&amp;parent-&gt;d_lock);</span>
<span class="p_add">+			if (can_free)</span>
<span class="p_add">+				dentry_free(dentry);</span>
 			continue;
<span class="p_add">+		}</span>
 
<span class="p_del">-		if (unlikely(parent == dentry)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * trylocks have failed and d_lock has been held the</span>
<span class="p_del">-			 * whole time, so it could not have been added to any</span>
<span class="p_del">-			 * other lists. Just add it back to the shrink list.</span>
<span class="p_del">-			 */</span>
<span class="p_add">+		inode = dentry-&gt;d_inode;</span>
<span class="p_add">+		if (inode &amp;&amp; unlikely(!spin_trylock(&amp;inode-&gt;i_lock))) {</span>
 			d_shrink_add(dentry, list);
 			spin_unlock(&amp;dentry-&gt;d_lock);
<span class="p_add">+			if (parent)</span>
<span class="p_add">+				spin_unlock(&amp;parent-&gt;d_lock);</span>
 			continue;
 		}
<span class="p_add">+</span>
<span class="p_add">+		__dentry_kill(dentry);</span>
<span class="p_add">+</span>
 		/*
 		 * We need to prune ancestors too. This is necessary to prevent
 		 * quadratic behavior of shrink_dcache_parent(), but is also
<span class="p_chunk">@@ -840,8 +885,26 @@</span> <span class="p_context"> static void shrink_dentry_list(struct list_head *list)</span>
 		 * fragmentation.
 		 */
 		dentry = parent;
<span class="p_del">-		while (dentry &amp;&amp; !lockref_put_or_lock(&amp;dentry-&gt;d_lockref))</span>
<span class="p_del">-			dentry = dentry_kill(dentry, 1);</span>
<span class="p_add">+		while (dentry &amp;&amp; !lockref_put_or_lock(&amp;dentry-&gt;d_lockref)) {</span>
<span class="p_add">+			parent = lock_parent(dentry);</span>
<span class="p_add">+			if (dentry-&gt;d_lockref.count != 1) {</span>
<span class="p_add">+				dentry-&gt;d_lockref.count--;</span>
<span class="p_add">+				spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+				if (parent)</span>
<span class="p_add">+					spin_unlock(&amp;parent-&gt;d_lock);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			inode = dentry-&gt;d_inode;	/* can&#39;t be NULL */</span>
<span class="p_add">+			if (unlikely(!spin_trylock(&amp;inode-&gt;i_lock))) {</span>
<span class="p_add">+				spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+				if (parent)</span>
<span class="p_add">+					spin_unlock(&amp;parent-&gt;d_lock);</span>
<span class="p_add">+				cpu_relax();</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			__dentry_kill(dentry);</span>
<span class="p_add">+			dentry = parent;</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index fe649d325b1f..ce653dfb0ae3 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -720,15 +720,13 @@</span> <span class="p_context"> static int hostfs_mknod(struct inode *dir, struct dentry *dentry, umode_t mode,</span>
 
 	init_special_inode(inode, mode, dev);
 	err = do_mknod(name, mode, MAJOR(dev), MINOR(dev));
<span class="p_del">-	if (!err)</span>
<span class="p_add">+	if (err)</span>
 		goto out_free;
 
 	err = read_name(inode, name);
 	__putname(name);
 	if (err)
 		goto out_put;
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_put;</span>
 
 	d_instantiate(dentry, inode);
 	return 0;
<span class="p_header">diff --git a/fs/lockd/host.c b/fs/lockd/host.c</span>
<span class="p_header">index 969d589c848d..b5f3c3ab0d5f 100644</span>
<span class="p_header">--- a/fs/lockd/host.c</span>
<span class="p_header">+++ b/fs/lockd/host.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> static struct nlm_host *nlm_alloc_host(struct nlm_lookup_host_info *ni,</span>
 		atomic_inc(&amp;nsm-&gt;sm_count);
 	else {
 		host = NULL;
<span class="p_del">-		nsm = nsm_get_handle(ni-&gt;sap, ni-&gt;salen,</span>
<span class="p_add">+		nsm = nsm_get_handle(ni-&gt;net, ni-&gt;sap, ni-&gt;salen,</span>
 					ni-&gt;hostname, ni-&gt;hostname_len);
 		if (unlikely(nsm == NULL)) {
 			dprintk(&quot;lockd: %s failed; no nsm handle\n&quot;,
<span class="p_chunk">@@ -534,17 +534,18 @@</span> <span class="p_context"> static struct nlm_host *next_host_state(struct hlist_head *cache,</span>
 
 /**
  * nlm_host_rebooted - Release all resources held by rebooted host
<span class="p_add">+ * @net:  network namespace</span>
  * @info: pointer to decoded results of NLM_SM_NOTIFY call
  *
  * We were notified that the specified host has rebooted.  Release
  * all resources held by that peer.
  */
<span class="p_del">-void nlm_host_rebooted(const struct nlm_reboot *info)</span>
<span class="p_add">+void nlm_host_rebooted(const struct net *net, const struct nlm_reboot *info)</span>
 {
 	struct nsm_handle *nsm;
 	struct nlm_host	*host;
 
<span class="p_del">-	nsm = nsm_reboot_lookup(info);</span>
<span class="p_add">+	nsm = nsm_reboot_lookup(net, info);</span>
 	if (unlikely(nsm == NULL))
 		return;
 
<span class="p_header">diff --git a/fs/lockd/mon.c b/fs/lockd/mon.c</span>
<span class="p_header">index 6ae664b489af..13fac49aff7f 100644</span>
<span class="p_header">--- a/fs/lockd/mon.c</span>
<span class="p_header">+++ b/fs/lockd/mon.c</span>
<span class="p_chunk">@@ -51,7 +51,6 @@</span> <span class="p_context"> struct nsm_res {</span>
 };
 
 static const struct rpc_program	nsm_program;
<span class="p_del">-static				LIST_HEAD(nsm_handles);</span>
 static				DEFINE_SPINLOCK(nsm_lock);
 
 /*
<span class="p_chunk">@@ -259,33 +258,35 @@</span> <span class="p_context"> void nsm_unmonitor(const struct nlm_host *host)</span>
 	}
 }
 
<span class="p_del">-static struct nsm_handle *nsm_lookup_hostname(const char *hostname,</span>
<span class="p_del">-					      const size_t len)</span>
<span class="p_add">+static struct nsm_handle *nsm_lookup_hostname(const struct list_head *nsm_handles,</span>
<span class="p_add">+					const char *hostname, const size_t len)</span>
 {
 	struct nsm_handle *nsm;
 
<span class="p_del">-	list_for_each_entry(nsm, &amp;nsm_handles, sm_link)</span>
<span class="p_add">+	list_for_each_entry(nsm, nsm_handles, sm_link)</span>
 		if (strlen(nsm-&gt;sm_name) == len &amp;&amp;
 		    memcmp(nsm-&gt;sm_name, hostname, len) == 0)
 			return nsm;
 	return NULL;
 }
 
<span class="p_del">-static struct nsm_handle *nsm_lookup_addr(const struct sockaddr *sap)</span>
<span class="p_add">+static struct nsm_handle *nsm_lookup_addr(const struct list_head *nsm_handles,</span>
<span class="p_add">+					const struct sockaddr *sap)</span>
 {
 	struct nsm_handle *nsm;
 
<span class="p_del">-	list_for_each_entry(nsm, &amp;nsm_handles, sm_link)</span>
<span class="p_add">+	list_for_each_entry(nsm, nsm_handles, sm_link)</span>
 		if (rpc_cmp_addr(nsm_addr(nsm), sap))
 			return nsm;
 	return NULL;
 }
 
<span class="p_del">-static struct nsm_handle *nsm_lookup_priv(const struct nsm_private *priv)</span>
<span class="p_add">+static struct nsm_handle *nsm_lookup_priv(const struct list_head *nsm_handles,</span>
<span class="p_add">+					const struct nsm_private *priv)</span>
 {
 	struct nsm_handle *nsm;
 
<span class="p_del">-	list_for_each_entry(nsm, &amp;nsm_handles, sm_link)</span>
<span class="p_add">+	list_for_each_entry(nsm, nsm_handles, sm_link)</span>
 		if (memcmp(nsm-&gt;sm_priv.data, priv-&gt;data,
 					sizeof(priv-&gt;data)) == 0)
 			return nsm;
<span class="p_chunk">@@ -350,6 +351,7 @@</span> <span class="p_context"> static struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,</span>
 
 /**
  * nsm_get_handle - Find or create a cached nsm_handle
<span class="p_add">+ * @net: network namespace</span>
  * @sap: pointer to socket address of handle to find
  * @salen: length of socket address
  * @hostname: pointer to C string containing hostname to find
<span class="p_chunk">@@ -362,11 +364,13 @@</span> <span class="p_context"> static struct nsm_handle *nsm_create_handle(const struct sockaddr *sap,</span>
  * @hostname cannot be found in the handle cache.  Returns NULL if
  * an error occurs.
  */
<span class="p_del">-struct nsm_handle *nsm_get_handle(const struct sockaddr *sap,</span>
<span class="p_add">+struct nsm_handle *nsm_get_handle(const struct net *net,</span>
<span class="p_add">+				  const struct sockaddr *sap,</span>
 				  const size_t salen, const char *hostname,
 				  const size_t hostname_len)
 {
 	struct nsm_handle *cached, *new = NULL;
<span class="p_add">+	struct lockd_net *ln = net_generic(net, lockd_net_id);</span>
 
 	if (hostname &amp;&amp; memchr(hostname, &#39;/&#39;, hostname_len) != NULL) {
 		if (printk_ratelimit()) {
<span class="p_chunk">@@ -381,9 +385,10 @@</span> <span class="p_context"> retry:</span>
 	spin_lock(&amp;nsm_lock);
 
 	if (nsm_use_hostnames &amp;&amp; hostname != NULL)
<span class="p_del">-		cached = nsm_lookup_hostname(hostname, hostname_len);</span>
<span class="p_add">+		cached = nsm_lookup_hostname(&amp;ln-&gt;nsm_handles,</span>
<span class="p_add">+					hostname, hostname_len);</span>
 	else
<span class="p_del">-		cached = nsm_lookup_addr(sap);</span>
<span class="p_add">+		cached = nsm_lookup_addr(&amp;ln-&gt;nsm_handles, sap);</span>
 
 	if (cached != NULL) {
 		atomic_inc(&amp;cached-&gt;sm_count);
<span class="p_chunk">@@ -397,7 +402,7 @@</span> <span class="p_context"> retry:</span>
 	}
 
 	if (new != NULL) {
<span class="p_del">-		list_add(&amp;new-&gt;sm_link, &amp;nsm_handles);</span>
<span class="p_add">+		list_add(&amp;new-&gt;sm_link, &amp;ln-&gt;nsm_handles);</span>
 		spin_unlock(&amp;nsm_lock);
 		dprintk(&quot;lockd: created nsm_handle for %s (%s)\n&quot;,
 				new-&gt;sm_name, new-&gt;sm_addrbuf);
<span class="p_chunk">@@ -414,19 +419,22 @@</span> <span class="p_context"> retry:</span>
 
 /**
  * nsm_reboot_lookup - match NLMPROC_SM_NOTIFY arguments to an nsm_handle
<span class="p_add">+ * @net:  network namespace</span>
  * @info: pointer to NLMPROC_SM_NOTIFY arguments
  *
  * Returns a matching nsm_handle if found in the nsm cache. The returned
  * nsm_handle&#39;s reference count is bumped. Otherwise returns NULL if some
  * error occurred.
  */
<span class="p_del">-struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info)</span>
<span class="p_add">+struct nsm_handle *nsm_reboot_lookup(const struct net *net,</span>
<span class="p_add">+				const struct nlm_reboot *info)</span>
 {
 	struct nsm_handle *cached;
<span class="p_add">+	struct lockd_net *ln = net_generic(net, lockd_net_id);</span>
 
 	spin_lock(&amp;nsm_lock);
 
<span class="p_del">-	cached = nsm_lookup_priv(&amp;info-&gt;priv);</span>
<span class="p_add">+	cached = nsm_lookup_priv(&amp;ln-&gt;nsm_handles, &amp;info-&gt;priv);</span>
 	if (unlikely(cached == NULL)) {
 		spin_unlock(&amp;nsm_lock);
 		dprintk(&quot;lockd: never saw rebooted peer &#39;%.*s&#39; before\n&quot;,
<span class="p_header">diff --git a/fs/lockd/netns.h b/fs/lockd/netns.h</span>
<span class="p_header">index 5010b55628b4..414da99744e9 100644</span>
<span class="p_header">--- a/fs/lockd/netns.h</span>
<span class="p_header">+++ b/fs/lockd/netns.h</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"> struct lockd_net {</span>
 	spinlock_t nsm_clnt_lock;
 	unsigned int nsm_users;
 	struct rpc_clnt *nsm_clnt;
<span class="p_add">+	struct list_head nsm_handles;</span>
 };
 
 extern int lockd_net_id;
<span class="p_header">diff --git a/fs/lockd/svc.c b/fs/lockd/svc.c</span>
<span class="p_header">index 59a53f664005..bb1ad4df024d 100644</span>
<span class="p_header">--- a/fs/lockd/svc.c</span>
<span class="p_header">+++ b/fs/lockd/svc.c</span>
<span class="p_chunk">@@ -583,6 +583,7 @@</span> <span class="p_context"> static int lockd_init_net(struct net *net)</span>
 	INIT_DELAYED_WORK(&amp;ln-&gt;grace_period_end, grace_ender);
 	INIT_LIST_HEAD(&amp;ln-&gt;grace_list);
 	spin_lock_init(&amp;ln-&gt;nsm_clnt_lock);
<span class="p_add">+	INIT_LIST_HEAD(&amp;ln-&gt;nsm_handles);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/lockd/svc4proc.c b/fs/lockd/svc4proc.c</span>
<span class="p_header">index b147d1ae71fd..09c576f26c7b 100644</span>
<span class="p_header">--- a/fs/lockd/svc4proc.c</span>
<span class="p_header">+++ b/fs/lockd/svc4proc.c</span>
<span class="p_chunk">@@ -421,7 +421,7 @@</span> <span class="p_context"> nlm4svc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,</span>
 		return rpc_system_err;
 	}
 
<span class="p_del">-	nlm_host_rebooted(argp);</span>
<span class="p_add">+	nlm_host_rebooted(SVC_NET(rqstp), argp);</span>
 	return rpc_success;
 }
 
<span class="p_header">diff --git a/fs/lockd/svcproc.c b/fs/lockd/svcproc.c</span>
<span class="p_header">index 21171f0c6477..fb26b9f522e7 100644</span>
<span class="p_header">--- a/fs/lockd/svcproc.c</span>
<span class="p_header">+++ b/fs/lockd/svcproc.c</span>
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> nlmsvc_proc_sm_notify(struct svc_rqst *rqstp, struct nlm_reboot *argp,</span>
 		return rpc_system_err;
 	}
 
<span class="p_del">-	nlm_host_rebooted(argp);</span>
<span class="p_add">+	nlm_host_rebooted(SVC_NET(rqstp), argp);</span>
 	return rpc_success;
 }
 
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index f4f6460b6958..c24781f07cf3 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -3085,6 +3085,10 @@</span> <span class="p_context"> opened:</span>
 			goto exit_fput;
 	}
 out:
<span class="p_add">+	if (unlikely(error &gt; 0)) {</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+		error = -EINVAL;</span>
<span class="p_add">+	}</span>
 	if (got_write)
 		mnt_drop_write(nd-&gt;path.mnt);
 	path_put(&amp;save_parent);
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 45a7dd36b4a6..3b5e86fd2800 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -2187,9 +2187,9 @@</span> <span class="p_context"> static int _nfs4_open_and_get_state(struct nfs4_opendata *opendata,</span>
 		dentry = d_add_unique(dentry, igrab(state-&gt;inode));
 		if (dentry == NULL) {
 			dentry = opendata-&gt;dentry;
<span class="p_del">-		} else if (dentry != ctx-&gt;dentry) {</span>
<span class="p_add">+		} else {</span>
 			dput(ctx-&gt;dentry);
<span class="p_del">-			ctx-&gt;dentry = dget(dentry);</span>
<span class="p_add">+			ctx-&gt;dentry = dentry;</span>
 		}
 		nfs_set_verifier(dentry,
 				nfs_save_change_attribute(opendata-&gt;dir-&gt;d_inode));
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index c402b672a474..1c02b300dc5d 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1482,7 +1482,7 @@</span> <span class="p_context"> restart:</span>
 					spin_unlock(&amp;state-&gt;state_lock);
 				}
 				nfs4_put_open_state(state);
<span class="p_del">-				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+				clear_bit(NFS_STATE_RECLAIM_NOGRACE,</span>
 					&amp;state-&gt;flags);
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index eaa7374305a3..6b1d8498d208 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static void *m_start(struct seq_file *m, loff_t *pos)</span>
 	if (!priv-&gt;task)
 		return ERR_PTR(-ESRCH);
 
<span class="p_del">-	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ_FSCREDS);</span>
 	if (!mm || IS_ERR(mm))
 		return mm;
 	down_read(&amp;mm-&gt;mmap_sem);
<span class="p_chunk">@@ -1182,7 +1182,7 @@</span> <span class="p_context"> static ssize_t pagemap_read(struct file *file, char __user *buf,</span>
 	if (!pm.buffer)
 		goto out_task;
 
<span class="p_del">-	mm = mm_access(task, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);</span>
 	ret = PTR_ERR(mm);
 	if (!mm || IS_ERR(mm))
 		goto out_free;
<span class="p_header">diff --git a/fs/proc/task_nommu.c b/fs/proc/task_nommu.c</span>
<span class="p_header">index 678455d2d683..f9db7e9f6966 100644</span>
<span class="p_header">--- a/fs/proc/task_nommu.c</span>
<span class="p_header">+++ b/fs/proc/task_nommu.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static void *m_start(struct seq_file *m, loff_t *pos)</span>
 	if (!priv-&gt;task)
 		return ERR_PTR(-ESRCH);
 
<span class="p_del">-	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = mm_access(priv-&gt;task, PTRACE_MODE_READ_FSCREDS);</span>
 	if (!mm || IS_ERR(mm)) {
 		put_task_struct(priv-&gt;task);
 		priv-&gt;task = NULL;
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index f345d53f94da..e64f59960ec5 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -949,6 +949,7 @@</span> <span class="p_context"> ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,</span>
 
 	splice_from_pipe_begin(sd);
 	do {
<span class="p_add">+		cond_resched();</span>
 		ret = splice_from_pipe_next(pipe, sd);
 		if (ret &gt; 0)
 			ret = splice_from_pipe_feed(pipe, sd, actor);
<span class="p_chunk">@@ -1175,7 +1176,7 @@</span> <span class="p_context"> ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,</span>
 	long ret, bytes;
 	umode_t i_mode;
 	size_t len;
<span class="p_del">-	int i, flags;</span>
<span class="p_add">+	int i, flags, more;</span>
 
 	/*
 	 * We require the input being a regular file, as we don&#39;t want to
<span class="p_chunk">@@ -1218,6 +1219,7 @@</span> <span class="p_context"> ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,</span>
 	 * Don&#39;t block on output, we have to drain the direct pipe.
 	 */
 	sd-&gt;flags &amp;= ~SPLICE_F_NONBLOCK;
<span class="p_add">+	more = sd-&gt;flags &amp; SPLICE_F_MORE;</span>
 
 	while (len) {
 		size_t read_len;
<span class="p_chunk">@@ -1231,6 +1233,15 @@</span> <span class="p_context"> ssize_t splice_direct_to_actor(struct file *in, struct splice_desc *sd,</span>
 		sd-&gt;total_len = read_len;
 
 		/*
<span class="p_add">+		 * If more data is pending, set SPLICE_F_MORE</span>
<span class="p_add">+		 * If this is the last data and SPLICE_F_MORE was not set</span>
<span class="p_add">+		 * initially, clears it.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (read_len &lt; len)</span>
<span class="p_add">+			sd-&gt;flags |= SPLICE_F_MORE;</span>
<span class="p_add">+		else if (!more)</span>
<span class="p_add">+			sd-&gt;flags &amp;= ~SPLICE_F_MORE;</span>
<span class="p_add">+		/*</span>
 		 * NOTE: nonblocking mode only applies to the input. We
 		 * must not do the output in nonblocking mode as then we
 		 * could get stuck data in the internal pipe:
<span class="p_header">diff --git a/include/asm-generic/cputime_nsecs.h b/include/asm-generic/cputime_nsecs.h</span>
<span class="p_header">index 2c9e62c2bfd0..f55fb04501ec 100644</span>
<span class="p_header">--- a/include/asm-generic/cputime_nsecs.h</span>
<span class="p_header">+++ b/include/asm-generic/cputime_nsecs.h</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> typedef u64 __nocast cputime64_t;</span>
  */
 static inline cputime_t timespec_to_cputime(const struct timespec *val)
 {
<span class="p_del">-	u64 ret = val-&gt;tv_sec * NSEC_PER_SEC + val-&gt;tv_nsec;</span>
<span class="p_add">+	u64 ret = (u64)val-&gt;tv_sec * NSEC_PER_SEC + val-&gt;tv_nsec;</span>
 	return (__force cputime_t) ret;
 }
 static inline void cputime_to_timespec(const cputime_t ct, struct timespec *val)
<span class="p_chunk">@@ -86,7 +86,8 @@</span> <span class="p_context"> static inline void cputime_to_timespec(const cputime_t ct, struct timespec *val)</span>
  */
 static inline cputime_t timeval_to_cputime(const struct timeval *val)
 {
<span class="p_del">-	u64 ret = val-&gt;tv_sec * NSEC_PER_SEC + val-&gt;tv_usec * NSEC_PER_USEC;</span>
<span class="p_add">+	u64 ret = (u64)val-&gt;tv_sec * NSEC_PER_SEC +</span>
<span class="p_add">+			val-&gt;tv_usec * NSEC_PER_USEC;</span>
 	return (__force cputime_t) ret;
 }
 static inline void cputime_to_timeval(const cputime_t ct, struct timeval *val)
<span class="p_header">diff --git a/include/linux/enclosure.h b/include/linux/enclosure.h</span>
<span class="p_header">index 9a33c5f7e126..f6c229e2bffa 100644</span>
<span class="p_header">--- a/include/linux/enclosure.h</span>
<span class="p_header">+++ b/include/linux/enclosure.h</span>
<span class="p_chunk">@@ -29,7 +29,11 @@</span> <span class="p_context"></span>
 /* A few generic types ... taken from ses-2 */
 enum enclosure_component_type {
 	ENCLOSURE_COMPONENT_DEVICE = 0x01,
<span class="p_add">+	ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS = 0x07,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_TARGET_PORT = 0x14,</span>
<span class="p_add">+	ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT = 0x15,</span>
 	ENCLOSURE_COMPONENT_ARRAY_DEVICE = 0x17,
<span class="p_add">+	ENCLOSURE_COMPONENT_SAS_EXPANDER = 0x18,</span>
 };
 
 /* ses-2 common element status */
<span class="p_header">diff --git a/include/linux/lockd/lockd.h b/include/linux/lockd/lockd.h</span>
<span class="p_header">index dcaad79f54ed..0adf073f13b3 100644</span>
<span class="p_header">--- a/include/linux/lockd/lockd.h</span>
<span class="p_header">+++ b/include/linux/lockd/lockd.h</span>
<span class="p_chunk">@@ -236,7 +236,8 @@</span> <span class="p_context"> void		  nlm_rebind_host(struct nlm_host *);</span>
 struct nlm_host * nlm_get_host(struct nlm_host *);
 void		  nlm_shutdown_hosts(void);
 void		  nlm_shutdown_hosts_net(struct net *net);
<span class="p_del">-void		  nlm_host_rebooted(const struct nlm_reboot *);</span>
<span class="p_add">+void		  nlm_host_rebooted(const struct net *net,</span>
<span class="p_add">+					const struct nlm_reboot *);</span>
 
 /*
  * Host monitoring
<span class="p_chunk">@@ -244,11 +245,13 @@</span> <span class="p_context"> void		  nlm_host_rebooted(const struct nlm_reboot *);</span>
 int		  nsm_monitor(const struct nlm_host *host);
 void		  nsm_unmonitor(const struct nlm_host *host);
 
<span class="p_del">-struct nsm_handle *nsm_get_handle(const struct sockaddr *sap,</span>
<span class="p_add">+struct nsm_handle *nsm_get_handle(const struct net *net,</span>
<span class="p_add">+					const struct sockaddr *sap,</span>
 					const size_t salen,
 					const char *hostname,
 					const size_t hostname_len);
<span class="p_del">-struct nsm_handle *nsm_reboot_lookup(const struct nlm_reboot *info);</span>
<span class="p_add">+struct nsm_handle *nsm_reboot_lookup(const struct net *net,</span>
<span class="p_add">+					const struct nlm_reboot *info);</span>
 void		  nsm_release(struct nsm_handle *nsm);
 
 /*
<span class="p_header">diff --git a/include/linux/nfs_fs.h b/include/linux/nfs_fs.h</span>
<span class="p_header">index 0ae5807480f4..1e122cc9ea3e 100644</span>
<span class="p_header">--- a/include/linux/nfs_fs.h</span>
<span class="p_header">+++ b/include/linux/nfs_fs.h</span>
<span class="p_chunk">@@ -580,9 +580,7 @@</span> <span class="p_context"> static inline int nfs3_proc_setacls(struct inode *inode, struct posix_acl *acl,</span>
 
 static inline loff_t nfs_size_to_loff_t(__u64 size)
 {
<span class="p_del">-	if (size &gt; (__u64) OFFSET_MAX - 1)</span>
<span class="p_del">-		return OFFSET_MAX - 1;</span>
<span class="p_del">-	return (loff_t) size;</span>
<span class="p_add">+	return min_t(u64, size, OFFSET_MAX);</span>
 }
 
 static inline ino_t
<span class="p_header">diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h</span>
<span class="p_header">index 7159a0a933df..97c8689c7e51 100644</span>
<span class="p_header">--- a/include/linux/tracepoint.h</span>
<span class="p_header">+++ b/include/linux/tracepoint.h</span>
<span class="p_chunk">@@ -14,8 +14,11 @@</span> <span class="p_context"></span>
  * See the file COPYING for more details.
  */
 
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpumask.h&gt;</span>
 #include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/static_key.h&gt;
 
<span class="p_chunk">@@ -126,6 +129,9 @@</span> <span class="p_context"> static inline void tracepoint_synchronize_unregister(void)</span>
 		void *it_func;						\
 		void *__data;						\
 									\
<span class="p_add">+		if (!cpu_online(raw_smp_processor_id()))		\</span>
<span class="p_add">+			return;						\</span>
<span class="p_add">+									\</span>
 		if (!(cond))						\
 			return;						\
 		prercu;							\
<span class="p_header">diff --git a/include/net/af_unix.h b/include/net/af_unix.h</span>
<span class="p_header">index e830c3dff61a..7bb69c9c3c43 100644</span>
<span class="p_header">--- a/include/net/af_unix.h</span>
<span class="p_header">+++ b/include/net/af_unix.h</span>
<span class="p_chunk">@@ -6,8 +6,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/mutex.h&gt;
 #include &lt;net/sock.h&gt;
 
<span class="p_del">-void unix_inflight(struct file *fp);</span>
<span class="p_del">-void unix_notinflight(struct file *fp);</span>
<span class="p_add">+void unix_inflight(struct user_struct *user, struct file *fp);</span>
<span class="p_add">+void unix_notinflight(struct user_struct *user, struct file *fp);</span>
 void unix_gc(void);
 void wait_for_unix_gc(void);
 struct sock *unix_get_socket(struct file *filp);
<span class="p_header">diff --git a/include/net/scm.h b/include/net/scm.h</span>
<span class="p_header">index 262532d111f5..59fa93c01d2a 100644</span>
<span class="p_header">--- a/include/net/scm.h</span>
<span class="p_header">+++ b/include/net/scm.h</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> struct scm_creds {</span>
 struct scm_fp_list {
 	short			count;
 	short			max;
<span class="p_add">+	struct user_struct	*user;</span>
 	struct file		*fp[SCM_MAX_FD];
 };
 
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index e4b9e011d2a1..42606764d830 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> struct se_cmd {</span>
 	sense_reason_t		(*execute_cmd)(struct se_cmd *);
 	sense_reason_t		(*execute_rw)(struct se_cmd *, struct scatterlist *,
 					      u32, enum dma_data_direction);
<span class="p_del">-	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool);</span>
<span class="p_add">+	sense_reason_t (*transport_complete_callback)(struct se_cmd *, bool, int *);</span>
 
 	unsigned char		*t_task_cdb;
 	unsigned char		__t_task_cdb[TCM_MAX_COMMAND_SIZE];
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index ebb8a9e937fa..2c2e5e70e4f3 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1230,6 +1230,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 	if (!desc)
 		return NULL;
 
<span class="p_add">+	chip_bus_lock(desc);</span>
 	raw_spin_lock_irqsave(&amp;desc-&gt;lock, flags);
 
 	/*
<span class="p_chunk">@@ -1243,7 +1244,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 		if (!action) {
 			WARN(1, &quot;Trying to free already-free IRQ %d\n&quot;, irq);
 			raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_del">-</span>
<span class="p_add">+			chip_bus_sync_unlock(desc);</span>
 			return NULL;
 		}
 
<span class="p_chunk">@@ -1266,6 +1267,7 @@</span> <span class="p_context"> static struct irqaction *__free_irq(unsigned int irq, void *dev_id)</span>
 #endif
 
 	raw_spin_unlock_irqrestore(&amp;desc-&gt;lock, flags);
<span class="p_add">+	chip_bus_sync_unlock(desc);</span>
 
 	unregister_handler_proc(irq, action);
 
<span class="p_chunk">@@ -1339,9 +1341,7 @@</span> <span class="p_context"> void free_irq(unsigned int irq, void *dev_id)</span>
 		desc-&gt;affinity_notify = NULL;
 #endif
 
<span class="p_del">-	chip_bus_lock(desc);</span>
 	kfree(__free_irq(irq, dev_id));
<span class="p_del">-	chip_bus_sync_unlock(desc);</span>
 }
 EXPORT_SYMBOL(free_irq);
 
<span class="p_header">diff --git a/kernel/resource.c b/kernel/resource.c</span>
<span class="p_header">index 3f285dce9347..449282e48bb1 100644</span>
<span class="p_header">--- a/kernel/resource.c</span>
<span class="p_header">+++ b/kernel/resource.c</span>
<span class="p_chunk">@@ -961,9 +961,10 @@</span> <span class="p_context"> struct resource * __request_region(struct resource *parent,</span>
 		if (!conflict)
 			break;
 		if (conflict != parent) {
<span class="p_del">-			parent = conflict;</span>
<span class="p_del">-			if (!(conflict-&gt;flags &amp; IORESOURCE_BUSY))</span>
<span class="p_add">+			if (!(conflict-&gt;flags &amp; IORESOURCE_BUSY)) {</span>
<span class="p_add">+				parent = conflict;</span>
 				continue;
<span class="p_add">+			}</span>
 		}
 		if (conflict-&gt;flags &amp; flags &amp; IORESOURCE_MUXED) {
 			add_wait_queue(&amp;muxed_resource_wait, &amp;wait);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index bbe957762ace..46afc8cd69dd 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -937,6 +937,13 @@</span> <span class="p_context"> inline int task_curr(const struct task_struct *p)</span>
 	return cpu_curr(task_cpu(p)) == p;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * switched_from, switched_to and prio_changed must _NOT_ drop rq-&gt;lock,</span>
<span class="p_add">+ * use the balance_callback list if you want balancing.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * this means any call to check_class_changed() must be followed by a call to</span>
<span class="p_add">+ * balance_callback().</span>
<span class="p_add">+ */</span>
 static inline void check_class_changed(struct rq *rq, struct task_struct *p,
 				       const struct sched_class *prev_class,
 				       int oldprio)
<span class="p_chunk">@@ -1423,8 +1430,12 @@</span> <span class="p_context"> ttwu_do_wakeup(struct rq *rq, struct task_struct *p, int wake_flags)</span>
 
 	p-&gt;state = TASK_RUNNING;
 #ifdef CONFIG_SMP
<span class="p_del">-	if (p-&gt;sched_class-&gt;task_woken)</span>
<span class="p_add">+	if (p-&gt;sched_class-&gt;task_woken) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * XXX can drop rq-&gt;lock; most likely ok.</span>
<span class="p_add">+		 */</span>
 		p-&gt;sched_class-&gt;task_woken(rq, p);
<span class="p_add">+	}</span>
 
 	if (rq-&gt;idle_stamp) {
 		u64 delta = rq_clock(rq) - rq-&gt;idle_stamp;
<span class="p_chunk">@@ -1685,7 +1696,6 @@</span> <span class="p_context"> out:</span>
  */
 int wake_up_process(struct task_struct *p)
 {
<span class="p_del">-	WARN_ON(task_is_stopped_or_traced(p));</span>
 	return try_to_wake_up(p, TASK_NORMAL, 0);
 }
 EXPORT_SYMBOL(wake_up_process);
<span class="p_chunk">@@ -2179,18 +2189,30 @@</span> <span class="p_context"> static inline void pre_schedule(struct rq *rq, struct task_struct *prev)</span>
 }
 
 /* rq-&gt;lock is NOT held, but preemption is disabled */
<span class="p_del">-static inline void post_schedule(struct rq *rq)</span>
<span class="p_add">+static void __balance_callback(struct rq *rq)</span>
 {
<span class="p_del">-	if (rq-&gt;post_schedule) {</span>
<span class="p_del">-		unsigned long flags;</span>
<span class="p_add">+	struct callback_head *head, *next;</span>
<span class="p_add">+	void (*func)(struct rq *rq);</span>
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_del">-		raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
<span class="p_del">-		if (rq-&gt;curr-&gt;sched_class-&gt;post_schedule)</span>
<span class="p_del">-			rq-&gt;curr-&gt;sched_class-&gt;post_schedule(rq);</span>
<span class="p_del">-		raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;rq-&gt;lock, flags);</span>
<span class="p_add">+	head = rq-&gt;balance_callback;</span>
<span class="p_add">+	rq-&gt;balance_callback = NULL;</span>
<span class="p_add">+	while (head) {</span>
<span class="p_add">+		func = (void (*)(struct rq *))head-&gt;func;</span>
<span class="p_add">+		next = head-&gt;next;</span>
<span class="p_add">+		head-&gt;next = NULL;</span>
<span class="p_add">+		head = next;</span>
 
<span class="p_del">-		rq-&gt;post_schedule = 0;</span>
<span class="p_add">+		func(rq);</span>
 	}
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;rq-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void balance_callback(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(rq-&gt;balance_callback))</span>
<span class="p_add">+		__balance_callback(rq);</span>
 }
 
 #else
<span class="p_chunk">@@ -2199,7 +2221,7 @@</span> <span class="p_context"> static inline void pre_schedule(struct rq *rq, struct task_struct *p)</span>
 {
 }
 
<span class="p_del">-static inline void post_schedule(struct rq *rq)</span>
<span class="p_add">+static inline void balance_callback(struct rq *rq)</span>
 {
 }
 
<span class="p_chunk">@@ -2220,7 +2242,7 @@</span> <span class="p_context"> asmlinkage void schedule_tail(struct task_struct *prev)</span>
 	 * FIXME: do we need to worry about rq being invalidated by the
 	 * task_switch?
 	 */
<span class="p_del">-	post_schedule(rq);</span>
<span class="p_add">+	balance_callback(rq);</span>
 
 #ifdef __ARCH_WANT_UNLOCKED_CTXSW
 	/* In this case, finish_task_switch does not reenable preemption */
<span class="p_chunk">@@ -2732,7 +2754,7 @@</span> <span class="p_context"> need_resched:</span>
 	} else
 		raw_spin_unlock_irq(&amp;rq-&gt;lock);
 
<span class="p_del">-	post_schedule(rq);</span>
<span class="p_add">+	balance_callback(rq);</span>
 
 	sched_preempt_enable_no_resched();
 	if (need_resched())
<span class="p_chunk">@@ -2994,7 +3016,11 @@</span> <span class="p_context"> void rt_mutex_setprio(struct task_struct *p, int prio)</span>
 
 	check_class_changed(rq, p, prev_class, oldprio);
 out_unlock:
<span class="p_add">+	preempt_disable(); /* avoid rq from going away on us */</span>
 	__task_rq_unlock(rq);
<span class="p_add">+</span>
<span class="p_add">+	balance_callback(rq);</span>
<span class="p_add">+	preempt_enable();</span>
 }
 #endif
 
<span class="p_chunk">@@ -3500,10 +3526,17 @@</span> <span class="p_context"> change:</span>
 		enqueue_task(rq, p, 0);
 
 	check_class_changed(rq, p, prev_class, oldprio);
<span class="p_add">+	preempt_disable(); /* avoid rq from going away on us */</span>
 	task_rq_unlock(rq, p, &amp;flags);
 
 	rt_mutex_adjust_pi(p);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Run balance callbacks after we&#39;ve adjusted the PI chain.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	balance_callback(rq);</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -5386,13 +5419,13 @@</span> <span class="p_context"> static int init_rootdomain(struct root_domain *rd)</span>
 {
 	memset(rd, 0, sizeof(*rd));
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
 		goto out;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
 		goto free_span;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;dlo_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;dlo_mask, GFP_KERNEL))</span>
 		goto free_online;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
 		goto free_dlo_mask;
 
 	init_dl_bw(&amp;rd-&gt;dl_bw);
<span class="p_chunk">@@ -6902,7 +6935,7 @@</span> <span class="p_context"> void __init sched_init(void)</span>
 		rq-&gt;sd = NULL;
 		rq-&gt;rd = NULL;
 		rq-&gt;cpu_power = SCHED_POWER_SCALE;
<span class="p_del">-		rq-&gt;post_schedule = 0;</span>
<span class="p_add">+		rq-&gt;balance_callback = NULL;</span>
 		rq-&gt;active_balance = 0;
 		rq-&gt;next_balance = jiffies;
 		rq-&gt;push_cpu = 0;
<span class="p_header">diff --git a/kernel/sched/deadline.c b/kernel/sched/deadline.c</span>
<span class="p_header">index 8d3c5ddfdfdd..6ab59bb2947b 100644</span>
<span class="p_header">--- a/kernel/sched/deadline.c</span>
<span class="p_header">+++ b/kernel/sched/deadline.c</span>
<span class="p_chunk">@@ -210,6 +210,25 @@</span> <span class="p_context"> static inline int has_pushable_dl_tasks(struct rq *rq)</span>
 
 static int push_dl_task(struct rq *rq);
 
<span class="p_add">+static DEFINE_PER_CPU(struct callback_head, dl_push_head);</span>
<span class="p_add">+static DEFINE_PER_CPU(struct callback_head, dl_pull_head);</span>
<span class="p_add">+</span>
<span class="p_add">+static void push_dl_tasks(struct rq *);</span>
<span class="p_add">+static void pull_dl_task(struct rq *);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void queue_push_tasks(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!has_pushable_dl_tasks(rq))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	queue_balance_callback(rq, &amp;per_cpu(dl_push_head, rq-&gt;cpu), push_dl_tasks);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void queue_pull_task(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	queue_balance_callback(rq, &amp;per_cpu(dl_pull_head, rq-&gt;cpu), pull_dl_task);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #else
 
 static inline
<span class="p_chunk">@@ -232,6 +251,13 @@</span> <span class="p_context"> void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)</span>
 {
 }
 
<span class="p_add">+static inline void queue_push_tasks(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void queue_pull_task(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 #endif /* CONFIG_SMP */
 
 static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);
<span class="p_chunk">@@ -1005,7 +1031,7 @@</span> <span class="p_context"> struct task_struct *pick_next_task_dl(struct rq *rq)</span>
 #endif
 
 #ifdef CONFIG_SMP
<span class="p_del">-	rq-&gt;post_schedule = has_pushable_dl_tasks(rq);</span>
<span class="p_add">+	queue_push_tasks(rq);</span>
 #endif /* CONFIG_SMP */
 
 	return p;
<span class="p_chunk">@@ -1336,15 +1362,16 @@</span> <span class="p_context"> static void push_dl_tasks(struct rq *rq)</span>
 		;
 }
 
<span class="p_del">-static int pull_dl_task(struct rq *this_rq)</span>
<span class="p_add">+static void pull_dl_task(struct rq *this_rq)</span>
 {
<span class="p_del">-	int this_cpu = this_rq-&gt;cpu, ret = 0, cpu;</span>
<span class="p_add">+	int this_cpu = this_rq-&gt;cpu, cpu;</span>
 	struct task_struct *p;
<span class="p_add">+	bool resched = false;</span>
 	struct rq *src_rq;
 	u64 dmin = LONG_MAX;
 
 	if (likely(!dl_overloaded(this_rq)))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return;</span>
 
 	/*
 	 * Match the barrier from dl_set_overloaded; this guarantees that if we
<span class="p_chunk">@@ -1399,7 +1426,7 @@</span> <span class="p_context"> static int pull_dl_task(struct rq *this_rq)</span>
 					   src_rq-&gt;curr-&gt;dl.deadline))
 				goto skip;
 
<span class="p_del">-			ret = 1;</span>
<span class="p_add">+			resched = true;</span>
 
 			deactivate_task(src_rq, p, 0);
 			set_task_cpu(p, this_cpu);
<span class="p_chunk">@@ -1412,7 +1439,8 @@</span> <span class="p_context"> skip:</span>
 		double_unlock_balance(this_rq, src_rq);
 	}
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	if (resched)</span>
<span class="p_add">+		resched_task(this_rq-&gt;curr);</span>
 }
 
 static void pre_schedule_dl(struct rq *rq, struct task_struct *prev)
<span class="p_chunk">@@ -1422,11 +1450,6 @@</span> <span class="p_context"> static void pre_schedule_dl(struct rq *rq, struct task_struct *prev)</span>
 		pull_dl_task(rq);
 }
 
<span class="p_del">-static void post_schedule_dl(struct rq *rq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	push_dl_tasks(rq);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Since the task is not running and a reschedule is not going to happen
  * anytime soon on its runqueue, we try pushing it away now.
<span class="p_chunk">@@ -1529,7 +1552,7 @@</span> <span class="p_context"> static void switched_from_dl(struct rq *rq, struct task_struct *p)</span>
 	 * from an overloaded cpu, if any.
 	 */
 	if (!rq-&gt;dl.dl_nr_running)
<span class="p_del">-		pull_dl_task(rq);</span>
<span class="p_add">+		queue_pull_task(rq);</span>
 #endif
 }
 
<span class="p_chunk">@@ -1539,8 +1562,6 @@</span> <span class="p_context"> static void switched_from_dl(struct rq *rq, struct task_struct *p)</span>
  */
 static void switched_to_dl(struct rq *rq, struct task_struct *p)
 {
<span class="p_del">-	int check_resched = 1;</span>
<span class="p_del">-</span>
 	/*
 	 * If p is throttled, don&#39;t consider the possibility
 	 * of preempting rq-&gt;curr, the check will be done right
<span class="p_chunk">@@ -1551,12 +1572,12 @@</span> <span class="p_context"> static void switched_to_dl(struct rq *rq, struct task_struct *p)</span>
 
 	if (p-&gt;on_rq || rq-&gt;curr != p) {
 #ifdef CONFIG_SMP
<span class="p_del">-		if (rq-&gt;dl.overloaded &amp;&amp; push_dl_task(rq) &amp;&amp; rq != task_rq(p))</span>
<span class="p_del">-			/* Only reschedule if pushing failed */</span>
<span class="p_del">-			check_resched = 0;</span>
<span class="p_del">-#endif /* CONFIG_SMP */</span>
<span class="p_del">-		if (check_resched &amp;&amp; task_has_dl_policy(rq-&gt;curr))</span>
<span class="p_add">+		if (rq-&gt;dl.overloaded)</span>
<span class="p_add">+			queue_push_tasks(rq);</span>
<span class="p_add">+#else</span>
<span class="p_add">+		if (task_has_dl_policy(rq-&gt;curr))</span>
 			check_preempt_curr_dl(rq, p, 0);
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 	}
 }
 
<span class="p_chunk">@@ -1576,15 +1597,14 @@</span> <span class="p_context"> static void prio_changed_dl(struct rq *rq, struct task_struct *p,</span>
 		 * or lowering its prio, so...
 		 */
 		if (!rq-&gt;dl.overloaded)
<span class="p_del">-			pull_dl_task(rq);</span>
<span class="p_add">+			queue_pull_task(rq);</span>
 
 		/*
 		 * If we now have a earlier deadline task than p,
 		 * then reschedule, provided p is still on this
 		 * runqueue.
 		 */
<span class="p_del">-		if (dl_time_before(rq-&gt;dl.earliest_dl.curr, p-&gt;dl.deadline) &amp;&amp;</span>
<span class="p_del">-		    rq-&gt;curr == p)</span>
<span class="p_add">+		if (dl_time_before(rq-&gt;dl.earliest_dl.curr, p-&gt;dl.deadline))</span>
 			resched_task(p);
 #else
 		/*
<span class="p_chunk">@@ -1615,7 +1635,6 @@</span> <span class="p_context"> const struct sched_class dl_sched_class = {</span>
 	.rq_online              = rq_online_dl,
 	.rq_offline             = rq_offline_dl,
 	.pre_schedule		= pre_schedule_dl,
<span class="p_del">-	.post_schedule		= post_schedule_dl,</span>
 	.task_woken		= task_woken_dl,
 #endif
 
<span class="p_header">diff --git a/kernel/sched/idle_task.c b/kernel/sched/idle_task.c</span>
<span class="p_header">index 516c3d9ceea1..d08678d38d12 100644</span>
<span class="p_header">--- a/kernel/sched/idle_task.c</span>
<span class="p_header">+++ b/kernel/sched/idle_task.c</span>
<span class="p_chunk">@@ -19,11 +19,6 @@</span> <span class="p_context"> static void pre_schedule_idle(struct rq *rq, struct task_struct *prev)</span>
 	idle_exit_fair(rq);
 	rq_last_tick_reset(rq);
 }
<span class="p_del">-</span>
<span class="p_del">-static void post_schedule_idle(struct rq *rq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	idle_enter_fair(rq);</span>
<span class="p_del">-}</span>
 #endif /* CONFIG_SMP */
 /*
  * Idle tasks are unconditionally rescheduled:
<span class="p_chunk">@@ -37,8 +32,7 @@</span> <span class="p_context"> static struct task_struct *pick_next_task_idle(struct rq *rq)</span>
 {
 	schedstat_inc(rq, sched_goidle);
 #ifdef CONFIG_SMP
<span class="p_del">-	/* Trigger the post schedule to do an idle_enter for CFS */</span>
<span class="p_del">-	rq-&gt;post_schedule = 1;</span>
<span class="p_add">+	idle_enter_fair(rq);</span>
 #endif
 	return rq-&gt;idle;
 }
<span class="p_chunk">@@ -102,7 +96,6 @@</span> <span class="p_context"> const struct sched_class idle_sched_class = {</span>
 #ifdef CONFIG_SMP
 	.select_task_rq		= select_task_rq_idle,
 	.pre_schedule		= pre_schedule_idle,
<span class="p_del">-	.post_schedule		= post_schedule_idle,</span>
 #endif
 
 	.set_curr_task          = set_curr_task_idle,
<span class="p_header">diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c</span>
<span class="p_header">index 27b8e836307f..0fb72ae876e7 100644</span>
<span class="p_header">--- a/kernel/sched/rt.c</span>
<span class="p_header">+++ b/kernel/sched/rt.c</span>
<span class="p_chunk">@@ -315,6 +315,25 @@</span> <span class="p_context"> static inline int has_pushable_tasks(struct rq *rq)</span>
 	return !plist_head_empty(&amp;rq-&gt;rt.pushable_tasks);
 }
 
<span class="p_add">+static DEFINE_PER_CPU(struct callback_head, rt_push_head);</span>
<span class="p_add">+static DEFINE_PER_CPU(struct callback_head, rt_pull_head);</span>
<span class="p_add">+</span>
<span class="p_add">+static void push_rt_tasks(struct rq *);</span>
<span class="p_add">+static void pull_rt_task(struct rq *);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void queue_push_tasks(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!has_pushable_tasks(rq))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	queue_balance_callback(rq, &amp;per_cpu(rt_push_head, rq-&gt;cpu), push_rt_tasks);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void queue_pull_task(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	queue_balance_callback(rq, &amp;per_cpu(rt_pull_head, rq-&gt;cpu), pull_rt_task);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void enqueue_pushable_task(struct rq *rq, struct task_struct *p)
 {
 	plist_del(&amp;p-&gt;pushable_tasks, &amp;rq-&gt;rt.pushable_tasks);
<span class="p_chunk">@@ -359,6 +378,9 @@</span> <span class="p_context"> void dec_rt_migration(struct sched_rt_entity *rt_se, struct rt_rq *rt_rq)</span>
 {
 }
 
<span class="p_add">+static inline void queue_push_tasks(struct rq *rq)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 #endif /* CONFIG_SMP */
 
 static inline int on_rt_rq(struct sched_rt_entity *rt_se)
<span class="p_chunk">@@ -1349,11 +1371,7 @@</span> <span class="p_context"> static struct task_struct *pick_next_task_rt(struct rq *rq)</span>
 		dequeue_pushable_task(rq, p);
 
 #ifdef CONFIG_SMP
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We detect this state here so that we can avoid taking the RQ</span>
<span class="p_del">-	 * lock again later if there is no need to push</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	rq-&gt;post_schedule = has_pushable_tasks(rq);</span>
<span class="p_add">+	queue_push_tasks(rq);</span>
 #endif
 
 	return p;
<span class="p_chunk">@@ -1641,14 +1659,15 @@</span> <span class="p_context"> static void push_rt_tasks(struct rq *rq)</span>
 		;
 }
 
<span class="p_del">-static int pull_rt_task(struct rq *this_rq)</span>
<span class="p_add">+static void pull_rt_task(struct rq *this_rq)</span>
 {
<span class="p_del">-	int this_cpu = this_rq-&gt;cpu, ret = 0, cpu;</span>
<span class="p_add">+	int this_cpu = this_rq-&gt;cpu, cpu;</span>
<span class="p_add">+	bool resched = false;</span>
 	struct task_struct *p;
 	struct rq *src_rq;
 
 	if (likely(!rt_overloaded(this_rq)))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return;</span>
 
 	/*
 	 * Match the barrier from rt_set_overloaded; this guarantees that if we
<span class="p_chunk">@@ -1705,7 +1724,7 @@</span> <span class="p_context"> static int pull_rt_task(struct rq *this_rq)</span>
 			if (p-&gt;prio &lt; src_rq-&gt;curr-&gt;prio)
 				goto skip;
 
<span class="p_del">-			ret = 1;</span>
<span class="p_add">+			resched = true;</span>
 
 			deactivate_task(src_rq, p, 0);
 			set_task_cpu(p, this_cpu);
<span class="p_chunk">@@ -1721,7 +1740,8 @@</span> <span class="p_context"> skip:</span>
 		double_unlock_balance(this_rq, src_rq);
 	}
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	if (resched)</span>
<span class="p_add">+		resched_task(this_rq-&gt;curr);</span>
 }
 
 static void pre_schedule_rt(struct rq *rq, struct task_struct *prev)
<span class="p_chunk">@@ -1731,11 +1751,6 @@</span> <span class="p_context"> static void pre_schedule_rt(struct rq *rq, struct task_struct *prev)</span>
 		pull_rt_task(rq);
 }
 
<span class="p_del">-static void post_schedule_rt(struct rq *rq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	push_rt_tasks(rq);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * If we are not running and we are not going to reschedule soon, we should
  * try to push tasks away now
<span class="p_chunk">@@ -1829,8 +1844,7 @@</span> <span class="p_context"> static void switched_from_rt(struct rq *rq, struct task_struct *p)</span>
 	if (!p-&gt;on_rq || rq-&gt;rt.rt_nr_running)
 		return;
 
<span class="p_del">-	if (pull_rt_task(rq))</span>
<span class="p_del">-		resched_task(rq-&gt;curr);</span>
<span class="p_add">+	queue_pull_task(rq);</span>
 }
 
 void init_sched_rt_class(void)
<span class="p_chunk">@@ -1851,8 +1865,6 @@</span> <span class="p_context"> void init_sched_rt_class(void)</span>
  */
 static void switched_to_rt(struct rq *rq, struct task_struct *p)
 {
<span class="p_del">-	int check_resched = 1;</span>
<span class="p_del">-</span>
 	/*
 	 * If we are already running, then there&#39;s nothing
 	 * that needs to be done. But if we are not running
<span class="p_chunk">@@ -1862,13 +1874,12 @@</span> <span class="p_context"> static void switched_to_rt(struct rq *rq, struct task_struct *p)</span>
 	 */
 	if (p-&gt;on_rq &amp;&amp; rq-&gt;curr != p) {
 #ifdef CONFIG_SMP
<span class="p_del">-		if (rq-&gt;rt.overloaded &amp;&amp; push_rt_task(rq) &amp;&amp;</span>
<span class="p_del">-		    /* Don&#39;t resched if we changed runqueues */</span>
<span class="p_del">-		    rq != task_rq(p))</span>
<span class="p_del">-			check_resched = 0;</span>
<span class="p_del">-#endif /* CONFIG_SMP */</span>
<span class="p_del">-		if (check_resched &amp;&amp; p-&gt;prio &lt; rq-&gt;curr-&gt;prio)</span>
<span class="p_add">+		if (rq-&gt;rt.overloaded)</span>
<span class="p_add">+			queue_push_tasks(rq);</span>
<span class="p_add">+#else</span>
<span class="p_add">+		if (p-&gt;prio &lt; rq-&gt;curr-&gt;prio)</span>
 			resched_task(rq-&gt;curr);
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 	}
 }
 
<span class="p_chunk">@@ -1889,14 +1900,13 @@</span> <span class="p_context"> prio_changed_rt(struct rq *rq, struct task_struct *p, int oldprio)</span>
 		 * may need to pull tasks to this runqueue.
 		 */
 		if (oldprio &lt; p-&gt;prio)
<span class="p_del">-			pull_rt_task(rq);</span>
<span class="p_add">+			queue_pull_task(rq);</span>
<span class="p_add">+</span>
 		/*
 		 * If there&#39;s a higher priority task waiting to run
<span class="p_del">-		 * then reschedule. Note, the above pull_rt_task</span>
<span class="p_del">-		 * can release the rq lock and p could migrate.</span>
<span class="p_del">-		 * Only reschedule if p is still on the same runqueue.</span>
<span class="p_add">+		 * then reschedule.</span>
 		 */
<span class="p_del">-		if (p-&gt;prio &gt; rq-&gt;rt.highest_prio.curr &amp;&amp; rq-&gt;curr == p)</span>
<span class="p_add">+		if (p-&gt;prio &gt; rq-&gt;rt.highest_prio.curr)</span>
 			resched_task(p);
 #else
 		/* For UP simply resched on drop of prio */
<span class="p_chunk">@@ -2008,7 +2018,6 @@</span> <span class="p_context"> const struct sched_class rt_sched_class = {</span>
 	.rq_online              = rq_online_rt,
 	.rq_offline             = rq_offline_rt,
 	.pre_schedule		= pre_schedule_rt,
<span class="p_del">-	.post_schedule		= post_schedule_rt,</span>
 	.task_woken		= task_woken_rt,
 	.switched_from		= switched_from_rt,
 #endif
<span class="p_header">diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h</span>
<span class="p_header">index 835b6efa8bd6..675e147a86f2 100644</span>
<span class="p_header">--- a/kernel/sched/sched.h</span>
<span class="p_header">+++ b/kernel/sched/sched.h</span>
<span class="p_chunk">@@ -587,9 +587,10 @@</span> <span class="p_context"> struct rq {</span>
 
 	unsigned long cpu_power;
 
<span class="p_add">+	struct callback_head *balance_callback;</span>
<span class="p_add">+</span>
 	unsigned char idle_balance;
 	/* For active balancing */
<span class="p_del">-	int post_schedule;</span>
 	int active_balance;
 	int push_cpu;
 	struct cpu_stop_work active_balance_work;
<span class="p_chunk">@@ -690,6 +691,21 @@</span> <span class="p_context"> extern int migrate_swap(struct task_struct *, struct task_struct *);</span>
 
 #ifdef CONFIG_SMP
 
<span class="p_add">+static inline void</span>
<span class="p_add">+queue_balance_callback(struct rq *rq,</span>
<span class="p_add">+		       struct callback_head *head,</span>
<span class="p_add">+		       void (*func)(struct rq *rq))</span>
<span class="p_add">+{</span>
<span class="p_add">+	lockdep_assert_held(&amp;rq-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(head-&gt;next))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	head-&gt;func = (void (*)(struct callback_head *))func;</span>
<span class="p_add">+	head-&gt;next = rq-&gt;balance_callback;</span>
<span class="p_add">+	rq-&gt;balance_callback = head;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define rcu_dereference_check_sched_domain(p) \
 	rcu_dereference_check((p), \
 			      lockdep_is_held(&amp;sched_domains_mutex))
<span class="p_chunk">@@ -1131,7 +1147,6 @@</span> <span class="p_context"> struct sched_class {</span>
 	void (*migrate_task_rq)(struct task_struct *p, int next_cpu);
 
 	void (*pre_schedule) (struct rq *this_rq, struct task_struct *task);
<span class="p_del">-	void (*post_schedule) (struct rq *this_rq);</span>
 	void (*task_waking) (struct task_struct *task);
 	void (*task_woken) (struct rq *this_rq, struct task_struct *task);
 
<span class="p_header">diff --git a/kernel/time/posix-clock.c b/kernel/time/posix-clock.c</span>
<span class="p_header">index ce033c7aa2e8..9cff0ab82b63 100644</span>
<span class="p_header">--- a/kernel/time/posix-clock.c</span>
<span class="p_header">+++ b/kernel/time/posix-clock.c</span>
<span class="p_chunk">@@ -69,10 +69,10 @@</span> <span class="p_context"> static ssize_t posix_clock_read(struct file *fp, char __user *buf,</span>
 static unsigned int posix_clock_poll(struct file *fp, poll_table *wait)
 {
 	struct posix_clock *clk = get_posix_clock(fp);
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	unsigned int result = 0;</span>
 
 	if (!clk)
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		return POLLERR;</span>
 
 	if (clk-&gt;ops.poll)
 		result = clk-&gt;ops.poll(clk, fp, wait);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index da41de9dc319..c798ed2fc281 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -1949,12 +1949,6 @@</span> <span class="p_context"> rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)</span>
 		goto again;
 }
 
<span class="p_del">-static void rb_reset_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpu_buffer-&gt;read_stamp = cpu_buffer-&gt;reader_page-&gt;page-&gt;time_stamp;</span>
<span class="p_del">-	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rb_inc_iter(struct ring_buffer_iter *iter)
 {
 	struct ring_buffer_per_cpu *cpu_buffer = iter-&gt;cpu_buffer;
<span class="p_chunk">@@ -3592,7 +3586,7 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 
 	/* Finally update the reader page to the new head */
 	cpu_buffer-&gt;reader_page = reader;
<span class="p_del">-	rb_reset_reader_page(cpu_buffer);</span>
<span class="p_add">+	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
 
 	if (overwrite != cpu_buffer-&gt;last_overrun) {
 		cpu_buffer-&gt;lost_events = overwrite - cpu_buffer-&gt;last_overrun;
<span class="p_chunk">@@ -3602,6 +3596,10 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	goto again;
 
  out:
<span class="p_add">+	/* Update the read_stamp on the first event */</span>
<span class="p_add">+	if (reader &amp;&amp; reader-&gt;read == 0)</span>
<span class="p_add">+		cpu_buffer-&gt;read_stamp = reader-&gt;page-&gt;time_stamp;</span>
<span class="p_add">+</span>
 	arch_spin_unlock(&amp;cpu_buffer-&gt;lock);
 	local_irq_restore(flags);
 
<span class="p_header">diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c</span>
<span class="p_header">index c6646a58d23e..bb1ac9cbe30a 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events.c</span>
<span class="p_chunk">@@ -606,7 +606,8 @@</span> <span class="p_context"> t_next(struct seq_file *m, void *v, loff_t *pos)</span>
 		 * The ftrace subsystem is for showing formats only.
 		 * They can not be enabled or disabled via the event files.
 		 */
<span class="p_del">-		if (call-&gt;class &amp;&amp; call-&gt;class-&gt;reg)</span>
<span class="p_add">+		if (call-&gt;class &amp;&amp; call-&gt;class-&gt;reg &amp;&amp;</span>
<span class="p_add">+		    !(call-&gt;flags &amp; TRACE_EVENT_FL_IGNORE_ENABLE))</span>
 			return file;
 	}
 
<span class="p_header">diff --git a/kernel/workqueue.c b/kernel/workqueue.c</span>
<span class="p_header">index 646a8b81bee1..423c9e37a9e7 100644</span>
<span class="p_header">--- a/kernel/workqueue.c</span>
<span class="p_header">+++ b/kernel/workqueue.c</span>
<span class="p_chunk">@@ -1475,13 +1475,13 @@</span> <span class="p_context"> static void __queue_delayed_work(int cpu, struct workqueue_struct *wq,</span>
 	timer_stats_timer_set_start_info(&amp;dwork-&gt;timer);
 
 	dwork-&gt;wq = wq;
<span class="p_del">-	/* timer isn&#39;t guaranteed to run in this cpu, record earlier */</span>
<span class="p_del">-	if (cpu == WORK_CPU_UNBOUND)</span>
<span class="p_del">-		cpu = raw_smp_processor_id();</span>
 	dwork-&gt;cpu = cpu;
 	timer-&gt;expires = jiffies + delay;
 
<span class="p_del">-	add_timer_on(timer, cpu);</span>
<span class="p_add">+	if (unlikely(cpu != WORK_CPU_UNBOUND))</span>
<span class="p_add">+		add_timer_on(timer, cpu);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		add_timer(timer);</span>
 }
 
 /**
<span class="p_header">diff --git a/lib/devres.c b/lib/devres.c</span>
<span class="p_header">index 823533138fa0..20afaf181b27 100644</span>
<span class="p_header">--- a/lib/devres.c</span>
<span class="p_header">+++ b/lib/devres.c</span>
<span class="p_chunk">@@ -423,7 +423,7 @@</span> <span class="p_context"> void pcim_iounmap_regions(struct pci_dev *pdev, int mask)</span>
 	if (!iomap)
 		return;
 
<span class="p_del">-	for (i = 0; i &lt; DEVICE_COUNT_RESOURCE; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; PCIM_IOMAP_MAX; i++) {</span>
 		if (!(mask &amp; (1 &lt;&lt; i)))
 			continue;
 
<span class="p_header">diff --git a/net/ceph/messenger.c b/net/ceph/messenger.c</span>
<span class="p_header">index 2e87eecec8f6..04dd542697a7 100644</span>
<span class="p_header">--- a/net/ceph/messenger.c</span>
<span class="p_header">+++ b/net/ceph/messenger.c</span>
<span class="p_chunk">@@ -2279,7 +2279,7 @@</span> <span class="p_context"> static int read_partial_message(struct ceph_connection *con)</span>
 		con-&gt;in_base_pos = -front_len - middle_len - data_len -
 			sizeof(m-&gt;footer);
 		con-&gt;in_tag = CEPH_MSGR_TAG_READY;
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return 1;</span>
 	} else if ((s64)seq - (s64)con-&gt;in_seq &gt; 1) {
 		pr_err(&quot;read_partial_message bad seq %lld expected %lld\n&quot;,
 		       seq, con-&gt;in_seq + 1);
<span class="p_chunk">@@ -2312,7 +2312,7 @@</span> <span class="p_context"> static int read_partial_message(struct ceph_connection *con)</span>
 				sizeof(m-&gt;footer);
 			con-&gt;in_tag = CEPH_MSGR_TAG_READY;
 			con-&gt;in_seq++;
<span class="p_del">-			return 0;</span>
<span class="p_add">+			return 1;</span>
 		}
 
 		BUG_ON(!con-&gt;in_msg);
<span class="p_header">diff --git a/net/core/scm.c b/net/core/scm.c</span>
<span class="p_header">index d30eb057fa7b..cad57a1390dd 100644</span>
<span class="p_header">--- a/net/core/scm.c</span>
<span class="p_header">+++ b/net/core/scm.c</span>
<span class="p_chunk">@@ -87,6 +87,7 @@</span> <span class="p_context"> static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)</span>
 		*fplp = fpl;
 		fpl-&gt;count = 0;
 		fpl-&gt;max = SCM_MAX_FD;
<span class="p_add">+		fpl-&gt;user = NULL;</span>
 	}
 	fpp = &amp;fpl-&gt;fp[fpl-&gt;count];
 
<span class="p_chunk">@@ -107,6 +108,10 @@</span> <span class="p_context"> static int scm_fp_copy(struct cmsghdr *cmsg, struct scm_fp_list **fplp)</span>
 		*fpp++ = file;
 		fpl-&gt;count++;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!fpl-&gt;user)</span>
<span class="p_add">+		fpl-&gt;user = get_uid(current_user());</span>
<span class="p_add">+</span>
 	return num;
 }
 
<span class="p_chunk">@@ -119,6 +124,7 @@</span> <span class="p_context"> void __scm_destroy(struct scm_cookie *scm)</span>
 		scm-&gt;fp = NULL;
 		for (i=fpl-&gt;count-1; i&gt;=0; i--)
 			fput(fpl-&gt;fp[i]);
<span class="p_add">+		free_uid(fpl-&gt;user);</span>
 		kfree(fpl);
 	}
 }
<span class="p_chunk">@@ -337,6 +343,7 @@</span> <span class="p_context"> struct scm_fp_list *scm_fp_dup(struct scm_fp_list *fpl)</span>
 		for (i = 0; i &lt; fpl-&gt;count; i++)
 			get_file(fpl-&gt;fp[i]);
 		new_fpl-&gt;max = new_fpl-&gt;count;
<span class="p_add">+		new_fpl-&gt;user = get_uid(fpl-&gt;user);</span>
 	}
 	return new_fpl;
 }
<span class="p_header">diff --git a/net/ipv4/netfilter/ipt_rpfilter.c b/net/ipv4/netfilter/ipt_rpfilter.c</span>
<span class="p_header">index c49dcd0284a0..56dd8ac6d28b 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/ipt_rpfilter.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/ipt_rpfilter.c</span>
<span class="p_chunk">@@ -61,9 +61,7 @@</span> <span class="p_context"> static bool rpfilter_lookup_reverse(struct flowi4 *fl4,</span>
 	if (FIB_RES_DEV(res) == dev)
 		dev_match = true;
 #endif
<span class="p_del">-	if (dev_match || flags &amp; XT_RPFILTER_LOOSE)</span>
<span class="p_del">-		return FIB_RES_NH(res).nh_scope &lt;= RT_SCOPE_HOST;</span>
<span class="p_del">-	return dev_match;</span>
<span class="p_add">+	return dev_match || flags &amp; XT_RPFILTER_LOOSE;</span>
 }
 
 static bool rpfilter_is_local(const struct sk_buff *skb)
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 3f0ec063d7f8..7b74fca4d850 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4793,6 +4793,21 @@</span> <span class="p_context"> int addrconf_sysctl_forward(struct ctl_table *ctl, int write,</span>
 	return ret;
 }
 
<span class="p_add">+static</span>
<span class="p_add">+int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,</span>
<span class="p_add">+			void __user *buffer, size_t *lenp, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inet6_dev *idev = ctl-&gt;extra1;</span>
<span class="p_add">+	int min_mtu = IPV6_MIN_MTU;</span>
<span class="p_add">+	struct ctl_table lctl;</span>
<span class="p_add">+</span>
<span class="p_add">+	lctl = *ctl;</span>
<span class="p_add">+	lctl.extra1 = &amp;min_mtu;</span>
<span class="p_add">+	lctl.extra2 = idev ? &amp;idev-&gt;dev-&gt;mtu : NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return proc_dointvec_minmax(&amp;lctl, write, buffer, lenp, ppos);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void dev_disable_change(struct inet6_dev *idev)
 {
 	struct netdev_notifier_info info;
<span class="p_chunk">@@ -4944,7 +4959,7 @@</span> <span class="p_context"> static struct addrconf_sysctl_table</span>
 			.data		= &amp;ipv6_devconf.mtu6,
 			.maxlen		= sizeof(int),
 			.mode		= 0644,
<span class="p_del">-			.proc_handler	= proc_dointvec,</span>
<span class="p_add">+			.proc_handler	= addrconf_sysctl_mtu,</span>
 		},
 		{
 			.procname	= &quot;accept_ra&quot;,
<span class="p_header">diff --git a/net/ipv6/netfilter/ip6t_SYNPROXY.c b/net/ipv6/netfilter/ip6t_SYNPROXY.c</span>
<span class="p_header">index a0d17270117c..bd174540eb21 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/ip6t_SYNPROXY.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/ip6t_SYNPROXY.c</span>
<span class="p_chunk">@@ -37,12 +37,13 @@</span> <span class="p_context"> synproxy_build_ip(struct sk_buff *skb, const struct in6_addr *saddr,</span>
 }
 
 static void
<span class="p_del">-synproxy_send_tcp(const struct sk_buff *skb, struct sk_buff *nskb,</span>
<span class="p_add">+synproxy_send_tcp(const struct synproxy_net *snet,</span>
<span class="p_add">+		  const struct sk_buff *skb, struct sk_buff *nskb,</span>
 		  struct nf_conntrack *nfct, enum ip_conntrack_info ctinfo,
 		  struct ipv6hdr *niph, struct tcphdr *nth,
 		  unsigned int tcp_hdr_size)
 {
<span class="p_del">-	struct net *net = nf_ct_net((struct nf_conn *)nfct);</span>
<span class="p_add">+	struct net *net = nf_ct_net(snet-&gt;tmpl);</span>
 	struct dst_entry *dst;
 	struct flowi6 fl6;
 
<span class="p_chunk">@@ -83,7 +84,8 @@</span> <span class="p_context"> free_nskb:</span>
 }
 
 static void
<span class="p_del">-synproxy_send_client_synack(const struct sk_buff *skb, const struct tcphdr *th,</span>
<span class="p_add">+synproxy_send_client_synack(const struct synproxy_net *snet,</span>
<span class="p_add">+			    const struct sk_buff *skb, const struct tcphdr *th,</span>
 			    const struct synproxy_options *opts)
 {
 	struct sk_buff *nskb;
<span class="p_chunk">@@ -119,7 +121,7 @@</span> <span class="p_context"> synproxy_send_client_synack(const struct sk_buff *skb, const struct tcphdr *th,</span>
 
 	synproxy_build_options(nth, opts);
 
<span class="p_del">-	synproxy_send_tcp(skb, nskb, skb-&gt;nfct, IP_CT_ESTABLISHED_REPLY,</span>
<span class="p_add">+	synproxy_send_tcp(snet, skb, nskb, skb-&gt;nfct, IP_CT_ESTABLISHED_REPLY,</span>
 			  niph, nth, tcp_hdr_size);
 }
 
<span class="p_chunk">@@ -163,7 +165,7 @@</span> <span class="p_context"> synproxy_send_server_syn(const struct synproxy_net *snet,</span>
 
 	synproxy_build_options(nth, opts);
 
<span class="p_del">-	synproxy_send_tcp(skb, nskb, &amp;snet-&gt;tmpl-&gt;ct_general, IP_CT_NEW,</span>
<span class="p_add">+	synproxy_send_tcp(snet, skb, nskb, &amp;snet-&gt;tmpl-&gt;ct_general, IP_CT_NEW,</span>
 			  niph, nth, tcp_hdr_size);
 }
 
<span class="p_chunk">@@ -203,7 +205,7 @@</span> <span class="p_context"> synproxy_send_server_ack(const struct synproxy_net *snet,</span>
 
 	synproxy_build_options(nth, opts);
 
<span class="p_del">-	synproxy_send_tcp(skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);</span>
<span class="p_add">+	synproxy_send_tcp(snet, skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);</span>
 }
 
 static void
<span class="p_chunk">@@ -241,7 +243,7 @@</span> <span class="p_context"> synproxy_send_client_ack(const struct synproxy_net *snet,</span>
 
 	synproxy_build_options(nth, opts);
 
<span class="p_del">-	synproxy_send_tcp(skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);</span>
<span class="p_add">+	synproxy_send_tcp(snet, skb, nskb, NULL, 0, niph, nth, tcp_hdr_size);</span>
 }
 
 static bool
<span class="p_chunk">@@ -301,7 +303,7 @@</span> <span class="p_context"> synproxy_tg6(struct sk_buff *skb, const struct xt_action_param *par)</span>
 					  XT_SYNPROXY_OPT_SACK_PERM |
 					  XT_SYNPROXY_OPT_ECN);
 
<span class="p_del">-		synproxy_send_client_synack(skb, th, &amp;opts);</span>
<span class="p_add">+		synproxy_send_client_synack(snet, skb, th, &amp;opts);</span>
 		return NF_DROP;
 
 	} else if (th-&gt;ack &amp;&amp; !(th-&gt;fin || th-&gt;rst || th-&gt;syn)) {
<span class="p_header">diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">index 7d050ed6fe5a..6d28bd434ce8 100644</span>
<span class="p_header">--- a/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">+++ b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_chunk">@@ -746,10 +746,8 @@</span> <span class="p_context"> void mesh_plink_broken(struct sta_info *sta)</span>
 static void mesh_path_node_reclaim(struct rcu_head *rp)
 {
 	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
<span class="p_del">-	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
 
 	del_timer_sync(&amp;node-&gt;mpath-&gt;timer);
<span class="p_del">-	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	kfree(node-&gt;mpath);
 	kfree(node);
 }
<span class="p_chunk">@@ -757,8 +755,9 @@</span> <span class="p_context"> static void mesh_path_node_reclaim(struct rcu_head *rp)</span>
 /* needs to be called with the corresponding hashwlock taken */
 static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
 {
<span class="p_del">-	struct mesh_path *mpath;</span>
<span class="p_del">-	mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct mesh_path *mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;mpath-&gt;state_lock);
 	mpath-&gt;flags |= MESH_PATH_RESOLVING;
 	if (mpath-&gt;is_gate)
<span class="p_chunk">@@ -766,6 +765,7 @@</span> <span class="p_context"> static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)</span>
 	hlist_del_rcu(&amp;node-&gt;list);
 	call_rcu(&amp;node-&gt;rcu, mesh_path_node_reclaim);
 	spin_unlock(&amp;mpath-&gt;state_lock);
<span class="p_add">+	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	atomic_dec(&amp;tbl-&gt;entries);
 }
 
<span class="p_header">diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c</span>
<span class="p_header">index 99de2409f731..4e8d90b8fc01 100644</span>
<span class="p_header">--- a/net/netfilter/nf_tables_api.c</span>
<span class="p_header">+++ b/net/netfilter/nf_tables_api.c</span>
<span class="p_chunk">@@ -3316,9 +3316,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nft_data_init);</span>
  */
 void nft_data_uninit(const struct nft_data *data, enum nft_data_types type)
 {
<span class="p_del">-	switch (type) {</span>
<span class="p_del">-	case NFT_DATA_VALUE:</span>
<span class="p_add">+	if (type &lt; NFT_DATA_VERDICT)</span>
 		return;
<span class="p_add">+	switch (type) {</span>
 	case NFT_DATA_VERDICT:
 		return nft_verdict_uninit(data);
 	default:
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index a82fb660ec00..44222c0607c7 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -955,11 +955,13 @@</span> <span class="p_context"> int rds_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,</span>
 		release_sock(sk);
 	}
 
<span class="p_del">-	/* racing with another thread binding seems ok here */</span>
<span class="p_add">+	lock_sock(sk);</span>
 	if (daddr == 0 || rs-&gt;rs_bound_addr == 0) {
<span class="p_add">+		release_sock(sk);</span>
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}
<span class="p_add">+	release_sock(sk);</span>
 
 	/* size of rm including all sgs */
 	ret = rds_rm_size(msg, payload_len);
<span class="p_header">diff --git a/net/rfkill/core.c b/net/rfkill/core.c</span>
<span class="p_header">index ed7e0b4e7f90..4b9dc2460772 100644</span>
<span class="p_header">--- a/net/rfkill/core.c</span>
<span class="p_header">+++ b/net/rfkill/core.c</span>
<span class="p_chunk">@@ -49,7 +49,6 @@</span> <span class="p_context"></span>
 struct rfkill {
 	spinlock_t		lock;
 
<span class="p_del">-	const char		*name;</span>
 	enum rfkill_type	type;
 
 	unsigned long		state;
<span class="p_chunk">@@ -73,6 +72,7 @@</span> <span class="p_context"> struct rfkill {</span>
 	struct delayed_work	poll_work;
 	struct work_struct	uevent_work;
 	struct work_struct	sync_work;
<span class="p_add">+	char			name[];</span>
 };
 #define to_rfkill(d)	container_of(d, struct rfkill, dev)
 
<span class="p_chunk">@@ -861,14 +861,14 @@</span> <span class="p_context"> struct rfkill * __must_check rfkill_alloc(const char *name,</span>
 	if (WARN_ON(type == RFKILL_TYPE_ALL || type &gt;= NUM_RFKILL_TYPES))
 		return NULL;
 
<span class="p_del">-	rfkill = kzalloc(sizeof(*rfkill), GFP_KERNEL);</span>
<span class="p_add">+	rfkill = kzalloc(sizeof(*rfkill) + strlen(name) + 1, GFP_KERNEL);</span>
 	if (!rfkill)
 		return NULL;
 
 	spin_lock_init(&amp;rfkill-&gt;lock);
 	INIT_LIST_HEAD(&amp;rfkill-&gt;node);
 	rfkill-&gt;type = type;
<span class="p_del">-	rfkill-&gt;name = name;</span>
<span class="p_add">+	strcpy(rfkill-&gt;name, name);</span>
 	rfkill-&gt;ops = ops;
 	rfkill-&gt;data = ops_data;
 
<span class="p_chunk">@@ -1078,17 +1078,6 @@</span> <span class="p_context"> static unsigned int rfkill_fop_poll(struct file *file, poll_table *wait)</span>
 	return res;
 }
 
<span class="p_del">-static bool rfkill_readable(struct rfkill_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool r;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;data-&gt;mtx);</span>
<span class="p_del">-	r = !list_empty(&amp;data-&gt;events);</span>
<span class="p_del">-	mutex_unlock(&amp;data-&gt;mtx);</span>
<span class="p_del">-</span>
<span class="p_del">-	return r;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static ssize_t rfkill_fop_read(struct file *file, char __user *buf,
 			       size_t count, loff_t *pos)
 {
<span class="p_chunk">@@ -1105,8 +1094,11 @@</span> <span class="p_context"> static ssize_t rfkill_fop_read(struct file *file, char __user *buf,</span>
 			goto out;
 		}
 		mutex_unlock(&amp;data-&gt;mtx);
<span class="p_add">+		/* since we re-check and it just compares pointers,</span>
<span class="p_add">+		 * using !list_empty() without locking isn&#39;t a problem</span>
<span class="p_add">+		 */</span>
 		ret = wait_event_interruptible(data-&gt;read_wait,
<span class="p_del">-					       rfkill_readable(data));</span>
<span class="p_add">+					       !list_empty(&amp;data-&gt;events));</span>
 		mutex_lock(&amp;data-&gt;mtx);
 
 		if (ret)
<span class="p_header">diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c</span>
<span class="p_header">index 0adc66caae2f..07edbcd8697e 100644</span>
<span class="p_header">--- a/net/sunrpc/cache.c</span>
<span class="p_header">+++ b/net/sunrpc/cache.c</span>
<span class="p_chunk">@@ -1230,7 +1230,7 @@</span> <span class="p_context"> int qword_get(char **bpp, char *dest, int bufsize)</span>
 	if (bp[0] == &#39;\\&#39; &amp;&amp; bp[1] == &#39;x&#39;) {
 		/* HEX STRING */
 		bp += 2;
<span class="p_del">-		while (len &lt; bufsize) {</span>
<span class="p_add">+		while (len &lt; bufsize - 1) {</span>
 			int h, l;
 
 			h = hex_to_bin(bp[0]);
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 0cd18c240250..ab2eeb1cb32c 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -1469,7 +1469,7 @@</span> <span class="p_context"> static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 	UNIXCB(skb).fp = NULL;
 
 	for (i = scm-&gt;fp-&gt;count-1; i &gt;= 0; i--)
<span class="p_del">-		unix_notinflight(scm-&gt;fp-&gt;fp[i]);</span>
<span class="p_add">+		unix_notinflight(scm-&gt;fp-&gt;user, scm-&gt;fp-&gt;fp[i]);</span>
 }
 
 static void unix_destruct_scm(struct sk_buff *skb)
<span class="p_chunk">@@ -1534,7 +1534,7 @@</span> <span class="p_context"> static int unix_attach_fds(struct scm_cookie *scm, struct sk_buff *skb)</span>
 		return -ENOMEM;
 
 	for (i = scm-&gt;fp-&gt;count - 1; i &gt;= 0; i--)
<span class="p_del">-		unix_inflight(scm-&gt;fp-&gt;fp[i]);</span>
<span class="p_add">+		unix_inflight(scm-&gt;fp-&gt;user, scm-&gt;fp-&gt;fp[i]);</span>
 	return max_level;
 }
 
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index 06730fe6ad9d..a72182d6750f 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> struct sock *unix_get_socket(struct file *filp)</span>
  *	descriptor if it is for an AF_UNIX socket.
  */
 
<span class="p_del">-void unix_inflight(struct file *fp)</span>
<span class="p_add">+void unix_inflight(struct user_struct *user, struct file *fp)</span>
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_chunk">@@ -139,11 +139,11 @@</span> <span class="p_context"> void unix_inflight(struct file *fp)</span>
 		}
 		unix_tot_inflight++;
 	}
<span class="p_del">-	fp-&gt;f_cred-&gt;user-&gt;unix_inflight++;</span>
<span class="p_add">+	user-&gt;unix_inflight++;</span>
 	spin_unlock(&amp;unix_gc_lock);
 }
 
<span class="p_del">-void unix_notinflight(struct file *fp)</span>
<span class="p_add">+void unix_notinflight(struct user_struct *user, struct file *fp)</span>
 {
 	struct sock *s = unix_get_socket(fp);
 
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> void unix_notinflight(struct file *fp)</span>
 			list_del_init(&amp;u-&gt;link);
 		unix_tot_inflight--;
 	}
<span class="p_del">-	fp-&gt;f_cred-&gt;user-&gt;unix_inflight--;</span>
<span class="p_add">+	user-&gt;unix_inflight--;</span>
 	spin_unlock(&amp;unix_gc_lock);
 }
 
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index 9c22317778eb..ee625e3a56ba 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -189,6 +189,20 @@</span> <span class="p_context"> static void *mmap_file(char const *fname)</span>
 		addr = umalloc(sb.st_size);
 		uread(fd_map, addr, sb.st_size);
 	}
<span class="p_add">+	if (sb.st_nlink != 1) {</span>
<span class="p_add">+		/* file is hard-linked, break the hard link */</span>
<span class="p_add">+		close(fd_map);</span>
<span class="p_add">+		if (unlink(fname) &lt; 0) {</span>
<span class="p_add">+			perror(fname);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		fd_map = open(fname, O_RDWR | O_CREAT, sb.st_mode);</span>
<span class="p_add">+		if (fd_map &lt; 0) {</span>
<span class="p_add">+			perror(fname);</span>
<span class="p_add">+			fail_file();</span>
<span class="p_add">+		}</span>
<span class="p_add">+		uwrite(fd_map, addr, sb.st_size);</span>
<span class="p_add">+	}</span>
 	return addr;
 }
 
<span class="p_header">diff --git a/tools/Makefile b/tools/Makefile</span>
<span class="p_header">index feec3ad5fd09..6e8ac8982149 100644</span>
<span class="p_header">--- a/tools/Makefile</span>
<span class="p_header">+++ b/tools/Makefile</span>
<span class="p_chunk">@@ -24,6 +24,10 @@</span> <span class="p_context"> help:</span>
 	@echo &#39;  from the kernel command line to build and install one of&#39;
 	@echo &#39;  the tools above&#39;
 	@echo &#39;&#39;
<span class="p_add">+	@echo &#39;  $$ make tools/all&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
<span class="p_add">+	@echo &#39;  builds all tools.&#39;</span>
<span class="p_add">+	@echo &#39;&#39;</span>
 	@echo &#39;  $$ make tools/install&#39;
 	@echo &#39;&#39;
 	@echo &#39;  installs all tools.&#39;
<span class="p_chunk">@@ -58,6 +62,11 @@</span> <span class="p_context"> turbostat x86_energy_perf_policy: FORCE</span>
 tmon: FORCE
 	$(call descend,thermal/$@)
 
<span class="p_add">+all: acpi cgroup cpupower firewire lguest \</span>
<span class="p_add">+		perf selftests turbostat usb \</span>
<span class="p_add">+		virtio vm net x86_energy_perf_policy \</span>
<span class="p_add">+		tmon</span>
<span class="p_add">+</span>
 acpi_install:
 	$(call descend,power/$(@:_install=),install)
 
<span class="p_header">diff --git a/virt/kvm/async_pf.c b/virt/kvm/async_pf.c</span>
<span class="p_header">index f2c80d5451c3..919095029528 100644</span>
<span class="p_header">--- a/virt/kvm/async_pf.c</span>
<span class="p_header">+++ b/virt/kvm/async_pf.c</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> int kvm_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn,</span>
 	 * do alloc nowait since if we are going to sleep anyway we
 	 * may as well sleep faulting in page
 	 */
<span class="p_del">-	work = kmem_cache_zalloc(async_pf_cache, GFP_NOWAIT);</span>
<span class="p_add">+	work = kmem_cache_zalloc(async_pf_cache, GFP_NOWAIT | __GFP_NOWARN);</span>
 	if (!work)
 		return 0;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



