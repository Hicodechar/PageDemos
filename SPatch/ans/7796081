
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v6,4/5] iommu/mediatek: Add mt8173 IOMMU driver - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v6,4/5] iommu/mediatek: Add mt8173 IOMMU driver</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=123111">Yong Wu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 8, 2015, 9:49 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1449568153-15643-5-git-send-email-yong.wu@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7796081/mbox/"
   >mbox</a>
|
   <a href="/patch/7796081/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7796081/">/patch/7796081/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 08A069F39B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Dec 2015 09:50:43 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 3CA18203F3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Dec 2015 09:50:41 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 45CB5203E6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Dec 2015 09:50:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933343AbbLHJud (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 8 Dec 2015 04:50:33 -0500
Received: from mailgw02.mediatek.com ([210.61.82.184]:60526 &quot;EHLO
	mailgw02.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S932645AbbLHJu0 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 8 Dec 2015 04:50:26 -0500
X-Listener-Flag: 11101
Received: from mtkhts07.mediatek.inc [(172.21.101.69)] by
	mailgw02.mediatek.com (envelope-from &lt;yong.wu@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 573900261; Tue, 08 Dec 2015 17:50:23 +0800
Received: from mhfsdcap03.mhfswrd (10.17.3.153) by mtkhts07.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.266.1;
	Tue, 8 Dec 2015 17:50:21 +0800
From: Yong Wu &lt;yong.wu@mediatek.com&gt;
To: Joerg Roedel &lt;joro@8bytes.org&gt;, Thierry Reding &lt;treding@nvidia.com&gt;,
	Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Matthias Brugger &lt;matthias.bgg@gmail.com&gt;
CC: Robin Murphy &lt;robin.murphy@arm.com&gt;, Will Deacon &lt;will.deacon@arm.com&gt;,
	Daniel Kurtz &lt;djkurtz@google.com&gt;, Tomasz Figa &lt;tfiga@google.com&gt;,
	Lucas Stach &lt;l.stach@pengutronix.de&gt;, Rob Herring &lt;robh+dt@kernel.org&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	&lt;linux-mediatek@lists.infradead.org&gt;,
	Sasha Hauer &lt;kernel@pengutronix.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;, &lt;pebolle@tiscali.nl&gt;,
	&lt;arnd@arndb.de&gt;, &lt;mitchelh@codeaurora.org&gt;,
	&lt;p.zabel@pengutronix.de&gt;, &lt;yingjoe.chen@mediatek.com&gt;,
	Yong Wu &lt;yong.wu@mediatek.com&gt;
Subject: [PATCH v6 4/5] iommu/mediatek: Add mt8173 IOMMU driver
Date: Tue, 8 Dec 2015 17:49:12 +0800
Message-ID: &lt;1449568153-15643-5-git-send-email-yong.wu@mediatek.com&gt;
X-Mailer: git-send-email 1.8.1.1.dirty
In-Reply-To: &lt;1449568153-15643-1-git-send-email-yong.wu@mediatek.com&gt;
References: &lt;1449568153-15643-1-git-send-email-yong.wu@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Dec. 8, 2015, 9:49 a.m.</div>
<pre class="content">
This patch adds support for mediatek m4u (MultiMedia Memory Management
Unit).
<span class="signed-off-by">
Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig     |  15 +
 drivers/iommu/Makefile    |   1 +
 drivers/iommu/mtk_iommu.c | 752 ++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 768 insertions(+)
 create mode 100644 drivers/iommu/mtk_iommu.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=143191">kbuild test robot</a> - Dec. 8, 2015, 10:32 a.m.</div>
<pre class="content">
Hi Yong,

[auto build test ERROR on tegra/for-next]
[also build test ERROR on v4.4-rc4 next-20151208]

url:    https://github.com/0day-ci/linux/commits/Yong-Wu/MT8173-IOMMU-SUPPORT/20151208-175252
base:   https://git.kernel.org/pub/scm/linux/kernel/git/tegra/linux for-next
config: x86_64-allmodconfig (attached as .config)
reproduce:
        # save the attached .config to linux build tree
        make ARCH=x86_64 

All error/warnings (new ones prefixed by &gt;&gt;):

   drivers/iommu/dma-iommu.c: In function &#39;__iommu_dma_alloc_pages&#39;:
<span class="quote">&gt;&gt; drivers/iommu/dma-iommu.c:198:11: error: implicit declaration of function &#39;vzalloc&#39; [-Werror=implicit-function-declaration]</span>
      pages = vzalloc(array_size);
              ^
<span class="quote">&gt;&gt; drivers/iommu/dma-iommu.c:198:9: warning: assignment makes pointer from integer without a cast [-Wint-conversion]</span>
      pages = vzalloc(array_size);
            ^
   cc1: some warnings being treated as errors
--
<span class="quote">&gt;&gt; drivers/iommu/mtk_iommu.c:176:19: warning: initialization from incompatible pointer type [-Wincompatible-pointer-types]</span>
     .tlb_add_flush = mtk_iommu_tlb_add_flush_nosync,
                      ^
   drivers/iommu/mtk_iommu.c:176:19: note: (near initialization for &#39;mtk_iommu_gather_ops.tlb_add_flush&#39;)
   drivers/iommu/mtk_iommu.c: In function &#39;mtk_iommu_domain_finalise&#39;:
<span class="quote">&gt;&gt; drivers/iommu/mtk_iommu.c:239:4: error: &#39;IO_PGTABLE_QUIRK_NO_PERMS&#39; undeclared (first use in this function)</span>
       IO_PGTABLE_QUIRK_NO_PERMS |
       ^
   drivers/iommu/mtk_iommu.c:239:4: note: each undeclared identifier is reported only once for each function it appears in
<span class="quote">&gt;&gt; drivers/iommu/mtk_iommu.c:240:4: error: &#39;IO_PGTABLE_QUIRK_TLBI_ON_MAP&#39; undeclared (first use in this function)</span>
       IO_PGTABLE_QUIRK_TLBI_ON_MAP,
       ^
<span class="quote">&gt;&gt; drivers/iommu/mtk_iommu.c:248:34: error: &#39;ARM_V7S&#39; undeclared (first use in this function)</span>
     dom-&gt;iop = alloc_io_pgtable_ops(ARM_V7S, &amp;dom-&gt;cfg, data);
                                     ^
   In file included from arch/x86/include/asm/realmode.h:5:0,
                    from arch/x86/include/asm/acpi.h:33,
                    from arch/x86/include/asm/fixmap.h:19,
                    from arch/x86/include/asm/apic.h:12,
                    from arch/x86/include/asm/smp.h:12,
                    from arch/x86/include/asm/mmzone_64.h:10,
                    from arch/x86/include/asm/mmzone.h:4,
                    from include/linux/mmzone.h:856,
                    from include/linux/topology.h:32,
                    from include/linux/of.h:24,
                    from include/linux/iommu.h:24,
                    from include/linux/dma-iommu.h:23,
                    from drivers/iommu/mtk_iommu.c:16:
<span class="quote">&gt;&gt; drivers/iommu/mtk_iommu.c:257:35: error: &#39;struct io_pgtable_cfg&#39; has no member named &#39;arm_v7s_cfg&#39;</span>
     writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],
                                      ^
   arch/x86/include/asm/io.h:81:39: note: in definition of macro &#39;writel_relaxed&#39;
    #define writel_relaxed(v, a) __writel(v, a)
                                          ^
   drivers/iommu/mtk_iommu.c: In function &#39;mtk_iommu_resume&#39;:
   drivers/iommu/mtk_iommu.c:702:35: error: &#39;struct io_pgtable_cfg&#39; has no member named &#39;arm_v7s_cfg&#39;
     writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],
                                      ^
   arch/x86/include/asm/io.h:81:39: note: in definition of macro &#39;writel_relaxed&#39;
    #define writel_relaxed(v, a) __writel(v, a)
                                          ^

vim +/IO_PGTABLE_QUIRK_NO_PERMS +239 drivers/iommu/mtk_iommu.c

   170		/* Clear the CPE status */
   171		writel_relaxed(0, data-&gt;base + REG_MMU_CPE_DONE);
   172	}
   173	
   174	static const struct iommu_gather_ops mtk_iommu_gather_ops = {
   175		.tlb_flush_all = mtk_iommu_tlb_flush_all,
<span class="quote"> &gt; 176		.tlb_add_flush = mtk_iommu_tlb_add_flush_nosync,</span>
   177		.tlb_sync = mtk_iommu_tlb_sync,
   178	};
   179	
   180	static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)
   181	{
   182		struct mtk_iommu_data *data = dev_id;
   183		struct mtk_iommu_domain *dom = data-&gt;m4u_dom;
   184		u32 int_state, regval, fault_iova, fault_pa;
   185		unsigned int fault_larb, fault_port;
   186		bool layer, write;
   187	
   188		/* Read error info from registers */
   189		int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST1);
   190		fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);
   191		layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;
   192		write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;
   193		fault_iova &amp;= F_MMU_FAULT_VA_MSK;
   194		fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);
   195		regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);
   196		fault_larb = F_MMU0_INT_ID_LARB_ID(regval);
   197		fault_port = F_MMU0_INT_ID_PORT_ID(regval);
   198	
   199		if (report_iommu_fault(&amp;dom-&gt;domain, data-&gt;dev, fault_iova,
   200				       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {
   201			dev_err_ratelimited(
   202				data-&gt;dev,
   203				&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,
   204				int_state, fault_iova, fault_pa, fault_larb, fault_port,
   205				layer, write ? &quot;write&quot; : &quot;read&quot;);
   206		}
   207	
   208		/* Interrupt clear */
   209		regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);
   210		regval |= F_INT_CLR_BIT;
   211		writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL0);
   212	
   213		mtk_iommu_tlb_flush_all(data);
   214	
   215		return IRQ_HANDLED;
   216	}
   217	
   218	static void mtk_iommu_config(struct mtk_iommu_data *data,
   219				     struct device *dev, bool enable)
   220	{
   221		struct mtk_iommu_client_priv *head, *cur, *next;
   222	
   223		head = dev-&gt;archdata.iommu;
   224		list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {
   225			mtk_smi_config_port(
   226				data-&gt;larbdev[MTK_M4U_TO_LARB(cur-&gt;mtk_m4u_id)],
   227				MTK_M4U_TO_PORT(cur-&gt;mtk_m4u_id), enable);
   228		}
   229	}
   230	
   231	static int mtk_iommu_domain_finalise(struct mtk_iommu_data *data)
   232	{
   233		struct mtk_iommu_domain *dom = data-&gt;m4u_dom;
   234	
   235		spin_lock_init(&amp;dom-&gt;pgtlock);
   236	
   237		dom-&gt;cfg = (struct io_pgtable_cfg) {
   238			.quirks = IO_PGTABLE_QUIRK_ARM_NS |
<span class="quote"> &gt; 239				IO_PGTABLE_QUIRK_NO_PERMS |</span>
<span class="quote"> &gt; 240				IO_PGTABLE_QUIRK_TLBI_ON_MAP,</span>
   241			.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,
   242			.ias = 32,
   243			.oas = 32,
   244			.tlb = &amp;mtk_iommu_gather_ops,
   245			.iommu_dev = data-&gt;dev,
   246		};
   247	
<span class="quote"> &gt; 248		dom-&gt;iop = alloc_io_pgtable_ops(ARM_V7S, &amp;dom-&gt;cfg, data);</span>
   249		if (!dom-&gt;iop) {
   250			dev_err(data-&gt;dev, &quot;Failed to alloc io pgtable\n&quot;);
   251			return -EINVAL;
   252		}
   253	
   254		/* Update our support page sizes bitmap */
   255		mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;
   256	
<span class="quote"> &gt; 257		writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
   258			       data-&gt;base + REG_MMU_PT_BASE_ADDR);
   259		return 0;
   260	}

---
0-DAY kernel test infrastructure                Open Source Technology Center
https://lists.01.org/pipermail/kbuild-all                   Intel Corporation
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Dec. 14, 2015, 2:16 p.m.</div>
<pre class="content">
On Tue, Dec 08, 2015 at 05:49:12PM +0800, Yong Wu wrote:
<span class="quote">&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +				   struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	if (!data) {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * The DMA core will run earlier than this probe, and it will</span>
<span class="quote">&gt; +		 * create a default iommu domain for each a iommu device.</span>
<span class="quote">&gt; +		 * But here there is only one domain called the m4u domain</span>
<span class="quote">&gt; +		 * which all the multimedia HW share.</span>
<span class="quote">&gt; +		 * The default domain isn&#39;t needed here.</span>
<span class="quote">&gt; +		 */</span>

The iommu core creates one domain per iommu-group. In your case this
means one default domain per iommu in the system.
<span class="quote">
&gt; +		iommu_domain_free(domain);</span>

This function is not supposed to free the domain passed to it.
<span class="quote">
&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>

[...]
<span class="quote">
&gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt; +}</span>

This looks much better than before, thanks.

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=13291">Matthias Brugger</a> - Dec. 14, 2015, 6:19 p.m.</div>
<pre class="content">
On 08/12/15 10:49, Yong Wu wrote:
<span class="quote">&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; Unit).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;   drivers/iommu/Kconfig     |  15 +</span>
<span class="quote">&gt;   drivers/iommu/Makefile    |   1 +</span>
<span class="quote">&gt;   drivers/iommu/mtk_iommu.c | 752 ++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;   3 files changed, 768 insertions(+)</span>
<span class="quote">&gt;   create mode 100644 drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; index b9094e9..aab942f 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/Kconfig</span>
<span class="quote">&gt; +++ b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; @@ -393,4 +393,19 @@ config S390_IOMMU</span>
<span class="quote">&gt;   	help</span>
<span class="quote">&gt;   	  Support for the IOMMU API for s390 PCI devices.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +config MTK_IOMMU</span>
<span class="quote">&gt; +	bool &quot;MTK IOMMU Support&quot;</span>
<span class="quote">&gt; +	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="quote">&gt; +	select IOMMU_API</span>
<span class="quote">&gt; +	select IOMMU_DMA</span>
<span class="quote">&gt; +	select IOMMU_IO_PGTABLE_ARMV7S</span>
<span class="quote">&gt; +	select MEMORY</span>
<span class="quote">&gt; +	select MTK_SMI</span>
<span class="quote">&gt; +	help</span>
<span class="quote">&gt; +	  Support for the M4U on certain Mediatek SOCs. M4U is MultiMedia</span>
<span class="quote">&gt; +	  Memory Management Unit. This option enables remapping of DMA memory</span>
<span class="quote">&gt; +	  accesses for the multimedia subsystem.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	  If unsure, say N here.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   endif # IOMMU_SUPPORT</span>
<span class="quote">&gt; diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="quote">&gt; index 68faca02..02887bc 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/Makefile</span>
<span class="quote">&gt; +++ b/drivers/iommu/Makefile</span>
<span class="quote">&gt; @@ -22,6 +22,7 @@ obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o</span>
<span class="quote">&gt;   obj-$(CONFIG_TEGRA_IOMMU_GART) += tegra-gart.o</span>
<span class="quote">&gt;   obj-$(CONFIG_TEGRA_IOMMU_SMMU) += tegra-smmu.o</span>
<span class="quote">&gt;   obj-$(CONFIG_EXYNOS_IOMMU) += exynos-iommu.o</span>
<span class="quote">&gt; +obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
<span class="quote">&gt;   obj-$(CONFIG_SHMOBILE_IOMMU) += shmobile-iommu.o</span>
<span class="quote">&gt;   obj-$(CONFIG_SHMOBILE_IPMMU) += shmobile-ipmmu.o</span>
<span class="quote">&gt;   obj-$(CONFIG_FSL_PAMU) += fsl_pamu.o fsl_pamu_domain.o</span>
<span class="quote">&gt; diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..6a21e70</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; @@ -0,0 +1,752 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="quote">&gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is distributed in the hope that it will be useful,</span>
<span class="quote">&gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="quote">&gt; + * GNU General Public License for more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#include &lt;linux/clk.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/component.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/dma-iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iopoll.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/list.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_platform.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; +#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="quote">&gt; +#include &lt;dt-bindings/memory/mt8173-larb-port.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &quot;io-pgtable.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_INVALIDATE			0x020</span>
<span class="quote">&gt; +#define F_ALL_INVLD				0x2</span>
<span class="quote">&gt; +#define F_MMU_INV_RANGE				0x1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_INVLD_START_A			0x024</span>
<span class="quote">&gt; +#define REG_MMU_INVLD_END_A			0x028</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_INV_SEL				0x038</span>
<span class="quote">&gt; +#define F_INVLD_EN0				BIT(0)</span>
<span class="quote">&gt; +#define F_INVLD_EN1				BIT(1)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_STANDARD_AXI_MODE		0x048</span>
<span class="quote">&gt; +#define REG_MMU_DCM_DIS				0x050</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_CTRL_REG			0x110</span>
<span class="quote">&gt; +#define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="quote">&gt; +#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="quote">&gt; +#define F_COHERENCE_EN				BIT(8)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_IVRP_PADDR			0x114</span>
<span class="quote">&gt; +#define F_MMU_IVRP_PA_SET(pa)			((pa) &gt;&gt; 1)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_INT_CONTROL0			0x120</span>
<span class="quote">&gt; +#define F_L2_MULIT_HIT_EN			BIT(0)</span>
<span class="quote">&gt; +#define F_TABLE_WALK_FAULT_INT_EN		BIT(1)</span>
<span class="quote">&gt; +#define F_PREETCH_FIFO_OVERFLOW_INT_EN		BIT(2)</span>
<span class="quote">&gt; +#define F_MISS_FIFO_OVERFLOW_INT_EN		BIT(3)</span>
<span class="quote">&gt; +#define F_PREFETCH_FIFO_ERR_INT_EN		BIT(5)</span>
<span class="quote">&gt; +#define F_MISS_FIFO_ERR_INT_EN			BIT(6)</span>
<span class="quote">&gt; +#define F_INT_CLR_BIT				BIT(12)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_INT_MAIN_CONTROL		0x124</span>
<span class="quote">&gt; +#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="quote">&gt; +#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="quote">&gt; +#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="quote">&gt; +#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="quote">&gt; +#define F_INT_TLB_MISS_FAULT			BIT(4)</span>
<span class="quote">&gt; +#define F_INT_MISS_TRANSATION_FIFO_FAULT	BIT(5)</span>
<span class="quote">&gt; +#define F_INT_PRETETCH_TRANSATION_FIFO_FAULT	BIT(6)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_CPE_DONE			0x12C</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_FAULT_ST1			0x134</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_FAULT_VA			0x13c</span>
<span class="quote">&gt; +#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="quote">&gt; +#define F_MMU_FAULT_VA_WRITE_BIT		BIT(1)</span>
<span class="quote">&gt; +#define F_MMU_FAULT_VA_LAYER_BIT		BIT(0)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define REG_MMU_INVLD_PA			0x140</span>
<span class="quote">&gt; +#define REG_MMU_INT_ID				0x150</span>
<span class="quote">&gt; +#define F_MMU0_INT_ID_LARB_ID(a)		(((a) &gt;&gt; 7) &amp; 0x7)</span>
<span class="quote">&gt; +#define F_MMU0_INT_ID_PORT_ID(a)		(((a) &gt;&gt; 2) &amp; 0x1f)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="quote">&gt; +#define MTK_IOMMU_LARB_MAX_NR			8</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct mtk_iommu_suspend_reg {</span>
<span class="quote">&gt; +	u32				standard_axi_mode;</span>
<span class="quote">&gt; +	u32				dcm_dis;</span>
<span class="quote">&gt; +	u32				ctrl_reg;</span>
<span class="quote">&gt; +	u32				int_control0;</span>
<span class="quote">&gt; +	u32				int_main_control;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct mtk_iommu_client_priv {</span>
<span class="quote">&gt; +	struct list_head		client;</span>
<span class="quote">&gt; +	unsigned int			mtk_m4u_id;</span>
<span class="quote">&gt; +	struct device			*m4udev;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct mtk_iommu_domain {</span>
<span class="quote">&gt; +	spinlock_t			pgtlock; /* lock for page table */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	struct io_pgtable_cfg		cfg;</span>
<span class="quote">&gt; +	struct io_pgtable_ops		*iop;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	struct iommu_domain		domain;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct mtk_iommu_data {</span>
<span class="quote">&gt; +	void __iomem			*base;</span>
<span class="quote">&gt; +	int				irq;</span>
<span class="quote">&gt; +	struct device			*dev;</span>
<span class="quote">&gt; +	struct device			*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="quote">&gt; +	struct clk			*bclk;</span>
<span class="quote">&gt; +	phys_addr_t			protect_base; /* protect memory base */</span>
<span class="quote">&gt; +	int				larb_nr;      /* local arbiter number */</span>
<span class="quote">&gt; +	struct mtk_iommu_suspend_reg	reg;</span>
<span class="quote">&gt; +	struct mtk_iommu_domain		*m4u_dom;</span>
<span class="quote">&gt; +	struct iommu_group		*m4u_group;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_ops mtk_iommu_ops;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return container_of(dom, struct mtk_iommu_domain, domain);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = cookie;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +	writel_relaxed(F_ALL_INVLD, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +	wmb(); /* Make sure the tlb flush all done */</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_add_flush_nosync(unsigned long iova, size_t size,</span>
<span class="quote">&gt; +					   size_t granule, bool leaf,</span>
<span class="quote">&gt; +					   void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = cookie;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(iova, data-&gt;base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; +	writel_relaxed(iova + size - 1, data-&gt;base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; +	writel_relaxed(F_MMU_INV_RANGE, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_sync(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = cookie;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +	u32 tmp;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = readl_poll_timeout_atomic(data-&gt;base + REG_MMU_CPE_DONE, tmp,</span>
<span class="quote">&gt; +					tmp != 0, 10, 100000);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_warn(data-&gt;dev,</span>
<span class="quote">&gt; +			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="quote">&gt; +		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	/* Clear the CPE status */</span>
<span class="quote">&gt; +	writel_relaxed(0, data-&gt;base + REG_MMU_CPE_DONE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="quote">&gt; +	.tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="quote">&gt; +	.tlb_add_flush = mtk_iommu_tlb_add_flush_nosync,</span>
<span class="quote">&gt; +	.tlb_sync = mtk_iommu_tlb_sync,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_id;</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; +	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="quote">&gt; +	unsigned int fault_larb, fault_port;</span>
<span class="quote">&gt; +	bool layer, write;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Read error info from registers */</span>
<span class="quote">&gt; +	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST1);</span>
<span class="quote">&gt; +	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="quote">&gt; +	layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="quote">&gt; +	write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="quote">&gt; +	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="quote">&gt; +	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="quote">&gt; +	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="quote">&gt; +	fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="quote">&gt; +	fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (report_iommu_fault(&amp;dom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="quote">&gt; +			       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {</span>
<span class="quote">&gt; +		dev_err_ratelimited(</span>
<span class="quote">&gt; +			data-&gt;dev,</span>
<span class="quote">&gt; +			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="quote">&gt; +			int_state, fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="quote">&gt; +			layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Interrupt clear */</span>
<span class="quote">&gt; +	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +	regval |= F_INT_CLR_BIT;</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mtk_iommu_tlb_flush_all(data);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return IRQ_HANDLED;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_config(struct mtk_iommu_data *data,</span>
<span class="quote">&gt; +			     struct device *dev, bool enable)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; +		mtk_smi_config_port(</span>
<span class="quote">&gt; +			data-&gt;larbdev[MTK_M4U_TO_LARB(cur-&gt;mtk_m4u_id)],</span>
<span class="quote">&gt; +			MTK_M4U_TO_PORT(cur-&gt;mtk_m4u_id), enable);</span>

Use an extra variable for MTK_M4U_TO_LARB(cur-&gt;mtk-m4u_id), this makes 
the code easier to read.

Regards,
Matthias
<span class="quote">
&gt; +	}</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_domain_finalise(struct mtk_iommu_data *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dom-&gt;cfg = (struct io_pgtable_cfg) {</span>
<span class="quote">&gt; +		.quirks = IO_PGTABLE_QUIRK_ARM_NS |</span>
<span class="quote">&gt; +			IO_PGTABLE_QUIRK_NO_PERMS |</span>
<span class="quote">&gt; +			IO_PGTABLE_QUIRK_TLBI_ON_MAP,</span>
<span class="quote">&gt; +		.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,</span>
<span class="quote">&gt; +		.ias = 32,</span>
<span class="quote">&gt; +		.oas = 32,</span>
<span class="quote">&gt; +		.tlb = &amp;mtk_iommu_gather_ops,</span>
<span class="quote">&gt; +		.iommu_dev = data-&gt;dev,</span>
<span class="quote">&gt; +	};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dom-&gt;iop = alloc_io_pgtable_ops(ARM_V7S, &amp;dom-&gt;cfg, data);</span>
<span class="quote">&gt; +	if (!dom-&gt;iop) {</span>
<span class="quote">&gt; +		dev_err(data-&gt;dev, &quot;Failed to alloc io pgtable\n&quot;);</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Update our support page sizes bitmap */</span>
<span class="quote">&gt; +	mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="quote">&gt; +		       data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="quote">&gt; +		return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dom = kzalloc(sizeof(*dom), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!dom)</span>
<span class="quote">&gt; +		return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (type == IOMMU_DOMAIN_DMA &amp;&amp; iommu_get_dma_cookie(&amp;dom-&gt;domain)) {</span>
<span class="quote">&gt; +		kfree(dom);</span>
<span class="quote">&gt; +		return NULL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dom-&gt;domain.geometry.aperture_start = 0;</span>
<span class="quote">&gt; +	dom-&gt;domain.geometry.aperture_end = DMA_BIT_MASK(32);</span>
<span class="quote">&gt; +	dom-&gt;domain.geometry.force_aperture = true;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return &amp;dom-&gt;domain;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (domain-&gt;type == IOMMU_DOMAIN_DMA)</span>
<span class="quote">&gt; +		iommu_put_dma_cookie(domain);</span>
<span class="quote">&gt; +	kfree(to_mtk_domain(domain));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +				   struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	if (!data) {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * The DMA core will run earlier than this probe, and it will</span>
<span class="quote">&gt; +		 * create a default iommu domain for each a iommu device.</span>
<span class="quote">&gt; +		 * But here there is only one domain called the m4u domain</span>
<span class="quote">&gt; +		 * which all the multimedia HW share.</span>
<span class="quote">&gt; +		 * The default domain isn&#39;t needed here.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		iommu_domain_free(domain);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		/* Return 0 for DMA to update dev-&gt;archdata.dma_ops */</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +	} else if (!data-&gt;m4u_dom) {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * While a device is added into a iommu group, the iommu core</span>
<span class="quote">&gt; +		 * will create a default domain for each a iommu group.</span>
<span class="quote">&gt; +		 * This default domain is reserved as the m4u domain and is</span>
<span class="quote">&gt; +		 * initiated here.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		data-&gt;m4u_dom = dom;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (domain-&gt;type == IOMMU_DOMAIN_DMA) {</span>
<span class="quote">&gt; +			ret = iommu_dma_init_domain(domain, 0,</span>
<span class="quote">&gt; +						    DMA_BIT_MASK(32));</span>
<span class="quote">&gt; +			if (ret)</span>
<span class="quote">&gt; +				goto err_uninit_dom;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		ret = mtk_iommu_domain_finalise(data);</span>
<span class="quote">&gt; +		if (ret)</span>
<span class="quote">&gt; +			goto err_uninit_dom;</span>
<span class="quote">&gt; +	} else if (data-&gt;m4u_dom != dom) {</span>
<span class="quote">&gt; +		/* All the client devices should be in the same m4u domain */</span>
<span class="quote">&gt; +		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="quote">&gt; +		return -EPERM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mtk_iommu_config(data, dev, true);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_uninit_dom:</span>
<span class="quote">&gt; +	data-&gt;m4u_dom = NULL;</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; +				    struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	if (data)</span>
<span class="quote">&gt; +		mtk_iommu_config(data, dev, false);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt; +			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +	ret = dom-&gt;iop-&gt;map(dom-&gt;iop, iova, paddr, size, prot);</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="quote">&gt; +			      unsigned long iova, size_t size)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	size_t unmapsz;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +	unmapsz = dom-&gt;iop-&gt;unmap(dom-&gt;iop, iova, size);</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return unmapsz;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="quote">&gt; +					  dma_addr_t iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; +	unsigned long flags;</span>
<span class="quote">&gt; +	phys_addr_t pa;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +	pa = dom-&gt;iop-&gt;iova_to_phys(dom-&gt;iop, iova);</span>
<span class="quote">&gt; +	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return pa;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	if (!head)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; +		list_del(&amp;cur-&gt;client);</span>
<span class="quote">&gt; +		kfree(cur);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	kfree(head);</span>
<span class="quote">&gt; +	dev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	iommu_group_remove_device(dev);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_of_xlate(struct device *dev, struct of_phandle_args *args)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="quote">&gt; +	struct platform_device *m4updev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (args-&gt;args_count != 1) {</span>
<span class="quote">&gt; +		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="quote">&gt; +			args-&gt;args_count);</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!dev-&gt;archdata.iommu) {</span>
<span class="quote">&gt; +		/* Get the m4u device */</span>
<span class="quote">&gt; +		m4updev = of_find_device_by_node(args-&gt;np);</span>
<span class="quote">&gt; +		of_node_put(args-&gt;np);</span>
<span class="quote">&gt; +		if (WARN_ON(!m4updev))</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="quote">&gt; +		if (!head)</span>
<span class="quote">&gt; +			return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		dev-&gt;archdata.iommu = head;</span>
<span class="quote">&gt; +		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="quote">&gt; +		head-&gt;m4udev = &amp;m4updev-&gt;dev;</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!priv)</span>
<span class="quote">&gt; +		goto err_free_mem;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv-&gt;mtk_m4u_id = args-&gt;args[0];</span>
<span class="quote">&gt; +	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_free_mem:</span>
<span class="quote">&gt; +	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="quote">&gt; +		kfree(priv);</span>
<span class="quote">&gt; +	kfree(head);</span>
<span class="quote">&gt; +	dev-&gt;archdata.iommu = NULL;</span>
<span class="quote">&gt; +	return -ENOMEM;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct iommu_ops mtk_iommu_ops = {</span>
<span class="quote">&gt; +	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="quote">&gt; +	.domain_free	= mtk_iommu_domain_free,</span>
<span class="quote">&gt; +	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="quote">&gt; +	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="quote">&gt; +	.map		= mtk_iommu_map,</span>
<span class="quote">&gt; +	.unmap		= mtk_iommu_unmap,</span>
<span class="quote">&gt; +	.map_sg		= default_iommu_map_sg,</span>
<span class="quote">&gt; +	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="quote">&gt; +	.add_device	= mtk_iommu_add_device,</span>
<span class="quote">&gt; +	.remove_device	= mtk_iommu_remove_device,</span>
<span class="quote">&gt; +	.device_group	= mtk_iommu_device_group,</span>
<span class="quote">&gt; +	.of_xlate	= mtk_iommu_of_xlate,</span>
<span class="quote">&gt; +	.pgsize_bitmap	= SZ_4K | SZ_64K | SZ_1M | SZ_16M,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	u32 regval;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		dev_err(data-&gt;dev, &quot;Failed to enable iommu bclk(%d)\n&quot;, ret);</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; +		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="quote">&gt; +		F_COHERENCE_EN;</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_L2_MULIT_HIT_EN |</span>
<span class="quote">&gt; +		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="quote">&gt; +		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; +		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="quote">&gt; +		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="quote">&gt; +		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="quote">&gt; +		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="quote">&gt; +		F_INT_INVALID_PA_FAULT |</span>
<span class="quote">&gt; +		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="quote">&gt; +		F_INT_TLB_MISS_FAULT |</span>
<span class="quote">&gt; +		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="quote">&gt; +		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	regval = F_MMU_IVRP_PA_SET(data-&gt;protect_base);</span>
<span class="quote">&gt; +	writel_relaxed(regval, data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(0, data-&gt;base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +	writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; +			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="quote">&gt; +		writel_relaxed(0, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; +		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int compare_of(struct device *dev, void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return dev-&gt;of_node == data;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_bind(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	void *protect;</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; +	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!protect)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	data-&gt;protect_base = ALIGN(virt_to_phys(protect), MTK_PROTECT_PA_ALIGN);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = component_bind_all(dev, NULL);</span>
<span class="quote">&gt; +	if (ret)</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = mtk_iommu_hw_init(data);</span>
<span class="quote">&gt; +	if (ret) {</span>
<span class="quote">&gt; +		component_unbind_all(dev, NULL);</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="quote">&gt; +		bus_set_iommu(&amp;platform_bus_type, &amp;mtk_iommu_ops);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_unbind(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (iommu_present(&amp;platform_bus_type))</span>
<span class="quote">&gt; +		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	component_unbind_all(dev, NULL);</span>
<span class="quote">&gt; +	free_io_pgtable_ops(data-&gt;m4u_dom-&gt;iop);</span>
<span class="quote">&gt; +	clk_disable_unprepare(data-&gt;bclk);</span>
<span class="quote">&gt; +	devm_free_irq(dev, data-&gt;irq, data);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct component_master_ops mtk_iommu_com_ops = {</span>
<span class="quote">&gt; +	.bind		= mtk_iommu_bind,</span>
<span class="quote">&gt; +	.unbind		= mtk_iommu_unbind,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data   *data;</span>
<span class="quote">&gt; +	struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +	struct resource         *res;</span>
<span class="quote">&gt; +	struct component_match  *match = NULL;</span>
<span class="quote">&gt; +	int                     i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!data)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	data-&gt;dev = dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="quote">&gt; +	data-&gt;base = devm_ioremap_resource(dev, res);</span>
<span class="quote">&gt; +	if (IS_ERR(data-&gt;base))</span>
<span class="quote">&gt; +		return PTR_ERR(data-&gt;base);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="quote">&gt; +	if (data-&gt;irq &lt; 0)</span>
<span class="quote">&gt; +		return data-&gt;irq;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="quote">&gt; +	if (IS_ERR(data-&gt;bclk))</span>
<span class="quote">&gt; +		return PTR_ERR(data-&gt;bclk);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	data-&gt;larb_nr = of_count_phandle_with_args(</span>
<span class="quote">&gt; +					dev-&gt;of_node, &quot;mediatek,larbs&quot;, NULL);</span>
<span class="quote">&gt; +	if (data-&gt;larb_nr &lt; 0)</span>
<span class="quote">&gt; +		return data-&gt;larb_nr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; data-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; +		struct device_node *larbnode;</span>
<span class="quote">&gt; +		struct platform_device *plarbdev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="quote">&gt; +		if (!larbnode)</span>
<span class="quote">&gt; +			return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (!of_device_is_available(larbnode))</span>
<span class="quote">&gt; +			continue;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; +		of_node_put(larbnode);</span>
<span class="quote">&gt; +		if (!plarbdev)</span>
<span class="quote">&gt; +			return -EPROBE_DEFER;</span>
<span class="quote">&gt; +		data-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		component_match_add(dev, &amp;match, compare_of, larbnode);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev_set_drvdata(dev, data);</span>
<span class="quote">&gt; +	return component_master_add_with_match(dev, &amp;mtk_iommu_com_ops, match);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	component_master_del(&amp;pdev-&gt;dev, &amp;mtk_iommu_com_ops);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_suspend(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="quote">&gt; +					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +	reg-&gt;int_main_control = readl_relaxed(base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; +	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="quote">&gt; +		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="quote">&gt; +		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; +	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base),</span>
<span class="quote">&gt; +		       base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="quote">&gt; +	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="quote">&gt; +	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="quote">&gt; +	{}</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct platform_driver mtk_iommu_driver = {</span>
<span class="quote">&gt; +	.probe	= mtk_iommu_probe,</span>
<span class="quote">&gt; +	.remove	= mtk_iommu_remove,</span>
<span class="quote">&gt; +	.driver	= {</span>
<span class="quote">&gt; +		.name = &quot;mtk-iommu&quot;,</span>
<span class="quote">&gt; +		.of_match_table = mtk_iommu_of_ids,</span>
<span class="quote">&gt; +		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init mtk_iommu_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +subsys_initcall(mtk_iommu_init);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct platform_device *pdev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="quote">&gt; +	if (IS_ERR(pdev))</span>
<span class="quote">&gt; +		return PTR_ERR(pdev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	of_iommu_set_ops(np, &amp;mtk_iommu_ops);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt;</span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Dec. 15, 2015, 2:40 a.m.</div>
<pre class="content">
On Mon, 2015-12-14 at 19:19 +0100, Matthias Brugger wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; On 08/12/15 10:49, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; &gt; Unit).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
[...]
<span class="quote">&gt; &gt; +static void mtk_iommu_config(struct mtk_iommu_data *data,</span>
<span class="quote">&gt; &gt; +			     struct device *dev, bool enable)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	head = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="quote">&gt; &gt; +		mtk_smi_config_port(</span>
<span class="quote">&gt; &gt; +			data-&gt;larbdev[MTK_M4U_TO_LARB(cur-&gt;mtk_m4u_id)],</span>
<span class="quote">&gt; &gt; +			MTK_M4U_TO_PORT(cur-&gt;mtk_m4u_id), enable);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Use an extra variable for MTK_M4U_TO_LARB(cur-&gt;mtk-m4u_id), this makes </span>
<span class="quote">&gt; the code easier to read.</span>

OK. Thanks.
I will fix it in next version.
<span class="quote">
&gt; </span>
<span class="quote">&gt; Regards,</span>
<span class="quote">&gt; Matthias</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
[...]


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Dec. 15, 2015, 3:28 a.m.</div>
<pre class="content">
On Mon, 2015-12-14 at 15:16 +0100, Joerg Roedel wrote:
<span class="quote">&gt; On Tue, Dec 08, 2015 at 05:49:12PM +0800, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt; +				   struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt; +	int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!priv)</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt; +	if (!data) {</span>
<span class="quote">&gt; &gt; +		/*</span>
<span class="quote">&gt; &gt; +		 * The DMA core will run earlier than this probe, and it will</span>
<span class="quote">&gt; &gt; +		 * create a default iommu domain for each a iommu device.</span>
<span class="quote">&gt; &gt; +		 * But here there is only one domain called the m4u domain</span>
<span class="quote">&gt; &gt; +		 * which all the multimedia HW share.</span>
<span class="quote">&gt; &gt; +		 * The default domain isn&#39;t needed here.</span>
<span class="quote">&gt; &gt; +		 */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The iommu core creates one domain per iommu-group. In your case this</span>
<span class="quote">&gt; means one default domain per iommu in the system.</span>

Yes. The iommu core will create one domain per iommu-group.
see the next &quot;if&quot; here.

But the domain here is created by the current DMA64. It&#39;s from this
function do_iommu_attach which will be called too early and will help
create a default domain for each a iommu device.(my codebase is
v4.4-rc1).


//=====the next &quot;if&quot;===========
} else if (!data-&gt;m4u_dom) {
	/*
	 * While a device is added into a iommu group, the iommu core
	 * will create a default domain for each a iommu group.
	 * This default domain is reserved as the m4u domain and is
	 * initiated here.
	 */
	data-&gt;m4u_dom = dom;
	if (domain-&gt;type == IOMMU_DOMAIN_DMA) {
		ret = iommu_dma_init_domain(domain, 0,
					    DMA_BIT_MASK(32));
		if (ret)
			goto err_uninit_dom;
	}

	ret = mtk_iommu_domain_finalise(data);
	if (ret)
		goto err_uninit_dom;
} 
//======================
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +		iommu_domain_free(domain);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This function is not supposed to free the domain passed to it.</span>

As above this domain is created in the do_iommu_attach which will help
create a default domain for each a iommu device.
We don&#39;t need this default domain!

If we don&#39;t free it here, there will be a memory leak.

From Robin&#39;s comment, He will improve the sequence of the
__iommu_setup_dma_ops in the future.

/*
 * TODO: Right now __iommu_setup_dma_ops() gets called too early to do
 * everything it needs to - the device is only partially created and the
 * IOMMU driver hasn&#39;t seen it yet, so it can&#39;t have a group. Thus we
 * need this delayed attachment dance. Once IOMMU probe ordering is
sorted
 * to move the arch_setup_dma_ops() call later, all the notifier bits
below
 * become unnecessary, and will go away.
 */

/*
 * Best case: The device is either part of a group which was
 * already attached to a domain in a previous call, or it&#39;s
 * been put in a default DMA domain by the IOMMU core.
 */

   But there is no this patch currently, so I add iommu_domain_free
here.
 
   &quot;free the domain&quot; here looks really not good. Then I delete the
iommu_domain_free here(allow this memory leak right now), is it ok?
(It will also works after Robin&#39;s change in the future.)
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; &gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt; &gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt; &gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +	return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +	if (!priv)</span>
<span class="quote">&gt; &gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt; &gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt; &gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt; &gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This looks much better than before, thanks.</span>

Thanks.
<span class="quote">
&gt; </span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Dec. 15, 2015, 12:37 p.m.</div>
<pre class="content">
On 15/12/15 03:28, Yong Wu wrote:
<span class="quote">&gt; On Mon, 2015-12-14 at 15:16 +0100, Joerg Roedel wrote:</span>
<span class="quote">&gt;&gt; On Tue, Dec 08, 2015 at 05:49:12PM +0800, Yong Wu wrote:</span>
<span class="quote">&gt;&gt;&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt;&gt;&gt; +				   struct device *dev)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt;&gt;&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt;&gt;&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt;&gt;&gt; +	int ret;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	if (!priv)</span>
<span class="quote">&gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt;&gt;&gt; +	if (!data) {</span>
<span class="quote">&gt;&gt;&gt; +		/*</span>
<span class="quote">&gt;&gt;&gt; +		 * The DMA core will run earlier than this probe, and it will</span>
<span class="quote">&gt;&gt;&gt; +		 * create a default iommu domain for each a iommu device.</span>
<span class="quote">&gt;&gt;&gt; +		 * But here there is only one domain called the m4u domain</span>
<span class="quote">&gt;&gt;&gt; +		 * which all the multimedia HW share.</span>
<span class="quote">&gt;&gt;&gt; +		 * The default domain isn&#39;t needed here.</span>
<span class="quote">&gt;&gt;&gt; +		 */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The iommu core creates one domain per iommu-group. In your case this</span>
<span class="quote">&gt;&gt; means one default domain per iommu in the system.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yes. The iommu core will create one domain per iommu-group.</span>
<span class="quote">&gt; see the next &quot;if&quot; here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; But the domain here is created by the current DMA64. It&#39;s from this</span>
<span class="quote">&gt; function do_iommu_attach which will be called too early and will help</span>
<span class="quote">&gt; create a default domain for each a iommu device.(my codebase is</span>
<span class="quote">&gt; v4.4-rc1).</span>

I still don&#39;t really understand the problem here. The M4U device is 
created early in mtk_iommu_init_fn, so it should be probed and ready to 
go long before anything else. Indeed, for your mtk_iommu_device_group() 
callback to work then everything must already be happening in the right 
order - add_device will only call iommu_group_get_for_dev() if of_xlate 
has populated dev-&gt;archdata.iommu, and of_xlate will only do that if the 
M4U was up and running before the client device started probing. 
Furthermore, if mtk_iommu_device_group() *does* work, then the IOMMU 
core will go ahead and allocate the default domain there and then, which 
the arch code should find and use later.

The potential issue I *do* see, looking more closely, is that 
iommu_group_get_for_dev() is setting group-&gt;domain but not calling the 
attach_dev callback, which looks wrong...
<span class="quote">
&gt;</span>
<span class="quote">&gt; //=====the next &quot;if&quot;===========</span>
<span class="quote">&gt; } else if (!data-&gt;m4u_dom) {</span>
<span class="quote">&gt; 	/*</span>
<span class="quote">&gt; 	 * While a device is added into a iommu group, the iommu core</span>
<span class="quote">&gt; 	 * will create a default domain for each a iommu group.</span>
<span class="quote">&gt; 	 * This default domain is reserved as the m4u domain and is</span>
<span class="quote">&gt; 	 * initiated here.</span>
<span class="quote">&gt; 	 */</span>
<span class="quote">&gt; 	data-&gt;m4u_dom = dom;</span>
<span class="quote">&gt; 	if (domain-&gt;type == IOMMU_DOMAIN_DMA) {</span>
<span class="quote">&gt; 		ret = iommu_dma_init_domain(domain, 0,</span>
<span class="quote">&gt; 					    DMA_BIT_MASK(32));</span>
<span class="quote">&gt; 		if (ret)</span>
<span class="quote">&gt; 			goto err_uninit_dom;</span>
<span class="quote">&gt; 	}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	ret = mtk_iommu_domain_finalise(data);</span>
<span class="quote">&gt; 	if (ret)</span>
<span class="quote">&gt; 		goto err_uninit_dom;</span>
<span class="quote">&gt; }</span>
<span class="quote">&gt; //======================</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +		iommu_domain_free(domain);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This function is not supposed to free the domain passed to it.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; As above this domain is created in the do_iommu_attach which will help</span>
<span class="quote">&gt; create a default domain for each a iommu device.</span>
<span class="quote">&gt; We don&#39;t need this default domain!</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If we don&#39;t free it here, there will be a memory leak.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  From Robin&#39;s comment, He will improve the sequence of the</span>
<span class="quote">&gt; __iommu_setup_dma_ops in the future.</span>

That already happened. The final version of the arm64 code which was 
merged makes sure that the IOMMU driver always sees the callbacks in the 
desired of_xlate -&gt; add_device -&gt; attach_dev order. The whole point of 
the comment below is that the driver itself *doesn&#39;t* have to care about 
the awkward way in which that is currently achieved.
<span class="quote">
&gt; /*</span>
<span class="quote">&gt;   * TODO: Right now __iommu_setup_dma_ops() gets called too early to do</span>
<span class="quote">&gt;   * everything it needs to - the device is only partially created and the</span>
<span class="quote">&gt;   * IOMMU driver hasn&#39;t seen it yet, so it can&#39;t have a group. Thus we</span>
<span class="quote">&gt;   * need this delayed attachment dance. Once IOMMU probe ordering is</span>
<span class="quote">&gt; sorted</span>
<span class="quote">&gt;   * to move the arch_setup_dma_ops() call later, all the notifier bits</span>
<span class="quote">&gt; below</span>
<span class="quote">&gt;   * become unnecessary, and will go away.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; /*</span>
<span class="quote">&gt;   * Best case: The device is either part of a group which was</span>
<span class="quote">&gt;   * already attached to a domain in a previous call, or it&#39;s</span>
<span class="quote">&gt;   * been put in a default DMA domain by the IOMMU core.</span>
<span class="quote">&gt;   */</span>

That was before Joerg made the device_group changes which enabled proper 
default domains for platform devices - with those, we should be now be 
hitting the &quot;best case&quot; behaviour every time. In fact I think the &quot;fake 
default domain&quot; workaround shouldn&#39;t be needed at all any more, so I 
will add removing it to my giant list of things to do.
<span class="quote">
&gt;     But there is no this patch currently, so I add iommu_domain_free</span>
<span class="quote">&gt; here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;     &quot;free the domain&quot; here looks really not good. Then I delete the</span>
<span class="quote">&gt; iommu_domain_free here(allow this memory leak right now), is it ok?</span>
<span class="quote">&gt; (It will also works after Robin&#39;s change in the future.)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt;&gt;&gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt;&gt;&gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt;&gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt;&gt;&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt;&gt;&gt; +	if (!priv)</span>
<span class="quote">&gt;&gt;&gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt;&gt;&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt;&gt;&gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt;&gt;&gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt;&gt;&gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt;&gt;&gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt;&gt;&gt; +	}</span>
<span class="quote">&gt;&gt;&gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt;&gt;&gt; +}</span>

As long as this works as expected, then AFAICS you shouldn&#39;t have to 
have *any* special-case behaviour or tracking of domains at all.

Robin.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Dec. 16, 2015, 5:59 a.m.</div>
<pre class="content">
On Tue, 2015-12-15 at 12:37 +0000, Robin Murphy wrote:
<span class="quote">&gt; On 15/12/15 03:28, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; On Mon, 2015-12-14 at 15:16 +0100, Joerg Roedel wrote:</span>
<span class="quote">&gt; &gt;&gt; On Tue, Dec 08, 2015 at 05:49:12PM +0800, Yong Wu wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt;&gt;&gt; +				   struct device *dev)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	int ret;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (!priv)</span>
<span class="quote">&gt; &gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (!data) {</span>
<span class="quote">&gt; &gt;&gt;&gt; +		/*</span>
<span class="quote">&gt; &gt;&gt;&gt; +		 * The DMA core will run earlier than this probe, and it will</span>
<span class="quote">&gt; &gt;&gt;&gt; +		 * create a default iommu domain for each a iommu device.</span>
<span class="quote">&gt; &gt;&gt;&gt; +		 * But here there is only one domain called the m4u domain</span>
<span class="quote">&gt; &gt;&gt;&gt; +		 * which all the multimedia HW share.</span>
<span class="quote">&gt; &gt;&gt;&gt; +		 * The default domain isn&#39;t needed here.</span>
<span class="quote">&gt; &gt;&gt;&gt; +		 */</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; The iommu core creates one domain per iommu-group. In your case this</span>
<span class="quote">&gt; &gt;&gt; means one default domain per iommu in the system.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Yes. The iommu core will create one domain per iommu-group.</span>
<span class="quote">&gt; &gt; see the next &quot;if&quot; here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; But the domain here is created by the current DMA64. It&#39;s from this</span>
<span class="quote">&gt; &gt; function do_iommu_attach which will be called too early and will help</span>
<span class="quote">&gt; &gt; create a default domain for each a iommu device.(my codebase is</span>
<span class="quote">&gt; &gt; v4.4-rc1).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I still don&#39;t really understand the problem here. The M4U device is </span>
<span class="quote">&gt; created early in mtk_iommu_init_fn, so it should be probed and ready to </span>
<span class="quote">&gt; go long before anything else. Indeed, for your mtk_iommu_device_group() </span>
<span class="quote">&gt; callback to work then everything must already be happening in the right </span>
<span class="quote">&gt; order - add_device will only call iommu_group_get_for_dev() if of_xlate </span>
<span class="quote">&gt; has populated dev-&gt;archdata.iommu, and of_xlate will only do that if the </span>
<span class="quote">&gt; M4U was up and running before the client device started probing. </span>
<span class="quote">&gt; Furthermore, if mtk_iommu_device_group() *does* work, then the IOMMU </span>
<span class="quote">&gt; core will go ahead and allocate the default domain there and then, which </span>
<span class="quote">&gt; the arch code should find and use later.</span>

Thanks. This is very helpful.

I understand your confuse right now and your expectant flow.

Our IOMMU probe was PROBE_DEFER by our SMI device, so currently it probe
was delayed, then have to add the workaround code.

Following your comment above, I test as below. Then the flows seems meet
the &quot;best case&quot; that the iommu core will help create default DMA domain.

@@ -664,19 +636,41 @@ static int mtk_iommu_probe(struct platform_device
*pdev)
for (i = 0; i &lt; larb_nr; i++) {
		struct device_node *larbnode;
		struct platform_device *plarbdev;

		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);
		if (!larbnode)
			return -EINVAL;

                plarbdev = of_find_device_by_node(larbnode);
                of_node_put(larbnode);
-               if (!plarbdev)
-                       return -EPROBE_DEFER;
+               if (!plarbdev) {
+                       plarbdev = of_platform_device_create(larbnode,
NULL, platform_bus_type.dev_root);
+                       if (IS_ERR(pdev))
+                               return -EPROBE_DEFER;
+               }
}

I only add of_platform_device_create for the SMI local arbiter devices
here.

This is a big improvement for us. If this is ok, I will send a quick
next version for this.
<span class="quote">
&gt; </span>
<span class="quote">&gt; The potential issue I *do* see, looking more closely, is that </span>
<span class="quote">&gt; iommu_group_get_for_dev() is setting group-&gt;domain but not calling the </span>
<span class="quote">&gt; attach_dev callback, which looks wrong...</span>

This is the backtrace,

(151216_09:58:05.207)Call trace:
(151216_09:58:05.207)[&lt;ffffffc000400668&gt;] mtk_iommu_attach_device
+0xb8/0x178
(151216_09:58:05.207)[&lt;ffffffc0003fc55c&gt;] iommu_group_add_device
+0x1d8/0x31c
(151216_09:58:05.207)[&lt;ffffffc0003fc988&gt;] iommu_group_get_for_dev
+0x88/0x108
(151216_09:58:05.207)[&lt;ffffffc0003ffcfc&gt;] mtk_iommu_add_device+0x14/0x34
(151216_09:58:05.207)[&lt;ffffffc0003fb280&gt;] add_iommu_group+0x20/0x44
(151216_09:58:05.207)[&lt;ffffffc000406cec&gt;] bus_for_each_dev+0x58/0x98
(151216_09:58:05.207)[&lt;ffffffc0003fbe8c&gt;] bus_set_iommu+0x9c/0xf8

If I change like above, I will delete the workaround code..
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; //=====the next &quot;if&quot;===========</span>
<span class="quote">&gt; &gt; } else if (!data-&gt;m4u_dom) {</span>
<span class="quote">&gt; &gt; 	/*</span>
<span class="quote">&gt; &gt; 	 * While a device is added into a iommu group, the iommu core</span>
<span class="quote">&gt; &gt; 	 * will create a default domain for each a iommu group.</span>
<span class="quote">&gt; &gt; 	 * This default domain is reserved as the m4u domain and is</span>
<span class="quote">&gt; &gt; 	 * initiated here.</span>
<span class="quote">&gt; &gt; 	 */</span>
<span class="quote">&gt; &gt; 	data-&gt;m4u_dom = dom;</span>
<span class="quote">&gt; &gt; 	if (domain-&gt;type == IOMMU_DOMAIN_DMA) {</span>
<span class="quote">&gt; &gt; 		ret = iommu_dma_init_domain(domain, 0,</span>
<span class="quote">&gt; &gt; 					    DMA_BIT_MASK(32));</span>
<span class="quote">&gt; &gt; 		if (ret)</span>
<span class="quote">&gt; &gt; 			goto err_uninit_dom;</span>
<span class="quote">&gt; &gt; 	}</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; 	ret = mtk_iommu_domain_finalise(data);</span>
<span class="quote">&gt; &gt; 	if (ret)</span>
<span class="quote">&gt; &gt; 		goto err_uninit_dom;</span>
<span class="quote">&gt; &gt; }</span>
<span class="quote">&gt; &gt; //======================</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +		iommu_domain_free(domain);</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; This function is not supposed to free the domain passed to it.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; As above this domain is created in the do_iommu_attach which will help</span>
<span class="quote">&gt; &gt; create a default domain for each a iommu device.</span>
<span class="quote">&gt; &gt; We don&#39;t need this default domain!</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; If we don&#39;t free it here, there will be a memory leak.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;  From Robin&#39;s comment, He will improve the sequence of the</span>
<span class="quote">&gt; &gt; __iommu_setup_dma_ops in the future.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That already happened. The final version of the arm64 code which was </span>
<span class="quote">&gt; merged makes sure that the IOMMU driver always sees the callbacks in the </span>
<span class="quote">&gt; desired of_xlate -&gt; add_device -&gt; attach_dev order. The whole point of </span>
<span class="quote">&gt; the comment below is that the driver itself *doesn&#39;t* have to care about </span>
<span class="quote">&gt; the awkward way in which that is currently achieved.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; /*</span>
<span class="quote">&gt; &gt;   * TODO: Right now __iommu_setup_dma_ops() gets called too early to do</span>
<span class="quote">&gt; &gt;   * everything it needs to - the device is only partially created and the</span>
<span class="quote">&gt; &gt;   * IOMMU driver hasn&#39;t seen it yet, so it can&#39;t have a group. Thus we</span>
<span class="quote">&gt; &gt;   * need this delayed attachment dance. Once IOMMU probe ordering is</span>
<span class="quote">&gt; &gt; sorted</span>
<span class="quote">&gt; &gt;   * to move the arch_setup_dma_ops() call later, all the notifier bits</span>
<span class="quote">&gt; &gt; below</span>
<span class="quote">&gt; &gt;   * become unnecessary, and will go away.</span>
<span class="quote">&gt; &gt;   */</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; /*</span>
<span class="quote">&gt; &gt;   * Best case: The device is either part of a group which was</span>
<span class="quote">&gt; &gt;   * already attached to a domain in a previous call, or it&#39;s</span>
<span class="quote">&gt; &gt;   * been put in a default DMA domain by the IOMMU core.</span>
<span class="quote">&gt; &gt;   */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That was before Joerg made the device_group changes which enabled proper </span>
<span class="quote">&gt; default domains for platform devices - with those, we should be now be </span>
<span class="quote">&gt; hitting the &quot;best case&quot; behaviour every time. In fact I think the &quot;fake </span>
<span class="quote">&gt; default domain&quot; workaround shouldn&#39;t be needed at all any more, so I </span>
<span class="quote">&gt; will add removing it to my giant list of things to do.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;     But there is no this patch currently, so I add iommu_domain_free</span>
<span class="quote">&gt; &gt; here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;     &quot;free the domain&quot; here looks really not good. Then I delete the</span>
<span class="quote">&gt; &gt; iommu_domain_free here(allow this memory leak right now), is it ok?</span>
<span class="quote">&gt; &gt; (It will also works after Robin&#39;s change in the future.)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt; &gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt; &gt;&gt;&gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	return 0;</span>
<span class="quote">&gt; &gt;&gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (!priv)</span>
<span class="quote">&gt; &gt;&gt;&gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt; &gt;&gt;&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt; &gt;&gt;&gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt;&gt;&gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt; &gt;&gt;&gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt;&gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt; &gt;&gt;&gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As long as this works as expected, then AFAICS you shouldn&#39;t have to </span>
<span class="quote">&gt; have *any* special-case behaviour or tracking of domains at all.</span>

We only need one iommu-group, one iommu domain here.

What&#39;s the special-case behavior, how can we track of domains.
Could you help give me a example?
<span class="quote">
&gt; </span>
<span class="quote">&gt; Robin.</span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Dec. 16, 2015, 12:48 p.m.</div>
<pre class="content">
On 16/12/15 05:59, Yong Wu wrote:
<span class="quote">&gt; On Tue, 2015-12-15 at 12:37 +0000, Robin Murphy wrote:</span>
<span class="quote">&gt;&gt; On 15/12/15 03:28, Yong Wu wrote:</span>
<span class="quote">&gt;&gt;&gt; On Mon, 2015-12-14 at 15:16 +0100, Joerg Roedel wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Tue, Dec 08, 2015 at 05:49:12PM +0800, Yong Wu wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +				   struct device *dev)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	int ret;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	if (!priv)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	if (!data) {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		/*</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		 * The DMA core will run earlier than this probe, and it will</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		 * create a default iommu domain for each a iommu device.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		 * But here there is only one domain called the m4u domain</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		 * which all the multimedia HW share.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		 * The default domain isn&#39;t needed here.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		 */</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; The iommu core creates one domain per iommu-group. In your case this</span>
<span class="quote">&gt;&gt;&gt;&gt; means one default domain per iommu in the system.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Yes. The iommu core will create one domain per iommu-group.</span>
<span class="quote">&gt;&gt;&gt; see the next &quot;if&quot; here.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; But the domain here is created by the current DMA64. It&#39;s from this</span>
<span class="quote">&gt;&gt;&gt; function do_iommu_attach which will be called too early and will help</span>
<span class="quote">&gt;&gt;&gt; create a default domain for each a iommu device.(my codebase is</span>
<span class="quote">&gt;&gt;&gt; v4.4-rc1).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I still don&#39;t really understand the problem here. The M4U device is</span>
<span class="quote">&gt;&gt; created early in mtk_iommu_init_fn, so it should be probed and ready to</span>
<span class="quote">&gt;&gt; go long before anything else. Indeed, for your mtk_iommu_device_group()</span>
<span class="quote">&gt;&gt; callback to work then everything must already be happening in the right</span>
<span class="quote">&gt;&gt; order - add_device will only call iommu_group_get_for_dev() if of_xlate</span>
<span class="quote">&gt;&gt; has populated dev-&gt;archdata.iommu, and of_xlate will only do that if the</span>
<span class="quote">&gt;&gt; M4U was up and running before the client device started probing.</span>
<span class="quote">&gt;&gt; Furthermore, if mtk_iommu_device_group() *does* work, then the IOMMU</span>
<span class="quote">&gt;&gt; core will go ahead and allocate the default domain there and then, which</span>
<span class="quote">&gt;&gt; the arch code should find and use later.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Thanks. This is very helpful.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I understand your confuse right now and your expectant flow.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Our IOMMU probe was PROBE_DEFER by our SMI device, so currently it probe</span>
<span class="quote">&gt; was delayed, then have to add the workaround code.</span>

Aha, I hadn&#39;t twigged that there was a dependency on another device that 
could delay the M4U probe, thanks for the clarification. That&#39;ll be a 
good case to bear in mind when I eventually get back to the IOMMU probe 
deferral stuff.
<span class="quote">
&gt; Following your comment above, I test as below. Then the flows seems meet</span>
<span class="quote">&gt; the &quot;best case&quot; that the iommu core will help create default DMA domain.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -664,19 +636,41 @@ static int mtk_iommu_probe(struct platform_device</span>
<span class="quote">&gt; *pdev)</span>
<span class="quote">&gt; for (i = 0; i &lt; larb_nr; i++) {</span>
<span class="quote">&gt; 		struct device_node *larbnode;</span>
<span class="quote">&gt; 		struct platform_device *plarbdev;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="quote">&gt; 		if (!larbnode)</span>
<span class="quote">&gt; 			return -EINVAL;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;                  plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt;                  of_node_put(larbnode);</span>
<span class="quote">&gt; -               if (!plarbdev)</span>
<span class="quote">&gt; -                       return -EPROBE_DEFER;</span>
<span class="quote">&gt; +               if (!plarbdev) {</span>
<span class="quote">&gt; +                       plarbdev = of_platform_device_create(larbnode,</span>
<span class="quote">&gt; NULL, platform_bus_type.dev_root);</span>
<span class="quote">&gt; +                       if (IS_ERR(pdev))</span>
<span class="quote">&gt; +                               return -EPROBE_DEFER;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I only add of_platform_device_create for the SMI local arbiter devices</span>
<span class="quote">&gt; here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This is a big improvement for us. If this is ok, I will send a quick</span>
<span class="quote">&gt; next version for this.</span>

In my opinion it&#39;s reasonable - we need the whole &quot;IOMMU&quot; to be ready, 
so if we already have to short-cut the creation of the M4U part it only 
seems fair to do the same for the SMI part. That said, would it work to 
just unconditionally poke the larbs in mtk_iommu_init_fn() before you 
poke the M4U itself? It would be nice to keep all that stuff together in 
the same place.
<span class="quote">
&gt;&gt; The potential issue I *do* see, looking more closely, is that</span>
<span class="quote">&gt;&gt; iommu_group_get_for_dev() is setting group-&gt;domain but not calling the</span>
<span class="quote">&gt;&gt; attach_dev callback, which looks wrong...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This is the backtrace,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; (151216_09:58:05.207)Call trace:</span>
<span class="quote">&gt; (151216_09:58:05.207)[&lt;ffffffc000400668&gt;] mtk_iommu_attach_device</span>
<span class="quote">&gt; +0xb8/0x178</span>
<span class="quote">&gt; (151216_09:58:05.207)[&lt;ffffffc0003fc55c&gt;] iommu_group_add_device</span>
<span class="quote">&gt; +0x1d8/0x31c</span>
<span class="quote">&gt; (151216_09:58:05.207)[&lt;ffffffc0003fc988&gt;] iommu_group_get_for_dev</span>
<span class="quote">&gt; +0x88/0x108</span>
<span class="quote">&gt; (151216_09:58:05.207)[&lt;ffffffc0003ffcfc&gt;] mtk_iommu_add_device+0x14/0x34</span>
<span class="quote">&gt; (151216_09:58:05.207)[&lt;ffffffc0003fb280&gt;] add_iommu_group+0x20/0x44</span>
<span class="quote">&gt; (151216_09:58:05.207)[&lt;ffffffc000406cec&gt;] bus_for_each_dev+0x58/0x98</span>
<span class="quote">&gt; (151216_09:58:05.207)[&lt;ffffffc0003fbe8c&gt;] bus_set_iommu+0x9c/0xf8</span>

Urgh, now I recall that this isn&#39;t even the first time I&#39;ve been 
confused by the attach being hidden elsewhere. Oh well, problem averted!
<span class="quote">
&gt; If I change like above, I will delete the workaround code..</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; //=====the next &quot;if&quot;===========</span>
<span class="quote">&gt;&gt;&gt; } else if (!data-&gt;m4u_dom) {</span>
<span class="quote">&gt;&gt;&gt; 	/*</span>
<span class="quote">&gt;&gt;&gt; 	 * While a device is added into a iommu group, the iommu core</span>
<span class="quote">&gt;&gt;&gt; 	 * will create a default domain for each a iommu group.</span>
<span class="quote">&gt;&gt;&gt; 	 * This default domain is reserved as the m4u domain and is</span>
<span class="quote">&gt;&gt;&gt; 	 * initiated here.</span>
<span class="quote">&gt;&gt;&gt; 	 */</span>
<span class="quote">&gt;&gt;&gt; 	data-&gt;m4u_dom = dom;</span>
<span class="quote">&gt;&gt;&gt; 	if (domain-&gt;type == IOMMU_DOMAIN_DMA) {</span>
<span class="quote">&gt;&gt;&gt; 		ret = iommu_dma_init_domain(domain, 0,</span>
<span class="quote">&gt;&gt;&gt; 					    DMA_BIT_MASK(32));</span>
<span class="quote">&gt;&gt;&gt; 		if (ret)</span>
<span class="quote">&gt;&gt;&gt; 			goto err_uninit_dom;</span>
<span class="quote">&gt;&gt;&gt; 	}</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; 	ret = mtk_iommu_domain_finalise(data);</span>
<span class="quote">&gt;&gt;&gt; 	if (ret)</span>
<span class="quote">&gt;&gt;&gt; 		goto err_uninit_dom;</span>
<span class="quote">&gt;&gt;&gt; }</span>
<span class="quote">&gt;&gt;&gt; //======================</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		iommu_domain_free(domain);</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; This function is not supposed to free the domain passed to it.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; As above this domain is created in the do_iommu_attach which will help</span>
<span class="quote">&gt;&gt;&gt; create a default domain for each a iommu device.</span>
<span class="quote">&gt;&gt;&gt; We don&#39;t need this default domain!</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; If we don&#39;t free it here, there will be a memory leak.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;   From Robin&#39;s comment, He will improve the sequence of the</span>
<span class="quote">&gt;&gt;&gt; __iommu_setup_dma_ops in the future.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; That already happened. The final version of the arm64 code which was</span>
<span class="quote">&gt;&gt; merged makes sure that the IOMMU driver always sees the callbacks in the</span>
<span class="quote">&gt;&gt; desired of_xlate -&gt; add_device -&gt; attach_dev order. The whole point of</span>
<span class="quote">&gt;&gt; the comment below is that the driver itself *doesn&#39;t* have to care about</span>
<span class="quote">&gt;&gt; the awkward way in which that is currently achieved.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; /*</span>
<span class="quote">&gt;&gt;&gt;    * TODO: Right now __iommu_setup_dma_ops() gets called too early to do</span>
<span class="quote">&gt;&gt;&gt;    * everything it needs to - the device is only partially created and the</span>
<span class="quote">&gt;&gt;&gt;    * IOMMU driver hasn&#39;t seen it yet, so it can&#39;t have a group. Thus we</span>
<span class="quote">&gt;&gt;&gt;    * need this delayed attachment dance. Once IOMMU probe ordering is</span>
<span class="quote">&gt;&gt;&gt; sorted</span>
<span class="quote">&gt;&gt;&gt;    * to move the arch_setup_dma_ops() call later, all the notifier bits</span>
<span class="quote">&gt;&gt;&gt; below</span>
<span class="quote">&gt;&gt;&gt;    * become unnecessary, and will go away.</span>
<span class="quote">&gt;&gt;&gt;    */</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; /*</span>
<span class="quote">&gt;&gt;&gt;    * Best case: The device is either part of a group which was</span>
<span class="quote">&gt;&gt;&gt;    * already attached to a domain in a previous call, or it&#39;s</span>
<span class="quote">&gt;&gt;&gt;    * been put in a default DMA domain by the IOMMU core.</span>
<span class="quote">&gt;&gt;&gt;    */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; That was before Joerg made the device_group changes which enabled proper</span>
<span class="quote">&gt;&gt; default domains for platform devices - with those, we should be now be</span>
<span class="quote">&gt;&gt; hitting the &quot;best case&quot; behaviour every time. In fact I think the &quot;fake</span>
<span class="quote">&gt;&gt; default domain&quot; workaround shouldn&#39;t be needed at all any more, so I</span>
<span class="quote">&gt;&gt; will add removing it to my giant list of things to do.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;      But there is no this patch currently, so I add iommu_domain_free</span>
<span class="quote">&gt;&gt;&gt; here.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;      &quot;free the domain&quot; here looks really not good. Then I delete the</span>
<span class="quote">&gt;&gt;&gt; iommu_domain_free here(allow this memory leak right now), is it ok?</span>
<span class="quote">&gt;&gt;&gt; (It will also works after Robin&#39;s change in the future.)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	struct iommu_group *group;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		return -ENODEV;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	group = iommu_group_get_for_dev(dev);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	if (IS_ERR(group))</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		return PTR_ERR(group);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	iommu_group_put(group);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	if (!priv)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	}</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; As long as this works as expected, then AFAICS you shouldn&#39;t have to</span>
<span class="quote">&gt;&gt; have *any* special-case behaviour or tracking of domains at all.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; We only need one iommu-group, one iommu domain here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What&#39;s the special-case behavior, how can we track of domains.</span>
<span class="quote">&gt; Could you help give me a example?</span>

The beauty of it is that you don&#39;t need to. If you guarantee all of an 
IOMMU&#39;s client devices are in the same group, you know you&#39;ve only got 
one thing which can be attached to that IOMMU&#39;s domains. Therefore, you 
can freely allow as many domains as you like to *exist*, because there 
can never be more than one *active* at any given time - the core code 
enforces that the group is detached from one domain before being 
attached to another, and the driver&#39;s attach and detach calls just 
become responsible for switching the given domain&#39;s page table in and 
out of the actual hardware. I think it&#39;s pretty neat.

Robin.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=317">Joerg Roedel</a> - Dec. 16, 2015, 3:15 p.m.</div>
<pre class="content">
On Tue, Dec 15, 2015 at 12:37:34PM +0000, Robin Murphy wrote:
<span class="quote">&gt; The potential issue I *do* see, looking more closely, is that</span>
<span class="quote">&gt; iommu_group_get_for_dev() is setting group-&gt;domain but not calling</span>
<span class="quote">&gt; the attach_dev callback, which looks wrong...</span>

Attaching the device happens from iommu_group_add_device(), which is
called from iommu_group_get_for_dev() right after the domains are
allocated/initialized.


	Joerg

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Dec. 17, 2015, 3:12 a.m.</div>
<pre class="content">
On Wed, 2015-12-16 at 12:48 +0000, Robin Murphy wrote:
<span class="quote">&gt; On 16/12/15 05:59, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; On Tue, 2015-12-15 at 12:37 +0000, Robin Murphy wrote:</span>
<span class="quote">&gt; &gt;&gt; On 15/12/15 03:28, Yong Wu wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; On Mon, 2015-12-14 at 15:16 +0100, Joerg Roedel wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; On Tue, Dec 08, 2015 at 05:49:12PM +0800, Yong Wu wrote:</span>
[...]
<span class="quote">&gt; &gt; Following your comment above, I test as below. Then the flows seems meet</span>
<span class="quote">&gt; &gt; the &quot;best case&quot; that the iommu core will help create default DMA domain.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; @@ -664,19 +636,41 @@ static int mtk_iommu_probe(struct platform_device</span>
<span class="quote">&gt; &gt; *pdev)</span>
<span class="quote">&gt; &gt; for (i = 0; i &lt; larb_nr; i++) {</span>
<span class="quote">&gt; &gt; 		struct device_node *larbnode;</span>
<span class="quote">&gt; &gt; 		struct platform_device *plarbdev;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; 		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="quote">&gt; &gt; 		if (!larbnode)</span>
<span class="quote">&gt; &gt; 			return -EINVAL;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;                  plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; &gt;                  of_node_put(larbnode);</span>
<span class="quote">&gt; &gt; -               if (!plarbdev)</span>
<span class="quote">&gt; &gt; -                       return -EPROBE_DEFER;</span>
<span class="quote">&gt; &gt; +               if (!plarbdev) {</span>
<span class="quote">&gt; &gt; +                       plarbdev = of_platform_device_create(larbnode,</span>
<span class="quote">&gt; &gt; NULL, platform_bus_type.dev_root);</span>
<span class="quote">&gt; &gt; +                       if (IS_ERR(pdev))</span>
<span class="quote">&gt; &gt; +                               return -EPROBE_DEFER;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; }</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I only add of_platform_device_create for the SMI local arbiter devices</span>
<span class="quote">&gt; &gt; here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This is a big improvement for us. If this is ok, I will send a quick</span>
<span class="quote">&gt; &gt; next version for this.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In my opinion it&#39;s reasonable - we need the whole &quot;IOMMU&quot; to be ready, </span>

  Thanks.
<span class="quote">
&gt; so if we already have to short-cut the creation of the M4U part it only </span>
<span class="quote">&gt; seems fair to do the same for the SMI part. That said, would it work to </span>
<span class="quote">&gt; just unconditionally poke the larbs in mtk_iommu_init_fn() before you </span>
<span class="quote">&gt; poke the M4U itself? It would be nice to keep all that stuff together in </span>
<span class="quote">&gt; the same place.</span>

    mtk_iommu_init_fn don&#39;t have the larb&#39;s &quot;struct device_node&quot;. So I
cann&#39;t create its platform_device directly.

    I have tried 2 method:
   a) add a mtk_smi_larb_init_fn in the SMI patch.

static int mtk_smi_larb_init_fn(struct device_node *np)
{
	struct platform_device *pdev;

	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);

	return IS_ERR(pdev) ? PTR_ERR(pdev) :  0;
}
IOMMU_OF_DECLARE(mtk_smi_larb, &quot;mediatek,mt8173-smi-larb&quot;,
mtk_smi_larb_init_fn);

   This don&#39;t work. It will run after mtk_iommu_init_fn. then the larb&#39;s
platform_device also don&#39;t exist while m4u&#39;s probe.

  b) Copy the code below to mtk_iommu_init_fn.

   for (i = 0; i &lt; larb_nr; i++) {
      xxx
      plarbdev = of_platform_device_create(larbnode,
                      NULL, platform_bus_type.dev_root);
   }

   It works. But then there are 2 same code of parsing the SMI local
arbiter(one is in mtk_iommu_init_fn, the other is in mtk_iommu_init_fn).
It looks not good. I think that the one I wrote in the previous mail is
better, It only add 3 lines, What&#39;s your opinion?
<span class="quote">
&gt; &gt;&gt;&gt;&gt;&gt; +static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	struct mtk_iommu_data *data;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	struct mtk_iommu_client_priv *priv;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	priv = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	if (!priv)</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +		return ERR_PTR(-ENODEV);</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	/* All the client devices are in the same m4u iommu-group */</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	if (!data-&gt;m4u_group) {</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	}</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +	return data-&gt;m4u_group;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; As long as this works as expected, then AFAICS you shouldn&#39;t have to</span>
<span class="quote">&gt; &gt;&gt; have *any* special-case behaviour or tracking of domains at all.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; We only need one iommu-group, one iommu domain here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; What&#39;s the special-case behavior, how can we track of domains.</span>
<span class="quote">&gt; &gt; Could you help give me a example?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The beauty of it is that you don&#39;t need to. If you guarantee all of an </span>
<span class="quote">&gt; IOMMU&#39;s client devices are in the same group, you know you&#39;ve only got </span>
<span class="quote">&gt; one thing which can be attached to that IOMMU&#39;s domains. Therefore, you </span>
<span class="quote">&gt; can freely allow as many domains as you like to *exist*, because there </span>
<span class="quote">&gt; can never be more than one *active* at any given time - the core code </span>
<span class="quote">&gt; enforces that the group is detached from one domain before being </span>
<span class="quote">&gt; attached to another, and the driver&#39;s attach and detach calls just </span>
<span class="quote">&gt; become responsible for switching the given domain&#39;s page table in and </span>
<span class="quote">&gt; out of the actual hardware. I think it&#39;s pretty neat.</span>

It seems that mtk-iommu can not detach/attach dynamically. the iommu
core don&#39;t support iommu_detach_device/iommu_attach_device whose
iommu-group have many devices.(Normally there is only one device in a
iommu-group). 

So currently we only iommu_attach_device while probe, it will never
attach/detach again.

All our multimedia modules are in the m4u&#39;domain and share m4u&#39;s
pagetable, They won&#39;t change pagetable.
<span class="quote">
&gt; </span>
<span class="quote">&gt; Robin.</span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index b9094e9..aab942f 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -393,4 +393,19 @@</span> <span class="p_context"> config S390_IOMMU</span>
 	help
 	  Support for the IOMMU API for s390 PCI devices.
 
<span class="p_add">+config MTK_IOMMU</span>
<span class="p_add">+	bool &quot;MTK IOMMU Support&quot;</span>
<span class="p_add">+	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="p_add">+	select IOMMU_API</span>
<span class="p_add">+	select IOMMU_DMA</span>
<span class="p_add">+	select IOMMU_IO_PGTABLE_ARMV7S</span>
<span class="p_add">+	select MEMORY</span>
<span class="p_add">+	select MTK_SMI</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for the M4U on certain Mediatek SOCs. M4U is MultiMedia</span>
<span class="p_add">+	  Memory Management Unit. This option enables remapping of DMA memory</span>
<span class="p_add">+	  accesses for the multimedia subsystem.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N here.</span>
<span class="p_add">+</span>
 endif # IOMMU_SUPPORT
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index 68faca02..02887bc 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"> obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o</span>
 obj-$(CONFIG_TEGRA_IOMMU_GART) += tegra-gart.o
 obj-$(CONFIG_TEGRA_IOMMU_SMMU) += tegra-smmu.o
 obj-$(CONFIG_EXYNOS_IOMMU) += exynos-iommu.o
<span class="p_add">+obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
 obj-$(CONFIG_SHMOBILE_IOMMU) += shmobile-iommu.o
 obj-$(CONFIG_SHMOBILE_IPMMU) += shmobile-ipmmu.o
 obj-$(CONFIG_FSL_PAMU) += fsl_pamu.o fsl_pamu_domain.o
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
new file mode 100644
<span class="p_header">index 0000000..6a21e70</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.c</span>
<span class="p_chunk">@@ -0,0 +1,752 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="p_add">+ * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;linux/component.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/iopoll.h&gt;</span>
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="p_add">+#include &lt;dt-bindings/memory/mt8173-larb-port.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;io-pgtable.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVALIDATE			0x020</span>
<span class="p_add">+#define F_ALL_INVLD				0x2</span>
<span class="p_add">+#define F_MMU_INV_RANGE				0x1</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_START_A			0x024</span>
<span class="p_add">+#define REG_MMU_INVLD_END_A			0x028</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INV_SEL				0x038</span>
<span class="p_add">+#define F_INVLD_EN0				BIT(0)</span>
<span class="p_add">+#define F_INVLD_EN1				BIT(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_STANDARD_AXI_MODE		0x048</span>
<span class="p_add">+#define REG_MMU_DCM_DIS				0x050</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CTRL_REG			0x110</span>
<span class="p_add">+#define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="p_add">+#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="p_add">+#define F_COHERENCE_EN				BIT(8)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_IVRP_PADDR			0x114</span>
<span class="p_add">+#define F_MMU_IVRP_PA_SET(pa)			((pa) &gt;&gt; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_CONTROL0			0x120</span>
<span class="p_add">+#define F_L2_MULIT_HIT_EN			BIT(0)</span>
<span class="p_add">+#define F_TABLE_WALK_FAULT_INT_EN		BIT(1)</span>
<span class="p_add">+#define F_PREETCH_FIFO_OVERFLOW_INT_EN		BIT(2)</span>
<span class="p_add">+#define F_MISS_FIFO_OVERFLOW_INT_EN		BIT(3)</span>
<span class="p_add">+#define F_PREFETCH_FIFO_ERR_INT_EN		BIT(5)</span>
<span class="p_add">+#define F_MISS_FIFO_ERR_INT_EN			BIT(6)</span>
<span class="p_add">+#define F_INT_CLR_BIT				BIT(12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_MAIN_CONTROL		0x124</span>
<span class="p_add">+#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="p_add">+#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="p_add">+#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="p_add">+#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="p_add">+#define F_INT_TLB_MISS_FAULT			BIT(4)</span>
<span class="p_add">+#define F_INT_MISS_TRANSATION_FIFO_FAULT	BIT(5)</span>
<span class="p_add">+#define F_INT_PRETETCH_TRANSATION_FIFO_FAULT	BIT(6)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CPE_DONE			0x12C</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_ST1			0x134</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_VA			0x13c</span>
<span class="p_add">+#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="p_add">+#define F_MMU_FAULT_VA_WRITE_BIT		BIT(1)</span>
<span class="p_add">+#define F_MMU_FAULT_VA_LAYER_BIT		BIT(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_PA			0x140</span>
<span class="p_add">+#define REG_MMU_INT_ID				0x150</span>
<span class="p_add">+#define F_MMU0_INT_ID_LARB_ID(a)		(((a) &gt;&gt; 7) &amp; 0x7)</span>
<span class="p_add">+#define F_MMU0_INT_ID_PORT_ID(a)		(((a) &gt;&gt; 2) &amp; 0x1f)</span>
<span class="p_add">+</span>
<span class="p_add">+#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="p_add">+#define MTK_IOMMU_LARB_MAX_NR			8</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_suspend_reg {</span>
<span class="p_add">+	u32				standard_axi_mode;</span>
<span class="p_add">+	u32				dcm_dis;</span>
<span class="p_add">+	u32				ctrl_reg;</span>
<span class="p_add">+	u32				int_control0;</span>
<span class="p_add">+	u32				int_main_control;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_client_priv {</span>
<span class="p_add">+	struct list_head		client;</span>
<span class="p_add">+	unsigned int			mtk_m4u_id;</span>
<span class="p_add">+	struct device			*m4udev;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_domain {</span>
<span class="p_add">+	spinlock_t			pgtlock; /* lock for page table */</span>
<span class="p_add">+</span>
<span class="p_add">+	struct io_pgtable_cfg		cfg;</span>
<span class="p_add">+	struct io_pgtable_ops		*iop;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct iommu_domain		domain;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_data {</span>
<span class="p_add">+	void __iomem			*base;</span>
<span class="p_add">+	int				irq;</span>
<span class="p_add">+	struct device			*dev;</span>
<span class="p_add">+	struct device			*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="p_add">+	struct clk			*bclk;</span>
<span class="p_add">+	phys_addr_t			protect_base; /* protect memory base */</span>
<span class="p_add">+	int				larb_nr;      /* local arbiter number */</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg	reg;</span>
<span class="p_add">+	struct mtk_iommu_domain		*m4u_dom;</span>
<span class="p_add">+	struct iommu_group		*m4u_group;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return container_of(dom, struct mtk_iommu_domain, domain);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = cookie;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel_relaxed(F_ALL_INVLD, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+	wmb(); /* Make sure the tlb flush all done */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_add_flush_nosync(unsigned long iova, size_t size,</span>
<span class="p_add">+					   size_t granule, bool leaf,</span>
<span class="p_add">+					   void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = cookie;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, data-&gt;base + REG_MMU_INV_SEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(iova, data-&gt;base + REG_MMU_INVLD_START_A);</span>
<span class="p_add">+	writel_relaxed(iova + size - 1, data-&gt;base + REG_MMU_INVLD_END_A);</span>
<span class="p_add">+	writel_relaxed(F_MMU_INV_RANGE, data-&gt;base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_sync(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = cookie;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = readl_poll_timeout_atomic(data-&gt;base + REG_MMU_CPE_DONE, tmp,</span>
<span class="p_add">+					tmp != 0, 10, 100000);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_warn(data-&gt;dev,</span>
<span class="p_add">+			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="p_add">+		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Clear the CPE status */</span>
<span class="p_add">+	writel_relaxed(0, data-&gt;base + REG_MMU_CPE_DONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="p_add">+	.tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="p_add">+	.tlb_add_flush = mtk_iommu_tlb_add_flush_nosync,</span>
<span class="p_add">+	.tlb_sync = mtk_iommu_tlb_sync,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_id;</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="p_add">+	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="p_add">+	unsigned int fault_larb, fault_port;</span>
<span class="p_add">+	bool layer, write;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Read error info from registers */</span>
<span class="p_add">+	int_state = readl_relaxed(data-&gt;base + REG_MMU_FAULT_ST1);</span>
<span class="p_add">+	fault_iova = readl_relaxed(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="p_add">+	layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="p_add">+	write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="p_add">+	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="p_add">+	fault_pa = readl_relaxed(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="p_add">+	fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="p_add">+	fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (report_iommu_fault(&amp;dom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="p_add">+			       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {</span>
<span class="p_add">+		dev_err_ratelimited(</span>
<span class="p_add">+			data-&gt;dev,</span>
<span class="p_add">+			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="p_add">+			int_state, fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="p_add">+			layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Interrupt clear */</span>
<span class="p_add">+	regval = readl_relaxed(data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	regval |= F_INT_CLR_BIT;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_all(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_config(struct mtk_iommu_data *data,</span>
<span class="p_add">+			     struct device *dev, bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		mtk_smi_config_port(</span>
<span class="p_add">+			data-&gt;larbdev[MTK_M4U_TO_LARB(cur-&gt;mtk_m4u_id)],</span>
<span class="p_add">+			MTK_M4U_TO_PORT(cur-&gt;mtk_m4u_id), enable);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_domain_finalise(struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = data-&gt;m4u_dom;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;cfg = (struct io_pgtable_cfg) {</span>
<span class="p_add">+		.quirks = IO_PGTABLE_QUIRK_ARM_NS |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_NO_PERMS |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_TLBI_ON_MAP,</span>
<span class="p_add">+		.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,</span>
<span class="p_add">+		.ias = 32,</span>
<span class="p_add">+		.oas = 32,</span>
<span class="p_add">+		.tlb = &amp;mtk_iommu_gather_ops,</span>
<span class="p_add">+		.iommu_dev = data-&gt;dev,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;iop = alloc_io_pgtable_ops(ARM_V7S, &amp;dom-&gt;cfg, data);</span>
<span class="p_add">+	if (!dom-&gt;iop) {</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed to alloc io pgtable\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Update our support page sizes bitmap */</span>
<span class="p_add">+	mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="p_add">+		       data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	dom = kzalloc(sizeof(*dom), GFP_KERNEL);</span>
<span class="p_add">+	if (!dom)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (type == IOMMU_DOMAIN_DMA &amp;&amp; iommu_get_dma_cookie(&amp;dom-&gt;domain)) {</span>
<span class="p_add">+		kfree(dom);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;domain.geometry.aperture_start = 0;</span>
<span class="p_add">+	dom-&gt;domain.geometry.aperture_end = DMA_BIT_MASK(32);</span>
<span class="p_add">+	dom-&gt;domain.geometry.force_aperture = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;dom-&gt;domain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (domain-&gt;type == IOMMU_DOMAIN_DMA)</span>
<span class="p_add">+		iommu_put_dma_cookie(domain);</span>
<span class="p_add">+	kfree(to_mtk_domain(domain));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				   struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	if (!data) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The DMA core will run earlier than this probe, and it will</span>
<span class="p_add">+		 * create a default iommu domain for each a iommu device.</span>
<span class="p_add">+		 * But here there is only one domain called the m4u domain</span>
<span class="p_add">+		 * which all the multimedia HW share.</span>
<span class="p_add">+		 * The default domain isn&#39;t needed here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		iommu_domain_free(domain);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Return 0 for DMA to update dev-&gt;archdata.dma_ops */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	} else if (!data-&gt;m4u_dom) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * While a device is added into a iommu group, the iommu core</span>
<span class="p_add">+		 * will create a default domain for each a iommu group.</span>
<span class="p_add">+		 * This default domain is reserved as the m4u domain and is</span>
<span class="p_add">+		 * initiated here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		data-&gt;m4u_dom = dom;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (domain-&gt;type == IOMMU_DOMAIN_DMA) {</span>
<span class="p_add">+			ret = iommu_dma_init_domain(domain, 0,</span>
<span class="p_add">+						    DMA_BIT_MASK(32));</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				goto err_uninit_dom;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = mtk_iommu_domain_finalise(data);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto err_uninit_dom;</span>
<span class="p_add">+	} else if (data-&gt;m4u_dom != dom) {</span>
<span class="p_add">+		/* All the client devices should be in the same m4u domain */</span>
<span class="p_add">+		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_config(data, dev, true);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_uninit_dom:</span>
<span class="p_add">+	data-&gt;m4u_dom = NULL;</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				    struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	if (data)</span>
<span class="p_add">+		mtk_iommu_config(data, dev, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	ret = dom-&gt;iop-&gt;map(dom-&gt;iop, iova, paddr, size, prot);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="p_add">+			      unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	size_t unmapsz;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	unmapsz = dom-&gt;iop-&gt;unmap(dom-&gt;iop, iova, size);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return unmapsz;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="p_add">+					  dma_addr_t iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *dom = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+	pa = dom-&gt;iop-&gt;iova_to_phys(dom-&gt;iop, iova);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dom-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_add_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) /* Not a iommu client device */</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get_for_dev(dev);</span>
<span class="p_add">+	if (IS_ERR(group))</span>
<span class="p_add">+		return PTR_ERR(group);</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_remove_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!head)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		list_del(&amp;cur-&gt;client);</span>
<span class="p_add">+		kfree(cur);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	iommu_group_remove_device(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_group *mtk_iommu_device_group(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return ERR_PTR(-ENODEV);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All the client devices are in the same m4u iommu-group */</span>
<span class="p_add">+	data = dev_get_drvdata(priv-&gt;m4udev);</span>
<span class="p_add">+	if (!data-&gt;m4u_group) {</span>
<span class="p_add">+		data-&gt;m4u_group = iommu_group_alloc();</span>
<span class="p_add">+		if (IS_ERR(data-&gt;m4u_group))</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to allocate M4U IOMMU group\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return data-&gt;m4u_group;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_of_xlate(struct device *dev, struct of_phandle_args *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="p_add">+	struct platform_device *m4updev;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (args-&gt;args_count != 1) {</span>
<span class="p_add">+		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="p_add">+			args-&gt;args_count);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) {</span>
<span class="p_add">+		/* Get the m4u device */</span>
<span class="p_add">+		m4updev = of_find_device_by_node(args-&gt;np);</span>
<span class="p_add">+		of_node_put(args-&gt;np);</span>
<span class="p_add">+		if (WARN_ON(!m4updev))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="p_add">+		if (!head)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev-&gt;archdata.iommu = head;</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="p_add">+		head-&gt;m4udev = &amp;m4updev-&gt;dev;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		goto err_free_mem;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;mtk_m4u_id = args-&gt;args[0];</span>
<span class="p_add">+	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_free_mem:</span>
<span class="p_add">+	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="p_add">+		kfree(priv);</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	return -ENOMEM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops = {</span>
<span class="p_add">+	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="p_add">+	.domain_free	= mtk_iommu_domain_free,</span>
<span class="p_add">+	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="p_add">+	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="p_add">+	.map		= mtk_iommu_map,</span>
<span class="p_add">+	.unmap		= mtk_iommu_unmap,</span>
<span class="p_add">+	.map_sg		= default_iommu_map_sg,</span>
<span class="p_add">+	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="p_add">+	.add_device	= mtk_iommu_add_device,</span>
<span class="p_add">+	.remove_device	= mtk_iommu_remove_device,</span>
<span class="p_add">+	.device_group	= mtk_iommu_device_group,</span>
<span class="p_add">+	.of_xlate	= mtk_iommu_of_xlate,</span>
<span class="p_add">+	.pgsize_bitmap	= SZ_4K | SZ_64K | SZ_1M | SZ_16M,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 regval;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed to enable iommu bclk(%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="p_add">+		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="p_add">+		F_COHERENCE_EN;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_L2_MULIT_HIT_EN |</span>
<span class="p_add">+		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="p_add">+		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="p_add">+		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="p_add">+		F_INT_INVALID_PA_FAULT |</span>
<span class="p_add">+		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="p_add">+		F_INT_TLB_MISS_FAULT |</span>
<span class="p_add">+		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="p_add">+		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_IVRP_PA_SET(data-&gt;protect_base);</span>
<span class="p_add">+	writel_relaxed(regval, data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(0, data-&gt;base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="p_add">+			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="p_add">+		writel_relaxed(0, data-&gt;base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int compare_of(struct device *dev, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;of_node == data;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_bind(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+	void *protect;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="p_add">+	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="p_add">+	if (!protect)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;protect_base = ALIGN(virt_to_phys(protect), MTK_PROTECT_PA_ALIGN);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = component_bind_all(dev, NULL);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_hw_init(data);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		component_unbind_all(dev, NULL);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_unbind(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	component_unbind_all(dev, NULL);</span>
<span class="p_add">+	free_io_pgtable_ops(data-&gt;m4u_dom-&gt;iop);</span>
<span class="p_add">+	clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+	devm_free_irq(dev, data-&gt;irq, data);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct component_master_ops mtk_iommu_com_ops = {</span>
<span class="p_add">+	.bind		= mtk_iommu_bind,</span>
<span class="p_add">+	.unbind		= mtk_iommu_unbind,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data   *data;</span>
<span class="p_add">+	struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct resource         *res;</span>
<span class="p_add">+	struct component_match  *match = NULL;</span>
<span class="p_add">+	int                     i;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;dev = dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	data-&gt;base = devm_ioremap_resource(dev, res);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;base))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (data-&gt;irq &lt; 0)</span>
<span class="p_add">+		return data-&gt;irq;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;bclk))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;bclk);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;larb_nr = of_count_phandle_with_args(</span>
<span class="p_add">+					dev-&gt;of_node, &quot;mediatek,larbs&quot;, NULL);</span>
<span class="p_add">+	if (data-&gt;larb_nr &lt; 0)</span>
<span class="p_add">+		return data-&gt;larb_nr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; data-&gt;larb_nr; i++) {</span>
<span class="p_add">+		struct device_node *larbnode;</span>
<span class="p_add">+		struct platform_device *plarbdev;</span>
<span class="p_add">+</span>
<span class="p_add">+		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="p_add">+		if (!larbnode)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!of_device_is_available(larbnode))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="p_add">+		of_node_put(larbnode);</span>
<span class="p_add">+		if (!plarbdev)</span>
<span class="p_add">+			return -EPROBE_DEFER;</span>
<span class="p_add">+		data-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+		component_match_add(dev, &amp;match, compare_of, larbnode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_set_drvdata(dev, data);</span>
<span class="p_add">+	return component_master_add_with_match(dev, &amp;mtk_iommu_com_ops, match);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	component_master_del(&amp;pdev-&gt;dev, &amp;mtk_iommu_com_ops);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg-&gt;standard_axi_mode = readl_relaxed(base +</span>
<span class="p_add">+					       REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	reg-&gt;dcm_dis = readl_relaxed(base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	reg-&gt;ctrl_reg = readl_relaxed(base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	reg-&gt;int_control0 = readl_relaxed(base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	reg-&gt;int_main_control = readl_relaxed(base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="p_add">+		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="p_add">+		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;ctrl_reg, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_control0, base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base),</span>
<span class="p_add">+		       base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="p_add">+	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mtk_iommu_driver = {</span>
<span class="p_add">+	.probe	= mtk_iommu_probe,</span>
<span class="p_add">+	.remove	= mtk_iommu_remove,</span>
<span class="p_add">+	.driver	= {</span>
<span class="p_add">+		.name = &quot;mtk-iommu&quot;,</span>
<span class="p_add">+		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mtk_iommu_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+subsys_initcall(mtk_iommu_init);</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct platform_device *pdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="p_add">+	if (IS_ERR(pdev))</span>
<span class="p_add">+		return PTR_ERR(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	of_iommu_set_ops(np, &amp;mtk_iommu_ops);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



