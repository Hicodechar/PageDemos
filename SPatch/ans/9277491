
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[1/6] powerpc: port 64 bits pgtable_cache to 32 bits - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [1/6] powerpc: port 64 bits pgtable_cache to 32 bits</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 12, 2016, 4:55 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;794b4abd8caaad32edf4180ac485a2eb914fba49.1471020647.git.christophe.leroy@c-s.fr&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9277491/mbox/"
   >mbox</a>
|
   <a href="/patch/9277491/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9277491/">/patch/9277491/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AB70860752 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 12 Aug 2016 16:57:08 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9882328A9C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 12 Aug 2016 16:57:08 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 8D23F28ABE; Fri, 12 Aug 2016 16:57:08 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A68D128A9C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 12 Aug 2016 16:57:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932343AbcHLQ5B (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 12 Aug 2016 12:57:01 -0400
Received: from pegase1.c-s.fr ([93.17.236.30]:30051 &quot;EHLO pegase1.c-s.fr&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1752600AbcHLQzs (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 12 Aug 2016 12:55:48 -0400
Received: from localhost (unknown [192.168.12.234])
	by localhost (Postfix) with ESMTP id 3s9rcK6Dxqz9ttFZ;
	Fri, 12 Aug 2016 18:55:45 +0200 (CEST)
X-Virus-Scanned: Debian amavisd-new at c-s.fr
Received: from pegase1.c-s.fr ([192.168.12.234])
	by localhost (pegase1.c-s.fr [192.168.12.234]) (amavisd-new,
	port 10024)
	with ESMTP id uuMm5Bjrx21S; Fri, 12 Aug 2016 18:55:45 +0200 (CEST)
Received: from messagerie.si.c-s.fr (messagerie.si.c-s.fr [192.168.25.192])
	by pegase1.c-s.fr (Postfix) with ESMTP id 3s9rcK5QV6z9ttFP;
	Fri, 12 Aug 2016 18:55:45 +0200 (CEST)
Received: from localhost (localhost [127.0.0.1])
	by messagerie.si.c-s.fr (Postfix) with ESMTP id CE7128B966;
	Fri, 12 Aug 2016 18:55:46 +0200 (CEST)
X-Virus-Scanned: amavisd-new at c-s.fr
Received: from messagerie.si.c-s.fr ([127.0.0.1])
	by localhost (messagerie.si.c-s.fr [127.0.0.1]) (amavisd-new,
	port 10023)
	with ESMTP id zVIdCWZaQ64C; Fri, 12 Aug 2016 18:55:46 +0200 (CEST)
Received: from PO10863.localdomain (po10863.idsi0.si.c-s.fr [172.25.231.6])
	by messagerie.si.c-s.fr (Postfix) with ESMTP id 90ED48B8BC;
	Fri, 12 Aug 2016 18:55:46 +0200 (CEST)
Received: by localhost.localdomain (Postfix, from userid 0)
	id 895071A2456; Fri, 12 Aug 2016 18:55:46 +0200 (CEST)
Message-Id: &lt;794b4abd8caaad32edf4180ac485a2eb914fba49.1471020647.git.christophe.leroy@c-s.fr&gt;
In-Reply-To: &lt;cover.1471020646.git.christophe.leroy@c-s.fr&gt;
References: &lt;cover.1471020646.git.christophe.leroy@c-s.fr&gt;
From: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;
Subject: [PATCH 1/6] powerpc: port 64 bits pgtable_cache to 32 bits
To: Benjamin Herrenschmidt &lt;benh@kernel.crashing.org&gt;,
	Paul Mackerras &lt;paulus@samba.org&gt;, Michael Ellerman &lt;mpe@ellerman.id.au&gt;,
	Scott Wood &lt;oss@buserror.net&gt;
Cc: linux-kernel@vger.kernel.org, linuxppc-dev@lists.ozlabs.org
Date: Fri, 12 Aug 2016 18:55:46 +0200 (CEST)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a> - Aug. 12, 2016, 4:55 p.m.</div>
<pre class="content">
Today powerpc64 uses a set of pgtable_caches while powerpc32 uses
standard pages when using 4k pages and a single pgtable_cache
if using other size pages. In addition powerpc32 uses another cache
when handling huge pages.

In preparation of implementing huge pages on the 8xx, this patch
replaces the specific powerpc32 handling by the 64 bits approach.
<span class="signed-off-by">
Signed-off-by: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;</span>
---
 arch/powerpc/include/asm/book3s/32/pgalloc.h |  44 ++++++--
 arch/powerpc/include/asm/book3s/32/pgtable.h |  43 ++++----
 arch/powerpc/include/asm/book3s/64/pgtable.h |   3 -
 arch/powerpc/include/asm/hugetlb.h           |   2 -
 arch/powerpc/include/asm/nohash/32/pgalloc.h |  44 ++++++--
 arch/powerpc/include/asm/nohash/32/pgtable.h |  45 ++++----
 arch/powerpc/include/asm/nohash/64/pgtable.h |   2 -
 arch/powerpc/include/asm/pgtable.h           |   2 +
 arch/powerpc/mm/Makefile                     |   2 +-
 arch/powerpc/mm/hugetlbpage.c                |  12 +--
 arch/powerpc/mm/init-common.c                | 152 +++++++++++++++++++++++++++
 arch/powerpc/mm/init_32.c                    |   5 -
 arch/powerpc/mm/init_64.c                    |  82 ---------------
 arch/powerpc/mm/pgtable_32.c                 |  37 -------
 14 files changed, 282 insertions(+), 193 deletions(-)
 create mode 100644 arch/powerpc/mm/init-common.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1141">Aneesh Kumar K.V</a> - Aug. 14, 2016, 2:17 p.m.</div>
<pre class="content">
Christophe Leroy &lt;christophe.leroy@c-s.fr&gt; writes:
<span class="quote">
&gt; Today powerpc64 uses a set of pgtable_caches while powerpc32 uses</span>
<span class="quote">&gt; standard pages when using 4k pages and a single pgtable_cache</span>
<span class="quote">&gt; if using other size pages. In addition powerpc32 uses another cache</span>
<span class="quote">&gt; when handling huge pages.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; In preparation of implementing huge pages on the 8xx, this patch</span>
<span class="quote">&gt; replaces the specific powerpc32 handling by the 64 bits approach.</span>

Why is this needed ? Can you also summarize the page size used and the
hugepage format you are planning to use ? . What are the page sizes
supported by 8xx ? Also is the new code copy of existing powerpc64 4k
page size code ?
<span class="quote">
&gt;</span>
<span class="quote">&gt; Signed-off-by: Christophe Leroy &lt;christophe.leroy@c-s.fr&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/powerpc/include/asm/book3s/32/pgalloc.h |  44 ++++++--</span>
<span class="quote">&gt;  arch/powerpc/include/asm/book3s/32/pgtable.h |  43 ++++----</span>
<span class="quote">&gt;  arch/powerpc/include/asm/book3s/64/pgtable.h |   3 -</span>
<span class="quote">&gt;  arch/powerpc/include/asm/hugetlb.h           |   2 -</span>
<span class="quote">&gt;  arch/powerpc/include/asm/nohash/32/pgalloc.h |  44 ++++++--</span>
<span class="quote">&gt;  arch/powerpc/include/asm/nohash/32/pgtable.h |  45 ++++----</span>
<span class="quote">&gt;  arch/powerpc/include/asm/nohash/64/pgtable.h |   2 -</span>
<span class="quote">&gt;  arch/powerpc/include/asm/pgtable.h           |   2 +</span>
<span class="quote">&gt;  arch/powerpc/mm/Makefile                     |   2 +-</span>
<span class="quote">&gt;  arch/powerpc/mm/hugetlbpage.c                |  12 +--</span>
<span class="quote">&gt;  arch/powerpc/mm/init-common.c                | 152 +++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/powerpc/mm/init_32.c                    |   5 -</span>
<span class="quote">&gt;  arch/powerpc/mm/init_64.c                    |  82 ---------------</span>
<span class="quote">&gt;  arch/powerpc/mm/pgtable_32.c                 |  37 -------</span>
<span class="quote">&gt;  14 files changed, 282 insertions(+), 193 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 arch/powerpc/mm/init-common.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/book3s/32/pgalloc.h b/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="quote">&gt; index 8e21bb4..ab215fd 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="quote">&gt; @@ -2,14 +2,42 @@</span>
<span class="quote">&gt;  #define _ASM_POWERPC_BOOK3S_32_PGALLOC_H</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;linux/threads.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -/* For 32-bit, all levels of page tables are just drawn from get_free_page() */</span>
<span class="quote">&gt; -#define MAX_PGTABLE_INDEX_SIZE	0</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Functions that deal with pagetables that could be at any level of</span>
<span class="quote">&gt; + * the table need to be passed an &quot;index_size&quot; so they know how to</span>
<span class="quote">&gt; + * handle allocation.  For PTE pages (which are linked to a struct</span>
<span class="quote">&gt; + * page for now, and drawn from the main get_free_pages() pool), the</span>
<span class="quote">&gt; + * allocation size will be (2^index_size * sizeof(pointer)) and</span>
<span class="quote">&gt; + * allocations are drawn from the kmem_cache in PGT_CACHE(index_size).</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * The maximum index size needs to be big enough to allow any</span>
<span class="quote">&gt; + * pagetable sizes we need, but small enough to fit in the low bits of</span>
<span class="quote">&gt; + * any page table pointer.  In other words all pagetables, even tiny</span>
<span class="quote">&gt; + * ones, must be aligned to allow at least enough low 0 bits to</span>
<span class="quote">&gt; + * contain this value.  This value is also used as a mask, so it must</span>
<span class="quote">&gt; + * be one less than a power of two.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define MAX_PGTABLE_INDEX_SIZE	0xf</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern void __bad_pte(pmd_t *pmd);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -extern pgd_t *pgd_alloc(struct mm_struct *mm);</span>
<span class="quote">&gt; -extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);</span>
<span class="quote">&gt; +extern struct kmem_cache *pgtable_cache[];</span>
<span class="quote">&gt; +#define PGT_CACHE(shift) ({				\</span>
<span class="quote">&gt; +			BUG_ON(!(shift));		\</span>
<span class="quote">&gt; +			pgtable_cache[(shift) - 1];	\</span>
<span class="quote">&gt; +		})</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return kmem_cache_alloc(PGT_CACHE(PGD_INDEX_SIZE), GFP_KERNEL);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	kmem_cache_free(PGT_CACHE(PGD_INDEX_SIZE), pgd);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * We don&#39;t have any real pmd&#39;s, and this code never triggers because</span>
<span class="quote">&gt; @@ -68,8 +96,12 @@ static inline void pte_free(struct mm_struct *mm, pgtable_t ptepage)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static inline void pgtable_free(void *table, unsigned index_size)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	BUG_ON(index_size); /* 32-bit doesn&#39;t use this */</span>
<span class="quote">&gt; -	free_page((unsigned long)table);</span>
<span class="quote">&gt; +	if (!index_size)</span>
<span class="quote">&gt; +		free_page((unsigned long)table);</span>
<span class="quote">&gt; +	else {</span>
<span class="quote">&gt; +		BUG_ON(index_size &gt; MAX_PGTABLE_INDEX_SIZE);</span>
<span class="quote">&gt; +		kmem_cache_free(PGT_CACHE(index_size), table);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define check_pgt_cache()	do { } while (0)</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/book3s/32/pgtable.h b/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="quote">&gt; index 38b33dc..83a2159 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="quote">&gt; @@ -8,6 +8,26 @@</span>
<span class="quote">&gt;  /* And here we include common definitions */</span>
<span class="quote">&gt;  #include &lt;asm/pte-common.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#define PTE_INDEX_SIZE	PTE_SHIFT</span>
<span class="quote">&gt; +#define PMD_INDEX_SIZE	0</span>
<span class="quote">&gt; +#define PUD_INDEX_SIZE	0</span>
<span class="quote">&gt; +#define PGD_INDEX_SIZE	(32 - PGDIR_SHIFT)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PMD_CACHE_INDEX	PMD_INDEX_SIZE</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifndef __ASSEMBLY__</span>
<span class="quote">&gt; +#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PMD_TABLE_SIZE	(sizeof(pmd_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PUD_TABLE_SIZE	(sizeof(pud_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="quote">&gt; +#endif	/* __ASSEMBLY__ */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PTRS_PER_PTE	(1 &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PTRS_PER_PGD	(1 &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* With 4k base page size, hugepage PTEs go at the PMD level */</span>
<span class="quote">&gt; +#define MIN_HUGEPTE_SHIFT	PMD_SHIFT</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * The normal case is that PTEs are 32-bits and we have a 1-page</span>
<span class="quote">&gt;   * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus</span>
<span class="quote">&gt; @@ -19,14 +39,10 @@</span>
<span class="quote">&gt;   * -Matt</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  /* PGDIR_SHIFT determines what a top-level page table entry can map */</span>
<span class="quote">&gt; -#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_SHIFT)</span>
<span class="quote">&gt; +#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_INDEX_SIZE)</span>
<span class="quote">&gt;  #define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="quote">&gt;  #define PGDIR_MASK	(~(PGDIR_SIZE-1))</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define PTRS_PER_PTE	(1 &lt;&lt; PTE_SHIFT)</span>
<span class="quote">&gt; -#define PTRS_PER_PMD	1</span>
<span class="quote">&gt; -#define PTRS_PER_PGD	(1 &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * This is the bottom of the PKMAP area with HIGHMEM or an arbitrary</span>
<span class="quote">&gt; @@ -82,12 +98,8 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern unsigned long ioremap_bot;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -/*</span>
<span class="quote">&gt; - * entries per page directory level: our page-table tree is two-level, so</span>
<span class="quote">&gt; - * we don&#39;t really have any PMD directory.</span>
<span class="quote">&gt; - */</span>
<span class="quote">&gt; -#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_SHIFT)</span>
<span class="quote">&gt; -#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="quote">&gt; +/* Bits to mask out from a PGD to get to the PUD page */</span>
<span class="quote">&gt; +#define PGD_MASKED_BITS		0</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define pte_ERROR(e) \</span>
<span class="quote">&gt;  	pr_err(&quot;%s:%d: bad pte %llx.\n&quot;, __FILE__, __LINE__, \</span>
<span class="quote">&gt; @@ -282,15 +294,6 @@ static inline void __ptep_set_access_flags(pte_t *ptep, pte_t entry)</span>
<span class="quote">&gt;  #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 3 })</span>
<span class="quote">&gt;  #define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 3 })</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="quote">&gt; -void pgtable_cache_init(void);</span>
<span class="quote">&gt; -#else</span>
<span class="quote">&gt; -/*</span>
<span class="quote">&gt; - * No page table caches to initialise</span>
<span class="quote">&gt; - */</span>
<span class="quote">&gt; -#define pgtable_cache_init()	do { } while (0)</span>
<span class="quote">&gt; -#endif</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  extern int get_pteptr(struct mm_struct *mm, unsigned long addr, pte_t **ptep,</span>
<span class="quote">&gt;  		      pmd_t **pmdp);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/book3s/64/pgtable.h b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="quote">&gt; index 263bf39..3f85d43 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="quote">&gt; @@ -786,9 +786,6 @@ extern struct page *pgd_page(pgd_t pgd);</span>
<span class="quote">&gt;  #define pgd_ERROR(e) \</span>
<span class="quote">&gt;  	pr_err(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="quote">&gt; -void pgtable_cache_init(void);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  static inline int map_kernel_page(unsigned long ea, unsigned long pa,</span>
<span class="quote">&gt;  				  unsigned long flags)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/hugetlb.h b/arch/powerpc/include/asm/hugetlb.h</span>
<span class="quote">&gt; index c5517f4..c201cd6 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/hugetlb.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/hugetlb.h</span>
<span class="quote">&gt; @@ -5,8 +5,6 @@</span>
<span class="quote">&gt;  #include &lt;asm/page.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm-generic/hugetlb.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -extern struct kmem_cache *hugepte_cache;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  #ifdef CONFIG_PPC_BOOK3S_64</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;asm/book3s/64/hugetlb-radix.h&gt;</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/nohash/32/pgalloc.h b/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="quote">&gt; index 76d6b9e..c2fe85c 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="quote">&gt; @@ -2,14 +2,42 @@</span>
<span class="quote">&gt;  #define _ASM_POWERPC_PGALLOC_32_H</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &lt;linux/threads.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -/* For 32-bit, all levels of page tables are just drawn from get_free_page() */</span>
<span class="quote">&gt; -#define MAX_PGTABLE_INDEX_SIZE	0</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Functions that deal with pagetables that could be at any level of</span>
<span class="quote">&gt; + * the table need to be passed an &quot;index_size&quot; so they know how to</span>
<span class="quote">&gt; + * handle allocation.  For PTE pages (which are linked to a struct</span>
<span class="quote">&gt; + * page for now, and drawn from the main get_free_pages() pool), the</span>
<span class="quote">&gt; + * allocation size will be (2^index_size * sizeof(pointer)) and</span>
<span class="quote">&gt; + * allocations are drawn from the kmem_cache in PGT_CACHE(index_size).</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * The maximum index size needs to be big enough to allow any</span>
<span class="quote">&gt; + * pagetable sizes we need, but small enough to fit in the low bits of</span>
<span class="quote">&gt; + * any page table pointer.  In other words all pagetables, even tiny</span>
<span class="quote">&gt; + * ones, must be aligned to allow at least enough low 0 bits to</span>
<span class="quote">&gt; + * contain this value.  This value is also used as a mask, so it must</span>
<span class="quote">&gt; + * be one less than a power of two.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define MAX_PGTABLE_INDEX_SIZE	0xf</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern void __bad_pte(pmd_t *pmd);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -extern pgd_t *pgd_alloc(struct mm_struct *mm);</span>
<span class="quote">&gt; -extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);</span>
<span class="quote">&gt; +extern struct kmem_cache *pgtable_cache[];</span>
<span class="quote">&gt; +#define PGT_CACHE(shift) ({				\</span>
<span class="quote">&gt; +			BUG_ON(!(shift));		\</span>
<span class="quote">&gt; +			pgtable_cache[(shift) - 1];	\</span>
<span class="quote">&gt; +		})</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return kmem_cache_alloc(PGT_CACHE(PGD_INDEX_SIZE), GFP_KERNEL);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	kmem_cache_free(PGT_CACHE(PGD_INDEX_SIZE), pgd);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * We don&#39;t have any real pmd&#39;s, and this code never triggers because</span>
<span class="quote">&gt; @@ -68,8 +96,12 @@ static inline void pte_free(struct mm_struct *mm, pgtable_t ptepage)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static inline void pgtable_free(void *table, unsigned index_size)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	BUG_ON(index_size); /* 32-bit doesn&#39;t use this */</span>
<span class="quote">&gt; -	free_page((unsigned long)table);</span>
<span class="quote">&gt; +	if (!index_size)</span>
<span class="quote">&gt; +		free_page((unsigned long)table);</span>
<span class="quote">&gt; +	else {</span>
<span class="quote">&gt; +		BUG_ON(index_size &gt; MAX_PGTABLE_INDEX_SIZE);</span>
<span class="quote">&gt; +		kmem_cache_free(PGT_CACHE(index_size), table);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define check_pgt_cache()	do { } while (0)</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/nohash/32/pgtable.h b/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="quote">&gt; index 7808475..8a2937d 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="quote">&gt; @@ -16,6 +16,26 @@ extern int icache_44x_need_flush;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #endif /* __ASSEMBLY__ */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#define PTE_INDEX_SIZE	PTE_SHIFT</span>
<span class="quote">&gt; +#define PMD_INDEX_SIZE	0</span>
<span class="quote">&gt; +#define PUD_INDEX_SIZE	0</span>
<span class="quote">&gt; +#define PGD_INDEX_SIZE	(32 - PGDIR_SHIFT)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PMD_CACHE_INDEX	PMD_INDEX_SIZE</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifndef __ASSEMBLY__</span>
<span class="quote">&gt; +#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PMD_TABLE_SIZE	(sizeof(pmd_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PUD_TABLE_SIZE	(sizeof(pud_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="quote">&gt; +#endif	/* __ASSEMBLY__ */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PTRS_PER_PTE	(1 &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="quote">&gt; +#define PTRS_PER_PGD	(1 &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* With 4k base page size, hugepage PTEs go at the PMD level */</span>
<span class="quote">&gt; +#define MIN_HUGEPTE_SHIFT	PMD_SHIFT</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * The normal case is that PTEs are 32-bits and we have a 1-page</span>
<span class="quote">&gt;   * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus</span>
<span class="quote">&gt; @@ -27,22 +47,12 @@ extern int icache_44x_need_flush;</span>
<span class="quote">&gt;   * -Matt</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt;  /* PGDIR_SHIFT determines what a top-level page table entry can map */</span>
<span class="quote">&gt; -#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_SHIFT)</span>
<span class="quote">&gt; +#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_INDEX_SIZE)</span>
<span class="quote">&gt;  #define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)</span>
<span class="quote">&gt;  #define PGDIR_MASK	(~(PGDIR_SIZE-1))</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -/*</span>
<span class="quote">&gt; - * entries per page directory level: our page-table tree is two-level, so</span>
<span class="quote">&gt; - * we don&#39;t really have any PMD directory.</span>
<span class="quote">&gt; - */</span>
<span class="quote">&gt; -#ifndef __ASSEMBLY__</span>
<span class="quote">&gt; -#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_SHIFT)</span>
<span class="quote">&gt; -#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="quote">&gt; -#endif	/* __ASSEMBLY__ */</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -#define PTRS_PER_PTE	(1 &lt;&lt; PTE_SHIFT)</span>
<span class="quote">&gt; -#define PTRS_PER_PMD	1</span>
<span class="quote">&gt; -#define PTRS_PER_PGD	(1 &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="quote">&gt; +/* Bits to mask out from a PGD to get to the PUD page */</span>
<span class="quote">&gt; +#define PGD_MASKED_BITS		0</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)</span>
<span class="quote">&gt;  #define FIRST_USER_ADDRESS	0UL</span>
<span class="quote">&gt; @@ -327,15 +337,6 @@ static inline void __ptep_set_access_flags(pte_t *ptep, pte_t entry)</span>
<span class="quote">&gt;  #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 3 })</span>
<span class="quote">&gt;  #define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 3 })</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="quote">&gt; -void pgtable_cache_init(void);</span>
<span class="quote">&gt; -#else</span>
<span class="quote">&gt; -/*</span>
<span class="quote">&gt; - * No page table caches to initialise</span>
<span class="quote">&gt; - */</span>
<span class="quote">&gt; -#define pgtable_cache_init()	do { } while (0)</span>
<span class="quote">&gt; -#endif</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  extern int get_pteptr(struct mm_struct *mm, unsigned long addr, pte_t **ptep,</span>
<span class="quote">&gt;  		      pmd_t **pmdp);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/nohash/64/pgtable.h b/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="quote">&gt; index d4d808c..b0fc9e4 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="quote">&gt; @@ -357,8 +357,6 @@ static inline void __ptep_set_access_flags(pte_t *ptep, pte_t entry)</span>
<span class="quote">&gt;  #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val((pte)) })</span>
<span class="quote">&gt;  #define __swp_entry_to_pte(x)		__pte((x).val)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="quote">&gt; -void pgtable_cache_init(void);</span>
<span class="quote">&gt;  extern int map_kernel_page(unsigned long ea, unsigned long pa,</span>
<span class="quote">&gt;  			   unsigned long flags);</span>
<span class="quote">&gt;  extern int __meminit vmemmap_create_mapping(unsigned long start,</span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/pgtable.h b/arch/powerpc/include/asm/pgtable.h</span>
<span class="quote">&gt; index 9bd87f2..dd01212 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/pgtable.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/pgtable.h</span>
<span class="quote">&gt; @@ -78,6 +78,8 @@ static inline pte_t *find_linux_pte_or_hugepte(pgd_t *pgdir, unsigned long ea,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  unsigned long vmalloc_to_phys(void *vmalloc_addr);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="quote">&gt; +void pgtable_cache_init(void);</span>
<span class="quote">&gt;  #endif /* __ASSEMBLY__ */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #endif /* _ASM_POWERPC_PGTABLE_H */</span>
<span class="quote">&gt; diff --git a/arch/powerpc/mm/Makefile b/arch/powerpc/mm/Makefile</span>
<span class="quote">&gt; index f2cea6d..08bb010 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/mm/Makefile</span>
<span class="quote">&gt; +++ b/arch/powerpc/mm/Makefile</span>
<span class="quote">&gt; @@ -7,7 +7,7 @@ subdir-ccflags-$(CONFIG_PPC_WERROR) := -Werror</span>
<span class="quote">&gt;  ccflags-$(CONFIG_PPC64)	:= $(NO_MINIMAL_TOC)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  obj-y				:= fault.o mem.o pgtable.o mmap.o \</span>
<span class="quote">&gt; -				   init_$(CONFIG_WORD_SIZE).o \</span>
<span class="quote">&gt; +				   init_$(CONFIG_WORD_SIZE).o init-common.o \</span>
<span class="quote">&gt;  				   pgtable_$(CONFIG_WORD_SIZE).o</span>
<span class="quote">&gt;  obj-$(CONFIG_PPC_MMU_NOHASH)	+= mmu_context_nohash.o tlb_nohash.o \</span>
<span class="quote">&gt;  				   tlb_nohash_low.o</span>
<span class="quote">&gt; diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt; index 7372ee1..9164a77 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt; @@ -68,7 +68,7 @@ static int __hugepte_alloc(struct mm_struct *mm, hugepd_t *hpdp,</span>
<span class="quote">&gt;  #ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="quote">&gt;  	int i;</span>
<span class="quote">&gt;  	int num_hugepd = 1 &lt;&lt; (pshift - pdshift);</span>
<span class="quote">&gt; -	cachep = hugepte_cache;</span>
<span class="quote">&gt; +	cachep = PGT_CACHE(1);</span>
<span class="quote">&gt;  #else</span>
<span class="quote">&gt;  	cachep = PGT_CACHE(pdshift - pshift);</span>
<span class="quote">&gt;  #endif</span>

Can you explain the usage of PGT_CACHE(1) ?
<span class="quote">
&gt; @@ -411,7 +411,7 @@ static void hugepd_free_rcu_callback(struct rcu_head *head)</span>
<span class="quote">&gt;  	unsigned int i;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	for (i = 0; i &lt; batch-&gt;index; i++)</span>
<span class="quote">&gt; -		kmem_cache_free(hugepte_cache, batch-&gt;ptes[i]);</span>
<span class="quote">&gt; +		kmem_cache_free(PGT_CACHE(1), batch-&gt;ptes[i]);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	free_page((unsigned long)batch);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt; @@ -425,7 +425,7 @@ static void hugepd_free(struct mmu_gather *tlb, void *hugepte)</span>
<span class="quote">&gt;  	if (atomic_read(&amp;tlb-&gt;mm-&gt;mm_users) &lt; 2 ||</span>
<span class="quote">&gt;  	    cpumask_equal(mm_cpumask(tlb-&gt;mm),</span>
<span class="quote">&gt;  			  cpumask_of(smp_processor_id()))) {</span>
<span class="quote">&gt; -		kmem_cache_free(hugepte_cache, hugepte);</span>
<span class="quote">&gt; +		kmem_cache_free(PGT_CACHE(1), hugepte);</span>
<span class="quote">&gt;  		put_cpu_var(hugepd_freelist_cur);</span>
<span class="quote">&gt;  		return;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; @@ -792,7 +792,6 @@ static int __init hugepage_setup_sz(char *str)</span>
<span class="quote">&gt;  __setup(&quot;hugepagesz=&quot;, hugepage_setup_sz);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="quote">&gt; -struct kmem_cache *hugepte_cache;</span>
<span class="quote">&gt;  static int __init hugetlbpage_init(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	int psize;</span>
<span class="quote">&gt; @@ -815,9 +814,8 @@ static int __init hugetlbpage_init(void)</span>
<span class="quote">&gt;  	 * Create a kmem cache for hugeptes.  The bottom bits in the pte have</span>
<span class="quote">&gt;  	 * size information encoded in them, so align them to allow this</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt; -	hugepte_cache =  kmem_cache_create(&quot;hugepte-cache&quot;, sizeof(pte_t),</span>
<span class="quote">&gt; -					   HUGEPD_SHIFT_MASK + 1, 0, NULL);</span>
<span class="quote">&gt; -	if (hugepte_cache == NULL)</span>
<span class="quote">&gt; +	pgtable_cache_add(1, NULL);</span>
<span class="quote">&gt; +	if (!PGT_CACHE(1))</span>
<span class="quote">&gt;  		panic(&quot;%s: Unable to create kmem cache for hugeptes\n&quot;,</span>
<span class="quote">&gt;  		      __func__);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/arch/powerpc/mm/init-common.c b/arch/powerpc/mm/init-common.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..2632eab</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/powerpc/mm/init-common.c</span>
<span class="quote">&gt; @@ -0,0 +1,152 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + *  PowerPC version</span>
<span class="quote">&gt; + *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)</span>
<span class="quote">&gt; + *  and Cort Dougan (PReP) (cort@cs.nmt.edu)</span>
<span class="quote">&gt; + *    Copyright (C) 1996 Paul Mackerras</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *  Derived from &quot;arch/i386/mm/init.c&quot;</span>
<span class="quote">&gt; + *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *  Dave Engebretsen &lt;engebret@us.ibm.com&gt;</span>
<span class="quote">&gt; + *      Rework for PPC64 port.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *  This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *  modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *  as published by the Free Software Foundation; either version</span>
<span class="quote">&gt; + *  2 of the License, or (at your option) any later version.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#undef DEBUG</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/signal.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/sched.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/errno.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/string.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/types.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mman.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/swap.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/stddef.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/vmalloc.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/init.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/delay.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/highmem.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/idr.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/nodemask.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/poison.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/memblock.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/hugetlb.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/page.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/prom.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/rtas.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/mmu_context.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/mmu.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/uaccess.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/smp.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/machdep.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlb.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/eeh.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/processor.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/mmzone.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/cputable.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/sections.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/vdso.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &quot;mmu_decl.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +phys_addr_t memstart_addr = (phys_addr_t)~0ull;</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(memstart_addr);</span>
<span class="quote">&gt; +phys_addr_t kernstart_addr;</span>
<span class="quote">&gt; +EXPORT_SYMBOL_GPL(kernstart_addr);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void pgd_ctor(void *addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	memset(addr, 0, PGD_TABLE_SIZE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void pud_ctor(void *addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	memset(addr, 0, PUD_TABLE_SIZE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void pmd_ctor(void *addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	memset(addr, 0, PMD_TABLE_SIZE);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct kmem_cache *pgtable_cache[MAX_PGTABLE_INDEX_SIZE];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Create a kmem_cache() for pagetables.  This is not used for PTE</span>
<span class="quote">&gt; + * pages - they&#39;re linked to struct page, come from the normal free</span>
<span class="quote">&gt; + * pages pool and have a different entry size (see real_pte_t) to</span>
<span class="quote">&gt; + * everything else.  Caches created by this function are used for all</span>
<span class="quote">&gt; + * the higher level pagetables, and for hugepage pagetables.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +void pgtable_cache_add(unsigned shift, void (*ctor)(void *))</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	char *name;</span>
<span class="quote">&gt; +	unsigned long table_size = sizeof(void *) &lt;&lt; shift;</span>
<span class="quote">&gt; +	unsigned long align = table_size;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* When batching pgtable pointers for RCU freeing, we store</span>
<span class="quote">&gt; +	 * the index size in the low bits.  Table alignment must be</span>
<span class="quote">&gt; +	 * big enough to fit it.</span>
<span class="quote">&gt; +	 *</span>
<span class="quote">&gt; +	 * Likewise, hugeapge pagetable pointers contain a (different)</span>
<span class="quote">&gt; +	 * shift value in the low bits.  All tables must be aligned so</span>
<span class="quote">&gt; +	 * as to leave enough 0 bits in the address to contain it. */</span>
<span class="quote">&gt; +	unsigned long minalign = max(MAX_PGTABLE_INDEX_SIZE + 1,</span>
<span class="quote">&gt; +				     HUGEPD_SHIFT_MASK + 1);</span>
<span class="quote">&gt; +	struct kmem_cache *new;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* It would be nice if this was a BUILD_BUG_ON(), but at the</span>
<span class="quote">&gt; +	 * moment, gcc doesn&#39;t seem to recognize is_power_of_2 as a</span>
<span class="quote">&gt; +	 * constant expression, so so much for that. */</span>
<span class="quote">&gt; +	BUG_ON(!is_power_of_2(minalign));</span>
<span class="quote">&gt; +	BUG_ON((shift &lt; 1) || (shift &gt; MAX_PGTABLE_INDEX_SIZE));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (PGT_CACHE(shift))</span>
<span class="quote">&gt; +		return; /* Already have a cache of this size */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	align = max_t(unsigned long, align, minalign);</span>
<span class="quote">&gt; +	name = kasprintf(GFP_KERNEL, &quot;pgtable-2^%d&quot;, shift);</span>
<span class="quote">&gt; +	new = kmem_cache_create(name, table_size, align, 0, ctor);</span>
<span class="quote">&gt; +	kfree(name);</span>
<span class="quote">&gt; +	pgtable_cache[shift - 1] = new;</span>
<span class="quote">&gt; +	pr_debug(&quot;Allocated pgtable cache for order %d\n&quot;, shift);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void pgtable_cache_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pgtable_cache_add(PGD_INDEX_SIZE, pgd_ctor);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (PMD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PMD_INDEX_SIZE))</span>
<span class="quote">&gt; +		pgtable_cache_add(PMD_CACHE_INDEX, pmd_ctor);</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * In all current configs, when the PUD index exists it&#39;s the</span>
<span class="quote">&gt; +	 * same size as either the pgd or pmd index except with THP enabled</span>
<span class="quote">&gt; +	 * on book3s 64</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="quote">&gt; +		pgtable_cache_add(PUD_INDEX_SIZE, pud_ctor);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!PGT_CACHE(PGD_INDEX_SIZE))</span>
<span class="quote">&gt; +		panic(&quot;Couldn&#39;t allocate pgd cache&quot;);</span>
<span class="quote">&gt; +	if (PMD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PMD_INDEX_SIZE))</span>
<span class="quote">&gt; +		panic(&quot;Couldn&#39;t allocate pmd pgtable caches&quot;);</span>
<span class="quote">&gt; +	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="quote">&gt; +		panic(&quot;Couldn&#39;t allocate pud pgtable caches&quot;);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; diff --git a/arch/powerpc/mm/init_32.c b/arch/powerpc/mm/init_32.c</span>
<span class="quote">&gt; index 448685f..79c24d4 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/mm/init_32.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/mm/init_32.c</span>
<span class="quote">&gt; @@ -59,11 +59,6 @@</span>
<span class="quote">&gt;  phys_addr_t total_memory;</span>
<span class="quote">&gt;  phys_addr_t total_lowmem;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -phys_addr_t memstart_addr = (phys_addr_t)~0ull;</span>
<span class="quote">&gt; -EXPORT_SYMBOL(memstart_addr);</span>
<span class="quote">&gt; -phys_addr_t kernstart_addr;</span>
<span class="quote">&gt; -EXPORT_SYMBOL(kernstart_addr);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  #ifdef CONFIG_RELOCATABLE</span>
<span class="quote">&gt;  /* Used in __va()/__pa() */</span>
<span class="quote">&gt;  long long virt_phys_offset;</span>
<span class="quote">&gt; diff --git a/arch/powerpc/mm/init_64.c b/arch/powerpc/mm/init_64.c</span>
<span class="quote">&gt; index 16ada1e..4acd546 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/mm/init_64.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/mm/init_64.c</span>
<span class="quote">&gt; @@ -75,88 +75,6 @@</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  #endif /* CONFIG_PPC_STD_MMU_64 */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -phys_addr_t memstart_addr = ~0;</span>
<span class="quote">&gt; -EXPORT_SYMBOL_GPL(memstart_addr);</span>
<span class="quote">&gt; -phys_addr_t kernstart_addr;</span>
<span class="quote">&gt; -EXPORT_SYMBOL_GPL(kernstart_addr);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static void pgd_ctor(void *addr)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	memset(addr, 0, PGD_TABLE_SIZE);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static void pud_ctor(void *addr)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	memset(addr, 0, PUD_TABLE_SIZE);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static void pmd_ctor(void *addr)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	memset(addr, 0, PMD_TABLE_SIZE);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -struct kmem_cache *pgtable_cache[MAX_PGTABLE_INDEX_SIZE];</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -/*</span>
<span class="quote">&gt; - * Create a kmem_cache() for pagetables.  This is not used for PTE</span>
<span class="quote">&gt; - * pages - they&#39;re linked to struct page, come from the normal free</span>
<span class="quote">&gt; - * pages pool and have a different entry size (see real_pte_t) to</span>
<span class="quote">&gt; - * everything else.  Caches created by this function are used for all</span>
<span class="quote">&gt; - * the higher level pagetables, and for hugepage pagetables.</span>
<span class="quote">&gt; - */</span>
<span class="quote">&gt; -void pgtable_cache_add(unsigned shift, void (*ctor)(void *))</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	char *name;</span>
<span class="quote">&gt; -	unsigned long table_size = sizeof(void *) &lt;&lt; shift;</span>
<span class="quote">&gt; -	unsigned long align = table_size;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	/* When batching pgtable pointers for RCU freeing, we store</span>
<span class="quote">&gt; -	 * the index size in the low bits.  Table alignment must be</span>
<span class="quote">&gt; -	 * big enough to fit it.</span>
<span class="quote">&gt; -	 *</span>
<span class="quote">&gt; -	 * Likewise, hugeapge pagetable pointers contain a (different)</span>
<span class="quote">&gt; -	 * shift value in the low bits.  All tables must be aligned so</span>
<span class="quote">&gt; -	 * as to leave enough 0 bits in the address to contain it. */</span>
<span class="quote">&gt; -	unsigned long minalign = max(MAX_PGTABLE_INDEX_SIZE + 1,</span>
<span class="quote">&gt; -				     HUGEPD_SHIFT_MASK + 1);</span>
<span class="quote">&gt; -	struct kmem_cache *new;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	/* It would be nice if this was a BUILD_BUG_ON(), but at the</span>
<span class="quote">&gt; -	 * moment, gcc doesn&#39;t seem to recognize is_power_of_2 as a</span>
<span class="quote">&gt; -	 * constant expression, so so much for that. */</span>
<span class="quote">&gt; -	BUG_ON(!is_power_of_2(minalign));</span>
<span class="quote">&gt; -	BUG_ON((shift &lt; 1) || (shift &gt; MAX_PGTABLE_INDEX_SIZE));</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	if (PGT_CACHE(shift))</span>
<span class="quote">&gt; -		return; /* Already have a cache of this size */</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	align = max_t(unsigned long, align, minalign);</span>
<span class="quote">&gt; -	name = kasprintf(GFP_KERNEL, &quot;pgtable-2^%d&quot;, shift);</span>
<span class="quote">&gt; -	new = kmem_cache_create(name, table_size, align, 0, ctor);</span>
<span class="quote">&gt; -	kfree(name);</span>
<span class="quote">&gt; -	pgtable_cache[shift - 1] = new;</span>
<span class="quote">&gt; -	pr_debug(&quot;Allocated pgtable cache for order %d\n&quot;, shift);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -void pgtable_cache_init(void)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	pgtable_cache_add(PGD_INDEX_SIZE, pgd_ctor);</span>
<span class="quote">&gt; -	pgtable_cache_add(PMD_CACHE_INDEX, pmd_ctor);</span>
<span class="quote">&gt; -	/*</span>
<span class="quote">&gt; -	 * In all current configs, when the PUD index exists it&#39;s the</span>
<span class="quote">&gt; -	 * same size as either the pgd or pmd index except with THP enabled</span>
<span class="quote">&gt; -	 * on book3s 64</span>
<span class="quote">&gt; -	 */</span>
<span class="quote">&gt; -	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="quote">&gt; -		pgtable_cache_add(PUD_INDEX_SIZE, pud_ctor);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	if (!PGT_CACHE(PGD_INDEX_SIZE) || !PGT_CACHE(PMD_CACHE_INDEX))</span>
<span class="quote">&gt; -		panic(&quot;Couldn&#39;t allocate pgtable caches&quot;);</span>
<span class="quote">&gt; -	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="quote">&gt; -		panic(&quot;Couldn&#39;t allocate pud pgtable caches&quot;);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  #ifdef CONFIG_SPARSEMEM_VMEMMAP</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Given an address within the vmemmap, determine the pfn of the page that</span>
<span class="quote">&gt; diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c</span>
<span class="quote">&gt; index 0ae0572..a65c0b4 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/mm/pgtable_32.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/mm/pgtable_32.c</span>
<span class="quote">&gt; @@ -42,43 +42,6 @@ EXPORT_SYMBOL(ioremap_bot);	/* aka VMALLOC_END */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern char etext[], _stext[], _sinittext[], _einittext[];</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define PGDIR_ORDER	(32 + PGD_T_LOG2 - PGDIR_SHIFT)</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="quote">&gt; -static struct kmem_cache *pgtable_cache;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -void pgtable_cache_init(void)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	pgtable_cache = kmem_cache_create(&quot;PGDIR cache&quot;, 1 &lt;&lt; PGDIR_ORDER,</span>
<span class="quote">&gt; -					  1 &lt;&lt; PGDIR_ORDER, 0, NULL);</span>
<span class="quote">&gt; -	if (pgtable_cache == NULL)</span>
<span class="quote">&gt; -		panic(&quot;Couldn&#39;t allocate pgtable caches&quot;);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -#endif</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	pgd_t *ret;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	/* pgdir take page or two with 4K pages and a page fraction otherwise */</span>
<span class="quote">&gt; -#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="quote">&gt; -	ret = kmem_cache_alloc(pgtable_cache, GFP_KERNEL | __GFP_ZERO);</span>
<span class="quote">&gt; -#else</span>
<span class="quote">&gt; -	ret = (pgd_t *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,</span>
<span class="quote">&gt; -			PGDIR_ORDER - PAGE_SHIFT);</span>
<span class="quote">&gt; -#endif</span>
<span class="quote">&gt; -	return ret;</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="quote">&gt; -	kmem_cache_free(pgtable_cache, (void *)pgd);</span>
<span class="quote">&gt; -#else</span>
<span class="quote">&gt; -	free_pages((unsigned long)pgd, PGDIR_ORDER - PAGE_SHIFT);</span>
<span class="quote">&gt; -#endif</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  __ref pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	pte_t *pte;</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.1.0</span>

I still didn&#39;t quiet follow why we are replacing

 -	hugepte_cache =  kmem_cache_create(&quot;hugepte-cache&quot;, sizeof(pte_t),
 -					   HUGEPD_SHIFT_MASK + 1, 0, NULL);
 +	pgtable_cache_add(1, NULL);

-aneesh
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=11492">LEROY Christophe</a> - Aug. 14, 2016, 6:51 p.m.</div>
<pre class="content">
Le 14/08/2016 à 16:17, Aneesh Kumar K.V a écrit :
<span class="quote">&gt; Christophe Leroy &lt;christophe.leroy@c-s.fr&gt; writes:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Today powerpc64 uses a set of pgtable_caches while powerpc32 uses</span>
<span class="quote">&gt;&gt; standard pages when using 4k pages and a single pgtable_cache</span>
<span class="quote">&gt;&gt; if using other size pages. In addition powerpc32 uses another cache</span>
<span class="quote">&gt;&gt; when handling huge pages.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; In preparation of implementing huge pages on the 8xx, this patch</span>
<span class="quote">&gt;&gt; replaces the specific powerpc32 handling by the 64 bits approach.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Why is this needed ? Can you also summarize the page size used and the</span>
<span class="quote">&gt; hugepage format you are planning to use ? . What are the page sizes</span>
<span class="quote">&gt; supported by 8xx ? Also is the new code copy of existing powerpc64 4k</span>
<span class="quote">&gt; page size code ?</span>

8xx supports two huge page sizes: 8M and 512k.
As PGD entries points on 4M page tables, it means we are in an 
eterogenous situation:
1/ when using 8M huge pages, we are in the same situation as what is 
done for the BOOK3S (which supports 16M, 256M and 1G), that is several 
PDG entries pointing to a single PTE entry.
2/ when using 512k huge pages, we are in the same situation as whan is 
done for the BOOK3E: a PGD entry points to the hugepage table that 
handles several huge pages (in our case 8 huge pages)

The code from init_64 have been moved to a new file named init-common in 
order to be used by init_32 too.
The code from the 64 bits .h has been copied into the 32 bits .h (indeed 
it&#39;s been copied twice as the .h are now duplicated into nohash and 
book3s versions)

[...]
<span class="quote">
&gt;&gt; diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt;&gt; index 7372ee1..9164a77 100644</span>
<span class="quote">&gt;&gt; --- a/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt;&gt; +++ b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt;&gt; @@ -68,7 +68,7 @@ static int __hugepte_alloc(struct mm_struct *mm, hugepd_t *hpdp,</span>
<span class="quote">&gt;&gt;  #ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="quote">&gt;&gt;  	int i;</span>
<span class="quote">&gt;&gt;  	int num_hugepd = 1 &lt;&lt; (pshift - pdshift);</span>
<span class="quote">&gt;&gt; -	cachep = hugepte_cache;</span>
<span class="quote">&gt;&gt; +	cachep = PGT_CACHE(1);</span>
<span class="quote">&gt;&gt;  #else</span>
<span class="quote">&gt;&gt;  	cachep = PGT_CACHE(pdshift - pshift);</span>
<span class="quote">&gt;&gt;  #endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can you explain the usage of PGT_CACHE(1) ?</span>

[...]
<span class="quote">
&gt;</span>
<span class="quote">&gt; I still didn&#39;t quiet follow why we are replacing</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  -	hugepte_cache =  kmem_cache_create(&quot;hugepte-cache&quot;, sizeof(pte_t),</span>
<span class="quote">&gt;  -					   HUGEPD_SHIFT_MASK + 1, 0, NULL);</span>
<span class="quote">&gt;  +	pgtable_cache_add(1, NULL);</span>
<span class="quote">&gt;</span>

Euh ... Indeed I wanted something to replace hugepte_cache. But it looks 
like it should be something like PGT_CACHE(0) for 32 bits targets having 
32 bits PTEs and PGT_CACHE(1) for 32 bits targets having 64 bits PTEs. 
But PGT_CACHE(0) doesn&#39;t exist (yet).

Looking once more, that might not really be needed I think. I&#39;ll rework 
it and see what I can achieve.

Christophe

---
L&#39;absence de virus dans ce courrier électronique a été vérifiée par le logiciel antivirus Avast.
https://www.avast.com/antivirus
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1141">Aneesh Kumar K.V</a> - Aug. 15, 2016, 10:23 a.m.</div>
<pre class="content">
christophe leroy &lt;christophe.leroy@c-s.fr&gt; writes:
<span class="quote">
&gt; Le 14/08/2016 à 16:17, Aneesh Kumar K.V a écrit :</span>
<span class="quote">&gt;&gt; Christophe Leroy &lt;christophe.leroy@c-s.fr&gt; writes:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Today powerpc64 uses a set of pgtable_caches while powerpc32 uses</span>
<span class="quote">&gt;&gt;&gt; standard pages when using 4k pages and a single pgtable_cache</span>
<span class="quote">&gt;&gt;&gt; if using other size pages. In addition powerpc32 uses another cache</span>
<span class="quote">&gt;&gt;&gt; when handling huge pages.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; In preparation of implementing huge pages on the 8xx, this patch</span>
<span class="quote">&gt;&gt;&gt; replaces the specific powerpc32 handling by the 64 bits approach.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Why is this needed ? Can you also summarize the page size used and the</span>
<span class="quote">&gt;&gt; hugepage format you are planning to use ? . What are the page sizes</span>
<span class="quote">&gt;&gt; supported by 8xx ? Also is the new code copy of existing powerpc64 4k</span>
<span class="quote">&gt;&gt; page size code ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 8xx supports two huge page sizes: 8M and 512k.</span>
<span class="quote">&gt; As PGD entries points on 4M page tables, it means we are in an </span>
<span class="quote">&gt; eterogenous situation:</span>
<span class="quote">&gt; 1/ when using 8M huge pages, we are in the same situation as what is </span>
<span class="quote">&gt; done for the BOOK3S (which supports 16M, 256M and 1G), that is several </span>
<span class="quote">&gt; PDG entries pointing to a single PTE entry.</span>

what is done for FSL BOOK3E ?
<span class="quote">

&gt; 2/ when using 512k huge pages, we are in the same situation as whan is </span>
<span class="quote">&gt; done for the BOOK3E: a PGD entry points to the hugepage table that </span>
<span class="quote">&gt; handles several huge pages (in our case 8 huge pages)</span>
<span class="quote">&gt;</span>

what is done for Book3s with 4K linux page size. ?


So the idea here is to allocate different hugepte table based on
hugepage size requested and hence the need to switch from hugpte-cache
to a more generic PGT_CACHE ?
<span class="quote">
&gt; The code from init_64 have been moved to a new file named init-common in </span>
<span class="quote">&gt; order to be used by init_32 too.</span>
<span class="quote">&gt; The code from the 64 bits .h has been copied into the 32 bits .h (indeed </span>
<span class="quote">&gt; it&#39;s been copied twice as the .h are now duplicated into nohash and </span>
<span class="quote">&gt; book3s versions)</span>


That explanation made it a lot easy to follow the patch. Can we capture
that in commit message too. Also Do we support hugepage with both 4k and
16K linux page size ?. I guess we do because 8xx only do a two level
linux page table ? 
<span class="quote">
&gt;</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;&gt; diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt;&gt;&gt; index 7372ee1..9164a77 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="quote">&gt;&gt;&gt; @@ -68,7 +68,7 @@ static int __hugepte_alloc(struct mm_struct *mm, hugepd_t *hpdp,</span>
<span class="quote">&gt;&gt;&gt;  #ifdef CONFIG_PPC_FSL_BOOK3E</span>
<span class="quote">&gt;&gt;&gt;  	int i;</span>
<span class="quote">&gt;&gt;&gt;  	int num_hugepd = 1 &lt;&lt; (pshift - pdshift);</span>
<span class="quote">&gt;&gt;&gt; -	cachep = hugepte_cache;</span>
<span class="quote">&gt;&gt;&gt; +	cachep = PGT_CACHE(1);</span>
<span class="quote">&gt;&gt;&gt;  #else</span>
<span class="quote">&gt;&gt;&gt;  	cachep = PGT_CACHE(pdshift - pshift);</span>
<span class="quote">&gt;&gt;&gt;  #endif</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Can you explain the usage of PGT_CACHE(1) ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I still didn&#39;t quiet follow why we are replacing</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  -	hugepte_cache =  kmem_cache_create(&quot;hugepte-cache&quot;, sizeof(pte_t),</span>
<span class="quote">&gt;&gt;  -					   HUGEPD_SHIFT_MASK + 1, 0, NULL);</span>
<span class="quote">&gt;&gt;  +	pgtable_cache_add(1, NULL);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Euh ... Indeed I wanted something to replace hugepte_cache. But it looks </span>
<span class="quote">&gt; like it should be something like PGT_CACHE(0) for 32 bits targets having </span>
<span class="quote">&gt; 32 bits PTEs and PGT_CACHE(1) for 32 bits targets having 64 bits PTEs. </span>
<span class="quote">&gt; But PGT_CACHE(0) doesn&#39;t exist (yet).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Looking once more, that might not really be needed I think. I&#39;ll rework </span>
<span class="quote">&gt; it and see what I can achieve.</span>
<span class="quote">&gt;</span>

Thanks
-aneesh
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/32/pgalloc.h b/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="p_header">index 8e21bb4..ab215fd 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/32/pgalloc.h</span>
<span class="p_chunk">@@ -2,14 +2,42 @@</span> <span class="p_context"></span>
 #define _ASM_POWERPC_BOOK3S_32_PGALLOC_H
 
 #include &lt;linux/threads.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 
<span class="p_del">-/* For 32-bit, all levels of page tables are just drawn from get_free_page() */</span>
<span class="p_del">-#define MAX_PGTABLE_INDEX_SIZE	0</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Functions that deal with pagetables that could be at any level of</span>
<span class="p_add">+ * the table need to be passed an &quot;index_size&quot; so they know how to</span>
<span class="p_add">+ * handle allocation.  For PTE pages (which are linked to a struct</span>
<span class="p_add">+ * page for now, and drawn from the main get_free_pages() pool), the</span>
<span class="p_add">+ * allocation size will be (2^index_size * sizeof(pointer)) and</span>
<span class="p_add">+ * allocations are drawn from the kmem_cache in PGT_CACHE(index_size).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The maximum index size needs to be big enough to allow any</span>
<span class="p_add">+ * pagetable sizes we need, but small enough to fit in the low bits of</span>
<span class="p_add">+ * any page table pointer.  In other words all pagetables, even tiny</span>
<span class="p_add">+ * ones, must be aligned to allow at least enough low 0 bits to</span>
<span class="p_add">+ * contain this value.  This value is also used as a mask, so it must</span>
<span class="p_add">+ * be one less than a power of two.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MAX_PGTABLE_INDEX_SIZE	0xf</span>
 
 extern void __bad_pte(pmd_t *pmd);
 
<span class="p_del">-extern pgd_t *pgd_alloc(struct mm_struct *mm);</span>
<span class="p_del">-extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);</span>
<span class="p_add">+extern struct kmem_cache *pgtable_cache[];</span>
<span class="p_add">+#define PGT_CACHE(shift) ({				\</span>
<span class="p_add">+			BUG_ON(!(shift));		\</span>
<span class="p_add">+			pgtable_cache[(shift) - 1];	\</span>
<span class="p_add">+		})</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kmem_cache_alloc(PGT_CACHE(PGD_INDEX_SIZE), GFP_KERNEL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kmem_cache_free(PGT_CACHE(PGD_INDEX_SIZE), pgd);</span>
<span class="p_add">+}</span>
 
 /*
  * We don&#39;t have any real pmd&#39;s, and this code never triggers because
<span class="p_chunk">@@ -68,8 +96,12 @@</span> <span class="p_context"> static inline void pte_free(struct mm_struct *mm, pgtable_t ptepage)</span>
 
 static inline void pgtable_free(void *table, unsigned index_size)
 {
<span class="p_del">-	BUG_ON(index_size); /* 32-bit doesn&#39;t use this */</span>
<span class="p_del">-	free_page((unsigned long)table);</span>
<span class="p_add">+	if (!index_size)</span>
<span class="p_add">+		free_page((unsigned long)table);</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		BUG_ON(index_size &gt; MAX_PGTABLE_INDEX_SIZE);</span>
<span class="p_add">+		kmem_cache_free(PGT_CACHE(index_size), table);</span>
<span class="p_add">+	}</span>
 }
 
 #define check_pgt_cache()	do { } while (0)
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/32/pgtable.h b/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="p_header">index 38b33dc..83a2159 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/32/pgtable.h</span>
<span class="p_chunk">@@ -8,6 +8,26 @@</span> <span class="p_context"></span>
 /* And here we include common definitions */
 #include &lt;asm/pte-common.h&gt;
 
<span class="p_add">+#define PTE_INDEX_SIZE	PTE_SHIFT</span>
<span class="p_add">+#define PMD_INDEX_SIZE	0</span>
<span class="p_add">+#define PUD_INDEX_SIZE	0</span>
<span class="p_add">+#define PGD_INDEX_SIZE	(32 - PGDIR_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PMD_CACHE_INDEX	PMD_INDEX_SIZE</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PMD_TABLE_SIZE	(sizeof(pmd_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PUD_TABLE_SIZE	(sizeof(pud_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+#endif	/* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define PTRS_PER_PTE	(1 &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PTRS_PER_PGD	(1 &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+/* With 4k base page size, hugepage PTEs go at the PMD level */</span>
<span class="p_add">+#define MIN_HUGEPTE_SHIFT	PMD_SHIFT</span>
<span class="p_add">+</span>
 /*
  * The normal case is that PTEs are 32-bits and we have a 1-page
  * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus
<span class="p_chunk">@@ -19,14 +39,10 @@</span> <span class="p_context"></span>
  * -Matt
  */
 /* PGDIR_SHIFT determines what a top-level page table entry can map */
<span class="p_del">-#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_SHIFT)</span>
<span class="p_add">+#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_INDEX_SIZE)</span>
 #define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
<span class="p_del">-#define PTRS_PER_PTE	(1 &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PTRS_PER_PMD	1</span>
<span class="p_del">-#define PTRS_PER_PGD	(1 &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_del">-</span>
 #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
 /*
  * This is the bottom of the PKMAP area with HIGHMEM or an arbitrary
<span class="p_chunk">@@ -82,12 +98,8 @@</span> <span class="p_context"></span>
 
 extern unsigned long ioremap_bot;
 
<span class="p_del">-/*</span>
<span class="p_del">- * entries per page directory level: our page-table tree is two-level, so</span>
<span class="p_del">- * we don&#39;t really have any PMD directory.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_add">+/* Bits to mask out from a PGD to get to the PUD page */</span>
<span class="p_add">+#define PGD_MASKED_BITS		0</span>
 
 #define pte_ERROR(e) \
 	pr_err(&quot;%s:%d: bad pte %llx.\n&quot;, __FILE__, __LINE__, \
<span class="p_chunk">@@ -282,15 +294,6 @@</span> <span class="p_context"> static inline void __ptep_set_access_flags(pte_t *ptep, pte_t entry)</span>
 #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 3 })
 #define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 3 })
 
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-/*</span>
<span class="p_del">- * No page table caches to initialise</span>
<span class="p_del">- */</span>
<span class="p_del">-#define pgtable_cache_init()	do { } while (0)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 extern int get_pteptr(struct mm_struct *mm, unsigned long addr, pte_t **ptep,
 		      pmd_t **pmdp);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/64/pgtable.h b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_header">index 263bf39..3f85d43 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_chunk">@@ -786,9 +786,6 @@</span> <span class="p_context"> extern struct page *pgd_page(pgd_t pgd);</span>
 #define pgd_ERROR(e) \
 	pr_err(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, pgd_val(e))
 
<span class="p_del">-void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
<span class="p_del">-</span>
 static inline int map_kernel_page(unsigned long ea, unsigned long pa,
 				  unsigned long flags)
 {
<span class="p_header">diff --git a/arch/powerpc/include/asm/hugetlb.h b/arch/powerpc/include/asm/hugetlb.h</span>
<span class="p_header">index c5517f4..c201cd6 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -5,8 +5,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm-generic/hugetlb.h&gt;
 
<span class="p_del">-extern struct kmem_cache *hugepte_cache;</span>
<span class="p_del">-</span>
 #ifdef CONFIG_PPC_BOOK3S_64
 
 #include &lt;asm/book3s/64/hugetlb-radix.h&gt;
<span class="p_header">diff --git a/arch/powerpc/include/asm/nohash/32/pgalloc.h b/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="p_header">index 76d6b9e..c2fe85c 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/nohash/32/pgalloc.h</span>
<span class="p_chunk">@@ -2,14 +2,42 @@</span> <span class="p_context"></span>
 #define _ASM_POWERPC_PGALLOC_32_H
 
 #include &lt;linux/threads.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 
<span class="p_del">-/* For 32-bit, all levels of page tables are just drawn from get_free_page() */</span>
<span class="p_del">-#define MAX_PGTABLE_INDEX_SIZE	0</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Functions that deal with pagetables that could be at any level of</span>
<span class="p_add">+ * the table need to be passed an &quot;index_size&quot; so they know how to</span>
<span class="p_add">+ * handle allocation.  For PTE pages (which are linked to a struct</span>
<span class="p_add">+ * page for now, and drawn from the main get_free_pages() pool), the</span>
<span class="p_add">+ * allocation size will be (2^index_size * sizeof(pointer)) and</span>
<span class="p_add">+ * allocations are drawn from the kmem_cache in PGT_CACHE(index_size).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The maximum index size needs to be big enough to allow any</span>
<span class="p_add">+ * pagetable sizes we need, but small enough to fit in the low bits of</span>
<span class="p_add">+ * any page table pointer.  In other words all pagetables, even tiny</span>
<span class="p_add">+ * ones, must be aligned to allow at least enough low 0 bits to</span>
<span class="p_add">+ * contain this value.  This value is also used as a mask, so it must</span>
<span class="p_add">+ * be one less than a power of two.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MAX_PGTABLE_INDEX_SIZE	0xf</span>
 
 extern void __bad_pte(pmd_t *pmd);
 
<span class="p_del">-extern pgd_t *pgd_alloc(struct mm_struct *mm);</span>
<span class="p_del">-extern void pgd_free(struct mm_struct *mm, pgd_t *pgd);</span>
<span class="p_add">+extern struct kmem_cache *pgtable_cache[];</span>
<span class="p_add">+#define PGT_CACHE(shift) ({				\</span>
<span class="p_add">+			BUG_ON(!(shift));		\</span>
<span class="p_add">+			pgtable_cache[(shift) - 1];	\</span>
<span class="p_add">+		})</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kmem_cache_alloc(PGT_CACHE(PGD_INDEX_SIZE), GFP_KERNEL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kmem_cache_free(PGT_CACHE(PGD_INDEX_SIZE), pgd);</span>
<span class="p_add">+}</span>
 
 /*
  * We don&#39;t have any real pmd&#39;s, and this code never triggers because
<span class="p_chunk">@@ -68,8 +96,12 @@</span> <span class="p_context"> static inline void pte_free(struct mm_struct *mm, pgtable_t ptepage)</span>
 
 static inline void pgtable_free(void *table, unsigned index_size)
 {
<span class="p_del">-	BUG_ON(index_size); /* 32-bit doesn&#39;t use this */</span>
<span class="p_del">-	free_page((unsigned long)table);</span>
<span class="p_add">+	if (!index_size)</span>
<span class="p_add">+		free_page((unsigned long)table);</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		BUG_ON(index_size &gt; MAX_PGTABLE_INDEX_SIZE);</span>
<span class="p_add">+		kmem_cache_free(PGT_CACHE(index_size), table);</span>
<span class="p_add">+	}</span>
 }
 
 #define check_pgt_cache()	do { } while (0)
<span class="p_header">diff --git a/arch/powerpc/include/asm/nohash/32/pgtable.h b/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="p_header">index 7808475..8a2937d 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/nohash/32/pgtable.h</span>
<span class="p_chunk">@@ -16,6 +16,26 @@</span> <span class="p_context"> extern int icache_44x_need_flush;</span>
 
 #endif /* __ASSEMBLY__ */
 
<span class="p_add">+#define PTE_INDEX_SIZE	PTE_SHIFT</span>
<span class="p_add">+#define PMD_INDEX_SIZE	0</span>
<span class="p_add">+#define PUD_INDEX_SIZE	0</span>
<span class="p_add">+#define PGD_INDEX_SIZE	(32 - PGDIR_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PMD_CACHE_INDEX	PMD_INDEX_SIZE</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PMD_TABLE_SIZE	(sizeof(pmd_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PUD_TABLE_SIZE	(sizeof(pud_t) &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+#endif	/* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define PTRS_PER_PTE	(1 &lt;&lt; PTE_INDEX_SIZE)</span>
<span class="p_add">+#define PTRS_PER_PGD	(1 &lt;&lt; PGD_INDEX_SIZE)</span>
<span class="p_add">+</span>
<span class="p_add">+/* With 4k base page size, hugepage PTEs go at the PMD level */</span>
<span class="p_add">+#define MIN_HUGEPTE_SHIFT	PMD_SHIFT</span>
<span class="p_add">+</span>
 /*
  * The normal case is that PTEs are 32-bits and we have a 1-page
  * 1024-entry pgdir pointing to 1-page 1024-entry PTE pages.  -- paulus
<span class="p_chunk">@@ -27,22 +47,12 @@</span> <span class="p_context"> extern int icache_44x_need_flush;</span>
  * -Matt
  */
 /* PGDIR_SHIFT determines what a top-level page table entry can map */
<span class="p_del">-#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_SHIFT)</span>
<span class="p_add">+#define PGDIR_SHIFT	(PAGE_SHIFT + PTE_INDEX_SIZE)</span>
 #define PGDIR_SIZE	(1UL &lt;&lt; PGDIR_SHIFT)
 #define PGDIR_MASK	(~(PGDIR_SIZE-1))
 
<span class="p_del">-/*</span>
<span class="p_del">- * entries per page directory level: our page-table tree is two-level, so</span>
<span class="p_del">- * we don&#39;t really have any PMD directory.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifndef __ASSEMBLY__</span>
<span class="p_del">-#define PTE_TABLE_SIZE	(sizeof(pte_t) &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PGD_TABLE_SIZE	(sizeof(pgd_t) &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_del">-#endif	/* __ASSEMBLY__ */</span>
<span class="p_del">-</span>
<span class="p_del">-#define PTRS_PER_PTE	(1 &lt;&lt; PTE_SHIFT)</span>
<span class="p_del">-#define PTRS_PER_PMD	1</span>
<span class="p_del">-#define PTRS_PER_PGD	(1 &lt;&lt; (32 - PGDIR_SHIFT))</span>
<span class="p_add">+/* Bits to mask out from a PGD to get to the PUD page */</span>
<span class="p_add">+#define PGD_MASKED_BITS		0</span>
 
 #define USER_PTRS_PER_PGD	(TASK_SIZE / PGDIR_SIZE)
 #define FIRST_USER_ADDRESS	0UL
<span class="p_chunk">@@ -327,15 +337,6 @@</span> <span class="p_context"> static inline void __ptep_set_access_flags(pte_t *ptep, pte_t entry)</span>
 #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val(pte) &gt;&gt; 3 })
 #define __swp_entry_to_pte(x)		((pte_t) { (x).val &lt;&lt; 3 })
 
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
<span class="p_del">-#else</span>
<span class="p_del">-/*</span>
<span class="p_del">- * No page table caches to initialise</span>
<span class="p_del">- */</span>
<span class="p_del">-#define pgtable_cache_init()	do { } while (0)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 extern int get_pteptr(struct mm_struct *mm, unsigned long addr, pte_t **ptep,
 		      pmd_t **pmdp);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/nohash/64/pgtable.h b/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="p_header">index d4d808c..b0fc9e4 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/nohash/64/pgtable.h</span>
<span class="p_chunk">@@ -357,8 +357,6 @@</span> <span class="p_context"> static inline void __ptep_set_access_flags(pte_t *ptep, pte_t entry)</span>
 #define __pte_to_swp_entry(pte)		((swp_entry_t) { pte_val((pte)) })
 #define __swp_entry_to_pte(x)		__pte((x).val)
 
<span class="p_del">-void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="p_del">-void pgtable_cache_init(void);</span>
 extern int map_kernel_page(unsigned long ea, unsigned long pa,
 			   unsigned long flags);
 extern int __meminit vmemmap_create_mapping(unsigned long start,
<span class="p_header">diff --git a/arch/powerpc/include/asm/pgtable.h b/arch/powerpc/include/asm/pgtable.h</span>
<span class="p_header">index 9bd87f2..dd01212 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -78,6 +78,8 @@</span> <span class="p_context"> static inline pte_t *find_linux_pte_or_hugepte(pgd_t *pgdir, unsigned long ea,</span>
 
 unsigned long vmalloc_to_phys(void *vmalloc_addr);
 
<span class="p_add">+void pgtable_cache_add(unsigned shift, void (*ctor)(void *));</span>
<span class="p_add">+void pgtable_cache_init(void);</span>
 #endif /* __ASSEMBLY__ */
 
 #endif /* _ASM_POWERPC_PGTABLE_H */
<span class="p_header">diff --git a/arch/powerpc/mm/Makefile b/arch/powerpc/mm/Makefile</span>
<span class="p_header">index f2cea6d..08bb010 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/Makefile</span>
<span class="p_header">+++ b/arch/powerpc/mm/Makefile</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"> subdir-ccflags-$(CONFIG_PPC_WERROR) := -Werror</span>
 ccflags-$(CONFIG_PPC64)	:= $(NO_MINIMAL_TOC)
 
 obj-y				:= fault.o mem.o pgtable.o mmap.o \
<span class="p_del">-				   init_$(CONFIG_WORD_SIZE).o \</span>
<span class="p_add">+				   init_$(CONFIG_WORD_SIZE).o init-common.o \</span>
 				   pgtable_$(CONFIG_WORD_SIZE).o
 obj-$(CONFIG_PPC_MMU_NOHASH)	+= mmu_context_nohash.o tlb_nohash.o \
 				   tlb_nohash_low.o
<span class="p_header">diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_header">index 7372ee1..9164a77 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> static int __hugepte_alloc(struct mm_struct *mm, hugepd_t *hpdp,</span>
 #ifdef CONFIG_PPC_FSL_BOOK3E
 	int i;
 	int num_hugepd = 1 &lt;&lt; (pshift - pdshift);
<span class="p_del">-	cachep = hugepte_cache;</span>
<span class="p_add">+	cachep = PGT_CACHE(1);</span>
 #else
 	cachep = PGT_CACHE(pdshift - pshift);
 #endif
<span class="p_chunk">@@ -411,7 +411,7 @@</span> <span class="p_context"> static void hugepd_free_rcu_callback(struct rcu_head *head)</span>
 	unsigned int i;
 
 	for (i = 0; i &lt; batch-&gt;index; i++)
<span class="p_del">-		kmem_cache_free(hugepte_cache, batch-&gt;ptes[i]);</span>
<span class="p_add">+		kmem_cache_free(PGT_CACHE(1), batch-&gt;ptes[i]);</span>
 
 	free_page((unsigned long)batch);
 }
<span class="p_chunk">@@ -425,7 +425,7 @@</span> <span class="p_context"> static void hugepd_free(struct mmu_gather *tlb, void *hugepte)</span>
 	if (atomic_read(&amp;tlb-&gt;mm-&gt;mm_users) &lt; 2 ||
 	    cpumask_equal(mm_cpumask(tlb-&gt;mm),
 			  cpumask_of(smp_processor_id()))) {
<span class="p_del">-		kmem_cache_free(hugepte_cache, hugepte);</span>
<span class="p_add">+		kmem_cache_free(PGT_CACHE(1), hugepte);</span>
 		put_cpu_var(hugepd_freelist_cur);
 		return;
 	}
<span class="p_chunk">@@ -792,7 +792,6 @@</span> <span class="p_context"> static int __init hugepage_setup_sz(char *str)</span>
 __setup(&quot;hugepagesz=&quot;, hugepage_setup_sz);
 
 #ifdef CONFIG_PPC_FSL_BOOK3E
<span class="p_del">-struct kmem_cache *hugepte_cache;</span>
 static int __init hugetlbpage_init(void)
 {
 	int psize;
<span class="p_chunk">@@ -815,9 +814,8 @@</span> <span class="p_context"> static int __init hugetlbpage_init(void)</span>
 	 * Create a kmem cache for hugeptes.  The bottom bits in the pte have
 	 * size information encoded in them, so align them to allow this
 	 */
<span class="p_del">-	hugepte_cache =  kmem_cache_create(&quot;hugepte-cache&quot;, sizeof(pte_t),</span>
<span class="p_del">-					   HUGEPD_SHIFT_MASK + 1, 0, NULL);</span>
<span class="p_del">-	if (hugepte_cache == NULL)</span>
<span class="p_add">+	pgtable_cache_add(1, NULL);</span>
<span class="p_add">+	if (!PGT_CACHE(1))</span>
 		panic(&quot;%s: Unable to create kmem cache for hugeptes\n&quot;,
 		      __func__);
 
<span class="p_header">diff --git a/arch/powerpc/mm/init-common.c b/arch/powerpc/mm/init-common.c</span>
new file mode 100644
<span class="p_header">index 0000000..2632eab</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/powerpc/mm/init-common.c</span>
<span class="p_chunk">@@ -0,0 +1,152 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ *  PowerPC version</span>
<span class="p_add">+ *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Modifications by Paul Mackerras (PowerMac) (paulus@cs.anu.edu.au)</span>
<span class="p_add">+ *  and Cort Dougan (PReP) (cort@cs.nmt.edu)</span>
<span class="p_add">+ *    Copyright (C) 1996 Paul Mackerras</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Derived from &quot;arch/i386/mm/init.c&quot;</span>
<span class="p_add">+ *    Copyright (C) 1991, 1992, 1993, 1994  Linus Torvalds</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Dave Engebretsen &lt;engebret@us.ibm.com&gt;</span>
<span class="p_add">+ *      Rework for PPC64 port.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *  modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *  as published by the Free Software Foundation; either version</span>
<span class="p_add">+ *  2 of the License, or (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#undef DEBUG</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/errno.h&gt;</span>
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;linux/mman.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/swap.h&gt;</span>
<span class="p_add">+#include &lt;linux/stddef.h&gt;</span>
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/highmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/idr.h&gt;</span>
<span class="p_add">+#include &lt;linux/nodemask.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/poison.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/hugetlb.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/pgalloc.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/prom.h&gt;</span>
<span class="p_add">+#include &lt;asm/rtas.h&gt;</span>
<span class="p_add">+#include &lt;asm/io.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu.h&gt;</span>
<span class="p_add">+#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+#include &lt;asm/machdep.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlb.h&gt;</span>
<span class="p_add">+#include &lt;asm/eeh.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmzone.h&gt;</span>
<span class="p_add">+#include &lt;asm/cputable.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/iommu.h&gt;</span>
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;mmu_decl.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+phys_addr_t memstart_addr = (phys_addr_t)~0ull;</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(memstart_addr);</span>
<span class="p_add">+phys_addr_t kernstart_addr;</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(kernstart_addr);</span>
<span class="p_add">+</span>
<span class="p_add">+static void pgd_ctor(void *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset(addr, 0, PGD_TABLE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pud_ctor(void *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset(addr, 0, PUD_TABLE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void pmd_ctor(void *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset(addr, 0, PMD_TABLE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct kmem_cache *pgtable_cache[MAX_PGTABLE_INDEX_SIZE];</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Create a kmem_cache() for pagetables.  This is not used for PTE</span>
<span class="p_add">+ * pages - they&#39;re linked to struct page, come from the normal free</span>
<span class="p_add">+ * pages pool and have a different entry size (see real_pte_t) to</span>
<span class="p_add">+ * everything else.  Caches created by this function are used for all</span>
<span class="p_add">+ * the higher level pagetables, and for hugepage pagetables.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void pgtable_cache_add(unsigned shift, void (*ctor)(void *))</span>
<span class="p_add">+{</span>
<span class="p_add">+	char *name;</span>
<span class="p_add">+	unsigned long table_size = sizeof(void *) &lt;&lt; shift;</span>
<span class="p_add">+	unsigned long align = table_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* When batching pgtable pointers for RCU freeing, we store</span>
<span class="p_add">+	 * the index size in the low bits.  Table alignment must be</span>
<span class="p_add">+	 * big enough to fit it.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Likewise, hugeapge pagetable pointers contain a (different)</span>
<span class="p_add">+	 * shift value in the low bits.  All tables must be aligned so</span>
<span class="p_add">+	 * as to leave enough 0 bits in the address to contain it. */</span>
<span class="p_add">+	unsigned long minalign = max(MAX_PGTABLE_INDEX_SIZE + 1,</span>
<span class="p_add">+				     HUGEPD_SHIFT_MASK + 1);</span>
<span class="p_add">+	struct kmem_cache *new;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It would be nice if this was a BUILD_BUG_ON(), but at the</span>
<span class="p_add">+	 * moment, gcc doesn&#39;t seem to recognize is_power_of_2 as a</span>
<span class="p_add">+	 * constant expression, so so much for that. */</span>
<span class="p_add">+	BUG_ON(!is_power_of_2(minalign));</span>
<span class="p_add">+	BUG_ON((shift &lt; 1) || (shift &gt; MAX_PGTABLE_INDEX_SIZE));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PGT_CACHE(shift))</span>
<span class="p_add">+		return; /* Already have a cache of this size */</span>
<span class="p_add">+</span>
<span class="p_add">+	align = max_t(unsigned long, align, minalign);</span>
<span class="p_add">+	name = kasprintf(GFP_KERNEL, &quot;pgtable-2^%d&quot;, shift);</span>
<span class="p_add">+	new = kmem_cache_create(name, table_size, align, 0, ctor);</span>
<span class="p_add">+	kfree(name);</span>
<span class="p_add">+	pgtable_cache[shift - 1] = new;</span>
<span class="p_add">+	pr_debug(&quot;Allocated pgtable cache for order %d\n&quot;, shift);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void pgtable_cache_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgtable_cache_add(PGD_INDEX_SIZE, pgd_ctor);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (PMD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PMD_INDEX_SIZE))</span>
<span class="p_add">+		pgtable_cache_add(PMD_CACHE_INDEX, pmd_ctor);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In all current configs, when the PUD index exists it&#39;s the</span>
<span class="p_add">+	 * same size as either the pgd or pmd index except with THP enabled</span>
<span class="p_add">+	 * on book3s 64</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_add">+		pgtable_cache_add(PUD_INDEX_SIZE, pud_ctor);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!PGT_CACHE(PGD_INDEX_SIZE))</span>
<span class="p_add">+		panic(&quot;Couldn&#39;t allocate pgd cache&quot;);</span>
<span class="p_add">+	if (PMD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PMD_INDEX_SIZE))</span>
<span class="p_add">+		panic(&quot;Couldn&#39;t allocate pmd pgtable caches&quot;);</span>
<span class="p_add">+	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_add">+		panic(&quot;Couldn&#39;t allocate pud pgtable caches&quot;);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/powerpc/mm/init_32.c b/arch/powerpc/mm/init_32.c</span>
<span class="p_header">index 448685f..79c24d4 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/init_32.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/init_32.c</span>
<span class="p_chunk">@@ -59,11 +59,6 @@</span> <span class="p_context"></span>
 phys_addr_t total_memory;
 phys_addr_t total_lowmem;
 
<span class="p_del">-phys_addr_t memstart_addr = (phys_addr_t)~0ull;</span>
<span class="p_del">-EXPORT_SYMBOL(memstart_addr);</span>
<span class="p_del">-phys_addr_t kernstart_addr;</span>
<span class="p_del">-EXPORT_SYMBOL(kernstart_addr);</span>
<span class="p_del">-</span>
 #ifdef CONFIG_RELOCATABLE
 /* Used in __va()/__pa() */
 long long virt_phys_offset;
<span class="p_header">diff --git a/arch/powerpc/mm/init_64.c b/arch/powerpc/mm/init_64.c</span>
<span class="p_header">index 16ada1e..4acd546 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/init_64.c</span>
<span class="p_chunk">@@ -75,88 +75,6 @@</span> <span class="p_context"></span>
 #endif
 #endif /* CONFIG_PPC_STD_MMU_64 */
 
<span class="p_del">-phys_addr_t memstart_addr = ~0;</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(memstart_addr);</span>
<span class="p_del">-phys_addr_t kernstart_addr;</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(kernstart_addr);</span>
<span class="p_del">-</span>
<span class="p_del">-static void pgd_ctor(void *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	memset(addr, 0, PGD_TABLE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pud_ctor(void *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	memset(addr, 0, PUD_TABLE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pmd_ctor(void *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	memset(addr, 0, PMD_TABLE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-struct kmem_cache *pgtable_cache[MAX_PGTABLE_INDEX_SIZE];</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Create a kmem_cache() for pagetables.  This is not used for PTE</span>
<span class="p_del">- * pages - they&#39;re linked to struct page, come from the normal free</span>
<span class="p_del">- * pages pool and have a different entry size (see real_pte_t) to</span>
<span class="p_del">- * everything else.  Caches created by this function are used for all</span>
<span class="p_del">- * the higher level pagetables, and for hugepage pagetables.</span>
<span class="p_del">- */</span>
<span class="p_del">-void pgtable_cache_add(unsigned shift, void (*ctor)(void *))</span>
<span class="p_del">-{</span>
<span class="p_del">-	char *name;</span>
<span class="p_del">-	unsigned long table_size = sizeof(void *) &lt;&lt; shift;</span>
<span class="p_del">-	unsigned long align = table_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* When batching pgtable pointers for RCU freeing, we store</span>
<span class="p_del">-	 * the index size in the low bits.  Table alignment must be</span>
<span class="p_del">-	 * big enough to fit it.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Likewise, hugeapge pagetable pointers contain a (different)</span>
<span class="p_del">-	 * shift value in the low bits.  All tables must be aligned so</span>
<span class="p_del">-	 * as to leave enough 0 bits in the address to contain it. */</span>
<span class="p_del">-	unsigned long minalign = max(MAX_PGTABLE_INDEX_SIZE + 1,</span>
<span class="p_del">-				     HUGEPD_SHIFT_MASK + 1);</span>
<span class="p_del">-	struct kmem_cache *new;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* It would be nice if this was a BUILD_BUG_ON(), but at the</span>
<span class="p_del">-	 * moment, gcc doesn&#39;t seem to recognize is_power_of_2 as a</span>
<span class="p_del">-	 * constant expression, so so much for that. */</span>
<span class="p_del">-	BUG_ON(!is_power_of_2(minalign));</span>
<span class="p_del">-	BUG_ON((shift &lt; 1) || (shift &gt; MAX_PGTABLE_INDEX_SIZE));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (PGT_CACHE(shift))</span>
<span class="p_del">-		return; /* Already have a cache of this size */</span>
<span class="p_del">-</span>
<span class="p_del">-	align = max_t(unsigned long, align, minalign);</span>
<span class="p_del">-	name = kasprintf(GFP_KERNEL, &quot;pgtable-2^%d&quot;, shift);</span>
<span class="p_del">-	new = kmem_cache_create(name, table_size, align, 0, ctor);</span>
<span class="p_del">-	kfree(name);</span>
<span class="p_del">-	pgtable_cache[shift - 1] = new;</span>
<span class="p_del">-	pr_debug(&quot;Allocated pgtable cache for order %d\n&quot;, shift);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-void pgtable_cache_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgtable_cache_add(PGD_INDEX_SIZE, pgd_ctor);</span>
<span class="p_del">-	pgtable_cache_add(PMD_CACHE_INDEX, pmd_ctor);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * In all current configs, when the PUD index exists it&#39;s the</span>
<span class="p_del">-	 * same size as either the pgd or pmd index except with THP enabled</span>
<span class="p_del">-	 * on book3s 64</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_del">-		pgtable_cache_add(PUD_INDEX_SIZE, pud_ctor);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!PGT_CACHE(PGD_INDEX_SIZE) || !PGT_CACHE(PMD_CACHE_INDEX))</span>
<span class="p_del">-		panic(&quot;Couldn&#39;t allocate pgtable caches&quot;);</span>
<span class="p_del">-	if (PUD_INDEX_SIZE &amp;&amp; !PGT_CACHE(PUD_INDEX_SIZE))</span>
<span class="p_del">-		panic(&quot;Couldn&#39;t allocate pud pgtable caches&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_SPARSEMEM_VMEMMAP
 /*
  * Given an address within the vmemmap, determine the pfn of the page that
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">index 0ae0572..a65c0b4 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_chunk">@@ -42,43 +42,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(ioremap_bot);	/* aka VMALLOC_END */</span>
 
 extern char etext[], _stext[], _sinittext[], _einittext[];
 
<span class="p_del">-#define PGDIR_ORDER	(32 + PGD_T_LOG2 - PGDIR_SHIFT)</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-static struct kmem_cache *pgtable_cache;</span>
<span class="p_del">-</span>
<span class="p_del">-void pgtable_cache_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgtable_cache = kmem_cache_create(&quot;PGDIR cache&quot;, 1 &lt;&lt; PGDIR_ORDER,</span>
<span class="p_del">-					  1 &lt;&lt; PGDIR_ORDER, 0, NULL);</span>
<span class="p_del">-	if (pgtable_cache == NULL)</span>
<span class="p_del">-		panic(&quot;Couldn&#39;t allocate pgtable caches&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-pgd_t *pgd_alloc(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* pgdir take page or two with 4K pages and a page fraction otherwise */</span>
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-	ret = kmem_cache_alloc(pgtable_cache, GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	ret = (pgd_t *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,</span>
<span class="p_del">-			PGDIR_ORDER - PAGE_SHIFT);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifndef CONFIG_PPC_4K_PAGES</span>
<span class="p_del">-	kmem_cache_free(pgtable_cache, (void *)pgd);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	free_pages((unsigned long)pgd, PGDIR_ORDER - PAGE_SHIFT);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 __ref pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
 {
 	pte_t *pte;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



