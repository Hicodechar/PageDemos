
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.18.74 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.18.74</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 8, 2017, 8:57 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171008085727.GB31132@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9991779/mbox/"
   >mbox</a>
|
   <a href="/patch/9991779/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9991779/">/patch/9991779/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	BEF3D60231 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:57:35 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A22D828650
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:57:35 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 9616028660; Sun,  8 Oct 2017 08:57:35 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DA8A828650
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:57:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753231AbdJHI53 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 8 Oct 2017 04:57:29 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:32860 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751597AbdJHI5U (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 8 Oct 2017 04:57:20 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id E73DF97;
	Sun,  8 Oct 2017 08:57:18 +0000 (UTC)
Date: Sun, 8 Oct 2017 10:57:27 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.18.74
Message-ID: &lt;20171008085727.GB31132@kroah.com&gt;
References: &lt;20171008085719.GA31132@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171008085719.GA31132@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 8, 2017, 8:57 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt b/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt</span>
new file mode 100644
<span class="p_header">index 000000000000..6ec1a880ac18</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt</span>
<span class="p_chunk">@@ -0,0 +1,46 @@</span> <span class="p_context"></span>
<span class="p_add">+THS8135 Video DAC</span>
<span class="p_add">+-----------------</span>
<span class="p_add">+</span>
<span class="p_add">+This is the binding for Texas Instruments THS8135 Video DAC bridge.</span>
<span class="p_add">+</span>
<span class="p_add">+Required properties:</span>
<span class="p_add">+</span>
<span class="p_add">+- compatible: Must be &quot;ti,ths8135&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+Required nodes:</span>
<span class="p_add">+</span>
<span class="p_add">+This device has two video ports. Their connections are modelled using the OF</span>
<span class="p_add">+graph bindings specified in Documentation/devicetree/bindings/graph.txt.</span>
<span class="p_add">+</span>
<span class="p_add">+- Video port 0 for RGB input</span>
<span class="p_add">+- Video port 1 for VGA output</span>
<span class="p_add">+</span>
<span class="p_add">+Example</span>
<span class="p_add">+-------</span>
<span class="p_add">+</span>
<span class="p_add">+vga-bridge {</span>
<span class="p_add">+	compatible = &quot;ti,ths8135&quot;;</span>
<span class="p_add">+	#address-cells = &lt;1&gt;;</span>
<span class="p_add">+	#size-cells = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+	ports {</span>
<span class="p_add">+		#address-cells = &lt;1&gt;;</span>
<span class="p_add">+		#size-cells = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+		port@0 {</span>
<span class="p_add">+			reg = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+			vga_bridge_in: endpoint {</span>
<span class="p_add">+				remote-endpoint = &lt;&amp;lcdc_out_vga&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
<span class="p_add">+		port@1 {</span>
<span class="p_add">+			reg = &lt;1&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+			vga_bridge_out: endpoint {</span>
<span class="p_add">+				remote-endpoint = &lt;&amp;vga_con_in&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+		};</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f5e683464cd4..bece4a07e07a 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 18
<span class="p_del">-SUBLEVEL = 73</span>
<span class="p_add">+SUBLEVEL = 74</span>
 EXTRAVERSION =
 NAME = Diseased Newt
 
<span class="p_header">diff --git a/arch/arm/Kconfig-nommu b/arch/arm/Kconfig-nommu</span>
<span class="p_header">index aed66d5df7f1..b7576349528c 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig-nommu</span>
<span class="p_header">+++ b/arch/arm/Kconfig-nommu</span>
<span class="p_chunk">@@ -34,8 +34,7 @@</span> <span class="p_context"> config PROCESSOR_ID</span>
 	  used instead of the auto-probing which utilizes the register.
 
 config REMAP_VECTORS_TO_RAM
<span class="p_del">-	bool &#39;Install vectors to the beginning of RAM&#39; if DRAM_BASE</span>
<span class="p_del">-	depends on DRAM_BASE</span>
<span class="p_add">+	bool &#39;Install vectors to the beginning of RAM&#39;</span>
 	help
 	  The kernel needs to change the hardware exception vectors.
 	  In nommu mode, the hardware exception vectors are normally
<span class="p_header">diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_header">index 3b46f7ce9ca7..77733b403c09 100644</span>
<span class="p_header">--- a/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> SECTIONS</span>
 	 * Force .bss to 64K alignment so that .bss..swapper_pg_dir
 	 * gets that alignment.	 .sbss should be empty, so there will be
 	 * no holes after __init_end. */
<span class="p_del">-	BSS_SECTION(0, 0x10000, 0)</span>
<span class="p_add">+	BSS_SECTION(0, 0x10000, 8)</span>
 
 	_end = . ;
 
<span class="p_header">diff --git a/arch/parisc/kernel/perf.c b/arch/parisc/kernel/perf.c</span>
<span class="p_header">index ba0c053e25ae..2a2fff407ac4 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/perf.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/perf.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"></span>
  *  the PDC INTRIGUE calls.  This is done to eliminate bugs introduced
  *  in various PDC revisions.  The code is much more maintainable
  *  and reliable this way vs having to debug on every version of PDC
<span class="p_del">- *  on every box. </span>
<span class="p_add">+ *  on every box.</span>
  */
 
 #include &lt;linux/capability.h&gt;
<span class="p_chunk">@@ -195,8 +195,8 @@</span> <span class="p_context"> static int perf_config(uint32_t *image_ptr);</span>
 static int perf_release(struct inode *inode, struct file *file);
 static int perf_open(struct inode *inode, struct file *file);
 static ssize_t perf_read(struct file *file, char __user *buf, size_t cnt, loff_t *ppos);
<span class="p_del">-static ssize_t perf_write(struct file *file, const char __user *buf, size_t count, </span>
<span class="p_del">-	loff_t *ppos);</span>
<span class="p_add">+static ssize_t perf_write(struct file *file, const char __user *buf,</span>
<span class="p_add">+	size_t count, loff_t *ppos);</span>
 static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 static void perf_start_counters(void);
 static int perf_stop_counters(uint32_t *raddr);
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> extern void perf_intrigue_disable_perf_counters (void);</span>
 /*
  * configure:
  *
<span class="p_del">- * Configure the cpu with a given data image.  First turn off the counters, </span>
<span class="p_add">+ * Configure the cpu with a given data image.  First turn off the counters,</span>
  * then download the image, then turn the counters back on.
  */
 static int perf_config(uint32_t *image_ptr)
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> static int perf_config(uint32_t *image_ptr)</span>
 	error = perf_stop_counters(raddr);
 	if (error != 0) {
 		printk(&quot;perf_config: perf_stop_counters = %ld\n&quot;, error);
<span class="p_del">-		return -EINVAL; </span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
 printk(&quot;Preparing to write image\n&quot;);
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> printk(&quot;Preparing to write image\n&quot;);</span>
 	error = perf_write_image((uint64_t *)image_ptr);
 	if (error != 0) {
 		printk(&quot;perf_config: DOWNLOAD = %ld\n&quot;, error);
<span class="p_del">-		return -EINVAL; </span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
 printk(&quot;Preparing to start counters\n&quot;);
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> printk(&quot;Preparing to start counters\n&quot;);</span>
 }
 
 /*
<span class="p_del">- * Open the device and initialize all of its memory.  The device is only </span>
<span class="p_add">+ * Open the device and initialize all of its memory.  The device is only</span>
  * opened once, but can be &quot;queried&quot; by multiple processes that know its
  * file descriptor.
  */
<span class="p_chunk">@@ -298,8 +298,8 @@</span> <span class="p_context"> static ssize_t perf_read(struct file *file, char __user *buf, size_t cnt, loff_t</span>
  * called on the processor that the download should happen
  * on.
  */
<span class="p_del">-static ssize_t perf_write(struct file *file, const char __user *buf, size_t count, </span>
<span class="p_del">-	loff_t *ppos)</span>
<span class="p_add">+static ssize_t perf_write(struct file *file, const char __user *buf,</span>
<span class="p_add">+	size_t count, loff_t *ppos)</span>
 {
 	int err;
 	size_t image_size;
<span class="p_chunk">@@ -307,11 +307,11 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 	uint32_t interface_type;
 	uint32_t test;
 
<span class="p_del">-	if (perf_processor_interface == ONYX_INTF) </span>
<span class="p_add">+	if (perf_processor_interface == ONYX_INTF)</span>
 		image_size = PCXU_IMAGE_SIZE;
<span class="p_del">-	else if (perf_processor_interface == CUDA_INTF) </span>
<span class="p_add">+	else if (perf_processor_interface == CUDA_INTF)</span>
 		image_size = PCXW_IMAGE_SIZE;
<span class="p_del">-	else </span>
<span class="p_add">+	else</span>
 		return -EFAULT;
 
 	if (!capable(CAP_SYS_ADMIN))
<span class="p_chunk">@@ -331,22 +331,22 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 
 	/* First check the machine type is correct for
 	   the requested image */
<span class="p_del">-        if (((perf_processor_interface == CUDA_INTF) &amp;&amp;</span>
<span class="p_del">-		       (interface_type != CUDA_INTF)) ||</span>
<span class="p_del">-	    ((perf_processor_interface == ONYX_INTF) &amp;&amp;</span>
<span class="p_del">-	               (interface_type != ONYX_INTF))) </span>
<span class="p_add">+	if (((perf_processor_interface == CUDA_INTF) &amp;&amp;</span>
<span class="p_add">+			(interface_type != CUDA_INTF)) ||</span>
<span class="p_add">+		((perf_processor_interface == ONYX_INTF) &amp;&amp;</span>
<span class="p_add">+			(interface_type != ONYX_INTF)))</span>
 		return -EINVAL;
 
 	/* Next check to make sure the requested image
 	   is valid */
<span class="p_del">-	if (((interface_type == CUDA_INTF) &amp;&amp; </span>
<span class="p_add">+	if (((interface_type == CUDA_INTF) &amp;&amp;</span>
 		       (test &gt;= MAX_CUDA_IMAGES)) ||
<span class="p_del">-	    ((interface_type == ONYX_INTF) &amp;&amp; </span>
<span class="p_del">-		       (test &gt;= MAX_ONYX_IMAGES))) </span>
<span class="p_add">+	    ((interface_type == ONYX_INTF) &amp;&amp;</span>
<span class="p_add">+		       (test &gt;= MAX_ONYX_IMAGES)))</span>
 		return -EINVAL;
 
 	/* Copy the image into the processor */
<span class="p_del">-	if (interface_type == CUDA_INTF) </span>
<span class="p_add">+	if (interface_type == CUDA_INTF)</span>
 		return perf_config(cuda_images[test]);
 	else
 		return perf_config(onyx_images[test]);
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 static void perf_patch_images(void)
 {
 #if 0 /* FIXME!! */
<span class="p_del">-/* </span>
<span class="p_add">+/*</span>
  * NOTE:  this routine is VERY specific to the current TLB image.
  * If the image is changed, this routine might also need to be changed.
  */
<span class="p_chunk">@@ -368,9 +368,9 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 	extern void $i_dtlb_miss_2_0();
 	extern void PA2_0_iva();
 
<span class="p_del">-	/* </span>
<span class="p_add">+	/*</span>
 	 * We can only use the lower 32-bits, the upper 32-bits should be 0
<span class="p_del">-	 * anyway given this is in the kernel </span>
<span class="p_add">+	 * anyway given this is in the kernel</span>
 	 */
 	uint32_t itlb_addr  = (uint32_t)&amp;($i_itlb_miss_2_0);
 	uint32_t dtlb_addr  = (uint32_t)&amp;($i_dtlb_miss_2_0);
<span class="p_chunk">@@ -378,21 +378,21 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 	if (perf_processor_interface == ONYX_INTF) {
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[TLBMISS][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[TLBMISS][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[TLBMISS][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[TLBMISS][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
 		onyx_images[TLBMISS][17] = itlb_addr;
 
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[TLBHANDMISS][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[TLBHANDMISS][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[TLBHANDMISS][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[TLBHANDMISS][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
 		onyx_images[TLBHANDMISS][17] = itlb_addr;
 
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[BIG_CPI][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[BIG_CPI][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[BIG_CPI][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[BIG_CPI][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
<span class="p_chunk">@@ -405,24 +405,24 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 	} else if (perf_processor_interface == CUDA_INTF) {
 		/* Cuda interface */
<span class="p_del">-		cuda_images[TLBMISS][16] =  </span>
<span class="p_add">+		cuda_images[TLBMISS][16] =</span>
 			(cuda_images[TLBMISS][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[TLBMISS][17] = </span>
<span class="p_add">+		cuda_images[TLBMISS][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[TLBMISS][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 
<span class="p_del">-		cuda_images[TLBHANDMISS][16] = </span>
<span class="p_add">+		cuda_images[TLBHANDMISS][16] =</span>
 			(cuda_images[TLBHANDMISS][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[TLBHANDMISS][17] = </span>
<span class="p_add">+		cuda_images[TLBHANDMISS][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[TLBHANDMISS][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 
<span class="p_del">-		cuda_images[BIG_CPI][16] = </span>
<span class="p_add">+		cuda_images[BIG_CPI][16] =</span>
 			(cuda_images[BIG_CPI][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[BIG_CPI][17] = </span>
<span class="p_add">+		cuda_images[BIG_CPI][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[BIG_CPI][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 	} else {
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 /*
  * ioctl routine
<span class="p_del">- * All routines effect the processor that they are executed on.  Thus you </span>
<span class="p_add">+ * All routines effect the processor that they are executed on.  Thus you</span>
  * must be running on the processor that you wish to change.
  */
 
<span class="p_chunk">@@ -460,7 +460,7 @@</span> <span class="p_context"> static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 			}
 
 			/* copy out the Counters */
<span class="p_del">-			if (copy_to_user((void __user *)arg, raddr, </span>
<span class="p_add">+			if (copy_to_user((void __user *)arg, raddr,</span>
 					sizeof (raddr)) != 0) {
 				error =  -EFAULT;
 				break;
<span class="p_chunk">@@ -488,7 +488,7 @@</span> <span class="p_context"> static const struct file_operations perf_fops = {</span>
 	.open = perf_open,
 	.release = perf_release
 };
<span class="p_del">-	</span>
<span class="p_add">+</span>
 static struct miscdevice perf_dev = {
 	MISC_DYNAMIC_MINOR,
 	PA_PERF_DEV,
<span class="p_chunk">@@ -595,7 +595,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		/* OR sticky2 (bit 1496) to counter2 bit 32 */
 		tmp64 |= (userbuf[23] &gt;&gt; 8) &amp; 0x0000000080000000;
 		raddr[2] = (uint32_t)tmp64;
<span class="p_del">-		</span>
<span class="p_add">+</span>
 		/* Counter3 is bits 1497 to 1528 */
 		tmp64 =  (userbuf[23] &gt;&gt; 7) &amp; 0x00000000ffffffff;
 		/* OR sticky3 (bit 1529) to counter3 bit 32 */
<span class="p_chunk">@@ -617,7 +617,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		userbuf[22] = 0;
 		userbuf[23] = 0;
 
<span class="p_del">-		/* </span>
<span class="p_add">+		/*</span>
 		 * Write back the zeroed bytes + the image given
 		 * the read was destructive.
 		 */
<span class="p_chunk">@@ -625,13 +625,13 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 	} else {
 
 		/*
<span class="p_del">-		 * Read RDR-15 which contains the counters and sticky bits </span>
<span class="p_add">+		 * Read RDR-15 which contains the counters and sticky bits</span>
 		 */
 		if (!perf_rdr_read_ubuf(15, userbuf)) {
 			return -13;
 		}
 
<span class="p_del">-		/* </span>
<span class="p_add">+		/*</span>
 		 * Clear out the counters
 		 */
 		perf_rdr_clear(15);
<span class="p_chunk">@@ -644,7 +644,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		raddr[2] = (uint32_t)((userbuf[1] &gt;&gt; 32) &amp; 0x00000000ffffffffUL);
 		raddr[3] = (uint32_t)(userbuf[1] &amp; 0x00000000ffffffffUL);
 	}
<span class="p_del">- </span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -682,7 +682,7 @@</span> <span class="p_context"> static int perf_rdr_read_ubuf(uint32_t	rdr_num, uint64_t *buffer)</span>
 	i = tentry-&gt;num_words;
 	while (i--) {
 		buffer[i] = 0;
<span class="p_del">-	}	</span>
<span class="p_add">+	}</span>
 
 	/* Check for bits an even number of 64 */
 	if ((xbits = width &amp; 0x03f) != 0) {
<span class="p_chunk">@@ -808,18 +808,22 @@</span> <span class="p_context"> static int perf_write_image(uint64_t *memaddr)</span>
 	}
 
 	runway = ioremap_nocache(cpu_device-&gt;hpa.start, 4096);
<span class="p_add">+	if (!runway) {</span>
<span class="p_add">+		pr_err(&quot;perf_write_image: ioremap failed!\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
 
 	/* Merge intrigue bits into Runway STATUS 0 */
 	tmp64 = __raw_readq(runway + RUNWAY_STATUS) &amp; 0xffecfffffffffffful;
<span class="p_del">-	__raw_writeq(tmp64 | (*memaddr++ &amp; 0x0013000000000000ul), </span>
<span class="p_add">+	__raw_writeq(tmp64 | (*memaddr++ &amp; 0x0013000000000000ul),</span>
 		     runway + RUNWAY_STATUS);
<span class="p_del">-	</span>
<span class="p_add">+</span>
 	/* Write RUNWAY DEBUG registers */
 	for (i = 0; i &lt; 8; i++) {
 		__raw_writeq(*memaddr++, runway + RUNWAY_DEBUG);
 	}
 
<span class="p_del">-	return 0; </span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -843,7 +847,7 @@</span> <span class="p_context"> printk(&quot;perf_rdr_write\n&quot;);</span>
 			perf_rdr_shift_out_U(rdr_num, buffer[i]);
 		} else {
 			perf_rdr_shift_out_W(rdr_num, buffer[i]);
<span class="p_del">-		}	</span>
<span class="p_add">+		}</span>
 	}
 printk(&quot;perf_rdr_write done\n&quot;);
 }
<span class="p_header">diff --git a/block/partitions/efi.c b/block/partitions/efi.c</span>
<span class="p_header">index 56d08fd75b1a..8de885e1e0c6 100644</span>
<span class="p_header">--- a/block/partitions/efi.c</span>
<span class="p_header">+++ b/block/partitions/efi.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static gpt_entry *alloc_read_gpt_entries(struct parsed_partitions *state,</span>
 	if (!gpt)
 		return NULL;
 
<span class="p_del">-	count = le32_to_cpu(gpt-&gt;num_partition_entries) *</span>
<span class="p_add">+	count = (size_t)le32_to_cpu(gpt-&gt;num_partition_entries) *</span>
                 le32_to_cpu(gpt-&gt;sizeof_partition_entry);
 	if (!count)
 		return NULL;
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> static int is_gpt_valid(struct parsed_partitions *state, u64 lba,</span>
 			gpt_header **gpt, gpt_entry **ptes)
 {
 	u32 crc, origcrc;
<span class="p_del">-	u64 lastlba;</span>
<span class="p_add">+	u64 lastlba, pt_size;</span>
 
 	if (!ptes)
 		return 0;
<span class="p_chunk">@@ -434,13 +434,20 @@</span> <span class="p_context"> static int is_gpt_valid(struct parsed_partitions *state, u64 lba,</span>
 		goto fail;
 	}
 
<span class="p_add">+	/* Sanity check partition table size */</span>
<span class="p_add">+	pt_size = (u64)le32_to_cpu((*gpt)-&gt;num_partition_entries) *</span>
<span class="p_add">+		le32_to_cpu((*gpt)-&gt;sizeof_partition_entry);</span>
<span class="p_add">+	if (pt_size &gt; KMALLOC_MAX_SIZE) {</span>
<span class="p_add">+		pr_debug(&quot;GUID Partition Table is too large: %llu &gt; %lu bytes\n&quot;,</span>
<span class="p_add">+			 (unsigned long long)pt_size, KMALLOC_MAX_SIZE);</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(*ptes = alloc_read_gpt_entries(state, *gpt)))
 		goto fail;
 
 	/* Check the GUID Partition Entry Array CRC */
<span class="p_del">-	crc = efi_crc32((const unsigned char *) (*ptes),</span>
<span class="p_del">-			le32_to_cpu((*gpt)-&gt;num_partition_entries) *</span>
<span class="p_del">-			le32_to_cpu((*gpt)-&gt;sizeof_partition_entry));</span>
<span class="p_add">+	crc = efi_crc32((const unsigned char *) (*ptes), pt_size);</span>
 
 	if (crc != le32_to_cpu((*gpt)-&gt;partition_entry_array_crc32)) {
 		pr_debug(&quot;GUID Partitition Entry Array CRC check failed.\n&quot;);
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index fd1967ecc928..110970be0716 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -448,13 +448,6 @@</span> <span class="p_context"> static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,</span>
 		char __user *from = iov-&gt;iov_base;
 
 		while (seglen) {
<span class="p_del">-			sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_del">-					       struct skcipher_sg_list, list);</span>
<span class="p_del">-			sg = sgl-&gt;sg;</span>
<span class="p_del">-</span>
<span class="p_del">-			while (!sg-&gt;length)</span>
<span class="p_del">-				sg++;</span>
<span class="p_del">-</span>
 			used = ctx-&gt;used;
 			if (!used) {
 				err = skcipher_wait_for_data(sk, flags);
<span class="p_chunk">@@ -476,6 +469,13 @@</span> <span class="p_context"> static int skcipher_recvmsg(struct kiocb *unused, struct socket *sock,</span>
 			if (!used)
 				goto free;
 
<span class="p_add">+			sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_add">+					       struct skcipher_sg_list, list);</span>
<span class="p_add">+			sg = sgl-&gt;sg;</span>
<span class="p_add">+</span>
<span class="p_add">+			while (!sg-&gt;length)</span>
<span class="p_add">+				sg++;</span>
<span class="p_add">+</span>
 			ablkcipher_request_set_crypt(&amp;ctx-&gt;req, sg,
 						     ctx-&gt;rsgl.sg, used,
 						     ctx-&gt;iv);
<span class="p_header">diff --git a/drivers/ata/libata-transport.c b/drivers/ata/libata-transport.c</span>
<span class="p_header">index fd29b7224082..43d4fbb377da 100644</span>
<span class="p_header">--- a/drivers/ata/libata-transport.c</span>
<span class="p_header">+++ b/drivers/ata/libata-transport.c</span>
<span class="p_chunk">@@ -223,7 +223,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_port_class,</span>
 
 static void ata_tport_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -283,7 +282,7 @@</span> <span class="p_context"> int ata_tport_add(struct device *parent,</span>
 	device_initialize(dev);
 	dev-&gt;type = &amp;ata_port_type;
 
<span class="p_del">-	dev-&gt;parent = get_device(parent);</span>
<span class="p_add">+	dev-&gt;parent = parent;</span>
 	dev-&gt;release = ata_tport_release;
 	dev_set_name(dev, &quot;ata%d&quot;, ap-&gt;print_id);
 	transport_setup_device(dev);
<span class="p_chunk">@@ -347,7 +346,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_link_class,</span>
 
 static void ata_tlink_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -409,7 +407,7 @@</span> <span class="p_context"> int ata_tlink_add(struct ata_link *link)</span>
 	int error;
 
 	device_initialize(dev);
<span class="p_del">-	dev-&gt;parent = get_device(&amp;ap-&gt;tdev);</span>
<span class="p_add">+	dev-&gt;parent = &amp;ap-&gt;tdev;</span>
 	dev-&gt;release = ata_tlink_release;
 	if (ata_is_host_link(link))
 		dev_set_name(dev, &quot;link%d&quot;, ap-&gt;print_id);
<span class="p_chunk">@@ -587,7 +585,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_dev_class,</span>
 
 static void ata_tdev_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -660,7 +657,7 @@</span> <span class="p_context"> static int ata_tdev_add(struct ata_device *ata_dev)</span>
 	int error;
 
 	device_initialize(dev);
<span class="p_del">-	dev-&gt;parent = get_device(&amp;link-&gt;tdev);</span>
<span class="p_add">+	dev-&gt;parent = &amp;link-&gt;tdev;</span>
 	dev-&gt;release = ata_tdev_release;
 	if (ata_is_host_link(link))
 		dev_set_name(dev, &quot;dev%d.%d&quot;, ap-&gt;print_id,ata_dev-&gt;devno);
<span class="p_header">diff --git a/drivers/hwmon/gl520sm.c b/drivers/hwmon/gl520sm.c</span>
<span class="p_header">index dee93ec87d02..84e0994aafdd 100644</span>
<span class="p_header">--- a/drivers/hwmon/gl520sm.c</span>
<span class="p_header">+++ b/drivers/hwmon/gl520sm.c</span>
<span class="p_chunk">@@ -208,11 +208,13 @@</span> <span class="p_context"> static ssize_t get_cpu_vid(struct device *dev, struct device_attribute *attr,</span>
 }
 static DEVICE_ATTR(cpu0_vid, S_IRUGO, get_cpu_vid, NULL);
 
<span class="p_del">-#define VDD_FROM_REG(val) (((val) * 95 + 2) / 4)</span>
<span class="p_del">-#define VDD_TO_REG(val) clamp_val((((val) * 4 + 47) / 95), 0, 255)</span>
<span class="p_add">+#define VDD_FROM_REG(val)	DIV_ROUND_CLOSEST((val) * 95, 4)</span>
<span class="p_add">+#define VDD_CLAMP(val)		clamp_val(val, 0, 255 * 95 / 4)</span>
<span class="p_add">+#define VDD_TO_REG(val)		DIV_ROUND_CLOSEST(VDD_CLAMP(val) * 4, 95)</span>
 
<span class="p_del">-#define IN_FROM_REG(val) ((val) * 19)</span>
<span class="p_del">-#define IN_TO_REG(val) clamp_val((((val) + 9) / 19), 0, 255)</span>
<span class="p_add">+#define IN_FROM_REG(val)	((val) * 19)</span>
<span class="p_add">+#define IN_CLAMP(val)		clamp_val(val, 0, 255 * 19)</span>
<span class="p_add">+#define IN_TO_REG(val)		DIV_ROUND_CLOSEST(IN_CLAMP(val), 19)</span>
 
 static ssize_t get_in_input(struct device *dev, struct device_attribute *attr,
 			    char *buf)
<span class="p_chunk">@@ -349,8 +351,13 @@</span> <span class="p_context"> static SENSOR_DEVICE_ATTR(in4_max, S_IRUGO | S_IWUSR,</span>
 
 #define DIV_FROM_REG(val) (1 &lt;&lt; (val))
 #define FAN_FROM_REG(val, div) ((val) == 0 ? 0 : (480000 / ((val) &lt;&lt; (div))))
<span class="p_del">-#define FAN_TO_REG(val, div) ((val) &lt;= 0 ? 0 : \</span>
<span class="p_del">-	clamp_val((480000 + ((val) &lt;&lt; ((div)-1))) / ((val) &lt;&lt; (div)), 1, 255))</span>
<span class="p_add">+</span>
<span class="p_add">+#define FAN_BASE(div)		(480000 &gt;&gt; (div))</span>
<span class="p_add">+#define FAN_CLAMP(val, div)	clamp_val(val, FAN_BASE(div) / 255, \</span>
<span class="p_add">+					  FAN_BASE(div))</span>
<span class="p_add">+#define FAN_TO_REG(val, div)	((val) == 0 ? 0 : \</span>
<span class="p_add">+				 DIV_ROUND_CLOSEST(480000, \</span>
<span class="p_add">+						FAN_CLAMP(val, div) &lt;&lt; (div)))</span>
 
 static ssize_t get_fan_input(struct device *dev, struct device_attribute *attr,
 			     char *buf)
<span class="p_chunk">@@ -513,9 +520,9 @@</span> <span class="p_context"> static SENSOR_DEVICE_ATTR(fan2_div, S_IRUGO | S_IWUSR,</span>
 static DEVICE_ATTR(fan1_off, S_IRUGO | S_IWUSR,
 		get_fan_off, set_fan_off);
 
<span class="p_del">-#define TEMP_FROM_REG(val) (((val) - 130) * 1000)</span>
<span class="p_del">-#define TEMP_TO_REG(val) clamp_val(((((val) &lt; 0 ? \</span>
<span class="p_del">-			(val) - 500 : (val) + 500) / 1000) + 130), 0, 255)</span>
<span class="p_add">+#define TEMP_FROM_REG(val)	(((val) - 130) * 1000)</span>
<span class="p_add">+#define TEMP_CLAMP(val)		clamp_val(val, -130000, 125000)</span>
<span class="p_add">+#define TEMP_TO_REG(val)	(DIV_ROUND_CLOSEST(TEMP_CLAMP(val), 1000) + 130)</span>
 
 static ssize_t get_temp_input(struct device *dev, struct device_attribute *attr,
 			      char *buf)
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">index 23ca2aca1ad6..5331f8683ef6 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_chunk">@@ -7078,7 +7078,7 @@</span> <span class="p_context"> static void qib_7322_txchk_change(struct qib_devdata *dd, u32 start,</span>
 	unsigned long flags;
 
 	while (wait) {
<span class="p_del">-		unsigned long shadow;</span>
<span class="p_add">+		unsigned long shadow = 0;</span>
 		int cstart, previ = -1;
 
 		/*
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 5e08db6f9d8c..eab9eda0e7bd 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -958,7 +958,7 @@</span> <span class="p_context"> static void __ipoib_reap_neigh(struct ipoib_dev_priv *priv)</span>
 						   rcu_dereference_protected(neigh-&gt;hnext,
 									     lockdep_is_held(&amp;priv-&gt;lock)));
 				/* remove from path/mc list */
<span class="p_del">-				list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+				list_del_init(&amp;neigh-&gt;list);</span>
 				call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			} else {
 				np = &amp;neigh-&gt;hnext;
<span class="p_chunk">@@ -1121,7 +1121,7 @@</span> <span class="p_context"> void ipoib_neigh_free(struct ipoib_neigh *neigh)</span>
 					   rcu_dereference_protected(neigh-&gt;hnext,
 								     lockdep_is_held(&amp;priv-&gt;lock)));
 			/* remove from parent list */
<span class="p_del">-			list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+			list_del_init(&amp;neigh-&gt;list);</span>
 			call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			return;
 		} else {
<span class="p_chunk">@@ -1206,7 +1206,7 @@</span> <span class="p_context"> void ipoib_del_neighs_by_gid(struct net_device *dev, u8 *gid)</span>
 						   rcu_dereference_protected(neigh-&gt;hnext,
 									     lockdep_is_held(&amp;priv-&gt;lock)));
 				/* remove from parent list */
<span class="p_del">-				list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+				list_del_init(&amp;neigh-&gt;list);</span>
 				call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			} else {
 				np = &amp;neigh-&gt;hnext;
<span class="p_chunk">@@ -1248,7 +1248,7 @@</span> <span class="p_context"> static void ipoib_flush_neighs(struct ipoib_dev_priv *priv)</span>
 					   rcu_dereference_protected(neigh-&gt;hnext,
 								     lockdep_is_held(&amp;priv-&gt;lock)));
 			/* remove from path/mc list */
<span class="p_del">-			list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+			list_del_init(&amp;neigh-&gt;list);</span>
 			call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 		}
 	}
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">index c995681befee..67182d4e8138 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_chunk">@@ -162,11 +162,11 @@</span> <span class="p_context"> int ipoib_vlan_add(struct net_device *pdev, unsigned short pkey)</span>
 out:
 	up_write(&amp;ppriv-&gt;vlan_rwsem);
 
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+</span>
 	if (result)
 		free_netdev(priv-&gt;dev);
 
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-</span>
 	return result;
 }
 
<span class="p_chunk">@@ -187,7 +187,6 @@</span> <span class="p_context"> int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)</span>
 	list_for_each_entry_safe(priv, tpriv, &amp;ppriv-&gt;child_intfs, list) {
 		if (priv-&gt;pkey == pkey &amp;&amp;
 		    priv-&gt;child_type == IPOIB_LEGACY_CHILD) {
<span class="p_del">-			unregister_netdevice(priv-&gt;dev);</span>
 			list_del(&amp;priv-&gt;list);
 			dev = priv-&gt;dev;
 			break;
<span class="p_chunk">@@ -195,6 +194,11 @@</span> <span class="p_context"> int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)</span>
 	}
 	up_write(&amp;ppriv-&gt;vlan_rwsem);
 
<span class="p_add">+	if (dev) {</span>
<span class="p_add">+		ipoib_dbg(ppriv, &quot;delete child vlan %s\n&quot;, dev-&gt;name);</span>
<span class="p_add">+		unregister_netdevice(dev);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rtnl_unlock();
 
 	if (dev) {
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 1b49827757b5..d207748fdc41 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -1514,11 +1514,24 @@</span> <span class="p_context"> retry_write:</span>
 			mbio-&gt;bi_private = r10_bio;
 
 			atomic_inc(&amp;r10_bio-&gt;remaining);
<span class="p_add">+</span>
<span class="p_add">+			cb = blk_check_plugged(raid10_unplug, mddev,</span>
<span class="p_add">+					       sizeof(*plug));</span>
<span class="p_add">+			if (cb)</span>
<span class="p_add">+				plug = container_of(cb, struct raid10_plug_cb,</span>
<span class="p_add">+						    cb);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				plug = NULL;</span>
 			spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
<span class="p_del">-			bio_list_add(&amp;conf-&gt;pending_bio_list, mbio);</span>
<span class="p_del">-			conf-&gt;pending_count++;</span>
<span class="p_add">+			if (plug) {</span>
<span class="p_add">+				bio_list_add(&amp;plug-&gt;pending, mbio);</span>
<span class="p_add">+				plug-&gt;pending_cnt++;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				bio_list_add(&amp;conf-&gt;pending_bio_list, mbio);</span>
<span class="p_add">+				conf-&gt;pending_count++;</span>
<span class="p_add">+			}</span>
 			spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
<span class="p_del">-			if (!mddev_check_plugged(mddev))</span>
<span class="p_add">+			if (!plug)</span>
 				md_wakeup_thread(mddev-&gt;thread);
 		}
 	}
<span class="p_header">diff --git a/drivers/media/pci/ttpci/av7110_hw.c b/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_header">index 300bd3c94738..0992bb0e207e 100644</span>
<span class="p_header">--- a/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_header">+++ b/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_chunk">@@ -56,11 +56,11 @@</span> <span class="p_context"></span>
    by Nathan Laredo &lt;laredo@gnu.org&gt; */
 
 int av7110_debiwrite(struct av7110 *av7110, u32 config,
<span class="p_del">-		     int addr, u32 val, int count)</span>
<span class="p_add">+		     int addr, u32 val, unsigned int count)</span>
 {
 	struct saa7146_dev *dev = av7110-&gt;dev;
 
<span class="p_del">-	if (count &lt;= 0 || count &gt; 32764) {</span>
<span class="p_add">+	if (count &gt; 32764) {</span>
 		printk(&quot;%s: invalid count %d\n&quot;, __func__, count);
 		return -1;
 	}
<span class="p_chunk">@@ -78,12 +78,12 @@</span> <span class="p_context"> int av7110_debiwrite(struct av7110 *av7110, u32 config,</span>
 	return 0;
 }
 
<span class="p_del">-u32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, int count)</span>
<span class="p_add">+u32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, unsigned int count)</span>
 {
 	struct saa7146_dev *dev = av7110-&gt;dev;
 	u32 result = 0;
 
<span class="p_del">-	if (count &gt; 32764 || count &lt;= 0) {</span>
<span class="p_add">+	if (count &gt; 32764) {</span>
 		printk(&quot;%s: invalid count %d\n&quot;, __func__, count);
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/media/pci/ttpci/av7110_hw.h b/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_header">index 1634aba5cb84..ccb148059406 100644</span>
<span class="p_header">--- a/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_header">+++ b/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_chunk">@@ -377,14 +377,14 @@</span> <span class="p_context"> extern int av7110_fw_request(struct av7110 *av7110, u16 *request_buf,</span>
 
 /* DEBI (saa7146 data extension bus interface) access */
 extern int av7110_debiwrite(struct av7110 *av7110, u32 config,
<span class="p_del">-			    int addr, u32 val, int count);</span>
<span class="p_add">+			    int addr, u32 val, unsigned int count);</span>
 extern u32 av7110_debiread(struct av7110 *av7110, u32 config,
<span class="p_del">-			   int addr, int count);</span>
<span class="p_add">+			   int addr, unsigned int count);</span>
 
 
 /* DEBI during interrupt */
 /* single word writes */
<span class="p_del">-static inline void iwdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline void iwdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	av7110_debiwrite(av7110, config, addr, val, count);
 }
<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> static inline void mwdebi(struct av7110 *av7110, u32 config, int addr,</span>
 	av7110_debiwrite(av7110, config, addr, 0, count);
 }
 
<span class="p_del">-static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	u32 res;
 
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, i</span>
 }
 
 /* DEBI outside interrupts, only for count &lt;= 4! */
<span class="p_del">-static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	unsigned long flags;
 
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, i</span>
 	spin_unlock_irqrestore(&amp;av7110-&gt;debilock, flags);
 }
 
<span class="p_del">-static inline u32 rdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline u32 rdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	unsigned long flags;
 	u32 res;
<span class="p_header">diff --git a/drivers/media/platform/exynos-gsc/gsc-core.c b/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_header">index b4c9f1d08968..fc1716f08777 100644</span>
<span class="p_header">--- a/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_header">+++ b/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_chunk">@@ -846,9 +846,7 @@</span> <span class="p_context"> int gsc_prepare_addr(struct gsc_ctx *ctx, struct vb2_buffer *vb,</span>
 
 	if ((frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_VYUY) ||
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVYU) ||
<span class="p_del">-		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_NV61) ||</span>
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVU420) ||
<span class="p_del">-		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_NV21) ||</span>
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVU420M))
 		swap(addr-&gt;cb, addr-&gt;cr);
 
<span class="p_header">diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c</span>
<span class="p_header">index 6da97b170563..8d246f815658 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sdio_bus.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sdio_bus.c</span>
<span class="p_chunk">@@ -265,7 +265,7 @@</span> <span class="p_context"> static void sdio_release_func(struct device *dev)</span>
 	sdio_free_func_cis(func);
 
 	kfree(func-&gt;info);
<span class="p_del">-</span>
<span class="p_add">+	kfree(func-&gt;tmpbuf);</span>
 	kfree(func);
 }
 
<span class="p_chunk">@@ -280,6 +280,16 @@</span> <span class="p_context"> struct sdio_func *sdio_alloc_func(struct mmc_card *card)</span>
 	if (!func)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * allocate buffer separately to make sure it&#39;s properly aligned for</span>
<span class="p_add">+	 * DMA usage (incl. 64 bit DMA)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	func-&gt;tmpbuf = kmalloc(4, GFP_KERNEL);</span>
<span class="p_add">+	if (!func-&gt;tmpbuf) {</span>
<span class="p_add">+		kfree(func);</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	func-&gt;card = card;
 
 	device_initialize(&amp;func-&gt;dev);
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.h b/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_header">index 22301bf9c21d..be909fe4fc7a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_chunk">@@ -326,7 +326,7 @@</span> <span class="p_context"> enum FELIC_MODE_BIT {</span>
 	ECMR_DPAD = 0x00200000, ECMR_RZPF = 0x00100000,
 	ECMR_ZPF = 0x00080000, ECMR_PFR = 0x00040000, ECMR_RXF = 0x00020000,
 	ECMR_TXF = 0x00010000, ECMR_MCT = 0x00002000, ECMR_PRCEF = 0x00001000,
<span class="p_del">-	ECMR_PMDE = 0x00000200, ECMR_RE = 0x00000040, ECMR_TE = 0x00000020,</span>
<span class="p_add">+	ECMR_MPDE = 0x00000200, ECMR_RE = 0x00000040, ECMR_TE = 0x00000020,</span>
 	ECMR_RTM = 0x00000010, ECMR_ILB = 0x00000008, ECMR_ELB = 0x00000004,
 	ECMR_DM = 0x00000002, ECMR_PRM = 0x00000001,
 };
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index 16c580379e38..dae9dcb69c1a 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -2331,8 +2331,10 @@</span> <span class="p_context"> start_again:</span>
 
 	hdr = genlmsg_put(skb, portid, seq, &amp;team_nl_family, flags | NLM_F_MULTI,
 			  TEAM_CMD_OPTIONS_GET);
<span class="p_del">-	if (!hdr)</span>
<span class="p_add">+	if (!hdr) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
 		return -EMSGSIZE;
<span class="p_add">+	}</span>
 
 	if (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team-&gt;dev-&gt;ifindex))
 		goto nla_put_failure;
<span class="p_chunk">@@ -2599,8 +2601,10 @@</span> <span class="p_context"> start_again:</span>
 
 	hdr = genlmsg_put(skb, portid, seq, &amp;team_nl_family, flags | NLM_F_MULTI,
 			  TEAM_CMD_PORT_LIST_GET);
<span class="p_del">-	if (!hdr)</span>
<span class="p_add">+	if (!hdr) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
 		return -EMSGSIZE;
<span class="p_add">+	}</span>
 
 	if (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team-&gt;dev-&gt;ifindex))
 		goto nla_put_failure;
<span class="p_header">diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig</span>
<span class="p_header">index 37eed4d84e9c..bf7553ed73bc 100644</span>
<span class="p_header">--- a/drivers/net/usb/Kconfig</span>
<span class="p_header">+++ b/drivers/net/usb/Kconfig</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> config USB_NET_NET1080</span>
 	  optionally with LEDs that indicate traffic
 
 config USB_NET_PLUSB
<span class="p_del">-	tristate &quot;Prolific PL-2301/2302/25A1 based cables&quot;</span>
<span class="p_add">+	tristate &quot;Prolific PL-2301/2302/25A1/27A1 based cables&quot;</span>
 	# if the handshake/init/reset problems, from original &#39;plusb&#39;,
 	# are ever resolved ... then remove &quot;experimental&quot;
 	depends on USB_USBNET
<span class="p_header">diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c</span>
<span class="p_header">index 1bfe0fcaccf5..7c02231c1a1b 100644</span>
<span class="p_header">--- a/drivers/net/usb/plusb.c</span>
<span class="p_header">+++ b/drivers/net/usb/plusb.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static int pl_reset(struct usbnet *dev)</span>
 }
 
 static const struct driver_info	prolific_info = {
<span class="p_del">-	.description =	&quot;Prolific PL-2301/PL-2302/PL-25A1&quot;,</span>
<span class="p_add">+	.description =	&quot;Prolific PL-2301/PL-2302/PL-25A1/PL-27A1&quot;,</span>
 	.flags =	FLAG_POINTTOPOINT | FLAG_NO_SETINT,
 		/* some PL-2302 versions seem to fail usb_set_interface() */
 	.reset =	pl_reset,
<span class="p_chunk">@@ -139,6 +139,17 @@</span> <span class="p_context"> static const struct usb_device_id	products [] = {</span>
 					 * Host-to-Host Cable
 					 */
 	.driver_info =  (unsigned long) &amp;prolific_info,
<span class="p_add">+</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
<span class="p_add">+/* super speed cables */</span>
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE(0x067b, 0x27a1),     /* PL-27A1, no eeprom</span>
<span class="p_add">+					 * also: goobay Active USB 3.0</span>
<span class="p_add">+					 * Data Link,</span>
<span class="p_add">+					 * Unitek Y-3501</span>
<span class="p_add">+					 */</span>
<span class="p_add">+	.driver_info =  (unsigned long) &amp;prolific_info,</span>
 },
 
 	{ },		// END
<span class="p_chunk">@@ -158,5 +169,5 @@</span> <span class="p_context"> static struct usb_driver plusb_driver = {</span>
 module_usb_driver(plusb_driver);
 
 MODULE_AUTHOR(&quot;David Brownell&quot;);
<span class="p_del">-MODULE_DESCRIPTION(&quot;Prolific PL-2301/2302/25A1 USB Host to Host Link Driver&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;Prolific PL-2301/2302/25A1/27A1 USB Host to Host Link Driver&quot;);</span>
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_header">diff --git a/drivers/staging/nvec/nvec_ps2.c b/drivers/staging/nvec/nvec_ps2.c</span>
<span class="p_header">index 3f631c067f54..dd2ebd223867 100644</span>
<span class="p_header">--- a/drivers/staging/nvec/nvec_ps2.c</span>
<span class="p_header">+++ b/drivers/staging/nvec/nvec_ps2.c</span>
<span class="p_chunk">@@ -165,8 +165,8 @@</span> <span class="p_context"> static int nvec_mouse_resume(struct device *dev)</span>
 }
 #endif
 
<span class="p_del">-static const SIMPLE_DEV_PM_OPS(nvec_mouse_pm_ops, nvec_mouse_suspend,</span>
<span class="p_del">-				nvec_mouse_resume);</span>
<span class="p_add">+static SIMPLE_DEV_PM_OPS(nvec_mouse_pm_ops, nvec_mouse_suspend,</span>
<span class="p_add">+			 nvec_mouse_resume);</span>
 
 static struct platform_driver nvec_mouse_driver = {
 	.probe  = nvec_mouse_probe,
<span class="p_header">diff --git a/drivers/tty/goldfish.c b/drivers/tty/goldfish.c</span>
<span class="p_header">index 09495f515fa9..beb3142a1414 100644</span>
<span class="p_header">--- a/drivers/tty/goldfish.c</span>
<span class="p_header">+++ b/drivers/tty/goldfish.c</span>
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> static int goldfish_tty_probe(struct platform_device *pdev)</span>
 
 	tty_unregister_device(goldfish_tty_driver, i);
 err_tty_register_device_failed:
<span class="p_del">-	free_irq(irq, pdev);</span>
<span class="p_add">+	free_irq(irq, qtty);</span>
 err_request_irq_failed:
 	goldfish_tty_current_line_count--;
 	if (goldfish_tty_current_line_count == 0)
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index c3b8ae360424..5e3a609fbab4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -236,11 +236,16 @@</span> <span class="p_context"> static int read_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,</span>
 
 	status = usb_control_msg(usbdev, pipe, request, requesttype, value,
 				     index, buf, 1, MOS_WDR_TIMEOUT);
<span class="p_del">-	if (status == 1)</span>
<span class="p_add">+	if (status == 1) {</span>
 		*data = *buf;
<span class="p_del">-	else if (status &lt; 0)</span>
<span class="p_add">+	} else {</span>
 		dev_err(&amp;usbdev-&gt;dev,
 			&quot;mos7720: usb_control_msg() failed: %d\n&quot;, status);
<span class="p_add">+		if (status &gt;= 0)</span>
<span class="p_add">+			status = -EIO;</span>
<span class="p_add">+		*data = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(buf);
 
 	return status;
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index 0b547d9e2aeb..a0dca81dfaca 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -285,9 +285,15 @@</span> <span class="p_context"> static int mos7840_get_reg_sync(struct usb_serial_port *port, __u16 reg,</span>
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,
 			      MCS_RD_RTYPE, 0, reg, buf, VENDOR_READ_LENGTH,
 			      MOS_WDR_TIMEOUT);
<span class="p_add">+	if (ret &lt; VENDOR_READ_LENGTH) {</span>
<span class="p_add">+		if (ret &gt;= 0)</span>
<span class="p_add">+			ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	*val = buf[0];
 	dev_dbg(&amp;port-&gt;dev, &quot;%s offset is %x, return val %x\n&quot;, __func__, reg, *val);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	kfree(buf);
 	return ret;
 }
<span class="p_chunk">@@ -353,8 +359,13 @@</span> <span class="p_context"> static int mos7840_get_uart_reg(struct usb_serial_port *port, __u16 reg,</span>
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,
 			      MCS_RD_RTYPE, Wval, reg, buf, VENDOR_READ_LENGTH,
 			      MOS_WDR_TIMEOUT);
<span class="p_add">+	if (ret &lt; VENDOR_READ_LENGTH) {</span>
<span class="p_add">+		if (ret &gt;= 0)</span>
<span class="p_add">+			ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	*val = buf[0];
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	kfree(buf);
 	return ret;
 }
<span class="p_chunk">@@ -1518,10 +1529,10 @@</span> <span class="p_context"> static int mos7840_tiocmget(struct tty_struct *tty)</span>
 		return -ENODEV;
 
 	status = mos7840_get_uart_reg(port, MODEM_STATUS_REGISTER, &amp;msr);
<span class="p_del">-	if (status != 1)</span>
<span class="p_add">+	if (status &lt; 0)</span>
 		return -EIO;
 	status = mos7840_get_uart_reg(port, MODEM_CONTROL_REGISTER, &amp;mcr);
<span class="p_del">-	if (status != 1)</span>
<span class="p_add">+	if (status &lt; 0)</span>
 		return -EIO;
 	result = ((mcr &amp; MCR_DTR) ? TIOCM_DTR : 0)
 	    | ((mcr &amp; MCR_RTS) ? TIOCM_RTS : 0)
<span class="p_header">diff --git a/fs/xfs/kmem.c b/fs/xfs/kmem.c</span>
<span class="p_header">index 53e95b2a1369..0abc6ae4fa57 100644</span>
<span class="p_header">--- a/fs/xfs/kmem.c</span>
<span class="p_header">+++ b/fs/xfs/kmem.c</span>
<span class="p_chunk">@@ -24,24 +24,6 @@</span> <span class="p_context"></span>
 #include &quot;kmem.h&quot;
 #include &quot;xfs_message.h&quot;
 
<span class="p_del">-/*</span>
<span class="p_del">- * Greedy allocation.  May fail and may return vmalloced memory.</span>
<span class="p_del">- */</span>
<span class="p_del">-void *</span>
<span class="p_del">-kmem_zalloc_greedy(size_t *size, size_t minsize, size_t maxsize)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void		*ptr;</span>
<span class="p_del">-	size_t		kmsize = maxsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (!(ptr = vzalloc(kmsize))) {</span>
<span class="p_del">-		if ((kmsize &gt;&gt;= 1) &lt;= minsize)</span>
<span class="p_del">-			kmsize = minsize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ptr)</span>
<span class="p_del">-		*size = kmsize;</span>
<span class="p_del">-	return ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void *
 kmem_alloc(size_t size, xfs_km_flags_t flags)
 {
<span class="p_header">diff --git a/fs/xfs/kmem.h b/fs/xfs/kmem.h</span>
<span class="p_header">index 64db0e53edea..2e75933bec1e 100644</span>
<span class="p_header">--- a/fs/xfs/kmem.h</span>
<span class="p_header">+++ b/fs/xfs/kmem.h</span>
<span class="p_chunk">@@ -66,8 +66,6 @@</span> <span class="p_context"> extern void *kmem_realloc(const void *, size_t, size_t, xfs_km_flags_t);</span>
 extern void  kmem_free(const void *);
 
 
<span class="p_del">-extern void *kmem_zalloc_greedy(size_t *, size_t, size_t);</span>
<span class="p_del">-</span>
 static inline void *
 kmem_zalloc(size_t size, xfs_km_flags_t flags)
 {
<span class="p_header">diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c</span>
<span class="p_header">index 894924a5129b..76dd8e7e914f 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_itable.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_itable.c</span>
<span class="p_chunk">@@ -356,7 +356,6 @@</span> <span class="p_context"> xfs_bulkstat(</span>
 	xfs_agino_t		agino;	/* inode # in allocation group */
 	xfs_agnumber_t		agno;	/* allocation group number */
 	xfs_btree_cur_t		*cur;	/* btree cursor for ialloc btree */
<span class="p_del">-	size_t			irbsize; /* size of irec buffer in bytes */</span>
 	xfs_inobt_rec_incore_t	*irbuf;	/* start of irec buffer */
 	int			nirbuf;	/* size of irbuf */
 	int			ubcount; /* size of user&#39;s buffer */
<span class="p_chunk">@@ -383,11 +382,10 @@</span> <span class="p_context"> xfs_bulkstat(</span>
 	*ubcountp = 0;
 	*done = 0;
 
<span class="p_del">-	irbuf = kmem_zalloc_greedy(&amp;irbsize, PAGE_SIZE, PAGE_SIZE * 4);</span>
<span class="p_add">+	irbuf = kmem_zalloc_large(PAGE_SIZE * 4, KM_SLEEP);</span>
 	if (!irbuf)
 		return -ENOMEM;
<span class="p_del">-</span>
<span class="p_del">-	nirbuf = irbsize / sizeof(*irbuf);</span>
<span class="p_add">+	nirbuf = (PAGE_SIZE * 4) / sizeof(*irbuf);</span>
 
 	/*
 	 * Loop over the allocation groups, starting from the last
<span class="p_header">diff --git a/include/linux/audit.h b/include/linux/audit.h</span>
<span class="p_header">index 10f155b7daf6..ba78e12bef53 100644</span>
<span class="p_header">--- a/include/linux/audit.h</span>
<span class="p_header">+++ b/include/linux/audit.h</span>
<span class="p_chunk">@@ -273,6 +273,20 @@</span> <span class="p_context"> static inline int audit_socketcall(int nargs, unsigned long *args)</span>
 		return __audit_socketcall(nargs, args);
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int audit_socketcall_compat(int nargs, u32 *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long a[AUDITSC_ARGS];</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (audit_dummy_context())</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; nargs; i++)</span>
<span class="p_add">+		a[i] = (unsigned long)args[i];</span>
<span class="p_add">+	return __audit_socketcall(nargs, a);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int audit_sockaddr(int len, void *addr)
 {
 	if (unlikely(!audit_dummy_context()))
<span class="p_chunk">@@ -398,6 +412,12 @@</span> <span class="p_context"> static inline int audit_socketcall(int nargs, unsigned long *args)</span>
 {
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int audit_socketcall_compat(int nargs, u32 *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void audit_fd_pair(int fd1, int fd2)
 { }
 static inline int audit_sockaddr(int len, void *addr)
<span class="p_header">diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h</span>
<span class="p_header">index 50f0bc952328..2d6cc69db1fe 100644</span>
<span class="p_header">--- a/include/linux/mmc/sdio_func.h</span>
<span class="p_header">+++ b/include/linux/mmc/sdio_func.h</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> struct sdio_func {</span>
 	unsigned int		state;		/* function state */
 #define SDIO_STATE_PRESENT	(1&lt;&lt;0)		/* present in sysfs */
 
<span class="p_del">-	u8			tmpbuf[4];	/* DMA:able scratch buffer */</span>
<span class="p_add">+	u8			*tmpbuf;	/* DMA:able scratch buffer */</span>
 
 	unsigned		num_info;	/* number of info strings */
 	const char		**info;		/* info strings */
<span class="p_header">diff --git a/lib/mpi/mpi-pow.c b/lib/mpi/mpi-pow.c</span>
<span class="p_header">index 5464c8744ea9..e24388a863a7 100644</span>
<span class="p_header">--- a/lib/mpi/mpi-pow.c</span>
<span class="p_header">+++ b/lib/mpi/mpi-pow.c</span>
<span class="p_chunk">@@ -64,8 +64,13 @@</span> <span class="p_context"> int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)</span>
 	if (!esize) {
 		/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0
 		 * depending on if MOD equals 1.  */
<span class="p_del">-		rp[0] = 1;</span>
 		res-&gt;nlimbs = (msize == 1 &amp;&amp; mod-&gt;d[0] == 1) ? 0 : 1;
<span class="p_add">+		if (res-&gt;nlimbs) {</span>
<span class="p_add">+			if (mpi_resize(res, 1) &lt; 0)</span>
<span class="p_add">+				goto enomem;</span>
<span class="p_add">+			rp = res-&gt;d;</span>
<span class="p_add">+			rp[0] = 1;</span>
<span class="p_add">+		}</span>
 		res-&gt;sign = 0;
 		goto leave;
 	}
<span class="p_header">diff --git a/net/compat.c b/net/compat.c</span>
<span class="p_header">index 53e933eb78b8..3bb039e92744 100644</span>
<span class="p_header">--- a/net/compat.c</span>
<span class="p_header">+++ b/net/compat.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/filter.h&gt;
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/security.h&gt;
<span class="p_add">+#include &lt;linux/audit.h&gt;</span>
 #include &lt;linux/export.h&gt;
 
 #include &lt;net/scm.h&gt;
<span class="p_chunk">@@ -796,14 +797,24 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE5(recvmmsg, int, fd, struct compat_mmsghdr __user *, mmsg,</span>
 
 COMPAT_SYSCALL_DEFINE2(socketcall, int, call, u32 __user *, args)
 {
<span class="p_del">-	int ret;</span>
<span class="p_del">-	u32 a[6];</span>
<span class="p_add">+	u32 a[AUDITSC_ARGS];</span>
<span class="p_add">+	unsigned int len;</span>
 	u32 a0, a1;
<span class="p_add">+	int ret;</span>
 
 	if (call &lt; SYS_SOCKET || call &gt; SYS_SENDMMSG)
 		return -EINVAL;
<span class="p_del">-	if (copy_from_user(a, args, nas[call]))</span>
<span class="p_add">+	len = nas[call];</span>
<span class="p_add">+	if (len &gt; sizeof(a))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(a, args, len))</span>
 		return -EFAULT;
<span class="p_add">+</span>
<span class="p_add">+	ret = audit_socketcall_compat(len / sizeof(a[0]), a);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	a0 = a[0];
 	a1 = a[1];
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 22ad4e433b3a..21b0bd976699 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2225,6 +2225,9 @@</span> <span class="p_context"> void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (unlikely(!skb))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (likely(atomic_read(&amp;skb-&gt;users) == 1)) {
 		smp_rmb();
 		atomic_set(&amp;skb-&gt;users, 0);
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">index 7c676671329d..cc626e1b06d3 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_chunk">@@ -1304,6 +1304,7 @@</span> <span class="p_context"> static int __init nf_nat_snmp_basic_init(void)</span>
 static void __exit nf_nat_snmp_basic_fini(void)
 {
 	RCU_INIT_POINTER(nf_nat_snmp_hook, NULL);
<span class="p_add">+	synchronize_rcu();</span>
 	nf_conntrack_helper_unregister(&amp;snmp_trap_helper);
 }
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_header">index 4e78c57b818f..f3b92ce463b0 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_chunk">@@ -200,6 +200,7 @@</span> <span class="p_context"> void nf_conntrack_unregister_notifier(struct net *net,</span>
 	BUG_ON(notify != new);
 	RCU_INIT_POINTER(net-&gt;ct.nf_conntrack_event_cb, NULL);
 	mutex_unlock(&amp;nf_ct_ecache_mutex);
<span class="p_add">+	/* synchronize_rcu() is called from ctnetlink_exit. */</span>
 }
 EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
 
<span class="p_chunk">@@ -236,6 +237,7 @@</span> <span class="p_context"> void nf_ct_expect_unregister_notifier(struct net *net,</span>
 	BUG_ON(notify != new);
 	RCU_INIT_POINTER(net-&gt;ct.nf_expect_event_cb, NULL);
 	mutex_unlock(&amp;nf_ct_ecache_mutex);
<span class="p_add">+	/* synchronize_rcu() is called from ctnetlink_exit. */</span>
 }
 EXPORT_SYMBOL_GPL(nf_ct_expect_unregister_notifier);
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index cccc4aaf09be..de9ea452dd60 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -3242,6 +3242,7 @@</span> <span class="p_context"> static void __exit ctnetlink_exit(void)</span>
 #ifdef CONFIG_NETFILTER_NETLINK_QUEUE_CT
 	RCU_INIT_POINTER(nfq_ct_hook, NULL);
 #endif
<span class="p_add">+	synchronize_rcu();</span>
 }
 
 module_init(ctnetlink_init);
<span class="p_header">diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c</span>
<span class="p_header">index 4e0b47831d43..56e175efb66e 100644</span>
<span class="p_header">--- a/net/netfilter/nf_nat_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_nat_core.c</span>
<span class="p_chunk">@@ -888,6 +888,8 @@</span> <span class="p_context"> static void __exit nf_nat_cleanup(void)</span>
 #ifdef CONFIG_XFRM
 	RCU_INIT_POINTER(nf_nat_decode_session_hook, NULL);
 #endif
<span class="p_add">+	synchronize_rcu();</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; NFPROTO_NUMPROTO; i++)
 		kfree(nf_nat_l4protos[i]);
 	synchronize_net();
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 54330fb5efaf..6d10002d23f8 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -161,6 +161,7 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 	int i, ret;
 	struct nf_conntrack_expect_policy *expect_policy;
 	struct nlattr *tb[NFCTH_POLICY_SET_MAX+1];
<span class="p_add">+	unsigned int class_max;</span>
 
 	ret = nla_parse_nested(tb, NFCTH_POLICY_SET_MAX, attr,
 			       nfnl_cthelper_expect_policy_set);
<span class="p_chunk">@@ -170,19 +171,18 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 	if (!tb[NFCTH_POLICY_SET_NUM])
 		return -EINVAL;
 
<span class="p_del">-	helper-&gt;expect_class_max =</span>
<span class="p_del">-		ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (helper-&gt;expect_class_max != 0 &amp;&amp;</span>
<span class="p_del">-	    helper-&gt;expect_class_max &gt; NF_CT_MAX_EXPECT_CLASSES)</span>
<span class="p_add">+	class_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_add">+	if (class_max == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (class_max &gt; NF_CT_MAX_EXPECT_CLASSES)</span>
 		return -EOVERFLOW;
 
 	expect_policy = kzalloc(sizeof(struct nf_conntrack_expect_policy) *
<span class="p_del">-				helper-&gt;expect_class_max, GFP_KERNEL);</span>
<span class="p_add">+				class_max, GFP_KERNEL);</span>
 	if (expect_policy == NULL)
 		return -ENOMEM;
 
<span class="p_del">-	for (i=0; i&lt;helper-&gt;expect_class_max; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; class_max; i++) {</span>
 		if (!tb[NFCTH_POLICY_SET+i])
 			goto err;
 
<span class="p_chunk">@@ -191,6 +191,8 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 		if (ret &lt; 0)
 			goto err;
 	}
<span class="p_add">+</span>
<span class="p_add">+	helper-&gt;expect_class_max = class_max - 1;</span>
 	helper-&gt;expect_policy = expect_policy;
 	return 0;
 err:
<span class="p_chunk">@@ -377,10 +379,10 @@</span> <span class="p_context"> nfnl_cthelper_dump_policy(struct sk_buff *skb,</span>
 		goto nla_put_failure;
 
 	if (nla_put_be32(skb, NFCTH_POLICY_SET_NUM,
<span class="p_del">-			 htonl(helper-&gt;expect_class_max)))</span>
<span class="p_add">+			 htonl(helper-&gt;expect_class_max + 1)))</span>
 		goto nla_put_failure;
 
<span class="p_del">-	for (i=0; i&lt;helper-&gt;expect_class_max; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; helper-&gt;expect_class_max + 1; i++) {</span>
 		nest_parms2 = nla_nest_start(skb,
 				(NFCTH_POLICY_SET+i) | NLA_F_NESTED);
 		if (nest_parms2 == NULL)
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cttimeout.c b/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_header">index 476accd17145..3dfe3b7271e4 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_chunk">@@ -578,6 +578,7 @@</span> <span class="p_context"> static void __exit cttimeout_exit(void)</span>
 #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 	RCU_INIT_POINTER(nf_ct_timeout_find_get_hook, NULL);
 	RCU_INIT_POINTER(nf_ct_timeout_put_hook, NULL);
<span class="p_add">+	synchronize_rcu();</span>
 #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
 }
 
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 1c03d83edd7e..7effa07c4491 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -3482,6 +3482,8 @@</span> <span class="p_context"> static int packet_getsockopt(struct socket *sock, int level, int optname,</span>
 	case PACKET_HDRLEN:
 		if (len &gt; sizeof(int))
 			len = sizeof(int);
<span class="p_add">+		if (len &lt; sizeof(int))</span>
<span class="p_add">+			return -EINVAL;</span>
 		if (copy_from_user(&amp;val, optval, len))
 			return -EFAULT;
 		switch (val) {
<span class="p_header">diff --git a/net/rds/ib_cm.c b/net/rds/ib_cm.c</span>
<span class="p_header">index 31b74f5e61ad..662122470bfa 100644</span>
<span class="p_header">--- a/net/rds/ib_cm.c</span>
<span class="p_header">+++ b/net/rds/ib_cm.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 		ret = PTR_ERR(ic-&gt;i_send_cq);
 		ic-&gt;i_send_cq = NULL;
 		rdsdebug(&quot;ib_create_cq send failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto rds_ibdev_out;</span>
 	}
 
 	ic-&gt;i_recv_cq = ib_create_cq(dev, rds_ib_recv_cq_comp_handler,
<span class="p_chunk">@@ -308,19 +308,19 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 		ret = PTR_ERR(ic-&gt;i_recv_cq);
 		ic-&gt;i_recv_cq = NULL;
 		rdsdebug(&quot;ib_create_cq recv failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto send_cq_out;</span>
 	}
 
 	ret = ib_req_notify_cq(ic-&gt;i_send_cq, IB_CQ_NEXT_COMP);
 	if (ret) {
 		rdsdebug(&quot;ib_req_notify_cq send failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	ret = ib_req_notify_cq(ic-&gt;i_recv_cq, IB_CQ_SOLICITED);
 	if (ret) {
 		rdsdebug(&quot;ib_req_notify_cq recv failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	/* XXX negotiate max send/recv with remote? */
<span class="p_chunk">@@ -344,7 +344,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	ret = rdma_create_qp(ic-&gt;i_cm_id, ic-&gt;i_pd, &amp;attr);
 	if (ret) {
 		rdsdebug(&quot;rdma_create_qp failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	ic-&gt;i_send_hdrs = ib_dma_alloc_coherent(dev,
<span class="p_chunk">@@ -354,7 +354,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_send_hdrs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent send failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto qp_out;</span>
 	}
 
 	ic-&gt;i_recv_hdrs = ib_dma_alloc_coherent(dev,
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_recv_hdrs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent recv failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto send_hdrs_dma_out;</span>
 	}
 
 	ic-&gt;i_ack = ib_dma_alloc_coherent(dev, sizeof(struct rds_header),
<span class="p_chunk">@@ -372,7 +372,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_ack) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent ack failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_hdrs_dma_out;</span>
 	}
 
 	ic-&gt;i_sends = vzalloc_node(ic-&gt;i_send_ring.w_nr * sizeof(struct rds_ib_send_work),
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_sends) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;send allocation failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto ack_dma_out;</span>
 	}
 
 	ic-&gt;i_recvs = vzalloc_node(ic-&gt;i_recv_ring.w_nr * sizeof(struct rds_ib_recv_work),
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_recvs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;recv allocation failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto sends_out;</span>
 	}
 
 	rds_ib_recv_init_ack(ic);
<span class="p_chunk">@@ -396,8 +396,33 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	rdsdebug(&quot;conn %p pd %p mr %p cq %p %p\n&quot;, conn, ic-&gt;i_pd, ic-&gt;i_mr,
 		 ic-&gt;i_send_cq, ic-&gt;i_recv_cq);
 
<span class="p_del">-out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+sends_out:</span>
<span class="p_add">+	vfree(ic-&gt;i_sends);</span>
<span class="p_add">+ack_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, sizeof(struct rds_header),</span>
<span class="p_add">+			     ic-&gt;i_ack, ic-&gt;i_ack_dma);</span>
<span class="p_add">+recv_hdrs_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, ic-&gt;i_recv_ring.w_nr *</span>
<span class="p_add">+					sizeof(struct rds_header),</span>
<span class="p_add">+					ic-&gt;i_recv_hdrs, ic-&gt;i_recv_hdrs_dma);</span>
<span class="p_add">+send_hdrs_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, ic-&gt;i_send_ring.w_nr *</span>
<span class="p_add">+					sizeof(struct rds_header),</span>
<span class="p_add">+					ic-&gt;i_send_hdrs, ic-&gt;i_send_hdrs_dma);</span>
<span class="p_add">+qp_out:</span>
<span class="p_add">+	rdma_destroy_qp(ic-&gt;i_cm_id);</span>
<span class="p_add">+recv_cq_out:</span>
<span class="p_add">+	if (!ib_destroy_cq(ic-&gt;i_recv_cq))</span>
<span class="p_add">+		ic-&gt;i_recv_cq = NULL;</span>
<span class="p_add">+send_cq_out:</span>
<span class="p_add">+	if (!ib_destroy_cq(ic-&gt;i_send_cq))</span>
<span class="p_add">+		ic-&gt;i_send_cq = NULL;</span>
<span class="p_add">+rds_ibdev_out:</span>
<span class="p_add">+	rds_ib_remove_conn(rds_ibdev, conn);</span>
 	rds_ib_dev_put(rds_ibdev);
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/net/rds/ib_send.c b/net/rds/ib_send.c</span>
<span class="p_header">index 1dde91e3dc70..5deecf4cce71 100644</span>
<span class="p_header">--- a/net/rds/ib_send.c</span>
<span class="p_header">+++ b/net/rds/ib_send.c</span>
<span class="p_chunk">@@ -102,16 +102,6 @@</span> <span class="p_context"> static void rds_ib_send_complete(struct rds_message *rm,</span>
 	complete(rm, notify_status);
 }
 
<span class="p_del">-static void rds_ib_send_unmap_data(struct rds_ib_connection *ic,</span>
<span class="p_del">-				   struct rm_data_op *op,</span>
<span class="p_del">-				   int wc_status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (op-&gt;op_nents)</span>
<span class="p_del">-		ib_dma_unmap_sg(ic-&gt;i_cm_id-&gt;device,</span>
<span class="p_del">-				op-&gt;op_sg, op-&gt;op_nents,</span>
<span class="p_del">-				DMA_TO_DEVICE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rds_ib_send_unmap_rdma(struct rds_ib_connection *ic,
 				   struct rm_rdma_op *op,
 				   int wc_status)
<span class="p_chunk">@@ -172,6 +162,21 @@</span> <span class="p_context"> static void rds_ib_send_unmap_atomic(struct rds_ib_connection *ic,</span>
 		rds_ib_stats_inc(s_ib_atomic_fadd);
 }
 
<span class="p_add">+static void rds_ib_send_unmap_data(struct rds_ib_connection *ic,</span>
<span class="p_add">+				   struct rm_data_op *op,</span>
<span class="p_add">+				   int wc_status)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rds_message *rm = container_of(op, struct rds_message, data);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (op-&gt;op_nents)</span>
<span class="p_add">+		ib_dma_unmap_sg(ic-&gt;i_cm_id-&gt;device,</span>
<span class="p_add">+				op-&gt;op_sg, op-&gt;op_nents,</span>
<span class="p_add">+				DMA_TO_DEVICE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rm-&gt;rdma.op_active &amp;&amp; rm-&gt;data.op_notify)</span>
<span class="p_add">+		rds_ib_send_unmap_rdma(ic, &amp;rm-&gt;rdma, wc_status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Unmap the resources associated with a struct send_work.
  *
<span class="p_header">diff --git a/net/rds/rdma.c b/net/rds/rdma.c</span>
<span class="p_header">index 40084d843e9f..3738b1920c09 100644</span>
<span class="p_header">--- a/net/rds/rdma.c</span>
<span class="p_header">+++ b/net/rds/rdma.c</span>
<span class="p_chunk">@@ -625,6 +625,16 @@</span> <span class="p_context"> int rds_cmsg_rdma_args(struct rds_sock *rs, struct rds_message *rm,</span>
 		}
 		op-&gt;op_notifier-&gt;n_user_token = args-&gt;user_token;
 		op-&gt;op_notifier-&gt;n_status = RDS_RDMA_SUCCESS;
<span class="p_add">+</span>
<span class="p_add">+		/* Enable rmda notification on data operation for composite</span>
<span class="p_add">+		 * rds messages and make sure notification is enabled only</span>
<span class="p_add">+		 * for the data operation which follows it so that application</span>
<span class="p_add">+		 * gets notified only after full message gets delivered.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (rm-&gt;data.op_sg) {</span>
<span class="p_add">+			rm-&gt;rdma.op_notify = 0;</span>
<span class="p_add">+			rm-&gt;data.op_notify = !!(args-&gt;flags &amp; RDS_RDMA_NOTIFY_ME);</span>
<span class="p_add">+		}</span>
 	}
 
 	/* The cookie contains the R_Key of the remote memory region, and
<span class="p_header">diff --git a/net/rds/rds.h b/net/rds/rds.h</span>
<span class="p_header">index 48f8ffc60f8f..42af715b63fc 100644</span>
<span class="p_header">--- a/net/rds/rds.h</span>
<span class="p_header">+++ b/net/rds/rds.h</span>
<span class="p_chunk">@@ -360,6 +360,7 @@</span> <span class="p_context"> struct rds_message {</span>
 		} rdma;
 		struct rm_data_op {
 			unsigned int		op_active:1;
<span class="p_add">+			unsigned int		op_notify:1;</span>
 			unsigned int		op_nents;
 			unsigned int		op_count;
 			struct scatterlist	*op_sg;
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index 0bae8d43b012..45b800c3cc83 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -425,12 +425,14 @@</span> <span class="p_context"> void rds_rdma_send_complete(struct rds_message *rm, int status)</span>
 	struct rm_rdma_op *ro;
 	struct rds_notifier *notifier;
 	unsigned long flags;
<span class="p_add">+	unsigned int notify = 0;</span>
 
 	spin_lock_irqsave(&amp;rm-&gt;m_rs_lock, flags);
 
<span class="p_add">+	notify =  rm-&gt;rdma.op_notify | rm-&gt;data.op_notify;</span>
 	ro = &amp;rm-&gt;rdma;
 	if (test_bit(RDS_MSG_ON_SOCK, &amp;rm-&gt;m_flags) &amp;&amp;
<span class="p_del">-	    ro-&gt;op_active &amp;&amp; ro-&gt;op_notify &amp;&amp; ro-&gt;op_notifier) {</span>
<span class="p_add">+	    ro-&gt;op_active &amp;&amp; notify &amp;&amp; ro-&gt;op_notifier) {</span>
 		notifier = ro-&gt;op_notifier;
 		rs = rm-&gt;m_rs;
 		sock_hold(rds_rs_to_sk(rs));
<span class="p_header">diff --git a/sound/pci/au88x0/au88x0_core.c b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">index 72002382a0db..53713278d19d 100644</span>
<span class="p_header">--- a/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">+++ b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_chunk">@@ -2273,6 +2273,9 @@</span> <span class="p_context"> vortex_adb_allocroute(vortex_t *vortex, int dma, int nr_ch, int dir,</span>
 	} else {
 		int src[2], mix[2];
 
<span class="p_add">+		if (nr_ch &lt; 1)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		/* Get SRC and MIXER hardware resources. */
 		for (i = 0; i &lt; nr_ch; i++) {
 			if ((mix[i] =

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



