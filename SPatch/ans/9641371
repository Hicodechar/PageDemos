
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Random guest crashes since 5c34d002dcc7 (&quot;virtio_pci: use shared interrupts for virtqueues&quot;) - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Random guest crashes since 5c34d002dcc7 (&quot;virtio_pci: use shared interrupts for virtqueues&quot;)</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=3140">Richard W.M. Jones</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 23, 2017, 2:59 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170323145903.GE30978@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9641371/mbox/"
   >mbox</a>
|
   <a href="/patch/9641371/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9641371/">/patch/9641371/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	8F0FA601E9 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 23 Mar 2017 14:59:18 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7999528478
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 23 Mar 2017 14:59:18 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6D33E28497; Thu, 23 Mar 2017 14:59:18 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8678228478
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 23 Mar 2017 14:59:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755972AbdCWO7L (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 23 Mar 2017 10:59:11 -0400
Received: from mx1.redhat.com ([209.132.183.28]:34616 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751444AbdCWO7J (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 23 Mar 2017 10:59:09 -0400
Received: from smtp.corp.redhat.com
	(int-mx06.intmail.prod.int.phx2.redhat.com [10.5.11.16])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id CC33370027;
	Thu, 23 Mar 2017 14:59:08 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.3.2 mx1.redhat.com CC33370027
Authentication-Results: ext-mx04.extmail.prod.ext.phx2.redhat.com;
	dmarc=none (p=none dis=none) header.from=redhat.com
Authentication-Results: ext-mx04.extmail.prod.ext.phx2.redhat.com;
	spf=pass smtp.mailfrom=rjones@redhat.com
DKIM-Filter: OpenDKIM Filter v2.11.0 mx1.redhat.com CC33370027
Received: from localhost (ovpn-116-64.ams2.redhat.com [10.36.116.64])
	by smtp.corp.redhat.com (Postfix) with ESMTP id 012D977550;
	Thu, 23 Mar 2017 14:59:05 +0000 (UTC)
Date: Thu, 23 Mar 2017 14:59:03 +0000
From: &quot;Richard W.M. Jones&quot; &lt;rjones@redhat.com&gt;
To: Thorsten Leemhuis &lt;linux@leemhuis.info&gt;
Cc: mst@redhat.com, hch@lst.de, virtio-dev@lists.oasis-open.org,
	Linux Kernel Mailing List &lt;linux-kernel@vger.kernel.org&gt;
Subject: Re: Random guest crashes since 5c34d002dcc7 (&quot;virtio_pci: use shared
	interrupts for virtqueues&quot;)
Message-ID: &lt;20170323145903.GE30978@redhat.com&gt;
References: &lt;f49abfcc-723e-fa91-bda0-198f4a0da0c0@leemhuis.info&gt;
MIME-Version: 1.0
Content-Type: multipart/mixed; boundary=&quot;Bn2rw/3z4jIqBvZU&quot;
Content-Disposition: inline
In-Reply-To: &lt;f49abfcc-723e-fa91-bda0-198f4a0da0c0@leemhuis.info&gt;
User-Agent: Mutt/1.5.20 (2009-12-10)
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.16
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.28]);
	Thu, 23 Mar 2017 14:59:09 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=3140">Richard W.M. Jones</a> - March 23, 2017, 2:59 p.m.</div>
<pre class="content">
On Thu, Mar 23, 2017 at 03:51:25PM +0100, Thorsten Leemhuis wrote:
<span class="quote">&gt; Hi Christoph! Hi Michael!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; (Mail roughly based on text from</span>
<span class="quote">&gt; https://bugzilla.kernel.org/show_bug.cgi?id=194911 )</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m seeing random crashes during boot every few boot attempts when</span>
<span class="quote">&gt; running Linux 4.11-rc/mainline in a Fedora 26 guest under a CentOS7 host</span>
<span class="quote">&gt; (CPU: Intel(R) Pentium(R) CPU G3220) using KVM. Sometimes when the guest</span>
<span class="quote">&gt; actually booted the network did not work. To get some impressions of the</span>
<span class="quote">&gt; crashes I got see this gallery:</span>
<span class="quote">&gt; https://plus.google.com/+ThorstenLeemhuis/posts/FjyyGjNtrrG</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Richard W.M. Jones and Adam Williamson see the same problems. See above</span>
<span class="quote">&gt; bug for details. It seems they ran into the problem in the past few</span>
<span class="quote">&gt; days, so I assume it&#39;s still present in mainline (I&#39;m travelling</span>
<span class="quote">&gt; currently and haven&#39;t had time for proper tests since last last Friday</span>
<span class="quote">&gt; (pre-rc3); but I thought it&#39;s time to get the problem to the lists).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Long story short: Richard and I did bisections and we both found that</span>
<span class="quote">&gt; https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=07ec51480b5e</span>
<span class="quote">&gt; (&quot;virtio_pci: use shared interrupts for virtqueues&quot;) is the first bad</span>
<span class="quote">&gt; commit. Any idea what might be wrong? Do you need more details from us</span>
<span class="quote">&gt; to fix this?</span>

Laura Abbott posted a kernel RPM which works for me.  She has had to
revert quite a number of commits, which are detailed in this comment:

  https://bugzilla.redhat.com/show_bug.cgi?id=1430297#c7

Her reverting patch is also attached.

Rich.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/block/Kconfig b/block/Kconfig</span>
<span class="p_header">index e9f780f..a2a92e5 100644</span>
<span class="p_header">--- a/block/Kconfig</span>
<span class="p_header">+++ b/block/Kconfig</span>
<span class="p_chunk">@@ -189,9 +189,4 @@</span> <span class="p_context"> config BLK_MQ_PCI</span>
 	depends on BLOCK &amp;&amp; PCI
 	default y
 
<span class="p_del">-config BLK_MQ_VIRTIO</span>
<span class="p_del">-	bool</span>
<span class="p_del">-	depends on BLOCK &amp;&amp; VIRTIO</span>
<span class="p_del">-	default y</span>
<span class="p_del">-</span>
 source block/Kconfig.iosched
<span class="p_header">diff --git a/block/Makefile b/block/Makefile</span>
<span class="p_header">index 081bb68..2ad7c30 100644</span>
<span class="p_header">--- a/block/Makefile</span>
<span class="p_header">+++ b/block/Makefile</span>
<span class="p_chunk">@@ -25,7 +25,6 @@</span> <span class="p_context"> obj-$(CONFIG_BLOCK_COMPAT)	+= compat_ioctl.o</span>
 obj-$(CONFIG_BLK_CMDLINE_PARSER)	+= cmdline-parser.o
 obj-$(CONFIG_BLK_DEV_INTEGRITY) += bio-integrity.o blk-integrity.o t10-pi.o
 obj-$(CONFIG_BLK_MQ_PCI)	+= blk-mq-pci.o
<span class="p_del">-obj-$(CONFIG_BLK_MQ_VIRTIO)	+= blk-mq-virtio.o</span>
 obj-$(CONFIG_BLK_DEV_ZONED)	+= blk-zoned.o
 obj-$(CONFIG_BLK_WBT)		+= blk-wbt.o
 obj-$(CONFIG_BLK_DEBUG_FS)	+= blk-mq-debugfs.o
<span class="p_header">diff --git a/block/blk-mq-virtio.c b/block/blk-mq-virtio.c</span>
deleted file mode 100644
<span class="p_header">index c3afbca..0000000</span>
<span class="p_header">--- a/block/blk-mq-virtio.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,54 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (c) 2016 Christoph Hellwig.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify it</span>
<span class="p_del">- * under the terms and conditions of the GNU General Public License,</span>
<span class="p_del">- * version 2, as published by the Free Software Foundation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope it will be useful, but WITHOUT</span>
<span class="p_del">- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
<span class="p_del">- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
<span class="p_del">- * more details.</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &lt;linux/device.h&gt;</span>
<span class="p_del">-#include &lt;linux/blk-mq.h&gt;</span>
<span class="p_del">-#include &lt;linux/blk-mq-virtio.h&gt;</span>
<span class="p_del">-#include &lt;linux/virtio_config.h&gt;</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &quot;blk-mq.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * blk_mq_virtio_map_queues - provide a default queue mapping for virtio device</span>
<span class="p_del">- * @set:	tagset to provide the mapping for</span>
<span class="p_del">- * @vdev:	virtio device associated with @set.</span>
<span class="p_del">- * @first_vec:	first interrupt vectors to use for queues (usually 0)</span>
<span class="p_del">- *</span>
<span class="p_del">- * This function assumes the virtio device @vdev has at least as many available</span>
<span class="p_del">- * interrupt vetors as @set has queues.  It will then queuery the vector</span>
<span class="p_del">- * corresponding to each queue for it&#39;s affinity mask and built queue mapping</span>
<span class="p_del">- * that maps a queue to the CPUs that have irq affinity for the corresponding</span>
<span class="p_del">- * vector.</span>
<span class="p_del">- */</span>
<span class="p_del">-int blk_mq_virtio_map_queues(struct blk_mq_tag_set *set,</span>
<span class="p_del">-		struct virtio_device *vdev, int first_vec)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct cpumask *mask;</span>
<span class="p_del">-	unsigned int queue, cpu;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!vdev-&gt;config-&gt;get_vq_affinity)</span>
<span class="p_del">-		goto fallback;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (queue = 0; queue &lt; set-&gt;nr_hw_queues; queue++) {</span>
<span class="p_del">-		mask = vdev-&gt;config-&gt;get_vq_affinity(vdev, first_vec + queue);</span>
<span class="p_del">-		if (!mask)</span>
<span class="p_del">-			goto fallback;</span>
<span class="p_del">-</span>
<span class="p_del">-		for_each_cpu(cpu, mask)</span>
<span class="p_del">-			set-&gt;mq_map[cpu] = queue;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-fallback:</span>
<span class="p_del">-	return blk_mq_map_queues(set);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(blk_mq_virtio_map_queues);</span>
<span class="p_header">diff --git a/drivers/block/virtio_blk.c b/drivers/block/virtio_blk.c</span>
<span class="p_header">index 1d4c9f8..024b473 100644</span>
<span class="p_header">--- a/drivers/block/virtio_blk.c</span>
<span class="p_header">+++ b/drivers/block/virtio_blk.c</span>
<span class="p_chunk">@@ -5,7 +5,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/hdreg.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/mutex.h&gt;
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
 #include &lt;linux/virtio.h&gt;
 #include &lt;linux/virtio_blk.h&gt;
 #include &lt;linux/scatterlist.h&gt;
<span class="p_chunk">@@ -13,7 +12,6 @@</span> <span class="p_context"></span>
 #include &lt;scsi/scsi_cmnd.h&gt;
 #include &lt;linux/idr.h&gt;
 #include &lt;linux/blk-mq.h&gt;
<span class="p_del">-#include &lt;linux/blk-mq-virtio.h&gt;</span>
 #include &lt;linux/numa.h&gt;
 
 #define PART_BITS 4
<span class="p_chunk">@@ -428,7 +426,6 @@</span> <span class="p_context"> static int init_vq(struct virtio_blk *vblk)</span>
 	struct virtqueue **vqs;
 	unsigned short num_vqs;
 	struct virtio_device *vdev = vblk-&gt;vdev;
<span class="p_del">-	struct irq_affinity desc = { 0, };</span>
 
 	err = virtio_cread_feature(vdev, VIRTIO_BLK_F_MQ,
 				   struct virtio_blk_config, num_queues,
<span class="p_chunk">@@ -455,8 +452,7 @@</span> <span class="p_context"> static int init_vq(struct virtio_blk *vblk)</span>
 	}
 
 	/* Discover virtqueues and write information to configuration.  */
<span class="p_del">-	err = vdev-&gt;config-&gt;find_vqs(vdev, num_vqs, vqs, callbacks, names,</span>
<span class="p_del">-			&amp;desc);</span>
<span class="p_add">+	err = vdev-&gt;config-&gt;find_vqs(vdev, num_vqs, vqs, callbacks, names);</span>
 	if (err)
 		goto out;
 
<span class="p_chunk">@@ -590,18 +586,10 @@</span> <span class="p_context"> static int virtblk_init_request(void *data, struct request *rq,</span>
 	return 0;
 }
 
<span class="p_del">-static int virtblk_map_queues(struct blk_mq_tag_set *set)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtio_blk *vblk = set-&gt;driver_data;</span>
<span class="p_del">-</span>
<span class="p_del">-	return blk_mq_virtio_map_queues(set, vblk-&gt;vdev, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct blk_mq_ops virtio_mq_ops = {
 	.queue_rq	= virtio_queue_rq,
 	.complete	= virtblk_request_done,
 	.init_request	= virtblk_init_request,
<span class="p_del">-	.map_queues	= virtblk_map_queues,</span>
 };
 
 static unsigned int virtblk_queue_depth;
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index e9b7e0b..17857be 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -1136,8 +1136,6 @@</span> <span class="p_context"> static int put_chars(u32 vtermno, const char *buf, int count)</span>
 {
 	struct port *port;
 	struct scatterlist sg[1];
<span class="p_del">-	void *data;</span>
<span class="p_del">-	int ret;</span>
 
 	if (unlikely(early_put_chars))
 		return early_put_chars(vtermno, buf, count);
<span class="p_chunk">@@ -1146,14 +1144,8 @@</span> <span class="p_context"> static int put_chars(u32 vtermno, const char *buf, int count)</span>
 	if (!port)
 		return -EPIPE;
 
<span class="p_del">-	data = kmemdup(buf, count, GFP_ATOMIC);</span>
<span class="p_del">-	if (!data)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	sg_init_one(sg, data, count);</span>
<span class="p_del">-	ret = __send_to_port(port, sg, 1, count, data, false);</span>
<span class="p_del">-	kfree(data);</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	sg_init_one(sg, buf, count);</span>
<span class="p_add">+	return __send_to_port(port, sg, 1, count, (void *)buf, false);</span>
 }
 
 /*
<span class="p_chunk">@@ -1947,7 +1939,7 @@</span> <span class="p_context"> static int init_vqs(struct ports_device *portdev)</span>
 	/* Find the queues. */
 	err = portdev-&gt;vdev-&gt;config-&gt;find_vqs(portdev-&gt;vdev, nr_queues, vqs,
 					      io_callbacks,
<span class="p_del">-					      (const char **)io_names, NULL);</span>
<span class="p_add">+					      (const char **)io_names);</span>
 	if (err)
 		goto free;
 
<span class="p_header">diff --git a/drivers/crypto/virtio/virtio_crypto_core.c b/drivers/crypto/virtio/virtio_crypto_core.c</span>
<span class="p_header">index 21472e4..b5b1533 100644</span>
<span class="p_header">--- a/drivers/crypto/virtio/virtio_crypto_core.c</span>
<span class="p_header">+++ b/drivers/crypto/virtio/virtio_crypto_core.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static int virtcrypto_find_vqs(struct virtio_crypto *vi)</span>
 	}
 
 	ret = vi-&gt;vdev-&gt;config-&gt;find_vqs(vi-&gt;vdev, total_vqs, vqs, callbacks,
<span class="p_del">-					 names, NULL);</span>
<span class="p_add">+					 names);</span>
 	if (ret)
 		goto err_find;
 
<span class="p_header">diff --git a/drivers/gpu/drm/virtio/virtgpu_kms.c b/drivers/gpu/drm/virtio/virtgpu_kms.c</span>
<span class="p_header">index 4918668..30f989a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/virtio/virtgpu_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/virtio/virtgpu_kms.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> int virtio_gpu_driver_load(struct drm_device *dev, unsigned long flags)</span>
 #endif
 
 	ret = vgdev-&gt;vdev-&gt;config-&gt;find_vqs(vgdev-&gt;vdev, 2, vqs,
<span class="p_del">-					    callbacks, names, NULL);</span>
<span class="p_add">+					    callbacks, names);</span>
 	if (ret) {
 		DRM_ERROR(&quot;failed to find virt queues\n&quot;);
 		goto err_vqs;
<span class="p_header">diff --git a/drivers/misc/mic/vop/vop_main.c b/drivers/misc/mic/vop/vop_main.c</span>
<span class="p_header">index c2e29d7..1a2b67f3 100644</span>
<span class="p_header">--- a/drivers/misc/mic/vop/vop_main.c</span>
<span class="p_header">+++ b/drivers/misc/mic/vop/vop_main.c</span>
<span class="p_chunk">@@ -374,7 +374,7 @@</span> <span class="p_context"> static struct virtqueue *vop_find_vq(struct virtio_device *dev,</span>
 static int vop_find_vqs(struct virtio_device *dev, unsigned nvqs,
 			struct virtqueue *vqs[],
 			vq_callback_t *callbacks[],
<span class="p_del">-			const char * const names[], struct irq_affinity *desc)</span>
<span class="p_add">+			const char * const names[])</span>
 {
 	struct _vop_vdev *vdev = to_vopvdev(dev);
 	struct vop_device *vpdev = vdev-&gt;vpdev;
<span class="p_header">diff --git a/drivers/net/caif/caif_virtio.c b/drivers/net/caif/caif_virtio.c</span>
<span class="p_header">index bc0eb47..b306210 100644</span>
<span class="p_header">--- a/drivers/net/caif/caif_virtio.c</span>
<span class="p_header">+++ b/drivers/net/caif/caif_virtio.c</span>
<span class="p_chunk">@@ -679,8 +679,7 @@</span> <span class="p_context"> static int cfv_probe(struct virtio_device *vdev)</span>
 		goto err;
 
 	/* Get the TX virtio ring. This is a &quot;guest side vring&quot;. */
<span class="p_del">-	err = vdev-&gt;config-&gt;find_vqs(vdev, 1, &amp;cfv-&gt;vq_tx, &amp;vq_cbs, &amp;names,</span>
<span class="p_del">-			NULL);</span>
<span class="p_add">+	err = vdev-&gt;config-&gt;find_vqs(vdev, 1, &amp;cfv-&gt;vq_tx, &amp;vq_cbs, &amp;names);</span>
 	if (err)
 		goto err;
 
<span class="p_header">diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c</span>
<span class="p_header">index ea9890d..e9d7e2b 100644</span>
<span class="p_header">--- a/drivers/net/virtio_net.c</span>
<span class="p_header">+++ b/drivers/net/virtio_net.c</span>
<span class="p_chunk">@@ -2080,7 +2080,7 @@</span> <span class="p_context"> static int virtnet_find_vqs(struct virtnet_info *vi)</span>
 	}
 
 	ret = vi-&gt;vdev-&gt;config-&gt;find_vqs(vi-&gt;vdev, total_vqs, vqs, callbacks,
<span class="p_del">-					 names, NULL);</span>
<span class="p_add">+					 names);</span>
 	if (ret)
 		goto err_find;
 
<span class="p_header">diff --git a/drivers/remoteproc/remoteproc_virtio.c b/drivers/remoteproc/remoteproc_virtio.c</span>
<span class="p_header">index 0142cc3..364411f 100644</span>
<span class="p_header">--- a/drivers/remoteproc/remoteproc_virtio.c</span>
<span class="p_header">+++ b/drivers/remoteproc/remoteproc_virtio.c</span>
<span class="p_chunk">@@ -137,8 +137,7 @@</span> <span class="p_context"> static void rproc_virtio_del_vqs(struct virtio_device *vdev)</span>
 static int rproc_virtio_find_vqs(struct virtio_device *vdev, unsigned int nvqs,
 				 struct virtqueue *vqs[],
 				 vq_callback_t *callbacks[],
<span class="p_del">-				 const char * const names[],</span>
<span class="p_del">-				 struct irq_affinity *desc)</span>
<span class="p_add">+				 const char * const names[])</span>
 {
 	int i, ret;
 
<span class="p_header">diff --git a/drivers/rpmsg/virtio_rpmsg_bus.c b/drivers/rpmsg/virtio_rpmsg_bus.c</span>
<span class="p_header">index 5e66e08..3090b0d 100644</span>
<span class="p_header">--- a/drivers/rpmsg/virtio_rpmsg_bus.c</span>
<span class="p_header">+++ b/drivers/rpmsg/virtio_rpmsg_bus.c</span>
<span class="p_chunk">@@ -869,7 +869,7 @@</span> <span class="p_context"> static int rpmsg_probe(struct virtio_device *vdev)</span>
 	init_waitqueue_head(&amp;vrp-&gt;sendq);
 
 	/* We expect two virtqueues, rx and tx (and in this order) */
<span class="p_del">-	err = vdev-&gt;config-&gt;find_vqs(vdev, 2, vqs, vq_cbs, names, NULL);</span>
<span class="p_add">+	err = vdev-&gt;config-&gt;find_vqs(vdev, 2, vqs, vq_cbs, names);</span>
 	if (err)
 		goto free_vrp;
 
<span class="p_header">diff --git a/drivers/s390/virtio/kvm_virtio.c b/drivers/s390/virtio/kvm_virtio.c</span>
<span class="p_header">index 2ce0b3e..5e5c11f 100644</span>
<span class="p_header">--- a/drivers/s390/virtio/kvm_virtio.c</span>
<span class="p_header">+++ b/drivers/s390/virtio/kvm_virtio.c</span>
<span class="p_chunk">@@ -255,8 +255,7 @@</span> <span class="p_context"> static void kvm_del_vqs(struct virtio_device *vdev)</span>
 static int kvm_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			struct virtqueue *vqs[],
 			vq_callback_t *callbacks[],
<span class="p_del">-			const char * const names[],</span>
<span class="p_del">-			struct irq_affinity *desc)</span>
<span class="p_add">+			const char * const names[])</span>
 {
 	struct kvm_device *kdev = to_kvmdev(vdev);
 	int i;
<span class="p_header">diff --git a/drivers/s390/virtio/virtio_ccw.c b/drivers/s390/virtio/virtio_ccw.c</span>
<span class="p_header">index 0ed209f..648373c 100644</span>
<span class="p_header">--- a/drivers/s390/virtio/virtio_ccw.c</span>
<span class="p_header">+++ b/drivers/s390/virtio/virtio_ccw.c</span>
<span class="p_chunk">@@ -628,8 +628,7 @@</span> <span class="p_context"> static int virtio_ccw_register_adapter_ind(struct virtio_ccw_device *vcdev,</span>
 static int virtio_ccw_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 			       struct virtqueue *vqs[],
 			       vq_callback_t *callbacks[],
<span class="p_del">-			       const char * const names[],</span>
<span class="p_del">-			       struct irq_affinity *desc)</span>
<span class="p_add">+			       const char * const names[])</span>
 {
 	struct virtio_ccw_device *vcdev = to_vc_device(vdev);
 	unsigned long *indicatorp = NULL;
<span class="p_header">diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">index 939c47d..c680d76 100644</span>
<span class="p_header">--- a/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">+++ b/drivers/scsi/virtio_scsi.c</span>
<span class="p_chunk">@@ -18,7 +18,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/mempool.h&gt;
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
 #include &lt;linux/virtio.h&gt;
 #include &lt;linux/virtio_ids.h&gt;
 #include &lt;linux/virtio_config.h&gt;
<span class="p_chunk">@@ -30,7 +29,6 @@</span> <span class="p_context"></span>
 #include &lt;scsi/scsi_cmnd.h&gt;
 #include &lt;scsi/scsi_tcq.h&gt;
 #include &lt;linux/seqlock.h&gt;
<span class="p_del">-#include &lt;linux/blk-mq-virtio.h&gt;</span>
 
 #define VIRTIO_SCSI_MEMPOOL_SZ 64
 #define VIRTIO_SCSI_EVENT_LEN 8
<span class="p_chunk">@@ -110,6 +108,7 @@</span> <span class="p_context"> struct virtio_scsi {</span>
 	bool affinity_hint_set;
 
 	struct hlist_node node;
<span class="p_add">+	struct hlist_node node_dead;</span>
 
 	/* Protected by event_vq lock */
 	bool stop_events;
<span class="p_chunk">@@ -119,6 +118,7 @@</span> <span class="p_context"> struct virtio_scsi {</span>
 	struct virtio_scsi_vq req_vqs[];
 };
 
<span class="p_add">+static enum cpuhp_state virtioscsi_online;</span>
 static struct kmem_cache *virtscsi_cmd_cache;
 static mempool_t *virtscsi_cmd_pool;
 
<span class="p_chunk">@@ -766,13 +766,6 @@</span> <span class="p_context"> static void virtscsi_target_destroy(struct scsi_target *starget)</span>
 	kfree(tgt);
 }
 
<span class="p_del">-static int virtscsi_map_queues(struct Scsi_Host *shost)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtio_scsi *vscsi = shost_priv(shost);</span>
<span class="p_del">-</span>
<span class="p_del">-	return blk_mq_virtio_map_queues(&amp;shost-&gt;tag_set, vscsi-&gt;vdev, 2);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct scsi_host_template virtscsi_host_template_single = {
 	.module = THIS_MODULE,
 	.name = &quot;Virtio SCSI HBA&quot;,
<span class="p_chunk">@@ -808,7 +801,6 @@</span> <span class="p_context"> static struct scsi_host_template virtscsi_host_template_multi = {</span>
 	.use_clustering = ENABLE_CLUSTERING,
 	.target_alloc = virtscsi_target_alloc,
 	.target_destroy = virtscsi_target_destroy,
<span class="p_del">-	.map_queues = virtscsi_map_queues,</span>
 	.track_queue_depth = 1,
 };
 
<span class="p_chunk">@@ -825,6 +817,80 @@</span> <span class="p_context"> static struct scsi_host_template virtscsi_host_template_multi = {</span>
 		virtio_cwrite(vdev, struct virtio_scsi_config, fld, &amp;__val); \
 	} while(0)
 
<span class="p_add">+static void __virtscsi_set_affinity(struct virtio_scsi *vscsi, bool affinity)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* In multiqueue mode, when the number of cpu is equal</span>
<span class="p_add">+	 * to the number of request queues, we let the qeueues</span>
<span class="p_add">+	 * to be private to one cpu by setting the affinity hint</span>
<span class="p_add">+	 * to eliminate the contention.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((vscsi-&gt;num_queues == 1 ||</span>
<span class="p_add">+	     vscsi-&gt;num_queues != num_online_cpus()) &amp;&amp; affinity) {</span>
<span class="p_add">+		if (vscsi-&gt;affinity_hint_set)</span>
<span class="p_add">+			affinity = false;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (affinity) {</span>
<span class="p_add">+		i = 0;</span>
<span class="p_add">+		for_each_online_cpu(cpu) {</span>
<span class="p_add">+			virtqueue_set_affinity(vscsi-&gt;req_vqs[i].vq, cpu);</span>
<span class="p_add">+			i++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		vscsi-&gt;affinity_hint_set = true;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		for (i = 0; i &lt; vscsi-&gt;num_queues; i++) {</span>
<span class="p_add">+			if (!vscsi-&gt;req_vqs[i].vq)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			virtqueue_set_affinity(vscsi-&gt;req_vqs[i].vq, -1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		vscsi-&gt;affinity_hint_set = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void virtscsi_set_affinity(struct virtio_scsi *vscsi, bool affinity)</span>
<span class="p_add">+{</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+	__virtscsi_set_affinity(vscsi, affinity);</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int virtscsi_cpu_online(unsigned int cpu, struct hlist_node *node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct virtio_scsi *vscsi = hlist_entry_safe(node, struct virtio_scsi,</span>
<span class="p_add">+						     node);</span>
<span class="p_add">+	__virtscsi_set_affinity(vscsi, true);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int virtscsi_cpu_notif_add(struct virtio_scsi *vi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = cpuhp_state_add_instance(virtioscsi_online, &amp;vi-&gt;node);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = cpuhp_state_add_instance(CPUHP_VIRT_SCSI_DEAD, &amp;vi-&gt;node_dead);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		cpuhp_state_remove_instance(virtioscsi_online, &amp;vi-&gt;node);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void virtscsi_cpu_notif_remove(struct virtio_scsi *vi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cpuhp_state_remove_instance_nocalls(virtioscsi_online, &amp;vi-&gt;node);</span>
<span class="p_add">+	cpuhp_state_remove_instance_nocalls(CPUHP_VIRT_SCSI_DEAD,</span>
<span class="p_add">+					    &amp;vi-&gt;node_dead);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void virtscsi_init_vq(struct virtio_scsi_vq *virtscsi_vq,
 			     struct virtqueue *vq)
 {
<span class="p_chunk">@@ -834,8 +900,14 @@</span> <span class="p_context"> static void virtscsi_init_vq(struct virtio_scsi_vq *virtscsi_vq,</span>
 
 static void virtscsi_remove_vqs(struct virtio_device *vdev)
 {
<span class="p_add">+	struct Scsi_Host *sh = virtio_scsi_host(vdev);</span>
<span class="p_add">+	struct virtio_scsi *vscsi = shost_priv(sh);</span>
<span class="p_add">+</span>
<span class="p_add">+	virtscsi_set_affinity(vscsi, false);</span>
<span class="p_add">+</span>
 	/* Stop all the virtqueues. */
 	vdev-&gt;config-&gt;reset(vdev);
<span class="p_add">+</span>
 	vdev-&gt;config-&gt;del_vqs(vdev);
 }
 
<span class="p_chunk">@@ -848,7 +920,6 @@</span> <span class="p_context"> static int virtscsi_init(struct virtio_device *vdev,</span>
 	vq_callback_t **callbacks;
 	const char **names;
 	struct virtqueue **vqs;
<span class="p_del">-	struct irq_affinity desc = { .pre_vectors = 2 };</span>
 
 	num_vqs = vscsi-&gt;num_queues + VIRTIO_SCSI_VQ_BASE;
 	vqs = kmalloc(num_vqs * sizeof(struct virtqueue *), GFP_KERNEL);
<span class="p_chunk">@@ -870,8 +941,7 @@</span> <span class="p_context"> static int virtscsi_init(struct virtio_device *vdev,</span>
 	}
 
 	/* Discover virtqueues and write information to configuration.  */
<span class="p_del">-	err = vdev-&gt;config-&gt;find_vqs(vdev, num_vqs, vqs, callbacks, names,</span>
<span class="p_del">-			&amp;desc);</span>
<span class="p_add">+	err = vdev-&gt;config-&gt;find_vqs(vdev, num_vqs, vqs, callbacks, names);</span>
 	if (err)
 		goto out;
 
<span class="p_chunk">@@ -937,6 +1007,10 @@</span> <span class="p_context"> static int virtscsi_probe(struct virtio_device *vdev)</span>
 	if (err)
 		goto virtscsi_init_failed;
 
<span class="p_add">+	err = virtscsi_cpu_notif_add(vscsi);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto scsi_add_host_failed;</span>
<span class="p_add">+</span>
 	cmd_per_lun = virtscsi_config_get(vdev, cmd_per_lun) ?: 1;
 	shost-&gt;cmd_per_lun = min_t(u32, cmd_per_lun, shost-&gt;can_queue);
 	shost-&gt;max_sectors = virtscsi_config_get(vdev, max_sectors) ?: 0xFFFF;
<span class="p_chunk">@@ -991,6 +1065,9 @@</span> <span class="p_context"> static void virtscsi_remove(struct virtio_device *vdev)</span>
 		virtscsi_cancel_event_work(vscsi);
 
 	scsi_remove_host(shost);
<span class="p_add">+</span>
<span class="p_add">+	virtscsi_cpu_notif_remove(vscsi);</span>
<span class="p_add">+</span>
 	virtscsi_remove_vqs(vdev);
 	scsi_host_put(shost);
 }
<span class="p_chunk">@@ -998,6 +1075,10 @@</span> <span class="p_context"> static void virtscsi_remove(struct virtio_device *vdev)</span>
 #ifdef CONFIG_PM_SLEEP
 static int virtscsi_freeze(struct virtio_device *vdev)
 {
<span class="p_add">+	struct Scsi_Host *sh = virtio_scsi_host(vdev);</span>
<span class="p_add">+	struct virtio_scsi *vscsi = shost_priv(sh);</span>
<span class="p_add">+</span>
<span class="p_add">+	virtscsi_cpu_notif_remove(vscsi);</span>
 	virtscsi_remove_vqs(vdev);
 	return 0;
 }
<span class="p_chunk">@@ -1012,6 +1093,11 @@</span> <span class="p_context"> static int virtscsi_restore(struct virtio_device *vdev)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	err = virtscsi_cpu_notif_add(vscsi);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		vdev-&gt;config-&gt;del_vqs(vdev);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
 	virtio_device_ready(vdev);
 
 	if (virtio_has_feature(vdev, VIRTIO_SCSI_F_HOTPLUG))
<span class="p_chunk">@@ -1066,6 +1152,16 @@</span> <span class="p_context"> static int __init init(void)</span>
 		pr_err(&quot;mempool_create() for virtscsi_cmd_pool failed\n&quot;);
 		goto error;
 	}
<span class="p_add">+	ret = cpuhp_setup_state_multi(CPUHP_AP_ONLINE_DYN,</span>
<span class="p_add">+				      &quot;scsi/virtio:online&quot;,</span>
<span class="p_add">+				      virtscsi_cpu_online, NULL);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	virtioscsi_online = ret;</span>
<span class="p_add">+	ret = cpuhp_setup_state_multi(CPUHP_VIRT_SCSI_DEAD, &quot;scsi/virtio:dead&quot;,</span>
<span class="p_add">+				      NULL, virtscsi_cpu_online);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto error;</span>
 	ret = register_virtio_driver(&amp;virtio_scsi_driver);
 	if (ret &lt; 0)
 		goto error;
<span class="p_chunk">@@ -1081,12 +1177,17 @@</span> <span class="p_context"> static int __init init(void)</span>
 		kmem_cache_destroy(virtscsi_cmd_cache);
 		virtscsi_cmd_cache = NULL;
 	}
<span class="p_add">+	if (virtioscsi_online)</span>
<span class="p_add">+		cpuhp_remove_multi_state(virtioscsi_online);</span>
<span class="p_add">+	cpuhp_remove_multi_state(CPUHP_VIRT_SCSI_DEAD);</span>
 	return ret;
 }
 
 static void __exit fini(void)
 {
 	unregister_virtio_driver(&amp;virtio_scsi_driver);
<span class="p_add">+	cpuhp_remove_multi_state(virtioscsi_online);</span>
<span class="p_add">+	cpuhp_remove_multi_state(CPUHP_VIRT_SCSI_DEAD);</span>
 	mempool_destroy(virtscsi_cmd_pool);
 	kmem_cache_destroy(virtscsi_cmd_cache);
 }
<span class="p_header">diff --git a/drivers/vhost/vhost.c b/drivers/vhost/vhost.c</span>
<span class="p_header">index f0ba362..c323bce 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.c</span>
<span class="p_header">+++ b/drivers/vhost/vhost.c</span>
<span class="p_chunk">@@ -284,22 +284,6 @@</span> <span class="p_context"> void vhost_poll_queue(struct vhost_poll *poll)</span>
 }
 EXPORT_SYMBOL_GPL(vhost_poll_queue);
 
<span class="p_del">-static void __vhost_vq_meta_reset(struct vhost_virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int j;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (j = 0; j &lt; VHOST_NUM_ADDRS; j++)</span>
<span class="p_del">-		vq-&gt;meta_iotlb[j] = NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void vhost_vq_meta_reset(struct vhost_dev *d)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; d-&gt;nvqs; ++i)</span>
<span class="p_del">-		__vhost_vq_meta_reset(d-&gt;vqs[i]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void vhost_vq_reset(struct vhost_dev *dev,
 			   struct vhost_virtqueue *vq)
 {
<span class="p_chunk">@@ -330,7 +314,6 @@</span> <span class="p_context"> static void vhost_vq_reset(struct vhost_dev *dev,</span>
 	vq-&gt;busyloop_timeout = 0;
 	vq-&gt;umem = NULL;
 	vq-&gt;iotlb = NULL;
<span class="p_del">-	__vhost_vq_meta_reset(vq);</span>
 }
 
 static int vhost_worker(void *data)
<span class="p_chunk">@@ -710,18 +693,6 @@</span> <span class="p_context"> static int vq_memory_access_ok(void __user *log_base, struct vhost_umem *umem,</span>
 	return 1;
 }
 
<span class="p_del">-static inline void __user *vhost_vq_meta_fetch(struct vhost_virtqueue *vq,</span>
<span class="p_del">-					       u64 addr, unsigned int size,</span>
<span class="p_del">-					       int type)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct vhost_umem_node *node = vq-&gt;meta_iotlb[type];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!node)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return (void *)(uintptr_t)(node-&gt;userspace_addr + addr - node-&gt;start);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Can we switch to this memory table? */
 /* Caller should have device mutex but not vq mutex */
 static int memory_access_ok(struct vhost_dev *d, struct vhost_umem *umem,
<span class="p_chunk">@@ -764,14 +735,8 @@</span> <span class="p_context"> static int vhost_copy_to_user(struct vhost_virtqueue *vq, void __user *to,</span>
 		 * could be access through iotlb. So -EAGAIN should
 		 * not happen in this case.
 		 */
<span class="p_add">+		/* TODO: more fast path */</span>
 		struct iov_iter t;
<span class="p_del">-		void __user *uaddr = vhost_vq_meta_fetch(vq,</span>
<span class="p_del">-				     (u64)(uintptr_t)to, size,</span>
<span class="p_del">-				     VHOST_ADDR_DESC);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (uaddr)</span>
<span class="p_del">-			return __copy_to_user(uaddr, from, size);</span>
<span class="p_del">-</span>
 		ret = translate_desc(vq, (u64)(uintptr_t)to, size, vq-&gt;iotlb_iov,
 				     ARRAY_SIZE(vq-&gt;iotlb_iov),
 				     VHOST_ACCESS_WO);
<span class="p_chunk">@@ -799,14 +764,8 @@</span> <span class="p_context"> static int vhost_copy_from_user(struct vhost_virtqueue *vq, void *to,</span>
 		 * could be access through iotlb. So -EAGAIN should
 		 * not happen in this case.
 		 */
<span class="p_del">-		void __user *uaddr = vhost_vq_meta_fetch(vq,</span>
<span class="p_del">-				     (u64)(uintptr_t)from, size,</span>
<span class="p_del">-				     VHOST_ADDR_DESC);</span>
<span class="p_add">+		/* TODO: more fast path */</span>
 		struct iov_iter f;
<span class="p_del">-</span>
<span class="p_del">-		if (uaddr)</span>
<span class="p_del">-			return __copy_from_user(to, uaddr, size);</span>
<span class="p_del">-</span>
 		ret = translate_desc(vq, (u64)(uintptr_t)from, size, vq-&gt;iotlb_iov,
 				     ARRAY_SIZE(vq-&gt;iotlb_iov),
 				     VHOST_ACCESS_RO);
<span class="p_chunk">@@ -826,12 +785,17 @@</span> <span class="p_context"> static int vhost_copy_from_user(struct vhost_virtqueue *vq, void *to,</span>
 	return ret;
 }
 
<span class="p_del">-static void __user *__vhost_get_user_slow(struct vhost_virtqueue *vq,</span>
<span class="p_del">-					  void __user *addr, unsigned int size,</span>
<span class="p_del">-					  int type)</span>
<span class="p_add">+static void __user *__vhost_get_user(struct vhost_virtqueue *vq,</span>
<span class="p_add">+				     void __user *addr, unsigned size)</span>
 {
 	int ret;
 
<span class="p_add">+	/* This function should be called after iotlb</span>
<span class="p_add">+	 * prefetch, which means we&#39;re sure that vq</span>
<span class="p_add">+	 * could be access through iotlb. So -EAGAIN should</span>
<span class="p_add">+	 * not happen in this case.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	/* TODO: more fast path */</span>
 	ret = translate_desc(vq, (u64)(uintptr_t)addr, size, vq-&gt;iotlb_iov,
 			     ARRAY_SIZE(vq-&gt;iotlb_iov),
 			     VHOST_ACCESS_RO);
<span class="p_chunk">@@ -852,32 +816,14 @@</span> <span class="p_context"> static void __user *__vhost_get_user_slow(struct vhost_virtqueue *vq,</span>
 	return vq-&gt;iotlb_iov[0].iov_base;
 }
 
<span class="p_del">-/* This function should be called after iotlb</span>
<span class="p_del">- * prefetch, which means we&#39;re sure that vq</span>
<span class="p_del">- * could be access through iotlb. So -EAGAIN should</span>
<span class="p_del">- * not happen in this case.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void __user *__vhost_get_user(struct vhost_virtqueue *vq,</span>
<span class="p_del">-					    void *addr, unsigned int size,</span>
<span class="p_del">-					    int type)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void __user *uaddr = vhost_vq_meta_fetch(vq,</span>
<span class="p_del">-			     (u64)(uintptr_t)addr, size, type);</span>
<span class="p_del">-	if (uaddr)</span>
<span class="p_del">-		return uaddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	return __vhost_get_user_slow(vq, addr, size, type);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#define vhost_put_user(vq, x, ptr)		\</span>
<span class="p_add">+#define vhost_put_user(vq, x, ptr) \</span>
 ({ \
 	int ret = -EFAULT; \
 	if (!vq-&gt;iotlb) { \
 		ret = __put_user(x, ptr); \
 	} else { \
 		__typeof__(ptr) to = \
<span class="p_del">-			(__typeof__(ptr)) __vhost_get_user(vq, ptr,	\</span>
<span class="p_del">-					  sizeof(*ptr), VHOST_ADDR_USED); \</span>
<span class="p_add">+			(__typeof__(ptr)) __vhost_get_user(vq, ptr, sizeof(*ptr)); \</span>
 		if (to != NULL) \
 			ret = __put_user(x, to); \
 		else \
<span class="p_chunk">@@ -886,16 +832,14 @@</span> <span class="p_context"> static inline void __user *__vhost_get_user(struct vhost_virtqueue *vq,</span>
 	ret; \
 })
 
<span class="p_del">-#define vhost_get_user(vq, x, ptr, type)		\</span>
<span class="p_add">+#define vhost_get_user(vq, x, ptr) \</span>
 ({ \
 	int ret; \
 	if (!vq-&gt;iotlb) { \
 		ret = __get_user(x, ptr); \
 	} else { \
 		__typeof__(ptr) from = \
<span class="p_del">-			(__typeof__(ptr)) __vhost_get_user(vq, ptr, \</span>
<span class="p_del">-							   sizeof(*ptr), \</span>
<span class="p_del">-							   type); \</span>
<span class="p_add">+			(__typeof__(ptr)) __vhost_get_user(vq, ptr, sizeof(*ptr)); \</span>
 		if (from != NULL) \
 			ret = __get_user(x, from); \
 		else \
<span class="p_chunk">@@ -904,12 +848,6 @@</span> <span class="p_context"> static inline void __user *__vhost_get_user(struct vhost_virtqueue *vq,</span>
 	ret; \
 })
 
<span class="p_del">-#define vhost_get_avail(vq, x, ptr) \</span>
<span class="p_del">-	vhost_get_user(vq, x, ptr, VHOST_ADDR_AVAIL)</span>
<span class="p_del">-</span>
<span class="p_del">-#define vhost_get_used(vq, x, ptr) \</span>
<span class="p_del">-	vhost_get_user(vq, x, ptr, VHOST_ADDR_USED)</span>
<span class="p_del">-</span>
 static void vhost_dev_lock_vqs(struct vhost_dev *d)
 {
 	int i = 0;
<span class="p_chunk">@@ -1015,7 +953,6 @@</span> <span class="p_context"> static int vhost_process_iotlb_msg(struct vhost_dev *dev,</span>
 			ret = -EFAULT;
 			break;
 		}
<span class="p_del">-		vhost_vq_meta_reset(dev);</span>
 		if (vhost_new_umem_range(dev-&gt;iotlb, msg-&gt;iova, msg-&gt;size,
 					 msg-&gt;iova + msg-&gt;size - 1,
 					 msg-&gt;uaddr, msg-&gt;perm)) {
<span class="p_chunk">@@ -1025,7 +962,6 @@</span> <span class="p_context"> static int vhost_process_iotlb_msg(struct vhost_dev *dev,</span>
 		vhost_iotlb_notify_vq(dev, msg);
 		break;
 	case VHOST_IOTLB_INVALIDATE:
<span class="p_del">-		vhost_vq_meta_reset(dev);</span>
 		vhost_del_umem_range(dev-&gt;iotlb, msg-&gt;iova,
 				     msg-&gt;iova + msg-&gt;size - 1);
 		break;
<span class="p_chunk">@@ -1169,26 +1105,12 @@</span> <span class="p_context"> static int vq_access_ok(struct vhost_virtqueue *vq, unsigned int num,</span>
 			sizeof *used + num * sizeof *used-&gt;ring + s);
 }
 
<span class="p_del">-static void vhost_vq_meta_update(struct vhost_virtqueue *vq,</span>
<span class="p_del">-				 const struct vhost_umem_node *node,</span>
<span class="p_del">-				 int type)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int access = (type == VHOST_ADDR_USED) ?</span>
<span class="p_del">-		     VHOST_ACCESS_WO : VHOST_ACCESS_RO;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (likely(node-&gt;perm &amp; access))</span>
<span class="p_del">-		vq-&gt;meta_iotlb[type] = node;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int iotlb_access_ok(struct vhost_virtqueue *vq,
<span class="p_del">-			   int access, u64 addr, u64 len, int type)</span>
<span class="p_add">+			   int access, u64 addr, u64 len)</span>
 {
 	const struct vhost_umem_node *node;
 	struct vhost_umem *umem = vq-&gt;iotlb;
<span class="p_del">-	u64 s = 0, size, orig_addr = addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (vhost_vq_meta_fetch(vq, addr, len, type))</span>
<span class="p_del">-		return true;</span>
<span class="p_add">+	u64 s = 0, size;</span>
 
 	while (len &gt; s) {
 		node = vhost_umem_interval_tree_iter_first(&amp;umem-&gt;umem_tree,
<span class="p_chunk">@@ -1205,10 +1127,6 @@</span> <span class="p_context"> static int iotlb_access_ok(struct vhost_virtqueue *vq,</span>
 		}
 
 		size = node-&gt;size - addr + node-&gt;start;
<span class="p_del">-</span>
<span class="p_del">-		if (orig_addr == addr &amp;&amp; size &gt;= len)</span>
<span class="p_del">-			vhost_vq_meta_update(vq, node, type);</span>
<span class="p_del">-</span>
 		s += size;
 		addr += size;
 	}
<span class="p_chunk">@@ -1225,15 +1143,13 @@</span> <span class="p_context"> int vq_iotlb_prefetch(struct vhost_virtqueue *vq)</span>
 		return 1;
 
 	return iotlb_access_ok(vq, VHOST_ACCESS_RO, (u64)(uintptr_t)vq-&gt;desc,
<span class="p_del">-			       num * sizeof(*vq-&gt;desc), VHOST_ADDR_DESC) &amp;&amp;</span>
<span class="p_add">+			       num * sizeof *vq-&gt;desc) &amp;&amp;</span>
 	       iotlb_access_ok(vq, VHOST_ACCESS_RO, (u64)(uintptr_t)vq-&gt;avail,
 			       sizeof *vq-&gt;avail +
<span class="p_del">-			       num * sizeof(*vq-&gt;avail-&gt;ring) + s,</span>
<span class="p_del">-			       VHOST_ADDR_AVAIL) &amp;&amp;</span>
<span class="p_add">+			       num * sizeof *vq-&gt;avail-&gt;ring + s) &amp;&amp;</span>
 	       iotlb_access_ok(vq, VHOST_ACCESS_WO, (u64)(uintptr_t)vq-&gt;used,
 			       sizeof *vq-&gt;used +
<span class="p_del">-			       num * sizeof(*vq-&gt;used-&gt;ring) + s,</span>
<span class="p_del">-			       VHOST_ADDR_USED);</span>
<span class="p_add">+			       num * sizeof *vq-&gt;used-&gt;ring + s);</span>
 }
 EXPORT_SYMBOL_GPL(vq_iotlb_prefetch);
 
<span class="p_chunk">@@ -1814,7 +1730,7 @@</span> <span class="p_context"> int vhost_vq_init_access(struct vhost_virtqueue *vq)</span>
 		r = -EFAULT;
 		goto err;
 	}
<span class="p_del">-	r = vhost_get_used(vq, last_used_idx, &amp;vq-&gt;used-&gt;idx);</span>
<span class="p_add">+	r = vhost_get_user(vq, last_used_idx, &amp;vq-&gt;used-&gt;idx);</span>
 	if (r) {
 		vq_err(vq, &quot;Can&#39;t access used idx at %p\n&quot;,
 		       &amp;vq-&gt;used-&gt;idx);
<span class="p_chunk">@@ -2018,7 +1934,7 @@</span> <span class="p_context"> int vhost_get_vq_desc(struct vhost_virtqueue *vq,</span>
 	last_avail_idx = vq-&gt;last_avail_idx;
 
 	if (vq-&gt;avail_idx == vq-&gt;last_avail_idx) {
<span class="p_del">-		if (unlikely(vhost_get_avail(vq, avail_idx, &amp;vq-&gt;avail-&gt;idx))) {</span>
<span class="p_add">+		if (unlikely(vhost_get_user(vq, avail_idx, &amp;vq-&gt;avail-&gt;idx))) {</span>
 			vq_err(vq, &quot;Failed to access avail idx at %p\n&quot;,
 				&amp;vq-&gt;avail-&gt;idx);
 			return -EFAULT;
<span class="p_chunk">@@ -2045,7 +1961,7 @@</span> <span class="p_context"> int vhost_get_vq_desc(struct vhost_virtqueue *vq,</span>
 
 	/* Grab the next descriptor number they&#39;re advertising, and increment
 	 * the index we&#39;ve seen. */
<span class="p_del">-	if (unlikely(vhost_get_avail(vq, ring_head,</span>
<span class="p_add">+	if (unlikely(vhost_get_user(vq, ring_head,</span>
 		     &amp;vq-&gt;avail-&gt;ring[last_avail_idx &amp; (vq-&gt;num - 1)]))) {
 		vq_err(vq, &quot;Failed to read head: idx %d address %p\n&quot;,
 		       last_avail_idx,
<span class="p_chunk">@@ -2261,7 +2177,7 @@</span> <span class="p_context"> static bool vhost_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)</span>
 		 * with the barrier that the Guest executes when enabling
 		 * interrupts. */
 		smp_mb();
<span class="p_del">-		if (vhost_get_avail(vq, flags, &amp;vq-&gt;avail-&gt;flags)) {</span>
<span class="p_add">+		if (vhost_get_user(vq, flags, &amp;vq-&gt;avail-&gt;flags)) {</span>
 			vq_err(vq, &quot;Failed to get flags&quot;);
 			return true;
 		}
<span class="p_chunk">@@ -2288,7 +2204,7 @@</span> <span class="p_context"> static bool vhost_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)</span>
 	 * interrupts. */
 	smp_mb();
 
<span class="p_del">-	if (vhost_get_avail(vq, event, vhost_used_event(vq))) {</span>
<span class="p_add">+	if (vhost_get_user(vq, event, vhost_used_event(vq))) {</span>
 		vq_err(vq, &quot;Failed to get used event idx&quot;);
 		return true;
 	}
<span class="p_chunk">@@ -2335,7 +2251,7 @@</span> <span class="p_context"> bool vhost_vq_avail_empty(struct vhost_dev *dev, struct vhost_virtqueue *vq)</span>
 	if (vq-&gt;avail_idx != vq-&gt;last_avail_idx)
 		return false;
 
<span class="p_del">-	r = vhost_get_avail(vq, avail_idx, &amp;vq-&gt;avail-&gt;idx);</span>
<span class="p_add">+	r = vhost_get_user(vq, avail_idx, &amp;vq-&gt;avail-&gt;idx);</span>
 	if (unlikely(r))
 		return false;
 	vq-&gt;avail_idx = vhost16_to_cpu(vq, avail_idx);
<span class="p_chunk">@@ -2371,7 +2287,7 @@</span> <span class="p_context"> bool vhost_enable_notify(struct vhost_dev *dev, struct vhost_virtqueue *vq)</span>
 	/* They could have slipped one in as we were doing that: make
 	 * sure it&#39;s written, then check again. */
 	smp_mb();
<span class="p_del">-	r = vhost_get_avail(vq, avail_idx, &amp;vq-&gt;avail-&gt;idx);</span>
<span class="p_add">+	r = vhost_get_user(vq, avail_idx, &amp;vq-&gt;avail-&gt;idx);</span>
 	if (r) {
 		vq_err(vq, &quot;Failed to check avail idx at %p: %d\n&quot;,
 		       &amp;vq-&gt;avail-&gt;idx, r);
<span class="p_header">diff --git a/drivers/vhost/vhost.h b/drivers/vhost/vhost.h</span>
<span class="p_header">index f55671d..a9cbbb1 100644</span>
<span class="p_header">--- a/drivers/vhost/vhost.h</span>
<span class="p_header">+++ b/drivers/vhost/vhost.h</span>
<span class="p_chunk">@@ -76,13 +76,6 @@</span> <span class="p_context"> struct vhost_umem {</span>
 	int numem;
 };
 
<span class="p_del">-enum vhost_uaddr_type {</span>
<span class="p_del">-	VHOST_ADDR_DESC = 0,</span>
<span class="p_del">-	VHOST_ADDR_AVAIL = 1,</span>
<span class="p_del">-	VHOST_ADDR_USED = 2,</span>
<span class="p_del">-	VHOST_NUM_ADDRS = 3,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /* The virtqueue structure describes a queue attached to a device. */
 struct vhost_virtqueue {
 	struct vhost_dev *dev;
<span class="p_chunk">@@ -93,7 +86,6 @@</span> <span class="p_context"> struct vhost_virtqueue {</span>
 	struct vring_desc __user *desc;
 	struct vring_avail __user *avail;
 	struct vring_used __user *used;
<span class="p_del">-	const struct vhost_umem_node *meta_iotlb[VHOST_NUM_ADDRS];</span>
 	struct file *kick;
 	struct file *call;
 	struct file *error;
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 4e11915..a610061 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -414,8 +414,7 @@</span> <span class="p_context"> static int init_vqs(struct virtio_balloon *vb)</span>
 	 * optionally stat.
 	 */
 	nvqs = virtio_has_feature(vb-&gt;vdev, VIRTIO_BALLOON_F_STATS_VQ) ? 3 : 2;
<span class="p_del">-	err = vb-&gt;vdev-&gt;config-&gt;find_vqs(vb-&gt;vdev, nvqs, vqs, callbacks, names,</span>
<span class="p_del">-			NULL);</span>
<span class="p_add">+	err = vb-&gt;vdev-&gt;config-&gt;find_vqs(vb-&gt;vdev, nvqs, vqs, callbacks, names);</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/drivers/virtio/virtio_input.c b/drivers/virtio/virtio_input.c</span>
<span class="p_header">index 79f1293..350a2a5 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_input.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_input.c</span>
<span class="p_chunk">@@ -173,8 +173,7 @@</span> <span class="p_context"> static int virtinput_init_vqs(struct virtio_input *vi)</span>
 	static const char * const names[] = { &quot;events&quot;, &quot;status&quot; };
 	int err;
 
<span class="p_del">-	err = vi-&gt;vdev-&gt;config-&gt;find_vqs(vi-&gt;vdev, 2, vqs, cbs, names,</span>
<span class="p_del">-			NULL);</span>
<span class="p_add">+	err = vi-&gt;vdev-&gt;config-&gt;find_vqs(vi-&gt;vdev, 2, vqs, cbs, names);</span>
 	if (err)
 		return err;
 	vi-&gt;evt = vqs[0];
<span class="p_header">diff --git a/drivers/virtio/virtio_mmio.c b/drivers/virtio/virtio_mmio.c</span>
<span class="p_header">index 78343b8..08357d7 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_mmio.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_mmio.c</span>
<span class="p_chunk">@@ -446,8 +446,7 @@</span> <span class="p_context"> static struct virtqueue *vm_setup_vq(struct virtio_device *vdev, unsigned index,</span>
 static int vm_find_vqs(struct virtio_device *vdev, unsigned nvqs,
 		       struct virtqueue *vqs[],
 		       vq_callback_t *callbacks[],
<span class="p_del">-		       const char * const names[],</span>
<span class="p_del">-		       struct irq_affinity *desc)</span>
<span class="p_add">+		       const char * const names[])</span>
 {
 	struct virtio_mmio_device *vm_dev = to_virtio_mmio_device(vdev);
 	unsigned int irq = platform_get_irq(vm_dev-&gt;pdev, 0);
<span class="p_header">diff --git a/drivers/virtio/virtio_pci_common.c b/drivers/virtio/virtio_pci_common.c</span>
<span class="p_header">index df548a6..a3376731 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_pci_common.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_pci_common.c</span>
<span class="p_chunk">@@ -33,8 +33,10 @@</span> <span class="p_context"> void vp_synchronize_vectors(struct virtio_device *vdev)</span>
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	int i;
 
<span class="p_del">-	synchronize_irq(pci_irq_vector(vp_dev-&gt;pci_dev, 0));</span>
<span class="p_del">-	for (i = 1; i &lt; vp_dev-&gt;msix_vectors; i++)</span>
<span class="p_add">+	if (vp_dev-&gt;intx_enabled)</span>
<span class="p_add">+		synchronize_irq(vp_dev-&gt;pci_dev-&gt;irq);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; vp_dev-&gt;msix_vectors; ++i)</span>
 		synchronize_irq(pci_irq_vector(vp_dev-&gt;pci_dev, i));
 }
 
<span class="p_chunk">@@ -97,10 +99,77 @@</span> <span class="p_context"> static irqreturn_t vp_interrupt(int irq, void *opaque)</span>
 	return vp_vring_interrupt(irq, opaque);
 }
 
<span class="p_del">-static void vp_remove_vqs(struct virtio_device *vdev)</span>
<span class="p_add">+static int vp_request_msix_vectors(struct virtio_device *vdev, int nvectors,</span>
<span class="p_add">+				   bool per_vq_vectors)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct virtio_pci_device *vp_dev = to_vp_device(vdev);</span>
<span class="p_add">+	const char *name = dev_name(&amp;vp_dev-&gt;vdev.dev);</span>
<span class="p_add">+	unsigned i, v;</span>
<span class="p_add">+	int err = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	vp_dev-&gt;msix_vectors = nvectors;</span>
<span class="p_add">+</span>
<span class="p_add">+	vp_dev-&gt;msix_names = kmalloc(nvectors * sizeof *vp_dev-&gt;msix_names,</span>
<span class="p_add">+				     GFP_KERNEL);</span>
<span class="p_add">+	if (!vp_dev-&gt;msix_names)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	vp_dev-&gt;msix_affinity_masks</span>
<span class="p_add">+		= kzalloc(nvectors * sizeof *vp_dev-&gt;msix_affinity_masks,</span>
<span class="p_add">+			  GFP_KERNEL);</span>
<span class="p_add">+	if (!vp_dev-&gt;msix_affinity_masks)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	for (i = 0; i &lt; nvectors; ++i)</span>
<span class="p_add">+		if (!alloc_cpumask_var(&amp;vp_dev-&gt;msix_affinity_masks[i],</span>
<span class="p_add">+					GFP_KERNEL))</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = pci_alloc_irq_vectors(vp_dev-&gt;pci_dev, nvectors, nvectors,</span>
<span class="p_add">+			PCI_IRQ_MSIX);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	vp_dev-&gt;msix_enabled = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the vector used for configuration */</span>
<span class="p_add">+	v = vp_dev-&gt;msix_used_vectors;</span>
<span class="p_add">+	snprintf(vp_dev-&gt;msix_names[v], sizeof *vp_dev-&gt;msix_names,</span>
<span class="p_add">+		 &quot;%s-config&quot;, name);</span>
<span class="p_add">+	err = request_irq(pci_irq_vector(vp_dev-&gt;pci_dev, v),</span>
<span class="p_add">+			  vp_config_changed, 0, vp_dev-&gt;msix_names[v],</span>
<span class="p_add">+			  vp_dev);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	++vp_dev-&gt;msix_used_vectors;</span>
<span class="p_add">+</span>
<span class="p_add">+	v = vp_dev-&gt;config_vector(vp_dev, v);</span>
<span class="p_add">+	/* Verify we had enough resources to assign the vector */</span>
<span class="p_add">+	if (v == VIRTIO_MSI_NO_VECTOR) {</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!per_vq_vectors) {</span>
<span class="p_add">+		/* Shared vector for all VQs */</span>
<span class="p_add">+		v = vp_dev-&gt;msix_used_vectors;</span>
<span class="p_add">+		snprintf(vp_dev-&gt;msix_names[v], sizeof *vp_dev-&gt;msix_names,</span>
<span class="p_add">+			 &quot;%s-virtqueues&quot;, name);</span>
<span class="p_add">+		err = request_irq(pci_irq_vector(vp_dev-&gt;pci_dev, v),</span>
<span class="p_add">+				  vp_vring_interrupt, 0, vp_dev-&gt;msix_names[v],</span>
<span class="p_add">+				  vp_dev);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		++vp_dev-&gt;msix_used_vectors;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+error:</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* the config-&gt;del_vqs() implementation */</span>
<span class="p_add">+void vp_del_vqs(struct virtio_device *vdev)</span>
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	struct virtqueue *vq, *n;
<span class="p_add">+	int i;</span>
 
 	list_for_each_entry_safe(vq, n, &amp;vdev-&gt;vqs, list) {
 		if (vp_dev-&gt;msix_vector_map) {
<span class="p_chunk">@@ -112,170 +181,117 @@</span> <span class="p_context"> static void vp_remove_vqs(struct virtio_device *vdev)</span>
 		}
 		vp_dev-&gt;del_vq(vq);
 	}
<span class="p_del">-}</span>
 
<span class="p_del">-/* the config-&gt;del_vqs() implementation */</span>
<span class="p_del">-void vp_del_vqs(struct virtio_device *vdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtio_pci_device *vp_dev = to_vp_device(vdev);</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (WARN_ON_ONCE(list_empty_careful(&amp;vdev-&gt;vqs)))</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	if (vp_dev-&gt;intx_enabled) {</span>
<span class="p_add">+		free_irq(vp_dev-&gt;pci_dev-&gt;irq, vp_dev);</span>
<span class="p_add">+		vp_dev-&gt;intx_enabled = 0;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	vp_remove_vqs(vdev);</span>
<span class="p_add">+	for (i = 0; i &lt; vp_dev-&gt;msix_used_vectors; ++i)</span>
<span class="p_add">+		free_irq(pci_irq_vector(vp_dev-&gt;pci_dev, i), vp_dev);</span>
 
<span class="p_del">-	if (vp_dev-&gt;pci_dev-&gt;msix_enabled) {</span>
<span class="p_del">-		for (i = 0; i &lt; vp_dev-&gt;msix_vectors; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; vp_dev-&gt;msix_vectors; i++)</span>
<span class="p_add">+		if (vp_dev-&gt;msix_affinity_masks[i])</span>
 			free_cpumask_var(vp_dev-&gt;msix_affinity_masks[i]);
 
<span class="p_add">+	if (vp_dev-&gt;msix_enabled) {</span>
 		/* Disable the vector used for configuration */
 		vp_dev-&gt;config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);
 
<span class="p_del">-		kfree(vp_dev-&gt;msix_affinity_masks);</span>
<span class="p_del">-		kfree(vp_dev-&gt;msix_names);</span>
<span class="p_del">-		kfree(vp_dev-&gt;msix_vector_map);</span>
<span class="p_add">+		pci_free_irq_vectors(vp_dev-&gt;pci_dev);</span>
<span class="p_add">+		vp_dev-&gt;msix_enabled = 0;</span>
 	}
 
<span class="p_del">-	free_irq(pci_irq_vector(vp_dev-&gt;pci_dev, 0), vp_dev);</span>
<span class="p_del">-	pci_free_irq_vectors(vp_dev-&gt;pci_dev);</span>
<span class="p_add">+	vp_dev-&gt;msix_vectors = 0;</span>
<span class="p_add">+	vp_dev-&gt;msix_used_vectors = 0;</span>
<span class="p_add">+	kfree(vp_dev-&gt;msix_names);</span>
<span class="p_add">+	vp_dev-&gt;msix_names = NULL;</span>
<span class="p_add">+	kfree(vp_dev-&gt;msix_affinity_masks);</span>
<span class="p_add">+	vp_dev-&gt;msix_affinity_masks = NULL;</span>
<span class="p_add">+	kfree(vp_dev-&gt;msix_vector_map);</span>
<span class="p_add">+	vp_dev-&gt;msix_vector_map = NULL;</span>
 }
 
 static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,
<span class="p_del">-		struct virtqueue *vqs[], vq_callback_t *callbacks[],</span>
<span class="p_del">-		const char * const names[], struct irq_affinity *desc)</span>
<span class="p_add">+			      struct virtqueue *vqs[],</span>
<span class="p_add">+			      vq_callback_t *callbacks[],</span>
<span class="p_add">+			      const char * const names[],</span>
<span class="p_add">+			      bool per_vq_vectors)</span>
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
<span class="p_del">-	const char *name = dev_name(&amp;vp_dev-&gt;vdev.dev);</span>
<span class="p_del">-	int i, err = -ENOMEM, allocated_vectors, nvectors;</span>
<span class="p_del">-	unsigned flags = PCI_IRQ_MSIX;</span>
<span class="p_del">-	bool shared = false;</span>
 	u16 msix_vec;
<span class="p_del">-</span>
<span class="p_del">-	if (desc) {</span>
<span class="p_del">-		flags |= PCI_IRQ_AFFINITY;</span>
<span class="p_del">-		desc-&gt;pre_vectors++; /* virtio config vector */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	nvectors = 1;</span>
<span class="p_del">-	for (i = 0; i &lt; nvqs; i++)</span>
<span class="p_del">-		if (callbacks[i])</span>
<span class="p_del">-			nvectors++;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Try one vector per queue first. */</span>
<span class="p_del">-	err = pci_alloc_irq_vectors_affinity(vp_dev-&gt;pci_dev, nvectors,</span>
<span class="p_del">-			nvectors, flags, desc);</span>
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		/* Fallback to one vector for config, one shared for queues. */</span>
<span class="p_del">-		shared = true;</span>
<span class="p_del">-		err = pci_alloc_irq_vectors(vp_dev-&gt;pci_dev, 2, 2,</span>
<span class="p_del">-				PCI_IRQ_MSIX);</span>
<span class="p_del">-		if (err &lt; 0)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
<span class="p_del">-	vp_dev-&gt;msix_vectors = nvectors;</span>
<span class="p_del">-	vp_dev-&gt;msix_names = kmalloc_array(nvectors,</span>
<span class="p_del">-			sizeof(*vp_dev-&gt;msix_names), GFP_KERNEL);</span>
<span class="p_del">-	if (!vp_dev-&gt;msix_names)</span>
<span class="p_del">-		goto out_free_irq_vectors;</span>
<span class="p_del">-</span>
<span class="p_del">-	vp_dev-&gt;msix_affinity_masks = kcalloc(nvectors,</span>
<span class="p_del">-			sizeof(*vp_dev-&gt;msix_affinity_masks), GFP_KERNEL);</span>
<span class="p_del">-	if (!vp_dev-&gt;msix_affinity_masks)</span>
<span class="p_del">-		goto out_free_msix_names;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; nvectors; ++i) {</span>
<span class="p_del">-		if (!alloc_cpumask_var(&amp;vp_dev-&gt;msix_affinity_masks[i],</span>
<span class="p_del">-				GFP_KERNEL))</span>
<span class="p_del">-			goto out_free_msix_affinity_masks;</span>
<span class="p_add">+	int i, err, nvectors, allocated_vectors;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (per_vq_vectors) {</span>
<span class="p_add">+		/* Best option: one for change interrupt, one per vq. */</span>
<span class="p_add">+		nvectors = 1;</span>
<span class="p_add">+		for (i = 0; i &lt; nvqs; ++i)</span>
<span class="p_add">+			if (callbacks[i])</span>
<span class="p_add">+				++nvectors;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Second best: one for change, shared for all vqs. */</span>
<span class="p_add">+		nvectors = 2;</span>
 	}
 
<span class="p_del">-	/* Set the vector used for configuration */</span>
<span class="p_del">-	snprintf(vp_dev-&gt;msix_names[0], sizeof(*vp_dev-&gt;msix_names),</span>
<span class="p_del">-		 &quot;%s-config&quot;, name);</span>
<span class="p_del">-	err = request_irq(pci_irq_vector(vp_dev-&gt;pci_dev, 0), vp_config_changed,</span>
<span class="p_del">-			0, vp_dev-&gt;msix_names[0], vp_dev);</span>
<span class="p_add">+	err = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors);</span>
 	if (err)
<span class="p_del">-		goto out_free_msix_affinity_masks;</span>
<span class="p_add">+		goto error_find;</span>
 
<span class="p_del">-	/* Verify we had enough resources to assign the vector */</span>
<span class="p_del">-	if (vp_dev-&gt;config_vector(vp_dev, 0) == VIRTIO_MSI_NO_VECTOR) {</span>
<span class="p_del">-		err = -EBUSY;</span>
<span class="p_del">-		goto out_free_config_irq;</span>
<span class="p_add">+	if (per_vq_vectors) {</span>
<span class="p_add">+		vp_dev-&gt;msix_vector_map = kmalloc_array(nvqs,</span>
<span class="p_add">+				sizeof(*vp_dev-&gt;msix_vector_map), GFP_KERNEL);</span>
<span class="p_add">+		if (!vp_dev-&gt;msix_vector_map)</span>
<span class="p_add">+			goto error_find;</span>
 	}
 
<span class="p_del">-	vp_dev-&gt;msix_vector_map = kmalloc_array(nvqs,</span>
<span class="p_del">-			sizeof(*vp_dev-&gt;msix_vector_map), GFP_KERNEL);</span>
<span class="p_del">-	if (!vp_dev-&gt;msix_vector_map)</span>
<span class="p_del">-		goto out_disable_config_irq;</span>
<span class="p_del">-</span>
<span class="p_del">-	allocated_vectors = 1; /* vector 0 is the config interrupt */</span>
<span class="p_add">+	allocated_vectors = vp_dev-&gt;msix_used_vectors;</span>
 	for (i = 0; i &lt; nvqs; ++i) {
 		if (!names[i]) {
 			vqs[i] = NULL;
 			continue;
 		}
 
<span class="p_del">-		if (callbacks[i])</span>
<span class="p_del">-			msix_vec = allocated_vectors;</span>
<span class="p_del">-		else</span>
<span class="p_add">+		if (!callbacks[i])</span>
 			msix_vec = VIRTIO_MSI_NO_VECTOR;
<span class="p_del">-</span>
<span class="p_add">+		else if (per_vq_vectors)</span>
<span class="p_add">+			msix_vec = allocated_vectors++;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			msix_vec = VP_MSIX_VQ_VECTOR;</span>
 		vqs[i] = vp_dev-&gt;setup_vq(vp_dev, i, callbacks[i], names[i],
 				msix_vec);
 		if (IS_ERR(vqs[i])) {
 			err = PTR_ERR(vqs[i]);
<span class="p_del">-			goto out_remove_vqs;</span>
<span class="p_add">+			goto error_find;</span>
 		}
 
<span class="p_add">+		if (!per_vq_vectors)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		if (msix_vec == VIRTIO_MSI_NO_VECTOR) {
 			vp_dev-&gt;msix_vector_map[i] = VIRTIO_MSI_NO_VECTOR;
 			continue;
 		}
 
<span class="p_del">-		snprintf(vp_dev-&gt;msix_names[i + 1],</span>
<span class="p_del">-			 sizeof(*vp_dev-&gt;msix_names), &quot;%s-%s&quot;,</span>
<span class="p_add">+		/* allocate per-vq irq if available and necessary */</span>
<span class="p_add">+		snprintf(vp_dev-&gt;msix_names[msix_vec],</span>
<span class="p_add">+			 sizeof *vp_dev-&gt;msix_names,</span>
<span class="p_add">+			 &quot;%s-%s&quot;,</span>
 			 dev_name(&amp;vp_dev-&gt;vdev.dev), names[i]);
 		err = request_irq(pci_irq_vector(vp_dev-&gt;pci_dev, msix_vec),
<span class="p_del">-				  vring_interrupt, IRQF_SHARED,</span>
<span class="p_del">-				  vp_dev-&gt;msix_names[i + 1], vqs[i]);</span>
<span class="p_add">+				  vring_interrupt, 0,</span>
<span class="p_add">+				  vp_dev-&gt;msix_names[msix_vec],</span>
<span class="p_add">+				  vqs[i]);</span>
 		if (err) {
 			/* don&#39;t free this irq on error */
 			vp_dev-&gt;msix_vector_map[i] = VIRTIO_MSI_NO_VECTOR;
<span class="p_del">-			goto out_remove_vqs;</span>
<span class="p_add">+			goto error_find;</span>
 		}
 		vp_dev-&gt;msix_vector_map[i] = msix_vec;
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Use a different vector for each queue if they are available,</span>
<span class="p_del">-		 * else share the same vector for all VQs.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!shared)</span>
<span class="p_del">-			allocated_vectors++;</span>
 	}
<span class="p_del">-</span>
 	return 0;
 
<span class="p_del">-out_remove_vqs:</span>
<span class="p_del">-	vp_remove_vqs(vdev);</span>
<span class="p_del">-	kfree(vp_dev-&gt;msix_vector_map);</span>
<span class="p_del">-out_disable_config_irq:</span>
<span class="p_del">-	vp_dev-&gt;config_vector(vp_dev, VIRTIO_MSI_NO_VECTOR);</span>
<span class="p_del">-out_free_config_irq:</span>
<span class="p_del">-	free_irq(pci_irq_vector(vp_dev-&gt;pci_dev, 0), vp_dev);</span>
<span class="p_del">-out_free_msix_affinity_masks:</span>
<span class="p_del">-	for (i = 0; i &lt; nvectors; i++) {</span>
<span class="p_del">-		if (vp_dev-&gt;msix_affinity_masks[i])</span>
<span class="p_del">-			free_cpumask_var(vp_dev-&gt;msix_affinity_masks[i]);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	kfree(vp_dev-&gt;msix_affinity_masks);</span>
<span class="p_del">-out_free_msix_names:</span>
<span class="p_del">-	kfree(vp_dev-&gt;msix_names);</span>
<span class="p_del">-out_free_irq_vectors:</span>
<span class="p_del">-	pci_free_irq_vectors(vp_dev-&gt;pci_dev);</span>
<span class="p_add">+error_find:</span>
<span class="p_add">+	vp_del_vqs(vdev);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -289,8 +305,9 @@</span> <span class="p_context"> static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,</span>
 	err = request_irq(vp_dev-&gt;pci_dev-&gt;irq, vp_interrupt, IRQF_SHARED,
 			dev_name(&amp;vdev-&gt;dev), vp_dev);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_del_vqs;</span>
 
<span class="p_add">+	vp_dev-&gt;intx_enabled = 1;</span>
 	for (i = 0; i &lt; nvqs; ++i) {
 		if (!names[i]) {
 			vqs[i] = NULL;
<span class="p_chunk">@@ -300,28 +317,33 @@</span> <span class="p_context"> static int vp_find_vqs_intx(struct virtio_device *vdev, unsigned nvqs,</span>
 				VIRTIO_MSI_NO_VECTOR);
 		if (IS_ERR(vqs[i])) {
 			err = PTR_ERR(vqs[i]);
<span class="p_del">-			goto out_remove_vqs;</span>
<span class="p_add">+			goto out_del_vqs;</span>
 		}
 	}
 
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-out_remove_vqs:</span>
<span class="p_del">-	vp_remove_vqs(vdev);</span>
<span class="p_del">-	free_irq(pci_irq_vector(vp_dev-&gt;pci_dev, 0), vp_dev);</span>
<span class="p_add">+out_del_vqs:</span>
<span class="p_add">+	vp_del_vqs(vdev);</span>
 	return err;
 }
 
 /* the config-&gt;find_vqs() implementation */
 int vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,
<span class="p_del">-		struct virtqueue *vqs[], vq_callback_t *callbacks[],</span>
<span class="p_del">-		const char * const names[], struct irq_affinity *desc)</span>
<span class="p_add">+		struct virtqueue *vqs[],</span>
<span class="p_add">+		vq_callback_t *callbacks[],</span>
<span class="p_add">+		const char * const names[])</span>
 {
 	int err;
 
<span class="p_del">-	err = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, desc);</span>
<span class="p_add">+	/* Try MSI-X with one vector per queue. */</span>
<span class="p_add">+	err = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, true);</span>
 	if (!err)
 		return 0;
<span class="p_add">+	/* Fallback: MSI-X with one vector for config, one shared for queues. */</span>
<span class="p_add">+	err = vp_find_vqs_msix(vdev, nvqs, vqs, callbacks, names, false);</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	/* Finally fall back to regular interrupts. */</span>
 	return vp_find_vqs_intx(vdev, nvqs, vqs, callbacks, names);
 }
 
<span class="p_chunk">@@ -345,7 +367,7 @@</span> <span class="p_context"> int vp_set_vq_affinity(struct virtqueue *vq, int cpu)</span>
 	if (!vq-&gt;callback)
 		return -EINVAL;
 
<span class="p_del">-	if (vp_dev-&gt;pci_dev-&gt;msix_enabled) {</span>
<span class="p_add">+	if (vp_dev-&gt;msix_enabled) {</span>
 		int vec = vp_dev-&gt;msix_vector_map[vq-&gt;index];
 		struct cpumask *mask = vp_dev-&gt;msix_affinity_masks[vec];
 		unsigned int irq = pci_irq_vector(vp_dev-&gt;pci_dev, vec);
<span class="p_chunk">@@ -361,17 +383,6 @@</span> <span class="p_context"> int vp_set_vq_affinity(struct virtqueue *vq, int cpu)</span>
 	return 0;
 }
 
<span class="p_del">-const struct cpumask *vp_get_vq_affinity(struct virtio_device *vdev, int index)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtio_pci_device *vp_dev = to_vp_device(vdev);</span>
<span class="p_del">-	unsigned int *map = vp_dev-&gt;msix_vector_map;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!map || map[index] == VIRTIO_MSI_NO_VECTOR)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return pci_irq_get_affinity(vp_dev-&gt;pci_dev, map[index]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifdef CONFIG_PM_SLEEP
 static int virtio_pci_freeze(struct device *dev)
 {
<span class="p_header">diff --git a/drivers/virtio/virtio_pci_common.h b/drivers/virtio/virtio_pci_common.h</span>
<span class="p_header">index ac8c9d7..2038887 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_pci_common.h</span>
<span class="p_header">+++ b/drivers/virtio/virtio_pci_common.h</span>
<span class="p_chunk">@@ -64,12 +64,18 @@</span> <span class="p_context"> struct virtio_pci_device {</span>
 	/* the IO mapping for the PCI config space */
 	void __iomem *ioaddr;
 
<span class="p_add">+	/* MSI-X support */</span>
<span class="p_add">+	int msix_enabled;</span>
<span class="p_add">+	int intx_enabled;</span>
 	cpumask_var_t *msix_affinity_masks;
 	/* Name strings for interrupts. This size should be enough,
 	 * and I&#39;m too lazy to allocate each name separately. */
 	char (*msix_names)[256];
<span class="p_del">-	/* Total Number of MSI-X vectors (including per-VQ ones). */</span>
<span class="p_del">-	int msix_vectors;</span>
<span class="p_add">+	/* Number of available vectors */</span>
<span class="p_add">+	unsigned msix_vectors;</span>
<span class="p_add">+	/* Vectors allocated, excluding per-vq vectors if any */</span>
<span class="p_add">+	unsigned msix_used_vectors;</span>
<span class="p_add">+</span>
 	/* Map of per-VQ MSI-X vectors, may be NULL */
 	unsigned *msix_vector_map;
 
<span class="p_chunk">@@ -83,6 +89,14 @@</span> <span class="p_context"> struct virtio_pci_device {</span>
 	u16 (*config_vector)(struct virtio_pci_device *vp_dev, u16 vector);
 };
 
<span class="p_add">+/* Constants for MSI-X */</span>
<span class="p_add">+/* Use first vector for configuration changes, second and the rest for</span>
<span class="p_add">+ * virtqueues Thus, we need at least 2 vectors for MSI. */</span>
<span class="p_add">+enum {</span>
<span class="p_add">+	VP_MSIX_CONFIG_VECTOR = 0,</span>
<span class="p_add">+	VP_MSIX_VQ_VECTOR = 1,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /* Convert a generic virtio device to our structure */
 static struct virtio_pci_device *to_vp_device(struct virtio_device *vdev)
 {
<span class="p_chunk">@@ -97,8 +111,9 @@</span> <span class="p_context"> bool vp_notify(struct virtqueue *vq);</span>
 void vp_del_vqs(struct virtio_device *vdev);
 /* the config-&gt;find_vqs() implementation */
 int vp_find_vqs(struct virtio_device *vdev, unsigned nvqs,
<span class="p_del">-		struct virtqueue *vqs[], vq_callback_t *callbacks[],</span>
<span class="p_del">-		const char * const names[], struct irq_affinity *desc);</span>
<span class="p_add">+		       struct virtqueue *vqs[],</span>
<span class="p_add">+		       vq_callback_t *callbacks[],</span>
<span class="p_add">+		       const char * const names[]);</span>
 const char *vp_bus_name(struct virtio_device *vdev);
 
 /* Setup the affinity for a virtqueue:
<span class="p_chunk">@@ -108,8 +123,6 @@</span> <span class="p_context"> const char *vp_bus_name(struct virtio_device *vdev);</span>
  */
 int vp_set_vq_affinity(struct virtqueue *vq, int cpu);
 
<span class="p_del">-const struct cpumask *vp_get_vq_affinity(struct virtio_device *vdev, int index);</span>
<span class="p_del">-</span>
 #if IS_ENABLED(CONFIG_VIRTIO_PCI_LEGACY)
 int virtio_pci_legacy_probe(struct virtio_pci_device *);
 void virtio_pci_legacy_remove(struct virtio_pci_device *);
<span class="p_header">diff --git a/drivers/virtio/virtio_pci_legacy.c b/drivers/virtio/virtio_pci_legacy.c</span>
<span class="p_header">index f7362c5..47292da 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_pci_legacy.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_pci_legacy.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static void del_vq(struct virtqueue *vq)</span>
 
 	iowrite16(vq-&gt;index, vp_dev-&gt;ioaddr + VIRTIO_PCI_QUEUE_SEL);
 
<span class="p_del">-	if (vp_dev-&gt;pci_dev-&gt;msix_enabled) {</span>
<span class="p_add">+	if (vp_dev-&gt;msix_enabled) {</span>
 		iowrite16(VIRTIO_MSI_NO_VECTOR,
 			  vp_dev-&gt;ioaddr + VIRTIO_MSI_QUEUE_VECTOR);
 		/* Flush the write out to device */
<span class="p_chunk">@@ -190,7 +190,6 @@</span> <span class="p_context"> static const struct virtio_config_ops virtio_pci_config_ops = {</span>
 	.finalize_features = vp_finalize_features,
 	.bus_name	= vp_bus_name,
 	.set_vq_affinity = vp_set_vq_affinity,
<span class="p_del">-	.get_vq_affinity = vp_get_vq_affinity,</span>
 };
 
 /* the PCI probing function */
<span class="p_header">diff --git a/drivers/virtio/virtio_pci_modern.c b/drivers/virtio/virtio_pci_modern.c</span>
<span class="p_header">index 7bc3004..00e6fc1 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_pci_modern.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_pci_modern.c</span>
<span class="p_chunk">@@ -384,12 +384,13 @@</span> <span class="p_context"> static struct virtqueue *setup_vq(struct virtio_pci_device *vp_dev,</span>
 }
 
 static int vp_modern_find_vqs(struct virtio_device *vdev, unsigned nvqs,
<span class="p_del">-		struct virtqueue *vqs[], vq_callback_t *callbacks[],</span>
<span class="p_del">-		const char * const names[], struct irq_affinity *desc)</span>
<span class="p_add">+			      struct virtqueue *vqs[],</span>
<span class="p_add">+			      vq_callback_t *callbacks[],</span>
<span class="p_add">+			      const char * const names[])</span>
 {
 	struct virtio_pci_device *vp_dev = to_vp_device(vdev);
 	struct virtqueue *vq;
<span class="p_del">-	int rc = vp_find_vqs(vdev, nvqs, vqs, callbacks, names, desc);</span>
<span class="p_add">+	int rc = vp_find_vqs(vdev, nvqs, vqs, callbacks, names);</span>
 
 	if (rc)
 		return rc;
<span class="p_chunk">@@ -411,7 +412,7 @@</span> <span class="p_context"> static void del_vq(struct virtqueue *vq)</span>
 
 	vp_iowrite16(vq-&gt;index, &amp;vp_dev-&gt;common-&gt;queue_select);
 
<span class="p_del">-	if (vp_dev-&gt;pci_dev-&gt;msix_enabled) {</span>
<span class="p_add">+	if (vp_dev-&gt;msix_enabled) {</span>
 		vp_iowrite16(VIRTIO_MSI_NO_VECTOR,
 			     &amp;vp_dev-&gt;common-&gt;queue_msix_vector);
 		/* Flush the write out to device */
<span class="p_chunk">@@ -437,7 +438,6 @@</span> <span class="p_context"> static const struct virtio_config_ops virtio_pci_config_nodev_ops = {</span>
 	.finalize_features = vp_finalize_features,
 	.bus_name	= vp_bus_name,
 	.set_vq_affinity = vp_set_vq_affinity,
<span class="p_del">-	.get_vq_affinity = vp_get_vq_affinity,</span>
 };
 
 static const struct virtio_config_ops virtio_pci_config_ops = {
<span class="p_chunk">@@ -453,7 +453,6 @@</span> <span class="p_context"> static const struct virtio_config_ops virtio_pci_config_ops = {</span>
 	.finalize_features = vp_finalize_features,
 	.bus_name	= vp_bus_name,
 	.set_vq_affinity = vp_set_vq_affinity,
<span class="p_del">-	.get_vq_affinity = vp_get_vq_affinity,</span>
 };
 
 /**
<span class="p_header">diff --git a/include/linux/blk-mq-virtio.h b/include/linux/blk-mq-virtio.h</span>
deleted file mode 100644
<span class="p_header">index b1ef6e1..0000000</span>
<span class="p_header">--- a/include/linux/blk-mq-virtio.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,10 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _LINUX_BLK_MQ_VIRTIO_H</span>
<span class="p_del">-#define _LINUX_BLK_MQ_VIRTIO_H</span>
<span class="p_del">-</span>
<span class="p_del">-struct blk_mq_tag_set;</span>
<span class="p_del">-struct virtio_device;</span>
<span class="p_del">-</span>
<span class="p_del">-int blk_mq_virtio_map_queues(struct blk_mq_tag_set *set,</span>
<span class="p_del">-		struct virtio_device *vdev, int first_vec);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _LINUX_BLK_MQ_VIRTIO_H */</span>
<span class="p_header">diff --git a/include/linux/cpuhotplug.h b/include/linux/cpuhotplug.h</span>
<span class="p_header">index 62d240e..bb790c4 100644</span>
<span class="p_header">--- a/include/linux/cpuhotplug.h</span>
<span class="p_header">+++ b/include/linux/cpuhotplug.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> enum cpuhp_state {</span>
 	CPUHP_ARM_OMAP_WAKE_DEAD,
 	CPUHP_IRQ_POLL_DEAD,
 	CPUHP_BLOCK_SOFTIRQ_DEAD,
<span class="p_add">+	CPUHP_VIRT_SCSI_DEAD,</span>
 	CPUHP_ACPI_CPUDRV_DEAD,
 	CPUHP_S390_PFAULT_DEAD,
 	CPUHP_BLK_MQ_DEAD,
<span class="p_header">diff --git a/include/linux/virtio_config.h b/include/linux/virtio_config.h</span>
<span class="p_header">index 8355bab..26c155b 100644</span>
<span class="p_header">--- a/include/linux/virtio_config.h</span>
<span class="p_header">+++ b/include/linux/virtio_config.h</span>
<span class="p_chunk">@@ -7,8 +7,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/virtio_byteorder.h&gt;
 #include &lt;uapi/linux/virtio_config.h&gt;
 
<span class="p_del">-struct irq_affinity;</span>
<span class="p_del">-</span>
 /**
  * virtio_config_ops - operations for configuring a virtio device
  * @get: read the value of a configuration field
<span class="p_chunk">@@ -58,7 +56,6 @@</span> <span class="p_context"> struct irq_affinity;</span>
  *      This returns a pointer to the bus name a la pci_name from which
  *      the caller can then copy.
  * @set_vq_affinity: set the affinity for a virtqueue.
<span class="p_del">- * @get_vq_affinity: get the affinity for a virtqueue (optional).</span>
  */
 typedef void vq_callback_t(struct virtqueue *);
 struct virtio_config_ops {
<span class="p_chunk">@@ -71,15 +68,14 @@</span> <span class="p_context"> struct virtio_config_ops {</span>
 	void (*set_status)(struct virtio_device *vdev, u8 status);
 	void (*reset)(struct virtio_device *vdev);
 	int (*find_vqs)(struct virtio_device *, unsigned nvqs,
<span class="p_del">-			struct virtqueue *vqs[], vq_callback_t *callbacks[],</span>
<span class="p_del">-			const char * const names[], struct irq_affinity *desc);</span>
<span class="p_add">+			struct virtqueue *vqs[],</span>
<span class="p_add">+			vq_callback_t *callbacks[],</span>
<span class="p_add">+			const char * const names[]);</span>
 	void (*del_vqs)(struct virtio_device *);
 	u64 (*get_features)(struct virtio_device *vdev);
 	int (*finalize_features)(struct virtio_device *vdev);
 	const char *(*bus_name)(struct virtio_device *vdev);
 	int (*set_vq_affinity)(struct virtqueue *vq, int cpu);
<span class="p_del">-	const struct cpumask *(*get_vq_affinity)(struct virtio_device *vdev,</span>
<span class="p_del">-			int index);</span>
 };
 
 /* If driver didn&#39;t advertise the feature, it will never appear. */
<span class="p_chunk">@@ -173,7 +169,7 @@</span> <span class="p_context"> struct virtqueue *virtio_find_single_vq(struct virtio_device *vdev,</span>
 	vq_callback_t *callbacks[] = { c };
 	const char *names[] = { n };
 	struct virtqueue *vq;
<span class="p_del">-	int err = vdev-&gt;config-&gt;find_vqs(vdev, 1, &amp;vq, callbacks, names, NULL);</span>
<span class="p_add">+	int err = vdev-&gt;config-&gt;find_vqs(vdev, 1, &amp;vq, callbacks, names);</span>
 	if (err &lt; 0)
 		return ERR_PTR(err);
 	return vq;
<span class="p_header">diff --git a/include/uapi/linux/virtio_pci.h b/include/uapi/linux/virtio_pci.h</span>
<span class="p_header">index 15b4385..90007a1 100644</span>
<span class="p_header">--- a/include/uapi/linux/virtio_pci.h</span>
<span class="p_header">+++ b/include/uapi/linux/virtio_pci.h</span>
<span class="p_chunk">@@ -79,7 +79,7 @@</span> <span class="p_context"></span>
  * configuration space */
 #define VIRTIO_PCI_CONFIG_OFF(msix_enabled)	((msix_enabled) ? 24 : 20)
 /* Deprecated: please use VIRTIO_PCI_CONFIG_OFF instead */
<span class="p_del">-#define VIRTIO_PCI_CONFIG(dev)	VIRTIO_PCI_CONFIG_OFF((dev)-&gt;pci_dev-&gt;msix_enabled)</span>
<span class="p_add">+#define VIRTIO_PCI_CONFIG(dev)	VIRTIO_PCI_CONFIG_OFF((dev)-&gt;msix_enabled)</span>
 
 /* Virtio ABI version, this must match exactly */
 #define VIRTIO_PCI_ABI_VERSION		0
<span class="p_header">diff --git a/net/vmw_vsock/virtio_transport.c b/net/vmw_vsock/virtio_transport.c</span>
<span class="p_header">index 9d24c0e..6788264 100644</span>
<span class="p_header">--- a/net/vmw_vsock/virtio_transport.c</span>
<span class="p_header">+++ b/net/vmw_vsock/virtio_transport.c</span>
<span class="p_chunk">@@ -532,8 +532,7 @@</span> <span class="p_context"> static int virtio_vsock_probe(struct virtio_device *vdev)</span>
 	vsock-&gt;vdev = vdev;
 
 	ret = vsock-&gt;vdev-&gt;config-&gt;find_vqs(vsock-&gt;vdev, VSOCK_VQ_MAX,
<span class="p_del">-					    vsock-&gt;vqs, callbacks, names,</span>
<span class="p_del">-					    NULL);</span>
<span class="p_add">+					    vsock-&gt;vqs, callbacks, names);</span>
 	if (ret &lt; 0)
 		goto out;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



