
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.8.5 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.8.5</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 28, 2016, 8:23 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161028082316.GB5898@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9401503/mbox/"
   >mbox</a>
|
   <a href="/patch/9401503/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9401503/">/patch/9401503/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4CFFB6022E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 28 Oct 2016 08:24:03 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2C3F72A63C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 28 Oct 2016 08:24:03 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1FF222A63E; Fri, 28 Oct 2016 08:24:03 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7C95D2A63C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 28 Oct 2016 08:23:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1759616AbcJ1IXl (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 28 Oct 2016 04:23:41 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:49112 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1759501AbcJ1IXN (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 28 Oct 2016 04:23:13 -0400
Received: from localhost (timessq103.t.subnet.rcn.com [206.71.234.194])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 90982480;
	Fri, 28 Oct 2016 08:23:06 +0000 (UTC)
Date: Fri, 28 Oct 2016 04:23:16 -0400
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.8.5
Message-ID: &lt;20161028082316.GB5898@kroah.com&gt;
References: &lt;20161028082302.GA5898@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161028082302.GA5898@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 28, 2016, 8:23 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-class-cxl b/Documentation/ABI/testing/sysfs-class-cxl</span>
<span class="p_header">index 4ba0a2a61926..640f65e79ef1 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/sysfs-class-cxl</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-class-cxl</span>
<span class="p_chunk">@@ -220,8 +220,11 @@</span> <span class="p_context"> What:           /sys/class/cxl/&lt;card&gt;/reset</span>
 Date:           October 2014
 Contact:        linuxppc-dev@lists.ozlabs.org
 Description:    write only
<span class="p_del">-                Writing 1 will issue a PERST to card which may cause the card</span>
<span class="p_del">-                to reload the FPGA depending on load_image_on_perst.</span>
<span class="p_add">+                Writing 1 will issue a PERST to card provided there are no</span>
<span class="p_add">+                contexts active on any one of the card AFUs. This may cause</span>
<span class="p_add">+                the card to reload the FPGA depending on load_image_on_perst.</span>
<span class="p_add">+                Writing -1 will do a force PERST irrespective of any active</span>
<span class="p_add">+                contexts on the card AFUs.</span>
 Users:		https://github.com/ibm-capi/libcxl
 
 What:		/sys/class/cxl/&lt;card&gt;/perst_reloads_same_image (not in a guest)
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index a4f4d693e2c1..46726d4899fe 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -1457,7 +1457,14 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 	i8042.nopnp	[HW] Don&#39;t use ACPIPnP / PnPBIOS to discover KBD/AUX
 			     controllers
 	i8042.notimeout	[HW] Ignore timeout condition signalled by controller
<span class="p_del">-	i8042.reset	[HW] Reset the controller during init and cleanup</span>
<span class="p_add">+	i8042.reset	[HW] Reset the controller during init, cleanup and</span>
<span class="p_add">+			     suspend-to-ram transitions, only during s2r</span>
<span class="p_add">+			     transitions, or never reset</span>
<span class="p_add">+			Format: { 1 | Y | y | 0 | N | n }</span>
<span class="p_add">+			1, Y, y: always reset controller</span>
<span class="p_add">+			0, N, n: don&#39;t ever reset controller</span>
<span class="p_add">+			Default: only on s2r transitions on x86; most other</span>
<span class="p_add">+			architectures force reset to be always executed</span>
 	i8042.unlock	[HW] Unlock (ignore) the keylock
 	i8042.kbdreset  [HW] Reset device connected to KBD port
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 82a36ab540a4..daa3a01d2525 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 8
<span class="p_del">-SUBLEVEL = 4</span>
<span class="p_add">+SUBLEVEL = 5</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arc/kernel/signal.c b/arch/arc/kernel/signal.c</span>
<span class="p_header">index 6cb3736b6b83..d347bbc086fe 100644</span>
<span class="p_header">--- a/arch/arc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/arc/kernel/signal.c</span>
<span class="p_chunk">@@ -107,13 +107,13 @@</span> <span class="p_context"> static int restore_usr_regs(struct pt_regs *regs, struct rt_sigframe __user *sf)</span>
 	struct user_regs_struct uregs;
 
 	err = __copy_from_user(&amp;set, &amp;sf-&gt;uc.uc_sigmask, sizeof(set));
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		set_current_blocked(&amp;set);</span>
<span class="p_del">-</span>
 	err |= __copy_from_user(&amp;uregs.scratch,
 				&amp;(sf-&gt;uc.uc_mcontext.regs.scratch),
 				sizeof(sf-&gt;uc.uc_mcontext.regs.scratch));
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_add">+	set_current_blocked(&amp;set);</span>
 	regs-&gt;bta	= uregs.scratch.bta;
 	regs-&gt;lp_start	= uregs.scratch.lp_start;
 	regs-&gt;lp_end	= uregs.scratch.lp_end;
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> static int restore_usr_regs(struct pt_regs *regs, struct rt_sigframe __user *sf)</span>
 	regs-&gt;r0	= uregs.scratch.r0;
 	regs-&gt;sp	= uregs.scratch.sp;
 
<span class="p_del">-	return err;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static inline int is_do_ss_needed(unsigned int magic)
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index 4cdeae3b17c6..948a9a8a9297 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -167,11 +167,6 @@</span> <span class="p_context"> static inline bool kvm_vcpu_dabt_isvalid(const struct kvm_vcpu *vcpu)</span>
 	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_ELx_ISV);
 }
 
<span class="p_del">-static inline bool kvm_vcpu_dabt_iswrite(const struct kvm_vcpu *vcpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_ELx_WNR);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline bool kvm_vcpu_dabt_issext(const struct kvm_vcpu *vcpu)
 {
 	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_ELx_SSE);
<span class="p_chunk">@@ -192,6 +187,12 @@</span> <span class="p_context"> static inline bool kvm_vcpu_dabt_iss1tw(const struct kvm_vcpu *vcpu)</span>
 	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_ELx_S1PTW);
 }
 
<span class="p_add">+static inline bool kvm_vcpu_dabt_iswrite(const struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_ELx_WNR) ||</span>
<span class="p_add">+		kvm_vcpu_dabt_iss1tw(vcpu); /* AF/DBM update */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool kvm_vcpu_dabt_is_cm(const struct kvm_vcpu *vcpu)
 {
 	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_ELx_CM);
<span class="p_header">diff --git a/arch/arm64/include/asm/module.h b/arch/arm64/include/asm/module.h</span>
<span class="p_header">index e12af6754634..06ff7fd9e81f 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/module.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/module.h</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #define __ASM_MODULE_H
 
 #include &lt;asm-generic/module.h&gt;
<span class="p_add">+#include &lt;asm/memory.h&gt;</span>
 
 #define MODULE_ARCH_VERMAGIC	&quot;aarch64&quot;
 
<span class="p_chunk">@@ -32,6 +33,10 @@</span> <span class="p_context"> u64 module_emit_plt_entry(struct module *mod, const Elf64_Rela *rela,</span>
 			  Elf64_Sym *sym);
 
 #ifdef CONFIG_RANDOMIZE_BASE
<span class="p_add">+#ifdef CONFIG_MODVERSIONS</span>
<span class="p_add">+#define ARCH_RELOCATES_KCRCTAB</span>
<span class="p_add">+#define reloc_start 		(kimage_vaddr - KIMAGE_VADDR)</span>
<span class="p_add">+#endif</span>
 extern u64 module_alloc_base;
 #else
 #define module_alloc_base	((u64)_etext - MODULES_VSIZE)
<span class="p_header">diff --git a/arch/arm64/include/asm/percpu.h b/arch/arm64/include/asm/percpu.h</span>
<span class="p_header">index 2fee2f59288c..5394c8405e66 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/percpu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/percpu.h</span>
<span class="p_chunk">@@ -44,48 +44,44 @@</span> <span class="p_context"> static inline unsigned long __percpu_##op(void *ptr,			\</span>
 									\
 	switch (size) {							\
 	case 1:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_1\n&quot;			\</span>
<span class="p_del">-			&quot;ldxrb	  %w[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_1\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxrb	  %w[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %w[ret], %w[ret], %w[val]\n&quot;		\
<span class="p_del">-			&quot;stxrb	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u8 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxrb	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u8 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	case 2:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_2\n&quot;			\</span>
<span class="p_del">-			&quot;ldxrh	  %w[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_2\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxrh	  %w[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %w[ret], %w[ret], %w[val]\n&quot;		\
<span class="p_del">-			&quot;stxrh	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr]  &quot;+Q&quot;(*(u16 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxrh	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr]  &quot;+Q&quot;(*(u16 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	case 4:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_4\n&quot;			\</span>
<span class="p_del">-			&quot;ldxr	  %w[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_4\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxr	  %w[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %w[ret], %w[ret], %w[val]\n&quot;		\
<span class="p_del">-			&quot;stxr	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u32 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxr	  %w[loop], %w[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u32 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	case 8:								\
<span class="p_del">-		do {							\</span>
<span class="p_del">-			asm (&quot;//__per_cpu_&quot; #op &quot;_8\n&quot;			\</span>
<span class="p_del">-			&quot;ldxr	  %[ret], %[ptr]\n&quot;			\</span>
<span class="p_add">+		asm (&quot;//__per_cpu_&quot; #op &quot;_8\n&quot;				\</span>
<span class="p_add">+		&quot;1:	ldxr	  %[ret], %[ptr]\n&quot;			\</span>
 			#asm_op &quot; %[ret], %[ret], %[val]\n&quot;		\
<span class="p_del">-			&quot;stxr	  %w[loop], %[ret], %[ptr]\n&quot;		\</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),	\</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u64 *)ptr)			\</span>
<span class="p_del">-			: [val] &quot;Ir&quot; (val));				\</span>
<span class="p_del">-		} while (loop);						\</span>
<span class="p_add">+		&quot;	stxr	  %w[loop], %[ret], %[ptr]\n&quot;		\</span>
<span class="p_add">+		&quot;	cbnz	  %w[loop], 1b&quot;				\</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot; (loop), [ret] &quot;=&amp;r&quot; (ret),		\</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u64 *)ptr)				\</span>
<span class="p_add">+		: [val] &quot;Ir&quot; (val));					\</span>
 		break;							\
 	default:							\
 		BUILD_BUG();						\
<span class="p_chunk">@@ -150,44 +146,40 @@</span> <span class="p_context"> static inline unsigned long __percpu_xchg(void *ptr, unsigned long val,</span>
 
 	switch (size) {
 	case 1:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_1\n&quot;</span>
<span class="p_del">-			&quot;ldxrb %w[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxrb %w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u8 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_1\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxrb	%w[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxrb	%w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u8 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	case 2:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_2\n&quot;</span>
<span class="p_del">-			&quot;ldxrh %w[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxrh %w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u16 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_2\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxrh	%w[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxrh	%w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u16 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	case 4:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_4\n&quot;</span>
<span class="p_del">-			&quot;ldxr %w[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxr %w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u32 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_4\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxr	%w[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxr	%w[loop], %w[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u32 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	case 8:
<span class="p_del">-		do {</span>
<span class="p_del">-			asm (&quot;//__percpu_xchg_8\n&quot;</span>
<span class="p_del">-			&quot;ldxr %[ret], %[ptr]\n&quot;</span>
<span class="p_del">-			&quot;stxr %w[loop], %[val], %[ptr]\n&quot;</span>
<span class="p_del">-			: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_del">-			  [ptr] &quot;+Q&quot;(*(u64 *)ptr)</span>
<span class="p_del">-			: [val] &quot;r&quot; (val));</span>
<span class="p_del">-		} while (loop);</span>
<span class="p_add">+		asm (&quot;//__percpu_xchg_8\n&quot;</span>
<span class="p_add">+		&quot;1:	ldxr	%[ret], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	stxr	%w[loop], %[val], %[ptr]\n&quot;</span>
<span class="p_add">+		&quot;	cbnz	%w[loop], 1b&quot;</span>
<span class="p_add">+		: [loop] &quot;=&amp;r&quot;(loop), [ret] &quot;=&amp;r&quot;(ret),</span>
<span class="p_add">+		  [ptr] &quot;+Q&quot;(*(u64 *)ptr)</span>
<span class="p_add">+		: [val] &quot;r&quot; (val));</span>
 		break;
 	default:
 		BUILD_BUG();
<span class="p_header">diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h</span>
<span class="p_header">index c47257c91b77..db849839e07b 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 /*
  * User space memory access functions
  */
<span class="p_add">+#include &lt;linux/bitops.h&gt;</span>
 #include &lt;linux/kasan-checks.h&gt;
 #include &lt;linux/string.h&gt;
 #include &lt;linux/thread_info.h&gt;
<span class="p_chunk">@@ -102,6 +103,13 @@</span> <span class="p_context"> static inline void set_fs(mm_segment_t fs)</span>
 	flag;								\
 })
 
<span class="p_add">+/*</span>
<span class="p_add">+ * When dealing with data aborts or instruction traps we may end up with</span>
<span class="p_add">+ * a tagged userland pointer. Clear the tag to get a sane pointer to pass</span>
<span class="p_add">+ * on to access_ok(), for instance.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define untagged_addr(addr)		sign_extend64(addr, 55)</span>
<span class="p_add">+</span>
 #define access_ok(type, addr, size)	__range_ok(addr, size)
 #define user_addr_max			get_fs
 
<span class="p_header">diff --git a/arch/arm64/kernel/armv8_deprecated.c b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">index 42ffdb54e162..b0988bb1bf64 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_chunk">@@ -280,35 +280,43 @@</span> <span class="p_context"> static void __init register_insn_emulation_sysctl(struct ctl_table *table)</span>
 /*
  * Error-checking SWP macros implemented using ldxr{b}/stxr{b}
  */
<span class="p_del">-#define __user_swpX_asm(data, addr, res, temp, B)		\</span>
<span class="p_add">+</span>
<span class="p_add">+/* Arbitrary constant to ensure forward-progress of the LL/SC loop */</span>
<span class="p_add">+#define __SWP_LL_SC_LOOPS	4</span>
<span class="p_add">+</span>
<span class="p_add">+#define __user_swpX_asm(data, addr, res, temp, temp2, B)	\</span>
 	__asm__ __volatile__(					\
<span class="p_add">+	&quot;	mov		%w3, %w7\n&quot;			\</span>
 	ALTERNATIVE(&quot;nop&quot;, SET_PSTATE_PAN(0), ARM64_HAS_PAN,	\
 		    CONFIG_ARM64_PAN)				\
<span class="p_del">-	&quot;0:	ldxr&quot;B&quot;		%w2, [%3]\n&quot;			\</span>
<span class="p_del">-	&quot;1:	stxr&quot;B&quot;		%w0, %w1, [%3]\n&quot;		\</span>
<span class="p_add">+	&quot;0:	ldxr&quot;B&quot;		%w2, [%4]\n&quot;			\</span>
<span class="p_add">+	&quot;1:	stxr&quot;B&quot;		%w0, %w1, [%4]\n&quot;		\</span>
 	&quot;	cbz		%w0, 2f\n&quot;			\
<span class="p_del">-	&quot;	mov		%w0, %w4\n&quot;			\</span>
<span class="p_add">+	&quot;	sub		%w3, %w3, #1\n&quot;			\</span>
<span class="p_add">+	&quot;	cbnz		%w3, 0b\n&quot;			\</span>
<span class="p_add">+	&quot;	mov		%w0, %w5\n&quot;			\</span>
 	&quot;	b		3f\n&quot;				\
 	&quot;2:\n&quot;							\
 	&quot;	mov		%w1, %w2\n&quot;			\
 	&quot;3:\n&quot;							\
 	&quot;	.pushsection	 .fixup,\&quot;ax\&quot;\n&quot;		\
 	&quot;	.align		2\n&quot;				\
<span class="p_del">-	&quot;4:	mov		%w0, %w5\n&quot;			\</span>
<span class="p_add">+	&quot;4:	mov		%w0, %w6\n&quot;			\</span>
 	&quot;	b		3b\n&quot;				\
 	&quot;	.popsection&quot;					\
 	_ASM_EXTABLE(0b, 4b)					\
 	_ASM_EXTABLE(1b, 4b)					\
 	ALTERNATIVE(&quot;nop&quot;, SET_PSTATE_PAN(1), ARM64_HAS_PAN,	\
 		CONFIG_ARM64_PAN)				\
<span class="p_del">-	: &quot;=&amp;r&quot; (res), &quot;+r&quot; (data), &quot;=&amp;r&quot; (temp)		\</span>
<span class="p_del">-	: &quot;r&quot; (addr), &quot;i&quot; (-EAGAIN), &quot;i&quot; (-EFAULT)		\</span>
<span class="p_add">+	: &quot;=&amp;r&quot; (res), &quot;+r&quot; (data), &quot;=&amp;r&quot; (temp), &quot;=&amp;r&quot; (temp2)	\</span>
<span class="p_add">+	: &quot;r&quot; (addr), &quot;i&quot; (-EAGAIN), &quot;i&quot; (-EFAULT),		\</span>
<span class="p_add">+	  &quot;i&quot; (__SWP_LL_SC_LOOPS)				\</span>
 	: &quot;memory&quot;)
 
<span class="p_del">-#define __user_swp_asm(data, addr, res, temp) \</span>
<span class="p_del">-	__user_swpX_asm(data, addr, res, temp, &quot;&quot;)</span>
<span class="p_del">-#define __user_swpb_asm(data, addr, res, temp) \</span>
<span class="p_del">-	__user_swpX_asm(data, addr, res, temp, &quot;b&quot;)</span>
<span class="p_add">+#define __user_swp_asm(data, addr, res, temp, temp2) \</span>
<span class="p_add">+	__user_swpX_asm(data, addr, res, temp, temp2, &quot;&quot;)</span>
<span class="p_add">+#define __user_swpb_asm(data, addr, res, temp, temp2) \</span>
<span class="p_add">+	__user_swpX_asm(data, addr, res, temp, temp2, &quot;b&quot;)</span>
 
 /*
  * Bit 22 of the instruction encoding distinguishes between
<span class="p_chunk">@@ -328,12 +336,12 @@</span> <span class="p_context"> static int emulate_swpX(unsigned int address, unsigned int *data,</span>
 	}
 
 	while (1) {
<span class="p_del">-		unsigned long temp;</span>
<span class="p_add">+		unsigned long temp, temp2;</span>
 
 		if (type == TYPE_SWPB)
<span class="p_del">-			__user_swpb_asm(*data, address, res, temp);</span>
<span class="p_add">+			__user_swpb_asm(*data, address, res, temp, temp2);</span>
 		else
<span class="p_del">-			__user_swp_asm(*data, address, res, temp);</span>
<span class="p_add">+			__user_swp_asm(*data, address, res, temp, temp2);</span>
 
 		if (likely(res != -EAGAIN) || signal_pending(current))
 			break;
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 3e7b050e99dc..4d19508c55a3 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -578,8 +578,9 @@</span> <span class="p_context"> CPU_LE(	movk	x0, #0x30d0, lsl #16	)	// Clear EE and E0E on LE systems</span>
 	b.lt	4f				// Skip if no PMU present
 	mrs	x0, pmcr_el0			// Disable debug access traps
 	ubfx	x0, x0, #11, #5			// to EL2 and allow access to
<span class="p_del">-	msr	mdcr_el2, x0			// all PMU counters from EL1</span>
 4:
<span class="p_add">+	csel	x0, xzr, x0, lt			// all PMU counters from EL1</span>
<span class="p_add">+	msr	mdcr_el2, x0			// (if they exist)</span>
 
 	/* Stage-2 translation */
 	msr	vttbr_el2, xzr
<span class="p_header">diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c</span>
<span class="p_header">index df06750846de..771a01a7fbce 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/traps.c</span>
<span class="p_chunk">@@ -434,18 +434,21 @@</span> <span class="p_context"> void cpu_enable_cache_maint_trap(void *__unused)</span>
 }
 
 #define __user_cache_maint(insn, address, res)			\
<span class="p_del">-	asm volatile (						\</span>
<span class="p_del">-		&quot;1:	&quot; insn &quot;, %1\n&quot;				\</span>
<span class="p_del">-		&quot;	mov	%w0, #0\n&quot;			\</span>
<span class="p_del">-		&quot;2:\n&quot;						\</span>
<span class="p_del">-		&quot;	.pushsection .fixup,\&quot;ax\&quot;\n&quot;		\</span>
<span class="p_del">-		&quot;	.align	2\n&quot;				\</span>
<span class="p_del">-		&quot;3:	mov	%w0, %w2\n&quot;			\</span>
<span class="p_del">-		&quot;	b	2b\n&quot;				\</span>
<span class="p_del">-		&quot;	.popsection\n&quot;				\</span>
<span class="p_del">-		_ASM_EXTABLE(1b, 3b)				\</span>
<span class="p_del">-		: &quot;=r&quot; (res)					\</span>
<span class="p_del">-		: &quot;r&quot; (address), &quot;i&quot; (-EFAULT) )</span>
<span class="p_add">+	if (untagged_addr(address) &gt;= user_addr_max())		\</span>
<span class="p_add">+		res = -EFAULT;					\</span>
<span class="p_add">+	else							\</span>
<span class="p_add">+		asm volatile (					\</span>
<span class="p_add">+			&quot;1:	&quot; insn &quot;, %1\n&quot;			\</span>
<span class="p_add">+			&quot;	mov	%w0, #0\n&quot;		\</span>
<span class="p_add">+			&quot;2:\n&quot;					\</span>
<span class="p_add">+			&quot;	.pushsection .fixup,\&quot;ax\&quot;\n&quot;	\</span>
<span class="p_add">+			&quot;	.align	2\n&quot;			\</span>
<span class="p_add">+			&quot;3:	mov	%w0, %w2\n&quot;		\</span>
<span class="p_add">+			&quot;	b	2b\n&quot;			\</span>
<span class="p_add">+			&quot;	.popsection\n&quot;			\</span>
<span class="p_add">+			_ASM_EXTABLE(1b, 3b)			\</span>
<span class="p_add">+			: &quot;=r&quot; (res)				\</span>
<span class="p_add">+			: &quot;r&quot; (address), &quot;i&quot; (-EFAULT) )</span>
 
 asmlinkage void __exception do_sysinstr(unsigned int esr, struct pt_regs *regs)
 {
<span class="p_header">diff --git a/arch/arm64/kvm/hyp/entry.S b/arch/arm64/kvm/hyp/entry.S</span>
<span class="p_header">index ce9e5e5f28cf..eaf08d3abbef 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp/entry.S</span>
<span class="p_chunk">@@ -98,6 +98,8 @@</span> <span class="p_context"> ENTRY(__guest_exit)</span>
 	// x4-x29,lr: vcpu regs
 	// vcpu x0-x3 on the stack
 
<span class="p_add">+	ALTERNATIVE(nop, SET_PSTATE_PAN(1), ARM64_HAS_PAN, CONFIG_ARM64_PAN)</span>
<span class="p_add">+</span>
 	add	x2, x0, #VCPU_CONTEXT
 
 	stp	x4, x5,   [x2, #CPU_XREG_OFFSET(4)]
<span class="p_header">diff --git a/arch/metag/include/asm/atomic.h b/arch/metag/include/asm/atomic.h</span>
<span class="p_header">index 470e365f04ea..8ff0a70865f6 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/atomic.h</span>
<span class="p_chunk">@@ -39,11 +39,10 @@</span> <span class="p_context"></span>
 #define atomic_dec(v) atomic_sub(1, (v))
 
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
<span class="p_add">+#define atomic_dec_if_positive(v)       atomic_sub_if_positive(1, v)</span>
 
 #endif
 
<span class="p_del">-#define atomic_dec_if_positive(v)       atomic_sub_if_positive(1, v)</span>
<span class="p_del">-</span>
 #include &lt;asm-generic/atomic64.h&gt;
 
 #endif /* __ASM_METAG_ATOMIC_H */
<span class="p_header">diff --git a/arch/mips/include/asm/ptrace.h b/arch/mips/include/asm/ptrace.h</span>
<span class="p_header">index f6fc6aac5496..b6578611dddb 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> static inline int is_syscall_success(struct pt_regs *regs)</span>
 
 static inline long regs_return_value(struct pt_regs *regs)
 {
<span class="p_del">-	if (is_syscall_success(regs))</span>
<span class="p_add">+	if (is_syscall_success(regs) || !user_mode(regs))</span>
 		return regs-&gt;regs[2];
 	else
 		return -regs-&gt;regs[2];
<span class="p_header">diff --git a/arch/mips/vdso/Makefile b/arch/mips/vdso/Makefile</span>
<span class="p_header">index 3b4538ec0102..de9e8836d248 100644</span>
<span class="p_header">--- a/arch/mips/vdso/Makefile</span>
<span class="p_header">+++ b/arch/mips/vdso/Makefile</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> obj-vdso := $(obj-vdso-y:%.o=$(obj)/%.o)</span>
 $(obj-vdso): KBUILD_CFLAGS := $(cflags-vdso) $(native-abi)
 $(obj-vdso): KBUILD_AFLAGS := $(aflags-vdso) $(native-abi)
 
<span class="p_del">-$(obj)/vdso.lds: KBUILD_CPPFLAGS := $(native-abi)</span>
<span class="p_add">+$(obj)/vdso.lds: KBUILD_CPPFLAGS := $(ccflags-vdso) $(native-abi)</span>
 
 $(obj)/vdso.so.dbg.raw: $(obj)/vdso.lds $(obj-vdso) FORCE
 	$(call if_changed,vdsold)
<span class="p_header">diff --git a/arch/parisc/include/asm/pgtable.h b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">index 291cee28ccb6..c2c43f714684 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -83,10 +83,10 @@</span> <span class="p_context"> static inline void purge_tlb_entries(struct mm_struct *mm, unsigned long addr)</span>
 	printk(&quot;%s:%d: bad pgd %08lx.\n&quot;, __FILE__, __LINE__, (unsigned long)pgd_val(e))
 
 /* This is the size of the initially mapped kernel memory */
<span class="p_del">-#ifdef CONFIG_64BIT</span>
<span class="p_del">-#define KERNEL_INITIAL_ORDER	25	/* 1&lt;&lt;25 = 32MB */</span>
<span class="p_add">+#if defined(CONFIG_64BIT)</span>
<span class="p_add">+#define KERNEL_INITIAL_ORDER	26	/* 1&lt;&lt;26 = 64MB */</span>
 #else
<span class="p_del">-#define KERNEL_INITIAL_ORDER	24	/* 1&lt;&lt;24 = 16MB */</span>
<span class="p_add">+#define KERNEL_INITIAL_ORDER	25	/* 1&lt;&lt;25 = 32MB */</span>
 #endif
 #define KERNEL_INITIAL_SIZE	(1 &lt;&lt; KERNEL_INITIAL_ORDER)
 
<span class="p_header">diff --git a/arch/parisc/kernel/setup.c b/arch/parisc/kernel/setup.c</span>
<span class="p_header">index f7ea626e29c9..81d6f6391944 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/setup.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/setup.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/export.h&gt;
 
 #include &lt;asm/processor.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/pdc.h&gt;
 #include &lt;asm/led.h&gt;
 #include &lt;asm/machdep.h&gt;	/* for pa7300lc_init() proto */
<span class="p_chunk">@@ -140,6 +141,13 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 #endif
 	printk(KERN_CONT &quot;.\n&quot;);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check if initial kernel page mappings are sufficient.</span>
<span class="p_add">+	 * panic early if not, else we may access kernel functions</span>
<span class="p_add">+	 * and variables which can&#39;t be reached.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (__pa((unsigned long) &amp;_end) &gt;= KERNEL_INITIAL_SIZE)</span>
<span class="p_add">+		panic(&quot;KERNEL_INITIAL_ORDER too small!&quot;);</span>
 
 	pdc_console_init();
 
<span class="p_header">diff --git a/arch/parisc/kernel/time.c b/arch/parisc/kernel/time.c</span>
<span class="p_header">index 4b0b963d52a7..9b63b876a13a 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/time.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/time.c</span>
<span class="p_chunk">@@ -226,12 +226,6 @@</span> <span class="p_context"> void __init start_cpu_itimer(void)</span>
 	unsigned int cpu = smp_processor_id();
 	unsigned long next_tick = mfctl(16) + clocktick;
 
<span class="p_del">-#if defined(CONFIG_HAVE_UNSTABLE_SCHED_CLOCK) &amp;&amp; defined(CONFIG_64BIT)</span>
<span class="p_del">-	/* With multiple 64bit CPUs online, the cr16&#39;s are not syncronized. */</span>
<span class="p_del">-	if (cpu != 0)</span>
<span class="p_del">-		clear_sched_clock_stable();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	mtctl(next_tick, 16);		/* kick off Interval Timer (CR16) */
 
 	per_cpu(cpu_data, cpu).it_value = next_tick;
<span class="p_header">diff --git a/arch/parisc/kernel/vmlinux.lds.S b/arch/parisc/kernel/vmlinux.lds.S</span>
<span class="p_header">index f3ead0b6ce46..75304af9f742 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -89,8 +89,9 @@</span> <span class="p_context"> SECTIONS</span>
 	/* Start of data section */
 	_sdata = .;
 
<span class="p_del">-	RO_DATA_SECTION(8)</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Architecturally we need to keep __gp below 0x1000000 and thus</span>
<span class="p_add">+	 * in front of RO_DATA_SECTION() which stores lots of tracepoint</span>
<span class="p_add">+	 * and ftrace symbols. */</span>
 #ifdef CONFIG_64BIT
 	. = ALIGN(16);
 	/* Linkage tables */
<span class="p_chunk">@@ -105,6 +106,8 @@</span> <span class="p_context"> SECTIONS</span>
 	}
 #endif
 
<span class="p_add">+	RO_DATA_SECTION(8)</span>
<span class="p_add">+</span>
 	/* unwind info */
 	.PARISC.unwind : {
 		__start___unwind = .;
<span class="p_header">diff --git a/arch/powerpc/Kconfig b/arch/powerpc/Kconfig</span>
<span class="p_header">index 927d2ab2ce08..792cb1768c8f 100644</span>
<span class="p_header">--- a/arch/powerpc/Kconfig</span>
<span class="p_header">+++ b/arch/powerpc/Kconfig</span>
<span class="p_chunk">@@ -637,7 +637,7 @@</span> <span class="p_context"> config FORCE_MAX_ZONEORDER</span>
 	int &quot;Maximum zone order&quot;
 	range 8 9 if PPC64 &amp;&amp; PPC_64K_PAGES
 	default &quot;9&quot; if PPC64 &amp;&amp; PPC_64K_PAGES
<span class="p_del">-	range 9 13 if PPC64 &amp;&amp; !PPC_64K_PAGES</span>
<span class="p_add">+	range 13 13 if PPC64 &amp;&amp; !PPC_64K_PAGES</span>
 	default &quot;13&quot; if PPC64 &amp;&amp; !PPC_64K_PAGES
 	range 9 64 if PPC32 &amp;&amp; PPC_16K_PAGES
 	default &quot;9&quot; if PPC32 &amp;&amp; PPC_16K_PAGES
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index 5f36e8a70daa..29aa8d1ce273 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -994,6 +994,14 @@</span> <span class="p_context"> static void eeh_handle_special_event(void)</span>
 				/* Notify all devices to be down */
 				eeh_pe_state_clear(pe, EEH_PE_PRI_BUS);
 				bus = eeh_pe_bus_get(phb_pe);
<span class="p_add">+				if (!bus) {</span>
<span class="p_add">+					pr_err(&quot;%s: Cannot find PCI bus for &quot;</span>
<span class="p_add">+					       &quot;PHB#%d-PE#%x\n&quot;,</span>
<span class="p_add">+					       __func__,</span>
<span class="p_add">+					       pe-&gt;phb-&gt;global_number,</span>
<span class="p_add">+					       pe-&gt;addr);</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 				eeh_pe_dev_traverse(pe,
 					eeh_report_failure, NULL);
 				pci_hp_remove_devices(bus);
<span class="p_header">diff --git a/arch/powerpc/kernel/vdso64/datapage.S b/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_header">index 184a6ba7f283..abf17feffe40 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> V_FUNCTION_BEGIN(__kernel_get_syscall_map)</span>
 	bl	V_LOCAL_FUNC(__get_datapage)
 	mtlr	r12
 	addi	r3,r3,CFG_SYSCALL_MAP64
<span class="p_del">-	cmpli	cr0,r4,0</span>
<span class="p_add">+	cmpldi	cr0,r4,0</span>
 	crclr	cr0*4+so
 	beqlr
 	li	r0,NR_syscalls
<span class="p_header">diff --git a/arch/powerpc/kernel/vdso64/gettimeofday.S b/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_header">index a76b4af37ef2..382021324883 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> V_FUNCTION_BEGIN(__kernel_clock_getres)</span>
 	bne	cr0,99f
 
 	li	r3,0
<span class="p_del">-	cmpli	cr0,r4,0</span>
<span class="p_add">+	cmpldi	cr0,r4,0</span>
 	crclr	cr0*4+so
 	beqlr
 	lis	r5,CLOCK_REALTIME_RES@h
<span class="p_header">diff --git a/arch/powerpc/lib/copyuser_64.S b/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_header">index f09899e35991..7b22624f332c 100644</span>
<span class="p_header">--- a/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_header">+++ b/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_chunk">@@ -359,6 +359,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)</span>
 	addi	r3,r3,8
 171:
 177:
<span class="p_add">+179:</span>
 	addi	r3,r3,8
 370:
 372:
<span class="p_chunk">@@ -373,7 +374,6 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)</span>
 173:
 174:
 175:
<span class="p_del">-179:</span>
 181:
 184:
 186:
<span class="p_header">diff --git a/arch/powerpc/mm/copro_fault.c b/arch/powerpc/mm/copro_fault.c</span>
<span class="p_header">index bb0354222b11..362954f98029 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/copro_fault.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/copro_fault.c</span>
<span class="p_chunk">@@ -106,6 +106,8 @@</span> <span class="p_context"> int copro_calculate_slb(struct mm_struct *mm, u64 ea, struct copro_slb *slb)</span>
 	switch (REGION_ID(ea)) {
 	case USER_REGION_ID:
 		pr_devel(&quot;%s: 0x%llx -- USER_REGION_ID\n&quot;, __func__, ea);
<span class="p_add">+		if (mm == NULL)</span>
<span class="p_add">+			return 1;</span>
 		psize = get_slice_psize(mm, ea);
 		ssize = user_segment_size(ea);
 		vsid = get_vsid(mm-&gt;context.id, ea, ssize);
<span class="p_header">diff --git a/arch/powerpc/mm/hash_utils_64.c b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">index 0821556e16f4..28923b2e2df1 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_chunk">@@ -526,7 +526,7 @@</span> <span class="p_context"> static bool might_have_hea(void)</span>
 	 */
 #ifdef CONFIG_IBMEBUS
 	return !cpu_has_feature(CPU_FTR_ARCH_207S) &amp;&amp;
<span class="p_del">-		!firmware_has_feature(FW_FEATURE_SPLPAR);</span>
<span class="p_add">+		firmware_has_feature(FW_FEATURE_SPLPAR);</span>
 #else
 	return false;
 #endif
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/eeh-powernv.c b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">index 86544ea85dc3..ba17fdd87ab0 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_chunk">@@ -1091,6 +1091,11 @@</span> <span class="p_context"> static int pnv_eeh_reset(struct eeh_pe *pe, int option)</span>
 	}
 
 	bus = eeh_pe_bus_get(pe);
<span class="p_add">+	if (!bus) {</span>
<span class="p_add">+		pr_err(&quot;%s: Cannot find PCI bus for PHB#%d-PE#%x\n&quot;,</span>
<span class="p_add">+			__func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr);</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	}</span>
 	if (pe-&gt;type &amp; EEH_PE_VF)
 		return pnv_eeh_reset_vf_pe(pe, option);
 
<span class="p_chunk">@@ -1306,7 +1311,7 @@</span> <span class="p_context"> static void pnv_eeh_get_and_dump_hub_diag(struct pci_controller *hose)</span>
 		return;
 	}
 
<span class="p_del">-	switch (data-&gt;type) {</span>
<span class="p_add">+	switch (be16_to_cpu(data-&gt;type)) {</span>
 	case OPAL_P7IOC_DIAG_TYPE_RGC:
 		pr_info(&quot;P7IOC diag-data for RGC\n\n&quot;);
 		pnv_eeh_dump_hub_diag_common(data);
<span class="p_chunk">@@ -1538,7 +1543,7 @@</span> <span class="p_context"> static int pnv_eeh_next_error(struct eeh_pe **pe)</span>
 
 				/* Try best to clear it */
 				opal_pci_eeh_freeze_clear(phb-&gt;opal_id,
<span class="p_del">-					frozen_pe_no,</span>
<span class="p_add">+					be64_to_cpu(frozen_pe_no),</span>
 					OPAL_EEH_ACTION_CLEAR_FREEZE_ALL);
 				ret = EEH_NEXT_ERR_NONE;
 			} else if ((*pe)-&gt;state &amp; EEH_PE_ISOLATED ||
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">index a21d831c1114..0fe3520058a5 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_chunk">@@ -309,8 +309,8 @@</span> <span class="p_context"> static void pnv_pci_dump_p7ioc_diag_data(struct pci_controller *hose,</span>
 			be64_to_cpu(data-&gt;dma1ErrorLog1));
 
 	for (i = 0; i &lt; OPAL_P7IOC_NUM_PEST_REGS; i++) {
<span class="p_del">-		if ((data-&gt;pestA[i] &gt;&gt; 63) == 0 &amp;&amp;</span>
<span class="p_del">-		    (data-&gt;pestB[i] &gt;&gt; 63) == 0)</span>
<span class="p_add">+		if ((be64_to_cpu(data-&gt;pestA[i]) &gt;&gt; 63) == 0 &amp;&amp;</span>
<span class="p_add">+		    (be64_to_cpu(data-&gt;pestB[i]) &gt;&gt; 63) == 0)</span>
 			continue;
 
 		pr_info(&quot;PE[%3d] A/B: %016llx %016llx\n&quot;,
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">index 86707e67843f..aa35245d8d6d 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static void __pSeries_lpar_hugepage_invalidate(unsigned long *slot,</span>
 					     unsigned long *vpn, int count,
 					     int psize, int ssize)
 {
<span class="p_del">-	unsigned long param[8];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	int i = 0, pix = 0, rc;
 	unsigned long flags = 0;
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_chunk">@@ -522,7 +522,7 @@</span> <span class="p_context"> static void pSeries_lpar_flush_hash_range(unsigned long number, int local)</span>
 	unsigned long flags = 0;
 	struct ppc64_tlb_batch *batch = this_cpu_ptr(&amp;ppc64_tlb_batch);
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_del">-	unsigned long param[9];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	unsigned long hash, index, shift, hidx, slot;
 	real_pte_t pte;
 	int psize, ssize;
<span class="p_header">diff --git a/arch/powerpc/sysdev/cpm1.c b/arch/powerpc/sysdev/cpm1.c</span>
<span class="p_header">index 81d49476c47e..82e8e2b6a3c4 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/cpm1.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/cpm1.c</span>
<span class="p_chunk">@@ -233,8 +233,6 @@</span> <span class="p_context"> void __init cpm_reset(void)</span>
 	else
 		out_be32(&amp;siu_conf-&gt;sc_sdcr, 1);
 	immr_unmap(siu_conf);
<span class="p_del">-</span>
<span class="p_del">-	cpm_muram_init();</span>
 }
 
 static DEFINE_SPINLOCK(cmd_lock);
<span class="p_header">diff --git a/arch/powerpc/sysdev/cpm2.c b/arch/powerpc/sysdev/cpm2.c</span>
<span class="p_header">index 8dc1e24f3c23..f78ff841652c 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/cpm2.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/cpm2.c</span>
<span class="p_chunk">@@ -66,10 +66,6 @@</span> <span class="p_context"> void __init cpm2_reset(void)</span>
 	cpm2_immr = ioremap(get_immrbase(), CPM_MAP_SIZE);
 #endif
 
<span class="p_del">-	/* Reclaim the DP memory for our use.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpm_muram_init();</span>
<span class="p_del">-</span>
 	/* Tell everyone where the comm processor resides.
 	 */
 	cpmp = &amp;cpm2_immr-&gt;im_cpm;
<span class="p_header">diff --git a/arch/powerpc/sysdev/cpm_common.c b/arch/powerpc/sysdev/cpm_common.c</span>
<span class="p_header">index 947f42007734..51bf749a4f3a 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/cpm_common.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/cpm_common.c</span>
<span class="p_chunk">@@ -37,6 +37,21 @@</span> <span class="p_context"></span>
 #include &lt;linux/of_gpio.h&gt;
 #endif
 
<span class="p_add">+static int __init cpm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+</span>
<span class="p_add">+	np = of_find_compatible_node(NULL, NULL, &quot;fsl,cpm1&quot;);</span>
<span class="p_add">+	if (!np)</span>
<span class="p_add">+		np = of_find_compatible_node(NULL, NULL, &quot;fsl,cpm2&quot;);</span>
<span class="p_add">+	if (!np)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	cpm_muram_init();</span>
<span class="p_add">+	of_node_put(np);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+subsys_initcall(cpm_init);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PPC_EARLY_DEBUG_CPM
 static u32 __iomem *cpm_udbg_txdesc;
 static u8 __iomem *cpm_udbg_txbuf;
<span class="p_header">diff --git a/arch/powerpc/xmon/spr_access.S b/arch/powerpc/xmon/spr_access.S</span>
<span class="p_header">index 84ad74213c83..7d8b0e8ed6d9 100644</span>
<span class="p_header">--- a/arch/powerpc/xmon/spr_access.S</span>
<span class="p_header">+++ b/arch/powerpc/xmon/spr_access.S</span>
<span class="p_chunk">@@ -2,12 +2,12 @@</span> <span class="p_context"></span>
 
 /* unsigned long xmon_mfspr(sprn, default_value) */
 _GLOBAL(xmon_mfspr)
<span class="p_del">-	ld	r5, .Lmfspr_table@got(r2)</span>
<span class="p_add">+	PPC_LL	r5, .Lmfspr_table@got(r2)</span>
 	b	xmon_mxspr
 
 /* void xmon_mtspr(sprn, new_value) */
 _GLOBAL(xmon_mtspr)
<span class="p_del">-	ld	r5, .Lmtspr_table@got(r2)</span>
<span class="p_add">+	PPC_LL	r5, .Lmtspr_table@got(r2)</span>
 	b	xmon_mxspr
 
 /*
<span class="p_header">diff --git a/arch/s390/kvm/intercept.c b/arch/s390/kvm/intercept.c</span>
<span class="p_header">index dfd0ca2638fa..9746b780ad5a 100644</span>
<span class="p_header">--- a/arch/s390/kvm/intercept.c</span>
<span class="p_header">+++ b/arch/s390/kvm/intercept.c</span>
<span class="p_chunk">@@ -118,8 +118,13 @@</span> <span class="p_context"> static int handle_validity(struct kvm_vcpu *vcpu)</span>
 
 	vcpu-&gt;stat.exit_validity++;
 	trace_kvm_s390_intercept_validity(vcpu, viwhy);
<span class="p_del">-	WARN_ONCE(true, &quot;kvm: unhandled validity intercept 0x%x\n&quot;, viwhy);</span>
<span class="p_del">-	return -EOPNOTSUPP;</span>
<span class="p_add">+	KVM_EVENT(3, &quot;validity intercept 0x%x for pid %u (kvm 0x%pK)&quot;, viwhy,</span>
<span class="p_add">+		  current-&gt;pid, vcpu-&gt;kvm);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do not warn on invalid runtime instrumentation mode */</span>
<span class="p_add">+	WARN_ONCE(viwhy != 0x44, &quot;kvm: unhandled validity intercept 0x%x\n&quot;,</span>
<span class="p_add">+		  viwhy);</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int handle_instruction(struct kvm_vcpu *vcpu)
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 8a90f1517837..625eb698c780 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -348,7 +348,7 @@</span> <span class="p_context"> int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,</span>
 		 * continue building up new bios map based on this
 		 * information
 		 */
<span class="p_del">-		if (current_type != last_type) {</span>
<span class="p_add">+		if (current_type != last_type || current_type == E820_PRAM) {</span>
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]-&gt;addr - last_addr;
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 82b17373b66a..9e152cdab0f3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -1408,15 +1408,17 @@</span> <span class="p_context"> __init void prefill_possible_map(void)</span>
 
 	/* No boot processor was found in mptable or ACPI MADT */
 	if (!num_processors) {
<span class="p_del">-		int apicid = boot_cpu_physical_apicid;</span>
<span class="p_del">-		int cpu = hard_smp_processor_id();</span>
<span class="p_add">+		if (boot_cpu_has(X86_FEATURE_APIC)) {</span>
<span class="p_add">+			int apicid = boot_cpu_physical_apicid;</span>
<span class="p_add">+			int cpu = hard_smp_processor_id();</span>
 
<span class="p_del">-		pr_warn(&quot;Boot CPU (id %d) not listed by BIOS\n&quot;, cpu);</span>
<span class="p_add">+			pr_warn(&quot;Boot CPU (id %d) not listed by BIOS\n&quot;, cpu);</span>
 
<span class="p_del">-		/* Make sure boot cpu is enumerated */</span>
<span class="p_del">-		if (apic-&gt;cpu_present_to_apicid(0) == BAD_APICID &amp;&amp;</span>
<span class="p_del">-		    apic-&gt;apic_id_valid(apicid))</span>
<span class="p_del">-			generic_processor_info(apicid, boot_cpu_apic_version);</span>
<span class="p_add">+			/* Make sure boot cpu is enumerated */</span>
<span class="p_add">+			if (apic-&gt;cpu_present_to_apicid(0) == BAD_APICID &amp;&amp;</span>
<span class="p_add">+			    apic-&gt;apic_id_valid(apicid))</span>
<span class="p_add">+				generic_processor_info(apicid, boot_cpu_apic_version);</span>
<span class="p_add">+		}</span>
 
 		if (!num_processors)
 			num_processors = 1;
<span class="p_header">diff --git a/arch/x86/kvm/ioapic.c b/arch/x86/kvm/ioapic.c</span>
<span class="p_header">index c7220ba94aa7..1a22de70f7f7 100644</span>
<span class="p_header">--- a/arch/x86/kvm/ioapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/ioapic.c</span>
<span class="p_chunk">@@ -594,7 +594,7 @@</span> <span class="p_context"> static void kvm_ioapic_reset(struct kvm_ioapic *ioapic)</span>
 	ioapic-&gt;irr = 0;
 	ioapic-&gt;irr_delivered = 0;
 	ioapic-&gt;id = 0;
<span class="p_del">-	memset(ioapic-&gt;irq_eoi, 0x00, IOAPIC_NUM_PINS);</span>
<span class="p_add">+	memset(ioapic-&gt;irq_eoi, 0x00, sizeof(ioapic-&gt;irq_eoi));</span>
 	rtc_irq_eoi_tracking_reset(ioapic);
 }
 
<span class="p_header">diff --git a/arch/x86/platform/uv/bios_uv.c b/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_header">index 23f2f3e41c7f..58e152b3bd90 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_chunk">@@ -40,7 +40,15 @@</span> <span class="p_context"> s64 uv_bios_call(enum uv_bios_cmd which, u64 a1, u64 a2, u64 a3, u64 a4, u64 a5)</span>
 		 */
 		return BIOS_STATUS_UNIMPLEMENTED;
 
<span class="p_del">-	ret = efi_call_virt_pointer(tab, function, (u64)which, a1, a2, a3, a4, a5);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If EFI_OLD_MEMMAP is set, we need to fall back to using our old EFI</span>
<span class="p_add">+	 * callback method, which uses efi_call() directly, with the kernel page tables:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(test_bit(EFI_OLD_MEMMAP, &amp;efi.flags)))</span>
<span class="p_add">+		ret = efi_call((void *)__va(tab-&gt;function), (u64)which, a1, a2, a3, a4, a5);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = efi_call_virt_pointer(tab, function, (u64)which, a1, a2, a3, a4, a5);</span>
<span class="p_add">+</span>
 	return ret;
 }
 EXPORT_SYMBOL_GPL(uv_bios_call);
<span class="p_header">diff --git a/block/blk-cgroup.c b/block/blk-cgroup.c</span>
<span class="p_header">index dd38e5ced4a3..b08ccbb9393a 100644</span>
<span class="p_header">--- a/block/blk-cgroup.c</span>
<span class="p_header">+++ b/block/blk-cgroup.c</span>
<span class="p_chunk">@@ -1340,10 +1340,8 @@</span> <span class="p_context"> int blkcg_policy_register(struct blkcg_policy *pol)</span>
 			struct blkcg_policy_data *cpd;
 
 			cpd = pol-&gt;cpd_alloc_fn(GFP_KERNEL);
<span class="p_del">-			if (!cpd) {</span>
<span class="p_del">-				mutex_unlock(&amp;blkcg_pol_mutex);</span>
<span class="p_add">+			if (!cpd)</span>
 				goto err_free_cpds;
<span class="p_del">-			}</span>
 
 			blkcg-&gt;cpd[pol-&gt;plid] = cpd;
 			cpd-&gt;blkcg = blkcg;
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index 6482d47deb50..d5572295cad3 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> int platform_get_irq(struct platform_device *dev, unsigned int num)</span>
 		int ret;
 
 		ret = of_irq_get(dev-&gt;dev.of_node, num);
<span class="p_del">-		if (ret &gt;= 0 || ret == -EPROBE_DEFER)</span>
<span class="p_add">+		if (ret &gt; 0 || ret == -EPROBE_DEFER)</span>
 			return ret;
 	}
 
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"> int platform_get_irq_byname(struct platform_device *dev, const char *name)</span>
 		int ret;
 
 		ret = of_irq_get_byname(dev-&gt;dev.of_node, name);
<span class="p_del">-		if (ret &gt;= 0 || ret == -EPROBE_DEFER)</span>
<span class="p_add">+		if (ret &gt; 0 || ret == -EPROBE_DEFER)</span>
 			return ret;
 	}
 
<span class="p_header">diff --git a/drivers/clk/imx/clk-imx6q.c b/drivers/clk/imx/clk-imx6q.c</span>
<span class="p_header">index ba1c1ae72ac2..ce8ea10407e4 100644</span>
<span class="p_header">--- a/drivers/clk/imx/clk-imx6q.c</span>
<span class="p_header">+++ b/drivers/clk/imx/clk-imx6q.c</span>
<span class="p_chunk">@@ -318,11 +318,16 @@</span> <span class="p_context"> static void __init imx6q_clocks_init(struct device_node *ccm_node)</span>
 		clk[IMX6QDL_CLK_IPG_PER_SEL] = imx_clk_mux(&quot;ipg_per_sel&quot;, base + 0x1c, 6, 1, ipg_per_sels, ARRAY_SIZE(ipg_per_sels));
 		clk[IMX6QDL_CLK_UART_SEL] = imx_clk_mux(&quot;uart_sel&quot;, base + 0x24, 6, 1, uart_sels, ARRAY_SIZE(uart_sels));
 		clk[IMX6QDL_CLK_GPU2D_CORE_SEL] = imx_clk_mux(&quot;gpu2d_core_sel&quot;, base + 0x18, 16, 2, gpu2d_core_sels_2, ARRAY_SIZE(gpu2d_core_sels_2));
<span class="p_add">+	} else if (clk_on_imx6dl()) {</span>
<span class="p_add">+		clk[IMX6QDL_CLK_MLB_SEL] = imx_clk_mux(&quot;mlb_sel&quot;,   base + 0x18, 16, 2, gpu2d_core_sels,   ARRAY_SIZE(gpu2d_core_sels));</span>
 	} else {
 		clk[IMX6QDL_CLK_GPU2D_CORE_SEL] = imx_clk_mux(&quot;gpu2d_core_sel&quot;,   base + 0x18, 16, 2, gpu2d_core_sels,   ARRAY_SIZE(gpu2d_core_sels));
 	}
 	clk[IMX6QDL_CLK_GPU3D_CORE_SEL]   = imx_clk_mux(&quot;gpu3d_core_sel&quot;,   base + 0x18, 4,  2, gpu3d_core_sels,   ARRAY_SIZE(gpu3d_core_sels));
<span class="p_del">-	clk[IMX6QDL_CLK_GPU3D_SHADER_SEL] = imx_clk_mux(&quot;gpu3d_shader_sel&quot;, base + 0x18, 8,  2, gpu3d_shader_sels, ARRAY_SIZE(gpu3d_shader_sels));</span>
<span class="p_add">+	if (clk_on_imx6dl())</span>
<span class="p_add">+		clk[IMX6QDL_CLK_GPU2D_CORE_SEL] = imx_clk_mux(&quot;gpu2d_core_sel&quot;, base + 0x18, 8,  2, gpu3d_shader_sels, ARRAY_SIZE(gpu3d_shader_sels));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		clk[IMX6QDL_CLK_GPU3D_SHADER_SEL] = imx_clk_mux(&quot;gpu3d_shader_sel&quot;, base + 0x18, 8,  2, gpu3d_shader_sels, ARRAY_SIZE(gpu3d_shader_sels));</span>
 	clk[IMX6QDL_CLK_IPU1_SEL]         = imx_clk_mux(&quot;ipu1_sel&quot;,         base + 0x3c, 9,  2, ipu_sels,          ARRAY_SIZE(ipu_sels));
 	clk[IMX6QDL_CLK_IPU2_SEL]         = imx_clk_mux(&quot;ipu2_sel&quot;,         base + 0x3c, 14, 2, ipu_sels,          ARRAY_SIZE(ipu_sels));
 	clk[IMX6QDL_CLK_LDB_DI0_SEL]      = imx_clk_mux_flags(&quot;ldb_di0_sel&quot;, base + 0x2c, 9,  3, ldb_di_sels,      ARRAY_SIZE(ldb_di_sels), CLK_SET_RATE_PARENT);
<span class="p_chunk">@@ -400,9 +405,15 @@</span> <span class="p_context"> static void __init imx6q_clocks_init(struct device_node *ccm_node)</span>
 		clk[IMX6QDL_CLK_LDB_DI0_DIV_3_5] = imx_clk_fixed_factor(&quot;ldb_di0_div_3_5&quot;, &quot;ldb_di0_sel&quot;, 2, 7);
 		clk[IMX6QDL_CLK_LDB_DI1_DIV_3_5] = imx_clk_fixed_factor(&quot;ldb_di1_div_3_5&quot;, &quot;ldb_di1_sel&quot;, 2, 7);
 	}
<span class="p_del">-	clk[IMX6QDL_CLK_GPU2D_CORE_PODF]  = imx_clk_divider(&quot;gpu2d_core_podf&quot;,  &quot;gpu2d_core_sel&quot;,    base + 0x18, 23, 3);</span>
<span class="p_add">+	if (clk_on_imx6dl())</span>
<span class="p_add">+		clk[IMX6QDL_CLK_MLB_PODF]  = imx_clk_divider(&quot;mlb_podf&quot;,  &quot;mlb_sel&quot;,    base + 0x18, 23, 3);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		clk[IMX6QDL_CLK_GPU2D_CORE_PODF]  = imx_clk_divider(&quot;gpu2d_core_podf&quot;,  &quot;gpu2d_core_sel&quot;,    base + 0x18, 23, 3);</span>
 	clk[IMX6QDL_CLK_GPU3D_CORE_PODF]  = imx_clk_divider(&quot;gpu3d_core_podf&quot;,  &quot;gpu3d_core_sel&quot;,    base + 0x18, 26, 3);
<span class="p_del">-	clk[IMX6QDL_CLK_GPU3D_SHADER]     = imx_clk_divider(&quot;gpu3d_shader&quot;,     &quot;gpu3d_shader_sel&quot;,  base + 0x18, 29, 3);</span>
<span class="p_add">+	if (clk_on_imx6dl())</span>
<span class="p_add">+		clk[IMX6QDL_CLK_GPU2D_CORE_PODF]  = imx_clk_divider(&quot;gpu2d_core_podf&quot;,     &quot;gpu2d_core_sel&quot;,  base + 0x18, 29, 3);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		clk[IMX6QDL_CLK_GPU3D_SHADER]     = imx_clk_divider(&quot;gpu3d_shader&quot;,     &quot;gpu3d_shader_sel&quot;,  base + 0x18, 29, 3);</span>
 	clk[IMX6QDL_CLK_IPU1_PODF]        = imx_clk_divider(&quot;ipu1_podf&quot;,        &quot;ipu1_sel&quot;,          base + 0x3c, 11, 3);
 	clk[IMX6QDL_CLK_IPU2_PODF]        = imx_clk_divider(&quot;ipu2_podf&quot;,        &quot;ipu2_sel&quot;,          base + 0x3c, 16, 3);
 	clk[IMX6QDL_CLK_LDB_DI0_PODF]     = imx_clk_divider_flags(&quot;ldb_di0_podf&quot;, &quot;ldb_di0_div_3_5&quot;, base + 0x20, 10, 1, 0);
<span class="p_chunk">@@ -473,14 +484,7 @@</span> <span class="p_context"> static void __init imx6q_clocks_init(struct device_node *ccm_node)</span>
 	clk[IMX6QDL_CLK_ESAI_MEM]     = imx_clk_gate2_shared(&quot;esai_mem&quot;, &quot;ahb&quot;,             base + 0x6c, 16, &amp;share_count_esai);
 	clk[IMX6QDL_CLK_GPT_IPG]      = imx_clk_gate2(&quot;gpt_ipg&quot;,       &quot;ipg&quot;,               base + 0x6c, 20);
 	clk[IMX6QDL_CLK_GPT_IPG_PER]  = imx_clk_gate2(&quot;gpt_ipg_per&quot;,   &quot;ipg_per&quot;,           base + 0x6c, 22);
<span class="p_del">-	if (clk_on_imx6dl())</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The multiplexer and divider of imx6q clock gpu3d_shader get</span>
<span class="p_del">-		 * redefined/reused as gpu2d_core_sel and gpu2d_core_podf on imx6dl.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		clk[IMX6QDL_CLK_GPU2D_CORE] = imx_clk_gate2(&quot;gpu2d_core&quot;, &quot;gpu3d_shader&quot;, base + 0x6c, 24);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		clk[IMX6QDL_CLK_GPU2D_CORE] = imx_clk_gate2(&quot;gpu2d_core&quot;, &quot;gpu2d_core_podf&quot;, base + 0x6c, 24);</span>
<span class="p_add">+	clk[IMX6QDL_CLK_GPU2D_CORE] = imx_clk_gate2(&quot;gpu2d_core&quot;, &quot;gpu2d_core_podf&quot;, base + 0x6c, 24);</span>
 	clk[IMX6QDL_CLK_GPU3D_CORE]   = imx_clk_gate2(&quot;gpu3d_core&quot;,    &quot;gpu3d_core_podf&quot;,   base + 0x6c, 26);
 	clk[IMX6QDL_CLK_HDMI_IAHB]    = imx_clk_gate2(&quot;hdmi_iahb&quot;,     &quot;ahb&quot;,               base + 0x70, 0);
 	clk[IMX6QDL_CLK_HDMI_ISFR]    = imx_clk_gate2(&quot;hdmi_isfr&quot;,     &quot;video_27m&quot;,         base + 0x70, 4);
<span class="p_chunk">@@ -511,7 +515,7 @@</span> <span class="p_context"> static void __init imx6q_clocks_init(struct device_node *ccm_node)</span>
 		 * The multiplexer and divider of the imx6q clock gpu2d get
 		 * redefined/reused as mlb_sys_sel and mlb_sys_clk_podf on imx6dl.
 		 */
<span class="p_del">-		clk[IMX6QDL_CLK_MLB] = imx_clk_gate2(&quot;mlb&quot;,            &quot;gpu2d_core_podf&quot;,   base + 0x74, 18);</span>
<span class="p_add">+		clk[IMX6QDL_CLK_MLB] = imx_clk_gate2(&quot;mlb&quot;,            &quot;mlb_podf&quot;,   base + 0x74, 18);</span>
 	else
 		clk[IMX6QDL_CLK_MLB] = imx_clk_gate2(&quot;mlb&quot;,            &quot;axi&quot;,               base + 0x74, 18);
 	clk[IMX6QDL_CLK_MMDC_CH0_AXI] = imx_clk_gate2(&quot;mmdc_ch0_axi&quot;,  &quot;mmdc_ch0_axi_podf&quot;, base + 0x74, 20);
<span class="p_chunk">@@ -629,6 +633,24 @@</span> <span class="p_context"> static void __init imx6q_clocks_init(struct device_node *ccm_node)</span>
 	if (IS_ENABLED(CONFIG_PCI_IMX6))
 		clk_set_parent(clk[IMX6QDL_CLK_LVDS1_SEL], clk[IMX6QDL_CLK_SATA_REF_100M]);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initialize the GPU clock muxes, so that the maximum specified clock</span>
<span class="p_add">+	 * rates for the respective SoC are not exceeded.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (clk_on_imx6dl()) {</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU3D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL2_PFD1_594M]);</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU2D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL2_PFD1_594M]);</span>
<span class="p_add">+	} else if (clk_on_imx6q()) {</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU3D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_MMDC_CH0_AXI]);</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU3D_SHADER_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL2_PFD1_594M]);</span>
<span class="p_add">+		clk_set_parent(clk[IMX6QDL_CLK_GPU2D_CORE_SEL],</span>
<span class="p_add">+			       clk[IMX6QDL_CLK_PLL3_USB_OTG]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	imx_register_uart_clocks(uart_clks);
 }
 CLK_OF_DECLARE(imx6q, &quot;fsl,imx6q-ccm&quot;, imx6q_clocks_init);
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c</span>
<span class="p_header">index 2ee40fd360ca..e1aa531a4c34 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq-dt-platdev.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq-dt-platdev.c</span>
<span class="p_chunk">@@ -68,6 +68,8 @@</span> <span class="p_context"> static const struct of_device_id machines[] __initconst = {</span>
 
 	{ .compatible = &quot;sigma,tango4&quot; },
 
<span class="p_add">+	{ .compatible = &quot;ti,am33xx&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;ti,dra7&quot;, },</span>
 	{ .compatible = &quot;ti,omap2&quot;, },
 	{ .compatible = &quot;ti,omap3&quot;, },
 	{ .compatible = &quot;ti,omap4&quot;, },
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">index 18da4f8051d3..13475890d792 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 struct cs_policy_dbs_info {
 	struct policy_dbs_info policy_dbs;
 	unsigned int down_skip;
<span class="p_add">+	unsigned int requested_freq;</span>
 };
 
 static inline struct cs_policy_dbs_info *to_dbs_info(struct policy_dbs_info *policy_dbs)
<span class="p_chunk">@@ -61,6 +62,7 @@</span> <span class="p_context"> static unsigned int cs_dbs_timer(struct cpufreq_policy *policy)</span>
 {
 	struct policy_dbs_info *policy_dbs = policy-&gt;governor_data;
 	struct cs_policy_dbs_info *dbs_info = to_dbs_info(policy_dbs);
<span class="p_add">+	unsigned int requested_freq = dbs_info-&gt;requested_freq;</span>
 	struct dbs_data *dbs_data = policy_dbs-&gt;dbs_data;
 	struct cs_dbs_tuners *cs_tuners = dbs_data-&gt;tuners;
 	unsigned int load = dbs_update(policy);
<span class="p_chunk">@@ -72,10 +74,16 @@</span> <span class="p_context"> static unsigned int cs_dbs_timer(struct cpufreq_policy *policy)</span>
 	if (cs_tuners-&gt;freq_step == 0)
 		goto out;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If requested_freq is out of range, it is likely that the limits</span>
<span class="p_add">+	 * changed in the meantime, so fall back to current frequency in that</span>
<span class="p_add">+	 * case.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (requested_freq &gt; policy-&gt;max || requested_freq &lt; policy-&gt;min)</span>
<span class="p_add">+		requested_freq = policy-&gt;cur;</span>
<span class="p_add">+</span>
 	/* Check for frequency increase */
 	if (load &gt; dbs_data-&gt;up_threshold) {
<span class="p_del">-		unsigned int requested_freq = policy-&gt;cur;</span>
<span class="p_del">-</span>
 		dbs_info-&gt;down_skip = 0;
 
 		/* if we are already at full speed then break out early */
<span class="p_chunk">@@ -83,8 +91,11 @@</span> <span class="p_context"> static unsigned int cs_dbs_timer(struct cpufreq_policy *policy)</span>
 			goto out;
 
 		requested_freq += get_freq_target(cs_tuners, policy);
<span class="p_add">+		if (requested_freq &gt; policy-&gt;max)</span>
<span class="p_add">+			requested_freq = policy-&gt;max;</span>
 
 		__cpufreq_driver_target(policy, requested_freq, CPUFREQ_RELATION_H);
<span class="p_add">+		dbs_info-&gt;requested_freq = requested_freq;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -95,7 +106,7 @@</span> <span class="p_context"> static unsigned int cs_dbs_timer(struct cpufreq_policy *policy)</span>
 
 	/* Check for frequency decrease */
 	if (load &lt; cs_tuners-&gt;down_threshold) {
<span class="p_del">-		unsigned int freq_target, requested_freq = policy-&gt;cur;</span>
<span class="p_add">+		unsigned int freq_target;</span>
 		/*
 		 * if we cannot reduce the frequency anymore, break out early
 		 */
<span class="p_chunk">@@ -109,6 +120,7 @@</span> <span class="p_context"> static unsigned int cs_dbs_timer(struct cpufreq_policy *policy)</span>
 			requested_freq = policy-&gt;min;
 
 		__cpufreq_driver_target(policy, requested_freq, CPUFREQ_RELATION_L);
<span class="p_add">+		dbs_info-&gt;requested_freq = requested_freq;</span>
 	}
 
  out:
<span class="p_chunk">@@ -287,6 +299,7 @@</span> <span class="p_context"> static void cs_start(struct cpufreq_policy *policy)</span>
 	struct cs_policy_dbs_info *dbs_info = to_dbs_info(policy-&gt;governor_data);
 
 	dbs_info-&gt;down_skip = 0;
<span class="p_add">+	dbs_info-&gt;requested_freq = policy-&gt;cur;</span>
 }
 
 static struct dbs_governor cs_governor = {
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index be9eade147f2..b46547e907be 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -556,12 +556,12 @@</span> <span class="p_context"> static void intel_pstate_hwp_set(const struct cpumask *cpumask)</span>
 	int min, hw_min, max, hw_max, cpu, range, adj_range;
 	u64 value, cap;
 
<span class="p_del">-	rdmsrl(MSR_HWP_CAPABILITIES, cap);</span>
<span class="p_del">-	hw_min = HWP_LOWEST_PERF(cap);</span>
<span class="p_del">-	hw_max = HWP_HIGHEST_PERF(cap);</span>
<span class="p_del">-	range = hw_max - hw_min;</span>
<span class="p_del">-</span>
 	for_each_cpu(cpu, cpumask) {
<span class="p_add">+		rdmsrl_on_cpu(cpu, MSR_HWP_CAPABILITIES, &amp;cap);</span>
<span class="p_add">+		hw_min = HWP_LOWEST_PERF(cap);</span>
<span class="p_add">+		hw_max = HWP_HIGHEST_PERF(cap);</span>
<span class="p_add">+		range = hw_max - hw_min;</span>
<span class="p_add">+</span>
 		rdmsrl_on_cpu(cpu, MSR_HWP_REQUEST, &amp;value);
 		adj_range = limits-&gt;min_perf_pct * range / 100;
 		min = hw_min + adj_range;
<span class="p_header">diff --git a/drivers/gpio/gpio-mpc8xxx.c b/drivers/gpio/gpio-mpc8xxx.c</span>
<span class="p_header">index 425501c39527..793518a30afe 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mpc8xxx.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mpc8xxx.c</span>
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static int mpc8xxx_gpio_irq_map(struct irq_domain *h, unsigned int irq,</span>
 				irq_hw_number_t hwirq)
 {
 	irq_set_chip_data(irq, h-&gt;host_data);
<span class="p_del">-	irq_set_chip_and_handler(irq, &amp;mpc8xxx_irq_chip, handle_level_irq);</span>
<span class="p_add">+	irq_set_chip_and_handler(irq, &amp;mpc8xxx_irq_chip, handle_edge_irq);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c</span>
<span class="p_header">index f2b776efab3a..5f88ccd6806b 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/verbs.c</span>
<span class="p_chunk">@@ -821,7 +821,7 @@</span> <span class="p_context"> struct ib_qp *ib_create_qp(struct ib_pd *pd,</span>
 		if (ret) {
 			pr_err(&quot;failed to init MR pool ret= %d\n&quot;, ret);
 			ib_destroy_qp(qp);
<span class="p_del">-			qp = ERR_PTR(ret);</span>
<span class="p_add">+			return ERR_PTR(ret);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 3322ed750172..6b07d4bca764 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -1400,7 +1400,9 @@</span> <span class="p_context"> static int srp_map_sg_entry(struct srp_map_state *state,</span>
 
 	while (dma_len) {
 		unsigned offset = dma_addr &amp; ~dev-&gt;mr_page_mask;
<span class="p_del">-		if (state-&gt;npages == dev-&gt;max_pages_per_mr || offset != 0) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (state-&gt;npages == dev-&gt;max_pages_per_mr ||</span>
<span class="p_add">+		    (state-&gt;npages &gt; 0 &amp;&amp; offset != 0)) {</span>
 			ret = srp_map_finish_fmr(state, ch);
 			if (ret)
 				return ret;
<span class="p_chunk">@@ -1417,12 +1419,12 @@</span> <span class="p_context"> static int srp_map_sg_entry(struct srp_map_state *state,</span>
 	}
 
 	/*
<span class="p_del">-	 * If the last entry of the MR wasn&#39;t a full page, then we need to</span>
<span class="p_add">+	 * If the end of the MR is not on a page boundary then we need to</span>
 	 * close it out and start a new one -- we can only merge at page
 	 * boundaries.
 	 */
 	ret = 0;
<span class="p_del">-	if (len != dev-&gt;mr_page_size)</span>
<span class="p_add">+	if ((dma_addr &amp; ~dev-&gt;mr_page_mask) != 0)</span>
 		ret = srp_map_finish_fmr(state, ch);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 08e252a42480..ff8c10749e57 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1159,6 +1159,13 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_has_middle_button[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;CELSIUS H730&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu H760 also has a middle button */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;CELSIUS H760&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 #endif
 	{ }
 };
<span class="p_chunk">@@ -1503,10 +1510,10 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {</span>
 		},
 	},
 	{
<span class="p_del">-		/* Fujitsu LIFEBOOK E554  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		/* Fujitsu H760 does not work with crc_enabled == 0 */</span>
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_del">-			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E554&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;CELSIUS H760&quot;),</span>
 		},
 	},
 	{
<span class="p_chunk">@@ -1517,6 +1524,20 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Fujitsu LIFEBOOK E554  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E554&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu LIFEBOOK E556 does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E556&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* Fujitsu LIFEBOOK U745 does not work with crc_enabled == 0 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_header">diff --git a/drivers/input/serio/i8042-io.h b/drivers/input/serio/i8042-io.h</span>
<span class="p_header">index a5eed2ade53d..34da81c006b6 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-io.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static inline int i8042_platform_init(void)</span>
 		return -EBUSY;
 #endif
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/input/serio/i8042-ip22io.h b/drivers/input/serio/i8042-ip22io.h</span>
<span class="p_header">index ee1ad27d6ed0..08a1c10a1448 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-ip22io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-ip22io.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> static inline int i8042_platform_init(void)</span>
 		return -EBUSY;
 #endif
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/serio/i8042-ppcio.h b/drivers/input/serio/i8042-ppcio.h</span>
<span class="p_header">index f708c75d16f1..1aabea43329e 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-ppcio.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-ppcio.h</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static inline void i8042_write_command(int val)</span>
 
 static inline int i8042_platform_init(void)
 {
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/input/serio/i8042-sparcio.h b/drivers/input/serio/i8042-sparcio.h</span>
<span class="p_header">index afcd1c1a05b2..6231d63860ee 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-sparcio.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-sparcio.h</span>
<span class="p_chunk">@@ -130,7 +130,7 @@</span> <span class="p_context"> static int __init i8042_platform_init(void)</span>
 		}
 	}
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/serio/i8042-unicore32io.h b/drivers/input/serio/i8042-unicore32io.h</span>
<span class="p_header">index 73f5cc124a36..455747552f85 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-unicore32io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-unicore32io.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> static inline int i8042_platform_init(void)</span>
 	if (!request_mem_region(I8042_REGION_START, I8042_REGION_SIZE, &quot;i8042&quot;))
 		return -EBUSY;
 
<span class="p_del">-	i8042_reset = 1;</span>
<span class="p_add">+	i8042_reset = I8042_RESET_ALWAYS;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index 68f5f4a0f1e7..f4bfb4b2d50a 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -510,6 +510,90 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {</span>
 	{ }
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * On some Asus laptops, just running self tests cause problems.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const struct dmi_system_id i8042_dmi_noselftest_table[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;A455LD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;K401LB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;K501LB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;K501LX&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;R409L&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;V502LX&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X302LA&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X450LCP&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X450LD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X455LAB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X455LDB&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;X455LF&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTeK COMPUTER INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Z450LA&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
 static const struct dmi_system_id __initconst i8042_dmi_reset_table[] = {
 	{
 		/* MSI Wind U-100 */
<span class="p_chunk">@@ -1072,12 +1156,18 @@</span> <span class="p_context"> static int __init i8042_platform_init(void)</span>
 		return retval;
 
 #if defined(__ia64__)
<span class="p_del">-        i8042_reset = true;</span>
<span class="p_add">+        i8042_reset = I8042_RESET_ALWAYS;</span>
 #endif
 
 #ifdef CONFIG_X86
<span class="p_del">-	if (dmi_check_system(i8042_dmi_reset_table))</span>
<span class="p_del">-		i8042_reset = true;</span>
<span class="p_add">+	/* Honor module parameter when value is not default */</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_DEFAULT) {</span>
<span class="p_add">+		if (dmi_check_system(i8042_dmi_reset_table))</span>
<span class="p_add">+			i8042_reset = I8042_RESET_ALWAYS;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (dmi_check_system(i8042_dmi_noselftest_table))</span>
<span class="p_add">+			i8042_reset = I8042_RESET_NEVER;</span>
<span class="p_add">+	}</span>
 
 	if (dmi_check_system(i8042_dmi_noloop_table))
 		i8042_noloop = true;
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index 405252a884dd..89abfdb539ac 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -48,9 +48,39 @@</span> <span class="p_context"> static bool i8042_unlock;</span>
 module_param_named(unlock, i8042_unlock, bool, 0);
 MODULE_PARM_DESC(unlock, &quot;Ignore keyboard lock.&quot;);
 
<span class="p_del">-static bool i8042_reset;</span>
<span class="p_del">-module_param_named(reset, i8042_reset, bool, 0);</span>
<span class="p_del">-MODULE_PARM_DESC(reset, &quot;Reset controller during init and cleanup.&quot;);</span>
<span class="p_add">+enum i8042_controller_reset_mode {</span>
<span class="p_add">+	I8042_RESET_NEVER,</span>
<span class="p_add">+	I8042_RESET_ALWAYS,</span>
<span class="p_add">+	I8042_RESET_ON_S2RAM,</span>
<span class="p_add">+#define I8042_RESET_DEFAULT	I8042_RESET_ON_S2RAM</span>
<span class="p_add">+};</span>
<span class="p_add">+static enum i8042_controller_reset_mode i8042_reset = I8042_RESET_DEFAULT;</span>
<span class="p_add">+static int i8042_set_reset(const char *val, const struct kernel_param *kp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	enum i8042_controller_reset_mode *arg = kp-&gt;arg;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+	bool reset;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (val) {</span>
<span class="p_add">+		error = kstrtobool(val, &amp;reset);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		reset = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*arg = reset ? I8042_RESET_ALWAYS : I8042_RESET_NEVER;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct kernel_param_ops param_ops_reset_param = {</span>
<span class="p_add">+	.flags = KERNEL_PARAM_OPS_FL_NOARG,</span>
<span class="p_add">+	.set = i8042_set_reset,</span>
<span class="p_add">+};</span>
<span class="p_add">+#define param_check_reset_param(name, p)	\</span>
<span class="p_add">+	__param_check(name, p, enum i8042_controller_reset_mode)</span>
<span class="p_add">+module_param_named(reset, i8042_reset, reset_param, 0);</span>
<span class="p_add">+MODULE_PARM_DESC(reset, &quot;Reset controller on resume, cleanup or both&quot;);</span>
 
 static bool i8042_direct;
 module_param_named(direct, i8042_direct, bool, 0);
<span class="p_chunk">@@ -1019,7 +1049,7 @@</span> <span class="p_context"> static int i8042_controller_init(void)</span>
  * Reset the controller and reset CRT to the original value set by BIOS.
  */
 
<span class="p_del">-static void i8042_controller_reset(bool force_reset)</span>
<span class="p_add">+static void i8042_controller_reset(bool s2r_wants_reset)</span>
 {
 	i8042_flush();
 
<span class="p_chunk">@@ -1044,8 +1074,10 @@</span> <span class="p_context"> static void i8042_controller_reset(bool force_reset)</span>
  * Reset the controller if requested.
  */
 
<span class="p_del">-	if (i8042_reset || force_reset)</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_ALWAYS ||</span>
<span class="p_add">+	    (i8042_reset == I8042_RESET_ON_S2RAM &amp;&amp; s2r_wants_reset)) {</span>
 		i8042_controller_selftest();
<span class="p_add">+	}</span>
 
 /*
  * Restore the original control register setting.
<span class="p_chunk">@@ -1110,7 +1142,7 @@</span> <span class="p_context"> static void i8042_dritek_enable(void)</span>
  * before suspending.
  */
 
<span class="p_del">-static int i8042_controller_resume(bool force_reset)</span>
<span class="p_add">+static int i8042_controller_resume(bool s2r_wants_reset)</span>
 {
 	int error;
 
<span class="p_chunk">@@ -1118,7 +1150,8 @@</span> <span class="p_context"> static int i8042_controller_resume(bool force_reset)</span>
 	if (error)
 		return error;
 
<span class="p_del">-	if (i8042_reset || force_reset) {</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_ALWAYS ||</span>
<span class="p_add">+	    (i8042_reset == I8042_RESET_ON_S2RAM &amp;&amp; s2r_wants_reset)) {</span>
 		error = i8042_controller_selftest();
 		if (error)
 			return error;
<span class="p_chunk">@@ -1195,7 +1228,7 @@</span> <span class="p_context"> static int i8042_pm_resume_noirq(struct device *dev)</span>
 
 static int i8042_pm_resume(struct device *dev)
 {
<span class="p_del">-	bool force_reset;</span>
<span class="p_add">+	bool want_reset;</span>
 	int i;
 
 	for (i = 0; i &lt; I8042_NUM_PORTS; i++) {
<span class="p_chunk">@@ -1218,9 +1251,9 @@</span> <span class="p_context"> static int i8042_pm_resume(struct device *dev)</span>
 	 * off control to the platform firmware, otherwise we can simply restore
 	 * the mode.
 	 */
<span class="p_del">-	force_reset = pm_resume_via_firmware();</span>
<span class="p_add">+	want_reset = pm_resume_via_firmware();</span>
 
<span class="p_del">-	return i8042_controller_resume(force_reset);</span>
<span class="p_add">+	return i8042_controller_resume(want_reset);</span>
 }
 
 static int i8042_pm_thaw(struct device *dev)
<span class="p_chunk">@@ -1482,7 +1515,7 @@</span> <span class="p_context"> static int __init i8042_probe(struct platform_device *dev)</span>
 
 	i8042_platform_device = dev;
 
<span class="p_del">-	if (i8042_reset) {</span>
<span class="p_add">+	if (i8042_reset == I8042_RESET_ALWAYS) {</span>
 		error = i8042_controller_selftest();
 		if (error)
 			return error;
<span class="p_header">diff --git a/drivers/irqchip/irq-eznps.c b/drivers/irqchip/irq-eznps.c</span>
<span class="p_header">index efbf0e4304b7..ebc2b0b15f67 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-eznps.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-eznps.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static void nps400_irq_eoi_global(struct irq_data *irqd)</span>
 	nps_ack_gic();
 }
 
<span class="p_del">-static void nps400_irq_eoi(struct irq_data *irqd)</span>
<span class="p_add">+static void nps400_irq_ack(struct irq_data *irqd)</span>
 {
 	unsigned int __maybe_unused irq = irqd_to_hwirq(irqd);
 
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> static struct irq_chip nps400_irq_chip_percpu = {</span>
 	.name		= &quot;NPS400 IC&quot;,
 	.irq_mask	= nps400_irq_mask,
 	.irq_unmask	= nps400_irq_unmask,
<span class="p_del">-	.irq_eoi	= nps400_irq_eoi,</span>
<span class="p_add">+	.irq_ack	= nps400_irq_ack,</span>
 };
 
 static int nps400_irq_map(struct irq_domain *d, unsigned int virq,
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">index da6c0ba61d4f..708a2604a7b5 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_chunk">@@ -153,7 +153,7 @@</span> <span class="p_context"> static void gic_enable_redist(bool enable)</span>
 			return;	/* No PM support in this redistributor */
 	}
 
<span class="p_del">-	while (count--) {</span>
<span class="p_add">+	while (--count) {</span>
 		val = readl_relaxed(rbase + GICR_WAKER);
 		if (enable ^ (bool)(val &amp; GICR_WAKER_ChildrenAsleep))
 			break;
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index 874295757caa..6fc8923bd92a 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -113,8 +113,7 @@</span> <span class="p_context"> struct iv_tcw_private {</span>
  * and encrypts / decrypts at the same time.
  */
 enum flags { DM_CRYPT_SUSPENDED, DM_CRYPT_KEY_VALID,
<span class="p_del">-	     DM_CRYPT_SAME_CPU, DM_CRYPT_NO_OFFLOAD,</span>
<span class="p_del">-	     DM_CRYPT_EXIT_THREAD};</span>
<span class="p_add">+	     DM_CRYPT_SAME_CPU, DM_CRYPT_NO_OFFLOAD };</span>
 
 /*
  * The fields in here must be read only after initialization.
<span class="p_chunk">@@ -1207,18 +1206,20 @@</span> <span class="p_context"> continue_locked:</span>
 		if (!RB_EMPTY_ROOT(&amp;cc-&gt;write_tree))
 			goto pop_from_list;
 
<span class="p_del">-		if (unlikely(test_bit(DM_CRYPT_EXIT_THREAD, &amp;cc-&gt;flags))) {</span>
<span class="p_del">-			spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		__set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_add">+		set_current_state(TASK_INTERRUPTIBLE);</span>
 		__add_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);
 
 		spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);
 
<span class="p_add">+		if (unlikely(kthread_should_stop())) {</span>
<span class="p_add">+			set_task_state(current, TASK_RUNNING);</span>
<span class="p_add">+			remove_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		schedule();
 
<span class="p_add">+		set_task_state(current, TASK_RUNNING);</span>
 		spin_lock_irq(&amp;cc-&gt;write_thread_wait.lock);
 		__remove_wait_queue(&amp;cc-&gt;write_thread_wait, &amp;wait);
 		goto continue_locked;
<span class="p_chunk">@@ -1533,13 +1534,8 @@</span> <span class="p_context"> static void crypt_dtr(struct dm_target *ti)</span>
 	if (!cc)
 		return;
 
<span class="p_del">-	if (cc-&gt;write_thread) {</span>
<span class="p_del">-		spin_lock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_del">-		set_bit(DM_CRYPT_EXIT_THREAD, &amp;cc-&gt;flags);</span>
<span class="p_del">-		wake_up_locked(&amp;cc-&gt;write_thread_wait);</span>
<span class="p_del">-		spin_unlock_irq(&amp;cc-&gt;write_thread_wait.lock);</span>
<span class="p_add">+	if (cc-&gt;write_thread)</span>
 		kthread_stop(cc-&gt;write_thread);
<span class="p_del">-	}</span>
 
 	if (cc-&gt;io_queue)
 		destroy_workqueue(cc-&gt;io_queue);
<span class="p_header">diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c</span>
<span class="p_header">index ac734e5bbe48..15db5e9c572e 100644</span>
<span class="p_header">--- a/drivers/md/dm-mpath.c</span>
<span class="p_header">+++ b/drivers/md/dm-mpath.c</span>
<span class="p_chunk">@@ -1521,10 +1521,10 @@</span> <span class="p_context"> static void activate_path(struct work_struct *work)</span>
 {
 	struct pgpath *pgpath =
 		container_of(work, struct pgpath, activate_path.work);
<span class="p_add">+	struct request_queue *q = bdev_get_queue(pgpath-&gt;path.dev-&gt;bdev);</span>
 
<span class="p_del">-	if (pgpath-&gt;is_active)</span>
<span class="p_del">-		scsi_dh_activate(bdev_get_queue(pgpath-&gt;path.dev-&gt;bdev),</span>
<span class="p_del">-				 pg_init_done, pgpath);</span>
<span class="p_add">+	if (pgpath-&gt;is_active &amp;&amp; !blk_queue_dying(q))</span>
<span class="p_add">+		scsi_dh_activate(q, pg_init_done, pgpath);</span>
 	else
 		pg_init_done(pgpath, SCSI_DH_DEV_OFFLINED);
 }
<span class="p_header">diff --git a/drivers/md/dm-rq.c b/drivers/md/dm-rq.c</span>
<span class="p_header">index 1ca7463e8bb2..5da86c8b6545 100644</span>
<span class="p_header">--- a/drivers/md/dm-rq.c</span>
<span class="p_header">+++ b/drivers/md/dm-rq.c</span>
<span class="p_chunk">@@ -73,15 +73,24 @@</span> <span class="p_context"> static void dm_old_start_queue(struct request_queue *q)</span>
 	spin_unlock_irqrestore(q-&gt;queue_lock, flags);
 }
 
<span class="p_add">+static void dm_mq_start_queue(struct request_queue *q)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(q-&gt;queue_lock, flags);</span>
<span class="p_add">+	queue_flag_clear(QUEUE_FLAG_STOPPED, q);</span>
<span class="p_add">+	spin_unlock_irqrestore(q-&gt;queue_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	blk_mq_start_stopped_hw_queues(q, true);</span>
<span class="p_add">+	blk_mq_kick_requeue_list(q);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void dm_start_queue(struct request_queue *q)
 {
 	if (!q-&gt;mq_ops)
 		dm_old_start_queue(q);
<span class="p_del">-	else {</span>
<span class="p_del">-		queue_flag_clear_unlocked(QUEUE_FLAG_STOPPED, q);</span>
<span class="p_del">-		blk_mq_start_stopped_hw_queues(q, true);</span>
<span class="p_del">-		blk_mq_kick_requeue_list(q);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dm_mq_start_queue(q);</span>
 }
 
 static void dm_old_stop_queue(struct request_queue *q)
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index fa9b1cb4438a..0f2928b3136b 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1873,6 +1873,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(dm_device_name);</span>
 
 static void __dm_destroy(struct mapped_device *md, bool wait)
 {
<span class="p_add">+	struct request_queue *q = dm_get_md_queue(md);</span>
 	struct dm_table *map;
 	int srcu_idx;
 
<span class="p_chunk">@@ -1883,6 +1884,10 @@</span> <span class="p_context"> static void __dm_destroy(struct mapped_device *md, bool wait)</span>
 	set_bit(DMF_FREEING, &amp;md-&gt;flags);
 	spin_unlock(&amp;_minor_lock);
 
<span class="p_add">+	spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+	queue_flag_set(QUEUE_FLAG_DYING, q);</span>
<span class="p_add">+	spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+</span>
 	if (dm_request_based(md) &amp;&amp; md-&gt;kworker_task)
 		flush_kthread_worker(&amp;md-&gt;kworker);
 
<span class="p_chunk">@@ -2249,10 +2254,11 @@</span> <span class="p_context"> static int __dm_resume(struct mapped_device *md, struct dm_table *map)</span>
 
 int dm_resume(struct mapped_device *md)
 {
<span class="p_del">-	int r = -EINVAL;</span>
<span class="p_add">+	int r;</span>
 	struct dm_table *map = NULL;
 
 retry:
<span class="p_add">+	r = -EINVAL;</span>
 	mutex_lock_nested(&amp;md-&gt;suspend_lock, SINGLE_DEPTH_NESTING);
 
 	if (!dm_suspended_md(md))
<span class="p_chunk">@@ -2276,8 +2282,6 @@</span> <span class="p_context"> retry:</span>
 		goto out;
 
 	clear_bit(DMF_SUSPENDED, &amp;md-&gt;flags);
<span class="p_del">-</span>
<span class="p_del">-	r = 0;</span>
 out:
 	mutex_unlock(&amp;md-&gt;suspend_lock);
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/mb86a20s.c b/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_header">index 41325328a22e..fe79358b035e 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_chunk">@@ -71,25 +71,27 @@</span> <span class="p_context"> static struct regdata mb86a20s_init1[] = {</span>
 };
 
 static struct regdata mb86a20s_init2[] = {
<span class="p_del">-	{ 0x28, 0x22 }, { 0x29, 0x00 }, { 0x2a, 0x1f }, { 0x2b, 0xf0 },</span>
<span class="p_add">+	{ 0x50, 0xd1 }, { 0x51, 0x22 },</span>
<span class="p_add">+	{ 0x39, 0x01 },</span>
<span class="p_add">+	{ 0x71, 0x00 },</span>
 	{ 0x3b, 0x21 },
<span class="p_del">-	{ 0x3c, 0x38 },</span>
<span class="p_add">+	{ 0x3c, 0x3a },</span>
 	{ 0x01, 0x0d },
<span class="p_del">-	{ 0x04, 0x08 }, { 0x05, 0x03 },</span>
<span class="p_add">+	{ 0x04, 0x08 }, { 0x05, 0x05 },</span>
 	{ 0x04, 0x0e }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x0f }, { 0x05, 0x37 },</span>
<span class="p_del">-	{ 0x04, 0x0b }, { 0x05, 0x78 },</span>
<span class="p_add">+	{ 0x04, 0x0f }, { 0x05, 0x14 },</span>
<span class="p_add">+	{ 0x04, 0x0b }, { 0x05, 0x8c },</span>
 	{ 0x04, 0x00 }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x01 }, { 0x05, 0x1e },</span>
<span class="p_del">-	{ 0x04, 0x02 }, { 0x05, 0x07 },</span>
<span class="p_del">-	{ 0x04, 0x03 }, { 0x05, 0xd0 },</span>
<span class="p_add">+	{ 0x04, 0x01 }, { 0x05, 0x07 },</span>
<span class="p_add">+	{ 0x04, 0x02 }, { 0x05, 0x0f },</span>
<span class="p_add">+	{ 0x04, 0x03 }, { 0x05, 0xa0 },</span>
 	{ 0x04, 0x09 }, { 0x05, 0x00 },
 	{ 0x04, 0x0a }, { 0x05, 0xff },
<span class="p_del">-	{ 0x04, 0x27 }, { 0x05, 0x00 },</span>
<span class="p_add">+	{ 0x04, 0x27 }, { 0x05, 0x64 },</span>
 	{ 0x04, 0x28 }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x1e }, { 0x05, 0x00 },</span>
<span class="p_del">-	{ 0x04, 0x29 }, { 0x05, 0x64 },</span>
<span class="p_del">-	{ 0x04, 0x32 }, { 0x05, 0x02 },</span>
<span class="p_add">+	{ 0x04, 0x1e }, { 0x05, 0xff },</span>
<span class="p_add">+	{ 0x04, 0x29 }, { 0x05, 0x0a },</span>
<span class="p_add">+	{ 0x04, 0x32 }, { 0x05, 0x0a },</span>
 	{ 0x04, 0x14 }, { 0x05, 0x02 },
 	{ 0x04, 0x04 }, { 0x05, 0x00 },
 	{ 0x04, 0x05 }, { 0x05, 0x22 },
<span class="p_chunk">@@ -97,8 +99,6 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x04, 0x07 }, { 0x05, 0xd8 },
 	{ 0x04, 0x12 }, { 0x05, 0x00 },
 	{ 0x04, 0x13 }, { 0x05, 0xff },
<span class="p_del">-	{ 0x04, 0x15 }, { 0x05, 0x4e },</span>
<span class="p_del">-	{ 0x04, 0x16 }, { 0x05, 0x20 },</span>
 
 	/*
 	 * On this demod, when the bit count reaches the count below,
<span class="p_chunk">@@ -152,42 +152,36 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x50, 0x51 }, { 0x51, 0x04 },		/* MER symbol 4 */
 	{ 0x45, 0x04 },				/* CN symbol 4 */
 	{ 0x48, 0x04 },				/* CN manual mode */
<span class="p_del">-</span>
<span class="p_add">+	{ 0x50, 0xd5 }, { 0x51, 0x01 },</span>
 	{ 0x50, 0xd6 }, { 0x51, 0x1f },
 	{ 0x50, 0xd2 }, { 0x51, 0x03 },
<span class="p_del">-	{ 0x50, 0xd7 }, { 0x51, 0xbf },</span>
<span class="p_del">-	{ 0x28, 0x74 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0xff },</span>
<span class="p_del">-	{ 0x28, 0x46 }, { 0x29, 0x00 }, { 0x2a, 0x1a }, { 0x2b, 0x0c },</span>
<span class="p_del">-</span>
<span class="p_del">-	{ 0x04, 0x40 }, { 0x05, 0x00 },</span>
<span class="p_del">-	{ 0x28, 0x00 }, { 0x2b, 0x08 },</span>
<span class="p_del">-	{ 0x28, 0x05 }, { 0x2b, 0x00 },</span>
<span class="p_add">+	{ 0x50, 0xd7 }, { 0x51, 0x3f },</span>
 	{ 0x1c, 0x01 },
<span class="p_del">-	{ 0x28, 0x06 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x1f },</span>
<span class="p_del">-	{ 0x28, 0x07 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x18 },</span>
<span class="p_del">-	{ 0x28, 0x08 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x12 },</span>
<span class="p_del">-	{ 0x28, 0x09 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x30 },</span>
<span class="p_del">-	{ 0x28, 0x0a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x37 },</span>
<span class="p_del">-	{ 0x28, 0x0b }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x02 },</span>
<span class="p_del">-	{ 0x28, 0x0c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x09 },</span>
<span class="p_del">-	{ 0x28, 0x0d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x06 },</span>
<span class="p_del">-	{ 0x28, 0x0e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x7b },</span>
<span class="p_del">-	{ 0x28, 0x0f }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x76 },</span>
<span class="p_del">-	{ 0x28, 0x10 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x7d },</span>
<span class="p_del">-	{ 0x28, 0x11 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x08 },</span>
<span class="p_del">-	{ 0x28, 0x12 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0b },</span>
<span class="p_del">-	{ 0x28, 0x13 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x00 },</span>
<span class="p_del">-	{ 0x28, 0x14 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xf2 },</span>
<span class="p_del">-	{ 0x28, 0x15 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xf3 },</span>
<span class="p_del">-	{ 0x28, 0x16 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x05 },</span>
<span class="p_del">-	{ 0x28, 0x17 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x16 },</span>
<span class="p_del">-	{ 0x28, 0x18 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0f },</span>
<span class="p_del">-	{ 0x28, 0x19 }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xef },</span>
<span class="p_del">-	{ 0x28, 0x1a }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xd8 },</span>
<span class="p_del">-	{ 0x28, 0x1b }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xf1 },</span>
<span class="p_del">-	{ 0x28, 0x1c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x3d },</span>
<span class="p_del">-	{ 0x28, 0x1d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x94 },</span>
<span class="p_del">-	{ 0x28, 0x1e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0xba },</span>
<span class="p_add">+	{ 0x28, 0x06 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x03 },</span>
<span class="p_add">+	{ 0x28, 0x07 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0d },</span>
<span class="p_add">+	{ 0x28, 0x08 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x02 },</span>
<span class="p_add">+	{ 0x28, 0x09 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x01 },</span>
<span class="p_add">+	{ 0x28, 0x0a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x21 },</span>
<span class="p_add">+	{ 0x28, 0x0b }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x29 },</span>
<span class="p_add">+	{ 0x28, 0x0c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x16 },</span>
<span class="p_add">+	{ 0x28, 0x0d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x31 },</span>
<span class="p_add">+	{ 0x28, 0x0e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0e },</span>
<span class="p_add">+	{ 0x28, 0x0f }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x4e },</span>
<span class="p_add">+	{ 0x28, 0x10 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x46 },</span>
<span class="p_add">+	{ 0x28, 0x11 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0f },</span>
<span class="p_add">+	{ 0x28, 0x12 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x56 },</span>
<span class="p_add">+	{ 0x28, 0x13 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x35 },</span>
<span class="p_add">+	{ 0x28, 0x14 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbe },</span>
<span class="p_add">+	{ 0x28, 0x15 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0x84 },</span>
<span class="p_add">+	{ 0x28, 0x16 }, { 0x29, 0x00 }, { 0x2a, 0x03 }, { 0x2b, 0xee },</span>
<span class="p_add">+	{ 0x28, 0x17 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x98 },</span>
<span class="p_add">+	{ 0x28, 0x18 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x9f },</span>
<span class="p_add">+	{ 0x28, 0x19 }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xb2 },</span>
<span class="p_add">+	{ 0x28, 0x1a }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0xc2 },</span>
<span class="p_add">+	{ 0x28, 0x1b }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0x4a },</span>
<span class="p_add">+	{ 0x28, 0x1c }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbc },</span>
<span class="p_add">+	{ 0x28, 0x1d }, { 0x29, 0x00 }, { 0x2a, 0x04 }, { 0x2b, 0xba },</span>
<span class="p_add">+	{ 0x28, 0x1e }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0x14 },</span>
 	{ 0x50, 0x1e }, { 0x51, 0x5d },
 	{ 0x50, 0x22 }, { 0x51, 0x00 },
 	{ 0x50, 0x23 }, { 0x51, 0xc8 },
<span class="p_chunk">@@ -196,9 +190,7 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x50, 0x26 }, { 0x51, 0x00 },
 	{ 0x50, 0x27 }, { 0x51, 0xc3 },
 	{ 0x50, 0x39 }, { 0x51, 0x02 },
<span class="p_del">-	{ 0xec, 0x0f },</span>
<span class="p_del">-	{ 0xeb, 0x1f },</span>
<span class="p_del">-	{ 0x28, 0x6a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x00 },</span>
<span class="p_add">+	{ 0x50, 0xd5 }, { 0x51, 0x01 },</span>
 	{ 0xd0, 0x00 },
 };
 
<span class="p_chunk">@@ -318,7 +310,11 @@</span> <span class="p_context"> static int mb86a20s_read_status(struct dvb_frontend *fe, enum fe_status *status)</span>
 	if (val &gt;= 7)
 		*status |= FE_HAS_SYNC;
 
<span class="p_del">-	if (val &gt;= 8)				/* Maybe 9? */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Actually, on state S8, it starts receiving TS, but the TS</span>
<span class="p_add">+	 * output is only on normal state after the transition to S9.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (val &gt;= 9)</span>
 		*status |= FE_HAS_LOCK;
 
 	dev_dbg(&amp;state-&gt;i2c-&gt;dev, &quot;%s: Status = 0x%02x (state = %d)\n&quot;,
<span class="p_chunk">@@ -2058,6 +2054,11 @@</span> <span class="p_context"> static void mb86a20s_release(struct dvb_frontend *fe)</span>
 	kfree(state);
 }
 
<span class="p_add">+static int mb86a20s_get_frontend_algo(struct dvb_frontend *fe)</span>
<span class="p_add">+{</span>
<span class="p_add">+        return DVBFE_ALGO_HW;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct dvb_frontend_ops mb86a20s_ops;
 
 struct dvb_frontend *mb86a20s_attach(const struct mb86a20s_config *config,
<span class="p_chunk">@@ -2130,6 +2131,7 @@</span> <span class="p_context"> static struct dvb_frontend_ops mb86a20s_ops = {</span>
 	.read_status = mb86a20s_read_status_and_stats,
 	.read_signal_strength = mb86a20s_read_signal_strength_from_cache,
 	.tune = mb86a20s_tune,
<span class="p_add">+	.get_frontend_algo = mb86a20s_get_frontend_algo,</span>
 };
 
 MODULE_DESCRIPTION(&quot;DVB Frontend module for Fujitsu mb86A20s hardware&quot;);
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-avcore.c b/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_header">index 491913778bcc..2f52d66b4dae 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_chunk">@@ -1264,7 +1264,10 @@</span> <span class="p_context"> int cx231xx_set_agc_analog_digital_mux_select(struct cx231xx *dev,</span>
 				   dev-&gt;board.agc_analog_digital_select_gpio,
 				   analog_or_digital);
 
<span class="p_del">-	return status;</span>
<span class="p_add">+	if (status &lt; 0)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 int cx231xx_enable_i2c_port_3(struct cx231xx *dev, bool is_port_3)
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-cards.c b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">index c63248a18823..72c246bfaa1c 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_chunk">@@ -486,7 +486,7 @@</span> <span class="p_context"> struct cx231xx_board cx231xx_boards[] = {</span>
 		.output_mode = OUT_MODE_VIP11,
 		.demod_xfer_mode = 0,
 		.ctl_pin_status_mask = 0xFFFFFFC4,
<span class="p_del">-		.agc_analog_digital_select_gpio = 0x00,	/* According with PV cxPolaris.inf file */</span>
<span class="p_add">+		.agc_analog_digital_select_gpio = 0x1c,</span>
 		.tuner_sif_gpio = -1,
 		.tuner_scl_gpio = -1,
 		.tuner_sda_gpio = -1,
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-core.c b/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_header">index 630f4fc5155f..ea9a99e41581 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_chunk">@@ -712,6 +712,7 @@</span> <span class="p_context"> int cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)</span>
 			break;
 		case CX231XX_BOARD_CNXT_RDE_253S:
 		case CX231XX_BOARD_CNXT_RDU_253S:
<span class="p_add">+		case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:</span>
 			errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);
 			break;
 		case CX231XX_BOARD_HAUPPAUGE_EXETER:
<span class="p_chunk">@@ -738,7 +739,7 @@</span> <span class="p_context"> int cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)</span>
 		case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:
<span class="p_del">-		errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);</span>
<span class="p_add">+			errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);</span>
 			break;
 		default:
 			break;
<span class="p_chunk">@@ -1301,15 +1302,29 @@</span> <span class="p_context"> int cx231xx_dev_init(struct cx231xx *dev)</span>
 	dev-&gt;i2c_bus[2].i2c_reserve = 0;
 
 	/* register I2C buses */
<span class="p_del">-	cx231xx_i2c_register(&amp;dev-&gt;i2c_bus[0]);</span>
<span class="p_del">-	cx231xx_i2c_register(&amp;dev-&gt;i2c_bus[1]);</span>
<span class="p_del">-	cx231xx_i2c_register(&amp;dev-&gt;i2c_bus[2]);</span>
<span class="p_add">+	errCode = cx231xx_i2c_register(&amp;dev-&gt;i2c_bus[0]);</span>
<span class="p_add">+	if (errCode &lt; 0)</span>
<span class="p_add">+		return errCode;</span>
<span class="p_add">+	errCode = cx231xx_i2c_register(&amp;dev-&gt;i2c_bus[1]);</span>
<span class="p_add">+	if (errCode &lt; 0)</span>
<span class="p_add">+		return errCode;</span>
<span class="p_add">+	errCode = cx231xx_i2c_register(&amp;dev-&gt;i2c_bus[2]);</span>
<span class="p_add">+	if (errCode &lt; 0)</span>
<span class="p_add">+		return errCode;</span>
 
 	errCode = cx231xx_i2c_mux_create(dev);
<span class="p_add">+	if (errCode &lt; 0) {</span>
<span class="p_add">+		dev_err(dev-&gt;dev,</span>
<span class="p_add">+			&quot;%s: Failed to create I2C mux\n&quot;, __func__);</span>
<span class="p_add">+		return errCode;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	errCode = cx231xx_i2c_mux_register(dev, 0);</span>
<span class="p_add">+	if (errCode &lt; 0)</span>
<span class="p_add">+		return errCode;</span>
<span class="p_add">+</span>
<span class="p_add">+	errCode = cx231xx_i2c_mux_register(dev, 1);</span>
 	if (errCode &lt; 0)
 		return errCode;
<span class="p_del">-	cx231xx_i2c_mux_register(dev, 0);</span>
<span class="p_del">-	cx231xx_i2c_mux_register(dev, 1);</span>
 
 	/* scan the real bus segments in the order of physical port numbers */
 	cx231xx_do_i2c_scan(dev, I2C_0);
<span class="p_header">diff --git a/drivers/memstick/host/rtsx_usb_ms.c b/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_header">index d34bc3530385..2e3cf012ef48 100644</span>
<span class="p_header">--- a/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_header">+++ b/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_chunk">@@ -524,6 +524,7 @@</span> <span class="p_context"> static void rtsx_usb_ms_handle_req(struct work_struct *work)</span>
 	int rc;
 
 	if (!host-&gt;req) {
<span class="p_add">+		pm_runtime_get_sync(ms_dev(host));</span>
 		do {
 			rc = memstick_next_req(msh, &amp;host-&gt;req);
 			dev_dbg(ms_dev(host), &quot;next req %d\n&quot;, rc);
<span class="p_chunk">@@ -544,6 +545,7 @@</span> <span class="p_context"> static void rtsx_usb_ms_handle_req(struct work_struct *work)</span>
 						host-&gt;req-&gt;error);
 			}
 		} while (!rc);
<span class="p_add">+		pm_runtime_put(ms_dev(host));</span>
 	}
 
 }
<span class="p_chunk">@@ -570,6 +572,7 @@</span> <span class="p_context"> static int rtsx_usb_ms_set_param(struct memstick_host *msh,</span>
 	dev_dbg(ms_dev(host), &quot;%s: param = %d, value = %d\n&quot;,
 			__func__, param, value);
 
<span class="p_add">+	pm_runtime_get_sync(ms_dev(host));</span>
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 	err = rtsx_usb_card_exclusive_check(ucr, RTSX_USB_MS_CARD);
<span class="p_chunk">@@ -635,6 +638,7 @@</span> <span class="p_context"> static int rtsx_usb_ms_set_param(struct memstick_host *msh,</span>
 	}
 out:
 	mutex_unlock(&amp;ucr-&gt;dev_mutex);
<span class="p_add">+	pm_runtime_put(ms_dev(host));</span>
 
 	/* power-on delay */
 	if (param == MEMSTICK_POWER &amp;&amp; value == MEMSTICK_POWER_ON)
<span class="p_chunk">@@ -681,6 +685,7 @@</span> <span class="p_context"> static int rtsx_usb_detect_ms_card(void *__host)</span>
 	int err;
 
 	for (;;) {
<span class="p_add">+		pm_runtime_get_sync(ms_dev(host));</span>
 		mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 		/* Check pending MS card changes */
<span class="p_chunk">@@ -703,6 +708,7 @@</span> <span class="p_context"> static int rtsx_usb_detect_ms_card(void *__host)</span>
 		}
 
 poll_again:
<span class="p_add">+		pm_runtime_put(ms_dev(host));</span>
 		if (host-&gt;eject)
 			break;
 
<span class="p_header">diff --git a/drivers/misc/cxl/api.c b/drivers/misc/cxl/api.c</span>
<span class="p_header">index f3d34b941f85..af23d7dfe752 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/api.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/api.c</span>
<span class="p_chunk">@@ -229,6 +229,14 @@</span> <span class="p_context"> int cxl_start_context(struct cxl_context *ctx, u64 wed,</span>
 	if (ctx-&gt;status == STARTED)
 		goto out; /* already started */
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment the mapped context count for adapter. This also checks</span>
<span class="p_add">+	 * if adapter_context_lock is taken.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = cxl_adapter_context_get(ctx-&gt;afu-&gt;adapter);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (task) {
 		ctx-&gt;pid = get_task_pid(task, PIDTYPE_PID);
 		ctx-&gt;glpid = get_task_pid(task-&gt;group_leader, PIDTYPE_PID);
<span class="p_chunk">@@ -240,6 +248,7 @@</span> <span class="p_context"> int cxl_start_context(struct cxl_context *ctx, u64 wed,</span>
 
 	if ((rc = cxl_ops-&gt;attach_process(ctx, kernel, wed, 0))) {
 		put_pid(ctx-&gt;pid);
<span class="p_add">+		cxl_adapter_context_put(ctx-&gt;afu-&gt;adapter);</span>
 		cxl_ctx_put();
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/misc/cxl/context.c b/drivers/misc/cxl/context.c</span>
<span class="p_header">index c466ee2b0c97..5e506c19108a 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/context.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/context.c</span>
<span class="p_chunk">@@ -238,6 +238,9 @@</span> <span class="p_context"> int __detach_context(struct cxl_context *ctx)</span>
 	put_pid(ctx-&gt;glpid);
 
 	cxl_ctx_put();
<span class="p_add">+</span>
<span class="p_add">+	/* Decrease the attached context count on the adapter */</span>
<span class="p_add">+	cxl_adapter_context_put(ctx-&gt;afu-&gt;adapter);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/misc/cxl/cxl.h b/drivers/misc/cxl/cxl.h</span>
<span class="p_header">index 344a0ff8f8c7..19aa2aca9683 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/cxl.h</span>
<span class="p_header">+++ b/drivers/misc/cxl/cxl.h</span>
<span class="p_chunk">@@ -615,6 +615,14 @@</span> <span class="p_context"> struct cxl {</span>
 	bool perst_select_user;
 	bool perst_same_image;
 	bool psl_timebase_synced;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * number of contexts mapped on to this card. Possible values are:</span>
<span class="p_add">+	 * &gt;0: Number of contexts mapped and new one can be mapped.</span>
<span class="p_add">+	 *  0: No active contexts and new ones can be mapped.</span>
<span class="p_add">+	 * -1: No contexts mapped and new ones cannot be mapped.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	atomic_t contexts_num;</span>
 };
 
 int cxl_pci_alloc_one_irq(struct cxl *adapter);
<span class="p_chunk">@@ -940,4 +948,20 @@</span> <span class="p_context"> bool cxl_pci_is_vphb_device(struct pci_dev *dev);</span>
 
 /* decode AFU error bits in the PSL register PSL_SERR_An */
 void cxl_afu_decode_psl_serr(struct cxl_afu *afu, u64 serr);
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Increments the number of attached contexts on an adapter.</span>
<span class="p_add">+ * In case an adapter_context_lock is taken the return -EBUSY.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int cxl_adapter_context_get(struct cxl *adapter);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Decrements the number of attached contexts on an adapter */</span>
<span class="p_add">+void cxl_adapter_context_put(struct cxl *adapter);</span>
<span class="p_add">+</span>
<span class="p_add">+/* If no active contexts then prevents contexts from being attached */</span>
<span class="p_add">+int cxl_adapter_context_lock(struct cxl *adapter);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Unlock the contexts-lock if taken. Warn and force unlock otherwise */</span>
<span class="p_add">+void cxl_adapter_context_unlock(struct cxl *adapter);</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/drivers/misc/cxl/file.c b/drivers/misc/cxl/file.c</span>
<span class="p_header">index 5fb9894b157f..d0b421f49b39 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/file.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/file.c</span>
<span class="p_chunk">@@ -205,11 +205,22 @@</span> <span class="p_context"> static long afu_ioctl_start_work(struct cxl_context *ctx,</span>
 	ctx-&gt;pid = get_task_pid(current, PIDTYPE_PID);
 	ctx-&gt;glpid = get_task_pid(current-&gt;group_leader, PIDTYPE_PID);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment the mapped context count for adapter. This also checks</span>
<span class="p_add">+	 * if adapter_context_lock is taken.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = cxl_adapter_context_get(ctx-&gt;afu-&gt;adapter);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		afu_release_irqs(ctx, ctx);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	trace_cxl_attach(ctx, work.work_element_descriptor, work.num_interrupts, amr);
 
 	if ((rc = cxl_ops-&gt;attach_process(ctx, false, work.work_element_descriptor,
 							amr))) {
 		afu_release_irqs(ctx, ctx);
<span class="p_add">+		cxl_adapter_context_put(ctx-&gt;afu-&gt;adapter);</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/drivers/misc/cxl/guest.c b/drivers/misc/cxl/guest.c</span>
<span class="p_header">index 9aa58a77a24d..3e102cd6ed91 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/guest.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/guest.c</span>
<span class="p_chunk">@@ -1152,6 +1152,9 @@</span> <span class="p_context"> struct cxl *cxl_guest_init_adapter(struct device_node *np, struct platform_devic</span>
 	if ((rc = cxl_sysfs_adapter_add(adapter)))
 		goto err_put1;
 
<span class="p_add">+	/* release the context lock as the adapter is configured */</span>
<span class="p_add">+	cxl_adapter_context_unlock(adapter);</span>
<span class="p_add">+</span>
 	return adapter;
 
 err_put1:
<span class="p_header">diff --git a/drivers/misc/cxl/main.c b/drivers/misc/cxl/main.c</span>
<span class="p_header">index d9be23b24aa3..62e0dfb5f15b 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/main.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/main.c</span>
<span class="p_chunk">@@ -243,8 +243,10 @@</span> <span class="p_context"> struct cxl *cxl_alloc_adapter(void)</span>
 	if (dev_set_name(&amp;adapter-&gt;dev, &quot;card%i&quot;, adapter-&gt;adapter_num))
 		goto err2;
 
<span class="p_del">-	return adapter;</span>
<span class="p_add">+	/* start with context lock taken */</span>
<span class="p_add">+	atomic_set(&amp;adapter-&gt;contexts_num, -1);</span>
 
<span class="p_add">+	return adapter;</span>
 err2:
 	cxl_remove_adapter_nr(adapter);
 err1:
<span class="p_chunk">@@ -286,6 +288,44 @@</span> <span class="p_context"> int cxl_afu_select_best_mode(struct cxl_afu *afu)</span>
 	return 0;
 }
 
<span class="p_add">+int cxl_adapter_context_get(struct cxl *adapter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = atomic_inc_unless_negative(&amp;adapter-&gt;contexts_num);</span>
<span class="p_add">+	return rc &gt;= 0 ? 0 : -EBUSY;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void cxl_adapter_context_put(struct cxl *adapter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_dec_if_positive(&amp;adapter-&gt;contexts_num);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int cxl_adapter_context_lock(struct cxl *adapter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+	/* no active contexts -&gt; contexts_num == 0 */</span>
<span class="p_add">+	rc = atomic_cmpxchg(&amp;adapter-&gt;contexts_num, 0, -1);</span>
<span class="p_add">+	return rc ? -EBUSY : 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void cxl_adapter_context_unlock(struct cxl *adapter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int val = atomic_cmpxchg(&amp;adapter-&gt;contexts_num, -1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * contexts lock taken -&gt; contexts_num == -1</span>
<span class="p_add">+	 * If not true then show a warning and force reset the lock.</span>
<span class="p_add">+	 * This will happen when context_unlock was requested without</span>
<span class="p_add">+	 * doing a context_lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (val != -1) {</span>
<span class="p_add">+		atomic_set(&amp;adapter-&gt;contexts_num, 0);</span>
<span class="p_add">+		WARN(1, &quot;Adapter context unlocked with %d active contexts&quot;,</span>
<span class="p_add">+		     val);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init init_cxl(void)
 {
 	int rc = 0;
<span class="p_header">diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c</span>
<span class="p_header">index 6f0c4ac4b649..8ad4e4f6ff77 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/pci.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/pci.c</span>
<span class="p_chunk">@@ -1484,6 +1484,8 @@</span> <span class="p_context"> static int cxl_configure_adapter(struct cxl *adapter, struct pci_dev *dev)</span>
 	if ((rc = cxl_native_register_psl_err_irq(adapter)))
 		goto err;
 
<span class="p_add">+	/* Release the context lock as adapter is configured */</span>
<span class="p_add">+	cxl_adapter_context_unlock(adapter);</span>
 	return 0;
 
 err:
<span class="p_header">diff --git a/drivers/misc/cxl/sysfs.c b/drivers/misc/cxl/sysfs.c</span>
<span class="p_header">index b043c20f158f..a8b6d6a635e9 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/sysfs.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/sysfs.c</span>
<span class="p_chunk">@@ -75,12 +75,31 @@</span> <span class="p_context"> static ssize_t reset_adapter_store(struct device *device,</span>
 	int val;
 
 	rc = sscanf(buf, &quot;%i&quot;, &amp;val);
<span class="p_del">-	if ((rc != 1) || (val != 1))</span>
<span class="p_add">+	if ((rc != 1) || (val != 1 &amp;&amp; val != -1))</span>
 		return -EINVAL;
 
<span class="p_del">-	if ((rc = cxl_ops-&gt;adapter_reset(adapter)))</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-	return count;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * See if we can lock the context mapping that&#39;s only allowed</span>
<span class="p_add">+	 * when there are no contexts attached to the adapter. Once</span>
<span class="p_add">+	 * taken this will also prevent any context from getting activated.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (val == 1) {</span>
<span class="p_add">+		rc =  cxl_adapter_context_lock(adapter);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = cxl_ops-&gt;adapter_reset(adapter);</span>
<span class="p_add">+		/* In case reset failed release context lock */</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			cxl_adapter_context_unlock(adapter);</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (val == -1) {</span>
<span class="p_add">+		/* Perform a forced adapter reset */</span>
<span class="p_add">+		rc = cxl_ops-&gt;adapter_reset(adapter);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return rc ? rc : count;</span>
 }
 
 static ssize_t load_image_on_perst_show(struct device *device,
<span class="p_header">diff --git a/drivers/misc/mei/amthif.c b/drivers/misc/mei/amthif.c</span>
<span class="p_header">index fd9271bc1a11..cd01e342bc78 100644</span>
<span class="p_header">--- a/drivers/misc/mei/amthif.c</span>
<span class="p_header">+++ b/drivers/misc/mei/amthif.c</span>
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> int mei_amthif_read(struct mei_device *dev, struct file *file,</span>
 			return -ERESTARTSYS;
 
 		if (!mei_cl_is_connected(cl)) {
<span class="p_del">-			rets = -EBUSY;</span>
<span class="p_add">+			rets = -ENODEV;</span>
 			goto out;
 		}
 
<span class="p_header">diff --git a/drivers/misc/mei/bus.c b/drivers/misc/mei/bus.c</span>
<span class="p_header">index e094df3cf2d5..5b5b2e07e99e 100644</span>
<span class="p_header">--- a/drivers/misc/mei/bus.c</span>
<span class="p_header">+++ b/drivers/misc/mei/bus.c</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> ssize_t __mei_cl_recv(struct mei_cl *cl, u8 *buf, size_t length)</span>
 		mutex_lock(&amp;bus-&gt;device_lock);
 
 		if (!mei_cl_is_connected(cl)) {
<span class="p_del">-			rets = -EBUSY;</span>
<span class="p_add">+			rets = -ENODEV;</span>
 			goto out;
 		}
 	}
<span class="p_header">diff --git a/drivers/misc/mei/hw-me-regs.h b/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_header">index 0dcb854b4bfc..7ad15d678878 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-me-regs.h</span>
<span class="p_chunk">@@ -125,6 +125,9 @@</span> <span class="p_context"></span>
 #define MEI_DEV_ID_BXT_M      0x1A9A  /* Broxton M */
 #define MEI_DEV_ID_APL_I      0x5A9A  /* Apollo Lake I */
 
<span class="p_add">+#define MEI_DEV_ID_KBP        0xA2BA  /* Kaby Point */</span>
<span class="p_add">+#define MEI_DEV_ID_KBP_2      0xA2BB  /* Kaby Point 2 */</span>
<span class="p_add">+</span>
 /*
  * MEI HW Section
  */
<span class="p_header">diff --git a/drivers/misc/mei/main.c b/drivers/misc/mei/main.c</span>
<span class="p_header">index 52635b063873..080208dc5516 100644</span>
<span class="p_header">--- a/drivers/misc/mei/main.c</span>
<span class="p_header">+++ b/drivers/misc/mei/main.c</span>
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static ssize_t mei_read(struct file *file, char __user *ubuf,</span>
 
 		mutex_lock(&amp;dev-&gt;device_lock);
 		if (!mei_cl_is_connected(cl)) {
<span class="p_del">-			rets = -EBUSY;</span>
<span class="p_add">+			rets = -ENODEV;</span>
 			goto out;
 		}
 	}
<span class="p_header">diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c</span>
<span class="p_header">index 71cea9b296b2..5eb9b75ae9ec 100644</span>
<span class="p_header">--- a/drivers/misc/mei/pci-me.c</span>
<span class="p_header">+++ b/drivers/misc/mei/pci-me.c</span>
<span class="p_chunk">@@ -91,6 +91,9 @@</span> <span class="p_context"> static const struct pci_device_id mei_me_pci_tbl[] = {</span>
 	{MEI_PCI_DEVICE(MEI_DEV_ID_BXT_M, mei_me_pch8_cfg)},
 	{MEI_PCI_DEVICE(MEI_DEV_ID_APL_I, mei_me_pch8_cfg)},
 
<span class="p_add">+	{MEI_PCI_DEVICE(MEI_DEV_ID_KBP, mei_me_pch8_cfg)},</span>
<span class="p_add">+	{MEI_PCI_DEVICE(MEI_DEV_ID_KBP_2, mei_me_pch8_cfg)},</span>
<span class="p_add">+</span>
 	/* required last entry */
 	{0, }
 };
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 2206d4477dbb..17891f17f39d 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1778,7 +1778,7 @@</span> <span class="p_context"> static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,</span>
 	struct mmc_blk_data *md = mq-&gt;data;
 	struct mmc_packed *packed = mqrq-&gt;packed;
 	bool do_rel_wr, do_data_tag;
<span class="p_del">-	u32 *packed_cmd_hdr;</span>
<span class="p_add">+	__le32 *packed_cmd_hdr;</span>
 	u8 hdr_blocks;
 	u8 i = 1;
 
<span class="p_chunk">@@ -2303,7 +2303,8 @@</span> <span class="p_context"> again:</span>
 	set_capacity(md-&gt;disk, size);
 
 	if (mmc_host_cmd23(card-&gt;host)) {
<span class="p_del">-		if (mmc_card_mmc(card) ||</span>
<span class="p_add">+		if ((mmc_card_mmc(card) &amp;&amp;</span>
<span class="p_add">+		     card-&gt;csd.mmca_vsn &gt;= CSD_SPEC_VER_3) ||</span>
 		    (mmc_card_sd(card) &amp;&amp;
 		     card-&gt;scr.cmds &amp; SD_SCR_CMD23_SUPPORT))
 			md-&gt;flags |= MMC_BLK_CMD23;
<span class="p_header">diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h</span>
<span class="p_header">index fee5e1271465..7f16709a5bd5 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.h</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.h</span>
<span class="p_chunk">@@ -31,7 +31,7 @@</span> <span class="p_context"> enum mmc_packed_type {</span>
 
 struct mmc_packed {
 	struct list_head	list;
<span class="p_del">-	u32			cmd_hdr[1024];</span>
<span class="p_add">+	__le32			cmd_hdr[1024];</span>
 	unsigned int		blocks;
 	u8			nr_entries;
 	u8			retries;
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index f2d185cf8a8b..c57eb32dc075 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -1259,6 +1259,16 @@</span> <span class="p_context"> static int mmc_select_hs400es(struct mmc_card *card)</span>
 		goto out_err;
 	}
 
<span class="p_add">+	if (card-&gt;mmc_avail_type &amp; EXT_CSD_CARD_TYPE_HS400_1_2V)</span>
<span class="p_add">+		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_120);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err &amp;&amp; card-&gt;mmc_avail_type &amp; EXT_CSD_CARD_TYPE_HS400_1_8V)</span>
<span class="p_add">+		err = __mmc_set_signal_voltage(host, MMC_SIGNAL_VOLTAGE_180);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If fails try again during next card power cycle */</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+</span>
 	err = mmc_select_bus_width(card);
 	if (err &lt; 0)
 		goto out_err;
<span class="p_header">diff --git a/drivers/mmc/host/rtsx_usb_sdmmc.c b/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_header">index 6c71fc9f76c7..da9f71b8deb0 100644</span>
<span class="p_header">--- a/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_chunk">@@ -1138,11 +1138,6 @@</span> <span class="p_context"> static void sdmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 	dev_dbg(sdmmc_dev(host), &quot;%s\n&quot;, __func__);
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
<span class="p_del">-	if (rtsx_usb_card_exclusive_check(ucr, RTSX_USB_SD_CARD)) {</span>
<span class="p_del">-		mutex_unlock(&amp;ucr-&gt;dev_mutex);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	sd_set_power_mode(host, ios-&gt;power_mode);
 	sd_set_bus_width(host, ios-&gt;bus_width);
 	sd_set_timing(host, ios-&gt;timing, &amp;host-&gt;ddr_mode);
<span class="p_chunk">@@ -1314,6 +1309,7 @@</span> <span class="p_context"> static void rtsx_usb_update_led(struct work_struct *work)</span>
 		container_of(work, struct rtsx_usb_sdmmc, led_work);
 	struct rtsx_ucr *ucr = host-&gt;ucr;
 
<span class="p_add">+	pm_runtime_get_sync(sdmmc_dev(host));</span>
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 	if (host-&gt;led.brightness == LED_OFF)
<span class="p_chunk">@@ -1322,6 +1318,7 @@</span> <span class="p_context"> static void rtsx_usb_update_led(struct work_struct *work)</span>
 		rtsx_usb_turn_on_led(ucr);
 
 	mutex_unlock(&amp;ucr-&gt;dev_mutex);
<span class="p_add">+	pm_runtime_put(sdmmc_dev(host));</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index cd65d474afa2..a8a022a7358f 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -687,7 +687,7 @@</span> <span class="p_context"> static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd)</span>
 			 * host-&gt;clock is in Hz.  target_timeout is in us.
 			 * Hence, us = 1000000 * cycles / Hz.  Round up.
 			 */
<span class="p_del">-			val = 1000000 * data-&gt;timeout_clks;</span>
<span class="p_add">+			val = 1000000ULL * data-&gt;timeout_clks;</span>
 			if (do_div(val, host-&gt;clock))
 				target_timeout++;
 			target_timeout += val;
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index f4533266d7b2..b419c7cfd014 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -644,7 +644,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int shutdown)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, lnum = -1;</span>
<span class="p_add">+	int erase = 0, keep = 0, vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_chunk">@@ -780,6 +780,16 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 			       e1-&gt;pnum);
 			scrubbing = 1;
 			goto out_not_moved;
<span class="p_add">+		} else if (ubi-&gt;fast_attach &amp;&amp; err == UBI_IO_BAD_HDR_EBADMSG) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * While a full scan would detect interrupted erasures</span>
<span class="p_add">+			 * at attach time we can face them here when attached from</span>
<span class="p_add">+			 * Fastmap.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dbg_wl(&quot;PEB %d has ECC errors, maybe from an interrupted erasure&quot;,</span>
<span class="p_add">+			       e1-&gt;pnum);</span>
<span class="p_add">+			erase = 1;</span>
<span class="p_add">+			goto out_not_moved;</span>
 		}
 
 		ubi_err(ubi, &quot;error %d while reading VID header from PEB %d&quot;,
<span class="p_chunk">@@ -815,6 +825,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 			 * Target PEB had bit-flips or write error - torture it.
 			 */
 			torture = 1;
<span class="p_add">+			keep = 1;</span>
 			goto out_not_moved;
 		}
 
<span class="p_chunk">@@ -901,7 +912,7 @@</span> <span class="p_context"> out_not_moved:</span>
 		ubi-&gt;erroneous_peb_count += 1;
 	} else if (scrubbing)
 		wl_tree_add(e1, &amp;ubi-&gt;scrub);
<span class="p_del">-	else</span>
<span class="p_add">+	else if (keep)</span>
 		wl_tree_add(e1, &amp;ubi-&gt;used);
 	if (dst_leb_clean) {
 		wl_tree_add(e2, &amp;ubi-&gt;free);
<span class="p_chunk">@@ -922,6 +933,12 @@</span> <span class="p_context"> out_not_moved:</span>
 			goto out_ro;
 	}
 
<span class="p_add">+	if (erase) {</span>
<span class="p_add">+		err = do_sync_erase(ubi, e1, vol_id, lnum, 1);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_ro;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;ubi-&gt;move_mutex);
 	return 0;
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/ce.c b/drivers/net/wireless/ath/ath10k/ce.c</span>
<span class="p_header">index 9fb8d7472d18..da9998ea9271 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/ce.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/ce.c</span>
<span class="p_chunk">@@ -433,6 +433,13 @@</span> <span class="p_context"> void ath10k_ce_rx_update_write_idx(struct ath10k_ce_pipe *pipe, u32 nentries)</span>
 	unsigned int nentries_mask = dest_ring-&gt;nentries_mask;
 	unsigned int write_index = dest_ring-&gt;write_index;
 	u32 ctrl_addr = pipe-&gt;ctrl_addr;
<span class="p_add">+	u32 cur_write_idx = ath10k_ce_dest_ring_write_index_get(ar, ctrl_addr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prevent CE ring stuck issue that will occur when ring is full.</span>
<span class="p_add">+	 * Make sure that write index is 1 less than read index.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((cur_write_idx + nentries)  == dest_ring-&gt;sw_index)</span>
<span class="p_add">+		nentries -= 1;</span>
 
 	write_index = CE_RING_IDX_ADD(nentries_mask, write_index, nentries);
 	ath10k_ce_dest_ring_write_index_set(ar, ctrl_addr, write_index);
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/regd.c b/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_header">index 3524441fd516..6ee6bf8e7eaf 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_chunk">@@ -345,9 +345,9 @@</span> <span class="p_context"> static const struct ieee80211_regdomain *_rtl_regdomain_select(</span>
 		return &amp;rtl_regdom_no_midband;
 	case COUNTRY_CODE_IC:
 		return &amp;rtl_regdom_11;
<span class="p_del">-	case COUNTRY_CODE_ETSI:</span>
 	case COUNTRY_CODE_TELEC_NETGEAR:
 		return &amp;rtl_regdom_60_64;
<span class="p_add">+	case COUNTRY_CODE_ETSI:</span>
 	case COUNTRY_CODE_SPAIN:
 	case COUNTRY_CODE_FRANCE:
 	case COUNTRY_CODE_ISRAEL:
<span class="p_chunk">@@ -406,6 +406,8 @@</span> <span class="p_context"> static u8 channel_plan_to_country_code(u8 channelplan)</span>
 		return COUNTRY_CODE_WORLD_WIDE_13;
 	case 0x22:
 		return COUNTRY_CODE_IC;
<span class="p_add">+	case 0x25:</span>
<span class="p_add">+		return COUNTRY_CODE_ETSI;</span>
 	case 0x32:
 		return COUNTRY_CODE_TELEC_NETGEAR;
 	case 0x41:
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index 6de0757b11e4..84d650d892e7 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -856,7 +856,7 @@</span> <span class="p_context"> static int tegra_pcie_phy_disable(struct tegra_pcie *pcie)</span>
 	/* override IDDQ */
 	value = pads_readl(pcie, PADS_CTL);
 	value |= PADS_CTL_IDDQ_1L;
<span class="p_del">-	pads_writel(pcie, PADS_CTL, value);</span>
<span class="p_add">+	pads_writel(pcie, value, PADS_CTL);</span>
 
 	/* reset PLL */
 	value = pads_readl(pcie, soc-&gt;pads_pll_ctl);
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 44e0ff37480b..4bf1a88d7ba7 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3198,6 +3198,7 @@</span> <span class="p_context"> static void quirk_no_bus_reset(struct pci_dev *dev)</span>
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0033, quirk_no_bus_reset);</span>
 
 static void quirk_no_pm_reset(struct pci_dev *dev)
 {
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-baytrail.c b/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_header">index d22a9fe2e6df..71bbeb9321ba 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_chunk">@@ -1808,6 +1808,8 @@</span> <span class="p_context"> static int byt_pinctrl_probe(struct platform_device *pdev)</span>
 		return PTR_ERR(vg-&gt;pctl_dev);
 	}
 
<span class="p_add">+	raw_spin_lock_init(&amp;vg-&gt;lock);</span>
<span class="p_add">+</span>
 	ret = byt_gpio_probe(vg);
 	if (ret) {
 		pinctrl_unregister(vg-&gt;pctl_dev);
<span class="p_chunk">@@ -1815,7 +1817,6 @@</span> <span class="p_context"> static int byt_pinctrl_probe(struct platform_device *pdev)</span>
 	}
 
 	platform_set_drvdata(pdev, vg);
<span class="p_del">-	raw_spin_lock_init(&amp;vg-&gt;lock);</span>
 	pm_runtime_enable(&amp;pdev-&gt;dev);
 
 	return 0;
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-intel.c b/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_header">index 257cab129692..2b5b20bf7d99 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/pinctrl/pinconf.h&gt;
 #include &lt;linux/pinctrl/pinconf-generic.h&gt;
 
<span class="p_add">+#include &quot;../core.h&quot;</span>
 #include &quot;pinctrl-intel.h&quot;
 
 /* Offset from regs */
<span class="p_chunk">@@ -1079,6 +1080,26 @@</span> <span class="p_context"> int intel_pinctrl_remove(struct platform_device *pdev)</span>
 EXPORT_SYMBOL_GPL(intel_pinctrl_remove);
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_add">+static bool intel_pinctrl_should_save(struct intel_pinctrl *pctrl, unsigned pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct pin_desc *pd = pin_desc_get(pctrl-&gt;pctldev, pin);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pd || !intel_pad_usable(pctrl, pin))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only restore the pin if it is actually in use by the kernel (or</span>
<span class="p_add">+	 * by userspace). It is possible that some pins are used by the</span>
<span class="p_add">+	 * BIOS during resume and those are not always locked down so leave</span>
<span class="p_add">+	 * them alone.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pd-&gt;mux_owner || pd-&gt;gpio_owner ||</span>
<span class="p_add">+	    gpiochip_line_is_irq(&amp;pctrl-&gt;chip, pin))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int intel_pinctrl_suspend(struct device *dev)
 {
 	struct platform_device *pdev = to_platform_device(dev);
<span class="p_chunk">@@ -1092,7 +1113,7 @@</span> <span class="p_context"> int intel_pinctrl_suspend(struct device *dev)</span>
 		const struct pinctrl_pin_desc *desc = &amp;pctrl-&gt;soc-&gt;pins[i];
 		u32 val;
 
<span class="p_del">-		if (!intel_pad_usable(pctrl, desc-&gt;number))</span>
<span class="p_add">+		if (!intel_pinctrl_should_save(pctrl, desc-&gt;number))</span>
 			continue;
 
 		val = readl(intel_get_padcfg(pctrl, desc-&gt;number, PADCFG0));
<span class="p_chunk">@@ -1153,7 +1174,7 @@</span> <span class="p_context"> int intel_pinctrl_resume(struct device *dev)</span>
 		void __iomem *padcfg;
 		u32 val;
 
<span class="p_del">-		if (!intel_pad_usable(pctrl, desc-&gt;number))</span>
<span class="p_add">+		if (!intel_pinctrl_should_save(pctrl, desc-&gt;number))</span>
 			continue;
 
 		padcfg = intel_get_padcfg(pctrl, desc-&gt;number, PADCFG0);
<span class="p_header">diff --git a/drivers/regulator/tps65910-regulator.c b/drivers/regulator/tps65910-regulator.c</span>
<span class="p_header">index fb991ec76423..696116ebdf50 100644</span>
<span class="p_header">--- a/drivers/regulator/tps65910-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/tps65910-regulator.c</span>
<span class="p_chunk">@@ -1111,6 +1111,12 @@</span> <span class="p_context"> static int tps65910_probe(struct platform_device *pdev)</span>
 		pmic-&gt;num_regulators = ARRAY_SIZE(tps65910_regs);
 		pmic-&gt;ext_sleep_control = tps65910_ext_sleep_control;
 		info = tps65910_regs;
<span class="p_add">+		/* Work around silicon erratum SWCZ010: output programmed</span>
<span class="p_add">+		 * voltage level can go higher than expected or crash</span>
<span class="p_add">+		 * Workaround: use no synchronization of DCDC clocks</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tps65910_reg_clear_bits(pmic-&gt;mfd, TPS65910_DCDCCTRL,</span>
<span class="p_add">+					DCDCCTRL_DCDCCKSYNC_MASK);</span>
 		break;
 	case TPS65911:
 		pmic-&gt;get_ctrl_reg = &amp;tps65911_get_ctrl_register;
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">index 5d7fbe4e907e..581001989937 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Debug traces for zfcp.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2016</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> void zfcp_dbf_pl_write(struct zfcp_dbf *dbf, void *data, u16 length, char *area,</span>
  * @tag: tag indicating which kind of unsolicited status has been received
  * @req: request for which a response was received
  */
<span class="p_del">-void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
<span class="p_add">+void zfcp_dbf_hba_fsf_res(char *tag, int level, struct zfcp_fsf_req *req)</span>
 {
 	struct zfcp_dbf *dbf = req-&gt;adapter-&gt;dbf;
 	struct fsf_qtcb_prefix *q_pref = &amp;req-&gt;qtcb-&gt;prefix;
<span class="p_chunk">@@ -85,6 +85,8 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
 	rec-&gt;u.res.req_issued = req-&gt;issued;
 	rec-&gt;u.res.prot_status = q_pref-&gt;prot_status;
 	rec-&gt;u.res.fsf_status = q_head-&gt;fsf_status;
<span class="p_add">+	rec-&gt;u.res.port_handle = q_head-&gt;port_handle;</span>
<span class="p_add">+	rec-&gt;u.res.lun_handle = q_head-&gt;lun_handle;</span>
 
 	memcpy(rec-&gt;u.res.prot_status_qual, &amp;q_pref-&gt;prot_status_qual,
 	       FSF_PROT_STATUS_QUAL_SIZE);
<span class="p_chunk">@@ -97,7 +99,7 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
 				  rec-&gt;pl_len, &quot;fsf_res&quot;, req-&gt;req_id);
 	}
 
<span class="p_del">-	debug_event(dbf-&gt;hba, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	debug_event(dbf-&gt;hba, level, rec, sizeof(*rec));</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;hba_lock, flags);
 }
 
<span class="p_chunk">@@ -241,7 +243,8 @@</span> <span class="p_context"> static void zfcp_dbf_set_common(struct zfcp_dbf_rec *rec,</span>
 	if (sdev) {
 		rec-&gt;lun_status = atomic_read(&amp;sdev_to_zfcp(sdev)-&gt;status);
 		rec-&gt;lun = zfcp_scsi_dev_lun(sdev);
<span class="p_del">-	}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		rec-&gt;lun = ZFCP_DBF_INVALID_LUN;</span>
 }
 
 /**
<span class="p_chunk">@@ -320,13 +323,48 @@</span> <span class="p_context"> void zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;rec_lock, flags);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * zfcp_dbf_rec_run_wka - trace wka port event with info like running recovery</span>
<span class="p_add">+ * @tag: identifier for event</span>
<span class="p_add">+ * @wka_port: well known address port</span>
<span class="p_add">+ * @req_id: request ID to correlate with potential HBA trace record</span>
<span class="p_add">+ */</span>
<span class="p_add">+void zfcp_dbf_rec_run_wka(char *tag, struct zfcp_fc_wka_port *wka_port,</span>
<span class="p_add">+			  u64 req_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_dbf *dbf = wka_port-&gt;adapter-&gt;dbf;</span>
<span class="p_add">+	struct zfcp_dbf_rec *rec = &amp;dbf-&gt;rec_buf;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dbf-&gt;rec_lock, flags);</span>
<span class="p_add">+	memset(rec, 0, sizeof(*rec));</span>
<span class="p_add">+</span>
<span class="p_add">+	rec-&gt;id = ZFCP_DBF_REC_RUN;</span>
<span class="p_add">+	memcpy(rec-&gt;tag, tag, ZFCP_DBF_TAG_LEN);</span>
<span class="p_add">+	rec-&gt;port_status = wka_port-&gt;status;</span>
<span class="p_add">+	rec-&gt;d_id = wka_port-&gt;d_id;</span>
<span class="p_add">+	rec-&gt;lun = ZFCP_DBF_INVALID_LUN;</span>
<span class="p_add">+</span>
<span class="p_add">+	rec-&gt;u.run.fsf_req_id = req_id;</span>
<span class="p_add">+	rec-&gt;u.run.rec_status = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_step = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_action = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_count = ~0;</span>
<span class="p_add">+</span>
<span class="p_add">+	debug_event(dbf-&gt;rec, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dbf-&gt;rec_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline
<span class="p_del">-void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,</span>
<span class="p_del">-		  u64 req_id, u32 d_id)</span>
<span class="p_add">+void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf,</span>
<span class="p_add">+		  char *paytag, struct scatterlist *sg, u8 id, u16 len,</span>
<span class="p_add">+		  u64 req_id, u32 d_id, u16 cap_len)</span>
 {
 	struct zfcp_dbf_san *rec = &amp;dbf-&gt;san_buf;
 	u16 rec_len;
 	unsigned long flags;
<span class="p_add">+	struct zfcp_dbf_pay *payload = &amp;dbf-&gt;pay_buf;</span>
<span class="p_add">+	u16 pay_sum = 0;</span>
 
 	spin_lock_irqsave(&amp;dbf-&gt;san_lock, flags);
 	memset(rec, 0, sizeof(*rec));
<span class="p_chunk">@@ -334,10 +372,41 @@</span> <span class="p_context"> void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,</span>
 	rec-&gt;id = id;
 	rec-&gt;fsf_req_id = req_id;
 	rec-&gt;d_id = d_id;
<span class="p_del">-	rec_len = min(len, (u16)ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_del">-	memcpy(rec-&gt;payload, data, rec_len);</span>
 	memcpy(rec-&gt;tag, tag, ZFCP_DBF_TAG_LEN);
<span class="p_add">+	rec-&gt;pl_len = len; /* full length even if we cap pay below */</span>
<span class="p_add">+	if (!sg)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	rec_len = min_t(unsigned int, sg-&gt;length, ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_add">+	memcpy(rec-&gt;payload, sg_virt(sg), rec_len); /* part of 1st sg entry */</span>
<span class="p_add">+	if (len &lt;= rec_len)</span>
<span class="p_add">+		goto out; /* skip pay record if full content in rec-&gt;payload */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if (len &gt; rec_len):</span>
<span class="p_add">+	 * dump data up to cap_len ignoring small duplicate in rec-&gt;payload</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;dbf-&gt;pay_lock);</span>
<span class="p_add">+	memset(payload, 0, sizeof(*payload));</span>
<span class="p_add">+	memcpy(payload-&gt;area, paytag, ZFCP_DBF_TAG_LEN);</span>
<span class="p_add">+	payload-&gt;fsf_req_id = req_id;</span>
<span class="p_add">+	payload-&gt;counter = 0;</span>
<span class="p_add">+	for (; sg &amp;&amp; pay_sum &lt; cap_len; sg = sg_next(sg)) {</span>
<span class="p_add">+		u16 pay_len, offset = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (offset &lt; sg-&gt;length &amp;&amp; pay_sum &lt; cap_len) {</span>
<span class="p_add">+			pay_len = min((u16)ZFCP_DBF_PAY_MAX_REC,</span>
<span class="p_add">+				      (u16)(sg-&gt;length - offset));</span>
<span class="p_add">+			/* cap_len &lt;= pay_sum &lt; cap_len+ZFCP_DBF_PAY_MAX_REC */</span>
<span class="p_add">+			memcpy(payload-&gt;data, sg_virt(sg) + offset, pay_len);</span>
<span class="p_add">+			debug_event(dbf-&gt;pay, 1, payload,</span>
<span class="p_add">+				    zfcp_dbf_plen(pay_len));</span>
<span class="p_add">+			payload-&gt;counter++;</span>
<span class="p_add">+			offset += pay_len;</span>
<span class="p_add">+			pay_sum += pay_len;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock(&amp;dbf-&gt;pay_lock);</span>
 
<span class="p_add">+out:</span>
 	debug_event(dbf-&gt;san, 1, rec, sizeof(*rec));
 	spin_unlock_irqrestore(&amp;dbf-&gt;san_lock, flags);
 }
<span class="p_chunk">@@ -354,9 +423,62 @@</span> <span class="p_context"> void zfcp_dbf_san_req(char *tag, struct zfcp_fsf_req *fsf, u32 d_id)</span>
 	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;
 	u16 length;
 
<span class="p_del">-	length = (u16)(ct_els-&gt;req-&gt;length + FC_CT_HDR_LEN);</span>
<span class="p_del">-	zfcp_dbf_san(tag, dbf, sg_virt(ct_els-&gt;req), ZFCP_DBF_SAN_REQ, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, d_id);</span>
<span class="p_add">+	length = (u16)zfcp_qdio_real_bytes(ct_els-&gt;req);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_req&quot;, ct_els-&gt;req, ZFCP_DBF_SAN_REQ,</span>
<span class="p_add">+		     length, fsf-&gt;req_id, d_id, length);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
<span class="p_add">+					      struct zfcp_fsf_req *fsf,</span>
<span class="p_add">+					      u16 len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;</span>
<span class="p_add">+	struct fc_ct_hdr *reqh = sg_virt(ct_els-&gt;req);</span>
<span class="p_add">+	struct fc_ns_gid_ft *reqn = (struct fc_ns_gid_ft *)(reqh + 1);</span>
<span class="p_add">+	struct scatterlist *resp_entry = ct_els-&gt;resp;</span>
<span class="p_add">+	struct fc_gpn_ft_resp *acc;</span>
<span class="p_add">+	int max_entries, x, last = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(memcmp(tag, &quot;fsscth2&quot;, 7) == 0</span>
<span class="p_add">+	      &amp;&amp; ct_els-&gt;d_id == FC_FID_DIR_SERV</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_rev == FC_CT_REV</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[0] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[1] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[2] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_fs_type == FC_FST_DIR</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_fs_subtype == FC_NS_SUBTYPE</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_options == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;_ct_resvd1 == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_cmd == FC_NS_GPN_FT</span>
<span class="p_add">+	      /* reqh-&gt;ct_mr_size can vary so do not match but read below */</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;_ct_resvd2 == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_reason == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_explan == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_vendor == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_resvd == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_domain_id_scope == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_area_id_scope == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_fc4_type == FC_TYPE_FCP))</span>
<span class="p_add">+		return len; /* not GPN_FT response so do not cap */</span>
<span class="p_add">+</span>
<span class="p_add">+	acc = sg_virt(resp_entry);</span>
<span class="p_add">+	max_entries = (reqh-&gt;ct_mr_size * 4 / sizeof(struct fc_gpn_ft_resp))</span>
<span class="p_add">+		+ 1 /* zfcp_fc_scan_ports: bytes correct, entries off-by-one</span>
<span class="p_add">+		     * to account for header as 1st pseudo &quot;entry&quot; */;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* the basic CT_IU preamble is the same size as one entry in the GPN_FT</span>
<span class="p_add">+	 * response, allowing us to skip special handling for it - just skip it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (x = 1; x &lt; max_entries &amp;&amp; !last; x++) {</span>
<span class="p_add">+		if (x % (ZFCP_FC_GPN_FT_ENT_PAGE + 1))</span>
<span class="p_add">+			acc++;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			acc = sg_virt(++resp_entry);</span>
<span class="p_add">+</span>
<span class="p_add">+		last = acc-&gt;fp_flags &amp; FC_NS_FID_LAST;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	len = min(len, (u16)(x * sizeof(struct fc_gpn_ft_resp)));</span>
<span class="p_add">+	return len; /* cap after last entry */</span>
 }
 
 /**
<span class="p_chunk">@@ -370,9 +492,10 @@</span> <span class="p_context"> void zfcp_dbf_san_res(char *tag, struct zfcp_fsf_req *fsf)</span>
 	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;
 	u16 length;
 
<span class="p_del">-	length = (u16)(ct_els-&gt;resp-&gt;length + FC_CT_HDR_LEN);</span>
<span class="p_del">-	zfcp_dbf_san(tag, dbf, sg_virt(ct_els-&gt;resp), ZFCP_DBF_SAN_RES, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, 0);</span>
<span class="p_add">+	length = (u16)zfcp_qdio_real_bytes(ct_els-&gt;resp);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_res&quot;, ct_els-&gt;resp, ZFCP_DBF_SAN_RES,</span>
<span class="p_add">+		     length, fsf-&gt;req_id, ct_els-&gt;d_id,</span>
<span class="p_add">+		     zfcp_dbf_san_res_cap_len_if_gpn_ft(tag, fsf, length));</span>
 }
 
 /**
<span class="p_chunk">@@ -386,11 +509,13 @@</span> <span class="p_context"> void zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)</span>
 	struct fsf_status_read_buffer *srb =
 		(struct fsf_status_read_buffer *) fsf-&gt;data;
 	u16 length;
<span class="p_add">+	struct scatterlist sg;</span>
 
 	length = (u16)(srb-&gt;length -
 			offsetof(struct fsf_status_read_buffer, payload));
<span class="p_del">-	zfcp_dbf_san(tag, dbf, srb-&gt;payload.data, ZFCP_DBF_SAN_ELS, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, ntoh24(srb-&gt;d_id));</span>
<span class="p_add">+	sg_init_one(&amp;sg, srb-&gt;payload.data, length);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_els&quot;, &amp;sg, ZFCP_DBF_SAN_ELS, length,</span>
<span class="p_add">+		     fsf-&gt;req_id, ntoh24(srb-&gt;d_id), length);</span>
 }
 
 /**
<span class="p_chunk">@@ -399,7 +524,8 @@</span> <span class="p_context"> void zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)</span>
  * @sc: pointer to struct scsi_cmnd
  * @fsf: pointer to struct zfcp_fsf_req
  */
<span class="p_del">-void zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)</span>
<span class="p_add">+void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
<span class="p_add">+		   struct zfcp_fsf_req *fsf)</span>
 {
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *) sc-&gt;device-&gt;host-&gt;hostdata[0];
<span class="p_chunk">@@ -442,7 +568,7 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)</span>
 		}
 	}
 
<span class="p_del">-	debug_event(dbf-&gt;scsi, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	debug_event(dbf-&gt;scsi, level, rec, sizeof(*rec));</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;scsi_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">index 0be3d48681ae..36d07584271d 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
  * zfcp device driver
  * debug feature declarations
  *
<span class="p_del">- * Copyright IBM Corp. 2008, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2008, 2015</span>
  */
 
 #ifndef ZFCP_DBF_H
<span class="p_chunk">@@ -17,6 +17,11 @@</span> <span class="p_context"></span>
 
 #define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
 
<span class="p_add">+enum zfcp_dbf_pseudo_erp_act_type {</span>
<span class="p_add">+	ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD = 0xff,</span>
<span class="p_add">+	ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL = 0xfe,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /**
  * struct zfcp_dbf_rec_trigger - trace record for triggered recovery action
  * @ready: number of ready recovery actions
<span class="p_chunk">@@ -110,6 +115,7 @@</span> <span class="p_context"> struct zfcp_dbf_san {</span>
 	u32 d_id;
 #define ZFCP_DBF_SAN_MAX_PAYLOAD (FC_CT_HDR_LEN + 32)
 	char payload[ZFCP_DBF_SAN_MAX_PAYLOAD];
<span class="p_add">+	u16 pl_len;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -126,6 +132,8 @@</span> <span class="p_context"> struct zfcp_dbf_hba_res {</span>
 	u8  prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];
 	u32 fsf_status;
 	u8  fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
<span class="p_add">+	u32 port_handle;</span>
<span class="p_add">+	u32 lun_handle;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -279,7 +287,7 @@</span> <span class="p_context"> static inline</span>
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
 	if (debug_level_enabled(req-&gt;adapter-&gt;dbf-&gt;hba, level))
<span class="p_del">-		zfcp_dbf_hba_fsf_res(tag, req);</span>
<span class="p_add">+		zfcp_dbf_hba_fsf_res(tag, level, req);</span>
 }
 
 /**
<span class="p_chunk">@@ -318,7 +326,7 @@</span> <span class="p_context"> void _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,</span>
 					scmd-&gt;device-&gt;host-&gt;hostdata[0];
 
 	if (debug_level_enabled(adapter-&gt;dbf-&gt;scsi, level))
<span class="p_del">-		zfcp_dbf_scsi(tag, scmd, req);</span>
<span class="p_add">+		zfcp_dbf_scsi(tag, level, scmd, req);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_erp.c b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">index 3fb410977014..a59d678125bd 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Error Recovery Procedures (ERP).
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -1217,8 +1217,14 @@</span> <span class="p_context"> static void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)</span>
 		break;
 
 	case ZFCP_ERP_ACTION_REOPEN_PORT:
<span class="p_del">-		if (result == ZFCP_ERP_SUCCEEDED)</span>
<span class="p_del">-			zfcp_scsi_schedule_rport_register(port);</span>
<span class="p_add">+		/* This switch case might also happen after a forced reopen</span>
<span class="p_add">+		 * was successfully done and thus overwritten with a new</span>
<span class="p_add">+		 * non-forced reopen at `ersfs_2&#39;. In this case, we must not</span>
<span class="p_add">+		 * do the clean-up of the non-forced version.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (act-&gt;step != ZFCP_ERP_STEP_UNINITIALIZED)</span>
<span class="p_add">+			if (result == ZFCP_ERP_SUCCEEDED)</span>
<span class="p_add">+				zfcp_scsi_schedule_rport_register(port);</span>
 		/* fall through */
 	case ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:
 		put_device(&amp;port-&gt;dev);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_ext.h b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">index 5b500652572b..c8fed9fa1cca 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * External function declarations.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #ifndef ZFCP_EXT_H
<span class="p_chunk">@@ -35,8 +35,9 @@</span> <span class="p_context"> extern void zfcp_dbf_adapter_unregister(struct zfcp_adapter *);</span>
 extern void zfcp_dbf_rec_trig(char *, struct zfcp_adapter *,
 			      struct zfcp_port *, struct scsi_device *, u8, u8);
 extern void zfcp_dbf_rec_run(char *, struct zfcp_erp_action *);
<span class="p_add">+extern void zfcp_dbf_rec_run_wka(char *, struct zfcp_fc_wka_port *, u64);</span>
 extern void zfcp_dbf_hba_fsf_uss(char *, struct zfcp_fsf_req *);
<span class="p_del">-extern void zfcp_dbf_hba_fsf_res(char *, struct zfcp_fsf_req *);</span>
<span class="p_add">+extern void zfcp_dbf_hba_fsf_res(char *, int, struct zfcp_fsf_req *);</span>
 extern void zfcp_dbf_hba_bit_err(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_berr(struct zfcp_dbf *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_def_err(struct zfcp_adapter *, u64, u16, void **);
<span class="p_chunk">@@ -44,7 +45,8 @@</span> <span class="p_context"> extern void zfcp_dbf_hba_basic(char *, struct zfcp_adapter *);</span>
 extern void zfcp_dbf_san_req(char *, struct zfcp_fsf_req *, u32);
 extern void zfcp_dbf_san_res(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_san_in_els(char *, struct zfcp_fsf_req *);
<span class="p_del">-extern void zfcp_dbf_scsi(char *, struct scsi_cmnd *, struct zfcp_fsf_req *);</span>
<span class="p_add">+extern void zfcp_dbf_scsi(char *, int, struct scsi_cmnd *,</span>
<span class="p_add">+			  struct zfcp_fsf_req *);</span>
 
 /* zfcp_erp.c */
 extern void zfcp_erp_set_adapter_status(struct zfcp_adapter *, u32);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">index 522a633c866a..75f820ca17b7 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Implementation of FSF commands.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -508,7 +508,10 @@</span> <span class="p_context"> static int zfcp_fsf_exchange_config_evaluate(struct zfcp_fsf_req *req)</span>
 		fc_host_port_type(shost) = FC_PORTTYPE_PTP;
 		break;
 	case FSF_TOPO_FABRIC:
<span class="p_del">-		fc_host_port_type(shost) = FC_PORTTYPE_NPORT;</span>
<span class="p_add">+		if (bottom-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE)</span>
<span class="p_add">+			fc_host_port_type(shost) = FC_PORTTYPE_NPIV;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			fc_host_port_type(shost) = FC_PORTTYPE_NPORT;</span>
 		break;
 	case FSF_TOPO_AL:
 		fc_host_port_type(shost) = FC_PORTTYPE_NLPORT;
<span class="p_chunk">@@ -613,7 +616,6 @@</span> <span class="p_context"> static void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)</span>
 
 	if (adapter-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE) {
 		fc_host_permanent_port_name(shost) = bottom-&gt;wwpn;
<span class="p_del">-		fc_host_port_type(shost) = FC_PORTTYPE_NPIV;</span>
 	} else
 		fc_host_permanent_port_name(shost) = fc_host_port_name(shost);
 	fc_host_maxframe_size(shost) = bottom-&gt;maximum_frame_size;
<span class="p_chunk">@@ -982,8 +984,12 @@</span> <span class="p_context"> static int zfcp_fsf_setup_ct_els_sbals(struct zfcp_fsf_req *req,</span>
 	if (zfcp_adapter_multi_buffer_active(adapter)) {
 		if (zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req, sg_req))
 			return -EIO;
<span class="p_add">+		qtcb-&gt;bottom.support.req_buf_length =</span>
<span class="p_add">+			zfcp_qdio_real_bytes(sg_req);</span>
 		if (zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req, sg_resp))
 			return -EIO;
<span class="p_add">+		qtcb-&gt;bottom.support.resp_buf_length =</span>
<span class="p_add">+			zfcp_qdio_real_bytes(sg_resp);</span>
 
 		zfcp_qdio_set_data_div(qdio, &amp;req-&gt;qdio_req,
 					zfcp_qdio_sbale_count(sg_req));
<span class="p_chunk">@@ -1073,6 +1079,7 @@</span> <span class="p_context"> int zfcp_fsf_send_ct(struct zfcp_fc_wka_port *wka_port,</span>
 
 	req-&gt;handler = zfcp_fsf_send_ct_handler;
 	req-&gt;qtcb-&gt;header.port_handle = wka_port-&gt;handle;
<span class="p_add">+	ct-&gt;d_id = wka_port-&gt;d_id;</span>
 	req-&gt;data = ct;
 
 	zfcp_dbf_san_req(&quot;fssct_1&quot;, req, wka_port-&gt;d_id);
<span class="p_chunk">@@ -1169,6 +1176,7 @@</span> <span class="p_context"> int zfcp_fsf_send_els(struct zfcp_adapter *adapter, u32 d_id,</span>
 
 	hton24(req-&gt;qtcb-&gt;bottom.support.d_id, d_id);
 	req-&gt;handler = zfcp_fsf_send_els_handler;
<span class="p_add">+	els-&gt;d_id = d_id;</span>
 	req-&gt;data = els;
 
 	zfcp_dbf_san_req(&quot;fssels1&quot;, req, d_id);
<span class="p_chunk">@@ -1575,7 +1583,7 @@</span> <span class="p_context"> out:</span>
 int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req;</span>
<span class="p_add">+	struct zfcp_fsf_req *req = NULL;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1604,6 +1612,8 @@</span> <span class="p_context"> int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_add">+	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+		zfcp_dbf_rec_run_wka(&quot;fsowp_1&quot;, wka_port, req-&gt;req_id);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -1628,7 +1638,7 @@</span> <span class="p_context"> static void zfcp_fsf_close_wka_port_handler(struct zfcp_fsf_req *req)</span>
 int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req;</span>
<span class="p_add">+	struct zfcp_fsf_req *req = NULL;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1657,6 +1667,8 @@</span> <span class="p_context"> int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_add">+	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+		zfcp_dbf_rec_run_wka(&quot;fscwp_1&quot;, wka_port, req-&gt;req_id);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.h b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">index 57ae3ae1046d..be1c04b334c5 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to the FSF support functions.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #ifndef FSF_H
<span class="p_chunk">@@ -436,6 +436,7 @@</span> <span class="p_context"> struct zfcp_blk_drv_data {</span>
  * @handler_data: data passed to handler function
  * @port: Optional pointer to port for zfcp internal ELS (only test link ADISC)
  * @status: used to pass error status to calling function
<span class="p_add">+ * @d_id: Destination ID of either open WKA port for CT or of D_ID for ELS</span>
  */
 struct zfcp_fsf_ct_els {
 	struct scatterlist *req;
<span class="p_chunk">@@ -444,6 +445,7 @@</span> <span class="p_context"> struct zfcp_fsf_ct_els {</span>
 	void *handler_data;
 	struct zfcp_port *port;
 	int status;
<span class="p_add">+	u32 d_id;</span>
 };
 
 #endif				/* FSF_H */
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index b3c6ff49103b..9069f98a1817 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to Linux SCSI midlayer.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -556,6 +556,9 @@</span> <span class="p_context"> static void zfcp_scsi_rport_register(struct zfcp_port *port)</span>
 	ids.port_id = port-&gt;d_id;
 	ids.roles = FC_RPORT_ROLE_FCP_TARGET;
 
<span class="p_add">+	zfcp_dbf_rec_trig(&quot;scpaddy&quot;, port-&gt;adapter, port, NULL,</span>
<span class="p_add">+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD,</span>
<span class="p_add">+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD);</span>
 	rport = fc_remote_port_add(port-&gt;adapter-&gt;scsi_host, 0, &amp;ids);
 	if (!rport) {
 		dev_err(&amp;port-&gt;adapter-&gt;ccw_device-&gt;dev,
<span class="p_chunk">@@ -577,6 +580,9 @@</span> <span class="p_context"> static void zfcp_scsi_rport_block(struct zfcp_port *port)</span>
 	struct fc_rport *rport = port-&gt;rport;
 
 	if (rport) {
<span class="p_add">+		zfcp_dbf_rec_trig(&quot;scpdely&quot;, port-&gt;adapter, port, NULL,</span>
<span class="p_add">+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL,</span>
<span class="p_add">+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL);</span>
 		fc_remote_port_delete(rport);
 		port-&gt;rport = NULL;
 	}
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index e0a78f53d809..bac8cdf9fb23 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -1472,12 +1472,12 @@</span> <span class="p_context"> retry:</span>
  out_err:
 	kfree(lun_data);
  out:
<span class="p_del">-	scsi_device_put(sdev);</span>
 	if (scsi_device_created(sdev))
 		/*
 		 * the sdev we used didn&#39;t appear in the report luns scan
 		 */
 		__scsi_remove_device(sdev);
<span class="p_add">+	scsi_device_put(sdev);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/soc/fsl/qe/gpio.c b/drivers/soc/fsl/qe/gpio.c</span>
<span class="p_header">index 333eb2215a57..0aaf429f31d5 100644</span>
<span class="p_header">--- a/drivers/soc/fsl/qe/gpio.c</span>
<span class="p_header">+++ b/drivers/soc/fsl/qe/gpio.c</span>
<span class="p_chunk">@@ -41,7 +41,8 @@</span> <span class="p_context"> struct qe_gpio_chip {</span>
 
 static void qe_gpio_save_regs(struct of_mm_gpio_chip *mm_gc)
 {
<span class="p_del">-	struct qe_gpio_chip *qe_gc = gpiochip_get_data(&amp;mm_gc-&gt;gc);</span>
<span class="p_add">+	struct qe_gpio_chip *qe_gc =</span>
<span class="p_add">+		container_of(mm_gc, struct qe_gpio_chip, mm_gc);</span>
 	struct qe_pio_regs __iomem *regs = mm_gc-&gt;regs;
 
 	qe_gc-&gt;cpdata = in_be32(&amp;regs-&gt;cpdata);
<span class="p_header">diff --git a/drivers/soc/fsl/qe/qe_common.c b/drivers/soc/fsl/qe/qe_common.c</span>
<span class="p_header">index 41eff805a904..104e68d9b84f 100644</span>
<span class="p_header">--- a/drivers/soc/fsl/qe/qe_common.c</span>
<span class="p_header">+++ b/drivers/soc/fsl/qe/qe_common.c</span>
<span class="p_chunk">@@ -70,6 +70,11 @@</span> <span class="p_context"> int cpm_muram_init(void)</span>
 	}
 
 	muram_pool = gen_pool_create(0, -1);
<span class="p_add">+	if (!muram_pool) {</span>
<span class="p_add">+		pr_err(&quot;Cannot allocate memory pool for CPM/QE muram&quot;);</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out_muram;</span>
<span class="p_add">+	}</span>
 	muram_pbase = of_translate_address(np, zero);
 	if (muram_pbase == (phys_addr_t)OF_BAD_ADDR) {
 		pr_err(&quot;Cannot translate zero through CPM muram node&quot;);
<span class="p_chunk">@@ -116,6 +121,9 @@</span> <span class="p_context"> static unsigned long cpm_muram_alloc_common(unsigned long size,</span>
 	struct muram_block *entry;
 	unsigned long start;
 
<span class="p_add">+	if (!muram_pool &amp;&amp; cpm_muram_init())</span>
<span class="p_add">+		goto out2;</span>
<span class="p_add">+</span>
 	start = gen_pool_alloc_algo(muram_pool, size, algo, data);
 	if (!start)
 		goto out2;
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 6094a6beddde..e825d580ccee 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -754,15 +754,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(target_complete_cmd);</span>
 
 void target_complete_cmd_with_length(struct se_cmd *cmd, u8 scsi_status, int length)
 {
<span class="p_del">-	if (scsi_status != SAM_STAT_GOOD) {</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Calculate new residual count based upon length of SCSI data</span>
<span class="p_del">-	 * transferred.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (length &lt; cmd-&gt;data_length) {</span>
<span class="p_add">+	if (scsi_status == SAM_STAT_GOOD &amp;&amp; length &lt; cmd-&gt;data_length) {</span>
 		if (cmd-&gt;se_cmd_flags &amp; SCF_UNDERFLOW_BIT) {
 			cmd-&gt;residual_count += cmd-&gt;data_length - length;
 		} else {
<span class="p_chunk">@@ -771,12 +763,6 @@</span> <span class="p_context"> void target_complete_cmd_with_length(struct se_cmd *cmd, u8 scsi_status, int len</span>
 		}
 
 		cmd-&gt;data_length = length;
<span class="p_del">-	} else if (length &gt; cmd-&gt;data_length) {</span>
<span class="p_del">-		cmd-&gt;se_cmd_flags |= SCF_OVERFLOW_BIT;</span>
<span class="p_del">-		cmd-&gt;residual_count = length - cmd-&gt;data_length;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		cmd-&gt;se_cmd_flags &amp;= ~(SCF_OVERFLOW_BIT | SCF_UNDERFLOW_BIT);</span>
<span class="p_del">-		cmd-&gt;residual_count = 0;</span>
 	}
 
 	target_complete_cmd(cmd, scsi_status);
<span class="p_chunk">@@ -1706,6 +1692,7 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	case TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:
 	case TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:
 	case TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:
<span class="p_add">+	case TCM_COPY_TARGET_DEVICE_NOT_REACHABLE:</span>
 		break;
 	case TCM_OUT_OF_RESOURCES:
 		sense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
<span class="p_chunk">@@ -2547,8 +2534,10 @@</span> <span class="p_context"> int target_get_sess_cmd(struct se_cmd *se_cmd, bool ack_kref)</span>
 	 * fabric acknowledgement that requires two target_put_sess_cmd()
 	 * invocations before se_cmd descriptor release.
 	 */
<span class="p_del">-	if (ack_kref)</span>
<span class="p_add">+	if (ack_kref) {</span>
 		kref_get(&amp;se_cmd-&gt;cmd_kref);
<span class="p_add">+		se_cmd-&gt;se_cmd_flags |= SCF_ACK_KREF;</span>
<span class="p_add">+	}</span>
 
 	spin_lock_irqsave(&amp;se_sess-&gt;sess_cmd_lock, flags);
 	if (se_sess-&gt;sess_tearing_down) {
<span class="p_chunk">@@ -2871,6 +2860,12 @@</span> <span class="p_context"> static const struct sense_info sense_info_table[] = {</span>
 		.ascq = 0x03, /* LOGICAL BLOCK REFERENCE TAG CHECK FAILED */
 		.add_sector_info = true,
 	},
<span class="p_add">+	[TCM_COPY_TARGET_DEVICE_NOT_REACHABLE] = {</span>
<span class="p_add">+		.key = COPY_ABORTED,</span>
<span class="p_add">+		.asc = 0x0d,</span>
<span class="p_add">+		.ascq = 0x02, /* COPY TARGET DEVICE NOT REACHABLE */</span>
<span class="p_add">+</span>
<span class="p_add">+	},</span>
 	[TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE] = {
 		/*
 		 * Returning ILLEGAL REQUEST would cause immediate IO errors on
<span class="p_header">diff --git a/drivers/target/target_core_xcopy.c b/drivers/target/target_core_xcopy.c</span>
<span class="p_header">index 75cd85426ae3..094a1440eacb 100644</span>
<span class="p_header">--- a/drivers/target/target_core_xcopy.c</span>
<span class="p_header">+++ b/drivers/target/target_core_xcopy.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> static int target_xcopy_locate_se_dev_e4(struct se_cmd *se_cmd, struct xcopy_op</span>
 	}
 	mutex_unlock(&amp;g_device_mutex);
 
<span class="p_del">-	pr_err(&quot;Unable to locate 0xe4 descriptor for EXTENDED_COPY\n&quot;);</span>
<span class="p_add">+	pr_debug_ratelimited(&quot;Unable to locate 0xe4 descriptor for EXTENDED_COPY\n&quot;);</span>
 	return -EINVAL;
 }
 
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> static int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op</span>
 
 static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,
 				struct xcopy_op *xop, unsigned char *p,
<span class="p_del">-				unsigned short tdll)</span>
<span class="p_add">+				unsigned short tdll, sense_reason_t *sense_ret)</span>
 {
 	struct se_device *local_dev = se_cmd-&gt;se_dev;
 	unsigned char *desc = p;
<span class="p_chunk">@@ -193,6 +193,8 @@</span> <span class="p_context"> static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,</span>
 	unsigned short start = 0;
 	bool src = true;
 
<span class="p_add">+	*sense_ret = TCM_INVALID_PARAMETER_LIST;</span>
<span class="p_add">+</span>
 	if (offset != 0) {
 		pr_err(&quot;XCOPY target descriptor list length is not&quot;
 			&quot; multiple of %d\n&quot;, XCOPY_TARGET_DESC_LEN);
<span class="p_chunk">@@ -243,9 +245,16 @@</span> <span class="p_context"> static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,</span>
 		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, true);
 	else
 		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, false);
<span class="p_del">-</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If a matching IEEE NAA 0x83 descriptor for the requested device</span>
<span class="p_add">+	 * is not located on this node, return COPY_ABORTED with ASQ/ASQC</span>
<span class="p_add">+	 * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the</span>
<span class="p_add">+	 * initiator to fall back to normal copy method.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	pr_debug(&quot;XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n&quot;,
 		 xop-&gt;src_dev, &amp;xop-&gt;src_tid_wwn[0]);
<span class="p_chunk">@@ -653,6 +662,7 @@</span> <span class="p_context"> static int target_xcopy_read_source(</span>
 	rc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, src_dev, &amp;cdb[0],
 				remote_port, true);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
 	}
<span class="p_chunk">@@ -664,6 +674,7 @@</span> <span class="p_context"> static int target_xcopy_read_source(</span>
 
 	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
 	}
<span class="p_chunk">@@ -714,6 +725,7 @@</span> <span class="p_context"> static int target_xcopy_write_destination(</span>
 				remote_port, false);
 	if (rc &lt; 0) {
 		struct se_cmd *src_cmd = &amp;xop-&gt;src_pt_cmd-&gt;se_cmd;
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		/*
 		 * If the failure happened before the t_mem_list hand-off in
 		 * target_xcopy_setup_pt_cmd(), Reset memory + clear flag so that
<span class="p_chunk">@@ -729,6 +741,7 @@</span> <span class="p_context"> static int target_xcopy_write_destination(</span>
 
 	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		se_cmd-&gt;se_cmd_flags &amp;= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
<span class="p_chunk">@@ -815,9 +828,14 @@</span> <span class="p_context"> static void target_xcopy_do_work(struct work_struct *work)</span>
 out:
 	xcopy_pt_undepend_remotedev(xop);
 	kfree(xop);
<span class="p_del">-</span>
<span class="p_del">-	pr_warn(&quot;target_xcopy_do_work: Setting X-COPY CHECK_CONDITION -&gt; sending response\n&quot;);</span>
<span class="p_del">-	ec_cmd-&gt;scsi_status = SAM_STAT_CHECK_CONDITION;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t override an error scsi status if it has already been set</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ec_cmd-&gt;scsi_status == SAM_STAT_GOOD) {</span>
<span class="p_add">+		pr_warn_ratelimited(&quot;target_xcopy_do_work: rc: %d, Setting X-COPY&quot;</span>
<span class="p_add">+			&quot; CHECK_CONDITION -&gt; sending response\n&quot;, rc);</span>
<span class="p_add">+		ec_cmd-&gt;scsi_status = SAM_STAT_CHECK_CONDITION;</span>
<span class="p_add">+	}</span>
 	target_complete_cmd(ec_cmd, SAM_STAT_CHECK_CONDITION);
 }
 
<span class="p_chunk">@@ -875,7 +893,7 @@</span> <span class="p_context"> sense_reason_t target_do_xcopy(struct se_cmd *se_cmd)</span>
 		&quot; tdll: %hu sdll: %u inline_dl: %u\n&quot;, list_id, list_id_usage,
 		tdll, sdll, inline_dl);
 
<span class="p_del">-	rc = target_xcopy_parse_target_descriptors(se_cmd, xop, &amp;p[16], tdll);</span>
<span class="p_add">+	rc = target_xcopy_parse_target_descriptors(se_cmd, xop, &amp;p[16], tdll, &amp;ret);</span>
 	if (rc &lt;= 0)
 		goto out;
 
<span class="p_header">diff --git a/drivers/target/tcm_fc/tfc_cmd.c b/drivers/target/tcm_fc/tfc_cmd.c</span>
<span class="p_header">index 216e18cc9133..9a874a89941d 100644</span>
<span class="p_header">--- a/drivers/target/tcm_fc/tfc_cmd.c</span>
<span class="p_header">+++ b/drivers/target/tcm_fc/tfc_cmd.c</span>
<span class="p_chunk">@@ -572,7 +572,7 @@</span> <span class="p_context"> static void ft_send_work(struct work_struct *work)</span>
 	if (target_submit_cmd(&amp;cmd-&gt;se_cmd, cmd-&gt;sess-&gt;se_sess, fcp-&gt;fc_cdb,
 			      &amp;cmd-&gt;ft_sense_buffer[0], scsilun_to_int(&amp;fcp-&gt;fc_lun),
 			      ntohl(fcp-&gt;fc_dl), task_attr, data_dir,
<span class="p_del">-			      TARGET_SCF_ACK_KREF))</span>
<span class="p_add">+			      TARGET_SCF_ACK_KREF | TARGET_SCF_USE_CPUID))</span>
 		goto err;
 
 	pr_debug(&quot;r_ctl %x alloc target_submit_cmd\n&quot;, fh-&gt;fh_r_ctl);
<span class="p_header">diff --git a/drivers/video/fbdev/efifb.c b/drivers/video/fbdev/efifb.c</span>
<span class="p_header">index 924bad45c176..37a37c4d04cb 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/efifb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/efifb.c</span>
<span class="p_chunk">@@ -50,9 +50,9 @@</span> <span class="p_context"> static int efifb_setcolreg(unsigned regno, unsigned red, unsigned green,</span>
 		return 1;
 
 	if (regno &lt; 16) {
<span class="p_del">-		red   &gt;&gt;= 8;</span>
<span class="p_del">-		green &gt;&gt;= 8;</span>
<span class="p_del">-		blue  &gt;&gt;= 8;</span>
<span class="p_add">+		red   &gt;&gt;= 16 - info-&gt;var.red.length;</span>
<span class="p_add">+		green &gt;&gt;= 16 - info-&gt;var.green.length;</span>
<span class="p_add">+		blue  &gt;&gt;= 16 - info-&gt;var.blue.length;</span>
 		((u32 *)(info-&gt;pseudo_palette))[regno] =
 			(red   &lt;&lt; info-&gt;var.red.offset)   |
 			(green &lt;&lt; info-&gt;var.green.offset) |
<span class="p_header">diff --git a/drivers/watchdog/mt7621_wdt.c b/drivers/watchdog/mt7621_wdt.c</span>
<span class="p_header">index 4a2290f900a8..d5735c12067d 100644</span>
<span class="p_header">--- a/drivers/watchdog/mt7621_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/mt7621_wdt.c</span>
<span class="p_chunk">@@ -139,7 +139,6 @@</span> <span class="p_context"> static int mt7621_wdt_probe(struct platform_device *pdev)</span>
 	if (!IS_ERR(mt7621_wdt_reset))
 		reset_control_deassert(mt7621_wdt_reset);
 
<span class="p_del">-	mt7621_wdt_dev.dev = &amp;pdev-&gt;dev;</span>
 	mt7621_wdt_dev.bootstatus = mt7621_wdt_bootcause();
 
 	watchdog_init_timeout(&amp;mt7621_wdt_dev, mt7621_wdt_dev.max_timeout,
<span class="p_header">diff --git a/drivers/watchdog/rt2880_wdt.c b/drivers/watchdog/rt2880_wdt.c</span>
<span class="p_header">index 1967919ae743..14b4fd428fff 100644</span>
<span class="p_header">--- a/drivers/watchdog/rt2880_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/rt2880_wdt.c</span>
<span class="p_chunk">@@ -158,7 +158,6 @@</span> <span class="p_context"> static int rt288x_wdt_probe(struct platform_device *pdev)</span>
 
 	rt288x_wdt_freq = clk_get_rate(rt288x_wdt_clk) / RALINK_WDT_PRESCALE;
 
<span class="p_del">-	rt288x_wdt_dev.dev = &amp;pdev-&gt;dev;</span>
 	rt288x_wdt_dev.bootstatus = rt288x_wdt_bootcause();
 	rt288x_wdt_dev.max_timeout = (0xfffful / rt288x_wdt_freq);
 	rt288x_wdt_dev.parent = &amp;pdev-&gt;dev;
<span class="p_header">diff --git a/fs/ceph/file.c b/fs/ceph/file.c</span>
<span class="p_header">index 0f5375d8e030..eede975e85c0 100644</span>
<span class="p_header">--- a/fs/ceph/file.c</span>
<span class="p_header">+++ b/fs/ceph/file.c</span>
<span class="p_chunk">@@ -1272,7 +1272,8 @@</span> <span class="p_context"> again:</span>
 		statret = __ceph_do_getattr(inode, page,
 					    CEPH_STAT_CAP_INLINE_DATA, !!page);
 		if (statret &lt; 0) {
<span class="p_del">-			 __free_page(page);</span>
<span class="p_add">+			if (page)</span>
<span class="p_add">+				__free_page(page);</span>
 			if (statret == -ENODATA) {
 				BUG_ON(retry_op != READ_INLINE);
 				goto again;
<span class="p_header">diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c</span>
<span class="p_header">index 6c58e13fed2f..3d03e48a9213 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.c</span>
<span class="p_chunk">@@ -152,6 +152,7 @@</span> <span class="p_context"> static int cifs_debug_data_proc_show(struct seq_file *m, void *v)</span>
 	list_for_each(tmp1, &amp;cifs_tcp_ses_list) {
 		server = list_entry(tmp1, struct TCP_Server_Info,
 				    tcp_ses_list);
<span class="p_add">+		seq_printf(m, &quot;\nNumber of credits: %d&quot;, server-&gt;credits);</span>
 		i++;
 		list_for_each(tmp2, &amp;server-&gt;smb_ses_list) {
 			ses = list_entry(tmp2, struct cifs_ses,
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 14ae4b8e1a3c..8c68d03a6949 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> cifs_alloc_inode(struct super_block *sb)</span>
 	cifs_inode-&gt;createtime = 0;
 	cifs_inode-&gt;epoch = 0;
 #ifdef CONFIG_CIFS_SMB2
<span class="p_del">-	get_random_bytes(cifs_inode-&gt;lease_key, SMB2_LEASE_KEY_SIZE);</span>
<span class="p_add">+	generate_random_uuid(cifs_inode-&gt;lease_key);</span>
 #endif
 	/*
 	 * Can not set i_flags here - they get immediately overwritten to zero
<span class="p_chunk">@@ -1271,7 +1271,6 @@</span> <span class="p_context"> init_cifs(void)</span>
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
 	spin_lock_init(&amp;cifs_tcp_ses_lock);
<span class="p_del">-	spin_lock_init(&amp;cifs_file_list_lock);</span>
 	spin_lock_init(&amp;GlobalMid_Lock);
 
 	get_random_bytes(&amp;cifs_lock_secret, sizeof(cifs_lock_secret));
<span class="p_header">diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h</span>
<span class="p_header">index 8f1d8c1e72be..65f78b7a9062 100644</span>
<span class="p_header">--- a/fs/cifs/cifsglob.h</span>
<span class="p_header">+++ b/fs/cifs/cifsglob.h</span>
<span class="p_chunk">@@ -833,6 +833,7 @@</span> <span class="p_context"> struct cifs_tcon {</span>
 	struct list_head tcon_list;
 	int tc_count;
 	struct list_head openFileList;
<span class="p_add">+	spinlock_t open_file_lock; /* protects list above */</span>
 	struct cifs_ses *ses;	/* pointer to session associated with */
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
<span class="p_chunk">@@ -889,7 +890,7 @@</span> <span class="p_context"> struct cifs_tcon {</span>
 #endif /* CONFIG_CIFS_STATS2 */
 	__u64    bytes_read;
 	__u64    bytes_written;
<span class="p_del">-	spinlock_t stat_lock;</span>
<span class="p_add">+	spinlock_t stat_lock;  /* protects the two fields above */</span>
 #endif /* CONFIG_CIFS_STATS */
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
<span class="p_chunk">@@ -1040,8 +1041,10 @@</span> <span class="p_context"> struct cifs_fid_locks {</span>
 };
 
 struct cifsFileInfo {
<span class="p_add">+	/* following two lists are protected by tcon-&gt;open_file_lock */</span>
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
<span class="p_add">+	/* lock list below protected by cifsi-&gt;lock_sem */</span>
 	struct cifs_fid_locks *llist;	/* brlocks held by this fid */
 	kuid_t uid;		/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
<span class="p_chunk">@@ -1049,11 +1052,12 @@</span> <span class="p_context"> struct cifsFileInfo {</span>
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
 	struct dentry *dentry;
<span class="p_del">-	unsigned int f_flags;</span>
 	struct tcon_link *tlink;
<span class="p_add">+	unsigned int f_flags;</span>
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
<span class="p_del">-	int count;		/* refcount protected by cifs_file_list_lock */</span>
<span class="p_add">+	int count;</span>
<span class="p_add">+	spinlock_t file_info_lock; /* protects four flag/count fields above */</span>
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 	struct work_struct oplock_break; /* work for oplock breaks */
<span class="p_chunk">@@ -1120,7 +1124,7 @@</span> <span class="p_context"> struct cifs_writedata {</span>
 
 /*
  * Take a reference on the file private data. Must be called with
<span class="p_del">- * cifs_file_list_lock held.</span>
<span class="p_add">+ * cfile-&gt;file_info_lock held.</span>
  */
 static inline void
 cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
<span class="p_chunk">@@ -1514,8 +1518,10 @@</span> <span class="p_context"> require use of the stronger protocol */</span>
  *  GlobalMid_Lock protects:
  *	list operations on pending_mid_q and oplockQ
  *      updates to XID counters, multiplex id  and SMB sequence numbers
<span class="p_del">- *  cifs_file_list_lock protects:</span>
<span class="p_del">- *	list operations on tcp and SMB session lists and tCon lists</span>
<span class="p_add">+ *  tcp_ses_lock protects:</span>
<span class="p_add">+ *	list operations on tcp and SMB session lists</span>
<span class="p_add">+ *  tcon-&gt;open_file_lock protects the list of open files hanging off the tcon</span>
<span class="p_add">+ *  cfile-&gt;file_info_lock protects counters and fields in cifs file struct</span>
  *  f_owner.lock protects certain per file struct operations
  *  mapping-&gt;page_lock protects certain per page operations
  *
<span class="p_chunk">@@ -1547,18 +1553,12 @@</span> <span class="p_context"> GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;</span>
  * tcp session, and the list of tcon&#39;s per smb session. It also protects
  * the reference counters for the server, smb session, and tcon. Finally,
  * changes to the tcon-&gt;tidStatus should be done while holding this lock.
<span class="p_add">+ * generally the locks should be taken in order tcp_ses_lock before</span>
<span class="p_add">+ * tcon-&gt;open_file_lock and that before file-&gt;file_info_lock since the</span>
<span class="p_add">+ * structure order is cifs_socket--&gt;cifs_ses--&gt;cifs_tcon--&gt;cifs_file</span>
  */
 GLOBAL_EXTERN spinlock_t		cifs_tcp_ses_lock;
 
<span class="p_del">-/*</span>
<span class="p_del">- * This lock protects the cifs_file-&gt;llist and cifs_file-&gt;flist</span>
<span class="p_del">- * list operations, and updates to some flags (cifs_file-&gt;invalidHandle)</span>
<span class="p_del">- * It will be moved to either use the tcon-&gt;stat_lock or equivalent later.</span>
<span class="p_del">- * If cifs_tcp_ses_lock and the lock below are both needed to be held, then</span>
<span class="p_del">- * the cifs_tcp_ses_lock must be grabbed first and released last.</span>
<span class="p_del">- */</span>
<span class="p_del">-GLOBAL_EXTERN spinlock_t	cifs_file_list_lock;</span>
<span class="p_del">-</span>
 #ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;
<span class="p_header">diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c</span>
<span class="p_header">index d47197ea4ab6..78046051bbbc 100644</span>
<span class="p_header">--- a/fs/cifs/cifssmb.c</span>
<span class="p_header">+++ b/fs/cifs/cifssmb.c</span>
<span class="p_chunk">@@ -98,13 +98,13 @@</span> <span class="p_context"> cifs_mark_open_files_invalid(struct cifs_tcon *tcon)</span>
 	struct list_head *tmp1;
 
 	/* list all files open on tree connection and mark them invalid */
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	list_for_each_safe(tmp, tmp1, &amp;tcon-&gt;openFileList) {
 		open_file = list_entry(tmp, struct cifsFileInfo, tlist);
 		open_file-&gt;invalidHandle = true;
 		open_file-&gt;oplock_break_cancelled = true;
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	/*
 	 * BB Add call to invalidate_inodes(sb) for all superblocks mounted
 	 * to this tcon.
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 2e4f4bad8b1e..7b67179521cf 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -2163,7 +2163,7 @@</span> <span class="p_context"> cifs_get_tcp_session(struct smb_vol *volume_info)</span>
 	memcpy(&amp;tcp_ses-&gt;dstaddr, &amp;volume_info-&gt;dstaddr,
 		sizeof(tcp_ses-&gt;dstaddr));
 #ifdef CONFIG_CIFS_SMB2
<span class="p_del">-	get_random_bytes(tcp_ses-&gt;client_guid, SMB2_CLIENT_GUID_SIZE);</span>
<span class="p_add">+	generate_random_uuid(tcp_ses-&gt;client_guid);</span>
 #endif
 	/*
 	 * at this point we are the only ones with the pointer
<span class="p_chunk">@@ -3688,14 +3688,16 @@</span> <span class="p_context"> remote_path_check:</span>
 			goto mount_fail_check;
 		}
 
<span class="p_del">-		rc = cifs_are_all_path_components_accessible(server,</span>
<span class="p_add">+		if (rc != -EREMOTE) {</span>
<span class="p_add">+			rc = cifs_are_all_path_components_accessible(server,</span>
 							     xid, tcon, cifs_sb,
 							     full_path);
<span class="p_del">-		if (rc != 0) {</span>
<span class="p_del">-			cifs_dbg(VFS, &quot;cannot query dirs between root and final path, &quot;</span>
<span class="p_del">-				 &quot;enabling CIFS_MOUNT_USE_PREFIX_PATH\n&quot;);</span>
<span class="p_del">-			cifs_sb-&gt;mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_del">-			rc = 0;</span>
<span class="p_add">+			if (rc != 0) {</span>
<span class="p_add">+				cifs_dbg(VFS, &quot;cannot query dirs between root and final path, &quot;</span>
<span class="p_add">+					 &quot;enabling CIFS_MOUNT_USE_PREFIX_PATH\n&quot;);</span>
<span class="p_add">+				cifs_sb-&gt;mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_add">+				rc = 0;</span>
<span class="p_add">+			}</span>
 		}
 		kfree(full_path);
 	}
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 579e41b350a2..605438afe7ef 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -305,6 +305,7 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 	cfile-&gt;tlink = cifs_get_tlink(tlink);
 	INIT_WORK(&amp;cfile-&gt;oplock_break, cifs_oplock_break);
 	mutex_init(&amp;cfile-&gt;fh_mutex);
<span class="p_add">+	spin_lock_init(&amp;cfile-&gt;file_info_lock);</span>
 
 	cifs_sb_active(inode-&gt;i_sb);
 
<span class="p_chunk">@@ -317,7 +318,7 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 		oplock = 0;
 	}
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	if (fid-&gt;pending_open-&gt;oplock != CIFS_OPLOCK_NO_CHANGE &amp;&amp; oplock)
 		oplock = fid-&gt;pending_open-&gt;oplock;
 	list_del(&amp;fid-&gt;pending_open-&gt;olist);
<span class="p_chunk">@@ -326,12 +327,13 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 	server-&gt;ops-&gt;set_fid(cfile, fid, oplock);
 
 	list_add(&amp;cfile-&gt;tlist, &amp;tcon-&gt;openFileList);
<span class="p_add">+</span>
 	/* if readable file instance put first in list*/
 	if (file-&gt;f_mode &amp; FMODE_READ)
 		list_add(&amp;cfile-&gt;flist, &amp;cinode-&gt;openFileList);
 	else
 		list_add_tail(&amp;cfile-&gt;flist, &amp;cinode-&gt;openFileList);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	if (fid-&gt;purge_cache)
 		cifs_zap_mapping(inode);
<span class="p_chunk">@@ -343,16 +345,16 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 struct cifsFileInfo *
 cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;cifs_file-&gt;file_info_lock);</span>
 	cifsFileInfo_get_locked(cifs_file);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
 	return cifs_file;
 }
 
 /*
  * Release a reference on the file private data. This may involve closing
  * the filehandle out on the server. Must be called without holding
<span class="p_del">- * cifs_file_list_lock.</span>
<span class="p_add">+ * tcon-&gt;open_file_lock and cifs_file-&gt;file_info_lock.</span>
  */
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
<span class="p_chunk">@@ -367,11 +369,15 @@</span> <span class="p_context"> void cifsFileInfo_put(struct cifsFileInfo *cifs_file)</span>
 	struct cifs_pending_open open;
 	bool oplock_break_cancelled;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;cifs_file-&gt;file_info_lock);</span>
 	if (--cifs_file-&gt;count &gt; 0) {
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
<span class="p_add">+		spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 		return;
 	}
<span class="p_add">+	spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
 
 	if (server-&gt;ops-&gt;get_lease_key)
 		server-&gt;ops-&gt;get_lease_key(inode, &amp;fid);
<span class="p_chunk">@@ -395,7 +401,8 @@</span> <span class="p_context"> void cifsFileInfo_put(struct cifsFileInfo *cifs_file)</span>
 			set_bit(CIFS_INO_INVALID_MAPPING, &amp;cifsi-&gt;flags);
 		cifs_set_oplock_level(cifsi, 0);
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	oplock_break_cancelled = cancel_work_sync(&amp;cifs_file-&gt;oplock_break);
 
<span class="p_chunk">@@ -772,10 +779,10 @@</span> <span class="p_context"> int cifs_closedir(struct inode *inode, struct file *file)</span>
 	server = tcon-&gt;ses-&gt;server;
 
 	cifs_dbg(FYI, &quot;Freeing private data in close dir\n&quot;);
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 	if (server-&gt;ops-&gt;dir_needs_close(cfile)) {
 		cfile-&gt;invalidHandle = true;
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 		if (server-&gt;ops-&gt;close_dir)
 			rc = server-&gt;ops-&gt;close_dir(xid, tcon, &amp;cfile-&gt;fid);
 		else
<span class="p_chunk">@@ -784,7 +791,7 @@</span> <span class="p_context"> int cifs_closedir(struct inode *inode, struct file *file)</span>
 		/* not much we can do if it fails anyway, ignore rc */
 		rc = 0;
 	} else
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 
 	buf = cfile-&gt;srch_inf.ntwrk_buf_start;
 	if (buf) {
<span class="p_chunk">@@ -1728,12 +1735,13 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 {
 	struct cifsFileInfo *open_file = NULL;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb);
<span class="p_add">+	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);</span>
 
 	/* only filter by fsuid on multiuser mounts */
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER))
 		fsuid_only = false;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	/* we could simply get the first_list_entry since write-only entries
 	   are always at the end of the list but since the first entry might
 	   have a close pending, we go through the whole list */
<span class="p_chunk">@@ -1744,8 +1752,8 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 			if (!open_file-&gt;invalidHandle) {
 				/* found a good file */
 				/* lock it so it will not be closed on us */
<span class="p_del">-				cifsFileInfo_get_locked(open_file);</span>
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				cifsFileInfo_get(open_file);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				return open_file;
 			} /* else might as well continue, and look for
 			     another, or simply have the caller reopen it
<span class="p_chunk">@@ -1753,7 +1761,7 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 		} else /* write only file */
 			break; /* write only files are last so must be done */
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	return NULL;
 }
 
<span class="p_chunk">@@ -1762,6 +1770,7 @@</span> <span class="p_context"> struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,</span>
 {
 	struct cifsFileInfo *open_file, *inv_file = NULL;
 	struct cifs_sb_info *cifs_sb;
<span class="p_add">+	struct cifs_tcon *tcon;</span>
 	bool any_available = false;
 	int rc;
 	unsigned int refind = 0;
<span class="p_chunk">@@ -1777,15 +1786,16 @@</span> <span class="p_context"> struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,</span>
 	}
 
 	cifs_sb = CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb);
<span class="p_add">+	tcon = cifs_sb_master_tcon(cifs_sb);</span>
 
 	/* only filter by fsuid on multiuser mounts */
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER))
 		fsuid_only = false;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 refind_writable:
 	if (refind &gt; MAX_REOPEN_ATT) {
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 		return NULL;
 	}
 	list_for_each_entry(open_file, &amp;cifs_inode-&gt;openFileList, flist) {
<span class="p_chunk">@@ -1796,8 +1806,8 @@</span> <span class="p_context"> refind_writable:</span>
 		if (OPEN_FMODE(open_file-&gt;f_flags) &amp; FMODE_WRITE) {
 			if (!open_file-&gt;invalidHandle) {
 				/* found a good writable file */
<span class="p_del">-				cifsFileInfo_get_locked(open_file);</span>
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				cifsFileInfo_get(open_file);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				return open_file;
 			} else {
 				if (!inv_file)
<span class="p_chunk">@@ -1813,24 +1823,24 @@</span> <span class="p_context"> refind_writable:</span>
 
 	if (inv_file) {
 		any_available = false;
<span class="p_del">-		cifsFileInfo_get_locked(inv_file);</span>
<span class="p_add">+		cifsFileInfo_get(inv_file);</span>
 	}
 
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	if (inv_file) {
 		rc = cifs_reopen_file(inv_file, false);
 		if (!rc)
 			return inv_file;
 		else {
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_move_tail(&amp;inv_file-&gt;flist,
 					&amp;cifs_inode-&gt;openFileList);
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			cifsFileInfo_put(inv_file);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
 			++refind;
 			inv_file = NULL;
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			goto refind_writable;
 		}
 	}
<span class="p_chunk">@@ -3618,15 +3628,17 @@</span> <span class="p_context"> static int cifs_readpage(struct file *file, struct page *page)</span>
 static int is_inode_writable(struct cifsInodeInfo *cifs_inode)
 {
 	struct cifsFileInfo *open_file;
<span class="p_add">+	struct cifs_tcon *tcon =</span>
<span class="p_add">+		cifs_sb_master_tcon(CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb));</span>
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	list_for_each_entry(open_file, &amp;cifs_inode-&gt;openFileList, flist) {
 		if (OPEN_FMODE(open_file-&gt;f_flags) &amp; FMODE_WRITE) {
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			return 1;
 		}
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c</span>
<span class="p_header">index 813fe13c2ae1..c6729156f9a0 100644</span>
<span class="p_header">--- a/fs/cifs/misc.c</span>
<span class="p_header">+++ b/fs/cifs/misc.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> tconInfoAlloc(void)</span>
 		++ret_buf-&gt;tc_count;
 		INIT_LIST_HEAD(&amp;ret_buf-&gt;openFileList);
 		INIT_LIST_HEAD(&amp;ret_buf-&gt;tcon_list);
<span class="p_add">+		spin_lock_init(&amp;ret_buf-&gt;open_file_lock);</span>
 #ifdef CONFIG_CIFS_STATS
 		spin_lock_init(&amp;ret_buf-&gt;stat_lock);
 #endif
<span class="p_chunk">@@ -465,7 +466,7 @@</span> <span class="p_context"> is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)</span>
 				continue;
 
 			cifs_stats_inc(&amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_for_each(tmp2, &amp;tcon-&gt;openFileList) {
 				netfile = list_entry(tmp2, struct cifsFileInfo,
 						     tlist);
<span class="p_chunk">@@ -495,11 +496,11 @@</span> <span class="p_context"> is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)</span>
 					   &amp;netfile-&gt;oplock_break);
 				netfile-&gt;oplock_break_cancelled = false;
 
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				spin_unlock(&amp;cifs_tcp_ses_lock);
 				return true;
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			spin_unlock(&amp;cifs_tcp_ses_lock);
 			cifs_dbg(FYI, &quot;No matching file for oplock break\n&quot;);
 			return true;
<span class="p_chunk">@@ -613,9 +614,9 @@</span> <span class="p_context"> backup_cred(struct cifs_sb_info *cifs_sb)</span>
 void
 cifs_del_pending_open(struct cifs_pending_open *open)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 	list_del(&amp;open-&gt;olist);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 }
 
 void
<span class="p_chunk">@@ -635,7 +636,7 @@</span> <span class="p_context"> void</span>
 cifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,
 		      struct cifs_pending_open *open)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tlink_tcon(tlink)-&gt;open_file_lock);</span>
 	cifs_add_pending_open_locked(fid, tlink, open);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 }
<span class="p_header">diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c</span>
<span class="p_header">index 65cf85dcda09..8f6a2a5863b9 100644</span>
<span class="p_header">--- a/fs/cifs/readdir.c</span>
<span class="p_header">+++ b/fs/cifs/readdir.c</span>
<span class="p_chunk">@@ -597,14 +597,14 @@</span> <span class="p_context"> find_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,</span>
 	     is_dir_changed(file)) || (index_to_find &lt; first_entry_in_buffer)) {
 		/* close and restart search */
 		cifs_dbg(FYI, &quot;search backing up - close and restart search\n&quot;);
<span class="p_del">-		spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 		if (server-&gt;ops-&gt;dir_needs_close(cfile)) {
 			cfile-&gt;invalidHandle = true;
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 			if (server-&gt;ops-&gt;close_dir)
 				server-&gt;ops-&gt;close_dir(xid, tcon, &amp;cfile-&gt;fid);
 		} else
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 		if (cfile-&gt;srch_inf.ntwrk_buf_start) {
 			cifs_dbg(FYI, &quot;freeing SMB ff cache buf on search rewind\n&quot;);
 			if (cfile-&gt;srch_inf.smallBuf)
<span class="p_header">diff --git a/fs/cifs/smb2glob.h b/fs/cifs/smb2glob.h</span>
<span class="p_header">index 0ffa18094335..238759c146ba 100644</span>
<span class="p_header">--- a/fs/cifs/smb2glob.h</span>
<span class="p_header">+++ b/fs/cifs/smb2glob.h</span>
<span class="p_chunk">@@ -61,4 +61,14 @@</span> <span class="p_context"></span>
 /* Maximum buffer size value we can send with 1 credit */
 #define SMB2_MAX_BUFFER_SIZE 65536
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Maximum number of credits to keep available.</span>
<span class="p_add">+ * This value is chosen somewhat arbitrarily. The Windows client</span>
<span class="p_add">+ * defaults to 128 credits, the Windows server allows clients up to</span>
<span class="p_add">+ * 512 credits, and the NetApp server does not limit clients at all.</span>
<span class="p_add">+ * Choose a high enough value such that the client shouldn&#39;t limit</span>
<span class="p_add">+ * performance.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SMB2_MAX_CREDITS_AVAILABLE 32000</span>
<span class="p_add">+</span>
 #endif	/* _SMB2_GLOB_H */
<span class="p_header">diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c</span>
<span class="p_header">index 4f0231e685a9..1238cd3552f9 100644</span>
<span class="p_header">--- a/fs/cifs/smb2inode.c</span>
<span class="p_header">+++ b/fs/cifs/smb2inode.c</span>
<span class="p_chunk">@@ -266,9 +266,15 @@</span> <span class="p_context"> smb2_set_file_info(struct inode *inode, const char *full_path,</span>
 	struct tcon_link *tlink;
 	int rc;
 
<span class="p_add">+	if ((buf-&gt;CreationTime == 0) &amp;&amp; (buf-&gt;LastAccessTime == 0) &amp;&amp;</span>
<span class="p_add">+	    (buf-&gt;LastWriteTime == 0) &amp;&amp; (buf-&gt;ChangeTime) &amp;&amp;</span>
<span class="p_add">+	    (buf-&gt;Attributes == 0))</span>
<span class="p_add">+		return 0; /* would be a no op, no sense sending this */</span>
<span class="p_add">+</span>
 	tlink = cifs_sb_tlink(cifs_sb);
 	if (IS_ERR(tlink))
 		return PTR_ERR(tlink);
<span class="p_add">+</span>
 	rc = smb2_open_op_close(xid, tlink_tcon(tlink), cifs_sb, full_path,
 				FILE_WRITE_ATTRIBUTES, FILE_OPEN, 0, buf,
 				SMB2_OP_SET_INFO);
<span class="p_header">diff --git a/fs/cifs/smb2misc.c b/fs/cifs/smb2misc.c</span>
<span class="p_header">index 389fb9f8c84e..3d383489b9cf 100644</span>
<span class="p_header">--- a/fs/cifs/smb2misc.c</span>
<span class="p_header">+++ b/fs/cifs/smb2misc.c</span>
<span class="p_chunk">@@ -549,19 +549,19 @@</span> <span class="p_context"> smb2_is_valid_lease_break(char *buffer)</span>
 		list_for_each(tmp1, &amp;server-&gt;smb_ses_list) {
 			ses = list_entry(tmp1, struct cifs_ses, smb_ses_list);
 
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
 			list_for_each(tmp2, &amp;ses-&gt;tcon_list) {
 				tcon = list_entry(tmp2, struct cifs_tcon,
 						  tcon_list);
<span class="p_add">+				spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 				cifs_stats_inc(
 				    &amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
 				if (smb2_tcon_has_lease(tcon, rsp, lw)) {
<span class="p_del">-					spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+					spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 					spin_unlock(&amp;cifs_tcp_ses_lock);
 					return true;
 				}
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
 		}
 	}
 	spin_unlock(&amp;cifs_tcp_ses_lock);
<span class="p_chunk">@@ -603,7 +603,7 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 			tcon = list_entry(tmp1, struct cifs_tcon, tcon_list);
 
 			cifs_stats_inc(&amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_for_each(tmp2, &amp;tcon-&gt;openFileList) {
 				cfile = list_entry(tmp2, struct cifsFileInfo,
 						     tlist);
<span class="p_chunk">@@ -615,7 +615,7 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 
 				cifs_dbg(FYI, &quot;file id match, oplock break\n&quot;);
 				cinode = CIFS_I(d_inode(cfile-&gt;dentry));
<span class="p_del">-</span>
<span class="p_add">+				spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 				if (!CIFS_CACHE_WRITE(cinode) &amp;&amp;
 				    rsp-&gt;OplockLevel == SMB2_OPLOCK_LEVEL_NONE)
 					cfile-&gt;oplock_break_cancelled = true;
<span class="p_chunk">@@ -637,14 +637,14 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 					clear_bit(
 					   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,
 					   &amp;cinode-&gt;flags);
<span class="p_del">-</span>
<span class="p_add">+				spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 				queue_work(cifsiod_wq, &amp;cfile-&gt;oplock_break);
 
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				spin_unlock(&amp;cifs_tcp_ses_lock);
 				return true;
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			spin_unlock(&amp;cifs_tcp_ses_lock);
 			cifs_dbg(FYI, &quot;No matching file for oplock break\n&quot;);
 			return true;
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index d203c0329626..0e73cefca65e 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -287,7 +287,7 @@</span> <span class="p_context"> SMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)</span>
 		cifs_dbg(FYI, &quot;Link Speed %lld\n&quot;,
 			le64_to_cpu(out_buf-&gt;LinkSpeed));
 	}
<span class="p_del">-</span>
<span class="p_add">+	kfree(out_buf);</span>
 	return rc;
 }
 #endif /* STATS2 */
<span class="p_chunk">@@ -541,6 +541,7 @@</span> <span class="p_context"> smb2_set_fid(struct cifsFileInfo *cfile, struct cifs_fid *fid, __u32 oplock)</span>
 	server-&gt;ops-&gt;set_oplock_level(cinode, oplock, fid-&gt;epoch,
 				      &amp;fid-&gt;purge_cache);
 	cinode-&gt;can_cache_brlcks = CIFS_CACHE_WRITE(cinode);
<span class="p_add">+	memcpy(cfile-&gt;fid.create_guid, fid-&gt;create_guid, 16);</span>
 }
 
 static void
<span class="p_chunk">@@ -699,6 +700,7 @@</span> <span class="p_context"> smb2_clone_range(const unsigned int xid,</span>
 
 cchunk_out:
 	kfree(pcchunk);
<span class="p_add">+	kfree(retbuf);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -823,7 +825,6 @@</span> <span class="p_context"> smb2_duplicate_extents(const unsigned int xid,</span>
 {
 	int rc;
 	unsigned int ret_data_len;
<span class="p_del">-	char *retbuf = NULL;</span>
 	struct duplicate_extents_to_file dup_ext_buf;
 	struct cifs_tcon *tcon = tlink_tcon(trgtfile-&gt;tlink);
 
<span class="p_chunk">@@ -849,7 +850,7 @@</span> <span class="p_context"> smb2_duplicate_extents(const unsigned int xid,</span>
 			FSCTL_DUPLICATE_EXTENTS_TO_FILE,
 			true /* is_fsctl */, (char *)&amp;dup_ext_buf,
 			sizeof(struct duplicate_extents_to_file),
<span class="p_del">-			(char **)&amp;retbuf,</span>
<span class="p_add">+			NULL,</span>
 			&amp;ret_data_len);
 
 	if (ret_data_len &gt; 0)
<span class="p_chunk">@@ -872,7 +873,6 @@</span> <span class="p_context"> smb3_set_integrity(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		   struct cifsFileInfo *cfile)
 {
 	struct fsctl_set_integrity_information_req integr_info;
<span class="p_del">-	char *retbuf = NULL;</span>
 	unsigned int ret_data_len;
 
 	integr_info.ChecksumAlgorithm = cpu_to_le16(CHECKSUM_TYPE_UNCHANGED);
<span class="p_chunk">@@ -884,7 +884,7 @@</span> <span class="p_context"> smb3_set_integrity(const unsigned int xid, struct cifs_tcon *tcon,</span>
 			FSCTL_SET_INTEGRITY_INFORMATION,
 			true /* is_fsctl */, (char *)&amp;integr_info,
 			sizeof(struct fsctl_set_integrity_information_req),
<span class="p_del">-			(char **)&amp;retbuf,</span>
<span class="p_add">+			NULL,</span>
 			&amp;ret_data_len);
 
 }
<span class="p_chunk">@@ -1041,7 +1041,7 @@</span> <span class="p_context"> smb2_set_lease_key(struct inode *inode, struct cifs_fid *fid)</span>
 static void
 smb2_new_lease_key(struct cifs_fid *fid)
 {
<span class="p_del">-	get_random_bytes(fid-&gt;lease_key, SMB2_LEASE_KEY_SIZE);</span>
<span class="p_add">+	generate_random_uuid(fid-&gt;lease_key);</span>
 }
 
 #define SMB2_SYMLINK_STRUCT_SIZE \
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 29e06db5f187..3eec96ca87d9 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -100,7 +100,21 @@</span> <span class="p_context"> smb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd /* command */ ,</span>
 	hdr-&gt;ProtocolId = SMB2_PROTO_NUMBER;
 	hdr-&gt;StructureSize = cpu_to_le16(64);
 	hdr-&gt;Command = smb2_cmd;
<span class="p_del">-	hdr-&gt;CreditRequest = cpu_to_le16(2); /* BB make this dynamic */</span>
<span class="p_add">+	if (tcon &amp;&amp; tcon-&gt;ses &amp;&amp; tcon-&gt;ses-&gt;server) {</span>
<span class="p_add">+		struct TCP_Server_Info *server = tcon-&gt;ses-&gt;server;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;server-&gt;req_lock);</span>
<span class="p_add">+		/* Request up to 2 credits but don&#39;t go over the limit. */</span>
<span class="p_add">+		if (server-&gt;credits &gt;= SMB2_MAX_CREDITS_AVAILABLE)</span>
<span class="p_add">+			hdr-&gt;CreditRequest = cpu_to_le16(0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			hdr-&gt;CreditRequest = cpu_to_le16(</span>
<span class="p_add">+				min_t(int, SMB2_MAX_CREDITS_AVAILABLE -</span>
<span class="p_add">+						server-&gt;credits, 2));</span>
<span class="p_add">+		spin_unlock(&amp;server-&gt;req_lock);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hdr-&gt;CreditRequest = cpu_to_le16(2);</span>
<span class="p_add">+	}</span>
 	hdr-&gt;ProcessId = cpu_to_le32((__u16)current-&gt;tgid);
 
 	if (!tcon)
<span class="p_chunk">@@ -590,6 +604,7 @@</span> <span class="p_context"> SMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,</span>
 	char *security_blob = NULL;
 	unsigned char *ntlmssp_blob = NULL;
 	bool use_spnego = false; /* else use raw ntlmssp */
<span class="p_add">+	u64 previous_session = ses-&gt;Suid;</span>
 
 	cifs_dbg(FYI, &quot;Session Setup\n&quot;);
 
<span class="p_chunk">@@ -627,6 +642,10 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 		return rc;
 
 	req-&gt;hdr.SessionId = 0; /* First session, not a reauthenticate */
<span class="p_add">+</span>
<span class="p_add">+	/* if reconnect, we need to send previous sess id, otherwise it is 0 */</span>
<span class="p_add">+	req-&gt;PreviousSessionId = previous_session;</span>
<span class="p_add">+</span>
 	req-&gt;Flags = 0; /* MBZ */
 	/* to enable echos and oplocks */
 	req-&gt;hdr.CreditRequest = cpu_to_le16(3);
<span class="p_chunk">@@ -1164,7 +1183,7 @@</span> <span class="p_context"> create_durable_v2_buf(struct cifs_fid *pfid)</span>
 
 	buf-&gt;dcontext.Timeout = 0; /* Should this be configurable by workload */
 	buf-&gt;dcontext.Flags = cpu_to_le32(SMB2_DHANDLE_FLAG_PERSISTENT);
<span class="p_del">-	get_random_bytes(buf-&gt;dcontext.CreateGuid, 16);</span>
<span class="p_add">+	generate_random_uuid(buf-&gt;dcontext.CreateGuid);</span>
 	memcpy(pfid-&gt;create_guid, buf-&gt;dcontext.CreateGuid, 16);
 
 	/* SMB2_CREATE_DURABLE_HANDLE_REQUEST is &quot;DH2Q&quot; */
<span class="p_chunk">@@ -2057,6 +2076,7 @@</span> <span class="p_context"> smb2_async_readv(struct cifs_readdata *rdata)</span>
 	if (rdata-&gt;credits) {
 		buf-&gt;CreditCharge = cpu_to_le16(DIV_ROUND_UP(rdata-&gt;bytes,
 						SMB2_MAX_BUFFER_SIZE));
<span class="p_add">+		buf-&gt;CreditRequest = buf-&gt;CreditCharge;</span>
 		spin_lock(&amp;server-&gt;req_lock);
 		server-&gt;credits += rdata-&gt;credits -
 						le16_to_cpu(buf-&gt;CreditCharge);
<span class="p_chunk">@@ -2243,6 +2263,7 @@</span> <span class="p_context"> smb2_async_writev(struct cifs_writedata *wdata,</span>
 	if (wdata-&gt;credits) {
 		req-&gt;hdr.CreditCharge = cpu_to_le16(DIV_ROUND_UP(wdata-&gt;bytes,
 						    SMB2_MAX_BUFFER_SIZE));
<span class="p_add">+		req-&gt;hdr.CreditRequest = req-&gt;hdr.CreditCharge;</span>
 		spin_lock(&amp;server-&gt;req_lock);
 		server-&gt;credits += wdata-&gt;credits -
 					le16_to_cpu(req-&gt;hdr.CreditCharge);
<span class="p_header">diff --git a/fs/cifs/smb2pdu.h b/fs/cifs/smb2pdu.h</span>
<span class="p_header">index ff88d9feb01e..fd3709e8de33 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.h</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.h</span>
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> struct smb2_sess_setup_req {</span>
 	__le32 Channel;
 	__le16 SecurityBufferOffset;
 	__le16 SecurityBufferLength;
<span class="p_del">-	__le64 PreviousSessionId;</span>
<span class="p_add">+	__u64 PreviousSessionId;</span>
 	__u8   Buffer[1];	/* variable length GSS security buffer */
 } __packed;
 
<span class="p_header">diff --git a/fs/crypto/crypto.c b/fs/crypto/crypto.c</span>
<span class="p_header">index c502c116924c..55d64fba1e87 100644</span>
<span class="p_header">--- a/fs/crypto/crypto.c</span>
<span class="p_header">+++ b/fs/crypto/crypto.c</span>
<span class="p_chunk">@@ -152,7 +152,10 @@</span> <span class="p_context"> static int do_page_crypto(struct inode *inode,</span>
 			struct page *src_page, struct page *dest_page,
 			gfp_t gfp_flags)
 {
<span class="p_del">-	u8 xts_tweak[FS_XTS_TWEAK_SIZE];</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		__le64 index;</span>
<span class="p_add">+		u8 padding[FS_XTS_TWEAK_SIZE - sizeof(__le64)];</span>
<span class="p_add">+	} xts_tweak;</span>
 	struct skcipher_request *req = NULL;
 	DECLARE_FS_COMPLETION_RESULT(ecr);
 	struct scatterlist dst, src;
<span class="p_chunk">@@ -172,17 +175,15 @@</span> <span class="p_context"> static int do_page_crypto(struct inode *inode,</span>
 		req, CRYPTO_TFM_REQ_MAY_BACKLOG | CRYPTO_TFM_REQ_MAY_SLEEP,
 		fscrypt_complete, &amp;ecr);
 
<span class="p_del">-	BUILD_BUG_ON(FS_XTS_TWEAK_SIZE &lt; sizeof(index));</span>
<span class="p_del">-	memcpy(xts_tweak, &amp;index, sizeof(index));</span>
<span class="p_del">-	memset(&amp;xts_tweak[sizeof(index)], 0,</span>
<span class="p_del">-			FS_XTS_TWEAK_SIZE - sizeof(index));</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(xts_tweak) != FS_XTS_TWEAK_SIZE);</span>
<span class="p_add">+	xts_tweak.index = cpu_to_le64(index);</span>
<span class="p_add">+	memset(xts_tweak.padding, 0, sizeof(xts_tweak.padding));</span>
 
 	sg_init_table(&amp;dst, 1);
 	sg_set_page(&amp;dst, dest_page, PAGE_SIZE, 0);
 	sg_init_table(&amp;src, 1);
 	sg_set_page(&amp;src, src_page, PAGE_SIZE, 0);
<span class="p_del">-	skcipher_request_set_crypt(req, &amp;src, &amp;dst, PAGE_SIZE,</span>
<span class="p_del">-					xts_tweak);</span>
<span class="p_add">+	skcipher_request_set_crypt(req, &amp;src, &amp;dst, PAGE_SIZE, &amp;xts_tweak);</span>
 	if (rw == FS_DECRYPT)
 		res = crypto_skcipher_decrypt(req);
 	else
<span class="p_header">diff --git a/fs/crypto/policy.c b/fs/crypto/policy.c</span>
<span class="p_header">index ed115acb5dee..6865663aac69 100644</span>
<span class="p_header">--- a/fs/crypto/policy.c</span>
<span class="p_header">+++ b/fs/crypto/policy.c</span>
<span class="p_chunk">@@ -109,6 +109,8 @@</span> <span class="p_context"> int fscrypt_process_policy(struct file *filp,</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	inode_lock(inode);</span>
<span class="p_add">+</span>
 	if (!inode_has_encryption_context(inode)) {
 		if (!S_ISDIR(inode-&gt;i_mode))
 			ret = -EINVAL;
<span class="p_chunk">@@ -127,6 +129,8 @@</span> <span class="p_context"> int fscrypt_process_policy(struct file *filp,</span>
 		ret = -EINVAL;
 	}
 
<span class="p_add">+	inode_unlock(inode);</span>
<span class="p_add">+</span>
 	mnt_drop_write_file(filp);
 	return ret;
 }
<span class="p_header">diff --git a/fs/ext4/sysfs.c b/fs/ext4/sysfs.c</span>
<span class="p_header">index 73bcfd41f5f2..42145be5c6b4 100644</span>
<span class="p_header">--- a/fs/ext4/sysfs.c</span>
<span class="p_header">+++ b/fs/ext4/sysfs.c</span>
<span class="p_chunk">@@ -223,14 +223,18 @@</span> <span class="p_context"> static struct attribute *ext4_attrs[] = {</span>
 EXT4_ATTR_FEATURE(lazy_itable_init);
 EXT4_ATTR_FEATURE(batched_discard);
 EXT4_ATTR_FEATURE(meta_bg_resize);
<span class="p_add">+#ifdef CONFIG_EXT4_FS_ENCRYPTION</span>
 EXT4_ATTR_FEATURE(encryption);
<span class="p_add">+#endif</span>
 EXT4_ATTR_FEATURE(metadata_csum_seed);
 
 static struct attribute *ext4_feat_attrs[] = {
 	ATTR_LIST(lazy_itable_init),
 	ATTR_LIST(batched_discard),
 	ATTR_LIST(meta_bg_resize),
<span class="p_add">+#ifdef CONFIG_EXT4_FS_ENCRYPTION</span>
 	ATTR_LIST(encryption),
<span class="p_add">+#endif</span>
 	ATTR_LIST(metadata_csum_seed),
 	NULL,
 };
<span class="p_header">diff --git a/fs/isofs/inode.c b/fs/isofs/inode.c</span>
<span class="p_header">index ad0c745ebad7..871c8b392099 100644</span>
<span class="p_header">--- a/fs/isofs/inode.c</span>
<span class="p_header">+++ b/fs/isofs/inode.c</span>
<span class="p_chunk">@@ -687,6 +687,11 @@</span> <span class="p_context"> static int isofs_fill_super(struct super_block *s, void *data, int silent)</span>
 	pri_bh = NULL;
 
 root_found:
<span class="p_add">+	/* We don&#39;t support read-write mounts */</span>
<span class="p_add">+	if (!(s-&gt;s_flags &amp; MS_RDONLY)) {</span>
<span class="p_add">+		error = -EACCES;</span>
<span class="p_add">+		goto out_freebh;</span>
<span class="p_add">+	}</span>
 
 	if (joliet_level &amp;&amp; (pri == NULL || !opt.rock)) {
 		/* This is the case of Joliet with the norock mount flag.
<span class="p_chunk">@@ -1501,9 +1506,6 @@</span> <span class="p_context"> struct inode *__isofs_iget(struct super_block *sb,</span>
 static struct dentry *isofs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
<span class="p_del">-	/* We don&#39;t support read-write mounts */</span>
<span class="p_del">-	if (!(flags &amp; MS_RDONLY))</span>
<span class="p_del">-		return ERR_PTR(-EACCES);</span>
 	return mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);
 }
 
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 3d8246a9faa4..e1652665bd93 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -1149,6 +1149,7 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 		JBUFFER_TRACE(jh, &quot;file as BJ_Reserved&quot;);
 		spin_lock(&amp;journal-&gt;j_list_lock);
 		__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	} else if (jh-&gt;b_transaction == journal-&gt;j_committing_transaction) {
 		/* first access by this transaction */
 		jh-&gt;b_modified = 0;
<span class="p_chunk">@@ -1156,8 +1157,8 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 		JBUFFER_TRACE(jh, &quot;set next transaction&quot;);
 		spin_lock(&amp;journal-&gt;j_list_lock);
 		jh-&gt;b_next_transaction = transaction;
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	}
<span class="p_del">-	spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	jbd_unlock_bh_state(bh);
 
 	/*
<span class="p_header">diff --git a/fs/nfs/blocklayout/blocklayout.c b/fs/nfs/blocklayout/blocklayout.c</span>
<span class="p_header">index 217847679f0e..2905479f214a 100644</span>
<span class="p_header">--- a/fs/nfs/blocklayout/blocklayout.c</span>
<span class="p_header">+++ b/fs/nfs/blocklayout/blocklayout.c</span>
<span class="p_chunk">@@ -344,9 +344,10 @@</span> <span class="p_context"> static void bl_write_cleanup(struct work_struct *work)</span>
 		u64 start = hdr-&gt;args.offset &amp; (loff_t)PAGE_MASK;
 		u64 end = (hdr-&gt;args.offset + hdr-&gt;args.count +
 			PAGE_SIZE - 1) &amp; (loff_t)PAGE_MASK;
<span class="p_add">+		u64 lwb = hdr-&gt;args.offset + hdr-&gt;args.count;</span>
 
 		ext_tree_mark_written(bl, start &gt;&gt; SECTOR_SHIFT,
<span class="p_del">-					(end - start) &gt;&gt; SECTOR_SHIFT, end);</span>
<span class="p_add">+					(end - start) &gt;&gt; SECTOR_SHIFT, lwb);</span>
 	}
 
 	pnfs_ld_write_done(hdr);
<span class="p_header">diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c</span>
<span class="p_header">index 322c2585bc34..b9c65421ed81 100644</span>
<span class="p_header">--- a/fs/nfs/delegation.c</span>
<span class="p_header">+++ b/fs/nfs/delegation.c</span>
<span class="p_chunk">@@ -41,6 +41,17 @@</span> <span class="p_context"> void nfs_mark_delegation_referenced(struct nfs_delegation *delegation)</span>
 	set_bit(NFS_DELEGATION_REFERENCED, &amp;delegation-&gt;flags);
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+nfs4_is_valid_delegation(const struct nfs_delegation *delegation,</span>
<span class="p_add">+		fmode_t flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (delegation != NULL &amp;&amp; (delegation-&gt;type &amp; flags) == flags &amp;&amp;</span>
<span class="p_add">+	    !test_bit(NFS_DELEGATION_REVOKED, &amp;delegation-&gt;flags) &amp;&amp;</span>
<span class="p_add">+	    !test_bit(NFS_DELEGATION_RETURNING, &amp;delegation-&gt;flags))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 nfs4_do_check_delegation(struct inode *inode, fmode_t flags, bool mark)
 {
<span class="p_chunk">@@ -50,8 +61,7 @@</span> <span class="p_context"> nfs4_do_check_delegation(struct inode *inode, fmode_t flags, bool mark)</span>
 	flags &amp;= FMODE_READ|FMODE_WRITE;
 	rcu_read_lock();
 	delegation = rcu_dereference(NFS_I(inode)-&gt;delegation);
<span class="p_del">-	if (delegation != NULL &amp;&amp; (delegation-&gt;type &amp; flags) == flags &amp;&amp;</span>
<span class="p_del">-	    !test_bit(NFS_DELEGATION_RETURNING, &amp;delegation-&gt;flags)) {</span>
<span class="p_add">+	if (nfs4_is_valid_delegation(delegation, flags)) {</span>
 		if (mark)
 			nfs_mark_delegation_referenced(delegation);
 		ret = 1;
<span class="p_chunk">@@ -893,7 +903,7 @@</span> <span class="p_context"> bool nfs4_copy_delegation_stateid(struct inode *inode, fmode_t flags,</span>
 	flags &amp;= FMODE_READ|FMODE_WRITE;
 	rcu_read_lock();
 	delegation = rcu_dereference(nfsi-&gt;delegation);
<span class="p_del">-	ret = (delegation != NULL &amp;&amp; (delegation-&gt;type &amp; flags) == flags);</span>
<span class="p_add">+	ret = nfs4_is_valid_delegation(delegation, flags);</span>
 	if (ret) {
 		nfs4_stateid_copy(dst, &amp;delegation-&gt;stateid);
 		nfs_mark_delegation_referenced(delegation);
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 177fefb26c18..6bc5a68e39f1 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -435,11 +435,11 @@</span> <span class="p_context"> int nfs_same_file(struct dentry *dentry, struct nfs_entry *entry)</span>
 		return 0;
 
 	nfsi = NFS_I(inode);
<span class="p_del">-	if (entry-&gt;fattr-&gt;fileid == nfsi-&gt;fileid)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	if (nfs_compare_fh(entry-&gt;fh, &amp;nfsi-&gt;fh) == 0)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (entry-&gt;fattr-&gt;fileid != nfsi-&gt;fileid)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (entry-&gt;fh-&gt;size &amp;&amp; nfs_compare_fh(entry-&gt;fh, &amp;nfsi-&gt;fh) != 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return 1;</span>
 }
 
 static
<span class="p_chunk">@@ -517,6 +517,8 @@</span> <span class="p_context"> again:</span>
 					&amp;entry-&gt;fattr-&gt;fsid))
 			goto out;
 		if (nfs_same_file(dentry, entry)) {
<span class="p_add">+			if (!entry-&gt;fh-&gt;size)</span>
<span class="p_add">+				goto out;</span>
 			nfs_set_verifier(dentry, nfs_save_change_attribute(dir));
 			status = nfs_refresh_inode(d_inode(dentry), entry-&gt;fattr);
 			if (!status)
<span class="p_chunk">@@ -529,6 +531,10 @@</span> <span class="p_context"> again:</span>
 			goto again;
 		}
 	}
<span class="p_add">+	if (!entry-&gt;fh-&gt;size) {</span>
<span class="p_add">+		d_lookup_done(dentry);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	inode = nfs_fhget(dentry-&gt;d_sb, entry-&gt;fh, entry-&gt;fattr, entry-&gt;label);
 	alias = d_splice_alias(inode, dentry);
<span class="p_header">diff --git a/fs/nfs/nfs42proc.c b/fs/nfs/nfs42proc.c</span>
<span class="p_header">index 64b43b4ad9dd..608501971fe0 100644</span>
<span class="p_header">--- a/fs/nfs/nfs42proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs42proc.c</span>
<span class="p_chunk">@@ -443,6 +443,7 @@</span> <span class="p_context"> int nfs42_proc_layoutstats_generic(struct nfs_server *server,</span>
 	task = rpc_run_task(&amp;task_setup);
 	if (IS_ERR(task))
 		return PTR_ERR(task);
<span class="p_add">+	rpc_put_task(task);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index cada00aa5096..8353f33f0466 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1498,6 +1498,9 @@</span> <span class="p_context"> restart:</span>
 					__func__, status);
 			case -ENOENT:
 			case -ENOMEM:
<span class="p_add">+			case -EACCES:</span>
<span class="p_add">+			case -EROFS:</span>
<span class="p_add">+			case -EIO:</span>
 			case -ESTALE:
 				/* Open state on this file cannot be recovered */
 				nfs4_state_mark_recovery_failed(state, status);
<span class="p_header">diff --git a/fs/nfsd/nfssvc.c b/fs/nfsd/nfssvc.c</span>
<span class="p_header">index 45007acaf364..a2b65fc56dd6 100644</span>
<span class="p_header">--- a/fs/nfsd/nfssvc.c</span>
<span class="p_header">+++ b/fs/nfsd/nfssvc.c</span>
<span class="p_chunk">@@ -366,14 +366,21 @@</span> <span class="p_context"> static struct notifier_block nfsd_inet6addr_notifier = {</span>
 };
 #endif
 
<span class="p_add">+/* Only used under nfsd_mutex, so this atomic may be overkill: */</span>
<span class="p_add">+static atomic_t nfsd_notifier_refcount = ATOMIC_INIT(0);</span>
<span class="p_add">+</span>
 static void nfsd_last_thread(struct svc_serv *serv, struct net *net)
 {
 	struct nfsd_net *nn = net_generic(net, nfsd_net_id);
 
<span class="p_del">-	unregister_inetaddr_notifier(&amp;nfsd_inetaddr_notifier);</span>
<span class="p_add">+	/* check if the notifier still has clients */</span>
<span class="p_add">+	if (atomic_dec_return(&amp;nfsd_notifier_refcount) == 0) {</span>
<span class="p_add">+		unregister_inetaddr_notifier(&amp;nfsd_inetaddr_notifier);</span>
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_del">-	unregister_inet6addr_notifier(&amp;nfsd_inet6addr_notifier);</span>
<span class="p_add">+		unregister_inet6addr_notifier(&amp;nfsd_inet6addr_notifier);</span>
 #endif
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * write_ports can create the server without actually starting
 	 * any threads--if we get shut down before any threads are
<span class="p_chunk">@@ -488,10 +495,13 @@</span> <span class="p_context"> int nfsd_create_serv(struct net *net)</span>
 	}
 
 	set_max_drc();
<span class="p_del">-	register_inetaddr_notifier(&amp;nfsd_inetaddr_notifier);</span>
<span class="p_add">+	/* check if the notifier is already set */</span>
<span class="p_add">+	if (atomic_inc_return(&amp;nfsd_notifier_refcount) == 1) {</span>
<span class="p_add">+		register_inetaddr_notifier(&amp;nfsd_inetaddr_notifier);</span>
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_del">-	register_inet6addr_notifier(&amp;nfsd_inet6addr_notifier);</span>
<span class="p_add">+		register_inet6addr_notifier(&amp;nfsd_inet6addr_notifier);</span>
 #endif
<span class="p_add">+	}</span>
 	do_gettimeofday(&amp;nn-&gt;nfssvc_boot);		/* record boot time */
 	return 0;
 }
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 43fdc2765aea..abadbc30e013 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -57,6 +57,7 @@</span> <span class="p_context"> int ovl_copy_xattr(struct dentry *old, struct dentry *new)</span>
 	ssize_t list_size, size, value_size = 0;
 	char *buf, *name, *value = NULL;
 	int uninitialized_var(error);
<span class="p_add">+	size_t slen;</span>
 
 	if (!old-&gt;d_inode-&gt;i_op-&gt;getxattr ||
 	    !new-&gt;d_inode-&gt;i_op-&gt;getxattr)
<span class="p_chunk">@@ -79,7 +80,16 @@</span> <span class="p_context"> int ovl_copy_xattr(struct dentry *old, struct dentry *new)</span>
 		goto out;
 	}
 
<span class="p_del">-	for (name = buf; name &lt; (buf + list_size); name += strlen(name) + 1) {</span>
<span class="p_add">+	for (name = buf; list_size; name += slen) {</span>
<span class="p_add">+		slen = strnlen(name, list_size) + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* underlying fs providing us with an broken xattr list? */</span>
<span class="p_add">+		if (WARN_ON(slen &gt; list_size)) {</span>
<span class="p_add">+			error = -EIO;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		list_size -= slen;</span>
<span class="p_add">+</span>
 		if (ovl_is_private_xattr(name))
 			continue;
 retry:
<span class="p_header">diff --git a/fs/overlayfs/dir.c b/fs/overlayfs/dir.c</span>
<span class="p_header">index 1560fdc09a5f..74e696426aae 100644</span>
<span class="p_header">--- a/fs/overlayfs/dir.c</span>
<span class="p_header">+++ b/fs/overlayfs/dir.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/cred.h&gt;
 #include &lt;linux/posix_acl.h&gt;
 #include &lt;linux/posix_acl_xattr.h&gt;
<span class="p_add">+#include &lt;linux/atomic.h&gt;</span>
 #include &quot;overlayfs.h&quot;
 
 void ovl_cleanup(struct inode *wdir, struct dentry *wdentry)
<span class="p_chunk">@@ -37,8 +38,10 @@</span> <span class="p_context"> struct dentry *ovl_lookup_temp(struct dentry *workdir, struct dentry *dentry)</span>
 {
 	struct dentry *temp;
 	char name[20];
<span class="p_add">+	static atomic_t temp_id = ATOMIC_INIT(0);</span>
 
<span class="p_del">-	snprintf(name, sizeof(name), &quot;#%lx&quot;, (unsigned long) dentry);</span>
<span class="p_add">+	/* counter is allowed to wrap, since temp dentries are ephemeral */</span>
<span class="p_add">+	snprintf(name, sizeof(name), &quot;#%x&quot;, atomic_inc_return(&amp;temp_id));</span>
 
 	temp = lookup_one_len(name, workdir, strlen(name));
 	if (!IS_ERR(temp) &amp;&amp; temp-&gt;d_inode) {
<span class="p_header">diff --git a/fs/pstore/ram.c b/fs/pstore/ram.c</span>
<span class="p_header">index 7a034d62cf8c..2340262a7e97 100644</span>
<span class="p_header">--- a/fs/pstore/ram.c</span>
<span class="p_header">+++ b/fs/pstore/ram.c</span>
<span class="p_chunk">@@ -377,13 +377,14 @@</span> <span class="p_context"> static void ramoops_free_przs(struct ramoops_context *cxt)</span>
 {
 	int i;
 
<span class="p_del">-	cxt-&gt;max_dump_cnt = 0;</span>
 	if (!cxt-&gt;przs)
 		return;
 
<span class="p_del">-	for (i = 0; !IS_ERR_OR_NULL(cxt-&gt;przs[i]); i++)</span>
<span class="p_add">+	for (i = 0; i &lt; cxt-&gt;max_dump_cnt; i++)</span>
 		persistent_ram_free(cxt-&gt;przs[i]);
<span class="p_add">+</span>
 	kfree(cxt-&gt;przs);
<span class="p_add">+	cxt-&gt;max_dump_cnt = 0;</span>
 }
 
 static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,
<span class="p_chunk">@@ -408,7 +409,7 @@</span> <span class="p_context"> static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,</span>
 			     GFP_KERNEL);
 	if (!cxt-&gt;przs) {
 		dev_err(dev, &quot;failed to initialize a prz array for dumps\n&quot;);
<span class="p_del">-		goto fail_prz;</span>
<span class="p_add">+		goto fail_mem;</span>
 	}
 
 	for (i = 0; i &lt; cxt-&gt;max_dump_cnt; i++) {
<span class="p_chunk">@@ -419,6 +420,11 @@</span> <span class="p_context"> static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,</span>
 			err = PTR_ERR(cxt-&gt;przs[i]);
 			dev_err(dev, &quot;failed to request mem region (0x%zx@0x%llx): %d\n&quot;,
 				cxt-&gt;record_size, (unsigned long long)*paddr, err);
<span class="p_add">+</span>
<span class="p_add">+			while (i &gt; 0) {</span>
<span class="p_add">+				i--;</span>
<span class="p_add">+				persistent_ram_free(cxt-&gt;przs[i]);</span>
<span class="p_add">+			}</span>
 			goto fail_prz;
 		}
 		*paddr += cxt-&gt;record_size;
<span class="p_chunk">@@ -426,7 +432,9 @@</span> <span class="p_context"> static int ramoops_init_przs(struct device *dev, struct ramoops_context *cxt,</span>
 
 	return 0;
 fail_prz:
<span class="p_del">-	ramoops_free_przs(cxt);</span>
<span class="p_add">+	kfree(cxt-&gt;przs);</span>
<span class="p_add">+fail_mem:</span>
<span class="p_add">+	cxt-&gt;max_dump_cnt = 0;</span>
 	return err;
 }
 
<span class="p_chunk">@@ -659,7 +667,6 @@</span> <span class="p_context"> static int ramoops_remove(struct platform_device *pdev)</span>
 	struct ramoops_context *cxt = &amp;oops_cxt;
 
 	pstore_unregister(&amp;cxt-&gt;pstore);
<span class="p_del">-	cxt-&gt;max_dump_cnt = 0;</span>
 
 	kfree(cxt-&gt;pstore.buf);
 	cxt-&gt;pstore.bufsize = 0;
<span class="p_header">diff --git a/fs/pstore/ram_core.c b/fs/pstore/ram_core.c</span>
<span class="p_header">index 76c3f80efdfa..364d2dffe5a6 100644</span>
<span class="p_header">--- a/fs/pstore/ram_core.c</span>
<span class="p_header">+++ b/fs/pstore/ram_core.c</span>
<span class="p_chunk">@@ -47,43 +47,10 @@</span> <span class="p_context"> static inline size_t buffer_start(struct persistent_ram_zone *prz)</span>
 	return atomic_read(&amp;prz-&gt;buffer-&gt;start);
 }
 
<span class="p_del">-/* increase and wrap the start pointer, returning the old value */</span>
<span class="p_del">-static size_t buffer_start_add_atomic(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int old;</span>
<span class="p_del">-	int new;</span>
<span class="p_del">-</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		old = atomic_read(&amp;prz-&gt;buffer-&gt;start);</span>
<span class="p_del">-		new = old + a;</span>
<span class="p_del">-		while (unlikely(new &gt;= prz-&gt;buffer_size))</span>
<span class="p_del">-			new -= prz-&gt;buffer_size;</span>
<span class="p_del">-	} while (atomic_cmpxchg(&amp;prz-&gt;buffer-&gt;start, old, new) != old);</span>
<span class="p_del">-</span>
<span class="p_del">-	return old;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* increase the size counter until it hits the max size */</span>
<span class="p_del">-static void buffer_size_add_atomic(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t old;</span>
<span class="p_del">-	size_t new;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (atomic_read(&amp;prz-&gt;buffer-&gt;size) == prz-&gt;buffer_size)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		old = atomic_read(&amp;prz-&gt;buffer-&gt;size);</span>
<span class="p_del">-		new = old + a;</span>
<span class="p_del">-		if (new &gt; prz-&gt;buffer_size)</span>
<span class="p_del">-			new = prz-&gt;buffer_size;</span>
<span class="p_del">-	} while (atomic_cmpxchg(&amp;prz-&gt;buffer-&gt;size, old, new) != old);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static DEFINE_RAW_SPINLOCK(buffer_lock);
 
 /* increase and wrap the start pointer, returning the old value */
<span class="p_del">-static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_add">+static size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)</span>
 {
 	int old;
 	int new;
<span class="p_chunk">@@ -103,7 +70,7 @@</span> <span class="p_context"> static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
 }
 
 /* increase the size counter until it hits the max size */
<span class="p_del">-static void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_add">+static void buffer_size_add(struct persistent_ram_zone *prz, size_t a)</span>
 {
 	size_t old;
 	size_t new;
<span class="p_chunk">@@ -124,9 +91,6 @@</span> <span class="p_context"> exit:</span>
 	raw_spin_unlock_irqrestore(&amp;buffer_lock, flags);
 }
 
<span class="p_del">-static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;</span>
<span class="p_del">-static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;</span>
<span class="p_del">-</span>
 static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,
 	uint8_t *data, size_t len, uint8_t *ecc)
 {
<span class="p_chunk">@@ -299,7 +263,7 @@</span> <span class="p_context"> static void notrace persistent_ram_update(struct persistent_ram_zone *prz,</span>
 	const void *s, unsigned int start, unsigned int count)
 {
 	struct persistent_ram_buffer *buffer = prz-&gt;buffer;
<span class="p_del">-	memcpy(buffer-&gt;data + start, s, count);</span>
<span class="p_add">+	memcpy_toio(buffer-&gt;data + start, s, count);</span>
 	persistent_ram_update_ecc(prz, start, count);
 }
 
<span class="p_chunk">@@ -322,8 +286,8 @@</span> <span class="p_context"> void persistent_ram_save_old(struct persistent_ram_zone *prz)</span>
 	}
 
 	prz-&gt;old_log_size = size;
<span class="p_del">-	memcpy(prz-&gt;old_log, &amp;buffer-&gt;data[start], size - start);</span>
<span class="p_del">-	memcpy(prz-&gt;old_log + size - start, &amp;buffer-&gt;data[0], start);</span>
<span class="p_add">+	memcpy_fromio(prz-&gt;old_log, &amp;buffer-&gt;data[start], size - start);</span>
<span class="p_add">+	memcpy_fromio(prz-&gt;old_log + size - start, &amp;buffer-&gt;data[0], start);</span>
 }
 
 int notrace persistent_ram_write(struct persistent_ram_zone *prz,
<span class="p_chunk">@@ -426,9 +390,6 @@</span> <span class="p_context"> static void *persistent_ram_iomap(phys_addr_t start, size_t size,</span>
 		return NULL;
 	}
 
<span class="p_del">-	buffer_start_add = buffer_start_add_locked;</span>
<span class="p_del">-	buffer_size_add = buffer_size_add_locked;</span>
<span class="p_del">-</span>
 	if (memtype)
 		va = ioremap(start, size);
 	else
<span class="p_header">diff --git a/fs/super.c b/fs/super.c</span>
<span class="p_header">index c2ff475c1711..47d11e0462d0 100644</span>
<span class="p_header">--- a/fs/super.c</span>
<span class="p_header">+++ b/fs/super.c</span>
<span class="p_chunk">@@ -1379,8 +1379,8 @@</span> <span class="p_context"> int freeze_super(struct super_block *sb)</span>
 		}
 	}
 	/*
<span class="p_del">-	 * This is just for debugging purposes so that fs can warn if it</span>
<span class="p_del">-	 * sees write activity when frozen is set to SB_FREEZE_COMPLETE.</span>
<span class="p_add">+	 * For debugging purposes so that fs can warn if it sees write activity</span>
<span class="p_add">+	 * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().</span>
 	 */
 	sb-&gt;s_writers.frozen = SB_FREEZE_COMPLETE;
 	up_write(&amp;sb-&gt;s_umount);
<span class="p_chunk">@@ -1399,7 +1399,7 @@</span> <span class="p_context"> int thaw_super(struct super_block *sb)</span>
 	int error;
 
 	down_write(&amp;sb-&gt;s_umount);
<span class="p_del">-	if (sb-&gt;s_writers.frozen == SB_UNFROZEN) {</span>
<span class="p_add">+	if (sb-&gt;s_writers.frozen != SB_FREEZE_COMPLETE) {</span>
 		up_write(&amp;sb-&gt;s_umount);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/fs/ubifs/xattr.c b/fs/ubifs/xattr.c</span>
<span class="p_header">index 11a004114eba..c9ee6f6efa07 100644</span>
<span class="p_header">--- a/fs/ubifs/xattr.c</span>
<span class="p_header">+++ b/fs/ubifs/xattr.c</span>
<span class="p_chunk">@@ -172,6 +172,7 @@</span> <span class="p_context"> out_cancel:</span>
 	host_ui-&gt;xattr_cnt -= 1;
 	host_ui-&gt;xattr_size -= CALC_DENT_SIZE(nm-&gt;len);
 	host_ui-&gt;xattr_size -= CALC_XATTR_BYTES(size);
<span class="p_add">+	host_ui-&gt;xattr_names -= nm-&gt;len;</span>
 	mutex_unlock(&amp;host_ui-&gt;ui_mutex);
 out_free:
 	make_bad_inode(inode);
<span class="p_chunk">@@ -476,6 +477,7 @@</span> <span class="p_context"> out_cancel:</span>
 	host_ui-&gt;xattr_cnt += 1;
 	host_ui-&gt;xattr_size += CALC_DENT_SIZE(nm-&gt;len);
 	host_ui-&gt;xattr_size += CALC_XATTR_BYTES(ui-&gt;data_len);
<span class="p_add">+	host_ui-&gt;xattr_names += nm-&gt;len;</span>
 	mutex_unlock(&amp;host_ui-&gt;ui_mutex);
 	ubifs_release_budget(c, &amp;req);
 	make_bad_inode(inode);
<span class="p_header">diff --git a/include/dt-bindings/clock/imx6qdl-clock.h b/include/dt-bindings/clock/imx6qdl-clock.h</span>
<span class="p_header">index 29050337d9d5..da59fd9cdb5e 100644</span>
<span class="p_header">--- a/include/dt-bindings/clock/imx6qdl-clock.h</span>
<span class="p_header">+++ b/include/dt-bindings/clock/imx6qdl-clock.h</span>
<span class="p_chunk">@@ -269,6 +269,8 @@</span> <span class="p_context"></span>
 #define IMX6QDL_CLK_PRG0_APB			256
 #define IMX6QDL_CLK_PRG1_APB			257
 #define IMX6QDL_CLK_PRE_AXI			258
<span class="p_del">-#define IMX6QDL_CLK_END				259</span>
<span class="p_add">+#define IMX6QDL_CLK_MLB_SEL			259</span>
<span class="p_add">+#define IMX6QDL_CLK_MLB_PODF			260</span>
<span class="p_add">+#define IMX6QDL_CLK_END				261</span>
 
 #endif /* __DT_BINDINGS_CLOCK_IMX6QDL_H */
<span class="p_header">diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h</span>
<span class="p_header">index 631ba33bbe9f..32dc0cbd51ca 100644</span>
<span class="p_header">--- a/include/linux/cpufreq.h</span>
<span class="p_header">+++ b/include/linux/cpufreq.h</span>
<span class="p_chunk">@@ -639,19 +639,19 @@</span> <span class="p_context"> static inline int cpufreq_table_find_index_al(struct cpufreq_policy *policy,</span>
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy-&gt;freq_table;
<span class="p_add">+	struct cpufreq_frequency_table *pos, *best = table - 1;</span>
 	unsigned int freq;
<span class="p_del">-	int i, best = -1;</span>
 
<span class="p_del">-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {</span>
<span class="p_del">-		freq = table[i].frequency;</span>
<span class="p_add">+	cpufreq_for_each_valid_entry(pos, table) {</span>
<span class="p_add">+		freq = pos-&gt;frequency;</span>
 
 		if (freq &gt;= target_freq)
<span class="p_del">-			return i;</span>
<span class="p_add">+			return pos - table;</span>
 
<span class="p_del">-		best = i;</span>
<span class="p_add">+		best = pos;</span>
 	}
 
<span class="p_del">-	return best;</span>
<span class="p_add">+	return best - table;</span>
 }
 
 /* Find lowest freq at or above target in a table in descending order */
<span class="p_chunk">@@ -659,28 +659,28 @@</span> <span class="p_context"> static inline int cpufreq_table_find_index_dl(struct cpufreq_policy *policy,</span>
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy-&gt;freq_table;
<span class="p_add">+	struct cpufreq_frequency_table *pos, *best = table - 1;</span>
 	unsigned int freq;
<span class="p_del">-	int i, best = -1;</span>
 
<span class="p_del">-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {</span>
<span class="p_del">-		freq = table[i].frequency;</span>
<span class="p_add">+	cpufreq_for_each_valid_entry(pos, table) {</span>
<span class="p_add">+		freq = pos-&gt;frequency;</span>
 
 		if (freq == target_freq)
<span class="p_del">-			return i;</span>
<span class="p_add">+			return pos - table;</span>
 
 		if (freq &gt; target_freq) {
<span class="p_del">-			best = i;</span>
<span class="p_add">+			best = pos;</span>
 			continue;
 		}
 
 		/* No freq found above target_freq */
<span class="p_del">-		if (best == -1)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (best == table - 1)</span>
<span class="p_add">+			return pos - table;</span>
 
<span class="p_del">-		return best;</span>
<span class="p_add">+		return best - table;</span>
 	}
 
<span class="p_del">-	return best;</span>
<span class="p_add">+	return best - table;</span>
 }
 
 /* Works only on sorted freq-tables */
<span class="p_chunk">@@ -700,28 +700,28 @@</span> <span class="p_context"> static inline int cpufreq_table_find_index_ah(struct cpufreq_policy *policy,</span>
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy-&gt;freq_table;
<span class="p_add">+	struct cpufreq_frequency_table *pos, *best = table - 1;</span>
 	unsigned int freq;
<span class="p_del">-	int i, best = -1;</span>
 
<span class="p_del">-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {</span>
<span class="p_del">-		freq = table[i].frequency;</span>
<span class="p_add">+	cpufreq_for_each_valid_entry(pos, table) {</span>
<span class="p_add">+		freq = pos-&gt;frequency;</span>
 
 		if (freq == target_freq)
<span class="p_del">-			return i;</span>
<span class="p_add">+			return pos - table;</span>
 
 		if (freq &lt; target_freq) {
<span class="p_del">-			best = i;</span>
<span class="p_add">+			best = pos;</span>
 			continue;
 		}
 
 		/* No freq found below target_freq */
<span class="p_del">-		if (best == -1)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (best == table - 1)</span>
<span class="p_add">+			return pos - table;</span>
 
<span class="p_del">-		return best;</span>
<span class="p_add">+		return best - table;</span>
 	}
 
<span class="p_del">-	return best;</span>
<span class="p_add">+	return best - table;</span>
 }
 
 /* Find highest freq at or below target in a table in descending order */
<span class="p_chunk">@@ -729,19 +729,19 @@</span> <span class="p_context"> static inline int cpufreq_table_find_index_dh(struct cpufreq_policy *policy,</span>
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy-&gt;freq_table;
<span class="p_add">+	struct cpufreq_frequency_table *pos, *best = table - 1;</span>
 	unsigned int freq;
<span class="p_del">-	int i, best = -1;</span>
 
<span class="p_del">-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {</span>
<span class="p_del">-		freq = table[i].frequency;</span>
<span class="p_add">+	cpufreq_for_each_valid_entry(pos, table) {</span>
<span class="p_add">+		freq = pos-&gt;frequency;</span>
 
 		if (freq &lt;= target_freq)
<span class="p_del">-			return i;</span>
<span class="p_add">+			return pos - table;</span>
 
<span class="p_del">-		best = i;</span>
<span class="p_add">+		best = pos;</span>
 	}
 
<span class="p_del">-	return best;</span>
<span class="p_add">+	return best - table;</span>
 }
 
 /* Works only on sorted freq-tables */
<span class="p_chunk">@@ -761,32 +761,32 @@</span> <span class="p_context"> static inline int cpufreq_table_find_index_ac(struct cpufreq_policy *policy,</span>
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy-&gt;freq_table;
<span class="p_add">+	struct cpufreq_frequency_table *pos, *best = table - 1;</span>
 	unsigned int freq;
<span class="p_del">-	int i, best = -1;</span>
 
<span class="p_del">-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {</span>
<span class="p_del">-		freq = table[i].frequency;</span>
<span class="p_add">+	cpufreq_for_each_valid_entry(pos, table) {</span>
<span class="p_add">+		freq = pos-&gt;frequency;</span>
 
 		if (freq == target_freq)
<span class="p_del">-			return i;</span>
<span class="p_add">+			return pos - table;</span>
 
 		if (freq &lt; target_freq) {
<span class="p_del">-			best = i;</span>
<span class="p_add">+			best = pos;</span>
 			continue;
 		}
 
 		/* No freq found below target_freq */
<span class="p_del">-		if (best == -1)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (best == table - 1)</span>
<span class="p_add">+			return pos - table;</span>
 
 		/* Choose the closest freq */
<span class="p_del">-		if (target_freq - table[best].frequency &gt; freq - target_freq)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (target_freq - best-&gt;frequency &gt; freq - target_freq)</span>
<span class="p_add">+			return pos - table;</span>
 
<span class="p_del">-		return best;</span>
<span class="p_add">+		return best - table;</span>
 	}
 
<span class="p_del">-	return best;</span>
<span class="p_add">+	return best - table;</span>
 }
 
 /* Find closest freq to target in a table in descending order */
<span class="p_chunk">@@ -794,32 +794,32 @@</span> <span class="p_context"> static inline int cpufreq_table_find_index_dc(struct cpufreq_policy *policy,</span>
 					      unsigned int target_freq)
 {
 	struct cpufreq_frequency_table *table = policy-&gt;freq_table;
<span class="p_add">+	struct cpufreq_frequency_table *pos, *best = table - 1;</span>
 	unsigned int freq;
<span class="p_del">-	int i, best = -1;</span>
 
<span class="p_del">-	for (i = 0; table[i].frequency != CPUFREQ_TABLE_END; i++) {</span>
<span class="p_del">-		freq = table[i].frequency;</span>
<span class="p_add">+	cpufreq_for_each_valid_entry(pos, table) {</span>
<span class="p_add">+		freq = pos-&gt;frequency;</span>
 
 		if (freq == target_freq)
<span class="p_del">-			return i;</span>
<span class="p_add">+			return pos - table;</span>
 
 		if (freq &gt; target_freq) {
<span class="p_del">-			best = i;</span>
<span class="p_add">+			best = pos;</span>
 			continue;
 		}
 
 		/* No freq found above target_freq */
<span class="p_del">-		if (best == -1)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (best == table - 1)</span>
<span class="p_add">+			return pos - table;</span>
 
 		/* Choose the closest freq */
<span class="p_del">-		if (table[best].frequency - target_freq &gt; target_freq - freq)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (best-&gt;frequency - target_freq &gt; target_freq - freq)</span>
<span class="p_add">+			return pos - table;</span>
 
<span class="p_del">-		return best;</span>
<span class="p_add">+		return best - table;</span>
 	}
 
<span class="p_del">-	return best;</span>
<span class="p_add">+	return best - table;</span>
 }
 
 /* Works only on sorted freq-tables */
<span class="p_header">diff --git a/include/linux/devfreq-event.h b/include/linux/devfreq-event.h</span>
<span class="p_header">index 0a83a1e648b0..4db00b02ca3f 100644</span>
<span class="p_header">--- a/include/linux/devfreq-event.h</span>
<span class="p_header">+++ b/include/linux/devfreq-event.h</span>
<span class="p_chunk">@@ -148,11 +148,6 @@</span> <span class="p_context"> static inline int devfreq_event_reset_event(struct devfreq_event_dev *edev)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-static inline void *devfreq_event_get_drvdata(struct devfreq_event_dev *edev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return ERR_PTR(-EINVAL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline struct devfreq_event_dev *devfreq_event_get_edev_by_phandle(
 					struct device *dev, int index)
 {
<span class="p_header">diff --git a/include/linux/irqchip/arm-gic-v3.h b/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_header">index 99ac022edc60..3a8610ea6ab7 100644</span>
<span class="p_header">--- a/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_header">+++ b/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_chunk">@@ -290,7 +290,7 @@</span> <span class="p_context"></span>
 #define GITS_BASER_TYPE_SHIFT			(56)
 #define GITS_BASER_TYPE(r)		(((r) &gt;&gt; GITS_BASER_TYPE_SHIFT) &amp; 7)
 #define GITS_BASER_ENTRY_SIZE_SHIFT		(48)
<span class="p_del">-#define GITS_BASER_ENTRY_SIZE(r)	((((r) &gt;&gt; GITS_BASER_ENTRY_SIZE_SHIFT) &amp; 0xff) + 1)</span>
<span class="p_add">+#define GITS_BASER_ENTRY_SIZE(r)	((((r) &gt;&gt; GITS_BASER_ENTRY_SIZE_SHIFT) &amp; 0x1f) + 1)</span>
 #define GITS_BASER_SHAREABILITY_SHIFT	(10)
 #define GITS_BASER_InnerShareable					\
 	GIC_BASER_SHAREABILITY(GITS_BASER, InnerShareable)
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index fb8e3b6febdf..c2119008990a 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -177,6 +177,7 @@</span> <span class="p_context"> enum tcm_sense_reason_table {</span>
 	TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED	= R(0x15),
 	TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED	= R(0x16),
 	TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED	= R(0x17),
<span class="p_add">+	TCM_COPY_TARGET_DEVICE_NOT_REACHABLE	= R(0x18),</span>
 #undef R
 };
 
<span class="p_header">diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c</span>
<span class="p_header">index 039de34f1521..8b3610c871f2 100644</span>
<span class="p_header">--- a/kernel/sched/fair.c</span>
<span class="p_header">+++ b/kernel/sched/fair.c</span>
<span class="p_chunk">@@ -456,17 +456,23 @@</span> <span class="p_context"> static inline int entity_before(struct sched_entity *a,</span>
 
 static void update_min_vruntime(struct cfs_rq *cfs_rq)
 {
<span class="p_add">+	struct sched_entity *curr = cfs_rq-&gt;curr;</span>
<span class="p_add">+</span>
 	u64 vruntime = cfs_rq-&gt;min_vruntime;
 
<span class="p_del">-	if (cfs_rq-&gt;curr)</span>
<span class="p_del">-		vruntime = cfs_rq-&gt;curr-&gt;vruntime;</span>
<span class="p_add">+	if (curr) {</span>
<span class="p_add">+		if (curr-&gt;on_rq)</span>
<span class="p_add">+			vruntime = curr-&gt;vruntime;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			curr = NULL;</span>
<span class="p_add">+	}</span>
 
 	if (cfs_rq-&gt;rb_leftmost) {
 		struct sched_entity *se = rb_entry(cfs_rq-&gt;rb_leftmost,
 						   struct sched_entity,
 						   run_node);
 
<span class="p_del">-		if (!cfs_rq-&gt;curr)</span>
<span class="p_add">+		if (!curr)</span>
 			vruntime = se-&gt;vruntime;
 		else
 			vruntime = min_vruntime(vruntime, se-&gt;vruntime);
<span class="p_chunk">@@ -680,7 +686,14 @@</span> <span class="p_context"> void init_entity_runnable_average(struct sched_entity *se)</span>
 	 * will definitely be update (after enqueue).
 	 */
 	sa-&gt;period_contrib = 1023;
<span class="p_del">-	sa-&gt;load_avg = scale_load_down(se-&gt;load.weight);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Tasks are intialized with full load to be seen as heavy tasks until</span>
<span class="p_add">+	 * they get a chance to stabilize to their real load level.</span>
<span class="p_add">+	 * Group entities are intialized with zero load to reflect the fact that</span>
<span class="p_add">+	 * nothing has been attached to the task group yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (entity_is_task(se))</span>
<span class="p_add">+		sa-&gt;load_avg = scale_load_down(se-&gt;load.weight);</span>
 	sa-&gt;load_sum = sa-&gt;load_avg * LOAD_AVG_MAX;
 	/*
 	 * At this point, util_avg won&#39;t be used in select_task_rq_fair anyway
<span class="p_chunk">@@ -3459,9 +3472,10 @@</span> <span class="p_context"> dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span>
 	account_entity_dequeue(cfs_rq, se);
 
 	/*
<span class="p_del">-	 * Normalize the entity after updating the min_vruntime because the</span>
<span class="p_del">-	 * update can refer to the -&gt;curr item and we need to reflect this</span>
<span class="p_del">-	 * movement in our normalized position.</span>
<span class="p_add">+	 * Normalize after update_curr(); which will also have moved</span>
<span class="p_add">+	 * min_vruntime if @se is the one holding it back. But before doing</span>
<span class="p_add">+	 * update_min_vruntime() again, which will discount @se&#39;s position and</span>
<span class="p_add">+	 * can move min_vruntime forward still more.</span>
 	 */
 	if (!(flags &amp; DEQUEUE_SLEEP))
 		se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;
<span class="p_chunk">@@ -3469,8 +3483,16 @@</span> <span class="p_context"> dequeue_entity(struct cfs_rq *cfs_rq, struct sched_entity *se, int flags)</span>
 	/* return excess runtime on last dequeue */
 	return_cfs_rq_runtime(cfs_rq);
 
<span class="p_del">-	update_min_vruntime(cfs_rq);</span>
 	update_cfs_shares(cfs_rq);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Now advance min_vruntime if @se was the entity holding it back,</span>
<span class="p_add">+	 * except when: DEQUEUE_SAVE &amp;&amp; !DEQUEUE_MOVE, in this case we&#39;ll be</span>
<span class="p_add">+	 * put back on, and if we advance min_vruntime, we&#39;ll be placed back</span>
<span class="p_add">+	 * further than we started -- ie. we&#39;ll be penalized.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((flags &amp; (DEQUEUE_SAVE | DEQUEUE_MOVE)) == DEQUEUE_SAVE)</span>
<span class="p_add">+		update_min_vruntime(cfs_rq);</span>
 }
 
 /*
<span class="p_header">diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c</span>
<span class="p_header">index bf168838a029..e72581da9648 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtsock.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtsock.c</span>
<span class="p_chunk">@@ -473,7 +473,16 @@</span> <span class="p_context"> static int xs_nospace(struct rpc_task *task)</span>
 	spin_unlock_bh(&amp;xprt-&gt;transport_lock);
 
 	/* Race breaker in case memory is freed before above code is called */
<span class="p_del">-	sk-&gt;sk_write_space(sk);</span>
<span class="p_add">+	if (ret == -EAGAIN) {</span>
<span class="p_add">+		struct socket_wq *wq;</span>
<span class="p_add">+</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		wq = rcu_dereference(sk-&gt;sk_wq);</span>
<span class="p_add">+		set_bit(SOCKWQ_ASYNC_NOSPACE, &amp;wq-&gt;flags);</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+		sk-&gt;sk_write_space(sk);</span>
<span class="p_add">+	}</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/sound/pci/hda/dell_wmi_helper.c b/sound/pci/hda/dell_wmi_helper.c</span>
<span class="p_header">index 9c22f95838ef..19d41da79f93 100644</span>
<span class="p_header">--- a/sound/pci/hda/dell_wmi_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/dell_wmi_helper.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> static void alc_fixup_dell_wmi(struct hda_codec *codec,</span>
 		removefunc = true;
 		if (dell_led_set_func(DELL_LED_MICMUTE, false) &gt;= 0) {
 			dell_led_value = 0;
<span class="p_del">-			if (spec-&gt;gen.num_adc_nids &gt; 1)</span>
<span class="p_add">+			if (spec-&gt;gen.num_adc_nids &gt; 1 &amp;&amp; !spec-&gt;gen.dyn_adc_switch)</span>
 				codec_dbg(codec, &quot;Skipping micmute LED control due to several ADCs&quot;);
 			else {
 				dell_old_cap_hook = spec-&gt;gen.cap_sync_hook;
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index f0955fd7a2e7..6a23302297c9 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -62,7 +62,7 @@</span> <span class="p_context"> static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,</span>
 			removefunc = false;
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) &gt;= 0) {
<span class="p_del">-			if (spec-&gt;num_adc_nids &gt; 1)</span>
<span class="p_add">+			if (spec-&gt;num_adc_nids &gt; 1 &amp;&amp; !spec-&gt;dyn_adc_switch)</span>
 				codec_dbg(codec,
 					  &quot;Skipping micmute LED control due to several ADCs&quot;);
 			else {
<span class="p_header">diff --git a/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c b/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c</span>
<span class="p_header">index 8ff6c6a61291..c9c8dc330116 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c</span>
<span class="p_header">+++ b/tools/perf/util/intel-pt-decoder/intel-pt-decoder.c</span>
<span class="p_chunk">@@ -89,6 +89,7 @@</span> <span class="p_context"> struct intel_pt_decoder {</span>
 	bool pge;
 	bool have_tma;
 	bool have_cyc;
<span class="p_add">+	bool fixup_last_mtc;</span>
 	uint64_t pos;
 	uint64_t last_ip;
 	uint64_t ip;
<span class="p_chunk">@@ -584,10 +585,31 @@</span> <span class="p_context"> struct intel_pt_calc_cyc_to_tsc_info {</span>
 	uint64_t        tsc_timestamp;
 	uint64_t        timestamp;
 	bool            have_tma;
<span class="p_add">+	bool            fixup_last_mtc;</span>
 	bool            from_mtc;
 	double          cbr_cyc_to_tsc;
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * MTC provides a 8-bit slice of CTC but the TMA packet only provides the lower</span>
<span class="p_add">+ * 16 bits of CTC. If mtc_shift &gt; 8 then some of the MTC bits are not in the CTC</span>
<span class="p_add">+ * provided by the TMA packet. Fix-up the last_mtc calculated from the TMA</span>
<span class="p_add">+ * packet by copying the missing bits from the current MTC assuming the least</span>
<span class="p_add">+ * difference between the two, and that the current MTC comes after last_mtc.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void intel_pt_fixup_last_mtc(uint32_t mtc, int mtc_shift,</span>
<span class="p_add">+				    uint32_t *last_mtc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint32_t first_missing_bit = 1U &lt;&lt; (16 - mtc_shift);</span>
<span class="p_add">+	uint32_t mask = ~(first_missing_bit - 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	*last_mtc |= mtc &amp; mask;</span>
<span class="p_add">+	if (*last_mtc &gt;= mtc) {</span>
<span class="p_add">+		*last_mtc -= first_missing_bit;</span>
<span class="p_add">+		*last_mtc &amp;= 0xff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)
 {
 	struct intel_pt_decoder *decoder = pkt_info-&gt;decoder;
<span class="p_chunk">@@ -617,6 +639,11 @@</span> <span class="p_context"> static int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)</span>
 			return 0;
 
 		mtc = pkt_info-&gt;packet.payload;
<span class="p_add">+		if (decoder-&gt;mtc_shift &gt; 8 &amp;&amp; data-&gt;fixup_last_mtc) {</span>
<span class="p_add">+			data-&gt;fixup_last_mtc = false;</span>
<span class="p_add">+			intel_pt_fixup_last_mtc(mtc, decoder-&gt;mtc_shift,</span>
<span class="p_add">+						&amp;data-&gt;last_mtc);</span>
<span class="p_add">+		}</span>
 		if (mtc &gt; data-&gt;last_mtc)
 			mtc_delta = mtc - data-&gt;last_mtc;
 		else
<span class="p_chunk">@@ -685,6 +712,7 @@</span> <span class="p_context"> static int intel_pt_calc_cyc_cb(struct intel_pt_pkt_info *pkt_info)</span>
 
 		data-&gt;ctc_delta = 0;
 		data-&gt;have_tma = true;
<span class="p_add">+		data-&gt;fixup_last_mtc = true;</span>
 
 		return 0;
 
<span class="p_chunk">@@ -751,6 +779,7 @@</span> <span class="p_context"> static void intel_pt_calc_cyc_to_tsc(struct intel_pt_decoder *decoder,</span>
 		.tsc_timestamp  = decoder-&gt;tsc_timestamp,
 		.timestamp      = decoder-&gt;timestamp,
 		.have_tma       = decoder-&gt;have_tma,
<span class="p_add">+		.fixup_last_mtc = decoder-&gt;fixup_last_mtc,</span>
 		.from_mtc       = from_mtc,
 		.cbr_cyc_to_tsc = 0,
 	};
<span class="p_chunk">@@ -1241,6 +1270,7 @@</span> <span class="p_context"> static void intel_pt_calc_tma(struct intel_pt_decoder *decoder)</span>
 	}
 	decoder-&gt;ctc_delta = 0;
 	decoder-&gt;have_tma = true;
<span class="p_add">+	decoder-&gt;fixup_last_mtc = true;</span>
 	intel_pt_log(&quot;CTC timestamp &quot; x64_fmt &quot; last MTC %#x  CTC rem %#x\n&quot;,
 		     decoder-&gt;ctc_timestamp, decoder-&gt;last_mtc, ctc_rem);
 }
<span class="p_chunk">@@ -1255,6 +1285,12 @@</span> <span class="p_context"> static void intel_pt_calc_mtc_timestamp(struct intel_pt_decoder *decoder)</span>
 
 	mtc = decoder-&gt;packet.payload;
 
<span class="p_add">+	if (decoder-&gt;mtc_shift &gt; 8 &amp;&amp; decoder-&gt;fixup_last_mtc) {</span>
<span class="p_add">+		decoder-&gt;fixup_last_mtc = false;</span>
<span class="p_add">+		intel_pt_fixup_last_mtc(mtc, decoder-&gt;mtc_shift,</span>
<span class="p_add">+					&amp;decoder-&gt;last_mtc);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (mtc &gt; decoder-&gt;last_mtc)
 		mtc_delta = mtc - decoder-&gt;last_mtc;
 	else
<span class="p_chunk">@@ -1323,6 +1359,8 @@</span> <span class="p_context"> static void intel_pt_calc_cyc_timestamp(struct intel_pt_decoder *decoder)</span>
 			     timestamp, decoder-&gt;timestamp);
 	else
 		decoder-&gt;timestamp = timestamp;
<span class="p_add">+</span>
<span class="p_add">+	decoder-&gt;timestamp_insn_cnt = 0;</span>
 }
 
 /* Walk PSB+ packets when already in sync. */
<span class="p_header">diff --git a/tools/perf/util/intel-pt.c b/tools/perf/util/intel-pt.c</span>
<span class="p_header">index 551ff6f640be..b2878d2b2d67 100644</span>
<span class="p_header">--- a/tools/perf/util/intel-pt.c</span>
<span class="p_header">+++ b/tools/perf/util/intel-pt.c</span>
<span class="p_chunk">@@ -241,7 +241,7 @@</span> <span class="p_context"> static int intel_pt_get_trace(struct intel_pt_buffer *b, void *data)</span>
 	}
 
 	queue = &amp;ptq-&gt;pt-&gt;queues.queue_array[ptq-&gt;queue_nr];
<span class="p_del">-</span>
<span class="p_add">+next:</span>
 	buffer = auxtrace_buffer__next(queue, buffer);
 	if (!buffer) {
 		if (old_buffer)
<span class="p_chunk">@@ -264,9 +264,6 @@</span> <span class="p_context"> static int intel_pt_get_trace(struct intel_pt_buffer *b, void *data)</span>
 	    intel_pt_do_fix_overlap(ptq-&gt;pt, old_buffer, buffer))
 		return -ENOMEM;
 
<span class="p_del">-	if (old_buffer)</span>
<span class="p_del">-		auxtrace_buffer__drop_data(old_buffer);</span>
<span class="p_del">-</span>
 	if (buffer-&gt;use_data) {
 		b-&gt;len = buffer-&gt;use_size;
 		b-&gt;buf = buffer-&gt;use_data;
<span class="p_chunk">@@ -276,6 +273,16 @@</span> <span class="p_context"> static int intel_pt_get_trace(struct intel_pt_buffer *b, void *data)</span>
 	}
 	b-&gt;ref_timestamp = buffer-&gt;reference;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If in snapshot mode and the buffer has no usable data, get next</span>
<span class="p_add">+	 * buffer and again check overlap against old_buffer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ptq-&gt;pt-&gt;snapshot_mode &amp;&amp; !b-&gt;len)</span>
<span class="p_add">+		goto next;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (old_buffer)</span>
<span class="p_add">+		auxtrace_buffer__drop_data(old_buffer);</span>
<span class="p_add">+</span>
 	if (!old_buffer || ptq-&gt;pt-&gt;sampling_mode || (ptq-&gt;pt-&gt;snapshot_mode &amp;&amp;
 						      !buffer-&gt;consecutive)) {
 		b-&gt;consecutive = false;
<span class="p_header">diff --git a/tools/spi/spidev_test.c b/tools/spi/spidev_test.c</span>
<span class="p_header">index 8a73d8185316..f3825b676e38 100644</span>
<span class="p_header">--- a/tools/spi/spidev_test.c</span>
<span class="p_header">+++ b/tools/spi/spidev_test.c</span>
<span class="p_chunk">@@ -284,7 +284,7 @@</span> <span class="p_context"> static void parse_opts(int argc, char *argv[])</span>
 
 static void transfer_escaped_string(int fd, char *str)
 {
<span class="p_del">-	size_t size = strlen(str + 1);</span>
<span class="p_add">+	size_t size = strlen(str);</span>
 	uint8_t *tx;
 	uint8_t *rx;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



