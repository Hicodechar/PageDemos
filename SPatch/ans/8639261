
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[1/2] mm/hugetlb: Introduce hugetlb_bad_size - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [1/2] mm/hugetlb: Introduce hugetlb_bad_size</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=154701">Vaishali Thakkar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 22, 2016, 10 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1458640843-13483-1-git-send-email-vaishali.thakkar@oracle.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8639261/mbox/"
   >mbox</a>
|
   <a href="/patch/8639261/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8639261/">/patch/8639261/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 459CB9F36E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 22 Mar 2016 10:12:14 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id C2FA32038A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 22 Mar 2016 10:12:10 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id D382020397
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 22 Mar 2016 10:12:05 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1758619AbcCVKMC (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 22 Mar 2016 06:12:02 -0400
Received: from userp1040.oracle.com ([156.151.31.81]:21872 &quot;EHLO
	userp1040.oracle.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1756105AbcCVKLz (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 22 Mar 2016 06:11:55 -0400
Received: from userv0021.oracle.com (userv0021.oracle.com [156.151.31.71])
	by userp1040.oracle.com (Sentrion-MTA-4.3.2/Sentrion-MTA-4.3.2) with
	ESMTP id u2MABRK1001826
	(version=TLSv1 cipher=DHE-RSA-AES256-SHA bits=256 verify=OK);
	Tue, 22 Mar 2016 10:11:27 GMT
Received: from aserv0121.oracle.com (aserv0121.oracle.com [141.146.126.235])
	by userv0021.oracle.com (8.13.8/8.13.8) with ESMTP id
	u2MABQI5001529
	(version=TLSv1/SSLv3 cipher=DHE-RSA-AES256-SHA bits=256 verify=FAIL); 
	Tue, 22 Mar 2016 10:11:26 GMT
Received: from abhmp0005.oracle.com (abhmp0005.oracle.com [141.146.116.11])
	by aserv0121.oracle.com (8.13.8/8.13.8) with ESMTP id
	u2MABPsw004792; Tue, 22 Mar 2016 10:11:25 GMT
Received: from vaishali.oracle.com (/43.249.235.45)
	by default (Oracle Beehive Gateway v4.0)
	with ESMTP ; Tue, 22 Mar 2016 03:11:24 -0700
From: Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;
To: akpm@linux-foundation.org
Cc: linux-kernel@vger.kernel.org, linux-mm@kvack.org,
	Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;,
	Mike Kravetz &lt;mike.kravetz@oracle.com&gt;,
	Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;,
	Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;, Michal Hocko &lt;mhocko@suse.com&gt;,
	Yaowei Bai &lt;baiyaowei@cmss.chinamobile.com&gt;,
	Dominik Dingel &lt;dingel@linux.vnet.ibm.com&gt;,
	&quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;,
	Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;,
	Dave Hansen &lt;dave.hansen@linux.intel.com&gt;
Subject: [PATCH 1/2] mm/hugetlb: Introduce hugetlb_bad_size
Date: Tue, 22 Mar 2016 15:30:43 +0530
Message-Id: &lt;1458640843-13483-1-git-send-email-vaishali.thakkar@oracle.com&gt;
X-Mailer: git-send-email 2.1.4
X-Source-IP: userv0021.oracle.com [156.151.31.71]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=154701">Vaishali Thakkar</a> - March 22, 2016, 10 a.m.</div>
<pre class="content">
When any unsupported hugepage size is specified, &#39;hugepagesz=&#39; and
&#39;hugepages=&#39; should be ignored during command line parsing until any
supported hugepage size is found. But currently incorrect number of
hugepages are allocated when unsupported size is specified as it fails
to ignore the &#39;hugepages=&#39; command.

Test case:

Note that this is specific to x86 architecture.

Boot the kernel with command line option &#39;hugepagesz=256M hugepages=X&#39;.
After boot, dmesg output shows that X number of hugepages of the size 2M
is pre-allocated instead of 0.

So, to handle such command line options, introduce new routine
hugetlb_bad_size. The routine hugetlb_bad_size sets the global variable
parsed_valid_hugepagesz. We are using parsed_valid_hugepagesz to save the
state when unsupported hugepagesize is found so that we can ignore the
&#39;hugepages=&#39; parameters after that and then reset the variable when
supported hugepage size is found.

The routine hugetlb_bad_size can be called while setting &#39;hugepagesz=&#39;
parameter in an architecture specific code.
<span class="signed-off-by">
Signed-off-by: Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;</span>
Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;
Cc: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;
Cc: Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;
Cc: Michal Hocko &lt;mhocko@suse.com&gt;
Cc: Yaowei Bai &lt;baiyaowei@cmss.chinamobile.com&gt;
Cc: Dominik Dingel &lt;dingel@linux.vnet.ibm.com&gt;
Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;
Cc: Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;
Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;
---
The patch is having 2 checkpatch.pl warnings. I have just followed
the current code to maintain consistency. If we decide to silent
these warnings then may be we should silent those warnings as well.
I am fine with any option whichever works best for everyone else. 
---
 include/linux/hugetlb.h |  1 +
 mm/hugetlb.c            | 14 +++++++++++++-
 2 files changed, 14 insertions(+), 1 deletion(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=50221">SeongJae Park</a> - March 22, 2016, 11:27 p.m.</div>
<pre class="content">
Hello Vaishali,


The patch looks good to me.  However, I have few trivial questions.

On Tue, 22 Mar 2016, Vaishali Thakkar wrote:
<span class="quote">
&gt; When any unsupported hugepage size is specified, &#39;hugepagesz=&#39; and</span>
<span class="quote">&gt; &#39;hugepages=&#39; should be ignored during command line parsing until any</span>
<span class="quote">&gt; supported hugepage size is found. But currently incorrect number of</span>
<span class="quote">&gt; hugepages are allocated when unsupported size is specified as it fails</span>
<span class="quote">&gt; to ignore the &#39;hugepages=&#39; command.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Test case:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Note that this is specific to x86 architecture.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Boot the kernel with command line option &#39;hugepagesz=256M hugepages=X&#39;.</span>
<span class="quote">&gt; After boot, dmesg output shows that X number of hugepages of the size 2M</span>
<span class="quote">&gt; is pre-allocated instead of 0.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So, to handle such command line options, introduce new routine</span>
<span class="quote">&gt; hugetlb_bad_size. The routine hugetlb_bad_size sets the global variable</span>
<span class="quote">&gt; parsed_valid_hugepagesz. We are using parsed_valid_hugepagesz to save the</span>
<span class="quote">&gt; state when unsupported hugepagesize is found so that we can ignore the</span>
<span class="quote">&gt; &#39;hugepages=&#39; parameters after that and then reset the variable when</span>
<span class="quote">&gt; supported hugepage size is found.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The routine hugetlb_bad_size can be called while setting &#39;hugepagesz=&#39;</span>
<span class="quote">&gt; parameter in an architecture specific code.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;</span>
<span class="quote">&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt; Cc: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt; Cc: Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;</span>
<span class="quote">&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; Cc: Yaowei Bai &lt;baiyaowei@cmss.chinamobile.com&gt;</span>
<span class="quote">&gt; Cc: Dominik Dingel &lt;dingel@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt; Cc: Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; The patch is having 2 checkpatch.pl warnings. I have just followed</span>
<span class="quote">&gt; the current code to maintain consistency. If we decide to silent</span>
<span class="quote">&gt; these warnings then may be we should silent those warnings as well.</span>
<span class="quote">&gt; I am fine with any option whichever works best for everyone else.</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; include/linux/hugetlb.h |  1 +</span>
<span class="quote">&gt; mm/hugetlb.c            | 14 +++++++++++++-</span>
<span class="quote">&gt; 2 files changed, 14 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt; index 7d953c2..e44c578 100644</span>
<span class="quote">&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt; @@ -338,6 +338,7 @@ int huge_add_to_page_cache(struct page *page, struct address_space *mapping,</span>
<span class="quote">&gt; /* arch callback */</span>
<span class="quote">&gt; int __init alloc_bootmem_huge_page(struct hstate *h);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +void __init hugetlb_bad_size(void);</span>
<span class="quote">&gt; void __init hugetlb_add_hstate(unsigned order);</span>
<span class="quote">&gt; struct hstate *size_to_hstate(unsigned long size);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt; index 06058ea..44fae6a 100644</span>
<span class="quote">&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -51,6 +51,7 @@ __initdata LIST_HEAD(huge_boot_pages);</span>
<span class="quote">&gt; static struct hstate * __initdata parsed_hstate;</span>
<span class="quote">&gt; static unsigned long __initdata default_hstate_max_huge_pages;</span>
<span class="quote">&gt; static unsigned long __initdata default_hstate_size;</span>
<span class="quote">&gt; +static bool __initdata parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; /*</span>
<span class="quote">&gt;  * Protects updates to hugepage_freelists, hugepage_activelist, nr_huge_pages,</span>
<span class="quote">&gt; @@ -2659,6 +2660,11 @@ static int __init hugetlb_init(void)</span>
<span class="quote">&gt; subsys_initcall(hugetlb_init);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; /* Should be called on processing a hugepagesz=... option */</span>
<span class="quote">&gt; +void __init hugetlb_bad_size(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	parsed_valid_hugepagesz = false;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; void __init hugetlb_add_hstate(unsigned int order)</span>
<span class="quote">&gt; {</span>
<span class="quote">&gt; 	struct hstate *h;</span>
<span class="quote">&gt; @@ -2691,11 +2697,17 @@ static int __init hugetlb_nrpages_setup(char *s)</span>
<span class="quote">&gt; 	unsigned long *mhp;</span>
<span class="quote">&gt; 	static unsigned long *last_mhp;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +	if (!parsed_valid_hugepagesz) {</span>
<span class="quote">&gt; +		pr_warn(&quot;hugepages = %s preceded by &quot;</span>
<span class="quote">&gt; +			&quot;an unsupported hugepagesz, ignoring\n&quot;, s);</span>

How about concatenating the format string?  `CodingStyle` now suggests to
_never_ break every user-visible strings.
<span class="quote">
&gt; +		parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt; +		return 1;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; 	/*</span>
<span class="quote">&gt; 	 * !hugetlb_max_hstate means we haven&#39;t parsed a hugepagesz= parameter yet,</span>
<span class="quote">&gt; 	 * so this hugepages= parameter goes to the &quot;default hstate&quot;.</span>
<span class="quote">&gt; 	 */</span>
<span class="quote">&gt; -	if (!hugetlb_max_hstate)</span>
<span class="quote">&gt; +	else if (!hugetlb_max_hstate)</span>

Because the upper `if` statement will do `return`, above change looks not
significantly necessary.  Is this intended?
<span class="quote">
&gt; 		mhp = &amp;default_hstate_max_huge_pages;</span>
<span class="quote">&gt; 	else</span>
<span class="quote">&gt; 		mhp = &amp;parsed_hstate-&gt;max_huge_pages;</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.1.4</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe, send a message with &#39;unsubscribe linux-mm&#39; in</span>
<span class="quote">&gt; the body to majordomo@kvack.org.  For more info on Linux MM,</span>
<span class="quote">&gt; see: http://www.linux-mm.org/ .</span>
<span class="quote">&gt; Don&#39;t email: &lt;a href=mailto:&quot;dont@kvack.org&quot;&gt; email@kvack.org &lt;/a&gt;</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=4407">Naoya Horiguchi</a> - March 22, 2016, 11:36 p.m.</div>
<pre class="content">
On Tue, Mar 22, 2016 at 03:30:43PM +0530, Vaishali Thakkar wrote:
<span class="quote">&gt; When any unsupported hugepage size is specified, &#39;hugepagesz=&#39; and</span>
<span class="quote">&gt; &#39;hugepages=&#39; should be ignored during command line parsing until any</span>
<span class="quote">&gt; supported hugepage size is found. But currently incorrect number of</span>
<span class="quote">&gt; hugepages are allocated when unsupported size is specified as it fails</span>
<span class="quote">&gt; to ignore the &#39;hugepages=&#39; command.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Test case:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Note that this is specific to x86 architecture.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Boot the kernel with command line option &#39;hugepagesz=256M hugepages=X&#39;.</span>
<span class="quote">&gt; After boot, dmesg output shows that X number of hugepages of the size 2M</span>
<span class="quote">&gt; is pre-allocated instead of 0.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So, to handle such command line options, introduce new routine</span>
<span class="quote">&gt; hugetlb_bad_size. The routine hugetlb_bad_size sets the global variable</span>
<span class="quote">&gt; parsed_valid_hugepagesz. We are using parsed_valid_hugepagesz to save the</span>
<span class="quote">&gt; state when unsupported hugepagesize is found so that we can ignore the</span>
<span class="quote">&gt; &#39;hugepages=&#39; parameters after that and then reset the variable when</span>
<span class="quote">&gt; supported hugepage size is found.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The routine hugetlb_bad_size can be called while setting &#39;hugepagesz=&#39;</span>
<span class="quote">&gt; parameter in an architecture specific code.</span>
<span class="quote">
&gt; Signed-off-by: Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;</span>
<span class="quote">&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt; Cc: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt; Cc: Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;</span>
<span class="quote">&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; Cc: Yaowei Bai &lt;baiyaowei@cmss.chinamobile.com&gt;</span>
<span class="quote">&gt; Cc: Dominik Dingel &lt;dingel@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt; Cc: Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;</span>

Maybe parsed_hstate can do what parsed_valid_hugepagesz does, but both
are __initdata so it&#39;s not a big deal.
<span class="reviewed-by">
Reviewed-by: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">
&gt; ---</span>
<span class="quote">&gt; The patch is having 2 checkpatch.pl warnings. I have just followed</span>
<span class="quote">&gt; the current code to maintain consistency. If we decide to silent</span>
<span class="quote">&gt; these warnings then may be we should silent those warnings as well.</span>
<span class="quote">&gt; I am fine with any option whichever works best for everyone else. </span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  include/linux/hugetlb.h |  1 +</span>
<span class="quote">&gt;  mm/hugetlb.c            | 14 +++++++++++++-</span>
<span class="quote">&gt;  2 files changed, 14 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt; index 7d953c2..e44c578 100644</span>
<span class="quote">&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt; @@ -338,6 +338,7 @@ int huge_add_to_page_cache(struct page *page, struct address_space *mapping,</span>
<span class="quote">&gt;  /* arch callback */</span>
<span class="quote">&gt;  int __init alloc_bootmem_huge_page(struct hstate *h);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +void __init hugetlb_bad_size(void);</span>
<span class="quote">&gt;  void __init hugetlb_add_hstate(unsigned order);</span>
<span class="quote">&gt;  struct hstate *size_to_hstate(unsigned long size);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt; index 06058ea..44fae6a 100644</span>
<span class="quote">&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -51,6 +51,7 @@ __initdata LIST_HEAD(huge_boot_pages);</span>
<span class="quote">&gt;  static struct hstate * __initdata parsed_hstate;</span>
<span class="quote">&gt;  static unsigned long __initdata default_hstate_max_huge_pages;</span>
<span class="quote">&gt;  static unsigned long __initdata default_hstate_size;</span>
<span class="quote">&gt; +static bool __initdata parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Protects updates to hugepage_freelists, hugepage_activelist, nr_huge_pages,</span>
<span class="quote">&gt; @@ -2659,6 +2660,11 @@ static int __init hugetlb_init(void)</span>
<span class="quote">&gt;  subsys_initcall(hugetlb_init);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Should be called on processing a hugepagesz=... option */</span>
<span class="quote">&gt; +void __init hugetlb_bad_size(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	parsed_valid_hugepagesz = false;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  void __init hugetlb_add_hstate(unsigned int order)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct hstate *h;</span>
<span class="quote">&gt; @@ -2691,11 +2697,17 @@ static int __init hugetlb_nrpages_setup(char *s)</span>
<span class="quote">&gt;  	unsigned long *mhp;</span>
<span class="quote">&gt;  	static unsigned long *last_mhp;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	if (!parsed_valid_hugepagesz) {</span>
<span class="quote">&gt; +		pr_warn(&quot;hugepages = %s preceded by &quot;</span>
<span class="quote">&gt; +			&quot;an unsupported hugepagesz, ignoring\n&quot;, s);</span>
<span class="quote">&gt; +		parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt; +		return 1;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * !hugetlb_max_hstate means we haven&#39;t parsed a hugepagesz= parameter yet,</span>
<span class="quote">&gt;  	 * so this hugepages= parameter goes to the &quot;default hstate&quot;.</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt; -	if (!hugetlb_max_hstate)</span>
<span class="quote">&gt; +	else if (!hugetlb_max_hstate)</span>
<span class="quote">&gt;  		mhp = &amp;default_hstate_max_huge_pages;</span>
<span class="quote">&gt;  	else</span>
<span class="quote">&gt;  		mhp = &amp;parsed_hstate-&gt;max_huge_pages;</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.1.4</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=124511">Mike Kravetz</a> - March 23, 2016, 2:40 a.m.</div>
<pre class="content">
On 03/22/2016 03:00 AM, Vaishali Thakkar wrote:
<span class="quote">&gt; When any unsupported hugepage size is specified, &#39;hugepagesz=&#39; and</span>
<span class="quote">&gt; &#39;hugepages=&#39; should be ignored during command line parsing until any</span>
<span class="quote">&gt; supported hugepage size is found. But currently incorrect number of</span>
<span class="quote">&gt; hugepages are allocated when unsupported size is specified as it fails</span>
<span class="quote">&gt; to ignore the &#39;hugepages=&#39; command.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Test case:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Note that this is specific to x86 architecture.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Boot the kernel with command line option &#39;hugepagesz=256M hugepages=X&#39;.</span>
<span class="quote">&gt; After boot, dmesg output shows that X number of hugepages of the size 2M</span>
<span class="quote">&gt; is pre-allocated instead of 0.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So, to handle such command line options, introduce new routine</span>
<span class="quote">&gt; hugetlb_bad_size. The routine hugetlb_bad_size sets the global variable</span>
<span class="quote">&gt; parsed_valid_hugepagesz. We are using parsed_valid_hugepagesz to save the</span>
<span class="quote">&gt; state when unsupported hugepagesize is found so that we can ignore the</span>
<span class="quote">&gt; &#39;hugepages=&#39; parameters after that and then reset the variable when</span>
<span class="quote">&gt; supported hugepage size is found.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The routine hugetlb_bad_size can be called while setting &#39;hugepagesz=&#39;</span>
<span class="quote">&gt; parameter in an architecture specific code.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;</span>
<span class="quote">&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt; Cc: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt; Cc: Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;</span>
<span class="quote">&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; Cc: Yaowei Bai &lt;baiyaowei@cmss.chinamobile.com&gt;</span>
<span class="quote">&gt; Cc: Dominik Dingel &lt;dingel@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt; Cc: Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;</span>
<span class="quote">&gt; ---</span>

Looks fine to me,
<span class="reviewed-by">
Reviewed-by: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">
&gt; The patch is having 2 checkpatch.pl warnings. I have just followed</span>
<span class="quote">&gt; the current code to maintain consistency. If we decide to silent</span>
<span class="quote">&gt; these warnings then may be we should silent those warnings as well.</span>
<span class="quote">&gt; I am fine with any option whichever works best for everyone else. </span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  include/linux/hugetlb.h |  1 +</span>
<span class="quote">&gt;  mm/hugetlb.c            | 14 +++++++++++++-</span>
<span class="quote">&gt;  2 files changed, 14 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt; index 7d953c2..e44c578 100644</span>
<span class="quote">&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt; @@ -338,6 +338,7 @@ int huge_add_to_page_cache(struct page *page, struct address_space *mapping,</span>
<span class="quote">&gt;  /* arch callback */</span>
<span class="quote">&gt;  int __init alloc_bootmem_huge_page(struct hstate *h);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +void __init hugetlb_bad_size(void);</span>
<span class="quote">&gt;  void __init hugetlb_add_hstate(unsigned order);</span>
<span class="quote">&gt;  struct hstate *size_to_hstate(unsigned long size);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt; index 06058ea..44fae6a 100644</span>
<span class="quote">&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -51,6 +51,7 @@ __initdata LIST_HEAD(huge_boot_pages);</span>
<span class="quote">&gt;  static struct hstate * __initdata parsed_hstate;</span>
<span class="quote">&gt;  static unsigned long __initdata default_hstate_max_huge_pages;</span>
<span class="quote">&gt;  static unsigned long __initdata default_hstate_size;</span>
<span class="quote">&gt; +static bool __initdata parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Protects updates to hugepage_freelists, hugepage_activelist, nr_huge_pages,</span>
<span class="quote">&gt; @@ -2659,6 +2660,11 @@ static int __init hugetlb_init(void)</span>
<span class="quote">&gt;  subsys_initcall(hugetlb_init);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* Should be called on processing a hugepagesz=... option */</span>
<span class="quote">&gt; +void __init hugetlb_bad_size(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	parsed_valid_hugepagesz = false;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  void __init hugetlb_add_hstate(unsigned int order)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct hstate *h;</span>
<span class="quote">&gt; @@ -2691,11 +2697,17 @@ static int __init hugetlb_nrpages_setup(char *s)</span>
<span class="quote">&gt;  	unsigned long *mhp;</span>
<span class="quote">&gt;  	static unsigned long *last_mhp;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	if (!parsed_valid_hugepagesz) {</span>
<span class="quote">&gt; +		pr_warn(&quot;hugepages = %s preceded by &quot;</span>
<span class="quote">&gt; +			&quot;an unsupported hugepagesz, ignoring\n&quot;, s);</span>
<span class="quote">&gt; +		parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt; +		return 1;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * !hugetlb_max_hstate means we haven&#39;t parsed a hugepagesz= parameter yet,</span>
<span class="quote">&gt;  	 * so this hugepages= parameter goes to the &quot;default hstate&quot;.</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt; -	if (!hugetlb_max_hstate)</span>
<span class="quote">&gt; +	else if (!hugetlb_max_hstate)</span>
<span class="quote">&gt;  		mhp = &amp;default_hstate_max_huge_pages;</span>
<span class="quote">&gt;  	else</span>
<span class="quote">&gt;  		mhp = &amp;parsed_hstate-&gt;max_huge_pages;</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=154701">Vaishali Thakkar</a> - March 23, 2016, 4:02 a.m.</div>
<pre class="content">
On Wednesday 23 March 2016 04:57 AM, SeongJae Park wrote:
<span class="quote">&gt; Hello Vaishali,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The patch looks good to me.  However, I have few trivial questions.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On Tue, 22 Mar 2016, Vaishali Thakkar wrote:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; When any unsupported hugepage size is specified, &#39;hugepagesz=&#39; and</span>
<span class="quote">&gt;&gt; &#39;hugepages=&#39; should be ignored during command line parsing until any</span>
<span class="quote">&gt;&gt; supported hugepage size is found. But currently incorrect number of</span>
<span class="quote">&gt;&gt; hugepages are allocated when unsupported size is specified as it fails</span>
<span class="quote">&gt;&gt; to ignore the &#39;hugepages=&#39; command.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Test case:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Note that this is specific to x86 architecture.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Boot the kernel with command line option &#39;hugepagesz=256M hugepages=X&#39;.</span>
<span class="quote">&gt;&gt; After boot, dmesg output shows that X number of hugepages of the size 2M</span>
<span class="quote">&gt;&gt; is pre-allocated instead of 0.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; So, to handle such command line options, introduce new routine</span>
<span class="quote">&gt;&gt; hugetlb_bad_size. The routine hugetlb_bad_size sets the global variable</span>
<span class="quote">&gt;&gt; parsed_valid_hugepagesz. We are using parsed_valid_hugepagesz to save the</span>
<span class="quote">&gt;&gt; state when unsupported hugepagesize is found so that we can ignore the</span>
<span class="quote">&gt;&gt; &#39;hugepages=&#39; parameters after that and then reset the variable when</span>
<span class="quote">&gt;&gt; supported hugepage size is found.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The routine hugetlb_bad_size can be called while setting &#39;hugepagesz=&#39;</span>
<span class="quote">&gt;&gt; parameter in an architecture specific code.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Yaowei Bai &lt;baiyaowei@cmss.chinamobile.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Dominik Dingel &lt;dingel@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;</span>
<span class="quote">&gt;&gt; Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt; The patch is having 2 checkpatch.pl warnings. I have just followed</span>
<span class="quote">&gt;&gt; the current code to maintain consistency. If we decide to silent</span>
<span class="quote">&gt;&gt; these warnings then may be we should silent those warnings as well.</span>
<span class="quote">&gt;&gt; I am fine with any option whichever works best for everyone else.</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt; include/linux/hugetlb.h |  1 +</span>
<span class="quote">&gt;&gt; mm/hugetlb.c            | 14 +++++++++++++-</span>
<span class="quote">&gt;&gt; 2 files changed, 14 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt;&gt; index 7d953c2..e44c578 100644</span>
<span class="quote">&gt;&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt;&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt;&gt; @@ -338,6 +338,7 @@ int huge_add_to_page_cache(struct page *page, struct address_space *mapping,</span>
<span class="quote">&gt;&gt; /* arch callback */</span>
<span class="quote">&gt;&gt; int __init alloc_bootmem_huge_page(struct hstate *h);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +void __init hugetlb_bad_size(void);</span>
<span class="quote">&gt;&gt; void __init hugetlb_add_hstate(unsigned order);</span>
<span class="quote">&gt;&gt; struct hstate *size_to_hstate(unsigned long size);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt;&gt; index 06058ea..44fae6a 100644</span>
<span class="quote">&gt;&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt;&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt;&gt; @@ -51,6 +51,7 @@ __initdata LIST_HEAD(huge_boot_pages);</span>
<span class="quote">&gt;&gt; static struct hstate * __initdata parsed_hstate;</span>
<span class="quote">&gt;&gt; static unsigned long __initdata default_hstate_max_huge_pages;</span>
<span class="quote">&gt;&gt; static unsigned long __initdata default_hstate_size;</span>
<span class="quote">&gt;&gt; +static bool __initdata parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; /*</span>
<span class="quote">&gt;&gt;  * Protects updates to hugepage_freelists, hugepage_activelist, nr_huge_pages,</span>
<span class="quote">&gt;&gt; @@ -2659,6 +2660,11 @@ static int __init hugetlb_init(void)</span>
<span class="quote">&gt;&gt; subsys_initcall(hugetlb_init);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; /* Should be called on processing a hugepagesz=... option */</span>
<span class="quote">&gt;&gt; +void __init hugetlb_bad_size(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +    parsed_valid_hugepagesz = false;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; void __init hugetlb_add_hstate(unsigned int order)</span>
<span class="quote">&gt;&gt; {</span>
<span class="quote">&gt;&gt;     struct hstate *h;</span>
<span class="quote">&gt;&gt; @@ -2691,11 +2697,17 @@ static int __init hugetlb_nrpages_setup(char *s)</span>
<span class="quote">&gt;&gt;     unsigned long *mhp;</span>
<span class="quote">&gt;&gt;     static unsigned long *last_mhp;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +    if (!parsed_valid_hugepagesz) {</span>
<span class="quote">&gt;&gt; +        pr_warn(&quot;hugepages = %s preceded by &quot;</span>
<span class="quote">&gt;&gt; +            &quot;an unsupported hugepagesz, ignoring\n&quot;, s);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; How about concatenating the format string?  `CodingStyle` now suggests to</span>
<span class="quote">&gt; _never_ break every user-visible strings.</span>
<span class="quote">&gt;</span>

As I said above, I just followed the pattern of the current code to maintain the
consistency. Probably a separate change would be good for solving all those
warnings. :)
<span class="quote">
&gt;&gt; +        parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt;&gt; +        return 1;</span>
<span class="quote">&gt;&gt; +    }</span>
<span class="quote">&gt;&gt;     /*</span>
<span class="quote">&gt;&gt;      * !hugetlb_max_hstate means we haven&#39;t parsed a hugepagesz= parameter yet,</span>
<span class="quote">&gt;&gt;      * so this hugepages= parameter goes to the &quot;default hstate&quot;.</span>
<span class="quote">&gt;&gt;      */</span>
<span class="quote">&gt;&gt; -    if (!hugetlb_max_hstate)</span>
<span class="quote">&gt;&gt; +    else if (!hugetlb_max_hstate)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Because the upper `if` statement will do `return`, above change looks not</span>
<span class="quote">&gt; significantly necessary.  Is this intended?</span>
<span class="quote">&gt;</span>

I think above change is necessary for the cases like &quot;hugepages=X&quot; because in that
case the X hugepages of the default size [like 2M for x86] should be allocated.
<span class="quote">
&gt;&gt;         mhp = &amp;default_hstate_max_huge_pages;</span>
<span class="quote">&gt;&gt;     else</span>
<span class="quote">&gt;&gt;         mhp = &amp;parsed_hstate-&gt;max_huge_pages;</span>
<span class="quote">&gt;&gt; -- </span>
<span class="quote">&gt;&gt; 2.1.4</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; -- </span>
<span class="quote">&gt;&gt; To unsubscribe, send a message with &#39;unsubscribe linux-mm&#39; in</span>
<span class="quote">&gt;&gt; the body to majordomo@kvack.org.  For more info on Linux MM,</span>
<span class="quote">&gt;&gt; see: http://www.linux-mm.org/ .</span>
<span class="quote">&gt;&gt; Don&#39;t email: &lt;a href=mailto:&quot;dont@kvack.org&quot;&gt; email@kvack.org &lt;/a&gt;</span>
<span class="quote">&gt;&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=50221">SeongJae Park</a> - March 23, 2016, 4:40 a.m.</div>
<pre class="content">
On Wed, 23 Mar 2016, Vaishali Thakkar wrote:
<span class="quote">
&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On Wednesday 23 March 2016 04:57 AM, SeongJae Park wrote:</span>
<span class="quote">&gt;&gt; Hello Vaishali,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The patch looks good to me.  However, I have few trivial questions.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Tue, 22 Mar 2016, Vaishali Thakkar wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; When any unsupported hugepage size is specified, &#39;hugepagesz=&#39; and</span>
<span class="quote">&gt;&gt;&gt; &#39;hugepages=&#39; should be ignored during command line parsing until any</span>
<span class="quote">&gt;&gt;&gt; supported hugepage size is found. But currently incorrect number of</span>
<span class="quote">&gt;&gt;&gt; hugepages are allocated when unsupported size is specified as it fails</span>
<span class="quote">&gt;&gt;&gt; to ignore the &#39;hugepages=&#39; command.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Test case:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Note that this is specific to x86 architecture.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Boot the kernel with command line option &#39;hugepagesz=256M hugepages=X&#39;.</span>
<span class="quote">&gt;&gt;&gt; After boot, dmesg output shows that X number of hugepages of the size 2M</span>
<span class="quote">&gt;&gt;&gt; is pre-allocated instead of 0.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; So, to handle such command line options, introduce new routine</span>
<span class="quote">&gt;&gt;&gt; hugetlb_bad_size. The routine hugetlb_bad_size sets the global variable</span>
<span class="quote">&gt;&gt;&gt; parsed_valid_hugepagesz. We are using parsed_valid_hugepagesz to save the</span>
<span class="quote">&gt;&gt;&gt; state when unsupported hugepagesize is found so that we can ignore the</span>
<span class="quote">&gt;&gt;&gt; &#39;hugepages=&#39; parameters after that and then reset the variable when</span>
<span class="quote">&gt;&gt;&gt; supported hugepage size is found.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; The routine hugetlb_bad_size can be called while setting &#39;hugepagesz=&#39;</span>
<span class="quote">&gt;&gt;&gt; parameter in an architecture specific code.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Vaishali Thakkar &lt;vaishali.thakkar@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Yaowei Bai &lt;baiyaowei@cmss.chinamobile.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Dominik Dingel &lt;dingel@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Paul Gortmaker &lt;paul.gortmaker@windriver.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Cc: Dave Hansen &lt;dave.hansen@linux.intel.com&gt;</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt; The patch is having 2 checkpatch.pl warnings. I have just followed</span>
<span class="quote">&gt;&gt;&gt; the current code to maintain consistency. If we decide to silent</span>
<span class="quote">&gt;&gt;&gt; these warnings then may be we should silent those warnings as well.</span>
<span class="quote">&gt;&gt;&gt; I am fine with any option whichever works best for everyone else.</span>
<span class="quote">&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt; include/linux/hugetlb.h |  1 +</span>
<span class="quote">&gt;&gt;&gt; mm/hugetlb.c            | 14 +++++++++++++-</span>
<span class="quote">&gt;&gt;&gt; 2 files changed, 14 insertions(+), 1 deletion(-)</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt;&gt;&gt; index 7d953c2..e44c578 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt;&gt;&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt;&gt;&gt; @@ -338,6 +338,7 @@ int huge_add_to_page_cache(struct page *page, struct address_space *mapping,</span>
<span class="quote">&gt;&gt;&gt; /* arch callback */</span>
<span class="quote">&gt;&gt;&gt; int __init alloc_bootmem_huge_page(struct hstate *h);</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +void __init hugetlb_bad_size(void);</span>
<span class="quote">&gt;&gt;&gt; void __init hugetlb_add_hstate(unsigned order);</span>
<span class="quote">&gt;&gt;&gt; struct hstate *size_to_hstate(unsigned long size);</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt;&gt;&gt; index 06058ea..44fae6a 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt;&gt;&gt; @@ -51,6 +51,7 @@ __initdata LIST_HEAD(huge_boot_pages);</span>
<span class="quote">&gt;&gt;&gt; static struct hstate * __initdata parsed_hstate;</span>
<span class="quote">&gt;&gt;&gt; static unsigned long __initdata default_hstate_max_huge_pages;</span>
<span class="quote">&gt;&gt;&gt; static unsigned long __initdata default_hstate_size;</span>
<span class="quote">&gt;&gt;&gt; +static bool __initdata parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; /*</span>
<span class="quote">&gt;&gt;&gt;  * Protects updates to hugepage_freelists, hugepage_activelist, nr_huge_pages,</span>
<span class="quote">&gt;&gt;&gt; @@ -2659,6 +2660,11 @@ static int __init hugetlb_init(void)</span>
<span class="quote">&gt;&gt;&gt; subsys_initcall(hugetlb_init);</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; /* Should be called on processing a hugepagesz=... option */</span>
<span class="quote">&gt;&gt;&gt; +void __init hugetlb_bad_size(void)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +    parsed_valid_hugepagesz = false;</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; void __init hugetlb_add_hstate(unsigned int order)</span>
<span class="quote">&gt;&gt;&gt; {</span>
<span class="quote">&gt;&gt;&gt;     struct hstate *h;</span>
<span class="quote">&gt;&gt;&gt; @@ -2691,11 +2697,17 @@ static int __init hugetlb_nrpages_setup(char *s)</span>
<span class="quote">&gt;&gt;&gt;     unsigned long *mhp;</span>
<span class="quote">&gt;&gt;&gt;     static unsigned long *last_mhp;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +    if (!parsed_valid_hugepagesz) {</span>
<span class="quote">&gt;&gt;&gt; +        pr_warn(&quot;hugepages = %s preceded by &quot;</span>
<span class="quote">&gt;&gt;&gt; +            &quot;an unsupported hugepagesz, ignoring\n&quot;, s);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; How about concatenating the format string?  `CodingStyle` now suggests to</span>
<span class="quote">&gt;&gt; _never_ break every user-visible strings.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; As I said above, I just followed the pattern of the current code to maintain the</span>
<span class="quote">&gt; consistency. Probably a separate change would be good for solving all those</span>
<span class="quote">&gt; warnings. :)</span>

Understood and agreed. :)
<span class="quote">

&gt;</span>
<span class="quote">&gt;&gt;&gt; +        parsed_valid_hugepagesz = true;</span>
<span class="quote">&gt;&gt;&gt; +        return 1;</span>
<span class="quote">&gt;&gt;&gt; +    }</span>
<span class="quote">&gt;&gt;&gt;     /*</span>
<span class="quote">&gt;&gt;&gt;      * !hugetlb_max_hstate means we haven&#39;t parsed a hugepagesz= parameter yet,</span>
<span class="quote">&gt;&gt;&gt;      * so this hugepages= parameter goes to the &quot;default hstate&quot;.</span>
<span class="quote">&gt;&gt;&gt;      */</span>
<span class="quote">&gt;&gt;&gt; -    if (!hugetlb_max_hstate)</span>
<span class="quote">&gt;&gt;&gt; +    else if (!hugetlb_max_hstate)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Because the upper `if` statement will do `return`, above change looks not</span>
<span class="quote">&gt;&gt; significantly necessary.  Is this intended?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I think above change is necessary for the cases like &quot;hugepages=X&quot; because in that</span>
<span class="quote">&gt; case the X hugepages of the default size [like 2M for x86] should be allocated.</span>

Looks like my poor English made some confusion, sorry.  I was just saying
about the addition of `else` in the line, not whole change.

Because the upper `if` statement that catching wrong `hugepagesz=` case
does `return`, below statements will not be executed at all in the case.
So, the result will not be changed even if the `else` is not added though
the addition of `else` may help readability for someone.
That&#39;s why I said the change (addition of `else`) looks not significantly
necessary.

If I am missing something wrong, please let me know.  Or, if this question
bothers you, just ignore it because I also know that this is just a
trivial question. ;)


Thanks,
SeongJae Park
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;&gt;         mhp = &amp;default_hstate_max_huge_pages;</span>
<span class="quote">&gt;&gt;&gt;     else</span>
<span class="quote">&gt;&gt;&gt;         mhp = &amp;parsed_hstate-&gt;max_huge_pages;</span>
<span class="quote">&gt;&gt;&gt; --</span>
<span class="quote">&gt;&gt;&gt; 2.1.4</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; --</span>
<span class="quote">&gt;&gt;&gt; To unsubscribe, send a message with &#39;unsubscribe linux-mm&#39; in</span>
<span class="quote">&gt;&gt;&gt; the body to majordomo@kvack.org.  For more info on Linux MM,</span>
<span class="quote">&gt;&gt;&gt; see: http://www.linux-mm.org/ .</span>
<span class="quote">&gt;&gt;&gt; Don&#39;t email: &lt;a href=mailto:&quot;dont@kvack.org&quot;&gt; email@kvack.org &lt;/a&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; Vaishali</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index 7d953c2..e44c578 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -338,6 +338,7 @@</span> <span class="p_context"> int huge_add_to_page_cache(struct page *page, struct address_space *mapping,</span>
 /* arch callback */
 int __init alloc_bootmem_huge_page(struct hstate *h);
 
<span class="p_add">+void __init hugetlb_bad_size(void);</span>
 void __init hugetlb_add_hstate(unsigned order);
 struct hstate *size_to_hstate(unsigned long size);
 
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 06058ea..44fae6a 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -51,6 +51,7 @@</span> <span class="p_context"> __initdata LIST_HEAD(huge_boot_pages);</span>
 static struct hstate * __initdata parsed_hstate;
 static unsigned long __initdata default_hstate_max_huge_pages;
 static unsigned long __initdata default_hstate_size;
<span class="p_add">+static bool __initdata parsed_valid_hugepagesz = true;</span>
 
 /*
  * Protects updates to hugepage_freelists, hugepage_activelist, nr_huge_pages,
<span class="p_chunk">@@ -2659,6 +2660,11 @@</span> <span class="p_context"> static int __init hugetlb_init(void)</span>
 subsys_initcall(hugetlb_init);
 
 /* Should be called on processing a hugepagesz=... option */
<span class="p_add">+void __init hugetlb_bad_size(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	parsed_valid_hugepagesz = false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init hugetlb_add_hstate(unsigned int order)
 {
 	struct hstate *h;
<span class="p_chunk">@@ -2691,11 +2697,17 @@</span> <span class="p_context"> static int __init hugetlb_nrpages_setup(char *s)</span>
 	unsigned long *mhp;
 	static unsigned long *last_mhp;
 
<span class="p_add">+	if (!parsed_valid_hugepagesz) {</span>
<span class="p_add">+		pr_warn(&quot;hugepages = %s preceded by &quot;</span>
<span class="p_add">+			&quot;an unsupported hugepagesz, ignoring\n&quot;, s);</span>
<span class="p_add">+		parsed_valid_hugepagesz = true;</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
 	/*
 	 * !hugetlb_max_hstate means we haven&#39;t parsed a hugepagesz= parameter yet,
 	 * so this hugepages= parameter goes to the &quot;default hstate&quot;.
 	 */
<span class="p_del">-	if (!hugetlb_max_hstate)</span>
<span class="p_add">+	else if (!hugetlb_max_hstate)</span>
 		mhp = &amp;default_hstate_max_huge_pages;
 	else
 		mhp = &amp;parsed_hstate-&gt;max_huge_pages;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



