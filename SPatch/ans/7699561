
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>arm64: calculate the various pages number to show - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    arm64: calculate the various pages number to show</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=146341">zhong jiang</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 25, 2015, 1:41 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1448458872-39897-1-git-send-email-zhongjiang@huawei.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7699561/mbox/"
   >mbox</a>
|
   <a href="/patch/7699561/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7699561/">/patch/7699561/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 4747FBF90C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 25 Nov 2015 13:48:37 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 3F760208E9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 25 Nov 2015 13:48:36 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 15548208E5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 25 Nov 2015 13:48:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754194AbbKYNsc (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 25 Nov 2015 08:48:32 -0500
Received: from szxga03-in.huawei.com ([119.145.14.66]:43863 &quot;EHLO
	szxga03-in.huawei.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752281AbbKYNs3 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 25 Nov 2015 08:48:29 -0500
Received: from 172.24.1.51 (EHLO szxeml433-hub.china.huawei.com)
	([172.24.1.51])
	by szxrg03-dlp.huawei.com (MOS 4.4.3-GA FastPath queued)
	with ESMTP id BRO69204; Wed, 25 Nov 2015 21:47:17 +0800 (CST)
Received: from linux-ibm.site (10.175.102.37) by
	szxeml433-hub.china.huawei.com (10.82.67.210) with Microsoft SMTP
	Server id 14.3.235.1; Wed, 25 Nov 2015 21:47:08 +0800
From: zhongjiang &lt;zhongjiang@huawei.com&gt;
To: &lt;catalin.marinas@arm.com&gt;, &lt;will.deacon@arm.com&gt;,
	&lt;lauraa@codeaurora.org&gt;, &lt;mark.rutland@arm.com&gt;
CC: &lt;zhongjiang@huawei.com&gt;, &lt;qiuxishi@huawei.com&gt;,
	&lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;guohanjun@huawei.com&gt;
Subject: [PATCH] arm64: calculate the various pages number to show
Date: Wed, 25 Nov 2015 21:41:12 +0800
Message-ID: &lt;1448458872-39897-1-git-send-email-zhongjiang@huawei.com&gt;
X-Mailer: git-send-email 1.7.12.4
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [10.175.102.37]
X-CFilter-Loop: Reflected
X-Mirapoint-Virus-RAPID-Raw: score=unknown(0),
	refid=str=0001.0A020201.5655BBEB.020A, ss=1, re=0.000, recu=0.000,
	reip=0.000, cl=1, cld=1, fgs=0, ip=0.0.0.0,
	so=2013-05-26 15:14:31, dmn=2013-03-21 17:37:32
X-Mirapoint-Loop-Id: 1439695f16fdbb6230a571440ac282c6
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=146341">zhong jiang</a> - Nov. 25, 2015, 1:41 p.m.</div>
<pre class="content">
This patch add the interface to show the number of 4KB or 64KB page,
aims to statistics the number of different types of pages.
<span class="signed-off-by">
Signed-off-by: zhongjiang &lt;zhongjiang@huawei.com&gt;</span>
---
 arch/arm64/include/asm/pgtable-types.h |   24 ++++++++++++++++++++++++
 arch/arm64/mm/mmu.c                    |   28 ++++++++++++++++++++++++++++
 arch/arm64/mm/pageattr.c               |   31 +++++++++++++++++++++++++++++++
 3 files changed, 83 insertions(+), 0 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=30282">Mark Rutland</a> - Nov. 25, 2015, 3:04 p.m.</div>
<pre class="content">
On Wed, Nov 25, 2015 at 09:41:12PM +0800, zhongjiang wrote:
<span class="quote">&gt; This patch add the interface to show the number of 4KB or 64KB page,</span>
<span class="quote">&gt; aims to statistics the number of different types of pages.</span>

What is this useful for? Why do we want it?

What does it account for, just the swapper?
<span class="quote">
&gt; Signed-off-by: zhongjiang &lt;zhongjiang@huawei.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm64/include/asm/pgtable-types.h |   24 ++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/arm64/mm/mmu.c                    |   28 ++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/arm64/mm/pageattr.c               |   31 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  3 files changed, 83 insertions(+), 0 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/pgtable-types.h b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt; index 2b1bd7e..aa52546 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt; @@ -86,6 +86,30 @@ typedef pteval_t pgprot_t;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #endif /* STRICT_MM_TYPECHECKS */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +struct seq_file;</span>
<span class="quote">&gt; +extern void arch_report_meminfo(struct seq_file *m);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +enum pg_level {</span>
<span class="quote">&gt; +	PG_LEVEL_NONE,</span>
<span class="quote">&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt; +	PG_LEVEL_4K,</span>
<span class="quote">&gt; +	PG_LEVEL_2M,</span>
<span class="quote">&gt; +	PG_LEVEL_1G,</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +	PG_LEVEL_64K,</span>
<span class="quote">&gt; +	PG_LEVEL_512M,</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +	PG_LEVEL_NUM</span>
<span class="quote">&gt; +};</span>

This doesn&#39;t account for 16K pages, and it means each call site has to
handle the various page sizes directly.

It would be better to simply count PTE/PMD/PUD/PGD, then handle the size
conversion at the end when logging.
<span class="quote">
&gt; @@ -85,6 +86,11 @@ void split_pmd(pmd_t *pmd, pte_t *pte)</span>
<span class="quote">&gt;  		set_pte(pte, pfn_pte(pfn, prot));</span>
<span class="quote">&gt;  		pfn++;</span>
<span class="quote">&gt;  	} while (pte++, i++, i &lt; PTRS_PER_PTE);</span>
<span class="quote">&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt; +	split_page_count(PG_LEVEL_2M);</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +	split_page_count(PG_LEVEL_512M);</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  }</span>

e.g. here you&#39;d just count PG_LEVEL_PMD, which would work regardless of
page size.
<span class="quote">
&gt; diff --git a/arch/arm64/mm/pageattr.c b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt; index 7a5ff11..c1888b9 100644</span>
<span class="quote">&gt; --- a/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt; +++ b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt; @@ -15,12 +15,43 @@</span>
<span class="quote">&gt;  #include &lt;linux/module.h&gt;</span>
<span class="quote">&gt;  #include &lt;linux/sched.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +#include &lt;linux/seq_file.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;  #include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #include &quot;mm.h&quot;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static unsigned long direct_pages_count[PG_LEVEL_NUM];</span>

This doesn&#39;t match reality by the time we start executing the kernel,
given we created page tables in head.S.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +void update_page_count(int level, unsigned long pages)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	direct_pages_count[level] += pages;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void split_page_count(int level)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	direct_pages_count[level]--;</span>
<span class="quote">&gt; +	direct_pages_count[level-1] += PTRS_PER_PTE;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void arch_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt; +	seq_printf(m, &quot;DirectMap4k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; +			direct_pages_count[PG_LEVEL_4K] &lt;&lt; 2);</span>
<span class="quote">&gt; +	seq_printf(m, &quot;DirectMap2M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; +			direct_pages_count[PG_LEVEL_2M] &lt;&lt; 11);</span>
<span class="quote">&gt; +	seq_printf(m, &quot;DirectMap1G:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; +			direct_pages_count[PG_LEVEL_1G] &lt;&lt; 20);</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +	seq_printf(m, &quot;DirectMap64k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; +			direct_pages_count[PG_LEVEL_64K] &lt;&lt; 6);</span>
<span class="quote">&gt; +	seq_printf(m, &quot;DirectMap512M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; +			direct_pages_count[PG_LEVEL_512M] &lt;&lt; 19);</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +}</span>

You could dynamuically determine the sizes here for each field, and not
have to have #ifdefs.

That all said, I don&#39;t see what this is useful for, and it looks very
fragile.

Thanks,
Mark.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=146341">zhong jiang</a> - Nov. 26, 2015, 3:05 p.m.</div>
<pre class="content">
On 2015/11/25 23:04, Mark Rutland wrote:
<span class="quote">&gt; On Wed, Nov 25, 2015 at 09:41:12PM +0800, zhongjiang wrote:</span>
<span class="quote">&gt;&gt; This patch add the interface to show the number of 4KB or 64KB page,</span>
<span class="quote">&gt;&gt; aims to statistics the number of different types of pages.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What is this useful for? Why do we want it?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What does it account for, just the swapper?</span>
<span class="quote">&gt; </span>

The patch is wirtten when I was in backport set_memory_ro. It can be used to
detect whether there is a large page spliting and merging. large page will
significantly reduce the TLB miss, and improve the system performance.
<span class="quote">
&gt;&gt; Signed-off-by: zhongjiang &lt;zhongjiang@huawei.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/arm64/include/asm/pgtable-types.h |   24 ++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  arch/arm64/mm/mmu.c                    |   28 ++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  arch/arm64/mm/pageattr.c               |   31 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  3 files changed, 83 insertions(+), 0 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/arm64/include/asm/pgtable-types.h b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt;&gt; index 2b1bd7e..aa52546 100644</span>
<span class="quote">&gt;&gt; --- a/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt;&gt; +++ b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt;&gt; @@ -86,6 +86,30 @@ typedef pteval_t pgprot_t;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  #endif /* STRICT_MM_TYPECHECKS */</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +struct seq_file;</span>
<span class="quote">&gt;&gt; +extern void arch_report_meminfo(struct seq_file *m);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +enum pg_level {</span>
<span class="quote">&gt;&gt; +	PG_LEVEL_NONE,</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt;&gt; +	PG_LEVEL_4K,</span>
<span class="quote">&gt;&gt; +	PG_LEVEL_2M,</span>
<span class="quote">&gt;&gt; +	PG_LEVEL_1G,</span>
<span class="quote">&gt;&gt; +#else</span>
<span class="quote">&gt;&gt; +	PG_LEVEL_64K,</span>
<span class="quote">&gt;&gt; +	PG_LEVEL_512M,</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +	PG_LEVEL_NUM</span>
<span class="quote">&gt;&gt; +};</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This doesn&#39;t account for 16K pages, and it means each call site has to</span>
<span class="quote">&gt; handle the various page sizes directly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It would be better to simply count PTE/PMD/PUD/PGD, then handle the size</span>
<span class="quote">&gt; conversion at the end when logging.</span>
<span class="quote">&gt; </span>

yes, now I only consider the 4kb and 64kb. if the patch is approved ,I will
improve it.
each call site need two different varialbes to statistics, aiming to distinguish
diffent pages. I think it will no more simple.
<span class="quote">

&gt;&gt; @@ -85,6 +86,11 @@ void split_pmd(pmd_t *pmd, pte_t *pte)</span>
<span class="quote">&gt;&gt;  		set_pte(pte, pfn_pte(pfn, prot));</span>
<span class="quote">&gt;&gt;  		pfn++;</span>
<span class="quote">&gt;&gt;  	} while (pte++, i++, i &lt; PTRS_PER_PTE);</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt;&gt; +	split_page_count(PG_LEVEL_2M);</span>
<span class="quote">&gt;&gt; +#else</span>
<span class="quote">&gt;&gt; +	split_page_count(PG_LEVEL_512M);</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; e.g. here you&#39;d just count PG_LEVEL_PMD, which would work regardless of</span>
<span class="quote">&gt; page size.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; diff --git a/arch/arm64/mm/pageattr.c b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt;&gt; index 7a5ff11..c1888b9 100644</span>
<span class="quote">&gt;&gt; --- a/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt;&gt; +++ b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt;&gt; @@ -15,12 +15,43 @@</span>
<span class="quote">&gt;&gt;  #include &lt;linux/module.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;linux/sched.h&gt;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +#include &lt;linux/seq_file.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;&gt;  #include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  #include &quot;mm.h&quot;</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt; +static unsigned long direct_pages_count[PG_LEVEL_NUM];</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This doesn&#39;t match reality by the time we start executing the kernel,</span>
<span class="quote">&gt; given we created page tables in head.S.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +void update_page_count(int level, unsigned long pages)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	direct_pages_count[level] += pages;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +void split_page_count(int level)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	direct_pages_count[level]--;</span>
<span class="quote">&gt;&gt; +	direct_pages_count[level-1] += PTRS_PER_PTE;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +void arch_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt;&gt; +	seq_printf(m, &quot;DirectMap4k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt; +			direct_pages_count[PG_LEVEL_4K] &lt;&lt; 2);</span>
<span class="quote">&gt;&gt; +	seq_printf(m, &quot;DirectMap2M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt; +			direct_pages_count[PG_LEVEL_2M] &lt;&lt; 11);</span>
<span class="quote">&gt;&gt; +	seq_printf(m, &quot;DirectMap1G:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt; +			direct_pages_count[PG_LEVEL_1G] &lt;&lt; 20);</span>
<span class="quote">&gt;&gt; +#else</span>
<span class="quote">&gt;&gt; +	seq_printf(m, &quot;DirectMap64k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt; +			direct_pages_count[PG_LEVEL_64K] &lt;&lt; 6);</span>
<span class="quote">&gt;&gt; +	seq_printf(m, &quot;DirectMap512M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt; +			direct_pages_count[PG_LEVEL_512M] &lt;&lt; 19);</span>
<span class="quote">&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You could dynamuically determine the sizes here for each field, and not</span>
<span class="quote">&gt; have to have #ifdefs.&gt; </span>

I don&#39;t understand what you mean. I think it can be more readable and operability.

Thanks
zhongjiang
<span class="quote">
&gt; That all said, I don&#39;t see what this is useful for, and it looks very</span>
<span class="quote">&gt; fragile.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Mark.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; .</span>
<span class="quote">&gt; </span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=30282">Mark Rutland</a> - Nov. 26, 2015, 3:49 p.m.</div>
<pre class="content">
On Thu, Nov 26, 2015 at 11:05:32PM +0800, zhong jiang wrote:
<span class="quote">&gt; On 2015/11/25 23:04, Mark Rutland wrote:</span>
<span class="quote">&gt; &gt; On Wed, Nov 25, 2015 at 09:41:12PM +0800, zhongjiang wrote:</span>
<span class="quote">&gt; &gt;&gt; This patch add the interface to show the number of 4KB or 64KB page,</span>
<span class="quote">&gt; &gt;&gt; aims to statistics the number of different types of pages.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; What is this useful for? Why do we want it?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; What does it account for, just the swapper?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The patch is wirtten when I was in backport set_memory_ro. It can be used to</span>
<span class="quote">&gt; detect whether there is a large page spliting and merging. large page will</span>
<span class="quote">&gt; significantly reduce the TLB miss, and improve the system performance.</span>

Ok, but typically the user isn&#39;t going to be able to do much with this
information. It feels more like something that should be in the page
table dump code (where we can calculate the values as we walk the
tables).

What is it intended to account for?

The entire swapper?

Just the linear mapping?
<span class="quote">
&gt; &gt;&gt; Signed-off-by: zhongjiang &lt;zhongjiang@huawei.com&gt;</span>
<span class="quote">&gt; &gt;&gt; ---</span>
<span class="quote">&gt; &gt;&gt;  arch/arm64/include/asm/pgtable-types.h |   24 ++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;&gt;  arch/arm64/mm/mmu.c                    |   28 ++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;&gt;  arch/arm64/mm/pageattr.c               |   31 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;&gt;  3 files changed, 83 insertions(+), 0 deletions(-)</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; diff --git a/arch/arm64/include/asm/pgtable-types.h b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt; &gt;&gt; index 2b1bd7e..aa52546 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt; &gt;&gt; +++ b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt; &gt;&gt; @@ -86,6 +86,30 @@ typedef pteval_t pgprot_t;</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;  #endif /* STRICT_MM_TYPECHECKS */</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt; +struct seq_file;</span>
<span class="quote">&gt; &gt;&gt; +extern void arch_report_meminfo(struct seq_file *m);</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +enum pg_level {</span>
<span class="quote">&gt; &gt;&gt; +	PG_LEVEL_NONE,</span>
<span class="quote">&gt; &gt;&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt; &gt;&gt; +	PG_LEVEL_4K,</span>
<span class="quote">&gt; &gt;&gt; +	PG_LEVEL_2M,</span>
<span class="quote">&gt; &gt;&gt; +	PG_LEVEL_1G,</span>
<span class="quote">&gt; &gt;&gt; +#else</span>
<span class="quote">&gt; &gt;&gt; +	PG_LEVEL_64K,</span>
<span class="quote">&gt; &gt;&gt; +	PG_LEVEL_512M,</span>
<span class="quote">&gt; &gt;&gt; +#endif</span>
<span class="quote">&gt; &gt;&gt; +	PG_LEVEL_NUM</span>
<span class="quote">&gt; &gt;&gt; +};</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This doesn&#39;t account for 16K pages, and it means each call site has to</span>
<span class="quote">&gt; &gt; handle the various page sizes directly.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; It would be better to simply count PTE/PMD/PUD/PGD, then handle the size</span>
<span class="quote">&gt; &gt; conversion at the end when logging.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; yes, now I only consider the 4kb and 64kb. if the patch is approved ,I will</span>
<span class="quote">&gt; improve it.</span>
<span class="quote">&gt; each call site need two different varialbes to statistics, aiming to distinguish</span>
<span class="quote">&gt; diffent pages. I think it will no more simple.</span>

I don&#39;t follow.

Rather than having:

	#if defined(CONFIG_ARM64_4K_PAGES)
		update_page_count(PG_LEVEL_4K, i);
	#else if defined(CONFIG_ARM64_16K_PAGES)
		update_page_count(PG_LEVEL_16K, i);
	#else if defined(CONFIG_ARM64_64K_PAGES)
		update_page_count(PG_LEVEL_64K, i);
	#else
	#error PAGE SIZE UNKNOWN
	#endif

You&#39;d have:

	update_page_count(PG_LEVEL_PTE, i)

The latter is clearly simpler.

See the end of this email for what the other end would look like.
<span class="quote">
&gt; &gt;&gt; diff --git a/arch/arm64/mm/pageattr.c b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt; &gt;&gt; index 7a5ff11..c1888b9 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt; &gt;&gt; @@ -15,12 +15,43 @@</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;linux/sched.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt; +#include &lt;linux/seq_file.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  #include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;  #include &quot;mm.h&quot;</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt; +static unsigned long direct_pages_count[PG_LEVEL_NUM];</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This doesn&#39;t match reality by the time we start executing the kernel,</span>
<span class="quote">&gt; &gt; given we created page tables in head.S.</span>

As I mentioned here, I don&#39;t think that the account is correct, but it
depends on what you&#39;re trying to account for.
<span class="quote">
&gt; &gt;&gt; +void update_page_count(int level, unsigned long pages)</span>
<span class="quote">&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; +	direct_pages_count[level] += pages;</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +void split_page_count(int level)</span>
<span class="quote">&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; +	direct_pages_count[level]--;</span>
<span class="quote">&gt; &gt;&gt; +	direct_pages_count[level-1] += PTRS_PER_PTE;</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +void arch_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt; &gt;&gt; +	seq_printf(m, &quot;DirectMap4k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt;&gt; +			direct_pages_count[PG_LEVEL_4K] &lt;&lt; 2);</span>
<span class="quote">&gt; &gt;&gt; +	seq_printf(m, &quot;DirectMap2M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt;&gt; +			direct_pages_count[PG_LEVEL_2M] &lt;&lt; 11);</span>
<span class="quote">&gt; &gt;&gt; +	seq_printf(m, &quot;DirectMap1G:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt;&gt; +			direct_pages_count[PG_LEVEL_1G] &lt;&lt; 20);</span>
<span class="quote">&gt; &gt;&gt; +#else</span>
<span class="quote">&gt; &gt;&gt; +	seq_printf(m, &quot;DirectMap64k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt;&gt; +			direct_pages_count[PG_LEVEL_64K] &lt;&lt; 6);</span>
<span class="quote">&gt; &gt;&gt; +	seq_printf(m, &quot;DirectMap512M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt;&gt; +			direct_pages_count[PG_LEVEL_512M] &lt;&lt; 19);</span>
<span class="quote">&gt; &gt;&gt; +#endif</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; You could dynamuically determine the sizes here for each field, and not</span>
<span class="quote">&gt; &gt; have to have #ifdefs.&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t understand what you mean. I think it can be more readable and operability.</span>

Assuming you use PGLEVEL_{PTE,PMD,PUD,PGD}, you can have this work for
any size of page and number of levels using something like:

void arch_report_meminfo(struct seq_file *m)
{
	seq_printf(m, &quot;DirectMap%dk:     %8lu kB\n&quot;,
		   PAGE_SIZE / SZ_1K,
		   direct_pages_count[PG_LEVEL_PTE] * PAGE_SIZE / SZ_1K);

#if CONFIG_PGTABLE_LEVELS &gt; 2
	seq_printf(m, &quot;DirectMap%dM:     %8lu kB\n&quot;,
		   PMD_SIZE / SZ_1M,
		   direct_pages_count[PG_LEVEL_PMD] * PUD_SIZE / SZ_1K);

#endif

#if CONFIG_PGTABLE_LEVELS &gt; 3
	seq_printf(m, &quot;DirectMap%dG:     %8lu kB\n&quot;,
		   PUD_SIZE / SZ_1G,
		   direct_pages_count[PG_LEVEL_PUD] * PUD_SIZE / SZ_1K);

#endif
}

I think that&#39;s far more readable and maintainable.

The above may not cover all cases; I&#39;m not sure if you can have a huge
PGD entry in some configuration. If we can, it should be easy to fix up
for.

Thanks,
Mark.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=55031">Xishi Qiu</a> - Nov. 27, 2015, 1:52 a.m.</div>
<pre class="content">
On 2015/11/26 23:49, Mark Rutland wrote:
<span class="quote">
&gt; On Thu, Nov 26, 2015 at 11:05:32PM +0800, zhong jiang wrote:</span>
<span class="quote">&gt;&gt; On 2015/11/25 23:04, Mark Rutland wrote:</span>
<span class="quote">&gt;&gt;&gt; On Wed, Nov 25, 2015 at 09:41:12PM +0800, zhongjiang wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; This patch add the interface to show the number of 4KB or 64KB page,</span>
<span class="quote">&gt;&gt;&gt;&gt; aims to statistics the number of different types of pages.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; What is this useful for? Why do we want it?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; What does it account for, just the swapper?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The patch is wirtten when I was in backport set_memory_ro. It can be used to</span>
<span class="quote">&gt;&gt; detect whether there is a large page spliting and merging. large page will</span>
<span class="quote">&gt;&gt; significantly reduce the TLB miss, and improve the system performance.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ok, but typically the user isn&#39;t going to be able to do much with this</span>
<span class="quote">&gt; information. It feels more like something that should be in the page</span>
<span class="quote">&gt; table dump code (where we can calculate the values as we walk the</span>
<span class="quote">&gt; tables).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What is it intended to account for?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The entire swapper?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Just the linear mapping?</span>

Hi Mark,

x86 has this information when cat /proc/meminfo, so how about just
like x86 to show it?

Thanks,
Xishi Qiu 

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=146341">zhong jiang</a> - Nov. 27, 2015, 8:40 a.m.</div>
<pre class="content">
On 2015/11/26 23:49, Mark Rutland wrote:
<span class="quote">&gt; On Thu, Nov 26, 2015 at 11:05:32PM +0800, zhong jiang wrote:</span>
<span class="quote">&gt;&gt; On 2015/11/25 23:04, Mark Rutland wrote:</span>
<span class="quote">&gt;&gt;&gt; On Wed, Nov 25, 2015 at 09:41:12PM +0800, zhongjiang wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; This patch add the interface to show the number of 4KB or 64KB page,</span>
<span class="quote">&gt;&gt;&gt;&gt; aims to statistics the number of different types of pages.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; What is this useful for? Why do we want it?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; What does it account for, just the swapper?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The patch is wirtten when I was in backport set_memory_ro. It can be used to</span>
<span class="quote">&gt;&gt; detect whether there is a large page spliting and merging. large page will</span>
<span class="quote">&gt;&gt; significantly reduce the TLB miss, and improve the system performance.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ok, but typically the user isn&#39;t going to be able to do much with this</span>
<span class="quote">&gt; information. It feels more like something that should be in the page</span>
<span class="quote">&gt; table dump code (where we can calculate the values as we walk the</span>
<span class="quote">&gt; tables).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What is it intended to account for?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The entire swapper?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Just the linear mapping?</span>

yes, It is used only to the direct mapping, calculating the number of
various pages just like the x86.
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; Signed-off-by: zhongjiang &lt;zhongjiang@huawei.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;&gt;  arch/arm64/include/asm/pgtable-types.h |   24 ++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;  arch/arm64/mm/mmu.c                    |   28 ++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;  arch/arm64/mm/pageattr.c               |   31 +++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;&gt;&gt;  3 files changed, 83 insertions(+), 0 deletions(-)</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; diff --git a/arch/arm64/include/asm/pgtable-types.h b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt;&gt;&gt;&gt; index 2b1bd7e..aa52546 100644</span>
<span class="quote">&gt;&gt;&gt;&gt; --- a/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt;&gt;&gt;&gt; +++ b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -86,6 +86,30 @@ typedef pteval_t pgprot_t;</span>
<span class="quote">&gt;&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;&gt;  #endif /* STRICT_MM_TYPECHECKS */</span>
<span class="quote">&gt;&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;&gt; +struct seq_file;</span>
<span class="quote">&gt;&gt;&gt;&gt; +extern void arch_report_meminfo(struct seq_file *m);</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +enum pg_level {</span>
<span class="quote">&gt;&gt;&gt;&gt; +	PG_LEVEL_NONE,</span>
<span class="quote">&gt;&gt;&gt;&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt;&gt;&gt;&gt; +	PG_LEVEL_4K,</span>
<span class="quote">&gt;&gt;&gt;&gt; +	PG_LEVEL_2M,</span>
<span class="quote">&gt;&gt;&gt;&gt; +	PG_LEVEL_1G,</span>
<span class="quote">&gt;&gt;&gt;&gt; +#else</span>
<span class="quote">&gt;&gt;&gt;&gt; +	PG_LEVEL_64K,</span>
<span class="quote">&gt;&gt;&gt;&gt; +	PG_LEVEL_512M,</span>
<span class="quote">&gt;&gt;&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt;&gt;&gt; +	PG_LEVEL_NUM</span>
<span class="quote">&gt;&gt;&gt;&gt; +};</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This doesn&#39;t account for 16K pages, and it means each call site has to</span>
<span class="quote">&gt;&gt;&gt; handle the various page sizes directly.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; It would be better to simply count PTE/PMD/PUD/PGD, then handle the size</span>
<span class="quote">&gt;&gt;&gt; conversion at the end when logging.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; yes, now I only consider the 4kb and 64kb. if the patch is approved ,I will</span>
<span class="quote">&gt;&gt; improve it.</span>
<span class="quote">&gt;&gt; each call site need two different varialbes to statistics, aiming to distinguish</span>
<span class="quote">&gt;&gt; diffent pages. I think it will no more simple.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t follow.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Rather than having:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	#if defined(CONFIG_ARM64_4K_PAGES)</span>
<span class="quote">&gt; 		update_page_count(PG_LEVEL_4K, i);</span>
<span class="quote">&gt; 	#else if defined(CONFIG_ARM64_16K_PAGES)</span>
<span class="quote">&gt; 		update_page_count(PG_LEVEL_16K, i);</span>
<span class="quote">&gt; 	#else if defined(CONFIG_ARM64_64K_PAGES)</span>
<span class="quote">&gt; 		update_page_count(PG_LEVEL_64K, i);</span>
<span class="quote">&gt; 	#else</span>
<span class="quote">&gt; 	#error PAGE SIZE UNKNOWN</span>
<span class="quote">&gt; 	#endif</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You&#39;d have:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	update_page_count(PG_LEVEL_PTE, i)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The latter is clearly simpler.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; See the end of this email for what the other end would look like.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; diff --git a/arch/arm64/mm/pageattr.c b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt;&gt;&gt;&gt; index 7a5ff11..c1888b9 100644</span>
<span class="quote">&gt;&gt;&gt;&gt; --- a/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt;&gt;&gt;&gt; +++ b/arch/arm64/mm/pageattr.c</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -15,12 +15,43 @@</span>
<span class="quote">&gt;&gt;&gt;&gt;  #include &lt;linux/module.h&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  #include &lt;linux/sched.h&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;&gt; +#include &lt;linux/seq_file.h&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  #include &lt;asm/pgalloc.h&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  #include &lt;asm/pgtable.h&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  #include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;&gt;  #include &quot;mm.h&quot;</span>
<span class="quote">&gt;&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt;&gt; +static unsigned long direct_pages_count[PG_LEVEL_NUM];</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This doesn&#39;t match reality by the time we start executing the kernel,</span>
<span class="quote">&gt;&gt;&gt; given we created page tables in head.S.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As I mentioned here, I don&#39;t think that the account is correct, but it</span>
<span class="quote">&gt; depends on what you&#39;re trying to account for.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; +void update_page_count(int level, unsigned long pages)</span>
<span class="quote">&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt; +	direct_pages_count[level] += pages;</span>
<span class="quote">&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +void split_page_count(int level)</span>
<span class="quote">&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt; +	direct_pages_count[level]--;</span>
<span class="quote">&gt;&gt;&gt;&gt; +	direct_pages_count[level-1] += PTRS_PER_PTE;</span>
<span class="quote">&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +void arch_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt; +#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="quote">&gt;&gt;&gt;&gt; +	seq_printf(m, &quot;DirectMap4k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt;&gt;&gt; +			direct_pages_count[PG_LEVEL_4K] &lt;&lt; 2);</span>
<span class="quote">&gt;&gt;&gt;&gt; +	seq_printf(m, &quot;DirectMap2M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt;&gt;&gt; +			direct_pages_count[PG_LEVEL_2M] &lt;&lt; 11);</span>
<span class="quote">&gt;&gt;&gt;&gt; +	seq_printf(m, &quot;DirectMap1G:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt;&gt;&gt; +			direct_pages_count[PG_LEVEL_1G] &lt;&lt; 20);</span>
<span class="quote">&gt;&gt;&gt;&gt; +#else</span>
<span class="quote">&gt;&gt;&gt;&gt; +	seq_printf(m, &quot;DirectMap64k:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt;&gt;&gt; +			direct_pages_count[PG_LEVEL_64K] &lt;&lt; 6);</span>
<span class="quote">&gt;&gt;&gt;&gt; +	seq_printf(m, &quot;DirectMap512M:     %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt;&gt;&gt; +			direct_pages_count[PG_LEVEL_512M] &lt;&lt; 19);</span>
<span class="quote">&gt;&gt;&gt;&gt; +#endif</span>
<span class="quote">&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; You could dynamuically determine the sizes here for each field, and not</span>
<span class="quote">&gt;&gt;&gt; have to have #ifdefs.&gt; </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I don&#39;t understand what you mean. I think it can be more readable and operability.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Assuming you use PGLEVEL_{PTE,PMD,PUD,PGD}, you can have this work for</span>
<span class="quote">&gt; any size of page and number of levels using something like:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; void arch_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt; {</span>
<span class="quote">&gt; 	seq_printf(m, &quot;DirectMap%dk:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; 		   PAGE_SIZE / SZ_1K,</span>
<span class="quote">&gt; 		   direct_pages_count[PG_LEVEL_PTE] * PAGE_SIZE / SZ_1K);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; #if CONFIG_PGTABLE_LEVELS &gt; 2</span>
<span class="quote">&gt; 	seq_printf(m, &quot;DirectMap%dM:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; 		   PMD_SIZE / SZ_1M,</span>
<span class="quote">&gt; 		   direct_pages_count[PG_LEVEL_PMD] * PUD_SIZE / SZ_1K);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; #endif</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; #if CONFIG_PGTABLE_LEVELS &gt; 3</span>
<span class="quote">&gt; 	seq_printf(m, &quot;DirectMap%dG:     %8lu kB\n&quot;,</span>
<span class="quote">&gt; 		   PUD_SIZE / SZ_1G,</span>
<span class="quote">&gt; 		   direct_pages_count[PG_LEVEL_PUD] * PUD_SIZE / SZ_1K);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; #endif</span>
<span class="quote">&gt; }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think that&#39;s far more readable and maintainable.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The above may not cover all cases; I&#39;m not sure if you can have a huge</span>
<span class="quote">&gt; PGD entry in some configuration. If we can, it should be easy to fix up</span>
<span class="quote">&gt; for.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Mark.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;</span>

OK, It seems to be better . then, I will improve it.
Thank you for your advice.

Thanks
zhongjiang







--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=30282">Mark Rutland</a> - Dec. 3, 2015, 6:22 p.m.</div>
<pre class="content">
On Fri, Nov 27, 2015 at 09:52:16AM +0800, Xishi Qiu wrote:
<span class="quote">&gt; On 2015/11/26 23:49, Mark Rutland wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; On Thu, Nov 26, 2015 at 11:05:32PM +0800, zhong jiang wrote:</span>
<span class="quote">&gt; &gt;&gt; On 2015/11/25 23:04, Mark Rutland wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; On Wed, Nov 25, 2015 at 09:41:12PM +0800, zhongjiang wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; This patch add the interface to show the number of 4KB or 64KB page,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; aims to statistics the number of different types of pages.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; What is this useful for? Why do we want it?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; What does it account for, just the swapper?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; The patch is wirtten when I was in backport set_memory_ro. It can be used to</span>
<span class="quote">&gt; &gt;&gt; detect whether there is a large page spliting and merging. large page will</span>
<span class="quote">&gt; &gt;&gt; significantly reduce the TLB miss, and improve the system performance.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Ok, but typically the user isn&#39;t going to be able to do much with this</span>
<span class="quote">&gt; &gt; information. It feels more like something that should be in the page</span>
<span class="quote">&gt; &gt; table dump code (where we can calculate the values as we walk the</span>
<span class="quote">&gt; &gt; tables).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; What is it intended to account for?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The entire swapper?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Just the linear mapping?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi Mark,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; x86 has this information when cat /proc/meminfo, so how about just</span>
<span class="quote">&gt; like x86 to show it?</span>

The fact that another architecture has some implementation doesn&#39;t
necessarily mean it&#39;s a good idea. In this case there are concerns that
don&#39;t apply to x86, in that we support a number of page sizes, and
anything reading this needs to handle that fact.

If there&#39;s a sensible use-case, then I am not opposed to this. I don&#39;t
see the point in adding it just because we can.

A prerequisite for adding it is knowing precisely what it is intended to
describe. Otherwise it&#39;s impossible to review.

Thanks,
Mark.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable-types.h b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="p_header">index 2b1bd7e..aa52546 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable-types.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable-types.h</span>
<span class="p_chunk">@@ -86,6 +86,30 @@</span> <span class="p_context"> typedef pteval_t pgprot_t;</span>
 
 #endif /* STRICT_MM_TYPECHECKS */
 
<span class="p_add">+struct seq_file;</span>
<span class="p_add">+extern void arch_report_meminfo(struct seq_file *m);</span>
<span class="p_add">+</span>
<span class="p_add">+enum pg_level {</span>
<span class="p_add">+	PG_LEVEL_NONE,</span>
<span class="p_add">+#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="p_add">+	PG_LEVEL_4K,</span>
<span class="p_add">+	PG_LEVEL_2M,</span>
<span class="p_add">+	PG_LEVEL_1G,</span>
<span class="p_add">+#else</span>
<span class="p_add">+	PG_LEVEL_64K,</span>
<span class="p_add">+	PG_LEVEL_512M,</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	PG_LEVEL_NUM</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_FS</span>
<span class="p_add">+extern void update_page_count(int level, unsigned long pages);</span>
<span class="p_add">+extern void split_page_count(int level);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline void update_page_count(int level, unsigned long pages) {}</span>
<span class="p_add">+static inline void split_page_count(int level) {}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #if CONFIG_PGTABLE_LEVELS == 2
 #include &lt;asm-generic/pgtable-nopmd.h&gt;
 #elif CONFIG_PGTABLE_LEVELS == 3
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index 0a7bee7..f9772d0 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/stop_machine.h&gt;
 #include &lt;linux/bootmem.h&gt;
 
<span class="p_add">+#include &lt;asm/pgtable-types.h&gt;</span>
 #include &lt;asm/cputype.h&gt;
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/sections.h&gt;
<span class="p_chunk">@@ -85,6 +86,11 @@</span> <span class="p_context"> void split_pmd(pmd_t *pmd, pte_t *pte)</span>
 		set_pte(pte, pfn_pte(pfn, prot));
 		pfn++;
 	} while (pte++, i++, i &lt; PTRS_PER_PTE);
<span class="p_add">+#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="p_add">+	split_page_count(PG_LEVEL_2M);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	split_page_count(PG_LEVEL_512M);</span>
<span class="p_add">+#endif</span>
 }
 
 static void alloc_init_pte(pmd_t *pmd, unsigned long addr,
<span class="p_chunk">@@ -93,6 +99,7 @@</span> <span class="p_context"> static void alloc_init_pte(pmd_t *pmd, unsigned long addr,</span>
 				  void *(*alloc)(unsigned long size))
 {
 	pte_t *pte;
<span class="p_add">+	unsigned long i = 0;</span>
 
 	if (pmd_none(*pmd) || pmd_sect(*pmd)) {
 		pte = alloc(PTRS_PER_PTE * sizeof(pte_t));
<span class="p_chunk">@@ -107,7 +114,13 @@</span> <span class="p_context"> static void alloc_init_pte(pmd_t *pmd, unsigned long addr,</span>
 	do {
 		set_pte(pte, pfn_pte(pfn, prot));
 		pfn++;
<span class="p_add">+		i++;</span>
 	} while (pte++, addr += PAGE_SIZE, addr != end);
<span class="p_add">+#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="p_add">+	update_page_count(PG_LEVEL_4K, i);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	update_page_count(PG_LEVEL_64K, i);</span>
<span class="p_add">+#endif</span>
 }
 
 void split_pud(pud_t *old_pud, pmd_t *pmd)
<span class="p_chunk">@@ -120,6 +133,9 @@</span> <span class="p_context"> void split_pud(pud_t *old_pud, pmd_t *pmd)</span>
 		set_pmd(pmd, __pmd(addr | prot));
 		addr += PMD_SIZE;
 	} while (pmd++, i++, i &lt; PTRS_PER_PMD);
<span class="p_add">+#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="p_add">+	split_page_count(PG_LEVEL_1G);</span>
<span class="p_add">+#endif</span>
 }
 
 static void alloc_init_pmd(struct mm_struct *mm, pud_t *pud,
<span class="p_chunk">@@ -129,6 +145,7 @@</span> <span class="p_context"> static void alloc_init_pmd(struct mm_struct *mm, pud_t *pud,</span>
 {
 	pmd_t *pmd;
 	unsigned long next;
<span class="p_add">+	unsigned long i = 0;</span>
 
 	/*
 	 * Check for initial section mappings in the pgd/pud and remove them.
<span class="p_chunk">@@ -159,6 +176,7 @@</span> <span class="p_context"> static void alloc_init_pmd(struct mm_struct *mm, pud_t *pud,</span>
 			 * Check for previous table entries created during
 			 * boot (__create_page_tables) and flush them.
 			 */
<span class="p_add">+			i++;</span>
 			if (!pmd_none(old_pmd)) {
 				flush_tlb_all();
 				if (pmd_table(old_pmd)) {
<span class="p_chunk">@@ -173,6 +191,11 @@</span> <span class="p_context"> static void alloc_init_pmd(struct mm_struct *mm, pud_t *pud,</span>
 		}
 		phys += next - addr;
 	} while (pmd++, addr = next, addr != end);
<span class="p_add">+#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="p_add">+	update_page_count(PG_LEVEL_2M, i);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	update_page_count(PG_LEVEL_512M, i);</span>
<span class="p_add">+#endif</span>
 }
 
 static inline bool use_1G_block(unsigned long addr, unsigned long next,
<span class="p_chunk">@@ -194,6 +217,7 @@</span> <span class="p_context"> static void alloc_init_pud(struct mm_struct *mm, pgd_t *pgd,</span>
 {
 	pud_t *pud;
 	unsigned long next;
<span class="p_add">+	unsigned long i = 0;</span>
 
 	if (pgd_none(*pgd)) {
 		pud = alloc(PTRS_PER_PUD * sizeof(pud_t));
<span class="p_chunk">@@ -220,6 +244,7 @@</span> <span class="p_context"> static void alloc_init_pud(struct mm_struct *mm, pgd_t *pgd,</span>
 			 *
 			 * Look up the old pmd table and free it.
 			 */
<span class="p_add">+			i++;</span>
 			if (!pud_none(old_pud)) {
 				flush_tlb_all();
 				if (pud_table(old_pud)) {
<span class="p_chunk">@@ -233,6 +258,9 @@</span> <span class="p_context"> static void alloc_init_pud(struct mm_struct *mm, pgd_t *pgd,</span>
 		}
 		phys += next - addr;
 	} while (pud++, addr = next, addr != end);
<span class="p_add">+#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="p_add">+	update_page_count(PG_LEVEL_1G, i);</span>
<span class="p_add">+#endif</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm64/mm/pageattr.c b/arch/arm64/mm/pageattr.c</span>
<span class="p_header">index 7a5ff11..c1888b9 100644</span>
<span class="p_header">--- a/arch/arm64/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/arm64/mm/pageattr.c</span>
<span class="p_chunk">@@ -15,12 +15,43 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/sched.h&gt;
 
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
 #include &lt;asm/pgalloc.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/tlbflush.h&gt;
 
 #include &quot;mm.h&quot;
 
<span class="p_add">+static unsigned long direct_pages_count[PG_LEVEL_NUM];</span>
<span class="p_add">+</span>
<span class="p_add">+void update_page_count(int level, unsigned long pages)</span>
<span class="p_add">+{</span>
<span class="p_add">+	direct_pages_count[level] += pages;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void split_page_count(int level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	direct_pages_count[level]--;</span>
<span class="p_add">+	direct_pages_count[level-1] += PTRS_PER_PTE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_report_meminfo(struct seq_file *m)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_ARM64_4K_PAGES</span>
<span class="p_add">+	seq_printf(m, &quot;DirectMap4k:     %8lu kB\n&quot;,</span>
<span class="p_add">+			direct_pages_count[PG_LEVEL_4K] &lt;&lt; 2);</span>
<span class="p_add">+	seq_printf(m, &quot;DirectMap2M:     %8lu kB\n&quot;,</span>
<span class="p_add">+			direct_pages_count[PG_LEVEL_2M] &lt;&lt; 11);</span>
<span class="p_add">+	seq_printf(m, &quot;DirectMap1G:     %8lu kB\n&quot;,</span>
<span class="p_add">+			direct_pages_count[PG_LEVEL_1G] &lt;&lt; 20);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	seq_printf(m, &quot;DirectMap64k:     %8lu kB\n&quot;,</span>
<span class="p_add">+			direct_pages_count[PG_LEVEL_64K] &lt;&lt; 6);</span>
<span class="p_add">+	seq_printf(m, &quot;DirectMap512M:     %8lu kB\n&quot;,</span>
<span class="p_add">+			direct_pages_count[PG_LEVEL_512M] &lt;&lt; 19);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int update_pte_range(struct mm_struct *mm, pmd_t *pmd,
 				unsigned long addr, unsigned long end,
 				pgprot_t clear, pgprot_t set)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



