
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[POC,02/83] switch free_pages() from unsigned long to const void * - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [POC,02/83] switch free_pages() from unsigned long to const void *</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=159">Al Viro</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 21, 2015, 11:46 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1450741676-5865-2-git-send-email-viro@ZenIV.linux.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7899541/mbox/"
   >mbox</a>
|
   <a href="/patch/7899541/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7899541/">/patch/7899541/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 59DB8BEEE5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 22 Dec 2015 00:13:05 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id E0C70205B6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 22 Dec 2015 00:12:58 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id F0C4B205B1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 22 Dec 2015 00:12:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932369AbbLVAL5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 21 Dec 2015 19:11:57 -0500
Received: from zeniv.linux.org.uk ([195.92.253.2]:32981 &quot;EHLO
	ZenIV.linux.org.uk&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751439AbbLUXr6 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 21 Dec 2015 18:47:58 -0500
Received: from viro by ZenIV.linux.org.uk with local (Exim 4.76 #1 (Red Hat
	Linux)) id 1aBABJ-0001X8-1r; Mon, 21 Dec 2015 23:47:57 +0000
From: Al Viro &lt;viro@ZenIV.linux.org.uk&gt;
To: linux-kernel@vger.kernel.org
Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Subject: [POC][PATCH 02/83] switch free_pages() from unsigned long to const
	void *
Date: Mon, 21 Dec 2015 23:46:35 +0000
Message-Id: &lt;1450741676-5865-2-git-send-email-viro@ZenIV.linux.org.uk&gt;
X-Mailer: git-send-email 1.7.7.6
In-Reply-To: &lt;20151221234615.GW20997@ZenIV.linux.org.uk&gt;
References: &lt;20151221234615.GW20997@ZenIV.linux.org.uk&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=159">Al Viro</a> - Dec. 21, 2015, 11:46 p.m.</div>
<pre class="content">
<span class="from">From: Al Viro &lt;viro@zeniv.linux.org.uk&gt;</span>
<span class="signed-off-by">
Signed-off-by: Al Viro &lt;viro@zeniv.linux.org.uk&gt;</span>
---
 arch/alpha/include/asm/agp.h                       |  2 +-
 arch/alpha/kernel/pci-noop.c                       |  2 +-
 arch/alpha/kernel/pci_iommu.c                      |  4 ++--
 arch/arc/include/asm/pgalloc.h                     |  6 +++---
 arch/arm/include/asm/tlb.h                         |  2 +-
 arch/arm/kvm/mmu.c                                 |  4 ++--
 arch/arm/mm/pgd.c                                  |  2 +-
 arch/blackfin/include/asm/mmu_context.h            |  2 +-
 arch/cris/arch-v32/drivers/pci/dma.c               |  2 +-
 arch/frv/mm/dma-alloc.c                            |  2 +-
 arch/h8300/kernel/dma.c                            |  2 +-
 arch/ia64/hp/common/sba_iommu.c                    |  2 +-
 arch/ia64/include/asm/agp.h                        |  2 +-
 arch/ia64/include/asm/thread_info.h                |  2 +-
 arch/ia64/include/asm/tlb.h                        |  2 +-
 arch/ia64/kernel/uncached.c                        |  2 +-
 arch/ia64/sn/pci/pci_dma.c                         |  4 ++--
 arch/ia64/sn/pci/tioca_provider.c                  |  2 +-
 arch/m68k/kernel/dma.c                             |  2 +-
 arch/m68k/sun3/sun3dvma.c                          |  4 ++--
 arch/microblaze/kernel/dma.c                       |  2 +-
 arch/microblaze/mm/consistent.c                    |  4 ++--
 arch/mips/include/asm/mach-generic/floppy.h        |  2 +-
 arch/mips/include/asm/mach-jazz/floppy.h           |  2 +-
 arch/mips/include/asm/pgalloc.h                    |  6 +++---
 arch/mips/mm/dma-default.c                         |  2 +-
 arch/mn10300/mm/dma-alloc.c                        |  2 +-
 arch/nios2/include/asm/pgalloc.h                   |  4 ++--
 arch/nios2/mm/dma-mapping.c                        |  2 +-
 arch/parisc/include/asm/agp.h                      |  2 +-
 arch/parisc/include/asm/floppy.h                   |  2 +-
 arch/parisc/include/asm/pgalloc.h                  |  4 ++--
 arch/parisc/kernel/pci-dma.c                       |  4 ++--
 arch/powerpc/include/asm/agp.h                     |  2 +-
 arch/powerpc/kernel/dma.c                          |  2 +-
 arch/powerpc/kernel/iommu.c                        |  6 +++---
 arch/powerpc/kvm/book3s_64_mmu_hv.c                |  4 ++--
 arch/powerpc/kvm/booke.c                           |  2 +-
 arch/powerpc/mm/init_64.c                          |  3 +--
 arch/powerpc/mm/pgtable_32.c                       |  2 +-
 arch/powerpc/platforms/cell/spufs/inode.c          |  2 +-
 arch/powerpc/platforms/powernv/pci-ioda.c          |  2 +-
 arch/powerpc/platforms/ps3/system-bus.c            |  4 ++--
 arch/s390/hypfs/hypfs_diag.c                       |  2 +-
 arch/s390/include/asm/idals.h                      |  5 ++---
 arch/s390/kernel/smp.c                             |  8 ++++----
 arch/s390/kernel/suspend.c                         |  2 +-
 arch/s390/kernel/vdso.c                            |  4 ++--
 arch/s390/mm/pgtable.c                             |  4 ++--
 arch/s390/pci/pci_clp.c                            |  2 +-
 arch/s390/pci/pci_dma.c                            |  4 ++--
 arch/score/include/asm/pgalloc.h                   |  4 ++--
 arch/sh/mm/consistent.c                            |  2 +-
 arch/sparc/include/asm/agp.h                       |  2 +-
 arch/sparc/kernel/iommu.c                          |  4 ++--
 arch/sparc/kernel/ioport.c                         |  6 +++---
 arch/sparc/kernel/ldc.c                            |  6 +++---
 arch/sparc/kernel/pci_fire.c                       |  2 +-
 arch/sparc/kernel/pci_sun4v.c                      |  8 ++++----
 arch/um/drivers/net_kern.c                         |  2 +-
 arch/um/kernel/process.c                           |  2 +-
 arch/unicore32/mm/pgd.c                            |  4 ++--
 arch/x86/include/asm/agp.h                         |  2 +-
 arch/x86/include/asm/floppy.h                      |  2 +-
 arch/x86/include/asm/xen/page-coherent.h           |  2 +-
 arch/x86/kernel/pci-calgary_64.c                   |  6 +++---
 arch/x86/kernel/pci-dma.c                          |  2 +-
 arch/x86/kvm/vmx.c                                 |  2 +-
 arch/x86/mm/init_64.c                              |  2 +-
 arch/x86/platform/efi/efi.c                        |  4 ++--
 arch/x86/um/ldt.c                                  |  2 +-
 arch/x86/xen/pmu.c                                 |  4 ++--
 arch/xtensa/kernel/pci-dma.c                       |  2 +-
 crypto/xor.c                                       |  2 +-
 drivers/base/devres.c                              |  4 ++--
 drivers/block/floppy.c                             |  2 +-
 drivers/block/ps3vram.c                            |  4 ++--
 drivers/block/xen-blkfront.c                       |  4 ++--
 drivers/block/zram/zcomp.c                         |  2 +-
 drivers/char/agp/hp-agp.c                          |  2 +-
 drivers/char/agp/uninorth-agp.c                    |  4 ++--
 drivers/char/mbcs.c                                |  4 ++--
 drivers/crypto/omap-aes.c                          |  4 ++--
 drivers/crypto/omap-des.c                          |  4 ++--
 drivers/dma/ste_dma40.c                            |  6 +++---
 drivers/firmware/dell_rbu.c                        |  9 ++++-----
 drivers/gpu/drm/amd/amdkfd/kfd_events.c            |  2 +-
 drivers/hv/channel.c                               |  4 ++--
 drivers/hv/connection.c                            |  6 +++---
 drivers/infiniband/hw/qib/qib_dma.c                |  2 +-
 drivers/iommu/amd_iommu_init.c                     | 21 ++++++++-------------
 drivers/iommu/exynos-iommu.c                       |  6 +++---
 drivers/iommu/fsl_pamu.c                           |  2 +-
 drivers/iommu/intel-svm.c                          |  8 ++++----
 drivers/iommu/intel_irq_remapping.c                |  2 +-
 drivers/iommu/msm_iommu.c                          |  2 +-
 drivers/md/bcache/bset.c                           | 10 ++++------
 drivers/md/bcache/btree.c                          |  2 +-
 drivers/md/bcache/journal.c                        |  4 ++--
 drivers/md/bcache/super.c                          |  4 ++--
 drivers/md/dm-bufio.c                              |  2 +-
 drivers/media/pci/solo6x10/solo6x10-p2m.c          |  6 +++---
 drivers/media/platform/davinci/dm644x_ccdc.c       |  4 ++--
 drivers/media/platform/omap/omap_voutlib.c         |  2 +-
 drivers/misc/cxl/native.c                          |  2 +-
 drivers/misc/mic/card/mic_virtio.c                 |  2 +-
 drivers/misc/mic/host/mic_virtio.c                 | 11 ++++-------
 drivers/misc/mic/scif/scif_rma.h                   |  2 +-
 drivers/misc/sgi-gru/grufile.c                     |  4 ++--
 drivers/misc/sgi-xp/xpc_uv.c                       |  4 ++--
 drivers/mmc/host/tmio_mmc_dma.c                    |  2 +-
 drivers/net/appletalk/ltpc.c                       |  4 ++--
 drivers/net/ethernet/amd/mvme147.c                 |  4 ++--
 drivers/net/ethernet/cavium/liquidio/octeon_main.h |  4 ++--
 drivers/net/ethernet/cirrus/cs89x0.c               |  2 +-
 drivers/net/ethernet/sgi/ioc3-eth.c                |  2 +-
 drivers/net/ethernet/sun/niu.c                     |  2 +-
 drivers/net/ethernet/tile/tilegx.c                 |  6 ++----
 drivers/net/irda/au1k_ir.c                         |  2 +-
 drivers/net/rionet.c                               |  2 +-
 drivers/net/wireless/b43/debugfs.c                 |  4 ++--
 drivers/net/wireless/b43legacy/debugfs.c           |  4 ++--
 drivers/net/wireless/iwlegacy/common.h             |  2 +-
 drivers/net/wireless/iwlwifi/iwl-trans.h           |  2 +-
 drivers/net/wireless/ti/wlcore/main.c              |  4 ++--
 drivers/parisc/ccio-dma.c                          |  2 +-
 drivers/parisc/ccio-rm-dma.c                       |  2 +-
 drivers/parisc/sba_iommu.c                         | 14 +++++++-------
 drivers/pci/host/pci-tegra.c                       |  2 +-
 drivers/pci/host/pcie-xilinx.c                     |  2 +-
 drivers/s390/block/dasd.c                          |  4 ++--
 drivers/s390/char/hmcdrv_cache.c                   |  2 +-
 drivers/s390/char/hmcdrv_ftp.c                     |  2 +-
 drivers/s390/char/tty3270.c                        |  4 ++--
 drivers/s390/char/vmcp.c                           |  5 ++---
 drivers/s390/cio/cmf.c                             |  4 ++--
 drivers/scsi/cxlflash/main.c                       |  2 +-
 drivers/scsi/libiscsi.c                            |  2 +-
 drivers/scsi/lpfc/lpfc_init.c                      |  4 ++--
 drivers/scsi/megaraid/megaraid_sas_base.c          |  4 ++--
 drivers/scsi/megaraid/megaraid_sas_fusion.c        |  4 ++--
 drivers/scsi/mpt3sas/mpt3sas_base.c                |  4 ++--
 drivers/scsi/ncr53c8xx.c                           |  2 +-
 drivers/scsi/sym53c8xx_2/sym_hipd.h                |  2 +-
 drivers/scsi/vmw_pvscsi.c                          |  5 ++---
 drivers/sh/maple/maple.c                           |  2 +-
 drivers/staging/rdma/ehca/ehca_mrmw.c              |  4 ++--
 drivers/staging/rdma/hfi1/dma.c                    |  2 +-
 drivers/staging/rdma/ipath/ipath_dma.c             |  2 +-
 drivers/usb/core/devices.c                         |  4 ++--
 drivers/video/fbdev/vermilion/vermilion.c          |  2 +-
 drivers/xen/swiotlb-xen.c                          |  4 ++--
 fs/ceph/mds_client.c                               |  2 +-
 fs/ecryptfs/crypto.c                               |  2 +-
 fs/hfs/mdb.c                                       |  2 +-
 fs/jbd2/journal.c                                  |  4 ++--
 fs/nilfs2/ioctl.c                                  |  2 +-
 fs/proc/vmcore.c                                   |  2 +-
 include/linux/gfp.h                                |  4 ++--
 kernel/trace/ftrace.c                              |  4 ++--
 kernel/trace/trace_events.c                        |  8 ++++----
 lib/percpu_ida.c                                   |  2 +-
 lib/raid6/algos.c                                  |  2 +-
 lib/swiotlb.c                                      | 21 +++++++++------------
 mm/memory.c                                        |  2 +-
 mm/page_alloc.c                                    |  8 ++++----
 mm/slob.c                                          |  2 +-
 mm/slub.c                                          |  3 +--
 mm/sparse.c                                        |  2 +-
 net/core/neighbour.c                               |  2 +-
 net/dccp/proto.c                                   |  8 ++++----
 net/ipv4/fib_semantics.c                           |  2 +-
 net/netfilter/nf_conntrack_core.c                  |  3 +--
 net/netlink/af_netlink.c                           |  2 +-
 net/packet/af_packet.c                             |  3 +--
 net/sched/sch_api.c                                |  2 +-
 net/sctp/protocol.c                                |  8 ++++----
 net/sctp/ssnmap.c                                  |  4 ++--
 net/xfrm/xfrm_hash.c                               |  2 +-
 security/integrity/ima/ima_crypto.c                |  2 +-
 sound/core/memalloc.c                              |  2 +-
 sound/oss/dmabuf.c                                 |  2 +-
 sound/usb/usx2y/usb_stream.c                       |  4 ++--
 183 files changed, 310 insertions(+), 333 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/alpha/include/asm/agp.h b/arch/alpha/include/asm/agp.h</span>
<span class="p_header">index a94d48b..2fe5800 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/agp.h</span>
<span class="p_chunk">@@ -13,6 +13,6 @@</span> <span class="p_context"></span>
 #define alloc_gatt_pages(order)		\
 	((char *)__get_free_pages(GFP_KERNEL, (order)))
 #define free_gatt_pages(table, order)	\
<span class="p_del">-	free_pages((unsigned long)(table), (order))</span>
<span class="p_add">+	free_pages((table), (order))</span>
 
 #endif
<span class="p_header">diff --git a/arch/alpha/kernel/pci-noop.c b/arch/alpha/kernel/pci-noop.c</span>
<span class="p_header">index 2b1f4a1..d3bcb88 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci-noop.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci-noop.c</span>
<span class="p_chunk">@@ -127,7 +127,7 @@</span> <span class="p_context"> static void alpha_noop_free_coherent(struct device *dev, size_t size,</span>
 				     void *cpu_addr, dma_addr_t dma_addr,
 				     struct dma_attrs *attrs)
 {
<span class="p_del">-	free_pages((unsigned long)cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 }
 
 static dma_addr_t alpha_noop_map_page(struct device *dev, struct page *page,
<span class="p_header">diff --git a/arch/alpha/kernel/pci_iommu.c b/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_header">index 8969bf2..fb0b20ee 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci_iommu.c</span>
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> try_again:</span>
 
 	*dma_addrp = pci_map_single_1(pdev, cpu_addr, size, 0);
 	if (*dma_addrp == 0) {
<span class="p_del">-		free_pages((unsigned long)cpu_addr, order);</span>
<span class="p_add">+		free_pages(cpu_addr, order);</span>
 		if (alpha_mv.mv_pci_tbi || (gfp &amp; GFP_DMA))
 			return NULL;
 		/* The address doesn&#39;t fit required mask and we
<span class="p_chunk">@@ -482,7 +482,7 @@</span> <span class="p_context"> static void alpha_pci_free_coherent(struct device *dev, size_t size,</span>
 {
 	struct pci_dev *pdev = alpha_gendev_to_pci(dev);
 	pci_unmap_single(pdev, dma_addr, size, PCI_DMA_BIDIRECTIONAL);
<span class="p_del">-	free_pages((unsigned long)cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 
 	DBGA2(&quot;pci_free_consistent: [%llx,%zx] from %pf\n&quot;,
 	      dma_addr, size, __builtin_return_address(0));
<span class="p_header">diff --git a/arch/arc/include/asm/pgalloc.h b/arch/arc/include/asm/pgalloc.h</span>
<span class="p_header">index 86ed671..1200117 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
 
 static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
<span class="p_del">-	free_pages((unsigned long)pgd, __get_order_pgd());</span>
<span class="p_add">+	free_pages(pgd, __get_order_pgd());</span>
 }
 
 
<span class="p_chunk">@@ -122,13 +122,13 @@</span> <span class="p_context"> pte_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 
 static inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
 {
<span class="p_del">-	free_pages((unsigned long)pte, __get_order_pte()); /* takes phy addr */</span>
<span class="p_add">+	free_pages(pte, __get_order_pte()); /* takes phy addr */</span>
 }
 
 static inline void pte_free(struct mm_struct *mm, pgtable_t ptep)
 {
 	pgtable_page_dtor(virt_to_page(ptep));
<span class="p_del">-	free_pages((unsigned long)ptep, __get_order_pte());</span>
<span class="p_add">+	free_pages(ptep, __get_order_pte());</span>
 }
 
 #define __pte_free_tlb(tlb, pte, addr)  pte_free((tlb)-&gt;mm, pte)
<span class="p_header">diff --git a/arch/arm/include/asm/tlb.h b/arch/arm/include/asm/tlb.h</span>
<span class="p_header">index 3cadb72..c8611f2 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/tlb.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/tlb.h</span>
<span class="p_chunk">@@ -174,7 +174,7 @@</span> <span class="p_context"> tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long end)</span>
 	check_pgt_cache();
 
 	if (tlb-&gt;pages != tlb-&gt;local)
<span class="p_del">-		free_pages((unsigned long)tlb-&gt;pages, 0);</span>
<span class="p_add">+		free_pages(tlb-&gt;pages, 0);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 5de6c6b..190e9fb 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -402,7 +402,7 @@</span> <span class="p_context"> void free_boot_hyp_pgd(void)</span>
 	if (boot_hyp_pgd) {
 		unmap_range(NULL, boot_hyp_pgd, hyp_idmap_start, PAGE_SIZE);
 		unmap_range(NULL, boot_hyp_pgd, TRAMPOLINE_VA, PAGE_SIZE);
<span class="p_del">-		free_pages((unsigned long)boot_hyp_pgd, hyp_pgd_order);</span>
<span class="p_add">+		free_pages(boot_hyp_pgd, hyp_pgd_order);</span>
 		boot_hyp_pgd = NULL;
 	}
 
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> void free_hyp_pgds(void)</span>
 		for (addr = VMALLOC_START; is_vmalloc_addr((void*)addr); addr += PGDIR_SIZE)
 			unmap_range(NULL, hyp_pgd, KERN_TO_HYP(addr), PGDIR_SIZE);
 
<span class="p_del">-		free_pages((unsigned long)hyp_pgd, hyp_pgd_order);</span>
<span class="p_add">+		free_pages(hyp_pgd, hyp_pgd_order);</span>
 		hyp_pgd = NULL;
 	}
 	if (merged_hyp_pgd) {
<span class="p_header">diff --git a/arch/arm/mm/pgd.c b/arch/arm/mm/pgd.c</span>
<span class="p_header">index e683db1..b8799fa 100644</span>
<span class="p_header">--- a/arch/arm/mm/pgd.c</span>
<span class="p_header">+++ b/arch/arm/mm/pgd.c</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"></span>
 #define __pgd_free(pgd)	kfree(pgd)
 #else
 #define __pgd_alloc()	(pgd_t *)__get_free_pages(GFP_KERNEL | __GFP_REPEAT, 2)
<span class="p_del">-#define __pgd_free(pgd)	free_pages((unsigned long)pgd, 2)</span>
<span class="p_add">+#define __pgd_free(pgd)	free_pages(pgd, 2)</span>
 #endif
 
 /*
<span class="p_header">diff --git a/arch/blackfin/include/asm/mmu_context.h b/arch/blackfin/include/asm/mmu_context.h</span>
<span class="p_header">index 15b16d3..198cb70 100644</span>
<span class="p_header">--- a/arch/blackfin/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/blackfin/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -203,7 +203,7 @@</span> <span class="p_context"> static inline void destroy_context(struct mm_struct *mm)</span>
 #ifdef CONFIG_MPU
 	if (current_rwx_mask[cpu] == mm-&gt;context.page_rwx_mask)
 		current_rwx_mask[cpu] = NULL;
<span class="p_del">-	free_pages((unsigned long)mm-&gt;context.page_rwx_mask, page_mask_order);</span>
<span class="p_add">+	free_pages(mm-&gt;context.page_rwx_mask, page_mask_order);</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/cris/arch-v32/drivers/pci/dma.c b/arch/cris/arch-v32/drivers/pci/dma.c</span>
<span class="p_header">index ee55578..9b43cec 100644</span>
<span class="p_header">--- a/arch/cris/arch-v32/drivers/pci/dma.c</span>
<span class="p_header">+++ b/arch/cris/arch-v32/drivers/pci/dma.c</span>
<span class="p_chunk">@@ -45,6 +45,6 @@</span> <span class="p_context"> void dma_free_coherent(struct device *dev, size_t size,</span>
 	int order = get_order(size);
 
 	if (!dma_release_from_coherent(dev, order, vaddr))
<span class="p_del">-		free_pages((unsigned long)vaddr, order);</span>
<span class="p_add">+		free_pages(vaddr, order);</span>
 }
 
<span class="p_header">diff --git a/arch/frv/mm/dma-alloc.c b/arch/frv/mm/dma-alloc.c</span>
<span class="p_header">index 7a73aae..c4c19ff 100644</span>
<span class="p_header">--- a/arch/frv/mm/dma-alloc.c</span>
<span class="p_header">+++ b/arch/frv/mm/dma-alloc.c</span>
<span class="p_chunk">@@ -101,7 +101,7 @@</span> <span class="p_context"> void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *dma_handle)</span>
 	/* allocate some common virtual space to map the new pages */
 	area = get_vm_area(size, VM_ALLOC);
 	if (area == 0) {
<span class="p_del">-		free_pages(page, order);</span>
<span class="p_add">+		free_pages((void *)page, order);</span>
 		return NULL;
 	}
 	va = VMALLOC_VMADDR(area-&gt;addr);
<span class="p_header">diff --git a/arch/h8300/kernel/dma.c b/arch/h8300/kernel/dma.c</span>
<span class="p_header">index eeb13d3..063a0f5 100644</span>
<span class="p_header">--- a/arch/h8300/kernel/dma.c</span>
<span class="p_header">+++ b/arch/h8300/kernel/dma.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static void dma_free(struct device *dev, size_t size,</span>
 		     struct dma_attrs *attrs)
 
 {
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 static dma_addr_t map_page(struct device *dev, struct page *page,
<span class="p_header">diff --git a/arch/ia64/hp/common/sba_iommu.c b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">index a6d6190..2988500 100644</span>
<span class="p_header">--- a/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_header">+++ b/arch/ia64/hp/common/sba_iommu.c</span>
<span class="p_chunk">@@ -1194,7 +1194,7 @@</span> <span class="p_context"> static void sba_free_coherent(struct device *dev, size_t size, void *vaddr,</span>
 			      dma_addr_t dma_handle, struct dma_attrs *attrs)
 {
 	sba_unmap_single_attrs(dev, dma_handle, size, 0, NULL);
<span class="p_del">-	free_pages((unsigned long) vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 
<span class="p_header">diff --git a/arch/ia64/include/asm/agp.h b/arch/ia64/include/asm/agp.h</span>
<span class="p_header">index 01d09c40..80c30d4 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/agp.h</span>
<span class="p_chunk">@@ -21,6 +21,6 @@</span> <span class="p_context"></span>
 #define alloc_gatt_pages(order)		\
 	((char *)__get_free_pages(GFP_KERNEL, (order)))
 #define free_gatt_pages(table, order)	\
<span class="p_del">-	free_pages((unsigned long)(table), (order))</span>
<span class="p_add">+	free_pages((table), (order))</span>
 
 #endif /* _ASM_IA64_AGP_H */
<span class="p_header">diff --git a/arch/ia64/include/asm/thread_info.h b/arch/ia64/include/asm/thread_info.h</span>
<span class="p_header">index aa995b6..53c52e9 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/thread_info.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/thread_info.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> struct thread_info {</span>
 										\
 	ret;									\
 })
<span class="p_del">-#define free_task_struct(tsk)	free_pages((unsigned long) (tsk), KERNEL_STACK_SIZE_ORDER)</span>
<span class="p_add">+#define free_task_struct(tsk)	free_pages((tsk), KERNEL_STACK_SIZE_ORDER)</span>
 
 #endif /* !__ASSEMBLY */
 
<span class="p_header">diff --git a/arch/ia64/include/asm/tlb.h b/arch/ia64/include/asm/tlb.h</span>
<span class="p_header">index 39d64e0d..52ab3a9 100644</span>
<span class="p_header">--- a/arch/ia64/include/asm/tlb.h</span>
<span class="p_header">+++ b/arch/ia64/include/asm/tlb.h</span>
<span class="p_chunk">@@ -197,7 +197,7 @@</span> <span class="p_context"> tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long end)</span>
 	check_pgt_cache();
 
 	if (tlb-&gt;pages != tlb-&gt;local)
<span class="p_del">-		free_pages((unsigned long)tlb-&gt;pages, 0);</span>
<span class="p_add">+		free_pages(tlb-&gt;pages, 0);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/ia64/kernel/uncached.c b/arch/ia64/kernel/uncached.c</span>
<span class="p_header">index f3976da..9b90526 100644</span>
<span class="p_header">--- a/arch/ia64/kernel/uncached.c</span>
<span class="p_header">+++ b/arch/ia64/kernel/uncached.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> failed:</span>
 	for (i = 0; i &lt; (IA64_GRANULE_SIZE / PAGE_SIZE); i++)
 		ClearPageUncached(&amp;page[i]);
 
<span class="p_del">-	free_pages(c_addr, IA64_GRANULE_SHIFT-PAGE_SHIFT);</span>
<span class="p_add">+	free_pages((void *)c_addr, IA64_GRANULE_SHIFT-PAGE_SHIFT);</span>
 	mutex_unlock(&amp;uc_pool-&gt;add_chunk_mutex);
 	return -1;
 }
<span class="p_header">diff --git a/arch/ia64/sn/pci/pci_dma.c b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">index 8f59907..f25c898 100644</span>
<span class="p_header">--- a/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_header">+++ b/arch/ia64/sn/pci/pci_dma.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> static void *sn_dma_alloc_coherent(struct device *dev, size_t size,</span>
 						   SN_DMA_ADDR_PHYS);
 	if (!*dma_handle) {
 		printk(KERN_ERR &quot;%s: out of ATEs\n&quot;, __func__);
<span class="p_del">-		free_pages((unsigned long)cpuaddr, get_order(size));</span>
<span class="p_add">+		free_pages(cpuaddr, get_order(size));</span>
 		return NULL;
 	}
 
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> static void sn_dma_free_coherent(struct device *dev, size_t size, void *cpu_addr</span>
 	BUG_ON(!dev_is_pci(dev));
 
 	provider-&gt;dma_unmap(pdev, dma_handle, 0);
<span class="p_del">-	free_pages((unsigned long)cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 }
 
 /**
<span class="p_header">diff --git a/arch/ia64/sn/pci/tioca_provider.c b/arch/ia64/sn/pci/tioca_provider.c</span>
<span class="p_header">index a70b11f..76bf4f0 100644</span>
<span class="p_header">--- a/arch/ia64/sn/pci/tioca_provider.c</span>
<span class="p_header">+++ b/arch/ia64/sn/pci/tioca_provider.c</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> tioca_gart_init(struct tioca_kernel *tioca_kern)</span>
 	tioca_kern-&gt;ca_pcigart_pagemap =
 	    kzalloc(tioca_kern-&gt;ca_pcigart_entries / 8, GFP_KERNEL);
 	if (!tioca_kern-&gt;ca_pcigart_pagemap) {
<span class="p_del">-		free_pages((unsigned long)tioca_kern-&gt;ca_gart,</span>
<span class="p_add">+		free_pages(tioca_kern-&gt;ca_gart,</span>
 			   get_order(tioca_kern-&gt;ca_gart_size));
 		return -1;
 	}
<span class="p_header">diff --git a/arch/m68k/kernel/dma.c b/arch/m68k/kernel/dma.c</span>
<span class="p_header">index 564665f..2bdf7bf 100644</span>
<span class="p_header">--- a/arch/m68k/kernel/dma.c</span>
<span class="p_header">+++ b/arch/m68k/kernel/dma.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> void *dma_alloc_coherent(struct device *dev, size_t size,</span>
 void dma_free_coherent(struct device *dev, size_t size,
 			 void *vaddr, dma_addr_t dma_handle)
 {
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 #endif /* CONFIG_MMU &amp;&amp; !CONFIG_COLDFIRE */
<span class="p_header">diff --git a/arch/m68k/sun3/sun3dvma.c b/arch/m68k/sun3/sun3dvma.c</span>
<span class="p_header">index b37521a..fdc4900 100644</span>
<span class="p_header">--- a/arch/m68k/sun3/sun3dvma.c</span>
<span class="p_header">+++ b/arch/m68k/sun3/sun3dvma.c</span>
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> void *dvma_malloc_align(unsigned long len, unsigned long align)</span>
 		return NULL;
 
 	if((baddr = (unsigned long)dvma_map_align(kaddr, len, align)) == 0) {
<span class="p_del">-		free_pages(kaddr, get_order(len));</span>
<span class="p_add">+		free_pages((void *)kaddr, get_order(len));</span>
 		return NULL;
 	}
 
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> void *dvma_malloc_align(unsigned long len, unsigned long align)</span>
 
 	if(dvma_map_cpu(kaddr, vaddr, len) &lt; 0) {
 		dvma_unmap((void *)baddr);
<span class="p_del">-		free_pages(kaddr, get_order(len));</span>
<span class="p_add">+		free_pages((void *)kaddr, get_order(len));</span>
 		return NULL;
 	}
 
<span class="p_header">diff --git a/arch/microblaze/kernel/dma.c b/arch/microblaze/kernel/dma.c</span>
<span class="p_header">index bf4dec2..641cbcb 100644</span>
<span class="p_header">--- a/arch/microblaze/kernel/dma.c</span>
<span class="p_header">+++ b/arch/microblaze/kernel/dma.c</span>
<span class="p_chunk">@@ -47,7 +47,7 @@</span> <span class="p_context"> static void dma_direct_free_coherent(struct device *dev, size_t size,</span>
 #ifdef NOT_COHERENT_CACHE
 	consistent_free(size, vaddr);
 #else
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/microblaze/mm/consistent.c b/arch/microblaze/mm/consistent.c</span>
<span class="p_header">index b06c3a7..a4b587a 100644</span>
<span class="p_header">--- a/arch/microblaze/mm/consistent.c</span>
<span class="p_header">+++ b/arch/microblaze/mm/consistent.c</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"> void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *dma_handle)</span>
 	/* Allocate some common virtual space to map the new pages. */
 	area = get_vm_area(size, VM_ALLOC);
 	if (!area) {
<span class="p_del">-		free_pages(vaddr, order);</span>
<span class="p_add">+		free_pages((void *)vaddr, order);</span>
 		return NULL;
 	}
 	va = (unsigned long) area-&gt;addr;
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> void *consistent_alloc(gfp_t gfp, size_t size, dma_addr_t *dma_handle)</span>
 	}
 
 	if (err) {
<span class="p_del">-		free_pages(vaddr, order);</span>
<span class="p_add">+		free_pages((void *)vaddr, order);</span>
 		return NULL;
 	}
 
<span class="p_header">diff --git a/arch/mips/include/asm/mach-generic/floppy.h b/arch/mips/include/asm/mach-generic/floppy.h</span>
<span class="p_header">index e2561d9..7b0b508 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-generic/floppy.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-generic/floppy.h</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> static inline unsigned long fd_dma_mem_alloc(unsigned long size)</span>
 
 static inline void fd_dma_mem_free(unsigned long addr, unsigned long size)
 {
<span class="p_del">-	free_pages(addr, get_order(size));</span>
<span class="p_add">+	free_pages((void *)addr, get_order(size));</span>
 }
 
 static inline unsigned long fd_drive_type(unsigned long n)
<span class="p_header">diff --git a/arch/mips/include/asm/mach-jazz/floppy.h b/arch/mips/include/asm/mach-jazz/floppy.h</span>
<span class="p_header">index 4b86c88a..4aaf35b 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-jazz/floppy.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-jazz/floppy.h</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static inline unsigned long fd_dma_mem_alloc(unsigned long size)</span>
 static inline void fd_dma_mem_free(unsigned long addr, unsigned long size)
 {
 	vdma_free(vdma_phys2log(CPHYSADDR(addr)));
<span class="p_del">-	free_pages(addr, get_order(size));</span>
<span class="p_add">+	free_pages((void *)addr, get_order(size));</span>
 }
 
 static inline unsigned long fd_drive_type(unsigned long n)
<span class="p_header">diff --git a/arch/mips/include/asm/pgalloc.h b/arch/mips/include/asm/pgalloc.h</span>
<span class="p_header">index b336037..e29cc40 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -61,7 +61,7 @@</span> <span class="p_context"> static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
 
 static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
<span class="p_del">-	free_pages((unsigned long)pgd, PGD_ORDER);</span>
<span class="p_add">+	free_pages(pgd, PGD_ORDER);</span>
 }
 
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static inline struct page *pte_alloc_one(struct mm_struct *mm,</span>
 
 static inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
 {
<span class="p_del">-	free_pages((unsigned long)pte, PTE_ORDER);</span>
<span class="p_add">+	free_pages(pte, PTE_ORDER);</span>
 }
 
 static inline void pte_free(struct mm_struct *mm, pgtable_t pte)
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> static inline pmd_t *pmd_alloc_one(struct mm_struct *mm, unsigned long address)</span>
 
 static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)
 {
<span class="p_del">-	free_pages((unsigned long)pmd, PMD_ORDER);</span>
<span class="p_add">+	free_pages(pmd, PMD_ORDER);</span>
 }
 
 #define __pmd_free_tlb(tlb, x, addr)	pmd_free((tlb)-&gt;mm, x)
<span class="p_header">diff --git a/arch/mips/mm/dma-default.c b/arch/mips/mm/dma-default.c</span>
<span class="p_header">index 730d394..d3c1cec 100644</span>
<span class="p_header">--- a/arch/mips/mm/dma-default.c</span>
<span class="p_header">+++ b/arch/mips/mm/dma-default.c</span>
<span class="p_chunk">@@ -171,7 +171,7 @@</span> <span class="p_context"> static void mips_dma_free_noncoherent(struct device *dev, size_t size,</span>
 		void *vaddr, dma_addr_t dma_handle)
 {
 	plat_unmap_dma_mem(dev, dma_handle, size, DMA_BIDIRECTIONAL);
<span class="p_del">-	free_pages((unsigned long) vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 static void mips_dma_free_coherent(struct device *dev, size_t size, void *vaddr,
<span class="p_header">diff --git a/arch/mn10300/mm/dma-alloc.c b/arch/mn10300/mm/dma-alloc.c</span>
<span class="p_header">index e244ebe..5f3132a4 100644</span>
<span class="p_header">--- a/arch/mn10300/mm/dma-alloc.c</span>
<span class="p_header">+++ b/arch/mn10300/mm/dma-alloc.c</span>
<span class="p_chunk">@@ -71,6 +71,6 @@</span> <span class="p_context"> void dma_free_coherent(struct device *dev, size_t size, void *vaddr,</span>
 	if (addr &gt;= 0x9c000000)
 		return;
 
<span class="p_del">-	free_pages(addr, get_order(size));</span>
<span class="p_add">+	free_pages((void *)addr, get_order(size));</span>
 }
 EXPORT_SYMBOL(dma_free_coherent);
<span class="p_header">diff --git a/arch/nios2/include/asm/pgalloc.h b/arch/nios2/include/asm/pgalloc.h</span>
<span class="p_header">index 6e2985e..91cd323 100644</span>
<span class="p_header">--- a/arch/nios2/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/nios2/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"> extern pgd_t *pgd_alloc(struct mm_struct *mm);</span>
 
 static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
<span class="p_del">-	free_pages((unsigned long)pgd, PGD_ORDER);</span>
<span class="p_add">+	free_pages(pgd, PGD_ORDER);</span>
 }
 
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> static inline pgtable_t pte_alloc_one(struct mm_struct *mm,</span>
 
 static inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
 {
<span class="p_del">-	free_pages((unsigned long)pte, PTE_ORDER);</span>
<span class="p_add">+	free_pages(pte, PTE_ORDER);</span>
 }
 
 static inline void pte_free(struct mm_struct *mm, struct page *pte)
<span class="p_header">diff --git a/arch/nios2/mm/dma-mapping.c b/arch/nios2/mm/dma-mapping.c</span>
<span class="p_header">index ac5da75..fa242ab 100644</span>
<span class="p_header">--- a/arch/nios2/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/nios2/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> void dma_free_coherent(struct device *dev, size_t size, void *vaddr,</span>
 {
 	unsigned long addr = (unsigned long) CAC_ADDR((unsigned long) vaddr);
 
<span class="p_del">-	free_pages(addr, get_order(size));</span>
<span class="p_add">+	free_pages((void *)addr, get_order(size));</span>
 }
 EXPORT_SYMBOL(dma_free_coherent);
 
<span class="p_header">diff --git a/arch/parisc/include/asm/agp.h b/arch/parisc/include/asm/agp.h</span>
<span class="p_header">index d226ffa..31f67a5 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/agp.h</span>
<span class="p_chunk">@@ -15,6 +15,6 @@</span> <span class="p_context"></span>
 #define alloc_gatt_pages(order)		\
 	((char *)__get_free_pages(GFP_KERNEL, (order)))
 #define free_gatt_pages(table, order)	\
<span class="p_del">-	free_pages((unsigned long)(table), (order))</span>
<span class="p_add">+	free_pages((table), (order))</span>
 
 #endif /* _ASM_PARISC_AGP_H */
<span class="p_header">diff --git a/arch/parisc/include/asm/floppy.h b/arch/parisc/include/asm/floppy.h</span>
<span class="p_header">index f84ff12..ce08762 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/floppy.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/floppy.h</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static void _fd_dma_mem_free(unsigned long addr, unsigned long size)</span>
 	if((unsigned int) addr &gt;= (unsigned int) high_memory)
 		return vfree((void *)addr);
 	else
<span class="p_del">-		free_pages(addr, get_order(size));		</span>
<span class="p_add">+		free_pages((void *)addr, get_order(size));		</span>
 }
 
 #define fd_dma_mem_free(addr, size)  _fd_dma_mem_free(addr, size) 
<span class="p_header">diff --git a/arch/parisc/include/asm/pgalloc.h b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">index daca63d..51cb827 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -48,7 +48,7 @@</span> <span class="p_context"> static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
 #if CONFIG_PGTABLE_LEVELS == 3
 	pgd -= PTRS_PER_PGD;
 #endif
<span class="p_del">-	free_pages((unsigned long)pgd, PGD_ALLOC_ORDER);</span>
<span class="p_add">+	free_pages(pgd, PGD_ALLOC_ORDER);</span>
 }
 
 #if CONFIG_PGTABLE_LEVELS == 3
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> static inline void pmd_free(struct mm_struct *mm, pmd_t *pmd)</span>
 		mm_inc_nr_pmds(mm);
 		return;
 	}
<span class="p_del">-	free_pages((unsigned long)pmd, PMD_ORDER);</span>
<span class="p_add">+	free_pages(pmd, PMD_ORDER);</span>
 }
 
 #else
<span class="p_header">diff --git a/arch/parisc/kernel/pci-dma.c b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">index b9402c9..3c4ebba 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -447,7 +447,7 @@</span> <span class="p_context"> static void pa11_dma_free_consistent (struct device *dev, size_t size, void *vad</span>
 	size = 1 &lt;&lt; (order + PAGE_SHIFT);
 	unmap_uncached_pages((unsigned long)vaddr, size);
 	pcxl_free_range((unsigned long)vaddr, size);
<span class="p_del">-	free_pages((unsigned long)__va(dma_handle), order);</span>
<span class="p_add">+	free_pages(__va(dma_handle), order);</span>
 }
 
 static dma_addr_t pa11_dma_map_single(struct device *dev, void *addr, size_t size, enum dma_data_direction direction)
<span class="p_chunk">@@ -581,7 +581,7 @@</span> <span class="p_context"> static void *pa11_dma_alloc_noncoherent(struct device *dev, size_t size,</span>
 static void pa11_dma_free_noncoherent(struct device *dev, size_t size,
 					void *vaddr, dma_addr_t iova)
 {
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 	return;
 }
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/agp.h b/arch/powerpc/include/asm/agp.h</span>
<span class="p_header">index 416e12c..06df165 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/agp.h</span>
<span class="p_chunk">@@ -12,7 +12,7 @@</span> <span class="p_context"></span>
 #define alloc_gatt_pages(order)		\
 	((char *)__get_free_pages(GFP_KERNEL, (order)))
 #define free_gatt_pages(table, order)	\
<span class="p_del">-	free_pages((unsigned long)(table), (order))</span>
<span class="p_add">+	free_pages((table), (order))</span>
 
 #endif /* __KERNEL__ */
 #endif	/* _ASM_POWERPC_AGP_H */
<span class="p_header">diff --git a/arch/powerpc/kernel/dma.c b/arch/powerpc/kernel/dma.c</span>
<span class="p_header">index 3f1472a..600fffc 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/dma.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/dma.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> void __dma_direct_free_coherent(struct device *dev, size_t size,</span>
 #ifdef CONFIG_NOT_COHERENT_CACHE
 	__dma_free_coherent(size, vaddr);
 #else
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/powerpc/kernel/iommu.c b/arch/powerpc/kernel/iommu.c</span>
<span class="p_header">index a8e3490..9fde7c9 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/iommu.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/iommu.c</span>
<span class="p_chunk">@@ -739,7 +739,7 @@</span> <span class="p_context"> void iommu_free_table(struct iommu_table *tbl, const char *node_name)</span>
 
 	/* free bitmap */
 	order = get_order(bitmap_sz);
<span class="p_del">-	free_pages((unsigned long) tbl-&gt;it_map, order);</span>
<span class="p_add">+	free_pages(tbl-&gt;it_map, order);</span>
 
 	/* free table */
 	kfree(tbl);
<span class="p_chunk">@@ -847,7 +847,7 @@</span> <span class="p_context"> void *iommu_alloc_coherent(struct device *dev, struct iommu_table *tbl,</span>
 	mapping = iommu_alloc(dev, tbl, ret, nio_pages, DMA_BIDIRECTIONAL,
 			      mask &gt;&gt; tbl-&gt;it_page_shift, io_order, NULL);
 	if (mapping == DMA_ERROR_CODE) {
<span class="p_del">-		free_pages((unsigned long)ret, order);</span>
<span class="p_add">+		free_pages(ret, order);</span>
 		return NULL;
 	}
 	*dma_handle = mapping;
<span class="p_chunk">@@ -864,7 +864,7 @@</span> <span class="p_context"> void iommu_free_coherent(struct iommu_table *tbl, size_t size,</span>
 		nio_pages = size &gt;&gt; tbl-&gt;it_page_shift;
 		iommu_free(tbl, dma_handle, nio_pages);
 		size = PAGE_ALIGN(size);
<span class="p_del">-		free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+		free_pages(vaddr, get_order(size));</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">index fb37290..e398fdc 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_chunk">@@ -108,7 +108,7 @@</span> <span class="p_context"> long kvmppc_alloc_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
 	if (kvm-&gt;arch.hpt_cma_alloc)
 		kvm_release_hpt(page, 1 &lt;&lt; (order - PAGE_SHIFT));
 	else
<span class="p_del">-		free_pages(hpt, order - PAGE_SHIFT);</span>
<span class="p_add">+		free_pages((void *)hpt, order - PAGE_SHIFT);</span>
 	return -ENOMEM;
 }
 
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> void kvmppc_free_hpt(struct kvm *kvm)</span>
 		kvm_release_hpt(virt_to_page(kvm-&gt;arch.hpt_virt),
 				1 &lt;&lt; (kvm-&gt;arch.hpt_order - PAGE_SHIFT));
 	else
<span class="p_del">-		free_pages(kvm-&gt;arch.hpt_virt,</span>
<span class="p_add">+		free_pages((void *)kvm-&gt;arch.hpt_virt,</span>
 			   kvm-&gt;arch.hpt_order - PAGE_SHIFT);
 }
 
<span class="p_header">diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c</span>
<span class="p_header">index fd587517..949a078 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/booke.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/booke.c</span>
<span class="p_chunk">@@ -2158,6 +2158,6 @@</span> <span class="p_context"> int __init kvmppc_booke_init(void)</span>
 
 void __exit kvmppc_booke_exit(void)
 {
<span class="p_del">-	free_pages(kvmppc_booke_handlers, VCPU_SIZE_ORDER);</span>
<span class="p_add">+	free_pages((void *)kvmppc_booke_handlers, VCPU_SIZE_ORDER);</span>
 	kvm_exit();
 }
<span class="p_header">diff --git a/arch/powerpc/mm/init_64.c b/arch/powerpc/mm/init_64.c</span>
<span class="p_header">index d747dd7..c709351 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/init_64.c</span>
<span class="p_chunk">@@ -397,8 +397,7 @@</span> <span class="p_context"> void __ref vmemmap_free(unsigned long start, unsigned long end)</span>
 						free_reserved_page(page++);
 				}
 			} else
<span class="p_del">-				free_pages((unsigned long)(__va(addr)),</span>
<span class="p_del">-							get_order(page_size));</span>
<span class="p_add">+				free_pages(__va(addr), get_order(page_size));</span>
 
 			vmemmap_remove_mapping(start, page_size);
 		}
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable_32.c b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">index 7692d1b..89bfc17 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable_32.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> void pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
 #ifndef CONFIG_PPC_4K_PAGES
 	kmem_cache_free(pgtable_cache, (void *)pgd);
 #else
<span class="p_del">-	free_pages((unsigned long)pgd, PGDIR_ORDER - PAGE_SHIFT);</span>
<span class="p_add">+	free_pages(pgd, PGDIR_ORDER - PAGE_SHIFT);</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/powerpc/platforms/cell/spufs/inode.c b/arch/powerpc/platforms/cell/spufs/inode.c</span>
<span class="p_header">index 11634fa..14a47f9 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/cell/spufs/inode.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/cell/spufs/inode.c</span>
<span class="p_chunk">@@ -648,7 +648,7 @@</span> <span class="p_context"> spufs_parse_options(struct super_block *sb, char *options, struct inode *root)</span>
 
 static void spufs_exit_isolated_loader(void)
 {
<span class="p_del">-	free_pages((unsigned long) isolated_loader,</span>
<span class="p_add">+	free_pages(isolated_loader,</span>
 			get_order(isolated_loader_size));
 }
 
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index 414fd1a..0b6f831 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -2323,7 +2323,7 @@</span> <span class="p_context"> static void pnv_pci_ioda2_table_do_free_pages(__be64 *addr,</span>
 		}
 	}
 
<span class="p_del">-	free_pages(addr_ul, get_order(size &lt;&lt; 3));</span>
<span class="p_add">+	free_pages((void *)addr_ul, get_order(size &lt;&lt; 3));</span>
 }
 
 static void pnv_pci_ioda2_table_free_pages(struct iommu_table *tbl)
<span class="p_header">diff --git a/arch/powerpc/platforms/ps3/system-bus.c b/arch/powerpc/platforms/ps3/system-bus.c</span>
<span class="p_header">index 5606fe3..001b93c 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/ps3/system-bus.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/ps3/system-bus.c</span>
<span class="p_chunk">@@ -546,7 +546,7 @@</span> <span class="p_context"> static void * ps3_alloc_coherent(struct device *_dev, size_t size,</span>
 	return (void*)virt_addr;
 
 clean_alloc:
<span class="p_del">-	free_pages(virt_addr, get_order(size));</span>
<span class="p_add">+	free_pages((void *)virt_addr, get_order(size));</span>
 clean_none:
 	dma_handle = NULL;
 	return NULL;
<span class="p_chunk">@@ -558,7 +558,7 @@</span> <span class="p_context"> static void ps3_free_coherent(struct device *_dev, size_t size, void *vaddr,</span>
 	struct ps3_system_bus_device *dev = ps3_dev_to_system_bus_dev(_dev);
 
 	ps3_dma_unmap(dev-&gt;d_region, dma_handle, size);
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 /* Creates TCEs for a user provided buffer.  The user buffer must be
<span class="p_header">diff --git a/arch/s390/hypfs/hypfs_diag.c b/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_header">index 0450357..08f71f8 100644</span>
<span class="p_header">--- a/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_header">+++ b/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_chunk">@@ -373,7 +373,7 @@</span> <span class="p_context"> static void diag204_free_buffer(void)</span>
 		vfree(diag204_buf_vmalloc);
 		diag204_buf_vmalloc = NULL;
 	} else {
<span class="p_del">-		free_pages((unsigned long) diag204_buf, 0);</span>
<span class="p_add">+		free_pages(diag204_buf, 0);</span>
 	}
 	diag204_buf = NULL;
 }
<span class="p_header">diff --git a/arch/s390/include/asm/idals.h b/arch/s390/include/asm/idals.h</span>
<span class="p_header">index a7b2d75..56b1baf 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/idals.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/idals.h</span>
<span class="p_chunk">@@ -139,8 +139,7 @@</span> <span class="p_context"> idal_buffer_alloc(size_t size, int page_order)</span>
 		// Not enough memory
 		while (i &gt;= nr_chunks) {
 			i -= nr_chunks;
<span class="p_del">-			free_pages((unsigned long) ib-&gt;data[i],</span>
<span class="p_del">-				   ib-&gt;page_order);</span>
<span class="p_add">+			free_pages(ib-&gt;data[i], ib-&gt;page_order);</span>
 		}
 		kfree(ib);
 		return ERR_PTR(-ENOMEM);
<span class="p_chunk">@@ -159,7 +158,7 @@</span> <span class="p_context"> idal_buffer_free(struct idal_buffer *ib)</span>
 	nr_ptrs = (ib-&gt;size + IDA_BLOCK_SIZE - 1) &gt;&gt; IDA_SIZE_LOG;
 	nr_chunks = (4096 &lt;&lt; ib-&gt;page_order) &gt;&gt; IDA_SIZE_LOG;
 	for (i = 0; i &lt; nr_ptrs; i += nr_chunks)
<span class="p_del">-		free_pages((unsigned long) ib-&gt;data[i], ib-&gt;page_order);</span>
<span class="p_add">+		free_pages(ib-&gt;data[i], ib-&gt;page_order);</span>
 	kfree(ib);
 }
 
<span class="p_header">diff --git a/arch/s390/kernel/smp.c b/arch/s390/kernel/smp.c</span>
<span class="p_header">index 216c8f5..63c1c8c 100644</span>
<span class="p_header">--- a/arch/s390/kernel/smp.c</span>
<span class="p_header">+++ b/arch/s390/kernel/smp.c</span>
<span class="p_chunk">@@ -211,8 +211,8 @@</span> <span class="p_context"> static int pcpu_alloc_lowcore(struct pcpu *pcpu, int cpu)</span>
 out:
 	if (pcpu != &amp;pcpu_devices[0]) {
 		free_page((void *)panic_stack);
<span class="p_del">-		free_pages(async_stack, ASYNC_ORDER);</span>
<span class="p_del">-		free_pages((unsigned long) pcpu-&gt;lowcore, LC_ORDER);</span>
<span class="p_add">+		free_pages((void *)async_stack, ASYNC_ORDER);</span>
<span class="p_add">+		free_pages(pcpu-&gt;lowcore, LC_ORDER);</span>
 	}
 	return -ENOMEM;
 }
<span class="p_chunk">@@ -227,8 +227,8 @@</span> <span class="p_context"> static void pcpu_free_lowcore(struct pcpu *pcpu)</span>
 	if (pcpu == &amp;pcpu_devices[0])
 		return;
 	free_page((void *)(pcpu-&gt;lowcore-&gt;panic_stack-PANIC_FRAME_OFFSET));
<span class="p_del">-	free_pages(pcpu-&gt;lowcore-&gt;async_stack-ASYNC_FRAME_OFFSET, ASYNC_ORDER);</span>
<span class="p_del">-	free_pages((unsigned long) pcpu-&gt;lowcore, LC_ORDER);</span>
<span class="p_add">+	free_pages((void *)pcpu-&gt;lowcore-&gt;async_stack-ASYNC_FRAME_OFFSET, ASYNC_ORDER);</span>
<span class="p_add">+	free_pages(pcpu-&gt;lowcore, LC_ORDER);</span>
 }
 
 #endif /* CONFIG_HOTPLUG_CPU */
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index 8c23212..c40bdca 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> static int suspend_pm_cb(struct notifier_block *nb, unsigned long action,</span>
 		break;
 	case PM_POST_SUSPEND:
 	case PM_POST_HIBERNATION:
<span class="p_del">-		free_pages(suspend_zero_pages, LC_ORDER);</span>
<span class="p_add">+		free_pages((void *)suspend_zero_pages, LC_ORDER);</span>
 		break;
 	default:
 		return NOTIFY_DONE;
<span class="p_header">diff --git a/arch/s390/kernel/vdso.c b/arch/s390/kernel/vdso.c</span>
<span class="p_header">index 2391d83..2518d55 100644</span>
<span class="p_header">--- a/arch/s390/kernel/vdso.c</span>
<span class="p_header">+++ b/arch/s390/kernel/vdso.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> int vdso_alloc_per_cpu(struct _lowcore *lowcore)</span>
 out:
 	free_page((void *)page_frame);
 	free_page((void *)page_table);
<span class="p_del">-	free_pages(segment_table, SEGMENT_ORDER);</span>
<span class="p_add">+	free_pages((void *)segment_table, SEGMENT_ORDER);</span>
 	return -ENOMEM;
 }
 
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> void vdso_free_per_cpu(struct _lowcore *lowcore)</span>
 
 	free_page((void *)page_frame);
 	free_page((void *)page_table);
<span class="p_del">-	free_pages(segment_table, SEGMENT_ORDER);</span>
<span class="p_add">+	free_pages((void *)segment_table, SEGMENT_ORDER);</span>
 }
 
 static void vdso_init_cr5(void)
<span class="p_header">diff --git a/arch/s390/mm/pgtable.c b/arch/s390/mm/pgtable.c</span>
<span class="p_header">index 676989b..df429c6 100644</span>
<span class="p_header">--- a/arch/s390/mm/pgtable.c</span>
<span class="p_header">+++ b/arch/s390/mm/pgtable.c</span>
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> unsigned long *crst_table_alloc(struct mm_struct *mm)</span>
 
 void crst_table_free(struct mm_struct *mm, unsigned long *table)
 {
<span class="p_del">-	free_pages((unsigned long) table, 2);</span>
<span class="p_add">+	free_pages(table, 2);</span>
 }
 
 static void __crst_table_upgrade(void *arg)
<span class="p_chunk">@@ -1051,7 +1051,7 @@</span> <span class="p_context"> static void __tlb_remove_table(void *_table)</span>
 
 	switch (mask) {
 	case 0:		/* pmd or pud */
<span class="p_del">-		free_pages((unsigned long) table, 2);</span>
<span class="p_add">+		free_pages(table, 2);</span>
 		break;
 	case 1:		/* lower 2K of a 4K page table */
 	case 2:		/* higher 2K of a 4K page table */
<span class="p_header">diff --git a/arch/s390/pci/pci_clp.c b/arch/s390/pci/pci_clp.c</span>
<span class="p_header">index d6e411e..5914a16 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci_clp.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci_clp.c</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> static void *clp_alloc_block(gfp_t gfp_mask)</span>
 
 static void clp_free_block(void *ptr)
 {
<span class="p_del">-	free_pages((unsigned long) ptr, get_order(CLP_BLK_SIZE));</span>
<span class="p_add">+	free_pages(ptr, get_order(CLP_BLK_SIZE));</span>
 }
 
 static void clp_store_query_pci_fngrp(struct zpci_dev *zdev,
<span class="p_header">diff --git a/arch/s390/pci/pci_dma.c b/arch/s390/pci/pci_dma.c</span>
<span class="p_header">index d348f2c..5a15471 100644</span>
<span class="p_header">--- a/arch/s390/pci/pci_dma.c</span>
<span class="p_header">+++ b/arch/s390/pci/pci_dma.c</span>
<span class="p_chunk">@@ -369,7 +369,7 @@</span> <span class="p_context"> static void *s390_dma_alloc(struct device *dev, size_t size,</span>
 	map = s390_dma_map_pages(dev, page, pa % PAGE_SIZE,
 				 size, DMA_BIDIRECTIONAL, NULL);
 	if (dma_mapping_error(dev, map)) {
<span class="p_del">-		free_pages(pa, get_order(size));</span>
<span class="p_add">+		free_pages((void *)pa, get_order(size));</span>
 		return NULL;
 	}
 
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static void s390_dma_free(struct device *dev, size_t size,</span>
 	size = PAGE_ALIGN(size);
 	atomic64_sub(size / PAGE_SIZE, &amp;zdev-&gt;allocated_pages);
 	s390_dma_unmap_pages(dev, dma_handle, size, DMA_BIDIRECTIONAL, NULL);
<span class="p_del">-	free_pages((unsigned long) pa, get_order(size));</span>
<span class="p_add">+	free_pages(pa, get_order(size));</span>
 }
 
 static int s390_dma_map_sg(struct device *dev, struct scatterlist *sg,
<span class="p_header">diff --git a/arch/score/include/asm/pgalloc.h b/arch/score/include/asm/pgalloc.h</span>
<span class="p_header">index 2e06765..55fb080 100644</span>
<span class="p_header">--- a/arch/score/include/asm/pgalloc.h</span>
<span class="p_header">+++ b/arch/score/include/asm/pgalloc.h</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"> static inline pgd_t *pgd_alloc(struct mm_struct *mm)</span>
 
 static inline void pgd_free(struct mm_struct *mm, pgd_t *pgd)
 {
<span class="p_del">-	free_pages((unsigned long)pgd, PGD_ORDER);</span>
<span class="p_add">+	free_pages(pgd, PGD_ORDER);</span>
 }
 
 static inline pte_t *pte_alloc_one_kernel(struct mm_struct *mm,
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> static inline struct page *pte_alloc_one(struct mm_struct *mm,</span>
 
 static inline void pte_free_kernel(struct mm_struct *mm, pte_t *pte)
 {
<span class="p_del">-	free_pages((unsigned long)pte, PTE_ORDER);</span>
<span class="p_add">+	free_pages(pte, PTE_ORDER);</span>
 }
 
 static inline void pte_free(struct mm_struct *mm, pgtable_t pte)
<span class="p_header">diff --git a/arch/sh/mm/consistent.c b/arch/sh/mm/consistent.c</span>
<span class="p_header">index b81d9db..4721e24 100644</span>
<span class="p_header">--- a/arch/sh/mm/consistent.c</span>
<span class="p_header">+++ b/arch/sh/mm/consistent.c</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> void *dma_generic_alloc_coherent(struct device *dev, size_t size,</span>
 
 	ret_nocache = (void __force *)ioremap_nocache(virt_to_phys(ret), size);
 	if (!ret_nocache) {
<span class="p_del">-		free_pages((unsigned long)ret, order);</span>
<span class="p_add">+		free_pages(ret, order);</span>
 		return NULL;
 	}
 
<span class="p_header">diff --git a/arch/sparc/include/asm/agp.h b/arch/sparc/include/asm/agp.h</span>
<span class="p_header">index 70f52c1..363d3e6 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/agp.h</span>
<span class="p_chunk">@@ -11,6 +11,6 @@</span> <span class="p_context"></span>
 #define alloc_gatt_pages(order)		\
 	((char *)__get_free_pages(GFP_KERNEL, (order)))
 #define free_gatt_pages(table, order)	\
<span class="p_del">-	free_pages((unsigned long)(table), (order))</span>
<span class="p_add">+	free_pages((table), (order))</span>
 
 #endif
<span class="p_header">diff --git a/arch/sparc/kernel/iommu.c b/arch/sparc/kernel/iommu.c</span>
<span class="p_header">index 7db91e1..eae7b6b 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/iommu.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/iommu.c</span>
<span class="p_chunk">@@ -223,7 +223,7 @@</span> <span class="p_context"> static void *dma_4u_alloc_coherent(struct device *dev, size_t size,</span>
 	iopte = alloc_npages(dev, iommu, size &gt;&gt; IO_PAGE_SHIFT);
 
 	if (unlikely(iopte == NULL)) {
<span class="p_del">-		free_pages(first_page, order);</span>
<span class="p_add">+		free_pages((void *)first_page, order);</span>
 		return NULL;
 	}
 
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static void dma_4u_free_coherent(struct device *dev, size_t size,</span>
 
 	order = get_order(size);
 	if (order &lt; 10)
<span class="p_del">-		free_pages((unsigned long)cpu, order);</span>
<span class="p_add">+		free_pages(cpu, order);</span>
 }
 
 static dma_addr_t dma_4u_map_page(struct device *dev, struct page *page,
<span class="p_header">diff --git a/arch/sparc/kernel/ioport.c b/arch/sparc/kernel/ioport.c</span>
<span class="p_header">index 28fed53..39b406a 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ioport.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ioport.c</span>
<span class="p_chunk">@@ -309,7 +309,7 @@</span> <span class="p_context"> err_noiommu:</span>
 err_nova:
 	kfree(res);
 err_nomem:
<span class="p_del">-	free_pages(va, order);</span>
<span class="p_add">+	free_pages((void *)va, order);</span>
 err_nopages:
 	return NULL;
 }
<span class="p_chunk">@@ -468,7 +468,7 @@</span> <span class="p_context"> static void *pci32_alloc_coherent(struct device *dev, size_t len,</span>
 err_nova:
 	kfree(res);
 err_nomem:
<span class="p_del">-	free_pages((unsigned long)va, order);</span>
<span class="p_add">+	free_pages(va, order);</span>
 err_nopages:
 	return NULL;
 }
<span class="p_chunk">@@ -509,7 +509,7 @@</span> <span class="p_context"> static void pci32_free_coherent(struct device *dev, size_t n, void *p,</span>
 
 	release_resource(res);
 	kfree(res);
<span class="p_del">-	free_pages((unsigned long)phys_to_virt(ba), get_order(n));</span>
<span class="p_add">+	free_pages(phys_to_virt(ba), get_order(n));</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c</span>
<span class="p_header">index 59d5038..1cba9b7 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ldc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ldc.c</span>
<span class="p_chunk">@@ -1000,7 +1000,7 @@</span> <span class="p_context"> static void free_queue(unsigned long num_entries, struct ldc_packet *q)</span>
 	size = num_entries * LDC_PACKET_SIZE;
 	order = get_order(size);
 
<span class="p_del">-	free_pages((unsigned long)q, order);</span>
<span class="p_add">+	free_pages(q, order);</span>
 }
 
 static unsigned long ldc_cookie_to_index(u64 cookie, void *arg)
<span class="p_chunk">@@ -1081,7 +1081,7 @@</span> <span class="p_context"> static int ldc_iommu_init(const char *name, struct ldc_channel *lp)</span>
 	return 0;
 
 out_free_table:
<span class="p_del">-	free_pages((unsigned long) table, order);</span>
<span class="p_add">+	free_pages(table, order);</span>
 	ldc_iommu-&gt;page_table = NULL;
 
 out_free_map:
<span class="p_chunk">@@ -1103,7 +1103,7 @@</span> <span class="p_context"> static void ldc_iommu_release(struct ldc_channel *lp)</span>
 	tsbsize = num_tsb_entries * sizeof(struct ldc_mtable_entry);
 	order = get_order(tsbsize);
 
<span class="p_del">-	free_pages((unsigned long) ldc_iommu-&gt;page_table, order);</span>
<span class="p_add">+	free_pages(ldc_iommu-&gt;page_table, order);</span>
 	ldc_iommu-&gt;page_table = NULL;
 
 	kfree(iommu-&gt;map);
<span class="p_header">diff --git a/arch/sparc/kernel/pci_fire.c b/arch/sparc/kernel/pci_fire.c</span>
<span class="p_header">index 11a1f0d..b8ac1bb 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci_fire.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci_fire.c</span>
<span class="p_chunk">@@ -265,7 +265,7 @@</span> <span class="p_context"> static void pci_fire_msiq_free(struct pci_pbm_info *pbm)</span>
 	order = get_order(512 * 1024);
 	pages = (unsigned long) pbm-&gt;msi_queues;
 
<span class="p_del">-	free_pages(pages, order);</span>
<span class="p_add">+	free_pages((void *)pages, order);</span>
 
 	pbm-&gt;msi_queues = NULL;
 }
<span class="p_header">diff --git a/arch/sparc/kernel/pci_sun4v.c b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">index 836e8ce..1a678fc 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci_sun4v.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> iommu_map_fail:</span>
 	iommu_tbl_range_free(&amp;iommu-&gt;tbl, *dma_addrp, npages, IOMMU_ERROR_CODE);
 
 range_alloc_fail:
<span class="p_del">-	free_pages(first_page, order);</span>
<span class="p_add">+	free_pages((void *)first_page, order);</span>
 	return NULL;
 }
 
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static void dma_4v_free_coherent(struct device *dev, size_t size, void *cpu,</span>
 	iommu_tbl_range_free(&amp;iommu-&gt;tbl, dvma, npages, IOMMU_ERROR_CODE);
 	order = get_order(size);
 	if (order &lt; 10)
<span class="p_del">-		free_pages((unsigned long)cpu, order);</span>
<span class="p_add">+		free_pages(cpu, order);</span>
 }
 
 static dma_addr_t dma_4v_map_page(struct device *dev, struct page *page,
<span class="p_chunk">@@ -795,7 +795,7 @@</span> <span class="p_context"> static int pci_sun4v_msiq_alloc(struct pci_pbm_info *pbm)</span>
 	return 0;
 
 h_error:
<span class="p_del">-	free_pages(pages, order);</span>
<span class="p_add">+	free_pages((void *)pages, order);</span>
 	return -EINVAL;
 }
 
<span class="p_chunk">@@ -816,7 +816,7 @@</span> <span class="p_context"> static void pci_sun4v_msiq_free(struct pci_pbm_info *pbm)</span>
 
 	pages = (unsigned long) pbm-&gt;msi_queues;
 
<span class="p_del">-	free_pages(pages, order);</span>
<span class="p_add">+	free_pages((void *)pages, order);</span>
 
 	pbm-&gt;msi_queues = NULL;
 }
<span class="p_header">diff --git a/arch/um/drivers/net_kern.c b/arch/um/drivers/net_kern.c</span>
<span class="p_header">index 9ef669d..504f60b 100644</span>
<span class="p_header">--- a/arch/um/drivers/net_kern.c</span>
<span class="p_header">+++ b/arch/um/drivers/net_kern.c</span>
<span class="p_chunk">@@ -888,7 +888,7 @@</span> <span class="p_context"> void *get_output_buffer(int *len_out)</span>
 
 void free_output_buffer(void *buffer)
 {
<span class="p_del">-	free_pages((unsigned long) buffer, 0);</span>
<span class="p_add">+	free_pages(buffer, 0);</span>
 }
 
 int tap_setup_common(char *str, char *type, char **dev_name, char **mac_out,
<span class="p_header">diff --git a/arch/um/kernel/process.c b/arch/um/kernel/process.c</span>
<span class="p_header">index 48af59a..b77685b 100644</span>
<span class="p_header">--- a/arch/um/kernel/process.c</span>
<span class="p_header">+++ b/arch/um/kernel/process.c</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> int pid_to_processor_id(int pid)</span>
 
 void free_stack(unsigned long stack, int order)
 {
<span class="p_del">-	free_pages(stack, order);</span>
<span class="p_add">+	free_pages((void *)stack, order);</span>
 }
 
 unsigned long alloc_stack(int order, int atomic)
<span class="p_header">diff --git a/arch/unicore32/mm/pgd.c b/arch/unicore32/mm/pgd.c</span>
<span class="p_header">index 2ade20d..9485183 100644</span>
<span class="p_header">--- a/arch/unicore32/mm/pgd.c</span>
<span class="p_header">+++ b/arch/unicore32/mm/pgd.c</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"> no_pte:</span>
 	pmd_free(mm, new_pmd);
 	mm_dec_nr_pmds(mm);
 no_pmd:
<span class="p_del">-	free_pages((unsigned long)new_pgd, 0);</span>
<span class="p_add">+	free_pages(new_pgd, 0);</span>
 no_pgd:
 	return NULL;
 }
<span class="p_chunk">@@ -101,5 +101,5 @@</span> <span class="p_context"> void free_pgd_slow(struct mm_struct *mm, pgd_t *pgd)</span>
 	pmd_free(mm, pmd);
 	mm_dec_nr_pmds(mm);
 free:
<span class="p_del">-	free_pages((unsigned long) pgd, 0);</span>
<span class="p_add">+	free_pages(pgd, 0);</span>
 }
<span class="p_header">diff --git a/arch/x86/include/asm/agp.h b/arch/x86/include/asm/agp.h</span>
<span class="p_header">index eec2a70..4f98370 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/agp.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/agp.h</span>
<span class="p_chunk">@@ -26,6 +26,6 @@</span> <span class="p_context"></span>
 #define alloc_gatt_pages(order)		\
 	((char *)__get_free_pages(GFP_KERNEL, (order)))
 #define free_gatt_pages(table, order)	\
<span class="p_del">-	free_pages((unsigned long)(table), (order))</span>
<span class="p_add">+	free_pages((table), (order))</span>
 
 #endif /* _ASM_X86_AGP_H */
<span class="p_header">diff --git a/arch/x86/include/asm/floppy.h b/arch/x86/include/asm/floppy.h</span>
<span class="p_header">index 1c7eefe..8203e1d 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/floppy.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/floppy.h</span>
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"> static void _fd_dma_mem_free(unsigned long addr, unsigned long size)</span>
 	if ((unsigned long)addr &gt;= (unsigned long)high_memory)
 		vfree((void *)addr);
 	else
<span class="p_del">-		free_pages(addr, get_order(size));</span>
<span class="p_add">+		free_pages((void *)addr, get_order(size));</span>
 }
 
 #define fd_dma_mem_free(addr, size)  _fd_dma_mem_free(addr, size)
<span class="p_header">diff --git a/arch/x86/include/asm/xen/page-coherent.h b/arch/x86/include/asm/xen/page-coherent.h</span>
<span class="p_header">index acd844c..8a55a89 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/xen/page-coherent.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/xen/page-coherent.h</span>
<span class="p_chunk">@@ -18,7 +18,7 @@</span> <span class="p_context"> static inline void xen_free_coherent_pages(struct device *hwdev, size_t size,</span>
 		void *cpu_addr, dma_addr_t dma_handle,
 		struct dma_attrs *attrs)
 {
<span class="p_del">-	free_pages((unsigned long) cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 }
 
 static inline void xen_dma_map_page(struct device *hwdev, struct page *page,
<span class="p_header">diff --git a/arch/x86/kernel/pci-calgary_64.c b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">index 0497f71..97e092d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-calgary_64.c</span>
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> static void* calgary_alloc_coherent(struct device *dev, size_t size,</span>
 	*dma_handle = mapping;
 	return ret;
 free:
<span class="p_del">-	free_pages((unsigned long)ret, get_order(size));</span>
<span class="p_add">+	free_pages(ret, get_order(size));</span>
 	ret = NULL;
 error:
 	return ret;
<span class="p_chunk">@@ -475,7 +475,7 @@</span> <span class="p_context"> static void calgary_free_coherent(struct device *dev, size_t size,</span>
 	npages = size &gt;&gt; PAGE_SHIFT;
 
 	iommu_free(tbl, dma_handle, npages);
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 static struct dma_map_ops calgary_dma_ops = {
<span class="p_chunk">@@ -815,7 +815,7 @@</span> <span class="p_context"> static void __init calgary_free_bus(struct pci_dev *dev)</span>
 	readq(target); /* flush */
 
 	bitmapsz = tbl-&gt;it_size / BITS_PER_BYTE;
<span class="p_del">-	free_pages((unsigned long)tbl-&gt;it_map, get_order(bitmapsz));</span>
<span class="p_add">+	free_pages(tbl-&gt;it_map, get_order(bitmapsz));</span>
 	tbl-&gt;it_map = NULL;
 
 	kfree(tbl);
<span class="p_header">diff --git a/arch/x86/kernel/pci-dma.c b/arch/x86/kernel/pci-dma.c</span>
<span class="p_header">index 6ba014c..2418156 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> void dma_generic_free_coherent(struct device *dev, size_t size, void *vaddr,</span>
 	struct page *page = virt_to_page(vaddr);
 
 	if (!dma_release_from_contiguous(dev, page, count))
<span class="p_del">-		free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+		free_pages(vaddr, get_order(size));</span>
 }
 
 bool arch_dma_alloc_attrs(struct device **dev, gfp_t *gfp)
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index f70ed2f..7206fee 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -3300,7 +3300,7 @@</span> <span class="p_context"> static struct vmcs *alloc_vmcs(void)</span>
 
 static void free_vmcs(struct vmcs *vmcs)
 {
<span class="p_del">-	free_pages((unsigned long)vmcs, vmcs_config.order);</span>
<span class="p_add">+	free_pages(vmcs, vmcs_config.order);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c</span>
<span class="p_header">index ec081fe..53c86b6 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_64.c</span>
<span class="p_chunk">@@ -727,7 +727,7 @@</span> <span class="p_context"> static void __meminit free_pagetable(struct page *page, int order)</span>
 			while (nr_pages--)
 				free_reserved_page(page++);
 	} else
<span class="p_del">-		free_pages((unsigned long)page_address(page), order);</span>
<span class="p_add">+		free_pages(page_address(page), order);</span>
 }
 
 static void __meminit free_pte_table(pte_t *pte_start, pmd_t *pmd)
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index ad28540..ed873dd 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -700,7 +700,7 @@</span> <span class="p_context"> static void *realloc_pages(void *old_memmap, int old_shift)</span>
 	memcpy(ret, old_memmap, PAGE_SIZE &lt;&lt; old_shift);
 
 out:
<span class="p_del">-	free_pages((unsigned long)old_memmap, old_shift);</span>
<span class="p_add">+	free_pages(old_memmap, old_shift);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -979,7 +979,7 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 	 *
 	 * efi_cleanup_page_tables(__pa(new_memmap), 1 &lt;&lt; pg_shift);
 	 */
<span class="p_del">-	free_pages((unsigned long)new_memmap, pg_shift);</span>
<span class="p_add">+	free_pages(new_memmap, pg_shift);</span>
 
 	/* clean DUMMY object */
 	efi_delete_dummy_variable();
<span class="p_header">diff --git a/arch/x86/um/ldt.c b/arch/x86/um/ldt.c</span>
<span class="p_header">index 42522ff..52e173d 100644</span>
<span class="p_header">--- a/arch/x86/um/ldt.c</span>
<span class="p_header">+++ b/arch/x86/um/ldt.c</span>
<span class="p_chunk">@@ -291,7 +291,7 @@</span> <span class="p_context"> static void ldt_get_host_info(void)</span>
 	host_ldt_entries[k] = -1;
 
 out_free:
<span class="p_del">-	free_pages((unsigned long)ldt, order);</span>
<span class="p_add">+	free_pages(ldt, order);</span>
 }
 
 long init_new_ldt(struct mm_context *new_mm, struct mm_context *from_mm)
<span class="p_header">diff --git a/arch/x86/xen/pmu.c b/arch/x86/xen/pmu.c</span>
<span class="p_header">index 724a087..77d8e3d 100644</span>
<span class="p_header">--- a/arch/x86/xen/pmu.c</span>
<span class="p_header">+++ b/arch/x86/xen/pmu.c</span>
<span class="p_chunk">@@ -549,7 +549,7 @@</span> <span class="p_context"> void xen_pmu_init(int cpu)</span>
 fail:
 	pr_warn_once(&quot;Could not initialize VPMU for cpu %d, error %d\n&quot;,
 		cpu, err);
<span class="p_del">-	free_pages((unsigned long)xenpmu_data, 0);</span>
<span class="p_add">+	free_pages(xenpmu_data, 0);</span>
 }
 
 void xen_pmu_finish(int cpu)
<span class="p_chunk">@@ -565,6 +565,6 @@</span> <span class="p_context"> void xen_pmu_finish(int cpu)</span>
 
 	(void)HYPERVISOR_xenpmu_op(XENPMU_finish, &amp;xp);
 
<span class="p_del">-	free_pages((unsigned long)per_cpu(xenpmu_shared, cpu).xenpmu_data, 0);</span>
<span class="p_add">+	free_pages(per_cpu(xenpmu_shared, cpu).xenpmu_data, 0);</span>
 	per_cpu(xenpmu_shared, cpu).xenpmu_data = NULL;
 }
<span class="p_header">diff --git a/arch/xtensa/kernel/pci-dma.c b/arch/xtensa/kernel/pci-dma.c</span>
<span class="p_header">index cd66698..0b8ef59 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -179,7 +179,7 @@</span> <span class="p_context"> static void xtensa_dma_free(struct device *hwdev, size_t size, void *vaddr,</span>
 	BUG_ON(addr &lt; XCHAL_KSEG_CACHED_VADDR ||
 	       addr &gt; XCHAL_KSEG_CACHED_VADDR + XCHAL_KSEG_SIZE - 1);
 
<span class="p_del">-	free_pages(addr, get_order(size));</span>
<span class="p_add">+	free_pages((void *)addr, get_order(size));</span>
 }
 
 static dma_addr_t xtensa_map_page(struct device *dev, struct page *page,
<span class="p_header">diff --git a/crypto/xor.c b/crypto/xor.c</span>
<span class="p_header">index 35d6b3a..20060f8 100644</span>
<span class="p_header">--- a/crypto/xor.c</span>
<span class="p_header">+++ b/crypto/xor.c</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> calibrate_xor_blocks(void)</span>
 #undef xor_speed
 
  out:
<span class="p_del">-	free_pages((unsigned long)b1, 2);</span>
<span class="p_add">+	free_pages(b1, 2);</span>
 
 	active_template = fastest;
 	return 0;
<span class="p_header">diff --git a/drivers/base/devres.c b/drivers/base/devres.c</span>
<span class="p_header">index 8fc654f..854f7ae 100644</span>
<span class="p_header">--- a/drivers/base/devres.c</span>
<span class="p_header">+++ b/drivers/base/devres.c</span>
<span class="p_chunk">@@ -927,7 +927,7 @@</span> <span class="p_context"> static void devm_pages_release(struct device *dev, void *res)</span>
 {
 	struct pages_devres *devres = res;
 
<span class="p_del">-	free_pages(devres-&gt;addr, devres-&gt;order);</span>
<span class="p_add">+	free_pages((void *)devres-&gt;addr, devres-&gt;order);</span>
 }
 
 /**
<span class="p_chunk">@@ -957,7 +957,7 @@</span> <span class="p_context"> unsigned long devm_get_free_pages(struct device *dev,</span>
 	devres = devres_alloc(devm_pages_release,
 			      sizeof(struct pages_devres), GFP_KERNEL);
 	if (unlikely(!devres)) {
<span class="p_del">-		free_pages(addr, order);</span>
<span class="p_add">+		free_pages((void *)addr, order);</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/drivers/block/floppy.c b/drivers/block/floppy.c</span>
<span class="p_header">index 331363e..e2738be 100644</span>
<span class="p_header">--- a/drivers/block/floppy.c</span>
<span class="p_header">+++ b/drivers/block/floppy.c</span>
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> static int set_next_request(void);</span>
 /* Dma Memory related stuff */
 
 #ifndef fd_dma_mem_free
<span class="p_del">-#define fd_dma_mem_free(addr, size) free_pages(addr, get_order(size))</span>
<span class="p_add">+#define fd_dma_mem_free(addr, size) free_pages((void *)addr, get_order(size))</span>
 #endif
 
 #ifndef fd_dma_mem_alloc
<span class="p_header">diff --git a/drivers/block/ps3vram.c b/drivers/block/ps3vram.c</span>
<span class="p_header">index 56847fc..db7ece5 100644</span>
<span class="p_header">--- a/drivers/block/ps3vram.c</span>
<span class="p_header">+++ b/drivers/block/ps3vram.c</span>
<span class="p_chunk">@@ -802,7 +802,7 @@</span> <span class="p_context"> out_free_memory:</span>
 out_close_gpu:
 	ps3_close_hv_device(dev);
 out_free_xdr_buf:
<span class="p_del">-	free_pages((unsigned long) priv-&gt;xdr_buf, get_order(XDR_BUF_SIZE));</span>
<span class="p_add">+	free_pages(priv-&gt;xdr_buf, get_order(XDR_BUF_SIZE));</span>
 fail_free_priv:
 	kfree(priv);
 	ps3_system_bus_set_drvdata(dev, NULL);
<span class="p_chunk">@@ -827,7 +827,7 @@</span> <span class="p_context"> static int ps3vram_remove(struct ps3_system_bus_device *dev)</span>
 	lv1_gpu_context_free(priv-&gt;context_handle);
 	lv1_gpu_memory_free(priv-&gt;memory_handle);
 	ps3_close_hv_device(dev);
<span class="p_del">-	free_pages((unsigned long) priv-&gt;xdr_buf, get_order(XDR_BUF_SIZE));</span>
<span class="p_add">+	free_pages(priv-&gt;xdr_buf, get_order(XDR_BUF_SIZE));</span>
 	kfree(priv);
 	ps3_system_bus_set_drvdata(dev, NULL);
 	return 0;
<span class="p_header">diff --git a/drivers/block/xen-blkfront.c b/drivers/block/xen-blkfront.c</span>
<span class="p_header">index 2fee2ee..19b8697 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkfront.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkfront.c</span>
<span class="p_chunk">@@ -1174,7 +1174,7 @@</span> <span class="p_context"> free_shadow:</span>
 			info-&gt;ring_ref[i] = GRANT_INVALID_REF;
 		}
 	}
<span class="p_del">-	free_pages((unsigned long)info-&gt;ring.sring, get_order(info-&gt;nr_ring_pages * PAGE_SIZE));</span>
<span class="p_add">+	free_pages(info-&gt;ring.sring, get_order(info-&gt;nr_ring_pages * PAGE_SIZE));</span>
 	info-&gt;ring.sring = NULL;
 
 	if (info-&gt;irq)
<span class="p_chunk">@@ -1429,7 +1429,7 @@</span> <span class="p_context"> static int setup_blkring(struct xenbus_device *dev,</span>
 
 	err = xenbus_grant_ring(dev, info-&gt;ring.sring, info-&gt;nr_ring_pages, gref);
 	if (err &lt; 0) {
<span class="p_del">-		free_pages((unsigned long)sring, get_order(ring_size));</span>
<span class="p_add">+		free_pages(sring, get_order(ring_size));</span>
 		info-&gt;ring.sring = NULL;
 		goto fail;
 	}
<span class="p_header">diff --git a/drivers/block/zram/zcomp.c b/drivers/block/zram/zcomp.c</span>
<span class="p_header">index 5cb13ca..efaa135 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"> static void zcomp_strm_free(struct zcomp *comp, struct zcomp_strm *zstrm)</span>
 {
 	if (zstrm-&gt;private)
 		comp-&gt;backend-&gt;destroy(zstrm-&gt;private);
<span class="p_del">-	free_pages((unsigned long)zstrm-&gt;buffer, 1);</span>
<span class="p_add">+	free_pages(zstrm-&gt;buffer, 1);</span>
 	kfree(zstrm);
 }
 
<span class="p_header">diff --git a/drivers/char/agp/hp-agp.c b/drivers/char/agp/hp-agp.c</span>
<span class="p_header">index 3695773..9f83f13 100644</span>
<span class="p_header">--- a/drivers/char/agp/hp-agp.c</span>
<span class="p_header">+++ b/drivers/char/agp/hp-agp.c</span>
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> hp_zx1_free_gatt_table (struct agp_bridge_data *bridge)</span>
 	struct _hp_private *hp = &amp;hp_private;
 
 	if (hp-&gt;io_pdir_owner)
<span class="p_del">-		free_pages((unsigned long) hp-&gt;io_pdir,</span>
<span class="p_add">+		free_pages(hp-&gt;io_pdir,</span>
 			    get_order(hp-&gt;io_pdir_size));
 	else
 		hp-&gt;gatt[0] = HP_ZX1_SBA_IOMMU_COOKIE;
<span class="p_header">diff --git a/drivers/char/agp/uninorth-agp.c b/drivers/char/agp/uninorth-agp.c</span>
<span class="p_header">index 0575544..bcbe6a5 100644</span>
<span class="p_header">--- a/drivers/char/agp/uninorth-agp.c</span>
<span class="p_header">+++ b/drivers/char/agp/uninorth-agp.c</span>
<span class="p_chunk">@@ -439,7 +439,7 @@</span> <span class="p_context"> static int uninorth_create_gatt_table(struct agp_bridge_data *bridge)</span>
 enomem:
 	kfree(uninorth_priv.pages_arr);
 	if (table)
<span class="p_del">-		free_pages((unsigned long)table, page_order);</span>
<span class="p_add">+		free_pages(table, page_order);</span>
 	return -ENOMEM;
 }
 
<span class="p_chunk">@@ -466,7 +466,7 @@</span> <span class="p_context"> static int uninorth_free_gatt_table(struct agp_bridge_data *bridge)</span>
 	for (page = virt_to_page(table); page &lt;= virt_to_page(table_end); page++)
 		ClearPageReserved(page);
 
<span class="p_del">-	free_pages((unsigned long) bridge-&gt;gatt_table_real, page_order);</span>
<span class="p_add">+	free_pages(bridge-&gt;gatt_table_real, page_order);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/char/mbcs.c b/drivers/char/mbcs.c</span>
<span class="p_header">index e5d3e3f..b9d9619 100644</span>
<span class="p_header">--- a/drivers/char/mbcs.c</span>
<span class="p_header">+++ b/drivers/char/mbcs.c</span>
<span class="p_chunk">@@ -419,7 +419,7 @@</span> <span class="p_context"> static ssize_t mbcs_sram_read(struct file * fp, char __user *buf, size_t len, lo</span>
 		rv = -EFAULT;
 
       exit:
<span class="p_del">-	free_pages(hostAddr, get_order(len));</span>
<span class="p_add">+	free_pages((void *)hostAddr, get_order(len));</span>
 
 	return rv;
 }
<span class="p_chunk">@@ -444,7 +444,7 @@</span> <span class="p_context"> mbcs_sram_write(struct file * fp, const char __user *buf, size_t len, loff_t * o</span>
 	rv = do_mbcs_sram_dmaread(soft, hostAddr, len, off);
 
       exit:
<span class="p_del">-	free_pages(hostAddr, get_order(len));</span>
<span class="p_add">+	free_pages((void *)hostAddr, get_order(len));</span>
 
 	return rv;
 }
<span class="p_header">diff --git a/drivers/crypto/omap-aes.c b/drivers/crypto/omap-aes.c</span>
<span class="p_header">index eba2314..cd41ce7 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-aes.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-aes.c</span>
<span class="p_chunk">@@ -701,8 +701,8 @@</span> <span class="p_context"> static void omap_aes_done_task(unsigned long data)</span>
 
 		len = ALIGN(dd-&gt;total_save, AES_BLOCK_SIZE);
 		pages = get_order(len);
<span class="p_del">-		free_pages((unsigned long)buf_in, pages);</span>
<span class="p_del">-		free_pages((unsigned long)buf_out, pages);</span>
<span class="p_add">+		free_pages(buf_in, pages);</span>
<span class="p_add">+		free_pages(buf_out, pages);</span>
 	}
 
 	omap_aes_finish_req(dd, 0);
<span class="p_header">diff --git a/drivers/crypto/omap-des.c b/drivers/crypto/omap-des.c</span>
<span class="p_header">index 0a70e46..462f2bc 100644</span>
<span class="p_header">--- a/drivers/crypto/omap-des.c</span>
<span class="p_header">+++ b/drivers/crypto/omap-des.c</span>
<span class="p_chunk">@@ -680,8 +680,8 @@</span> <span class="p_context"> static void omap_des_done_task(unsigned long data)</span>
 		sg_copy_buf(buf_out, dd-&gt;orig_out, 0, dd-&gt;total_save, 1);
 
 		pages = get_order(dd-&gt;total_save);
<span class="p_del">-		free_pages((unsigned long)buf_in, pages);</span>
<span class="p_del">-		free_pages((unsigned long)buf_out, pages);</span>
<span class="p_add">+		free_pages(buf_in, pages);</span>
<span class="p_add">+		free_pages(buf_out, pages);</span>
 	}
 
 	omap_des_finish_req(dd, 0);
<span class="p_header">diff --git a/drivers/dma/ste_dma40.c b/drivers/dma/ste_dma40.c</span>
<span class="p_header">index dd3e7ba..2971d47 100644</span>
<span class="p_header">--- a/drivers/dma/ste_dma40.c</span>
<span class="p_header">+++ b/drivers/dma/ste_dma40.c</span>
<span class="p_chunk">@@ -3434,7 +3434,7 @@</span> <span class="p_context"> static int __init d40_lcla_allocate(struct d40_base *base)</span>
 			ret = -ENOMEM;
 
 			for (j = 0; j &lt; i; j++)
<span class="p_del">-				free_pages(page_list[j], base-&gt;lcla_pool.pages);</span>
<span class="p_add">+				free_pages((void *)page_list[j], base-&gt;lcla_pool.pages);</span>
 			goto failure;
 		}
 
<span class="p_chunk">@@ -3444,7 +3444,7 @@</span> <span class="p_context"> static int __init d40_lcla_allocate(struct d40_base *base)</span>
 	}
 
 	for (j = 0; j &lt; i; j++)
<span class="p_del">-		free_pages(page_list[j], base-&gt;lcla_pool.pages);</span>
<span class="p_add">+		free_pages((void *)page_list[j], base-&gt;lcla_pool.pages);</span>
 
 	if (i &lt; MAX_LCLA_ALLOC_ATTEMPTS) {
 		base-&gt;lcla_pool.base = (void *)page_list[i];
<span class="p_chunk">@@ -3710,7 +3710,7 @@</span> <span class="p_context"> failure:</span>
 					 DMA_TO_DEVICE);
 
 		if (!base-&gt;lcla_pool.base_unaligned &amp;&amp; base-&gt;lcla_pool.base)
<span class="p_del">-			free_pages((unsigned long)base-&gt;lcla_pool.base,</span>
<span class="p_add">+			free_pages(base-&gt;lcla_pool.base,</span>
 				   base-&gt;lcla_pool.pages);
 
 		kfree(base-&gt;lcla_pool.base_unaligned);
<span class="p_header">diff --git a/drivers/firmware/dell_rbu.c b/drivers/firmware/dell_rbu.c</span>
<span class="p_header">index 2f452f1f..7d1afaa 100644</span>
<span class="p_header">--- a/drivers/firmware/dell_rbu.c</span>
<span class="p_header">+++ b/drivers/firmware/dell_rbu.c</span>
<span class="p_chunk">@@ -207,7 +207,7 @@</span> <span class="p_context"> out_alloc_packet_array:</span>
 		pr_debug(&quot;freeing unused packet below floor 0x%lx.\n&quot;,
 			(unsigned long)virt_to_phys(
 				invalid_addr_packet_array[idx-1]));
<span class="p_del">-		free_pages((unsigned long)invalid_addr_packet_array[idx-1],</span>
<span class="p_add">+		free_pages(invalid_addr_packet_array[idx-1],</span>
 			ordernum);
 	}
 	kfree(invalid_addr_packet_array);
<span class="p_chunk">@@ -349,8 +349,7 @@</span> <span class="p_context"> static void packet_empty_list(void)</span>
 		 * to make sure there are no stale RBU packets left in memory
 		 */
 		memset(newpacket-&gt;data, 0, rbu_data.packetsize);
<span class="p_del">-		free_pages((unsigned long) newpacket-&gt;data,</span>
<span class="p_del">-			newpacket-&gt;ordernum);</span>
<span class="p_add">+		free_pages(newpacket-&gt;data, newpacket-&gt;ordernum);</span>
 		kfree(newpacket);
 	}
 	rbu_data.packet_read_count = 0;
<span class="p_chunk">@@ -376,7 +375,7 @@</span> <span class="p_context"> static void img_update_free(void)</span>
 		dma_free_coherent(NULL, rbu_data.bios_image_size,
 			rbu_data.image_update_buffer, dell_rbu_dmaaddr);
 	else
<span class="p_del">-		free_pages((unsigned long) rbu_data.image_update_buffer,</span>
<span class="p_add">+		free_pages(rbu_data.image_update_buffer,</span>
 			rbu_data.image_update_ordernum);
 
 	/*
<span class="p_chunk">@@ -442,7 +441,7 @@</span> <span class="p_context"> static int img_update_realloc(unsigned long size)</span>
 		(unsigned long) virt_to_phys(image_update_buffer);
 
 	if (img_buf_phys_addr &gt; BIOS_SCAN_LIMIT) {
<span class="p_del">-		free_pages((unsigned long) image_update_buffer, ordernum);</span>
<span class="p_add">+		free_pages(image_update_buffer, ordernum);</span>
 		ordernum = -1;
 		image_update_buffer = dma_alloc_coherent(NULL, size,
 			&amp;dell_rbu_dmaaddr, GFP_KERNEL);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_events.c b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">index b6e28dc..8bb3671 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_chunk">@@ -381,7 +381,7 @@</span> <span class="p_context"> static void shutdown_signal_pages(struct kfd_process *p)</span>
 
 	list_for_each_entry_safe(page, tmp, &amp;p-&gt;signal_event_pages,
 					event_pages) {
<span class="p_del">-		free_pages((unsigned long)page-&gt;kernel_address,</span>
<span class="p_add">+		free_pages(page-&gt;kernel_address,</span>
 				get_order(KFD_SIGNAL_EVENT_LIMIT * 8));
 		kfree(page);
 	}
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index c4dcab0..0b65dc5 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -210,7 +210,7 @@</span> <span class="p_context"> error_gpadl:</span>
 	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);
 
 error0:
<span class="p_del">-	free_pages((unsigned long)out,</span>
<span class="p_add">+	free_pages(out,</span>
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
 	kfree(open_info);
 	newchannel-&gt;state = CHANNEL_OPEN_STATE;
<span class="p_chunk">@@ -546,7 +546,7 @@</span> <span class="p_context"> static int vmbus_close_internal(struct vmbus_channel *channel)</span>
 	hv_ringbuffer_cleanup(&amp;channel-&gt;outbound);
 	hv_ringbuffer_cleanup(&amp;channel-&gt;inbound);
 
<span class="p_del">-	free_pages((unsigned long)channel-&gt;ringbuffer_pages,</span>
<span class="p_add">+	free_pages(channel-&gt;ringbuffer_pages,</span>
 		get_order(channel-&gt;ringbuffer_pagecount * PAGE_SIZE));
 
 	/*
<span class="p_header">diff --git a/drivers/hv/connection.c b/drivers/hv/connection.c</span>
<span class="p_header">index 4fc2e88..99cf9e9 100644</span>
<span class="p_header">--- a/drivers/hv/connection.c</span>
<span class="p_header">+++ b/drivers/hv/connection.c</span>
<span class="p_chunk">@@ -241,12 +241,12 @@</span> <span class="p_context"> void vmbus_disconnect(void)</span>
 	}
 
 	if (vmbus_connection.int_page) {
<span class="p_del">-		free_pages((unsigned long)vmbus_connection.int_page, 0);</span>
<span class="p_add">+		free_pages(vmbus_connection.int_page, 0);</span>
 		vmbus_connection.int_page = NULL;
 	}
 
<span class="p_del">-	free_pages((unsigned long)vmbus_connection.monitor_pages[0], 0);</span>
<span class="p_del">-	free_pages((unsigned long)vmbus_connection.monitor_pages[1], 0);</span>
<span class="p_add">+	free_pages(vmbus_connection.monitor_pages[0], 0);</span>
<span class="p_add">+	free_pages(vmbus_connection.monitor_pages[1], 0);</span>
 	vmbus_connection.monitor_pages[0] = NULL;
 	vmbus_connection.monitor_pages[1] = NULL;
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_dma.c b/drivers/infiniband/hw/qib/qib_dma.c</span>
<span class="p_header">index 59fe092..9544208 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_dma.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_dma.c</span>
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static void *qib_dma_alloc_coherent(struct ib_device *dev, size_t size,</span>
 static void qib_dma_free_coherent(struct ib_device *dev, size_t size,
 				  void *cpu_addr, u64 dma_handle)
 {
<span class="p_del">-	free_pages((unsigned long) cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 }
 
 struct ib_dma_mapping_ops qib_dma_mapping_ops = {
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c</span>
<span class="p_header">index 013bdff..ace59ca 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_init.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_init.c</span>
<span class="p_chunk">@@ -541,7 +541,7 @@</span> <span class="p_context"> static void iommu_enable_command_buffer(struct amd_iommu *iommu)</span>
 
 static void __init free_command_buffer(struct amd_iommu *iommu)
 {
<span class="p_del">-	free_pages((unsigned long)iommu-&gt;cmd_buf, get_order(CMD_BUFFER_SIZE));</span>
<span class="p_add">+	free_pages(iommu-&gt;cmd_buf, get_order(CMD_BUFFER_SIZE));</span>
 }
 
 /* allocates the memory where the IOMMU will log its events to */
<span class="p_chunk">@@ -573,7 +573,7 @@</span> <span class="p_context"> static void iommu_enable_event_buffer(struct amd_iommu *iommu)</span>
 
 static void __init free_event_buffer(struct amd_iommu *iommu)
 {
<span class="p_del">-	free_pages((unsigned long)iommu-&gt;evt_buf, get_order(EVT_BUFFER_SIZE));</span>
<span class="p_add">+	free_pages(iommu-&gt;evt_buf, get_order(EVT_BUFFER_SIZE));</span>
 }
 
 /* allocates the memory where the IOMMU will log its events to */
<span class="p_chunk">@@ -610,7 +610,7 @@</span> <span class="p_context"> static void __init free_ppr_log(struct amd_iommu *iommu)</span>
 	if (iommu-&gt;ppr_log == NULL)
 		return;
 
<span class="p_del">-	free_pages((unsigned long)iommu-&gt;ppr_log, get_order(PPR_LOG_SIZE));</span>
<span class="p_add">+	free_pages(iommu-&gt;ppr_log, get_order(PPR_LOG_SIZE));</span>
 }
 
 static void iommu_enable_gt(struct amd_iommu *iommu)
<span class="p_chunk">@@ -1692,20 +1692,16 @@</span> <span class="p_context"> static struct syscore_ops amd_iommu_syscore_ops = {</span>
 
 static void __init free_on_init_error(void)
 {
<span class="p_del">-	free_pages((unsigned long)irq_lookup_table,</span>
<span class="p_del">-		   get_order(rlookup_table_size));</span>
<span class="p_add">+	free_pages(irq_lookup_table, get_order(rlookup_table_size));</span>
 
 	kmem_cache_destroy(amd_iommu_irq_cache);
 	amd_iommu_irq_cache = NULL;
 
<span class="p_del">-	free_pages((unsigned long)amd_iommu_rlookup_table,</span>
<span class="p_del">-		   get_order(rlookup_table_size));</span>
<span class="p_add">+	free_pages(amd_iommu_rlookup_table, get_order(rlookup_table_size));</span>
 
<span class="p_del">-	free_pages((unsigned long)amd_iommu_alias_table,</span>
<span class="p_del">-		   get_order(alias_table_size));</span>
<span class="p_add">+	free_pages(amd_iommu_alias_table, get_order(alias_table_size));</span>
 
<span class="p_del">-	free_pages((unsigned long)amd_iommu_dev_table,</span>
<span class="p_del">-		   get_order(dev_table_size));</span>
<span class="p_add">+	free_pages(amd_iommu_dev_table, get_order(dev_table_size));</span>
 
 	free_iommu_all();
 
<span class="p_chunk">@@ -1773,8 +1769,7 @@</span> <span class="p_context"> static bool __init check_ioapic_information(void)</span>
 
 static void __init free_dma_resources(void)
 {
<span class="p_del">-	free_pages((unsigned long)amd_iommu_pd_alloc_bitmap,</span>
<span class="p_del">-		   get_order(MAX_DOMAIN_ID/8));</span>
<span class="p_add">+	free_pages(amd_iommu_pd_alloc_bitmap, get_order(MAX_DOMAIN_ID/8));</span>
 
 	free_unity_maps();
 }
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index 97c41b8..828a316 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -702,7 +702,7 @@</span> <span class="p_context"> static struct iommu_domain *exynos_iommu_domain_alloc(unsigned type)</span>
 	return &amp;domain-&gt;domain;
 
 err_counter:
<span class="p_del">-	free_pages((unsigned long)domain-&gt;pgtable, 2);</span>
<span class="p_add">+	free_pages(domain-&gt;pgtable, 2);</span>
 err_pgtable:
 	kfree(domain);
 	return NULL;
<span class="p_chunk">@@ -732,8 +732,8 @@</span> <span class="p_context"> static void exynos_iommu_domain_free(struct iommu_domain *iommu_domain)</span>
 			kmem_cache_free(lv2table_kmem_cache,
 				phys_to_virt(lv2table_base(domain-&gt;pgtable + i)));
 
<span class="p_del">-	free_pages((unsigned long)domain-&gt;pgtable, 2);</span>
<span class="p_del">-	free_pages((unsigned long)domain-&gt;lv2entcnt, 1);</span>
<span class="p_add">+	free_pages(domain-&gt;pgtable, 2);</span>
<span class="p_add">+	free_pages(domain-&gt;lv2entcnt, 1);</span>
 	kfree(domain);
 }
 
<span class="p_header">diff --git a/drivers/iommu/fsl_pamu.c b/drivers/iommu/fsl_pamu.c</span>
<span class="p_header">index a34355f..3772d00 100644</span>
<span class="p_header">--- a/drivers/iommu/fsl_pamu.c</span>
<span class="p_header">+++ b/drivers/iommu/fsl_pamu.c</span>
<span class="p_chunk">@@ -1193,7 +1193,7 @@</span> <span class="p_context"> error:</span>
 		iounmap(guts_regs);
 
 	if (ppaact)
<span class="p_del">-		free_pages((unsigned long)ppaact, order);</span>
<span class="p_add">+		free_pages(ppaact, order);</span>
 
 	ppaact = NULL;
 
<span class="p_header">diff --git a/drivers/iommu/intel-svm.c b/drivers/iommu/intel-svm.c</span>
<span class="p_header">index c69e3f9..a911b6c 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-svm.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-svm.c</span>
<span class="p_chunk">@@ -75,11 +75,11 @@</span> <span class="p_context"> int intel_svm_free_pasid_tables(struct intel_iommu *iommu)</span>
 		order = 0;
 
 	if (iommu-&gt;pasid_table) {
<span class="p_del">-		free_pages((unsigned long)iommu-&gt;pasid_table, order);</span>
<span class="p_add">+		free_pages(iommu-&gt;pasid_table, order);</span>
 		iommu-&gt;pasid_table = NULL;
 	}
 	if (iommu-&gt;pasid_state_table) {
<span class="p_del">-		free_pages((unsigned long)iommu-&gt;pasid_state_table, order);</span>
<span class="p_add">+		free_pages(iommu-&gt;pasid_state_table, order);</span>
 		iommu-&gt;pasid_state_table = NULL;
 	}
 	idr_destroy(&amp;iommu-&gt;pasid_idr);
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> int intel_svm_enable_prq(struct intel_iommu *iommu)</span>
 		       iommu-&gt;name);
 		ret = -EINVAL;
 	err:
<span class="p_del">-		free_pages((unsigned long)iommu-&gt;prq, PRQ_ORDER);</span>
<span class="p_add">+		free_pages(iommu-&gt;prq, PRQ_ORDER);</span>
 		iommu-&gt;prq = NULL;
 		return ret;
 	}
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> int intel_svm_finish_prq(struct intel_iommu *iommu)</span>
 	dmar_free_hwirq(iommu-&gt;pr_irq);
 	iommu-&gt;pr_irq = 0;
 
<span class="p_del">-	free_pages((unsigned long)iommu-&gt;prq, PRQ_ORDER);</span>
<span class="p_add">+	free_pages(iommu-&gt;prq, PRQ_ORDER);</span>
 	iommu-&gt;prq = NULL;
 
 	return 0;
<span class="p_header">diff --git a/drivers/iommu/intel_irq_remapping.c b/drivers/iommu/intel_irq_remapping.c</span>
<span class="p_header">index 1fae188..fb79ee2 100644</span>
<span class="p_header">--- a/drivers/iommu/intel_irq_remapping.c</span>
<span class="p_header">+++ b/drivers/iommu/intel_irq_remapping.c</span>
<span class="p_chunk">@@ -602,7 +602,7 @@</span> <span class="p_context"> static void intel_teardown_irq_remapping(struct intel_iommu *iommu)</span>
 			irq_domain_remove(iommu-&gt;ir_domain);
 			iommu-&gt;ir_domain = NULL;
 		}
<span class="p_del">-		free_pages((unsigned long)iommu-&gt;ir_table-&gt;base,</span>
<span class="p_add">+		free_pages(iommu-&gt;ir_table-&gt;base,</span>
 			   INTR_REMAP_PAGE_ORDER);
 		kfree(iommu-&gt;ir_table-&gt;bitmap);
 		kfree(iommu-&gt;ir_table);
<span class="p_header">diff --git a/drivers/iommu/msm_iommu.c b/drivers/iommu/msm_iommu.c</span>
<span class="p_header">index b8bcc57..01afc79 100644</span>
<span class="p_header">--- a/drivers/iommu/msm_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/msm_iommu.c</span>
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> static void msm_iommu_domain_free(struct iommu_domain *domain)</span>
 		if ((fl_table[i] &amp; 0x03) == FL_TYPE_TABLE)
 			free_page(__va(((fl_table[i]) &amp; FL_BASE_MASK)));
 
<span class="p_del">-	free_pages((unsigned long)priv-&gt;pgtable, get_order(SZ_16K));</span>
<span class="p_add">+	free_pages(priv-&gt;pgtable, get_order(SZ_16K));</span>
 	priv-&gt;pgtable = NULL;
 
 	kfree(priv);
<span class="p_header">diff --git a/drivers/md/bcache/bset.c b/drivers/md/bcache/bset.c</span>
<span class="p_header">index 646fe85..3059674 100644</span>
<span class="p_header">--- a/drivers/md/bcache/bset.c</span>
<span class="p_header">+++ b/drivers/md/bcache/bset.c</span>
<span class="p_chunk">@@ -292,16 +292,14 @@</span> <span class="p_context"> void bch_btree_keys_free(struct btree_keys *b)</span>
 	if (bset_prev_bytes(b) &lt; PAGE_SIZE)
 		kfree(t-&gt;prev);
 	else
<span class="p_del">-		free_pages((unsigned long) t-&gt;prev,</span>
<span class="p_del">-			   get_order(bset_prev_bytes(b)));</span>
<span class="p_add">+		free_pages(t-&gt;prev, get_order(bset_prev_bytes(b)));</span>
 
 	if (bset_tree_bytes(b) &lt; PAGE_SIZE)
 		kfree(t-&gt;tree);
 	else
<span class="p_del">-		free_pages((unsigned long) t-&gt;tree,</span>
<span class="p_del">-			   get_order(bset_tree_bytes(b)));</span>
<span class="p_add">+		free_pages(t-&gt;tree, get_order(bset_tree_bytes(b)));</span>
 
<span class="p_del">-	free_pages((unsigned long) t-&gt;data, b-&gt;page_order);</span>
<span class="p_add">+	free_pages(t-&gt;data, b-&gt;page_order);</span>
 
 	t-&gt;prev = NULL;
 	t-&gt;tree = NULL;
<span class="p_chunk">@@ -1220,7 +1218,7 @@</span> <span class="p_context"> static void __btree_sort(struct btree_keys *b, struct btree_iter *iter,</span>
 	if (used_mempool)
 		mempool_free(virt_to_page(out), state-&gt;pool);
 	else
<span class="p_del">-		free_pages((unsigned long) out, order);</span>
<span class="p_add">+		free_pages(out, order);</span>
 
 	bch_bset_build_written_tree(b);
 
<span class="p_header">diff --git a/drivers/md/bcache/btree.c b/drivers/md/bcache/btree.c</span>
<span class="p_header">index 83392f8..1540114 100644</span>
<span class="p_header">--- a/drivers/md/bcache/btree.c</span>
<span class="p_header">+++ b/drivers/md/bcache/btree.c</span>
<span class="p_chunk">@@ -751,7 +751,7 @@</span> <span class="p_context"> void bch_btree_cache_free(struct cache_set *c)</span>
 	if (c-&gt;verify_data)
 		list_move(&amp;c-&gt;verify_data-&gt;list, &amp;c-&gt;btree_cache);
 
<span class="p_del">-	free_pages((unsigned long) c-&gt;verify_ondisk, ilog2(bucket_pages(c)));</span>
<span class="p_add">+	free_pages(c-&gt;verify_ondisk, ilog2(bucket_pages(c)));</span>
 #endif
 
 	list_splice(&amp;c-&gt;btree_cache_freeable,
<span class="p_header">diff --git a/drivers/md/bcache/journal.c b/drivers/md/bcache/journal.c</span>
<span class="p_header">index 29eba72..6ed9533 100644</span>
<span class="p_header">--- a/drivers/md/bcache/journal.c</span>
<span class="p_header">+++ b/drivers/md/bcache/journal.c</span>
<span class="p_chunk">@@ -797,8 +797,8 @@</span> <span class="p_context"> void bch_journal_meta(struct cache_set *c, struct closure *cl)</span>
 
 void bch_journal_free(struct cache_set *c)
 {
<span class="p_del">-	free_pages((unsigned long) c-&gt;journal.w[1].data, JSET_BITS);</span>
<span class="p_del">-	free_pages((unsigned long) c-&gt;journal.w[0].data, JSET_BITS);</span>
<span class="p_add">+	free_pages(c-&gt;journal.w[1].data, JSET_BITS);</span>
<span class="p_add">+	free_pages(c-&gt;journal.w[0].data, JSET_BITS);</span>
 	free_fifo(&amp;c-&gt;journal.pin);
 }
 
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index 679a093..cd04e2d 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1329,7 +1329,7 @@</span> <span class="p_context"> static void cache_set_free(struct closure *cl)</span>
 		}
 
 	bch_bset_sort_state_free(&amp;c-&gt;sort);
<span class="p_del">-	free_pages((unsigned long) c-&gt;uuids, ilog2(bucket_pages(c)));</span>
<span class="p_add">+	free_pages(c-&gt;uuids, ilog2(bucket_pages(c)));</span>
 
 	if (c-&gt;moving_gc_wq)
 		destroy_workqueue(c-&gt;moving_gc_wq);
<span class="p_chunk">@@ -1768,7 +1768,7 @@</span> <span class="p_context"> void bch_cache_release(struct kobject *kobj)</span>
 		ca-&gt;set-&gt;cache[ca-&gt;sb.nr_this_dev] = NULL;
 	}
 
<span class="p_del">-	free_pages((unsigned long) ca-&gt;disk_buckets, ilog2(bucket_pages(ca)));</span>
<span class="p_add">+	free_pages(ca-&gt;disk_buckets, ilog2(bucket_pages(ca)));</span>
 	kfree(ca-&gt;prio_buckets);
 	vfree(ca-&gt;buckets);
 
<span class="p_header">diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c</span>
<span class="p_header">index 2dd3308..10f8a45 100644</span>
<span class="p_header">--- a/drivers/md/dm-bufio.c</span>
<span class="p_header">+++ b/drivers/md/dm-bufio.c</span>
<span class="p_chunk">@@ -419,7 +419,7 @@</span> <span class="p_context"> static void free_buffer_data(struct dm_bufio_client *c,</span>
 		break;
 
 	case DATA_MODE_GET_FREE_PAGES:
<span class="p_del">-		free_pages((unsigned long)data, c-&gt;pages_per_block_bits);</span>
<span class="p_add">+		free_pages(data, c-&gt;pages_per_block_bits);</span>
 		break;
 
 	case DATA_MODE_VMALLOC:
<span class="p_header">diff --git a/drivers/media/pci/solo6x10/solo6x10-p2m.c b/drivers/media/pci/solo6x10/solo6x10-p2m.c</span>
<span class="p_header">index 8c84846..ef91be9 100644</span>
<span class="p_header">--- a/drivers/media/pci/solo6x10/solo6x10-p2m.c</span>
<span class="p_header">+++ b/drivers/media/pci/solo6x10/solo6x10-p2m.c</span>
<span class="p_chunk">@@ -227,7 +227,7 @@</span> <span class="p_context"> static int solo_p2m_test(struct solo_dev *solo_dev, int base, int size)</span>
 
 	rd_buf = (u32 *)__get_free_pages(GFP_KERNEL, order);
 	if (rd_buf == NULL) {
<span class="p_del">-		free_pages((unsigned long)wr_buf, order);</span>
<span class="p_add">+		free_pages(wr_buf, order);</span>
 		return -1;
 	}
 
<span class="p_chunk">@@ -253,8 +253,8 @@</span> <span class="p_context"> static int solo_p2m_test(struct solo_dev *solo_dev, int base, int size)</span>
 	ret = 0;
 
 test_fail:
<span class="p_del">-	free_pages((unsigned long)wr_buf, order);</span>
<span class="p_del">-	free_pages((unsigned long)rd_buf, order);</span>
<span class="p_add">+	free_pages(wr_buf, order);</span>
<span class="p_add">+	free_pages(rd_buf, order);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/media/platform/davinci/dm644x_ccdc.c b/drivers/media/platform/davinci/dm644x_ccdc.c</span>
<span class="p_header">index ffbefdf..31d4015 100644</span>
<span class="p_header">--- a/drivers/media/platform/davinci/dm644x_ccdc.c</span>
<span class="p_header">+++ b/drivers/media/platform/davinci/dm644x_ccdc.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static int ccdc_update_raw_params(struct ccdc_config_params_raw *raw_params)</span>
 	 */
 	if (raw_params-&gt;fault_pxl.fp_num != config_params-&gt;fault_pxl.fp_num) {
 		if (fpc_physaddr != NULL) {
<span class="p_del">-			free_pages((unsigned long)fpc_physaddr,</span>
<span class="p_add">+			free_pages(fpc_physaddr,</span>
 				   get_order
 				   (config_params-&gt;fault_pxl.fp_num *
 				   FP_NUM_BYTES));
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static int ccdc_close(struct device *dev)</span>
 	if (fpc_physaddr != NULL) {
 		fpc_virtaddr = (unsigned int *)
 		    phys_to_virt((unsigned long)fpc_physaddr);
<span class="p_del">-		free_pages((unsigned long)fpc_virtaddr,</span>
<span class="p_add">+		free_pages(fpc_virtaddr,</span>
 			   get_order(config_params-&gt;fault_pxl.fp_num *
 			   FP_NUM_BYTES));
 	}
<span class="p_header">diff --git a/drivers/media/platform/omap/omap_voutlib.c b/drivers/media/platform/omap/omap_voutlib.c</span>
<span class="p_header">index 80b0d88..f8cf63a 100644</span>
<span class="p_header">--- a/drivers/media/platform/omap/omap_voutlib.c</span>
<span class="p_header">+++ b/drivers/media/platform/omap/omap_voutlib.c</span>
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> void omap_vout_free_buffer(unsigned long virtaddr, u32 buf_size)</span>
 		addr += PAGE_SIZE;
 		size -= PAGE_SIZE;
 	}
<span class="p_del">-	free_pages((unsigned long) virtaddr, order);</span>
<span class="p_add">+	free_pages((void *)virtaddr, order);</span>
 }
 
 bool omap_vout_dss_omap24xx(void)
<span class="p_header">diff --git a/drivers/misc/cxl/native.c b/drivers/misc/cxl/native.c</span>
<span class="p_header">index f409097..4620627 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/native.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/native.c</span>
<span class="p_chunk">@@ -228,7 +228,7 @@</span> <span class="p_context"> static inline void detach_spa(struct cxl_afu *afu)</span>
 void cxl_release_spa(struct cxl_afu *afu)
 {
 	if (afu-&gt;spa) {
<span class="p_del">-		free_pages((unsigned long) afu-&gt;spa, afu-&gt;spa_order);</span>
<span class="p_add">+		free_pages(afu-&gt;spa, afu-&gt;spa_order);</span>
 		afu-&gt;spa = NULL;
 	}
 }
<span class="p_header">diff --git a/drivers/misc/mic/card/mic_virtio.c b/drivers/misc/mic/card/mic_virtio.c</span>
<span class="p_header">index e486a0c..bb364ee 100644</span>
<span class="p_header">--- a/drivers/misc/mic/card/mic_virtio.c</span>
<span class="p_header">+++ b/drivers/misc/mic/card/mic_virtio.c</span>
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> static void mic_del_vq(struct virtqueue *vq, int n)</span>
 	struct mic_vdev *mvdev = to_micvdev(vq-&gt;vdev);
 	struct vring *vr = (struct vring *)(vq + 1);
 
<span class="p_del">-	free_pages((unsigned long) vr-&gt;used, get_order(mvdev-&gt;used_size[n]));</span>
<span class="p_add">+	free_pages(vr-&gt;used, get_order(mvdev-&gt;used_size[n]));</span>
 	vring_del_virtqueue(vq);
 	mic_card_unmap(mvdev-&gt;mdev, mvdev-&gt;vr[n]);
 	mvdev-&gt;vr[n] = NULL;
<span class="p_header">diff --git a/drivers/misc/mic/host/mic_virtio.c b/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_header">index 58b107a..3474aa2 100644</span>
<span class="p_header">--- a/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_header">+++ b/drivers/misc/mic/host/mic_virtio.c</span>
<span class="p_chunk">@@ -663,7 +663,7 @@</span> <span class="p_context"> int mic_virtio_add_device(struct mic_vdev *mvdev,</span>
 		vr-&gt;info-&gt;magic = cpu_to_le32(MIC_MAGIC + mvdev-&gt;virtio_id + i);
 		vr_addr = mic_map_single(mdev, vr-&gt;va, vr_size);
 		if (mic_map_error(vr_addr)) {
<span class="p_del">-			free_pages((unsigned long)vr-&gt;va, get_order(vr_size));</span>
<span class="p_add">+			free_pages(vr-&gt;va, get_order(vr_size));</span>
 			ret = -ENOMEM;
 			dev_err(mic_dev(mvdev), &quot;%s %d err %d\n&quot;,
 				__func__, __LINE__, ret);
<span class="p_chunk">@@ -732,8 +732,7 @@</span> <span class="p_context"> err:</span>
 		struct mic_vringh *mvr = &amp;mvdev-&gt;mvr[j];
 		mic_unmap_single(mdev, le64_to_cpu(vqconfig[j].address),
 				 mvr-&gt;vring.len);
<span class="p_del">-		free_pages((unsigned long)mvr-&gt;vring.va,</span>
<span class="p_del">-			   get_order(mvr-&gt;vring.len));</span>
<span class="p_add">+		free_pages(mvr-&gt;vring.va, get_order(mvr-&gt;vring.len));</span>
 	}
 	mutex_unlock(&amp;mdev-&gt;mic_mutex);
 	return ret;
<span class="p_chunk">@@ -779,14 +778,12 @@</span> <span class="p_context"> skip_hot_remove:</span>
 
 		mic_unmap_single(mvdev-&gt;mdev, mvr-&gt;buf_da,
 				 MIC_INT_DMA_BUF_SIZE);
<span class="p_del">-		free_pages((unsigned long)mvr-&gt;buf,</span>
<span class="p_del">-			   get_order(MIC_INT_DMA_BUF_SIZE));</span>
<span class="p_add">+		free_pages(mvr-&gt;buf, get_order(MIC_INT_DMA_BUF_SIZE));</span>
 		vringh_kiov_cleanup(&amp;mvr-&gt;riov);
 		vringh_kiov_cleanup(&amp;mvr-&gt;wiov);
 		mic_unmap_single(mdev, le64_to_cpu(vqconfig[i].address),
 				 mvr-&gt;vring.len);
<span class="p_del">-		free_pages((unsigned long)mvr-&gt;vring.va,</span>
<span class="p_del">-			   get_order(mvr-&gt;vring.len));</span>
<span class="p_add">+		free_pages(mvr-&gt;vring.va, get_order(mvr-&gt;vring.len));</span>
 	}
 
 	list_for_each_safe(pos, tmp, &amp;mdev-&gt;vdev_list) {
<span class="p_header">diff --git a/drivers/misc/mic/scif/scif_rma.h b/drivers/misc/mic/scif/scif_rma.h</span>
<span class="p_header">index fa67222..e13ab83 100644</span>
<span class="p_header">--- a/drivers/misc/mic/scif/scif_rma.h</span>
<span class="p_header">+++ b/drivers/misc/mic/scif/scif_rma.h</span>
<span class="p_chunk">@@ -420,7 +420,7 @@</span> <span class="p_context"> static inline void scif_free(void *addr, size_t size)</span>
 	if (is_vmalloc_addr(addr))
 		vfree(addr);
 	else
<span class="p_del">-		free_pages((unsigned long)addr, get_order(align));</span>
<span class="p_add">+		free_pages(addr, get_order(align));</span>
 }
 
 static inline void scif_get_window(struct scif_window *window, int nr_pages)
<span class="p_header">diff --git a/drivers/misc/sgi-gru/grufile.c b/drivers/misc/sgi-gru/grufile.c</span>
<span class="p_header">index 104a05f..276a599 100644</span>
<span class="p_header">--- a/drivers/misc/sgi-gru/grufile.c</span>
<span class="p_header">+++ b/drivers/misc/sgi-gru/grufile.c</span>
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static int gru_init_tables(unsigned long gru_base_paddr, void *gru_base_vaddr)</span>
 
 fail:
 	for (bid--; bid &gt;= 0; bid--)
<span class="p_del">-		free_pages((unsigned long)gru_base[bid], order);</span>
<span class="p_add">+		free_pages(gru_base[bid], order);</span>
 	return -ENOMEM;
 }
 
<span class="p_chunk">@@ -317,7 +317,7 @@</span> <span class="p_context"> static void gru_free_tables(void)</span>
 			      GRU_CHIPLETS_PER_BLADE);
 
 	for (bid = 0; bid &lt; GRU_MAX_BLADES; bid++)
<span class="p_del">-		free_pages((unsigned long)gru_base[bid], order);</span>
<span class="p_add">+		free_pages(gru_base[bid], order);</span>
 }
 
 static unsigned long gru_chiplet_cpu_to_mmr(int chiplet, int cpu, int *corep)
<span class="p_header">diff --git a/drivers/misc/sgi-xp/xpc_uv.c b/drivers/misc/sgi-xp/xpc_uv.c</span>
<span class="p_header">index 340b44d..c3fce37 100644</span>
<span class="p_header">--- a/drivers/misc/sgi-xp/xpc_uv.c</span>
<span class="p_header">+++ b/drivers/misc/sgi-xp/xpc_uv.c</span>
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> out_5:</span>
 out_4:
 	xpc_gru_mq_watchlist_free_uv(mq);
 out_3:
<span class="p_del">-	free_pages((unsigned long)mq-&gt;address, pg_order);</span>
<span class="p_add">+	free_pages(mq-&gt;address, pg_order);</span>
 out_2:
 	kfree(mq-&gt;gru_mq_desc);
 out_1:
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> xpc_destroy_gru_mq_uv(struct xpc_gru_mq_uv *mq)</span>
 	xpc_gru_mq_watchlist_free_uv(mq);
 
 	pg_order = mq-&gt;order - PAGE_SHIFT;
<span class="p_del">-	free_pages((unsigned long)mq-&gt;address, pg_order);</span>
<span class="p_add">+	free_pages(mq-&gt;address, pg_order);</span>
 
 	kfree(mq);
 }
<span class="p_header">diff --git a/drivers/mmc/host/tmio_mmc_dma.c b/drivers/mmc/host/tmio_mmc_dma.c</span>
<span class="p_header">index e4b05db..be9c8d7 100644</span>
<span class="p_header">--- a/drivers/mmc/host/tmio_mmc_dma.c</span>
<span class="p_header">+++ b/drivers/mmc/host/tmio_mmc_dma.c</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> void tmio_mmc_release_dma(struct tmio_mmc_host *host)</span>
 		dma_release_channel(chan);
 	}
 	if (host-&gt;bounce_buf) {
<span class="p_del">-		free_pages((unsigned long)host-&gt;bounce_buf, 0);</span>
<span class="p_add">+		free_pages(host-&gt;bounce_buf, 0);</span>
 		host-&gt;bounce_buf = NULL;
 	}
 }
<span class="p_header">diff --git a/drivers/net/appletalk/ltpc.c b/drivers/net/appletalk/ltpc.c</span>
<span class="p_header">index 01e2ac5..c98dea0 100644</span>
<span class="p_header">--- a/drivers/net/appletalk/ltpc.c</span>
<span class="p_header">+++ b/drivers/net/appletalk/ltpc.c</span>
<span class="p_chunk">@@ -1182,7 +1182,7 @@</span> <span class="p_context"> out4:</span>
 	if (dev-&gt;irq)
 		free_irq(dev-&gt;irq, dev);
 out3:
<span class="p_del">-	free_pages((unsigned long)ltdmabuf, get_order(1000));</span>
<span class="p_add">+	free_pages(ltdmabuf, get_order(1000));</span>
 out2:
 	release_region(io, 8);
 out1:
<span class="p_chunk">@@ -1277,7 +1277,7 @@</span> <span class="p_context"> static void __exit ltpc_cleanup(void)</span>
 
 	if(debug &amp; DEBUG_VERBOSE) printk(&quot;free_pages\n&quot;);
 
<span class="p_del">-	free_pages( (unsigned long) ltdmabuf, get_order(1000));</span>
<span class="p_add">+	free_pages(ltdmabuf, get_order(1000));</span>
 
 	if(debug &amp; DEBUG_VERBOSE) printk(&quot;returning from cleanup_module\n&quot;);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/amd/mvme147.c b/drivers/net/ethernet/amd/mvme147.c</span>
<span class="p_header">index 0660ac5..abda91c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/mvme147.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/mvme147.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> struct net_device * __init mvme147lance_probe(int unit)</span>
 
 	err = register_netdev(dev);
 	if (err) {
<span class="p_del">-		free_pages(lp-&gt;ram, 3);</span>
<span class="p_add">+		free_pages((void *)lp-&gt;ram, 3);</span>
 		free_netdev(dev);
 		return ERR_PTR(err);
 	}
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> void __exit cleanup_module(void)</span>
 {
 	struct m147lance_private *lp = netdev_priv(dev_mvme147_lance);
 	unregister_netdev(dev_mvme147_lance);
<span class="p_del">-	free_pages(lp-&gt;ram, 3);</span>
<span class="p_add">+	free_pages((void *)lp-&gt;ram, 3);</span>
 	free_netdev(dev_mvme147_lance);
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/cavium/liquidio/octeon_main.h b/drivers/net/ethernet/cavium/liquidio/octeon_main.h</span>
<span class="p_header">index cbd0819..61dbccc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cavium/liquidio/octeon_main.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/cavium/liquidio/octeon_main.h</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> cnnic_alloc_aligned_dma(struct pci_dev *pci_dev,</span>
 		    (void *)__get_free_pages(GFP_KERNEL,
 					     get_order(size));
 		if ((unsigned long)ptr &amp; 0x07) {
<span class="p_del">-			free_pages((unsigned long)ptr, get_order(size));</span>
<span class="p_add">+			free_pages(ptr, get_order(size));</span>
 			ptr = NULL;
 			/* Increment the size required if the first
 			 * attempt failed.
<span class="p_chunk">@@ -160,7 +160,7 @@</span> <span class="p_context"> cnnic_alloc_aligned_dma(struct pci_dev *pci_dev,</span>
 }
 
 #define cnnic_free_aligned_dma(pci_dev, ptr, size, orig_ptr, dma_addr) \
<span class="p_del">-		free_pages(orig_ptr, get_order(size))</span>
<span class="p_add">+		free_pages((void *)orig_ptr, get_order(size))</span>
 
 static inline void
 sleep_cond(wait_queue_head_t *wait_queue, int *condition)
<span class="p_header">diff --git a/drivers/net/ethernet/cirrus/cs89x0.c b/drivers/net/ethernet/cirrus/cs89x0.c</span>
<span class="p_header">index 6038304..815c596 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cirrus/cs89x0.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/cirrus/cs89x0.c</span>
<span class="p_chunk">@@ -473,7 +473,7 @@</span> <span class="p_context"> skip_this_frame:</span>
 static void release_dma_buff(struct net_local *lp)
 {
 	if (lp-&gt;dma_buff) {
<span class="p_del">-		free_pages((unsigned long)(lp-&gt;dma_buff),</span>
<span class="p_add">+		free_pages(lp-&gt;dma_buff,</span>
 			   get_order(lp-&gt;dmasize * 1024));
 		lp-&gt;dma_buff = NULL;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/sgi/ioc3-eth.c b/drivers/net/ethernet/sgi/ioc3-eth.c</span>
<span class="p_header">index d3b1416..e314d3f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sgi/ioc3-eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sgi/ioc3-eth.c</span>
<span class="p_chunk">@@ -872,7 +872,7 @@</span> <span class="p_context"> static void ioc3_free_rings(struct ioc3_private *ip)</span>
 
 	if (ip-&gt;txr) {
 		ioc3_clean_tx_ring(ip);
<span class="p_del">-		free_pages((unsigned long)ip-&gt;txr, 2);</span>
<span class="p_add">+		free_pages(ip-&gt;txr, 2);</span>
 		ip-&gt;txr = NULL;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/sun/niu.c b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">index ab6051a..66ac0ffe 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sun/niu.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sun/niu.c</span>
<span class="p_chunk">@@ -9974,7 +9974,7 @@</span> <span class="p_context"> static void niu_phys_free_coherent(struct device *dev, size_t size,</span>
 {
 	unsigned long order = get_order(size);
 
<span class="p_del">-	free_pages((unsigned long) cpu_addr, order);</span>
<span class="p_add">+	free_pages(cpu_addr, order);</span>
 }
 
 static u64 niu_phys_map_page(struct device *dev, struct page *page,
<span class="p_header">diff --git a/drivers/net/ethernet/tile/tilegx.c b/drivers/net/ethernet/tile/tilegx.c</span>
<span class="p_header">index 0a15acc..d1a9d77 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/tile/tilegx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/tile/tilegx.c</span>
<span class="p_chunk">@@ -1262,12 +1262,10 @@</span> <span class="p_context"> static void tile_net_init_mpipe_fail(int instance)</span>
 
 	for_each_online_cpu(cpu) {
 		struct tile_net_info *info = &amp;per_cpu(per_cpu_info, cpu);
<span class="p_del">-		free_pages(</span>
<span class="p_del">-			(unsigned long)(</span>
<span class="p_del">-				info-&gt;mpipe[instance].comps_for_echannel[0]),</span>
<span class="p_add">+		free_pages(info-&gt;mpipe[instance].comps_for_echannel[0],</span>
 			get_order(COMPS_SIZE));
 		info-&gt;mpipe[instance].comps_for_echannel[0] = NULL;
<span class="p_del">-		free_pages((unsigned long)(info-&gt;mpipe[instance].iqueue.idescs),</span>
<span class="p_add">+		free_pages(info-&gt;mpipe[instance].iqueue.idescs,</span>
 			   get_order(NOTIF_RING_SIZE));
 		info-&gt;mpipe[instance].iqueue.idescs = NULL;
 	}
<span class="p_header">diff --git a/drivers/net/irda/au1k_ir.c b/drivers/net/irda/au1k_ir.c</span>
<span class="p_header">index 44e4f38..6095cf4 100644</span>
<span class="p_header">--- a/drivers/net/irda/au1k_ir.c</span>
<span class="p_header">+++ b/drivers/net/irda/au1k_ir.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> static void *dma_alloc(size_t size, dma_addr_t *dma_handle)</span>
 static void dma_free(void *vaddr, size_t size)
 {
 	vaddr = (void *)KSEG0ADDR(vaddr);
<span class="p_del">-	free_pages((unsigned long) vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 
<span class="p_header">diff --git a/drivers/net/rionet.c b/drivers/net/rionet.c</span>
<span class="p_header">index 01f08a7..d0c1b13 100644</span>
<span class="p_header">--- a/drivers/net/rionet.c</span>
<span class="p_header">+++ b/drivers/net/rionet.c</span>
<span class="p_chunk">@@ -626,7 +626,7 @@</span> <span class="p_context"> static void __exit rionet_exit(void)</span>
 				kfree(peer);
 			}
 
<span class="p_del">-			free_pages((unsigned long)nets[i].active,</span>
<span class="p_add">+			free_pages(nets[i].active,</span>
 				 get_order(sizeof(void *) *
 				 RIO_MAX_ROUTE_ENTRIES(rnet-&gt;mport-&gt;sys_size)));
 			nets[i].active = NULL;
<span class="p_header">diff --git a/drivers/net/wireless/b43/debugfs.c b/drivers/net/wireless/b43/debugfs.c</span>
<span class="p_header">index 260de71..50a2316 100644</span>
<span class="p_header">--- a/drivers/net/wireless/b43/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/b43/debugfs.c</span>
<span class="p_chunk">@@ -540,7 +540,7 @@</span> <span class="p_context"> static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,</span>
 		memset(buf, 0, bufsize);
 		ret = dfops-&gt;read(dev, buf, bufsize);
 		if (ret &lt;= 0) {
<span class="p_del">-			free_pages((unsigned long)buf, buforder);</span>
<span class="p_add">+			free_pages(buf, buforder);</span>
 			err = ret;
 			goto out_unlock;
 		}
<span class="p_chunk">@@ -552,7 +552,7 @@</span> <span class="p_context"> static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,</span>
 				      dfile-&gt;buffer,
 				      dfile-&gt;data_len);
 	if (*ppos &gt;= dfile-&gt;data_len) {
<span class="p_del">-		free_pages((unsigned long)dfile-&gt;buffer, buforder);</span>
<span class="p_add">+		free_pages(dfile-&gt;buffer, buforder);</span>
 		dfile-&gt;buffer = NULL;
 		dfile-&gt;data_len = 0;
 	}
<span class="p_header">diff --git a/drivers/net/wireless/b43legacy/debugfs.c b/drivers/net/wireless/b43legacy/debugfs.c</span>
<span class="p_header">index 947a823..e243955 100644</span>
<span class="p_header">--- a/drivers/net/wireless/b43legacy/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/b43legacy/debugfs.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> static ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,</span>
 		} else
 			ret = dfops-&gt;read(dev, buf, bufsize);
 		if (ret &lt;= 0) {
<span class="p_del">-			free_pages((unsigned long)buf, buforder);</span>
<span class="p_add">+			free_pages(buf, buforder);</span>
 			err = ret;
 			goto out_unlock;
 		}
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> static ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,</span>
 				      dfile-&gt;buffer,
 				      dfile-&gt;data_len);
 	if (*ppos &gt;= dfile-&gt;data_len) {
<span class="p_del">-		free_pages((unsigned long)dfile-&gt;buffer, buforder);</span>
<span class="p_add">+		free_pages(dfile-&gt;buffer, buforder);</span>
 		dfile-&gt;buffer = NULL;
 		dfile-&gt;data_len = 0;
 	}
<span class="p_header">diff --git a/drivers/net/wireless/iwlegacy/common.h b/drivers/net/wireless/iwlegacy/common.h</span>
<span class="p_header">index ce52cf1..555bf02 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlegacy/common.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlegacy/common.h</span>
<span class="p_chunk">@@ -1504,7 +1504,7 @@</span> <span class="p_context"> __il_free_pages(struct il_priv *il, struct page *page)</span>
 static inline void
 il_free_pages(struct il_priv *il, unsigned long page)
 {
<span class="p_del">-	free_pages(page, il-&gt;hw_params.rx_page_order);</span>
<span class="p_add">+	free_pages((void *)page, il-&gt;hw_params.rx_page_order);</span>
 	il-&gt;alloc_rxb_page--;
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/iwl-trans.h b/drivers/net/wireless/iwlwifi/iwl-trans.h</span>
<span class="p_header">index 6f76525..8ccbda2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/iwl-trans.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/iwl-trans.h</span>
<span class="p_chunk">@@ -342,7 +342,7 @@</span> <span class="p_context"> struct iwl_host_cmd {</span>
 
 static inline void iwl_free_resp(struct iwl_host_cmd *cmd)
 {
<span class="p_del">-	free_pages(cmd-&gt;_rx_page_addr, cmd-&gt;_rx_page_order);</span>
<span class="p_add">+	free_pages((void *)cmd-&gt;_rx_page_addr, cmd-&gt;_rx_page_order);</span>
 }
 
 struct iwl_rx_cmd_buffer {
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/main.c b/drivers/net/wireless/ti/wlcore/main.c</span>
<span class="p_header">index 25defe4..374adb1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/main.c</span>
<span class="p_chunk">@@ -6354,7 +6354,7 @@</span> <span class="p_context"> err_dummy_packet:</span>
 	dev_kfree_skb(wl-&gt;dummy_packet);
 
 err_aggr:
<span class="p_del">-	free_pages((unsigned long)wl-&gt;aggr_buf, order);</span>
<span class="p_add">+	free_pages(wl-&gt;aggr_buf, order);</span>
 
 err_wq:
 	destroy_workqueue(wl-&gt;freezable_wq);
<span class="p_chunk">@@ -6386,7 +6386,7 @@</span> <span class="p_context"> int wlcore_free_hw(struct wl1271 *wl)</span>
 	kfree(wl-&gt;mbox);
 	free_page(wl-&gt;fwlog);
 	dev_kfree_skb(wl-&gt;dummy_packet);
<span class="p_del">-	free_pages((unsigned long)wl-&gt;aggr_buf, get_order(wl-&gt;aggr_buf_size));</span>
<span class="p_add">+	free_pages(wl-&gt;aggr_buf, get_order(wl-&gt;aggr_buf_size));</span>
 
 	wl1271_debugfs_exit(wl);
 
<span class="p_header">diff --git a/drivers/parisc/ccio-dma.c b/drivers/parisc/ccio-dma.c</span>
<span class="p_header">index 8e11fb2..b172617 100644</span>
<span class="p_header">--- a/drivers/parisc/ccio-dma.c</span>
<span class="p_header">+++ b/drivers/parisc/ccio-dma.c</span>
<span class="p_chunk">@@ -871,7 +871,7 @@</span> <span class="p_context"> ccio_free_consistent(struct device *dev, size_t size, void *cpu_addr,</span>
 		     dma_addr_t dma_handle)
 {
 	ccio_unmap_single(dev, dma_handle, size, 0);
<span class="p_del">-	free_pages((unsigned long)cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/parisc/ccio-rm-dma.c b/drivers/parisc/ccio-rm-dma.c</span>
<span class="p_header">index f78f6f1..b9649c2 100644</span>
<span class="p_header">--- a/drivers/parisc/ccio-rm-dma.c</span>
<span class="p_header">+++ b/drivers/parisc/ccio-rm-dma.c</span>
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> static void *ccio_alloc_consistent(struct pci_dev *dev, size_t size,</span>
 static void ccio_free_consistent(struct pci_dev *dev, size_t size,
 			       void *vaddr, dma_addr_t handle)
 {
<span class="p_del">-	free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 static dma_addr_t ccio_map_single(struct pci_dev *dev, void *ptr, size_t size,
<span class="p_header">diff --git a/drivers/parisc/sba_iommu.c b/drivers/parisc/sba_iommu.c</span>
<span class="p_header">index 225049b..6066d4e 100644</span>
<span class="p_header">--- a/drivers/parisc/sba_iommu.c</span>
<span class="p_header">+++ b/drivers/parisc/sba_iommu.c</span>
<span class="p_chunk">@@ -901,7 +901,7 @@</span> <span class="p_context"> sba_free_consistent(struct device *hwdev, size_t size, void *vaddr,</span>
 		    dma_addr_t dma_handle)
 {
 	sba_unmap_single(hwdev, dma_handle, size, 0);
<span class="p_del">-	free_pages((unsigned long) vaddr, get_order(size));</span>
<span class="p_add">+	free_pages(vaddr, get_order(size));</span>
 }
 
 
<span class="p_chunk">@@ -1156,14 +1156,14 @@</span> <span class="p_context"> sba_alloc_pdir(unsigned int pdir_size)</span>
 			/* allocate a new one on 512k alignment */
 			unsigned long new_pdir = __get_free_pages(GFP_KERNEL, (19-12));
 			/* release original */
<span class="p_del">-			free_pages(pdir_base, pdir_order);</span>
<span class="p_add">+			free_pages((void *)pdir_base, pdir_order);</span>
 
 			pdir_base = new_pdir;
 
 			/* release excess */
 			while (pdir_order &lt; (19-12)) {
 				new_pdir += pdir_size;
<span class="p_del">-				free_pages(new_pdir, pdir_order);</span>
<span class="p_add">+				free_pages((void *)new_pdir, pdir_order);</span>
 				pdir_order +=1;
 				pdir_size &lt;&lt;=1;
 			}
<span class="p_chunk">@@ -1176,10 +1176,10 @@</span> <span class="p_context"> sba_alloc_pdir(unsigned int pdir_size)</span>
 		unsigned long new_pdir = __get_free_pages(GFP_KERNEL, pdir_order+1); /* 2 or 4MB */
 
 		/* release original */
<span class="p_del">-		free_pages( pdir_base, pdir_order);</span>
<span class="p_add">+		free_pages((void *)pdir_base, pdir_order);</span>
 
 		/* release first 1MB */
<span class="p_del">-		free_pages(new_pdir, 20-12);</span>
<span class="p_add">+		free_pages((void *)new_pdir, 20-12);</span>
 
 		pdir_base = new_pdir + 1024*1024;
 
<span class="p_chunk">@@ -1194,10 +1194,10 @@</span> <span class="p_context"> sba_alloc_pdir(unsigned int pdir_size)</span>
 
 			new_pdir += 3*1024*1024;
 			/* release last 1MB */
<span class="p_del">-			free_pages(new_pdir, 20-12);</span>
<span class="p_add">+			free_pages((void *)new_pdir, 20-12);</span>
 
 			/* release unusable 128KB */
<span class="p_del">-			free_pages(new_pdir - 128*1024 , 17-12);</span>
<span class="p_add">+			free_pages((void *)new_pdir - 128*1024 , 17-12);</span>
 
 			pdir_size -= 128*1024;
 		}
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index 3018ae5..9ad90fd 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -1347,7 +1347,7 @@</span> <span class="p_context"> static int tegra_pcie_disable_msi(struct tegra_pcie *pcie)</span>
 	afi_writel(pcie, 0, AFI_MSI_EN_VEC6);
 	afi_writel(pcie, 0, AFI_MSI_EN_VEC7);
 
<span class="p_del">-	free_pages(msi-&gt;pages, 0);</span>
<span class="p_add">+	free_pages((void *)msi-&gt;pages, 0);</span>
 
 	if (msi-&gt;irq &gt; 0)
 		free_irq(msi-&gt;irq, pcie);
<span class="p_header">diff --git a/drivers/pci/host/pcie-xilinx.c b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">index 3c7a0d5..a9438d2 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_chunk">@@ -527,7 +527,7 @@</span> <span class="p_context"> static void xilinx_pcie_free_irq_domain(struct xilinx_pcie_port *port)</span>
 	/* Free IRQ Domain */
 	if (IS_ENABLED(CONFIG_PCI_MSI)) {
 
<span class="p_del">-		free_pages(port-&gt;msi_pages, 0);</span>
<span class="p_add">+		free_pages((void *)port-&gt;msi_pages, 0);</span>
 
 		num_irqs = XILINX_NUM_MSI_IRQS;
 	} else {
<span class="p_header">diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c</span>
<span class="p_header">index 5257c80..7b24131 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> struct dasd_device *dasd_alloc_device(void)</span>
 	/* Get one page for error recovery. */
 	device-&gt;erp_mem = (void *) get_zeroed_page(GFP_ATOMIC | GFP_DMA);
 	if (!device-&gt;erp_mem) {
<span class="p_del">-		free_pages((unsigned long) device-&gt;ccw_mem, 1);</span>
<span class="p_add">+		free_pages(device-&gt;ccw_mem, 1);</span>
 		kfree(device);
 		return ERR_PTR(-ENOMEM);
 	}
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> void dasd_free_device(struct dasd_device *device)</span>
 {
 	kfree(device-&gt;private);
 	free_page(device-&gt;erp_mem);
<span class="p_del">-	free_pages((unsigned long)device-&gt;ccw_mem, 1);</span>
<span class="p_add">+	free_pages(device-&gt;ccw_mem, 1);</span>
 	kfree(device);
 }
 
<span class="p_header">diff --git a/drivers/s390/char/hmcdrv_cache.c b/drivers/s390/char/hmcdrv_cache.c</span>
<span class="p_header">index 4cda5ad..60a4233 100644</span>
<span class="p_header">--- a/drivers/s390/char/hmcdrv_cache.c</span>
<span class="p_header">+++ b/drivers/s390/char/hmcdrv_cache.c</span>
<span class="p_chunk">@@ -240,7 +240,7 @@</span> <span class="p_context"> int hmcdrv_cache_startup(size_t cachesize)</span>
 void hmcdrv_cache_shutdown(void)
 {
 	if (hmcdrv_cache_file.content) {
<span class="p_del">-		free_pages((unsigned long) hmcdrv_cache_file.content,</span>
<span class="p_add">+		free_pages(hmcdrv_cache_file.content,</span>
 			   hmcdrv_cache_order);
 		hmcdrv_cache_file.content = NULL;
 	}
<span class="p_header">diff --git a/drivers/s390/char/hmcdrv_ftp.c b/drivers/s390/char/hmcdrv_ftp.c</span>
<span class="p_header">index d8a07bb..c08e633 100644</span>
<span class="p_header">--- a/drivers/s390/char/hmcdrv_ftp.c</span>
<span class="p_header">+++ b/drivers/s390/char/hmcdrv_ftp.c</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> ssize_t hmcdrv_ftp_cmd(char __kernel *cmd, loff_t offset,</span>
 		break;
 	}
 
<span class="p_del">-	free_pages((unsigned long) ftp.buf, order);</span>
<span class="p_add">+	free_pages(ftp.buf, order);</span>
 	return retlen;
 }
 
<span class="p_header">diff --git a/drivers/s390/char/tty3270.c b/drivers/s390/char/tty3270.c</span>
<span class="p_header">index e96fc7f..bb61f97 100644</span>
<span class="p_header">--- a/drivers/s390/char/tty3270.c</span>
<span class="p_header">+++ b/drivers/s390/char/tty3270.c</span>
<span class="p_chunk">@@ -728,7 +728,7 @@</span> <span class="p_context"> out_write:</span>
 	raw3270_request_free(tp-&gt;write);
 out_pages:
 	while (pages--)
<span class="p_del">-		free_pages((unsigned long) tp-&gt;freemem_pages[pages], 0);</span>
<span class="p_add">+		free_pages(tp-&gt;freemem_pages[pages], 0);</span>
 	kfree(tp-&gt;freemem_pages);
 	tty_port_destroy(&amp;tp-&gt;port);
 out_tp:
<span class="p_chunk">@@ -750,7 +750,7 @@</span> <span class="p_context"> tty3270_free_view(struct tty3270 *tp)</span>
 	raw3270_request_free(tp-&gt;read);
 	raw3270_request_free(tp-&gt;write);
 	for (pages = 0; pages &lt; TTY3270_STRING_PAGES; pages++)
<span class="p_del">-		free_pages((unsigned long) tp-&gt;freemem_pages[pages], 0);</span>
<span class="p_add">+		free_pages(tp-&gt;freemem_pages[pages], 0);</span>
 	kfree(tp-&gt;freemem_pages);
 	tty_port_destroy(&amp;tp-&gt;port);
 	kfree(tp);
<span class="p_header">diff --git a/drivers/s390/char/vmcp.c b/drivers/s390/char/vmcp.c</span>
<span class="p_header">index 0fdedad..f73bf6b 100644</span>
<span class="p_header">--- a/drivers/s390/char/vmcp.c</span>
<span class="p_header">+++ b/drivers/s390/char/vmcp.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> static int vmcp_release(struct inode *inode, struct file *file)</span>
 
 	session = file-&gt;private_data;
 	file-&gt;private_data = NULL;
<span class="p_del">-	free_pages((unsigned long)session-&gt;response, get_order(session-&gt;bufsize));</span>
<span class="p_add">+	free_pages(session-&gt;response, get_order(session-&gt;bufsize));</span>
 	kfree(session);
 	return 0;
 }
<span class="p_chunk">@@ -151,8 +151,7 @@</span> <span class="p_context"> static long vmcp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 		mutex_unlock(&amp;session-&gt;mutex);
 		return put_user(temp, argp);
 	case VMCP_SETBUF:
<span class="p_del">-		free_pages((unsigned long)session-&gt;response,</span>
<span class="p_del">-				get_order(session-&gt;bufsize));</span>
<span class="p_add">+		free_pages(session-&gt;response, get_order(session-&gt;bufsize));</span>
 		session-&gt;response=NULL;
 		temp = get_user(session-&gt;bufsize, argp);
 		if (get_order(session-&gt;bufsize) &gt; 8) {
<span class="p_header">diff --git a/drivers/s390/cio/cmf.c b/drivers/s390/cio/cmf.c</span>
<span class="p_header">index b2afad5..70356a3 100644</span>
<span class="p_header">--- a/drivers/s390/cio/cmf.c</span>
<span class="p_header">+++ b/drivers/s390/cio/cmf.c</span>
<span class="p_chunk">@@ -578,7 +578,7 @@</span> <span class="p_context"> static int alloc_cmb(struct ccw_device *cdev)</span>
 
 		if (cmb_area.mem) {
 			/* ok, another thread was faster */
<span class="p_del">-			free_pages((unsigned long)mem, get_order(size));</span>
<span class="p_add">+			free_pages(mem, get_order(size));</span>
 		} else if (!mem) {
 			/* no luck */
 			ret = -ENOMEM;
<span class="p_chunk">@@ -622,7 +622,7 @@</span> <span class="p_context"> static void free_cmb(struct ccw_device *cdev)</span>
 		ssize_t size;
 		size = sizeof(struct cmb) * cmb_area.num_channels;
 		cmf_activate(NULL, 0);
<span class="p_del">-		free_pages((unsigned long)cmb_area.mem, get_order(size));</span>
<span class="p_add">+		free_pages(cmb_area.mem, get_order(size));</span>
 		cmb_area.mem = NULL;
 	}
 	spin_unlock_irq(cdev-&gt;ccwlock);
<span class="p_header">diff --git a/drivers/scsi/cxlflash/main.c b/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">index b91d769..d4d6e38 100644</span>
<span class="p_header">--- a/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">+++ b/drivers/scsi/cxlflash/main.c</span>
<span class="p_chunk">@@ -622,7 +622,7 @@</span> <span class="p_context"> static void free_mem(struct cxlflash_cfg *cfg)</span>
 				free_page(buf);
 		}
 
<span class="p_del">-		free_pages((ulong)afu, get_order(sizeof(struct afu)));</span>
<span class="p_add">+		free_pages(afu, get_order(sizeof(struct afu)));</span>
 		cfg-&gt;afu = NULL;
 	}
 }
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index 6bffd91..d03ab52 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -2962,7 +2962,7 @@</span> <span class="p_context"> void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)</span>
 	iscsi_suspend_tx(conn);
 
 	spin_lock_bh(&amp;session-&gt;frwd_lock);
<span class="p_del">-	free_pages((unsigned long) conn-&gt;data,</span>
<span class="p_add">+	free_pages(conn-&gt;data,</span>
 		   get_order(ISCSI_DEF_MAX_RECV_SEG_LEN));
 	kfree(conn-&gt;persistent_address);
 	kfree(conn-&gt;local_ipaddr);
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">index db9446c..4d9457b 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_chunk">@@ -11476,14 +11476,14 @@</span> <span class="p_context"> lpfc_exit(void)</span>
 		printk(KERN_ERR	&quot;9062 BLKGRD: freeing %lu pages for &quot;
 				&quot;_dump_buf_data at 0x%p\n&quot;,
 				(1L &lt;&lt; _dump_buf_data_order), _dump_buf_data);
<span class="p_del">-		free_pages((unsigned long)_dump_buf_data, _dump_buf_data_order);</span>
<span class="p_add">+		free_pages(_dump_buf_data, _dump_buf_data_order);</span>
 	}
 
 	if (_dump_buf_dif) {
 		printk(KERN_ERR	&quot;9049 BLKGRD: freeing %lu pages for &quot;
 				&quot;_dump_buf_dif at 0x%p\n&quot;,
 				(1L &lt;&lt; _dump_buf_dif_order), _dump_buf_dif);
<span class="p_del">-		free_pages((unsigned long)_dump_buf_dif, _dump_buf_dif_order);</span>
<span class="p_add">+		free_pages(_dump_buf_dif, _dump_buf_dif_order);</span>
 	}
 	kfree(lpfc_used_cpu);
 	idr_destroy(&amp;lpfc_hba_index);
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 97a1c1c..2c81ab3 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -5939,7 +5939,7 @@</span> <span class="p_context"> static void megasas_detach_one(struct pci_dev *pdev)</span>
 						  fusion-&gt;ld_map[i],
 						  fusion-&gt;ld_map_phys[i]);
 			if (fusion-&gt;ld_drv_map[i])
<span class="p_del">-				free_pages((ulong)fusion-&gt;ld_drv_map[i],</span>
<span class="p_add">+				free_pages(fusion-&gt;ld_drv_map[i],</span>
 					fusion-&gt;drv_map_pages);
 				if (fusion-&gt;pd_seq_sync)
 					dma_free_coherent(&amp;instance-&gt;pdev-&gt;dev,
<span class="p_chunk">@@ -5947,7 +5947,7 @@</span> <span class="p_context"> static void megasas_detach_one(struct pci_dev *pdev)</span>
 						fusion-&gt;pd_seq_sync[i],
 						fusion-&gt;pd_seq_phys[i]);
 		}
<span class="p_del">-		free_pages((ulong)instance-&gt;ctrl_context,</span>
<span class="p_add">+		free_pages(instance-&gt;ctrl_context,</span>
 			instance-&gt;ctrl_context_pages);
 	} else {
 		megasas_release_mfi(instance);
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index 8d630a5..6429914 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -1193,7 +1193,7 @@</span> <span class="p_context"> megasas_init_adapter_fusion(struct megasas_instance *instance)</span>
 				&quot;memory for local map info for %d pages\n&quot;,
 				fusion-&gt;drv_map_pages);
 			if (i == 1)
<span class="p_del">-				free_pages((ulong)fusion-&gt;ld_drv_map[0],</span>
<span class="p_add">+				free_pages(fusion-&gt;ld_drv_map[0],</span>
 					fusion-&gt;drv_map_pages);
 			goto fail_ioc_init;
 		}
<span class="p_chunk">@@ -2486,7 +2486,7 @@</span> <span class="p_context"> megasas_free_host_crash_buffer(struct megasas_instance *instance)</span>
 ;
 	for (i = 0; i &lt; instance-&gt;drv_buf_alloc; i++) {
 		if (instance-&gt;crash_buf[i])
<span class="p_del">-			free_pages((ulong)instance-&gt;crash_buf[i],</span>
<span class="p_add">+			free_pages(instance-&gt;crash_buf[i],</span>
 					instance-&gt;crash_buf_pages);
 	}
 	instance-&gt;drv_buf_index = 0;
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">index 11393eb..0d73ea3 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_chunk">@@ -3115,7 +3115,7 @@</span> <span class="p_context"> _base_release_memory_pools(struct MPT3SAS_ADAPTER *ioc)</span>
 	}
 
 	if (ioc-&gt;scsi_lookup) {
<span class="p_del">-		free_pages((ulong)ioc-&gt;scsi_lookup, ioc-&gt;scsi_lookup_pages);</span>
<span class="p_add">+		free_pages(ioc-&gt;scsi_lookup, ioc-&gt;scsi_lookup_pages);</span>
 		ioc-&gt;scsi_lookup = NULL;
 	}
 	kfree(ioc-&gt;hpr_lookup);
<span class="p_chunk">@@ -3129,7 +3129,7 @@</span> <span class="p_context"> _base_release_memory_pools(struct MPT3SAS_ADAPTER *ioc)</span>
 		}
 		if (ioc-&gt;chain_dma_pool)
 			pci_pool_destroy(ioc-&gt;chain_dma_pool);
<span class="p_del">-		free_pages((ulong)ioc-&gt;chain_lookup, ioc-&gt;chain_pages);</span>
<span class="p_add">+		free_pages(ioc-&gt;chain_lookup, ioc-&gt;chain_pages);</span>
 		ioc-&gt;chain_lookup = NULL;
 	}
 }
<span class="p_header">diff --git a/drivers/scsi/ncr53c8xx.c b/drivers/scsi/ncr53c8xx.c</span>
<span class="p_header">index 5b93ed8..1c3f5a0 100644</span>
<span class="p_header">--- a/drivers/scsi/ncr53c8xx.c</span>
<span class="p_header">+++ b/drivers/scsi/ncr53c8xx.c</span>
<span class="p_chunk">@@ -366,7 +366,7 @@</span> <span class="p_context"> static m_addr_t ___mp0_getp(m_pool_s *mp)</span>
 
 static void ___mp0_freep(m_pool_s *mp, m_addr_t m)
 {
<span class="p_del">-	free_pages(m, MEMO_PAGE_ORDER);</span>
<span class="p_add">+	free_pages((void *)m, MEMO_PAGE_ORDER);</span>
 	--mp-&gt;nump;
 }
 
<span class="p_header">diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h</span>
<span class="p_header">index a141b17..45f9ac2 100644</span>
<span class="p_header">--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h</span>
<span class="p_header">+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h</span>
<span class="p_chunk">@@ -1125,7 +1125,7 @@</span> <span class="p_context"> bad:</span>
 #define sym_get_mem_cluster()	\
 	(void *) __get_free_pages(GFP_ATOMIC, SYM_MEM_PAGE_ORDER)
 #define sym_free_mem_cluster(p)	\
<span class="p_del">-	free_pages((unsigned long)p, SYM_MEM_PAGE_ORDER)</span>
<span class="p_add">+	free_pages(p, SYM_MEM_PAGE_ORDER)</span>
 
 /*
  *  Link between free memory chunks of a given size.
<span class="p_header">diff --git a/drivers/scsi/vmw_pvscsi.c b/drivers/scsi/vmw_pvscsi.c</span>
<span class="p_header">index 0f133c1..7921fc8 100644</span>
<span class="p_header">--- a/drivers/scsi/vmw_pvscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/vmw_pvscsi.c</span>
<span class="p_chunk">@@ -1159,7 +1159,7 @@</span> <span class="p_context"> static void pvscsi_free_sgls(const struct pvscsi_adapter *adapter)</span>
 	unsigned i;
 
 	for (i = 0; i &lt; adapter-&gt;req_depth; ++i, ++ctx)
<span class="p_del">-		free_pages((unsigned long)ctx-&gt;sgl, get_order(SGL_SIZE));</span>
<span class="p_add">+		free_pages(ctx-&gt;sgl, get_order(SGL_SIZE));</span>
 }
 
 static int pvscsi_setup_msix(const struct pvscsi_adapter *adapter,
<span class="p_chunk">@@ -1257,8 +1257,7 @@</span> <span class="p_context"> static int pvscsi_allocate_sg(struct pvscsi_adapter *adapter)</span>
 		BUG_ON(!IS_ALIGNED(((unsigned long)ctx-&gt;sgl), PAGE_SIZE));
 		if (!ctx-&gt;sgl) {
 			for (; i &gt;= 0; --i, --ctx) {
<span class="p_del">-				free_pages((unsigned long)ctx-&gt;sgl,</span>
<span class="p_del">-					   get_order(SGL_SIZE));</span>
<span class="p_add">+				free_pages(ctx-&gt;sgl, get_order(SGL_SIZE));</span>
 				ctx-&gt;sgl = NULL;
 			}
 			return -ENOMEM;
<span class="p_header">diff --git a/drivers/sh/maple/maple.c b/drivers/sh/maple/maple.c</span>
<span class="p_header">index bec81c2..84fa4f7 100644</span>
<span class="p_header">--- a/drivers/sh/maple/maple.c</span>
<span class="p_header">+++ b/drivers/sh/maple/maple.c</span>
<span class="p_chunk">@@ -874,7 +874,7 @@</span> <span class="p_context"> cleanup_irq:</span>
 	free_irq(HW_EVENT_MAPLE_DMA, 0);
 
 cleanup_dma:
<span class="p_del">-	free_pages((unsigned long) maple_sendbuf, MAPLE_DMA_PAGES);</span>
<span class="p_add">+	free_pages(maple_sendbuf, MAPLE_DMA_PAGES);</span>
 
 cleanup_basic:
 	driver_unregister(&amp;maple_unsupported_device.drv);
<span class="p_header">diff --git a/drivers/staging/rdma/ehca/ehca_mrmw.c b/drivers/staging/rdma/ehca/ehca_mrmw.c</span>
<span class="p_header">index f914b30..8bc19ca 100644</span>
<span class="p_header">--- a/drivers/staging/rdma/ehca/ehca_mrmw.c</span>
<span class="p_header">+++ b/drivers/staging/rdma/ehca/ehca_mrmw.c</span>
<span class="p_chunk">@@ -2560,7 +2560,7 @@</span> <span class="p_context"> static void *ehca_dma_alloc_coherent(struct ib_device *dev, size_t size,</span>
 		addr = page_address(p);
 		dma_addr = ehca_map_vaddr(addr);
 		if (ehca_dma_mapping_error(dev, dma_addr)) {
<span class="p_del">-			free_pages((unsigned long)addr,	get_order(size));</span>
<span class="p_add">+			free_pages(addr,	get_order(size));</span>
 			return NULL;
 		}
 		if (dma_handle)
<span class="p_chunk">@@ -2574,7 +2574,7 @@</span> <span class="p_context"> static void ehca_dma_free_coherent(struct ib_device *dev, size_t size,</span>
 				   void *cpu_addr, u64 dma_handle)
 {
 	if (cpu_addr &amp;&amp; size)
<span class="p_del">-		free_pages((unsigned long)cpu_addr, get_order(size));</span>
<span class="p_add">+		free_pages(cpu_addr, get_order(size));</span>
 }
 
 
<span class="p_header">diff --git a/drivers/staging/rdma/hfi1/dma.c b/drivers/staging/rdma/hfi1/dma.c</span>
<span class="p_header">index e03bd73..2ba5ce4 100644</span>
<span class="p_header">--- a/drivers/staging/rdma/hfi1/dma.c</span>
<span class="p_header">+++ b/drivers/staging/rdma/hfi1/dma.c</span>
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> static void *hfi1_dma_alloc_coherent(struct ib_device *dev, size_t size,</span>
 static void hfi1_dma_free_coherent(struct ib_device *dev, size_t size,
 				   void *cpu_addr, u64 dma_handle)
 {
<span class="p_del">-	free_pages((unsigned long) cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 }
 
 struct ib_dma_mapping_ops hfi1_dma_mapping_ops = {
<span class="p_header">diff --git a/drivers/staging/rdma/ipath/ipath_dma.c b/drivers/staging/rdma/ipath/ipath_dma.c</span>
<span class="p_header">index 123a8c0..e363f70 100644</span>
<span class="p_header">--- a/drivers/staging/rdma/ipath/ipath_dma.c</span>
<span class="p_header">+++ b/drivers/staging/rdma/ipath/ipath_dma.c</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> static void *ipath_dma_alloc_coherent(struct ib_device *dev, size_t size,</span>
 static void ipath_dma_free_coherent(struct ib_device *dev, size_t size,
 				    void *cpu_addr, u64 dma_handle)
 {
<span class="p_del">-	free_pages((unsigned long) cpu_addr, get_order(size));</span>
<span class="p_add">+	free_pages(cpu_addr, get_order(size));</span>
 }
 
 struct ib_dma_mapping_ops ipath_dma_mapping_ops = {
<span class="p_header">diff --git a/drivers/usb/core/devices.c b/drivers/usb/core/devices.c</span>
<span class="p_header">index 2a3bbdf..b741639 100644</span>
<span class="p_header">--- a/drivers/usb/core/devices.c</span>
<span class="p_header">+++ b/drivers/usb/core/devices.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,</span>
 		if (length &gt; *nbytes)
 			length = *nbytes;
 		if (copy_to_user(*buffer, pages_start + *skip_bytes, length)) {
<span class="p_del">-			free_pages((unsigned long)pages_start, 1);</span>
<span class="p_add">+			free_pages(pages_start, 1);</span>
 			return -EFAULT;
 		}
 		*nbytes -= length;
<span class="p_chunk">@@ -594,7 +594,7 @@</span> <span class="p_context"> static ssize_t usb_device_dump(char __user **buffer, size_t *nbytes,</span>
 	} else
 		*skip_bytes -= length;
 
<span class="p_del">-	free_pages((unsigned long)pages_start, 1);</span>
<span class="p_add">+	free_pages(pages_start, 1);</span>
 
 	/* Now look at all of this device&#39;s children. */
 	usb_hub_for_each_child(usbdev, chix, childdev) {
<span class="p_header">diff --git a/drivers/video/fbdev/vermilion/vermilion.c b/drivers/video/fbdev/vermilion/vermilion.c</span>
<span class="p_header">index 1c1e95a..0882f41 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/vermilion/vermilion.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/vermilion/vermilion.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> static void vmlfb_free_vram_area(struct vram_area *va)</span>
 		printk(KERN_DEBUG MODULE_NAME
 		       &quot;: Freeing %ld bytes vram area at 0x%08lx\n&quot;,
 		       va-&gt;size, va-&gt;phys);
<span class="p_del">-		free_pages(va-&gt;logical, va-&gt;order);</span>
<span class="p_add">+		free_pages((void *)va-&gt;logical, va-&gt;order);</span>
 
 		va-&gt;logical = 0;
 	}
<span class="p_header">diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">index 7399782..fa6b56e 100644</span>
<span class="p_header">--- a/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">+++ b/drivers/xen/swiotlb-xen.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> retry:</span>
 		if (early)
 			free_bootmem(__pa(xen_io_tlb_start), PAGE_ALIGN(bytes));
 		else {
<span class="p_del">-			free_pages((unsigned long)xen_io_tlb_start, order);</span>
<span class="p_add">+			free_pages(xen_io_tlb_start, order);</span>
 			xen_io_tlb_start = NULL;
 		}
 		m_ret = XEN_SWIOTLB_EFIXUP;
<span class="p_chunk">@@ -288,7 +288,7 @@</span> <span class="p_context"> error:</span>
 	if (early)
 		panic(&quot;%s (rc:%d)&quot;, xen_swiotlb_error(m_ret), rc);
 	else
<span class="p_del">-		free_pages((unsigned long)xen_io_tlb_start, order);</span>
<span class="p_add">+		free_pages(xen_io_tlb_start, order);</span>
 	return rc;
 }
 void *
<span class="p_header">diff --git a/fs/ceph/mds_client.c b/fs/ceph/mds_client.c</span>
<span class="p_header">index e7b130a..40c9ef6 100644</span>
<span class="p_header">--- a/fs/ceph/mds_client.c</span>
<span class="p_header">+++ b/fs/ceph/mds_client.c</span>
<span class="p_chunk">@@ -339,7 +339,7 @@</span> <span class="p_context"> static void destroy_reply_info(struct ceph_mds_reply_info_parsed *info)</span>
 {
 	if (!info-&gt;dir_in)
 		return;
<span class="p_del">-	free_pages((unsigned long)info-&gt;dir_in, get_order(info-&gt;dir_buf_size));</span>
<span class="p_add">+	free_pages(info-&gt;dir_in, get_order(info-&gt;dir_buf_size));</span>
 }
 
 
<span class="p_header">diff --git a/fs/ecryptfs/crypto.c b/fs/ecryptfs/crypto.c</span>
<span class="p_header">index 80d6901..cf53226 100644</span>
<span class="p_header">--- a/fs/ecryptfs/crypto.c</span>
<span class="p_header">+++ b/fs/ecryptfs/crypto.c</span>
<span class="p_chunk">@@ -1233,7 +1233,7 @@</span> <span class="p_context"> int ecryptfs_write_metadata(struct dentry *ecryptfs_dentry,</span>
 		goto out_free;
 	}
 out_free:
<span class="p_del">-	free_pages((unsigned long)virt, order);</span>
<span class="p_add">+	free_pages(virt, order);</span>
 out:
 	return rc;
 }
<span class="p_header">diff --git a/fs/hfs/mdb.c b/fs/hfs/mdb.c</span>
<span class="p_header">index aa3f0d6..92f1730 100644</span>
<span class="p_header">--- a/fs/hfs/mdb.c</span>
<span class="p_header">+++ b/fs/hfs/mdb.c</span>
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> void hfs_mdb_put(struct super_block *sb)</span>
 	unload_nls(HFS_SB(sb)-&gt;nls_io);
 	unload_nls(HFS_SB(sb)-&gt;nls_disk);
 
<span class="p_del">-	free_pages((unsigned long)HFS_SB(sb)-&gt;bitmap, PAGE_SIZE &lt; 8192 ? 1 : 0);</span>
<span class="p_add">+	free_pages(HFS_SB(sb)-&gt;bitmap, PAGE_SIZE &lt; 8192 ? 1 : 0);</span>
 	kfree(HFS_SB(sb));
 	sb-&gt;s_fs_info = NULL;
 }
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index 81e6226..450a30b 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -2322,14 +2322,14 @@</span> <span class="p_context"> void *jbd2_alloc(size_t size, gfp_t flags)</span>
 void jbd2_free(void *ptr, size_t size)
 {
 	if (size == PAGE_SIZE) {
<span class="p_del">-		free_pages((unsigned long)ptr, 0);</span>
<span class="p_add">+		free_pages(ptr, 0);</span>
 		return;
 	}
 	if (size &gt; PAGE_SIZE) {
 		int order = get_order(size);
 
 		if (order &lt; 3)
<span class="p_del">-			free_pages((unsigned long)ptr, order);</span>
<span class="p_add">+			free_pages(ptr, order);</span>
 		else
 			vfree(ptr);
 		return;
<span class="p_header">diff --git a/fs/nilfs2/ioctl.c b/fs/nilfs2/ioctl.c</span>
<span class="p_header">index aba4381..09d2ede 100644</span>
<span class="p_header">--- a/fs/nilfs2/ioctl.c</span>
<span class="p_header">+++ b/fs/nilfs2/ioctl.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> static int nilfs_ioctl_wrap_copy(struct the_nilfs *nilfs,</span>
 	}
 	argv-&gt;v_nmembs = total;
 
<span class="p_del">-	free_pages((unsigned long)buf, 0);</span>
<span class="p_add">+	free_pages(buf, 0);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/fs/proc/vmcore.c b/fs/proc/vmcore.c</span>
<span class="p_header">index 4e61388..dd6566c 100644</span>
<span class="p_header">--- a/fs/proc/vmcore.c</span>
<span class="p_header">+++ b/fs/proc/vmcore.c</span>
<span class="p_chunk">@@ -990,7 +990,7 @@</span> <span class="p_context"> static void __init set_vmcore_list_offsets(size_t elfsz, size_t elfnotes_sz,</span>
 
 static void free_elfcorebuf(void)
 {
<span class="p_del">-	free_pages((unsigned long)elfcorebuf, get_order(elfcorebuf_sz_orig));</span>
<span class="p_add">+	free_pages(elfcorebuf, get_order(elfcorebuf_sz_orig));</span>
 	elfcorebuf = NULL;
 	vfree(elfnotes_buf);
 	elfnotes_buf = NULL;
<span class="p_header">diff --git a/include/linux/gfp.h b/include/linux/gfp.h</span>
<span class="p_header">index 54c6efd..df5c0a0 100644</span>
<span class="p_header">--- a/include/linux/gfp.h</span>
<span class="p_header">+++ b/include/linux/gfp.h</span>
<span class="p_chunk">@@ -487,7 +487,7 @@</span> <span class="p_context"> void * __meminit alloc_pages_exact_nid(int nid, size_t size, gfp_t gfp_mask);</span>
 		__get_free_pages((gfp_mask) | GFP_DMA, (order))
 
 extern void __free_pages(struct page *page, unsigned int order);
<span class="p_del">-extern void free_pages(unsigned long addr, unsigned int order);</span>
<span class="p_add">+extern void free_pages(const void *addr, unsigned int order);</span>
 extern void free_hot_cold_page(struct page *page, bool cold);
 extern void free_hot_cold_page_list(struct list_head *list, bool cold);
 
<span class="p_chunk">@@ -500,7 +500,7 @@</span> <span class="p_context"> extern void __free_kmem_pages(struct page *page, unsigned int order);</span>
 extern void free_kmem_pages(unsigned long addr, unsigned int order);
 
 #define __free_page(page) __free_pages((page), 0)
<span class="p_del">-#define free_page(addr) free_pages((unsigned long)(addr), 0)</span>
<span class="p_add">+#define free_page(addr) free_pages((addr), 0)</span>
 
 void page_alloc_init(void);
 void drain_zone_pages(struct zone *zone, struct per_cpu_pages *pcp);
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 14703bb..b995e08 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -2985,7 +2985,7 @@</span> <span class="p_context"> ftrace_allocate_pages(unsigned long num_to_init)</span>
 	pg = start_pg;
 	while (pg) {
 		order = get_count_order(pg-&gt;size / ENTRIES_PER_PAGE);
<span class="p_del">-		free_pages((unsigned long)pg-&gt;records, order);</span>
<span class="p_add">+		free_pages(pg-&gt;records, order);</span>
 		start_pg = pg-&gt;next;
 		kfree(pg);
 		pg = start_pg;
<span class="p_chunk">@@ -4931,7 +4931,7 @@</span> <span class="p_context"> void ftrace_release_mod(struct module *mod)</span>
 
 			*last_pg = pg-&gt;next;
 			order = get_count_order(pg-&gt;size / ENTRIES_PER_PAGE);
<span class="p_del">-			free_pages((unsigned long)pg-&gt;records, order);</span>
<span class="p_add">+			free_pages(pg-&gt;records, order);</span>
 			kfree(pg);
 		} else
 			last_pg = &amp;pg-&gt;next;
<span class="p_header">diff --git a/kernel/trace/trace_events.c b/kernel/trace/trace_events.c</span>
<span class="p_header">index f2e26df..5d06111 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events.c</span>
<span class="p_chunk">@@ -600,7 +600,7 @@</span> <span class="p_context"> static void __ftrace_clear_event_pids(struct trace_array *tr)</span>
 	/* Wait till all users are no longer using pid filtering */
 	synchronize_sched();
 
<span class="p_del">-	free_pages((unsigned long)pid_list-&gt;pids, pid_list-&gt;order);</span>
<span class="p_add">+	free_pages(pid_list-&gt;pids, pid_list-&gt;order);</span>
 	kfree(pid_list);
 }
 
<span class="p_chunk">@@ -1662,7 +1662,7 @@</span> <span class="p_context"> ftrace_event_pid_write(struct file *filp, const char __user *ubuf,</span>
 				break;
 			memcpy(pid_page, pid_list-&gt;pids,
 			       pid_list-&gt;nr_pids * sizeof(pid_t));
<span class="p_del">-			free_pages((unsigned long)pid_list-&gt;pids, pid_list-&gt;order);</span>
<span class="p_add">+			free_pages(pid_list-&gt;pids, pid_list-&gt;order);</span>
 
 			pid_list-&gt;order++;
 			pid_list-&gt;pids = pid_page;
<span class="p_chunk">@@ -1676,7 +1676,7 @@</span> <span class="p_context"> ftrace_event_pid_write(struct file *filp, const char __user *ubuf,</span>
 
 	if (ret &lt; 0) {
 		if (pid_list)
<span class="p_del">-			free_pages((unsigned long)pid_list-&gt;pids, pid_list-&gt;order);</span>
<span class="p_add">+			free_pages(pid_list-&gt;pids, pid_list-&gt;order);</span>
 		kfree(pid_list);
 		mutex_unlock(&amp;event_mutex);
 		return ret;
<span class="p_chunk">@@ -1717,7 +1717,7 @@</span> <span class="p_context"> ftrace_event_pid_write(struct file *filp, const char __user *ubuf,</span>
 	if (filtered_pids) {
 		synchronize_sched();
 
<span class="p_del">-		free_pages((unsigned long)filtered_pids-&gt;pids, filtered_pids-&gt;order);</span>
<span class="p_add">+		free_pages(filtered_pids-&gt;pids, filtered_pids-&gt;order);</span>
 		kfree(filtered_pids);
 	} else {
 		/*
<span class="p_header">diff --git a/lib/percpu_ida.c b/lib/percpu_ida.c</span>
<span class="p_header">index 6d40944..d58f5a9 100644</span>
<span class="p_header">--- a/lib/percpu_ida.c</span>
<span class="p_header">+++ b/lib/percpu_ida.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(percpu_ida_free);</span>
 void percpu_ida_destroy(struct percpu_ida *pool)
 {
 	free_percpu(pool-&gt;tag_cpu);
<span class="p_del">-	free_pages((unsigned long) pool-&gt;freelist,</span>
<span class="p_add">+	free_pages(pool-&gt;freelist,</span>
 		   get_order(pool-&gt;nr_tags * sizeof(unsigned)));
 }
 EXPORT_SYMBOL_GPL(percpu_ida_destroy);
<span class="p_header">diff --git a/lib/raid6/algos.c b/lib/raid6/algos.c</span>
<span class="p_header">index 975c6e0..3d8cf31 100644</span>
<span class="p_header">--- a/lib/raid6/algos.c</span>
<span class="p_header">+++ b/lib/raid6/algos.c</span>
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> int __init raid6_select_algo(void)</span>
 	/* select raid recover functions */
 	rec_best = raid6_choose_recov();
 
<span class="p_del">-	free_pages((unsigned long)syndromes, 1);</span>
<span class="p_add">+	free_pages(syndromes, 1);</span>
 
 	return gen_best &amp;&amp; rec_best ? 0 : -EINVAL;
 }
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index 76f29ec..87e33e7 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> swiotlb_late_init_with_default_size(size_t default_size)</span>
 	}
 	rc = swiotlb_late_init_with_tbl(vstart, io_tlb_nslabs);
 	if (rc)
<span class="p_del">-		free_pages((unsigned long)vstart, order);</span>
<span class="p_add">+		free_pages(vstart, order);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -336,12 +336,10 @@</span> <span class="p_context"> swiotlb_late_init_with_tbl(char *tlb, unsigned long nslabs)</span>
 	return 0;
 
 cleanup4:
<span class="p_del">-	free_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *</span>
<span class="p_del">-	                                                 sizeof(int)));</span>
<span class="p_add">+	free_pages(io_tlb_list, get_order(io_tlb_nslabs * sizeof(int)));</span>
 	io_tlb_list = NULL;
 cleanup3:
<span class="p_del">-	free_pages((unsigned long)v_overflow_buffer,</span>
<span class="p_del">-		   get_order(io_tlb_overflow));</span>
<span class="p_add">+	free_pages(v_overflow_buffer, get_order(io_tlb_overflow));</span>
 	io_tlb_overflow_buffer = 0;
 cleanup2:
 	io_tlb_end = 0;
<span class="p_chunk">@@ -356,13 +354,12 @@</span> <span class="p_context"> void __init swiotlb_free(void)</span>
 		return;
 
 	if (late_alloc) {
<span class="p_del">-		free_pages((unsigned long)phys_to_virt(io_tlb_overflow_buffer),</span>
<span class="p_add">+		free_pages(phys_to_virt(io_tlb_overflow_buffer),</span>
 			   get_order(io_tlb_overflow));
<span class="p_del">-		free_pages((unsigned long)io_tlb_orig_addr,</span>
<span class="p_add">+		free_pages(io_tlb_orig_addr,</span>
 			   get_order(io_tlb_nslabs * sizeof(phys_addr_t)));
<span class="p_del">-		free_pages((unsigned long)io_tlb_list, get_order(io_tlb_nslabs *</span>
<span class="p_del">-								 sizeof(int)));</span>
<span class="p_del">-		free_pages((unsigned long)phys_to_virt(io_tlb_start),</span>
<span class="p_add">+		free_pages(io_tlb_list, get_order(io_tlb_nslabs * sizeof(int)));</span>
<span class="p_add">+		free_pages(phys_to_virt(io_tlb_start),</span>
 			   get_order(io_tlb_nslabs &lt;&lt; IO_TLB_SHIFT));
 	} else {
 		memblock_free_late(io_tlb_overflow_buffer,
<span class="p_chunk">@@ -644,7 +641,7 @@</span> <span class="p_context"> swiotlb_alloc_coherent(struct device *hwdev, size_t size,</span>
 			/*
 			 * The allocated memory isn&#39;t reachable by the device.
 			 */
<span class="p_del">-			free_pages((unsigned long) ret, order);</span>
<span class="p_add">+			free_pages(ret, order);</span>
 			ret = NULL;
 		}
 	}
<span class="p_chunk">@@ -696,7 +693,7 @@</span> <span class="p_context"> swiotlb_free_coherent(struct device *hwdev, size_t size, void *vaddr,</span>
 
 	WARN_ON(irqs_disabled());
 	if (!is_swiotlb_buffer(paddr))
<span class="p_del">-		free_pages((unsigned long)vaddr, get_order(size));</span>
<span class="p_add">+		free_pages(vaddr, get_order(size));</span>
 	else
 		/* DMA_TO_DEVICE to avoid memcpy in swiotlb_tbl_unmap_single */
 		swiotlb_tbl_unmap_single(hwdev, paddr, size, DMA_TO_DEVICE);
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 47f8f87..8364c20 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> void tlb_finish_mmu(struct mmu_gather *tlb, unsigned long start, unsigned long e</span>
 
 	for (batch = tlb-&gt;local.next; batch; batch = next) {
 		next = batch-&gt;next;
<span class="p_del">-		free_pages((unsigned long)batch, 0);</span>
<span class="p_add">+		free_pages(batch, 0);</span>
 	}
 	tlb-&gt;local.next = NULL;
 }
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index e68689c..11014f3 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -3292,11 +3292,11 @@</span> <span class="p_context"> void __free_pages(struct page *page, unsigned int order)</span>
 
 EXPORT_SYMBOL(__free_pages);
 
<span class="p_del">-void free_pages(unsigned long addr, unsigned int order)</span>
<span class="p_add">+void free_pages(const void *addr, unsigned int order)</span>
 {
<span class="p_del">-	if (addr != 0) {</span>
<span class="p_del">-		VM_BUG_ON(!virt_addr_valid((void *)addr));</span>
<span class="p_del">-		__free_pages(virt_to_page((void *)addr), order);</span>
<span class="p_add">+	if (addr) {</span>
<span class="p_add">+		VM_BUG_ON(!virt_addr_valid(addr));</span>
<span class="p_add">+		__free_pages(virt_to_page(addr), order);</span>
 	}
 }
 
<span class="p_header">diff --git a/mm/slob.c b/mm/slob.c</span>
<span class="p_header">index 17e8f8c..d6430e8 100644</span>
<span class="p_header">--- a/mm/slob.c</span>
<span class="p_header">+++ b/mm/slob.c</span>
<span class="p_chunk">@@ -208,7 +208,7 @@</span> <span class="p_context"> static void slob_free_pages(void *b, int order)</span>
 {
 	if (current-&gt;reclaim_state)
 		current-&gt;reclaim_state-&gt;reclaimed_slab += 1 &lt;&lt; order;
<span class="p_del">-	free_pages((unsigned long)b, order);</span>
<span class="p_add">+	free_pages(b, order);</span>
 }
 
 /*
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index b50b454..5da985fe 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -4196,8 +4196,7 @@</span> <span class="p_context"> struct loc_track {</span>
 static void free_loc_track(struct loc_track *t)
 {
 	if (t-&gt;max)
<span class="p_del">-		free_pages((unsigned long)t-&gt;loc,</span>
<span class="p_del">-			get_order(sizeof(struct location) * t-&gt;max));</span>
<span class="p_add">+		free_pages(t-&gt;loc, get_order(sizeof(struct location) * t-&gt;max));</span>
 }
 
 static int alloc_loc_track(struct loc_track *t, unsigned long max, gfp_t flags)
<span class="p_header">diff --git a/mm/sparse.c b/mm/sparse.c</span>
<span class="p_header">index d1b48b6..109258a 100644</span>
<span class="p_header">--- a/mm/sparse.c</span>
<span class="p_header">+++ b/mm/sparse.c</span>
<span class="p_chunk">@@ -648,7 +648,7 @@</span> <span class="p_context"> static void __kfree_section_memmap(struct page *memmap)</span>
 	if (is_vmalloc_addr(memmap))
 		vfree(memmap);
 	else
<span class="p_del">-		free_pages((unsigned long)memmap,</span>
<span class="p_add">+		free_pages(memmap,</span>
 			   get_order(sizeof(struct page) * PAGES_PER_SECTION));
 }
 
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index f18ae91..6eb5170 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> static void neigh_hash_free_rcu(struct rcu_head *head)</span>
 	if (size &lt;= PAGE_SIZE)
 		kfree(buckets);
 	else
<span class="p_del">-		free_pages((unsigned long)buckets, get_order(size));</span>
<span class="p_add">+		free_pages(buckets, get_order(size));</span>
 	kfree(nht);
 }
 
<span class="p_header">diff --git a/net/dccp/proto.c b/net/dccp/proto.c</span>
<span class="p_header">index 41e6580..b689ca8 100644</span>
<span class="p_header">--- a/net/dccp/proto.c</span>
<span class="p_header">+++ b/net/dccp/proto.c</span>
<span class="p_chunk">@@ -1211,11 +1211,11 @@</span> <span class="p_context"> out_ackvec_exit:</span>
 out_free_dccp_mib:
 	dccp_mib_exit();
 out_free_dccp_bhash:
<span class="p_del">-	free_pages((unsigned long)dccp_hashinfo.bhash, bhash_order);</span>
<span class="p_add">+	free_pages(dccp_hashinfo.bhash, bhash_order);</span>
 out_free_dccp_locks:
 	inet_ehash_locks_free(&amp;dccp_hashinfo);
 out_free_dccp_ehash:
<span class="p_del">-	free_pages((unsigned long)dccp_hashinfo.ehash, ehash_order);</span>
<span class="p_add">+	free_pages(dccp_hashinfo.ehash, ehash_order);</span>
 out_free_bind_bucket_cachep:
 	kmem_cache_destroy(dccp_hashinfo.bind_bucket_cachep);
 out_free_percpu:
<span class="p_chunk">@@ -1231,10 +1231,10 @@</span> <span class="p_context"> static void __exit dccp_fini(void)</span>
 {
 	ccid_cleanup_builtins();
 	dccp_mib_exit();
<span class="p_del">-	free_pages((unsigned long)dccp_hashinfo.bhash,</span>
<span class="p_add">+	free_pages(dccp_hashinfo.bhash,</span>
 		   get_order(dccp_hashinfo.bhash_size *
 			     sizeof(struct inet_bind_hashbucket)));
<span class="p_del">-	free_pages((unsigned long)dccp_hashinfo.ehash,</span>
<span class="p_add">+	free_pages(dccp_hashinfo.ehash,</span>
 		   get_order((dccp_hashinfo.ehash_mask + 1) *
 			     sizeof(struct inet_ehash_bucket)));
 	inet_ehash_locks_free(&amp;dccp_hashinfo);
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index d97268e..f69b6d9 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -853,7 +853,7 @@</span> <span class="p_context"> static void fib_info_hash_free(struct hlist_head *hash, int bytes)</span>
 	if (bytes &lt;= PAGE_SIZE)
 		kfree(hash);
 	else
<span class="p_del">-		free_pages((unsigned long) hash, get_order(bytes));</span>
<span class="p_add">+		free_pages(hash, get_order(bytes));</span>
 }
 
 static void fib_info_hash_move(struct hlist_head *new_info_hash,
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 3cb3cb8..5a80da65 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -1444,8 +1444,7 @@</span> <span class="p_context"> void nf_ct_free_hashtable(void *hash, unsigned int size)</span>
 	if (is_vmalloc_addr(hash))
 		vfree(hash);
 	else
<span class="p_del">-		free_pages((unsigned long)hash,</span>
<span class="p_del">-			   get_order(sizeof(struct hlist_head) * size));</span>
<span class="p_add">+		free_pages(hash, get_order(sizeof(struct hlist_head) * size));</span>
 }
 EXPORT_SYMBOL_GPL(nf_ct_free_hashtable);
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 59651af..da6fba6 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -328,7 +328,7 @@</span> <span class="p_context"> static void free_pg_vec(void **pg_vec, unsigned int order, unsigned int len)</span>
 			if (is_vmalloc_addr(pg_vec[i]))
 				vfree(pg_vec[i]);
 			else
<span class="p_del">-				free_pages((unsigned long)pg_vec[i], order);</span>
<span class="p_add">+				free_pages(pg_vec[i], order);</span>
 		}
 	}
 	kfree(pg_vec);
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 992396a..fae2812 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -4000,8 +4000,7 @@</span> <span class="p_context"> static void free_pg_vec(struct pgv *pg_vec, unsigned int order,</span>
 			if (is_vmalloc_addr(pg_vec[i].buffer))
 				vfree(pg_vec[i].buffer);
 			else
<span class="p_del">-				free_pages((unsigned long)pg_vec[i].buffer,</span>
<span class="p_del">-					   order);</span>
<span class="p_add">+				free_pages(pg_vec[i].buffer, order);</span>
 			pg_vec[i].buffer = NULL;
 		}
 	}
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index 7ec667d..1c9ff0b 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -645,7 +645,7 @@</span> <span class="p_context"> static void qdisc_class_hash_free(struct hlist_head *h, unsigned int n)</span>
 	if (size &lt;= PAGE_SIZE)
 		kfree(h);
 	else
<span class="p_del">-		free_pages((unsigned long)h, get_order(size));</span>
<span class="p_add">+		free_pages(h, get_order(size));</span>
 }
 
 void qdisc_class_hash_grow(struct Qdisc *sch, struct Qdisc_class_hash *clhash)
<span class="p_header">diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c</span>
<span class="p_header">index 3d9ea9a..8dfdd0e 100644</span>
<span class="p_header">--- a/net/sctp/protocol.c</span>
<span class="p_header">+++ b/net/sctp/protocol.c</span>
<span class="p_chunk">@@ -1514,13 +1514,13 @@</span> <span class="p_context"> err_register_defaults:</span>
 	sctp_v4_pf_exit();
 	sctp_v6_pf_exit();
 	sctp_sysctl_unregister();
<span class="p_del">-	free_pages((unsigned long)sctp_port_hashtable,</span>
<span class="p_add">+	free_pages(sctp_port_hashtable,</span>
 		   get_order(sctp_port_hashsize *
 			     sizeof(struct sctp_bind_hashbucket)));
 err_bhash_alloc:
 	kfree(sctp_ep_hashtable);
 err_ehash_alloc:
<span class="p_del">-	free_pages((unsigned long)sctp_assoc_hashtable,</span>
<span class="p_add">+	free_pages(sctp_assoc_hashtable,</span>
 		   get_order(sctp_assoc_hashsize *
 			     sizeof(struct sctp_hashbucket)));
 err_ahash_alloc:
<span class="p_chunk">@@ -1557,11 +1557,11 @@</span> <span class="p_context"> static __exit void sctp_exit(void)</span>
 
 	sctp_sysctl_unregister();
 
<span class="p_del">-	free_pages((unsigned long)sctp_assoc_hashtable,</span>
<span class="p_add">+	free_pages(sctp_assoc_hashtable,</span>
 		   get_order(sctp_assoc_hashsize *
 			     sizeof(struct sctp_hashbucket)));
 	kfree(sctp_ep_hashtable);
<span class="p_del">-	free_pages((unsigned long)sctp_port_hashtable,</span>
<span class="p_add">+	free_pages(sctp_port_hashtable,</span>
 		   get_order(sctp_port_hashsize *
 			     sizeof(struct sctp_bind_hashbucket)));
 
<span class="p_header">diff --git a/net/sctp/ssnmap.c b/net/sctp/ssnmap.c</span>
<span class="p_header">index b9c8521..97b1939 100644</span>
<span class="p_header">--- a/net/sctp/ssnmap.c</span>
<span class="p_header">+++ b/net/sctp/ssnmap.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> fail_map:</span>
 	if (size &lt;= KMALLOC_MAX_SIZE)
 		kfree(retval);
 	else
<span class="p_del">-		free_pages((unsigned long)retval, get_order(size));</span>
<span class="p_add">+		free_pages(retval, get_order(size));</span>
 fail:
 	return NULL;
 }
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> void sctp_ssnmap_free(struct sctp_ssnmap *map)</span>
 	if (size &lt;= KMALLOC_MAX_SIZE)
 		kfree(map);
 	else
<span class="p_del">-		free_pages((unsigned long)map, get_order(size));</span>
<span class="p_add">+		free_pages(map, get_order(size));</span>
 
 	SCTP_DBG_OBJCNT_DEC(ssnmap);
 }
<span class="p_header">diff --git a/net/xfrm/xfrm_hash.c b/net/xfrm/xfrm_hash.c</span>
<span class="p_header">index 1e98bc0..f19872e 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_hash.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_hash.c</span>
<span class="p_chunk">@@ -35,5 +35,5 @@</span> <span class="p_context"> void xfrm_hash_free(struct hlist_head *n, unsigned int sz)</span>
 	else if (hashdist)
 		vfree(n);
 	else
<span class="p_del">-		free_pages((unsigned long)n, get_order(sz));</span>
<span class="p_add">+		free_pages(n, get_order(sz));</span>
 }
<span class="p_header">diff --git a/security/integrity/ima/ima_crypto.c b/security/integrity/ima/ima_crypto.c</span>
<span class="p_header">index 6eb6293..96f416c 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_crypto.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_crypto.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static void ima_free_pages(void *ptr, size_t size)</span>
 {
 	if (!ptr)
 		return;
<span class="p_del">-	free_pages((unsigned long)ptr, get_order(size));</span>
<span class="p_add">+	free_pages(ptr, get_order(size));</span>
 }
 
 static struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)
<span class="p_header">diff --git a/sound/core/memalloc.c b/sound/core/memalloc.c</span>
<span class="p_header">index f05cb6a..43ac8b5 100644</span>
<span class="p_header">--- a/sound/core/memalloc.c</span>
<span class="p_header">+++ b/sound/core/memalloc.c</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> void snd_free_pages(void *ptr, size_t size)</span>
 	if (ptr == NULL)
 		return;
 	pg = get_order(size);
<span class="p_del">-	free_pages((unsigned long) ptr, pg);</span>
<span class="p_add">+	free_pages(ptr, pg);</span>
 }
 
 /*
<span class="p_header">diff --git a/sound/oss/dmabuf.c b/sound/oss/dmabuf.c</span>
<span class="p_header">index e3f2913..457755a 100644</span>
<span class="p_header">--- a/sound/oss/dmabuf.c</span>
<span class="p_header">+++ b/sound/oss/dmabuf.c</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> static void sound_free_dmap(struct dma_buffparms *dmap)</span>
 		ClearPageReserved(page);
 
 	dma_unmap_single(NULL, dmap-&gt;raw_buf_phys, dmap-&gt;buffsize, DMA_BIDIRECTIONAL);
<span class="p_del">-	free_pages((unsigned long) dmap-&gt;raw_buf, sz);</span>
<span class="p_add">+	free_pages(dmap-&gt;raw_buf, sz);</span>
 	dmap-&gt;raw_buf = NULL;
 }
 
<span class="p_header">diff --git a/sound/usb/usx2y/usb_stream.c b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">index bf618e1..c423951 100644</span>
<span class="p_header">--- a/sound/usb/usx2y/usb_stream.c</span>
<span class="p_header">+++ b/sound/usb/usx2y/usb_stream.c</span>
<span class="p_chunk">@@ -143,9 +143,9 @@</span> <span class="p_context"> void usb_stream_free(struct usb_stream_kernel *sk)</span>
 	if (!s)
 		return;
 
<span class="p_del">-	free_pages((unsigned long)sk-&gt;write_page, get_order(s-&gt;write_size));</span>
<span class="p_add">+	free_pages(sk-&gt;write_page, get_order(s-&gt;write_size));</span>
 	sk-&gt;write_page = NULL;
<span class="p_del">-	free_pages((unsigned long)s, get_order(s-&gt;read_size));</span>
<span class="p_add">+	free_pages(s, get_order(s-&gt;read_size));</span>
 	sk-&gt;s = NULL;
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



