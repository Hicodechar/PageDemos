
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[06/11] powerpc/kvm: Allow KVM_PPC_ALLOCATE_HTAB ioctl() to change HPT size - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [06/11] powerpc/kvm: Allow KVM_PPC_ALLOCATE_HTAB ioctl() to change HPT size</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=1741">David Gibson</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 15, 2016, 5:53 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161215055404.29351-7-david@gibson.dropbear.id.au&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9475555/mbox/"
   >mbox</a>
|
   <a href="/patch/9475555/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9475555/">/patch/9475555/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AB0EA60827 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 06:00:27 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9A567286C1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 06:00:27 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 8F3A6286B5; Thu, 15 Dec 2016 06:00:27 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU,
	RCVD_IN_DNSWL_HI autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2B0B1286AA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 15 Dec 2016 06:00:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934955AbcLOGAW (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 15 Dec 2016 01:00:22 -0500
Received: from ozlabs.org ([103.22.144.67]:35245 &quot;EHLO ozlabs.org&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1755250AbcLOF6x (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 15 Dec 2016 00:58:53 -0500
Received: by ozlabs.org (Postfix, from userid 1007)
	id 3tfN6Y3tS1z9t80; Thu, 15 Dec 2016 16:58:45 +1100 (AEDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple;
	d=gibson.dropbear.id.au; s=201602; t=1481781525;
	bh=k806FQfPARsmLIlHdYHMP8J/pztJvMloCnHEcmIPRck=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
	b=OYezXzEpjWux5Bw/PCQHV2/IcGrxhXdabELQ4mRt36jmxg/YvhPLdL3UTadqt91tz
	miVI4YK/Ep+B7q3C4N9RXGp5LElWO9Mzww4Tk7iNdslyBKg4sl+EUvO/y/xFJ7kXth
	BvPHw4hdOs3WWVVmnqEhGEsejMlxyabWw/NbN/lo=
From: David Gibson &lt;david@gibson.dropbear.id.au&gt;
To: paulus@samba.org
Cc: michael@ellerman.id.au, benh@kernel.crashing.org,
	sjitindarsingh@gmail.com, thuth@redhat.com, lvivier@redhat.com,
	linuxppc-dev@lists.ozlabs.org, linux-kernel@vger.kernel.org,
	kvm@vger.kernel.org, David Gibson &lt;david@gibson.dropbear.id.au&gt;
Subject: [PATCH 06/11] powerpc/kvm: Allow KVM_PPC_ALLOCATE_HTAB ioctl() to
	change HPT size
Date: Thu, 15 Dec 2016 16:53:59 +1100
Message-Id: &lt;20161215055404.29351-7-david@gibson.dropbear.id.au&gt;
X-Mailer: git-send-email 2.9.3
In-Reply-To: &lt;20161215055404.29351-1-david@gibson.dropbear.id.au&gt;
References: &lt;20161215055404.29351-1-david@gibson.dropbear.id.au&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1741">David Gibson</a> - Dec. 15, 2016, 5:53 a.m.</div>
<pre class="content">
The KVM_PPC_ALLOCATE_HTAB ioctl() is used to set the size of hashed page
table (HPT) that userspace expects a guest VM to have, and is also used to
clear that HPT when necessary (e.g. guest reboot).

At present, once the ioctl() is called for the first time, the HPT size can
never be changed thereafter - it will be cleared but always sized as from
the first call.

With upcoming HPT resize implementation, we&#39;re going to need to allow
userspace to resize the HPT at reset (to change it back to the default size
if the guest changed it).

So, we need to allow this ioctl() to change the HPT size.
<span class="signed-off-by">
Signed-off-by: David Gibson &lt;david@gibson.dropbear.id.au&gt;</span>
---
 arch/powerpc/include/asm/kvm_ppc.h  |  2 +-
 arch/powerpc/kvm/book3s_64_mmu_hv.c | 53 ++++++++++++++++++++-----------------
 arch/powerpc/kvm/book3s_hv.c        |  5 +---
 3 files changed, 30 insertions(+), 30 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129511">Thomas Huth</a> - Dec. 16, 2016, 12:44 p.m.</div>
<pre class="content">
On 15.12.2016 06:53, David Gibson wrote:
<span class="quote">&gt; The KVM_PPC_ALLOCATE_HTAB ioctl() is used to set the size of hashed page</span>
<span class="quote">&gt; table (HPT) that userspace expects a guest VM to have, and is also used to</span>
<span class="quote">&gt; clear that HPT when necessary (e.g. guest reboot).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; At present, once the ioctl() is called for the first time, the HPT size can</span>
<span class="quote">&gt; never be changed thereafter - it will be cleared but always sized as from</span>
<span class="quote">&gt; the first call.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; With upcoming HPT resize implementation, we&#39;re going to need to allow</span>
<span class="quote">&gt; userspace to resize the HPT at reset (to change it back to the default size</span>
<span class="quote">&gt; if the guest changed it).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So, we need to allow this ioctl() to change the HPT size.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: David Gibson &lt;david@gibson.dropbear.id.au&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/powerpc/include/asm/kvm_ppc.h  |  2 +-</span>
<span class="quote">&gt;  arch/powerpc/kvm/book3s_64_mmu_hv.c | 53 ++++++++++++++++++++-----------------</span>
<span class="quote">&gt;  arch/powerpc/kvm/book3s_hv.c        |  5 +---</span>
<span class="quote">&gt;  3 files changed, 30 insertions(+), 30 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="quote">&gt; index 41575b8..3b837bc 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="quote">&gt; +++ b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="quote">&gt; @@ -157,7 +157,7 @@ extern void kvmppc_map_magic(struct kvm_vcpu *vcpu);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  extern int kvmppc_allocate_hpt(struct kvm_hpt_info *info, u32 order);</span>
<span class="quote">&gt;  extern void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info);</span>
<span class="quote">&gt; -extern long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp);</span>
<span class="quote">&gt; +extern long kvmppc_alloc_reset_hpt(struct kvm *kvm, int order);</span>
<span class="quote">&gt;  extern void kvmppc_free_hpt(struct kvm_hpt_info *info);</span>
<span class="quote">&gt;  extern long kvmppc_prepare_vrma(struct kvm *kvm,</span>
<span class="quote">&gt;  				struct kvm_userspace_memory_region *mem);</span>
<span class="quote">&gt; diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; index 68bb228..8e5ac2f 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; @@ -104,10 +104,22 @@ void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info)</span>
<span class="quote">&gt;  		info-&gt;virt, (long)info-&gt;order, kvm-&gt;arch.lpid);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt; +void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	vfree(info-&gt;rev);</span>
<span class="quote">&gt; +	if (info-&gt;cma)</span>
<span class="quote">&gt; +		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="quote">&gt; +				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="quote">&gt; +	info-&gt;virt = 0;</span>
<span class="quote">&gt; +	info-&gt;order = 0;</span>
<span class="quote">&gt; +}</span>

Why do you need to move kvmppc_free_hpt() around? Seems like unecessary
code churn to me?
<span class="quote">
&gt; +long kvmppc_alloc_reset_hpt(struct kvm *kvm, int order)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	long err = -EBUSY;</span>
<span class="quote">&gt; -	long order;</span>
<span class="quote">&gt; +	struct kvm_hpt_info info;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	mutex_lock(&amp;kvm-&gt;lock);</span>
<span class="quote">&gt;  	if (kvm-&gt;arch.hpte_setup_done) {</span>
<span class="quote">&gt; @@ -119,8 +131,9 @@ long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt;  			goto out;</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; -	if (kvm-&gt;arch.hpt.virt) {</span>
<span class="quote">&gt; -		order = kvm-&gt;arch.hpt.order;</span>
<span class="quote">&gt; +	if (kvm-&gt;arch.hpt.order == order) {</span>
<span class="quote">&gt; +		/* We already have a suitable HPT */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  		/* Set the entire HPT to 0, i.e. invalid HPTEs */</span>
<span class="quote">&gt;  		memset((void *)kvm-&gt;arch.hpt.virt, 0, 1ul &lt;&lt; order);</span>
<span class="quote">&gt;  		/*</span>
<span class="quote">&gt; @@ -129,33 +142,23 @@ long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt;  		kvmppc_rmap_reset(kvm);</span>
<span class="quote">&gt;  		/* Ensure that each vcpu will flush its TLB on next entry. */</span>
<span class="quote">&gt;  		cpumask_setall(&amp;kvm-&gt;arch.need_tlb_flush);</span>
<span class="quote">&gt; -		*htab_orderp = order;</span>
<span class="quote">&gt;  		err = 0;</span>
<span class="quote">&gt; -	} else {</span>
<span class="quote">&gt; -		struct kvm_hpt_info info;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		err = kvmppc_allocate_hpt(&amp;info, *htab_orderp);</span>
<span class="quote">&gt; -		if (err &lt; 0)</span>
<span class="quote">&gt; -			goto out;</span>
<span class="quote">&gt; -		kvmppc_set_hpt(kvm, &amp;info);</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; - out:</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (kvm-&gt;arch.hpt.virt)</span>
<span class="quote">&gt; +		kvmppc_free_hpt(&amp;kvm-&gt;arch.hpt);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	err = kvmppc_allocate_hpt(&amp;info, order);</span>
<span class="quote">&gt; +	if (err &lt; 0)</span>
<span class="quote">&gt; +		goto out;</span>
<span class="quote">&gt; +	kvmppc_set_hpt(kvm, &amp;info);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +out:</span>
<span class="quote">&gt;  	mutex_unlock(&amp;kvm-&gt;lock);</span>
<span class="quote">&gt;  	return err;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	vfree(info-&gt;rev);</span>
<span class="quote">&gt; -	if (info-&gt;cma)</span>
<span class="quote">&gt; -		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="quote">&gt; -				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="quote">&gt; -	else</span>
<span class="quote">&gt; -		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="quote">&gt; -	info-&gt;virt = 0;</span>
<span class="quote">&gt; -	info-&gt;order = 0;</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  /* Bits in first HPTE dword for pagesize 4k, 64k or 16M */</span>
<span class="quote">&gt;  static inline unsigned long hpte0_pgsize_encoding(unsigned long pgsize)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; index 71c5adb..957e473 100644</span>
<span class="quote">&gt; --- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; +++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; @@ -3600,12 +3600,9 @@ static long kvm_arch_vm_ioctl_hv(struct file *filp,</span>
<span class="quote">&gt;  		r = -EFAULT;</span>
<span class="quote">&gt;  		if (get_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt;  			break;</span>
<span class="quote">&gt; -		r = kvmppc_alloc_reset_hpt(kvm, &amp;htab_order);</span>
<span class="quote">&gt; +		r = kvmppc_alloc_reset_hpt(kvm, htab_order);</span>
<span class="quote">&gt;  		if (r)</span>
<span class="quote">&gt;  			break;</span>
<span class="quote">&gt; -		r = -EFAULT;</span>
<span class="quote">&gt; -		if (put_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt; -			break;</span>

Now that htab_order is not changed anymore by the kernel, I&#39;m pretty
sure you need some checks on the value here before calling
kvmppc_alloc_reset_hpt(), e.g. return an error code if htab_order &lt;
PPC_MIN_HPT_ORDER.

And, I&#39;m not sure if I got that right, but in former times, the
htab_order from the userspace application was just a suggestion, and now
it&#39;s mandatory, right? So if an old userspace used a very high value
here (or even something smaller than PPC_MIN_HPT_ORDER like 0), the
kernel fixed this up and the userspace could run happily with the fixed
value afterwards. But since this value from userspace if mandatory now,
such an userspace application is broken now. So maybe it&#39;s better to
introduce a new ioctl for this new behavior instead, to avoid breaking
old userspace applications?

Anyway, you should also update Documentation/virtual/kvm/api.txt to
reflect the new behavior.
<span class="quote">
&gt;  		r = 0;</span>
<span class="quote">&gt;  		break;</span>
<span class="quote">&gt;  	}</span>

 Thomas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1741">David Gibson</a> - Dec. 19, 2016, 12:48 a.m.</div>
<pre class="content">
On Fri, Dec 16, 2016 at 01:44:57PM +0100, Thomas Huth wrote:
<span class="quote">&gt; On 15.12.2016 06:53, David Gibson wrote:</span>
<span class="quote">&gt; &gt; The KVM_PPC_ALLOCATE_HTAB ioctl() is used to set the size of hashed page</span>
<span class="quote">&gt; &gt; table (HPT) that userspace expects a guest VM to have, and is also used to</span>
<span class="quote">&gt; &gt; clear that HPT when necessary (e.g. guest reboot).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; At present, once the ioctl() is called for the first time, the HPT size can</span>
<span class="quote">&gt; &gt; never be changed thereafter - it will be cleared but always sized as from</span>
<span class="quote">&gt; &gt; the first call.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; With upcoming HPT resize implementation, we&#39;re going to need to allow</span>
<span class="quote">&gt; &gt; userspace to resize the HPT at reset (to change it back to the default size</span>
<span class="quote">&gt; &gt; if the guest changed it).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So, we need to allow this ioctl() to change the HPT size.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: David Gibson &lt;david@gibson.dropbear.id.au&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  arch/powerpc/include/asm/kvm_ppc.h  |  2 +-</span>
<span class="quote">&gt; &gt;  arch/powerpc/kvm/book3s_64_mmu_hv.c | 53 ++++++++++++++++++++-----------------</span>
<span class="quote">&gt; &gt;  arch/powerpc/kvm/book3s_hv.c        |  5 +---</span>
<span class="quote">&gt; &gt;  3 files changed, 30 insertions(+), 30 deletions(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="quote">&gt; &gt; index 41575b8..3b837bc 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="quote">&gt; &gt; @@ -157,7 +157,7 @@ extern void kvmppc_map_magic(struct kvm_vcpu *vcpu);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  extern int kvmppc_allocate_hpt(struct kvm_hpt_info *info, u32 order);</span>
<span class="quote">&gt; &gt;  extern void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info);</span>
<span class="quote">&gt; &gt; -extern long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp);</span>
<span class="quote">&gt; &gt; +extern long kvmppc_alloc_reset_hpt(struct kvm *kvm, int order);</span>
<span class="quote">&gt; &gt;  extern void kvmppc_free_hpt(struct kvm_hpt_info *info);</span>
<span class="quote">&gt; &gt;  extern long kvmppc_prepare_vrma(struct kvm *kvm,</span>
<span class="quote">&gt; &gt;  				struct kvm_userspace_memory_region *mem);</span>
<span class="quote">&gt; &gt; diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; &gt; index 68bb228..8e5ac2f 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; &gt; @@ -104,10 +104,22 @@ void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info)</span>
<span class="quote">&gt; &gt;  		info-&gt;virt, (long)info-&gt;order, kvm-&gt;arch.lpid);</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt; &gt; +void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	vfree(info-&gt;rev);</span>
<span class="quote">&gt; &gt; +	if (info-&gt;cma)</span>
<span class="quote">&gt; &gt; +		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="quote">&gt; &gt; +				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="quote">&gt; &gt; +	else</span>
<span class="quote">&gt; &gt; +		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="quote">&gt; &gt; +	info-&gt;virt = 0;</span>
<span class="quote">&gt; &gt; +	info-&gt;order = 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why do you need to move kvmppc_free_hpt() around? Seems like unecessary</span>
<span class="quote">&gt; code churn to me?</span>

Previously, kvmppc_free_hpt() wasn&#39;t needed in
kvmppc_alloc_reset_hpt(), now it is.  So we need to move it above that
function.  I could move it in the previous patch, but that would
obscure what the actual changes are to it, so it seemed better to do
it here.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +long kvmppc_alloc_reset_hpt(struct kvm *kvm, int order)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	long err = -EBUSY;</span>
<span class="quote">&gt; &gt; -	long order;</span>
<span class="quote">&gt; &gt; +	struct kvm_hpt_info info;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	mutex_lock(&amp;kvm-&gt;lock);</span>
<span class="quote">&gt; &gt;  	if (kvm-&gt;arch.hpte_setup_done) {</span>
<span class="quote">&gt; &gt; @@ -119,8 +131,9 @@ long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt; &gt;  			goto out;</span>
<span class="quote">&gt; &gt;  		}</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt; -	if (kvm-&gt;arch.hpt.virt) {</span>
<span class="quote">&gt; &gt; -		order = kvm-&gt;arch.hpt.order;</span>
<span class="quote">&gt; &gt; +	if (kvm-&gt;arch.hpt.order == order) {</span>
<span class="quote">&gt; &gt; +		/* We already have a suitable HPT */</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  		/* Set the entire HPT to 0, i.e. invalid HPTEs */</span>
<span class="quote">&gt; &gt;  		memset((void *)kvm-&gt;arch.hpt.virt, 0, 1ul &lt;&lt; order);</span>
<span class="quote">&gt; &gt;  		/*</span>
<span class="quote">&gt; &gt; @@ -129,33 +142,23 @@ long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt; &gt;  		kvmppc_rmap_reset(kvm);</span>
<span class="quote">&gt; &gt;  		/* Ensure that each vcpu will flush its TLB on next entry. */</span>
<span class="quote">&gt; &gt;  		cpumask_setall(&amp;kvm-&gt;arch.need_tlb_flush);</span>
<span class="quote">&gt; &gt; -		*htab_orderp = order;</span>
<span class="quote">&gt; &gt;  		err = 0;</span>
<span class="quote">&gt; &gt; -	} else {</span>
<span class="quote">&gt; &gt; -		struct kvm_hpt_info info;</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt; -		err = kvmppc_allocate_hpt(&amp;info, *htab_orderp);</span>
<span class="quote">&gt; &gt; -		if (err &lt; 0)</span>
<span class="quote">&gt; &gt; -			goto out;</span>
<span class="quote">&gt; &gt; -		kvmppc_set_hpt(kvm, &amp;info);</span>
<span class="quote">&gt; &gt; +		goto out;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt; - out:</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	if (kvm-&gt;arch.hpt.virt)</span>
<span class="quote">&gt; &gt; +		kvmppc_free_hpt(&amp;kvm-&gt;arch.hpt);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	err = kvmppc_allocate_hpt(&amp;info, order);</span>
<span class="quote">&gt; &gt; +	if (err &lt; 0)</span>
<span class="quote">&gt; &gt; +		goto out;</span>
<span class="quote">&gt; &gt; +	kvmppc_set_hpt(kvm, &amp;info);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +out:</span>
<span class="quote">&gt; &gt;  	mutex_unlock(&amp;kvm-&gt;lock);</span>
<span class="quote">&gt; &gt;  	return err;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="quote">&gt; &gt; -{</span>
<span class="quote">&gt; &gt; -	vfree(info-&gt;rev);</span>
<span class="quote">&gt; &gt; -	if (info-&gt;cma)</span>
<span class="quote">&gt; &gt; -		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="quote">&gt; &gt; -				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="quote">&gt; &gt; -	else</span>
<span class="quote">&gt; &gt; -		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="quote">&gt; &gt; -	info-&gt;virt = 0;</span>
<span class="quote">&gt; &gt; -	info-&gt;order = 0;</span>
<span class="quote">&gt; &gt; -}</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt;  /* Bits in first HPTE dword for pagesize 4k, 64k or 16M */</span>
<span class="quote">&gt; &gt;  static inline unsigned long hpte0_pgsize_encoding(unsigned long pgsize)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; &gt; index 71c5adb..957e473 100644</span>
<span class="quote">&gt; &gt; --- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; &gt; +++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; &gt; @@ -3600,12 +3600,9 @@ static long kvm_arch_vm_ioctl_hv(struct file *filp,</span>
<span class="quote">&gt; &gt;  		r = -EFAULT;</span>
<span class="quote">&gt; &gt;  		if (get_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt; &gt;  			break;</span>
<span class="quote">&gt; &gt; -		r = kvmppc_alloc_reset_hpt(kvm, &amp;htab_order);</span>
<span class="quote">&gt; &gt; +		r = kvmppc_alloc_reset_hpt(kvm, htab_order);</span>
<span class="quote">&gt; &gt;  		if (r)</span>
<span class="quote">&gt; &gt;  			break;</span>
<span class="quote">&gt; &gt; -		r = -EFAULT;</span>
<span class="quote">&gt; &gt; -		if (put_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt; &gt; -			break;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Now that htab_order is not changed anymore by the kernel, I&#39;m pretty</span>
<span class="quote">&gt; sure you need some checks on the value here before calling</span>
<span class="quote">&gt; kvmppc_alloc_reset_hpt(), e.g. return an error code if htab_order &lt;</span>
<span class="quote">&gt; PPC_MIN_HPT_ORDER.</span>

Right.  I&#39;ve done that by putting the checks into
kvmppc_allocate_hpt() in the earlier patch.
<span class="quote">
&gt; And, I&#39;m not sure if I got that right, but in former times, the</span>
<span class="quote">&gt; htab_order from the userspace application was just a suggestion, and now</span>
<span class="quote">&gt; it&#39;s mandatory, right? So if an old userspace used a very high value</span>
<span class="quote">&gt; here (or even something smaller than PPC_MIN_HPT_ORDER like 0), the</span>
<span class="quote">&gt; kernel fixed this up and the userspace could run happily with the fixed</span>
<span class="quote">&gt; value afterwards. But since this value from userspace if mandatory now,</span>
<span class="quote">&gt; such an userspace application is broken now. So maybe it&#39;s better to</span>
<span class="quote">&gt; introduce a new ioctl for this new behavior instead, to avoid breaking</span>
<span class="quote">&gt; old userspace applications?</span>

A long time ago it was just a hint.  However, that behaviour was
already changed in 572abd5 &quot;KVM: PPC: Book3S HV: Don&#39;t fall back to
smaller HPT size in allocation ioctl&quot;.  This is important: without
that we could get a different HPT size on the two ends of a migration,
which broke things nastily.
<span class="quote">
&gt; Anyway, you should also update Documentation/virtual/kvm/api.txt to</span>
<span class="quote">&gt; reflect the new behavior.</span>

Good point.  Done.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;  		r = 0;</span>
<span class="quote">&gt; &gt;  		break;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  Thomas</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=129511">Thomas Huth</a> - Dec. 19, 2016, 7:49 a.m.</div>
<pre class="content">
On 19.12.2016 01:48, David Gibson wrote:
<span class="quote">&gt; On Fri, Dec 16, 2016 at 01:44:57PM +0100, Thomas Huth wrote:</span>
<span class="quote">&gt;&gt; On 15.12.2016 06:53, David Gibson wrote:</span>
<span class="quote">&gt;&gt;&gt; The KVM_PPC_ALLOCATE_HTAB ioctl() is used to set the size of hashed page</span>
<span class="quote">&gt;&gt;&gt; table (HPT) that userspace expects a guest VM to have, and is also used to</span>
<span class="quote">&gt;&gt;&gt; clear that HPT when necessary (e.g. guest reboot).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; At present, once the ioctl() is called for the first time, the HPT size can</span>
<span class="quote">&gt;&gt;&gt; never be changed thereafter - it will be cleared but always sized as from</span>
<span class="quote">&gt;&gt;&gt; the first call.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; With upcoming HPT resize implementation, we&#39;re going to need to allow</span>
<span class="quote">&gt;&gt;&gt; userspace to resize the HPT at reset (to change it back to the default size</span>
<span class="quote">&gt;&gt;&gt; if the guest changed it).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; So, we need to allow this ioctl() to change the HPT size.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: David Gibson &lt;david@gibson.dropbear.id.au&gt;</span>
<span class="quote">&gt;&gt;&gt; ---</span>
[...]
<span class="quote">&gt;&gt;&gt; diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt;&gt;&gt; index 68bb228..8e5ac2f 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt;&gt;&gt; @@ -104,10 +104,22 @@ void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info)</span>
<span class="quote">&gt;&gt;&gt;  		info-&gt;virt, (long)info-&gt;order, kvm-&gt;arch.lpid);</span>
<span class="quote">&gt;&gt;&gt;  }</span>
<span class="quote">&gt;&gt;&gt;  </span>
<span class="quote">&gt;&gt;&gt; -long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt;&gt;&gt; +void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +	vfree(info-&gt;rev);</span>
<span class="quote">&gt;&gt;&gt; +	if (info-&gt;cma)</span>
<span class="quote">&gt;&gt;&gt; +		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="quote">&gt;&gt;&gt; +				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="quote">&gt;&gt;&gt; +	else</span>
<span class="quote">&gt;&gt;&gt; +		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="quote">&gt;&gt;&gt; +	info-&gt;virt = 0;</span>
<span class="quote">&gt;&gt;&gt; +	info-&gt;order = 0;</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Why do you need to move kvmppc_free_hpt() around? Seems like unecessary</span>
<span class="quote">&gt;&gt; code churn to me?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Previously, kvmppc_free_hpt() wasn&#39;t needed in</span>
<span class="quote">&gt; kvmppc_alloc_reset_hpt(), now it is.  So we need to move it above that</span>
<span class="quote">&gt; function.  I could move it in the previous patch, but that would</span>
<span class="quote">&gt; obscure what the actual changes are to it, so it seemed better to do</span>
<span class="quote">&gt; it here.</span>

kvmppc_free_hpt() is not a static function, there is a prototype in a
header for this somewhere, so as far as I can see, it should also work
without moving this function?

[...]
<span class="quote">&gt;&gt;&gt; diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt;&gt;&gt; index 71c5adb..957e473 100644</span>
<span class="quote">&gt;&gt;&gt; --- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt;&gt;&gt; +++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt;&gt;&gt; @@ -3600,12 +3600,9 @@ static long kvm_arch_vm_ioctl_hv(struct file *filp,</span>
<span class="quote">&gt;&gt;&gt;  		r = -EFAULT;</span>
<span class="quote">&gt;&gt;&gt;  		if (get_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt;&gt;&gt;  			break;</span>
<span class="quote">&gt;&gt;&gt; -		r = kvmppc_alloc_reset_hpt(kvm, &amp;htab_order);</span>
<span class="quote">&gt;&gt;&gt; +		r = kvmppc_alloc_reset_hpt(kvm, htab_order);</span>
<span class="quote">&gt;&gt;&gt;  		if (r)</span>
<span class="quote">&gt;&gt;&gt;  			break;</span>
<span class="quote">&gt;&gt;&gt; -		r = -EFAULT;</span>
<span class="quote">&gt;&gt;&gt; -		if (put_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt;&gt;&gt; -			break;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Now that htab_order is not changed anymore by the kernel, I&#39;m pretty</span>
<span class="quote">&gt;&gt; sure you need some checks on the value here before calling</span>
<span class="quote">&gt;&gt; kvmppc_alloc_reset_hpt(), e.g. return an error code if htab_order &lt;</span>
<span class="quote">&gt;&gt; PPC_MIN_HPT_ORDER.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Right.  I&#39;ve done that by putting the checks into</span>
<span class="quote">&gt; kvmppc_allocate_hpt() in the earlier patch.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; And, I&#39;m not sure if I got that right, but in former times, the</span>
<span class="quote">&gt;&gt; htab_order from the userspace application was just a suggestion, and now</span>
<span class="quote">&gt;&gt; it&#39;s mandatory, right? So if an old userspace used a very high value</span>
<span class="quote">&gt;&gt; here (or even something smaller than PPC_MIN_HPT_ORDER like 0), the</span>
<span class="quote">&gt;&gt; kernel fixed this up and the userspace could run happily with the fixed</span>
<span class="quote">&gt;&gt; value afterwards. But since this value from userspace if mandatory now,</span>
<span class="quote">&gt;&gt; such an userspace application is broken now. So maybe it&#39;s better to</span>
<span class="quote">&gt;&gt; introduce a new ioctl for this new behavior instead, to avoid breaking</span>
<span class="quote">&gt;&gt; old userspace applications?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A long time ago it was just a hint.  However, that behaviour was</span>
<span class="quote">&gt; already changed in 572abd5 &quot;KVM: PPC: Book3S HV: Don&#39;t fall back to</span>
<span class="quote">&gt; smaller HPT size in allocation ioctl&quot;.  This is important: without</span>
<span class="quote">&gt; that we could get a different HPT size on the two ends of a migration,</span>
<span class="quote">&gt; which broke things nastily.</span>

OK, makes sense, especially if the userspace provided an order. But if I
get that patch right, it was still possible to call with order == 0 to
get the automatic sizing? Do we need to preserve that behavior for some
very old userspace applications?

 Thomas
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1741">David Gibson</a> - Dec. 19, 2016, 11:16 p.m.</div>
<pre class="content">
On Mon, Dec 19, 2016 at 08:49:24AM +0100, Thomas Huth wrote:
<span class="quote">&gt; On 19.12.2016 01:48, David Gibson wrote:</span>
<span class="quote">&gt; &gt; On Fri, Dec 16, 2016 at 01:44:57PM +0100, Thomas Huth wrote:</span>
<span class="quote">&gt; &gt;&gt; On 15.12.2016 06:53, David Gibson wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; The KVM_PPC_ALLOCATE_HTAB ioctl() is used to set the size of hashed page</span>
<span class="quote">&gt; &gt;&gt;&gt; table (HPT) that userspace expects a guest VM to have, and is also used to</span>
<span class="quote">&gt; &gt;&gt;&gt; clear that HPT when necessary (e.g. guest reboot).</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; At present, once the ioctl() is called for the first time, the HPT size can</span>
<span class="quote">&gt; &gt;&gt;&gt; never be changed thereafter - it will be cleared but always sized as from</span>
<span class="quote">&gt; &gt;&gt;&gt; the first call.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; With upcoming HPT resize implementation, we&#39;re going to need to allow</span>
<span class="quote">&gt; &gt;&gt;&gt; userspace to resize the HPT at reset (to change it back to the default size</span>
<span class="quote">&gt; &gt;&gt;&gt; if the guest changed it).</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; So, we need to allow this ioctl() to change the HPT size.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Signed-off-by: David Gibson &lt;david@gibson.dropbear.id.au&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; ---</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt; diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; &gt;&gt;&gt; index 68bb228..8e5ac2f 100644</span>
<span class="quote">&gt; &gt;&gt;&gt; --- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; &gt;&gt;&gt; +++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="quote">&gt; &gt;&gt;&gt; @@ -104,10 +104,22 @@ void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info)</span>
<span class="quote">&gt; &gt;&gt;&gt;  		info-&gt;virt, (long)info-&gt;order, kvm-&gt;arch.lpid);</span>
<span class="quote">&gt; &gt;&gt;&gt;  }</span>
<span class="quote">&gt; &gt;&gt;&gt;  </span>
<span class="quote">&gt; &gt;&gt;&gt; -long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="quote">&gt; &gt;&gt;&gt; +void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +	vfree(info-&gt;rev);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	if (info-&gt;cma)</span>
<span class="quote">&gt; &gt;&gt;&gt; +		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="quote">&gt; &gt;&gt;&gt; +				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="quote">&gt; &gt;&gt;&gt; +	else</span>
<span class="quote">&gt; &gt;&gt;&gt; +		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="quote">&gt; &gt;&gt;&gt; +	info-&gt;virt = 0;</span>
<span class="quote">&gt; &gt;&gt;&gt; +	info-&gt;order = 0;</span>
<span class="quote">&gt; &gt;&gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Why do you need to move kvmppc_free_hpt() around? Seems like unecessary</span>
<span class="quote">&gt; &gt;&gt; code churn to me?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Previously, kvmppc_free_hpt() wasn&#39;t needed in</span>
<span class="quote">&gt; &gt; kvmppc_alloc_reset_hpt(), now it is.  So we need to move it above that</span>
<span class="quote">&gt; &gt; function.  I could move it in the previous patch, but that would</span>
<span class="quote">&gt; &gt; obscure what the actual changes are to it, so it seemed better to do</span>
<span class="quote">&gt; &gt; it here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; kvmppc_free_hpt() is not a static function, there is a prototype in a</span>
<span class="quote">&gt; header for this somewhere, so as far as I can see, it should also work</span>
<span class="quote">&gt; without moving this function?</span>

Oh yeah.. how did I miss that..
<span class="quote">
&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt; diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; &gt;&gt;&gt; index 71c5adb..957e473 100644</span>
<span class="quote">&gt; &gt;&gt;&gt; --- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; &gt;&gt;&gt; +++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="quote">&gt; &gt;&gt;&gt; @@ -3600,12 +3600,9 @@ static long kvm_arch_vm_ioctl_hv(struct file *filp,</span>
<span class="quote">&gt; &gt;&gt;&gt;  		r = -EFAULT;</span>
<span class="quote">&gt; &gt;&gt;&gt;  		if (get_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt; &gt;&gt;&gt;  			break;</span>
<span class="quote">&gt; &gt;&gt;&gt; -		r = kvmppc_alloc_reset_hpt(kvm, &amp;htab_order);</span>
<span class="quote">&gt; &gt;&gt;&gt; +		r = kvmppc_alloc_reset_hpt(kvm, htab_order);</span>
<span class="quote">&gt; &gt;&gt;&gt;  		if (r)</span>
<span class="quote">&gt; &gt;&gt;&gt;  			break;</span>
<span class="quote">&gt; &gt;&gt;&gt; -		r = -EFAULT;</span>
<span class="quote">&gt; &gt;&gt;&gt; -		if (put_user(htab_order, (u32 __user *)argp))</span>
<span class="quote">&gt; &gt;&gt;&gt; -			break;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Now that htab_order is not changed anymore by the kernel, I&#39;m pretty</span>
<span class="quote">&gt; &gt;&gt; sure you need some checks on the value here before calling</span>
<span class="quote">&gt; &gt;&gt; kvmppc_alloc_reset_hpt(), e.g. return an error code if htab_order &lt;</span>
<span class="quote">&gt; &gt;&gt; PPC_MIN_HPT_ORDER.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Right.  I&#39;ve done that by putting the checks into</span>
<span class="quote">&gt; &gt; kvmppc_allocate_hpt() in the earlier patch.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;&gt; And, I&#39;m not sure if I got that right, but in former times, the</span>
<span class="quote">&gt; &gt;&gt; htab_order from the userspace application was just a suggestion, and now</span>
<span class="quote">&gt; &gt;&gt; it&#39;s mandatory, right? So if an old userspace used a very high value</span>
<span class="quote">&gt; &gt;&gt; here (or even something smaller than PPC_MIN_HPT_ORDER like 0), the</span>
<span class="quote">&gt; &gt;&gt; kernel fixed this up and the userspace could run happily with the fixed</span>
<span class="quote">&gt; &gt;&gt; value afterwards. But since this value from userspace if mandatory now,</span>
<span class="quote">&gt; &gt;&gt; such an userspace application is broken now. So maybe it&#39;s better to</span>
<span class="quote">&gt; &gt;&gt; introduce a new ioctl for this new behavior instead, to avoid breaking</span>
<span class="quote">&gt; &gt;&gt; old userspace applications?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; A long time ago it was just a hint.  However, that behaviour was</span>
<span class="quote">&gt; &gt; already changed in 572abd5 &quot;KVM: PPC: Book3S HV: Don&#39;t fall back to</span>
<span class="quote">&gt; &gt; smaller HPT size in allocation ioctl&quot;.  This is important: without</span>
<span class="quote">&gt; &gt; that we could get a different HPT size on the two ends of a migration,</span>
<span class="quote">&gt; &gt; which broke things nastily.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; OK, makes sense, especially if the userspace provided an order. But if I</span>
<span class="quote">&gt; get that patch right, it was still possible to call with order == 0 to</span>
<span class="quote">&gt; get the automatic sizing?</span>

No, I don&#39;t think so.  It was possible to pass a NULL htab_orderp to
the allocation functions to get autosizing, but that would only
actually happen when called from kvm run because the explicit
allocation ioctl() hadn&#39;t been called yet.
<span class="quote">
&gt; Do we need to preserve that behavior for some</span>
<span class="quote">&gt; very old userspace applications?</span>

No; as long as userspace has used this ioctl() at all, it has always
passed an explicit size, never attempted to use autosizing.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/powerpc/include/asm/kvm_ppc.h b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="p_header">index 41575b8..3b837bc 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/kvm_ppc.h</span>
<span class="p_chunk">@@ -157,7 +157,7 @@</span> <span class="p_context"> extern void kvmppc_map_magic(struct kvm_vcpu *vcpu);</span>
 
 extern int kvmppc_allocate_hpt(struct kvm_hpt_info *info, u32 order);
 extern void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info);
<span class="p_del">-extern long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp);</span>
<span class="p_add">+extern long kvmppc_alloc_reset_hpt(struct kvm *kvm, int order);</span>
 extern void kvmppc_free_hpt(struct kvm_hpt_info *info);
 extern long kvmppc_prepare_vrma(struct kvm *kvm,
 				struct kvm_userspace_memory_region *mem);
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">index 68bb228..8e5ac2f 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_chunk">@@ -104,10 +104,22 @@</span> <span class="p_context"> void kvmppc_set_hpt(struct kvm *kvm, struct kvm_hpt_info *info)</span>
 		info-&gt;virt, (long)info-&gt;order, kvm-&gt;arch.lpid);
 }
 
<span class="p_del">-long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
<span class="p_add">+void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vfree(info-&gt;rev);</span>
<span class="p_add">+	if (info-&gt;cma)</span>
<span class="p_add">+		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="p_add">+				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="p_add">+	info-&gt;virt = 0;</span>
<span class="p_add">+	info-&gt;order = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long kvmppc_alloc_reset_hpt(struct kvm *kvm, int order)</span>
 {
 	long err = -EBUSY;
<span class="p_del">-	long order;</span>
<span class="p_add">+	struct kvm_hpt_info info;</span>
 
 	mutex_lock(&amp;kvm-&gt;lock);
 	if (kvm-&gt;arch.hpte_setup_done) {
<span class="p_chunk">@@ -119,8 +131,9 @@</span> <span class="p_context"> long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
 			goto out;
 		}
 	}
<span class="p_del">-	if (kvm-&gt;arch.hpt.virt) {</span>
<span class="p_del">-		order = kvm-&gt;arch.hpt.order;</span>
<span class="p_add">+	if (kvm-&gt;arch.hpt.order == order) {</span>
<span class="p_add">+		/* We already have a suitable HPT */</span>
<span class="p_add">+</span>
 		/* Set the entire HPT to 0, i.e. invalid HPTEs */
 		memset((void *)kvm-&gt;arch.hpt.virt, 0, 1ul &lt;&lt; order);
 		/*
<span class="p_chunk">@@ -129,33 +142,23 @@</span> <span class="p_context"> long kvmppc_alloc_reset_hpt(struct kvm *kvm, u32 *htab_orderp)</span>
 		kvmppc_rmap_reset(kvm);
 		/* Ensure that each vcpu will flush its TLB on next entry. */
 		cpumask_setall(&amp;kvm-&gt;arch.need_tlb_flush);
<span class="p_del">-		*htab_orderp = order;</span>
 		err = 0;
<span class="p_del">-	} else {</span>
<span class="p_del">-		struct kvm_hpt_info info;</span>
<span class="p_del">-</span>
<span class="p_del">-		err = kvmppc_allocate_hpt(&amp;info, *htab_orderp);</span>
<span class="p_del">-		if (err &lt; 0)</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		kvmppc_set_hpt(kvm, &amp;info);</span>
<span class="p_add">+		goto out;</span>
 	}
<span class="p_del">- out:</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kvm-&gt;arch.hpt.virt)</span>
<span class="p_add">+		kvmppc_free_hpt(&amp;kvm-&gt;arch.hpt);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = kvmppc_allocate_hpt(&amp;info, order);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	kvmppc_set_hpt(kvm, &amp;info);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;kvm-&gt;lock);
 	return err;
 }
 
<span class="p_del">-void kvmppc_free_hpt(struct kvm_hpt_info *info)</span>
<span class="p_del">-{</span>
<span class="p_del">-	vfree(info-&gt;rev);</span>
<span class="p_del">-	if (info-&gt;cma)</span>
<span class="p_del">-		kvm_free_hpt_cma(virt_to_page(info-&gt;virt),</span>
<span class="p_del">-				 1 &lt;&lt; (info-&gt;order - PAGE_SHIFT));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		free_pages(info-&gt;virt, info-&gt;order - PAGE_SHIFT);</span>
<span class="p_del">-	info-&gt;virt = 0;</span>
<span class="p_del">-	info-&gt;order = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Bits in first HPTE dword for pagesize 4k, 64k or 16M */
 static inline unsigned long hpte0_pgsize_encoding(unsigned long pgsize)
 {
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 71c5adb..957e473 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -3600,12 +3600,9 @@</span> <span class="p_context"> static long kvm_arch_vm_ioctl_hv(struct file *filp,</span>
 		r = -EFAULT;
 		if (get_user(htab_order, (u32 __user *)argp))
 			break;
<span class="p_del">-		r = kvmppc_alloc_reset_hpt(kvm, &amp;htab_order);</span>
<span class="p_add">+		r = kvmppc_alloc_reset_hpt(kvm, htab_order);</span>
 		if (r)
 			break;
<span class="p_del">-		r = -EFAULT;</span>
<span class="p_del">-		if (put_user(htab_order, (u32 __user *)argp))</span>
<span class="p_del">-			break;</span>
 		r = 0;
 		break;
 	}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



