
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.2.69 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.2.69</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 10, 2015, 1:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1431263220.2233.21.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6371671/mbox/"
   >mbox</a>
|
   <a href="/patch/6371671/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6371671/">/patch/6371671/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 6C1329F399
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 May 2015 13:08:31 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id CA2152039D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 May 2015 13:08:18 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 4D489203A9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 10 May 2015 13:07:54 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751489AbbEJNHj (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 10 May 2015 09:07:39 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:46858 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751171AbbEJNHV (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 10 May 2015 09:07:21 -0400
Received: from deadeye.wl.decadent.org.uk ([192.168.4.249] helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_128_GCM_SHA256:128) (Exim 4.84)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1YrQwp-0003CH-5m; Sun, 10 May 2015 14:07:11 +0100
Received: from ben by deadeye with local (Exim 4.85)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1YrQwj-0004KB-S4; Sun, 10 May 2015 14:07:05 +0100
Message-ID: &lt;1431263220.2233.21.camel@decadent.org.uk&gt;
Subject: Linux 3.2.69
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Date: Sun, 10 May 2015 14:07:00 +0100
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-zAp7GAJYoqgfYfQ4zZ2K&quot;
X-Mailer: Evolution 3.12.9-1+b1 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 192.168.4.249
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD, T_TVD_MIME_EPI,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - May 10, 2015, 1:07 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.2.69 kernel.

All users of the 3.2 kernel series should upgrade.

The updated 3.2.y git tree can be found at:
        git://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.2.y
and can be browsed at the normal kernel.org git web browser:
        http://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.2.68 is attached to this message.

Ben.

------------

 Documentation/usb/usb-serial.txt                   |   2 +-
 Makefile                                           |   2 +-
 arch/arm/mach-pxa/corgi.c                          |   3 +
 arch/arm/mach-pxa/hx4700.c                         |   2 +
 arch/arm/mach-pxa/poodle.c                         |   2 +
 arch/arm/mach-pxa/spitz.c                          |   2 +
 arch/arm/mach-sa1100/pm.c                          |   1 +
 arch/powerpc/sysdev/axonram.c                      |   2 +-
 arch/s390/kvm/intercept.c                          |   2 -
 arch/s390/kvm/kvm-s390.c                           |   2 +-
 arch/x86/crypto/aesni-intel_glue.c                 |   4 +-
 arch/x86/kernel/entry_64.S                         |  13 +-
 arch/x86/kernel/reboot.c                           |  58 +++++--
 arch/x86/kernel/traps.c                            |   2 +-
 arch/x86/kvm/emulate.c                             |   3 +-
 arch/x86/mm/mmap.c                                 |   6 +-
 arch/x86/vdso/vdso32/sigreturn.S                   |   1 +
 drivers/acpi/video.c                               |  11 ++
 drivers/block/nbd.c                                |   8 +-
 drivers/bluetooth/ath3k.c                          |   2 +
 drivers/bluetooth/btusb.c                          |   1 +
 drivers/char/tpm/tpm.c                             |   2 +-
 drivers/char/virtio_console.c                      |  16 ++
 drivers/cpufreq/speedstep-lib.c                    |   3 +
 drivers/cpufreq/speedstep-smi.c                    |  12 ++
 drivers/gpio/gpio-tps65912.c                       |  14 +-
 drivers/gpu/drm/radeon/atombios_dp.c               |   4 +-
 drivers/gpu/drm/radeon/evergreen.c                 |   3 +
 drivers/gpu/drm/radeon/r100.c                      |   4 +
 drivers/gpu/drm/radeon/r600.c                      |   3 +
 drivers/gpu/drm/radeon/radeon_bios.c               |  10 +-
 drivers/gpu/drm/radeon/radeon_cs.c                 |   4 +-
 drivers/gpu/drm/radeon/rs600.c                     |   4 +
 drivers/gpu/drm/vmwgfx/vmwgfx_drv.c                |  47 +++---
 drivers/infiniband/core/umem.c                     |   8 +
 drivers/infiniband/core/uverbs_main.c              |   1 +
 drivers/infiniband/hw/mlx4/mad.c                   |  20 ++-
 drivers/infiniband/hw/qib/qib.h                    |   9 +-
 drivers/infiniband/hw/qib/qib_eeprom.c             | 180 ---------------------
 drivers/infiniband/hw/qib/qib_iba6120.c            |   2 -
 drivers/infiniband/hw/qib/qib_iba7220.c            |   2 -
 drivers/infiniband/hw/qib/qib_iba7322.c            |   2 -
 drivers/infiniband/hw/qib/qib_init.c               |   1 -
 drivers/infiniband/hw/qib/qib_sysfs.c              |  24 ---
 drivers/input/mouse/synaptics.c                    |  73 ++++++---
 drivers/md/dm-io.c                                 |  12 +-
 drivers/md/dm-raid1.c                              |   9 ++
 drivers/md/dm-snap.c                               |   4 +-
 drivers/md/dm.c                                    |  33 ++--
 drivers/media/dvb/dvb-usb/lmedm04.c                |   8 +
 drivers/net/can/dev.c                              |   5 +
 drivers/net/ethernet/amd/pcnet32.c                 |  31 +++-
 drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c   |   4 +
 drivers/net/ethernet/broadcom/tg3.c                |  14 +-
 drivers/net/ethernet/emulex/benet/be_main.c        |   2 +-
 drivers/net/ethernet/freescale/gianfar.c           |   4 +-
 drivers/net/ethernet/intel/ixgb/ixgb_main.c        |   6 +-
 .../net/ethernet/qlogic/netxen/netxen_nic_main.c   |   5 +-
 drivers/net/ethernet/realtek/8139cp.c              |   2 +-
 drivers/net/ethernet/realtek/8139too.c             |   4 +-
 drivers/net/ethernet/realtek/r8169.c               |   6 +-
 drivers/net/macvtap.c                              |  13 +-
 drivers/net/ppp/ppp_deflate.c                      |   2 +-
 drivers/net/usb/plusb.c                            |   5 +
 drivers/net/xen-netfront.c                         |   5 +-
 drivers/pci/hotplug.c                              |   2 +-
 drivers/pci/rom.c                                  |   7 +-
 drivers/scsi/be2iscsi/be_main.c                    |   3 +-
 drivers/scsi/libsas/sas_discover.c                 |   6 +-
 drivers/scsi/scsi_lib.c                            |   4 +-
 drivers/scsi/sg.c                                  |   6 +-
 drivers/spi/spi-dw.c                               |   4 +-
 drivers/spi/spidev.c                               |   5 +-
 drivers/staging/comedi/comedi_compat32.c           |  12 +-
 drivers/staging/iio/imu/adis16400_core.c           |   3 +-
 drivers/staging/iio/industrialio-core.c            |   2 +
 drivers/staging/vt6655/rf.c                        |   1 +
 drivers/target/iscsi/iscsi_target_tq.c             |  30 +---
 drivers/target/target_core_pscsi.c                 |   2 +-
 drivers/target/tcm_fc/tfc_io.c                     |   3 +-
 drivers/tty/pty.c                                  |   3 +
 drivers/tty/serial/8250_pci.c                      |   2 +-
 drivers/tty/tty_io.c                               |   4 +-
 drivers/tty/tty_ioctl.c                            |  12 +-
 drivers/tty/vt/vt.c                                |   4 +-
 drivers/usb/class/cdc-acm.c                        |  21 ++-
 drivers/usb/core/buffer.c                          |  26 +--
 drivers/usb/core/devio.c                           |   2 +
 drivers/usb/core/driver.c                          |  12 ++
 drivers/usb/core/hcd.c                             |  16 +-
 drivers/usb/core/usb.c                             |   1 +
 drivers/usb/gadget/inode.c                         |  15 +-
 drivers/usb/host/isp1760-hcd.c                     |   3 +
 drivers/usb/host/xhci-hub.c                        |   9 +-
 drivers/usb/host/xhci-pci.c                        |  33 +++-
 drivers/usb/host/xhci-ring.c                       |  10 +-
 drivers/usb/host/xhci.h                            |   9 +-
 drivers/usb/serial/Kconfig                         |   4 +-
 drivers/usb/serial/bus.c                           |  13 +-
 drivers/usb/serial/cp210x.c                        |   3 +
 drivers/usb/serial/ftdi_sio.c                      |  28 +++-
 drivers/usb/serial/ftdi_sio_ids.h                  |  29 ++++
 drivers/usb/serial/keyspan_pda.c                   |  19 ++-
 drivers/xen/manage.c                               |   8 +-
 drivers/xen/xen-pciback/conf_space.c               |   2 +-
 drivers/xen/xen-pciback/conf_space.h               |   2 +
 drivers/xen/xen-pciback/conf_space_header.c        |  61 +++++--
 fs/autofs4/dev-ioctl.c                             |  11 +-
 fs/binfmt_elf.c                                    |   5 +-
 fs/cifs/file.c                                     |   1 +
 fs/debugfs/inode.c                                 |  46 +++---
 fs/ecryptfs/file.c                                 |  36 ++++-
 fs/exec.c                                          |  65 +++++---
 fs/fuse/dev.c                                      |   7 +-
 fs/hfsplus/brec.c                                  |  20 +--
 fs/jffs2/scan.c                                    |   5 +
 fs/jfs/jfs_dtree.c                                 |   4 +-
 fs/nfs/callback.c                                  |   8 +-
 fs/nfs/callback_xdr.c                              |   4 +-
 fs/nfs/delegation.c                                |   2 +-
 fs/nfs/nfs4proc.c                                  |  10 +-
 fs/nilfs2/btree.c                                  |  47 +++++-
 fs/nilfs2/segment.c                                |   7 +-
 fs/ocfs2/file.c                                    |  14 +-
 fs/proc/task_mmu.c                                 |  10 ++
 fs/udf/inode.c                                     |  32 ++--
 fs/xfs/xfs_file.c                                  |  14 +-
 fs/xfs/xfs_iops.c                                  |  36 ++---
 fs/xfs/xfs_vnodeops.h                              |   3 +-
 include/linux/blk_types.h                          |   4 +-
 include/linux/compiler-gcc4.h                      |   2 +
 include/linux/compiler.h                           |   4 +-
 include/linux/fsnotify.h                           |   6 +-
 include/linux/kernel.h                             |  16 ++
 include/linux/usb/hcd.h                            |   3 +
 include/net/netfilter/nf_conntrack_extend.h        |   4 +-
 kernel/debug/kdb/kdb_main.c                        |   2 +-
 kernel/events/core.c                               |  10 ++
 kernel/printk.c                                    |   3 +-
 kernel/sched.c                                     |  11 +-
 kernel/sched_autogroup.c                           |   6 +-
 kernel/trace/ftrace.c                              |  31 +++-
 mm/hugetlb.c                                       |  72 ++++++---
 mm/memory.c                                        |   2 +-
 mm/mmap.c                                          |   6 +-
 mm/nommu.c                                         |   2 +-
 mm/page-writeback.c                                |   7 +-
 mm/rmap.c                                          |   7 +
 net/caif/caif_socket.c                             |   2 +-
 net/can/af_can.c                                   |   3 +
 net/ceph/osd_client.c                              |  25 ++-
 net/compat.c                                       |  16 +-
 net/core/dev.c                                     |  22 ++-
 net/core/gen_stats.c                               |  15 +-
 net/core/rtnetlink.c                               |  28 ++--
 net/core/sysctl_net_core.c                         |  14 +-
 net/ipv4/ip_forward.c                              |   3 +
 net/ipv4/ip_fragment.c                             |  11 +-
 net/ipv4/ip_output.c                               |   3 +-
 net/ipv4/ip_sockglue.c                             |   8 +-
 net/ipv4/ping.c                                    |  13 +-
 net/ipv4/sysctl_net_ipv4.c                         |  12 +-
 net/ipv4/tcp_output.c                              |  54 ++++---
 net/ipv6/datagram.c                                |  10 +-
 net/ipv6/ip6_output.c                              |   3 +-
 net/ipv6/ndisc.c                                   |   9 +-
 net/ipv6/route.c                                   |   9 +-
 net/irda/ircomm/ircomm_tty.c                       |   4 +-
 net/llc/sysctl_net_llc.c                           |   8 +-
 net/mac80211/agg-rx.c                              |   8 +-
 net/mac80211/ieee80211_i.h                         |  24 ++-
 net/mac80211/rx.c                                  |  10 +-
 net/mac80211/sta_info.h                            |   2 +
 net/mac80211/tx.c                                  |   8 +-
 net/netfilter/ipvs/ip_vs_core.c                    |  32 ++--
 net/netfilter/ipvs/ip_vs_ftp.c                     |  10 +-
 net/netfilter/ipvs/ip_vs_sync.c                    |   3 +
 net/netfilter/nf_queue.c                           |   2 +-
 net/netfilter/xt_socket.c                          |  22 +--
 net/rds/iw_rdma.c                                  |  40 ++---
 net/rds/sysctl.c                                   |   4 +-
 net/rxrpc/ar-recvmsg.c                             |   2 +-
 net/sched/ematch.c                                 |   1 +
 net/socket.c                                       |   3 +
 net/sunrpc/cache.c                                 |   2 +-
 net/sunrpc/xprtrdma/verbs.c                        |   8 +-
 net/wireless/nl80211.c                             |   8 +
 net/xfrm/xfrm_output.c                             |   2 +
 security/selinux/selinuxfs.c                       |   2 +-
 security/smack/smack.h                             |  10 ++
 security/smack/smack_lsm.c                         |  24 +--
 sound/core/control.c                               |   4 +
 sound/core/pcm_native.c                            |   2 +
 sound/pci/hda/patch_realtek.c                      |   2 +-
 sound/pci/riptide/riptide.c                        |  27 +++-
 sound/pci/rme9652/hdspm.c                          |   6 +
 sound/soc/codecs/adav80x.c                         |   4 +-
 sound/soc/codecs/ak4641.c                          |   4 +-
 sound/soc/codecs/cs4271.c                          |   4 +-
 sound/soc/codecs/sgtl5000.c                        |   8 +-
 sound/soc/codecs/wm2000.c                          |   8 +-
 sound/soc/codecs/wm8731.c                          |   4 +-
 sound/soc/codecs/wm8903.c                          |   4 +-
 sound/soc/codecs/wm8904.c                          |   4 +-
 sound/soc/codecs/wm8955.c                          |   4 +-
 sound/soc/codecs/wm8960.c                          |   4 +-
 sound/soc/omap/omap-pcm.c                          |   4 +-
 sound/usb/mixer_quirks.c                           |   1 +
 sound/usb/quirks-table.h                           |  30 ++++
 209 files changed, 1534 insertions(+), 866 deletions(-)

Adrian Knoth (1):
      ALSA: hdspm - Constrain periods to 2 on older cards

Al Viro (7):
      debugfs: leave freeing a symlink body until inode eviction
      autofs4 copy_dev_ioctl(): keep the value of -&gt;size we&#39;d used for allocation
      sunrpc: fix braino in -&gt;poll()
      gadgetfs: use-after-free in -&gt;aio_read()
      ocfs2: _really_ sync the right range
      caif: fix MSG_OOB test in caif_seqpkt_recvmsg()
      rxrpc: bogus MSG_PEEK test in rxrpc_recvmsg()

Alan Stern (3):
      USB: add flag for HCDs that can&#39;t receive wakeup requests (isp1760-hcd)
      USB: fix use-after-free bug in usb_hcd_unlink_urb()
      USB: usbfs: don&#39;t leak kernel data in siginfo

Aleksander Morgado (1):
      xhci: fix reporting of 0-sized URBs in control endpoint

Alex Deucher (5):
      drm/radeon/dp: Set EDP_CONFIGURATION_SET for bridge chips if necessary
      drm/radeon: do a posting read in r100_set_irq
      drm/radeon: do a posting read in rs600_set_irq
      drm/radeon: do a posting read in r600_set_irq
      drm/radeon: do a posting read in evergreen_set_irq

Alexander Drozdov (2):
      ipv4: ip_check_defrag should correctly check return value of skb_copy_bits
      ipv4: ip_check_defrag should not assume that skb_network_offset is zero

Alexey Kodanev (1):
      net: sysctl_net_core: check SNDBUF and RCVBUF for min length

Andrey Ryabinin (1):
      smack: fix possible use after frees in task_security() callers

Andrey Vagin (1):
      netfilter: nf_conntrack: reserve two bytes for nf_ct_ext-&gt;len

Andy Lutomirski (2):
      x86/asm/entry/64: Remove a bogus &#39;ret_from_fork&#39; optimization
      x86/asm/entry/32: Fix user_mode() misuses

Andy Shevchenko (1):
      spi: dw: revisit FIFO size detection again

Ani Sinha (1):
      net:socket: set msg_namelen to 0 if msg_name is passed as NULL in msghdr struct from userland.

Arik Nemtsov (1):
      mac80211: set only VO as a U-APSD enabled AC

Arnd Bergmann (1):
      rds: avoid potential stack overflow

Bart Van Assche (1):
      Defer processing of REQ_PREEMPT requests for blocked devices

Ben Hutchings (3):
      gadgetfs: Fix leak on error in aio_read()
      Revert &quot;KVM: s390: flush CPU on load control&quot;
      Linux 3.2.69

Ben Shelton (1):
      usb: plusb: Add support for National Instruments host-to-host cable

Benjamin Tissoires (1):
      Input: synaptics - handle spurious release of trackstick buttons

Bob Copeland (1):
      mac80211: drop unencrypted frames in mesh fwding

Brian King (1):
      bnx2x: Force fundamental reset for EEH recovery

Brian Silverman (1):
      sched: Fix RLIMIT_RTTIME when PI-boosting to RT

Catalin Marinas (2):
      net: compat: Ignore MSG_CMSG_COMPAT in compat_sys_{send, recv}msg
      net: compat: Update get_compat_msghdr() to match copy_msghdr_from_user() behaviour

Chen Jie (1):
      jffs2: fix handling of corrupted summary length

Chris Wilson (1):
      ACPI / video: Load the module even if ACPI is disabled

Christian Gmeiner (1):
      x86/reboot: Add reboot quirk for Certec BPC600

Chuck Lever (1):
      xprtrdma: Free the pd if ib_query_qp() fails

D.S. Ljungmark (1):
      ipv6: Don&#39;t reduce hop limit for an interface

Dan Carpenter (3):
      ALSA: off by one bug in snd_riptide_joystick_probe()
      tcm_fc: missing curly braces in ft_invl_hw_context()
      ipvs: uninitialized data with IP_VS_IPV6

Daniel Borkmann (1):
      rtnetlink: ifla_vf_policy: fix misuses of NLA_BINARY

Daniel Mack (1):
      ALSA: snd-usb: add quirks for Roland UA-22

Daniel Martin (1):
      Input: synaptics - query min dimensions for fw v8.1

Darrick J. Wong (2):
      dm io: reject unsupported DISCARD requests with EOPNOTSUPP
      dm io: deal with wandering queue limits when handling REQ_DISCARD and REQ_WRITE_SAME

Dave Chinner (1):
      xfs: ensure truncate forces zeroed blocks to disk

Dave Jones (1):
      x86/reboot: Fix apparent cut-n-paste mistake in Dell reboot workaround

Dave Kleikamp (1):
      jfs: fix readdir regression

David Daney (1):
      kernel.h: add BUILD_BUG() macro

David Disseldorp (1):
      cifs: fix use-after-free bug in find_writable_file

David Hildenbrand (1):
      KVM: s390: base hrtimer on a monotonic clock

David Hooper (1):
      x86/reboot: Remove quirk entry for SBC FITPC

David Howells (1):
      TPM: Add new TPMs to the tail of the list to prevent inadvertent change of dev

David Miller (1):
      radeon: Do not directly dereference pointers to BIOS area.

David S. Miller (1):
      ipv4: Missing sk_nulls_node_init() in ping_unhash().

Dmitry Eremin-Solenikov (4):
      ARM: pxa: add regulator_has_full_constraints to corgi board file
      ARM: pxa: add regulator_has_full_constraints to poodle board file
      ARM: pxa: add regulator_has_full_constraints to spitz board file
      ARM: 8284/1: sa1100: clear RCSR_SMR on resume

Dmitry M. Fedin (1):
      ALSA: usb - Creative USB X-Fi Pro SB1095 volume knob support

Dmitry Torokhov (1):
      Input: synaptics - fix middle button on Lenovo 2015 products

Dmitry Tunin (1):
      Bluetooth: ath3k: Add support of AR3012 bluetooth 13d3:3423 device

Doug Goldstein (2):
      USB: ftdi_sio: Added custom PID for Synapse Wireless product
      USB: ftdi_sio: Use jtag quirk for SNAP Connect E10

Eli Cohen (1):
      IB/core: Avoid leakage from kernel to user space

Eric Dumazet (6):
      netfilter: xt_socket: fix a stack corruption bug
      net: rps: fix cpu unplug
      netxen: fix netxen_nic_poll() logic
      macvtap: make sure neighbour code can push ethernet header
      tcp: make connect() mem charging friendly
      tcp: avoid looping in tcp_send_fin()

Eric Nelson (1):
      ASoC: sgtl5000: remove useless register write clearing CHRGPUMP_POWERUP

Eric W. Biederman (7):
      8139cp: Call dev_kfree_skby_any instead of kfree_skb.
      8139too: Call dev_kfree_skby_any instead of dev_kfree_skb.
      r8169: Call dev_kfree_skby_any instead of dev_kfree_skb.
      tg3: Call dev_kfree_skby_any instead of dev_kfree_skb.
      ixgb: Call dev_kfree_skby_any instead of dev_kfree_skb.
      benet: Call dev_kfree_skby_any instead of kfree_skb.
      gianfar: Carefully free skbs in functions called by netpoll.

Florian Westphal (2):
      ppp: deflate: never return len larger than output buffer
      net: make skb_gso_segment error handling more robust

Grazvydas Ignotas (1):
      mm/memory.c: actually remap enough memory

Hagen Paul Pfeifer (1):
      ipv6: stop sending PTB packets for MTU &lt; 1280

Hector Marco-Gisbert (1):
      x86, mm/ASLR: Fix stack randomization on 64-bit systems

Hui Wang (1):
      ALSA: hda - Add one more node in the EAPD supporting candidate list

Ian Abbott (2):
      staging: comedi: comedi_compat32.c: fix COMEDI_CMD copy back
      spi: spidev: fix possible arithmetic overflow for multi-transfer message

Ignacy Gaw?dzki (2):
      gen_stats.c: Duplicate xstats buffer for later use
      ematch: Fix auto-loading of ematch modules.

Ilya Dryomov (1):
      libceph: fix double __remove_osd() problem

James Bottomley (1):
      libsas: Fix Kernel Crash in smp_execute_task

Jan Beulich (1):
      xen-pciback: limit guest control of command register

Jan Kara (3):
      udf: Remove repeated loads blocksize
      udf: Check length of extended attributes and allocation descriptors
      fsnotify: fix handling of renames in audit

Jann Horn (1):
      fs: take i_mutex during prepare_binprm for set[ug]id executables

Jason Wang (1):
      macvtap: limit head length of skb allocated

Jay Lan (1):
      kdb: fix incorrect counts in KDB summary command output

Jeff Layton (1):
      nfs: don&#39;t call blocking operations while !TASK_RUNNING

Jiri Slaby (2):
      tty: fix up atime/mtime mess, take four
      x86/vdso: Fix the build on GCC5

Joe Perches (1):
      selinux: fix sel_write_enforce broken return value

Johan Hovold (4):
      USB: serial: fix potential use-after-free after failed probe
      USB: serial: fix tty-device error handling at probe
      net: irda: fix wait_until_sent poll timeout
      TTY: fix tty_wait_until_sent on 64-bit machines

Johannes Berg (2):
      nl80211: ignore HT/VHT capabilities without QoS/WMM
      mac80211: fix RX A-MPDU session reorder timer deletion

John Soni Jose (1):
      be2iscsi: Fix kernel panic when device initialization fails

Jonathan Davies (1):
      xen-netfront: transmit fully GSO-sized packets

Jouni Malinen (1):
      mac80211: Send EAPOL frames at lowest rate

Julian Anastasov (2):
      ipvs: add missing ip_vs_pe_put in sync code
      ipvs: rerouting to local clients is not needed anymore

Kirill A. Shutemov (1):
      pagemap: do not leak physical addresses to non-privileged userspace

Lennart Sorensen (1):
      USB: cp210x: add ID for RUGGEDCOM USB Serial Console

Leon Yu (1):
      mm: fix anon_vma-&gt;degree underflow in anon_vma endless growing prevention

Lorenzo Colitti (1):
      net: ping: Return EAFNOSUPPORT when appropriate.

Lu Baolu (2):
      usb: xhci: handle Config Error Change (CEC) in xhci driver
      usb: xhci: apply XHCI_AVOID_BEI quirk to all Intel xHCI controllers

Majd Dibbiny (1):
      IB/mlx4: Saturate RoCE port PMA counters in case of overflow

Malcolm Priestley (2):
      lmedm04: Fix usb_submit_urb BOGUS urb xfer, pipe 1 != type 3 in interrupt urb
      vt6655: RFbSetPower fix missing rate RATE_12M

Mark Glover (1):
      USB: ftdi_sio: add PIDs for Actisense USB devices

Mark Knibbs (1):
      USB: serial: keyspan_pda: fix Entrega company name spelling

Markos Chandras (1):
      net: ethernet: pcnet32: Setup the SRAM and NOUFLO on Am79C97{3, 5}

Martin Fuzzey (1):
      iio: core: Fix double free.

Martin KaFai Lau (1):
      ipv6: fix ipv6_cow_metrics for non DST_HOST case

Martin Vajnar (1):
      hx4700: regulator: declare full constraints

Masoud Sharbiani (2):
      x86/reboot: Add quirk to make Dell C6100 use reboot=pci automatically
      x86/reboot: Remove the duplicate C6100 entry in the reboot quirks list

Mathias Nyman (2):
      xhci: Allocate correct amount of scratchpad buffers
      xhci: Workaround for PME stuck issues in Intel xhci

Matthew Thode (1):
      net: reject creation of netdev names with colons

Matthew Wilcox (1):
      axonram: Fix bug in direct_access

Max Mansfield (1):
      usb: ftdi_sio: Add jtag quirk support for Cyber Cortex AV boards

Michael D Labriola (1):
      x86/reboot: Remove VersaLogic Menlow reboot quirk

Michael S. Tsirkin (1):
      virtio_console: avoid config access from irq

Michal Kazior (1):
      mac80211: disable u-APSD queues by default

Michal Kube?ek (1):
      udp: only allow UFO for packets from SOCK_DGRAM sockets

Michel Dänzer (1):
      PCI: Fix infinite loop with ROM image of size 0

Michiel vd Garde (1):
      USB: serial: cp210x: Adding Seletek device id&#39;s

Miklos Szeredi (2):
      fuse: notify: don&#39;t move pages
      fuse: set stolen page uptodate

Mikulas Patocka (5):
      cpufreq: speedstep-smi: enable interrupts when waiting
      dm mirror: do not degrade the mirror on discard error
      dm: fix a race condition in dm_get_md
      dm snapshot: fix a possible invalid memory access on unload
      dm: hold suspend_lock while suspending device during device deletion

Minh Duc Tran (1):
      fixed invalid assignment of 64bit mask to host dma_boundary for scatter gather segment boundary limit.

Mitko Haralanov (1):
      IB/qib: Do not write EEPROM

Naoya Horiguchi (3):
      mm/hugetlb: fix getting refcount 0 page in hugetlb_fault()
      mm/hugetlb: add migration/hwpoisoned entry check in hugetlb_change_protection
      mm/hugetlb: add migration entry check in __unmap_hugepage_range

Nathaniel W Filardo (1):
      USB: keyspan_pda: add new device id

Nicholas Bellinger (2):
      iscsi-target: Drop problematic active_ts_list usage
      target/pscsi: Fix NULL pointer dereference in get_device_type

Nicolas Pitre (1):
      vt: provide notifications on selection changes

Nicolas Saenz Julienne (1):
      gpio: tps65912: fix wrong container_of arguments

Oliver Hartkopp (1):
      can: add missing initialisations in CAN related skbuffs

Oliver Neukum (1):
      cdc-acm: add sanity checks

Paolo Bonzini (1):
      KVM: emulate: fix CMPXCHG8B on 32-bit hosts

Peter Hurley (2):
      tty: Prevent untrappable signals from malicious program
      console: Fix console name size mismatch

Peter Ujfalusi (1):
      ASoC: omap-pcm: Correct dma mask

Peter Zijlstra (2):
      sched/autogroup: Fix failure to set cpu.rt_runtime_us
      perf: Fix irq_work &#39;tail&#39; recursion

Pratyush Anand (1):
      ftrace: Fix en(dis)able graph caller when en(dis)abling record via sysctl

Rasmus Villemoes (1):
      iio: imu: adis16400: Fix sign extension

Ricardo Ribalda Delgado (1):
      PCI: Generate uppercase hex for modalias var in uevent

Roman Gushchin (2):
      mm/mmap.c: fix arithmetic overflow in __vm_enough_memory()
      mm/nommu.c: fix arithmetic overflow in __vm_enough_memory()

Ross Lagerwall (1):
      xen/manage: Fix USB interaction issues when resuming

Russell King (1):
      Change email address for 8250_pci

Ryusuke Konishi (2):
      nilfs2: fix potential memory overrun on inode
      nilfs2: fix deadlock of segment constructor during recovery

Sasha Levin (3):
      autofs4: check dev ioctl size before allocating
      net: llc: use correct size for sysctl timeout entries
      net: rds: use correct size for max unacked packets and bytes

Sebastian Andrzej Siewior (1):
      usb: core: buffer: smallest buffer should start at ARCH_DMA_MINALIGN

Sebastian Pöhn (1):
      ip_forward: Drop frames with attached skb-&gt;sk

Sergei Antonov (1):
      hfsplus: fix B-tree corruption after insertion at position 0

Shachar Raindel (1):
      IB/uverbs: Prevent integer overflow in ib_umem_get address arithmetic

Stefan Lippers-Hollmann (1):
      x86/reboot: Add ASRock Q1900DC-ITX mainboard reboot quirk

Stephan Mueller (1):
      crypto: aesni - fix memory usage in GCM decryption

Steven Rostedt (Red Hat) (1):
      ftrace: Fix ftrace enable ordering of sysctl ftrace_enabled

Sudip Mukherjee (1):
      nbd: fix possible memory leak

Takashi Iwai (11):
      ALSA: pcm: Don&#39;t leave PREPARED state after draining
      ASoC: adav80x: Fix wrong value references for boolean kctl
      ASoC: ak4641: Fix wrong value references for boolean kctl
      ASoC: cs4271: Fix wrong value references for boolean kctl
      ASoC: wm2000: Fix wrong value references for boolean kctl
      ASoC: wm8731: Fix wrong value references for boolean kctl
      ASoC: wm8903: Fix wrong value references for boolean kctl
      ASoC: wm8904: Fix wrong value references for boolean kctl
      ASoC: wm8955: Fix wrong value references for boolean kctl
      ASoC: wm8960: Fix wrong value references for boolean kctl
      ALSA: control: Add sanity checks for user ctl id name string

Tejun Heo (2):
      writeback: add missing INITIAL_JIFFIES init in global_update_bandwidth()
      writeback: fix possible underflow in write bandwidth calculation

Thomas Hellstrom (1):
      drm/vmwgfx: Reorder device takedown somewhat

Tommi Rantala (1):
      drm/radeon: fix DRM_IOCTL_RADEON_CS oops

Tony Battersby (1):
      sg: fix read() error reporting

Trond Myklebust (3):
      NFSv4.1: Fix a kfree() of uninitialised pointers in decode_cb_sequence_args
      NFSv4: Don&#39;t call put_rpccred() under the rcu_read_lock()
      NFSv4: Minor cleanups for nfs4_handle_exception and nfs4_async_handle_error

Tyler Hicks (1):
      eCryptfs: don&#39;t pass fs-specific ioctl commands through

Ville Syrjälä (1):
      x86/reboot: Add reboot quirk for Dell Latitude E5410

WANG Cong (2):
      net: use for_each_netdev_safe() in rtnl_group_changelink()
      rtnetlink: call -&gt;dellink on failure when -&gt;newlink exists

Willem de Bruijn (1):
      ip: zero sockaddr returned on error queue

Zhang Rui (1):
      ACPI, x86: fix Dell M6600 ACPI reboot regression via DMI

bingtian.ly@taobao.com (1):
      net: avoid to hang up on sending due to sysctl configuration overflow.

subashab@codeaurora.org (1):
      ping: Fix race in free in receive path
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/usb/usb-serial.txt b/Documentation/usb/usb-serial.txt</span>
<span class="p_header">index 5bd7926..947fa62 100644</span>
<span class="p_header">--- a/Documentation/usb/usb-serial.txt</span>
<span class="p_header">+++ b/Documentation/usb/usb-serial.txt</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> Keyspan PDA Serial Adapter</span>
   Single port DB-9 serial adapter, pushed as a PDA adapter for iMacs (mostly
   sold in Macintosh catalogs, comes in a translucent white/green dongle).
   Fairly simple device. Firmware is homebrew.
<span class="p_del">-  This driver also works for the Xircom/Entrgra single port serial adapter.</span>
<span class="p_add">+  This driver also works for the Xircom/Entrega single port serial adapter.</span>
 
   Current status:
    Things that work:
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 2e7cbda..8071888 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 68</span>
<span class="p_add">+SUBLEVEL = 69</span>
 EXTRAVERSION =
 NAME = Saber-toothed Squirrel
 
<span class="p_header">diff --git a/arch/arm/mach-pxa/corgi.c b/arch/arm/mach-pxa/corgi.c</span>
<span class="p_header">index 549468d..e1715af 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/corgi.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/corgi.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/i2c.h&gt;
 #include &lt;linux/i2c/pxa-i2c.h&gt;
 #include &lt;linux/io.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 #include &lt;linux/spi/spi.h&gt;
 #include &lt;linux/spi/ads7846.h&gt;
 #include &lt;linux/spi/corgi_lcd.h&gt;
<span class="p_chunk">@@ -704,6 +705,8 @@</span> <span class="p_context"> static void __init corgi_init(void)</span>
 		sharpsl_nand_partitions[1].size = 53 * 1024 * 1024;
 
 	platform_add_devices(devices, ARRAY_SIZE(devices));
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init fixup_corgi(struct tag *tags, char **cmdline,
<span class="p_header">diff --git a/arch/arm/mach-pxa/hx4700.c b/arch/arm/mach-pxa/hx4700.c</span>
<span class="p_header">index 6f6368e..a7be979 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/hx4700.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/hx4700.c</span>
<span class="p_chunk">@@ -835,6 +835,8 @@</span> <span class="p_context"> static void __init hx4700_init(void)</span>
 	mdelay(10);
 	gpio_set_value(GPIO71_HX4700_ASIC3_nRESET, 1);
 	mdelay(10);
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 MACHINE_START(H4700, &quot;HP iPAQ HX4700&quot;)
<span class="p_header">diff --git a/arch/arm/mach-pxa/poodle.c b/arch/arm/mach-pxa/poodle.c</span>
<span class="p_header">index 50c8331..fb645f4 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/poodle.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/poodle.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/gpio.h&gt;
 #include &lt;linux/i2c.h&gt;
 #include &lt;linux/i2c/pxa-i2c.h&gt;
<span class="p_add">+#include &lt;linux/regulator/machine.h&gt;</span>
 #include &lt;linux/spi/spi.h&gt;
 #include &lt;linux/spi/ads7846.h&gt;
 #include &lt;linux/spi/pxa2xx_spi.h&gt;
<span class="p_chunk">@@ -453,6 +454,7 @@</span> <span class="p_context"> static void __init poodle_init(void)</span>
 	pxa_set_i2c_info(NULL);
 	i2c_register_board_info(0, ARRAY_AND_SIZE(poodle_i2c_devices));
 	poodle_init_spi();
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init fixup_poodle(struct tag *tags, char **cmdline,
<span class="p_header">diff --git a/arch/arm/mach-pxa/spitz.c b/arch/arm/mach-pxa/spitz.c</span>
<span class="p_header">index 953a919..0451bbd 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/spitz.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/spitz.c</span>
<span class="p_chunk">@@ -969,6 +969,8 @@</span> <span class="p_context"> static void __init spitz_init(void)</span>
 	spitz_nor_init();
 	spitz_nand_init();
 	spitz_i2c_init();
<span class="p_add">+</span>
<span class="p_add">+	regulator_has_full_constraints();</span>
 }
 
 static void __init spitz_fixup(struct tag *tags, char **cmdline,
<span class="p_header">diff --git a/arch/arm/mach-sa1100/pm.c b/arch/arm/mach-sa1100/pm.c</span>
<span class="p_header">index bf85b8b..66c4845 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/pm.c</span>
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"> static int sa11x0_pm_enter(suspend_state_t state)</span>
 	/*
 	 * Ensure not to come back here if it wasn&#39;t intended
 	 */
<span class="p_add">+	RCSR = RCSR_SMR;</span>
 	PSPR = 0;
 
 	/*
<span class="p_header">diff --git a/arch/powerpc/sysdev/axonram.c b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">index ba42719..9befade 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/axonram.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/axonram.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> axon_ram_direct_access(struct block_device *device, sector_t sector,</span>
 	}
 
 	*kaddr = (void *)(bank-&gt;ph_addr + offset);
<span class="p_del">-	*pfn = virt_to_phys(kaddr) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	*pfn = virt_to_phys(*kaddr) &gt;&gt; PAGE_SHIFT;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/s390/kvm/intercept.c b/arch/s390/kvm/intercept.c</span>
<span class="p_header">index bc486d0..a5f6eff 100644</span>
<span class="p_header">--- a/arch/s390/kvm/intercept.c</span>
<span class="p_header">+++ b/arch/s390/kvm/intercept.c</span>
<span class="p_chunk">@@ -58,7 +58,6 @@</span> <span class="p_context"> static int handle_lctlg(struct kvm_vcpu *vcpu)</span>
 			break;
 		reg = (reg + 1) % 16;
 	} while (1);
<span class="p_del">-	kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -98,7 +97,6 @@</span> <span class="p_context"> static int handle_lctl(struct kvm_vcpu *vcpu)</span>
 			break;
 		reg = (reg + 1) % 16;
 	} while (1);
<span class="p_del">-	kvm_make_request(KVM_REQ_TLB_FLUSH, vcpu);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">index f6f41dd..b96b4de 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)</span>
 	vcpu-&gt;arch.sie_block-&gt;ecb   = 6;
 	vcpu-&gt;arch.sie_block-&gt;eca   = 0xC1002001U;
 	vcpu-&gt;arch.sie_block-&gt;fac   = (int) (long) facilities;
<span class="p_del">-	hrtimer_init(&amp;vcpu-&gt;arch.ckc_timer, CLOCK_REALTIME, HRTIMER_MODE_ABS);</span>
<span class="p_add">+	hrtimer_init(&amp;vcpu-&gt;arch.ckc_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);</span>
 	tasklet_init(&amp;vcpu-&gt;arch.tasklet, kvm_s390_tasklet,
 		     (unsigned long) vcpu);
 	vcpu-&gt;arch.ckc_timer.function = kvm_s390_idle_wakeup;
<span class="p_header">diff --git a/arch/x86/crypto/aesni-intel_glue.c b/arch/x86/crypto/aesni-intel_glue.c</span>
<span class="p_header">index 16acf68..3b3a62f 100644</span>
<span class="p_header">--- a/arch/x86/crypto/aesni-intel_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/aesni-intel_glue.c</span>
<span class="p_chunk">@@ -1202,7 +1202,7 @@</span> <span class="p_context"> static int __driver_rfc4106_decrypt(struct aead_request *req)</span>
 		src = kmalloc(req-&gt;cryptlen + req-&gt;assoclen, GFP_ATOMIC);
 		if (!src)
 			return -ENOMEM;
<span class="p_del">-		assoc = (src + req-&gt;cryptlen + auth_tag_len);</span>
<span class="p_add">+		assoc = (src + req-&gt;cryptlen);</span>
 		scatterwalk_map_and_copy(src, req-&gt;src, 0, req-&gt;cryptlen, 0);
 		scatterwalk_map_and_copy(assoc, req-&gt;assoc, 0,
 			req-&gt;assoclen, 0);
<span class="p_chunk">@@ -1227,7 +1227,7 @@</span> <span class="p_context"> static int __driver_rfc4106_decrypt(struct aead_request *req)</span>
 		scatterwalk_done(&amp;src_sg_walk, 0, 0);
 		scatterwalk_done(&amp;assoc_sg_walk, 0, 0);
 	} else {
<span class="p_del">-		scatterwalk_map_and_copy(dst, req-&gt;dst, 0, req-&gt;cryptlen, 1);</span>
<span class="p_add">+		scatterwalk_map_and_copy(dst, req-&gt;dst, 0, tempCipherLen, 1);</span>
 		kfree(src);
 	}
 	return retval;
<span class="p_header">diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S</span>
<span class="p_header">index 9d28dbac..8d15c69 100644</span>
<span class="p_header">--- a/arch/x86/kernel/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/entry_64.S</span>
<span class="p_chunk">@@ -414,11 +414,14 @@</span> <span class="p_context"> ENTRY(ret_from_fork)</span>
 	testl $3, CS-ARGOFFSET(%rsp)		# from kernel_thread?
 	je   int_ret_from_sys_call
 
<span class="p_del">-	testl $_TIF_IA32, TI_flags(%rcx)	# 32-bit compat task needs IRET</span>
<span class="p_del">-	jnz  int_ret_from_sys_call</span>
<span class="p_del">-</span>
<span class="p_del">-	RESTORE_TOP_OF_STACK %rdi, -ARGOFFSET</span>
<span class="p_del">-	jmp ret_from_sys_call			# go to the SYSRET fastpath</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * By the time we get here, we have no idea whether our pt_regs,</span>
<span class="p_add">+	 * ti flags, and ti status came from the 64-bit SYSCALL fast path,</span>
<span class="p_add">+	 * the slow path, or one of the ia32entry paths.</span>
<span class="p_add">+	 * Use int_ret_from_sys_call to return, since it can safely handle</span>
<span class="p_add">+	 * all of the above.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	jmp  int_ret_from_sys_call</span>
 
 	CFI_ENDPROC
 END(ret_from_fork)
<span class="p_header">diff --git a/arch/x86/kernel/reboot.c b/arch/x86/kernel/reboot.c</span>
<span class="p_header">index f411aca..41b2f57 100644</span>
<span class="p_header">--- a/arch/x86/kernel/reboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/reboot.c</span>
<span class="p_chunk">@@ -279,14 +279,6 @@</span> <span class="p_context"> static struct dmi_system_id __initdata reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;VGN-Z540N&quot;),
 		},
 	},
<span class="p_del">-	{	/* Handle problems with rebooting on CompuLab SBC-FITPC2 */</span>
<span class="p_del">-		.callback = set_bios_reboot,</span>
<span class="p_del">-		.ident = &quot;CompuLab SBC-FITPC2&quot;,</span>
<span class="p_del">-		.matches = {</span>
<span class="p_del">-			DMI_MATCH(DMI_SYS_VENDOR, &quot;CompuLab&quot;),</span>
<span class="p_del">-			DMI_MATCH(DMI_PRODUCT_NAME, &quot;SBC-FITPC2&quot;),</span>
<span class="p_del">-		},</span>
<span class="p_del">-	},</span>
 	{       /* Handle problems with rebooting on ASUS P4S800 */
 		.callback = set_bios_reboot,
 		.ident = &quot;ASUS P4S800&quot;,
<span class="p_chunk">@@ -295,14 +287,6 @@</span> <span class="p_context"> static struct dmi_system_id __initdata reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_BOARD_NAME, &quot;P4S800&quot;),
 		},
 	},
<span class="p_del">-	{	/* Handle problems with rebooting on VersaLogic Menlow boards */</span>
<span class="p_del">-		.callback = set_bios_reboot,</span>
<span class="p_del">-		.ident = &quot;VersaLogic Menlow based board&quot;,</span>
<span class="p_del">-		.matches = {</span>
<span class="p_del">-			DMI_MATCH(DMI_BOARD_VENDOR, &quot;VersaLogic Corporation&quot;),</span>
<span class="p_del">-			DMI_MATCH(DMI_BOARD_NAME, &quot;VersaLogic Menlow board&quot;),</span>
<span class="p_del">-		},</span>
<span class="p_del">-	},</span>
 	{ /* Handle reboot issue on Acer Aspire one */
 		.callback = set_kbd_reboot,
 		.ident = &quot;Acer Aspire One A110&quot;,
<span class="p_chunk">@@ -428,6 +412,24 @@</span> <span class="p_context"> static struct dmi_system_id __initdata pci_reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;iMac9,1&quot;),
 		},
 	},
<span class="p_add">+	/* ASRock */</span>
<span class="p_add">+	{	/* Handle problems with rebooting on ASRock Q1900DC-ITX */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;ASRock Q1900DC-ITX&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;ASRock&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_NAME, &quot;Q1900DC-ITX&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	/* Certec */</span>
<span class="p_add">+	{       /* Handle problems with rebooting on Certec BPC600 */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;Certec BPC600&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Certec&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;BPC600&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{	/* Handle problems with rebooting on the Latitude E6320. */
 		.callback = set_pci_reboot,
 		.ident = &quot;Dell Latitude E6320&quot;,
<span class="p_chunk">@@ -436,6 +438,14 @@</span> <span class="p_context"> static struct dmi_system_id __initdata pci_reboot_dmi_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude E6320&quot;),
 		},
 	},
<span class="p_add">+	{	/* Handle problems with rebooting on the Latitude E5410. */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;Dell Latitude E5410&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude E5410&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{	/* Handle problems with rebooting on the Latitude E5420. */
 		.callback = set_pci_reboot,
 		.ident = &quot;Dell Latitude E5420&quot;,
<span class="p_chunk">@@ -462,6 +472,22 @@</span> <span class="p_context"> static struct dmi_system_id __initdata pci_reboot_dmi_table[] = {</span>
 	},
 	{	/* Handle problems with rebooting on the Precision M6600. */
 		.callback = set_pci_reboot,
<span class="p_add">+		.ident = &quot;Dell Precision M6600&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Precision M6600&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* Handle problems with rebooting on the Dell PowerEdge C6100. */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
<span class="p_add">+		.ident = &quot;Dell PowerEdge C6100&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;C6100&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* Handle problems with rebooting on the Precision M6600. */</span>
<span class="p_add">+		.callback = set_pci_reboot,</span>
 		.ident = &quot;Dell OptiPlex 990&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),
<span class="p_header">diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c</span>
<span class="p_header">index 2aff347..edbd30a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/traps.c</span>
<span class="p_header">+++ b/arch/x86/kernel/traps.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> dotraplinkage void __kprobes do_debug(struct pt_regs *regs, long error_code)</span>
 	 * then it&#39;s very likely the result of an icebp/int01 trap.
 	 * User wants a sigtrap for that.
 	 */
<span class="p_del">-	if (!dr6 &amp;&amp; user_mode(regs))</span>
<span class="p_add">+	if (!dr6 &amp;&amp; user_mode_vm(regs))</span>
 		user_icebp = 1;
 
 	/* Catch kmemcheck conditions first of all! */
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index bdad489..9af0b82 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -4014,7 +4014,8 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 		if (rc != X86EMUL_CONTINUE)
 			goto done;
 	}
<span class="p_del">-	ctxt-&gt;dst.orig_val = ctxt-&gt;dst.val;</span>
<span class="p_add">+	/* Copy full 64-bit value for CMPXCHG8B.  */</span>
<span class="p_add">+	ctxt-&gt;dst.orig_val64 = ctxt-&gt;dst.val64;</span>
 
 special_insn:
 
<span class="p_header">diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c</span>
<span class="p_header">index 5c1ae28..75f9e5d 100644</span>
<span class="p_header">--- a/arch/x86/mm/mmap.c</span>
<span class="p_header">+++ b/arch/x86/mm/mmap.c</span>
<span class="p_chunk">@@ -35,12 +35,12 @@</span> <span class="p_context"> struct __read_mostly va_alignment va_align = {</span>
 	.flags = -1,
 };
 
<span class="p_del">-static unsigned int stack_maxrandom_size(void)</span>
<span class="p_add">+static unsigned long stack_maxrandom_size(void)</span>
 {
<span class="p_del">-	unsigned int max = 0;</span>
<span class="p_add">+	unsigned long max = 0;</span>
 	if ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp;
 		!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE)) {
<span class="p_del">-		max = ((-1U) &amp; STACK_RND_MASK) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+		max = ((-1UL) &amp; STACK_RND_MASK) &lt;&lt; PAGE_SHIFT;</span>
 	}
 
 	return max;
<span class="p_header">diff --git a/arch/x86/vdso/vdso32/sigreturn.S b/arch/x86/vdso/vdso32/sigreturn.S</span>
<span class="p_header">index 31776d0..d7ec4e2 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vdso32/sigreturn.S</span>
<span class="p_header">+++ b/arch/x86/vdso/vdso32/sigreturn.S</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 	.text
 	.globl __kernel_sigreturn
 	.type __kernel_sigreturn,@function
<span class="p_add">+	nop /* this guy is needed for .LSTARTFDEDLSI1 below (watch for HACK) */</span>
 	ALIGN
 __kernel_sigreturn:
 .LSTART_sigreturn:
<span class="p_header">diff --git a/drivers/acpi/video.c b/drivers/acpi/video.c</span>
<span class="p_header">index 2ebfdd2..cb842a8 100644</span>
<span class="p_header">--- a/drivers/acpi/video.c</span>
<span class="p_header">+++ b/drivers/acpi/video.c</span>
<span class="p_chunk">@@ -1854,6 +1854,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(acpi_video_unregister);</span>
 
 static int __init acpi_video_init(void)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Let the module load even if ACPI is disabled (e.g. due to</span>
<span class="p_add">+	 * a broken BIOS) so that i915.ko can still be loaded on such</span>
<span class="p_add">+	 * old systems without an AcpiOpRegion.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * acpi_video_register() will report -ENODEV later as well due</span>
<span class="p_add">+	 * to acpi_disabled when i915.ko tries to register itself afterwards.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (acpi_disabled)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	dmi_check_system(video_dmi_table);
 
 	if (intel_opregion_present())
<span class="p_header">diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c</span>
<span class="p_header">index 5fb6885..788581e 100644</span>
<span class="p_header">--- a/drivers/block/nbd.c</span>
<span class="p_header">+++ b/drivers/block/nbd.c</span>
<span class="p_chunk">@@ -773,10 +773,6 @@</span> <span class="p_context"> static int __init nbd_init(void)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL);</span>
<span class="p_del">-	if (!nbd_dev)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
 	part_shift = 0;
 	if (max_part &gt; 0) {
 		part_shift = fls(max_part);
<span class="p_chunk">@@ -798,6 +794,10 @@</span> <span class="p_context"> static int __init nbd_init(void)</span>
 	if (nbds_max &gt; 1UL &lt;&lt; (MINORBITS - part_shift))
 		return -EINVAL;
 
<span class="p_add">+	nbd_dev = kcalloc(nbds_max, sizeof(*nbd_dev), GFP_KERNEL);</span>
<span class="p_add">+	if (!nbd_dev)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; nbds_max; i++) {
 		struct gendisk *disk = alloc_disk(1 &lt;&lt; part_shift);
 		if (!disk)
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 22775ae..3eb6ad2 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -106,6 +106,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3393) },
 	{ USB_DEVICE(0x13d3, 0x3402) },
 	{ USB_DEVICE(0x13d3, 0x3408) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3423) },</span>
 	{ USB_DEVICE(0x13d3, 0x3432) },
 
 	/* Atheros AR5BBU12 with sflash firmware */
<span class="p_chunk">@@ -160,6 +161,7 @@</span> <span class="p_context"> static struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU22 with sflash firmware */
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 2b479d6..5c385e5 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -191,6 +191,7 @@</span> <span class="p_context"> static struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3393), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3402), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
 
 	/* Atheros AR5BBU12 with sflash firmware */
<span class="p_header">diff --git a/drivers/char/tpm/tpm.c b/drivers/char/tpm/tpm.c</span>
<span class="p_header">index c234b9e..f7395c4 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm.c</span>
<span class="p_chunk">@@ -1341,7 +1341,7 @@</span> <span class="p_context"> struct tpm_chip *tpm_register_hardware(struct device *dev,</span>
 
 	/* Make chip available */
 	spin_lock(&amp;driver_lock);
<span class="p_del">-	list_add_rcu(&amp;chip-&gt;list, &amp;tpm_chip_list);</span>
<span class="p_add">+	list_add_tail_rcu(&amp;chip-&gt;list, &amp;tpm_chip_list);</span>
 	spin_unlock(&amp;driver_lock);
 
 	return chip;
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index c68b8ad..e9d18aa 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -124,6 +124,7 @@</span> <span class="p_context"> struct ports_device {</span>
 	 * notification
 	 */
 	struct work_struct control_work;
<span class="p_add">+	struct work_struct config_work;</span>
 
 	struct list_head ports;
 
<span class="p_chunk">@@ -1556,10 +1557,21 @@</span> <span class="p_context"> static void config_intr(struct virtio_device *vdev)</span>
 
 	portdev = vdev-&gt;priv;
 
<span class="p_add">+	if (!use_multiport(portdev))</span>
<span class="p_add">+		schedule_work(&amp;portdev-&gt;config_work);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void config_work_handler(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ports_device *portdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	portdev = container_of(work, struct ports_device, control_work);</span>
 	if (!use_multiport(portdev)) {
<span class="p_add">+		struct virtio_device *vdev;</span>
 		struct port *port;
 		u16 rows, cols;
 
<span class="p_add">+		vdev = portdev-&gt;vdev;</span>
 		vdev-&gt;config-&gt;get(vdev,
 				  offsetof(struct virtio_console_config, cols),
 				  &amp;cols, sizeof(u16));
<span class="p_chunk">@@ -1731,6 +1743,8 @@</span> <span class="p_context"> static int __devinit virtcons_probe(struct virtio_device *vdev)</span>
 	spin_lock_init(&amp;portdev-&gt;ports_lock);
 	INIT_LIST_HEAD(&amp;portdev-&gt;ports);
 
<span class="p_add">+	INIT_WORK(&amp;portdev-&gt;config_work, &amp;config_work_handler);</span>
<span class="p_add">+</span>
 	if (multiport) {
 		unsigned int nr_added_bufs;
 
<span class="p_chunk">@@ -1806,6 +1820,8 @@</span> <span class="p_context"> static void virtcons_remove(struct virtio_device *vdev)</span>
 	/* Finish up work that&#39;s lined up */
 	if (use_multiport(portdev))
 		cancel_work_sync(&amp;portdev-&gt;control_work);
<span class="p_add">+	else</span>
<span class="p_add">+		cancel_work_sync(&amp;portdev-&gt;config_work);</span>
 
 	list_for_each_entry_safe(port, port2, &amp;portdev-&gt;ports, list)
 		unplug_port(port);
<span class="p_header">diff --git a/drivers/cpufreq/speedstep-lib.c b/drivers/cpufreq/speedstep-lib.c</span>
<span class="p_header">index 8af2d2f..2c0345a 100644</span>
<span class="p_header">--- a/drivers/cpufreq/speedstep-lib.c</span>
<span class="p_header">+++ b/drivers/cpufreq/speedstep-lib.c</span>
<span class="p_chunk">@@ -399,6 +399,7 @@</span> <span class="p_context"> unsigned int speedstep_get_freqs(enum speedstep_processor processor,</span>
 
 	pr_debug(&quot;previous speed is %u\n&quot;, prev_speed);
 
<span class="p_add">+	preempt_disable();</span>
 	local_irq_save(flags);
 
 	/* switch to low state */
<span class="p_chunk">@@ -463,6 +464,8 @@</span> <span class="p_context"> unsigned int speedstep_get_freqs(enum speedstep_processor processor,</span>
 
 out:
 	local_irq_restore(flags);
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+</span>
 	return ret;
 }
 EXPORT_SYMBOL_GPL(speedstep_get_freqs);
<span class="p_header">diff --git a/drivers/cpufreq/speedstep-smi.c b/drivers/cpufreq/speedstep-smi.c</span>
<span class="p_header">index c76ead3..8a97f94 100644</span>
<span class="p_header">--- a/drivers/cpufreq/speedstep-smi.c</span>
<span class="p_header">+++ b/drivers/cpufreq/speedstep-smi.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static void speedstep_set_state(unsigned int state)</span>
 		return;
 
 	/* Disable IRQs */
<span class="p_add">+	preempt_disable();</span>
 	local_irq_save(flags);
 
 	command = (smi_sig &amp; 0xffffff00) | (smi_cmd &amp; 0xff);
<span class="p_chunk">@@ -197,9 +198,19 @@</span> <span class="p_context"> static void speedstep_set_state(unsigned int state)</span>
 
 	do {
 		if (retry) {
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We need to enable interrupts, otherwise the blockage</span>
<span class="p_add">+			 * won&#39;t resolve.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * We disable preemption so that other processes don&#39;t</span>
<span class="p_add">+			 * run. If other processes were running, they could</span>
<span class="p_add">+			 * submit more DMA requests, making the blockage worse.</span>
<span class="p_add">+			 */</span>
 			pr_debug(&quot;retry %u, previous result %u, waiting...\n&quot;,
 					retry, result);
<span class="p_add">+			local_irq_enable();</span>
 			mdelay(retry * 50);
<span class="p_add">+			local_irq_disable();</span>
 		}
 		retry++;
 		__asm__ __volatile__(
<span class="p_chunk">@@ -216,6 +227,7 @@</span> <span class="p_context"> static void speedstep_set_state(unsigned int state)</span>
 
 	/* enable IRQs */
 	local_irq_restore(flags);
<span class="p_add">+	preempt_enable();</span>
 
 	if (new_state == state)
 		pr_debug(&quot;change to %u MHz succeeded after %u tries &quot;
<span class="p_header">diff --git a/drivers/gpio/gpio-tps65912.c b/drivers/gpio/gpio-tps65912.c</span>
<span class="p_header">index 79e66c0..2712680 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-tps65912.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-tps65912.c</span>
<span class="p_chunk">@@ -26,9 +26,12 @@</span> <span class="p_context"> struct tps65912_gpio_data {</span>
 	struct gpio_chip gpio_chip;
 };
 
<span class="p_add">+#define to_tgd(gc) container_of(gc, struct tps65912_gpio_data, gpio_chip)</span>
<span class="p_add">+</span>
 static int tps65912_gpio_get(struct gpio_chip *gc, unsigned offset)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 	int val;
 
 	val = tps65912_reg_read(tps65912, TPS65912_GPIO1 + offset);
<span class="p_chunk">@@ -42,7 +45,8 @@</span> <span class="p_context"> static int tps65912_gpio_get(struct gpio_chip *gc, unsigned offset)</span>
 static void tps65912_gpio_set(struct gpio_chip *gc, unsigned offset,
 			      int value)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 
 	if (value)
 		tps65912_set_bits(tps65912, TPS65912_GPIO1 + offset,
<span class="p_chunk">@@ -55,7 +59,8 @@</span> <span class="p_context"> static void tps65912_gpio_set(struct gpio_chip *gc, unsigned offset,</span>
 static int tps65912_gpio_output(struct gpio_chip *gc, unsigned offset,
 				int value)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 
 	/* Set the initial value */
 	tps65912_gpio_set(gc, offset, value);
<span class="p_chunk">@@ -66,7 +71,8 @@</span> <span class="p_context"> static int tps65912_gpio_output(struct gpio_chip *gc, unsigned offset,</span>
 
 static int tps65912_gpio_input(struct gpio_chip *gc, unsigned offset)
 {
<span class="p_del">-	struct tps65912 *tps65912 = container_of(gc, struct tps65912, gpio);</span>
<span class="p_add">+	struct tps65912_gpio_data *tps65912_gpio = to_tgd(gc);</span>
<span class="p_add">+	struct tps65912 *tps65912 = tps65912_gpio-&gt;tps65912;</span>
 
 	return tps65912_clear_bits(tps65912, TPS65912_GPIO1 + offset,
 								GPIO_CFG_MASK);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index e8a3c31..3e34f1e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -739,10 +739,8 @@</span> <span class="p_context"> static int radeon_dp_link_train_init(struct radeon_dp_link_train_info *dp_info)</span>
 		radeon_write_dpcd_reg(dp_info-&gt;radeon_connector,
 				      DP_DOWNSPREAD_CTRL, 0);
 
<span class="p_del">-	if ((dp_info-&gt;connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP) &amp;&amp;</span>
<span class="p_del">-	    (dig-&gt;panel_mode == DP_PANEL_MODE_INTERNAL_DP2_MODE)) {</span>
<span class="p_add">+	if (dig-&gt;panel_mode == DP_PANEL_MODE_INTERNAL_DP2_MODE)</span>
 		radeon_write_dpcd_reg(dp_info-&gt;radeon_connector, DP_EDP_CONFIGURATION_SET, 1);
<span class="p_del">-	}</span>
 
 	/* set the lane count on the sink */
 	tmp = dp_info-&gt;dp_lane_count;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">index 9b3f787..5d78973 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_chunk">@@ -2631,6 +2631,9 @@</span> <span class="p_context"> int evergreen_irq_set(struct radeon_device *rdev)</span>
 	WREG32(DC_HPD5_INT_CONTROL, hpd5);
 	WREG32(DC_HPD6_INT_CONTROL, hpd6);
 
<span class="p_add">+	/* posting read */</span>
<span class="p_add">+	RREG32(SRBM_STATUS);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r100.c b/drivers/gpu/drm/radeon/r100.c</span>
<span class="p_header">index 76c1290..dfd1267 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r100.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r100.c</span>
<span class="p_chunk">@@ -688,6 +688,10 @@</span> <span class="p_context"> int r100_irq_set(struct radeon_device *rdev)</span>
 		tmp |= RADEON_FP2_DETECT_MASK;
 	}
 	WREG32(RADEON_GEN_INT_CNTL, tmp);
<span class="p_add">+</span>
<span class="p_add">+	/* read back to post the write */</span>
<span class="p_add">+	RREG32(RADEON_GEN_INT_CNTL);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">index ab46a99..e5299a0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_chunk">@@ -3156,6 +3156,9 @@</span> <span class="p_context"> int r600_irq_set(struct radeon_device *rdev)</span>
 		WREG32(DC_HOT_PLUG_DETECT3_INT_CONTROL, hpd3);
 	}
 
<span class="p_add">+	/* posting read */</span>
<span class="p_add">+	RREG32(R_000E50_SRBM_STATUS);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_bios.c b/drivers/gpu/drm/radeon/radeon_bios.c</span>
<span class="p_header">index ccf324b..6e98703 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_bios.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static bool igp_read_bios_from_vram(struct radeon_device *rdev)</span>
 
 static bool radeon_read_bios(struct radeon_device *rdev)
 {
<span class="p_del">-	uint8_t __iomem *bios;</span>
<span class="p_add">+	uint8_t __iomem *bios, val1, val2;</span>
 	size_t size;
 
 	rdev-&gt;bios = NULL;
<span class="p_chunk">@@ -86,15 +86,19 @@</span> <span class="p_context"> static bool radeon_read_bios(struct radeon_device *rdev)</span>
 		return false;
 	}
 
<span class="p_del">-	if (size == 0 || bios[0] != 0x55 || bios[1] != 0xaa) {</span>
<span class="p_add">+	val1 = readb(&amp;bios[0]);</span>
<span class="p_add">+	val2 = readb(&amp;bios[1]);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size == 0 || val1 != 0x55 || val2 != 0xaa) {</span>
 		pci_unmap_rom(rdev-&gt;pdev, bios);
 		return false;
 	}
<span class="p_del">-	rdev-&gt;bios = kmemdup(bios, size, GFP_KERNEL);</span>
<span class="p_add">+	rdev-&gt;bios = kzalloc(size, GFP_KERNEL);</span>
 	if (rdev-&gt;bios == NULL) {
 		pci_unmap_rom(rdev-&gt;pdev, bios);
 		return false;
 	}
<span class="p_add">+	memcpy_fromio(rdev-&gt;bios, bios, size);</span>
 	pci_unmap_rom(rdev-&gt;pdev, bios);
 	return true;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">index 1f32557..0ddc08c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_chunk">@@ -95,11 +95,13 @@</span> <span class="p_context"> int radeon_cs_parser_init(struct radeon_cs_parser *p, void *data)</span>
 	uint64_t *chunk_array_ptr;
 	unsigned size, i, flags = 0;
 
<span class="p_add">+	INIT_LIST_HEAD(&amp;p-&gt;validated);</span>
<span class="p_add">+</span>
 	if (!cs-&gt;num_chunks) {
 		return 0;
 	}
<span class="p_add">+</span>
 	/* get chunks */
<span class="p_del">-	INIT_LIST_HEAD(&amp;p-&gt;validated);</span>
 	p-&gt;idx = 0;
 	p-&gt;chunk_ib_idx = -1;
 	p-&gt;chunk_relocs_idx = -1;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rs600.c b/drivers/gpu/drm/radeon/rs600.c</span>
<span class="p_header">index dc00155..fc37558 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rs600.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rs600.c</span>
<span class="p_chunk">@@ -576,6 +576,10 @@</span> <span class="p_context"> int rs600_irq_set(struct radeon_device *rdev)</span>
 	WREG32(R_006540_DxMODE_INT_MASK, mode_int);
 	WREG32(R_007D08_DC_HOT_PLUG_DETECT1_INT_CONTROL, hpd1);
 	WREG32(R_007D18_DC_HOT_PLUG_DETECT2_INT_CONTROL, hpd2);
<span class="p_add">+</span>
<span class="p_add">+	/* posting read */</span>
<span class="p_add">+	RREG32(R_000040_GEN_INT_CNTL);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">index b639536..f739fcf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_chunk">@@ -503,21 +503,6 @@</span> <span class="p_context"> static int vmw_driver_load(struct drm_device *dev, unsigned long chipset)</span>
 		goto out_err1;
 	}
 
<span class="p_del">-	ret = ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM,</span>
<span class="p_del">-			     (dev_priv-&gt;vram_size &gt;&gt; PAGE_SHIFT));</span>
<span class="p_del">-	if (unlikely(ret != 0)) {</span>
<span class="p_del">-		DRM_ERROR(&quot;Failed initializing memory manager for VRAM.\n&quot;);</span>
<span class="p_del">-		goto out_err2;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_priv-&gt;has_gmr = true;</span>
<span class="p_del">-	if (ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR,</span>
<span class="p_del">-			   dev_priv-&gt;max_gmr_ids) != 0) {</span>
<span class="p_del">-		DRM_INFO(&quot;No GMR memory available. &quot;</span>
<span class="p_del">-			 &quot;Graphics memory resources are very limited.\n&quot;);</span>
<span class="p_del">-		dev_priv-&gt;has_gmr = false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	dev_priv-&gt;mmio_mtrr = drm_mtrr_add(dev_priv-&gt;mmio_start,
 					   dev_priv-&gt;mmio_size, DRM_MTRR_WC);
 
<span class="p_chunk">@@ -570,6 +555,22 @@</span> <span class="p_context"> static int vmw_driver_load(struct drm_device *dev, unsigned long chipset)</span>
 	if (unlikely(dev_priv-&gt;fman == NULL))
 		goto out_no_fman;
 
<span class="p_add">+</span>
<span class="p_add">+	ret = ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM,</span>
<span class="p_add">+			     (dev_priv-&gt;vram_size &gt;&gt; PAGE_SHIFT));</span>
<span class="p_add">+	if (unlikely(ret != 0)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;Failed initializing memory manager for VRAM.\n&quot;);</span>
<span class="p_add">+		goto out_no_vram;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_priv-&gt;has_gmr = true;</span>
<span class="p_add">+	if (ttm_bo_init_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR,</span>
<span class="p_add">+			   dev_priv-&gt;max_gmr_ids) != 0) {</span>
<span class="p_add">+		DRM_INFO(&quot;No GMR memory available. &quot;</span>
<span class="p_add">+			 &quot;Graphics memory resources are very limited.\n&quot;);</span>
<span class="p_add">+		dev_priv-&gt;has_gmr = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Need to start the fifo to check if we can do screen objects */
 	ret = vmw_3d_resource_inc(dev_priv, true);
 	if (unlikely(ret != 0))
<span class="p_chunk">@@ -620,6 +621,10 @@</span> <span class="p_context"> out_no_kms:</span>
 		vmw_3d_resource_dec(dev_priv, false);
 	}
 out_no_fifo:
<span class="p_add">+	if (dev_priv-&gt;has_gmr)</span>
<span class="p_add">+		(void) ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_add">+	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
<span class="p_add">+out_no_vram:</span>
 	vmw_fence_manager_takedown(dev_priv-&gt;fman);
 out_no_fman:
 	if (dev_priv-&gt;stealth)
<span class="p_chunk">@@ -633,10 +638,6 @@</span> <span class="p_context"> out_err4:</span>
 out_err3:
 	drm_mtrr_del(dev_priv-&gt;mmio_mtrr, dev_priv-&gt;mmio_start,
 		     dev_priv-&gt;mmio_size, DRM_MTRR_WC);
<span class="p_del">-	if (dev_priv-&gt;has_gmr)</span>
<span class="p_del">-		(void) ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_del">-	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
<span class="p_del">-out_err2:</span>
 	(void)ttm_bo_device_release(&amp;dev_priv-&gt;bdev);
 out_err1:
 	vmw_ttm_global_release(dev_priv);
<span class="p_chunk">@@ -665,6 +666,11 @@</span> <span class="p_context"> static int vmw_driver_unload(struct drm_device *dev)</span>
 	}
 	vmw_kms_close(dev_priv);
 	vmw_overlay_close(dev_priv);
<span class="p_add">+</span>
<span class="p_add">+	if (dev_priv-&gt;has_gmr)</span>
<span class="p_add">+		(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_add">+	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
<span class="p_add">+</span>
 	vmw_fence_manager_takedown(dev_priv-&gt;fman);
 	if (dev_priv-&gt;stealth)
 		pci_release_region(dev-&gt;pdev, 2);
<span class="p_chunk">@@ -675,9 +681,6 @@</span> <span class="p_context"> static int vmw_driver_unload(struct drm_device *dev)</span>
 	iounmap(dev_priv-&gt;mmio_virt);
 	drm_mtrr_del(dev_priv-&gt;mmio_mtrr, dev_priv-&gt;mmio_start,
 		     dev_priv-&gt;mmio_size, DRM_MTRR_WC);
<span class="p_del">-	if (dev_priv-&gt;has_gmr)</span>
<span class="p_del">-		(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, VMW_PL_GMR);</span>
<span class="p_del">-	(void)ttm_bo_clean_mm(&amp;dev_priv-&gt;bdev, TTM_PL_VRAM);</span>
 	(void)ttm_bo_device_release(&amp;dev_priv-&gt;bdev);
 	vmw_ttm_global_release(dev_priv);
 	idr_destroy(&amp;dev_priv-&gt;surface_idr);
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index a841123..055ebeb 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,6 +94,14 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the combination of the addr and size requested for this memory</span>
<span class="p_add">+	 * region causes an integer overflow, return error.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((PAGE_ALIGN(addr + size) &lt;= size) ||</span>
<span class="p_add">+	    (PAGE_ALIGN(addr + size) &lt;= addr))</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	if (!can_do_mlock())
 		return ERR_PTR(-EPERM);
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 8796367..9379b97 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -451,6 +451,7 @@</span> <span class="p_context"> static void ib_uverbs_async_handler(struct ib_uverbs_file *file,</span>
 
 	entry-&gt;desc.async.element    = element;
 	entry-&gt;desc.async.event_type = event;
<span class="p_add">+	entry-&gt;desc.async.reserved   = 0;</span>
 	entry-&gt;counter               = counter;
 
 	list_add_tail(&amp;entry-&gt;list, &amp;file-&gt;async_file-&gt;event_list);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 77702c0..46b291e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -44,6 +44,14 @@</span> <span class="p_context"> enum {</span>
 	MLX4_IB_VENDOR_CLASS2 = 0xa
 };
 
<span class="p_add">+/* Counters should be saturate once they reach their maximum value */</span>
<span class="p_add">+#define ASSIGN_32BIT_COUNTER(counter, value) do {\</span>
<span class="p_add">+	if ((value) &gt; (u32)~0U)			 \</span>
<span class="p_add">+		counter = cpu_to_be32((u32)~0U); \</span>
<span class="p_add">+	else					 \</span>
<span class="p_add">+		counter = cpu_to_be32(value);	 \</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
 int mlx4_MAD_IFC(struct mlx4_ib_dev *dev, int ignore_mkey, int ignore_bkey,
 		 int port, struct ib_wc *in_wc, struct ib_grh *in_grh,
 		 void *in_mad, void *response_mad)
<span class="p_chunk">@@ -303,10 +311,14 @@</span> <span class="p_context"> static int ib_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,</span>
 static void edit_counter(struct mlx4_counter *cnt,
 					struct ib_pma_portcounters *pma_cnt)
 {
<span class="p_del">-	pma_cnt-&gt;port_xmit_data = cpu_to_be32((be64_to_cpu(cnt-&gt;tx_bytes)&gt;&gt;2));</span>
<span class="p_del">-	pma_cnt-&gt;port_rcv_data  = cpu_to_be32((be64_to_cpu(cnt-&gt;rx_bytes)&gt;&gt;2));</span>
<span class="p_del">-	pma_cnt-&gt;port_xmit_packets = cpu_to_be32(be64_to_cpu(cnt-&gt;tx_frames));</span>
<span class="p_del">-	pma_cnt-&gt;port_rcv_packets  = cpu_to_be32(be64_to_cpu(cnt-&gt;rx_frames));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_xmit_data,</span>
<span class="p_add">+			     (be64_to_cpu(cnt-&gt;tx_bytes) &gt;&gt; 2));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_rcv_data,</span>
<span class="p_add">+			     (be64_to_cpu(cnt-&gt;rx_bytes) &gt;&gt; 2));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_xmit_packets,</span>
<span class="p_add">+			     be64_to_cpu(cnt-&gt;tx_frames));</span>
<span class="p_add">+	ASSIGN_32BIT_COUNTER(pma_cnt-&gt;port_rcv_packets,</span>
<span class="p_add">+			     be64_to_cpu(cnt-&gt;rx_frames));</span>
 }
 
 static int iboe_process_mad(struct ib_device *ibdev, int mad_flags, u8 port_num,
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">index b881bdc..4c2b079 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_chunk">@@ -1005,12 +1005,6 @@</span> <span class="p_context"> struct qib_devdata {</span>
 	/* control high-level access to EEPROM */
 	struct mutex eep_lock;
 	uint64_t traffic_wds;
<span class="p_del">-	/* active time is kept in seconds, but logged in hours */</span>
<span class="p_del">-	atomic_t active_time;</span>
<span class="p_del">-	/* Below are nominal shadow of EEPROM, new since last EEPROM update */</span>
<span class="p_del">-	uint8_t eep_st_errs[QIB_EEP_LOG_CNT];</span>
<span class="p_del">-	uint8_t eep_st_new_errs[QIB_EEP_LOG_CNT];</span>
<span class="p_del">-	uint16_t eep_hrs;</span>
 	/*
 	 * masks for which bits of errs, hwerrs that cause
 	 * each of the counters to increment.
<span class="p_chunk">@@ -1227,8 +1221,7 @@</span> <span class="p_context"> int qib_twsi_blk_rd(struct qib_devdata *dd, int dev, int addr, void *buffer,</span>
 int qib_twsi_blk_wr(struct qib_devdata *dd, int dev, int addr,
 		    const void *buffer, int len);
 void qib_get_eeprom_info(struct qib_devdata *);
<span class="p_del">-int qib_update_eeprom_log(struct qib_devdata *dd);</span>
<span class="p_del">-void qib_inc_eeprom_err(struct qib_devdata *dd, u32 eidx, u32 incr);</span>
<span class="p_add">+#define qib_inc_eeprom_err(dd, eidx, incr)</span>
 void qib_dump_lookup_output_queue(struct qib_devdata *);
 void qib_force_pio_avail_update(struct qib_devdata *);
 void qib_clear_symerror_on_linkup(unsigned long opaque);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_eeprom.c b/drivers/infiniband/hw/qib/qib_eeprom.c</span>
<span class="p_header">index 92d9cfe..6359c2f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_eeprom.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_eeprom.c</span>
<span class="p_chunk">@@ -263,189 +263,9 @@</span> <span class="p_context"> void qib_get_eeprom_info(struct qib_devdata *dd)</span>
 		qib_dev_err(dd, &quot;Board SN %s did not pass functional &quot;
 			    &quot;test: %s\n&quot;, dd-&gt;serial, ifp-&gt;if_comment);
 
<span class="p_del">-	memcpy(&amp;dd-&gt;eep_st_errs, &amp;ifp-&gt;if_errcntp, QIB_EEP_LOG_CNT);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Power-on (actually &quot;active&quot;) hours are kept as little-endian value</span>
<span class="p_del">-	 * in EEPROM, but as seconds in a (possibly as small as 24-bit)</span>
<span class="p_del">-	 * atomic_t while running.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	atomic_set(&amp;dd-&gt;active_time, 0);</span>
<span class="p_del">-	dd-&gt;eep_hrs = ifp-&gt;if_powerhour[0] | (ifp-&gt;if_powerhour[1] &lt;&lt; 8);</span>
<span class="p_del">-</span>
 done:
 	vfree(buf);
 
 bail:;
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * qib_update_eeprom_log - copy active-time and error counters to eeprom</span>
<span class="p_del">- * @dd: the qlogic_ib device</span>
<span class="p_del">- *</span>
<span class="p_del">- * Although the time is kept as seconds in the qib_devdata struct, it is</span>
<span class="p_del">- * rounded to hours for re-write, as we have only 16 bits in EEPROM.</span>
<span class="p_del">- * First-cut code reads whole (expected) struct qib_flash, modifies,</span>
<span class="p_del">- * re-writes. Future direction: read/write only what we need, assuming</span>
<span class="p_del">- * that the EEPROM had to have been &quot;good enough&quot; for driver init, and</span>
<span class="p_del">- * if not, we aren&#39;t making it worse.</span>
<span class="p_del">- *</span>
<span class="p_del">- */</span>
<span class="p_del">-int qib_update_eeprom_log(struct qib_devdata *dd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *buf;</span>
<span class="p_del">-	struct qib_flash *ifp;</span>
<span class="p_del">-	int len, hi_water;</span>
<span class="p_del">-	uint32_t new_time, new_hrs;</span>
<span class="p_del">-	u8 csum;</span>
<span class="p_del">-	int ret, idx;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* first, check if we actually need to do anything. */</span>
<span class="p_del">-	ret = 0;</span>
<span class="p_del">-	for (idx = 0; idx &lt; QIB_EEP_LOG_CNT; ++idx) {</span>
<span class="p_del">-		if (dd-&gt;eep_st_new_errs[idx]) {</span>
<span class="p_del">-			ret = 1;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	new_time = atomic_read(&amp;dd-&gt;active_time);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret == 0 &amp;&amp; new_time &lt; 3600)</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The quick-check above determined that there is something worthy</span>
<span class="p_del">-	 * of logging, so get current contents and do a more detailed idea.</span>
<span class="p_del">-	 * read full flash, not just currently used part, since it may have</span>
<span class="p_del">-	 * been written with a newer definition</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	len = sizeof(struct qib_flash);</span>
<span class="p_del">-	buf = vmalloc(len);</span>
<span class="p_del">-	ret = 1;</span>
<span class="p_del">-	if (!buf) {</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Couldn&#39;t allocate memory to read %u &quot;</span>
<span class="p_del">-			    &quot;bytes from eeprom for logging\n&quot;, len);</span>
<span class="p_del">-		goto bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Grab semaphore and read current EEPROM. If we get an</span>
<span class="p_del">-	 * error, let go, but if not, keep it until we finish write.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = mutex_lock_interruptible(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Unable to acquire EEPROM for logging\n&quot;);</span>
<span class="p_del">-		goto free_bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	ret = qib_twsi_blk_rd(dd, dd-&gt;twsi_eeprom_dev, 0, buf, len);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		mutex_unlock(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Unable read EEPROM for logging\n&quot;);</span>
<span class="p_del">-		goto free_bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	ifp = (struct qib_flash *)buf;</span>
<span class="p_del">-</span>
<span class="p_del">-	csum = flash_csum(ifp, 0);</span>
<span class="p_del">-	if (csum != ifp-&gt;if_csum) {</span>
<span class="p_del">-		mutex_unlock(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-		qib_dev_err(dd, &quot;EEPROM cks err (0x%02X, S/B 0x%02X)\n&quot;,</span>
<span class="p_del">-			    csum, ifp-&gt;if_csum);</span>
<span class="p_del">-		ret = 1;</span>
<span class="p_del">-		goto free_bail;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	hi_water = 0;</span>
<span class="p_del">-	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-	for (idx = 0; idx &lt; QIB_EEP_LOG_CNT; ++idx) {</span>
<span class="p_del">-		int new_val = dd-&gt;eep_st_new_errs[idx];</span>
<span class="p_del">-		if (new_val) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * If we have seen any errors, add to EEPROM values</span>
<span class="p_del">-			 * We need to saturate at 0xFF (255) and we also</span>
<span class="p_del">-			 * would need to adjust the checksum if we were</span>
<span class="p_del">-			 * trying to minimize EEPROM traffic</span>
<span class="p_del">-			 * Note that we add to actual current count in EEPROM,</span>
<span class="p_del">-			 * in case it was altered while we were running.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			new_val += ifp-&gt;if_errcntp[idx];</span>
<span class="p_del">-			if (new_val &gt; 0xFF)</span>
<span class="p_del">-				new_val = 0xFF;</span>
<span class="p_del">-			if (ifp-&gt;if_errcntp[idx] != new_val) {</span>
<span class="p_del">-				ifp-&gt;if_errcntp[idx] = new_val;</span>
<span class="p_del">-				hi_water = offsetof(struct qib_flash,</span>
<span class="p_del">-						    if_errcntp) + idx;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * update our shadow (used to minimize EEPROM</span>
<span class="p_del">-			 * traffic), to match what we are about to write.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			dd-&gt;eep_st_errs[idx] = new_val;</span>
<span class="p_del">-			dd-&gt;eep_st_new_errs[idx] = 0;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now update active-time. We would like to round to the nearest hour</span>
<span class="p_del">-	 * but unless atomic_t are sure to be proper signed ints we cannot,</span>
<span class="p_del">-	 * because we need to account for what we &quot;transfer&quot; to EEPROM and</span>
<span class="p_del">-	 * if we log an hour at 31 minutes, then we would need to set</span>
<span class="p_del">-	 * active_time to -29 to accurately count the _next_ hour.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (new_time &gt;= 3600) {</span>
<span class="p_del">-		new_hrs = new_time / 3600;</span>
<span class="p_del">-		atomic_sub((new_hrs * 3600), &amp;dd-&gt;active_time);</span>
<span class="p_del">-		new_hrs += dd-&gt;eep_hrs;</span>
<span class="p_del">-		if (new_hrs &gt; 0xFFFF)</span>
<span class="p_del">-			new_hrs = 0xFFFF;</span>
<span class="p_del">-		dd-&gt;eep_hrs = new_hrs;</span>
<span class="p_del">-		if ((new_hrs &amp; 0xFF) != ifp-&gt;if_powerhour[0]) {</span>
<span class="p_del">-			ifp-&gt;if_powerhour[0] = new_hrs &amp; 0xFF;</span>
<span class="p_del">-			hi_water = offsetof(struct qib_flash, if_powerhour);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if ((new_hrs &gt;&gt; 8) != ifp-&gt;if_powerhour[1]) {</span>
<span class="p_del">-			ifp-&gt;if_powerhour[1] = new_hrs &gt;&gt; 8;</span>
<span class="p_del">-			hi_water = offsetof(struct qib_flash, if_powerhour) + 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There is a tiny possibility that we could somehow fail to write</span>
<span class="p_del">-	 * the EEPROM after updating our shadows, but problems from holding</span>
<span class="p_del">-	 * the spinlock too long are a much bigger issue.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-	if (hi_water) {</span>
<span class="p_del">-		/* we made some change to the data, uopdate cksum and write */</span>
<span class="p_del">-		csum = flash_csum(ifp, 1);</span>
<span class="p_del">-		ret = eeprom_write_with_enable(dd, 0, buf, hi_water + 1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mutex_unlock(&amp;dd-&gt;eep_lock);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		qib_dev_err(dd, &quot;Failed updating EEPROM\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-free_bail:</span>
<span class="p_del">-	vfree(buf);</span>
<span class="p_del">-bail:</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * qib_inc_eeprom_err - increment one of the four error counters</span>
<span class="p_del">- * that are logged to EEPROM.</span>
<span class="p_del">- * @dd: the qlogic_ib device</span>
<span class="p_del">- * @eidx: 0..3, the counter to increment</span>
<span class="p_del">- * @incr: how much to add</span>
<span class="p_del">- *</span>
<span class="p_del">- * Each counter is 8-bits, and saturates at 255 (0xFF). They</span>
<span class="p_del">- * are copied to the EEPROM (aka flash) whenever qib_update_eeprom_log()</span>
<span class="p_del">- * is called, but it can only be called in a context that allows sleep.</span>
<span class="p_del">- * This function can be called even at interrupt level.</span>
<span class="p_del">- */</span>
<span class="p_del">-void qib_inc_eeprom_err(struct qib_devdata *dd, u32 eidx, u32 incr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	uint new_val;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-	new_val = dd-&gt;eep_st_new_errs[eidx] + incr;</span>
<span class="p_del">-	if (new_val &gt; 255)</span>
<span class="p_del">-		new_val = 255;</span>
<span class="p_del">-	dd-&gt;eep_st_new_errs[eidx] = new_val;</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba6120.c b/drivers/infiniband/hw/qib/qib_iba6120.c</span>
<span class="p_header">index 4f18e2d..2a0f7de 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba6120.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba6120.c</span>
<span class="p_chunk">@@ -2674,8 +2674,6 @@</span> <span class="p_context"> static void qib_get_6120_faststats(unsigned long opaque)</span>
 	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);
 	traffic_wds -= dd-&gt;traffic_wds;
 	dd-&gt;traffic_wds += traffic_wds;
<span class="p_del">-	if (traffic_wds  &gt;= QIB_TRAFFIC_ACTIVE_THRESHOLD)</span>
<span class="p_del">-		atomic_add(5, &amp;dd-&gt;active_time); /* S/B #define */</span>
 	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);
 
 	qib_chk_6120_errormask(dd);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba7220.c b/drivers/infiniband/hw/qib/qib_iba7220.c</span>
<span class="p_header">index 7ec4048..4dc04e3 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba7220.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba7220.c</span>
<span class="p_chunk">@@ -3292,8 +3292,6 @@</span> <span class="p_context"> static void qib_get_7220_faststats(unsigned long opaque)</span>
 	spin_lock_irqsave(&amp;dd-&gt;eep_st_lock, flags);
 	traffic_wds -= dd-&gt;traffic_wds;
 	dd-&gt;traffic_wds += traffic_wds;
<span class="p_del">-	if (traffic_wds  &gt;= QIB_TRAFFIC_ACTIVE_THRESHOLD)</span>
<span class="p_del">-		atomic_add(5, &amp;dd-&gt;active_time); /* S/B #define */</span>
 	spin_unlock_irqrestore(&amp;dd-&gt;eep_st_lock, flags);
 done:
 	mod_timer(&amp;dd-&gt;stats_timer, jiffies + HZ * ACTIVITY_TIMER);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">index d8517fc..44180c6 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_chunk">@@ -4793,8 +4793,6 @@</span> <span class="p_context"> static void qib_get_7322_faststats(unsigned long opaque)</span>
 		spin_lock_irqsave(&amp;ppd-&gt;dd-&gt;eep_st_lock, flags);
 		traffic_wds -= ppd-&gt;dd-&gt;traffic_wds;
 		ppd-&gt;dd-&gt;traffic_wds += traffic_wds;
<span class="p_del">-		if (traffic_wds &gt;= QIB_TRAFFIC_ACTIVE_THRESHOLD)</span>
<span class="p_del">-			atomic_add(ACTIVITY_TIMER, &amp;ppd-&gt;dd-&gt;active_time);</span>
 		spin_unlock_irqrestore(&amp;ppd-&gt;dd-&gt;eep_st_lock, flags);
 		if (ppd-&gt;cpspec-&gt;qdr_dfe_on &amp;&amp; (ppd-&gt;link_speed_active &amp;
 						QIB_IB_QDR) &amp;&amp;
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_init.c b/drivers/infiniband/hw/qib/qib_init.c</span>
<span class="p_header">index 58b0f8a..9966ec2 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_init.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_init.c</span>
<span class="p_chunk">@@ -765,7 +765,6 @@</span> <span class="p_context"> static void qib_shutdown_device(struct qib_devdata *dd)</span>
 		dd-&gt;f_quiet_serdes(ppd);
 	}
 
<span class="p_del">-	qib_update_eeprom_log(dd);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_sysfs.c b/drivers/infiniband/hw/qib/qib_sysfs.c</span>
<span class="p_header">index 78fbd56..c97224a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_sysfs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_sysfs.c</span>
<span class="p_chunk">@@ -550,28 +550,6 @@</span> <span class="p_context"> bail:</span>
 	return ret &lt; 0 ? ret : count;
 }
 
<span class="p_del">-static ssize_t show_logged_errs(struct device *device,</span>
<span class="p_del">-				struct device_attribute *attr, char *buf)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct qib_ibdev *dev =</span>
<span class="p_del">-		container_of(device, struct qib_ibdev, ibdev.dev);</span>
<span class="p_del">-	struct qib_devdata *dd = dd_from_dev(dev);</span>
<span class="p_del">-	int idx, count;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* force consistency with actual EEPROM */</span>
<span class="p_del">-	if (qib_update_eeprom_log(dd) != 0)</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	count = 0;</span>
<span class="p_del">-	for (idx = 0; idx &lt; QIB_EEP_LOG_CNT; ++idx) {</span>
<span class="p_del">-		count += scnprintf(buf + count, PAGE_SIZE - count, &quot;%d%c&quot;,</span>
<span class="p_del">-				   dd-&gt;eep_st_errs[idx],</span>
<span class="p_del">-				   idx == (QIB_EEP_LOG_CNT - 1) ? &#39;\n&#39; : &#39; &#39;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return count;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Dump tempsense regs. in decimal, to ease shell-scripts.
  */
<span class="p_chunk">@@ -618,7 +596,6 @@</span> <span class="p_context"> static DEVICE_ATTR(nctxts, S_IRUGO, show_nctxts, NULL);</span>
 static DEVICE_ATTR(nfreectxts, S_IRUGO, show_nfreectxts, NULL);
 static DEVICE_ATTR(serial, S_IRUGO, show_serial, NULL);
 static DEVICE_ATTR(boardversion, S_IRUGO, show_boardversion, NULL);
<span class="p_del">-static DEVICE_ATTR(logged_errors, S_IRUGO, show_logged_errs, NULL);</span>
 static DEVICE_ATTR(tempsense, S_IRUGO, show_tempsense, NULL);
 static DEVICE_ATTR(localbus_info, S_IRUGO, show_localbus_info, NULL);
 static DEVICE_ATTR(chip_reset, S_IWUSR, NULL, store_chip_reset);
<span class="p_chunk">@@ -632,7 +609,6 @@</span> <span class="p_context"> static struct device_attribute *qib_attributes[] = {</span>
 	&amp;dev_attr_nfreectxts,
 	&amp;dev_attr_serial,
 	&amp;dev_attr_boardversion,
<span class="p_del">-	&amp;dev_attr_logged_errors,</span>
 	&amp;dev_attr_tempsense,
 	&amp;dev_attr_localbus_info,
 	&amp;dev_attr_chip_reset,
<span class="p_header">diff --git a/drivers/input/mouse/synaptics.c b/drivers/input/mouse/synaptics.c</span>
<span class="p_header">index bb41f94..91e94ad 100644</span>
<span class="p_header">--- a/drivers/input/mouse/synaptics.c</span>
<span class="p_header">+++ b/drivers/input/mouse/synaptics.c</span>
<span class="p_chunk">@@ -274,8 +274,14 @@</span> <span class="p_context"> static int synaptics_resolution(struct psmouse *psmouse)</span>
 		}
 	}
 
<span class="p_del">-	if (SYN_EXT_CAP_REQUESTS(priv-&gt;capabilities) &gt;= 7 &amp;&amp;</span>
<span class="p_del">-	    SYN_CAP_MIN_DIMENSIONS(priv-&gt;ext_cap_0c)) {</span>
<span class="p_add">+	if (SYN_CAP_MIN_DIMENSIONS(priv-&gt;ext_cap_0c) &amp;&amp;</span>
<span class="p_add">+	    (SYN_EXT_CAP_REQUESTS(priv-&gt;capabilities) &gt;= 7 ||</span>
<span class="p_add">+	     /*</span>
<span class="p_add">+	      * Firmware v8.1 does not report proper number of extended</span>
<span class="p_add">+	      * capabilities, but has been proven to report correct min</span>
<span class="p_add">+	      * coordinates.</span>
<span class="p_add">+	      */</span>
<span class="p_add">+	     SYN_ID_FULL(priv-&gt;identity) == 0x801)) {</span>
 		if (synaptics_send_cmd(psmouse, SYN_QUE_EXT_MIN_COORDS, resp)) {
 			psmouse_warn(psmouse,
 				     &quot;device claims to have min coordinates query, but I&#39;m not able to read it.\n&quot;);
<span class="p_chunk">@@ -495,6 +501,18 @@</span> <span class="p_context"> static void synaptics_parse_agm(const unsigned char buf[],</span>
 	priv-&gt;agm_pending = true;
 }
 
<span class="p_add">+static void synaptics_parse_ext_buttons(const unsigned char buf[],</span>
<span class="p_add">+					struct synaptics_data *priv,</span>
<span class="p_add">+					struct synaptics_hw_state *hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int ext_bits =</span>
<span class="p_add">+		(SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) + 1) &gt;&gt; 1;</span>
<span class="p_add">+	unsigned int ext_mask = (1U &lt;&lt; ext_bits) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	hw-&gt;ext_buttons = buf[4] &amp; ext_mask;</span>
<span class="p_add">+	hw-&gt;ext_buttons |= (buf[5] &amp; ext_mask) &lt;&lt; ext_bits;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool is_forcepad;
 
 static int synaptics_parse_hw_state(const unsigned char buf[],
<span class="p_chunk">@@ -581,28 +599,9 @@</span> <span class="p_context"> static int synaptics_parse_hw_state(const unsigned char buf[],</span>
 			hw-&gt;down = ((buf[0] ^ buf[3]) &amp; 0x02) ? 1 : 0;
 		}
 
<span class="p_del">-		if (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) &amp;&amp;</span>
<span class="p_add">+		if (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) &gt; 0 &amp;&amp;</span>
 		    ((buf[0] ^ buf[3]) &amp; 0x02)) {
<span class="p_del">-			switch (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) &amp; ~0x01) {</span>
<span class="p_del">-			default:</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * if nExtBtn is greater than 8 it should be</span>
<span class="p_del">-				 * considered invalid and treated as 0</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 8:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x08)) ? 0x80 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x08)) ? 0x40 : 0;</span>
<span class="p_del">-			case 6:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x04)) ? 0x20 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x04)) ? 0x10 : 0;</span>
<span class="p_del">-			case 4:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x02)) ? 0x08 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x02)) ? 0x04 : 0;</span>
<span class="p_del">-			case 2:</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[5] &amp; 0x01)) ? 0x02 : 0;</span>
<span class="p_del">-				hw-&gt;ext_buttons |= ((buf[4] &amp; 0x01)) ? 0x01 : 0;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			synaptics_parse_ext_buttons(buf, priv, hw);</span>
 		}
 	} else {
 		hw-&gt;x = (((buf[1] &amp; 0x1f) &lt;&lt; 8) | buf[2]);
<span class="p_chunk">@@ -664,12 +663,35 @@</span> <span class="p_context"> static void synaptics_report_semi_mt_data(struct input_dev *dev,</span>
 	}
 }
 
<span class="p_add">+static void synaptics_report_ext_buttons(struct psmouse *psmouse,</span>
<span class="p_add">+					 const struct synaptics_hw_state *hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct input_dev *dev = psmouse-&gt;dev;</span>
<span class="p_add">+	struct synaptics_data *priv = psmouse-&gt;private;</span>
<span class="p_add">+	int ext_bits = (SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap) + 1) &gt;&gt; 1;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Bug in FW 8.1, buttons are reported only when ExtBit is 1 */</span>
<span class="p_add">+	if (SYN_ID_FULL(priv-&gt;identity) == 0x801 &amp;&amp;</span>
<span class="p_add">+	    !((psmouse-&gt;packet[0] ^ psmouse-&gt;packet[3]) &amp; 0x02))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ext_bits; i++) {</span>
<span class="p_add">+		input_report_key(dev, BTN_0 + 2 * i,</span>
<span class="p_add">+			hw-&gt;ext_buttons &amp; (1 &lt;&lt; i));</span>
<span class="p_add">+		input_report_key(dev, BTN_1 + 2 * i,</span>
<span class="p_add">+			hw-&gt;ext_buttons &amp; (1 &lt;&lt; (i + ext_bits)));</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void synaptics_report_buttons(struct psmouse *psmouse,
 				     const struct synaptics_hw_state *hw)
 {
 	struct input_dev *dev = psmouse-&gt;dev;
 	struct synaptics_data *priv = psmouse-&gt;private;
<span class="p_del">-	int i;</span>
 
 	input_report_key(dev, BTN_LEFT, hw-&gt;left);
 	input_report_key(dev, BTN_RIGHT, hw-&gt;right);
<span class="p_chunk">@@ -682,8 +704,7 @@</span> <span class="p_context"> static void synaptics_report_buttons(struct psmouse *psmouse,</span>
 		input_report_key(dev, BTN_BACK, hw-&gt;down);
 	}
 
<span class="p_del">-	for (i = 0; i &lt; SYN_CAP_MULTI_BUTTON_NO(priv-&gt;ext_cap); i++)</span>
<span class="p_del">-		input_report_key(dev, BTN_0 + i, hw-&gt;ext_buttons &amp; (1 &lt;&lt; i));</span>
<span class="p_add">+	synaptics_report_ext_buttons(psmouse, hw);</span>
 }
 
 static void synaptics_report_slot(struct input_dev *dev, int slot,
<span class="p_header">diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c</span>
<span class="p_header">index 39a08be..b8ed01b 100644</span>
<span class="p_header">--- a/drivers/md/dm-io.c</span>
<span class="p_header">+++ b/drivers/md/dm-io.c</span>
<span class="p_chunk">@@ -299,6 +299,16 @@</span> <span class="p_context"> static void do_region(int rw, unsigned region, struct dm_io_region *where,</span>
 	sector_t remaining = where-&gt;count;
 	struct request_queue *q = bdev_get_queue(where-&gt;bdev);
 	sector_t discard_sectors;
<span class="p_add">+	unsigned int uninitialized_var(special_cmd_max_sectors);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reject unsupported discard requests */</span>
<span class="p_add">+	if (rw &amp; REQ_DISCARD) {</span>
<span class="p_add">+		special_cmd_max_sectors = q-&gt;limits.max_discard_sectors;</span>
<span class="p_add">+		if (special_cmd_max_sectors == 0) {</span>
<span class="p_add">+			dec_count(io, region, -EOPNOTSUPP);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * where-&gt;count may be zero if rw holds a flush and we need to
<span class="p_chunk">@@ -322,7 +332,7 @@</span> <span class="p_context"> static void do_region(int rw, unsigned region, struct dm_io_region *where,</span>
 		store_io_and_region_in_bio(bio, io, region);
 
 		if (rw &amp; REQ_DISCARD) {
<span class="p_del">-			discard_sectors = min_t(sector_t, q-&gt;limits.max_discard_sectors, remaining);</span>
<span class="p_add">+			discard_sectors = min_t(sector_t, special_cmd_max_sectors, remaining);</span>
 			bio-&gt;bi_size = discard_sectors &lt;&lt; SECTOR_SHIFT;
 			remaining -= discard_sectors;
 		} else while (remaining) {
<span class="p_header">diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c</span>
<span class="p_header">index b7b649d..b4361eb 100644</span>
<span class="p_header">--- a/drivers/md/dm-raid1.c</span>
<span class="p_header">+++ b/drivers/md/dm-raid1.c</span>
<span class="p_chunk">@@ -603,6 +603,15 @@</span> <span class="p_context"> static void write_callback(unsigned long error, void *context)</span>
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the bio is discard, return an error, but do not</span>
<span class="p_add">+	 * degrade the array.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bio-&gt;bi_rw &amp; REQ_DISCARD) {</span>
<span class="p_add">+		bio_endio(bio, -EOPNOTSUPP);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; ms-&gt;nr_mirrors; i++)
 		if (test_bit(i, &amp;error))
 			fail_mirror(ms-&gt;mirror + i, DM_RAID1_WRITE_ERROR);
<span class="p_header">diff --git a/drivers/md/dm-snap.c b/drivers/md/dm-snap.c</span>
<span class="p_header">index fec79e7..6b94c3c 100644</span>
<span class="p_header">--- a/drivers/md/dm-snap.c</span>
<span class="p_header">+++ b/drivers/md/dm-snap.c</span>
<span class="p_chunk">@@ -1444,8 +1444,6 @@</span> <span class="p_context"> out:</span>
 		full_bio-&gt;bi_end_io = pe-&gt;full_bio_end_io;
 		full_bio-&gt;bi_private = pe-&gt;full_bio_private;
 	}
<span class="p_del">-	free_pending_exception(pe);</span>
<span class="p_del">-</span>
 	increment_pending_exceptions_done_count();
 
 	up_write(&amp;s-&gt;lock);
<span class="p_chunk">@@ -1462,6 +1460,8 @@</span> <span class="p_context"> out:</span>
 	}
 
 	retry_origin_bios(s, origin_bios);
<span class="p_add">+</span>
<span class="p_add">+	free_pending_exception(pe);</span>
 }
 
 static void commit_callback(void *context, int success)
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 7ead065..c00bcdc 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -2232,7 +2232,7 @@</span> <span class="p_context"> int dm_setup_md_queue(struct mapped_device *md)</span>
 	return 0;
 }
 
<span class="p_del">-static struct mapped_device *dm_find_md(dev_t dev)</span>
<span class="p_add">+struct mapped_device *dm_get_md(dev_t dev)</span>
 {
 	struct mapped_device *md;
 	unsigned minor = MINOR(dev);
<span class="p_chunk">@@ -2243,12 +2243,15 @@</span> <span class="p_context"> static struct mapped_device *dm_find_md(dev_t dev)</span>
 	spin_lock(&amp;_minor_lock);
 
 	md = idr_find(&amp;_minor_idr, minor);
<span class="p_del">-	if (md &amp;&amp; (md == MINOR_ALLOCED ||</span>
<span class="p_del">-		   (MINOR(disk_devt(dm_disk(md))) != minor) ||</span>
<span class="p_del">-		   dm_deleting_md(md) ||</span>
<span class="p_del">-		   test_bit(DMF_FREEING, &amp;md-&gt;flags))) {</span>
<span class="p_del">-		md = NULL;</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	if (md) {</span>
<span class="p_add">+		if ((md == MINOR_ALLOCED ||</span>
<span class="p_add">+		     (MINOR(disk_devt(dm_disk(md))) != minor) ||</span>
<span class="p_add">+		     dm_deleting_md(md) ||</span>
<span class="p_add">+		     test_bit(DMF_FREEING, &amp;md-&gt;flags))) {</span>
<span class="p_add">+			md = NULL;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		dm_get(md);</span>
 	}
 
 out:
<span class="p_chunk">@@ -2256,16 +2259,6 @@</span> <span class="p_context"> out:</span>
 
 	return md;
 }
<span class="p_del">-</span>
<span class="p_del">-struct mapped_device *dm_get_md(dev_t dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mapped_device *md = dm_find_md(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (md)</span>
<span class="p_del">-		dm_get(md);</span>
<span class="p_del">-</span>
<span class="p_del">-	return md;</span>
<span class="p_del">-}</span>
 EXPORT_SYMBOL_GPL(dm_get_md);
 
 void *dm_get_mdptr(struct mapped_device *md)
<span class="p_chunk">@@ -2302,10 +2295,16 @@</span> <span class="p_context"> static void __dm_destroy(struct mapped_device *md, bool wait)</span>
 	set_bit(DMF_FREEING, &amp;md-&gt;flags);
 	spin_unlock(&amp;_minor_lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Take suspend_lock so that presuspend and postsuspend methods</span>
<span class="p_add">+	 * do not race with internal suspend.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock(&amp;md-&gt;suspend_lock);</span>
 	if (!dm_suspended_md(md)) {
 		dm_table_presuspend_targets(map);
 		dm_table_postsuspend_targets(map);
 	}
<span class="p_add">+	mutex_unlock(&amp;md-&gt;suspend_lock);</span>
 
 	/*
 	 * Rare, but there may be I/O requests still going to complete,
<span class="p_header">diff --git a/drivers/media/dvb/dvb-usb/lmedm04.c b/drivers/media/dvb/dvb-usb/lmedm04.c</span>
<span class="p_header">index b922824..c7ad854 100644</span>
<span class="p_header">--- a/drivers/media/dvb/dvb-usb/lmedm04.c</span>
<span class="p_header">+++ b/drivers/media/dvb/dvb-usb/lmedm04.c</span>
<span class="p_chunk">@@ -326,7 +326,9 @@</span> <span class="p_context"> static void lme2510_int_response(struct urb *lme_urb)</span>
 
 static int lme2510_int_read(struct dvb_usb_adapter *adap)
 {
<span class="p_add">+	struct dvb_usb_device *d = adap-&gt;dev;</span>
 	struct lme2510_state *lme_int = adap-&gt;dev-&gt;priv;
<span class="p_add">+	struct usb_host_endpoint *ep;</span>
 
 	lme_int-&gt;lme_urb = usb_alloc_urb(0, GFP_ATOMIC);
 
<span class="p_chunk">@@ -348,6 +350,12 @@</span> <span class="p_context"> static int lme2510_int_read(struct dvb_usb_adapter *adap)</span>
 				adap,
 				8);
 
<span class="p_add">+	/* Quirk of pipe reporting PIPE_BULK but behaves as interrupt */</span>
<span class="p_add">+	ep = usb_pipe_endpoint(d-&gt;udev, lme_int-&gt;lme_urb-&gt;pipe);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (usb_endpoint_type(&amp;ep-&gt;desc) == USB_ENDPOINT_XFER_BULK)</span>
<span class="p_add">+		lme_int-&gt;lme_urb-&gt;pipe = usb_rcvbulkpipe(d-&gt;udev, 0xa),</span>
<span class="p_add">+</span>
 	lme_int-&gt;lme_urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
 
 	usb_submit_urb(lme_int-&gt;lme_urb, GFP_ATOMIC);
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index a25442e..db9100f 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -468,6 +468,11 @@</span> <span class="p_context"> struct sk_buff *alloc_can_skb(struct net_device *dev, struct can_frame **cf)</span>
 	skb-&gt;protocol = htons(ETH_P_CAN);
 	skb-&gt;pkt_type = PACKET_BROADCAST;
 	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;
<span class="p_add">+</span>
<span class="p_add">+	skb_reset_mac_header(skb);</span>
<span class="p_add">+	skb_reset_network_header(skb);</span>
<span class="p_add">+	skb_reset_transport_header(skb);</span>
<span class="p_add">+</span>
 	*cf = (struct can_frame *)skb_put(skb, sizeof(struct can_frame));
 	memset(*cf, 0, sizeof(struct can_frame));
 
<span class="p_header">diff --git a/drivers/net/ethernet/amd/pcnet32.c b/drivers/net/ethernet/amd/pcnet32.c</span>
<span class="p_header">index f92bc6e..c664abb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/pcnet32.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/pcnet32.c</span>
<span class="p_chunk">@@ -1524,7 +1524,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 {
 	struct pcnet32_private *lp;
 	int i, media;
<span class="p_del">-	int fdx, mii, fset, dxsuflo;</span>
<span class="p_add">+	int fdx, mii, fset, dxsuflo, sram;</span>
 	int chip_version;
 	char *chipname;
 	struct net_device *dev;
<span class="p_chunk">@@ -1561,7 +1561,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 	}
 
 	/* initialize variables */
<span class="p_del">-	fdx = mii = fset = dxsuflo = 0;</span>
<span class="p_add">+	fdx = mii = fset = dxsuflo = sram = 0;</span>
 	chip_version = (chip_version &gt;&gt; 12) &amp; 0xffff;
 
 	switch (chip_version) {
<span class="p_chunk">@@ -1594,6 +1594,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 		chipname = &quot;PCnet/FAST III 79C973&quot;;	/* PCI */
 		fdx = 1;
 		mii = 1;
<span class="p_add">+		sram = 1;</span>
 		break;
 	case 0x2626:
 		chipname = &quot;PCnet/Home 79C978&quot;;	/* PCI */
<span class="p_chunk">@@ -1617,6 +1618,7 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 		chipname = &quot;PCnet/FAST III 79C975&quot;;	/* PCI */
 		fdx = 1;
 		mii = 1;
<span class="p_add">+		sram = 1;</span>
 		break;
 	case 0x2628:
 		chipname = &quot;PCnet/PRO 79C976&quot;;
<span class="p_chunk">@@ -1645,6 +1647,31 @@</span> <span class="p_context"> pcnet32_probe1(unsigned long ioaddr, int shared, struct pci_dev *pdev)</span>
 		dxsuflo = 1;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The Am79C973/Am79C975 controllers come with 12K of SRAM</span>
<span class="p_add">+	 * which we can use for the Tx/Rx buffers but most importantly,</span>
<span class="p_add">+	 * the use of SRAM allow us to use the BCR18:NOUFLO bit to avoid</span>
<span class="p_add">+	 * Tx fifo underflows.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (sram) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The SRAM is being configured in two steps. First we</span>
<span class="p_add">+		 * set the SRAM size in the BCR25:SRAM_SIZE bits. According</span>
<span class="p_add">+		 * to the datasheet, each bit corresponds to a 512-byte</span>
<span class="p_add">+		 * page so we can have at most 24 pages. The SRAM_SIZE</span>
<span class="p_add">+		 * holds the value of the upper 8 bits of the 16-bit SRAM size.</span>
<span class="p_add">+		 * The low 8-bits start at 0x00 and end at 0xff. So the</span>
<span class="p_add">+		 * address range is from 0x0000 up to 0x17ff. Therefore,</span>
<span class="p_add">+		 * the SRAM_SIZE is set to 0x17. The next step is to set</span>
<span class="p_add">+		 * the BCR26:SRAM_BND midway through so the Tx and Rx</span>
<span class="p_add">+		 * buffers can share the SRAM equally.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		a-&gt;write_bcr(ioaddr, 25, 0x17);</span>
<span class="p_add">+		a-&gt;write_bcr(ioaddr, 26, 0xc);</span>
<span class="p_add">+		/* And finally enable the NOUFLO bit */</span>
<span class="p_add">+		a-&gt;write_bcr(ioaddr, 18, a-&gt;read_bcr(ioaddr, 18) | (1 &lt;&lt; 11));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev = alloc_etherdev(sizeof(*lp));
 	if (!dev) {
 		if (pcnet32_debug &amp; NETIF_MSG_PROBE)
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">index 2f6361e..1042935 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnx2x/bnx2x_main.c</span>
<span class="p_chunk">@@ -10325,6 +10325,10 @@</span> <span class="p_context"> static int __devinit bnx2x_init_dev(struct pci_dev *pdev,</span>
 	/* clean indirect addresses */
 	pci_write_config_dword(bp-&gt;pdev, PCICFG_GRC_ADDRESS,
 			       PCICFG_VENDOR_ID_OFFSET);
<span class="p_add">+</span>
<span class="p_add">+	/* Set PCIe reset type to fundamental for EEH recovery */</span>
<span class="p_add">+	pdev-&gt;needs_freset = 1;</span>
<span class="p_add">+</span>
 	/*
 	 * Clean the following indirect addresses for all functions since it
 	 * is not used by the driver.
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">index 2ec19e7..d0ebf9c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_chunk">@@ -5412,7 +5412,7 @@</span> <span class="p_context"> static void tg3_tx(struct tg3_napi *tnapi)</span>
 			sw_idx = NEXT_TX(sw_idx);
 		}
 
<span class="p_del">-		dev_kfree_skb(skb);</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 
 		if (unlikely(tx_bug)) {
 			tg3_tx_recover(tp);
<span class="p_chunk">@@ -5702,7 +5702,7 @@</span> <span class="p_context"> static int tg3_rx(struct tg3_napi *tnapi, int budget)</span>
 
 		if (len &gt; (tp-&gt;dev-&gt;mtu + ETH_HLEN) &amp;&amp;
 		    skb-&gt;protocol != htons(ETH_P_8021Q)) {
<span class="p_del">-			dev_kfree_skb(skb);</span>
<span class="p_add">+			dev_kfree_skb_any(skb);</span>
 			goto drop_it_no_recycle;
 		}
 
<span class="p_chunk">@@ -6609,7 +6609,7 @@</span> <span class="p_context"> static int tigon3_dma_hwbug_workaround(struct tg3_napi *tnapi,</span>
 					  PCI_DMA_TODEVICE);
 		/* Make sure the mapping succeeded */
 		if (pci_dma_mapping_error(tp-&gt;pdev, new_addr)) {
<span class="p_del">-			dev_kfree_skb(new_skb);</span>
<span class="p_add">+			dev_kfree_skb_any(new_skb);</span>
 			ret = -1;
 		} else {
 			u32 save_entry = *entry;
<span class="p_chunk">@@ -6624,13 +6624,13 @@</span> <span class="p_context"> static int tigon3_dma_hwbug_workaround(struct tg3_napi *tnapi,</span>
 					    new_skb-&gt;len, base_flags,
 					    mss, vlan)) {
 				tg3_tx_skb_unmap(tnapi, save_entry, -1);
<span class="p_del">-				dev_kfree_skb(new_skb);</span>
<span class="p_add">+				dev_kfree_skb_any(new_skb);</span>
 				ret = -1;
 			}
 		}
 	}
 
<span class="p_del">-	dev_kfree_skb(skb);</span>
<span class="p_add">+	dev_kfree_skb_any(skb);</span>
 	*pskb = new_skb;
 	return ret;
 }
<span class="p_chunk">@@ -6673,7 +6673,7 @@</span> <span class="p_context"> static int tg3_tso_bug(struct tg3 *tp, struct sk_buff *skb)</span>
 	} while (segs);
 
 tg3_tso_bug_end:
<span class="p_del">-	dev_kfree_skb(skb);</span>
<span class="p_add">+	dev_kfree_skb_any(skb);</span>
 
 	return NETDEV_TX_OK;
 }
<span class="p_chunk">@@ -6888,7 +6888,7 @@</span> <span class="p_context"> dma_error:</span>
 	tg3_tx_skb_unmap(tnapi, tnapi-&gt;tx_prod, --i);
 	tnapi-&gt;tx_buffers[tnapi-&gt;tx_prod].skb = NULL;
 drop:
<span class="p_del">-	dev_kfree_skb(skb);</span>
<span class="p_add">+	dev_kfree_skb_any(skb);</span>
 drop_nofree:
 	tp-&gt;tx_dropped++;
 	return NETDEV_TX_OK;
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index 36c7c4e..10c9acf 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -1434,7 +1434,7 @@</span> <span class="p_context"> static u16 be_tx_compl_process(struct be_adapter *adapter,</span>
 		queue_tail_inc(txq);
 	} while (cur_index != last_index);
 
<span class="p_del">-	kfree_skb(sent_skb);</span>
<span class="p_add">+	dev_kfree_skb_any(sent_skb);</span>
 	return num_wrbs;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">index fb9e7d3..b167e38 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_chunk">@@ -2092,10 +2092,10 @@</span> <span class="p_context"> static int gfar_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		skb_new = skb_realloc_headroom(skb, GMAC_FCB_LEN);
 		if (!skb_new) {
 			dev-&gt;stats.tx_errors++;
<span class="p_del">-			kfree_skb(skb);</span>
<span class="p_add">+			dev_kfree_skb_any(skb);</span>
 			return NETDEV_TX_OK;
 		}
<span class="p_del">-		kfree_skb(skb);</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 		skb = skb_new;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgb/ixgb_main.c b/drivers/net/ethernet/intel/ixgb/ixgb_main.c</span>
<span class="p_header">index e21148f..e17cfca 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgb/ixgb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgb/ixgb_main.c</span>
<span class="p_chunk">@@ -1539,12 +1539,12 @@</span> <span class="p_context"> ixgb_xmit_frame(struct sk_buff *skb, struct net_device *netdev)</span>
 	int tso;
 
 	if (test_bit(__IXGB_DOWN, &amp;adapter-&gt;flags)) {
<span class="p_del">-		dev_kfree_skb(skb);</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 		return NETDEV_TX_OK;
 	}
 
 	if (skb-&gt;len &lt;= 0) {
<span class="p_del">-		dev_kfree_skb(skb);</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 		return NETDEV_TX_OK;
 	}
 
<span class="p_chunk">@@ -1561,7 +1561,7 @@</span> <span class="p_context"> ixgb_xmit_frame(struct sk_buff *skb, struct net_device *netdev)</span>
 
 	tso = ixgb_tso(adapter, skb);
 	if (tso &lt; 0) {
<span class="p_del">-		dev_kfree_skb(skb);</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 		return NETDEV_TX_OK;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c</span>
<span class="p_header">index 4a238a4..8737e0d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/netxen/netxen_nic_main.c</span>
<span class="p_chunk">@@ -2277,7 +2277,10 @@</span> <span class="p_context"> static int netxen_nic_poll(struct napi_struct *napi, int budget)</span>
 
 	work_done = netxen_process_rcv_ring(sds_ring, budget);
 
<span class="p_del">-	if ((work_done &lt; budget) &amp;&amp; tx_complete) {</span>
<span class="p_add">+	if (!tx_complete)</span>
<span class="p_add">+		work_done = budget;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (work_done &lt; budget) {</span>
 		napi_complete(&amp;sds_ring-&gt;napi);
 		if (test_bit(__NX_DEV_UP, &amp;adapter-&gt;state))
 			netxen_nic_enable_int(sds_ring);
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/8139cp.c b/drivers/net/ethernet/realtek/8139cp.c</span>
<span class="p_header">index 4aa830f..ab5c276 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/8139cp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/8139cp.c</span>
<span class="p_chunk">@@ -886,7 +886,7 @@</span> <span class="p_context"> out_unlock:</span>
 
 	return NETDEV_TX_OK;
 out_dma_error:
<span class="p_del">-	kfree_skb(skb);</span>
<span class="p_add">+	dev_kfree_skb_any(skb);</span>
 	cp-&gt;dev-&gt;stats.tx_dropped++;
 	goto out_unlock;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/8139too.c b/drivers/net/ethernet/realtek/8139too.c</span>
<span class="p_header">index 4d6b254..728805f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/8139too.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/8139too.c</span>
<span class="p_chunk">@@ -1703,9 +1703,9 @@</span> <span class="p_context"> static netdev_tx_t rtl8139_start_xmit (struct sk_buff *skb,</span>
 		if (len &lt; ETH_ZLEN)
 			memset(tp-&gt;tx_buf[entry], 0, ETH_ZLEN);
 		skb_copy_and_csum_dev(skb, tp-&gt;tx_buf[entry]);
<span class="p_del">-		dev_kfree_skb(skb);</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 	} else {
<span class="p_del">-		dev_kfree_skb(skb);</span>
<span class="p_add">+		dev_kfree_skb_any(skb);</span>
 		dev-&gt;stats.tx_dropped++;
 		return NETDEV_TX_OK;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/realtek/r8169.c b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">index a3bd0ba..0c26787 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/realtek/r8169.c</span>
<span class="p_chunk">@@ -5372,7 +5372,7 @@</span> <span class="p_context"> static void rtl8169_tx_clear_range(struct rtl8169_private *tp, u32 start,</span>
 					     tp-&gt;TxDescArray + entry);
 			if (skb) {
 				tp-&gt;dev-&gt;stats.tx_dropped++;
<span class="p_del">-				dev_kfree_skb(skb);</span>
<span class="p_add">+				dev_kfree_skb_any(skb);</span>
 				tx_skb-&gt;skb = NULL;
 			}
 		}
<span class="p_chunk">@@ -5651,7 +5651,7 @@</span> <span class="p_context"> static netdev_tx_t rtl8169_start_xmit(struct sk_buff *skb,</span>
 err_dma_1:
 	rtl8169_unmap_tx_skb(d, tp-&gt;tx_skb + entry, txd);
 err_dma_0:
<span class="p_del">-	dev_kfree_skb(skb);</span>
<span class="p_add">+	dev_kfree_skb_any(skb);</span>
 err_update_stats:
 	dev-&gt;stats.tx_dropped++;
 	return NETDEV_TX_OK;
<span class="p_chunk">@@ -5734,7 +5734,7 @@</span> <span class="p_context"> static void rtl8169_tx_interrupt(struct net_device *dev,</span>
 		if (status &amp; LastFrag) {
 			dev-&gt;stats.tx_packets++;
 			dev-&gt;stats.tx_bytes += tx_skb-&gt;skb-&gt;len;
<span class="p_del">-			dev_kfree_skb(tx_skb-&gt;skb);</span>
<span class="p_add">+			dev_kfree_skb_any(tx_skb-&gt;skb);</span>
 			tx_skb-&gt;skb = NULL;
 		}
 		dirty_tx++;
<span class="p_header">diff --git a/drivers/net/macvtap.c b/drivers/net/macvtap.c</span>
<span class="p_header">index 0e6e57e..7300447 100644</span>
<span class="p_header">--- a/drivers/net/macvtap.c</span>
<span class="p_header">+++ b/drivers/net/macvtap.c</span>
<span class="p_chunk">@@ -667,11 +667,15 @@</span> <span class="p_context"> static unsigned long iov_pages(const struct iovec *iv, int offset,</span>
 	return pages;
 }
 
<span class="p_add">+/* Neighbour code has some assumptions on HH_DATA_MOD alignment */</span>
<span class="p_add">+#define MACVTAP_RESERVE HH_DATA_OFF(ETH_HLEN)</span>
<span class="p_add">+</span>
 /* Get packet from user space buffer */
 static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,
 				const struct iovec *iv, unsigned long total_len,
 				size_t count, int noblock)
 {
<span class="p_add">+	int good_linear = SKB_MAX_HEAD(MACVTAP_RESERVE);</span>
 	struct sk_buff *skb;
 	struct macvlan_dev *vlan;
 	unsigned long len = total_len;
<span class="p_chunk">@@ -714,6 +718,8 @@</span> <span class="p_context"> static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,</span>
 
 	if (m &amp;&amp; m-&gt;msg_control &amp;&amp; sock_flag(&amp;q-&gt;sk, SOCK_ZEROCOPY)) {
 		copylen = vnet_hdr.hdr_len ? vnet_hdr.hdr_len : GOODCOPY_LEN;
<span class="p_add">+		if (copylen &gt; good_linear)</span>
<span class="p_add">+			copylen = good_linear;</span>
 		linear = copylen;
 		if (iov_pages(iv, vnet_hdr_len + copylen, count)
 		    &lt;= MAX_SKB_FRAGS)
<span class="p_chunk">@@ -722,10 +728,13 @@</span> <span class="p_context"> static ssize_t macvtap_get_user(struct macvtap_queue *q, struct msghdr *m,</span>
 
 	if (!zerocopy) {
 		copylen = len;
<span class="p_del">-		linear = vnet_hdr.hdr_len;</span>
<span class="p_add">+		if (vnet_hdr.hdr_len &gt; good_linear)</span>
<span class="p_add">+			linear = good_linear;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			linear = vnet_hdr.hdr_len;</span>
 	}
 
<span class="p_del">-	skb = macvtap_alloc_skb(&amp;q-&gt;sk, NET_IP_ALIGN, copylen,</span>
<span class="p_add">+	skb = macvtap_alloc_skb(&amp;q-&gt;sk, MACVTAP_RESERVE, copylen,</span>
 				linear, noblock, &amp;err);
 	if (!skb)
 		goto err;
<span class="p_header">diff --git a/drivers/net/ppp/ppp_deflate.c b/drivers/net/ppp/ppp_deflate.c</span>
<span class="p_header">index 1dbdf82..43764cc 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_deflate.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_deflate.c</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> static int z_compress(void *arg, unsigned char *rptr, unsigned char *obuf,</span>
 	/*
 	 * See if we managed to reduce the size of the packet.
 	 */
<span class="p_del">-	if (olen &lt; isize) {</span>
<span class="p_add">+	if (olen &lt; isize &amp;&amp; olen &lt;= osize) {</span>
 		state-&gt;stats.comp_bytes += olen;
 		state-&gt;stats.comp_packets++;
 	} else {
<span class="p_header">diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c</span>
<span class="p_header">index 217aec8..4a09110 100644</span>
<span class="p_header">--- a/drivers/net/usb/plusb.c</span>
<span class="p_header">+++ b/drivers/net/usb/plusb.c</span>
<span class="p_chunk">@@ -139,6 +139,11 @@</span> <span class="p_context"> static const struct usb_device_id	products [] = {</span>
 }, {
 	USB_DEVICE(0x050d, 0x258a),     /* Belkin F5U258/F5U279 (PL-25A1) */
 	.driver_info =  (unsigned long) &amp;prolific_info,
<span class="p_add">+}, {</span>
<span class="p_add">+	USB_DEVICE(0x3923, 0x7825),     /* National Instruments USB</span>
<span class="p_add">+					 * Host-to-Host Cable</span>
<span class="p_add">+					 */</span>
<span class="p_add">+	.driver_info =  (unsigned long) &amp;prolific_info,</span>
 },
 
 	{ },		// END
<span class="p_header">diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c</span>
<span class="p_header">index 0d9914b..c64a60e 100644</span>
<span class="p_header">--- a/drivers/net/xen-netfront.c</span>
<span class="p_header">+++ b/drivers/net/xen-netfront.c</span>
<span class="p_chunk">@@ -1053,8 +1053,7 @@</span> <span class="p_context"> err:</span>
 
 static int xennet_change_mtu(struct net_device *dev, int mtu)
 {
<span class="p_del">-	int max = xennet_can_sg(dev) ?</span>
<span class="p_del">-		XEN_NETIF_MAX_TX_SIZE - MAX_TCP_HEADER : ETH_DATA_LEN;</span>
<span class="p_add">+	int max = xennet_can_sg(dev) ? XEN_NETIF_MAX_TX_SIZE : ETH_DATA_LEN;</span>
 
 	if (mtu &gt; max)
 		return -EINVAL;
<span class="p_chunk">@@ -1329,8 +1328,6 @@</span> <span class="p_context"> static struct net_device * __devinit xennet_create_dev(struct xenbus_device *dev</span>
 	SET_ETHTOOL_OPS(netdev, &amp;xennet_ethtool_ops);
 	SET_NETDEV_DEV(netdev, &amp;dev-&gt;dev);
 
<span class="p_del">-	netif_set_gso_max_size(netdev, XEN_NETIF_MAX_TX_SIZE - MAX_TCP_HEADER);</span>
<span class="p_del">-</span>
 	np-&gt;netdev = netdev;
 
 	netif_carrier_off(netdev);
<span class="p_header">diff --git a/drivers/pci/hotplug.c b/drivers/pci/hotplug.c</span>
<span class="p_header">index 2b5352a..3b70f5c 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug.c</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> int pci_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
 	if (add_uevent_var(env, &quot;PCI_SLOT_NAME=%s&quot;, pci_name(pdev)))
 		return -ENOMEM;
 
<span class="p_del">-	if (add_uevent_var(env, &quot;MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02x&quot;,</span>
<span class="p_add">+	if (add_uevent_var(env, &quot;MODALIAS=pci:v%08Xd%08Xsv%08Xsd%08Xbc%02Xsc%02Xi%02X&quot;,</span>
 			   pdev-&gt;vendor, pdev-&gt;device,
 			   pdev-&gt;subsystem_vendor, pdev-&gt;subsystem_device,
 			   (u8)(pdev-&gt;class &gt;&gt; 16), (u8)(pdev-&gt;class &gt;&gt; 8),
<span class="p_header">diff --git a/drivers/pci/rom.c b/drivers/pci/rom.c</span>
<span class="p_header">index 48ebdb2..e31659c 100644</span>
<span class="p_header">--- a/drivers/pci/rom.c</span>
<span class="p_header">+++ b/drivers/pci/rom.c</span>
<span class="p_chunk">@@ -69,6 +69,7 @@</span> <span class="p_context"> size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)</span>
 {
 	void __iomem *image;
 	int last_image;
<span class="p_add">+	unsigned length;</span>
 
 	image = rom;
 	do {
<span class="p_chunk">@@ -91,9 +92,9 @@</span> <span class="p_context"> size_t pci_get_rom_size(struct pci_dev *pdev, void __iomem *rom, size_t size)</span>
 		if (readb(pds + 3) != &#39;R&#39;)
 			break;
 		last_image = readb(pds + 21) &amp; 0x80;
<span class="p_del">-		/* this length is reliable */</span>
<span class="p_del">-		image += readw(pds + 16) * 512;</span>
<span class="p_del">-	} while (!last_image);</span>
<span class="p_add">+		length = readw(pds + 16);</span>
<span class="p_add">+		image += length * 512;</span>
<span class="p_add">+	} while (length &amp;&amp; !last_image);</span>
 
 	/* never return a size larger than the PCI resource window */
 	/* there are known ROMs that get the size wrong */
<span class="p_header">diff --git a/drivers/scsi/be2iscsi/be_main.c b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">index 379c696..b9ee9f3 100644</span>
<span class="p_header">--- a/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_header">+++ b/drivers/scsi/be2iscsi/be_main.c</span>
<span class="p_chunk">@@ -424,7 +424,6 @@</span> <span class="p_context"> static struct beiscsi_hba *beiscsi_hba_alloc(struct pci_dev *pcidev)</span>
 			&quot;iscsi_host_alloc failed\n&quot;);
 		return NULL;
 	}
<span class="p_del">-	shost-&gt;dma_boundary = pcidev-&gt;dma_mask;</span>
 	shost-&gt;max_id = BE2_MAX_SESSIONS;
 	shost-&gt;max_channel = 0;
 	shost-&gt;max_cmd_len = BEISCSI_MAX_CMD_LEN;
<span class="p_chunk">@@ -4398,9 +4397,9 @@</span> <span class="p_context"> free_port:</span>
 hba_free:
 	if (phba-&gt;msix_enabled)
 		pci_disable_msix(phba-&gt;pcidev);
<span class="p_del">-	iscsi_host_remove(phba-&gt;shost);</span>
 	pci_dev_put(phba-&gt;pcidev);
 	iscsi_host_free(phba-&gt;shost);
<span class="p_add">+	pci_set_drvdata(pcidev, NULL);</span>
 disable_pci:
 	pci_disable_device(pcidev);
 	return ret;
<span class="p_header">diff --git a/drivers/scsi/libsas/sas_discover.c b/drivers/scsi/libsas/sas_discover.c</span>
<span class="p_header">index 54a5199..676e169 100644</span>
<span class="p_header">--- a/drivers/scsi/libsas/sas_discover.c</span>
<span class="p_header">+++ b/drivers/scsi/libsas/sas_discover.c</span>
<span class="p_chunk">@@ -336,14 +336,16 @@</span> <span class="p_context"> static void sas_revalidate_domain(struct work_struct *work)</span>
 	struct sas_discovery_event *ev =
 		container_of(work, struct sas_discovery_event, work);
 	struct asd_sas_port *port = ev-&gt;port;
<span class="p_add">+	struct domain_device *ddev = port-&gt;port_dev;</span>
 
 	sas_begin_event(DISCE_REVALIDATE_DOMAIN, &amp;port-&gt;disc.disc_event_lock,
 			&amp;port-&gt;disc.pending);
 
 	SAS_DPRINTK(&quot;REVALIDATING DOMAIN on port %d, pid:%d\n&quot;, port-&gt;id,
 		    task_pid_nr(current));
<span class="p_del">-	if (port-&gt;port_dev)</span>
<span class="p_del">-		res = sas_ex_revalidate_domain(port-&gt;port_dev);</span>
<span class="p_add">+	if (ddev &amp;&amp; (ddev-&gt;dev_type == FANOUT_DEV ||</span>
<span class="p_add">+		     ddev-&gt;dev_type == EDGE_DEV))</span>
<span class="p_add">+		res = sas_ex_revalidate_domain(ddev);</span>
 
 	SAS_DPRINTK(&quot;done REVALIDATING DOMAIN on port %d, pid:%d, res 0x%x\n&quot;,
 		    port-&gt;id, task_pid_nr(current), res);
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index 0bdc4a7..f6a464a 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -1206,9 +1206,11 @@</span> <span class="p_context"> int scsi_prep_state_check(struct scsi_device *sdev, struct request *req)</span>
 				    &quot;rejecting I/O to dead device\n&quot;);
 			ret = BLKPREP_KILL;
 			break;
<span class="p_del">-		case SDEV_QUIESCE:</span>
 		case SDEV_BLOCK:
 		case SDEV_CREATED_BLOCK:
<span class="p_add">+			ret = BLKPREP_DEFER;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SDEV_QUIESCE:</span>
 			/*
 			 * If the devices is blocked we defer normal commands.
 			 */
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index 441a1c5..2d25616 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -498,7 +498,7 @@</span> <span class="p_context"> static ssize_t</span>
 sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)
 {
 	sg_io_hdr_t *hp = &amp;srp-&gt;header;
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	int err = 0, err2;</span>
 	int len;
 
 	if (count &lt; SZ_SG_IO_HDR) {
<span class="p_chunk">@@ -527,8 +527,8 @@</span> <span class="p_context"> sg_new_read(Sg_fd * sfp, char __user *buf, size_t count, Sg_request * srp)</span>
 		goto err_out;
 	}
 err_out:
<span class="p_del">-	err = sg_finish_rem_req(srp);</span>
<span class="p_del">-	return (0 == err) ? count : err;</span>
<span class="p_add">+	err2 = sg_finish_rem_req(srp);</span>
<span class="p_add">+	return err ? : err2 ? : count;</span>
 }
 
 static ssize_t
<span class="p_header">diff --git a/drivers/spi/spi-dw.c b/drivers/spi/spi-dw.c</span>
<span class="p_header">index bbdf0cf..9fc34e6 100644</span>
<span class="p_header">--- a/drivers/spi/spi-dw.c</span>
<span class="p_header">+++ b/drivers/spi/spi-dw.c</span>
<span class="p_chunk">@@ -786,13 +786,13 @@</span> <span class="p_context"> static void spi_hw_init(struct dw_spi *dws)</span>
 	 */
 	if (!dws-&gt;fifo_len) {
 		u32 fifo;
<span class="p_del">-		for (fifo = 2; fifo &lt;= 256; fifo++) {</span>
<span class="p_add">+		for (fifo = 1; fifo &lt; 256; fifo++) {</span>
 			dw_writew(dws, DW_SPI_TXFLTR, fifo);
 			if (fifo != dw_readw(dws, DW_SPI_TXFLTR))
 				break;
 		}
 
<span class="p_del">-		dws-&gt;fifo_len = (fifo == 2) ? 0 : fifo - 1;</span>
<span class="p_add">+		dws-&gt;fifo_len = (fifo == 1) ? 0 : fifo;</span>
 		dw_writew(dws, DW_SPI_TXFLTR, 0);
 	}
 }
<span class="p_header">diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c</span>
<span class="p_header">index 830adbe..1556db9 100644</span>
<span class="p_header">--- a/drivers/spi/spidev.c</span>
<span class="p_header">+++ b/drivers/spi/spidev.c</span>
<span class="p_chunk">@@ -241,7 +241,10 @@</span> <span class="p_context"> static int spidev_message(struct spidev_data *spidev,</span>
 		k_tmp-&gt;len = u_tmp-&gt;len;
 
 		total += k_tmp-&gt;len;
<span class="p_del">-		if (total &gt; bufsiz) {</span>
<span class="p_add">+		/* Check total length of transfers.  Also check each</span>
<span class="p_add">+		 * transfer length to avoid arithmetic overflow.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (total &gt; bufsiz || k_tmp-&gt;len &gt; bufsiz) {</span>
 			status = -EMSGSIZE;
 			goto done;
 		}
<span class="p_header">diff --git a/drivers/staging/comedi/comedi_compat32.c b/drivers/staging/comedi/comedi_compat32.c</span>
<span class="p_header">index 41a7a62..a8a0c0f 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/comedi_compat32.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/comedi_compat32.c</span>
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static int compat_cmd(struct file *file, unsigned long arg)</span>
 {
 	struct comedi_cmd __user *cmd;
 	struct comedi32_cmd_struct __user *cmd32;
<span class="p_del">-	int rc;</span>
<span class="p_add">+	int rc, err;</span>
 
 	cmd32 = compat_ptr(arg);
 	cmd = compat_alloc_user_space(sizeof(*cmd));
<span class="p_chunk">@@ -280,7 +280,15 @@</span> <span class="p_context"> static int compat_cmd(struct file *file, unsigned long arg)</span>
 	if (rc)
 		return rc;
 
<span class="p_del">-	return translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);</span>
<span class="p_add">+	rc = translated_ioctl(file, COMEDI_CMD, (unsigned long)cmd);</span>
<span class="p_add">+	if (rc == -EAGAIN) {</span>
<span class="p_add">+		/* Special case: copy cmd back to user. */</span>
<span class="p_add">+		err = put_compat_cmd(cmd32, cmd);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			rc = err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
 }
 
 /* Handle 32-bit COMEDI_CMDTEST ioctl. */
<span class="p_header">diff --git a/drivers/staging/iio/imu/adis16400_core.c b/drivers/staging/iio/imu/adis16400_core.c</span>
<span class="p_header">index d082a37..57cb92f 100644</span>
<span class="p_header">--- a/drivers/staging/iio/imu/adis16400_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/imu/adis16400_core.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/sysfs.h&gt;
 #include &lt;linux/list.h&gt;
 #include &lt;linux/module.h&gt;
<span class="p_add">+#include &lt;linux/bitops.h&gt;</span>
 
 #include &quot;../iio.h&quot;
 #include &quot;../sysfs.h&quot;
<span class="p_chunk">@@ -541,7 +542,7 @@</span> <span class="p_context"> static int adis16400_read_raw(struct iio_dev *indio_dev,</span>
 		mutex_unlock(&amp;indio_dev-&gt;mlock);
 		if (ret)
 			return ret;
<span class="p_del">-		val16 = ((val16 &amp; 0xFFF) &lt;&lt; 4) &gt;&gt; 4;</span>
<span class="p_add">+		val16 = sign_extend32(val16, 11);</span>
 		*val = val16;
 		return IIO_VAL_INT;
 	case (1 &lt;&lt; IIO_CHAN_INFO_OFFSET_SEPARATE):
<span class="p_header">diff --git a/drivers/staging/iio/industrialio-core.c b/drivers/staging/iio/industrialio-core.c</span>
<span class="p_header">index aec9311..f0abf29 100644</span>
<span class="p_header">--- a/drivers/staging/iio/industrialio-core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/industrialio-core.c</span>
<span class="p_chunk">@@ -711,6 +711,7 @@</span> <span class="p_context"> static void iio_device_unregister_sysfs(struct iio_dev *indio_dev)</span>
 		iio_device_remove_and_free_read_attr(indio_dev, p);
 	}
 	kfree(indio_dev-&gt;chan_attr_group.attrs);
<span class="p_add">+	indio_dev-&gt;chan_attr_group.attrs = NULL;</span>
 }
 
 static const char * const iio_ev_type_text[] = {
<span class="p_chunk">@@ -986,6 +987,7 @@</span> <span class="p_context"> static int iio_device_register_eventset(struct iio_dev *indio_dev)</span>
 error_free_setup_event_lines:
 	__iio_remove_event_config_attrs(indio_dev);
 	kfree(indio_dev-&gt;event_interface);
<span class="p_add">+	indio_dev-&gt;event_interface = NULL;</span>
 error_ret:
 
 	return ret;
<span class="p_header">diff --git a/drivers/staging/vt6655/rf.c b/drivers/staging/vt6655/rf.c</span>
<span class="p_header">index b8ec783..3003363 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/rf.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/rf.c</span>
<span class="p_chunk">@@ -1029,6 +1029,7 @@</span> <span class="p_context"> unsigned char byPwrdBm = 0;</span>
 		break;
     case RATE_6M:
     case RATE_9M:
<span class="p_add">+    case RATE_12M:</span>
     case RATE_18M:
         byPwr = pDevice-&gt;abyOFDMPwrTbl[uCH];
         if (pDevice-&gt;byRFType == RF_UW2452) {
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_tq.c b/drivers/target/iscsi/iscsi_target_tq.c</span>
<span class="p_header">index 0baac5b..3f59a80 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_tq.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_tq.c</span>
<span class="p_chunk">@@ -26,36 +26,22 @@</span> <span class="p_context"></span>
 #include &quot;iscsi_target_tq.h&quot;
 #include &quot;iscsi_target.h&quot;
 
<span class="p_del">-static LIST_HEAD(active_ts_list);</span>
 static LIST_HEAD(inactive_ts_list);
<span class="p_del">-static DEFINE_SPINLOCK(active_ts_lock);</span>
 static DEFINE_SPINLOCK(inactive_ts_lock);
 static DEFINE_SPINLOCK(ts_bitmap_lock);
 
<span class="p_del">-static void iscsi_add_ts_to_active_list(struct iscsi_thread_set *ts)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spin_lock(&amp;active_ts_lock);</span>
<span class="p_del">-	list_add_tail(&amp;ts-&gt;ts_list, &amp;active_ts_list);</span>
<span class="p_del">-	iscsit_global-&gt;active_ts++;</span>
<span class="p_del">-	spin_unlock(&amp;active_ts_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 extern void iscsi_add_ts_to_inactive_list(struct iscsi_thread_set *ts)
 {
<span class="p_add">+	if (!list_empty(&amp;ts-&gt;ts_list)) {</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	spin_lock(&amp;inactive_ts_lock);
 	list_add_tail(&amp;ts-&gt;ts_list, &amp;inactive_ts_list);
 	iscsit_global-&gt;inactive_ts++;
 	spin_unlock(&amp;inactive_ts_lock);
 }
 
<span class="p_del">-static void iscsi_del_ts_from_active_list(struct iscsi_thread_set *ts)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spin_lock(&amp;active_ts_lock);</span>
<span class="p_del">-	list_del(&amp;ts-&gt;ts_list);</span>
<span class="p_del">-	iscsit_global-&gt;active_ts--;</span>
<span class="p_del">-	spin_unlock(&amp;active_ts_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static struct iscsi_thread_set *iscsi_get_ts_from_inactive_list(void)
 {
 	struct iscsi_thread_set *ts;
<span class="p_chunk">@@ -69,7 +55,7 @@</span> <span class="p_context"> static struct iscsi_thread_set *iscsi_get_ts_from_inactive_list(void)</span>
 	list_for_each_entry(ts, &amp;inactive_ts_list, ts_list)
 		break;
 
<span class="p_del">-	list_del(&amp;ts-&gt;ts_list);</span>
<span class="p_add">+	list_del_init(&amp;ts-&gt;ts_list);</span>
 	iscsit_global-&gt;inactive_ts--;
 	spin_unlock(&amp;inactive_ts_lock);
 
<span class="p_chunk">@@ -220,8 +206,6 @@</span> <span class="p_context"> static void iscsi_deallocate_extra_thread_sets(void)</span>
 
 void iscsi_activate_thread_set(struct iscsi_conn *conn, struct iscsi_thread_set *ts)
 {
<span class="p_del">-	iscsi_add_ts_to_active_list(ts);</span>
<span class="p_del">-</span>
 	spin_lock_bh(&amp;ts-&gt;ts_state_lock);
 	conn-&gt;thread_set = ts;
 	ts-&gt;conn = conn;
<span class="p_chunk">@@ -424,7 +408,6 @@</span> <span class="p_context"> struct iscsi_conn *iscsi_rx_thread_pre_handler(struct iscsi_thread_set *ts)</span>
 
 	if (ts-&gt;delay_inactive &amp;&amp; (--ts-&gt;thread_count == 0)) {
 		spin_unlock_bh(&amp;ts-&gt;ts_state_lock);
<span class="p_del">-		iscsi_del_ts_from_active_list(ts);</span>
 
 		if (!iscsit_global-&gt;in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
<span class="p_chunk">@@ -477,7 +460,6 @@</span> <span class="p_context"> struct iscsi_conn *iscsi_tx_thread_pre_handler(struct iscsi_thread_set *ts)</span>
 
 	if (ts-&gt;delay_inactive &amp;&amp; (--ts-&gt;thread_count == 0)) {
 		spin_unlock_bh(&amp;ts-&gt;ts_state_lock);
<span class="p_del">-		iscsi_del_ts_from_active_list(ts);</span>
 
 		if (!iscsit_global-&gt;in_shutdown)
 			iscsi_deallocate_extra_thread_sets();
<span class="p_chunk">@@ -536,10 +518,8 @@</span> <span class="p_context"> int iscsi_thread_set_init(void)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	spin_lock_init(&amp;active_ts_lock);</span>
 	spin_lock_init(&amp;inactive_ts_lock);
 	spin_lock_init(&amp;ts_bitmap_lock);
<span class="p_del">-	INIT_LIST_HEAD(&amp;active_ts_list);</span>
 	INIT_LIST_HEAD(&amp;inactive_ts_list);
 
 	return 0;
<span class="p_header">diff --git a/drivers/target/target_core_pscsi.c b/drivers/target/target_core_pscsi.c</span>
<span class="p_header">index e813227..ebf9b60 100644</span>
<span class="p_header">--- a/drivers/target/target_core_pscsi.c</span>
<span class="p_header">+++ b/drivers/target/target_core_pscsi.c</span>
<span class="p_chunk">@@ -1168,7 +1168,7 @@</span> <span class="p_context"> static u32 pscsi_get_device_type(struct se_device *dev)</span>
 	struct pscsi_dev_virt *pdv = dev-&gt;dev_ptr;
 	struct scsi_device *sd = pdv-&gt;pdv_sd;
 
<span class="p_del">-	return sd-&gt;type;</span>
<span class="p_add">+	return (sd) ? sd-&gt;type : TYPE_NO_LUN;</span>
 }
 
 static sector_t pscsi_get_blocks(struct se_device *dev)
<span class="p_header">diff --git a/drivers/target/tcm_fc/tfc_io.c b/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_header">index ada131c..cebd235 100644</span>
<span class="p_header">--- a/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_header">+++ b/drivers/target/tcm_fc/tfc_io.c</span>
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> void ft_invl_hw_context(struct ft_cmd *cmd)</span>
 		ep = fc_seq_exch(seq);
 		if (ep) {
 			lport = ep-&gt;lp;
<span class="p_del">-			if (lport &amp;&amp; (ep-&gt;xid &lt;= lport-&gt;lro_xid))</span>
<span class="p_add">+			if (lport &amp;&amp; (ep-&gt;xid &lt;= lport-&gt;lro_xid)) {</span>
 				/*
 				 * &quot;ddp_done&quot; trigger invalidation of HW
 				 * specific DDP context
<span class="p_chunk">@@ -350,6 +350,7 @@</span> <span class="p_context"> void ft_invl_hw_context(struct ft_cmd *cmd)</span>
 				 * identified using ep-&gt;xid)
 				 */
 				cmd-&gt;was_ddp_setup = 0;
<span class="p_add">+			}</span>
 		}
 	}
 }
<span class="p_header">diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c</span>
<span class="p_header">index 4735928..e753be2 100644</span>
<span class="p_header">--- a/drivers/tty/pty.c</span>
<span class="p_header">+++ b/drivers/tty/pty.c</span>
<span class="p_chunk">@@ -175,6 +175,9 @@</span> <span class="p_context"> static int pty_signal(struct tty_struct *tty, int sig)</span>
 	unsigned long flags;
 	struct pid *pgrp;
 
<span class="p_add">+	if (sig != SIGINT &amp;&amp; sig != SIGQUIT &amp;&amp; sig != SIGTSTP)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (tty-&gt;link) {
 		spin_lock_irqsave(&amp;tty-&gt;link-&gt;ctrl_lock, flags);
 		pgrp = get_pid(tty-&gt;link-&gt;pgrp);
<span class="p_header">diff --git a/drivers/tty/serial/8250_pci.c b/drivers/tty/serial/8250_pci.c</span>
<span class="p_header">index ef24e96..c1c1e52 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250_pci.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> static void moan_device(const char *str, struct pci_dev *dev)</span>
 	       &quot;Please send the output of lspci -vv, this\n&quot;
 	       &quot;message (0x%04x,0x%04x,0x%04x,0x%04x), the\n&quot;
 	       &quot;manufacturer and name of serial board or\n&quot;
<span class="p_del">-	       &quot;modem board to rmk+serial@arm.linux.org.uk.\n&quot;,</span>
<span class="p_add">+	       &quot;modem board to &lt;linux-serial@vger.kernel.org&gt;.\n&quot;,</span>
 	       pci_name(dev), str, dev-&gt;vendor, dev-&gt;device,
 	       dev-&gt;subsystem_vendor, dev-&gt;subsystem_device);
 }
<span class="p_header">diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c</span>
<span class="p_header">index 613f06a..fa59fbe 100644</span>
<span class="p_header">--- a/drivers/tty/tty_io.c</span>
<span class="p_header">+++ b/drivers/tty/tty_io.c</span>
<span class="p_chunk">@@ -943,8 +943,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(start_tty);</span>
 /* We limit tty time update visibility to every 8 seconds or so. */
 static void tty_update_time(struct timespec *time)
 {
<span class="p_del">-	unsigned long sec = get_seconds() &amp; ~7;</span>
<span class="p_del">-	if ((long)(sec - time-&gt;tv_sec) &gt; 0)</span>
<span class="p_add">+	unsigned long sec = get_seconds();</span>
<span class="p_add">+	if (abs(sec - time-&gt;tv_sec) &amp; ~7)</span>
 		time-&gt;tv_sec = sec;
 }
 
<span class="p_header">diff --git a/drivers/tty/tty_ioctl.c b/drivers/tty/tty_ioctl.c</span>
<span class="p_header">index 937f927..1740117 100644</span>
<span class="p_header">--- a/drivers/tty/tty_ioctl.c</span>
<span class="p_header">+++ b/drivers/tty/tty_ioctl.c</span>
<span class="p_chunk">@@ -154,11 +154,17 @@</span> <span class="p_context"> void tty_wait_until_sent(struct tty_struct *tty, long timeout)</span>
 #endif
 	if (!timeout)
 		timeout = MAX_SCHEDULE_TIMEOUT;
<span class="p_add">+</span>
 	if (wait_event_interruptible_timeout(tty-&gt;write_wait,
<span class="p_del">-			!tty_chars_in_buffer(tty), timeout) &gt;= 0) {</span>
<span class="p_del">-		if (tty-&gt;ops-&gt;wait_until_sent)</span>
<span class="p_del">-			tty-&gt;ops-&gt;wait_until_sent(tty, timeout);</span>
<span class="p_add">+			!tty_chars_in_buffer(tty), timeout) &lt; 0) {</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (timeout == MAX_SCHEDULE_TIMEOUT)</span>
<span class="p_add">+		timeout = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tty-&gt;ops-&gt;wait_until_sent)</span>
<span class="p_add">+		tty-&gt;ops-&gt;wait_until_sent(tty, timeout);</span>
 }
 EXPORT_SYMBOL(tty_wait_until_sent);
 
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 632df54f..c51803f 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -499,6 +499,7 @@</span> <span class="p_context"> void invert_screen(struct vc_data *vc, int offset, int count, int viewed)</span>
 #endif
 	if (DO_UPDATE(vc))
 		do_update_region(vc, (unsigned long) p, count);
<span class="p_add">+	notify_update(vc);</span>
 }
 
 /* used by selection: complement pointer position */
<span class="p_chunk">@@ -515,6 +516,7 @@</span> <span class="p_context"> void complement_pos(struct vc_data *vc, int offset)</span>
 		scr_writew(old, screenpos(vc, old_offset, 1));
 		if (DO_UPDATE(vc))
 			vc-&gt;vc_sw-&gt;con_putc(vc, old, oldy, oldx);
<span class="p_add">+		notify_update(vc);</span>
 	}
 
 	old_offset = offset;
<span class="p_chunk">@@ -532,8 +534,8 @@</span> <span class="p_context"> void complement_pos(struct vc_data *vc, int offset)</span>
 			oldy = (offset &gt;&gt; 1) / vc-&gt;vc_cols;
 			vc-&gt;vc_sw-&gt;con_putc(vc, new, oldy, oldx);
 		}
<span class="p_add">+		notify_update(vc);</span>
 	}
<span class="p_del">-</span>
 }
 
 static void insert_char(struct vc_data *vc, unsigned int nr)
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index d38d88e..360ddb5 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -911,6 +911,7 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	unsigned long quirks;
 	int num_rx_buf;
 	int i;
<span class="p_add">+	unsigned int elength = 0;</span>
 	int combined_interfaces = 0;
 
 	/* normal quirks */
<span class="p_chunk">@@ -950,9 +951,12 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage\n&quot;);
 			goto next_desc;
 		}
<span class="p_add">+		elength = buffer[0];</span>
 
 		switch (buffer[2]) {
 		case USB_CDC_UNION_TYPE: /* we&#39;ve found it */
<span class="p_add">+			if (elength &lt; sizeof(struct usb_cdc_union_desc))</span>
<span class="p_add">+				goto next_desc;</span>
 			if (union_header) {
 				dev_err(&amp;intf-&gt;dev, &quot;More than one &quot;
 					&quot;union descriptor, skipping ...\n&quot;);
<span class="p_chunk">@@ -961,31 +965,38 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 			union_header = (struct usb_cdc_union_desc *)buffer;
 			break;
 		case USB_CDC_COUNTRY_TYPE: /* export through sysfs*/
<span class="p_add">+			if (elength &lt; sizeof(struct usb_cdc_country_functional_desc))</span>
<span class="p_add">+				goto next_desc;</span>
 			cfd = (struct usb_cdc_country_functional_desc *)buffer;
 			break;
 		case USB_CDC_HEADER_TYPE: /* maybe check version */
 			break; /* for now we ignore it */
 		case USB_CDC_ACM_TYPE:
<span class="p_add">+			if (elength &lt; 4)</span>
<span class="p_add">+				goto next_desc;</span>
 			ac_management_function = buffer[3];
 			break;
 		case USB_CDC_CALL_MANAGEMENT_TYPE:
<span class="p_add">+			if (elength &lt; 5)</span>
<span class="p_add">+				goto next_desc;</span>
 			call_management_function = buffer[3];
 			call_interface_num = buffer[4];
 			if ( (quirks &amp; NOT_A_MODEM) == 0 &amp;&amp; (call_management_function &amp; 3) != 3)
 				dev_err(&amp;intf-&gt;dev, &quot;This device cannot do calls on its own. It is not a modem.\n&quot;);
 			break;
 		default:
<span class="p_del">-			/* there are LOTS more CDC descriptors that</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * there are LOTS more CDC descriptors that</span>
 			 * could legitimately be found here.
 			 */
 			dev_dbg(&amp;intf-&gt;dev, &quot;Ignoring descriptor: &quot;
<span class="p_del">-					&quot;type %02x, length %d\n&quot;,</span>
<span class="p_del">-					buffer[2], buffer[0]);</span>
<span class="p_add">+					&quot;type %02x, length %ud\n&quot;,</span>
<span class="p_add">+					buffer[2], elength);</span>
 			break;
 		}
 next_desc:
<span class="p_del">-		buflen -= buffer[0];</span>
<span class="p_del">-		buffer += buffer[0];</span>
<span class="p_add">+		buflen -= elength;</span>
<span class="p_add">+		buffer += elength;</span>
 	}
 
 	if (!union_header) {
<span class="p_header">diff --git a/drivers/usb/core/buffer.c b/drivers/usb/core/buffer.c</span>
<span class="p_header">index b0585e6..19fa68a 100644</span>
<span class="p_header">--- a/drivers/usb/core/buffer.c</span>
<span class="p_header">+++ b/drivers/usb/core/buffer.c</span>
<span class="p_chunk">@@ -22,17 +22,25 @@</span> <span class="p_context"></span>
  */
 
 /* FIXME tune these based on pool statistics ... */
<span class="p_del">-static const size_t	pool_max[HCD_BUFFER_POOLS] = {</span>
<span class="p_del">-	/* platforms without dma-friendly caches might need to</span>
<span class="p_del">-	 * prevent cacheline sharing...</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	32,</span>
<span class="p_del">-	128,</span>
<span class="p_del">-	512,</span>
<span class="p_del">-	PAGE_SIZE / 2</span>
<span class="p_del">-	/* bigger --&gt; allocate pages */</span>
<span class="p_add">+static size_t pool_max[HCD_BUFFER_POOLS] = {</span>
<span class="p_add">+	32, 128, 512, 2048,</span>
 };
 
<span class="p_add">+void __init usb_init_pool_max(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The pool_max values must never be smaller than</span>
<span class="p_add">+	 * ARCH_KMALLOC_MINALIGN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ARCH_KMALLOC_MINALIGN &lt;= 32)</span>
<span class="p_add">+		;			/* Original value is okay */</span>
<span class="p_add">+	else if (ARCH_KMALLOC_MINALIGN &lt;= 64)</span>
<span class="p_add">+		pool_max[0] = 64;</span>
<span class="p_add">+	else if (ARCH_KMALLOC_MINALIGN &lt;= 128)</span>
<span class="p_add">+		pool_max[0] = 0;	/* Don&#39;t use this pool */</span>
<span class="p_add">+	else</span>
<span class="p_add">+		BUILD_BUG();		/* We don&#39;t allow this */</span>
<span class="p_add">+}</span>
 
 /* SETUP primitives */
 
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 49257b3..64340f3 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -406,6 +406,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	as-&gt;status = urb-&gt;status;
 	signr = as-&gt;signr;
 	if (signr) {
<span class="p_add">+		memset(&amp;sinfo, 0, sizeof(sinfo));</span>
 		sinfo.si_signo = as-&gt;signr;
 		sinfo.si_errno = as-&gt;status;
 		sinfo.si_code = SI_ASYNCIO;
<span class="p_chunk">@@ -2031,6 +2032,7 @@</span> <span class="p_context"> static void usbdev_remove(struct usb_device *udev)</span>
 		wake_up_all(&amp;ps-&gt;wait);
 		list_del_init(&amp;ps-&gt;list);
 		if (ps-&gt;discsignr) {
<span class="p_add">+			memset(&amp;sinfo, 0, sizeof(sinfo));</span>
 			sinfo.si_signo = ps-&gt;discsignr;
 			sinfo.si_errno = EPIPE;
 			sinfo.si_code = SI_ASYNCIO;
<span class="p_header">diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c</span>
<span class="p_header">index cc13abf..c105ba3 100644</span>
<span class="p_header">--- a/drivers/usb/core/driver.c</span>
<span class="p_header">+++ b/drivers/usb/core/driver.c</span>
<span class="p_chunk">@@ -1664,6 +1664,18 @@</span> <span class="p_context"> static int autosuspend_check(struct usb_device *udev)</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;remote wakeup needed for autosuspend\n&quot;);
 		return -EOPNOTSUPP;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the device is a direct child of the root hub and the HCD</span>
<span class="p_add">+	 * doesn&#39;t handle wakeup requests, don&#39;t allow autosuspend when</span>
<span class="p_add">+	 * wakeup is needed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (w &amp;&amp; udev-&gt;parent == udev-&gt;bus-&gt;root_hub &amp;&amp;</span>
<span class="p_add">+			bus_to_hcd(udev-&gt;bus)-&gt;cant_recv_wakeups) {</span>
<span class="p_add">+		dev_dbg(&amp;udev-&gt;dev, &quot;HCD doesn&#39;t handle wakeup requests\n&quot;);</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	udev-&gt;do_remote_wakeup = w;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index c0ee52a..eb2c3bd 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -1542,6 +1542,7 @@</span> <span class="p_context"> static int unlink1(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 int usb_hcd_unlink_urb (struct urb *urb, int status)
 {
 	struct usb_hcd		*hcd;
<span class="p_add">+	struct usb_device	*udev = urb-&gt;dev;</span>
 	int			retval = -EIDRM;
 	unsigned long		flags;
 
<span class="p_chunk">@@ -1553,20 +1554,19 @@</span> <span class="p_context"> int usb_hcd_unlink_urb (struct urb *urb, int status)</span>
 	spin_lock_irqsave(&amp;hcd_urb_unlink_lock, flags);
 	if (atomic_read(&amp;urb-&gt;use_count) &gt; 0) {
 		retval = 0;
<span class="p_del">-		usb_get_dev(urb-&gt;dev);</span>
<span class="p_add">+		usb_get_dev(udev);</span>
 	}
 	spin_unlock_irqrestore(&amp;hcd_urb_unlink_lock, flags);
 	if (retval == 0) {
 		hcd = bus_to_hcd(urb-&gt;dev-&gt;bus);
 		retval = unlink1(hcd, urb, status);
<span class="p_del">-		usb_put_dev(urb-&gt;dev);</span>
<span class="p_add">+		if (retval == 0)</span>
<span class="p_add">+			retval = -EINPROGRESS;</span>
<span class="p_add">+		else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)</span>
<span class="p_add">+			dev_dbg(&amp;udev-&gt;dev, &quot;hcd_unlink_urb %p fail %d\n&quot;,</span>
<span class="p_add">+					urb, retval);</span>
<span class="p_add">+		usb_put_dev(udev);</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	if (retval == 0)</span>
<span class="p_del">-		retval = -EINPROGRESS;</span>
<span class="p_del">-	else if (retval != -EIDRM &amp;&amp; retval != -EBUSY)</span>
<span class="p_del">-		dev_dbg(&amp;urb-&gt;dev-&gt;dev, &quot;hcd_unlink_urb %p fail %d\n&quot;,</span>
<span class="p_del">-				urb, retval);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/usb/core/usb.c b/drivers/usb/core/usb.c</span>
<span class="p_header">index 73cd900..9044ef6 100644</span>
<span class="p_header">--- a/drivers/usb/core/usb.c</span>
<span class="p_header">+++ b/drivers/usb/core/usb.c</span>
<span class="p_chunk">@@ -1010,6 +1010,7 @@</span> <span class="p_context"> static int __init usb_init(void)</span>
 		pr_info(&quot;%s: USB support disabled\n&quot;, usbcore_name);
 		return 0;
 	}
<span class="p_add">+	usb_init_pool_max();</span>
 
 	retval = usb_debugfs_init();
 	if (retval)
<span class="p_header">diff --git a/drivers/usb/gadget/inode.c b/drivers/usb/gadget/inode.c</span>
<span class="p_header">index 7138540..ce7253b 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/inode.c</span>
<span class="p_chunk">@@ -570,6 +570,7 @@</span> <span class="p_context"> static ssize_t ep_aio_read_retry(struct kiocb *iocb)</span>
 			break;
 	}
 	kfree(priv-&gt;buf);
<span class="p_add">+	kfree(priv-&gt;iv);</span>
 	kfree(priv);
 	return len;
 }
<span class="p_chunk">@@ -591,6 +592,7 @@</span> <span class="p_context"> static void ep_aio_complete(struct usb_ep *ep, struct usb_request *req)</span>
 	 */
 	if (priv-&gt;iv == NULL || unlikely(req-&gt;actual == 0)) {
 		kfree(req-&gt;buf);
<span class="p_add">+		kfree(priv-&gt;iv);</span>
 		kfree(priv);
 		iocb-&gt;private = NULL;
 		/* aio_complete() reports bytes-transferred _and_ faults */
<span class="p_chunk">@@ -626,7 +628,7 @@</span> <span class="p_context"> ep_aio_rwtail(</span>
 	struct usb_request	*req;
 	ssize_t			value;
 
<span class="p_del">-	priv = kmalloc(sizeof *priv, GFP_KERNEL);</span>
<span class="p_add">+	priv = kzalloc(sizeof *priv, GFP_KERNEL);</span>
 	if (!priv) {
 		value = -ENOMEM;
 fail:
<span class="p_chunk">@@ -634,11 +636,19 @@</span> <span class="p_context"> fail:</span>
 		return value;
 	}
 	iocb-&gt;private = priv;
<span class="p_del">-	priv-&gt;iv = iv;</span>
<span class="p_add">+	if (iv) {</span>
<span class="p_add">+		priv-&gt;iv = kmemdup(iv, nr_segs * sizeof(struct iovec),</span>
<span class="p_add">+				   GFP_KERNEL);</span>
<span class="p_add">+		if (!priv-&gt;iv) {</span>
<span class="p_add">+			kfree(priv);</span>
<span class="p_add">+			goto fail;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	priv-&gt;nr_segs = nr_segs;
 
 	value = get_ready_ep(iocb-&gt;ki_filp-&gt;f_flags, epdata);
 	if (unlikely(value &lt; 0)) {
<span class="p_add">+		kfree(priv-&gt;iv);</span>
 		kfree(priv);
 		goto fail;
 	}
<span class="p_chunk">@@ -672,6 +682,7 @@</span> <span class="p_context"> fail:</span>
 	mutex_unlock(&amp;epdata-&gt;lock);
 
 	if (unlikely(value)) {
<span class="p_add">+		kfree(priv-&gt;iv);</span>
 		kfree(priv);
 		put_ep(epdata);
 	} else
<span class="p_header">diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">index 27dfab8..a4c2369 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_chunk">@@ -2254,6 +2254,9 @@</span> <span class="p_context"> struct usb_hcd *isp1760_register(phys_addr_t res_start, resource_size_t res_len,</span>
 	hcd-&gt;rsrc_start = res_start;
 	hcd-&gt;rsrc_len = res_len;
 
<span class="p_add">+	/* This driver doesn&#39;t support wakeup requests */</span>
<span class="p_add">+	hcd-&gt;cant_recv_wakeups = 1;</span>
<span class="p_add">+</span>
 	ret = usb_add_hcd(hcd, irq, irqflags);
 	if (ret)
 		goto err_unmap;
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index a8bbeed..c1fa92e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -385,6 +385,10 @@</span> <span class="p_context"> static void xhci_clear_port_change_bit(struct xhci_hcd *xhci, u16 wValue,</span>
 		status = PORT_PLC;
 		port_change_bit = &quot;link state&quot;;
 		break;
<span class="p_add">+	case USB_PORT_FEAT_C_PORT_CONFIG_ERROR:</span>
<span class="p_add">+		status = PORT_CEC;</span>
<span class="p_add">+		port_change_bit = &quot;config error&quot;;</span>
<span class="p_add">+		break;</span>
 	default:
 		/* Should never happen */
 		return;
<span class="p_chunk">@@ -592,6 +596,8 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				status |= USB_PORT_STAT_C_LINK_STATE &lt;&lt; 16;
 			if ((temp &amp; PORT_WRC))
 				status |= USB_PORT_STAT_C_BH_RESET &lt;&lt; 16;
<span class="p_add">+			if ((temp &amp; PORT_CEC))</span>
<span class="p_add">+				status |= USB_PORT_STAT_C_CONFIG_ERROR &lt;&lt; 16;</span>
 		}
 
 		if (hcd-&gt;speed != HCD_USB3) {
<span class="p_chunk">@@ -868,6 +874,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 		case USB_PORT_FEAT_C_OVER_CURRENT:
 		case USB_PORT_FEAT_C_ENABLE:
 		case USB_PORT_FEAT_C_PORT_LINK_STATE:
<span class="p_add">+		case USB_PORT_FEAT_C_PORT_CONFIG_ERROR:</span>
 			xhci_clear_port_change_bit(xhci, wValue, wIndex,
 					port_array[wIndex], temp);
 			break;
<span class="p_chunk">@@ -916,7 +923,7 @@</span> <span class="p_context"> int xhci_hub_status_data(struct usb_hcd *hcd, char *buf)</span>
 	memset(buf, 0, retval);
 	status = 0;
 
<span class="p_del">-	mask = PORT_CSC | PORT_PEC | PORT_OCC | PORT_PLC | PORT_WRC;</span>
<span class="p_add">+	mask = PORT_CSC | PORT_PEC | PORT_OCC | PORT_PLC | PORT_WRC | PORT_CEC;</span>
 
 	spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 	/* For each port, did anything change?  If so, set that bit in buf. */
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index a464dbc..a30f9e5 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -36,6 +36,9 @@</span> <span class="p_context"></span>
 
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5</span>
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f</span>
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -102,6 +105,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_AMD)
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_AVOID_BEI;</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 			pdev-&gt;device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
 		xhci-&gt;quirks |= XHCI_EP_LIMIT_QUIRK;
<span class="p_chunk">@@ -116,7 +121,12 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		 * PPT chipsets.
 		 */
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
<span class="p_del">-		xhci-&gt;quirks |= XHCI_AVOID_BEI;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;</span>
<span class="p_add">+		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)) {</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;</span>
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
 			pdev-&gt;device == PCI_DEVICE_ID_ASROCK_P67) {
<span class="p_chunk">@@ -128,6 +138,21 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_RESET_ON_RESUME;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Make sure PME works on some Intel xHCI controllers by writing 1 to clear</span>
<span class="p_add">+ * the Internal PME flag bit in vendor specific PMCTRL register at offset 0x80a4</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void xhci_pme_quirk(struct xhci_hcd *xhci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+	void __iomem *reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = (void __iomem *) xhci-&gt;cap_regs + 0x80a4;</span>
<span class="p_add">+	val = readl(reg);</span>
<span class="p_add">+	writel(val | BIT(28), reg);</span>
<span class="p_add">+	readl(reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* called during probe() after chip reset completes */
 static int xhci_pci_setup(struct usb_hcd *hcd)
 {
<span class="p_chunk">@@ -235,6 +260,9 @@</span> <span class="p_context"> static int xhci_pci_suspend(struct usb_hcd *hcd, bool do_wakeup)</span>
 			xhci-&gt;shared_hcd-&gt;state != HC_STATE_SUSPENDED)
 		return -EINVAL;
 
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_PME_STUCK_QUIRK)</span>
<span class="p_add">+		xhci_pme_quirk(xhci);</span>
<span class="p_add">+</span>
 	retval = xhci_suspend(xhci, do_wakeup);
 
 	return retval;
<span class="p_chunk">@@ -265,6 +293,9 @@</span> <span class="p_context"> static int xhci_pci_resume(struct usb_hcd *hcd, bool hibernated)</span>
 	if (usb_is_intel_switchable_xhci(pdev))
 		usb_enable_xhci_ports(pdev);
 
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_PME_STUCK_QUIRK)</span>
<span class="p_add">+		xhci_pme_quirk(xhci);</span>
<span class="p_add">+</span>
 	retval = xhci_resume(xhci, hibernated);
 	return retval;
 }
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 3755274..25e9eb4 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1980,7 +1980,7 @@</span> <span class="p_context"> static int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 	if (event_trb != ep_ring-&gt;dequeue) {
 		/* The event was for the status stage */
 		if (event_trb == td-&gt;last_trb) {
<span class="p_del">-			if (td-&gt;urb-&gt;actual_length != 0) {</span>
<span class="p_add">+			if (td-&gt;urb_length_set) {</span>
 				/* Don&#39;t overwrite a previously set error code
 				 */
 				if ((*status == -EINPROGRESS || *status == 0) &amp;&amp;
<span class="p_chunk">@@ -1994,7 +1994,13 @@</span> <span class="p_context"> static int process_ctrl_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 					td-&gt;urb-&gt;transfer_buffer_length;
 			}
 		} else {
<span class="p_del">-		/* Maybe the event was for the data stage? */</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Maybe the event was for the data stage? If so, update</span>
<span class="p_add">+			 * already the actual_length of the URB and flag it as</span>
<span class="p_add">+			 * set, so that it is not overwritten in the event for</span>
<span class="p_add">+			 * the last TRB.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			td-&gt;urb_length_set = true;</span>
 			td-&gt;urb-&gt;actual_length =
 				td-&gt;urb-&gt;transfer_buffer_length -
 				EVENT_TRB_LEN(le32_to_cpu(event-&gt;transfer_len));
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 2090a03..efbdf83 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1,3 +1,4 @@</span> <span class="p_context"></span>
<span class="p_add">+</span>
 /*
  * xHCI host controller driver
  *
<span class="p_chunk">@@ -88,9 +89,10 @@</span> <span class="p_context"> struct xhci_cap_regs {</span>
 #define HCS_IST(p)		(((p) &gt;&gt; 0) &amp; 0xf)
 /* bits 4:7, max number of Event Ring segments */
 #define HCS_ERST_MAX(p)		(((p) &gt;&gt; 4) &amp; 0xf)
<span class="p_add">+/* bits 21:25 Hi 5 bits of Scratchpad buffers SW must allocate for the HW */</span>
 /* bit 26 Scratchpad restore - for save/restore HW state - not used yet */
<span class="p_del">-/* bits 27:31 number of Scratchpad buffers SW must allocate for the HW */</span>
<span class="p_del">-#define HCS_MAX_SCRATCHPAD(p)   (((p) &gt;&gt; 27) &amp; 0x1f)</span>
<span class="p_add">+/* bits 27:31 Lo 5 bits of Scratchpad buffers SW must allocate for the HW */</span>
<span class="p_add">+#define HCS_MAX_SCRATCHPAD(p)   ((((p) &gt;&gt; 16) &amp; 0x3e0) | (((p) &gt;&gt; 27) &amp; 0x1f))</span>
 
 /* HCSPARAMS3 - hcs_params3 - bitmasks */
 /* bits 0:7, Max U1 to U0 latency for the roothub ports */
<span class="p_chunk">@@ -1255,6 +1257,8 @@</span> <span class="p_context"> struct xhci_td {</span>
 	struct xhci_segment	*start_seg;
 	union xhci_trb		*first_trb;
 	union xhci_trb		*last_trb;
<span class="p_add">+	/* actual_length of the URB has already been set */</span>
<span class="p_add">+	bool			urb_length_set;</span>
 };
 
 /* xHCI command default timeout value */
<span class="p_chunk">@@ -1493,6 +1497,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define XHCI_AVOID_BEI		(1 &lt;&lt; 15)
 #define XHCI_SLOW_SUSPEND	(1 &lt;&lt; 17)
 #define XHCI_SPURIOUS_WAKEUP	(1 &lt;&lt; 18)
<span class="p_add">+#define XHCI_PME_STUCK_QUIRK	(1 &lt;&lt; 20)</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/serial/Kconfig b/drivers/usb/serial/Kconfig</span>
<span class="p_header">index 677f577..1888da7c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/Kconfig</span>
<span class="p_header">+++ b/drivers/usb/serial/Kconfig</span>
<span class="p_chunk">@@ -578,10 +578,10 @@</span> <span class="p_context"> config USB_SERIAL_CYBERJACK</span>
 	  If unsure, say N.
 
 config USB_SERIAL_XIRCOM
<span class="p_del">-	tristate &quot;USB Xircom / Entregra Single Port Serial Driver&quot;</span>
<span class="p_add">+	tristate &quot;USB Xircom / Entrega Single Port Serial Driver&quot;</span>
 	select USB_EZUSB
 	help
<span class="p_del">-	  Say Y here if you want to use a Xircom or Entregra single port USB to</span>
<span class="p_add">+	  Say Y here if you want to use a Xircom or Entrega single port USB to</span>
 	  serial converter device.  This driver makes use of firmware
 	  developed from scratch by Brian Warner.
 
<span class="p_header">diff --git a/drivers/usb/serial/bus.c b/drivers/usb/serial/bus.c</span>
<span class="p_header">index 7f547dc..a8dc799 100644</span>
<span class="p_header">--- a/drivers/usb/serial/bus.c</span>
<span class="p_header">+++ b/drivers/usb/serial/bus.c</span>
<span class="p_chunk">@@ -52,6 +52,7 @@</span> <span class="p_context"> static int usb_serial_device_probe(struct device *dev)</span>
 {
 	struct usb_serial_driver *driver;
 	struct usb_serial_port *port;
<span class="p_add">+	struct device *tty_dev;</span>
 	int retval = 0;
 	int minor;
 
<span class="p_chunk">@@ -73,12 +74,20 @@</span> <span class="p_context"> static int usb_serial_device_probe(struct device *dev)</span>
 	retval = device_create_file(dev, &amp;dev_attr_port_number);
 	if (retval) {
 		if (driver-&gt;port_remove)
<span class="p_del">-			retval = driver-&gt;port_remove(port);</span>
<span class="p_add">+			driver-&gt;port_remove(port);</span>
 		goto exit;
 	}
 
 	minor = port-&gt;number;
<span class="p_del">-	tty_register_device(usb_serial_tty_driver, minor, dev);</span>
<span class="p_add">+	tty_dev = tty_register_device(usb_serial_tty_driver, minor, dev);</span>
<span class="p_add">+	if (IS_ERR(tty_dev)) {</span>
<span class="p_add">+		retval = PTR_ERR(tty_dev);</span>
<span class="p_add">+		device_remove_file(dev, &amp;dev_attr_port_number);</span>
<span class="p_add">+		if (driver-&gt;port_remove)</span>
<span class="p_add">+			driver-&gt;port_remove(port);</span>
<span class="p_add">+		goto exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev_info(&amp;port-&gt;serial-&gt;dev-&gt;dev,
 		 &quot;%s converter now attached to ttyUSB%d\n&quot;,
 		 driver-&gt;description, minor);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index e795a4c..7f32c74 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -63,6 +63,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x0846, 0x1100) }, /* NetGear Managed Switch M4100 series, M5300 series, M7100 series */
 	{ USB_DEVICE(0x08e6, 0x5501) }, /* Gemalto Prox-PU/CU contactless smartcard reader */
 	{ USB_DEVICE(0x08FD, 0x000A) }, /* Digianswer A/S , ZigBee/802.15.4 MAC Device */
<span class="p_add">+	{ USB_DEVICE(0x0908, 0x01FF) }, /* Siemens RUGGEDCOM USB Serial Console */</span>
 	{ USB_DEVICE(0x0BED, 0x1100) }, /* MEI (TM) Cashflow-SC Bill/Voucher Acceptor */
 	{ USB_DEVICE(0x0BED, 0x1101) }, /* MEI series 2000 Combo Acceptor */
 	{ USB_DEVICE(0x0FCF, 0x1003) }, /* Dynastream ANT development board */
<span class="p_chunk">@@ -152,6 +153,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x166A, 0x0305) }, /* Clipsal C-5000CT2 C-Bus Spectrum Colour Touchscreen */
 	{ USB_DEVICE(0x166A, 0x0401) }, /* Clipsal L51xx C-Bus Architectural Dimmer */
 	{ USB_DEVICE(0x166A, 0x0101) }, /* Clipsal 5560884 C-Bus Multi-room Audio Matrix Switcher */
<span class="p_add">+	{ USB_DEVICE(0x16C0, 0x09B0) }, /* Lunatico Seletek */</span>
<span class="p_add">+	{ USB_DEVICE(0x16C0, 0x09B1) }, /* Lunatico Seletek */</span>
 	{ USB_DEVICE(0x16D6, 0x0001) }, /* Jablotron serial interface */
 	{ USB_DEVICE(0x16DC, 0x0010) }, /* W-IE-NE-R Plein &amp; Baus GmbH PL512 Power Supply */
 	{ USB_DEVICE(0x16DC, 0x0011) }, /* W-IE-NE-R Plein &amp; Baus GmbH RCM Remote Control for MARATON Power Supply */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index f6a6205..e13ebb0 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -628,6 +628,7 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONLXM_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_SYNAPSE_SS200_PID) },</span>
 	/*
 	 * ELV devices:
 	 */
<span class="p_chunk">@@ -823,6 +824,8 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_ELSTER_UNICOM_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_JTAGCABLEII_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_PROPOX_ISPCABLEIII_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CYBER_CORTEX_AV_PID),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },</span>
 	{ USB_DEVICE(OLIMEX_VID, OLIMEX_ARM_USB_OCD_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(OLIMEX_VID, OLIMEX_ARM_USB_OCD_H_PID),
<span class="p_chunk">@@ -1000,6 +1003,23 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_EKEY_CONV_USB_PID) },
 	/* GE Healthcare devices */
 	{ USB_DEVICE(GE_HEALTHCARE_VID, GE_HEALTHCARE_NEMO_TRACKER_PID) },
<span class="p_add">+	/* Active Research (Actisense) devices */</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_NDC_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_USG_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_NGT_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_NGW_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AC_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AD_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AE_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, ACTISENSE_D9AF_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEAGAUGE_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASWITCH_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_NMEA2000_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_ETHERNET_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_WIFI_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_DISPLAY_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_LITE_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, CHETCO_SEASMART_ANALOG_PID) },</span>
 	{ },					/* Optional parameter entry */
 	{ }					/* Terminating entry */
 };
<span class="p_chunk">@@ -1927,8 +1947,12 @@</span> <span class="p_context"> static int ftdi_8u2232c_probe(struct usb_serial *serial)</span>
 
 	dbg(&quot;%s&quot;, __func__);
 
<span class="p_del">-	if ((udev-&gt;manufacturer &amp;&amp; !strcmp(udev-&gt;manufacturer, &quot;CALAO Systems&quot;)) ||</span>
<span class="p_del">-	    (udev-&gt;product &amp;&amp; !strcmp(udev-&gt;product, &quot;BeagleBone/XDS100V2&quot;)))</span>
<span class="p_add">+	if (udev-&gt;manufacturer &amp;&amp; !strcmp(udev-&gt;manufacturer, &quot;CALAO Systems&quot;))</span>
<span class="p_add">+		return ftdi_jtag_probe(serial);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (udev-&gt;product &amp;&amp;</span>
<span class="p_add">+		(!strcmp(udev-&gt;product, &quot;BeagleBone/XDS100V2&quot;) ||</span>
<span class="p_add">+		 !strcmp(udev-&gt;product, &quot;SNAP Connect E10&quot;)))</span>
 		return ftdi_jtag_probe(serial);
 
 	return 0;
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 5735fb7..361192c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -38,6 +38,9 @@</span> <span class="p_context"></span>
 
 #define FTDI_LUMEL_PD12_PID	0x6002
 
<span class="p_add">+/* Cyber Cortex AV by Fabulous Silicon (http://fabuloussilicon.com) */</span>
<span class="p_add">+#define CYBER_CORTEX_AV_PID	0x8698</span>
<span class="p_add">+</span>
 /*
  * Marvell OpenRD Base, Client
  * http://www.open-rd.org
<span class="p_chunk">@@ -558,6 +561,12 @@</span> <span class="p_context"></span>
  */
 #define FTDI_NT_ORIONLXM_PID	0x7c90	/* OrionLXm Substation Automation Platform */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Synapse Wireless product ids (FTDI_VID)</span>
<span class="p_add">+ * http://www.synapse-wireless.com</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_SYNAPSE_SS200_PID 0x9090 /* SS200 - SNAP Stick 200 */</span>
<span class="p_add">+</span>
 
 /********************************/
 /** third-party VID/PID combos **/
<span class="p_chunk">@@ -1432,3 +1441,23 @@</span> <span class="p_context"></span>
  */
 #define GE_HEALTHCARE_VID		0x1901
 #define GE_HEALTHCARE_NEMO_TRACKER_PID	0x0015
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Active Research (Actisense) devices</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ACTISENSE_NDC_PID		0xD9A8 /* NDC USB Serial Adapter */</span>
<span class="p_add">+#define ACTISENSE_USG_PID		0xD9A9 /* USG USB Serial Adapter */</span>
<span class="p_add">+#define ACTISENSE_NGT_PID		0xD9AA /* NGT NMEA2000 Interface */</span>
<span class="p_add">+#define ACTISENSE_NGW_PID		0xD9AB /* NGW NMEA2000 Gateway */</span>
<span class="p_add">+#define ACTISENSE_D9AC_PID		0xD9AC /* Actisense Reserved */</span>
<span class="p_add">+#define ACTISENSE_D9AD_PID		0xD9AD /* Actisense Reserved */</span>
<span class="p_add">+#define ACTISENSE_D9AE_PID		0xD9AE /* Actisense Reserved */</span>
<span class="p_add">+#define ACTISENSE_D9AF_PID		0xD9AF /* Actisense Reserved */</span>
<span class="p_add">+#define CHETCO_SEAGAUGE_PID		0xA548 /* SeaGauge USB Adapter */</span>
<span class="p_add">+#define CHETCO_SEASWITCH_PID		0xA549 /* SeaSwitch USB Adapter */</span>
<span class="p_add">+#define CHETCO_SEASMART_NMEA2000_PID	0xA54A /* SeaSmart NMEA2000 Gateway */</span>
<span class="p_add">+#define CHETCO_SEASMART_ETHERNET_PID	0xA54B /* SeaSmart Ethernet Gateway */</span>
<span class="p_add">+#define CHETCO_SEASMART_WIFI_PID	0xA5AC /* SeaSmart Wifi Gateway */</span>
<span class="p_add">+#define CHETCO_SEASMART_DISPLAY_PID	0xA5AD /* SeaSmart NMEA2000 Display */</span>
<span class="p_add">+#define CHETCO_SEASMART_LITE_PID	0xA5AE /* SeaSmart Lite USB Adapter */</span>
<span class="p_add">+#define CHETCO_SEASMART_ANALOG_PID	0xA5AF /* SeaSmart Analog Adapter */</span>
<span class="p_header">diff --git a/drivers/usb/serial/keyspan_pda.c b/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_header">index d5c0c6a..661a1a2 100644</span>
<span class="p_header">--- a/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_header">+++ b/drivers/usb/serial/keyspan_pda.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * USB Keyspan PDA / Xircom / Entregra Converter driver</span>
<span class="p_add">+ * USB Keyspan PDA / Xircom / Entrega Converter driver</span>
  *
  * Copyright (C) 1999 - 2001 Greg Kroah-Hartman	&lt;greg@kroah.com&gt;
  * Copyright (C) 1999, 2000 Brian Warner	&lt;warner@lothar.com&gt;
<span class="p_chunk">@@ -119,11 +119,12 @@</span> <span class="p_context"> struct keyspan_pda_private {</span>
 #define KEYSPAN_PDA_FAKE_ID		0x0103
 #define KEYSPAN_PDA_ID			0x0104 /* no clue */
 
<span class="p_del">-/* For Xircom PGSDB9 and older Entregra version of the same device */</span>
<span class="p_add">+/* For Xircom PGSDB9 and older Entrega version of the same device */</span>
 #define XIRCOM_VENDOR_ID		0x085a
 #define XIRCOM_FAKE_ID			0x8027
<span class="p_del">-#define ENTREGRA_VENDOR_ID		0x1645</span>
<span class="p_del">-#define ENTREGRA_FAKE_ID		0x8093</span>
<span class="p_add">+#define XIRCOM_FAKE_ID_2		0x8025 /* &quot;PGMFHUB&quot; serial */</span>
<span class="p_add">+#define ENTREGA_VENDOR_ID		0x1645</span>
<span class="p_add">+#define ENTREGA_FAKE_ID			0x8093</span>
 
 static const struct usb_device_id id_table_combined[] = {
 #ifdef KEYSPAN
<span class="p_chunk">@@ -131,7 +132,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 #endif
 #ifdef XIRCOM
 	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID) },
<span class="p_del">-	{ USB_DEVICE(ENTREGRA_VENDOR_ID, ENTREGRA_FAKE_ID) },</span>
<span class="p_add">+	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID_2) },</span>
<span class="p_add">+	{ USB_DEVICE(ENTREGA_VENDOR_ID, ENTREGA_FAKE_ID) },</span>
 #endif
 	{ USB_DEVICE(KEYSPAN_VENDOR_ID, KEYSPAN_PDA_ID) },
 	{ }						/* Terminating entry */
<span class="p_chunk">@@ -162,7 +164,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_fake[] = {</span>
 #ifdef XIRCOM
 static const struct usb_device_id id_table_fake_xircom[] = {
 	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID) },
<span class="p_del">-	{ USB_DEVICE(ENTREGRA_VENDOR_ID, ENTREGRA_FAKE_ID) },</span>
<span class="p_add">+	{ USB_DEVICE(XIRCOM_VENDOR_ID, XIRCOM_FAKE_ID_2) },</span>
<span class="p_add">+	{ USB_DEVICE(ENTREGA_VENDOR_ID, ENTREGA_FAKE_ID) },</span>
 	{ }
 };
 #endif
<span class="p_chunk">@@ -757,7 +760,7 @@</span> <span class="p_context"> static int keyspan_pda_fake_startup(struct usb_serial *serial)</span>
 #endif
 #ifdef XIRCOM
 	else if ((le16_to_cpu(serial-&gt;dev-&gt;descriptor.idVendor) == XIRCOM_VENDOR_ID) ||
<span class="p_del">-		 (le16_to_cpu(serial-&gt;dev-&gt;descriptor.idVendor) == ENTREGRA_VENDOR_ID))</span>
<span class="p_add">+		 (le16_to_cpu(serial-&gt;dev-&gt;descriptor.idVendor) == ENTREGA_VENDOR_ID))</span>
 		fw_name = &quot;keyspan_pda/xircom_pgs.fw&quot;;
 #endif
 	else {
<span class="p_chunk">@@ -848,7 +851,7 @@</span> <span class="p_context"> static struct usb_serial_driver xircom_pgs_fake_device = {</span>
 		.owner =	THIS_MODULE,
 		.name =		&quot;xircom_no_firm&quot;,
 	},
<span class="p_del">-	.description =		&quot;Xircom / Entregra PGS - (prerenumeration)&quot;,</span>
<span class="p_add">+	.description =		&quot;Xircom / Entrega PGS - (prerenumeration)&quot;,</span>
 	.usb_driver = 		&amp;keyspan_pda_driver,
 	.id_table =		id_table_fake_xircom,
 	.num_ports =		1,
<span class="p_header">diff --git a/drivers/xen/manage.c b/drivers/xen/manage.c</span>
<span class="p_header">index 6548417..caa3969 100644</span>
<span class="p_header">--- a/drivers/xen/manage.c</span>
<span class="p_header">+++ b/drivers/xen/manage.c</span>
<span class="p_chunk">@@ -110,10 +110,16 @@</span> <span class="p_context"> static void do_suspend(void)</span>
 
 	err = freeze_processes();
 	if (err) {
<span class="p_del">-		printk(KERN_ERR &quot;xen suspend: freeze failed %d\n&quot;, err);</span>
<span class="p_add">+		pr_err(&quot;%s: freeze processes failed %d\n&quot;, __func__, err);</span>
 		goto out;
 	}
 
<span class="p_add">+	err = freeze_kernel_threads();</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		pr_err(&quot;%s: freeze kernel threads failed %d\n&quot;, __func__, err);</span>
<span class="p_add">+		goto out_thaw;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = dpm_suspend_start(PMSG_FREEZE);
 	if (err) {
 		printk(KERN_ERR &quot;xen suspend: dpm_suspend_start %d\n&quot;, err);
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.c b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">index 52fed16..82ab1c3 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"></span>
 #include &quot;conf_space.h&quot;
 #include &quot;conf_space_quirks.h&quot;
 
<span class="p_del">-static int permissive;</span>
<span class="p_add">+bool permissive;</span>
 module_param(permissive, bool, 0644);
 
 /* This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.h b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">index e56c934..2e1d73d 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_chunk">@@ -64,6 +64,8 @@</span> <span class="p_context"> struct config_field_entry {</span>
 	void *data;
 };
 
<span class="p_add">+extern bool permissive;</span>
<span class="p_add">+</span>
 #define OFFSET(cfg_entry) ((cfg_entry)-&gt;base_offset+(cfg_entry)-&gt;field-&gt;offset)
 
 /* Add fields to a device - the add_fields macro expects to get a pointer to
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space_header.c b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">index 3daf862..a5bb81a 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_chunk">@@ -9,6 +9,10 @@</span> <span class="p_context"></span>
 #include &quot;pciback.h&quot;
 #include &quot;conf_space.h&quot;
 
<span class="p_add">+struct pci_cmd_info {</span>
<span class="p_add">+	u16 val;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct pci_bar_info {
 	u32 val;
 	u32 len_val;
<span class="p_chunk">@@ -18,22 +22,36 @@</span> <span class="p_context"> struct pci_bar_info {</span>
 #define is_enable_cmd(value) ((value)&amp;(PCI_COMMAND_MEMORY|PCI_COMMAND_IO))
 #define is_master_cmd(value) ((value)&amp;PCI_COMMAND_MASTER)
 
<span class="p_del">-static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)</span>
<span class="p_add">+/* Bits guests are allowed to control in permissive mode. */</span>
<span class="p_add">+#define PCI_COMMAND_GUEST (PCI_COMMAND_MASTER|PCI_COMMAND_SPECIAL| \</span>
<span class="p_add">+			   PCI_COMMAND_INVALIDATE|PCI_COMMAND_VGA_PALETTE| \</span>
<span class="p_add">+			   PCI_COMMAND_WAIT|PCI_COMMAND_FAST_BACK)</span>
<span class="p_add">+</span>
<span class="p_add">+static void *command_init(struct pci_dev *dev, int offset)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = xen_pcibk_read_config_word(dev, offset, value, data);</span>
<span class="p_del">-	if (!pci_is_enabled(dev))</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; PCI_ROM_RESOURCE; i++) {</span>
<span class="p_del">-		if (dev-&gt;resource[i].flags &amp; IORESOURCE_IO)</span>
<span class="p_del">-			*value |= PCI_COMMAND_IO;</span>
<span class="p_del">-		if (dev-&gt;resource[i].flags &amp; IORESOURCE_MEM)</span>
<span class="p_del">-			*value |= PCI_COMMAND_MEMORY;</span>
<span class="p_add">+	struct pci_cmd_info *cmd = kmalloc(sizeof(*cmd), GFP_KERNEL);</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cmd)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = pci_read_config_word(dev, PCI_COMMAND, &amp;cmd-&gt;val);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		kfree(cmd);</span>
<span class="p_add">+		return ERR_PTR(err);</span>
 	}
 
<span class="p_add">+	return cmd;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = pci_read_config_word(dev, offset, value);</span>
<span class="p_add">+	const struct pci_cmd_info *cmd = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	*value &amp;= PCI_COMMAND_GUEST;</span>
<span class="p_add">+	*value |= cmd-&gt;val &amp; ~PCI_COMMAND_GUEST;</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -41,6 +59,8 @@</span> <span class="p_context"> static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)</span>
 {
 	struct xen_pcibk_dev_data *dev_data;
 	int err;
<span class="p_add">+	u16 val;</span>
<span class="p_add">+	struct pci_cmd_info *cmd = data;</span>
 
 	dev_data = pci_get_drvdata(dev);
 	if (!pci_is_enabled(dev) &amp;&amp; is_enable_cmd(value)) {
<span class="p_chunk">@@ -83,6 +103,19 @@</span> <span class="p_context"> static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)</span>
 		}
 	}
 
<span class="p_add">+	cmd-&gt;val = value;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only allow the guest to control certain bits. */</span>
<span class="p_add">+	err = pci_read_config_word(dev, offset, &amp;val);</span>
<span class="p_add">+	if (err || val == value)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	value &amp;= PCI_COMMAND_GUEST;</span>
<span class="p_add">+	value |= val &amp; ~PCI_COMMAND_GUEST;</span>
<span class="p_add">+</span>
 	return pci_write_config_word(dev, offset, value);
 }
 
<span class="p_chunk">@@ -282,6 +315,8 @@</span> <span class="p_context"> static const struct config_field header_common[] = {</span>
 	{
 	 .offset    = PCI_COMMAND,
 	 .size      = 2,
<span class="p_add">+	 .init      = command_init,</span>
<span class="p_add">+	 .release   = bar_release,</span>
 	 .u.w.read  = command_read,
 	 .u.w.write = command_write,
 	},
<span class="p_header">diff --git a/fs/autofs4/dev-ioctl.c b/fs/autofs4/dev-ioctl.c</span>
<span class="p_header">index de54271..62d7a6d 100644</span>
<span class="p_header">--- a/fs/autofs4/dev-ioctl.c</span>
<span class="p_header">+++ b/fs/autofs4/dev-ioctl.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static int check_dev_ioctl_version(int cmd, struct autofs_dev_ioctl *param)</span>
  */
 static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *in)
 {
<span class="p_del">-	struct autofs_dev_ioctl tmp;</span>
<span class="p_add">+	struct autofs_dev_ioctl tmp, *res;</span>
 
 	if (copy_from_user(&amp;tmp, in, sizeof(tmp)))
 		return ERR_PTR(-EFAULT);
<span class="p_chunk">@@ -103,7 +103,14 @@</span> <span class="p_context"> static struct autofs_dev_ioctl *copy_dev_ioctl(struct autofs_dev_ioctl __user *i</span>
 	if (tmp.size &lt; sizeof(tmp))
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	return memdup_user(in, tmp.size);</span>
<span class="p_add">+	if (tmp.size &gt; (PATH_MAX + sizeof(tmp)))</span>
<span class="p_add">+		return ERR_PTR(-ENAMETOOLONG);</span>
<span class="p_add">+</span>
<span class="p_add">+	res = memdup_user(in, tmp.size);</span>
<span class="p_add">+	if (!IS_ERR(res))</span>
<span class="p_add">+		res-&gt;size = tmp.size;</span>
<span class="p_add">+</span>
<span class="p_add">+	return res;</span>
 }
 
 static inline void free_dev_ioctl(struct autofs_dev_ioctl *param)
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 8dd615c..2aed667 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -542,11 +542,12 @@</span> <span class="p_context"> out:</span>
 
 static unsigned long randomize_stack_top(unsigned long stack_top)
 {
<span class="p_del">-	unsigned int random_variable = 0;</span>
<span class="p_add">+	unsigned long random_variable = 0;</span>
 
 	if ((current-&gt;flags &amp; PF_RANDOMIZE) &amp;&amp;
 		!(current-&gt;personality &amp; ADDR_NO_RANDOMIZE)) {
<span class="p_del">-		random_variable = get_random_int() &amp; STACK_RND_MASK;</span>
<span class="p_add">+		random_variable = (unsigned long) get_random_int();</span>
<span class="p_add">+		random_variable &amp;= STACK_RND_MASK;</span>
 		random_variable &lt;&lt;= PAGE_SHIFT;
 	}
 #ifdef CONFIG_STACK_GROWSUP
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index aa05d5e..f9d2863 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -1608,6 +1608,7 @@</span> <span class="p_context"> refind_writable:</span>
 			cifsFileInfo_put(inv_file);
 			spin_lock(&amp;cifs_file_list_lock);
 			++refind;
<span class="p_add">+			inv_file = NULL;</span>
 			goto refind_writable;
 		}
 	}
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index 6ac0893..a15f1e2 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -125,11 +125,30 @@</span> <span class="p_context"> static inline int debugfs_positive(struct dentry *dentry)</span>
 	return dentry-&gt;d_inode &amp;&amp; !d_unhashed(dentry);
 }
 
<span class="p_add">+static void debugfs_evict_inode(struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	truncate_inode_pages(&amp;inode-&gt;i_data, 0);</span>
<span class="p_add">+	end_writeback(inode);</span>
<span class="p_add">+	if (S_ISLNK(inode-&gt;i_mode))</span>
<span class="p_add">+		kfree(inode-&gt;i_private);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct super_operations debugfs_super_operations = {</span>
<span class="p_add">+	.evict_inode	= debugfs_evict_inode,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int debug_fill_super(struct super_block *sb, void *data, int silent)
 {
 	static struct tree_descr debug_files[] = {{&quot;&quot;}};
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	return simple_fill_super(sb, DEBUGFS_MAGIC, debug_files);</span>
<span class="p_add">+	err = simple_fill_super(sb, DEBUGFS_MAGIC, debug_files);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	sb-&gt;s_op = &amp;debugfs_super_operations;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static struct dentry *debug_mount(struct file_system_type *fs_type,
<span class="p_chunk">@@ -312,23 +331,14 @@</span> <span class="p_context"> static int __debugfs_remove(struct dentry *dentry, struct dentry *parent)</span>
 	int ret = 0;
 
 	if (debugfs_positive(dentry)) {
<span class="p_del">-		if (dentry-&gt;d_inode) {</span>
<span class="p_del">-			dget(dentry);</span>
<span class="p_del">-			switch (dentry-&gt;d_inode-&gt;i_mode &amp; S_IFMT) {</span>
<span class="p_del">-			case S_IFDIR:</span>
<span class="p_del">-				ret = simple_rmdir(parent-&gt;d_inode, dentry);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case S_IFLNK:</span>
<span class="p_del">-				kfree(dentry-&gt;d_inode-&gt;i_private);</span>
<span class="p_del">-				/* fall through */</span>
<span class="p_del">-			default:</span>
<span class="p_del">-				simple_unlink(parent-&gt;d_inode, dentry);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (!ret)</span>
<span class="p_del">-				d_delete(dentry);</span>
<span class="p_del">-			dput(dentry);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		dget(dentry);</span>
<span class="p_add">+		if (S_ISDIR(dentry-&gt;d_inode-&gt;i_mode))</span>
<span class="p_add">+			ret = simple_rmdir(parent-&gt;d_inode, dentry);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			simple_unlink(parent-&gt;d_inode, dentry);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			d_delete(dentry);</span>
<span class="p_add">+		dput(dentry);</span>
 	}
 	return ret;
 }
<span class="p_header">diff --git a/fs/ecryptfs/file.c b/fs/ecryptfs/file.c</span>
<span class="p_header">index 80fc876..464fe1f 100644</span>
<span class="p_header">--- a/fs/ecryptfs/file.c</span>
<span class="p_header">+++ b/fs/ecryptfs/file.c</span>
<span class="p_chunk">@@ -307,9 +307,23 @@</span> <span class="p_context"> ecryptfs_unlocked_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 
 	if (ecryptfs_file_to_private(file))
 		lower_file = ecryptfs_file_to_lower(file);
<span class="p_del">-	if (lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;unlocked_ioctl)</span>
<span class="p_add">+	if (!(lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;unlocked_ioctl))</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case FITRIM:</span>
<span class="p_add">+	case FS_IOC_GETFLAGS:</span>
<span class="p_add">+	case FS_IOC_SETFLAGS:</span>
<span class="p_add">+	case FS_IOC_GETVERSION:</span>
<span class="p_add">+	case FS_IOC_SETVERSION:</span>
 		rc = lower_file-&gt;f_op-&gt;unlocked_ioctl(lower_file, cmd, arg);
<span class="p_del">-	return rc;</span>
<span class="p_add">+		fsstack_copy_attr_all(file-&gt;f_path.dentry-&gt;d_inode,</span>
<span class="p_add">+				      lower_file-&gt;f_path.dentry-&gt;d_inode);</span>
<span class="p_add">+</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	}</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_chunk">@@ -321,9 +335,23 @@</span> <span class="p_context"> ecryptfs_compat_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 
 	if (ecryptfs_file_to_private(file))
 		lower_file = ecryptfs_file_to_lower(file);
<span class="p_del">-	if (lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;compat_ioctl)</span>
<span class="p_add">+	if (!(lower_file &amp;&amp; lower_file-&gt;f_op &amp;&amp; lower_file-&gt;f_op-&gt;compat_ioctl))</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case FITRIM:</span>
<span class="p_add">+	case FS_IOC32_GETFLAGS:</span>
<span class="p_add">+	case FS_IOC32_SETFLAGS:</span>
<span class="p_add">+	case FS_IOC32_GETVERSION:</span>
<span class="p_add">+	case FS_IOC32_SETVERSION:</span>
 		rc = lower_file-&gt;f_op-&gt;compat_ioctl(lower_file, cmd, arg);
<span class="p_del">-	return rc;</span>
<span class="p_add">+		fsstack_copy_attr_all(file-&gt;f_path.dentry-&gt;d_inode,</span>
<span class="p_add">+				      lower_file-&gt;f_path.dentry-&gt;d_inode);</span>
<span class="p_add">+</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	}</span>
 }
 #endif
 
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 78199eb..7adb43f 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -1282,6 +1282,45 @@</span> <span class="p_context"> int check_unsafe_exec(struct linux_binprm *bprm)</span>
 	return res;
 }
 
<span class="p_add">+static void bprm_fill_uid(struct linux_binprm *bprm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode;</span>
<span class="p_add">+	unsigned int mode;</span>
<span class="p_add">+	uid_t uid;</span>
<span class="p_add">+	gid_t gid;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_add">+	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_add">+	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;</span>
<span class="p_add">+	mode = ACCESS_ONCE(inode-&gt;i_mode);</span>
<span class="p_add">+	if (!(mode &amp; (S_ISUID|S_ISGID)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Be careful if suid/sgid is set */</span>
<span class="p_add">+	mutex_lock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reload atomically mode/uid/gid now that lock held */</span>
<span class="p_add">+	mode = inode-&gt;i_mode;</span>
<span class="p_add">+	uid = inode-&gt;i_uid;</span>
<span class="p_add">+	gid = inode-&gt;i_gid;</span>
<span class="p_add">+	mutex_unlock(&amp;inode-&gt;i_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mode &amp; S_ISUID) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;euid = uid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_add">+		bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_add">+		bprm-&gt;cred-&gt;egid = gid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* 
  * Fill the binprm structure from the inode. 
  * Check permissions, then read the first 128 (BINPRM_BUF_SIZE) bytes
<span class="p_chunk">@@ -1290,36 +1329,12 @@</span> <span class="p_context"> int check_unsafe_exec(struct linux_binprm *bprm)</span>
  */
 int prepare_binprm(struct linux_binprm *bprm)
 {
<span class="p_del">-	umode_t mode;</span>
<span class="p_del">-	struct inode * inode = bprm-&gt;file-&gt;f_path.dentry-&gt;d_inode;</span>
 	int retval;
 
<span class="p_del">-	mode = inode-&gt;i_mode;</span>
 	if (bprm-&gt;file-&gt;f_op == NULL)
 		return -EACCES;
 
<span class="p_del">-	/* clear any previous set[ug]id data from a previous binary */</span>
<span class="p_del">-	bprm-&gt;cred-&gt;euid = current_euid();</span>
<span class="p_del">-	bprm-&gt;cred-&gt;egid = current_egid();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(bprm-&gt;file-&gt;f_path.mnt-&gt;mnt_flags &amp; MNT_NOSUID)) {</span>
<span class="p_del">-		/* Set-uid? */</span>
<span class="p_del">-		if (mode &amp; S_ISUID) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;euid = inode-&gt;i_uid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Set-gid? */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If setgid is set but no group execute bit then this</span>
<span class="p_del">-		 * is a candidate for mandatory locking, not a setgid</span>
<span class="p_del">-		 * executable.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_del">-			bprm-&gt;per_clear |= PER_CLEAR_ON_SETID;</span>
<span class="p_del">-			bprm-&gt;cred-&gt;egid = inode-&gt;i_gid;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	bprm_fill_uid(bprm);</span>
 
 	/* fill in binprm security blob */
 	retval = security_bprm_set_creds(bprm);
<span class="p_header">diff --git a/fs/fuse/dev.c b/fs/fuse/dev.c</span>
<span class="p_header">index cf0098d..81970d7 100644</span>
<span class="p_header">--- a/fs/fuse/dev.c</span>
<span class="p_header">+++ b/fs/fuse/dev.c</span>
<span class="p_chunk">@@ -717,8 +717,8 @@</span> <span class="p_context"> static int fuse_try_move_page(struct fuse_copy_state *cs, struct page **pagep)</span>
 
 	newpage = buf-&gt;page;
 
<span class="p_del">-	if (WARN_ON(!PageUptodate(newpage)))</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+	if (!PageUptodate(newpage))</span>
<span class="p_add">+		SetPageUptodate(newpage);</span>
 
 	ClearPageMappedToDisk(newpage);
 
<span class="p_chunk">@@ -1570,6 +1570,9 @@</span> <span class="p_context"> copy_finish:</span>
 static int fuse_notify(struct fuse_conn *fc, enum fuse_notify_code code,
 		       unsigned int size, struct fuse_copy_state *cs)
 {
<span class="p_add">+	/* Don&#39;t try to move pages (yet) */</span>
<span class="p_add">+	cs-&gt;move_pages = 0;</span>
<span class="p_add">+</span>
 	switch (code) {
 	case FUSE_NOTIFY_POLL:
 		return fuse_notify_poll(fc, size, cs);
<span class="p_header">diff --git a/fs/hfsplus/brec.c b/fs/hfsplus/brec.c</span>
<span class="p_header">index 2a734cf..7429c40 100644</span>
<span class="p_header">--- a/fs/hfsplus/brec.c</span>
<span class="p_header">+++ b/fs/hfsplus/brec.c</span>
<span class="p_chunk">@@ -130,13 +130,16 @@</span> <span class="p_context"> skip:</span>
 	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
 	hfs_bnode_dump(node);
 
<span class="p_del">-	if (new_node) {</span>
<span class="p_del">-		/* update parent key if we inserted a key</span>
<span class="p_del">-		 * at the start of the first node</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!rec &amp;&amp; new_node != node)</span>
<span class="p_del">-			hfs_brec_update_parent(fd);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * update parent key if we inserted a key</span>
<span class="p_add">+	 * at the start of the node and it is not the new node</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!rec &amp;&amp; new_node != node) {</span>
<span class="p_add">+		hfs_bnode_read_key(node, fd-&gt;search_key, data_off + size);</span>
<span class="p_add">+		hfs_brec_update_parent(fd);</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	if (new_node) {</span>
 		hfs_bnode_put(fd-&gt;bnode);
 		if (!new_node-&gt;parent) {
 			hfs_btree_inc_height(tree);
<span class="p_chunk">@@ -166,9 +169,6 @@</span> <span class="p_context"> skip:</span>
 		goto again;
 	}
 
<span class="p_del">-	if (!rec)</span>
<span class="p_del">-		hfs_brec_update_parent(fd);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -368,6 +368,8 @@</span> <span class="p_context"> again:</span>
 	if (IS_ERR(parent))
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd);
<span class="p_add">+	if (fd-&gt;record &lt; 0)</span>
<span class="p_add">+		return -ENOENT;</span>
 	hfs_bnode_dump(parent);
 	rec = fd-&gt;record;
 
<span class="p_header">diff --git a/fs/jffs2/scan.c b/fs/jffs2/scan.c</span>
<span class="p_header">index 28107ca..327cc17 100644</span>
<span class="p_header">--- a/fs/jffs2/scan.c</span>
<span class="p_header">+++ b/fs/jffs2/scan.c</span>
<span class="p_chunk">@@ -503,6 +503,10 @@</span> <span class="p_context"> static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblo</span>
 				sumlen = c-&gt;sector_size - je32_to_cpu(sm-&gt;offset);
 				sumptr = buf + buf_size - sumlen;
 
<span class="p_add">+				/* sm-&gt;offset maybe wrong but MAGIC maybe right */</span>
<span class="p_add">+				if (sumlen &gt; c-&gt;sector_size)</span>
<span class="p_add">+					goto full_scan;</span>
<span class="p_add">+</span>
 				/* Now, make sure the summary itself is available */
 				if (sumlen &gt; buf_size) {
 					/* Need to kmalloc for this. */
<span class="p_chunk">@@ -537,6 +541,7 @@</span> <span class="p_context"> static int jffs2_scan_eraseblock (struct jffs2_sb_info *c, struct jffs2_eraseblo</span>
 		}
 	}
 
<span class="p_add">+full_scan:</span>
 	buf_ofs = jeb-&gt;offset;
 
 	if (!buf_size) {
<span class="p_header">diff --git a/fs/jfs/jfs_dtree.c b/fs/jfs/jfs_dtree.c</span>
<span class="p_header">index 9f7c758..f6f32fa 100644</span>
<span class="p_header">--- a/fs/jfs/jfs_dtree.c</span>
<span class="p_header">+++ b/fs/jfs/jfs_dtree.c</span>
<span class="p_chunk">@@ -3103,7 +3103,7 @@</span> <span class="p_context"> int jfs_readdir(struct file *filp, void *dirent, filldir_t filldir)</span>
 				 * self &quot;.&quot;
 				 */
 				filp-&gt;f_pos = 1;
<span class="p_del">-				if (filldir(dirent, &quot;.&quot;, 1, 0, ip-&gt;i_ino,</span>
<span class="p_add">+				if (filldir(dirent, &quot;.&quot;, 1, 1, ip-&gt;i_ino,</span>
 					    DT_DIR))
 					return 0;
 			}
<span class="p_chunk">@@ -3111,7 +3111,7 @@</span> <span class="p_context"> int jfs_readdir(struct file *filp, void *dirent, filldir_t filldir)</span>
 			 * parent &quot;..&quot;
 			 */
 			filp-&gt;f_pos = 2;
<span class="p_del">-			if (filldir(dirent, &quot;..&quot;, 2, 1, PARENT(ip), DT_DIR))</span>
<span class="p_add">+			if (filldir(dirent, &quot;..&quot;, 2, 2, PARENT(ip), DT_DIR))</span>
 				return 0;
 
 			/*
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 516f337..3172b51 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -149,22 +149,24 @@</span> <span class="p_context"> nfs41_callback_svc(void *vrqstp)</span>
 	set_freezable();
 
 	while (!kthread_should_stop()) {
<span class="p_del">-		prepare_to_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq, TASK_INTERRUPTIBLE);</span>
<span class="p_add">+		prepare_to_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq, TASK_UNINTERRUPTIBLE);</span>
 		spin_lock_bh(&amp;serv-&gt;sv_cb_lock);
 		if (!list_empty(&amp;serv-&gt;sv_cb_list)) {
 			req = list_first_entry(&amp;serv-&gt;sv_cb_list,
 					struct rpc_rqst, rq_bc_list);
 			list_del(&amp;req-&gt;rq_bc_list);
 			spin_unlock_bh(&amp;serv-&gt;sv_cb_lock);
<span class="p_add">+			finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
 			dprintk(&quot;Invoking bc_svc_process()\n&quot;);
 			error = bc_svc_process(serv, req, rqstp);
 			dprintk(&quot;bc_svc_process() returned w/ error code= %d\n&quot;,
 				error);
 		} else {
 			spin_unlock_bh(&amp;serv-&gt;sv_cb_lock);
<span class="p_del">-			schedule();</span>
<span class="p_add">+			/* schedule_timeout to game the hung task watchdog */</span>
<span class="p_add">+			schedule_timeout(60 * HZ);</span>
<span class="p_add">+			finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
 		}
<span class="p_del">-		finish_wait(&amp;serv-&gt;sv_cb_waitq, &amp;wq);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c</span>
<span class="p_header">index 3fde055..6d22d35 100644</span>
<span class="p_header">--- a/fs/nfs/callback_xdr.c</span>
<span class="p_header">+++ b/fs/nfs/callback_xdr.c</span>
<span class="p_chunk">@@ -459,8 +459,10 @@</span> <span class="p_context"> static __be32 decode_cb_sequence_args(struct svc_rqst *rqstp,</span>
 
 		for (i = 0; i &lt; args-&gt;csa_nrclists; i++) {
 			status = decode_rc_list(xdr, &amp;args-&gt;csa_rclists[i]);
<span class="p_del">-			if (status)</span>
<span class="p_add">+			if (status) {</span>
<span class="p_add">+				args-&gt;csa_nrclists = i;</span>
 				goto out_free;
<span class="p_add">+			}</span>
 		}
 	}
 	status = 0;
<span class="p_header">diff --git a/fs/nfs/delegation.c b/fs/nfs/delegation.c</span>
<span class="p_header">index ac889af..92cf07d 100644</span>
<span class="p_header">--- a/fs/nfs/delegation.c</span>
<span class="p_header">+++ b/fs/nfs/delegation.c</span>
<span class="p_chunk">@@ -149,8 +149,8 @@</span> <span class="p_context"> void nfs_inode_reclaim_delegation(struct inode *inode, struct rpc_cred *cred,</span>
 				  &amp;delegation-&gt;flags);
 			NFS_I(inode)-&gt;delegation_state = delegation-&gt;type;
 			spin_unlock(&amp;delegation-&gt;lock);
<span class="p_del">-			put_rpccred(oldcred);</span>
 			rcu_read_unlock();
<span class="p_add">+			put_rpccred(oldcred);</span>
 		} else {
 			/* We appear to have raced with a delegation return. */
 			spin_unlock(&amp;delegation-&gt;lock);
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 351989e..e83786f 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> static int nfs4_handle_exception(struct nfs_server *server, int errorcode, struc</span>
 		case 0:
 			return 0;
 		case -NFS4ERR_OPENMODE:
<span class="p_del">-			if (nfs_have_delegation(inode, FMODE_READ)) {</span>
<span class="p_add">+			if (inode &amp;&amp; nfs_have_delegation(inode, FMODE_READ)) {</span>
 				nfs_inode_return_delegation(inode);
 				exception-&gt;retry = 1;
 				return 0;
<span class="p_chunk">@@ -279,10 +279,9 @@</span> <span class="p_context"> static int nfs4_handle_exception(struct nfs_server *server, int errorcode, struc</span>
 		case -NFS4ERR_DELEG_REVOKED:
 		case -NFS4ERR_ADMIN_REVOKED:
 		case -NFS4ERR_BAD_STATEID:
<span class="p_del">-			if (state != NULL)</span>
<span class="p_del">-				nfs_remove_bad_delegation(state-&gt;inode);</span>
 			if (state == NULL)
 				break;
<span class="p_add">+			nfs_remove_bad_delegation(state-&gt;inode);</span>
 			nfs4_schedule_stateid_recovery(server, state);
 			goto wait_on_recovery;
 		case -NFS4ERR_EXPIRED:
<span class="p_chunk">@@ -3746,8 +3745,9 @@</span> <span class="p_context"> nfs4_async_handle_error(struct rpc_task *task, const struct nfs_server *server,</span>
 		case -NFS4ERR_DELEG_REVOKED:
 		case -NFS4ERR_ADMIN_REVOKED:
 		case -NFS4ERR_BAD_STATEID:
<span class="p_del">-			if (state != NULL)</span>
<span class="p_del">-				nfs_remove_bad_delegation(state-&gt;inode);</span>
<span class="p_add">+			if (state == NULL)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			nfs_remove_bad_delegation(state-&gt;inode);</span>
 		case -NFS4ERR_OPENMODE:
 			if (state == NULL)
 				break;
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index b2e3ff3..ecdbae1 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -31,6 +31,8 @@</span> <span class="p_context"></span>
 #include &quot;alloc.h&quot;
 #include &quot;dat.h&quot;
 
<span class="p_add">+static void __nilfs_btree_init(struct nilfs_bmap *bmap);</span>
<span class="p_add">+</span>
 static struct nilfs_btree_path *nilfs_btree_alloc_path(void)
 {
 	struct nilfs_btree_path *path;
<span class="p_chunk">@@ -368,6 +370,34 @@</span> <span class="p_context"> static int nilfs_btree_node_broken(const struct nilfs_btree_node *node,</span>
 	return ret;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * nilfs_btree_root_broken - verify consistency of btree root node</span>
<span class="p_add">+ * @node: btree root node to be examined</span>
<span class="p_add">+ * @ino: inode number</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return Value: If node is broken, 1 is returned. Otherwise, 0 is returned.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,</span>
<span class="p_add">+				   unsigned long ino)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int level, flags, nchildren;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	level = nilfs_btree_node_get_level(node);</span>
<span class="p_add">+	flags = nilfs_btree_node_get_flags(node);</span>
<span class="p_add">+	nchildren = nilfs_btree_node_get_nchildren(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(level &lt; NILFS_BTREE_LEVEL_NODE_MIN ||</span>
<span class="p_add">+		     level &gt; NILFS_BTREE_LEVEL_MAX ||</span>
<span class="p_add">+		     nchildren &lt; 0 ||</span>
<span class="p_add">+		     nchildren &gt; NILFS_BTREE_ROOT_NCHILDREN_MAX)) {</span>
<span class="p_add">+		pr_crit(&quot;NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n&quot;,</span>
<span class="p_add">+			ino, level, flags, nchildren);</span>
<span class="p_add">+		ret = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int nilfs_btree_broken_node_block(struct buffer_head *bh)
 {
 	int ret;
<span class="p_chunk">@@ -1713,7 +1743,7 @@</span> <span class="p_context"> nilfs_btree_commit_convert_and_insert(struct nilfs_bmap *btree,</span>
 
 	/* convert and insert */
 	dat = NILFS_BMAP_USE_VBN(btree) ? nilfs_bmap_get_dat(btree) : NULL;
<span class="p_del">-	nilfs_btree_init(btree);</span>
<span class="p_add">+	__nilfs_btree_init(btree);</span>
 	if (nreq != NULL) {
 		nilfs_bmap_commit_alloc_ptr(btree, dreq, dat);
 		nilfs_bmap_commit_alloc_ptr(btree, nreq, dat);
<span class="p_chunk">@@ -2294,12 +2324,23 @@</span> <span class="p_context"> static const struct nilfs_bmap_operations nilfs_btree_ops_gc = {</span>
 	.bop_gather_data	=	NULL,
 };
 
<span class="p_del">-int nilfs_btree_init(struct nilfs_bmap *bmap)</span>
<span class="p_add">+static void __nilfs_btree_init(struct nilfs_bmap *bmap)</span>
 {
 	bmap-&gt;b_ops = &amp;nilfs_btree_ops;
 	bmap-&gt;b_nchildren_per_block =
 		NILFS_BTREE_NODE_NCHILDREN_MAX(nilfs_btree_node_size(bmap));
<span class="p_del">-	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int nilfs_btree_init(struct nilfs_bmap *bmap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	__nilfs_btree_init(bmap);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nilfs_btree_root_broken(nilfs_btree_get_root(bmap),</span>
<span class="p_add">+				    bmap-&gt;b_inode-&gt;i_ino))</span>
<span class="p_add">+		ret = -EIO;</span>
<span class="p_add">+	return ret;</span>
 }
 
 void nilfs_btree_init_gc(struct nilfs_bmap *bmap)
<span class="p_header">diff --git a/fs/nilfs2/segment.c b/fs/nilfs2/segment.c</span>
<span class="p_header">index eb7f6a6..6bba106 100644</span>
<span class="p_header">--- a/fs/nilfs2/segment.c</span>
<span class="p_header">+++ b/fs/nilfs2/segment.c</span>
<span class="p_chunk">@@ -1903,6 +1903,7 @@</span> <span class="p_context"> static void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,</span>
 					     struct the_nilfs *nilfs)
 {
 	struct nilfs_inode_info *ii, *n;
<span class="p_add">+	int during_mount = !(sci-&gt;sc_super-&gt;s_flags &amp; MS_ACTIVE);</span>
 	int defer_iput = false;
 
 	spin_lock(&amp;nilfs-&gt;ns_inode_lock);
<span class="p_chunk">@@ -1915,10 +1916,10 @@</span> <span class="p_context"> static void nilfs_segctor_drop_written_files(struct nilfs_sc_info *sci,</span>
 		brelse(ii-&gt;i_bh);
 		ii-&gt;i_bh = NULL;
 		list_del_init(&amp;ii-&gt;i_dirty);
<span class="p_del">-		if (!ii-&gt;vfs_inode.i_nlink) {</span>
<span class="p_add">+		if (!ii-&gt;vfs_inode.i_nlink || during_mount) {</span>
 			/*
<span class="p_del">-			 * Defer calling iput() to avoid a deadlock</span>
<span class="p_del">-			 * over I_SYNC flag for inodes with i_nlink == 0</span>
<span class="p_add">+			 * Defer calling iput() to avoid deadlocks if</span>
<span class="p_add">+			 * i_nlink == 0 or mount is not yet finished.</span>
 			 */
 			list_add_tail(&amp;ii-&gt;i_dirty, &amp;sci-&gt;sc_iput_queue);
 			defer_iput = true;
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index 0de24a2..6a7a3d9 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -2387,10 +2387,14 @@</span> <span class="p_context"> out_dio:</span>
 	/* buffered aio wouldn&#39;t have proper lock coverage today */
 	BUG_ON(ret == -EIOCBQUEUED &amp;&amp; !(file-&gt;f_flags &amp; O_DIRECT));
 
<span class="p_add">+	if (unlikely(written &lt;= 0))</span>
<span class="p_add">+		goto no_sync;</span>
<span class="p_add">+</span>
 	if (((file-&gt;f_flags &amp; O_DSYNC) &amp;&amp; !direct_io) || IS_SYNC(inode) ||
 	    ((file-&gt;f_flags &amp; O_DIRECT) &amp;&amp; !direct_io)) {
<span class="p_del">-		ret = filemap_fdatawrite_range(file-&gt;f_mapping, *ppos,</span>
<span class="p_del">-					       *ppos + count - 1);</span>
<span class="p_add">+		ret = filemap_fdatawrite_range(file-&gt;f_mapping,</span>
<span class="p_add">+					       iocb-&gt;ki_pos - written,</span>
<span class="p_add">+					       iocb-&gt;ki_pos - 1);</span>
 		if (ret &lt; 0)
 			written = ret;
 
<span class="p_chunk">@@ -2403,10 +2407,12 @@</span> <span class="p_context"> out_dio:</span>
 		}
 
 		if (!ret)
<span class="p_del">-			ret = filemap_fdatawait_range(file-&gt;f_mapping, *ppos,</span>
<span class="p_del">-						      *ppos + count - 1);</span>
<span class="p_add">+			ret = filemap_fdatawait_range(file-&gt;f_mapping,</span>
<span class="p_add">+						      iocb-&gt;ki_pos - written,</span>
<span class="p_add">+						      iocb-&gt;ki_pos - 1);</span>
 	}
 
<span class="p_add">+no_sync:</span>
 	/*
 	 * deep in g_f_a_w_n()-&gt;ocfs2_direct_IO we pass in a ocfs2_dio_end_io
 	 * function pointer which is called when o_direct io completes so that
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index ef1740d..d1bd6a9 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -864,9 +864,19 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_add">+static int pagemap_open(struct inode *inode, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* do not disclose physical addresses to unprivileged</span>
<span class="p_add">+	   userspace (closes a rowhammer attack vector) */</span>
<span class="p_add">+	if (!capable(CAP_SYS_ADMIN))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 const struct file_operations proc_pagemap_operations = {
 	.llseek		= mem_lseek, /* borrow this */
 	.read		= pagemap_read,
<span class="p_add">+	.open		= pagemap_open,</span>
 };
 #endif /* CONFIG_PROC_PAGE_MONITOR */
 
<span class="p_header">diff --git a/fs/udf/inode.c b/fs/udf/inode.c</span>
<span class="p_header">index 2a706bb..e081440 100644</span>
<span class="p_header">--- a/fs/udf/inode.c</span>
<span class="p_header">+++ b/fs/udf/inode.c</span>
<span class="p_chunk">@@ -1271,6 +1271,7 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 	struct udf_sb_info *sbi = UDF_SB(inode-&gt;i_sb);
 	struct udf_inode_info *iinfo = UDF_I(inode);
 	unsigned int link_count;
<span class="p_add">+	int bs = inode-&gt;i_sb-&gt;s_blocksize;</span>
 
 	fe = (struct fileEntry *)bh-&gt;b_data;
 	efe = (struct extendedFileEntry *)bh-&gt;b_data;
<span class="p_chunk">@@ -1291,41 +1292,38 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 	if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_EFE)) {
 		iinfo-&gt;i_efe = 1;
 		iinfo-&gt;i_use = 0;
<span class="p_del">-		if (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_add">+		if (udf_alloc_i_data(inode, bs -</span>
 					sizeof(struct extendedFileEntry))) {
 			make_bad_inode(inode);
 			return;
 		}
 		memcpy(iinfo-&gt;i_ext.i_data,
 		       bh-&gt;b_data + sizeof(struct extendedFileEntry),
<span class="p_del">-		       inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-					sizeof(struct extendedFileEntry));</span>
<span class="p_add">+		       bs - sizeof(struct extendedFileEntry));</span>
 	} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_FE)) {
 		iinfo-&gt;i_efe = 0;
 		iinfo-&gt;i_use = 0;
<span class="p_del">-		if (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-						sizeof(struct fileEntry))) {</span>
<span class="p_add">+		if (udf_alloc_i_data(inode, bs - sizeof(struct fileEntry))) {</span>
 			make_bad_inode(inode);
 			return;
 		}
 		memcpy(iinfo-&gt;i_ext.i_data,
 		       bh-&gt;b_data + sizeof(struct fileEntry),
<span class="p_del">-		       inode-&gt;i_sb-&gt;s_blocksize - sizeof(struct fileEntry));</span>
<span class="p_add">+		       bs - sizeof(struct fileEntry));</span>
 	} else if (fe-&gt;descTag.tagIdent == cpu_to_le16(TAG_IDENT_USE)) {
 		iinfo-&gt;i_efe = 0;
 		iinfo-&gt;i_use = 1;
 		iinfo-&gt;i_lenAlloc = le32_to_cpu(
 				((struct unallocSpaceEntry *)bh-&gt;b_data)-&gt;
 				 lengthAllocDescs);
<span class="p_del">-		if (udf_alloc_i_data(inode, inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_add">+		if (udf_alloc_i_data(inode, bs -</span>
 					sizeof(struct unallocSpaceEntry))) {
 			make_bad_inode(inode);
 			return;
 		}
 		memcpy(iinfo-&gt;i_ext.i_data,
 		       bh-&gt;b_data + sizeof(struct unallocSpaceEntry),
<span class="p_del">-		       inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-					sizeof(struct unallocSpaceEntry));</span>
<span class="p_add">+		       bs - sizeof(struct unallocSpaceEntry));</span>
 		return;
 	}
 
<span class="p_chunk">@@ -1403,6 +1401,19 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 							iinfo-&gt;i_lenEAttr;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Sanity check length of allocation descriptors and extended attrs to</span>
<span class="p_add">+	 * avoid integer overflows</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (iinfo-&gt;i_lenEAttr &gt; bs || iinfo-&gt;i_lenAlloc &gt; bs) {</span>
<span class="p_add">+		make_bad_inode(inode);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Now do exact checks */</span>
<span class="p_add">+	if (udf_file_entry_alloc_offset(inode) + iinfo-&gt;i_lenAlloc &gt; bs) {</span>
<span class="p_add">+		make_bad_inode(inode);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	/* Sanity checks for files in ICB so that we don&#39;t get confused later */
 	if (iinfo-&gt;i_alloc_type == ICBTAG_FLAG_AD_IN_ICB) {
 		/*
<span class="p_chunk">@@ -1414,8 +1425,7 @@</span> <span class="p_context"> static void udf_fill_inode(struct inode *inode, struct buffer_head *bh)</span>
 			return;
 		}
 		/* File in ICB has to fit in there... */
<span class="p_del">-		if (inode-&gt;i_size &gt; inode-&gt;i_sb-&gt;s_blocksize -</span>
<span class="p_del">-					udf_file_entry_alloc_offset(inode)) {</span>
<span class="p_add">+		if (inode-&gt;i_size &gt; bs - udf_file_entry_alloc_offset(inode)) {</span>
 			make_bad_inode(inode);
 			return;
 		}
<span class="p_header">diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c</span>
<span class="p_header">index 753ed9b..8ae937a 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_file.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_file.c</span>
<span class="p_chunk">@@ -516,7 +516,8 @@</span> <span class="p_context"> STATIC int				/* error (positive) */</span>
 xfs_zero_last_block(
 	xfs_inode_t	*ip,
 	xfs_fsize_t	offset,
<span class="p_del">-	xfs_fsize_t	isize)</span>
<span class="p_add">+	xfs_fsize_t	isize,</span>
<span class="p_add">+	bool		*did_zeroing)</span>
 {
 	xfs_fileoff_t	last_fsb;
 	xfs_mount_t	*mp = ip-&gt;i_mount;
<span class="p_chunk">@@ -560,6 +561,7 @@</span> <span class="p_context"> xfs_zero_last_block(</span>
 	zero_len = mp-&gt;m_sb.sb_blocksize - zero_offset;
 	if (isize + zero_len &gt; offset)
 		zero_len = offset - isize;
<span class="p_add">+	*did_zeroing = true;</span>
 	error = xfs_iozero(ip, isize, zero_len);
 
 	xfs_ilock(ip, XFS_ILOCK_EXCL);
<span class="p_chunk">@@ -582,7 +584,8 @@</span> <span class="p_context"> int					/* error (positive) */</span>
 xfs_zero_eof(
 	xfs_inode_t	*ip,
 	xfs_off_t	offset,		/* starting I/O offset */
<span class="p_del">-	xfs_fsize_t	isize)		/* current inode size */</span>
<span class="p_add">+	xfs_fsize_t	isize,		/* current inode size */</span>
<span class="p_add">+	bool		*did_zeroing)</span>
 {
 	xfs_mount_t	*mp = ip-&gt;i_mount;
 	xfs_fileoff_t	start_zero_fsb;
<span class="p_chunk">@@ -602,7 +605,7 @@</span> <span class="p_context"> xfs_zero_eof(</span>
 	 * First handle zeroing the block on which isize resides.
 	 * We only zero a part of that block so it is handled specially.
 	 */
<span class="p_del">-	error = xfs_zero_last_block(ip, offset, isize);</span>
<span class="p_add">+	error = xfs_zero_last_block(ip, offset, isize, did_zeroing);</span>
 	if (error) {
 		ASSERT(xfs_isilocked(ip, XFS_ILOCK_EXCL|XFS_IOLOCK_EXCL));
 		return error;
<span class="p_chunk">@@ -672,6 +675,7 @@</span> <span class="p_context"> xfs_zero_eof(</span>
 			goto out_lock;
 		}
 
<span class="p_add">+		*did_zeroing = true;</span>
 		start_zero_fsb = imap.br_startoff + imap.br_blockcount;
 		ASSERT(start_zero_fsb &lt;= (end_zero_fsb + 1));
 
<span class="p_chunk">@@ -729,13 +733,15 @@</span> <span class="p_context"> restart:</span>
 	 */
 	if ((ip-&gt;i_new_size &amp;&amp; *pos &gt; ip-&gt;i_new_size) ||
 	    (!ip-&gt;i_new_size &amp;&amp; *pos &gt; ip-&gt;i_size)) {
<span class="p_add">+		bool	zero = false;</span>
<span class="p_add">+</span>
 		if (*iolock == XFS_IOLOCK_SHARED) {
 			xfs_rw_iunlock(ip, XFS_ILOCK_EXCL | *iolock);
 			*iolock = XFS_IOLOCK_EXCL;
 			xfs_rw_ilock(ip, XFS_ILOCK_EXCL | *iolock);
 			goto restart;
 		}
<span class="p_del">-		error = -xfs_zero_eof(ip, *pos, ip-&gt;i_size);</span>
<span class="p_add">+		error = -xfs_zero_eof(ip, *pos, ip-&gt;i_size, &amp;zero);</span>
 	}
 
 	/*
<span class="p_header">diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c</span>
<span class="p_header">index bd2fb43..1c01f04 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.c</span>
<span class="p_chunk">@@ -766,6 +766,7 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 	int			error;
 	uint			lock_flags;
 	uint			commit_flags = 0;
<span class="p_add">+	bool			did_zeroing = false;</span>
 
 	trace_xfs_setattr(ip);
 
<span class="p_chunk">@@ -812,20 +813,16 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 		goto out_unlock;
 
 	/*
<span class="p_del">-	 * Now we can make the changes.  Before we join the inode to the</span>
<span class="p_del">-	 * transaction, take care of the part of the truncation that must be</span>
<span class="p_del">-	 * done without the inode lock.  This needs to be done before joining</span>
<span class="p_del">-	 * the inode to the transaction, because the inode cannot be unlocked</span>
<span class="p_del">-	 * once it is a part of the transaction.</span>
<span class="p_add">+	 * File data changes must be complete before we start the transaction to</span>
<span class="p_add">+	 * modify the inode.  This needs to be done before joining the inode to</span>
<span class="p_add">+	 * the transaction because the inode cannot be unlocked once it is a</span>
<span class="p_add">+	 * part of the transaction.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Start with zeroing any data block beyond EOF that we may expose on</span>
<span class="p_add">+	 * file extension.</span>
 	 */
 	if (iattr-&gt;ia_size &gt; ip-&gt;i_size) {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Do the first part of growing a file: zero any data in the</span>
<span class="p_del">-		 * last block that is beyond the old EOF.  We need to do this</span>
<span class="p_del">-		 * before the inode is joined to the transaction to modify</span>
<span class="p_del">-		 * i_size.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		error = xfs_zero_eof(ip, iattr-&gt;ia_size, ip-&gt;i_size);</span>
<span class="p_add">+		error = xfs_zero_eof(ip, iattr-&gt;ia_size, ip-&gt;i_size, &amp;did_zeroing);</span>
 		if (error)
 			goto out_unlock;
 	}
<span class="p_chunk">@@ -837,23 +834,18 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 	 * any previous writes that are beyond the on disk EOF and the new
 	 * EOF that have not been written out need to be written here.  If we
 	 * do not write the data out, we expose ourselves to the null files
<span class="p_del">-	 * problem.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Only flush from the on disk size to the smaller of the in memory</span>
<span class="p_del">-	 * file size or the new size as that&#39;s the range we really care about</span>
<span class="p_del">-	 * here and prevents waiting for other data not within the range we</span>
<span class="p_del">-	 * care about here.</span>
<span class="p_add">+	 * problem. Note that this includes any block zeroing we did above;</span>
<span class="p_add">+	 * otherwise those blocks may not be zeroed after a crash.</span>
 	 */
<span class="p_del">-	if (ip-&gt;i_size != ip-&gt;i_d.di_size &amp;&amp; iattr-&gt;ia_size &gt; ip-&gt;i_d.di_size) {</span>
<span class="p_add">+	if (iattr-&gt;ia_size &gt; ip-&gt;i_d.di_size &amp;&amp;</span>
<span class="p_add">+	    (ip-&gt;i_size != ip-&gt;i_d.di_size || did_zeroing)) {</span>
 		error = xfs_flush_pages(ip, ip-&gt;i_d.di_size, iattr-&gt;ia_size, 0,
 					FI_NONE);
 		if (error)
 			goto out_unlock;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Wait for all direct I/O to complete.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Now wait for all direct I/O to complete. */</span>
 	inode_dio_wait(inode);
 
 	error = -block_truncate_page(inode-&gt;i_mapping, iattr-&gt;ia_size,
<span class="p_header">diff --git a/fs/xfs/xfs_vnodeops.h b/fs/xfs/xfs_vnodeops.h</span>
<span class="p_header">index 35d3d51..c0f7714 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_vnodeops.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_vnodeops.h</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"> int xfs_flush_pages(struct xfs_inode *ip, xfs_off_t first,</span>
 		xfs_off_t last, uint64_t flags, int fiopt);
 int xfs_wait_on_pages(struct xfs_inode *ip, xfs_off_t first, xfs_off_t last);
 
<span class="p_del">-int xfs_zero_eof(struct xfs_inode *, xfs_off_t, xfs_fsize_t);</span>
<span class="p_add">+int	xfs_zero_eof(struct xfs_inode *ip, xfs_off_t offset,</span>
<span class="p_add">+		     xfs_fsize_t isize, bool *did_zeroing);</span>
 
 #endif /* _XFS_VNODEOPS_H */
<span class="p_header">diff --git a/include/linux/blk_types.h b/include/linux/blk_types.h</span>
<span class="p_header">index 4053cbd..ddce23d 100644</span>
<span class="p_header">--- a/include/linux/blk_types.h</span>
<span class="p_header">+++ b/include/linux/blk_types.h</span>
<span class="p_chunk">@@ -144,7 +144,9 @@</span> <span class="p_context"> enum rq_flag_bits {</span>
 	__REQ_ELVPRIV,		/* elevator private data attached */
 	__REQ_FAILED,		/* set if the request failed */
 	__REQ_QUIET,		/* don&#39;t worry about errors */
<span class="p_del">-	__REQ_PREEMPT,		/* set for &quot;ide_preempt&quot; requests */</span>
<span class="p_add">+	__REQ_PREEMPT,		/* set for &quot;ide_preempt&quot; requests and also</span>
<span class="p_add">+				   for requests for which the SCSI &quot;quiesce&quot;</span>
<span class="p_add">+				   state must be ignored. */</span>
 	__REQ_ALLOCED,		/* request came from our alloc pool */
 	__REQ_COPY_USER,	/* contains copies of user pages */
 	__REQ_FLUSH_SEQ,	/* request for flush sequence */
<span class="p_header">diff --git a/include/linux/compiler-gcc4.h b/include/linux/compiler-gcc4.h</span>
<span class="p_header">index e2a360a..59a7e4c 100644</span>
<span class="p_header">--- a/include/linux/compiler-gcc4.h</span>
<span class="p_header">+++ b/include/linux/compiler-gcc4.h</span>
<span class="p_chunk">@@ -29,6 +29,8 @@</span> <span class="p_context"></span>
    the kernel context */
 #define __cold			__attribute__((__cold__))
 
<span class="p_add">+#define __linktime_error(message) __attribute__((__error__(message)))</span>
<span class="p_add">+</span>
 /*
  * GCC &#39;asm goto&#39; miscompiles certain code sequences:
  *
<span class="p_header">diff --git a/include/linux/compiler.h b/include/linux/compiler.h</span>
<span class="p_header">index 7c7546b..65c8b78 100644</span>
<span class="p_header">--- a/include/linux/compiler.h</span>
<span class="p_header">+++ b/include/linux/compiler.h</span>
<span class="p_chunk">@@ -297,7 +297,9 @@</span> <span class="p_context"> void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);</span>
 #ifndef __compiletime_error
 # define __compiletime_error(message)
 #endif
<span class="p_del">-</span>
<span class="p_add">+#ifndef __linktime_error</span>
<span class="p_add">+# define __linktime_error(message)</span>
<span class="p_add">+#endif</span>
 /*
  * Prevent the compiler from merging or refetching accesses.  The compiler
  * is also forbidden from reordering successive instances of ACCESS_ONCE(),
<span class="p_header">diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h</span>
<span class="p_header">index 2a53f10..dad4f61 100644</span>
<span class="p_header">--- a/include/linux/fsnotify.h</span>
<span class="p_header">+++ b/include/linux/fsnotify.h</span>
<span class="p_chunk">@@ -100,8 +100,10 @@</span> <span class="p_context"> static inline void fsnotify_move(struct inode *old_dir, struct inode *new_dir,</span>
 		new_dir_mask |= FS_ISDIR;
 	}
 
<span class="p_del">-	fsnotify(old_dir, old_dir_mask, old_dir, FSNOTIFY_EVENT_INODE, old_name, fs_cookie);</span>
<span class="p_del">-	fsnotify(new_dir, new_dir_mask, new_dir, FSNOTIFY_EVENT_INODE, new_name, fs_cookie);</span>
<span class="p_add">+	fsnotify(old_dir, old_dir_mask, source, FSNOTIFY_EVENT_INODE, old_name,</span>
<span class="p_add">+		 fs_cookie);</span>
<span class="p_add">+	fsnotify(new_dir, new_dir_mask, source, FSNOTIFY_EVENT_INODE, new_name,</span>
<span class="p_add">+		 fs_cookie);</span>
 
 	if (target)
 		fsnotify_link_count(target);
<span class="p_header">diff --git a/include/linux/kernel.h b/include/linux/kernel.h</span>
<span class="p_header">index 0b8ca35..dcf6a8b 100644</span>
<span class="p_header">--- a/include/linux/kernel.h</span>
<span class="p_header">+++ b/include/linux/kernel.h</span>
<span class="p_chunk">@@ -679,6 +679,7 @@</span> <span class="p_context"> static inline void ftrace_dump(enum ftrace_dump_mode oops_dump_mode) { }</span>
 #define BUILD_BUG_ON_ZERO(e) (0)
 #define BUILD_BUG_ON_NULL(e) ((void*)0)
 #define BUILD_BUG_ON(condition)
<span class="p_add">+#define BUILD_BUG() (0)</span>
 #else /* __CHECKER__ */
 
 /* Force a compilation error if a constant expression is not a power of 2 */
<span class="p_chunk">@@ -717,6 +718,21 @@</span> <span class="p_context"> extern int __build_bug_on_failed;</span>
 		if (condition) __build_bug_on_failed = 1;	\
 	} while(0)
 #endif
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * BUILD_BUG - break compile if used.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If you have some code that you expect the compiler to eliminate at</span>
<span class="p_add">+ * build time, you should use BUILD_BUG to detect if it is</span>
<span class="p_add">+ * unexpectedly used.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define BUILD_BUG()						\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		extern void __build_bug_failed(void)		\</span>
<span class="p_add">+			__linktime_error(&quot;BUILD_BUG failed&quot;);	\</span>
<span class="p_add">+		__build_bug_failed();				\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
 #endif	/* __CHECKER__ */
 
 /* Trap pasters of __FUNCTION__ at compile-time */
<span class="p_header">diff --git a/include/linux/usb/hcd.h b/include/linux/usb/hcd.h</span>
<span class="p_header">index 0daa46b..4fc3e5d 100644</span>
<span class="p_header">--- a/include/linux/usb/hcd.h</span>
<span class="p_header">+++ b/include/linux/usb/hcd.h</span>
<span class="p_chunk">@@ -128,6 +128,8 @@</span> <span class="p_context"> struct usb_hcd {</span>
 	unsigned		wireless:1;	/* Wireless USB HCD */
 	unsigned		authorized_default:1;
 	unsigned		has_tt:1;	/* Integrated TT in root hub */
<span class="p_add">+	unsigned		cant_recv_wakeups:1;</span>
<span class="p_add">+			/* wakeup requests from downstream aren&#39;t received */</span>
 
 	int			irq;		/* irq allocated */
 	void __iomem		*regs;		/* device memory/io */
<span class="p_chunk">@@ -401,6 +403,7 @@</span> <span class="p_context"> extern const struct dev_pm_ops usb_hcd_pci_pm_ops;</span>
 #endif /* CONFIG_PCI */
 
 /* pci-ish (pdev null is ok) buffer alloc/mapping support */
<span class="p_add">+void usb_init_pool_max(void);</span>
 int hcd_buffer_create(struct usb_hcd *hcd);
 void hcd_buffer_destroy(struct usb_hcd *hcd);
 
<span class="p_header">diff --git a/include/net/netfilter/nf_conntrack_extend.h b/include/net/netfilter/nf_conntrack_extend.h</span>
<span class="p_header">index 2dcf317..d918074 100644</span>
<span class="p_header">--- a/include/net/netfilter/nf_conntrack_extend.h</span>
<span class="p_header">+++ b/include/net/netfilter/nf_conntrack_extend.h</span>
<span class="p_chunk">@@ -33,8 +33,8 @@</span> <span class="p_context"> enum nf_ct_ext_id {</span>
 /* Extensions: optional stuff which isn&#39;t permanently in struct. */
 struct nf_ct_ext {
 	struct rcu_head rcu;
<span class="p_del">-	u8 offset[NF_CT_EXT_NUM];</span>
<span class="p_del">-	u8 len;</span>
<span class="p_add">+	u16 offset[NF_CT_EXT_NUM];</span>
<span class="p_add">+	u16 len;</span>
 	char data[0];
 };
 
<span class="p_header">diff --git a/kernel/debug/kdb/kdb_main.c b/kernel/debug/kdb/kdb_main.c</span>
<span class="p_header">index 63786e7..f56af55 100644</span>
<span class="p_header">--- a/kernel/debug/kdb/kdb_main.c</span>
<span class="p_header">+++ b/kernel/debug/kdb/kdb_main.c</span>
<span class="p_chunk">@@ -2595,7 +2595,7 @@</span> <span class="p_context"> static int kdb_summary(int argc, const char **argv)</span>
 #define K(x) ((x) &lt;&lt; (PAGE_SHIFT - 10))
 	kdb_printf(&quot;\nMemTotal:       %8lu kB\nMemFree:        %8lu kB\n&quot;
 		   &quot;Buffers:        %8lu kB\n&quot;,
<span class="p_del">-		   val.totalram, val.freeram, val.bufferram);</span>
<span class="p_add">+		   K(val.totalram), K(val.freeram), K(val.bufferram));</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 2a4bf43..4277095 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3956,6 +3956,13 @@</span> <span class="p_context"> static void perf_pending_event(struct irq_work *entry)</span>
 {
 	struct perf_event *event = container_of(entry,
 			struct perf_event, pending);
<span class="p_add">+	int rctx;</span>
<span class="p_add">+</span>
<span class="p_add">+	rctx = perf_swevent_get_recursion_context();</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we &#39;fail&#39; here, that&#39;s OK, it means recursion is already disabled</span>
<span class="p_add">+	 * and we won&#39;t recurse &#39;further&#39;.</span>
<span class="p_add">+	 */</span>
 
 	if (event-&gt;pending_disable) {
 		event-&gt;pending_disable = 0;
<span class="p_chunk">@@ -3966,6 +3973,9 @@</span> <span class="p_context"> static void perf_pending_event(struct irq_work *entry)</span>
 		event-&gt;pending_wakeup = 0;
 		perf_event_wakeup(event);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (rctx &gt;= 0)</span>
<span class="p_add">+		perf_swevent_put_recursion_context(rctx);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/printk.c b/kernel/printk.c</span>
<span class="p_header">index 8fac434..c073f43 100644</span>
<span class="p_header">--- a/kernel/printk.c</span>
<span class="p_header">+++ b/kernel/printk.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> static struct console *exclusive_console;</span>
  */
 struct console_cmdline
 {
<span class="p_del">-	char	name[8];			/* Name of the driver	    */</span>
<span class="p_add">+	char	name[16];			/* Name of the driver	    */</span>
 	int	index;				/* Minor dev. to use	    */
 	char	*options;			/* Options for the driver   */
 #ifdef CONFIG_A11Y_BRAILLE_CONSOLE
<span class="p_chunk">@@ -1477,6 +1477,7 @@</span> <span class="p_context"> void register_console(struct console *newcon)</span>
 	 */
 	for (i = 0; i &lt; MAX_CMDLINECONSOLES &amp;&amp; console_cmdline[i].name[0];
 			i++) {
<span class="p_add">+		BUILD_BUG_ON(sizeof(console_cmdline[i].name) != sizeof(newcon-&gt;name));</span>
 		if (strcmp(console_cmdline[i].name, newcon-&gt;name) != 0)
 			continue;
 		if (newcon-&gt;index &gt;= 0 &amp;&amp;
<span class="p_header">diff --git a/kernel/sched.c b/kernel/sched.c</span>
<span class="p_header">index ea85b0d..fe33d0f 100644</span>
<span class="p_header">--- a/kernel/sched.c</span>
<span class="p_header">+++ b/kernel/sched.c</span>
<span class="p_chunk">@@ -5224,8 +5224,11 @@</span> <span class="p_context"> void rt_mutex_setprio(struct task_struct *p, int prio)</span>
 
 	if (rt_prio(prio))
 		p-&gt;sched_class = &amp;rt_sched_class;
<span class="p_del">-	else</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		if (rt_prio(oldprio))</span>
<span class="p_add">+			p-&gt;rt.timeout = 0;</span>
 		p-&gt;sched_class = &amp;fair_sched_class;
<span class="p_add">+	}</span>
 
 	p-&gt;prio = prio;
 
<span class="p_chunk">@@ -9104,6 +9107,12 @@</span> <span class="p_context"> static inline int tg_has_rt_tasks(struct task_group *tg)</span>
 {
 	struct task_struct *g, *p;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Autogroups do not have RT tasks; see autogroup_create().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (task_group_is_autogroup(tg))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	do_each_thread(g, p) {
 		if (rt_task(p) &amp;&amp; rt_rq_of_se(&amp;p-&gt;rt)-&gt;tg == tg)
 			return 1;
<span class="p_header">diff --git a/kernel/sched_autogroup.c b/kernel/sched_autogroup.c</span>
<span class="p_header">index f280df1..cb0a950 100644</span>
<span class="p_header">--- a/kernel/sched_autogroup.c</span>
<span class="p_header">+++ b/kernel/sched_autogroup.c</span>
<span class="p_chunk">@@ -86,8 +86,7 @@</span> <span class="p_context"> static inline struct autogroup *autogroup_create(void)</span>
 	 * so we don&#39;t have to move tasks around upon policy change,
 	 * or flail around trying to allocate bandwidth on the fly.
 	 * A bandwidth exception in __sched_setscheduler() allows
<span class="p_del">-	 * the policy change to proceed.  Thereafter, task_group()</span>
<span class="p_del">-	 * returns &amp;root_task_group, so zero bandwidth is required.</span>
<span class="p_add">+	 * the policy change to proceed.</span>
 	 */
 	free_rt_sched_group(tg);
 	tg-&gt;rt_se = root_task_group.rt_se;
<span class="p_chunk">@@ -114,9 +113,6 @@</span> <span class="p_context"> task_wants_autogroup(struct task_struct *p, struct task_group *tg)</span>
 	if (tg != &amp;root_task_group)
 		return false;
 
<span class="p_del">-	if (p-&gt;sched_class != &amp;fair_sched_class)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
 	/*
 	 * We can only assume the task group can&#39;t go away on us if
 	 * autogroup_move_group() can see us on -&gt;thread_group list.
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index dcbafed..08e043b 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -935,6 +935,12 @@</span> <span class="p_context"> static __init void ftrace_profile_debugfs(struct dentry *d_tracer)</span>
 
 static struct pid * const ftrace_swapper_pid = &amp;init_struct_pid;
 
<span class="p_add">+#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="p_add">+static int ftrace_graph_active;</span>
<span class="p_add">+#else</span>
<span class="p_add">+# define ftrace_graph_active 0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static loff_t
 ftrace_filter_lseek(struct file *file, loff_t offset, int whence)
 {
<span class="p_chunk">@@ -1810,24 +1816,36 @@</span> <span class="p_context"> static int ftrace_shutdown(struct ftrace_ops *ops, int command)</span>
 
 static void ftrace_startup_sysctl(void)
 {
<span class="p_add">+	int command;</span>
<span class="p_add">+</span>
 	if (unlikely(ftrace_disabled))
 		return;
 
 	/* Force update next time */
 	saved_ftrace_func = NULL;
 	/* ftrace_start_up is true if we want ftrace running */
<span class="p_del">-	if (ftrace_start_up)</span>
<span class="p_del">-		ftrace_run_update_code(FTRACE_UPDATE_CALLS);</span>
<span class="p_add">+	if (ftrace_start_up) {</span>
<span class="p_add">+		command = FTRACE_UPDATE_CALLS;</span>
<span class="p_add">+		if (ftrace_graph_active)</span>
<span class="p_add">+			command |= FTRACE_START_FUNC_RET;</span>
<span class="p_add">+		ftrace_startup_enable(command);</span>
<span class="p_add">+	}</span>
 }
 
 static void ftrace_shutdown_sysctl(void)
 {
<span class="p_add">+	int command;</span>
<span class="p_add">+</span>
 	if (unlikely(ftrace_disabled))
 		return;
 
 	/* ftrace_start_up is true if ftrace is running */
<span class="p_del">-	if (ftrace_start_up)</span>
<span class="p_del">-		ftrace_run_update_code(FTRACE_DISABLE_CALLS);</span>
<span class="p_add">+	if (ftrace_start_up) {</span>
<span class="p_add">+		command = FTRACE_DISABLE_CALLS;</span>
<span class="p_add">+		if (ftrace_graph_active)</span>
<span class="p_add">+			command |= FTRACE_STOP_FUNC_RET;</span>
<span class="p_add">+		ftrace_run_update_code(command);</span>
<span class="p_add">+	}</span>
 }
 
 static cycle_t		ftrace_update_time;
<span class="p_chunk">@@ -4024,12 +4042,12 @@</span> <span class="p_context"> ftrace_enable_sysctl(struct ctl_table *table, int write,</span>
 
 	if (ftrace_enabled) {
 
<span class="p_del">-		ftrace_startup_sysctl();</span>
<span class="p_del">-</span>
 		/* we are starting ftrace again */
 		if (ftrace_ops_list != &amp;ftrace_list_end)
 			update_ftrace_function();
 
<span class="p_add">+		ftrace_startup_sysctl();</span>
<span class="p_add">+</span>
 	} else {
 		/* stopping ftrace calls (just send to ftrace_stub) */
 		ftrace_trace_function = ftrace_stub;
<span class="p_chunk">@@ -4044,7 +4062,6 @@</span> <span class="p_context"> ftrace_enable_sysctl(struct ctl_table *table, int write,</span>
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
 
<span class="p_del">-static int ftrace_graph_active;</span>
 static struct notifier_block ftrace_suspend_notifier;
 
 int ftrace_graph_entry_stub(struct ftrace_graph_ent *trace)
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index d2c43a2..26922da 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -2418,9 +2418,10 @@</span> <span class="p_context"> void __unmap_hugepage_range(struct vm_area_struct *vma, unsigned long start,</span>
 			continue;
 
 		/*
<span class="p_del">-		 * HWPoisoned hugepage is already unmapped and dropped reference</span>
<span class="p_add">+		 * Migrating hugepage or HWPoisoned hugepage is already</span>
<span class="p_add">+		 * unmapped and its refcount is dropped</span>
 		 */
<span class="p_del">-		if (unlikely(is_hugetlb_entry_hwpoisoned(pte)))</span>
<span class="p_add">+		if (unlikely(!pte_present(pte)))</span>
 			continue;
 
 		page = pte_page(pte);
<span class="p_chunk">@@ -2798,6 +2799,7 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	struct page *pagecache_page = NULL;
 	static DEFINE_MUTEX(hugetlb_instantiation_mutex);
 	struct hstate *h = hstate_vma(vma);
<span class="p_add">+	int need_wait_lock = 0;</span>
 
 	ptep = huge_pte_offset(mm, address);
 	if (ptep) {
<span class="p_chunk">@@ -2829,6 +2831,16 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	ret = 0;
 
 	/*
<span class="p_add">+	 * entry could be a migration/hwpoison entry at this point, so this</span>
<span class="p_add">+	 * check prevents the kernel from going below assuming that we have</span>
<span class="p_add">+	 * a active hugepage in pagecache. This goto expects the 2nd page fault,</span>
<span class="p_add">+	 * and is_hugetlb_entry_(migration|hwpoisoned) check will properly</span>
<span class="p_add">+	 * handle it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!pte_present(entry))</span>
<span class="p_add">+		goto out_mutex;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * If we are going to COW the mapping later, we examine the pending
 	 * reservations for this page now. This will ensure that any
 	 * allocations necessary to record that reservation occur outside the
<span class="p_chunk">@@ -2847,29 +2859,30 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 								vma, address);
 	}
 
<span class="p_add">+	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_add">+	/* Check for a racing update before calling hugetlb_cow */</span>
<span class="p_add">+	if (unlikely(!pte_same(entry, huge_ptep_get(ptep))))</span>
<span class="p_add">+		goto out_page_table_lock;</span>
<span class="p_add">+</span>
 	/*
 	 * hugetlb_cow() requires page locks of pte_page(entry) and
 	 * pagecache_page, so here we need take the former one
 	 * when page != pagecache_page or !pagecache_page.
<span class="p_del">-	 * Note that locking order is always pagecache_page -&gt; page,</span>
<span class="p_del">-	 * so no worry about deadlock.</span>
 	 */
 	page = pte_page(entry);
<span class="p_del">-	get_page(page);</span>
 	if (page != pagecache_page)
<span class="p_del">-		lock_page(page);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_del">-	/* Check for a racing update before calling hugetlb_cow */</span>
<span class="p_del">-	if (unlikely(!pte_same(entry, huge_ptep_get(ptep))))</span>
<span class="p_del">-		goto out_page_table_lock;</span>
<span class="p_add">+		if (!trylock_page(page)) {</span>
<span class="p_add">+			need_wait_lock = 1;</span>
<span class="p_add">+			goto out_page_table_lock;</span>
<span class="p_add">+		}</span>
 
<span class="p_add">+	get_page(page);</span>
 
 	if (flags &amp; FAULT_FLAG_WRITE) {
 		if (!pte_write(entry)) {
 			ret = hugetlb_cow(mm, vma, address, ptep, entry,
 							pagecache_page);
<span class="p_del">-			goto out_page_table_lock;</span>
<span class="p_add">+			goto out_put_page;</span>
 		}
 		entry = pte_mkdirty(entry);
 	}
<span class="p_chunk">@@ -2877,7 +2890,10 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (huge_ptep_set_access_flags(vma, address, ptep, entry,
 						flags &amp; FAULT_FLAG_WRITE))
 		update_mmu_cache(vma, address, ptep);
<span class="p_del">-</span>
<span class="p_add">+out_put_page:</span>
<span class="p_add">+	if (page != pagecache_page)</span>
<span class="p_add">+		unlock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
 out_page_table_lock:
 	spin_unlock(&amp;mm-&gt;page_table_lock);
 
<span class="p_chunk">@@ -2885,13 +2901,18 @@</span> <span class="p_context"> out_page_table_lock:</span>
 		unlock_page(pagecache_page);
 		put_page(pagecache_page);
 	}
<span class="p_del">-	if (page != pagecache_page)</span>
<span class="p_del">-		unlock_page(page);</span>
<span class="p_del">-	put_page(page);</span>
<span class="p_del">-</span>
 out_mutex:
 	mutex_unlock(&amp;hugetlb_instantiation_mutex);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Generally it&#39;s safe to hold refcount during waiting page lock. But</span>
<span class="p_add">+	 * here we just wait to defer the next page fault to avoid busy loop and</span>
<span class="p_add">+	 * the page is not used after unlocked before returning from the current</span>
<span class="p_add">+	 * page fault. So we are safe from accessing freed page, even if we wait</span>
<span class="p_add">+	 * here without taking refcount.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (need_wait_lock)</span>
<span class="p_add">+		wait_on_page_locked(page);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -3017,7 +3038,22 @@</span> <span class="p_context"> void hugetlb_change_protection(struct vm_area_struct *vma,</span>
 			continue;
 		if (huge_pmd_unshare(mm, &amp;address, ptep))
 			continue;
<span class="p_del">-		if (!huge_pte_none(huge_ptep_get(ptep))) {</span>
<span class="p_add">+		pte = huge_ptep_get(ptep);</span>
<span class="p_add">+		if (unlikely(is_hugetlb_entry_hwpoisoned(pte)))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (unlikely(is_hugetlb_entry_migration(pte))) {</span>
<span class="p_add">+			swp_entry_t entry = pte_to_swp_entry(pte);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (is_write_migration_entry(entry)) {</span>
<span class="p_add">+				pte_t newpte;</span>
<span class="p_add">+</span>
<span class="p_add">+				make_migration_entry_read(&amp;entry);</span>
<span class="p_add">+				newpte = swp_entry_to_pte(entry);</span>
<span class="p_add">+				set_huge_pte_at(mm, address, ptep, newpte);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (!huge_pte_none(pte)) {</span>
 			pte = huge_ptep_get_and_clear(mm, address, ptep);
 			pte = pte_mkhuge(pte_modify(pte, newprot));
 			set_huge_pte_at(mm, address, ptep, pte);
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 0a7bb38..452b8ba 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3831,7 +3831,7 @@</span> <span class="p_context"> int generic_access_phys(struct vm_area_struct *vma, unsigned long addr,</span>
 	if (follow_phys(vma, addr, write, &amp;prot, &amp;phys_addr))
 		return -EINVAL;
 
<span class="p_del">-	maddr = ioremap_prot(phys_addr, PAGE_SIZE, prot);</span>
<span class="p_add">+	maddr = ioremap_prot(phys_addr, PAGE_ALIGN(len + offset), prot);</span>
 	if (write)
 		memcpy_toio(maddr + offset, buf, len);
 	else
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 13b5685..94f4e34 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> struct percpu_counter vm_committed_as ____cacheline_aligned_in_smp;</span>
  */
 int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 {
<span class="p_del">-	unsigned long free, allowed;</span>
<span class="p_add">+	long free, allowed;</span>
 
 	vm_acct_memory(pages);
 
<span class="p_chunk">@@ -541,10 +541,8 @@</span> <span class="p_context"> again:			remove_next = 1 + (end &gt; next-&gt;vm_end);</span>
 
 			importer-&gt;anon_vma = exporter-&gt;anon_vma;
 			error = anon_vma_clone(importer, exporter);
<span class="p_del">-			if (error) {</span>
<span class="p_del">-				importer-&gt;anon_vma = NULL;</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/mm/nommu.c b/mm/nommu.c</span>
<span class="p_header">index 1db7971..d0cb11f 100644</span>
<span class="p_header">--- a/mm/nommu.c</span>
<span class="p_header">+++ b/mm/nommu.c</span>
<span class="p_chunk">@@ -1885,7 +1885,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(unmap_mapping_range);</span>
  */
 int __vm_enough_memory(struct mm_struct *mm, long pages, int cap_sys_admin)
 {
<span class="p_del">-	unsigned long free, allowed;</span>
<span class="p_add">+	long free, allowed;</span>
 
 	vm_acct_memory(pages);
 
<span class="p_header">diff --git a/mm/page-writeback.c b/mm/page-writeback.c</span>
<span class="p_header">index aad22aa..1bf1f74 100644</span>
<span class="p_header">--- a/mm/page-writeback.c</span>
<span class="p_header">+++ b/mm/page-writeback.c</span>
<span class="p_chunk">@@ -661,8 +661,11 @@</span> <span class="p_context"> static void bdi_update_write_bandwidth(struct backing_dev_info *bdi,</span>
 	 *                   bw * elapsed + write_bandwidth * (period - elapsed)
 	 * write_bandwidth = ---------------------------------------------------
 	 *                                          period
<span class="p_add">+	 *</span>
<span class="p_add">+	 * @written may have decreased due to account_page_redirty().</span>
<span class="p_add">+	 * Avoid underflowing @bw calculation.</span>
 	 */
<span class="p_del">-	bw = written - bdi-&gt;written_stamp;</span>
<span class="p_add">+	bw = written - min(written, bdi-&gt;written_stamp);</span>
 	bw *= HZ;
 	if (unlikely(elapsed &gt; period)) {
 		do_div(bw, elapsed);
<span class="p_chunk">@@ -726,7 +729,7 @@</span> <span class="p_context"> static void global_update_bandwidth(unsigned long thresh,</span>
 				    unsigned long now)
 {
 	static DEFINE_SPINLOCK(dirty_lock);
<span class="p_del">-	static unsigned long update_time;</span>
<span class="p_add">+	static unsigned long update_time = INITIAL_JIFFIES;</span>
 
 	/*
 	 * check locklessly first to optimize away locking for the most time
<span class="p_header">diff --git a/mm/rmap.c b/mm/rmap.c</span>
<span class="p_header">index 2c4ee3e..98f0bf7f 100644</span>
<span class="p_header">--- a/mm/rmap.c</span>
<span class="p_header">+++ b/mm/rmap.c</span>
<span class="p_chunk">@@ -295,6 +295,13 @@</span> <span class="p_context"> int anon_vma_clone(struct vm_area_struct *dst, struct vm_area_struct *src)</span>
 	return 0;
 
  enomem_failure:
<span class="p_add">+	/*</span>
<span class="p_add">+	 * dst-&gt;anon_vma is dropped here otherwise its degree can be incorrectly</span>
<span class="p_add">+	 * decremented in unlink_anon_vmas().</span>
<span class="p_add">+	 * We can safely do this because callers of anon_vma_clone() don&#39;t care</span>
<span class="p_add">+	 * about dst-&gt;anon_vma if anon_vma_clone() failed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dst-&gt;anon_vma = NULL;</span>
 	unlink_anon_vmas(dst);
 	return -ENOMEM;
 }
<span class="p_header">diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c</span>
<span class="p_header">index 7fac75f..7eed9eb 100644</span>
<span class="p_header">--- a/net/caif/caif_socket.c</span>
<span class="p_header">+++ b/net/caif/caif_socket.c</span>
<span class="p_chunk">@@ -317,7 +317,7 @@</span> <span class="p_context"> static int caif_seqpkt_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 	int copylen;
 
 	ret = -EOPNOTSUPP;
<span class="p_del">-	if (m-&gt;msg_flags&amp;MSG_OOB)</span>
<span class="p_add">+	if (flags &amp; MSG_OOB)</span>
 		goto read_error;
 
 	skb = skb_recv_datagram(sk, flags, 0 , &amp;ret);
<span class="p_header">diff --git a/net/can/af_can.c b/net/can/af_can.c</span>
<span class="p_header">index 0ce2ad0..7d9dff222 100644</span>
<span class="p_header">--- a/net/can/af_can.c</span>
<span class="p_header">+++ b/net/can/af_can.c</span>
<span class="p_chunk">@@ -244,6 +244,9 @@</span> <span class="p_context"> int can_send(struct sk_buff *skb, int loop)</span>
 	}
 
 	skb-&gt;protocol = htons(ETH_P_CAN);
<span class="p_add">+	skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb_reset_mac_header(skb);</span>
 	skb_reset_network_header(skb);
 	skb_reset_transport_header(skb);
 
<span class="p_header">diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c</span>
<span class="p_header">index a70f426..2df98a6 100644</span>
<span class="p_header">--- a/net/ceph/osd_client.c</span>
<span class="p_header">+++ b/net/ceph/osd_client.c</span>
<span class="p_chunk">@@ -678,12 +678,22 @@</span> <span class="p_context"> static void put_osd(struct ceph_osd *osd)</span>
  */
 static void __remove_osd(struct ceph_osd_client *osdc, struct ceph_osd *osd)
 {
<span class="p_del">-	dout(&quot;__remove_osd %p\n&quot;, osd);</span>
<span class="p_add">+	dout(&quot;%s %p osd%d\n&quot;, __func__, osd, osd-&gt;o_osd);</span>
 	BUG_ON(!list_empty(&amp;osd-&gt;o_requests));
<span class="p_del">-	rb_erase(&amp;osd-&gt;o_node, &amp;osdc-&gt;osds);</span>
 	list_del_init(&amp;osd-&gt;o_osd_lru);
<span class="p_del">-	ceph_con_close(&amp;osd-&gt;o_con);</span>
<span class="p_del">-	put_osd(osd);</span>
<span class="p_add">+	rb_erase(&amp;osd-&gt;o_node, &amp;osdc-&gt;osds);</span>
<span class="p_add">+	RB_CLEAR_NODE(&amp;osd-&gt;o_node);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void remove_osd(struct ceph_osd_client *osdc, struct ceph_osd *osd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dout(&quot;%s %p osd%d\n&quot;, __func__, osd, osd-&gt;o_osd);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!RB_EMPTY_NODE(&amp;osd-&gt;o_node)) {</span>
<span class="p_add">+		ceph_con_close(&amp;osd-&gt;o_con);</span>
<span class="p_add">+		__remove_osd(osdc, osd);</span>
<span class="p_add">+		put_osd(osd);</span>
<span class="p_add">+	}</span>
 }
 
 static void remove_all_osds(struct ceph_osd_client *osdc)
<span class="p_chunk">@@ -693,7 +703,7 @@</span> <span class="p_context"> static void remove_all_osds(struct ceph_osd_client *osdc)</span>
 	while (!RB_EMPTY_ROOT(&amp;osdc-&gt;osds)) {
 		struct ceph_osd *osd = rb_entry(rb_first(&amp;osdc-&gt;osds),
 						struct ceph_osd, o_node);
<span class="p_del">-		__remove_osd(osdc, osd);</span>
<span class="p_add">+		remove_osd(osdc, osd);</span>
 	}
 	mutex_unlock(&amp;osdc-&gt;request_mutex);
 }
<span class="p_chunk">@@ -723,7 +733,7 @@</span> <span class="p_context"> static void remove_old_osds(struct ceph_osd_client *osdc)</span>
 	list_for_each_entry_safe(osd, nosd, &amp;osdc-&gt;osd_lru, o_osd_lru) {
 		if (time_before(jiffies, osd-&gt;lru_ttl))
 			break;
<span class="p_del">-		__remove_osd(osdc, osd);</span>
<span class="p_add">+		remove_osd(osdc, osd);</span>
 	}
 	mutex_unlock(&amp;osdc-&gt;request_mutex);
 }
<span class="p_chunk">@@ -739,7 +749,7 @@</span> <span class="p_context"> static int __reset_osd(struct ceph_osd_client *osdc, struct ceph_osd *osd)</span>
 	dout(&quot;__reset_osd %p osd%d\n&quot;, osd, osd-&gt;o_osd);
 	if (list_empty(&amp;osd-&gt;o_requests) &amp;&amp;
 	    list_empty(&amp;osd-&gt;o_linger_requests)) {
<span class="p_del">-		__remove_osd(osdc, osd);</span>
<span class="p_add">+		remove_osd(osdc, osd);</span>
 	} else if (memcmp(&amp;osdc-&gt;osdmap-&gt;osd_addr[osd-&gt;o_osd],
 			  &amp;osd-&gt;o_con.peer_addr,
 			  sizeof(osd-&gt;o_con.peer_addr)) == 0 &amp;&amp;
<span class="p_chunk">@@ -1271,6 +1281,7 @@</span> <span class="p_context"> static void reset_changed_osds(struct ceph_osd_client *osdc)</span>
 {
 	struct rb_node *p, *n;
 
<span class="p_add">+	dout(&quot;%s %p\n&quot;, __func__, osdc);</span>
 	for (p = rb_first(&amp;osdc-&gt;osds); p; p = n) {
 		struct ceph_osd *osd = rb_entry(p, struct ceph_osd, o_node);
 
<span class="p_header">diff --git a/net/compat.c b/net/compat.c</span>
<span class="p_header">index 759e542..f06994d 100644</span>
<span class="p_header">--- a/net/compat.c</span>
<span class="p_header">+++ b/net/compat.c</span>
<span class="p_chunk">@@ -71,6 +71,13 @@</span> <span class="p_context"> int get_compat_msghdr(struct msghdr *kmsg, struct compat_msghdr __user *umsg)</span>
 	    __get_user(kmsg-&gt;msg_controllen, &amp;umsg-&gt;msg_controllen) ||
 	    __get_user(kmsg-&gt;msg_flags, &amp;umsg-&gt;msg_flags))
 		return -EFAULT;
<span class="p_add">+</span>
<span class="p_add">+	if (!tmp1)</span>
<span class="p_add">+		kmsg-&gt;msg_namelen = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kmsg-&gt;msg_namelen &lt; 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (kmsg-&gt;msg_namelen &gt; sizeof(struct sockaddr_storage))
 		kmsg-&gt;msg_namelen = sizeof(struct sockaddr_storage);
 	kmsg-&gt;msg_name = compat_ptr(tmp1);
<span class="p_chunk">@@ -737,24 +744,18 @@</span> <span class="p_context"> static unsigned char nas[21] = {</span>
 
 asmlinkage long compat_sys_sendmsg(int fd, struct compat_msghdr __user *msg, unsigned flags)
 {
<span class="p_del">-	if (flags &amp; MSG_CMSG_COMPAT)</span>
<span class="p_del">-		return -EINVAL;</span>
 	return __sys_sendmsg(fd, (struct msghdr __user *)msg, flags | MSG_CMSG_COMPAT);
 }
 
 asmlinkage long compat_sys_sendmmsg(int fd, struct compat_mmsghdr __user *mmsg,
 				    unsigned vlen, unsigned int flags)
 {
<span class="p_del">-	if (flags &amp; MSG_CMSG_COMPAT)</span>
<span class="p_del">-		return -EINVAL;</span>
 	return __sys_sendmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 			      flags | MSG_CMSG_COMPAT);
 }
 
 asmlinkage long compat_sys_recvmsg(int fd, struct compat_msghdr __user *msg, unsigned int flags)
 {
<span class="p_del">-	if (flags &amp; MSG_CMSG_COMPAT)</span>
<span class="p_del">-		return -EINVAL;</span>
 	return __sys_recvmsg(fd, (struct msghdr __user *)msg, flags | MSG_CMSG_COMPAT);
 }
 
<span class="p_chunk">@@ -777,9 +778,6 @@</span> <span class="p_context"> asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,</span>
 	int datagrams;
 	struct timespec ktspec;
 
<span class="p_del">-	if (flags &amp; MSG_CMSG_COMPAT)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	if (timeout == NULL)
 		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
 				      flags | MSG_CMSG_COMPAT, NULL);
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index fcb5133..1c0d862 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -859,7 +859,7 @@</span> <span class="p_context"> int dev_valid_name(const char *name)</span>
 		return 0;
 
 	while (*name) {
<span class="p_del">-		if (*name == &#39;/&#39; || isspace(*name))</span>
<span class="p_add">+		if (*name == &#39;/&#39; || *name == &#39;:&#39; || isspace(*name))</span>
 			return 0;
 		name++;
 	}
<span class="p_chunk">@@ -6338,10 +6338,20 @@</span> <span class="p_context"> static int dev_cpu_callback(struct notifier_block *nfb,</span>
 		oldsd-&gt;output_queue = NULL;
 		oldsd-&gt;output_queue_tailp = &amp;oldsd-&gt;output_queue;
 	}
<span class="p_del">-	/* Append NAPI poll list from offline CPU. */</span>
<span class="p_del">-	if (!list_empty(&amp;oldsd-&gt;poll_list)) {</span>
<span class="p_del">-		list_splice_init(&amp;oldsd-&gt;poll_list, &amp;sd-&gt;poll_list);</span>
<span class="p_del">-		raise_softirq_irqoff(NET_RX_SOFTIRQ);</span>
<span class="p_add">+	/* Append NAPI poll list from offline CPU, with one exception :</span>
<span class="p_add">+	 * process_backlog() must be called by cpu owning percpu backlog.</span>
<span class="p_add">+	 * We properly handle process_queue &amp; input_pkt_queue later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (!list_empty(&amp;oldsd-&gt;poll_list)) {</span>
<span class="p_add">+		struct napi_struct *napi = list_first_entry(&amp;oldsd-&gt;poll_list,</span>
<span class="p_add">+							    struct napi_struct,</span>
<span class="p_add">+							    poll_list);</span>
<span class="p_add">+</span>
<span class="p_add">+		list_del_init(&amp;napi-&gt;poll_list);</span>
<span class="p_add">+		if (napi-&gt;poll == process_backlog)</span>
<span class="p_add">+			napi-&gt;state = 0;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			____napi_schedule(sd, napi);</span>
 	}
 
 	raise_softirq_irqoff(NET_TX_SOFTIRQ);
<span class="p_chunk">@@ -6352,7 +6362,7 @@</span> <span class="p_context"> static int dev_cpu_callback(struct notifier_block *nfb,</span>
 		netif_rx(skb);
 		input_queue_head_incr(oldsd);
 	}
<span class="p_del">-	while ((skb = __skb_dequeue(&amp;oldsd-&gt;input_pkt_queue))) {</span>
<span class="p_add">+	while ((skb = skb_dequeue(&amp;oldsd-&gt;input_pkt_queue))) {</span>
 		netif_rx(skb);
 		input_queue_head_incr(oldsd);
 	}
<span class="p_header">diff --git a/net/core/gen_stats.c b/net/core/gen_stats.c</span>
<span class="p_header">index 0452eb2..91080c1 100644</span>
<span class="p_header">--- a/net/core/gen_stats.c</span>
<span class="p_header">+++ b/net/core/gen_stats.c</span>
<span class="p_chunk">@@ -31,6 +31,9 @@</span> <span class="p_context"> gnet_stats_copy(struct gnet_dump *d, int type, void *buf, int size)</span>
 	return 0;
 
 nla_put_failure:
<span class="p_add">+	kfree(d-&gt;xstats);</span>
<span class="p_add">+	d-&gt;xstats = NULL;</span>
<span class="p_add">+	d-&gt;xstats_len = 0;</span>
 	spin_unlock_bh(d-&gt;lock);
 	return -1;
 }
<span class="p_chunk">@@ -204,7 +207,9 @@</span> <span class="p_context"> int</span>
 gnet_stats_copy_app(struct gnet_dump *d, void *st, int len)
 {
 	if (d-&gt;compat_xstats) {
<span class="p_del">-		d-&gt;xstats = st;</span>
<span class="p_add">+		d-&gt;xstats = kmemdup(st, len, GFP_ATOMIC);</span>
<span class="p_add">+		if (!d-&gt;xstats)</span>
<span class="p_add">+			goto err_out;</span>
 		d-&gt;xstats_len = len;
 	}
 
<span class="p_chunk">@@ -212,6 +217,11 @@</span> <span class="p_context"> gnet_stats_copy_app(struct gnet_dump *d, void *st, int len)</span>
 		return gnet_stats_copy(d, TCA_STATS_APP, st, len);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	d-&gt;xstats_len = 0;</span>
<span class="p_add">+	spin_unlock_bh(d-&gt;lock);</span>
<span class="p_add">+	return -1;</span>
 }
 EXPORT_SYMBOL(gnet_stats_copy_app);
 
<span class="p_chunk">@@ -244,6 +254,9 @@</span> <span class="p_context"> gnet_stats_finish_copy(struct gnet_dump *d)</span>
 			return -1;
 	}
 
<span class="p_add">+	kfree(d-&gt;xstats);</span>
<span class="p_add">+	d-&gt;xstats = NULL;</span>
<span class="p_add">+	d-&gt;xstats_len = 0;</span>
 	spin_unlock_bh(d-&gt;lock);
 	return 0;
 }
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 0900a17..5b412f0 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -1152,14 +1152,10 @@</span> <span class="p_context"> static const struct nla_policy ifla_vfinfo_policy[IFLA_VF_INFO_MAX+1] = {</span>
 };
 
 static const struct nla_policy ifla_vf_policy[IFLA_VF_MAX+1] = {
<span class="p_del">-	[IFLA_VF_MAC]		= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_mac) },</span>
<span class="p_del">-	[IFLA_VF_VLAN]		= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_vlan) },</span>
<span class="p_del">-	[IFLA_VF_TX_RATE]	= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_tx_rate) },</span>
<span class="p_del">-	[IFLA_VF_SPOOFCHK]	= { .type = NLA_BINARY,</span>
<span class="p_del">-				    .len = sizeof(struct ifla_vf_spoofchk) },</span>
<span class="p_add">+	[IFLA_VF_MAC]		= { .len = sizeof(struct ifla_vf_mac) },</span>
<span class="p_add">+	[IFLA_VF_VLAN]		= { .len = sizeof(struct ifla_vf_vlan) },</span>
<span class="p_add">+	[IFLA_VF_TX_RATE]	= { .len = sizeof(struct ifla_vf_tx_rate) },</span>
<span class="p_add">+	[IFLA_VF_SPOOFCHK]	= { .len = sizeof(struct ifla_vf_spoofchk) },</span>
 };
 
 static const struct nla_policy ifla_port_policy[IFLA_PORT_MAX+1] = {
<span class="p_chunk">@@ -1705,10 +1701,10 @@</span> <span class="p_context"> static int rtnl_group_changelink(struct net *net, int group,</span>
 		struct ifinfomsg *ifm,
 		struct nlattr **tb)
 {
<span class="p_del">-	struct net_device *dev;</span>
<span class="p_add">+	struct net_device *dev, *aux;</span>
 	int err;
 
<span class="p_del">-	for_each_netdev(net, dev) {</span>
<span class="p_add">+	for_each_netdev_safe(net, dev, aux) {</span>
 		if (dev-&gt;group == group) {
 			err = do_setlink(dev, ifm, tb, NULL, 0);
 			if (err &lt; 0)
<span class="p_chunk">@@ -1864,8 +1860,16 @@</span> <span class="p_context"> replay:</span>
 			goto out;
 
 		err = rtnl_configure_link(dev, ifm);
<span class="p_del">-		if (err &lt; 0)</span>
<span class="p_del">-			unregister_netdevice(dev);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			if (ops-&gt;newlink) {</span>
<span class="p_add">+				LIST_HEAD(list_kill);</span>
<span class="p_add">+</span>
<span class="p_add">+				ops-&gt;dellink(dev, &amp;list_kill);</span>
<span class="p_add">+				unregister_netdevice_many(&amp;list_kill);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				unregister_netdevice(dev);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 out:
 		put_net(dest_net);
 		return err;
<span class="p_header">diff --git a/net/core/sysctl_net_core.c b/net/core/sysctl_net_core.c</span>
<span class="p_header">index f0bdd36..f9496c4 100644</span>
<span class="p_header">--- a/net/core/sysctl_net_core.c</span>
<span class="p_header">+++ b/net/core/sysctl_net_core.c</span>
<span class="p_chunk">@@ -21,6 +21,8 @@</span> <span class="p_context"></span>
 
 static int zero = 0;
 static int ushort_max = USHRT_MAX;
<span class="p_add">+static int min_sndbuf = SOCK_MIN_SNDBUF;</span>
<span class="p_add">+static int min_rcvbuf = SOCK_MIN_RCVBUF;</span>
 
 #ifdef CONFIG_RPS
 static int rps_sock_flow_sysctl(ctl_table *table, int write,
<span class="p_chunk">@@ -89,28 +91,32 @@</span> <span class="p_context"> static struct ctl_table net_core_table[] = {</span>
 		.data		= &amp;sysctl_wmem_max,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;min_sndbuf,</span>
 	},
 	{
 		.procname	= &quot;rmem_max&quot;,
 		.data		= &amp;sysctl_rmem_max,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;min_rcvbuf,</span>
 	},
 	{
 		.procname	= &quot;wmem_default&quot;,
 		.data		= &amp;sysctl_wmem_default,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;min_sndbuf,</span>
 	},
 	{
 		.procname	= &quot;rmem_default&quot;,
 		.data		= &amp;sysctl_rmem_default,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;min_rcvbuf,</span>
 	},
 	{
 		.procname	= &quot;dev_weight&quot;,
<span class="p_header">diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c</span>
<span class="p_header">index 29a07b6..bcd78a3 100644</span>
<span class="p_header">--- a/net/ipv4/ip_forward.c</span>
<span class="p_header">+++ b/net/ipv4/ip_forward.c</span>
<span class="p_chunk">@@ -57,6 +57,9 @@</span> <span class="p_context"> int ip_forward(struct sk_buff *skb)</span>
 	struct rtable *rt;	/* Route we use */
 	struct ip_options * opt	= &amp;(IPCB(skb)-&gt;opt);
 
<span class="p_add">+	if (unlikely(skb-&gt;sk))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+</span>
 	if (skb_warn_if_lro(skb))
 		goto drop;
 
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index 8f441b2..16e25a4 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -692,27 +692,30 @@</span> <span class="p_context"> EXPORT_SYMBOL(ip_defrag);</span>
 struct sk_buff *ip_check_defrag(struct sk_buff *skb, u32 user)
 {
 	struct iphdr iph;
<span class="p_add">+	int netoff;</span>
 	u32 len;
 
 	if (skb-&gt;protocol != htons(ETH_P_IP))
 		return skb;
 
<span class="p_del">-	if (!skb_copy_bits(skb, 0, &amp;iph, sizeof(iph)))</span>
<span class="p_add">+	netoff = skb_network_offset(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb_copy_bits(skb, netoff, &amp;iph, sizeof(iph)) &lt; 0)</span>
 		return skb;
 
 	if (iph.ihl &lt; 5 || iph.version != 4)
 		return skb;
 
 	len = ntohs(iph.tot_len);
<span class="p_del">-	if (skb-&gt;len &lt; len || len &lt; (iph.ihl * 4))</span>
<span class="p_add">+	if (skb-&gt;len &lt; netoff + len || len &lt; (iph.ihl * 4))</span>
 		return skb;
 
 	if (ip_is_fragment(&amp;iph)) {
 		skb = skb_share_check(skb, GFP_ATOMIC);
 		if (skb) {
<span class="p_del">-			if (!pskb_may_pull(skb, iph.ihl*4))</span>
<span class="p_add">+			if (!pskb_may_pull(skb, netoff + iph.ihl * 4))</span>
 				return skb;
<span class="p_del">-			if (pskb_trim_rcsum(skb, len))</span>
<span class="p_add">+			if (pskb_trim_rcsum(skb, netoff + len))</span>
 				return skb;
 			memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 			if (ip_defrag(skb, user))
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index bf2e54b..013f59b 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -834,7 +834,8 @@</span> <span class="p_context"> static int __ip_append_data(struct sock *sk,</span>
 	cork-&gt;length += length;
 	if (((length &gt; mtu) || (skb &amp;&amp; skb_has_frags(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
<span class="p_del">-	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len) {</span>
<span class="p_add">+	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len &amp;&amp;</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
 		err = ip_ufo_append_data(sk, queue, getfrag, from, length,
 					 hh_len, fragheaderlen, transhdrlen,
 					 maxfraglen, flags);
<span class="p_header">diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c</span>
<span class="p_header">index 542a9c1..043d882 100644</span>
<span class="p_header">--- a/net/ipv4/ip_sockglue.c</span>
<span class="p_header">+++ b/net/ipv4/ip_sockglue.c</span>
<span class="p_chunk">@@ -416,15 +416,11 @@</span> <span class="p_context"> int ip_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)</span>
 
 	memcpy(&amp;errhdr.ee, &amp;serr-&gt;ee, sizeof(struct sock_extended_err));
 	sin = &amp;errhdr.offender;
<span class="p_del">-	sin-&gt;sin_family = AF_UNSPEC;</span>
<span class="p_add">+	memset(sin, 0, sizeof(*sin));</span>
 	if (serr-&gt;ee.ee_origin == SO_EE_ORIGIN_ICMP) {
<span class="p_del">-		struct inet_sock *inet = inet_sk(sk);</span>
<span class="p_del">-</span>
 		sin-&gt;sin_family = AF_INET;
 		sin-&gt;sin_addr.s_addr = ip_hdr(skb)-&gt;saddr;
<span class="p_del">-		sin-&gt;sin_port = 0;</span>
<span class="p_del">-		memset(&amp;sin-&gt;sin_zero, 0, sizeof(sin-&gt;sin_zero));</span>
<span class="p_del">-		if (inet-&gt;cmsg_flags)</span>
<span class="p_add">+		if (inet_sk(sk)-&gt;cmsg_flags)</span>
 			ip_cmsg_recv(msg, skb);
 	}
 
<span class="p_header">diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c</span>
<span class="p_header">index d495d4b..7aa6225 100644</span>
<span class="p_header">--- a/net/ipv4/ping.c</span>
<span class="p_header">+++ b/net/ipv4/ping.c</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> static void ping_v4_unhash(struct sock *sk)</span>
 	if (sk_hashed(sk)) {
 		write_lock_bh(&amp;ping_table.lock);
 		hlist_nulls_del(&amp;sk-&gt;sk_nulls_node);
<span class="p_add">+		sk_nulls_node_init(&amp;sk-&gt;sk_nulls_node);</span>
 		sock_put(sk);
 		isk-&gt;inet_num = isk-&gt;inet_sport = 0;
 		sock_prot_inuse_add(sock_net(sk), sk-&gt;sk_prot, -1);
<span class="p_chunk">@@ -257,6 +258,11 @@</span> <span class="p_context"> static int ping_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	if (addr_len &lt; sizeof(struct sockaddr_in))
 		return -EINVAL;
 
<span class="p_add">+	if (addr-&gt;sin_family != AF_INET &amp;&amp;</span>
<span class="p_add">+	    !(addr-&gt;sin_family == AF_UNSPEC &amp;&amp;</span>
<span class="p_add">+	      addr-&gt;sin_addr.s_addr == htonl(INADDR_ANY)))</span>
<span class="p_add">+		return -EAFNOSUPPORT;</span>
<span class="p_add">+</span>
 	pr_debug(&quot;ping_v4_bind(sk=%p,sa_addr=%08x,sa_port=%d)\n&quot;,
 		sk, addr-&gt;sin_addr.s_addr, ntohs(addr-&gt;sin_port));
 
<span class="p_chunk">@@ -504,7 +510,7 @@</span> <span class="p_context"> static int ping_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,</span>
 		if (msg-&gt;msg_namelen &lt; sizeof(*usin))
 			return -EINVAL;
 		if (usin-&gt;sin_family != AF_INET)
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			return -EAFNOSUPPORT;</span>
 		daddr = usin-&gt;sin_addr.s_addr;
 		/* no remote port */
 	} else {
<span class="p_chunk">@@ -716,8 +722,11 @@</span> <span class="p_context"> void ping_rcv(struct sk_buff *skb)</span>
 	sk = ping_v4_lookup(net, saddr, daddr, ntohs(icmph-&gt;un.echo.id),
 			    skb-&gt;dev-&gt;ifindex);
 	if (sk != NULL) {
<span class="p_add">+		struct sk_buff *skb2 = skb_clone(skb, GFP_ATOMIC);</span>
<span class="p_add">+</span>
 		pr_debug(&quot;rcv on socket %p\n&quot;, sk);
<span class="p_del">-		ping_queue_rcv_skb(sk, skb_get(skb));</span>
<span class="p_add">+		if (skb2)</span>
<span class="p_add">+			ping_queue_rcv_skb(sk, skb2);</span>
 		sock_put(sk);
 		return;
 	}
<span class="p_header">diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_header">index 739b073..253dd80 100644</span>
<span class="p_header">--- a/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;net/inet_frag.h&gt;
 #include &lt;net/ping.h&gt;
 
<span class="p_del">-static int zero;</span>
<span class="p_add">+static int one = 1;</span>
 static int tcp_retr1_max = 255;
 static int ip_local_port_range_min[] = { 1, 1 };
 static int ip_local_port_range_max[] = { 65535, 65535 };
<span class="p_chunk">@@ -448,14 +448,16 @@</span> <span class="p_context"> static struct ctl_table ipv4_table[] = {</span>
 		.data		= &amp;sysctl_tcp_wmem,
 		.maxlen		= sizeof(sysctl_tcp_wmem),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;one,</span>
 	},
 	{
 		.procname	= &quot;tcp_rmem&quot;,
 		.data		= &amp;sysctl_tcp_rmem,
 		.maxlen		= sizeof(sysctl_tcp_rmem),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;one,</span>
 	},
 	{
 		.procname	= &quot;tcp_app_win&quot;,
<span class="p_chunk">@@ -662,7 +664,7 @@</span> <span class="p_context"> static struct ctl_table ipv4_table[] = {</span>
 		.maxlen		= sizeof(sysctl_udp_rmem_min),
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec_minmax,
<span class="p_del">-		.extra1		= &amp;zero</span>
<span class="p_add">+		.extra1		= &amp;one</span>
 	},
 	{
 		.procname	= &quot;udp_wmem_min&quot;,
<span class="p_chunk">@@ -670,7 +672,7 @@</span> <span class="p_context"> static struct ctl_table ipv4_table[] = {</span>
 		.maxlen		= sizeof(sysctl_udp_wmem_min),
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec_minmax,
<span class="p_del">-		.extra1		= &amp;zero</span>
<span class="p_add">+		.extra1		= &amp;one</span>
 	},
 	{ }
 };
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 3a37f54..e614810 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -2320,33 +2320,40 @@</span> <span class="p_context"> begin_fwd:</span>
 	}
 }
 
<span class="p_del">-/* Send a fin.  The caller locks the socket for us.  This cannot be</span>
<span class="p_del">- * allowed to fail queueing a FIN frame under any circumstances.</span>
<span class="p_add">+/* Send a FIN. The caller locks the socket for us.</span>
<span class="p_add">+ * We should try to send a FIN packet really hard, but eventually give up.</span>
  */
 void tcp_send_fin(struct sock *sk)
 {
<span class="p_add">+	struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);</span>
 	struct tcp_sock *tp = tcp_sk(sk);
<span class="p_del">-	struct sk_buff *skb = tcp_write_queue_tail(sk);</span>
<span class="p_del">-	int mss_now;</span>
 
<span class="p_del">-	/* Optimization, tack on the FIN if we have a queue of</span>
<span class="p_del">-	 * unsent frames.  But be careful about outgoing SACKS</span>
<span class="p_del">-	 * and IP options.</span>
<span class="p_add">+	/* Optimization, tack on the FIN if we have one skb in write queue and</span>
<span class="p_add">+	 * this skb was not yet sent, or we are under memory pressure.</span>
<span class="p_add">+	 * Note: in the latter case, FIN packet will be sent after a timeout,</span>
<span class="p_add">+	 * as TCP stack thinks it has already been transmitted.</span>
 	 */
<span class="p_del">-	mss_now = tcp_current_mss(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tcp_send_head(sk) != NULL) {</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;end_seq++;</span>
<span class="p_add">+	if (tskb &amp;&amp; (tcp_send_head(sk) || tcp_memory_pressure)) {</span>
<span class="p_add">+coalesce:</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;end_seq++;</span>
 		tp-&gt;write_seq++;
<span class="p_add">+		if (!tcp_send_head(sk)) {</span>
<span class="p_add">+			/* This means tskb was already sent.</span>
<span class="p_add">+			 * Pretend we included the FIN on previous transmit.</span>
<span class="p_add">+			 * We need to set tp-&gt;snd_nxt to the value it would have</span>
<span class="p_add">+			 * if FIN had been sent. This is because retransmit path</span>
<span class="p_add">+			 * does not change tp-&gt;snd_nxt.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tp-&gt;snd_nxt++;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
 	} else {
<span class="p_del">-		/* Socket is locked, keep trying until memory is available. */</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			skb = alloc_skb_fclone(MAX_TCP_HEADER,</span>
<span class="p_del">-					       sk-&gt;sk_allocation);</span>
<span class="p_del">-			if (skb)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			yield();</span>
<span class="p_add">+		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk-&gt;sk_allocation);</span>
<span class="p_add">+		if (unlikely(!skb)) {</span>
<span class="p_add">+			if (tskb)</span>
<span class="p_add">+				goto coalesce;</span>
<span class="p_add">+			return;</span>
 		}
 
 		/* Reserve space for headers and prepare control bits. */
<span class="p_chunk">@@ -2356,7 +2363,7 @@</span> <span class="p_context"> void tcp_send_fin(struct sock *sk)</span>
 				     TCPHDR_ACK | TCPHDR_FIN);
 		tcp_queue_skb(sk, skb);
 	}
<span class="p_del">-	__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);</span>
<span class="p_add">+	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span>
 }
 
 /* We get here when a process closes a file descriptor (either due to
<span class="p_chunk">@@ -2632,13 +2639,10 @@</span> <span class="p_context"> int tcp_connect(struct sock *sk)</span>
 
 	tcp_connect_init(sk);
 
<span class="p_del">-	buff = alloc_skb_fclone(MAX_TCP_HEADER + 15, sk-&gt;sk_allocation);</span>
<span class="p_del">-	if (unlikely(buff == NULL))</span>
<span class="p_add">+	buff = sk_stream_alloc_skb(sk, 0, sk-&gt;sk_allocation);</span>
<span class="p_add">+	if (unlikely(!buff))</span>
 		return -ENOBUFS;
 
<span class="p_del">-	/* Reserve space for headers. */</span>
<span class="p_del">-	skb_reserve(buff, MAX_TCP_HEADER);</span>
<span class="p_del">-</span>
 	tp-&gt;snd_nxt = tp-&gt;write_seq;
 	tcp_init_nondata_skb(buff, tp-&gt;write_seq++, TCPHDR_SYN);
 	TCP_ECN_send_syn(sk, buff);
<span class="p_header">diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c</span>
<span class="p_header">index 3c7c948..33719b7 100644</span>
<span class="p_header">--- a/net/ipv6/datagram.c</span>
<span class="p_header">+++ b/net/ipv6/datagram.c</span>
<span class="p_chunk">@@ -371,12 +371,10 @@</span> <span class="p_context"> int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)</span>
 
 	memcpy(&amp;errhdr.ee, &amp;serr-&gt;ee, sizeof(struct sock_extended_err));
 	sin = &amp;errhdr.offender;
<span class="p_del">-	sin-&gt;sin6_family = AF_UNSPEC;</span>
<span class="p_add">+	memset(sin, 0, sizeof(*sin));</span>
<span class="p_add">+</span>
 	if (serr-&gt;ee.ee_origin != SO_EE_ORIGIN_LOCAL) {
 		sin-&gt;sin6_family = AF_INET6;
<span class="p_del">-		sin-&gt;sin6_flowinfo = 0;</span>
<span class="p_del">-		sin-&gt;sin6_port = 0;</span>
<span class="p_del">-		sin-&gt;sin6_scope_id = 0;</span>
 		if (skb-&gt;protocol == htons(ETH_P_IPV6)) {
 			ipv6_addr_copy(&amp;sin-&gt;sin6_addr, &amp;ipv6_hdr(skb)-&gt;saddr);
 			if (np-&gt;rxopt.all)
<span class="p_chunk">@@ -384,11 +382,9 @@</span> <span class="p_context"> int ipv6_recv_error(struct sock *sk, struct msghdr *msg, int len, int *addr_len)</span>
 			if (ipv6_addr_type(&amp;sin-&gt;sin6_addr) &amp; IPV6_ADDR_LINKLOCAL)
 				sin-&gt;sin6_scope_id = IP6CB(skb)-&gt;iif;
 		} else {
<span class="p_del">-			struct inet_sock *inet = inet_sk(sk);</span>
<span class="p_del">-</span>
 			ipv6_addr_set_v4mapped(ip_hdr(skb)-&gt;saddr,
 					       &amp;sin-&gt;sin6_addr);
<span class="p_del">-			if (inet-&gt;cmsg_flags)</span>
<span class="p_add">+			if (inet_sk(sk)-&gt;cmsg_flags)</span>
 				ip_cmsg_recv(msg, skb);
 		}
 	}
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 2215d6b..6b3edff 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1339,7 +1339,8 @@</span> <span class="p_context"> int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,</span>
 	if (((length &gt; mtu) ||
 	     (skb &amp;&amp; skb_has_frags(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
<span class="p_del">-	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO)) {</span>
<span class="p_add">+	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp;</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
 		err = ip6_ufo_append_data(sk, getfrag, from, length,
 					  hh_len, fragheaderlen,
 					  transhdrlen, mtu, flags, rt);
<span class="p_header">diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c</span>
<span class="p_header">index 62096d8..884d45f 100644</span>
<span class="p_header">--- a/net/ipv6/ndisc.c</span>
<span class="p_header">+++ b/net/ipv6/ndisc.c</span>
<span class="p_chunk">@@ -1277,7 +1277,14 @@</span> <span class="p_context"> static void ndisc_router_discovery(struct sk_buff *skb)</span>
 		rt-&gt;rt6i_expires = jiffies + (HZ * lifetime);
 
 	if (ra_msg-&gt;icmph.icmp6_hop_limit) {
<span class="p_del">-		in6_dev-&gt;cnf.hop_limit = ra_msg-&gt;icmph.icmp6_hop_limit;</span>
<span class="p_add">+		/* Only set hop_limit on the interface if it is higher than</span>
<span class="p_add">+		 * the current hop_limit.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (in6_dev-&gt;cnf.hop_limit &lt; ra_msg-&gt;icmph.icmp6_hop_limit) {</span>
<span class="p_add">+			in6_dev-&gt;cnf.hop_limit = ra_msg-&gt;icmph.icmp6_hop_limit;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			ND_PRINTK2(KERN_WARNING &quot;RA: Got route advertisement with lower hop_limit than current\n&quot;);</span>
<span class="p_add">+		}</span>
 		if (rt)
 			dst_metric_set(&amp;rt-&gt;dst, RTAX_HOPLIMIT,
 				       ra_msg-&gt;icmph.icmp6_hop_limit);
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 782f67a..d89d1a6 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> static u32 *ipv6_cow_metrics(struct dst_entry *dst, unsigned long old)</span>
 	u32 *p = NULL;
 
 	if (!(rt-&gt;dst.flags &amp; DST_HOST))
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		return dst_cow_metrics_generic(dst, old);</span>
 
 	if (!rt-&gt;rt6i_peer)
 		rt6_bind_peer(rt, 1);
<span class="p_chunk">@@ -1018,12 +1018,9 @@</span> <span class="p_context"> static void ip6_rt_update_pmtu(struct dst_entry *dst, u32 mtu)</span>
 
 	if (mtu &lt; dst_mtu(dst) &amp;&amp; rt6-&gt;rt6i_dst.plen == 128) {
 		rt6-&gt;rt6i_flags |= RTF_MODIFIED;
<span class="p_del">-		if (mtu &lt; IPV6_MIN_MTU) {</span>
<span class="p_del">-			u32 features = dst_metric(dst, RTAX_FEATURES);</span>
<span class="p_add">+		if (mtu &lt; IPV6_MIN_MTU)</span>
 			mtu = IPV6_MIN_MTU;
<span class="p_del">-			features |= RTAX_FEATURE_ALLFRAG;</span>
<span class="p_del">-			dst_metric_set(dst, RTAX_FEATURES, features);</span>
<span class="p_del">-		}</span>
<span class="p_add">+</span>
 		dst_metric_set(dst, RTAX_MTU, mtu);
 	}
 }
<span class="p_header">diff --git a/net/irda/ircomm/ircomm_tty.c b/net/irda/ircomm/ircomm_tty.c</span>
<span class="p_header">index 253695d..cf368dd 100644</span>
<span class="p_header">--- a/net/irda/ircomm/ircomm_tty.c</span>
<span class="p_header">+++ b/net/irda/ircomm/ircomm_tty.c</span>
<span class="p_chunk">@@ -848,7 +848,9 @@</span> <span class="p_context"> static void ircomm_tty_wait_until_sent(struct tty_struct *tty, int timeout)</span>
 	orig_jiffies = jiffies;
 
 	/* Set poll time to 200 ms */
<span class="p_del">-	poll_time = IRDA_MIN(timeout, msecs_to_jiffies(200));</span>
<span class="p_add">+	poll_time = msecs_to_jiffies(200);</span>
<span class="p_add">+	if (timeout)</span>
<span class="p_add">+		poll_time = min_t(unsigned long, timeout, poll_time);</span>
 
 	spin_lock_irqsave(&amp;self-&gt;spinlock, flags);
 	while (self-&gt;tx_skb &amp;&amp; self-&gt;tx_skb-&gt;len) {
<span class="p_header">diff --git a/net/llc/sysctl_net_llc.c b/net/llc/sysctl_net_llc.c</span>
<span class="p_header">index e2ebe35..be078ec 100644</span>
<span class="p_header">--- a/net/llc/sysctl_net_llc.c</span>
<span class="p_header">+++ b/net/llc/sysctl_net_llc.c</span>
<span class="p_chunk">@@ -17,28 +17,28 @@</span> <span class="p_context"> static struct ctl_table llc2_timeout_table[] = {</span>
 	{
 		.procname	= &quot;ack&quot;,
 		.data		= &amp;sysctl_llc2_ack_timeout,
<span class="p_del">-		.maxlen		= sizeof(long),</span>
<span class="p_add">+		.maxlen		= sizeof(sysctl_llc2_ack_timeout),</span>
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= &quot;busy&quot;,
 		.data		= &amp;sysctl_llc2_busy_timeout,
<span class="p_del">-		.maxlen		= sizeof(long),</span>
<span class="p_add">+		.maxlen		= sizeof(sysctl_llc2_busy_timeout),</span>
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= &quot;p&quot;,
 		.data		= &amp;sysctl_llc2_p_timeout,
<span class="p_del">-		.maxlen		= sizeof(long),</span>
<span class="p_add">+		.maxlen		= sizeof(sysctl_llc2_p_timeout),</span>
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
 	{
 		.procname	= &quot;rej&quot;,
 		.data		= &amp;sysctl_llc2_rej_timeout,
<span class="p_del">-		.maxlen		= sizeof(long),</span>
<span class="p_add">+		.maxlen		= sizeof(sysctl_llc2_rej_timeout),</span>
 		.mode		= 0644,
 		.proc_handler   = proc_dointvec_jiffies,
 	},
<span class="p_header">diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c</span>
<span class="p_header">index aea1559..6174785 100644</span>
<span class="p_header">--- a/net/mac80211/agg-rx.c</span>
<span class="p_header">+++ b/net/mac80211/agg-rx.c</span>
<span class="p_chunk">@@ -49,8 +49,6 @@</span> <span class="p_context"> static void ieee80211_free_tid_rx(struct rcu_head *h)</span>
 		container_of(h, struct tid_ampdu_rx, rcu_head);
 	int i;
 
<span class="p_del">-	del_timer_sync(&amp;tid_rx-&gt;reorder_timer);</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; tid_rx-&gt;buf_size; i++)
 		dev_kfree_skb(tid_rx-&gt;reorder_buf[i]);
 	kfree(tid_rx-&gt;reorder_buf);
<span class="p_chunk">@@ -91,6 +89,12 @@</span> <span class="p_context"> void ___ieee80211_stop_rx_ba_session(struct sta_info *sta, u16 tid,</span>
 
 	del_timer_sync(&amp;tid_rx-&gt;session_timer);
 
<span class="p_add">+	/* make sure ieee80211_sta_reorder_release() doesn&#39;t re-arm the timer */</span>
<span class="p_add">+	spin_lock_bh(&amp;tid_rx-&gt;reorder_lock);</span>
<span class="p_add">+	tid_rx-&gt;removed = true;</span>
<span class="p_add">+	spin_unlock_bh(&amp;tid_rx-&gt;reorder_lock);</span>
<span class="p_add">+	del_timer_sync(&amp;tid_rx-&gt;reorder_timer);</span>
<span class="p_add">+</span>
 	call_rcu(&amp;tid_rx-&gt;rcu_head, ieee80211_free_tid_rx);
 }
 
<span class="p_header">diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h</span>
<span class="p_header">index a9cf593..8da371c5 100644</span>
<span class="p_header">--- a/net/mac80211/ieee80211_i.h</span>
<span class="p_header">+++ b/net/mac80211/ieee80211_i.h</span>
<span class="p_chunk">@@ -53,11 +53,25 @@</span> <span class="p_context"> struct ieee80211_local;</span>
 
 #define TU_TO_EXP_TIME(x)	(jiffies + usecs_to_jiffies((x) * 1024))
 
<span class="p_del">-#define IEEE80211_DEFAULT_UAPSD_QUEUES \</span>
<span class="p_del">-	(IEEE80211_WMM_IE_STA_QOSINFO_AC_BK |	\</span>
<span class="p_del">-	 IEEE80211_WMM_IE_STA_QOSINFO_AC_BE |	\</span>
<span class="p_del">-	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VI |	\</span>
<span class="p_del">-	 IEEE80211_WMM_IE_STA_QOSINFO_AC_VO)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Some APs experience problems when working with U-APSD. Decreasing the</span>
<span class="p_add">+ * probability of that happening by using legacy mode for all ACs but VO isn&#39;t</span>
<span class="p_add">+ * enough.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Cisco 4410N originally forced us to enable VO by default only because it</span>
<span class="p_add">+ * treated non-VO ACs as legacy.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * However some APs (notably Netgear R7000) silently reclassify packets to</span>
<span class="p_add">+ * different ACs. Since u-APSD ACs require trigger frames for frame retrieval</span>
<span class="p_add">+ * clients would never see some frames (e.g. ARP responses) or would fetch them</span>
<span class="p_add">+ * accidentally after a long time.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It makes little sense to enable u-APSD queues by default because it needs</span>
<span class="p_add">+ * userspace applications to be aware of it to actually take advantage of the</span>
<span class="p_add">+ * possible additional powersavings. Implicitly depending on driver autotrigger</span>
<span class="p_add">+ * frame support doesn&#39;t make much sense.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define IEEE80211_DEFAULT_UAPSD_QUEUES 0</span>
 
 #define IEEE80211_DEFAULT_MAX_SP_LEN		\
 	IEEE80211_WMM_IE_STA_QOSINFO_SP_ALL
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index c0444a0..7c53eff 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -670,9 +670,10 @@</span> <span class="p_context"> static void ieee80211_sta_reorder_release(struct ieee80211_hw *hw,</span>
 
  set_release_timer:
 
<span class="p_del">-		mod_timer(&amp;tid_agg_rx-&gt;reorder_timer,</span>
<span class="p_del">-			  tid_agg_rx-&gt;reorder_time[j] + 1 +</span>
<span class="p_del">-			  HT_RX_REORDER_BUF_TIMEOUT);</span>
<span class="p_add">+		if (!tid_agg_rx-&gt;removed)</span>
<span class="p_add">+			mod_timer(&amp;tid_agg_rx-&gt;reorder_timer,</span>
<span class="p_add">+				  tid_agg_rx-&gt;reorder_time[j] + 1 +</span>
<span class="p_add">+				  HT_RX_REORDER_BUF_TIMEOUT);</span>
 	} else {
 		del_timer(&amp;tid_agg_rx-&gt;reorder_timer);
 	}
<span class="p_chunk">@@ -1921,6 +1922,9 @@</span> <span class="p_context"> ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)</span>
 	hdr = (struct ieee80211_hdr *) skb-&gt;data;
 	mesh_hdr = (struct ieee80211s_hdr *) (skb-&gt;data + hdrlen);
 
<span class="p_add">+	if (ieee80211_drop_unencrypted(rx, hdr-&gt;frame_control))</span>
<span class="p_add">+		return RX_DROP_MONITOR;</span>
<span class="p_add">+</span>
 	/* frame is in RMC, don&#39;t forward */
 	if (ieee80211_is_data(hdr-&gt;frame_control) &amp;&amp;
 	    is_multicast_ether_addr(hdr-&gt;addr1) &amp;&amp;
<span class="p_header">diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h</span>
<span class="p_header">index a68155f..556fbcc 100644</span>
<span class="p_header">--- a/net/mac80211/sta_info.h</span>
<span class="p_header">+++ b/net/mac80211/sta_info.h</span>
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> struct tid_ampdu_tx {</span>
  * @dialog_token: dialog token for aggregation session
  * @rcu_head: RCU head used for freeing this struct
  * @reorder_lock: serializes access to reorder buffer, see below.
<span class="p_add">+ * @removed: this session is removed (but might have been found due to RCU)</span>
  *
  * This structure&#39;s lifetime is managed by RCU, assignments to
  * the array holding it must hold the aggregation mutex.
<span class="p_chunk">@@ -160,6 +161,7 @@</span> <span class="p_context"> struct tid_ampdu_rx {</span>
 	u16 buf_size;
 	u16 timeout;
 	u8 dialog_token;
<span class="p_add">+	bool removed;</span>
 };
 
 /**
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index 25bbb2e..65df296 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -537,9 +537,11 @@</span> <span class="p_context"> ieee80211_tx_h_check_control_port_protocol(struct ieee80211_tx_data *tx)</span>
 {
 	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(tx-&gt;skb);
 
<span class="p_del">-	if (unlikely(tx-&gt;sdata-&gt;control_port_protocol == tx-&gt;skb-&gt;protocol &amp;&amp;</span>
<span class="p_del">-		     tx-&gt;sdata-&gt;control_port_no_encrypt))</span>
<span class="p_del">-		info-&gt;flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;</span>
<span class="p_add">+	if (unlikely(tx-&gt;sdata-&gt;control_port_protocol == tx-&gt;skb-&gt;protocol)) {</span>
<span class="p_add">+		if (tx-&gt;sdata-&gt;control_port_no_encrypt)</span>
<span class="p_add">+			info-&gt;flags |= IEEE80211_TX_INTFL_DONT_ENCRYPT;</span>
<span class="p_add">+		info-&gt;flags |= IEEE80211_TX_CTL_USE_MINRATE;</span>
<span class="p_add">+	}</span>
 
 	return TX_CONTINUE;
 }
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_core.c b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">index 6dc7d7d..d864aaf 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_core.c</span>
<span class="p_chunk">@@ -662,16 +662,24 @@</span> <span class="p_context"> static inline int ip_vs_gather_frags_v6(struct sk_buff *skb, u_int32_t user)</span>
 }
 #endif
 
<span class="p_del">-static int ip_vs_route_me_harder(int af, struct sk_buff *skb)</span>
<span class="p_add">+static int ip_vs_route_me_harder(int af, struct sk_buff *skb,</span>
<span class="p_add">+				 unsigned int hooknum)</span>
 {
<span class="p_add">+	if (!sysctl_snat_reroute(skb))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	/* Reroute replies only to remote clients (FORWARD and LOCAL_OUT) */</span>
<span class="p_add">+	if (NF_INET_LOCAL_IN == hooknum)</span>
<span class="p_add">+		return 0;</span>
 #ifdef CONFIG_IP_VS_IPV6
 	if (af == AF_INET6) {
<span class="p_del">-		if (sysctl_snat_reroute(skb) &amp;&amp; ip6_route_me_harder(skb) != 0)</span>
<span class="p_add">+		struct dst_entry *dst = skb_dst(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (dst-&gt;dev &amp;&amp; !(dst-&gt;dev-&gt;flags &amp; IFF_LOOPBACK) &amp;&amp;</span>
<span class="p_add">+		    ip6_route_me_harder(skb) != 0)</span>
 			return 1;
 	} else
 #endif
<span class="p_del">-		if ((sysctl_snat_reroute(skb) ||</span>
<span class="p_del">-		     skb_rtable(skb)-&gt;rt_flags &amp; RTCF_LOCAL) &amp;&amp;</span>
<span class="p_add">+		if (!(skb_rtable(skb)-&gt;rt_flags &amp; RTCF_LOCAL) &amp;&amp;</span>
 		    ip_route_me_harder(skb, RTN_LOCAL) != 0)
 			return 1;
 
<span class="p_chunk">@@ -782,7 +790,8 @@</span> <span class="p_context"> static int handle_response_icmp(int af, struct sk_buff *skb,</span>
 				union nf_inet_addr *snet,
 				__u8 protocol, struct ip_vs_conn *cp,
 				struct ip_vs_protocol *pp,
<span class="p_del">-				unsigned int offset, unsigned int ihl)</span>
<span class="p_add">+				unsigned int offset, unsigned int ihl,</span>
<span class="p_add">+				unsigned int hooknum)</span>
 {
 	unsigned int verdict = NF_DROP;
 
<span class="p_chunk">@@ -812,7 +821,7 @@</span> <span class="p_context"> static int handle_response_icmp(int af, struct sk_buff *skb,</span>
 #endif
 		ip_vs_nat_icmp(skb, pp, cp, 1);
 
<span class="p_del">-	if (ip_vs_route_me_harder(af, skb))</span>
<span class="p_add">+	if (ip_vs_route_me_harder(af, skb, hooknum))</span>
 		goto out;
 
 	/* do the statistics and put it back */
<span class="p_chunk">@@ -908,7 +917,7 @@</span> <span class="p_context"> static int ip_vs_out_icmp(struct sk_buff *skb, int *related,</span>
 
 	snet.ip = iph-&gt;saddr;
 	return handle_response_icmp(AF_INET, skb, &amp;snet, cih-&gt;protocol, cp,
<span class="p_del">-				    pp, offset, ihl);</span>
<span class="p_add">+				    pp, offset, ihl, hooknum);</span>
 }
 
 #ifdef CONFIG_IP_VS_IPV6
<span class="p_chunk">@@ -985,7 +994,8 @@</span> <span class="p_context"> static int ip_vs_out_icmp_v6(struct sk_buff *skb, int *related,</span>
 
 	ipv6_addr_copy(&amp;snet.in6, &amp;iph-&gt;saddr);
 	return handle_response_icmp(AF_INET6, skb, &amp;snet, cih-&gt;nexthdr, cp,
<span class="p_del">-				    pp, offset, sizeof(struct ipv6hdr));</span>
<span class="p_add">+				    pp, offset, sizeof(struct ipv6hdr),</span>
<span class="p_add">+				    hooknum);</span>
 }
 #endif
 
<span class="p_chunk">@@ -1018,7 +1028,7 @@</span> <span class="p_context"> static inline int is_tcp_reset(const struct sk_buff *skb, int nh_len)</span>
  */
 static unsigned int
 handle_response(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,
<span class="p_del">-		struct ip_vs_conn *cp, int ihl)</span>
<span class="p_add">+		struct ip_vs_conn *cp, int ihl, unsigned int hooknum)</span>
 {
 	struct ip_vs_protocol *pp = pd-&gt;pp;
 
<span class="p_chunk">@@ -1056,7 +1066,7 @@</span> <span class="p_context"> handle_response(int af, struct sk_buff *skb, struct ip_vs_proto_data *pd,</span>
 	 * if it came from this machine itself.  So re-compute
 	 * the routing information.
 	 */
<span class="p_del">-	if (ip_vs_route_me_harder(af, skb))</span>
<span class="p_add">+	if (ip_vs_route_me_harder(af, skb, hooknum))</span>
 		goto drop;
 
 	IP_VS_DBG_PKT(10, af, pp, skb, 0, &quot;After SNAT&quot;);
<span class="p_chunk">@@ -1169,7 +1179,7 @@</span> <span class="p_context"> ip_vs_out(unsigned int hooknum, struct sk_buff *skb, int af)</span>
 	cp = pp-&gt;conn_out_get(af, skb, &amp;iph, iph.len, 0);
 
 	if (likely(cp))
<span class="p_del">-		return handle_response(af, skb, pd, cp, iph.len);</span>
<span class="p_add">+		return handle_response(af, skb, pd, cp, iph.len, hooknum);</span>
 	if (sysctl_nat_icmp_send(net) &amp;&amp;
 	    (pp-&gt;protocol == IPPROTO_TCP ||
 	     pp-&gt;protocol == IPPROTO_UDP ||
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ftp.c b/net/netfilter/ipvs/ip_vs_ftp.c</span>
<span class="p_header">index 538d74e..365163f 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ftp.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ftp.c</span>
<span class="p_chunk">@@ -183,6 +183,8 @@</span> <span class="p_context"> static int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 	struct nf_conn *ct;
 	struct net *net;
 
<span class="p_add">+	*diff = 0;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_IP_VS_IPV6
 	/* This application helper doesn&#39;t work with IPv6 yet,
 	 * so turn this into a no-op for IPv6 packets
<span class="p_chunk">@@ -191,8 +193,6 @@</span> <span class="p_context"> static int ip_vs_ftp_out(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 		return 1;
 #endif
 
<span class="p_del">-	*diff = 0;</span>
<span class="p_del">-</span>
 	/* Only useful for established sessions */
 	if (cp-&gt;state != IP_VS_TCP_S_ESTABLISHED)
 		return 1;
<span class="p_chunk">@@ -318,6 +318,9 @@</span> <span class="p_context"> static int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 	struct ip_vs_conn *n_cp;
 	struct net *net;
 
<span class="p_add">+	/* no diff required for incoming packets */</span>
<span class="p_add">+	*diff = 0;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_IP_VS_IPV6
 	/* This application helper doesn&#39;t work with IPv6 yet,
 	 * so turn this into a no-op for IPv6 packets
<span class="p_chunk">@@ -326,9 +329,6 @@</span> <span class="p_context"> static int ip_vs_ftp_in(struct ip_vs_app *app, struct ip_vs_conn *cp,</span>
 		return 1;
 #endif
 
<span class="p_del">-	/* no diff required for incoming packets */</span>
<span class="p_del">-	*diff = 0;</span>
<span class="p_del">-</span>
 	/* Only useful for established sessions */
 	if (cp-&gt;state != IP_VS_TCP_S_ESTABLISHED)
 		return 1;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">index 2b6678c0..2cbcc83 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_chunk">@@ -763,6 +763,8 @@</span> <span class="p_context"> static void ip_vs_proc_conn(struct net *net, struct ip_vs_conn_param *param,</span>
 			IP_VS_DBG(2, &quot;BACKUP, add new conn. failed\n&quot;);
 			return;
 		}
<span class="p_add">+		if (!(flags &amp; IP_VS_CONN_F_TEMPLATE))</span>
<span class="p_add">+			kfree(param-&gt;pe_data);</span>
 	} else if (!cp-&gt;dest) {
 		dest = ip_vs_try_bind_dest(cp);
 		if (dest)
<span class="p_chunk">@@ -1064,6 +1066,7 @@</span> <span class="p_context"> static inline int ip_vs_proc_sync_conn(struct net *net, __u8 *p, __u8 *msg_end)</span>
 				(opt_flags &amp; IPVS_OPT_F_SEQ_DATA ? &amp;opt : NULL)
 				);
 #endif
<span class="p_add">+	ip_vs_pe_put(param.pe);</span>
 	return 0;
 	/* Error exit */
 out:
<span class="p_header">diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c</span>
<span class="p_header">index b3a7db6..6d70533 100644</span>
<span class="p_header">--- a/net/netfilter/nf_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nf_queue.c</span>
<span class="p_chunk">@@ -233,7 +233,7 @@</span> <span class="p_context"> int nf_queue(struct sk_buff *skb,</span>
 	 * returned by nf_queue.  For instance, callers rely on -ECANCELED to mean
 	 * &#39;ignore this hook&#39;.
 	 */
<span class="p_del">-	if (IS_ERR(segs))</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(segs))</span>
 		return -EINVAL;
 
 	queued = 0;
<span class="p_header">diff --git a/net/netfilter/xt_socket.c b/net/netfilter/xt_socket.c</span>
<span class="p_header">index fe39f7e..c4706be 100644</span>
<span class="p_header">--- a/net/netfilter/xt_socket.c</span>
<span class="p_header">+++ b/net/netfilter/xt_socket.c</span>
<span class="p_chunk">@@ -205,12 +205,13 @@</span> <span class="p_context"> static int</span>
 extract_icmp6_fields(const struct sk_buff *skb,
 		     unsigned int outside_hdrlen,
 		     int *protocol,
<span class="p_del">-		     struct in6_addr **raddr,</span>
<span class="p_del">-		     struct in6_addr **laddr,</span>
<span class="p_add">+		     const struct in6_addr **raddr,</span>
<span class="p_add">+		     const struct in6_addr **laddr,</span>
 		     __be16 *rport,
<span class="p_del">-		     __be16 *lport)</span>
<span class="p_add">+		     __be16 *lport,</span>
<span class="p_add">+		     struct ipv6hdr *ipv6_var)</span>
 {
<span class="p_del">-	struct ipv6hdr *inside_iph, _inside_iph;</span>
<span class="p_add">+	const struct ipv6hdr *inside_iph;</span>
 	struct icmp6hdr *icmph, _icmph;
 	__be16 *ports, _ports[2];
 	u8 inside_nexthdr;
<span class="p_chunk">@@ -224,12 +225,15 @@</span> <span class="p_context"> extract_icmp6_fields(const struct sk_buff *skb,</span>
 	if (icmph-&gt;icmp6_type &amp; ICMPV6_INFOMSG_MASK)
 		return 1;
 
<span class="p_del">-	inside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph), sizeof(_inside_iph), &amp;_inside_iph);</span>
<span class="p_add">+	inside_iph = skb_header_pointer(skb, outside_hdrlen + sizeof(_icmph),</span>
<span class="p_add">+					sizeof(*ipv6_var), ipv6_var);</span>
 	if (inside_iph == NULL)
 		return 1;
 	inside_nexthdr = inside_iph-&gt;nexthdr;
 
<span class="p_del">-	inside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) + sizeof(_inside_iph), &amp;inside_nexthdr);</span>
<span class="p_add">+	inside_hdrlen = ipv6_skip_exthdr(skb, outside_hdrlen + sizeof(_icmph) +</span>
<span class="p_add">+					      sizeof(*ipv6_var),</span>
<span class="p_add">+					 &amp;inside_nexthdr);</span>
 	if (inside_hdrlen &lt; 0)
 		return 1; /* hjm: Packet has no/incomplete transport layer headers. */
 
<span class="p_chunk">@@ -256,10 +260,10 @@</span> <span class="p_context"> extract_icmp6_fields(const struct sk_buff *skb,</span>
 static bool
 socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)
 {
<span class="p_del">-	struct ipv6hdr *iph = ipv6_hdr(skb);</span>
<span class="p_add">+	struct ipv6hdr ipv6_var, *iph = ipv6_hdr(skb);</span>
 	struct udphdr _hdr, *hp = NULL;
 	struct sock *sk;
<span class="p_del">-	struct in6_addr *daddr, *saddr;</span>
<span class="p_add">+	const struct in6_addr *daddr, *saddr;</span>
 	__be16 dport, sport;
 	int thoff, tproto;
 	const struct xt_socket_mtinfo1 *info = (struct xt_socket_mtinfo1 *) par-&gt;matchinfo;
<span class="p_chunk">@@ -283,7 +287,7 @@</span> <span class="p_context"> socket_mt6_v1(const struct sk_buff *skb, struct xt_action_param *par)</span>
 
 	} else if (tproto == IPPROTO_ICMPV6) {
 		if (extract_icmp6_fields(skb, thoff, &amp;tproto, &amp;saddr, &amp;daddr,
<span class="p_del">-					 &amp;sport, &amp;dport))</span>
<span class="p_add">+					 &amp;sport, &amp;dport, &amp;ipv6_var))</span>
 			return false;
 	} else {
 		return false;
<span class="p_header">diff --git a/net/rds/iw_rdma.c b/net/rds/iw_rdma.c</span>
<span class="p_header">index 4e1de17..83725f3 100644</span>
<span class="p_header">--- a/net/rds/iw_rdma.c</span>
<span class="p_header">+++ b/net/rds/iw_rdma.c</span>
<span class="p_chunk">@@ -88,7 +88,9 @@</span> <span class="p_context"> static unsigned int rds_iw_unmap_fastreg_list(struct rds_iw_mr_pool *pool,</span>
 			int *unpinned);
 static void rds_iw_destroy_fastreg(struct rds_iw_mr_pool *pool, struct rds_iw_mr *ibmr);
 
<span class="p_del">-static int rds_iw_get_device(struct rds_sock *rs, struct rds_iw_device **rds_iwdev, struct rdma_cm_id **cm_id)</span>
<span class="p_add">+static int rds_iw_get_device(struct sockaddr_in *src, struct sockaddr_in *dst,</span>
<span class="p_add">+			     struct rds_iw_device **rds_iwdev,</span>
<span class="p_add">+			     struct rdma_cm_id **cm_id)</span>
 {
 	struct rds_iw_device *iwdev;
 	struct rds_iw_cm_id *i_cm_id;
<span class="p_chunk">@@ -112,15 +114,15 @@</span> <span class="p_context"> static int rds_iw_get_device(struct rds_sock *rs, struct rds_iw_device **rds_iwd</span>
 				src_addr-&gt;sin_port,
 				dst_addr-&gt;sin_addr.s_addr,
 				dst_addr-&gt;sin_port,
<span class="p_del">-				rs-&gt;rs_bound_addr,</span>
<span class="p_del">-				rs-&gt;rs_bound_port,</span>
<span class="p_del">-				rs-&gt;rs_conn_addr,</span>
<span class="p_del">-				rs-&gt;rs_conn_port);</span>
<span class="p_add">+				src-&gt;sin_addr.s_addr,</span>
<span class="p_add">+				src-&gt;sin_port,</span>
<span class="p_add">+				dst-&gt;sin_addr.s_addr,</span>
<span class="p_add">+				dst-&gt;sin_port);</span>
 #ifdef WORKING_TUPLE_DETECTION
<span class="p_del">-			if (src_addr-&gt;sin_addr.s_addr == rs-&gt;rs_bound_addr &amp;&amp;</span>
<span class="p_del">-			    src_addr-&gt;sin_port == rs-&gt;rs_bound_port &amp;&amp;</span>
<span class="p_del">-			    dst_addr-&gt;sin_addr.s_addr == rs-&gt;rs_conn_addr &amp;&amp;</span>
<span class="p_del">-			    dst_addr-&gt;sin_port == rs-&gt;rs_conn_port) {</span>
<span class="p_add">+			if (src_addr-&gt;sin_addr.s_addr == src-&gt;sin_addr.s_addr &amp;&amp;</span>
<span class="p_add">+			    src_addr-&gt;sin_port == src-&gt;sin_port &amp;&amp;</span>
<span class="p_add">+			    dst_addr-&gt;sin_addr.s_addr == dst-&gt;sin_addr.s_addr &amp;&amp;</span>
<span class="p_add">+			    dst_addr-&gt;sin_port == dst-&gt;sin_port) {</span>
 #else
 			/* FIXME - needs to compare the local and remote
 			 * ipaddr/port tuple, but the ipaddr is the only
<span class="p_chunk">@@ -128,7 +130,7 @@</span> <span class="p_context"> static int rds_iw_get_device(struct rds_sock *rs, struct rds_iw_device **rds_iwd</span>
 			 * zero&#39;ed.  It doesn&#39;t appear to be properly populated
 			 * during connection setup...
 			 */
<span class="p_del">-			if (src_addr-&gt;sin_addr.s_addr == rs-&gt;rs_bound_addr) {</span>
<span class="p_add">+			if (src_addr-&gt;sin_addr.s_addr == src-&gt;sin_addr.s_addr) {</span>
 #endif
 				spin_unlock_irq(&amp;iwdev-&gt;spinlock);
 				*rds_iwdev = iwdev;
<span class="p_chunk">@@ -180,19 +182,13 @@</span> <span class="p_context"> int rds_iw_update_cm_id(struct rds_iw_device *rds_iwdev, struct rdma_cm_id *cm_i</span>
 {
 	struct sockaddr_in *src_addr, *dst_addr;
 	struct rds_iw_device *rds_iwdev_old;
<span class="p_del">-	struct rds_sock rs;</span>
 	struct rdma_cm_id *pcm_id;
 	int rc;
 
 	src_addr = (struct sockaddr_in *)&amp;cm_id-&gt;route.addr.src_addr;
 	dst_addr = (struct sockaddr_in *)&amp;cm_id-&gt;route.addr.dst_addr;
 
<span class="p_del">-	rs.rs_bound_addr = src_addr-&gt;sin_addr.s_addr;</span>
<span class="p_del">-	rs.rs_bound_port = src_addr-&gt;sin_port;</span>
<span class="p_del">-	rs.rs_conn_addr = dst_addr-&gt;sin_addr.s_addr;</span>
<span class="p_del">-	rs.rs_conn_port = dst_addr-&gt;sin_port;</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = rds_iw_get_device(&amp;rs, &amp;rds_iwdev_old, &amp;pcm_id);</span>
<span class="p_add">+	rc = rds_iw_get_device(src_addr, dst_addr, &amp;rds_iwdev_old, &amp;pcm_id);</span>
 	if (rc)
 		rds_iw_remove_cm_id(rds_iwdev, cm_id);
 
<span class="p_chunk">@@ -611,9 +607,17 @@</span> <span class="p_context"> void *rds_iw_get_mr(struct scatterlist *sg, unsigned long nents,</span>
 	struct rds_iw_device *rds_iwdev;
 	struct rds_iw_mr *ibmr = NULL;
 	struct rdma_cm_id *cm_id;
<span class="p_add">+	struct sockaddr_in src = {</span>
<span class="p_add">+		.sin_addr.s_addr = rs-&gt;rs_bound_addr,</span>
<span class="p_add">+		.sin_port = rs-&gt;rs_bound_port,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	struct sockaddr_in dst = {</span>
<span class="p_add">+		.sin_addr.s_addr = rs-&gt;rs_conn_addr,</span>
<span class="p_add">+		.sin_port = rs-&gt;rs_conn_port,</span>
<span class="p_add">+	};</span>
 	int ret;
 
<span class="p_del">-	ret = rds_iw_get_device(rs, &amp;rds_iwdev, &amp;cm_id);</span>
<span class="p_add">+	ret = rds_iw_get_device(&amp;src, &amp;dst, &amp;rds_iwdev, &amp;cm_id);</span>
 	if (ret || !cm_id) {
 		ret = -ENODEV;
 		goto out;
<span class="p_header">diff --git a/net/rds/sysctl.c b/net/rds/sysctl.c</span>
<span class="p_header">index 25ad0c7..065026f 100644</span>
<span class="p_header">--- a/net/rds/sysctl.c</span>
<span class="p_header">+++ b/net/rds/sysctl.c</span>
<span class="p_chunk">@@ -71,14 +71,14 @@</span> <span class="p_context"> static ctl_table rds_sysctl_rds_table[] = {</span>
 	{
 		.procname	= &quot;max_unacked_packets&quot;,
 		.data		= &amp;rds_sysctl_max_unacked_packets,
<span class="p_del">-		.maxlen         = sizeof(unsigned long),</span>
<span class="p_add">+		.maxlen         = sizeof(int),</span>
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
 	{
 		.procname	= &quot;max_unacked_bytes&quot;,
 		.data		= &amp;rds_sysctl_max_unacked_bytes,
<span class="p_del">-		.maxlen         = sizeof(unsigned long),</span>
<span class="p_add">+		.maxlen         = sizeof(int),</span>
 		.mode           = 0644,
 		.proc_handler   = proc_dointvec,
 	},
<span class="p_header">diff --git a/net/rxrpc/ar-recvmsg.c b/net/rxrpc/ar-recvmsg.c</span>
<span class="p_header">index 898492a..5cc2da5 100644</span>
<span class="p_header">--- a/net/rxrpc/ar-recvmsg.c</span>
<span class="p_header">+++ b/net/rxrpc/ar-recvmsg.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> int rxrpc_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 		if (!skb) {
 			/* nothing remains on the queue */
 			if (copied &amp;&amp;
<span class="p_del">-			    (msg-&gt;msg_flags &amp; MSG_PEEK || timeo == 0))</span>
<span class="p_add">+			    (flags &amp; MSG_PEEK || timeo == 0))</span>
 				goto out;
 
 			/* wait for a message to turn up */
<span class="p_header">diff --git a/net/sched/ematch.c b/net/sched/ematch.c</span>
<span class="p_header">index 88d93eb..088342f 100644</span>
<span class="p_header">--- a/net/sched/ematch.c</span>
<span class="p_header">+++ b/net/sched/ematch.c</span>
<span class="p_chunk">@@ -227,6 +227,7 @@</span> <span class="p_context"> static int tcf_em_validate(struct tcf_proto *tp,</span>
 				 * to replay the request.
 				 */
 				module_put(em-&gt;ops-&gt;owner);
<span class="p_add">+				em-&gt;ops = NULL;</span>
 				err = -EAGAIN;
 			}
 #endif
<span class="p_header">diff --git a/net/socket.c b/net/socket.c</span>
<span class="p_header">index 3faa358..116cf9d 100644</span>
<span class="p_header">--- a/net/socket.c</span>
<span class="p_header">+++ b/net/socket.c</span>
<span class="p_chunk">@@ -1885,6 +1885,9 @@</span> <span class="p_context"> static int copy_msghdr_from_user(struct msghdr *kmsg,</span>
 	if (copy_from_user(kmsg, umsg, sizeof(struct msghdr)))
 		return -EFAULT;
 
<span class="p_add">+	if (kmsg-&gt;msg_name == NULL)</span>
<span class="p_add">+		kmsg-&gt;msg_namelen = 0;</span>
<span class="p_add">+</span>
 	if (kmsg-&gt;msg_namelen &lt; 0)
 		return -EINVAL;
 
<span class="p_header">diff --git a/net/sunrpc/cache.c b/net/sunrpc/cache.c</span>
<span class="p_header">index 237a2ee..7de935a 100644</span>
<span class="p_header">--- a/net/sunrpc/cache.c</span>
<span class="p_header">+++ b/net/sunrpc/cache.c</span>
<span class="p_chunk">@@ -909,7 +909,7 @@</span> <span class="p_context"> static unsigned int cache_poll(struct file *filp, poll_table *wait,</span>
 	poll_wait(filp, &amp;queue_wait, wait);
 
 	/* alway allow write */
<span class="p_del">-	mask = POLL_OUT | POLLWRNORM;</span>
<span class="p_add">+	mask = POLLOUT | POLLWRNORM;</span>
 
 	if (!rp)
 		return mask;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/verbs.c b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">index 28236ba..37e4484 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/verbs.c</span>
<span class="p_chunk">@@ -485,7 +485,7 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 	if (rc) {
 		dprintk(&quot;RPC:       %s: ib_query_device failed %d\n&quot;,
 			__func__, rc);
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out3;</span>
 	}
 
 	if (devattr.device_cap_flags &amp; IB_DEVICE_LOCAL_DMA_LKEY) {
<span class="p_chunk">@@ -587,7 +587,7 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 		printk(KERN_ERR &quot;%s: invalid memory registration mode %d\n&quot;,
 				__func__, memreg);
 		rc = -EINVAL;
<span class="p_del">-		goto out2;</span>
<span class="p_add">+		goto out3;</span>
 	}
 	dprintk(&quot;RPC:       %s: memory registration strategy is %d\n&quot;,
 		__func__, memreg);
<span class="p_chunk">@@ -596,6 +596,10 @@</span> <span class="p_context"> rpcrdma_ia_open(struct rpcrdma_xprt *xprt, struct sockaddr *addr, int memreg)</span>
 	ia-&gt;ri_memreg_strategy = memreg;
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+out3:</span>
<span class="p_add">+	ib_dealloc_pd(ia-&gt;ri_pd);</span>
<span class="p_add">+	ia-&gt;ri_pd = NULL;</span>
 out2:
 	rdma_destroy_id(ia-&gt;ri_id);
 	ia-&gt;ri_id = NULL;
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index cb4168e..e1f73b6 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -2650,6 +2650,14 @@</span> <span class="p_context"> static int nl80211_new_station(struct sk_buff *skb, struct genl_info *info)</span>
 	if (parse_station_flags(info, &amp;params))
 		return -EINVAL;
 
<span class="p_add">+	/* HT requires QoS, but if we don&#39;t have that just ignore HT/VHT</span>
<span class="p_add">+	 * as userspace might just pass through the capabilities from the IEs</span>
<span class="p_add">+	 * directly, rather than enforcing this restriction and returning an</span>
<span class="p_add">+	 * error in this case.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(params.sta_flags_set &amp; BIT(NL80211_STA_FLAG_WME)))</span>
<span class="p_add">+		params.ht_capa = NULL;</span>
<span class="p_add">+</span>
 	/* parse WME attributes if sta is WME capable */
 	if ((rdev-&gt;wiphy.flags &amp; WIPHY_FLAG_AP_UAPSD) &amp;&amp;
 	    (params.sta_flags_set &amp; BIT(NL80211_STA_FLAG_WME)) &amp;&amp;
<span class="p_header">diff --git a/net/xfrm/xfrm_output.c b/net/xfrm/xfrm_output.c</span>
<span class="p_header">index 47bacd8..e49d5f4 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_output.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_output.c</span>
<span class="p_chunk">@@ -151,6 +151,8 @@</span> <span class="p_context"> static int xfrm_output_gso(struct sk_buff *skb)</span>
 	kfree_skb(skb);
 	if (IS_ERR(segs))
 		return PTR_ERR(segs);
<span class="p_add">+	if (segs == NULL)</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	do {
 		struct sk_buff *nskb = segs-&gt;next;
<span class="p_header">diff --git a/security/selinux/selinuxfs.c b/security/selinux/selinuxfs.c</span>
<span class="p_header">index 4dd8dcf..bac8928 100644</span>
<span class="p_header">--- a/security/selinux/selinuxfs.c</span>
<span class="p_header">+++ b/security/selinux/selinuxfs.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static ssize_t sel_write_enforce(struct file *file, const char __user *buf,</span>
 		goto out;
 
 	/* No partial writes. */
<span class="p_del">-	length = EINVAL;</span>
<span class="p_add">+	length = -EINVAL;</span>
 	if (*ppos != 0)
 		goto out;
 
<span class="p_header">diff --git a/security/smack/smack.h b/security/smack/smack.h</span>
<span class="p_header">index 2ad0065..bd88b73 100644</span>
<span class="p_header">--- a/security/smack/smack.h</span>
<span class="p_header">+++ b/security/smack/smack.h</span>
<span class="p_chunk">@@ -272,6 +272,16 @@</span> <span class="p_context"> static inline char *smk_of_task(const struct task_smack *tsp)</span>
 	return tsp-&gt;smk_task;
 }
 
<span class="p_add">+static inline char *smk_of_task_struct(const struct task_struct *t)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char *skp;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	skp = smk_of_task(__task_cred(t)-&gt;security);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return skp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Present a pointer to the forked smack label in an task blob.
  */
<span class="p_header">diff --git a/security/smack/smack_lsm.c b/security/smack/smack_lsm.c</span>
<span class="p_header">index e3adb49..774c159 100644</span>
<span class="p_header">--- a/security/smack/smack_lsm.c</span>
<span class="p_header">+++ b/security/smack/smack_lsm.c</span>
<span class="p_chunk">@@ -38,8 +38,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/personality.h&gt;
 #include &quot;smack.h&quot;
 
<span class="p_del">-#define task_security(task)	(task_cred_xxx((task), security))</span>
<span class="p_del">-</span>
 #define TRANS_TRUE	&quot;TRUE&quot;
 #define TRANS_TRUE_SIZE	4
 
<span class="p_chunk">@@ -161,7 +159,7 @@</span> <span class="p_context"> static int smack_ptrace_access_check(struct task_struct *ctp, unsigned int mode)</span>
 	if (rc != 0)
 		return rc;
 
<span class="p_del">-	tsp = smk_of_task(task_security(ctp));</span>
<span class="p_add">+	tsp = smk_of_task_struct(ctp);</span>
 	smk_ad_init(&amp;ad, __func__, LSM_AUDIT_DATA_TASK);
 	smk_ad_setfield_u_tsk(&amp;ad, ctp);
 
<span class="p_chunk">@@ -187,7 +185,7 @@</span> <span class="p_context"> static int smack_ptrace_traceme(struct task_struct *ptp)</span>
 	if (rc != 0)
 		return rc;
 
<span class="p_del">-	tsp = smk_of_task(task_security(ptp));</span>
<span class="p_add">+	tsp = smk_of_task_struct(ptp);</span>
 	smk_ad_init(&amp;ad, __func__, LSM_AUDIT_DATA_TASK);
 	smk_ad_setfield_u_tsk(&amp;ad, ptp);
 
<span class="p_chunk">@@ -1515,7 +1513,7 @@</span> <span class="p_context"> static int smk_curacc_on_task(struct task_struct *p, int access,</span>
 
 	smk_ad_init(&amp;ad, caller, LSM_AUDIT_DATA_TASK);
 	smk_ad_setfield_u_tsk(&amp;ad, p);
<span class="p_del">-	return smk_curacc(smk_of_task(task_security(p)), access, &amp;ad);</span>
<span class="p_add">+	return smk_curacc(smk_of_task_struct(p), access, &amp;ad);</span>
 }
 
 /**
<span class="p_chunk">@@ -1561,7 +1559,7 @@</span> <span class="p_context"> static int smack_task_getsid(struct task_struct *p)</span>
  */
 static void smack_task_getsecid(struct task_struct *p, u32 *secid)
 {
<span class="p_del">-	*secid = smack_to_secid(smk_of_task(task_security(p)));</span>
<span class="p_add">+	*secid = smack_to_secid(smk_of_task_struct(p));</span>
 }
 
 /**
<span class="p_chunk">@@ -1673,7 +1671,7 @@</span> <span class="p_context"> static int smack_task_kill(struct task_struct *p, struct siginfo *info,</span>
 	 * can write the receiver.
 	 */
 	if (secid == 0)
<span class="p_del">-		return smk_curacc(smk_of_task(task_security(p)), MAY_WRITE,</span>
<span class="p_add">+		return smk_curacc(smk_of_task_struct(p), MAY_WRITE,</span>
 				  &amp;ad);
 	/*
 	 * If the secid isn&#39;t 0 we&#39;re dealing with some USB IO
<span class="p_chunk">@@ -1681,7 +1679,7 @@</span> <span class="p_context"> static int smack_task_kill(struct task_struct *p, struct siginfo *info,</span>
 	 * we can&#39;t take privilege into account.
 	 */
 	return smk_access(smack_from_secid(secid),
<span class="p_del">-			  smk_of_task(task_security(p)), MAY_WRITE, &amp;ad);</span>
<span class="p_add">+			  smk_of_task_struct(p), MAY_WRITE, &amp;ad);</span>
 }
 
 /**
<span class="p_chunk">@@ -1694,9 +1692,13 @@</span> <span class="p_context"> static int smack_task_wait(struct task_struct *p)</span>
 {
 	struct smk_audit_info ad;
 	char *sp = smk_of_current();
<span class="p_del">-	char *tsp = smk_of_forked(task_security(p));</span>
<span class="p_add">+	char *tsp;</span>
 	int rc;
 
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	tsp = smk_of_forked(__task_cred(p)-&gt;security);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	/* we don&#39;t log here, we can be overriden */
 	rc = smk_access(tsp, sp, MAY_WRITE, NULL);
 	if (rc == 0)
<span class="p_chunk">@@ -1733,7 +1735,7 @@</span> <span class="p_context"> static int smack_task_wait(struct task_struct *p)</span>
 static void smack_task_to_inode(struct task_struct *p, struct inode *inode)
 {
 	struct inode_smack *isp = inode-&gt;i_security;
<span class="p_del">-	isp-&gt;smk_inode = smk_of_task(task_security(p));</span>
<span class="p_add">+	isp-&gt;smk_inode = smk_of_task_struct(p);</span>
 }
 
 /*
<span class="p_chunk">@@ -2714,7 +2716,7 @@</span> <span class="p_context"> static int smack_getprocattr(struct task_struct *p, char *name, char **value)</span>
 	if (strcmp(name, &quot;current&quot;) != 0)
 		return -EINVAL;
 
<span class="p_del">-	cp = kstrdup(smk_of_task(task_security(p)), GFP_KERNEL);</span>
<span class="p_add">+	cp = kstrdup(smk_of_task_struct(p), GFP_KERNEL);</span>
 	if (cp == NULL)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 9210594..1ba5d33 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -1164,6 +1164,10 @@</span> <span class="p_context"> static int snd_ctl_elem_add(struct snd_ctl_file *file,</span>
 
 	if (info-&gt;count &lt; 1)
 		return -EINVAL;
<span class="p_add">+	if (!*info-&gt;id.name)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (strnlen(info-&gt;id.name, sizeof(info-&gt;id.name)) &gt;= sizeof(info-&gt;id.name))</span>
<span class="p_add">+		return -EINVAL;</span>
 	access = info-&gt;access == 0 ? SNDRV_CTL_ELEM_ACCESS_READWRITE :
 		(info-&gt;access &amp; (SNDRV_CTL_ELEM_ACCESS_READWRITE|
 				 SNDRV_CTL_ELEM_ACCESS_INACTIVE|
<span class="p_header">diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c</span>
<span class="p_header">index 638600b..8a00555 100644</span>
<span class="p_header">--- a/sound/core/pcm_native.c</span>
<span class="p_header">+++ b/sound/core/pcm_native.c</span>
<span class="p_chunk">@@ -1382,6 +1382,8 @@</span> <span class="p_context"> static int snd_pcm_do_drain_init(struct snd_pcm_substream *substream, int state)</span>
 			if (! snd_pcm_playback_empty(substream)) {
 				snd_pcm_do_start(substream, SNDRV_PCM_STATE_DRAINING);
 				snd_pcm_post_start(substream, SNDRV_PCM_STATE_DRAINING);
<span class="p_add">+			} else {</span>
<span class="p_add">+				runtime-&gt;status-&gt;state = SNDRV_PCM_STATE_SETUP;</span>
 			}
 			break;
 		case SNDRV_PCM_STATE_RUNNING:
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index d10a6ef..6d19f99 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -737,7 +737,7 @@</span> <span class="p_context"> static void alc_auto_setup_eapd(struct hda_codec *codec, bool on)</span>
 {
 	/* We currently only handle front, HP */
 	static hda_nid_t pins[] = {
<span class="p_del">-		0x0f, 0x10, 0x14, 0x15, 0</span>
<span class="p_add">+		0x0f, 0x10, 0x14, 0x15, 0x17, 0</span>
 	};
 	hda_nid_t *p;
 	for (p = pins; *p; p++)
<span class="p_header">diff --git a/sound/pci/riptide/riptide.c b/sound/pci/riptide/riptide.c</span>
<span class="p_header">index dcbedd3..c86044f 100644</span>
<span class="p_header">--- a/sound/pci/riptide/riptide.c</span>
<span class="p_header">+++ b/sound/pci/riptide/riptide.c</span>
<span class="p_chunk">@@ -2026,32 +2026,43 @@</span> <span class="p_context"> snd_riptide_joystick_probe(struct pci_dev *pci, const struct pci_device_id *id)</span>
 {
 	static int dev;
 	struct gameport *gameport;
<span class="p_add">+	int ret;</span>
 
 	if (dev &gt;= SNDRV_CARDS)
 		return -ENODEV;
<span class="p_add">+</span>
 	if (!enable[dev]) {
<span class="p_del">-		dev++;</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_add">+		ret = -ENOENT;</span>
<span class="p_add">+		goto inc_dev;</span>
 	}
 
<span class="p_del">-	if (!joystick_port[dev++])</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (!joystick_port[dev]) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto inc_dev;</span>
<span class="p_add">+	}</span>
 
 	gameport = gameport_allocate_port();
<span class="p_del">-	if (!gameport)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!gameport) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto inc_dev;</span>
<span class="p_add">+	}</span>
 	if (!request_region(joystick_port[dev], 8, &quot;Riptide gameport&quot;)) {
 		snd_printk(KERN_WARNING
 			   &quot;Riptide: cannot grab gameport 0x%x\n&quot;,
 			   joystick_port[dev]);
 		gameport_free_port(gameport);
<span class="p_del">-		return -EBUSY;</span>
<span class="p_add">+		ret = -EBUSY;</span>
<span class="p_add">+		goto inc_dev;</span>
 	}
 
 	gameport-&gt;io = joystick_port[dev];
 	gameport_register_port(gameport);
 	pci_set_drvdata(pci, gameport);
<span class="p_del">-	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = 0;</span>
<span class="p_add">+inc_dev:</span>
<span class="p_add">+	dev++;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void __devexit snd_riptide_joystick_remove(struct pci_dev *pci)
<span class="p_header">diff --git a/sound/pci/rme9652/hdspm.c b/sound/pci/rme9652/hdspm.c</span>
<span class="p_header">index 19ee220..71a3d52 100644</span>
<span class="p_header">--- a/sound/pci/rme9652/hdspm.c</span>
<span class="p_header">+++ b/sound/pci/rme9652/hdspm.c</span>
<span class="p_chunk">@@ -5966,6 +5966,9 @@</span> <span class="p_context"> static int snd_hdspm_playback_open(struct snd_pcm_substream *substream)</span>
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
<span class="p_add">+		snd_pcm_hw_constraint_minmax(runtime,</span>
<span class="p_add">+					     SNDRV_PCM_HW_PARAM_PERIODS,</span>
<span class="p_add">+					     2, 2);</span>
 		break;
 	}
 
<span class="p_chunk">@@ -6040,6 +6043,9 @@</span> <span class="p_context"> static int snd_hdspm_capture_open(struct snd_pcm_substream *substream)</span>
 		snd_pcm_hw_constraint_minmax(runtime,
 					     SNDRV_PCM_HW_PARAM_PERIOD_SIZE,
 					     64, 8192);
<span class="p_add">+		snd_pcm_hw_constraint_minmax(runtime,</span>
<span class="p_add">+					     SNDRV_PCM_HW_PARAM_PERIODS,</span>
<span class="p_add">+					     2, 2);</span>
 		break;
 	}
 
<span class="p_header">diff --git a/sound/soc/codecs/adav80x.c b/sound/soc/codecs/adav80x.c</span>
<span class="p_header">index f9f0894..b23d979 100644</span>
<span class="p_header">--- a/sound/soc/codecs/adav80x.c</span>
<span class="p_header">+++ b/sound/soc/codecs/adav80x.c</span>
<span class="p_chunk">@@ -307,7 +307,7 @@</span> <span class="p_context"> static int adav80x_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	unsigned int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	unsigned int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static int adav80x_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct adav80x *adav80x = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = adav80x-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = adav80x-&gt;deemph;</span>
 	return 0;
 };
 
<span class="p_header">diff --git a/sound/soc/codecs/ak4641.c b/sound/soc/codecs/ak4641.c</span>
<span class="p_header">index 7783858..60891f6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/ak4641.c</span>
<span class="p_header">+++ b/sound/soc/codecs/ak4641.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> static int ak4641_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_chunk">@@ -91,7 +91,7 @@</span> <span class="p_context"> static int ak4641_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct ak4641_priv *ak4641 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = ak4641-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = ak4641-&gt;deemph;</span>
 	return 0;
 };
 
<span class="p_header">diff --git a/sound/soc/codecs/cs4271.c b/sound/soc/codecs/cs4271.c</span>
<span class="p_header">index 69fde15..561d5e0 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4271.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4271.c</span>
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static int cs4271_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = cs4271-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = cs4271-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static int cs4271_put_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct cs4271_private *cs4271 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	cs4271-&gt;deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	cs4271-&gt;deemph = ucontrol-&gt;value.integer.value[0];</span>
 	return cs4271_set_deemph(codec);
 }
 
<span class="p_header">diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c</span>
<span class="p_header">index c8cdf91..ed07d83 100644</span>
<span class="p_header">--- a/sound/soc/codecs/sgtl5000.c</span>
<span class="p_header">+++ b/sound/soc/codecs/sgtl5000.c</span>
<span class="p_chunk">@@ -1098,13 +1098,7 @@</span> <span class="p_context"> static int sgtl5000_set_power_regs(struct snd_soc_codec *codec)</span>
 		/* Enable VDDC charge pump */
 		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
 	} else if (vddio &gt;= 3100 &amp;&amp; vdda &gt;= 3100) {
<span class="p_del">-		/*</span>
<span class="p_del">-		 * if vddio and vddd &gt; 3.1v,</span>
<span class="p_del">-		 * charge pump should be clean before set ana_pwr</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		snd_soc_update_bits(codec, SGTL5000_CHIP_ANA_POWER,</span>
<span class="p_del">-				SGTL5000_VDDC_CHRGPMP_POWERUP, 0);</span>
<span class="p_del">-</span>
<span class="p_add">+		ana_pwr &amp;= ~SGTL5000_VDDC_CHRGPMP_POWERUP;</span>
 		/* VDDC use VDDIO rail */
 		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
 		lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO &lt;&lt;
<span class="p_header">diff --git a/sound/soc/codecs/wm2000.c b/sound/soc/codecs/wm2000.c</span>
<span class="p_header">index ba03dc2..d421140 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm2000.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm2000.c</span>
<span class="p_chunk">@@ -614,7 +614,7 @@</span> <span class="p_context"> static int wm2000_anc_mode_get(struct snd_kcontrol *kcontrol,</span>
 {
 	struct wm2000_priv *wm2000 = dev_get_drvdata(&amp;wm2000_i2c-&gt;dev);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm2000-&gt;anc_active;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm2000-&gt;anc_active;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -623,7 +623,7 @@</span> <span class="p_context"> static int wm2000_anc_mode_put(struct snd_kcontrol *kcontrol,</span>
 			       struct snd_ctl_elem_value *ucontrol)
 {
 	struct wm2000_priv *wm2000 = dev_get_drvdata(&amp;wm2000_i2c-&gt;dev);
<span class="p_del">-	int anc_active = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int anc_active = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (anc_active &gt; 1)
 		return -EINVAL;
<span class="p_chunk">@@ -638,7 +638,7 @@</span> <span class="p_context"> static int wm2000_speaker_get(struct snd_kcontrol *kcontrol,</span>
 {
 	struct wm2000_priv *wm2000 = dev_get_drvdata(&amp;wm2000_i2c-&gt;dev);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm2000-&gt;spk_ena;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm2000-&gt;spk_ena;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -647,7 +647,7 @@</span> <span class="p_context"> static int wm2000_speaker_put(struct snd_kcontrol *kcontrol,</span>
 			      struct snd_ctl_elem_value *ucontrol)
 {
 	struct wm2000_priv *wm2000 = dev_get_drvdata(&amp;wm2000_i2c-&gt;dev);
<span class="p_del">-	int val = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int val = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (val &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/codecs/wm8731.c b/sound/soc/codecs/wm8731.c</span>
<span class="p_header">index 6cfd4f7..dffede1 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8731.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8731.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> static int wm8731_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8731-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8731-&gt;deemph;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> static int wm8731_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8731_priv *wm8731 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 	int ret = 0;
 
 	if (deemph &gt; 1)
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.c b/sound/soc/codecs/wm8903.c</span>
<span class="p_header">index 4352ffb..16c0ec5 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.c</span>
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> static int wm8903_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8903-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8903-&gt;deemph;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -474,7 +474,7 @@</span> <span class="p_context"> static int wm8903_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8903_priv *wm8903 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 	int ret = 0;
 
 	if (deemph &gt; 1)
<span class="p_header">diff --git a/sound/soc/codecs/wm8904.c b/sound/soc/codecs/wm8904.c</span>
<span class="p_header">index fafb76f..79bfa52 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8904.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8904.c</span>
<span class="p_chunk">@@ -814,7 +814,7 @@</span> <span class="p_context"> static int wm8904_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8904-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8904-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -823,7 +823,7 @@</span> <span class="p_context"> static int wm8904_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8904_priv *wm8904 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 3c71987..77ff1d7 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -377,7 +377,7 @@</span> <span class="p_context"> static int wm8955_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8955-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8955-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static int wm8955_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8955_priv *wm8955 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index 3551705..b2abe93 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> static int wm8960_get_deemph(struct snd_kcontrol *kcontrol,</span>
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
 
<span class="p_del">-	ucontrol-&gt;value.enumerated.item[0] = wm8960-&gt;deemph;</span>
<span class="p_add">+	ucontrol-&gt;value.integer.value[0] = wm8960-&gt;deemph;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static int wm8960_put_deemph(struct snd_kcontrol *kcontrol,</span>
 {
 	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct wm8960_priv *wm8960 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int deemph = ucontrol-&gt;value.enumerated.item[0];</span>
<span class="p_add">+	int deemph = ucontrol-&gt;value.integer.value[0];</span>
 
 	if (deemph &gt; 1)
 		return -EINVAL;
<span class="p_header">diff --git a/sound/soc/omap/omap-pcm.c b/sound/soc/omap/omap-pcm.c</span>
<span class="p_header">index 6ede7dc..9563728 100644</span>
<span class="p_header">--- a/sound/soc/omap/omap-pcm.c</span>
<span class="p_header">+++ b/sound/soc/omap/omap-pcm.c</span>
<span class="p_chunk">@@ -333,7 +333,7 @@</span> <span class="p_context"> static struct snd_pcm_ops omap_pcm_ops = {</span>
 	.mmap		= omap_pcm_mmap,
 };
 
<span class="p_del">-static u64 omap_pcm_dmamask = DMA_BIT_MASK(64);</span>
<span class="p_add">+static u64 omap_pcm_dmamask = DMA_BIT_MASK(32);</span>
 
 static int omap_pcm_preallocate_dma_buffer(struct snd_pcm *pcm,
 	int stream)
<span class="p_chunk">@@ -385,7 +385,7 @@</span> <span class="p_context"> static int omap_pcm_new(struct snd_soc_pcm_runtime *rtd)</span>
 	if (!card-&gt;dev-&gt;dma_mask)
 		card-&gt;dev-&gt;dma_mask = &amp;omap_pcm_dmamask;
 	if (!card-&gt;dev-&gt;coherent_dma_mask)
<span class="p_del">-		card-&gt;dev-&gt;coherent_dma_mask = DMA_BIT_MASK(64);</span>
<span class="p_add">+		card-&gt;dev-&gt;coherent_dma_mask = DMA_BIT_MASK(32);</span>
 
 	if (dai-&gt;driver-&gt;playback.channels_min) {
 		ret = omap_pcm_preallocate_dma_buffer(pcm,
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index fb95069..040d101 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> static const struct rc_config {</span>
 	{ USB_ID(0x041e, 0x3040), 2, 2, 6, 6,  2,  0x6e91 }, /* Live! 24-bit */
 	{ USB_ID(0x041e, 0x3042), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 */
 	{ USB_ID(0x041e, 0x30df), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */
<span class="p_add">+	{ USB_ID(0x041e, 0x3237), 0, 1, 1, 1,  1,  0x000d }, /* Usb X-Fi S51 Pro */</span>
 	{ USB_ID(0x041e, 0x3048), 2, 2, 6, 6,  2,  0x6e91 }, /* Toshiba SB0500 */
 };
 
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index 2aacb96..b38dde0 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -1803,6 +1803,36 @@</span> <span class="p_context"> YAMAHA_DEVICE(0x7010, &quot;UB99&quot;),</span>
 		}
 	}
 },
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE(0x0582, 0x0159),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp; (const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		/* .vendor_name = &quot;Roland&quot;, */</span>
<span class="p_add">+		/* .product_name = &quot;UA-22&quot;, */</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_INTERFACE</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_MIDI_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp; (const struct snd_usb_midi_endpoint_info) {</span>
<span class="p_add">+					.out_cables = 0x0001,</span>
<span class="p_add">+					.in_cables = 0x0001</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = -1</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
 
 /* Guillemot devices */
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



