
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.7.8 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.7.8</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 16, 2016, 4:11 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161016161121.GB19710@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9378245/mbox/"
   >mbox</a>
|
   <a href="/patch/9378245/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9378245/">/patch/9378245/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4967D600CA for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:11:39 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3954628BE4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:11:39 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 2A89128DE0; Sun, 16 Oct 2016 16:11:39 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 381B928BEC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 16 Oct 2016 16:11:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932744AbcJPQLd (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 16 Oct 2016 12:11:33 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:47549 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932612AbcJPQLP (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 16 Oct 2016 12:11:15 -0400
Received: from localhost (unknown [37.162.138.181])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 3A5B8A48;
	Sun, 16 Oct 2016 16:11:14 +0000 (UTC)
Date: Sun, 16 Oct 2016 18:11:21 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.7.8
Message-ID: &lt;20161016161121.GB19710@kroah.com&gt;
References: &lt;20161016161114.GA19710@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161016161114.GA19710@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 16, 2016, 4:11 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/virtual/kvm/devices/vcpu.txt b/Documentation/virtual/kvm/devices/vcpu.txt</span>
<span class="p_header">index c04165868faf..02f50686c418 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/devices/vcpu.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/devices/vcpu.txt</span>
<span class="p_chunk">@@ -30,4 +30,6 @@</span> <span class="p_context"> Returns: -ENODEV: PMUv3 not supported</span>
                  attribute
          -EBUSY: PMUv3 already initialized
 
<span class="p_del">-Request the initialization of the PMUv3.</span>
<span class="p_add">+Request the initialization of the PMUv3.  This must be done after creating the</span>
<span class="p_add">+in-kernel irqchip.  Creating a PMU with a userspace irqchip is currently not</span>
<span class="p_add">+supported.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 320a9308470b..4e17baa91e9c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 7
<span class="p_del">-SUBLEVEL = 7</span>
<span class="p_add">+SUBLEVEL = 8</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-390.dtsi b/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_header">index 094e39c66039..6cd18d8aaac7 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-390.dtsi</span>
<span class="p_chunk">@@ -47,6 +47,8 @@</span> <span class="p_context"></span>
 #include &quot;armada-39x.dtsi&quot;
 
 / {
<span class="p_add">+	compatible = &quot;marvell,armada390&quot;;</span>
<span class="p_add">+</span>
 	soc {
 		internal-regs {
 			pinctrl@18000 {
<span class="p_chunk">@@ -54,4 +56,5 @@</span> <span class="p_context"></span>
 				reg = &lt;0x18000 0x20&gt;;
 			};
 		};
<span class="p_add">+	};</span>
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/qcom-apq8064.dtsi b/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_header">index df96ccdc9bb4..779f8445942c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/qcom-apq8064.dtsi</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;dt-bindings/reset/qcom,gcc-msm8960.h&gt;
 #include &lt;dt-bindings/clock/qcom,mmcc-msm8960.h&gt;
 #include &lt;dt-bindings/soc/qcom,gsbi.h&gt;
<span class="p_add">+#include &lt;dt-bindings/interrupt-controller/irq.h&gt;</span>
 #include &lt;dt-bindings/interrupt-controller/arm-gic.h&gt;
 / {
 	model = &quot;Qualcomm APQ8064&quot;;
<span class="p_chunk">@@ -552,22 +553,50 @@</span> <span class="p_context"></span>
 					compatible = &quot;qcom,pm8921-gpio&quot;,
 						     &quot;qcom,ssbi-gpio&quot;;
 					reg = &lt;0x150&gt;;
<span class="p_del">-					interrupts = &lt;192 1&gt;, &lt;193 1&gt;, &lt;194 1&gt;,</span>
<span class="p_del">-						     &lt;195 1&gt;, &lt;196 1&gt;, &lt;197 1&gt;,</span>
<span class="p_del">-						     &lt;198 1&gt;, &lt;199 1&gt;, &lt;200 1&gt;,</span>
<span class="p_del">-						     &lt;201 1&gt;, &lt;202 1&gt;, &lt;203 1&gt;,</span>
<span class="p_del">-						     &lt;204 1&gt;, &lt;205 1&gt;, &lt;206 1&gt;,</span>
<span class="p_del">-						     &lt;207 1&gt;, &lt;208 1&gt;, &lt;209 1&gt;,</span>
<span class="p_del">-						     &lt;210 1&gt;, &lt;211 1&gt;, &lt;212 1&gt;,</span>
<span class="p_del">-						     &lt;213 1&gt;, &lt;214 1&gt;, &lt;215 1&gt;,</span>
<span class="p_del">-						     &lt;216 1&gt;, &lt;217 1&gt;, &lt;218 1&gt;,</span>
<span class="p_del">-						     &lt;219 1&gt;, &lt;220 1&gt;, &lt;221 1&gt;,</span>
<span class="p_del">-						     &lt;222 1&gt;, &lt;223 1&gt;, &lt;224 1&gt;,</span>
<span class="p_del">-						     &lt;225 1&gt;, &lt;226 1&gt;, &lt;227 1&gt;,</span>
<span class="p_del">-						     &lt;228 1&gt;, &lt;229 1&gt;, &lt;230 1&gt;,</span>
<span class="p_del">-						     &lt;231 1&gt;, &lt;232 1&gt;, &lt;233 1&gt;,</span>
<span class="p_del">-						     &lt;234 1&gt;, &lt;235 1&gt;;</span>
<span class="p_del">-</span>
<span class="p_add">+					interrupts = &lt;192 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;193 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;194 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;195 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;196 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;197 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;198 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;199 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;200 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;201 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;202 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;203 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;204 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;205 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;206 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;207 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;208 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;209 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;210 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;211 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;212 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;213 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;214 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;215 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;216 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;217 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;218 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;219 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;220 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;221 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;222 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;223 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;224 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;225 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;226 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;227 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;228 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;229 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;230 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;231 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;232 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;233 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;234 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+						     &lt;235 IRQ_TYPE_NONE&gt;;</span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 
<span class="p_chunk">@@ -580,9 +609,18 @@</span> <span class="p_context"></span>
 					gpio-controller;
 					#gpio-cells = &lt;2&gt;;
 					interrupts =
<span class="p_del">-					&lt;128 1&gt;, &lt;129 1&gt;, &lt;130 1&gt;, &lt;131 1&gt;,</span>
<span class="p_del">-					&lt;132 1&gt;, &lt;133 1&gt;, &lt;134 1&gt;, &lt;135 1&gt;,</span>
<span class="p_del">-					&lt;136 1&gt;, &lt;137 1&gt;, &lt;138 1&gt;, &lt;139 1&gt;;</span>
<span class="p_add">+					&lt;128 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;129 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;130 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;131 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;132 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;133 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;134 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;135 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;136 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;137 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;138 IRQ_TYPE_NONE&gt;,</span>
<span class="p_add">+					&lt;139 IRQ_TYPE_NONE&gt;;</span>
 				};
 
 				rtc@11d {
<span class="p_header">diff --git a/arch/arm64/kernel/stacktrace.c b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">index d9751a4769e7..d34fd72172b6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -43,6 +43,9 @@</span> <span class="p_context"> int notrace unwind_frame(struct task_struct *tsk, struct stackframe *frame)</span>
 	unsigned long fp = frame-&gt;fp;
 	unsigned long irq_stack_ptr;
 
<span class="p_add">+	if (!tsk)</span>
<span class="p_add">+		tsk = current;</span>
<span class="p_add">+</span>
 	/*
 	 * Switching between stacks is valid when tracing current and in
 	 * non-preemptible context.
<span class="p_chunk">@@ -67,7 +70,7 @@</span> <span class="p_context"> int notrace unwind_frame(struct task_struct *tsk, struct stackframe *frame)</span>
 	frame-&gt;pc = READ_ONCE_NOCHECK(*(unsigned long *)(fp + 8));
 
 #ifdef CONFIG_FUNCTION_GRAPH_TRACER
<span class="p_del">-	if (tsk &amp;&amp; tsk-&gt;ret_stack &amp;&amp;</span>
<span class="p_add">+	if (tsk-&gt;ret_stack &amp;&amp;</span>
 			(frame-&gt;pc == (unsigned long)return_to_handler)) {
 		/*
 		 * This is a case where function graph tracer has
<span class="p_header">diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c</span>
<span class="p_header">index 2a43012616b7..f014df90f956 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/traps.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/traps.c</span>
<span class="p_chunk">@@ -149,6 +149,11 @@</span> <span class="p_context"> static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)</span>
 	unsigned long irq_stack_ptr;
 	int skip;
 
<span class="p_add">+	pr_debug(&quot;%s(regs = %p tsk = %p)\n&quot;, __func__, regs, tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tsk)</span>
<span class="p_add">+		tsk = current;</span>
<span class="p_add">+</span>
 	/*
 	 * Switching between stacks is valid when tracing current and in
 	 * non-preemptible context.
<span class="p_chunk">@@ -158,11 +163,6 @@</span> <span class="p_context"> static void dump_backtrace(struct pt_regs *regs, struct task_struct *tsk)</span>
 	else
 		irq_stack_ptr = 0;
 
<span class="p_del">-	pr_debug(&quot;%s(regs = %p tsk = %p)\n&quot;, __func__, regs, tsk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!tsk)</span>
<span class="p_del">-		tsk = current;</span>
<span class="p_del">-</span>
 	if (tsk == current) {
 		frame.fp = (unsigned long)__builtin_frame_address(0);
 		frame.sp = current_stack_pointer;
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index 2b42a74ed771..efa592f0bf9a 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -807,6 +807,47 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbr(struct kvm_vcpu *vcpu)</span>
 	return EMULATE_FAIL;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * kvm_mips_invalidate_guest_tlb() - Indicates a change in guest MMU map.</span>
<span class="p_add">+ * @vcpu:	VCPU with changed mappings.</span>
<span class="p_add">+ * @tlb:	TLB entry being removed.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is called to indicate a single change in guest MMU mappings, so that we</span>
<span class="p_add">+ * can arrange TLB flushes on this and other CPUs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void kvm_mips_invalidate_guest_tlb(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+					  struct kvm_mips_tlb *tlb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu, i;</span>
<span class="p_add">+	bool user;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No need to flush for entries which are already invalid */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_lo[0] | tlb-&gt;tlb_lo[1]) &amp; ENTRYLO_V))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	/* User address space doesn&#39;t need flushing for KSeg2/3 changes */</span>
<span class="p_add">+	user = tlb-&gt;tlb_hi &lt; KVM_GUEST_KSEG0;</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_add">+	 * matches, invalidate it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Invalidate the whole ASID on other CPUs */</span>
<span class="p_add">+	cpu = smp_processor_id();</span>
<span class="p_add">+	for_each_possible_cpu(i) {</span>
<span class="p_add">+		if (i == cpu)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (user)</span>
<span class="p_add">+			vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+		vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Write Guest TLB Entry @ Index */
 enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -826,11 +867,8 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwi(struct kvm_vcpu *vcpu)</span>
 	}
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_del">-	 * matches, invalidate it</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -859,11 +897,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_tlbwr(struct kvm_vcpu *vcpu)</span>
 
 	tlb = &amp;vcpu-&gt;arch.guest_tlb[index];
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Probe the shadow host TLB for the entry being overwritten, if one</span>
<span class="p_del">-	 * matches, invalidate it</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	kvm_mips_host_tlb_inv(vcpu, tlb-&gt;tlb_hi);</span>
<span class="p_add">+	kvm_mips_invalidate_guest_tlb(vcpu, tlb);</span>
 
 	tlb-&gt;tlb_mask = kvm_read_c0_guest_pagemask(cop0);
 	tlb-&gt;tlb_hi = kvm_read_c0_guest_entryhi(cop0);
<span class="p_chunk">@@ -982,6 +1016,7 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc,</span>
 	int32_t rt, rd, copz, sel, co_bit, op;
 	uint32_t pc = vcpu-&gt;arch.pc;
 	unsigned long curr_pc;
<span class="p_add">+	int cpu, i;</span>
 
 	/*
 	 * Update PC and hold onto current PC in case there is
<span class="p_chunk">@@ -1089,8 +1124,16 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_CP0(uint32_t inst, uint32_t *opc,</span>
 						vcpu-&gt;arch.gprs[rt]
 						&amp; KVM_ENTRYHI_ASID);
 
<span class="p_add">+					preempt_disable();</span>
 					/* Blow away the shadow host TLBs */
 					kvm_mips_flush_host_tlb(1);
<span class="p_add">+					cpu = smp_processor_id();</span>
<span class="p_add">+					for_each_possible_cpu(i)</span>
<span class="p_add">+						if (i != cpu) {</span>
<span class="p_add">+							vcpu-&gt;arch.guest_user_asid[i] = 0;</span>
<span class="p_add">+							vcpu-&gt;arch.guest_kernel_asid[i] = 0;</span>
<span class="p_add">+						}</span>
<span class="p_add">+					preempt_enable();</span>
 				}
 				kvm_write_c0_guest_entryhi(cop0,
 							   vcpu-&gt;arch.gprs[rt]);
<span class="p_header">diff --git a/arch/powerpc/include/asm/pci-bridge.h b/arch/powerpc/include/asm/pci-bridge.h</span>
<span class="p_header">index 467c0b05b6fb..9e9d38a3f56f 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/pci-bridge.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/pci-bridge.h</span>
<span class="p_chunk">@@ -299,6 +299,7 @@</span> <span class="p_context"> extern void pci_process_bridge_OF_ranges(struct pci_controller *hose,</span>
 /* Allocate &amp; free a PCI host bridge structure */
 extern struct pci_controller *pcibios_alloc_controller(struct device_node *dev);
 extern void pcibios_free_controller(struct pci_controller *phb);
<span class="p_add">+extern void pcibios_free_controller_deferred(struct pci_host_bridge *bridge);</span>
 
 #ifdef CONFIG_PCI
 extern int pcibios_vaddr_is_ioport(void __iomem *address);
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index a0948f40bc7b..145e5b71c1a9 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -718,6 +718,7 @@</span> <span class="p_context"></span>
 #define   MMCR0_FCHV	0x00000001UL /* freeze conditions in hypervisor mode */
 #define SPRN_MMCR1	798
 #define SPRN_MMCR2	785
<span class="p_add">+#define SPRN_UMMCR2	769</span>
 #define SPRN_MMCRA	0x312
 #define   MMCRA_SDSYNC	0x80000000UL /* SDAR synced with SIAR */
 #define   MMCRA_SDAR_DCACHE_MISS 0x40000000UL
<span class="p_header">diff --git a/arch/powerpc/kernel/pci-common.c b/arch/powerpc/kernel/pci-common.c</span>
<span class="p_header">index 0f7a60f1e9f6..14af45c5f77d 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/pci-common.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/pci-common.c</span>
<span class="p_chunk">@@ -103,6 +103,42 @@</span> <span class="p_context"> void pcibios_free_controller(struct pci_controller *phb)</span>
 EXPORT_SYMBOL_GPL(pcibios_free_controller);
 
 /*
<span class="p_add">+ * This function is used to call pcibios_free_controller()</span>
<span class="p_add">+ * in a deferred manner: a callback from the PCI subsystem.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * _*DO NOT*_ call pcibios_free_controller() explicitly if</span>
<span class="p_add">+ * this is used (or it may access an invalid *phb pointer).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The callback occurs when all references to the root bus</span>
<span class="p_add">+ * are dropped (e.g., child buses/devices and their users).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It&#39;s called as .release_fn() of &#39;struct pci_host_bridge&#39;</span>
<span class="p_add">+ * which is associated with the &#39;struct pci_controller.bus&#39;</span>
<span class="p_add">+ * (root bus) - it expects .release_data to hold a pointer</span>
<span class="p_add">+ * to &#39;struct pci_controller&#39;.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to use it, register .release_fn()/release_data</span>
<span class="p_add">+ * like this:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * pci_set_host_bridge_release(bridge,</span>
<span class="p_add">+ *                             pcibios_free_controller_deferred</span>
<span class="p_add">+ *                             (void *) phb);</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * e.g. in the pcibios_root_bridge_prepare() callback from</span>
<span class="p_add">+ * pci_create_root_bus().</span>
<span class="p_add">+ */</span>
<span class="p_add">+void pcibios_free_controller_deferred(struct pci_host_bridge *bridge)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_controller *phb = (struct pci_controller *)</span>
<span class="p_add">+					 bridge-&gt;release_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;domain %d, dynamic %d\n&quot;, phb-&gt;global_number, phb-&gt;is_dynamic);</span>
<span class="p_add">+</span>
<span class="p_add">+	pcibios_free_controller(phb);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(pcibios_free_controller_deferred);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * The function is used to return the minimal alignment
  * for memory or I/O windows of the associated P2P bridge.
  * By default, 4KiB alignment for I/O windows and 1MiB for
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_emulate.c b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">index 2afdb9c0937d..729f8faa95c5 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_chunk">@@ -498,6 +498,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mtspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong spr_val)</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 #endif
 		break;
 unprivileged:
<span class="p_chunk">@@ -640,6 +641,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mfspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong *spr_val</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 	case SPRN_TIR:
 #endif
 		*spr_val = 0;
<span class="p_header">diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c</span>
<span class="p_header">index 4afae695899a..eb283c5d8cf1 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/booke.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/booke.c</span>
<span class="p_chunk">@@ -2038,7 +2038,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,</span>
 		if (type == KVMPPC_DEBUG_NONE)
 			continue;
 
<span class="p_del">-		if (type &amp; !(KVMPPC_DEBUG_WATCH_READ |</span>
<span class="p_add">+		if (type &amp; ~(KVMPPC_DEBUG_WATCH_READ |</span>
 			     KVMPPC_DEBUG_WATCH_WRITE |
 			     KVMPPC_DEBUG_BREAKPOINT))
 			return -EINVAL;
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/pci.c b/arch/powerpc/platforms/pseries/pci.c</span>
<span class="p_header">index fe16a50700de..09eba5a9929a 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/pci.c</span>
<span class="p_chunk">@@ -119,6 +119,10 @@</span> <span class="p_context"> int pseries_root_bridge_prepare(struct pci_host_bridge *bridge)</span>
 
 	bus = bridge-&gt;bus;
 
<span class="p_add">+	/* Rely on the pcibios_free_controller_deferred() callback. */</span>
<span class="p_add">+	pci_set_host_bridge_release(bridge, pcibios_free_controller_deferred,</span>
<span class="p_add">+					(void *) pci_bus_to_host(bus));</span>
<span class="p_add">+</span>
 	dn = pcibios_get_phb_of_node(bus);
 	if (!dn)
 		return 0;
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/pci_dlpar.c b/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_header">index 906dbaa97fe2..547fd13e4f8e 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/pci_dlpar.c</span>
<span class="p_chunk">@@ -106,8 +106,11 @@</span> <span class="p_context"> int remove_phb_dynamic(struct pci_controller *phb)</span>
 		release_resource(res);
 	}
 
<span class="p_del">-	/* Free pci_controller data structure */</span>
<span class="p_del">-	pcibios_free_controller(phb);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The pci_controller data structure is freed by</span>
<span class="p_add">+	 * the pcibios_free_controller_deferred() callback;</span>
<span class="p_add">+	 * see pseries_root_bridge_prepare().</span>
<span class="p_add">+	 */</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/x86/include/asm/fpu/xstate.h b/arch/x86/include/asm/fpu/xstate.h</span>
<span class="p_header">index 38951b0fcc5a..993a07235e91 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/fpu/xstate.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/fpu/xstate.h</span>
<span class="p_chunk">@@ -24,11 +24,12 @@</span> <span class="p_context"></span>
 				 XFEATURE_MASK_YMM | \
 				 XFEATURE_MASK_OPMASK | \
 				 XFEATURE_MASK_ZMM_Hi256 | \
<span class="p_del">-				 XFEATURE_MASK_Hi16_ZMM	 | \</span>
<span class="p_del">-				 XFEATURE_MASK_PKRU)</span>
<span class="p_add">+				 XFEATURE_MASK_Hi16_ZMM)</span>
 
 /* Supported features which require eager state saving */
<span class="p_del">-#define XFEATURE_MASK_EAGER	(XFEATURE_MASK_BNDREGS | XFEATURE_MASK_BNDCSR)</span>
<span class="p_add">+#define XFEATURE_MASK_EAGER	(XFEATURE_MASK_BNDREGS | \</span>
<span class="p_add">+				 XFEATURE_MASK_BNDCSR | \</span>
<span class="p_add">+				 XFEATURE_MASK_PKRU)</span>
 
 /* All currently supported features */
 #define XCNTXT_MASK	(XFEATURE_MASK_LAZY | XFEATURE_MASK_EAGER)
<span class="p_header">diff --git a/arch/x86/include/asm/mpspec.h b/arch/x86/include/asm/mpspec.h</span>
<span class="p_header">index b07233b64578..c2f94dcc92ce 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mpspec.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mpspec.h</span>
<span class="p_chunk">@@ -6,7 +6,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/x86_init.h&gt;
 #include &lt;asm/apicdef.h&gt;
 
<span class="p_del">-extern int apic_version[];</span>
 extern int pic_mode;
 
 #ifdef CONFIG_X86_32
<span class="p_chunk">@@ -40,6 +39,7 @@</span> <span class="p_context"> extern int mp_bus_id_to_type[MAX_MP_BUSSES];</span>
 extern DECLARE_BITMAP(mp_bus_not_pci, MAX_MP_BUSSES);
 
 extern unsigned int boot_cpu_physical_apicid;
<span class="p_add">+extern u8 boot_cpu_apic_version;</span>
 extern unsigned long mp_lapic_addr;
 
 #ifdef CONFIG_X86_LOCAL_APIC
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index 9414f84584e4..8e6e8bc8cd9f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int acpi_register_lapic(int id, u8 enabled)</span>
 	}
 
 	if (boot_cpu_physical_apicid != -1U)
<span class="p_del">-		ver = apic_version[boot_cpu_physical_apicid];</span>
<span class="p_add">+		ver = boot_cpu_apic_version;</span>
 
 	return generic_processor_info(id, ver);
 }
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic.c b/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">index b15e1c158bda..cc7bc8bfd890 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic.c</span>
<span class="p_chunk">@@ -64,6 +64,8 @@</span> <span class="p_context"> unsigned disabled_cpus;</span>
 unsigned int boot_cpu_physical_apicid = -1U;
 EXPORT_SYMBOL_GPL(boot_cpu_physical_apicid);
 
<span class="p_add">+u8 boot_cpu_apic_version;</span>
<span class="p_add">+</span>
 /*
  * The highest APIC ID seen during enumeration.
  */
<span class="p_chunk">@@ -1790,8 +1792,7 @@</span> <span class="p_context"> void __init init_apic_mappings(void)</span>
 		 * since smp_sanity_check is prepared for such a case
 		 * and disable smp mode
 		 */
<span class="p_del">-		apic_version[new_apicid] =</span>
<span class="p_del">-			 GET_APIC_VERSION(apic_read(APIC_LVR));</span>
<span class="p_add">+		boot_cpu_apic_version = GET_APIC_VERSION(apic_read(APIC_LVR));</span>
 	}
 }
 
<span class="p_chunk">@@ -1806,13 +1807,10 @@</span> <span class="p_context"> void __init register_lapic_address(unsigned long address)</span>
 	}
 	if (boot_cpu_physical_apicid == -1U) {
 		boot_cpu_physical_apicid  = read_apic_id();
<span class="p_del">-		apic_version[boot_cpu_physical_apicid] =</span>
<span class="p_del">-			 GET_APIC_VERSION(apic_read(APIC_LVR));</span>
<span class="p_add">+		boot_cpu_apic_version = GET_APIC_VERSION(apic_read(APIC_LVR));</span>
 	}
 }
 
<span class="p_del">-int apic_version[MAX_LOCAL_APIC];</span>
<span class="p_del">-</span>
 /*
  * Local APIC interrupts
  */
<span class="p_chunk">@@ -2102,11 +2100,10 @@</span> <span class="p_context"> int generic_processor_info(int apicid, int version)</span>
 			   cpu, apicid);
 		version = 0x10;
 	}
<span class="p_del">-	apic_version[apicid] = version;</span>
 
<span class="p_del">-	if (version != apic_version[boot_cpu_physical_apicid]) {</span>
<span class="p_add">+	if (version != boot_cpu_apic_version) {</span>
 		pr_warning(&quot;BIOS bug: APIC version mismatch, boot CPU: %x, CPU %d: version %x\n&quot;,
<span class="p_del">-			apic_version[boot_cpu_physical_apicid], cpu, version);</span>
<span class="p_add">+			boot_cpu_apic_version, cpu, version);</span>
 	}
 
 	physid_set(apicid, phys_cpu_present_map);
<span class="p_chunk">@@ -2249,7 +2246,7 @@</span> <span class="p_context"> int __init APIC_init_uniprocessor(void)</span>
 	 * Complain if the BIOS pretends there is one.
 	 */
 	if (!boot_cpu_has(X86_FEATURE_APIC) &amp;&amp;
<span class="p_del">-	    APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {</span>
<span class="p_add">+	    APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 		pr_err(&quot;BIOS bug, local APIC 0x%x not detected!...\n&quot;,
 			boot_cpu_physical_apicid);
 		return -1;
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index 446702ed99dc..fbfb2446de58 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -1592,7 +1592,7 @@</span> <span class="p_context"> void __init setup_ioapic_ids_from_mpc(void)</span>
 	 * no meaning without the serial APIC bus.
 	 */
 	if (!(boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)
<span class="p_del">-		|| APIC_XAPIC(apic_version[boot_cpu_physical_apicid]))</span>
<span class="p_add">+		|| APIC_XAPIC(boot_cpu_apic_version))</span>
 		return;
 	setup_ioapic_ids_from_mpc_nocheck();
 }
<span class="p_chunk">@@ -2422,7 +2422,7 @@</span> <span class="p_context"> static int io_apic_get_unique_id(int ioapic, int apic_id)</span>
 static u8 io_apic_unique_id(int idx, u8 id)
 {
 	if ((boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) &amp;&amp;
<span class="p_del">-	    !APIC_XAPIC(apic_version[boot_cpu_physical_apicid]))</span>
<span class="p_add">+	    !APIC_XAPIC(boot_cpu_apic_version))</span>
 		return io_apic_get_unique_id(idx, id);
 	else
 		return id;
<span class="p_header">diff --git a/arch/x86/kernel/apic/probe_32.c b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">index f316e34abb42..49da80cf6a77 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/probe_32.c</span>
<span class="p_chunk">@@ -153,7 +153,7 @@</span> <span class="p_context"> early_param(&quot;apic&quot;, parse_apic);</span>
 
 void __init default_setup_apic_routing(void)
 {
<span class="p_del">-	int version = apic_version[boot_cpu_physical_apicid];</span>
<span class="p_add">+	int version = boot_cpu_apic_version;</span>
 
 	if (num_possible_cpus() &gt; 8) {
 		switch (boot_cpu_data.x86_vendor) {
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index a5e400afc563..84eced58a428 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -661,11 +661,28 @@</span> <span class="p_context"> void irq_complete_move(struct irq_cfg *cfg)</span>
  */
 void irq_force_complete_move(struct irq_desc *desc)
 {
<span class="p_del">-	struct irq_data *irqdata = irq_desc_get_irq_data(desc);</span>
<span class="p_del">-	struct apic_chip_data *data = apic_chip_data(irqdata);</span>
<span class="p_del">-	struct irq_cfg *cfg = data ? &amp;data-&gt;cfg : NULL;</span>
<span class="p_add">+	struct irq_data *irqdata;</span>
<span class="p_add">+	struct apic_chip_data *data;</span>
<span class="p_add">+	struct irq_cfg *cfg;</span>
 	unsigned int cpu;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The function is called for all descriptors regardless of which</span>
<span class="p_add">+	 * irqdomain they belong to. For example if an IRQ is provided by</span>
<span class="p_add">+	 * an irq_chip as part of a GPIO driver, the chip data for that</span>
<span class="p_add">+	 * descriptor is specific to the irq_chip in question.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Check first that the chip_data is what we expect</span>
<span class="p_add">+	 * (apic_chip_data) before touching it any further.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	irqdata = irq_domain_get_irq_data(x86_vector_domain,</span>
<span class="p_add">+					  irq_desc_get_irq(desc));</span>
<span class="p_add">+	if (!irqdata)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = apic_chip_data(irqdata);</span>
<span class="p_add">+	cfg = data ? &amp;data-&gt;cfg : NULL;</span>
<span class="p_add">+</span>
 	if (!cfg)
 		return;
 
<span class="p_header">diff --git a/arch/x86/kernel/e820.c b/arch/x86/kernel/e820.c</span>
<span class="p_header">index 621b501f8935..8a90f1517837 100644</span>
<span class="p_header">--- a/arch/x86/kernel/e820.c</span>
<span class="p_header">+++ b/arch/x86/kernel/e820.c</span>
<span class="p_chunk">@@ -348,7 +348,7 @@</span> <span class="p_context"> int __init sanitize_e820_map(struct e820entry *biosmap, int max_nr_map,</span>
 		 * continue building up new bios map based on this
 		 * information
 		 */
<span class="p_del">-		if (current_type != last_type || current_type == E820_PRAM) {</span>
<span class="p_add">+		if (current_type != last_type) {</span>
 			if (last_type != 0)	 {
 				new_bios[new_bios_entry].size =
 					change_point[chgidx]-&gt;addr - last_addr;
<span class="p_chunk">@@ -754,7 +754,7 @@</span> <span class="p_context"> u64 __init early_reserve_e820(u64 size, u64 align)</span>
 /*
  * Find the highest page frame number we have available
  */
<span class="p_del">-static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
<span class="p_add">+static unsigned long __init e820_end_pfn(unsigned long limit_pfn, unsigned type)</span>
 {
 	int i;
 	unsigned long last_pfn = 0;
<span class="p_chunk">@@ -765,11 +765,7 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 		unsigned long start_pfn;
 		unsigned long end_pfn;
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Persistent memory is accounted as ram for purposes of</span>
<span class="p_del">-		 * establishing max_pfn and mem_map.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ei-&gt;type != E820_RAM &amp;&amp; ei-&gt;type != E820_PRAM)</span>
<span class="p_add">+		if (ei-&gt;type != type)</span>
 			continue;
 
 		start_pfn = ei-&gt;addr &gt;&gt; PAGE_SHIFT;
<span class="p_chunk">@@ -794,12 +790,12 @@</span> <span class="p_context"> static unsigned long __init e820_end_pfn(unsigned long limit_pfn)</span>
 }
 unsigned long __init e820_end_of_ram_pfn(void)
 {
<span class="p_del">-	return e820_end_pfn(MAX_ARCH_PFN);</span>
<span class="p_add">+	return e820_end_pfn(MAX_ARCH_PFN, E820_RAM);</span>
 }
 
 unsigned long __init e820_end_of_low_ram_pfn(void)
 {
<span class="p_del">-	return e820_end_pfn(1UL &lt;&lt; (32-PAGE_SHIFT));</span>
<span class="p_add">+	return e820_end_pfn(1UL &lt;&lt; (32 - PAGE_SHIFT), E820_RAM);</span>
 }
 
 static void early_panic(char *msg)
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index 6e789ca1f841..5dc86d216a58 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -110,12 +110,13 @@</span> <span class="p_context"> void __show_regs(struct pt_regs *regs, int all)</span>
 	get_debugreg(d7, 7);
 
 	/* Only print out debug registers if they are in their non-default state. */
<span class="p_del">-	if ((d0 == 0) &amp;&amp; (d1 == 0) &amp;&amp; (d2 == 0) &amp;&amp; (d3 == 0) &amp;&amp;</span>
<span class="p_del">-	    (d6 == DR6_RESERVED) &amp;&amp; (d7 == 0x400))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	printk(KERN_DEFAULT &quot;DR0: %016lx DR1: %016lx DR2: %016lx\n&quot;, d0, d1, d2);</span>
<span class="p_del">-	printk(KERN_DEFAULT &quot;DR3: %016lx DR6: %016lx DR7: %016lx\n&quot;, d3, d6, d7);</span>
<span class="p_add">+	if (!((d0 == 0) &amp;&amp; (d1 == 0) &amp;&amp; (d2 == 0) &amp;&amp; (d3 == 0) &amp;&amp;</span>
<span class="p_add">+	    (d6 == DR6_RESERVED) &amp;&amp; (d7 == 0x400))) {</span>
<span class="p_add">+		printk(KERN_DEFAULT &quot;DR0: %016lx DR1: %016lx DR2: %016lx\n&quot;,</span>
<span class="p_add">+		       d0, d1, d2);</span>
<span class="p_add">+		printk(KERN_DEFAULT &quot;DR3: %016lx DR6: %016lx DR7: %016lx\n&quot;,</span>
<span class="p_add">+		       d3, d6, d7);</span>
<span class="p_add">+	}</span>
 
 	if (boot_cpu_has(X86_FEATURE_OSPKE))
 		printk(KERN_DEFAULT &quot;PKRU: %08x\n&quot;, read_pkru());
<span class="p_header">diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c</span>
<span class="p_header">index 600edd225e81..67ed18e02523 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ptrace.c</span>
<span class="p_chunk">@@ -173,8 +173,8 @@</span> <span class="p_context"> unsigned long kernel_stack_pointer(struct pt_regs *regs)</span>
 		return sp;
 
 	prev_esp = (u32 *)(context);
<span class="p_del">-	if (prev_esp)</span>
<span class="p_del">-		return (unsigned long)prev_esp;</span>
<span class="p_add">+	if (*prev_esp)</span>
<span class="p_add">+		return (unsigned long)*prev_esp;</span>
 
 	return (unsigned long)regs;
 }
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index fafe8b923cac..694c5297a0fa 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -676,7 +676,7 @@</span> <span class="p_context"> wakeup_secondary_cpu_via_nmi(int apicid, unsigned long start_eip)</span>
 	 * Give the other CPU some time to accept the IPI.
 	 */
 	udelay(200);
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 		maxlvt = lapic_get_maxlvt();
 		if (maxlvt &gt; 3)			/* Due to the Pentium erratum 3AP.  */
 			apic_write(APIC_ESR, 0);
<span class="p_chunk">@@ -703,7 +703,7 @@</span> <span class="p_context"> wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)</span>
 	/*
 	 * Be paranoid about clearing APIC errors.
 	 */
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[phys_apicid])) {</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 		if (maxlvt &gt; 3)		/* Due to the Pentium erratum 3AP.  */
 			apic_write(APIC_ESR, 0);
 		apic_read(APIC_ESR);
<span class="p_chunk">@@ -742,7 +742,7 @@</span> <span class="p_context"> wakeup_secondary_cpu_via_init(int phys_apicid, unsigned long start_eip)</span>
 	 * Determine this based on the APIC version.
 	 * If we don&#39;t have an integrated APIC, don&#39;t send the STARTUP IPIs.
 	 */
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[phys_apicid]))</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version))</span>
 		num_starts = 2;
 	else
 		num_starts = 0;
<span class="p_chunk">@@ -980,7 +980,7 @@</span> <span class="p_context"> static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle)</span>
 		/*
 		 * Be paranoid about clearing APIC errors.
 		*/
<span class="p_del">-		if (APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid])) {</span>
<span class="p_add">+		if (APIC_INTEGRATED(boot_cpu_apic_version)) {</span>
 			apic_write(APIC_ESR, 0);
 			apic_read(APIC_ESR);
 		}
<span class="p_chunk">@@ -1235,7 +1235,7 @@</span> <span class="p_context"> static int __init smp_sanity_check(unsigned max_cpus)</span>
 	/*
 	 * If we couldn&#39;t find a local APIC, then get out of here now!
 	 */
<span class="p_del">-	if (APIC_INTEGRATED(apic_version[boot_cpu_physical_apicid]) &amp;&amp;</span>
<span class="p_add">+	if (APIC_INTEGRATED(boot_cpu_apic_version) &amp;&amp;</span>
 	    !boot_cpu_has(X86_FEATURE_APIC)) {
 		if (!disable_apic) {
 			pr_err(&quot;BIOS bug, local APIC #%d not detected!...\n&quot;,
<span class="p_chunk">@@ -1393,9 +1393,21 @@</span> <span class="p_context"> __init void prefill_possible_map(void)</span>
 {
 	int i, possible;
 
<span class="p_del">-	/* no processor from mptable or madt */</span>
<span class="p_del">-	if (!num_processors)</span>
<span class="p_del">-		num_processors = 1;</span>
<span class="p_add">+	/* No boot processor was found in mptable or ACPI MADT */</span>
<span class="p_add">+	if (!num_processors) {</span>
<span class="p_add">+		int apicid = boot_cpu_physical_apicid;</span>
<span class="p_add">+		int cpu = hard_smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_warn(&quot;Boot CPU (id %d) not listed by BIOS\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Make sure boot cpu is enumerated */</span>
<span class="p_add">+		if (apic-&gt;cpu_present_to_apicid(0) == BAD_APICID &amp;&amp;</span>
<span class="p_add">+		    apic-&gt;apic_id_valid(apicid))</span>
<span class="p_add">+			generic_processor_info(apicid, boot_cpu_apic_version);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!num_processors)</span>
<span class="p_add">+			num_processors = 1;</span>
<span class="p_add">+	}</span>
 
 	i = setup_max_cpus ?: 1;
 	if (setup_possible_cpus == -1) {
<span class="p_header">diff --git a/arch/x86/xen/smp.c b/arch/x86/xen/smp.c</span>
<span class="p_header">index 719cf291dcdf..40c3aab901ed 100644</span>
<span class="p_header">--- a/arch/x86/xen/smp.c</span>
<span class="p_header">+++ b/arch/x86/xen/smp.c</span>
<span class="p_chunk">@@ -87,6 +87,12 @@</span> <span class="p_context"> static void cpu_bringup(void)</span>
 	cpu_data(cpu).x86_max_cores = 1;
 	set_cpu_sibling_map(cpu);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * identify_cpu() may have set logical_pkg_id to -1 due</span>
<span class="p_add">+	 * to incorrect phys_proc_id. Let&#39;s re-comupte it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	topology_update_package_map(apic-&gt;cpu_present_to_apicid(cpu), cpu);</span>
<span class="p_add">+</span>
 	xen_setup_cpu_clockevents();
 
 	notify_cpu_starting(cpu);
<span class="p_header">diff --git a/drivers/char/tpm/tpm-dev.c b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">index de0337ebd658..4f3137d9a35e 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> static ssize_t tpm_write(struct file *file, const char __user *buf,</span>
 
 	/* atomic tpm command send and result receive */
 	out_size = tpm_transmit(priv-&gt;chip, priv-&gt;data_buffer,
<span class="p_del">-				sizeof(priv-&gt;data_buffer));</span>
<span class="p_add">+				sizeof(priv-&gt;data_buffer), 0);</span>
 	if (out_size &lt; 0) {
 		mutex_unlock(&amp;priv-&gt;buffer_mutex);
 		return out_size;
<span class="p_header">diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">index e2fa89c88304..9ba86eb3f2ef 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_chunk">@@ -330,8 +330,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(tpm_calc_ordinal_duration);</span>
 /*
  * Internal kernel interface to transmit TPM commands
  */
<span class="p_del">-ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
<span class="p_del">-		     size_t bufsiz)</span>
<span class="p_add">+ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,</span>
<span class="p_add">+		     unsigned int flags)</span>
 {
 	ssize_t rc;
 	u32 count, ordinal;
<span class="p_chunk">@@ -350,7 +350,8 @@</span> <span class="p_context"> ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
 		return -E2BIG;
 	}
 
<span class="p_del">-	mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	if (!(flags &amp; TPM_TRANSMIT_UNLOCKED))</span>
<span class="p_add">+		mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
 
 	rc = chip-&gt;ops-&gt;send(chip, (u8 *) buf, count);
 	if (rc &lt; 0) {
<span class="p_chunk">@@ -393,20 +394,21 @@</span> <span class="p_context"> out_recv:</span>
 		dev_err(chip-&gt;pdev,
 			&quot;tpm_transmit: tpm_recv: error %zd\n&quot;, rc);
 out:
<span class="p_del">-	mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	if (!(flags &amp; TPM_TRANSMIT_UNLOCKED))</span>
<span class="p_add">+		mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
 	return rc;
 }
 
 #define TPM_DIGEST_SIZE 20
 #define TPM_RET_CODE_IDX 6
 
<span class="p_del">-ssize_t tpm_transmit_cmd(struct tpm_chip *chip, void *cmd,</span>
<span class="p_del">-			 int len, const char *desc)</span>
<span class="p_add">+ssize_t tpm_transmit_cmd(struct tpm_chip *chip, const void *cmd,</span>
<span class="p_add">+			 int len, unsigned int flags, const char *desc)</span>
 {
<span class="p_del">-	struct tpm_output_header *header;</span>
<span class="p_add">+	const struct tpm_output_header *header;</span>
 	int err;
 
<span class="p_del">-	len = tpm_transmit(chip, (u8 *) cmd, len);</span>
<span class="p_add">+	len = tpm_transmit(chip, (const u8 *)cmd, len, flags);</span>
 	if (len &lt;  0)
 		return len;
 	else if (len &lt; TPM_HEADER_SIZE)
<span class="p_chunk">@@ -454,7 +456,8 @@</span> <span class="p_context"> ssize_t tpm_getcap(struct device *dev, __be32 subcap_id, cap_t *cap,</span>
 		tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 		tpm_cmd.params.getcap_in.subcap = subcap_id;
 	}
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, desc);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
<span class="p_add">+			      desc);</span>
 	if (!rc)
 		*cap = tpm_cmd.params.getcap_out.cap;
 	return rc;
<span class="p_chunk">@@ -470,7 +473,7 @@</span> <span class="p_context"> void tpm_gen_interrupt(struct tpm_chip *chip)</span>
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 			      &quot;attempting to determine the timeouts&quot;);
 }
 EXPORT_SYMBOL_GPL(tpm_gen_interrupt);
<span class="p_chunk">@@ -491,7 +494,7 @@</span> <span class="p_context"> static int tpm_startup(struct tpm_chip *chip, __be16 startup_type)</span>
 	start_cmd.header.in = tpm_startup_header;
 
 	start_cmd.params.startup_in.startup_type = startup_type;
<span class="p_del">-	return tpm_transmit_cmd(chip, &amp;start_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	return tpm_transmit_cmd(chip, &amp;start_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 				&quot;attempting to start the TPM&quot;);
 }
 
<span class="p_chunk">@@ -522,7 +525,8 @@</span> <span class="p_context"> int tpm_get_timeouts(struct tpm_chip *chip)</span>
 	tpm_cmd.params.getcap_in.cap = TPM_CAP_PROP;
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, NULL);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
<span class="p_add">+			      NULL);</span>
 
 	if (rc == TPM_ERR_INVALID_POSTINIT) {
 		/* The TPM is not started, we are the first to talk to it.
<span class="p_chunk">@@ -536,7 +540,7 @@</span> <span class="p_context"> int tpm_get_timeouts(struct tpm_chip *chip)</span>
 		tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 		tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_TIMEOUT;
 		rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,
<span class="p_del">-				  NULL);</span>
<span class="p_add">+				      0, NULL);</span>
 	}
 	if (rc) {
 		dev_err(chip-&gt;pdev,
<span class="p_chunk">@@ -597,7 +601,7 @@</span> <span class="p_context"> duration:</span>
 	tpm_cmd.params.getcap_in.subcap_size = cpu_to_be32(4);
 	tpm_cmd.params.getcap_in.subcap = TPM_CAP_PROP_TIS_DURATION;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;tpm_cmd, TPM_INTERNAL_RESULT_SIZE, 0,</span>
 			      &quot;attempting to determine the durations&quot;);
 	if (rc)
 		return rc;
<span class="p_chunk">@@ -653,7 +657,7 @@</span> <span class="p_context"> static int tpm_continue_selftest(struct tpm_chip *chip)</span>
 	struct tpm_cmd_t cmd;
 
 	cmd.header.in = continue_selftest_header;
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, CONTINUE_SELFTEST_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, CONTINUE_SELFTEST_RESULT_SIZE, 0,</span>
 			      &quot;continue selftest&quot;);
 	return rc;
 }
<span class="p_chunk">@@ -673,7 +677,7 @@</span> <span class="p_context"> int tpm_pcr_read_dev(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)</span>
 
 	cmd.header.in = pcrread_header;
 	cmd.params.pcrread_in.pcr_idx = cpu_to_be32(pcr_idx);
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, READ_PCR_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, READ_PCR_RESULT_SIZE, 0,</span>
 			      &quot;attempting to read a pcr value&quot;);
 
 	if (rc == 0)
<span class="p_chunk">@@ -771,7 +775,7 @@</span> <span class="p_context"> int tpm_pcr_extend(u32 chip_num, int pcr_idx, const u8 *hash)</span>
 	cmd.header.in = pcrextend_header;
 	cmd.params.pcrextend_in.pcr_idx = cpu_to_be32(pcr_idx);
 	memcpy(cmd.params.pcrextend_in.hash, hash, TPM_DIGEST_SIZE);
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE, 0,</span>
 			      &quot;attempting extend a PCR value&quot;);
 
 	tpm_chip_put(chip);
<span class="p_chunk">@@ -810,7 +814,7 @@</span> <span class="p_context"> int tpm_do_selftest(struct tpm_chip *chip)</span>
 		/* Attempt to read a PCR value */
 		cmd.header.in = pcrread_header;
 		cmd.params.pcrread_in.pcr_idx = cpu_to_be32(0);
<span class="p_del">-		rc = tpm_transmit(chip, (u8 *) &amp;cmd, READ_PCR_RESULT_SIZE);</span>
<span class="p_add">+		rc = tpm_transmit(chip, (u8 *) &amp;cmd, READ_PCR_RESULT_SIZE, 0);</span>
 		/* Some buggy TPMs will not respond to tpm_tis_ready() for
 		 * around 300ms while the self test is ongoing, keep trying
 		 * until the self test duration expires. */
<span class="p_chunk">@@ -851,7 +855,7 @@</span> <span class="p_context"> int tpm_send(u32 chip_num, void *cmd, size_t buflen)</span>
 	if (chip == NULL)
 		return -ENODEV;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, cmd, buflen, &quot;attempting tpm_cmd&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, cmd, buflen, 0, &quot;attempting tpm_cmd&quot;);</span>
 
 	tpm_chip_put(chip);
 	return rc;
<span class="p_chunk">@@ -953,14 +957,15 @@</span> <span class="p_context"> int tpm_pm_suspend(struct device *dev)</span>
 		cmd.params.pcrextend_in.pcr_idx = cpu_to_be32(tpm_suspend_pcr);
 		memcpy(cmd.params.pcrextend_in.hash, dummy_hash,
 		       TPM_DIGEST_SIZE);
<span class="p_del">-		rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE,</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, EXTEND_PCR_RESULT_SIZE, 0,</span>
 				      &quot;extending dummy pcr before suspend&quot;);
 	}
 
 	/* now do the actual savestate */
 	for (try = 0; try &lt; TPM_RETRY; try++) {
 		cmd.header.in = savestate_header;
<span class="p_del">-		rc = tpm_transmit_cmd(chip, &amp;cmd, SAVESTATE_RESULT_SIZE, NULL);</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, SAVESTATE_RESULT_SIZE, 0,</span>
<span class="p_add">+				      NULL);</span>
 
 		/*
 		 * If the TPM indicates that it is too busy to respond to
<span class="p_chunk">@@ -1044,8 +1049,8 @@</span> <span class="p_context"> int tpm_get_random(u32 chip_num, u8 *out, size_t max)</span>
 		tpm_cmd.params.getrandom_in.num_bytes = cpu_to_be32(num_bytes);
 
 		err = tpm_transmit_cmd(chip, &amp;tpm_cmd,
<span class="p_del">-				   TPM_GETRANDOM_RESULT_SIZE + num_bytes,</span>
<span class="p_del">-				   &quot;attempting get random&quot;);</span>
<span class="p_add">+				       TPM_GETRANDOM_RESULT_SIZE + num_bytes,</span>
<span class="p_add">+				       0, &quot;attempting get random&quot;);</span>
 		if (err)
 			break;
 
<span class="p_header">diff --git a/drivers/char/tpm/tpm-sysfs.c b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">index ee66fd4673f3..f880856aa75e 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-sysfs.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"> static ssize_t pubek_show(struct device *dev, struct device_attribute *attr,</span>
 	struct tpm_chip *chip = dev_get_drvdata(dev);
 
 	tpm_cmd.header.in = tpm_readpubek_header;
<span class="p_del">-	err = tpm_transmit_cmd(chip, &amp;tpm_cmd, READ_PUBEK_RESULT_SIZE,</span>
<span class="p_add">+	err = tpm_transmit_cmd(chip, &amp;tpm_cmd, READ_PUBEK_RESULT_SIZE, 0,</span>
 			       &quot;attempting to read the PUBEK&quot;);
 	if (err)
 		goto out;
<span class="p_header">diff --git a/drivers/char/tpm/tpm.h b/drivers/char/tpm/tpm.h</span>
<span class="p_header">index 28b477e8da6a..f475b747454b 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm.h</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm.h</span>
<span class="p_chunk">@@ -494,11 +494,15 @@</span> <span class="p_context"> extern struct class *tpm_class;</span>
 extern dev_t tpm_devt;
 extern const struct file_operations tpm_fops;
 
<span class="p_add">+enum tpm_transmit_flags {</span>
<span class="p_add">+	TPM_TRANSMIT_UNLOCKED	= BIT(0),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+ssize_t tpm_transmit(struct tpm_chip *chip, const u8 *buf, size_t bufsiz,</span>
<span class="p_add">+		     unsigned int flags);</span>
<span class="p_add">+ssize_t tpm_transmit_cmd(struct tpm_chip *chip, const void *cmd, int len,</span>
<span class="p_add">+			 unsigned int flags, const char *desc);</span>
 ssize_t	tpm_getcap(struct device *, __be32, cap_t *, const char *);
<span class="p_del">-ssize_t tpm_transmit(struct tpm_chip *chip, const char *buf,</span>
<span class="p_del">-		     size_t bufsiz);</span>
<span class="p_del">-ssize_t tpm_transmit_cmd(struct tpm_chip *chip, void *cmd, int len,</span>
<span class="p_del">-			 const char *desc);</span>
 extern int tpm_get_timeouts(struct tpm_chip *);
 extern void tpm_gen_interrupt(struct tpm_chip *);
 extern int tpm_do_selftest(struct tpm_chip *);
<span class="p_header">diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">index ca2d2386a4eb..19f14dc4cda7 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> int tpm2_pcr_read(struct tpm_chip *chip, int pcr_idx, u8 *res_buf)</span>
 	       sizeof(cmd.params.pcrread_in.pcr_select));
 	cmd.params.pcrread_in.pcr_select[pcr_idx &gt;&gt; 3] = 1 &lt;&lt; (pcr_idx &amp; 0x7);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 			      &quot;attempting to read a pcr value&quot;);
 	if (rc == 0) {
 		buf = cmd.params.pcrread_out.digest;
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"> int tpm2_pcr_extend(struct tpm_chip *chip, int pcr_idx, const u8 *hash)</span>
 	cmd.params.pcrextend_in.hash_alg = cpu_to_be16(TPM2_ALG_SHA1);
 	memcpy(cmd.params.pcrextend_in.digest, hash, TPM_DIGEST_SIZE);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 			      &quot;attempting extend a PCR value&quot;);
 
 	return rc;
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> int tpm2_get_random(struct tpm_chip *chip, u8 *out, size_t max)</span>
 		cmd.header.in = tpm2_getrandom_header;
 		cmd.params.getrandom_in.size = cpu_to_be16(num_bytes);
 
<span class="p_del">-		err = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+		err = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 				       &quot;attempting get random&quot;);
 		if (err)
 			break;
<span class="p_chunk">@@ -434,12 +434,12 @@</span> <span class="p_context"> static void tpm2_buf_append_auth(struct tpm_buf *buf, u32 session_handle,</span>
 }
 
 /**
<span class="p_del">- * tpm2_seal_trusted() - seal a trusted key</span>
<span class="p_del">- * @chip_num: A specific chip number for the request or TPM_ANY_NUM</span>
<span class="p_del">- * @options: authentication values and other options</span>
<span class="p_add">+ * tpm2_seal_trusted() - seal the payload of a trusted key</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
  * @payload: the key data in clear and encrypted form
<span class="p_add">+ * @options: authentication values and other options</span>
  *
<span class="p_del">- * Returns &lt; 0 on error and 0 on success.</span>
<span class="p_add">+ * Return: &lt; 0 on error and 0 on success.</span>
  */
 int tpm2_seal_trusted(struct tpm_chip *chip,
 		      struct trusted_key_payload *payload,
<span class="p_chunk">@@ -512,7 +512,7 @@</span> <span class="p_context"> int tpm2_seal_trusted(struct tpm_chip *chip,</span>
 		goto out;
 	}
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;sealing data&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, 0, &quot;sealing data&quot;);</span>
 	if (rc)
 		goto out;
 
<span class="p_chunk">@@ -538,10 +538,18 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_del">-static int tpm2_load(struct tpm_chip *chip,</span>
<span class="p_del">-		     struct trusted_key_payload *payload,</span>
<span class="p_del">-		     struct trusted_key_options *options,</span>
<span class="p_del">-		     u32 *blob_handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_load_cmd() - execute a TPM2_Load command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int tpm2_load_cmd(struct tpm_chip *chip,</span>
<span class="p_add">+			 struct trusted_key_payload *payload,</span>
<span class="p_add">+			 struct trusted_key_options *options,</span>
<span class="p_add">+			 u32 *blob_handle, unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	unsigned int private_len;
<span class="p_chunk">@@ -576,7 +584,7 @@</span> <span class="p_context"> static int tpm2_load(struct tpm_chip *chip,</span>
 		goto out;
 	}
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;loading blob&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags, &quot;loading blob&quot;);</span>
 	if (!rc)
 		*blob_handle = be32_to_cpup(
 			(__be32 *) &amp;buf.data[TPM_HEADER_SIZE]);
<span class="p_chunk">@@ -590,7 +598,16 @@</span> <span class="p_context"> out:</span>
 	return rc;
 }
 
<span class="p_del">-static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_flush_context_cmd() - execute a TPM2_FlushContext command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void tpm2_flush_context_cmd(struct tpm_chip *chip, u32 handle,</span>
<span class="p_add">+				   unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	int rc;
<span class="p_chunk">@@ -604,7 +621,8 @@</span> <span class="p_context"> static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
 
 	tpm_buf_append_u32(&amp;buf, handle);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;flushing context&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags,</span>
<span class="p_add">+			      &quot;flushing context&quot;);</span>
 	if (rc)
 		dev_warn(chip-&gt;pdev, &quot;0x%08x was not flushed, rc=%d\n&quot;, handle,
 			 rc);
<span class="p_chunk">@@ -612,10 +630,18 @@</span> <span class="p_context"> static void tpm2_flush_context(struct tpm_chip *chip, u32 handle)</span>
 	tpm_buf_destroy(&amp;buf);
 }
 
<span class="p_del">-static int tpm2_unseal(struct tpm_chip *chip,</span>
<span class="p_del">-		       struct trusted_key_payload *payload,</span>
<span class="p_del">-		       struct trusted_key_options *options,</span>
<span class="p_del">-		       u32 blob_handle)</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * tpm2_unseal_cmd() - execute a TPM2_Unload command</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
<span class="p_add">+ * @payload: the key data in clear and encrypted form</span>
<span class="p_add">+ * @options: authentication values and other options</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: same as with tpm_transmit_cmd</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int tpm2_unseal_cmd(struct tpm_chip *chip,</span>
<span class="p_add">+			   struct trusted_key_payload *payload,</span>
<span class="p_add">+			   struct trusted_key_options *options,</span>
<span class="p_add">+			   u32 blob_handle, unsigned int flags)</span>
 {
 	struct tpm_buf buf;
 	u16 data_len;
<span class="p_chunk">@@ -635,7 +661,7 @@</span> <span class="p_context"> static int tpm2_unseal(struct tpm_chip *chip,</span>
 			     options-&gt;blobauth /* hmac */,
 			     TPM_DIGEST_SIZE);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, &quot;unsealing&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, buf.data, PAGE_SIZE, flags, &quot;unsealing&quot;);</span>
 	if (rc &gt; 0)
 		rc = -EPERM;
 
<span class="p_chunk">@@ -654,12 +680,12 @@</span> <span class="p_context"> static int tpm2_unseal(struct tpm_chip *chip,</span>
 }
 
 /**
<span class="p_del">- * tpm_unseal_trusted() - unseal a trusted key</span>
<span class="p_del">- * @chip_num: A specific chip number for the request or TPM_ANY_NUM</span>
<span class="p_del">- * @options: authentication values and other options</span>
<span class="p_add">+ * tpm_unseal_trusted() - unseal the payload of a trusted key</span>
<span class="p_add">+ * @chip_num: TPM chip to use</span>
  * @payload: the key data in clear and encrypted form
<span class="p_add">+ * @options: authentication values and other options</span>
  *
<span class="p_del">- * Returns &lt; 0 on error and 0 on success.</span>
<span class="p_add">+ * Return: &lt; 0 on error and 0 on success.</span>
  */
 int tpm2_unseal_trusted(struct tpm_chip *chip,
 			struct trusted_key_payload *payload,
<span class="p_chunk">@@ -668,14 +694,17 @@</span> <span class="p_context"> int tpm2_unseal_trusted(struct tpm_chip *chip,</span>
 	u32 blob_handle;
 	int rc;
 
<span class="p_del">-	rc = tpm2_load(chip, payload, options, &amp;blob_handle);</span>
<span class="p_add">+	mutex_lock(&amp;chip-&gt;tpm_mutex);</span>
<span class="p_add">+	rc = tpm2_load_cmd(chip, payload, options, &amp;blob_handle,</span>
<span class="p_add">+			   TPM_TRANSMIT_UNLOCKED);</span>
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = tpm2_unseal(chip, payload, options, blob_handle);</span>
<span class="p_del">-</span>
<span class="p_del">-	tpm2_flush_context(chip, blob_handle);</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_add">+	rc = tpm2_unseal_cmd(chip, payload, options, blob_handle,</span>
<span class="p_add">+			     TPM_TRANSMIT_UNLOCKED);</span>
<span class="p_add">+	tpm2_flush_context_cmd(chip, blob_handle, TPM_TRANSMIT_UNLOCKED);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;chip-&gt;tpm_mutex);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -701,7 +730,7 @@</span> <span class="p_context"> ssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,  u32 *value,</span>
 	cmd.params.get_tpm_pt_in.property_id = cpu_to_be32(property_id);
 	cmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), desc);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, desc);</span>
 	if (!rc)
 		*value = be32_to_cpu(cmd.params.get_tpm_pt_out.value);
 
<span class="p_chunk">@@ -735,7 +764,7 @@</span> <span class="p_context"> int tpm2_startup(struct tpm_chip *chip, u16 startup_type)</span>
 	cmd.header.in = tpm2_startup_header;
 
 	cmd.params.startup_in.startup_type = cpu_to_be16(startup_type);
<span class="p_del">-	return tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd),</span>
<span class="p_add">+	return tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0,</span>
 				&quot;attempting to start the TPM&quot;);
 }
 EXPORT_SYMBOL_GPL(tpm2_startup);
<span class="p_chunk">@@ -764,7 +793,7 @@</span> <span class="p_context"> void tpm2_shutdown(struct tpm_chip *chip, u16 shutdown_type)</span>
 	cmd.header.in = tpm2_shutdown_header;
 	cmd.params.startup_in.startup_type = cpu_to_be16(shutdown_type);
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), &quot;stopping the TPM&quot;);</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, &quot;stopping the TPM&quot;);</span>
 
 	/* In places where shutdown command is sent there&#39;s no much we can do
 	 * except print the error code on a system failure.
<span class="p_chunk">@@ -830,7 +859,7 @@</span> <span class="p_context"> static int tpm2_start_selftest(struct tpm_chip *chip, bool full)</span>
 	cmd.header.in = tpm2_selftest_header;
 	cmd.params.selftest_in.full_test = full;
 
<span class="p_del">-	rc = tpm_transmit_cmd(chip, &amp;cmd, TPM2_SELF_TEST_IN_SIZE,</span>
<span class="p_add">+	rc = tpm_transmit_cmd(chip, &amp;cmd, TPM2_SELF_TEST_IN_SIZE, 0,</span>
 			      &quot;continue selftest&quot;);
 
 	/* At least some prototype chips seem to give RC_TESTING error
<span class="p_chunk">@@ -882,7 +911,7 @@</span> <span class="p_context"> int tpm2_do_selftest(struct tpm_chip *chip)</span>
 		cmd.params.pcrread_in.pcr_select[1] = 0x00;
 		cmd.params.pcrread_in.pcr_select[2] = 0x00;
 
<span class="p_del">-		rc = tpm_transmit_cmd(chip, (u8 *) &amp;cmd, sizeof(cmd), NULL);</span>
<span class="p_add">+		rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), 0, NULL);</span>
 		if (rc &lt; 0)
 			break;
 
<span class="p_chunk">@@ -931,7 +960,7 @@</span> <span class="p_context"> int tpm2_probe(struct tpm_chip *chip)</span>
 	cmd.params.get_tpm_pt_in.property_id = cpu_to_be32(0x100);
 	cmd.params.get_tpm_pt_in.property_cnt = cpu_to_be32(1);
 
<span class="p_del">-	rc = tpm_transmit(chip, (const char *) &amp;cmd, sizeof(cmd));</span>
<span class="p_add">+	rc = tpm_transmit(chip, (const u8 *)&amp;cmd, sizeof(cmd), 0);</span>
 	if (rc &lt;  0)
 		return rc;
 	else if (rc &lt; TPM_HEADER_SIZE)
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index 0f7ec0deed6c..ee300bdcd266 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -142,6 +142,11 @@</span> <span class="p_context"> static int crb_send(struct tpm_chip *chip, u8 *buf, size_t len)</span>
 	struct crb_priv *priv = chip-&gt;vendor.priv;
 	int rc = 0;
 
<span class="p_add">+	/* Zero the cancel register so that the next command will not get</span>
<span class="p_add">+	 * canceled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	iowrite32(0, &amp;priv-&gt;cca-&gt;cancel);</span>
<span class="p_add">+</span>
 	if (len &gt; ioread32(&amp;priv-&gt;cca-&gt;cmd_size)) {
 		dev_err(&amp;chip-&gt;dev,
 			&quot;invalid command count value %x %zx\n&quot;,
<span class="p_chunk">@@ -175,8 +180,6 @@</span> <span class="p_context"> static void crb_cancel(struct tpm_chip *chip)</span>
 
 	if ((priv-&gt;flags &amp; CRB_FL_ACPI_START) &amp;&amp; crb_do_acpi_start(chip))
 		dev_err(&amp;chip-&gt;dev, &quot;ACPI Start failed\n&quot;);
<span class="p_del">-</span>
<span class="p_del">-	iowrite32(0, &amp;priv-&gt;cca-&gt;cancel);</span>
 }
 
 static bool crb_req_canceled(struct tpm_chip *chip, u8 status)
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle-arm.c b/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_header">index e342565e8715..1855b9ee807f 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle-arm.c</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"> static int __init arm_idle_init(void)</span>
 		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 		if (!dev) {
 			pr_err(&quot;Failed to allocate cpuidle device\n&quot;);
<span class="p_add">+			ret = -ENOMEM;</span>
 			goto out_fail;
 		}
 		dev-&gt;cpu = cpu;
<span class="p_header">diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig</span>
<span class="p_header">index 1bcf601de5bc..26c084da877c 100644</span>
<span class="p_header">--- a/drivers/mfd/Kconfig</span>
<span class="p_header">+++ b/drivers/mfd/Kconfig</span>
<span class="p_chunk">@@ -1535,6 +1535,7 @@</span> <span class="p_context"> config MFD_WM8350</span>
 config MFD_WM8350_I2C
 	bool &quot;Wolfson Microelectronics WM8350 with I2C&quot;
 	select MFD_WM8350
<span class="p_add">+	select REGMAP_I2C</span>
 	depends on I2C=y
 	help
 	  The WM8350 is an integrated audio and power management
<span class="p_header">diff --git a/drivers/mfd/atmel-hlcdc.c b/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_header">index eca7ea69b81c..4b15b0840f16 100644</span>
<span class="p_header">--- a/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_header">+++ b/drivers/mfd/atmel-hlcdc.c</span>
<span class="p_chunk">@@ -50,8 +50,9 @@</span> <span class="p_context"> static int regmap_atmel_hlcdc_reg_write(void *context, unsigned int reg,</span>
 	if (reg &lt;= ATMEL_HLCDC_DIS) {
 		u32 status;
 
<span class="p_del">-		readl_poll_timeout(hregmap-&gt;regs + ATMEL_HLCDC_SR, status,</span>
<span class="p_del">-				   !(status &amp; ATMEL_HLCDC_SIP), 1, 100);</span>
<span class="p_add">+		readl_poll_timeout_atomic(hregmap-&gt;regs + ATMEL_HLCDC_SR,</span>
<span class="p_add">+					  status, !(status &amp; ATMEL_HLCDC_SIP),</span>
<span class="p_add">+					  1, 100);</span>
 	}
 
 	writel(val, hregmap-&gt;regs + reg);
<span class="p_header">diff --git a/drivers/mfd/rtsx_usb.c b/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">index dbd907d7170e..691dab791f7a 100644</span>
<span class="p_header">--- a/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">+++ b/drivers/mfd/rtsx_usb.c</span>
<span class="p_chunk">@@ -46,9 +46,6 @@</span> <span class="p_context"> static void rtsx_usb_sg_timed_out(unsigned long data)</span>
 
 	dev_dbg(&amp;ucr-&gt;pusb_intf-&gt;dev, &quot;%s: sg transfer timed out&quot;, __func__);
 	usb_sg_cancel(&amp;ucr-&gt;current_sg);
<span class="p_del">-</span>
<span class="p_del">-	/* we know the cancellation is caused by time-out */</span>
<span class="p_del">-	ucr-&gt;current_sg.status = -ETIMEDOUT;</span>
 }
 
 static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,
<span class="p_chunk">@@ -67,12 +64,15 @@</span> <span class="p_context"> static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,</span>
 	ucr-&gt;sg_timer.expires = jiffies + msecs_to_jiffies(timeout);
 	add_timer(&amp;ucr-&gt;sg_timer);
 	usb_sg_wait(&amp;ucr-&gt;current_sg);
<span class="p_del">-	del_timer_sync(&amp;ucr-&gt;sg_timer);</span>
<span class="p_add">+	if (!del_timer_sync(&amp;ucr-&gt;sg_timer))</span>
<span class="p_add">+		ret = -ETIMEDOUT;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = ucr-&gt;current_sg.status;</span>
 
 	if (act_len)
 		*act_len = ucr-&gt;current_sg.bytes;
 
<span class="p_del">-	return ucr-&gt;current_sg.status;</span>
<span class="p_add">+	return ret;</span>
 }
 
 int rtsx_usb_transfer_data(struct rtsx_ucr *ucr, unsigned int pipe,
<span class="p_header">diff --git a/drivers/misc/cxl/vphb.c b/drivers/misc/cxl/vphb.c</span>
<span class="p_header">index cdc7723b845d..bec6c2260a11 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/vphb.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/vphb.c</span>
<span class="p_chunk">@@ -243,6 +243,11 @@</span> <span class="p_context"> int cxl_pci_vphb_add(struct cxl_afu *afu)</span>
 	if (phb-&gt;bus == NULL)
 		return -ENXIO;
 
<span class="p_add">+	/* Set release hook on root bus */</span>
<span class="p_add">+	pci_set_host_bridge_release(to_pci_host_bridge(phb-&gt;bus-&gt;bridge),</span>
<span class="p_add">+				    pcibios_free_controller_deferred,</span>
<span class="p_add">+				    (void *) phb);</span>
<span class="p_add">+</span>
 	/* Claim resources. This might need some rework as well depending
 	 * whether we are doing probe-only or not, like assigning unassigned
 	 * resources etc...
<span class="p_chunk">@@ -269,7 +274,10 @@</span> <span class="p_context"> void cxl_pci_vphb_remove(struct cxl_afu *afu)</span>
 	afu-&gt;phb = NULL;
 
 	pci_remove_root_bus(phb-&gt;bus);
<span class="p_del">-	pcibios_free_controller(phb);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We don&#39;t free phb here - that&#39;s handled by</span>
<span class="p_add">+	 * pcibios_free_controller_deferred()</span>
<span class="p_add">+	 */</span>
 }
 
 bool cxl_pci_is_vphb_device(struct pci_dev *dev)
<span class="p_header">diff --git a/drivers/pci/host-bridge.c b/drivers/pci/host-bridge.c</span>
<span class="p_header">index 5f4a2e04c8d7..add66236215c 100644</span>
<span class="p_header">--- a/drivers/pci/host-bridge.c</span>
<span class="p_header">+++ b/drivers/pci/host-bridge.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"> void pci_set_host_bridge_release(struct pci_host_bridge *bridge,</span>
 	bridge-&gt;release_fn = release_fn;
 	bridge-&gt;release_data = release_data;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(pci_set_host_bridge_release);</span>
 
 void pcibios_resource_to_bus(struct pci_bus *bus, struct pci_bus_region *region,
 			     struct resource *res)
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 05a5300aa1ab..b16813c04484 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -363,7 +363,8 @@</span> <span class="p_context"> static int dwc3_send_clear_stall_ep_cmd(struct dwc3_ep *dep)</span>
 	 * IN transfers due to a mishandled error condition. Synopsys
 	 * STAR 9000614252.
 	 */
<span class="p_del">-	if (dep-&gt;direction &amp;&amp; (dwc-&gt;revision &gt;= DWC3_REVISION_260A))</span>
<span class="p_add">+	if (dep-&gt;direction &amp;&amp; (dwc-&gt;revision &gt;= DWC3_REVISION_260A) &amp;&amp;</span>
<span class="p_add">+	    (dwc-&gt;gadget.speed &gt;= USB_SPEED_SUPER))</span>
 		cmd |= DWC3_DEPCMD_CLEARPENDIN;
 
 	memset(&amp;params, 0, sizeof(params));
<span class="p_header">diff --git a/include/linux/mfd/88pm80x.h b/include/linux/mfd/88pm80x.h</span>
<span class="p_header">index d409ceb2231e..c118a7ec94d6 100644</span>
<span class="p_header">--- a/include/linux/mfd/88pm80x.h</span>
<span class="p_header">+++ b/include/linux/mfd/88pm80x.h</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> static inline int pm80x_dev_suspend(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		set_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		set_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -362,7 +362,7 @@</span> <span class="p_context"> static inline int pm80x_dev_resume(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		clear_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		clear_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c</span>
<span class="p_header">index b6c394563178..1b72b17d90fe 100644</span>
<span class="p_header">--- a/kernel/time/timekeeping.c</span>
<span class="p_header">+++ b/kernel/time/timekeeping.c</span>
<span class="p_chunk">@@ -403,8 +403,11 @@</span> <span class="p_context"> static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)</span>
 		tkr = tkf-&gt;base + (seq &amp; 0x01);
 		now = ktime_to_ns(tkr-&gt;base);
 
<span class="p_del">-		now += clocksource_delta(tkr-&gt;read(tkr-&gt;clock),</span>
<span class="p_del">-					 tkr-&gt;cycle_last, tkr-&gt;mask);</span>
<span class="p_add">+		now += timekeeping_delta_to_ns(tkr,</span>
<span class="p_add">+				clocksource_delta(</span>
<span class="p_add">+					tkr-&gt;read(tkr-&gt;clock),</span>
<span class="p_add">+					tkr-&gt;cycle_last,</span>
<span class="p_add">+					tkr-&gt;mask));</span>
 	} while (read_seqcount_retry(&amp;tkf-&gt;seq, seq));
 
 	return now;
<span class="p_header">diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">index 1bcbc12e03d9..b5b932c7d1a8 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_appraise.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> int ima_appraise_measurement(enum ima_hooks func,</span>
 {
 	static const char op[] = &quot;appraise_data&quot;;
 	char *cause = &quot;unknown&quot;;
<span class="p_del">-	struct dentry *dentry = file-&gt;f_path.dentry;</span>
<span class="p_add">+	struct dentry *dentry = file_dentry(file);</span>
 	struct inode *inode = d_backing_inode(dentry);
 	enum integrity_status status = INTEGRITY_UNKNOWN;
 	int rc = xattr_len, hash_start = 0;
<span class="p_chunk">@@ -295,7 +295,7 @@</span> <span class="p_context"> out:</span>
  */
 void ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)
 {
<span class="p_del">-	struct dentry *dentry = file-&gt;f_path.dentry;</span>
<span class="p_add">+	struct dentry *dentry = file_dentry(file);</span>
 	int rc = 0;
 
 	/* do not collect and update hash for digital signatures */
<span class="p_header">diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c</span>
<span class="p_header">index 68b26c340acd..60ac3aeb5bc6 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_main.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_main.c</span>
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> static int process_measurement(struct file *file, char *buf, loff_t size,</span>
 	if ((action &amp; IMA_APPRAISE_SUBMASK) ||
 		    strcmp(template_desc-&gt;name, IMA_TEMPLATE_IMA_NAME) != 0)
 		/* read &#39;security.ima&#39; */
<span class="p_del">-		xattr_len = ima_read_xattr(file-&gt;f_path.dentry, &amp;xattr_value);</span>
<span class="p_add">+		xattr_len = ima_read_xattr(file_dentry(file), &amp;xattr_value);</span>
 
 	hash_algo = ima_get_hash_algo(xattr_value, xattr_len);
 
<span class="p_header">diff --git a/sound/pci/ali5451/ali5451.c b/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">index 36470af7eda7..92b819e4f729 100644</span>
<span class="p_header">--- a/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">+++ b/sound/pci/ali5451/ali5451.c</span>
<span class="p_chunk">@@ -1408,6 +1408,7 @@</span> <span class="p_context"> snd_ali_playback_pointer(struct snd_pcm_substream *substream)</span>
 	spin_unlock(&amp;codec-&gt;reg_lock);
 	dev_dbg(codec-&gt;card-&gt;dev, &quot;playback pointer returned cso=%xh.\n&quot;, cso);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_chunk">@@ -1428,6 +1429,7 @@</span> <span class="p_context"> static snd_pcm_uframes_t snd_ali_pointer(struct snd_pcm_substream *substream)</span>
 	cso = inw(ALI_REG(codec, ALI_CSO_ALPHA_FMS + 2));
 	spin_unlock(&amp;codec-&gt;reg_lock);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_header">diff --git a/sound/usb/line6/driver.c b/sound/usb/line6/driver.c</span>
<span class="p_header">index 81b7da8e56d3..183311cb849e 100644</span>
<span class="p_header">--- a/sound/usb/line6/driver.c</span>
<span class="p_header">+++ b/sound/usb/line6/driver.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 /*
 	This is Line 6&#39;s MIDI manufacturer ID.
 */
<span class="p_del">-const unsigned char line6_midi_id[] = {</span>
<span class="p_add">+const unsigned char line6_midi_id[3] = {</span>
 	0x00, 0x01, 0x0c
 };
 EXPORT_SYMBOL_GPL(line6_midi_id);
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index f6c3bf79af9a..04991b009132 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -1831,6 +1831,7 @@</span> <span class="p_context"> void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,</span>
 }
 
 static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,
<span class="p_add">+					 struct usb_mixer_elem_info *cval,</span>
 					 struct snd_kcontrol *kctl)
 {
 	/* Approximation using 10 ranges based on output measurement on hw v1.2.
<span class="p_chunk">@@ -1848,10 +1849,19 @@</span> <span class="p_context"> static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,</span>
 		41, 50, TLV_DB_MINMAX_ITEM(-441, 0),
 	);
 
<span class="p_del">-	usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk\n&quot;);</span>
<span class="p_del">-	kctl-&gt;tlv.p = scale;</span>
<span class="p_del">-	kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_del">-	kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50) {</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk (0-50 variant)\n&quot;);</span>
<span class="p_add">+		kctl-&gt;tlv.p = scale;</span>
<span class="p_add">+		kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max &lt;= 1000) {</span>
<span class="p_add">+		/* Some other clearly broken DragonFly variant.</span>
<span class="p_add">+		 * At least a 0..53 variant (hw v1.0) exists.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;ignoring too narrow dB range on a DragonFly device&quot;);</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	}</span>
 }
 
 void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,
<span class="p_chunk">@@ -1860,8 +1870,8 @@</span> <span class="p_context"> void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
 {
 	switch (mixer-&gt;chip-&gt;usb_id) {
 	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */
<span class="p_del">-		if (unitid == 7 &amp;&amp; cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50)</span>
<span class="p_del">-			snd_dragonfly_quirk_db_scale(mixer, kctl);</span>
<span class="p_add">+		if (unitid == 7 &amp;&amp; cval-&gt;control == UAC_FU_VOLUME)</span>
<span class="p_add">+			snd_dragonfly_quirk_db_scale(mixer, cval, kctl);</span>
 		break;
 	}
 }
<span class="p_header">diff --git a/virt/kvm/arm/pmu.c b/virt/kvm/arm/pmu.c</span>
<span class="p_header">index a027569facfa..6e9c40eea208 100644</span>
<span class="p_header">--- a/virt/kvm/arm/pmu.c</span>
<span class="p_header">+++ b/virt/kvm/arm/pmu.c</span>
<span class="p_chunk">@@ -423,6 +423,14 @@</span> <span class="p_context"> static int kvm_arm_pmu_v3_init(struct kvm_vcpu *vcpu)</span>
 	if (!kvm_arm_support_pmu_v3())
 		return -ENODEV;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We currently require an in-kernel VGIC to use the PMU emulation,</span>
<span class="p_add">+	 * because we do not support forwarding PMU overflow interrupts to</span>
<span class="p_add">+	 * userspace yet.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!irqchip_in_kernel(vcpu-&gt;kvm) || !vgic_initialized(vcpu-&gt;kvm))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	if (!test_bit(KVM_ARM_VCPU_PMU_V3, vcpu-&gt;arch.features) ||
 	    !kvm_arm_pmu_irq_initialized(vcpu))
 		return -ENXIO;
<span class="p_header">diff --git a/virt/kvm/arm/vgic/vgic.c b/virt/kvm/arm/vgic/vgic.c</span>
<span class="p_header">index 69b61abefa19..7ea791151006 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic/vgic.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic/vgic.c</span>
<span class="p_chunk">@@ -553,6 +553,9 @@</span> <span class="p_context"> next:</span>
 /* Sync back the hardware VGIC state into our emulation after a guest&#39;s run. */
 void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	if (unlikely(!vgic_initialized(vcpu-&gt;kvm)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	vgic_process_maintenance_interrupt(vcpu);
 	vgic_fold_lr_state(vcpu);
 	vgic_prune_ap_list(vcpu);
<span class="p_chunk">@@ -561,6 +564,9 @@</span> <span class="p_context"> void kvm_vgic_sync_hwstate(struct kvm_vcpu *vcpu)</span>
 /* Flush our emulation state into the GIC hardware before entering the guest. */
 void kvm_vgic_flush_hwstate(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	if (unlikely(!vgic_initialized(vcpu-&gt;kvm)))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;vcpu-&gt;arch.vgic_cpu.ap_list_lock);
 	vgic_flush_lr_state(vcpu);
 	spin_unlock(&amp;vcpu-&gt;arch.vgic_cpu.ap_list_lock);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



