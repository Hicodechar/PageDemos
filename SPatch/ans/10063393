
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,15/16] iommu: introduce page response function - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,15/16] iommu: introduce page response function</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 17, 2017, 6:55 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1510944914-54430-16-git-send-email-jacob.jun.pan@linux.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10063393/mbox/"
   >mbox</a>
|
   <a href="/patch/10063393/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10063393/">/patch/10063393/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9C35B601D3 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Nov 2017 18:57:07 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9350420408
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Nov 2017 18:57:07 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 860912A45B; Fri, 17 Nov 2017 18:57:07 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 172B020408
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 17 Nov 2017 18:57:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1161604AbdKQS5F (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 17 Nov 2017 13:57:05 -0500
Received: from mga03.intel.com ([134.134.136.65]:54137 &quot;EHLO mga03.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S965873AbdKQSyi (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 17 Nov 2017 13:54:38 -0500
Received: from orsmga003.jf.intel.com ([10.7.209.27])
	by orsmga103.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384;
	17 Nov 2017 10:54:15 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.44,410,1505804400&quot;; d=&quot;scan&#39;208&quot;;a=&quot;3461209&quot;
Received: from jacob-builder.jf.intel.com ([10.7.199.155])
	by orsmga003.jf.intel.com with ESMTP; 17 Nov 2017 10:54:15 -0800
From: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
To: iommu@lists.linux-foundation.org, LKML &lt;linux-kernel@vger.kernel.org&gt;,
	Joerg Roedel &lt;joro@8bytes.org&gt;, David Woodhouse &lt;dwmw2@infradead.org&gt;,
	Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;,
	Rafael Wysocki &lt;rafael.j.wysocki@intel.com&gt;,
	Alex Williamson &lt;alex.williamson@redhat.com&gt;
Cc: &quot;Liu, Yi L&quot; &lt;yi.l.liu@intel.com&gt;, Lan Tianyu &lt;tianyu.lan@intel.com&gt;,
	&quot;Tian, Kevin&quot; &lt;kevin.tian@intel.com&gt;, Raj Ashok &lt;ashok.raj@intel.com&gt;,
	Jean Delvare &lt;khali@linux-fr.org&gt;,
	&quot;Christoph Hellwig&quot; &lt;hch@infradead.org&gt;,
	Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;
Subject: [PATCH v3 15/16] iommu: introduce page response function
Date: Fri, 17 Nov 2017 10:55:13 -0800
Message-Id: &lt;1510944914-54430-16-git-send-email-jacob.jun.pan@linux.intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1510944914-54430-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
References: &lt;1510944914-54430-1-git-send-email-jacob.jun.pan@linux.intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Nov. 17, 2017, 6:55 p.m.</div>
<pre class="content">
When nested translation is turned on and guest owns the
first level page tables, device page request can be forwared
to the guest for handling faults. As the page response returns
by the guest, IOMMU driver on the host need to process the
response which informs the device and completes the page request
transaction.

This patch introduces generic API function for page response
passing from the guest or other in-kernel users. The definitions of
the generic data is based on PCI ATS specification not limited to
any vendor.
<span class="signed-off-by">
Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
---
 drivers/iommu/iommu.c | 14 ++++++++++++++
 include/linux/iommu.h | 42 ++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 56 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Nov. 24, 2017, 12:03 p.m.</div>
<pre class="content">
On 17/11/17 18:55, Jacob Pan wrote:
<span class="quote">&gt; When nested translation is turned on and guest owns the</span>
<span class="quote">&gt; first level page tables, device page request can be forwared</span>
<span class="quote">&gt; to the guest for handling faults. As the page response returns</span>
<span class="quote">&gt; by the guest, IOMMU driver on the host need to process the</span>
<span class="quote">&gt; response which informs the device and completes the page request</span>
<span class="quote">&gt; transaction.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This patch introduces generic API function for page response</span>
<span class="quote">&gt; passing from the guest or other in-kernel users. The definitions of</span>
<span class="quote">&gt; the generic data is based on PCI ATS specification not limited to</span>
<span class="quote">&gt; any vendor.&gt;</span>
<span class="quote">&gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/iommu/iommu.c | 14 ++++++++++++++</span>
<span class="quote">&gt;  include/linux/iommu.h | 42 ++++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  2 files changed, 56 insertions(+)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; index 97b7990..7aefb40 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; @@ -1416,6 +1416,20 @@ int iommu_sva_invalidate(struct iommu_domain *domain,</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  EXPORT_SYMBOL_GPL(iommu_sva_invalidate);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +int iommu_page_response(struct iommu_domain *domain, struct device *dev,</span>
<span class="quote">&gt; +			struct page_response_msg *msg)</span>

I think it&#39;s simpler, both for IOMMU and device drivers, to pass the exact
structure received in the fault handler back to the IOMMU driver, along
with a separate response status. So maybe

int iommu_page_response(struct iommu_domain *domain, struct device *dev,
			struct iommu_fault_event *event, u32 response)

And then you&#39;d just need to define the IOMMU_PAGE_RESPONSE_* values.

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Dec. 4, 2017, 9:37 p.m.</div>
<pre class="content">
On Fri, 24 Nov 2017 12:03:50 +0000
Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:
<span class="quote">
&gt; On 17/11/17 18:55, Jacob Pan wrote:</span>
<span class="quote">&gt; &gt; When nested translation is turned on and guest owns the</span>
<span class="quote">&gt; &gt; first level page tables, device page request can be forwared</span>
<span class="quote">&gt; &gt; to the guest for handling faults. As the page response returns</span>
<span class="quote">&gt; &gt; by the guest, IOMMU driver on the host need to process the</span>
<span class="quote">&gt; &gt; response which informs the device and completes the page request</span>
<span class="quote">&gt; &gt; transaction.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This patch introduces generic API function for page response</span>
<span class="quote">&gt; &gt; passing from the guest or other in-kernel users. The definitions of</span>
<span class="quote">&gt; &gt; the generic data is based on PCI ATS specification not limited to</span>
<span class="quote">&gt; &gt; any vendor.&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  drivers/iommu/iommu.c | 14 ++++++++++++++</span>
<span class="quote">&gt; &gt;  include/linux/iommu.h | 42</span>
<span class="quote">&gt; &gt; ++++++++++++++++++++++++++++++++++++++++++ 2 files changed, 56</span>
<span class="quote">&gt; &gt; insertions(+)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; index 97b7990..7aefb40 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/iommu.c</span>
<span class="quote">&gt; &gt; @@ -1416,6 +1416,20 @@ int iommu_sva_invalidate(struct iommu_domain</span>
<span class="quote">&gt; &gt; *domain, }</span>
<span class="quote">&gt; &gt;  EXPORT_SYMBOL_GPL(iommu_sva_invalidate);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +int iommu_page_response(struct iommu_domain *domain, struct device</span>
<span class="quote">&gt; &gt; *dev,</span>
<span class="quote">&gt; &gt; +			struct page_response_msg *msg)  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think it&#39;s simpler, both for IOMMU and device drivers, to pass the</span>
<span class="quote">&gt; exact structure received in the fault handler back to the IOMMU</span>
<span class="quote">&gt; driver, along with a separate response status. So maybe</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; int iommu_page_response(struct iommu_domain *domain, struct device</span>
<span class="quote">&gt; *dev, struct iommu_fault_event *event, u32 response)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And then you&#39;d just need to define the IOMMU_PAGE_RESPONSE_* values.</span>
<span class="quote">&gt; </span>
Apologize for the late response,

I think the simpler interface works for in-kernel driver use case very
well. But in case of VFIO, the callback function does not turn around
send back page response. The page response comes from guest and qemu,
where they don;t keep track of the the prq event data.
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Jean</span>

[Jacob Pan]
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Dec. 5, 2017, 5:21 p.m.</div>
<pre class="content">
Hi Jacob,

On 04/12/17 21:37, Jacob Pan wrote:
<span class="quote">&gt; On Fri, 24 Nov 2017 12:03:50 +0000</span>
<span class="quote">&gt; Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; On 17/11/17 18:55, Jacob Pan wrote:</span>
<span class="quote">&gt;&gt;&gt; When nested translation is turned on and guest owns the</span>
<span class="quote">&gt;&gt;&gt; first level page tables, device page request can be forwared</span>
<span class="quote">&gt;&gt;&gt; to the guest for handling faults. As the page response returns</span>
<span class="quote">&gt;&gt;&gt; by the guest, IOMMU driver on the host need to process the</span>
<span class="quote">&gt;&gt;&gt; response which informs the device and completes the page request</span>
<span class="quote">&gt;&gt;&gt; transaction.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This patch introduces generic API function for page response</span>
<span class="quote">&gt;&gt;&gt; passing from the guest or other in-kernel users. The definitions of</span>
<span class="quote">&gt;&gt;&gt; the generic data is based on PCI ATS specification not limited to</span>
<span class="quote">&gt;&gt;&gt; any vendor.&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;</span>
[...]
<span class="quote">&gt; I think the simpler interface works for in-kernel driver use case very</span>
<span class="quote">&gt; well. But in case of VFIO, the callback function does not turn around</span>
<span class="quote">&gt; send back page response. The page response comes from guest and qemu,</span>
<span class="quote">&gt; where they don;t keep track of the the prq event data.</span>

Is it safe to trust whatever response the guest or userspace gives us? The
answer seems fairly vendor- and device-specific so I wonder if VFIO or
IOMMU shouldn&#39;t do a bit of sanity checking somewhere, and keep track of
all injected page requests.

From SMMUv3 POV, it seems safe (haven&#39;t looked at SMMUv2 but I&#39;m not so
confident).

* The guest can only send page responses to devices assigned to it, that&#39;s
  a given.

* If, after we injected a page request, the guest doesn&#39;t reply at all,
  then the device leaks page request credits and at some point it will
  stop sending requests.
  -&gt; So the PRI capability needs to be reset whenever we change the
     device&#39;s domain, to clear the credit counter and pending states.

  For SMMUv3, the stall buffer may be shared between devices on some
  implementations, in which case the guest could prevent other devices to
  stall by letting the buffer fill up.
  -&gt; We might have to keep track of stalls in the host driver and set a
     credit or timeout to each stall, if it comes to that.
  -&gt; In addition, send a terminate-all-stalls command when changing the
     device&#39;s domain.

* If the guest sends spurious or duplicate page responses (where the PRGI
  or PASID doesn&#39;t exist in any outstanding page request of the device)

  For PRI if we send an invalid PRG Response, the endpoint sets UPRGI in
  the PRI cap, and issues an Unexpected Completion. Then I suppose the
  worst that happens is we get an AER report that we can&#39;t handle? I&#39;m not
  too familiar with that part of PCIe.

  Stall is designed to tolerate this and will just ignore the response.

* If PRI/stall isn&#39;t even enabled, the IOMMU driver can check that in the
  device configuration and not send the reply.




Regardless, I have a few comments on the page_response_msg:
<span class="quote">
&gt; +/**</span>
<span class="quote">&gt; + * Generic page response information based on PCI ATS and PASID spec.</span>
<span class="quote">&gt; + * @paddr: servicing page address</span>

Maybe call it @addr, so we don&#39;t read this field as &quot;phys addr&quot;
<span class="quote">
&gt; + * @pasid: contains process address space ID, used in shared virtual memory(SVM)</span>

The &quot;used in shared virtual memory(SVM)&quot; part isn&#39;t necessary and we&#39;re
changing the API name.
<span class="quote">
&gt; + * @rid: requestor ID</span>
<span class="quote">&gt; + * @did: destination device ID</span>

I guess you can remove @rid and @did
<span class="quote">
&gt; + * @last_req: last request in a page request group</span>

Is @last_req needed at all, since only the last request requires a response?
<span class="quote">
&gt; + * @resp_code: response code</span>

The comment is missing a description for @pasid_present here
<span class="quote">
&gt; + * @page_req_group_id: page request group index</span>
<span class="quote">&gt; + * @prot: page access protection flag, e.g. IOMMU_FAULT_READ, IOMMU_FAULT_WRITE</span>

Is @prot really needed in the response?
<span class="quote">
&gt; + * @type: group or stream response</span>

The page request doesn&#39;t provide this information
<span class="quote">
&gt; + * @private_data: uniquely identify device-specific private data for an</span>
<span class="quote">&gt; + *                individual page response</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +struct page_response_msg {</span>
<span class="quote">&gt; +	u64 paddr;</span>
<span class="quote">&gt; +	u32 pasid;</span>
<span class="quote">&gt; +	u32 rid:16;</span>
<span class="quote">&gt; +	u32 did:16;</span>
<span class="quote">&gt; +	u32 resp_code:4;</span>
<span class="quote">&gt; +	u32 last_req:1;</span>
<span class="quote">&gt; +	u32 pasid_present:1;</span>
<span class="quote">&gt; +#define IOMMU_PAGE_RESP_SUCCESS	0</span>
<span class="quote">&gt; +#define IOMMU_PAGE_RESP_INVALID	1</span>
<span class="quote">&gt; +#define IOMMU_PAGE_RESP_FAILURE	0xF</span>

Maybe move these defines closer to resp_code.
For someone not familiar with PRI, we should add some comments about those
values:

* SUCCESS: the request was paged-in successfully
* INVALID: could not page-in one or more pages in the group
* FAILURE: permanent PRI error, may disable faults in the device
<span class="quote">
&gt; +	u32 page_req_group_id : 9;</span>
<span class="quote">&gt; +	u32 prot;</span>
<span class="quote">&gt; +	enum page_response_type type;</span>
<span class="quote">&gt; +	u32 private_data;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Dec. 6, 2017, 7:25 p.m.</div>
<pre class="content">
On Tue, 5 Dec 2017 17:21:15 +0000
Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:
<span class="quote">
&gt; Hi Jacob,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 04/12/17 21:37, Jacob Pan wrote:</span>
<span class="quote">&gt; &gt; On Fri, 24 Nov 2017 12:03:50 +0000</span>
<span class="quote">&gt; &gt; Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; &gt;&gt; On 17/11/17 18:55, Jacob Pan wrote:  </span>
<span class="quote">&gt; &gt;&gt;&gt; When nested translation is turned on and guest owns the</span>
<span class="quote">&gt; &gt;&gt;&gt; first level page tables, device page request can be forwared</span>
<span class="quote">&gt; &gt;&gt;&gt; to the guest for handling faults. As the page response returns</span>
<span class="quote">&gt; &gt;&gt;&gt; by the guest, IOMMU driver on the host need to process the</span>
<span class="quote">&gt; &gt;&gt;&gt; response which informs the device and completes the page request</span>
<span class="quote">&gt; &gt;&gt;&gt; transaction.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; This patch introduces generic API function for page response</span>
<span class="quote">&gt; &gt;&gt;&gt; passing from the guest or other in-kernel users. The definitions</span>
<span class="quote">&gt; &gt;&gt;&gt; of the generic data is based on PCI ATS specification not limited</span>
<span class="quote">&gt; &gt;&gt;&gt; to any vendor.&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;  </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; I think the simpler interface works for in-kernel driver use case</span>
<span class="quote">&gt; &gt; very well. But in case of VFIO, the callback function does not turn</span>
<span class="quote">&gt; &gt; around send back page response. The page response comes from guest</span>
<span class="quote">&gt; &gt; and qemu, where they don;t keep track of the the prq event data.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is it safe to trust whatever response the guest or userspace gives</span>
<span class="quote">&gt; us? The answer seems fairly vendor- and device-specific so I wonder</span>
<span class="quote">&gt; if VFIO or IOMMU shouldn&#39;t do a bit of sanity checking somewhere, and</span>
<span class="quote">&gt; keep track of all injected page requests.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; From SMMUv3 POV, it seems safe (haven&#39;t looked at SMMUv2 but I&#39;m not</span>
<span class="quote">&gt; so confident).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; * The guest can only send page responses to devices assigned to it,</span>
<span class="quote">&gt; that&#39;s a given.</span>
<span class="quote">&gt; </span>
Agree, IOMMU driver cannot enforce it. I think VFIO layer can make sure
page response come from the assigned device and its guest/container.
<span class="quote">&gt; * If, after we injected a page request, the guest doesn&#39;t reply at</span>
<span class="quote">&gt; all, then the device leaks page request credits and at some point it</span>
<span class="quote">&gt; will stop sending requests.</span>
<span class="quote">&gt;   -&gt; So the PRI capability needs to be reset whenever we change the  </span>
<span class="quote">&gt;      device&#39;s domain, to clear the credit counter and pending states.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   For SMMUv3, the stall buffer may be shared between devices on some</span>
<span class="quote">&gt;   implementations, in which case the guest could prevent other</span>
<span class="quote">&gt; devices to stall by letting the buffer fill up.</span>
<span class="quote">&gt;   -&gt; We might have to keep track of stalls in the host driver and set</span>
<span class="quote">&gt; a credit or timeout to each stall, if it comes to that.</span>
<span class="quote">&gt;   -&gt; In addition, send a terminate-all-stalls command when changing</span>
<span class="quote">&gt; the device&#39;s domain.</span>
<span class="quote">&gt; </span>
We have the same situation in VT-d with shared queue which in turn may
affect other guests. Letting host driver maintain record of pending page
request seems the best way to go. VT-d has a way to drain PRQ per PASID
and RID combination. I guess this is the same as your
&quot;terminate-all-stalls&quot; but with finer control? Or
&quot;terminate-all-stalls&quot; only applies to a given device.
Seems we can implement a generic timeout/credit mechanism in IOMMU
driver with model specific action to drain/terminate. The timeout value
can also be model specific.
<span class="quote">
&gt; * If the guest sends spurious or duplicate page responses (where the</span>
<span class="quote">&gt; PRGI or PASID doesn&#39;t exist in any outstanding page request of the</span>
<span class="quote">&gt; device)</span>
<span class="quote">&gt; </span>
If we keep track of pending PRQ in host IOMMU driver, then it can
detect duplicated case.
<span class="quote">&gt;   For PRI if we send an invalid PRG Response, the endpoint sets UPRGI</span>
<span class="quote">&gt; in the PRI cap, and issues an Unexpected Completion. Then I suppose</span>
<span class="quote">&gt; the worst that happens is we get an AER report that we can&#39;t handle?</span>
<span class="quote">&gt; I&#39;m not too familiar with that part of PCIe.</span>
<span class="quote">&gt; </span>
I don;t see this mentioned in the PCI ATS spec., but in general this
sounds like a case HW has to handle, perhaps ignoring them is
reasonable as you said below.
<span class="quote">&gt;   Stall is designed to tolerate this and will just ignore the</span>
<span class="quote">&gt; response.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; * If PRI/stall isn&#39;t even enabled, the IOMMU driver can check that in</span>
<span class="quote">&gt; the device configuration and not send the reply.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Regardless, I have a few comments on the page_response_msg:</span>
<span class="quote">&gt; </span>
Thanks, all points are taken unless commented.
<span class="quote">&gt; &gt; +/**</span>
<span class="quote">&gt; &gt; + * Generic page response information based on PCI ATS and PASID</span>
<span class="quote">&gt; &gt; spec.</span>
<span class="quote">&gt; &gt; + * @paddr: servicing page address  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Maybe call it @addr, so we don&#39;t read this field as &quot;phys addr&quot;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; + * @pasid: contains process address space ID, used in shared</span>
<span class="quote">&gt; &gt; virtual memory(SVM)  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The &quot;used in shared virtual memory(SVM)&quot; part isn&#39;t necessary and</span>
<span class="quote">&gt; we&#39;re changing the API name.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; + * @rid: requestor ID</span>
<span class="quote">&gt; &gt; + * @did: destination device ID  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I guess you can remove @rid and @did</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; + * @last_req: last request in a page request group  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is @last_req needed at all, since only the last request requires a</span>
<span class="quote">&gt; response?</span>
<span class="quote">&gt; </span>
right, i was thinking we had single page response in vt-d, but there is
not need either.
<span class="quote">&gt; &gt; + * @resp_code: response code  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The comment is missing a description for @pasid_present here</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; + * @page_req_group_id: page request group index</span>
<span class="quote">&gt; &gt; + * @prot: page access protection flag, e.g. IOMMU_FAULT_READ,</span>
<span class="quote">&gt; &gt; IOMMU_FAULT_WRITE  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is @prot really needed in the response?</span>
<span class="quote">&gt; </span>
no, you are right.
<span class="quote">&gt; &gt; + * @type: group or stream response  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The page request doesn&#39;t provide this information</span>
<span class="quote">&gt; </span>
this is vt-d specific. it is in the vt-d page request descriptor and
response descriptors are different depending on the type.
Since we intend the generic data to be super set of models, I add this
field.
<span class="quote">&gt; &gt; + * @private_data: uniquely identify device-specific private data</span>
<span class="quote">&gt; &gt; for an</span>
<span class="quote">&gt; &gt; + *                individual page response</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +struct page_response_msg {</span>
<span class="quote">&gt; &gt; +	u64 paddr;</span>
<span class="quote">&gt; &gt; +	u32 pasid;</span>
<span class="quote">&gt; &gt; +	u32 rid:16;</span>
<span class="quote">&gt; &gt; +	u32 did:16;</span>
<span class="quote">&gt; &gt; +	u32 resp_code:4;</span>
<span class="quote">&gt; &gt; +	u32 last_req:1;</span>
<span class="quote">&gt; &gt; +	u32 pasid_present:1;</span>
<span class="quote">&gt; &gt; +#define IOMMU_PAGE_RESP_SUCCESS	0</span>
<span class="quote">&gt; &gt; +#define IOMMU_PAGE_RESP_INVALID	1</span>
<span class="quote">&gt; &gt; +#define IOMMU_PAGE_RESP_FAILURE	0xF  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Maybe move these defines closer to resp_code.</span>
<span class="quote">&gt; For someone not familiar with PRI, we should add some comments about</span>
<span class="quote">&gt; those values:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; * SUCCESS: the request was paged-in successfully</span>
<span class="quote">&gt; * INVALID: could not page-in one or more pages in the group</span>
<span class="quote">&gt; * FAILURE: permanent PRI error, may disable faults in the device</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	u32 page_req_group_id : 9;</span>
<span class="quote">&gt; &gt; +	u32 prot;</span>
<span class="quote">&gt; &gt; +	enum page_response_type type;</span>
<span class="quote">&gt; &gt; +	u32 private_data;</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Jean</span>

[Jacob Pan]
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Dec. 7, 2017, 12:56 p.m.</div>
<pre class="content">
On 06/12/17 19:25, Jacob Pan wrote:
[...]
<span class="quote">&gt;&gt;   For SMMUv3, the stall buffer may be shared between devices on some</span>
<span class="quote">&gt;&gt;   implementations, in which case the guest could prevent other</span>
<span class="quote">&gt;&gt; devices to stall by letting the buffer fill up.</span>
<span class="quote">&gt;&gt;   -&gt; We might have to keep track of stalls in the host driver and set</span>
<span class="quote">&gt;&gt; a credit or timeout to each stall, if it comes to that.</span>
<span class="quote">&gt;&gt;   -&gt; In addition, send a terminate-all-stalls command when changing</span>
<span class="quote">&gt;&gt; the device&#39;s domain.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; We have the same situation in VT-d with shared queue which in turn may</span>
<span class="quote">&gt; affect other guests. Letting host driver maintain record of pending page</span>
<span class="quote">&gt; request seems the best way to go. VT-d has a way to drain PRQ per PASID</span>
<span class="quote">&gt; and RID combination. I guess this is the same as your</span>
<span class="quote">&gt; &quot;terminate-all-stalls&quot; but with finer control? Or</span>
<span class="quote">&gt; &quot;terminate-all-stalls&quot; only applies to a given device.</span>

That command terminates all stalls for a given device (for all PASIDs).
It&#39;s a bit awkward to implement but should be enough to ensure that we
don&#39;t leak any outstanding faults to the next VM.
<span class="quote">
&gt; Seems we can implement a generic timeout/credit mechanism in IOMMU</span>
<span class="quote">&gt; driver with model specific action to drain/terminate. The timeout value</span>
<span class="quote">&gt; can also be model specific.</span>

Sounds good. Timeout seems a bit complicated to implement (and how do we
guess what timeout would work?), so maybe it&#39;s simpler to enforce a quota
of outstanding faults per VM, for example half of the shared queue size
(the number can be chosen by the IOMMU driver). If a VM has that many
outstanding faults, then any new fault is immediately terminated by the
host. A bit rough but it might be enough to mitigate the problem
initially, and we can always tweak it later (for instance disable faulting
if a guest doesn&#39;t ever reply).

Seems like VFIO should enforce this quota, since the IOMMU layer doesn&#39;t
know which device is assigned to which VM. If it&#39;s the IOMMU that enforces
quotas per device and a VM has 15 devices assigned, then the guest can
still DoS the IOMMU.

[...]
<span class="quote">&gt;&gt;&gt; + * @type: group or stream response  </span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The page request doesn&#39;t provide this information</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; this is vt-d specific. it is in the vt-d page request descriptor and</span>
<span class="quote">&gt; response descriptors are different depending on the type.</span>
<span class="quote">&gt; Since we intend the generic data to be super set of models, I add this</span>
<span class="quote">&gt; field.</span>

But don&#39;t you need to add the stream type to enum iommu_fault_type, in
patch 8? Otherwise the guest can&#39;t know what type to set in the response.

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - Dec. 7, 2017, 9:51 p.m.</div>
<pre class="content">
On Wed, 6 Dec 2017 11:25:21 -0800
Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt; wrote:
<span class="quote">
&gt; On Tue, 5 Dec 2017 17:21:15 +0000</span>
<span class="quote">&gt; Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Hi Jacob,</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; On 04/12/17 21:37, Jacob Pan wrote:  </span>
<span class="quote">&gt; &gt; &gt; On Fri, 24 Nov 2017 12:03:50 +0000</span>
<span class="quote">&gt; &gt; &gt; Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:</span>
<span class="quote">&gt; &gt; &gt;     </span>
<span class="quote">&gt; &gt; &gt;&gt; On 17/11/17 18:55, Jacob Pan wrote:    </span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; When nested translation is turned on and guest owns the</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; first level page tables, device page request can be forwared</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; to the guest for handling faults. As the page response returns</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; by the guest, IOMMU driver on the host need to process the</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; response which informs the device and completes the page request</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; transaction.</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; This patch introduces generic API function for page response</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; passing from the guest or other in-kernel users. The definitions</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; of the generic data is based on PCI ATS specification not limited</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; to any vendor.&gt;</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; Signed-off-by: Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt;    </span>
<span class="quote">&gt; &gt; [...]  </span>
<span class="quote">&gt; &gt; &gt; I think the simpler interface works for in-kernel driver use case</span>
<span class="quote">&gt; &gt; &gt; very well. But in case of VFIO, the callback function does not turn</span>
<span class="quote">&gt; &gt; &gt; around send back page response. The page response comes from guest</span>
<span class="quote">&gt; &gt; &gt; and qemu, where they don;t keep track of the the prq event data.    </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Is it safe to trust whatever response the guest or userspace gives</span>
<span class="quote">&gt; &gt; us? The answer seems fairly vendor- and device-specific so I wonder</span>
<span class="quote">&gt; &gt; if VFIO or IOMMU shouldn&#39;t do a bit of sanity checking somewhere, and</span>
<span class="quote">&gt; &gt; keep track of all injected page requests.</span>

This is always my question when we start embedding IDs in structures.
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; From SMMUv3 POV, it seems safe (haven&#39;t looked at SMMUv2 but I&#39;m not</span>
<span class="quote">&gt; &gt; so confident).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; * The guest can only send page responses to devices assigned to it,</span>
<span class="quote">&gt; &gt; that&#39;s a given.</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; Agree, IOMMU driver cannot enforce it. I think VFIO layer can make sure</span>
<span class="quote">&gt; page response come from the assigned device and its guest/container.</span>

Can we enforce it via the IOMMU/VFIO interface?  If the response is for
a struct device, and not an rid/did embedded in a structure, then vfio
can pass it through w/o worrying about it, ie. response comes in via
ioctl with association to vfio device fd -&gt; struct vfio_device -&gt; struct
device, iommu driver fills in rid/did.  Thanks,

Alex
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - Dec. 7, 2017, 9:56 p.m.</div>
<pre class="content">
On Thu, 7 Dec 2017 12:56:55 +0000
Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:
<span class="quote">
&gt; On 06/12/17 19:25, Jacob Pan wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;   For SMMUv3, the stall buffer may be shared between devices on some</span>
<span class="quote">&gt; &gt;&gt;   implementations, in which case the guest could prevent other</span>
<span class="quote">&gt; &gt;&gt; devices to stall by letting the buffer fill up.  </span>
<span class="quote">&gt; &gt;&gt;   -&gt; We might have to keep track of stalls in the host driver and set  </span>
<span class="quote">&gt; &gt;&gt; a credit or timeout to each stall, if it comes to that.  </span>
<span class="quote">&gt; &gt;&gt;   -&gt; In addition, send a terminate-all-stalls command when changing  </span>
<span class="quote">&gt; &gt;&gt; the device&#39;s domain.</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt; We have the same situation in VT-d with shared queue which in turn may</span>
<span class="quote">&gt; &gt; affect other guests. Letting host driver maintain record of pending page</span>
<span class="quote">&gt; &gt; request seems the best way to go. VT-d has a way to drain PRQ per PASID</span>
<span class="quote">&gt; &gt; and RID combination. I guess this is the same as your</span>
<span class="quote">&gt; &gt; &quot;terminate-all-stalls&quot; but with finer control? Or</span>
<span class="quote">&gt; &gt; &quot;terminate-all-stalls&quot; only applies to a given device.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That command terminates all stalls for a given device (for all PASIDs).</span>
<span class="quote">&gt; It&#39;s a bit awkward to implement but should be enough to ensure that we</span>
<span class="quote">&gt; don&#39;t leak any outstanding faults to the next VM.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Seems we can implement a generic timeout/credit mechanism in IOMMU</span>
<span class="quote">&gt; &gt; driver with model specific action to drain/terminate. The timeout value</span>
<span class="quote">&gt; &gt; can also be model specific.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Sounds good. Timeout seems a bit complicated to implement (and how do we</span>
<span class="quote">&gt; guess what timeout would work?), so maybe it&#39;s simpler to enforce a quota</span>
<span class="quote">&gt; of outstanding faults per VM, for example half of the shared queue size</span>
<span class="quote">&gt; (the number can be chosen by the IOMMU driver). If a VM has that many</span>
<span class="quote">&gt; outstanding faults, then any new fault is immediately terminated by the</span>
<span class="quote">&gt; host. A bit rough but it might be enough to mitigate the problem</span>
<span class="quote">&gt; initially, and we can always tweak it later (for instance disable faulting</span>
<span class="quote">&gt; if a guest doesn&#39;t ever reply).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Seems like VFIO should enforce this quota, since the IOMMU layer doesn&#39;t</span>
<span class="quote">&gt; know which device is assigned to which VM. If it&#39;s the IOMMU that enforces</span>
<span class="quote">&gt; quotas per device and a VM has 15 devices assigned, then the guest can</span>
<span class="quote">&gt; still DoS the IOMMU.</span>

VFIO also doesn&#39;t know about VMs.  We know that devices attached to the
same container are probably used by the same user, but once we add
viommu, each device(group) uses its own container and we have no idea
they&#39;re associated.  So, no to VM based accounting, and it seems like
an IOMMU problem, X number of outstanding requests per device.  Thanks,

Alex
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Dec. 8, 2017, 1:17 a.m.</div>
<pre class="content">
On Thu, 7 Dec 2017 12:56:55 +0000
Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:
<span class="quote">
&gt; On 06/12/17 19:25, Jacob Pan wrote:</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;   For SMMUv3, the stall buffer may be shared between devices on</span>
<span class="quote">&gt; &gt;&gt; some implementations, in which case the guest could prevent other</span>
<span class="quote">&gt; &gt;&gt; devices to stall by letting the buffer fill up.  </span>
<span class="quote">&gt; &gt;&gt;   -&gt; We might have to keep track of stalls in the host driver and</span>
<span class="quote">&gt; &gt;&gt; set a credit or timeout to each stall, if it comes to that.  </span>
<span class="quote">&gt; &gt;&gt;   -&gt; In addition, send a terminate-all-stalls command when</span>
<span class="quote">&gt; &gt;&gt; changing the device&#39;s domain.</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt; We have the same situation in VT-d with shared queue which in turn</span>
<span class="quote">&gt; &gt; may affect other guests. Letting host driver maintain record of</span>
<span class="quote">&gt; &gt; pending page request seems the best way to go. VT-d has a way to</span>
<span class="quote">&gt; &gt; drain PRQ per PASID and RID combination. I guess this is the same</span>
<span class="quote">&gt; &gt; as your &quot;terminate-all-stalls&quot; but with finer control? Or</span>
<span class="quote">&gt; &gt; &quot;terminate-all-stalls&quot; only applies to a given device.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That command terminates all stalls for a given device (for all</span>
<span class="quote">&gt; PASIDs). It&#39;s a bit awkward to implement but should be enough to</span>
<span class="quote">&gt; ensure that we don&#39;t leak any outstanding faults to the next VM.</span>
<span class="quote">&gt; </span>
OK, in any case, I think this terminate request should come from the
drivers or vfio not initiated by IOMMU.
<span class="quote">&gt; &gt; Seems we can implement a generic timeout/credit mechanism in IOMMU</span>
<span class="quote">&gt; &gt; driver with model specific action to drain/terminate. The timeout</span>
<span class="quote">&gt; &gt; value can also be model specific.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Sounds good. Timeout seems a bit complicated to implement (and how do</span>
<span class="quote">&gt; we guess what timeout would work?), so maybe it&#39;s simpler to enforce</span>
<span class="quote">&gt; a quota of outstanding faults per VM, for example half of the shared</span>
<span class="quote">&gt; queue size (the number can be chosen by the IOMMU driver). If a VM</span>
<span class="quote">&gt; has that many outstanding faults, then any new fault is immediately</span>
<span class="quote">&gt; terminated by the host. A bit rough but it might be enough to</span>
<span class="quote">&gt; mitigate the problem initially, and we can always tweak it later (for</span>
<span class="quote">&gt; instance disable faulting if a guest doesn&#39;t ever reply).</span>
<span class="quote">&gt; </span>
I have to make a correction/clarification, even though vt-d has a per
iommu shared queue for prq but we do not stall. Ashok reminded me that.
So there is no constraint on IOMMU if one of the guests does not
respond. All the pressure is on the device which may have limited # of
pending PR.
<span class="quote">
&gt; Seems like VFIO should enforce this quota, since the IOMMU layer</span>
<span class="quote">&gt; doesn&#39;t know which device is assigned to which VM. If it&#39;s the IOMMU</span>
<span class="quote">&gt; that enforces quotas per device and a VM has 15 devices assigned,</span>
<span class="quote">&gt; then the guest can still DoS the IOMMU.</span>
<span class="quote">&gt; </span>
I still think timeout makes more sense than quota in that a VM could
be under quota but failed to respond to one of the devices forever.
I agree it is hard to devise a good timeout limit but since this is to
prevent rare faults, we could pick a relatively large timeout. And we
only tracks the longest pending timeout per device. The error condition
we try to prevent is not necessarily only stall buffer overflow but
timeout also, right?
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt; + * @type: group or stream response    </span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; The page request doesn&#39;t provide this information</span>
<span class="quote">&gt; &gt;&gt;  </span>
<span class="quote">&gt; &gt; this is vt-d specific. it is in the vt-d page request descriptor and</span>
<span class="quote">&gt; &gt; response descriptors are different depending on the type.</span>
<span class="quote">&gt; &gt; Since we intend the generic data to be super set of models, I add</span>
<span class="quote">&gt; &gt; this field.  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But don&#39;t you need to add the stream type to enum iommu_fault_type, in</span>
<span class="quote">&gt; patch 8? Otherwise the guest can&#39;t know what type to set in the</span>
<span class="quote">&gt; response.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Jean</span>
<span class="quote">&gt; </span>

[Jacob Pan]
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Dec. 8, 2017, 1:51 p.m.</div>
<pre class="content">
On 07/12/17 21:56, Alex Williamson wrote:
[...]
<span class="quote">&gt;&gt; Seems like VFIO should enforce this quota, since the IOMMU layer doesn&#39;t</span>
<span class="quote">&gt;&gt; know which device is assigned to which VM. If it&#39;s the IOMMU that enforces</span>
<span class="quote">&gt;&gt; quotas per device and a VM has 15 devices assigned, then the guest can</span>
<span class="quote">&gt;&gt; still DoS the IOMMU.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; VFIO also doesn&#39;t know about VMs.  We know that devices attached to the</span>
<span class="quote">&gt; same container are probably used by the same user, but once we add</span>
<span class="quote">&gt; viommu, each device(group) uses its own container and we have no idea</span>
<span class="quote">&gt; they&#39;re associated.  So, no to VM based accounting, and it seems like</span>
<span class="quote">&gt; an IOMMU problem, X number of outstanding requests per device.  Thanks,</span>

Ok. It&#39;s not clear anyway how the architecture and implementations expect
us to virtualize stall, I&#39;ll try to clarify it.

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Dec. 8, 2017, 1:51 p.m.</div>
<pre class="content">
On 08/12/17 01:17, Jacob Pan wrote:
[...]
<span class="quote">&gt;&gt; Sounds good. Timeout seems a bit complicated to implement (and how do</span>
<span class="quote">&gt;&gt; we guess what timeout would work?), so maybe it&#39;s simpler to enforce</span>
<span class="quote">&gt;&gt; a quota of outstanding faults per VM, for example half of the shared</span>
<span class="quote">&gt;&gt; queue size (the number can be chosen by the IOMMU driver). If a VM</span>
<span class="quote">&gt;&gt; has that many outstanding faults, then any new fault is immediately</span>
<span class="quote">&gt;&gt; terminated by the host. A bit rough but it might be enough to</span>
<span class="quote">&gt;&gt; mitigate the problem initially, and we can always tweak it later (for</span>
<span class="quote">&gt;&gt; instance disable faulting if a guest doesn&#39;t ever reply).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; I have to make a correction/clarification, even though vt-d has a per</span>
<span class="quote">&gt; iommu shared queue for prq but we do not stall. Ashok reminded me that.</span>
<span class="quote">&gt; So there is no constraint on IOMMU if one of the guests does not</span>
<span class="quote">&gt; respond. All the pressure is on the device which may have limited # of</span>
<span class="quote">&gt; pending PR.</span>

Right that makes more sense, for PRI the IOMMU doesn&#39;t need to keep page
request state internally. Then it seems the problem only exists for Stall
and someone&#39;s going to have a fun time working around it in the SMMU driver :(
<span class="quote">
&gt;&gt; Seems like VFIO should enforce this quota, since the IOMMU layer</span>
<span class="quote">&gt;&gt; doesn&#39;t know which device is assigned to which VM. If it&#39;s the IOMMU</span>
<span class="quote">&gt;&gt; that enforces quotas per device and a VM has 15 devices assigned,</span>
<span class="quote">&gt;&gt; then the guest can still DoS the IOMMU.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt; I still think timeout makes more sense than quota in that a VM could</span>
<span class="quote">&gt; be under quota but failed to respond to one of the devices forever.</span>
<span class="quote">&gt; I agree it is hard to devise a good timeout limit but since this is to</span>
<span class="quote">&gt; prevent rare faults, we could pick a relatively large timeout. And we</span>
<span class="quote">&gt; only tracks the longest pending timeout per device. The error condition</span>
<span class="quote">&gt; we try to prevent is not necessarily only stall buffer overflow but</span>
<span class="quote">&gt; timeout also, right?</span>

Handling timeouts is less crucial than making sure a guest doesn&#39;t
monopolize all the shared resources, in my opinion. If a guest can&#39;t reply
to the injected faults, it&#39;s not really our problem as long as it doesn&#39;t
affect fault injection for other guests. We can reset the device and clean
pending faults when the guest terminates or resets the device.

I guess it&#39;s similar to IRQ injection, you don&#39;t care if the guest
acknowledges your interrupt or not as long as you make sure it is delivered.

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=97951">Jean-Philippe Brucker</a> - Dec. 8, 2017, 1:52 p.m.</div>
<pre class="content">
On 07/12/17 21:51, Alex Williamson wrote:
<span class="quote">&gt;&gt; Agree, IOMMU driver cannot enforce it. I think VFIO layer can make sure</span>
<span class="quote">&gt;&gt; page response come from the assigned device and its guest/container.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Can we enforce it via the IOMMU/VFIO interface?  If the response is for</span>
<span class="quote">&gt; a struct device, and not an rid/did embedded in a structure, then vfio</span>
<span class="quote">&gt; can pass it through w/o worrying about it, ie. response comes in via</span>
<span class="quote">&gt; ioctl with association to vfio device fd -&gt; struct vfio_device -&gt; struct</span>
<span class="quote">&gt; device, iommu driver fills in rid/did.  Thanks,</span>

Yes that&#39;s probably the best way, reporting faults and receiving responses
on the device fd.

Thanks,
Jean
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7040">Jacob Pan</a> - Dec. 8, 2017, 8:40 p.m.</div>
<pre class="content">
On Fri, 8 Dec 2017 13:52:00 +0000
Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:
<span class="quote">
&gt; On 07/12/17 21:51, Alex Williamson wrote:</span>
<span class="quote">&gt; &gt;&gt; Agree, IOMMU driver cannot enforce it. I think VFIO layer can make</span>
<span class="quote">&gt; &gt;&gt; sure page response come from the assigned device and its</span>
<span class="quote">&gt; &gt;&gt; guest/container.  </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Can we enforce it via the IOMMU/VFIO interface?  If the response is</span>
<span class="quote">&gt; &gt; for a struct device, and not an rid/did embedded in a structure,</span>
<span class="quote">&gt; &gt; then vfio can pass it through w/o worrying about it, ie. response</span>
<span class="quote">&gt; &gt; comes in via ioctl with association to vfio device fd -&gt; struct</span>
<span class="quote">&gt; &gt; vfio_device -&gt; struct device, iommu driver fills in rid/did.</span>
<span class="quote">&gt; &gt; Thanks,  </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yes that&#39;s probably the best way, reporting faults and receiving</span>
<span class="quote">&gt; responses on the device fd.</span>
<span class="quote">&gt; </span>
Just to put these ideas in to code. The IOMMU API used by VFIO has
struct device* (derived from fd), no did/rid (to be derived from
struct device by IOMMU driver.)

int intel_iommu_page_response(struct iommu_domain *domain, struct device *dev,
			struct page_response_msg *msg)

IOMMU driver can further sanitize by checking whether this is a pending
page request for the device, and refcount outstanding PRQs.

Does it sound right?

/**
 * Generic page response information based on PCI ATS and PASID spec.
 * @addr: servicing page address
 * @pasid: contains process address space ID, used in shared virtual
memory(SVM)
 * @resp_code: response code
 * @page_req_group_id: page request group index
 * @type: group or stream/single page response
 * @private_data: uniquely identify device-specific private data for an
 *                individual page response

 */
struct page_response_msg {
	u64 addr;
	u32 pasid;
	u32 resp_code:4;
#define IOMMU_PAGE_RESP_SUCCESS	0
#define IOMMU_PAGE_RESP_INVALID	1
#define IOMMU_PAGE_RESP_FAILURE	0xF

	u32 pasid_present:1;
	u32 page_req_group_id : 9;
	enum page_response_type type;
	u32 private_data;
};
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7781">Alex Williamson</a> - Dec. 8, 2017, 11:01 p.m.</div>
<pre class="content">
On Fri, 8 Dec 2017 12:40:17 -0800
Jacob Pan &lt;jacob.jun.pan@linux.intel.com&gt; wrote:
<span class="quote">
&gt; On Fri, 8 Dec 2017 13:52:00 +0000</span>
<span class="quote">&gt; Jean-Philippe Brucker &lt;jean-philippe.brucker@arm.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; On 07/12/17 21:51, Alex Williamson wrote:  </span>
<span class="quote">&gt; &gt; &gt;&gt; Agree, IOMMU driver cannot enforce it. I think VFIO layer can make</span>
<span class="quote">&gt; &gt; &gt;&gt; sure page response come from the assigned device and its</span>
<span class="quote">&gt; &gt; &gt;&gt; guest/container.    </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Can we enforce it via the IOMMU/VFIO interface?  If the response is</span>
<span class="quote">&gt; &gt; &gt; for a struct device, and not an rid/did embedded in a structure,</span>
<span class="quote">&gt; &gt; &gt; then vfio can pass it through w/o worrying about it, ie. response</span>
<span class="quote">&gt; &gt; &gt; comes in via ioctl with association to vfio device fd -&gt; struct</span>
<span class="quote">&gt; &gt; &gt; vfio_device -&gt; struct device, iommu driver fills in rid/did.</span>
<span class="quote">&gt; &gt; &gt; Thanks,    </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Yes that&#39;s probably the best way, reporting faults and receiving</span>
<span class="quote">&gt; &gt; responses on the device fd.</span>
<span class="quote">&gt; &gt;   </span>
<span class="quote">&gt; Just to put these ideas in to code. The IOMMU API used by VFIO has</span>
<span class="quote">&gt; struct device* (derived from fd), no did/rid (to be derived from</span>
<span class="quote">&gt; struct device by IOMMU driver.)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; int intel_iommu_page_response(struct iommu_domain *domain, struct device *dev,</span>
<span class="quote">&gt; 			struct page_response_msg *msg)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; IOMMU driver can further sanitize by checking whether this is a pending</span>
<span class="quote">&gt; page request for the device, and refcount outstanding PRQs.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Does it sound right?</span>

Yep.  Thanks,

Alex
<span class="quote"> 
&gt; /**</span>
<span class="quote">&gt;  * Generic page response information based on PCI ATS and PASID spec.</span>
<span class="quote">&gt;  * @addr: servicing page address</span>
<span class="quote">&gt;  * @pasid: contains process address space ID, used in shared virtual</span>
<span class="quote">&gt; memory(SVM)</span>
<span class="quote">&gt;  * @resp_code: response code</span>
<span class="quote">&gt;  * @page_req_group_id: page request group index</span>
<span class="quote">&gt;  * @type: group or stream/single page response</span>
<span class="quote">&gt;  * @private_data: uniquely identify device-specific private data for an</span>
<span class="quote">&gt;  *                individual page response</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  */</span>
<span class="quote">&gt; struct page_response_msg {</span>
<span class="quote">&gt; 	u64 addr;</span>
<span class="quote">&gt; 	u32 pasid;</span>
<span class="quote">&gt; 	u32 resp_code:4;</span>
<span class="quote">&gt; #define IOMMU_PAGE_RESP_SUCCESS	0</span>
<span class="quote">&gt; #define IOMMU_PAGE_RESP_INVALID	1</span>
<span class="quote">&gt; #define IOMMU_PAGE_RESP_FAILURE	0xF</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	u32 pasid_present:1;</span>
<span class="quote">&gt; 	u32 page_req_group_id : 9;</span>
<span class="quote">&gt; 	enum page_response_type type;</span>
<span class="quote">&gt; 	u32 private_data;</span>
<span class="quote">&gt; };</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="p_header">index 97b7990..7aefb40 100644</span>
<span class="p_header">--- a/drivers/iommu/iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/iommu.c</span>
<span class="p_chunk">@@ -1416,6 +1416,20 @@</span> <span class="p_context"> int iommu_sva_invalidate(struct iommu_domain *domain,</span>
 }
 EXPORT_SYMBOL_GPL(iommu_sva_invalidate);
 
<span class="p_add">+int iommu_page_response(struct iommu_domain *domain, struct device *dev,</span>
<span class="p_add">+			struct page_response_msg *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!domain-&gt;ops-&gt;page_response))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = domain-&gt;ops-&gt;page_response(domain, dev, msg);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(iommu_page_response);</span>
<span class="p_add">+</span>
 static void __iommu_detach_device(struct iommu_domain *domain,
 				  struct device *dev)
 {
<span class="p_header">diff --git a/include/linux/iommu.h b/include/linux/iommu.h</span>
<span class="p_header">index 3083796b..17f698b 100644</span>
<span class="p_header">--- a/include/linux/iommu.h</span>
<span class="p_header">+++ b/include/linux/iommu.h</span>
<span class="p_chunk">@@ -163,6 +163,43 @@</span> <span class="p_context"> struct iommu_resv_region {</span>
 
 #ifdef CONFIG_IOMMU_API
 
<span class="p_add">+enum page_response_type {</span>
<span class="p_add">+	IOMMU_PAGE_STREAM_RESP = 1,</span>
<span class="p_add">+	IOMMU_PAGE_GROUP_RESP,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * Generic page response information based on PCI ATS and PASID spec.</span>
<span class="p_add">+ * @paddr: servicing page address</span>
<span class="p_add">+ * @pasid: contains process address space ID, used in shared virtual memory(SVM)</span>
<span class="p_add">+ * @rid: requestor ID</span>
<span class="p_add">+ * @did: destination device ID</span>
<span class="p_add">+ * @last_req: last request in a page request group</span>
<span class="p_add">+ * @resp_code: response code</span>
<span class="p_add">+ * @page_req_group_id: page request group index</span>
<span class="p_add">+ * @prot: page access protection flag, e.g. IOMMU_FAULT_READ, IOMMU_FAULT_WRITE</span>
<span class="p_add">+ * @type: group or stream response</span>
<span class="p_add">+ * @private_data: uniquely identify device-specific private data for an</span>
<span class="p_add">+ *                individual page response</span>
<span class="p_add">+</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct page_response_msg {</span>
<span class="p_add">+	u64 paddr;</span>
<span class="p_add">+	u32 pasid;</span>
<span class="p_add">+	u32 rid:16;</span>
<span class="p_add">+	u32 did:16;</span>
<span class="p_add">+	u32 resp_code:4;</span>
<span class="p_add">+	u32 last_req:1;</span>
<span class="p_add">+	u32 pasid_present:1;</span>
<span class="p_add">+#define IOMMU_PAGE_RESP_SUCCESS	0</span>
<span class="p_add">+#define IOMMU_PAGE_RESP_INVALID	1</span>
<span class="p_add">+#define IOMMU_PAGE_RESP_FAILURE	0xF</span>
<span class="p_add">+	u32 page_req_group_id : 9;</span>
<span class="p_add">+	u32 prot;</span>
<span class="p_add">+	enum page_response_type type;</span>
<span class="p_add">+	u32 private_data;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /**
  * struct iommu_ops - iommu ops and capabilities
  * @capable: check capability
<span class="p_chunk">@@ -196,6 +233,7 @@</span> <span class="p_context"> struct iommu_resv_region {</span>
  * @bind_pasid_table: bind pasid table pointer for guest SVM
  * @unbind_pasid_table: unbind pasid table pointer and restore defaults
  * @sva_invalidate: invalidate translation caches of shared virtual address
<span class="p_add">+ * @page_response: handle page request response</span>
  */
 struct iommu_ops {
 	bool (*capable)(enum iommu_cap);
<span class="p_chunk">@@ -251,6 +289,8 @@</span> <span class="p_context"> struct iommu_ops {</span>
 				struct device *dev);
 	int (*sva_invalidate)(struct iommu_domain *domain,
 		struct device *dev, struct tlb_invalidate_info *inv_info);
<span class="p_add">+	int (*page_response)(struct iommu_domain *domain, struct device *dev,</span>
<span class="p_add">+			struct page_response_msg *msg);</span>
 
 	unsigned long pgsize_bitmap;
 };
<span class="p_chunk">@@ -472,6 +512,8 @@</span> <span class="p_context"> extern int iommu_unregister_device_fault_handler(struct device *dev);</span>
 
 extern int iommu_report_device_fault(struct device *dev, struct iommu_fault_event *evt);
 
<span class="p_add">+extern int iommu_page_response(struct iommu_domain *domain, struct device *dev,</span>
<span class="p_add">+			struct page_response_msg *msg);</span>
 extern int iommu_group_id(struct iommu_group *group);
 extern struct iommu_group *iommu_group_get_for_dev(struct device *dev);
 extern struct iommu_domain *iommu_group_default_domain(struct iommu_group *);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



