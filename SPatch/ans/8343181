
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.2 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.2</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 17, 2016, 8:37 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160217203738.GB14820@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8343181/mbox/"
   >mbox</a>
|
   <a href="/patch/8343181/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8343181/">/patch/8343181/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 41E999F372
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 17 Feb 2016 20:38:25 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 8F536203A4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 17 Feb 2016 20:38:16 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id EF05B2037F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 17 Feb 2016 20:38:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1423209AbcBQUh7 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 17 Feb 2016 15:37:59 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:52287 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S965253AbcBQUhj (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 17 Feb 2016 15:37:39 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 90479FC5;
	Wed, 17 Feb 2016 20:37:38 +0000 (UTC)
Date: Wed, 17 Feb 2016 12:37:38 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.2
Message-ID: &lt;20160217203738.GB14820@kroah.com&gt;
References: &lt;20160217203730.GA14820@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160217203730.GA14820@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Feb. 17, 2016, 8:37 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index c6a265b52c93..e7a2958eb771 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 1</span>
<span class="p_add">+SUBLEVEL = 2</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/parisc/include/asm/hugetlb.h b/arch/parisc/include/asm/hugetlb.h</span>
<span class="p_header">index 7d56a9ccb752..a65d888716c4 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -54,24 +54,12 @@</span> <span class="p_context"> static inline pte_t huge_pte_wrprotect(pte_t pte)</span>
 	return pte_wrprotect(pte);
 }
 
<span class="p_del">-static inline void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="p_del">-					   unsigned long addr, pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pte_t old_pte = *ptep;</span>
<span class="p_del">-	set_huge_pte_at(mm, addr, ptep, pte_wrprotect(old_pte));</span>
<span class="p_del">-}</span>
<span class="p_add">+void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="p_add">+					   unsigned long addr, pte_t *ptep);</span>
 
<span class="p_del">-static inline int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
 					     unsigned long addr, pte_t *ptep,
<span class="p_del">-					     pte_t pte, int dirty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int changed = !pte_same(*ptep, pte);</span>
<span class="p_del">-	if (changed) {</span>
<span class="p_del">-		set_huge_pte_at(vma-&gt;vm_mm, addr, ptep, pte);</span>
<span class="p_del">-		flush_tlb_page(vma, addr);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return changed;</span>
<span class="p_del">-}</span>
<span class="p_add">+					     pte_t pte, int dirty);</span>
 
 static inline pte_t huge_ptep_get(pte_t *ptep)
 {
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/siginfo.h b/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_header">index d7034728f377..1c75565d984b 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/siginfo.h</span>
<span class="p_chunk">@@ -1,6 +1,10 @@</span> <span class="p_context"></span>
 #ifndef _PARISC_SIGINFO_H
 #define _PARISC_SIGINFO_H
 
<span class="p_add">+#if defined(__LP64__)</span>
<span class="p_add">+#define __ARCH_SI_PREAMBLE_SIZE   (4 * sizeof(int))</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #include &lt;asm-generic/siginfo.h&gt;
 
 #undef NSIGTRAP
<span class="p_header">diff --git a/arch/parisc/mm/hugetlbpage.c b/arch/parisc/mm/hugetlbpage.c</span>
<span class="p_header">index f6fdc77a72bd..54ba39262b82 100644</span>
<span class="p_header">--- a/arch/parisc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/parisc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -105,15 +105,13 @@</span> <span class="p_context"> static inline void purge_tlb_entries_huge(struct mm_struct *mm, unsigned long ad</span>
 	addr |= _HUGE_PAGE_SIZE_ENCODING_DEFAULT;
 
 	for (i = 0; i &lt; (1 &lt;&lt; (HPAGE_SHIFT-REAL_HPAGE_SHIFT)); i++) {
<span class="p_del">-		mtsp(mm-&gt;context, 1);</span>
<span class="p_del">-		pdtlb(addr);</span>
<span class="p_del">-		if (unlikely(split_tlb))</span>
<span class="p_del">-			pitlb(addr);</span>
<span class="p_add">+		purge_tlb_entries(mm, addr);</span>
 		addr += (1UL &lt;&lt; REAL_HPAGE_SHIFT);
 	}
 }
 
<span class="p_del">-void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+/* __set_huge_pte_at() must be called holding the pa_tlb_lock. */</span>
<span class="p_add">+static void __set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
 		     pte_t *ptep, pte_t entry)
 {
 	unsigned long addr_start;
<span class="p_chunk">@@ -123,14 +121,9 @@</span> <span class="p_context"> void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
 	addr_start = addr;
 
 	for (i = 0; i &lt; (1 &lt;&lt; HUGETLB_PAGE_ORDER); i++) {
<span class="p_del">-		/* Directly write pte entry.  We could call set_pte_at(mm, addr, ptep, entry)</span>
<span class="p_del">-		 * instead, but then we get double locking on pa_tlb_lock. */</span>
<span class="p_del">-		*ptep = entry;</span>
<span class="p_add">+		set_pte(ptep, entry);</span>
 		ptep++;
 
<span class="p_del">-		/* Drop the PAGE_SIZE/non-huge tlb entry */</span>
<span class="p_del">-		purge_tlb_entries(mm, addr);</span>
<span class="p_del">-</span>
 		addr += PAGE_SIZE;
 		pte_val(entry) += PAGE_SIZE;
 	}
<span class="p_chunk">@@ -138,18 +131,61 @@</span> <span class="p_context"> void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
 	purge_tlb_entries_huge(mm, addr_start);
 }
 
<span class="p_add">+void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+		     pte_t *ptep, pte_t entry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	purge_tlb_start(flags);</span>
<span class="p_add">+	__set_huge_pte_at(mm, addr, ptep, entry);</span>
<span class="p_add">+	purge_tlb_end(flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 
 pte_t huge_ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,
 			      pte_t *ptep)
 {
<span class="p_add">+	unsigned long flags;</span>
 	pte_t entry;
 
<span class="p_add">+	purge_tlb_start(flags);</span>
 	entry = *ptep;
<span class="p_del">-	set_huge_pte_at(mm, addr, ptep, __pte(0));</span>
<span class="p_add">+	__set_huge_pte_at(mm, addr, ptep, __pte(0));</span>
<span class="p_add">+	purge_tlb_end(flags);</span>
 
 	return entry;
 }
 
<span class="p_add">+</span>
<span class="p_add">+void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="p_add">+				unsigned long addr, pte_t *ptep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	pte_t old_pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	purge_tlb_start(flags);</span>
<span class="p_add">+	old_pte = *ptep;</span>
<span class="p_add">+	__set_huge_pte_at(mm, addr, ptep, pte_wrprotect(old_pte));</span>
<span class="p_add">+	purge_tlb_end(flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+				unsigned long addr, pte_t *ptep,</span>
<span class="p_add">+				pte_t pte, int dirty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int changed;</span>
<span class="p_add">+</span>
<span class="p_add">+	purge_tlb_start(flags);</span>
<span class="p_add">+	changed = !pte_same(*ptep, pte);</span>
<span class="p_add">+	if (changed) {</span>
<span class="p_add">+		__set_huge_pte_at(vma-&gt;vm_mm, addr, ptep, pte);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	purge_tlb_end(flags);</span>
<span class="p_add">+	return changed;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 int pmd_huge(pmd_t pmd)
 {
 	return 0;
<span class="p_header">diff --git a/arch/x86/crypto/chacha20-ssse3-x86_64.S b/arch/x86/crypto/chacha20-ssse3-x86_64.S</span>
<span class="p_header">index 712b13047b41..3a33124e9112 100644</span>
<span class="p_header">--- a/arch/x86/crypto/chacha20-ssse3-x86_64.S</span>
<span class="p_header">+++ b/arch/x86/crypto/chacha20-ssse3-x86_64.S</span>
<span class="p_chunk">@@ -157,7 +157,9 @@</span> <span class="p_context"> ENTRY(chacha20_4block_xor_ssse3)</span>
 	# done with the slightly better performing SSSE3 byte shuffling,
 	# 7/12-bit word rotation uses traditional shift+OR.
 
<span class="p_del">-	sub		$0x40,%rsp</span>
<span class="p_add">+	mov		%rsp,%r11</span>
<span class="p_add">+	sub		$0x80,%rsp</span>
<span class="p_add">+	and		$~63,%rsp</span>
 
 	# x0..15[0-3] = s0..3[0..3]
 	movq		0x00(%rdi),%xmm1
<span class="p_chunk">@@ -620,6 +622,6 @@</span> <span class="p_context"> ENTRY(chacha20_4block_xor_ssse3)</span>
 	pxor		%xmm1,%xmm15
 	movdqu		%xmm15,0xf0(%rsi)
 
<span class="p_del">-	add		$0x40,%rsp</span>
<span class="p_add">+	mov		%r11,%rsp</span>
 	ret
 ENDPROC(chacha20_4block_xor_ssse3)
<span class="p_header">diff --git a/block/blk-merge.c b/block/blk-merge.c</span>
<span class="p_header">index e01405a3e8b3..b966db8f3556 100644</span>
<span class="p_header">--- a/block/blk-merge.c</span>
<span class="p_header">+++ b/block/blk-merge.c</span>
<span class="p_chunk">@@ -68,6 +68,18 @@</span> <span class="p_context"> static struct bio *blk_bio_write_same_split(struct request_queue *q,</span>
 	return bio_split(bio, q-&gt;limits.max_write_same_sectors, GFP_NOIO, bs);
 }
 
<span class="p_add">+static inline unsigned get_max_io_size(struct request_queue *q,</span>
<span class="p_add">+				       struct bio *bio)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned sectors = blk_max_size_offset(q, bio-&gt;bi_iter.bi_sector);</span>
<span class="p_add">+	unsigned mask = queue_logical_block_size(q) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* aligned to logical block size */</span>
<span class="p_add">+	sectors &amp;= ~(mask &gt;&gt; 9);</span>
<span class="p_add">+</span>
<span class="p_add">+	return sectors;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct bio *blk_bio_segment_split(struct request_queue *q,
 					 struct bio *bio,
 					 struct bio_set *bs,
<span class="p_chunk">@@ -79,11 +91,9 @@</span> <span class="p_context"> static struct bio *blk_bio_segment_split(struct request_queue *q,</span>
 	unsigned front_seg_size = bio-&gt;bi_seg_front_size;
 	bool do_split = true;
 	struct bio *new = NULL;
<span class="p_add">+	const unsigned max_sectors = get_max_io_size(q, bio);</span>
 
 	bio_for_each_segment(bv, bio, iter) {
<span class="p_del">-		if (sectors + (bv.bv_len &gt;&gt; 9) &gt; queue_max_sectors(q))</span>
<span class="p_del">-			goto split;</span>
<span class="p_del">-</span>
 		/*
 		 * If the queue doesn&#39;t support SG gaps and adding this
 		 * offset would create a gap, disallow it.
<span class="p_chunk">@@ -91,6 +101,21 @@</span> <span class="p_context"> static struct bio *blk_bio_segment_split(struct request_queue *q,</span>
 		if (bvprvp &amp;&amp; bvec_gap_to_prev(q, bvprvp, bv.bv_offset))
 			goto split;
 
<span class="p_add">+		if (sectors + (bv.bv_len &gt;&gt; 9) &gt; max_sectors) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Consider this a new segment if we&#39;re splitting in</span>
<span class="p_add">+			 * the middle of this vector.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (nsegs &lt; queue_max_segments(q) &amp;&amp;</span>
<span class="p_add">+			    sectors &lt; max_sectors) {</span>
<span class="p_add">+				nsegs++;</span>
<span class="p_add">+				sectors = max_sectors;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if (sectors)</span>
<span class="p_add">+				goto split;</span>
<span class="p_add">+			/* Make this single bvec as the 1st segment */</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (bvprvp &amp;&amp; blk_queue_cluster(q)) {
 			if (seg_size + bv.bv_len &gt; queue_max_segment_size(q))
 				goto new_segment;
<span class="p_header">diff --git a/crypto/af_alg.c b/crypto/af_alg.c</span>
<span class="p_header">index a8e7aa3e257b..f5e18c2a4852 100644</span>
<span class="p_header">--- a/crypto/af_alg.c</span>
<span class="p_header">+++ b/crypto/af_alg.c</span>
<span class="p_chunk">@@ -76,6 +76,8 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type)</span>
 		goto unlock;
 
 	type-&gt;ops-&gt;owner = THIS_MODULE;
<span class="p_add">+	if (type-&gt;ops_nokey)</span>
<span class="p_add">+		type-&gt;ops_nokey-&gt;owner = THIS_MODULE;</span>
 	node-&gt;type = type;
 	list_add(&amp;node-&gt;list, &amp;alg_types);
 	err = 0;
<span class="p_chunk">@@ -125,6 +127,26 @@</span> <span class="p_context"> int af_alg_release(struct socket *sock)</span>
 }
 EXPORT_SYMBOL_GPL(af_alg_release);
 
<span class="p_add">+void af_alg_release_parent(struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+	unsigned int nokey = ask-&gt;nokey_refcnt;</span>
<span class="p_add">+	bool last = nokey &amp;&amp; !ask-&gt;refcnt;</span>
<span class="p_add">+</span>
<span class="p_add">+	sk = ask-&gt;parent;</span>
<span class="p_add">+	ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt -= nokey;</span>
<span class="p_add">+	if (!last)</span>
<span class="p_add">+		last = !--ask-&gt;refcnt;</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (last)</span>
<span class="p_add">+		sock_put(sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(af_alg_release_parent);</span>
<span class="p_add">+</span>
 static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
 {
 	const u32 forbidden = CRYPTO_ALG_INTERNAL;
<span class="p_chunk">@@ -133,6 +155,7 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct sockaddr_alg *sa = (void *)uaddr;
 	const struct af_alg_type *type;
 	void *private;
<span class="p_add">+	int err;</span>
 
 	if (sock-&gt;state == SS_CONNECTED)
 		return -EINVAL;
<span class="p_chunk">@@ -160,16 +183,22 @@</span> <span class="p_context"> static int alg_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 		return PTR_ERR(private);
 	}
 
<span class="p_add">+	err = -EBUSY;</span>
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt | ask-&gt;nokey_refcnt)</span>
<span class="p_add">+		goto unlock;</span>
 
 	swap(ask-&gt;type, type);
 	swap(ask-&gt;private, private);
 
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
 	release_sock(sk);
 
 	alg_do_release(type, private);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 static int alg_setkey(struct sock *sk, char __user *ukey,
<span class="p_chunk">@@ -202,11 +231,15 @@</span> <span class="p_context"> static int alg_setsockopt(struct socket *sock, int level, int optname,</span>
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
<span class="p_del">-	int err = -ENOPROTOOPT;</span>
<span class="p_add">+	int err = -EBUSY;</span>
 
 	lock_sock(sk);
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
 	type = ask-&gt;type;
 
<span class="p_add">+	err = -ENOPROTOOPT;</span>
 	if (level != SOL_ALG || !type)
 		goto unlock;
 
<span class="p_chunk">@@ -238,6 +271,7 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	struct alg_sock *ask = alg_sk(sk);
 	const struct af_alg_type *type;
 	struct sock *sk2;
<span class="p_add">+	unsigned int nokey;</span>
 	int err;
 
 	lock_sock(sk);
<span class="p_chunk">@@ -257,20 +291,29 @@</span> <span class="p_context"> int af_alg_accept(struct sock *sk, struct socket *newsock)</span>
 	security_sk_clone(sk, sk2);
 
 	err = type-&gt;accept(ask-&gt;private, sk2);
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		sk_free(sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	nokey = err == -ENOKEY;</span>
<span class="p_add">+	if (nokey &amp;&amp; type-&gt;accept_nokey)</span>
<span class="p_add">+		err = type-&gt;accept_nokey(ask-&gt;private, sk2);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
 		goto unlock;
<span class="p_del">-	}</span>
 
 	sk2-&gt;sk_family = PF_ALG;
 
<span class="p_del">-	sock_hold(sk);</span>
<span class="p_add">+	if (nokey || !ask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(sk);</span>
<span class="p_add">+	ask-&gt;nokey_refcnt += nokey;</span>
 	alg_sk(sk2)-&gt;parent = sk;
 	alg_sk(sk2)-&gt;type = type;
<span class="p_add">+	alg_sk(sk2)-&gt;nokey_refcnt = nokey;</span>
 
 	newsock-&gt;ops = type-&gt;ops;
 	newsock-&gt;state = SS_CONNECTED;
 
<span class="p_add">+	if (nokey)</span>
<span class="p_add">+		newsock-&gt;ops = type-&gt;ops_nokey;</span>
<span class="p_add">+</span>
 	err = 0;
 
 unlock:
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index 9c1dc8d6106a..d19b52324cf5 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -451,6 +451,7 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	struct ahash_alg *alg = crypto_ahash_alg(hash);
 
 	hash-&gt;setkey = ahash_nosetkey;
<span class="p_add">+	hash-&gt;has_setkey = false;</span>
 	hash-&gt;export = ahash_no_export;
 	hash-&gt;import = ahash_no_import;
 
<span class="p_chunk">@@ -463,8 +464,10 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	hash-&gt;finup = alg-&gt;finup ?: ahash_def_finup;
 	hash-&gt;digest = alg-&gt;digest;
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_add">+	if (alg-&gt;setkey) {</span>
 		hash-&gt;setkey = alg-&gt;setkey;
<span class="p_add">+		hash-&gt;has_setkey = true;</span>
<span class="p_add">+	}</span>
 	if (alg-&gt;export)
 		hash-&gt;export = alg-&gt;export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c</span>
<span class="p_header">index b4c24fe3dcfb..68a5ceaa04c8 100644</span>
<span class="p_header">--- a/crypto/algif_hash.c</span>
<span class="p_header">+++ b/crypto/algif_hash.c</span>
<span class="p_chunk">@@ -34,6 +34,11 @@</span> <span class="p_context"> struct hash_ctx {</span>
 	struct ahash_request req;
 };
 
<span class="p_add">+struct algif_hash_tfm {</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int hash_sendmsg(struct socket *sock, struct msghdr *msg,
 			size_t ignored)
 {
<span class="p_chunk">@@ -49,7 +54,8 @@</span> <span class="p_context"> static int hash_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 
 	lock_sock(sk);
 	if (!ctx-&gt;more) {
<span class="p_del">-		err = crypto_ahash_init(&amp;ctx-&gt;req);</span>
<span class="p_add">+		err = af_alg_wait_for_completion(crypto_ahash_init(&amp;ctx-&gt;req),</span>
<span class="p_add">+						&amp;ctx-&gt;completion);</span>
 		if (err)
 			goto unlock;
 	}
<span class="p_chunk">@@ -120,6 +126,7 @@</span> <span class="p_context"> static ssize_t hash_sendpage(struct socket *sock, struct page *page,</span>
 	} else {
 		if (!ctx-&gt;more) {
 			err = crypto_ahash_init(&amp;ctx-&gt;req);
<span class="p_add">+			err = af_alg_wait_for_completion(err, &amp;ctx-&gt;completion);</span>
 			if (err)
 				goto unlock;
 		}
<span class="p_chunk">@@ -235,19 +242,151 @@</span> <span class="p_context"> static struct proto_ops algif_hash_ops = {</span>
 	.accept		=	hash_accept,
 };
 
<span class="p_add">+static int hash_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_sendmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+			      size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendmsg(sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t hash_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				   int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_recvmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+			      size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_recvmsg(sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int hash_accept_nokey(struct socket *sock, struct socket *newsock,</span>
<span class="p_add">+			     int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = hash_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept(sock, newsock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_hash_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+	.poll		=	sock_no_poll,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	hash_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	hash_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	hash_recvmsg_nokey,</span>
<span class="p_add">+	.accept		=	hash_accept_nokey,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *hash_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct crypto_ahash *hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	hash = crypto_alloc_ahash(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(hash)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(hash);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;hash = hash;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void hash_release(void *private)
 {
<span class="p_del">-	crypto_free_ahash(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_ahash(tfm-&gt;hash);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_ahash_setkey(private, key, keylen);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_ahash_setkey(tfm-&gt;hash, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void hash_sock_destruct(struct sock *sk)
<span class="p_chunk">@@ -261,12 +400,14 @@</span> <span class="p_context"> static void hash_sock_destruct(struct sock *sk)</span>
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int hash_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct hash_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(private);</span>
<span class="p_del">-	unsigned ds = crypto_ahash_digestsize(private);</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_ahash *hash = tfm-&gt;hash;</span>
<span class="p_add">+	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(hash);</span>
<span class="p_add">+	unsigned ds = crypto_ahash_digestsize(hash);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
<span class="p_chunk">@@ -286,7 +427,7 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ahash_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_add">+	ahash_request_set_tfm(&amp;ctx-&gt;req, hash);</span>
 	ahash_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				   af_alg_complete, &amp;ctx-&gt;completion);
 
<span class="p_chunk">@@ -295,12 +436,24 @@</span> <span class="p_context"> static int hash_accept_parent(void *private, struct sock *sk)</span>
 	return 0;
 }
 
<span class="p_add">+static int hash_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key &amp;&amp; crypto_ahash_has_setkey(tfm-&gt;hash))</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hash_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_hash = {
 	.bind		=	hash_bind,
 	.release	=	hash_release,
 	.setkey		=	hash_setkey,
 	.accept		=	hash_accept_parent,
<span class="p_add">+	.accept_nokey	=	hash_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_hash_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_hash_ops_nokey,</span>
 	.name		=	&quot;hash&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index 634b4d1ab681..f5e9f9310b48 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -31,6 +31,11 @@</span> <span class="p_context"> struct skcipher_sg_list {</span>
 	struct scatterlist sg[0];
 };
 
<span class="p_add">+struct skcipher_tfm {</span>
<span class="p_add">+	struct crypto_skcipher *skcipher;</span>
<span class="p_add">+	bool has_key;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct skcipher_ctx {
 	struct list_head tsgl;
 	struct af_alg_sgl rsgl;
<span class="p_chunk">@@ -60,18 +65,10 @@</span> <span class="p_context"> struct skcipher_async_req {</span>
 	struct skcipher_async_rsgl first_sgl;
 	struct list_head list;
 	struct scatterlist *tsg;
<span class="p_del">-	char iv[];</span>
<span class="p_add">+	atomic_t *inflight;</span>
<span class="p_add">+	struct skcipher_request req;</span>
 };
 
<span class="p_del">-#define GET_SREQ(areq, ctx) (struct skcipher_async_req *)((char *)areq + \</span>
<span class="p_del">-	crypto_skcipher_reqsize(crypto_skcipher_reqtfm(&amp;ctx-&gt;req)))</span>
<span class="p_del">-</span>
<span class="p_del">-#define GET_REQ_SIZE(ctx) \</span>
<span class="p_del">-	crypto_skcipher_reqsize(crypto_skcipher_reqtfm(&amp;ctx-&gt;req))</span>
<span class="p_del">-</span>
<span class="p_del">-#define GET_IV_SIZE(ctx) \</span>
<span class="p_del">-	crypto_skcipher_ivsize(crypto_skcipher_reqtfm(&amp;ctx-&gt;req))</span>
<span class="p_del">-</span>
 #define MAX_SGL_ENTS ((4096 - sizeof(struct skcipher_sg_list)) / \
 		      sizeof(struct scatterlist) - 1)
 
<span class="p_chunk">@@ -97,15 +94,12 @@</span> <span class="p_context"> static void skcipher_free_async_sgls(struct skcipher_async_req *sreq)</span>
 
 static void skcipher_async_cb(struct crypto_async_request *req, int err)
 {
<span class="p_del">-	struct sock *sk = req-&gt;data;</span>
<span class="p_del">-	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_del">-	struct skcipher_ctx *ctx = ask-&gt;private;</span>
<span class="p_del">-	struct skcipher_async_req *sreq = GET_SREQ(req, ctx);</span>
<span class="p_add">+	struct skcipher_async_req *sreq = req-&gt;data;</span>
 	struct kiocb *iocb = sreq-&gt;iocb;
 
<span class="p_del">-	atomic_dec(&amp;ctx-&gt;inflight);</span>
<span class="p_add">+	atomic_dec(sreq-&gt;inflight);</span>
 	skcipher_free_async_sgls(sreq);
<span class="p_del">-	kfree(req);</span>
<span class="p_add">+	kzfree(sreq);</span>
 	iocb-&gt;ki_complete(iocb, err, err);
 }
 
<span class="p_chunk">@@ -301,8 +295,11 @@</span> <span class="p_context"> static int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_add">+	struct sock *psk = ask-&gt;parent;</span>
<span class="p_add">+	struct alg_sock *pask = alg_sk(psk);</span>
 	struct skcipher_ctx *ctx = ask-&gt;private;
<span class="p_del">-	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(&amp;ctx-&gt;req);</span>
<span class="p_add">+	struct skcipher_tfm *skc = pask-&gt;private;</span>
<span class="p_add">+	struct crypto_skcipher *tfm = skc-&gt;skcipher;</span>
 	unsigned ivsize = crypto_skcipher_ivsize(tfm);
 	struct skcipher_sg_list *sgl;
 	struct af_alg_control con = {};
<span class="p_chunk">@@ -387,7 +384,8 @@</span> <span class="p_context"> static int skcipher_sendmsg(struct socket *sock, struct msghdr *msg,</span>
 
 		sgl = list_entry(ctx-&gt;tsgl.prev, struct skcipher_sg_list, list);
 		sg = sgl-&gt;sg;
<span class="p_del">-		sg_unmark_end(sg + sgl-&gt;cur);</span>
<span class="p_add">+		if (sgl-&gt;cur)</span>
<span class="p_add">+			sg_unmark_end(sg + sgl-&gt;cur - 1);</span>
 		do {
 			i = sgl-&gt;cur;
 			plen = min_t(int, len, PAGE_SIZE);
<span class="p_chunk">@@ -503,37 +501,43 @@</span> <span class="p_context"> static int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_add">+	struct sock *psk = ask-&gt;parent;</span>
<span class="p_add">+	struct alg_sock *pask = alg_sk(psk);</span>
 	struct skcipher_ctx *ctx = ask-&gt;private;
<span class="p_add">+	struct skcipher_tfm *skc = pask-&gt;private;</span>
<span class="p_add">+	struct crypto_skcipher *tfm = skc-&gt;skcipher;</span>
 	struct skcipher_sg_list *sgl;
 	struct scatterlist *sg;
 	struct skcipher_async_req *sreq;
 	struct skcipher_request *req;
 	struct skcipher_async_rsgl *last_rsgl = NULL;
<span class="p_del">-	unsigned int txbufs = 0, len = 0, tx_nents = skcipher_all_sg_nents(ctx);</span>
<span class="p_del">-	unsigned int reqlen = sizeof(struct skcipher_async_req) +</span>
<span class="p_del">-				GET_REQ_SIZE(ctx) + GET_IV_SIZE(ctx);</span>
<span class="p_add">+	unsigned int txbufs = 0, len = 0, tx_nents;</span>
<span class="p_add">+	unsigned int reqsize = crypto_skcipher_reqsize(tfm);</span>
<span class="p_add">+	unsigned int ivsize = crypto_skcipher_ivsize(tfm);</span>
 	int err = -ENOMEM;
 	bool mark = false;
<span class="p_add">+	char *iv;</span>
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_del">-	req = kmalloc(reqlen, GFP_KERNEL);</span>
<span class="p_del">-	if (unlikely(!req))</span>
<span class="p_del">-		goto unlock;</span>
<span class="p_add">+	sreq = kzalloc(sizeof(*sreq) + reqsize + ivsize, GFP_KERNEL);</span>
<span class="p_add">+	if (unlikely(!sreq))</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_del">-	sreq = GET_SREQ(req, ctx);</span>
<span class="p_add">+	req = &amp;sreq-&gt;req;</span>
<span class="p_add">+	iv = (char *)(req + 1) + reqsize;</span>
 	sreq-&gt;iocb = msg-&gt;msg_iocb;
<span class="p_del">-	memset(&amp;sreq-&gt;first_sgl, &#39;\0&#39;, sizeof(struct skcipher_async_rsgl));</span>
 	INIT_LIST_HEAD(&amp;sreq-&gt;list);
<span class="p_add">+	sreq-&gt;inflight = &amp;ctx-&gt;inflight;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	tx_nents = skcipher_all_sg_nents(ctx);</span>
 	sreq-&gt;tsg = kcalloc(tx_nents, sizeof(*sg), GFP_KERNEL);
<span class="p_del">-	if (unlikely(!sreq-&gt;tsg)) {</span>
<span class="p_del">-		kfree(req);</span>
<span class="p_add">+	if (unlikely(!sreq-&gt;tsg))</span>
 		goto unlock;
<span class="p_del">-	}</span>
 	sg_init_table(sreq-&gt;tsg, tx_nents);
<span class="p_del">-	memcpy(sreq-&gt;iv, ctx-&gt;iv, GET_IV_SIZE(ctx));</span>
<span class="p_del">-	skcipher_request_set_tfm(req, crypto_skcipher_reqtfm(&amp;ctx-&gt;req));</span>
<span class="p_del">-	skcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span>
<span class="p_del">-				      skcipher_async_cb, sk);</span>
<span class="p_add">+	memcpy(iv, ctx-&gt;iv, ivsize);</span>
<span class="p_add">+	skcipher_request_set_tfm(req, tfm);</span>
<span class="p_add">+	skcipher_request_set_callback(req, CRYPTO_TFM_REQ_MAY_SLEEP,</span>
<span class="p_add">+				      skcipher_async_cb, sreq);</span>
 
 	while (iov_iter_count(&amp;msg-&gt;msg_iter)) {
 		struct skcipher_async_rsgl *rsgl;
<span class="p_chunk">@@ -609,20 +613,22 @@</span> <span class="p_context"> static int skcipher_recvmsg_async(struct socket *sock, struct msghdr *msg,</span>
 		sg_mark_end(sreq-&gt;tsg + txbufs - 1);
 
 	skcipher_request_set_crypt(req, sreq-&gt;tsg, sreq-&gt;first_sgl.sgl.sg,
<span class="p_del">-				   len, sreq-&gt;iv);</span>
<span class="p_add">+				   len, iv);</span>
 	err = ctx-&gt;enc ? crypto_skcipher_encrypt(req) :
 			 crypto_skcipher_decrypt(req);
 	if (err == -EINPROGRESS) {
 		atomic_inc(&amp;ctx-&gt;inflight);
 		err = -EIOCBQUEUED;
<span class="p_add">+		sreq = NULL;</span>
 		goto unlock;
 	}
 free:
 	skcipher_free_async_sgls(sreq);
<span class="p_del">-	kfree(req);</span>
 unlock:
 	skcipher_wmem_wakeup(sk);
 	release_sock(sk);
<span class="p_add">+	kzfree(sreq);</span>
<span class="p_add">+out:</span>
 	return err;
 }
 
<span class="p_chunk">@@ -631,9 +637,12 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 {
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_add">+	struct sock *psk = ask-&gt;parent;</span>
<span class="p_add">+	struct alg_sock *pask = alg_sk(psk);</span>
 	struct skcipher_ctx *ctx = ask-&gt;private;
<span class="p_del">-	unsigned bs = crypto_skcipher_blocksize(crypto_skcipher_reqtfm(</span>
<span class="p_del">-		&amp;ctx-&gt;req));</span>
<span class="p_add">+	struct skcipher_tfm *skc = pask-&gt;private;</span>
<span class="p_add">+	struct crypto_skcipher *tfm = skc-&gt;skcipher;</span>
<span class="p_add">+	unsigned bs = crypto_skcipher_blocksize(tfm);</span>
 	struct skcipher_sg_list *sgl;
 	struct scatterlist *sg;
 	int err = -EAGAIN;
<span class="p_chunk">@@ -642,13 +651,6 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 
 	lock_sock(sk);
 	while (msg_data_left(msg)) {
<span class="p_del">-		sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_del">-				       struct skcipher_sg_list, list);</span>
<span class="p_del">-		sg = sgl-&gt;sg;</span>
<span class="p_del">-</span>
<span class="p_del">-		while (!sg-&gt;length)</span>
<span class="p_del">-			sg++;</span>
<span class="p_del">-</span>
 		if (!ctx-&gt;used) {
 			err = skcipher_wait_for_data(sk, flags);
 			if (err)
<span class="p_chunk">@@ -669,6 +671,13 @@</span> <span class="p_context"> static int skcipher_recvmsg_sync(struct socket *sock, struct msghdr *msg,</span>
 		if (!used)
 			goto free;
 
<span class="p_add">+		sgl = list_first_entry(&amp;ctx-&gt;tsgl,</span>
<span class="p_add">+				       struct skcipher_sg_list, list);</span>
<span class="p_add">+		sg = sgl-&gt;sg;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (!sg-&gt;length)</span>
<span class="p_add">+			sg++;</span>
<span class="p_add">+</span>
 		skcipher_request_set_crypt(&amp;ctx-&gt;req, sg, ctx-&gt;rsgl.sg, used,
 					   ctx-&gt;iv);
 
<span class="p_chunk">@@ -748,19 +757,139 @@</span> <span class="p_context"> static struct proto_ops algif_skcipher_ops = {</span>
 	.poll		=	skcipher_poll,
 };
 
<span class="p_add">+static int skcipher_check_key(struct socket *sock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	struct sock *psk;</span>
<span class="p_add">+	struct alg_sock *pask;</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct sock *sk = sock-&gt;sk;</span>
<span class="p_add">+	struct alg_sock *ask = alg_sk(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	if (ask-&gt;refcnt)</span>
<span class="p_add">+		goto unlock_child;</span>
<span class="p_add">+</span>
<span class="p_add">+	psk = ask-&gt;parent;</span>
<span class="p_add">+	pask = alg_sk(ask-&gt;parent);</span>
<span class="p_add">+	tfm = pask-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOKEY;</span>
<span class="p_add">+	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+	if (!tfm-&gt;has_key)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pask-&gt;refcnt++)</span>
<span class="p_add">+		sock_hold(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	ask-&gt;refcnt = 1;</span>
<span class="p_add">+	sock_put(psk);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	release_sock(psk);</span>
<span class="p_add">+unlock_child:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_sendmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+				  size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendmsg(sock, msg, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t skcipher_sendpage_nokey(struct socket *sock, struct page *page,</span>
<span class="p_add">+				       int offset, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_sendpage(sock, page, offset, size, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int skcipher_recvmsg_nokey(struct socket *sock, struct msghdr *msg,</span>
<span class="p_add">+				  size_t ignored, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = skcipher_check_key(sock);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_recvmsg(sock, msg, ignored, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct proto_ops algif_skcipher_ops_nokey = {</span>
<span class="p_add">+	.family		=	PF_ALG,</span>
<span class="p_add">+</span>
<span class="p_add">+	.connect	=	sock_no_connect,</span>
<span class="p_add">+	.socketpair	=	sock_no_socketpair,</span>
<span class="p_add">+	.getname	=	sock_no_getname,</span>
<span class="p_add">+	.ioctl		=	sock_no_ioctl,</span>
<span class="p_add">+	.listen		=	sock_no_listen,</span>
<span class="p_add">+	.shutdown	=	sock_no_shutdown,</span>
<span class="p_add">+	.getsockopt	=	sock_no_getsockopt,</span>
<span class="p_add">+	.mmap		=	sock_no_mmap,</span>
<span class="p_add">+	.bind		=	sock_no_bind,</span>
<span class="p_add">+	.accept		=	sock_no_accept,</span>
<span class="p_add">+	.setsockopt	=	sock_no_setsockopt,</span>
<span class="p_add">+</span>
<span class="p_add">+	.release	=	af_alg_release,</span>
<span class="p_add">+	.sendmsg	=	skcipher_sendmsg_nokey,</span>
<span class="p_add">+	.sendpage	=	skcipher_sendpage_nokey,</span>
<span class="p_add">+	.recvmsg	=	skcipher_recvmsg_nokey,</span>
<span class="p_add">+	.poll		=	skcipher_poll,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void *skcipher_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	return crypto_alloc_skcipher(name, type, mask);</span>
<span class="p_add">+	struct skcipher_tfm *tfm;</span>
<span class="p_add">+	struct crypto_skcipher *skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_add">+	if (!tfm)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	skcipher = crypto_alloc_skcipher(name, type, mask);</span>
<span class="p_add">+	if (IS_ERR(skcipher)) {</span>
<span class="p_add">+		kfree(tfm);</span>
<span class="p_add">+		return ERR_CAST(skcipher);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tfm-&gt;skcipher = skcipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm;</span>
 }
 
 static void skcipher_release(void *private)
 {
<span class="p_del">-	crypto_free_skcipher(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	crypto_free_skcipher(tfm-&gt;skcipher);</span>
<span class="p_add">+	kfree(tfm);</span>
 }
 
 static int skcipher_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	return crypto_skcipher_setkey(private, key, keylen);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = crypto_skcipher_setkey(tfm-&gt;skcipher, key, keylen);</span>
<span class="p_add">+	tfm-&gt;has_key = !err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static void skcipher_wait(struct sock *sk)
<span class="p_chunk">@@ -788,24 +917,26 @@</span> <span class="p_context"> static void skcipher_sock_destruct(struct sock *sk)</span>
 	af_alg_release_parent(sk);
 }
 
<span class="p_del">-static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+static int skcipher_accept_parent_nokey(void *private, struct sock *sk)</span>
 {
 	struct skcipher_ctx *ctx;
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(private);</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_skcipher *skcipher = tfm-&gt;skcipher;</span>
<span class="p_add">+	unsigned int len = sizeof(*ctx) + crypto_skcipher_reqsize(skcipher);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
 		return -ENOMEM;
 
<span class="p_del">-	ctx-&gt;iv = sock_kmalloc(sk, crypto_skcipher_ivsize(private),</span>
<span class="p_add">+	ctx-&gt;iv = sock_kmalloc(sk, crypto_skcipher_ivsize(skcipher),</span>
 			       GFP_KERNEL);
 	if (!ctx-&gt;iv) {
 		sock_kfree_s(sk, ctx, len);
 		return -ENOMEM;
 	}
 
<span class="p_del">-	memset(ctx-&gt;iv, 0, crypto_skcipher_ivsize(private));</span>
<span class="p_add">+	memset(ctx-&gt;iv, 0, crypto_skcipher_ivsize(skcipher));</span>
 
 	INIT_LIST_HEAD(&amp;ctx-&gt;tsgl);
 	ctx-&gt;len = len;
<span class="p_chunk">@@ -818,8 +949,9 @@</span> <span class="p_context"> static int skcipher_accept_parent(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	skcipher_request_set_tfm(&amp;ctx-&gt;req, private);</span>
<span class="p_del">-	skcipher_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,</span>
<span class="p_add">+	skcipher_request_set_tfm(&amp;ctx-&gt;req, skcipher);</span>
<span class="p_add">+	skcipher_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_SLEEP |</span>
<span class="p_add">+						 CRYPTO_TFM_REQ_MAY_BACKLOG,</span>
 				      af_alg_complete, &amp;ctx-&gt;completion);
 
 	sk-&gt;sk_destruct = skcipher_sock_destruct;
<span class="p_chunk">@@ -827,12 +959,24 @@</span> <span class="p_context"> static int skcipher_accept_parent(void *private, struct sock *sk)</span>
 	return 0;
 }
 
<span class="p_add">+static int skcipher_accept_parent(void *private, struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct skcipher_tfm *tfm = private;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tfm-&gt;has_key &amp;&amp; crypto_skcipher_has_setkey(tfm-&gt;skcipher))</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skcipher_accept_parent_nokey(private, sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct af_alg_type algif_type_skcipher = {
 	.bind		=	skcipher_bind,
 	.release	=	skcipher_release,
 	.setkey		=	skcipher_setkey,
 	.accept		=	skcipher_accept_parent,
<span class="p_add">+	.accept_nokey	=	skcipher_accept_parent_nokey,</span>
 	.ops		=	&amp;algif_skcipher_ops,
<span class="p_add">+	.ops_nokey	=	&amp;algif_skcipher_ops_nokey,</span>
 	.name		=	&quot;skcipher&quot;,
 	.owner		=	THIS_MODULE
 };
<span class="p_header">diff --git a/crypto/crc32c_generic.c b/crypto/crc32c_generic.c</span>
<span class="p_header">index 06f1b60f02b2..4c0a0e271876 100644</span>
<span class="p_header">--- a/crypto/crc32c_generic.c</span>
<span class="p_header">+++ b/crypto/crc32c_generic.c</span>
<span class="p_chunk">@@ -172,4 +172,3 @@</span> <span class="p_context"> MODULE_DESCRIPTION(&quot;CRC32c (Castagnoli) calculations wrapper for lib/crc32c&quot;);</span>
 MODULE_LICENSE(&quot;GPL&quot;);
 MODULE_ALIAS_CRYPTO(&quot;crc32c&quot;);
 MODULE_ALIAS_CRYPTO(&quot;crc32c-generic&quot;);
<span class="p_del">-MODULE_SOFTDEP(&quot;pre: crc32c&quot;);</span>
<span class="p_header">diff --git a/crypto/crypto_user.c b/crypto/crypto_user.c</span>
<span class="p_header">index 237f3795cfaa..43fe85f20d57 100644</span>
<span class="p_header">--- a/crypto/crypto_user.c</span>
<span class="p_header">+++ b/crypto/crypto_user.c</span>
<span class="p_chunk">@@ -499,6 +499,7 @@</span> <span class="p_context"> static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 		if (link-&gt;dump == NULL)
 			return -EINVAL;
 
<span class="p_add">+		down_read(&amp;crypto_alg_sem);</span>
 		list_for_each_entry(alg, &amp;crypto_alg_list, cra_list)
 			dump_alloc += CRYPTO_REPORT_MAXSIZE;
 
<span class="p_chunk">@@ -508,8 +509,11 @@</span> <span class="p_context"> static int crypto_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 				.done = link-&gt;done,
 				.min_dump_alloc = dump_alloc,
 			};
<span class="p_del">-			return netlink_dump_start(crypto_nlsk, skb, nlh, &amp;c);</span>
<span class="p_add">+			err = netlink_dump_start(crypto_nlsk, skb, nlh, &amp;c);</span>
 		}
<span class="p_add">+		up_read(&amp;crypto_alg_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+		return err;</span>
 	}
 
 	err = nlmsg_parse(nlh, crypto_msg_min[type], attrs, CRYPTOCFGA_MAX,
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index ecb1e3d39bf0..359754591653 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -354,9 +354,10 @@</span> <span class="p_context"> int crypto_init_shash_ops_async(struct crypto_tfm *tfm)</span>
 	crt-&gt;final = shash_async_final;
 	crt-&gt;finup = shash_async_finup;
 	crt-&gt;digest = shash_async_digest;
<span class="p_add">+	crt-&gt;setkey = shash_async_setkey;</span>
<span class="p_add">+</span>
<span class="p_add">+	crt-&gt;has_setkey = alg-&gt;setkey != shash_no_setkey;</span>
 
<span class="p_del">-	if (alg-&gt;setkey)</span>
<span class="p_del">-		crt-&gt;setkey = shash_async_setkey;</span>
 	if (alg-&gt;export)
 		crt-&gt;export = shash_async_export;
 	if (alg-&gt;import)
<span class="p_header">diff --git a/crypto/skcipher.c b/crypto/skcipher.c</span>
<span class="p_header">index 7591928be7ca..d199c0b1751c 100644</span>
<span class="p_header">--- a/crypto/skcipher.c</span>
<span class="p_header">+++ b/crypto/skcipher.c</span>
<span class="p_chunk">@@ -118,6 +118,7 @@</span> <span class="p_context"> static int crypto_init_skcipher_ops_blkcipher(struct crypto_tfm *tfm)</span>
 	skcipher-&gt;decrypt = skcipher_decrypt_blkcipher;
 
 	skcipher-&gt;ivsize = crypto_blkcipher_ivsize(blkcipher);
<span class="p_add">+	skcipher-&gt;has_setkey = calg-&gt;cra_blkcipher.max_keysize;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -210,6 +211,7 @@</span> <span class="p_context"> static int crypto_init_skcipher_ops_ablkcipher(struct crypto_tfm *tfm)</span>
 	skcipher-&gt;ivsize = crypto_ablkcipher_ivsize(ablkcipher);
 	skcipher-&gt;reqsize = crypto_ablkcipher_reqsize(ablkcipher) +
 			    sizeof(struct ablkcipher_request);
<span class="p_add">+	skcipher-&gt;has_setkey = calg-&gt;cra_ablkcipher.max_keysize;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index cdfbcc54821f..99921aa0daca 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -264,6 +264,26 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x3b2b), board_ahci }, /* PCH RAID */
 	{ PCI_VDEVICE(INTEL, 0x3b2c), board_ahci }, /* PCH RAID */
 	{ PCI_VDEVICE(INTEL, 0x3b2f), board_ahci }, /* PCH AHCI */
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b0), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b1), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b2), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b3), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b4), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b5), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b6), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19b7), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19bE), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19bF), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c0), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c1), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c2), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c3), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c4), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c5), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c6), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19c7), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19cE), board_ahci }, /* DNV AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x19cF), board_ahci }, /* DNV AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0x1c02), board_ahci }, /* CPT AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c03), board_ahci }, /* CPT AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c04), board_ahci }, /* CPT RAID */
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index 4665512dae44..1f225cc1827f 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -495,8 +495,8 @@</span> <span class="p_context"> void ahci_save_initial_config(struct device *dev, struct ahci_host_priv *hpriv)</span>
 		}
 	}
 
<span class="p_del">-	/* fabricate port_map from cap.nr_ports */</span>
<span class="p_del">-	if (!port_map) {</span>
<span class="p_add">+	/* fabricate port_map from cap.nr_ports for &lt; AHCI 1.3 */</span>
<span class="p_add">+	if (!port_map &amp;&amp; vers &lt; 0x10300) {</span>
 		port_map = (1 &lt;&lt; ahci_nr_ports(cap)) - 1;
 		dev_warn(dev, &quot;forcing PORTS_IMPL to 0x%x\n&quot;, port_map);
 
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index 1dd6d3bf1098..176b59f5bc47 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -513,10 +513,15 @@</span> <span class="p_context"> static int platform_drv_probe(struct device *_dev)</span>
 		return ret;
 
 	ret = dev_pm_domain_attach(_dev, true);
<span class="p_del">-	if (ret != -EPROBE_DEFER &amp;&amp; drv-&gt;probe) {</span>
<span class="p_del">-		ret = drv-&gt;probe(dev);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			dev_pm_domain_detach(_dev, true);</span>
<span class="p_add">+	if (ret != -EPROBE_DEFER) {</span>
<span class="p_add">+		if (drv-&gt;probe) {</span>
<span class="p_add">+			ret = drv-&gt;probe(dev);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				dev_pm_domain_detach(_dev, true);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* don&#39;t fail if just dev_pm_domain_attach failed */</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
 	}
 
 	if (drv-&gt;prevent_deferred_probe &amp;&amp; ret == -EPROBE_DEFER) {
<span class="p_header">diff --git a/drivers/block/zram/zcomp.c b/drivers/block/zram/zcomp.c</span>
<span class="p_header">index 5cb13ca3a3ac..c53617752b93 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp.c</span>
<span class="p_chunk">@@ -76,7 +76,7 @@</span> <span class="p_context"> static void zcomp_strm_free(struct zcomp *comp, struct zcomp_strm *zstrm)</span>
  */
 static struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)
 {
<span class="p_del">-	struct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_KERNEL);</span>
<span class="p_add">+	struct zcomp_strm *zstrm = kmalloc(sizeof(*zstrm), GFP_NOIO);</span>
 	if (!zstrm)
 		return NULL;
 
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static struct zcomp_strm *zcomp_strm_alloc(struct zcomp *comp)</span>
 	 * allocate 2 pages. 1 for compressed data, plus 1 extra for the
 	 * case when compressed size is larger than the original one
 	 */
<span class="p_del">-	zstrm-&gt;buffer = (void *)__get_free_pages(GFP_KERNEL | __GFP_ZERO, 1);</span>
<span class="p_add">+	zstrm-&gt;buffer = (void *)__get_free_pages(GFP_NOIO | __GFP_ZERO, 1);</span>
 	if (!zstrm-&gt;private || !zstrm-&gt;buffer) {
 		zcomp_strm_free(comp, zstrm);
 		zstrm = NULL;
<span class="p_header">diff --git a/drivers/block/zram/zcomp_lz4.c b/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_header">index f2afb7e988c3..dd6083124276 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp_lz4.c</span>
<span class="p_chunk">@@ -10,17 +10,36 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/lz4.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &quot;zcomp_lz4.h&quot;
 
 static void *zcomp_lz4_create(void)
 {
<span class="p_del">-	return kzalloc(LZ4_MEM_COMPRESS, GFP_KERNEL);</span>
<span class="p_add">+	void *ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This function can be called in swapout/fs write path</span>
<span class="p_add">+	 * so we can&#39;t use GFP_FS|IO. And it assumes we already</span>
<span class="p_add">+	 * have at least one stream in zram initialization so we</span>
<span class="p_add">+	 * don&#39;t do best effort to allocate more stream in here.</span>
<span class="p_add">+	 * A default stream will work well without further multiple</span>
<span class="p_add">+	 * streams. That&#39;s why we use NORETRY | NOWARN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = kzalloc(LZ4_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span>
<span class="p_add">+					__GFP_NOWARN);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = __vmalloc(LZ4_MEM_COMPRESS,</span>
<span class="p_add">+				GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span>
<span class="p_add">+				__GFP_ZERO | __GFP_HIGHMEM,</span>
<span class="p_add">+				PAGE_KERNEL);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void zcomp_lz4_destroy(void *private)
 {
<span class="p_del">-	kfree(private);</span>
<span class="p_add">+	kvfree(private);</span>
 }
 
 static int zcomp_lz4_compress(const unsigned char *src, unsigned char *dst,
<span class="p_header">diff --git a/drivers/block/zram/zcomp_lzo.c b/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_header">index da1bc47d588e..edc549920fa0 100644</span>
<span class="p_header">--- a/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_header">+++ b/drivers/block/zram/zcomp_lzo.c</span>
<span class="p_chunk">@@ -10,17 +10,36 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/lzo.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &quot;zcomp_lzo.h&quot;
 
 static void *lzo_create(void)
 {
<span class="p_del">-	return kzalloc(LZO1X_MEM_COMPRESS, GFP_KERNEL);</span>
<span class="p_add">+	void *ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This function can be called in swapout/fs write path</span>
<span class="p_add">+	 * so we can&#39;t use GFP_FS|IO. And it assumes we already</span>
<span class="p_add">+	 * have at least one stream in zram initialization so we</span>
<span class="p_add">+	 * don&#39;t do best effort to allocate more stream in here.</span>
<span class="p_add">+	 * A default stream will work well without further multiple</span>
<span class="p_add">+	 * streams. That&#39;s why we use NORETRY | NOWARN.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = kzalloc(LZO1X_MEM_COMPRESS, GFP_NOIO | __GFP_NORETRY |</span>
<span class="p_add">+					__GFP_NOWARN);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = __vmalloc(LZO1X_MEM_COMPRESS,</span>
<span class="p_add">+				GFP_NOIO | __GFP_NORETRY | __GFP_NOWARN |</span>
<span class="p_add">+				__GFP_ZERO | __GFP_HIGHMEM,</span>
<span class="p_add">+				PAGE_KERNEL);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void lzo_destroy(void *private)
 {
<span class="p_del">-	kfree(private);</span>
<span class="p_add">+	kvfree(private);</span>
 }
 
 static int lzo_compress(const unsigned char *src, unsigned char *dst,
<span class="p_header">diff --git a/drivers/block/zram/zram_drv.c b/drivers/block/zram/zram_drv.c</span>
<span class="p_header">index 47915d736f8d..370c2f76016d 100644</span>
<span class="p_header">--- a/drivers/block/zram/zram_drv.c</span>
<span class="p_header">+++ b/drivers/block/zram/zram_drv.c</span>
<span class="p_chunk">@@ -1325,7 +1325,6 @@</span> <span class="p_context"> static int zram_remove(struct zram *zram)</span>
 
 	pr_info(&quot;Removed device: %s\n&quot;, zram-&gt;disk-&gt;disk_name);
 
<span class="p_del">-	idr_remove(&amp;zram_index_idr, zram-&gt;disk-&gt;first_minor);</span>
 	blk_cleanup_queue(zram-&gt;disk-&gt;queue);
 	del_gendisk(zram-&gt;disk);
 	put_disk(zram-&gt;disk);
<span class="p_chunk">@@ -1367,10 +1366,12 @@</span> <span class="p_context"> static ssize_t hot_remove_store(struct class *class,</span>
 	mutex_lock(&amp;zram_index_mutex);
 
 	zram = idr_find(&amp;zram_index_idr, dev_id);
<span class="p_del">-	if (zram)</span>
<span class="p_add">+	if (zram) {</span>
 		ret = zram_remove(zram);
<span class="p_del">-	else</span>
<span class="p_add">+		idr_remove(&amp;zram_index_idr, dev_id);</span>
<span class="p_add">+	} else {</span>
 		ret = -ENODEV;
<span class="p_add">+	}</span>
 
 	mutex_unlock(&amp;zram_index_mutex);
 	return ret ? ret : count;
<span class="p_header">diff --git a/drivers/crypto/atmel-sha.c b/drivers/crypto/atmel-sha.c</span>
<span class="p_header">index 660d8c06540b..3178f84d2757 100644</span>
<span class="p_header">--- a/drivers/crypto/atmel-sha.c</span>
<span class="p_header">+++ b/drivers/crypto/atmel-sha.c</span>
<span class="p_chunk">@@ -783,7 +783,7 @@</span> <span class="p_context"> static void atmel_sha_finish_req(struct ahash_request *req, int err)</span>
 	dd-&gt;flags &amp;= ~(SHA_FLAGS_BUSY | SHA_FLAGS_FINAL | SHA_FLAGS_CPU |
 			SHA_FLAGS_DMA_READY | SHA_FLAGS_OUTPUT_READY);
 
<span class="p_del">-	clk_disable_unprepare(dd-&gt;iclk);</span>
<span class="p_add">+	clk_disable(dd-&gt;iclk);</span>
 
 	if (req-&gt;base.complete)
 		req-&gt;base.complete(&amp;req-&gt;base, err);
<span class="p_chunk">@@ -796,7 +796,7 @@</span> <span class="p_context"> static int atmel_sha_hw_init(struct atmel_sha_dev *dd)</span>
 {
 	int err;
 
<span class="p_del">-	err = clk_prepare_enable(dd-&gt;iclk);</span>
<span class="p_add">+	err = clk_enable(dd-&gt;iclk);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -823,7 +823,7 @@</span> <span class="p_context"> static void atmel_sha_hw_version_init(struct atmel_sha_dev *dd)</span>
 	dev_info(dd-&gt;dev,
 			&quot;version: 0x%x\n&quot;, dd-&gt;hw_version);
 
<span class="p_del">-	clk_disable_unprepare(dd-&gt;iclk);</span>
<span class="p_add">+	clk_disable(dd-&gt;iclk);</span>
 }
 
 static int atmel_sha_handle_queue(struct atmel_sha_dev *dd,
<span class="p_chunk">@@ -1411,6 +1411,10 @@</span> <span class="p_context"> static int atmel_sha_probe(struct platform_device *pdev)</span>
 		goto res_err;
 	}
 
<span class="p_add">+	err = clk_prepare(sha_dd-&gt;iclk);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto res_err;</span>
<span class="p_add">+</span>
 	atmel_sha_hw_version_init(sha_dd);
 
 	atmel_sha_get_cap(sha_dd);
<span class="p_chunk">@@ -1422,12 +1426,12 @@</span> <span class="p_context"> static int atmel_sha_probe(struct platform_device *pdev)</span>
 			if (IS_ERR(pdata)) {
 				dev_err(&amp;pdev-&gt;dev, &quot;platform data not available\n&quot;);
 				err = PTR_ERR(pdata);
<span class="p_del">-				goto res_err;</span>
<span class="p_add">+				goto iclk_unprepare;</span>
 			}
 		}
 		if (!pdata-&gt;dma_slave) {
 			err = -ENXIO;
<span class="p_del">-			goto res_err;</span>
<span class="p_add">+			goto iclk_unprepare;</span>
 		}
 		err = atmel_sha_dma_init(sha_dd, pdata);
 		if (err)
<span class="p_chunk">@@ -1458,6 +1462,8 @@</span> <span class="p_context"> err_algs:</span>
 	if (sha_dd-&gt;caps.has_dma)
 		atmel_sha_dma_cleanup(sha_dd);
 err_sha_dma:
<span class="p_add">+iclk_unprepare:</span>
<span class="p_add">+	clk_unprepare(sha_dd-&gt;iclk);</span>
 res_err:
 	tasklet_kill(&amp;sha_dd-&gt;done_task);
 sha_dd_err:
<span class="p_chunk">@@ -1484,12 +1490,7 @@</span> <span class="p_context"> static int atmel_sha_remove(struct platform_device *pdev)</span>
 	if (sha_dd-&gt;caps.has_dma)
 		atmel_sha_dma_cleanup(sha_dd);
 
<span class="p_del">-	iounmap(sha_dd-&gt;io_base);</span>
<span class="p_del">-</span>
<span class="p_del">-	clk_put(sha_dd-&gt;iclk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (sha_dd-&gt;irq &gt;= 0)</span>
<span class="p_del">-		free_irq(sha_dd-&gt;irq, sha_dd);</span>
<span class="p_add">+	clk_unprepare(sha_dd-&gt;iclk);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">index 8abb4bc548cc..69d4a1326fee 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/ctrl.c</span>
<span class="p_chunk">@@ -534,8 +534,8 @@</span> <span class="p_context"> static int caam_probe(struct platform_device *pdev)</span>
 	 * long pointers in master configuration register
 	 */
 	clrsetbits_32(&amp;ctrl-&gt;mcr, MCFGR_AWCACHE_MASK, MCFGR_AWCACHE_CACH |
<span class="p_del">-		      MCFGR_WDENABLE | (sizeof(dma_addr_t) == sizeof(u64) ?</span>
<span class="p_del">-					MCFGR_LONG_PTR : 0));</span>
<span class="p_add">+		      MCFGR_AWCACHE_BUFF | MCFGR_WDENABLE |</span>
<span class="p_add">+		      (sizeof(dma_addr_t) == sizeof(u64) ? MCFGR_LONG_PTR : 0));</span>
 
 	/*
 	 *  Read the Compile Time paramters and SCFGR to determine
<span class="p_header">diff --git a/drivers/crypto/marvell/cesa.c b/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">index 0643e3366e33..c0656e7f37b5 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/cesa.c</span>
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static int mv_cesa_dev_dma_init(struct mv_cesa_dev *cesa)</span>
 		return -ENOMEM;
 
 	dma-&gt;padding_pool = dmam_pool_create(&quot;cesa_padding&quot;, dev, 72, 1, 0);
<span class="p_del">-	if (!dma-&gt;cache_pool)</span>
<span class="p_add">+	if (!dma-&gt;padding_pool)</span>
 		return -ENOMEM;
 
 	cesa-&gt;dma = dma;
<span class="p_header">diff --git a/drivers/crypto/sunxi-ss/sun4i-ss-core.c b/drivers/crypto/sunxi-ss/sun4i-ss-core.c</span>
<span class="p_header">index eab6fe227fa0..107cd2a41cae 100644</span>
<span class="p_header">--- a/drivers/crypto/sunxi-ss/sun4i-ss-core.c</span>
<span class="p_header">+++ b/drivers/crypto/sunxi-ss/sun4i-ss-core.c</span>
<span class="p_chunk">@@ -39,6 +39,7 @@</span> <span class="p_context"> static struct sun4i_ss_alg_template ss_algs[] = {</span>
 		.import = sun4i_hash_import_md5,
 		.halg = {
 			.digestsize = MD5_DIGEST_SIZE,
<span class="p_add">+			.statesize = sizeof(struct md5_state),</span>
 			.base = {
 				.cra_name = &quot;md5&quot;,
 				.cra_driver_name = &quot;md5-sun4i-ss&quot;,
<span class="p_chunk">@@ -66,6 +67,7 @@</span> <span class="p_context"> static struct sun4i_ss_alg_template ss_algs[] = {</span>
 		.import = sun4i_hash_import_sha1,
 		.halg = {
 			.digestsize = SHA1_DIGEST_SIZE,
<span class="p_add">+			.statesize = sizeof(struct sha1_state),</span>
 			.base = {
 				.cra_name = &quot;sha1&quot;,
 				.cra_driver_name = &quot;sha1-sun4i-ss&quot;,
<span class="p_header">diff --git a/drivers/hid/hid-multitouch.c b/drivers/hid/hid-multitouch.c</span>
<span class="p_header">index 3d664d01305e..2b8ff18d3713 100644</span>
<span class="p_header">--- a/drivers/hid/hid-multitouch.c</span>
<span class="p_header">+++ b/drivers/hid/hid-multitouch.c</span>
<span class="p_chunk">@@ -357,8 +357,19 @@</span> <span class="p_context"> static void mt_feature_mapping(struct hid_device *hdev,</span>
 			break;
 		}
 
<span class="p_del">-		td-&gt;inputmode = field-&gt;report-&gt;id;</span>
<span class="p_del">-		td-&gt;inputmode_index = usage-&gt;usage_index;</span>
<span class="p_add">+		if (td-&gt;inputmode &lt; 0) {</span>
<span class="p_add">+			td-&gt;inputmode = field-&gt;report-&gt;id;</span>
<span class="p_add">+			td-&gt;inputmode_index = usage-&gt;usage_index;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Some elan panels wrongly declare 2 input mode</span>
<span class="p_add">+			 * features, and silently ignore when we set the</span>
<span class="p_add">+			 * value in the second field. Skip the second feature</span>
<span class="p_add">+			 * and hope for the best.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dev_info(&amp;hdev-&gt;dev,</span>
<span class="p_add">+				 &quot;Ignoring the extra HID_DG_INPUTMODE\n&quot;);</span>
<span class="p_add">+		}</span>
 
 		break;
 	case HID_DG_CONTACTMAX:
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">index 36712e9f56c2..5dd426fee8cc 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_chunk">@@ -477,8 +477,6 @@</span> <span class="p_context"> static void hid_ctrl(struct urb *urb)</span>
 	struct usbhid_device *usbhid = hid-&gt;driver_data;
 	int unplug = 0, status = urb-&gt;status;
 
<span class="p_del">-	spin_lock(&amp;usbhid-&gt;lock);</span>
<span class="p_del">-</span>
 	switch (status) {
 	case 0:			/* success */
 		if (usbhid-&gt;ctrl[usbhid-&gt;ctrltail].dir == USB_DIR_IN)
<span class="p_chunk">@@ -498,6 +496,8 @@</span> <span class="p_context"> static void hid_ctrl(struct urb *urb)</span>
 		hid_warn(urb-&gt;dev, &quot;ctrl urb status %d received\n&quot;, status);
 	}
 
<span class="p_add">+	spin_lock(&amp;usbhid-&gt;lock);</span>
<span class="p_add">+</span>
 	if (unplug) {
 		usbhid-&gt;ctrltail = usbhid-&gt;ctrlhead;
 	} else {
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">index 7df97777662d..dad768caa9c5 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_chunk">@@ -405,17 +405,18 @@</span> <span class="p_context"> static void __arm_lpae_free_pgtable(struct arm_lpae_io_pgtable *data, int lvl,</span>
 	arm_lpae_iopte *start, *end;
 	unsigned long table_size;
 
<span class="p_del">-	/* Only leaf entries at the last level */</span>
<span class="p_del">-	if (lvl == ARM_LPAE_MAX_LEVELS - 1)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	if (lvl == ARM_LPAE_START_LVL(data))
 		table_size = data-&gt;pgd_size;
 	else
 		table_size = 1UL &lt;&lt; data-&gt;pg_shift;
 
 	start = ptep;
<span class="p_del">-	end = (void *)ptep + table_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only leaf entries at the last level */</span>
<span class="p_add">+	if (lvl == ARM_LPAE_MAX_LEVELS - 1)</span>
<span class="p_add">+		end = ptep;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		end = (void *)ptep + table_size;</span>
 
 	while (ptep != end) {
 		arm_lpae_iopte pte = *ptep++;
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 61aacab424cf..b1e1f6b95782 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -2017,28 +2017,32 @@</span> <span class="p_context"> int md_integrity_register(struct mddev *mddev)</span>
 }
 EXPORT_SYMBOL(md_integrity_register);
 
<span class="p_del">-/* Disable data integrity if non-capable/non-matching disk is being added */</span>
<span class="p_del">-void md_integrity_add_rdev(struct md_rdev *rdev, struct mddev *mddev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Attempt to add an rdev, but only if it is consistent with the current</span>
<span class="p_add">+ * integrity profile</span>
<span class="p_add">+ */</span>
<span class="p_add">+int md_integrity_add_rdev(struct md_rdev *rdev, struct mddev *mddev)</span>
 {
 	struct blk_integrity *bi_rdev;
 	struct blk_integrity *bi_mddev;
<span class="p_add">+	char name[BDEVNAME_SIZE];</span>
 
 	if (!mddev-&gt;gendisk)
<span class="p_del">-		return;</span>
<span class="p_add">+		return 0;</span>
 
 	bi_rdev = bdev_get_integrity(rdev-&gt;bdev);
 	bi_mddev = blk_get_integrity(mddev-&gt;gendisk);
 
 	if (!bi_mddev) /* nothing to do */
<span class="p_del">-		return;</span>
<span class="p_del">-	if (rdev-&gt;raid_disk &lt; 0) /* skip spares */</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (bi_rdev &amp;&amp; blk_integrity_compare(mddev-&gt;gendisk,</span>
<span class="p_del">-					     rdev-&gt;bdev-&gt;bd_disk) &gt;= 0)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	WARN_ON_ONCE(!mddev-&gt;suspended);</span>
<span class="p_del">-	printk(KERN_NOTICE &quot;disabling data integrity on %s\n&quot;, mdname(mddev));</span>
<span class="p_del">-	blk_integrity_unregister(mddev-&gt;gendisk);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (blk_integrity_compare(mddev-&gt;gendisk, rdev-&gt;bdev-&gt;bd_disk) != 0) {</span>
<span class="p_add">+		printk(KERN_NOTICE &quot;%s: incompatible integrity profile for %s\n&quot;,</span>
<span class="p_add">+				mdname(mddev), bdevname(rdev-&gt;bdev, name));</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL(md_integrity_add_rdev);
 
<span class="p_header">diff --git a/drivers/md/md.h b/drivers/md/md.h</span>
<span class="p_header">index ca0b643fe3c1..dfa57b41541b 100644</span>
<span class="p_header">--- a/drivers/md/md.h</span>
<span class="p_header">+++ b/drivers/md/md.h</span>
<span class="p_chunk">@@ -657,7 +657,7 @@</span> <span class="p_context"> extern void md_wait_for_blocked_rdev(struct md_rdev *rdev, struct mddev *mddev);</span>
 extern void md_set_array_sectors(struct mddev *mddev, sector_t array_sectors);
 extern int md_check_no_bitmap(struct mddev *mddev);
 extern int md_integrity_register(struct mddev *mddev);
<span class="p_del">-extern void md_integrity_add_rdev(struct md_rdev *rdev, struct mddev *mddev);</span>
<span class="p_add">+extern int md_integrity_add_rdev(struct md_rdev *rdev, struct mddev *mddev);</span>
 extern int strict_strtoul_scaled(const char *cp, unsigned long *res, int scale);
 
 extern void mddev_init(struct mddev *mddev);
<span class="p_header">diff --git a/drivers/md/multipath.c b/drivers/md/multipath.c</span>
<span class="p_header">index 7331a80d89f1..0a72ab6e6c20 100644</span>
<span class="p_header">--- a/drivers/md/multipath.c</span>
<span class="p_header">+++ b/drivers/md/multipath.c</span>
<span class="p_chunk">@@ -257,6 +257,9 @@</span> <span class="p_context"> static int multipath_add_disk(struct mddev *mddev, struct md_rdev *rdev)</span>
 			disk_stack_limits(mddev-&gt;gendisk, rdev-&gt;bdev,
 					  rdev-&gt;data_offset &lt;&lt; 9);
 
<span class="p_add">+			err = md_integrity_add_rdev(rdev, mddev);</span>
<span class="p_add">+			if (err)</span>
<span class="p_add">+				break;</span>
 			spin_lock_irq(&amp;conf-&gt;device_lock);
 			mddev-&gt;degraded--;
 			rdev-&gt;raid_disk = path;
<span class="p_chunk">@@ -264,9 +267,6 @@</span> <span class="p_context"> static int multipath_add_disk(struct mddev *mddev, struct md_rdev *rdev)</span>
 			spin_unlock_irq(&amp;conf-&gt;device_lock);
 			rcu_assign_pointer(p-&gt;rdev, rdev);
 			err = 0;
<span class="p_del">-			mddev_suspend(mddev);</span>
<span class="p_del">-			md_integrity_add_rdev(rdev, mddev);</span>
<span class="p_del">-			mddev_resume(mddev);</span>
 			break;
 		}
 
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index e2169ff6e0f0..c4b913409226 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -1589,6 +1589,9 @@</span> <span class="p_context"> static int raid1_add_disk(struct mddev *mddev, struct md_rdev *rdev)</span>
 	if (mddev-&gt;recovery_disabled == conf-&gt;recovery_disabled)
 		return -EBUSY;
 
<span class="p_add">+	if (md_integrity_add_rdev(rdev, mddev))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
 	if (rdev-&gt;raid_disk &gt;= 0)
 		first = last = rdev-&gt;raid_disk;
 
<span class="p_chunk">@@ -1632,9 +1635,6 @@</span> <span class="p_context"> static int raid1_add_disk(struct mddev *mddev, struct md_rdev *rdev)</span>
 			break;
 		}
 	}
<span class="p_del">-	mddev_suspend(mddev);</span>
<span class="p_del">-	md_integrity_add_rdev(rdev, mddev);</span>
<span class="p_del">-	mddev_resume(mddev);</span>
 	if (mddev-&gt;queue &amp;&amp; blk_queue_discard(bdev_get_queue(rdev-&gt;bdev)))
 		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, mddev-&gt;queue);
 	print_conf(conf);
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 84e597e1c489..ce959b4ae4df 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -1698,6 +1698,9 @@</span> <span class="p_context"> static int raid10_add_disk(struct mddev *mddev, struct md_rdev *rdev)</span>
 	if (rdev-&gt;saved_raid_disk &lt; 0 &amp;&amp; !_enough(conf, 1, -1))
 		return -EINVAL;
 
<span class="p_add">+	if (md_integrity_add_rdev(rdev, mddev))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
 	if (rdev-&gt;raid_disk &gt;= 0)
 		first = last = rdev-&gt;raid_disk;
 
<span class="p_chunk">@@ -1739,9 +1742,6 @@</span> <span class="p_context"> static int raid10_add_disk(struct mddev *mddev, struct md_rdev *rdev)</span>
 		rcu_assign_pointer(p-&gt;rdev, rdev);
 		break;
 	}
<span class="p_del">-	mddev_suspend(mddev);</span>
<span class="p_del">-	md_integrity_add_rdev(rdev, mddev);</span>
<span class="p_del">-	mddev_resume(mddev);</span>
 	if (mddev-&gt;queue &amp;&amp; blk_queue_discard(bdev_get_queue(rdev-&gt;bdev)))
 		queue_flag_set_unlocked(QUEUE_FLAG_DISCARD, mddev-&gt;queue);
 
<span class="p_header">diff --git a/drivers/media/i2c/ir-kbd-i2c.c b/drivers/media/i2c/ir-kbd-i2c.c</span>
<span class="p_header">index 728d2cc8a3e7..175a76114953 100644</span>
<span class="p_header">--- a/drivers/media/i2c/ir-kbd-i2c.c</span>
<span class="p_header">+++ b/drivers/media/i2c/ir-kbd-i2c.c</span>
<span class="p_chunk">@@ -478,7 +478,6 @@</span> <span class="p_context"> static const struct i2c_device_id ir_kbd_id[] = {</span>
 	{ &quot;ir_rx_z8f0811_hdpvr&quot;, 0 },
 	{ }
 };
<span class="p_del">-MODULE_DEVICE_TABLE(i2c, ir_kbd_id);</span>
 
 static struct i2c_driver ir_kbd_driver = {
 	.driver = {
<span class="p_header">diff --git a/drivers/media/pci/saa7134/saa7134-alsa.c b/drivers/media/pci/saa7134/saa7134-alsa.c</span>
<span class="p_header">index 1d2c310ce838..94f816244407 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7134/saa7134-alsa.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7134/saa7134-alsa.c</span>
<span class="p_chunk">@@ -1211,6 +1211,8 @@</span> <span class="p_context"> static int alsa_device_init(struct saa7134_dev *dev)</span>
 
 static int alsa_device_exit(struct saa7134_dev *dev)
 {
<span class="p_add">+	if (!snd_saa7134_cards[dev-&gt;nr])</span>
<span class="p_add">+		return 1;</span>
 
 	snd_card_free(snd_saa7134_cards[dev-&gt;nr]);
 	snd_saa7134_cards[dev-&gt;nr] = NULL;
<span class="p_chunk">@@ -1260,7 +1262,8 @@</span> <span class="p_context"> static void saa7134_alsa_exit(void)</span>
 	int idx;
 
 	for (idx = 0; idx &lt; SNDRV_CARDS; idx++) {
<span class="p_del">-		snd_card_free(snd_saa7134_cards[idx]);</span>
<span class="p_add">+		if (snd_saa7134_cards[idx])</span>
<span class="p_add">+			snd_card_free(snd_saa7134_cards[idx]);</span>
 	}
 
 	saa7134_dmasound_init = NULL;
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index ece544efccc3..3ff583f165cd 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -3995,6 +3995,9 @@</span> <span class="p_context"> int nand_scan_ident(struct mtd_info *mtd, int maxchips,</span>
 			return ret;
 	}
 
<span class="p_add">+	if (!mtd-&gt;name &amp;&amp; mtd-&gt;dev.parent)</span>
<span class="p_add">+		mtd-&gt;name = dev_name(mtd-&gt;dev.parent);</span>
<span class="p_add">+</span>
 	/* Set the default functions */
 	nand_set_defaults(chip, chip-&gt;options &amp; NAND_BUSWIDTH_16);
 
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/regd.c b/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_header">index a62bf0a65c32..5be34118e0af 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/regd.c</span>
<span class="p_chunk">@@ -351,7 +351,6 @@</span> <span class="p_context"> static const struct ieee80211_regdomain *_rtl_regdomain_select(</span>
 	case COUNTRY_CODE_SPAIN:
 	case COUNTRY_CODE_FRANCE:
 	case COUNTRY_CODE_ISRAEL:
<span class="p_del">-	case COUNTRY_CODE_WORLD_WIDE_13:</span>
 		return &amp;rtl_regdom_12_13;
 	case COUNTRY_CODE_MKK:
 	case COUNTRY_CODE_MKK1:
<span class="p_chunk">@@ -360,6 +359,7 @@</span> <span class="p_context"> static const struct ieee80211_regdomain *_rtl_regdomain_select(</span>
 		return &amp;rtl_regdom_14_60_64;
 	case COUNTRY_CODE_GLOBAL_DOMAIN:
 		return &amp;rtl_regdom_14;
<span class="p_add">+	case COUNTRY_CODE_WORLD_WIDE_13:</span>
 	case COUNTRY_CODE_WORLD_WIDE_13_5G_ALL:
 		return &amp;rtl_regdom_12_13_5g_all;
 	default:
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/sw.c b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">index 142bdff4ed60..4159f9b14db6 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_chunk">@@ -95,8 +95,6 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 	struct rtl_hal *rtlhal = rtl_hal(rtl_priv(hw));
 
 	rtl8821ae_bt_reg_init(hw);
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
<span class="p_del">-	rtlpci-&gt;int_clear = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
 	rtlpriv-&gt;btcoexist.btc_ops = rtl_btc_get_ops_pointer();
 
 	rtlpriv-&gt;dm.dm_initialgain_enable = 1;
<span class="p_chunk">@@ -168,12 +166,15 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
 	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
<span class="p_add">+	rtlpci-&gt;int_clear = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;sw_crypto;</span>
<span class="p_add">+	rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog =</span>
<span class="p_add">+		rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog;</span>
 	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog)
 		pr_info(&quot;watchdog disabled\n&quot;);
 	rtlpriv-&gt;psc.reg_fwctrl_lps = 3;
 	rtlpriv-&gt;psc.reg_max_lps_awakeintvl = 5;
<span class="p_del">-	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;</span>
 
 	/* for ASPM, you can close aspm through
 	 * set const_support_pciaspm = 0
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/io.h b/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_header">index 0305729d0986..10cf3747694d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/io.h</span>
<span class="p_chunk">@@ -207,19 +207,23 @@</span> <span class="p_context"> static inline int __must_check wlcore_write_reg(struct wl1271 *wl, int reg,</span>
 
 static inline void wl1271_power_off(struct wl1271 *wl)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	if (!test_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags))
 		return;
 
<span class="p_del">-	ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, false);</span>
<span class="p_add">+	if (wl-&gt;if_ops-&gt;power)</span>
<span class="p_add">+		ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, false);</span>
 	if (!ret)
 		clear_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags);
 }
 
 static inline int wl1271_power_on(struct wl1271 *wl)
 {
<span class="p_del">-	int ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, true);</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (wl-&gt;if_ops-&gt;power)</span>
<span class="p_add">+		ret = wl-&gt;if_ops-&gt;power(wl-&gt;dev, true);</span>
 	if (ret == 0)
 		set_bit(WL1271_FLAG_GPIO_POWER, &amp;wl-&gt;flags);
 
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/spi.c b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">index 236b41090827..44f059f7f34e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/spi.c</span>
<span class="p_chunk">@@ -73,7 +73,10 @@</span> <span class="p_context"></span>
  */
 #define SPI_AGGR_BUFFER_SIZE (4 * PAGE_SIZE)
 
<span class="p_del">-#define WSPI_MAX_NUM_OF_CHUNKS (SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE)</span>
<span class="p_add">+/* Maximum number of SPI write chunks */</span>
<span class="p_add">+#define WSPI_MAX_NUM_OF_CHUNKS \</span>
<span class="p_add">+	((SPI_AGGR_BUFFER_SIZE / WSPI_MAX_CHUNK_SIZE) + 1)</span>
<span class="p_add">+</span>
 
 struct wl12xx_spi_glue {
 	struct device *dev;
<span class="p_chunk">@@ -268,9 +271,10 @@</span> <span class="p_context"> static int __must_check wl12xx_spi_raw_write(struct device *child, int addr,</span>
 					     void *buf, size_t len, bool fixed)
 {
 	struct wl12xx_spi_glue *glue = dev_get_drvdata(child-&gt;parent);
<span class="p_del">-	struct spi_transfer t[2 * (WSPI_MAX_NUM_OF_CHUNKS + 1)];</span>
<span class="p_add">+	/* SPI write buffers - 2 for each chunk */</span>
<span class="p_add">+	struct spi_transfer t[2 * WSPI_MAX_NUM_OF_CHUNKS];</span>
 	struct spi_message m;
<span class="p_del">-	u32 commands[WSPI_MAX_NUM_OF_CHUNKS];</span>
<span class="p_add">+	u32 commands[WSPI_MAX_NUM_OF_CHUNKS]; /* 1 command per chunk */</span>
 	u32 *cmd;
 	u32 chunk_len;
 	int i;
<span class="p_header">diff --git a/drivers/pci/bus.c b/drivers/pci/bus.c</span>
<span class="p_header">index d3346d23963b..89b3befc7155 100644</span>
<span class="p_header">--- a/drivers/pci/bus.c</span>
<span class="p_header">+++ b/drivers/pci/bus.c</span>
<span class="p_chunk">@@ -140,6 +140,8 @@</span> <span class="p_context"> static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,</span>
 	type_mask |= IORESOURCE_TYPE_BITS;
 
 	pci_bus_for_each_resource(bus, r, i) {
<span class="p_add">+		resource_size_t min_used = min;</span>
<span class="p_add">+</span>
 		if (!r)
 			continue;
 
<span class="p_chunk">@@ -163,12 +165,12 @@</span> <span class="p_context"> static int pci_bus_alloc_from_region(struct pci_bus *bus, struct resource *res,</span>
 		 * overrides &quot;min&quot;.
 		 */
 		if (avail.start)
<span class="p_del">-			min = avail.start;</span>
<span class="p_add">+			min_used = avail.start;</span>
 
 		max = avail.end;
 
 		/* Ok, try it out.. */
<span class="p_del">-		ret = allocate_resource(r, res, size, min, max,</span>
<span class="p_add">+		ret = allocate_resource(r, res, size, min_used, max,</span>
 					align, alignf, alignf_data);
 		if (ret == 0)
 			return 0;
<span class="p_header">diff --git a/drivers/pci/host/pci-dra7xx.c b/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_header">index 8c3688046c02..923607bdabc5 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-dra7xx.c</span>
<span class="p_chunk">@@ -302,7 +302,8 @@</span> <span class="p_context"> static int __init dra7xx_add_pcie_port(struct dra7xx_pcie *dra7xx,</span>
 	}
 
 	ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;irq,
<span class="p_del">-			       dra7xx_pcie_msi_irq_handler, IRQF_SHARED,</span>
<span class="p_add">+			       dra7xx_pcie_msi_irq_handler,</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
 			       &quot;dra7-pcie-msi&quot;,	pp);
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request irq\n&quot;);
<span class="p_header">diff --git a/drivers/pci/host/pci-exynos.c b/drivers/pci/host/pci-exynos.c</span>
<span class="p_header">index 01095e1160a4..d997d22d4231 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-exynos.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-exynos.c</span>
<span class="p_chunk">@@ -522,7 +522,8 @@</span> <span class="p_context"> static int __init exynos_add_pcie_port(struct pcie_port *pp,</span>
 
 		ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;msi_irq,
 					exynos_pcie_msi_irq_handler,
<span class="p_del">-					IRQF_SHARED, &quot;exynos-pcie&quot;, pp);</span>
<span class="p_add">+					IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+					&quot;exynos-pcie&quot;, pp);</span>
 		if (ret) {
 			dev_err(&amp;pdev-&gt;dev, &quot;failed to request msi irq\n&quot;);
 			return ret;
<span class="p_header">diff --git a/drivers/pci/host/pci-imx6.c b/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">index 22e8224126fd..9ce7cd148c86 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-imx6.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-imx6.c</span>
<span class="p_chunk">@@ -537,7 +537,8 @@</span> <span class="p_context"> static int __init imx6_add_pcie_port(struct pcie_port *pp,</span>
 
 		ret = devm_request_irq(&amp;pdev-&gt;dev, pp-&gt;msi_irq,
 				       imx6_pcie_msi_handler,
<span class="p_del">-				       IRQF_SHARED, &quot;mx6-pcie-msi&quot;, pp);</span>
<span class="p_add">+				       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+				       &quot;mx6-pcie-msi&quot;, pp);</span>
 		if (ret) {
 			dev_err(&amp;pdev-&gt;dev, &quot;failed to request MSI irq\n&quot;);
 			return ret;
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index 3018ae52e092..30323114c53c 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -1288,7 +1288,7 @@</span> <span class="p_context"> static int tegra_pcie_enable_msi(struct tegra_pcie *pcie)</span>
 
 	msi-&gt;irq = err;
 
<span class="p_del">-	err = request_irq(msi-&gt;irq, tegra_pcie_msi_irq, 0,</span>
<span class="p_add">+	err = request_irq(msi-&gt;irq, tegra_pcie_msi_irq, IRQF_NO_THREAD,</span>
 			  tegra_msi_irq_chip.name, pcie);
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
<span class="p_header">diff --git a/drivers/pci/host/pcie-rcar.c b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">index f4fa6c537448..414c33686621 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_chunk">@@ -720,14 +720,16 @@</span> <span class="p_context"> static int rcar_pcie_enable_msi(struct rcar_pcie *pcie)</span>
 
 	/* Two irqs are for MSI, but they are also used for non-MSI irqs */
 	err = devm_request_irq(&amp;pdev-&gt;dev, msi-&gt;irq1, rcar_pcie_msi_irq,
<span class="p_del">-			       IRQF_SHARED, rcar_msi_irq_chip.name, pcie);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       rcar_msi_irq_chip.name, pcie);</span>
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
 		goto err;
 	}
 
 	err = devm_request_irq(&amp;pdev-&gt;dev, msi-&gt;irq2, rcar_pcie_msi_irq,
<span class="p_del">-			       IRQF_SHARED, rcar_msi_irq_chip.name, pcie);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       rcar_msi_irq_chip.name, pcie);</span>
 	if (err &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request IRQ: %d\n&quot;, err);
 		goto err;
<span class="p_header">diff --git a/drivers/pci/host/pcie-spear13xx.c b/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_header">index b95b7563c052..a6cd8233e8c0 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-spear13xx.c</span>
<span class="p_chunk">@@ -279,7 +279,8 @@</span> <span class="p_context"> static int spear13xx_add_pcie_port(struct pcie_port *pp,</span>
 		return -ENODEV;
 	}
 	ret = devm_request_irq(dev, pp-&gt;irq, spear13xx_pcie_irq_handler,
<span class="p_del">-			       IRQF_SHARED, &quot;spear1340-pcie&quot;, pp);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       &quot;spear1340-pcie&quot;, pp);</span>
 	if (ret) {
 		dev_err(dev, &quot;failed to request irq %d\n&quot;, pp-&gt;irq);
 		return ret;
<span class="p_header">diff --git a/drivers/pci/host/pcie-xilinx.c b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">index 3c7a0d580b1e..4cfa46360d12 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-xilinx.c</span>
<span class="p_chunk">@@ -781,7 +781,8 @@</span> <span class="p_context"> static int xilinx_pcie_parse_dt(struct xilinx_pcie_port *port)</span>
 
 	port-&gt;irq = irq_of_parse_and_map(node, 0);
 	err = devm_request_irq(dev, port-&gt;irq, xilinx_pcie_intr_handler,
<span class="p_del">-			       IRQF_SHARED, &quot;xilinx-pcie&quot;, port);</span>
<span class="p_add">+			       IRQF_SHARED | IRQF_NO_THREAD,</span>
<span class="p_add">+			       &quot;xilinx-pcie&quot;, port);</span>
 	if (err) {
 		dev_err(dev, &quot;unable to request irq %d\n&quot;, port-&gt;irq);
 		return err;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index e49c2bce551d..cf000b331eed 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -258,16 +258,13 @@</span> <span class="p_context"> static void n_tty_check_throttle(struct tty_struct *tty)</span>
 
 static void n_tty_check_unthrottle(struct tty_struct *tty)
 {
<span class="p_del">-	if (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY &amp;&amp;</span>
<span class="p_del">-	    tty-&gt;link-&gt;ldisc-&gt;ops-&gt;write_wakeup == n_tty_write_wakeup) {</span>
<span class="p_add">+	if (tty-&gt;driver-&gt;type == TTY_DRIVER_TYPE_PTY) {</span>
 		if (chars_in_buffer(tty) &gt; TTY_THRESHOLD_UNTHROTTLE)
 			return;
 		if (!tty-&gt;count)
 			return;
 		n_tty_kick_worker(tty);
<span class="p_del">-		n_tty_write_wakeup(tty-&gt;link);</span>
<span class="p_del">-		if (waitqueue_active(&amp;tty-&gt;link-&gt;write_wait))</span>
<span class="p_del">-			wake_up_interruptible_poll(&amp;tty-&gt;link-&gt;write_wait, POLLOUT);</span>
<span class="p_add">+		tty_wakeup(tty-&gt;link);</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/tty/tty_io.c b/drivers/tty/tty_io.c</span>
<span class="p_header">index bcc8e1e8bb72..7cef54334b12 100644</span>
<span class="p_header">--- a/drivers/tty/tty_io.c</span>
<span class="p_header">+++ b/drivers/tty/tty_io.c</span>
<span class="p_chunk">@@ -1462,13 +1462,13 @@</span> <span class="p_context"> static int tty_reopen(struct tty_struct *tty)</span>
 {
 	struct tty_driver *driver = tty-&gt;driver;
 
<span class="p_del">-	if (!tty-&gt;count)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	if (driver-&gt;type == TTY_DRIVER_TYPE_PTY &amp;&amp;
 	    driver-&gt;subtype == PTY_TYPE_MASTER)
 		return -EIO;
 
<span class="p_add">+	if (!tty-&gt;count)</span>
<span class="p_add">+		return -EAGAIN;</span>
<span class="p_add">+</span>
 	if (test_bit(TTY_EXCLUSIVE, &amp;tty-&gt;flags) &amp;&amp; !capable(CAP_SYS_ADMIN))
 		return -EBUSY;
 
<span class="p_chunk">@@ -2069,7 +2069,12 @@</span> <span class="p_context"> retry_open:</span>
 
 		if (tty) {
 			mutex_unlock(&amp;tty_mutex);
<span class="p_del">-			tty_lock(tty);</span>
<span class="p_add">+			retval = tty_lock_interruptible(tty);</span>
<span class="p_add">+			if (retval) {</span>
<span class="p_add">+				if (retval == -EINTR)</span>
<span class="p_add">+					retval = -ERESTARTSYS;</span>
<span class="p_add">+				goto err_unref;</span>
<span class="p_add">+			}</span>
 			/* safe to drop the kref from tty_driver_lookup_tty() */
 			tty_kref_put(tty);
 			retval = tty_reopen(tty);
<span class="p_chunk">@@ -2087,7 +2092,11 @@</span> <span class="p_context"> retry_open:</span>
 
 	if (IS_ERR(tty)) {
 		retval = PTR_ERR(tty);
<span class="p_del">-		goto err_file;</span>
<span class="p_add">+		if (retval != -EAGAIN || signal_pending(current))</span>
<span class="p_add">+			goto err_file;</span>
<span class="p_add">+		tty_free_file(filp);</span>
<span class="p_add">+		schedule();</span>
<span class="p_add">+		goto retry_open;</span>
 	}
 
 	tty_add_file(tty, filp);
<span class="p_chunk">@@ -2156,6 +2165,7 @@</span> <span class="p_context"> retry_open:</span>
 	return 0;
 err_unlock:
 	mutex_unlock(&amp;tty_mutex);
<span class="p_add">+err_unref:</span>
 	/* after locks to avoid deadlock */
 	if (!IS_ERR_OR_NULL(driver))
 		tty_driver_kref_put(driver);
<span class="p_chunk">@@ -2653,6 +2663,28 @@</span> <span class="p_context"> static int tiocsetd(struct tty_struct *tty, int __user *p)</span>
 }
 
 /**
<span class="p_add">+ *	tiocgetd	-	get line discipline</span>
<span class="p_add">+ *	@tty: tty device</span>
<span class="p_add">+ *	@p: pointer to user data</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Retrieves the line discipline id directly from the ldisc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Locking: waits for ldisc reference (in case the line discipline</span>
<span class="p_add">+ *		is changing or the tty is being hungup)</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static int tiocgetd(struct tty_struct *tty, int __user *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct tty_ldisc *ld;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ld = tty_ldisc_ref_wait(tty);</span>
<span class="p_add">+	ret = put_user(ld-&gt;ops-&gt;num, p);</span>
<span class="p_add">+	tty_ldisc_deref(ld);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  *	send_break	-	performed time break
  *	@tty: device to break on
  *	@duration: timeout in mS
<span class="p_chunk">@@ -2878,7 +2910,7 @@</span> <span class="p_context"> long tty_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 	case TIOCGSID:
 		return tiocgsid(tty, real_tty, p);
 	case TIOCGETD:
<span class="p_del">-		return put_user(tty-&gt;ldisc-&gt;ops-&gt;num, (int __user *)p);</span>
<span class="p_add">+		return tiocgetd(tty, p);</span>
 	case TIOCSETD:
 		return tiocsetd(tty, p);
 	case TIOCVHANGUP:
<span class="p_header">diff --git a/drivers/tty/tty_mutex.c b/drivers/tty/tty_mutex.c</span>
<span class="p_header">index 0efcf713b756..d09293bc0e04 100644</span>
<span class="p_header">--- a/drivers/tty/tty_mutex.c</span>
<span class="p_header">+++ b/drivers/tty/tty_mutex.c</span>
<span class="p_chunk">@@ -22,6 +22,14 @@</span> <span class="p_context"> void __lockfunc tty_lock(struct tty_struct *tty)</span>
 }
 EXPORT_SYMBOL(tty_lock);
 
<span class="p_add">+int tty_lock_interruptible(struct tty_struct *tty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (WARN(tty-&gt;magic != TTY_MAGIC, &quot;L Bad %p\n&quot;, tty))</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	tty_kref_get(tty);</span>
<span class="p_add">+	return mutex_lock_interruptible(&amp;tty-&gt;legacy_mutex);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __lockfunc tty_unlock(struct tty_struct *tty)
 {
 	if (tty-&gt;magic != TTY_MAGIC) {
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 26ca4f910cb0..e4c70dce3e7c 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -428,7 +428,8 @@</span> <span class="p_context"> static void acm_read_bulk_callback(struct urb *urb)</span>
 		set_bit(rb-&gt;index, &amp;acm-&gt;read_urbs_free);
 		dev_dbg(&amp;acm-&gt;data-&gt;dev, &quot;%s - non-zero urb status: %d\n&quot;,
 							__func__, status);
<span class="p_del">-		return;</span>
<span class="p_add">+		if ((status != -ENOENT) || (urb-&gt;actual_length == 0))</span>
<span class="p_add">+			return;</span>
 	}
 
 	usb_mark_last_busy(acm-&gt;dev);
<span class="p_chunk">@@ -1404,6 +1405,8 @@</span> <span class="p_context"> made_compressed_probe:</span>
 				usb_sndbulkpipe(usb_dev, epwrite-&gt;bEndpointAddress),
 				NULL, acm-&gt;writesize, acm_write_bulk, snd);
 		snd-&gt;urb-&gt;transfer_flags |= URB_NO_TRANSFER_DMA_MAP;
<span class="p_add">+		if (quirks &amp; SEND_ZERO_PACKET)</span>
<span class="p_add">+			snd-&gt;urb-&gt;transfer_flags |= URB_ZERO_PACKET;</span>
 		snd-&gt;instance = acm;
 	}
 
<span class="p_chunk">@@ -1861,6 +1864,10 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
 		USB_CDC_ACM_PROTO_AT_CDMA) },
 
<span class="p_add">+	{ USB_DEVICE(0x1519, 0x0452), /* Intel 7260 modem */</span>
<span class="p_add">+	.driver_info = SEND_ZERO_PACKET,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index dd9af38e7cda..ccfaba9ab4e4 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -134,3 +134,4 @@</span> <span class="p_context"> struct acm {</span>
 #define IGNORE_DEVICE			BIT(5)
 #define QUIRK_CONTROL_LINE_STATE	BIT(6)
 #define CLEAR_HALT_CONDITIONS		BIT(7)
<span class="p_add">+#define SEND_ZERO_PACKET		BIT(8)</span>
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 8683436788c3..1560f3f3e756 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -5386,7 +5386,6 @@</span> <span class="p_context"> static int usb_reset_and_verify_device(struct usb_device *udev)</span>
 	}
 
 	bos = udev-&gt;bos;
<span class="p_del">-	udev-&gt;bos = NULL;</span>
 
 	for (i = 0; i &lt; SET_CONFIG_TRIES; ++i) {
 
<span class="p_chunk">@@ -5479,8 +5478,11 @@</span> <span class="p_context"> done:</span>
 	usb_set_usb2_hardware_lpm(udev, 1);
 	usb_unlocked_enable_lpm(udev);
 	usb_enable_ltm(udev);
<span class="p_del">-	usb_release_bos_descriptor(udev);</span>
<span class="p_del">-	udev-&gt;bos = bos;</span>
<span class="p_add">+	/* release the new BOS descriptor allocated  by hub_port_init() */</span>
<span class="p_add">+	if (udev-&gt;bos != bos) {</span>
<span class="p_add">+		usb_release_bos_descriptor(udev);</span>
<span class="p_add">+		udev-&gt;bos = bos;</span>
<span class="p_add">+	}</span>
 	return 0;
 
 re_enumerate:
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c62109091d12..c2d65206ec6c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -28,7 +28,9 @@</span> <span class="p_context"></span>
 #include &quot;xhci.h&quot;
 #include &quot;xhci-trace.h&quot;
 
<span class="p_del">-#define PORT2_SSIC_CONFIG_REG2	0x883c</span>
<span class="p_add">+#define SSIC_PORT_NUM		2</span>
<span class="p_add">+#define SSIC_PORT_CFG2		0x880c</span>
<span class="p_add">+#define SSIC_PORT_CFG2_OFFSET	0x30</span>
 #define PROG_DONE		(1 &lt;&lt; 30)
 #define SSIC_PORT_UNUSED	(1 &lt;&lt; 31)
 
<span class="p_chunk">@@ -45,6 +47,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -152,7 +155,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
<span class="p_del">-		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI)) {</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
<span class="p_chunk">@@ -322,28 +326,36 @@</span> <span class="p_context"> static void xhci_pme_quirk(struct usb_hcd *hcd, bool suspend)</span>
 	struct pci_dev		*pdev = to_pci_dev(hcd-&gt;self.controller);
 	u32 val;
 	void __iomem *reg;
<span class="p_add">+	int i;</span>
 
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
 
<span class="p_del">-		reg = (void __iomem *) xhci-&gt;cap_regs + PORT2_SSIC_CONFIG_REG2;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Notify SSIC that SSIC profile programming is not done */</span>
<span class="p_del">-		val = readl(reg) &amp; ~PROG_DONE;</span>
<span class="p_del">-		writel(val, reg);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Mark SSIC port as unused(suspend) or used(resume) */</span>
<span class="p_del">-		val = readl(reg);</span>
<span class="p_del">-		if (suspend)</span>
<span class="p_del">-			val |= SSIC_PORT_UNUSED;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			val &amp;= ~SSIC_PORT_UNUSED;</span>
<span class="p_del">-		writel(val, reg);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Notify SSIC that SSIC profile programming is done */</span>
<span class="p_del">-		val = readl(reg) | PROG_DONE;</span>
<span class="p_del">-		writel(val, reg);</span>
<span class="p_del">-		readl(reg);</span>
<span class="p_add">+		for (i = 0; i &lt; SSIC_PORT_NUM; i++) {</span>
<span class="p_add">+			reg = (void __iomem *) xhci-&gt;cap_regs +</span>
<span class="p_add">+					SSIC_PORT_CFG2 +</span>
<span class="p_add">+					i * SSIC_PORT_CFG2_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Notify SSIC that SSIC profile programming</span>
<span class="p_add">+			 * is not done.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			val = readl(reg) &amp; ~PROG_DONE;</span>
<span class="p_add">+			writel(val, reg);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Mark SSIC port as unused(suspend) or used(resume) */</span>
<span class="p_add">+			val = readl(reg);</span>
<span class="p_add">+			if (suspend)</span>
<span class="p_add">+				val |= SSIC_PORT_UNUSED;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				val &amp;= ~SSIC_PORT_UNUSED;</span>
<span class="p_add">+			writel(val, reg);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Notify SSIC that SSIC profile programming is done */</span>
<span class="p_add">+			val = readl(reg) | PROG_DONE;</span>
<span class="p_add">+			writel(val, reg);</span>
<span class="p_add">+			readl(reg);</span>
<span class="p_add">+		}</span>
 	}
 
 	reg = (void __iomem *) xhci-&gt;cap_regs + 0x80a4;
<span class="p_header">diff --git a/drivers/usb/phy/phy-msm-usb.c b/drivers/usb/phy/phy-msm-usb.c</span>
<span class="p_header">index 0d19a6d61a71..970a30e155cb 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy-msm-usb.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy-msm-usb.c</span>
<span class="p_chunk">@@ -1599,6 +1599,8 @@</span> <span class="p_context"> static int msm_otg_read_dt(struct platform_device *pdev, struct msm_otg *motg)</span>
 						&amp;motg-&gt;id.nb);
 		if (ret &lt; 0) {
 			dev_err(&amp;pdev-&gt;dev, &quot;register ID notifier failed\n&quot;);
<span class="p_add">+			extcon_unregister_notifier(motg-&gt;vbus.extcon,</span>
<span class="p_add">+						   EXTCON_USB, &amp;motg-&gt;vbus.nb);</span>
 			return ret;
 		}
 
<span class="p_chunk">@@ -1660,15 +1662,6 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	if (!motg)
 		return -ENOMEM;
 
<span class="p_del">-	pdata = dev_get_platdata(&amp;pdev-&gt;dev);</span>
<span class="p_del">-	if (!pdata) {</span>
<span class="p_del">-		if (!np)</span>
<span class="p_del">-			return -ENXIO;</span>
<span class="p_del">-		ret = msm_otg_read_dt(pdev, motg);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	motg-&gt;phy.otg = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct usb_otg),
 				     GFP_KERNEL);
 	if (!motg-&gt;phy.otg)
<span class="p_chunk">@@ -1710,6 +1703,15 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	if (!motg-&gt;regs)
 		return -ENOMEM;
 
<span class="p_add">+	pdata = dev_get_platdata(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (!pdata) {</span>
<span class="p_add">+		if (!np)</span>
<span class="p_add">+			return -ENXIO;</span>
<span class="p_add">+		ret = msm_otg_read_dt(pdev, motg);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * NOTE: The PHYs can be multiplexed between the chipidea controller
 	 * and the dwc3 controller, using a single bit. It is important that
<span class="p_chunk">@@ -1717,8 +1719,10 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	 */
 	if (motg-&gt;phy_number) {
 		phy_select = devm_ioremap_nocache(&amp;pdev-&gt;dev, USB2_PHY_SEL, 4);
<span class="p_del">-		if (!phy_select)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_add">+		if (!phy_select) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto unregister_extcon;</span>
<span class="p_add">+		}</span>
 		/* Enable second PHY with the OTG port */
 		writel(0x1, phy_select);
 	}
<span class="p_chunk">@@ -1728,7 +1732,8 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 	motg-&gt;irq = platform_get_irq(pdev, 0);
 	if (motg-&gt;irq &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;platform_get_irq failed\n&quot;);
<span class="p_del">-		return motg-&gt;irq;</span>
<span class="p_add">+		ret = motg-&gt;irq;</span>
<span class="p_add">+		goto unregister_extcon;</span>
 	}
 
 	regs[0].supply = &quot;vddcx&quot;;
<span class="p_chunk">@@ -1737,7 +1742,7 @@</span> <span class="p_context"> static int msm_otg_probe(struct platform_device *pdev)</span>
 
 	ret = devm_regulator_bulk_get(motg-&gt;phy.dev, ARRAY_SIZE(regs), regs);
 	if (ret)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto unregister_extcon;</span>
 
 	motg-&gt;vddcx = regs[0].consumer;
 	motg-&gt;v3p3  = regs[1].consumer;
<span class="p_chunk">@@ -1834,6 +1839,12 @@</span> <span class="p_context"> disable_clks:</span>
 	clk_disable_unprepare(motg-&gt;clk);
 	if (!IS_ERR(motg-&gt;core_clk))
 		clk_disable_unprepare(motg-&gt;core_clk);
<span class="p_add">+unregister_extcon:</span>
<span class="p_add">+	extcon_unregister_notifier(motg-&gt;id.extcon,</span>
<span class="p_add">+				   EXTCON_USB_HOST, &amp;motg-&gt;id.nb);</span>
<span class="p_add">+	extcon_unregister_notifier(motg-&gt;vbus.extcon,</span>
<span class="p_add">+				   EXTCON_USB, &amp;motg-&gt;vbus.nb);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 59b2126b21a3..1dd9919081f8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -98,6 +98,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x81AC) }, /* MSD Dash Hawk */
 	{ USB_DEVICE(0x10C4, 0x81AD) }, /* INSYS USB Modem */
 	{ USB_DEVICE(0x10C4, 0x81C8) }, /* Lipowsky Industrie Elektronik GmbH, Baby-JTAG */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x81D7) }, /* IAI Corp. RCB-CV-USB USB to RS485 Adaptor */</span>
 	{ USB_DEVICE(0x10C4, 0x81E2) }, /* Lipowsky Industrie Elektronik GmbH, Baby-LIN */
 	{ USB_DEVICE(0x10C4, 0x81E7) }, /* Aerocomm Radio */
 	{ USB_DEVICE(0x10C4, 0x81E8) }, /* Zephyr Bioharness */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index a5a0376bbd48..8c660ae401d8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -824,6 +824,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_TURTELIZER_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_USB60F) },
<span class="p_add">+	{ USB_DEVICE(RATOC_VENDOR_ID, RATOC_PRODUCT_ID_SCU18) },</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_REU_TINY_PID) },
 
 	/* Papouch devices based on FTDI chip */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 67c6d4469730..a84df2513994 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -615,6 +615,7 @@</span> <span class="p_context"></span>
  */
 #define RATOC_VENDOR_ID		0x0584
 #define RATOC_PRODUCT_ID_USB60F	0xb020
<span class="p_add">+#define RATOC_PRODUCT_ID_SCU18	0xb03a</span>
 
 /*
  * Infineon Technologies
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index f2280606b73c..db86e512e0fc 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -268,6 +268,8 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_CC864_SINGLE		0x1006
 #define TELIT_PRODUCT_DE910_DUAL		0x1010
 #define TELIT_PRODUCT_UE910_V2			0x1012
<span class="p_add">+#define TELIT_PRODUCT_LE922_USBCFG0		0x1042</span>
<span class="p_add">+#define TELIT_PRODUCT_LE922_USBCFG3		0x1043</span>
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
 
<span class="p_chunk">@@ -615,6 +617,16 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le920_blacklist = {</span>
 	.reserved = BIT(1) | BIT(5),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_le922_blacklist_usbcfg0 = {</span>
<span class="p_add">+	.sendsetup = BIT(2),</span>
<span class="p_add">+	.reserved = BIT(0) | BIT(1) | BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct option_blacklist_info telit_le922_blacklist_usbcfg3 = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(1) | BIT(2) | BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1160,6 +1172,10 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_CC864_SINGLE) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_DE910_DUAL) },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_UE910_V2) },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG0),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE922_USBCFG3),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
<span class="p_chunk">@@ -1679,7 +1695,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_EU3_P) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_del">-	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX, 0xff) },</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PLXX),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, 
<span class="p_header">diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c</span>
<span class="p_header">index 60afb39eb73c..337a0be89fcf 100644</span>
<span class="p_header">--- a/drivers/usb/serial/visor.c</span>
<span class="p_header">+++ b/drivers/usb/serial/visor.c</span>
<span class="p_chunk">@@ -544,6 +544,11 @@</span> <span class="p_context"> static int treo_attach(struct usb_serial *serial)</span>
 		(serial-&gt;num_interrupt_in == 0))
 		return 0;
 
<span class="p_add">+	if (serial-&gt;num_bulk_in &lt; 2 || serial-&gt;num_interrupt_in &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	* It appears that Treos and Kyoceras want to use the
 	* 1st bulk in endpoint to communicate with the 2nd bulk out endpoint,
<span class="p_chunk">@@ -597,8 +602,10 @@</span> <span class="p_context"> static int clie_5_attach(struct usb_serial *serial)</span>
 	 */
 
 	/* some sanity check */
<span class="p_del">-	if (serial-&gt;num_ports &lt; 2)</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+	if (serial-&gt;num_bulk_out &lt; 2) {</span>
<span class="p_add">+		dev_err(&amp;serial-&gt;interface-&gt;dev, &quot;missing bulk out endpoints\n&quot;);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
 
 	/* port 0 now uses the modified endpoint Address */
 	port = serial-&gt;port[0];
<span class="p_header">diff --git a/fs/ext4/crypto_key.c b/fs/ext4/crypto_key.c</span>
<span class="p_header">index c5882b36e558..9a16d1e75a49 100644</span>
<span class="p_header">--- a/fs/ext4/crypto_key.c</span>
<span class="p_header">+++ b/fs/ext4/crypto_key.c</span>
<span class="p_chunk">@@ -213,9 +213,11 @@</span> <span class="p_context"> retry:</span>
 		res = -ENOKEY;
 		goto out;
 	}
<span class="p_add">+	down_read(&amp;keyring_key-&gt;sem);</span>
 	ukp = user_key_payload(keyring_key);
 	if (ukp-&gt;datalen != sizeof(struct ext4_encryption_key)) {
 		res = -EINVAL;
<span class="p_add">+		up_read(&amp;keyring_key-&gt;sem);</span>
 		goto out;
 	}
 	master_key = (struct ext4_encryption_key *)ukp-&gt;data;
<span class="p_chunk">@@ -226,10 +228,12 @@</span> <span class="p_context"> retry:</span>
 			    &quot;ext4: key size incorrect: %d\n&quot;,
 			    master_key-&gt;size);
 		res = -ENOKEY;
<span class="p_add">+		up_read(&amp;keyring_key-&gt;sem);</span>
 		goto out;
 	}
 	res = ext4_derive_key_aes(ctx.nonce, master_key-&gt;raw,
 				  raw_key);
<span class="p_add">+	up_read(&amp;keyring_key-&gt;sem);</span>
 	if (res)
 		goto out;
 got_key:
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 89818036f035..343b0f1f15b1 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -8054,7 +8054,6 @@</span> <span class="p_context"> static void nfs4_layoutreturn_release(void *calldata)</span>
 		pnfs_set_layout_stateid(lo, &amp;lrp-&gt;res.stateid, true);
 	pnfs_mark_matching_lsegs_invalid(lo, &amp;freeme, &amp;lrp-&gt;args.range);
 	pnfs_clear_layoutreturn_waitbit(lo);
<span class="p_del">-	lo-&gt;plh_block_lgets--;</span>
 	spin_unlock(&amp;lo-&gt;plh_inode-&gt;i_lock);
 	pnfs_free_lseg_list(&amp;freeme);
 	pnfs_put_layout_hdr(lrp-&gt;args.layout);
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index 84f2f8079466..4e2162b355db 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -2519,6 +2519,11 @@</span> <span class="p_context"> static int dlm_migrate_lockres(struct dlm_ctxt *dlm,</span>
 	spin_lock(&amp;dlm-&gt;master_lock);
 	ret = dlm_add_migration_mle(dlm, res, mle, &amp;oldmle, name,
 				    namelen, target, dlm-&gt;node_num);
<span class="p_add">+	/* get an extra reference on the mle.</span>
<span class="p_add">+	 * otherwise the assert_master from the new</span>
<span class="p_add">+	 * master will destroy this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dlm_get_mle_inuse(mle);</span>
 	spin_unlock(&amp;dlm-&gt;master_lock);
 	spin_unlock(&amp;dlm-&gt;spinlock);
 
<span class="p_chunk">@@ -2554,6 +2559,7 @@</span> <span class="p_context"> fail:</span>
 		if (mle_added) {
 			dlm_mle_detach_hb_events(dlm, mle);
 			dlm_put_mle(mle);
<span class="p_add">+			dlm_put_mle_inuse(mle);</span>
 		} else if (mle) {
 			kmem_cache_free(dlm_mle_cache, mle);
 			mle = NULL;
<span class="p_chunk">@@ -2571,17 +2577,6 @@</span> <span class="p_context"> fail:</span>
 	 * ensure that all assert_master work is flushed. */
 	flush_workqueue(dlm-&gt;dlm_worker);
 
<span class="p_del">-	/* get an extra reference on the mle.</span>
<span class="p_del">-	 * otherwise the assert_master from the new</span>
<span class="p_del">-	 * master will destroy this.</span>
<span class="p_del">-	 * also, make sure that all callers of dlm_get_mle</span>
<span class="p_del">-	 * take both dlm-&gt;spinlock and dlm-&gt;master_lock */</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-	spin_lock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	dlm_get_mle_inuse(mle);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;master_lock);</span>
<span class="p_del">-	spin_unlock(&amp;dlm-&gt;spinlock);</span>
<span class="p_del">-</span>
 	/* notify new node and send all lock state */
 	/* call send_one_lockres with migration flag.
 	 * this serves as notice to the target node that a
<span class="p_chunk">@@ -3312,6 +3307,15 @@</span> <span class="p_context"> top:</span>
 			    mle-&gt;new_master != dead_node)
 				continue;
 
<span class="p_add">+			if (mle-&gt;new_master == dead_node &amp;&amp; mle-&gt;inuse) {</span>
<span class="p_add">+				mlog(ML_NOTICE, &quot;%s: target %u died during &quot;</span>
<span class="p_add">+						&quot;migration from %u, the MLE is &quot;</span>
<span class="p_add">+						&quot;still keep used, ignore it!\n&quot;,</span>
<span class="p_add">+						dlm-&gt;name, dead_node,</span>
<span class="p_add">+						mle-&gt;master);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			/* If we have reached this point, this mle needs to be
 			 * removed from the list and freed. */
 			dlm_clean_migration_mle(dlm, mle);
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmrecovery.c b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">index 9e4f862d20fe..42f0cae93a0a 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_chunk">@@ -2360,6 +2360,8 @@</span> <span class="p_context"> static void dlm_do_local_recovery_cleanup(struct dlm_ctxt *dlm, u8 dead_node)</span>
 						break;
 					}
 				}
<span class="p_add">+				dlm_lockres_clear_refmap_bit(dlm, res,</span>
<span class="p_add">+						dead_node);</span>
 				spin_unlock(&amp;res-&gt;spinlock);
 				continue;
 			}
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 20276e340339..b002acf50203 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -1390,6 +1390,7 @@</span> <span class="p_context"> static int __ocfs2_cluster_lock(struct ocfs2_super *osb,</span>
 	unsigned int gen;
 	int noqueue_attempted = 0;
 	int dlm_locked = 0;
<span class="p_add">+	int kick_dc = 0;</span>
 
 	if (!(lockres-&gt;l_flags &amp; OCFS2_LOCK_INITIALIZED)) {
 		mlog_errno(-EINVAL);
<span class="p_chunk">@@ -1524,7 +1525,12 @@</span> <span class="p_context"> update_holders:</span>
 unlock:
 	lockres_clear_flags(lockres, OCFS2_LOCK_UPCONVERT_FINISHING);
 
<span class="p_add">+	/* ocfs2_unblock_lock reques on seeing OCFS2_LOCK_UPCONVERT_FINISHING */</span>
<span class="p_add">+	kick_dc = (lockres-&gt;l_flags &amp; OCFS2_LOCK_BLOCKED);</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;lockres-&gt;l_lock, flags);
<span class="p_add">+	if (kick_dc)</span>
<span class="p_add">+		ocfs2_wake_downconvert_thread(osb);</span>
 out:
 	/*
 	 * This is helping work around a lock inversion between the page lock
<span class="p_header">diff --git a/include/crypto/hash.h b/include/crypto/hash.h</span>
<span class="p_header">index 3d69c93d50e8..6361892ea737 100644</span>
<span class="p_header">--- a/include/crypto/hash.h</span>
<span class="p_header">+++ b/include/crypto/hash.h</span>
<span class="p_chunk">@@ -204,6 +204,7 @@</span> <span class="p_context"> struct crypto_ahash {</span>
 		      unsigned int keylen);
 
 	unsigned int reqsize;
<span class="p_add">+	bool has_setkey;</span>
 	struct crypto_tfm base;
 };
 
<span class="p_chunk">@@ -375,6 +376,11 @@</span> <span class="p_context"> static inline void *ahash_request_ctx(struct ahash_request *req)</span>
 int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
 			unsigned int keylen);
 
<span class="p_add">+static inline bool crypto_ahash_has_setkey(struct crypto_ahash *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return tfm-&gt;has_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * crypto_ahash_finup() - update and finalize message digest
  * @req: reference to the ahash_request handle that holds all information
<span class="p_header">diff --git a/include/crypto/if_alg.h b/include/crypto/if_alg.h</span>
<span class="p_header">index 018afb264ac2..a2bfd7843f18 100644</span>
<span class="p_header">--- a/include/crypto/if_alg.h</span>
<span class="p_header">+++ b/include/crypto/if_alg.h</span>
<span class="p_chunk">@@ -30,6 +30,9 @@</span> <span class="p_context"> struct alg_sock {</span>
 
 	struct sock *parent;
 
<span class="p_add">+	unsigned int refcnt;</span>
<span class="p_add">+	unsigned int nokey_refcnt;</span>
<span class="p_add">+</span>
 	const struct af_alg_type *type;
 	void *private;
 };
<span class="p_chunk">@@ -50,9 +53,11 @@</span> <span class="p_context"> struct af_alg_type {</span>
 	void (*release)(void *private);
 	int (*setkey)(void *private, const u8 *key, unsigned int keylen);
 	int (*accept)(void *private, struct sock *sk);
<span class="p_add">+	int (*accept_nokey)(void *private, struct sock *sk);</span>
 	int (*setauthsize)(void *private, unsigned int authsize);
 
 	struct proto_ops *ops;
<span class="p_add">+	struct proto_ops *ops_nokey;</span>
 	struct module *owner;
 	char name[14];
 };
<span class="p_chunk">@@ -67,6 +72,7 @@</span> <span class="p_context"> int af_alg_register_type(const struct af_alg_type *type);</span>
 int af_alg_unregister_type(const struct af_alg_type *type);
 
 int af_alg_release(struct socket *sock);
<span class="p_add">+void af_alg_release_parent(struct sock *sk);</span>
 int af_alg_accept(struct sock *sk, struct socket *newsock);
 
 int af_alg_make_sg(struct af_alg_sgl *sgl, struct iov_iter *iter, int len);
<span class="p_chunk">@@ -83,11 +89,6 @@</span> <span class="p_context"> static inline struct alg_sock *alg_sk(struct sock *sk)</span>
 	return (struct alg_sock *)sk;
 }
 
<span class="p_del">-static inline void af_alg_release_parent(struct sock *sk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	sock_put(alg_sk(sk)-&gt;parent);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void af_alg_init_completion(struct af_alg_completion *completion)
 {
 	init_completion(&amp;completion-&gt;completion);
<span class="p_header">diff --git a/include/crypto/skcipher.h b/include/crypto/skcipher.h</span>
<span class="p_header">index d8dd41fb034f..fd8742a40ff3 100644</span>
<span class="p_header">--- a/include/crypto/skcipher.h</span>
<span class="p_header">+++ b/include/crypto/skcipher.h</span>
<span class="p_chunk">@@ -61,6 +61,8 @@</span> <span class="p_context"> struct crypto_skcipher {</span>
 	unsigned int ivsize;
 	unsigned int reqsize;
 
<span class="p_add">+	bool has_setkey;</span>
<span class="p_add">+</span>
 	struct crypto_tfm base;
 };
 
<span class="p_chunk">@@ -305,6 +307,11 @@</span> <span class="p_context"> static inline int crypto_skcipher_setkey(struct crypto_skcipher *tfm,</span>
 	return tfm-&gt;setkey(tfm, key, keylen);
 }
 
<span class="p_add">+static inline bool crypto_skcipher_has_setkey(struct crypto_skcipher *tfm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return tfm-&gt;has_setkey;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * crypto_skcipher_reqtfm() - obtain cipher handle from request
  * @req: skcipher_request out of which the cipher handle is to be obtained
<span class="p_header">diff --git a/include/linux/console.h b/include/linux/console.h</span>
<span class="p_header">index bd194343c346..ea731af2451e 100644</span>
<span class="p_header">--- a/include/linux/console.h</span>
<span class="p_header">+++ b/include/linux/console.h</span>
<span class="p_chunk">@@ -150,6 +150,7 @@</span> <span class="p_context"> extern int console_trylock(void);</span>
 extern void console_unlock(void);
 extern void console_conditional_schedule(void);
 extern void console_unblank(void);
<span class="p_add">+extern void console_flush_on_panic(void);</span>
 extern struct tty_driver *console_device(int *);
 extern void console_stop(struct console *);
 extern void console_start(struct console *);
<span class="p_header">diff --git a/include/linux/hrtimer.h b/include/linux/hrtimer.h</span>
<span class="p_header">index 76dd4f0da5ca..2ead22dd74a0 100644</span>
<span class="p_header">--- a/include/linux/hrtimer.h</span>
<span class="p_header">+++ b/include/linux/hrtimer.h</span>
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> enum hrtimer_restart {</span>
  * @function:	timer expiry callback function
  * @base:	pointer to the timer base (per cpu and per clock)
  * @state:	state information (See bit values above)
<span class="p_del">- * @start_pid: timer statistics field to store the pid of the task which</span>
<span class="p_add">+ * @is_rel:	Set if the timer was armed relative</span>
<span class="p_add">+ * @start_pid:  timer statistics field to store the pid of the task which</span>
  *		started the timer
  * @start_site:	timer statistics field to store the site where the timer
  *		was started
<span class="p_chunk">@@ -101,7 +102,8 @@</span> <span class="p_context"> struct hrtimer {</span>
 	ktime_t				_softexpires;
 	enum hrtimer_restart		(*function)(struct hrtimer *);
 	struct hrtimer_clock_base	*base;
<span class="p_del">-	unsigned long			state;</span>
<span class="p_add">+	u8				state;</span>
<span class="p_add">+	u8				is_rel;</span>
 #ifdef CONFIG_TIMER_STATS
 	int				start_pid;
 	void				*start_site;
<span class="p_chunk">@@ -321,6 +323,27 @@</span> <span class="p_context"> static inline void clock_was_set_delayed(void) { }</span>
 
 #endif
 
<span class="p_add">+static inline ktime_t</span>
<span class="p_add">+__hrtimer_expires_remaining_adjusted(const struct hrtimer *timer, ktime_t now)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ktime_t rem = ktime_sub(timer-&gt;node.expires, now);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Adjust relative timers for the extra we added in</span>
<span class="p_add">+	 * hrtimer_start_range_ns() to prevent short timeouts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_TIME_LOW_RES) &amp;&amp; timer-&gt;is_rel)</span>
<span class="p_add">+		rem.tv64 -= hrtimer_resolution;</span>
<span class="p_add">+	return rem;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline ktime_t</span>
<span class="p_add">+hrtimer_expires_remaining_adjusted(const struct hrtimer *timer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __hrtimer_expires_remaining_adjusted(timer,</span>
<span class="p_add">+						    timer-&gt;base-&gt;get_time());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern void clock_was_set(void);
 #ifdef CONFIG_TIMERFD
 extern void timerfd_clock_was_set(void);
<span class="p_chunk">@@ -390,7 +413,12 @@</span> <span class="p_context"> static inline void hrtimer_restart(struct hrtimer *timer)</span>
 }
 
 /* Query timers: */
<span class="p_del">-extern ktime_t hrtimer_get_remaining(const struct hrtimer *timer);</span>
<span class="p_add">+extern ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline ktime_t hrtimer_get_remaining(const struct hrtimer *timer)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __hrtimer_get_remaining(timer, false);</span>
<span class="p_add">+}</span>
 
 extern u64 hrtimer_get_next_event(void);
 
<span class="p_header">diff --git a/include/linux/tty.h b/include/linux/tty.h</span>
<span class="p_header">index 5e31f1b99037..6b6e811f4575 100644</span>
<span class="p_header">--- a/include/linux/tty.h</span>
<span class="p_header">+++ b/include/linux/tty.h</span>
<span class="p_chunk">@@ -654,6 +654,7 @@</span> <span class="p_context"> extern long vt_compat_ioctl(struct tty_struct *tty,</span>
 /* tty_mutex.c */
 /* functions for preparation of BKL removal */
 extern void __lockfunc tty_lock(struct tty_struct *tty);
<span class="p_add">+extern int  tty_lock_interruptible(struct tty_struct *tty);</span>
 extern void __lockfunc tty_unlock(struct tty_struct *tty);
 extern void __lockfunc tty_lock_slave(struct tty_struct *tty);
 extern void __lockfunc tty_unlock_slave(struct tty_struct *tty);
<span class="p_header">diff --git a/include/sound/rawmidi.h b/include/sound/rawmidi.h</span>
<span class="p_header">index f6cbef78db62..3b91ad5d5115 100644</span>
<span class="p_header">--- a/include/sound/rawmidi.h</span>
<span class="p_header">+++ b/include/sound/rawmidi.h</span>
<span class="p_chunk">@@ -167,6 +167,10 @@</span> <span class="p_context"> int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count);
 int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream,
 			 unsigned char *buffer, int count);
<span class="p_add">+int __snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+			      unsigned char *buffer, int count);</span>
<span class="p_add">+int __snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+			       int count);</span>
 
 /* main midi functions */
 
<span class="p_header">diff --git a/kernel/panic.c b/kernel/panic.c</span>
<span class="p_header">index 4b150bc0c6c1..41e2b54f36b5 100644</span>
<span class="p_header">--- a/kernel/panic.c</span>
<span class="p_header">+++ b/kernel/panic.c</span>
<span class="p_chunk">@@ -157,8 +157,7 @@</span> <span class="p_context"> void panic(const char *fmt, ...)</span>
 	 * panic() is not being callled from OOPS.
 	 */
 	debug_locks_off();
<span class="p_del">-	console_trylock();</span>
<span class="p_del">-	console_unlock();</span>
<span class="p_add">+	console_flush_on_panic();</span>
 
 	if (!panic_blink)
 		panic_blink = no_blink;
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index 2ce8826f1053..c048e34b177f 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -2233,13 +2233,24 @@</span> <span class="p_context"> void console_unlock(void)</span>
 	static u64 seen_seq;
 	unsigned long flags;
 	bool wake_klogd = false;
<span class="p_del">-	bool retry;</span>
<span class="p_add">+	bool do_cond_resched, retry;</span>
 
 	if (console_suspended) {
 		up_console_sem();
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Console drivers are called under logbuf_lock, so</span>
<span class="p_add">+	 * @console_may_schedule should be cleared before; however, we may</span>
<span class="p_add">+	 * end up dumping a lot of lines, for example, if called from</span>
<span class="p_add">+	 * console registration path, and should invoke cond_resched()</span>
<span class="p_add">+	 * between lines if allowable.  Not doing so can cause a very long</span>
<span class="p_add">+	 * scheduling stall on a slow console leading to RCU stall and</span>
<span class="p_add">+	 * softlockup warnings which exacerbate the issue with more</span>
<span class="p_add">+	 * messages practically incapacitating the system.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do_cond_resched = console_may_schedule;</span>
 	console_may_schedule = 0;
 
 	/* flush buffered message fragment immediately to console */
<span class="p_chunk">@@ -2311,6 +2322,9 @@</span> <span class="p_context"> skip:</span>
 		call_console_drivers(level, ext_text, ext_len, text, len);
 		start_critical_timings();
 		local_irq_restore(flags);
<span class="p_add">+</span>
<span class="p_add">+		if (do_cond_resched)</span>
<span class="p_add">+			cond_resched();</span>
 	}
 	console_locked = 0;
 
<span class="p_chunk">@@ -2378,6 +2392,25 @@</span> <span class="p_context"> void console_unblank(void)</span>
 	console_unlock();
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * console_flush_on_panic - flush console content on panic</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Immediately output all pending messages no matter what.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void console_flush_on_panic(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If someone else is holding the console lock, trylock will fail</span>
<span class="p_add">+	 * and may_schedule may be set.  Ignore and proceed to unlock so</span>
<span class="p_add">+	 * that messages are flushed out.  As this can be called from any</span>
<span class="p_add">+	 * context and we don&#39;t want to get preempted while flushing,</span>
<span class="p_add">+	 * ensure may_schedule is cleared.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	console_trylock();</span>
<span class="p_add">+	console_may_schedule = 0;</span>
<span class="p_add">+	console_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Return the console tty driver structure and its associated index
  */
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 732e993b564b..eb70592f03f6 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -6738,7 +6738,7 @@</span> <span class="p_context"> static void sched_init_numa(void)</span>
 
 			sched_domains_numa_masks[i][j] = mask;
 
<span class="p_del">-			for (k = 0; k &lt; nr_node_ids; k++) {</span>
<span class="p_add">+			for_each_node(k) {</span>
 				if (node_distance(j, k) &gt; sched_domains_numa_distance[i])
 					continue;
 
<span class="p_header">diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c</span>
<span class="p_header">index 435b8850dd80..fa909f9fd559 100644</span>
<span class="p_header">--- a/kernel/time/hrtimer.c</span>
<span class="p_header">+++ b/kernel/time/hrtimer.c</span>
<span class="p_chunk">@@ -897,10 +897,10 @@</span> <span class="p_context"> static int enqueue_hrtimer(struct hrtimer *timer,</span>
  */
 static void __remove_hrtimer(struct hrtimer *timer,
 			     struct hrtimer_clock_base *base,
<span class="p_del">-			     unsigned long newstate, int reprogram)</span>
<span class="p_add">+			     u8 newstate, int reprogram)</span>
 {
 	struct hrtimer_cpu_base *cpu_base = base-&gt;cpu_base;
<span class="p_del">-	unsigned int state = timer-&gt;state;</span>
<span class="p_add">+	u8 state = timer-&gt;state;</span>
 
 	timer-&gt;state = newstate;
 	if (!(state &amp; HRTIMER_STATE_ENQUEUED))
<span class="p_chunk">@@ -930,7 +930,7 @@</span> <span class="p_context"> static inline int</span>
 remove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool restart)
 {
 	if (hrtimer_is_queued(timer)) {
<span class="p_del">-		unsigned long state = timer-&gt;state;</span>
<span class="p_add">+		u8 state = timer-&gt;state;</span>
 		int reprogram;
 
 		/*
<span class="p_chunk">@@ -954,6 +954,22 @@</span> <span class="p_context"> remove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base, bool rest</span>
 	return 0;
 }
 
<span class="p_add">+static inline ktime_t hrtimer_update_lowres(struct hrtimer *timer, ktime_t tim,</span>
<span class="p_add">+					    const enum hrtimer_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_TIME_LOW_RES</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * CONFIG_TIME_LOW_RES indicates that the system has no way to return</span>
<span class="p_add">+	 * granular time values. For relative timers we add hrtimer_resolution</span>
<span class="p_add">+	 * (i.e. one jiffie) to prevent short timeouts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	timer-&gt;is_rel = mode &amp; HRTIMER_MODE_REL;</span>
<span class="p_add">+	if (timer-&gt;is_rel)</span>
<span class="p_add">+		tim = ktime_add_safe(tim, ktime_set(0, hrtimer_resolution));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return tim;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * hrtimer_start_range_ns - (re)start an hrtimer on the current CPU
  * @timer:	the timer to be added
<span class="p_chunk">@@ -974,19 +990,10 @@</span> <span class="p_context"> void hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,</span>
 	/* Remove an active timer from the queue: */
 	remove_hrtimer(timer, base, true);
 
<span class="p_del">-	if (mode &amp; HRTIMER_MODE_REL) {</span>
<span class="p_add">+	if (mode &amp; HRTIMER_MODE_REL)</span>
 		tim = ktime_add_safe(tim, base-&gt;get_time());
<span class="p_del">-		/*</span>
<span class="p_del">-		 * CONFIG_TIME_LOW_RES is a temporary way for architectures</span>
<span class="p_del">-		 * to signal that they simply return xtime in</span>
<span class="p_del">-		 * do_gettimeoffset(). In this case we want to round up by</span>
<span class="p_del">-		 * resolution when starting a relative timer, to avoid short</span>
<span class="p_del">-		 * timeouts. This will go away with the GTOD framework.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-#ifdef CONFIG_TIME_LOW_RES</span>
<span class="p_del">-		tim = ktime_add_safe(tim, ktime_set(0, hrtimer_resolution));</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_add">+</span>
<span class="p_add">+	tim = hrtimer_update_lowres(timer, tim, mode);</span>
 
 	hrtimer_set_expires_range_ns(timer, tim, delta_ns);
 
<span class="p_chunk">@@ -1074,19 +1081,23 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(hrtimer_cancel);</span>
 /**
  * hrtimer_get_remaining - get remaining time for the timer
  * @timer:	the timer to read
<span class="p_add">+ * @adjust:	adjust relative timers when CONFIG_TIME_LOW_RES=y</span>
  */
<span class="p_del">-ktime_t hrtimer_get_remaining(const struct hrtimer *timer)</span>
<span class="p_add">+ktime_t __hrtimer_get_remaining(const struct hrtimer *timer, bool adjust)</span>
 {
 	unsigned long flags;
 	ktime_t rem;
 
 	lock_hrtimer_base(timer, &amp;flags);
<span class="p_del">-	rem = hrtimer_expires_remaining(timer);</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_TIME_LOW_RES) &amp;&amp; adjust)</span>
<span class="p_add">+		rem = hrtimer_expires_remaining_adjusted(timer);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		rem = hrtimer_expires_remaining(timer);</span>
 	unlock_hrtimer_base(timer, &amp;flags);
 
 	return rem;
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(hrtimer_get_remaining);</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(__hrtimer_get_remaining);</span>
 
 #ifdef CONFIG_NO_HZ_COMMON
 /**
<span class="p_chunk">@@ -1220,6 +1231,14 @@</span> <span class="p_context"> static void __run_hrtimer(struct hrtimer_cpu_base *cpu_base,</span>
 	fn = timer-&gt;function;
 
 	/*
<span class="p_add">+	 * Clear the &#39;is relative&#39; flag for the TIME_LOW_RES case. If the</span>
<span class="p_add">+	 * timer is restarted with a period then it becomes an absolute</span>
<span class="p_add">+	 * timer. If its not restarted it does not matter.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_TIME_LOW_RES))</span>
<span class="p_add">+		timer-&gt;is_rel = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Because we run timers from hardirq context, there is no chance
 	 * they get migrated to another cpu, therefore its safe to unlock
 	 * the timer base.
<span class="p_header">diff --git a/kernel/time/timer_list.c b/kernel/time/timer_list.c</span>
<span class="p_header">index f75e35b60149..ba7d8b288bb3 100644</span>
<span class="p_header">--- a/kernel/time/timer_list.c</span>
<span class="p_header">+++ b/kernel/time/timer_list.c</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> print_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,</span>
 	print_name_offset(m, taddr);
 	SEQ_printf(m, &quot;, &quot;);
 	print_name_offset(m, timer-&gt;function);
<span class="p_del">-	SEQ_printf(m, &quot;, S:%02lx&quot;, timer-&gt;state);</span>
<span class="p_add">+	SEQ_printf(m, &quot;, S:%02x&quot;, timer-&gt;state);</span>
 #ifdef CONFIG_TIMER_STATS
 	SEQ_printf(m, &quot;, &quot;);
 	print_name_offset(m, timer-&gt;start_site);
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 87fb9801bd9e..d9293402ee68 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -1751,7 +1751,7 @@</span> <span class="p_context"> void trace_buffer_unlock_commit_regs(struct trace_array *tr,</span>
 {
 	__buffer_unlock_commit(buffer, event);
 
<span class="p_del">-	ftrace_trace_stack(tr, buffer, flags, 6, pc, regs);</span>
<span class="p_add">+	ftrace_trace_stack(tr, buffer, flags, 0, pc, regs);</span>
 	ftrace_trace_userstack(buffer, flags, pc);
 }
 EXPORT_SYMBOL_GPL(trace_buffer_unlock_commit_regs);
<span class="p_header">diff --git a/kernel/trace/trace_stack.c b/kernel/trace/trace_stack.c</span>
<span class="p_header">index dda9e6742950..202df6cffcca 100644</span>
<span class="p_header">--- a/kernel/trace/trace_stack.c</span>
<span class="p_header">+++ b/kernel/trace/trace_stack.c</span>
<span class="p_chunk">@@ -126,6 +126,13 @@</span> <span class="p_context"> check_stack(unsigned long ip, unsigned long *stack)</span>
 	}
 
 	/*
<span class="p_add">+	 * Some archs may not have the passed in ip in the dump.</span>
<span class="p_add">+	 * If that happens, we need to show everything.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (i == stack_trace_max.nr_entries)</span>
<span class="p_add">+		i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * Now find where in the stack these are.
 	 */
 	x = 0;
<span class="p_header">diff --git a/lib/libcrc32c.c b/lib/libcrc32c.c</span>
<span class="p_header">index 6a08ce7d6adc..acf9da449f81 100644</span>
<span class="p_header">--- a/lib/libcrc32c.c</span>
<span class="p_header">+++ b/lib/libcrc32c.c</span>
<span class="p_chunk">@@ -74,3 +74,4 @@</span> <span class="p_context"> module_exit(libcrc32c_mod_fini);</span>
 MODULE_AUTHOR(&quot;Clay Haapala &lt;chaapala@cisco.com&gt;&quot;);
 MODULE_DESCRIPTION(&quot;CRC32c (Castagnoli) calculations&quot;);
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_add">+MODULE_SOFTDEP(&quot;pre: crc32c&quot;);</span>
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index 7340353f8aea..cbe6f0b96f29 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -989,7 +989,7 @@</span> <span class="p_context"> long wait_iff_congested(struct zone *zone, int sync, long timeout)</span>
 		 * here rather than calling cond_resched().
 		 */
 		if (current-&gt;flags &amp; PF_WQ_WORKER)
<span class="p_del">-			schedule_timeout(1);</span>
<span class="p_add">+			schedule_timeout_uninterruptible(1);</span>
 		else
 			cond_resched();
 
<span class="p_header">diff --git a/mm/zsmalloc.c b/mm/zsmalloc.c</span>
<span class="p_header">index 9f15bdd9163c..fc083996e40a 100644</span>
<span class="p_header">--- a/mm/zsmalloc.c</span>
<span class="p_header">+++ b/mm/zsmalloc.c</span>
<span class="p_chunk">@@ -309,7 +309,12 @@</span> <span class="p_context"> static void free_handle(struct zs_pool *pool, unsigned long handle)</span>
 
 static void record_obj(unsigned long handle, unsigned long obj)
 {
<span class="p_del">-	*(unsigned long *)handle = obj;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * lsb of @obj represents handle lock while other bits</span>
<span class="p_add">+	 * represent object value the handle is pointing so</span>
<span class="p_add">+	 * updating shouldn&#39;t do store tearing.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WRITE_ONCE(*(unsigned long *)handle, obj);</span>
 }
 
 /* zpool driver */
<span class="p_chunk">@@ -1635,6 +1640,13 @@</span> <span class="p_context"> static int migrate_zspage(struct zs_pool *pool, struct size_class *class,</span>
 		free_obj = obj_malloc(d_page, class, handle);
 		zs_object_copy(free_obj, used_obj, class);
 		index++;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * record_obj updates handle&#39;s value to free_obj and it will</span>
<span class="p_add">+		 * invalidate lock bit(ie, HANDLE_PIN_BIT) of handle, which</span>
<span class="p_add">+		 * breaks synchronization using pin_tag(e,g, zs_free) so</span>
<span class="p_add">+		 * let&#39;s keep the lock bit.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		free_obj |= BIT(HANDLE_PIN_BIT);</span>
 		record_obj(handle, free_obj);
 		unpin_tag(handle);
 		obj_free(pool, class, used_obj);
<span class="p_header">diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c</span>
<span class="p_header">index 1334e02ae8f4..3d145a3ffccf 100644</span>
<span class="p_header">--- a/security/integrity/evm/evm_main.c</span>
<span class="p_header">+++ b/security/integrity/evm/evm_main.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/integrity.h&gt;
 #include &lt;linux/evm.h&gt;
 #include &lt;crypto/hash.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 #include &quot;evm.h&quot;
 
 int evm_initialized;
<span class="p_chunk">@@ -148,7 +149,7 @@</span> <span class="p_context"> static enum integrity_status evm_verify_hmac(struct dentry *dentry,</span>
 				   xattr_value_len, calc.digest);
 		if (rc)
 			break;
<span class="p_del">-		rc = memcmp(xattr_data-&gt;digest, calc.digest,</span>
<span class="p_add">+		rc = crypto_memneq(xattr_data-&gt;digest, calc.digest,</span>
 			    sizeof(calc.digest));
 		if (rc)
 			rc = -EINVAL;
<span class="p_header">diff --git a/sound/core/compress_offload.c b/sound/core/compress_offload.c</span>
<span class="p_header">index b123c42e7dc8..b554d7f9e3be 100644</span>
<span class="p_header">--- a/sound/core/compress_offload.c</span>
<span class="p_header">+++ b/sound/core/compress_offload.c</span>
<span class="p_chunk">@@ -44,6 +44,13 @@</span> <span class="p_context"></span>
 #include &lt;sound/compress_offload.h&gt;
 #include &lt;sound/compress_driver.h&gt;
 
<span class="p_add">+/* struct snd_compr_codec_caps overflows the ioctl bit size for some</span>
<span class="p_add">+ * architectures, so we need to disable the relevant ioctls.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#if _IOC_SIZEBITS &lt; 14</span>
<span class="p_add">+#define COMPR_CODEC_CAPS_OVERFLOW</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /* TODO:
  * - add substream support for multiple devices in case of
  *	SND_DYNAMIC_MINORS is not used
<span class="p_chunk">@@ -438,6 +445,7 @@</span> <span class="p_context"> out:</span>
 	return retval;
 }
 
<span class="p_add">+#ifndef COMPR_CODEC_CAPS_OVERFLOW</span>
 static int
 snd_compr_get_codec_caps(struct snd_compr_stream *stream, unsigned long arg)
 {
<span class="p_chunk">@@ -461,6 +469,7 @@</span> <span class="p_context"> out:</span>
 	kfree(caps);
 	return retval;
 }
<span class="p_add">+#endif /* !COMPR_CODEC_CAPS_OVERFLOW */</span>
 
 /* revisit this with snd_pcm_preallocate_xxx */
 static int snd_compr_allocate_buffer(struct snd_compr_stream *stream,
<span class="p_chunk">@@ -799,9 +808,11 @@</span> <span class="p_context"> static long snd_compr_ioctl(struct file *f, unsigned int cmd, unsigned long arg)</span>
 	case _IOC_NR(SNDRV_COMPRESS_GET_CAPS):
 		retval = snd_compr_get_caps(stream, arg);
 		break;
<span class="p_add">+#ifndef COMPR_CODEC_CAPS_OVERFLOW</span>
 	case _IOC_NR(SNDRV_COMPRESS_GET_CODEC_CAPS):
 		retval = snd_compr_get_codec_caps(stream, arg);
 		break;
<span class="p_add">+#endif</span>
 	case _IOC_NR(SNDRV_COMPRESS_SET_PARAMS):
 		retval = snd_compr_set_params(stream, arg);
 		break;
<span class="p_header">diff --git a/sound/core/oss/pcm_oss.c b/sound/core/oss/pcm_oss.c</span>
<span class="p_header">index 58550cc93f28..33e72c809e50 100644</span>
<span class="p_header">--- a/sound/core/oss/pcm_oss.c</span>
<span class="p_header">+++ b/sound/core/oss/pcm_oss.c</span>
<span class="p_chunk">@@ -834,7 +834,8 @@</span> <span class="p_context"> static int choose_rate(struct snd_pcm_substream *substream,</span>
 	return snd_pcm_hw_param_near(substream, params, SNDRV_PCM_HW_PARAM_RATE, best_rate, NULL);
 }
 
<span class="p_del">-static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)</span>
<span class="p_add">+static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream,</span>
<span class="p_add">+				     bool trylock)</span>
 {
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
 	struct snd_pcm_hw_params *params, *sparams;
<span class="p_chunk">@@ -848,7 +849,10 @@</span> <span class="p_context"> static int snd_pcm_oss_change_params(struct snd_pcm_substream *substream)</span>
 	struct snd_mask sformat_mask;
 	struct snd_mask mask;
 
<span class="p_del">-	if (mutex_lock_interruptible(&amp;runtime-&gt;oss.params_lock))</span>
<span class="p_add">+	if (trylock) {</span>
<span class="p_add">+		if (!(mutex_trylock(&amp;runtime-&gt;oss.params_lock)))</span>
<span class="p_add">+			return -EAGAIN;</span>
<span class="p_add">+	} else if (mutex_lock_interruptible(&amp;runtime-&gt;oss.params_lock))</span>
 		return -EINTR;
 	sw_params = kmalloc(sizeof(*sw_params), GFP_KERNEL);
 	params = kmalloc(sizeof(*params), GFP_KERNEL);
<span class="p_chunk">@@ -1092,7 +1096,7 @@</span> <span class="p_context"> static int snd_pcm_oss_get_active_substream(struct snd_pcm_oss_file *pcm_oss_fil</span>
 		if (asubstream == NULL)
 			asubstream = substream;
 		if (substream-&gt;runtime-&gt;oss.params) {
<span class="p_del">-			err = snd_pcm_oss_change_params(substream);</span>
<span class="p_add">+			err = snd_pcm_oss_change_params(substream, false);</span>
 			if (err &lt; 0)
 				return err;
 		}
<span class="p_chunk">@@ -1132,7 +1136,7 @@</span> <span class="p_context"> static int snd_pcm_oss_make_ready(struct snd_pcm_substream *substream)</span>
 		return 0;
 	runtime = substream-&gt;runtime;
 	if (runtime-&gt;oss.params) {
<span class="p_del">-		err = snd_pcm_oss_change_params(substream);</span>
<span class="p_add">+		err = snd_pcm_oss_change_params(substream, false);</span>
 		if (err &lt; 0)
 			return err;
 	}
<span class="p_chunk">@@ -2163,7 +2167,7 @@</span> <span class="p_context"> static int snd_pcm_oss_get_space(struct snd_pcm_oss_file *pcm_oss_file, int stre</span>
 	runtime = substream-&gt;runtime;
 
 	if (runtime-&gt;oss.params &amp;&amp;
<span class="p_del">-	    (err = snd_pcm_oss_change_params(substream)) &lt; 0)</span>
<span class="p_add">+	    (err = snd_pcm_oss_change_params(substream, false)) &lt; 0)</span>
 		return err;
 
 	info.fragsize = runtime-&gt;oss.period_bytes;
<span class="p_chunk">@@ -2800,7 +2804,12 @@</span> <span class="p_context"> static int snd_pcm_oss_mmap(struct file *file, struct vm_area_struct *area)</span>
 		return -EIO;
 	
 	if (runtime-&gt;oss.params) {
<span class="p_del">-		if ((err = snd_pcm_oss_change_params(substream)) &lt; 0)</span>
<span class="p_add">+		/* use mutex_trylock() for params_lock for avoiding a deadlock</span>
<span class="p_add">+		 * between mmap_sem and params_lock taken by</span>
<span class="p_add">+		 * copy_from/to_user() in snd_pcm_oss_write/read()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		err = snd_pcm_oss_change_params(substream, true);</span>
<span class="p_add">+		if (err &lt; 0)</span>
 			return err;
 	}
 #ifdef CONFIG_SND_PCM_OSS_PLUGINS
<span class="p_header">diff --git a/sound/core/rawmidi.c b/sound/core/rawmidi.c</span>
<span class="p_header">index a7759846fbaa..795437b10082 100644</span>
<span class="p_header">--- a/sound/core/rawmidi.c</span>
<span class="p_header">+++ b/sound/core/rawmidi.c</span>
<span class="p_chunk">@@ -942,31 +942,36 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_read1(struct snd_rawmidi_substream *substream,</span>
 	unsigned long flags;
 	long result = 0, count1;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
<span class="p_add">+	unsigned long appl_ptr;</span>
 
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	while (count &gt; 0 &amp;&amp; runtime-&gt;avail) {
 		count1 = runtime-&gt;buffer_size - runtime-&gt;appl_ptr;
 		if (count1 &gt; count)
 			count1 = count;
<span class="p_del">-		spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 		if (count1 &gt; (int)runtime-&gt;avail)
 			count1 = runtime-&gt;avail;
<span class="p_add">+</span>
<span class="p_add">+		/* update runtime-&gt;appl_ptr before unlocking for userbuf */</span>
<span class="p_add">+		appl_ptr = runtime-&gt;appl_ptr;</span>
<span class="p_add">+		runtime-&gt;appl_ptr += count1;</span>
<span class="p_add">+		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_add">+		runtime-&gt;avail -= count1;</span>
<span class="p_add">+</span>
 		if (kernelbuf)
<span class="p_del">-			memcpy(kernelbuf + result, runtime-&gt;buffer + runtime-&gt;appl_ptr, count1);</span>
<span class="p_add">+			memcpy(kernelbuf + result, runtime-&gt;buffer + appl_ptr, count1);</span>
 		if (userbuf) {
 			spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
 			if (copy_to_user(userbuf + result,
<span class="p_del">-					 runtime-&gt;buffer + runtime-&gt;appl_ptr, count1)) {</span>
<span class="p_add">+					 runtime-&gt;buffer + appl_ptr, count1)) {</span>
 				return result &gt; 0 ? result : -EFAULT;
 			}
 			spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
 		}
<span class="p_del">-		runtime-&gt;appl_ptr += count1;</span>
<span class="p_del">-		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_del">-		runtime-&gt;avail -= count1;</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
 		result += count1;
 		count -= count1;
 	}
<span class="p_add">+	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
 	return result;
 }
 
<span class="p_chunk">@@ -1055,23 +1060,16 @@</span> <span class="p_context"> int snd_rawmidi_transmit_empty(struct snd_rawmidi_substream *substream)</span>
 EXPORT_SYMBOL(snd_rawmidi_transmit_empty);
 
 /**
<span class="p_del">- * snd_rawmidi_transmit_peek - copy data from the internal buffer</span>
<span class="p_add">+ * __snd_rawmidi_transmit_peek - copy data from the internal buffer</span>
  * @substream: the rawmidi substream
  * @buffer: the buffer pointer
  * @count: data size to transfer
  *
<span class="p_del">- * Copies data from the internal output buffer to the given buffer.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Call this in the interrupt handler when the midi output is ready,</span>
<span class="p_del">- * and call snd_rawmidi_transmit_ack() after the transmission is</span>
<span class="p_del">- * finished.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Return: The size of copied data, or a negative error code on failure.</span>
<span class="p_add">+ * This is a variant of snd_rawmidi_transmit_peek() without spinlock.</span>
  */
<span class="p_del">-int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+int __snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 			      unsigned char *buffer, int count)
 {
<span class="p_del">-	unsigned long flags;</span>
 	int result, count1;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 
<span class="p_chunk">@@ -1081,7 +1079,6 @@</span> <span class="p_context"> int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 		return -EINVAL;
 	}
 	result = 0;
<span class="p_del">-	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	if (runtime-&gt;avail &gt;= runtime-&gt;buffer_size) {
 		/* warning: lowlevel layer MUST trigger down the hardware */
 		goto __skip;
<span class="p_chunk">@@ -1106,25 +1103,47 @@</span> <span class="p_context"> int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
 		}
 	}
       __skip:
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__snd_rawmidi_transmit_peek);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * snd_rawmidi_transmit_peek - copy data from the internal buffer</span>
<span class="p_add">+ * @substream: the rawmidi substream</span>
<span class="p_add">+ * @buffer: the buffer pointer</span>
<span class="p_add">+ * @count: data size to transfer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copies data from the internal output buffer to the given buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Call this in the interrupt handler when the midi output is ready,</span>
<span class="p_add">+ * and call snd_rawmidi_transmit_ack() after the transmission is</span>
<span class="p_add">+ * finished.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: The size of copied data, or a negative error code on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_rawmidi_transmit_peek(struct snd_rawmidi_substream *substream,</span>
<span class="p_add">+			      unsigned char *buffer, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	result = __snd_rawmidi_transmit_peek(substream, buffer, count);</span>
 	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
 	return result;
 }
 EXPORT_SYMBOL(snd_rawmidi_transmit_peek);
 
 /**
<span class="p_del">- * snd_rawmidi_transmit_ack - acknowledge the transmission</span>
<span class="p_add">+ * __snd_rawmidi_transmit_ack - acknowledge the transmission</span>
  * @substream: the rawmidi substream
  * @count: the transferred count
  *
<span class="p_del">- * Advances the hardware pointer for the internal output buffer with</span>
<span class="p_del">- * the given size and updates the condition.</span>
<span class="p_del">- * Call after the transmission is finished.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Return: The advanced size if successful, or a negative error code on failure.</span>
<span class="p_add">+ * This is a variant of __snd_rawmidi_transmit_ack() without spinlock.</span>
  */
<span class="p_del">-int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
<span class="p_add">+int __snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
 {
<span class="p_del">-	unsigned long flags;</span>
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 
 	if (runtime-&gt;buffer == NULL) {
<span class="p_chunk">@@ -1132,7 +1151,6 @@</span> <span class="p_context"> int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
 			  &quot;snd_rawmidi_transmit_ack: output is not active!!!\n&quot;);
 		return -EINVAL;
 	}
<span class="p_del">-	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	snd_BUG_ON(runtime-&gt;avail + count &gt; runtime-&gt;buffer_size);
 	runtime-&gt;hw_ptr += count;
 	runtime-&gt;hw_ptr %= runtime-&gt;buffer_size;
<span class="p_chunk">@@ -1142,9 +1160,32 @@</span> <span class="p_context"> int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
 		if (runtime-&gt;drain || snd_rawmidi_ready(substream))
 			wake_up(&amp;runtime-&gt;sleep);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
 	return count;
 }
<span class="p_add">+EXPORT_SYMBOL(__snd_rawmidi_transmit_ack);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * snd_rawmidi_transmit_ack - acknowledge the transmission</span>
<span class="p_add">+ * @substream: the rawmidi substream</span>
<span class="p_add">+ * @count: the transferred count</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Advances the hardware pointer for the internal output buffer with</span>
<span class="p_add">+ * the given size and updates the condition.</span>
<span class="p_add">+ * Call after the transmission is finished.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: The advanced size if successful, or a negative error code on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_rawmidi_transmit_ack(struct snd_rawmidi_substream *substream, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	result = __snd_rawmidi_transmit_ack(substream, count);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(snd_rawmidi_transmit_ack);
 
 /**
<span class="p_chunk">@@ -1160,12 +1201,22 @@</span> <span class="p_context"> EXPORT_SYMBOL(snd_rawmidi_transmit_ack);</span>
 int snd_rawmidi_transmit(struct snd_rawmidi_substream *substream,
 			 unsigned char *buffer, int count)
 {
<span class="p_add">+	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;runtime-&gt;lock, flags);</span>
 	if (!substream-&gt;opened)
<span class="p_del">-		return -EBADFD;</span>
<span class="p_del">-	count = snd_rawmidi_transmit_peek(substream, buffer, count);</span>
<span class="p_del">-	if (count &lt; 0)</span>
<span class="p_del">-		return count;</span>
<span class="p_del">-	return snd_rawmidi_transmit_ack(substream, count);</span>
<span class="p_add">+		result = -EBADFD;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		count = __snd_rawmidi_transmit_peek(substream, buffer, count);</span>
<span class="p_add">+		if (count &lt;= 0)</span>
<span class="p_add">+			result = count;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			result = __snd_rawmidi_transmit_ack(substream, count);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);</span>
<span class="p_add">+	return result;</span>
 }
 EXPORT_SYMBOL(snd_rawmidi_transmit);
 
<span class="p_chunk">@@ -1177,8 +1228,9 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,</span>
 	unsigned long flags;
 	long count1, result;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
<span class="p_add">+	unsigned long appl_ptr;</span>
 
<span class="p_del">-	if (snd_BUG_ON(!kernelbuf &amp;&amp; !userbuf))</span>
<span class="p_add">+	if (!kernelbuf &amp;&amp; !userbuf)</span>
 		return -EINVAL;
 	if (snd_BUG_ON(!runtime-&gt;buffer))
 		return -EINVAL;
<span class="p_chunk">@@ -1197,12 +1249,19 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,</span>
 			count1 = count;
 		if (count1 &gt; (long)runtime-&gt;avail)
 			count1 = runtime-&gt;avail;
<span class="p_add">+</span>
<span class="p_add">+		/* update runtime-&gt;appl_ptr before unlocking for userbuf */</span>
<span class="p_add">+		appl_ptr = runtime-&gt;appl_ptr;</span>
<span class="p_add">+		runtime-&gt;appl_ptr += count1;</span>
<span class="p_add">+		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_add">+		runtime-&gt;avail -= count1;</span>
<span class="p_add">+</span>
 		if (kernelbuf)
<span class="p_del">-			memcpy(runtime-&gt;buffer + runtime-&gt;appl_ptr,</span>
<span class="p_add">+			memcpy(runtime-&gt;buffer + appl_ptr,</span>
 			       kernelbuf + result, count1);
 		else if (userbuf) {
 			spin_unlock_irqrestore(&amp;runtime-&gt;lock, flags);
<span class="p_del">-			if (copy_from_user(runtime-&gt;buffer + runtime-&gt;appl_ptr,</span>
<span class="p_add">+			if (copy_from_user(runtime-&gt;buffer + appl_ptr,</span>
 					   userbuf + result, count1)) {
 				spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
 				result = result &gt; 0 ? result : -EFAULT;
<span class="p_chunk">@@ -1210,9 +1269,6 @@</span> <span class="p_context"> static long snd_rawmidi_kernel_write1(struct snd_rawmidi_substream *substream,</span>
 			}
 			spin_lock_irqsave(&amp;runtime-&gt;lock, flags);
 		}
<span class="p_del">-		runtime-&gt;appl_ptr += count1;</span>
<span class="p_del">-		runtime-&gt;appl_ptr %= runtime-&gt;buffer_size;</span>
<span class="p_del">-		runtime-&gt;avail -= count1;</span>
 		result += count1;
 		count -= count1;
 	}
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_init.c b/sound/core/seq/oss/seq_oss_init.c</span>
<span class="p_header">index b1221b29728e..6779e82b46dd 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_init.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_init.c</span>
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> snd_seq_oss_open(struct file *file, int level)</span>
 
 	dp-&gt;index = i;
 	if (i &gt;= SNDRV_SEQ_OSS_MAX_CLIENTS) {
<span class="p_del">-		pr_err(&quot;ALSA: seq_oss: too many applications\n&quot;);</span>
<span class="p_add">+		pr_debug(&quot;ALSA: seq_oss: too many applications\n&quot;);</span>
 		rc = -ENOMEM;
 		goto _error;
 	}
<span class="p_header">diff --git a/sound/core/seq/oss/seq_oss_synth.c b/sound/core/seq/oss/seq_oss_synth.c</span>
<span class="p_header">index 0f3b38184fe5..b16dbef04174 100644</span>
<span class="p_header">--- a/sound/core/seq/oss/seq_oss_synth.c</span>
<span class="p_header">+++ b/sound/core/seq/oss/seq_oss_synth.c</span>
<span class="p_chunk">@@ -308,7 +308,7 @@</span> <span class="p_context"> snd_seq_oss_synth_cleanup(struct seq_oss_devinfo *dp)</span>
 	struct seq_oss_synth *rec;
 	struct seq_oss_synthinfo *info;
 
<span class="p_del">-	if (snd_BUG_ON(dp-&gt;max_synthdev &gt;= SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))</span>
<span class="p_add">+	if (snd_BUG_ON(dp-&gt;max_synthdev &gt; SNDRV_SEQ_OSS_MAX_SYNTH_DEVS))</span>
 		return;
 	for (i = 0; i &lt; dp-&gt;max_synthdev; i++) {
 		info = &amp;dp-&gt;synths[i];
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index 13cfa815732d..58e79e02f217 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -678,6 +678,9 @@</span> <span class="p_context"> static int deliver_to_subscribers(struct snd_seq_client *client,</span>
 	else
 		down_read(&amp;grp-&gt;list_mutex);
 	list_for_each_entry(subs, &amp;grp-&gt;list_head, src_list) {
<span class="p_add">+		/* both ports ready? */</span>
<span class="p_add">+		if (atomic_read(&amp;subs-&gt;ref_count) != 2)</span>
<span class="p_add">+			continue;</span>
 		event-&gt;dest = subs-&gt;info.dest;
 		if (subs-&gt;info.flags &amp; SNDRV_SEQ_PORT_SUBS_TIMESTAMP)
 			/* convert time according to flag with subscription */
<span class="p_header">diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c</span>
<span class="p_header">index 55170a20ae72..921fb2bd8fad 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_ports.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_ports.c</span>
<span class="p_chunk">@@ -173,10 +173,6 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 }
 
 /* */
<span class="p_del">-enum group_type {</span>
<span class="p_del">-	SRC_LIST, DEST_LIST</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static int subscribe_port(struct snd_seq_client *client,
 			  struct snd_seq_client_port *port,
 			  struct snd_seq_port_subs_info *grp,
<span class="p_chunk">@@ -203,6 +199,20 @@</span> <span class="p_context"> static struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,</span>
 	return NULL;
 }
 
<span class="p_add">+static void delete_and_unsubscribe_port(struct snd_seq_client *client,</span>
<span class="p_add">+					struct snd_seq_client_port *port,</span>
<span class="p_add">+					struct snd_seq_subscribers *subs,</span>
<span class="p_add">+					bool is_src, bool ack);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct snd_seq_subscribers *</span>
<span class="p_add">+get_subscriber(struct list_head *p, bool is_src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (is_src)</span>
<span class="p_add">+		return list_entry(p, struct snd_seq_subscribers, src_list);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return list_entry(p, struct snd_seq_subscribers, dest_list);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * remove all subscribers on the list
  * this is called from port_delete, for each src and dest list.
<span class="p_chunk">@@ -210,7 +220,7 @@</span> <span class="p_context"> static struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,</span>
 static void clear_subscriber_list(struct snd_seq_client *client,
 				  struct snd_seq_client_port *port,
 				  struct snd_seq_port_subs_info *grp,
<span class="p_del">-				  int grptype)</span>
<span class="p_add">+				  int is_src)</span>
 {
 	struct list_head *p, *n;
 
<span class="p_chunk">@@ -219,15 +229,13 @@</span> <span class="p_context"> static void clear_subscriber_list(struct snd_seq_client *client,</span>
 		struct snd_seq_client *c;
 		struct snd_seq_client_port *aport;
 
<span class="p_del">-		if (grptype == SRC_LIST) {</span>
<span class="p_del">-			subs = list_entry(p, struct snd_seq_subscribers, src_list);</span>
<span class="p_add">+		subs = get_subscriber(p, is_src);</span>
<span class="p_add">+		if (is_src)</span>
 			aport = get_client_port(&amp;subs-&gt;info.dest, &amp;c);
<span class="p_del">-		} else {</span>
<span class="p_del">-			subs = list_entry(p, struct snd_seq_subscribers, dest_list);</span>
<span class="p_add">+		else</span>
 			aport = get_client_port(&amp;subs-&gt;info.sender, &amp;c);
<span class="p_del">-		}</span>
<span class="p_del">-		list_del(p);</span>
<span class="p_del">-		unsubscribe_port(client, port, grp, &amp;subs-&gt;info, 0);</span>
<span class="p_add">+		delete_and_unsubscribe_port(client, port, subs, is_src, false);</span>
<span class="p_add">+</span>
 		if (!aport) {
 			/* looks like the connected port is being deleted.
 			 * we decrease the counter, and when both ports are deleted
<span class="p_chunk">@@ -235,21 +243,14 @@</span> <span class="p_context"> static void clear_subscriber_list(struct snd_seq_client *client,</span>
 			 */
 			if (atomic_dec_and_test(&amp;subs-&gt;ref_count))
 				kfree(subs);
<span class="p_del">-		} else {</span>
<span class="p_del">-			/* ok we got the connected port */</span>
<span class="p_del">-			struct snd_seq_port_subs_info *agrp;</span>
<span class="p_del">-			agrp = (grptype == SRC_LIST) ? &amp;aport-&gt;c_dest : &amp;aport-&gt;c_src;</span>
<span class="p_del">-			down_write(&amp;agrp-&gt;list_mutex);</span>
<span class="p_del">-			if (grptype == SRC_LIST)</span>
<span class="p_del">-				list_del(&amp;subs-&gt;dest_list);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				list_del(&amp;subs-&gt;src_list);</span>
<span class="p_del">-			up_write(&amp;agrp-&gt;list_mutex);</span>
<span class="p_del">-			unsubscribe_port(c, aport, agrp, &amp;subs-&gt;info, 1);</span>
<span class="p_del">-			kfree(subs);</span>
<span class="p_del">-			snd_seq_port_unlock(aport);</span>
<span class="p_del">-			snd_seq_client_unlock(c);</span>
<span class="p_add">+			continue;</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* ok we got the connected port */</span>
<span class="p_add">+		delete_and_unsubscribe_port(c, aport, subs, !is_src, true);</span>
<span class="p_add">+		kfree(subs);</span>
<span class="p_add">+		snd_seq_port_unlock(aport);</span>
<span class="p_add">+		snd_seq_client_unlock(c);</span>
 	}
 }
 
<span class="p_chunk">@@ -262,8 +263,8 @@</span> <span class="p_context"> static int port_delete(struct snd_seq_client *client,</span>
 	snd_use_lock_sync(&amp;port-&gt;use_lock); 
 
 	/* clear subscribers info */
<span class="p_del">-	clear_subscriber_list(client, port, &amp;port-&gt;c_src, SRC_LIST);</span>
<span class="p_del">-	clear_subscriber_list(client, port, &amp;port-&gt;c_dest, DEST_LIST);</span>
<span class="p_add">+	clear_subscriber_list(client, port, &amp;port-&gt;c_src, true);</span>
<span class="p_add">+	clear_subscriber_list(client, port, &amp;port-&gt;c_dest, false);</span>
 
 	if (port-&gt;private_free)
 		port-&gt;private_free(port-&gt;private_data);
<span class="p_chunk">@@ -479,85 +480,120 @@</span> <span class="p_context"> static int match_subs_info(struct snd_seq_port_subscribe *r,</span>
 	return 0;
 }
 
<span class="p_del">-</span>
<span class="p_del">-/* connect two ports */</span>
<span class="p_del">-int snd_seq_port_connect(struct snd_seq_client *connector,</span>
<span class="p_del">-			 struct snd_seq_client *src_client,</span>
<span class="p_del">-			 struct snd_seq_client_port *src_port,</span>
<span class="p_del">-			 struct snd_seq_client *dest_client,</span>
<span class="p_del">-			 struct snd_seq_client_port *dest_port,</span>
<span class="p_del">-			 struct snd_seq_port_subscribe *info)</span>
<span class="p_add">+static int check_and_subscribe_port(struct snd_seq_client *client,</span>
<span class="p_add">+				    struct snd_seq_client_port *port,</span>
<span class="p_add">+				    struct snd_seq_subscribers *subs,</span>
<span class="p_add">+				    bool is_src, bool exclusive, bool ack)</span>
 {
<span class="p_del">-	struct snd_seq_port_subs_info *src = &amp;src_port-&gt;c_src;</span>
<span class="p_del">-	struct snd_seq_port_subs_info *dest = &amp;dest_port-&gt;c_dest;</span>
<span class="p_del">-	struct snd_seq_subscribers *subs, *s;</span>
<span class="p_del">-	int err, src_called = 0;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	int exclusive;</span>
<span class="p_add">+	struct snd_seq_port_subs_info *grp;</span>
<span class="p_add">+	struct list_head *p;</span>
<span class="p_add">+	struct snd_seq_subscribers *s;</span>
<span class="p_add">+	int err;</span>
 
<span class="p_del">-	subs = kzalloc(sizeof(*subs), GFP_KERNEL);</span>
<span class="p_del">-	if (! subs)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	subs-&gt;info = *info;</span>
<span class="p_del">-	atomic_set(&amp;subs-&gt;ref_count, 2);</span>
<span class="p_del">-</span>
<span class="p_del">-	down_write(&amp;src-&gt;list_mutex);</span>
<span class="p_del">-	down_write_nested(&amp;dest-&gt;list_mutex, SINGLE_DEPTH_NESTING);</span>
<span class="p_del">-</span>
<span class="p_del">-	exclusive = info-&gt;flags &amp; SNDRV_SEQ_PORT_SUBS_EXCLUSIVE ? 1 : 0;</span>
<span class="p_add">+	grp = is_src ? &amp;port-&gt;c_src : &amp;port-&gt;c_dest;</span>
 	err = -EBUSY;
<span class="p_add">+	down_write(&amp;grp-&gt;list_mutex);</span>
 	if (exclusive) {
<span class="p_del">-		if (! list_empty(&amp;src-&gt;list_head) || ! list_empty(&amp;dest-&gt;list_head))</span>
<span class="p_add">+		if (!list_empty(&amp;grp-&gt;list_head))</span>
 			goto __error;
 	} else {
<span class="p_del">-		if (src-&gt;exclusive || dest-&gt;exclusive)</span>
<span class="p_add">+		if (grp-&gt;exclusive)</span>
 			goto __error;
 		/* check whether already exists */
<span class="p_del">-		list_for_each_entry(s, &amp;src-&gt;list_head, src_list) {</span>
<span class="p_del">-			if (match_subs_info(info, &amp;s-&gt;info))</span>
<span class="p_del">-				goto __error;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		list_for_each_entry(s, &amp;dest-&gt;list_head, dest_list) {</span>
<span class="p_del">-			if (match_subs_info(info, &amp;s-&gt;info))</span>
<span class="p_add">+		list_for_each(p, &amp;grp-&gt;list_head) {</span>
<span class="p_add">+			s = get_subscriber(p, is_src);</span>
<span class="p_add">+			if (match_subs_info(&amp;subs-&gt;info, &amp;s-&gt;info))</span>
 				goto __error;
 		}
 	}
 
<span class="p_del">-	if ((err = subscribe_port(src_client, src_port, src, info,</span>
<span class="p_del">-				  connector-&gt;number != src_client-&gt;number)) &lt; 0)</span>
<span class="p_del">-		goto __error;</span>
<span class="p_del">-	src_called = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((err = subscribe_port(dest_client, dest_port, dest, info,</span>
<span class="p_del">-				  connector-&gt;number != dest_client-&gt;number)) &lt; 0)</span>
<span class="p_add">+	err = subscribe_port(client, port, grp, &amp;subs-&gt;info, ack);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		grp-&gt;exclusive = 0;</span>
 		goto __error;
<span class="p_add">+	}</span>
 
 	/* add to list */
<span class="p_del">-	write_lock_irqsave(&amp;src-&gt;list_lock, flags);</span>
<span class="p_del">-	// write_lock(&amp;dest-&gt;list_lock); // no other lock yet</span>
<span class="p_del">-	list_add_tail(&amp;subs-&gt;src_list, &amp;src-&gt;list_head);</span>
<span class="p_del">-	list_add_tail(&amp;subs-&gt;dest_list, &amp;dest-&gt;list_head);</span>
<span class="p_del">-	// write_unlock(&amp;dest-&gt;list_lock); // no other lock yet</span>
<span class="p_del">-	write_unlock_irqrestore(&amp;src-&gt;list_lock, flags);</span>
<span class="p_add">+	write_lock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	if (is_src)</span>
<span class="p_add">+		list_add_tail(&amp;subs-&gt;src_list, &amp;grp-&gt;list_head);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		list_add_tail(&amp;subs-&gt;dest_list, &amp;grp-&gt;list_head);</span>
<span class="p_add">+	grp-&gt;exclusive = exclusive;</span>
<span class="p_add">+	atomic_inc(&amp;subs-&gt;ref_count);</span>
<span class="p_add">+	write_unlock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ __error:</span>
<span class="p_add">+	up_write(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	src-&gt;exclusive = dest-&gt;exclusive = exclusive;</span>
<span class="p_add">+static void delete_and_unsubscribe_port(struct snd_seq_client *client,</span>
<span class="p_add">+					struct snd_seq_client_port *port,</span>
<span class="p_add">+					struct snd_seq_subscribers *subs,</span>
<span class="p_add">+					bool is_src, bool ack)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_seq_port_subs_info *grp;</span>
<span class="p_add">+</span>
<span class="p_add">+	grp = is_src ? &amp;port-&gt;c_src : &amp;port-&gt;c_dest;</span>
<span class="p_add">+	down_write(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+	write_lock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	if (is_src)</span>
<span class="p_add">+		list_del(&amp;subs-&gt;src_list);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		list_del(&amp;subs-&gt;dest_list);</span>
<span class="p_add">+	grp-&gt;exclusive = 0;</span>
<span class="p_add">+	write_unlock_irq(&amp;grp-&gt;list_lock);</span>
<span class="p_add">+	up_write(&amp;grp-&gt;list_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	unsubscribe_port(client, port, grp, &amp;subs-&gt;info, ack);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* connect two ports */</span>
<span class="p_add">+int snd_seq_port_connect(struct snd_seq_client *connector,</span>
<span class="p_add">+			 struct snd_seq_client *src_client,</span>
<span class="p_add">+			 struct snd_seq_client_port *src_port,</span>
<span class="p_add">+			 struct snd_seq_client *dest_client,</span>
<span class="p_add">+			 struct snd_seq_client_port *dest_port,</span>
<span class="p_add">+			 struct snd_seq_port_subscribe *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snd_seq_subscribers *subs;</span>
<span class="p_add">+	bool exclusive;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	subs = kzalloc(sizeof(*subs), GFP_KERNEL);</span>
<span class="p_add">+	if (!subs)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	subs-&gt;info = *info;</span>
<span class="p_add">+	atomic_set(&amp;subs-&gt;ref_count, 0);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;subs-&gt;src_list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;subs-&gt;dest_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	exclusive = !!(info-&gt;flags &amp; SNDRV_SEQ_PORT_SUBS_EXCLUSIVE);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = check_and_subscribe_port(src_client, src_port, subs, true,</span>
<span class="p_add">+				       exclusive,</span>
<span class="p_add">+				       connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	err = check_and_subscribe_port(dest_client, dest_port, subs, false,</span>
<span class="p_add">+				       exclusive,</span>
<span class="p_add">+				       connector-&gt;number != dest_client-&gt;number);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error_dest;</span>
 
<span class="p_del">-	up_write(&amp;dest-&gt;list_mutex);</span>
<span class="p_del">-	up_write(&amp;src-&gt;list_mutex);</span>
 	return 0;
 
<span class="p_del">- __error:</span>
<span class="p_del">-	if (src_called)</span>
<span class="p_del">-		unsubscribe_port(src_client, src_port, src, info,</span>
<span class="p_del">-				 connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+ error_dest:</span>
<span class="p_add">+	delete_and_unsubscribe_port(src_client, src_port, subs, true,</span>
<span class="p_add">+				    connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+ error:</span>
 	kfree(subs);
<span class="p_del">-	up_write(&amp;dest-&gt;list_mutex);</span>
<span class="p_del">-	up_write(&amp;src-&gt;list_mutex);</span>
 	return err;
 }
 
<span class="p_del">-</span>
 /* remove the connection */
 int snd_seq_port_disconnect(struct snd_seq_client *connector,
 			    struct snd_seq_client *src_client,
<span class="p_chunk">@@ -567,37 +603,28 @@</span> <span class="p_context"> int snd_seq_port_disconnect(struct snd_seq_client *connector,</span>
 			    struct snd_seq_port_subscribe *info)
 {
 	struct snd_seq_port_subs_info *src = &amp;src_port-&gt;c_src;
<span class="p_del">-	struct snd_seq_port_subs_info *dest = &amp;dest_port-&gt;c_dest;</span>
 	struct snd_seq_subscribers *subs;
 	int err = -ENOENT;
<span class="p_del">-	unsigned long flags;</span>
 
 	down_write(&amp;src-&gt;list_mutex);
<span class="p_del">-	down_write_nested(&amp;dest-&gt;list_mutex, SINGLE_DEPTH_NESTING);</span>
<span class="p_del">-</span>
 	/* look for the connection */
 	list_for_each_entry(subs, &amp;src-&gt;list_head, src_list) {
 		if (match_subs_info(info, &amp;subs-&gt;info)) {
<span class="p_del">-			write_lock_irqsave(&amp;src-&gt;list_lock, flags);</span>
<span class="p_del">-			// write_lock(&amp;dest-&gt;list_lock);  // no lock yet</span>
<span class="p_del">-			list_del(&amp;subs-&gt;src_list);</span>
<span class="p_del">-			list_del(&amp;subs-&gt;dest_list);</span>
<span class="p_del">-			// write_unlock(&amp;dest-&gt;list_lock);</span>
<span class="p_del">-			write_unlock_irqrestore(&amp;src-&gt;list_lock, flags);</span>
<span class="p_del">-			src-&gt;exclusive = dest-&gt;exclusive = 0;</span>
<span class="p_del">-			unsubscribe_port(src_client, src_port, src, info,</span>
<span class="p_del">-					 connector-&gt;number != src_client-&gt;number);</span>
<span class="p_del">-			unsubscribe_port(dest_client, dest_port, dest, info,</span>
<span class="p_del">-					 connector-&gt;number != dest_client-&gt;number);</span>
<span class="p_del">-			kfree(subs);</span>
<span class="p_add">+			atomic_dec(&amp;subs-&gt;ref_count); /* mark as not ready */</span>
 			err = 0;
 			break;
 		}
 	}
<span class="p_del">-</span>
<span class="p_del">-	up_write(&amp;dest-&gt;list_mutex);</span>
 	up_write(&amp;src-&gt;list_mutex);
<span class="p_del">-	return err;</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	delete_and_unsubscribe_port(src_client, src_port, subs, true,</span>
<span class="p_add">+				    connector-&gt;number != src_client-&gt;number);</span>
<span class="p_add">+	delete_and_unsubscribe_port(dest_client, dest_port, subs, false,</span>
<span class="p_add">+				    connector-&gt;number != dest_client-&gt;number);</span>
<span class="p_add">+	kfree(subs);</span>
<span class="p_add">+	return 0;</span>
 }
 
 
<span class="p_header">diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c</span>
<span class="p_header">index 82b220c769c1..293104926098 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_timer.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_timer.c</span>
<span class="p_chunk">@@ -90,6 +90,9 @@</span> <span class="p_context"> void snd_seq_timer_delete(struct snd_seq_timer **tmr)</span>
 
 void snd_seq_timer_defaults(struct snd_seq_timer * tmr)
 {
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
 	/* setup defaults */
 	tmr-&gt;ppq = 96;		/* 96 PPQ */
 	tmr-&gt;tempo = 500000;	/* 120 BPM */
<span class="p_chunk">@@ -105,21 +108,25 @@</span> <span class="p_context"> void snd_seq_timer_defaults(struct snd_seq_timer * tmr)</span>
 	tmr-&gt;preferred_resolution = seq_default_timer_resolution;
 
 	tmr-&gt;skew = tmr-&gt;skew_base = SKEW_BASE;
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
 }
 
<span class="p_del">-void snd_seq_timer_reset(struct snd_seq_timer * tmr)</span>
<span class="p_add">+static void seq_timer_reset(struct snd_seq_timer *tmr)</span>
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	/* reset time &amp; songposition */
 	tmr-&gt;cur_time.tv_sec = 0;
 	tmr-&gt;cur_time.tv_nsec = 0;
 
 	tmr-&gt;tick.cur_tick = 0;
 	tmr-&gt;tick.fraction = 0;
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void snd_seq_timer_reset(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	seq_timer_reset(tmr);</span>
 	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);
 }
 
<span class="p_chunk">@@ -138,8 +145,11 @@</span> <span class="p_context"> static void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,</span>
 	tmr = q-&gt;timer;
 	if (tmr == NULL)
 		return;
<span class="p_del">-	if (!tmr-&gt;running)</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	if (!tmr-&gt;running) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
 		return;
<span class="p_add">+	}</span>
 
 	resolution *= ticks;
 	if (tmr-&gt;skew != tmr-&gt;skew_base) {
<span class="p_chunk">@@ -148,8 +158,6 @@</span> <span class="p_context"> static void snd_seq_timer_interrupt(struct snd_timer_instance *timeri,</span>
 			(((resolution &amp; 0xffff) * tmr-&gt;skew) &gt;&gt; 16);
 	}
 
<span class="p_del">-	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	/* update timer */
 	snd_seq_inc_time_nsec(&amp;tmr-&gt;cur_time, resolution);
 
<span class="p_chunk">@@ -296,26 +304,30 @@</span> <span class="p_context"> int snd_seq_timer_open(struct snd_seq_queue *q)</span>
 	t-&gt;callback = snd_seq_timer_interrupt;
 	t-&gt;callback_data = q;
 	t-&gt;flags |= SNDRV_TIMER_IFLG_AUTO;
<span class="p_add">+	spin_lock_irq(&amp;tmr-&gt;lock);</span>
 	tmr-&gt;timeri = t;
<span class="p_add">+	spin_unlock_irq(&amp;tmr-&gt;lock);</span>
 	return 0;
 }
 
 int snd_seq_timer_close(struct snd_seq_queue *q)
 {
 	struct snd_seq_timer *tmr;
<span class="p_add">+	struct snd_timer_instance *t;</span>
 	
 	tmr = q-&gt;timer;
 	if (snd_BUG_ON(!tmr))
 		return -EINVAL;
<span class="p_del">-	if (tmr-&gt;timeri) {</span>
<span class="p_del">-		snd_timer_stop(tmr-&gt;timeri);</span>
<span class="p_del">-		snd_timer_close(tmr-&gt;timeri);</span>
<span class="p_del">-		tmr-&gt;timeri = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	spin_lock_irq(&amp;tmr-&gt;lock);</span>
<span class="p_add">+	t = tmr-&gt;timeri;</span>
<span class="p_add">+	tmr-&gt;timeri = NULL;</span>
<span class="p_add">+	spin_unlock_irq(&amp;tmr-&gt;lock);</span>
<span class="p_add">+	if (t)</span>
<span class="p_add">+		snd_timer_close(t);</span>
 	return 0;
 }
 
<span class="p_del">-int snd_seq_timer_stop(struct snd_seq_timer * tmr)</span>
<span class="p_add">+static int seq_timer_stop(struct snd_seq_timer *tmr)</span>
 {
 	if (! tmr-&gt;timeri)
 		return -EINVAL;
<span class="p_chunk">@@ -326,6 +338,17 @@</span> <span class="p_context"> int snd_seq_timer_stop(struct snd_seq_timer * tmr)</span>
 	return 0;
 }
 
<span class="p_add">+int snd_seq_timer_stop(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	err = seq_timer_stop(tmr);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int initialize_timer(struct snd_seq_timer *tmr)
 {
 	struct snd_timer *t;
<span class="p_chunk">@@ -358,13 +381,13 @@</span> <span class="p_context"> static int initialize_timer(struct snd_seq_timer *tmr)</span>
 	return 0;
 }
 
<span class="p_del">-int snd_seq_timer_start(struct snd_seq_timer * tmr)</span>
<span class="p_add">+static int seq_timer_start(struct snd_seq_timer *tmr)</span>
 {
 	if (! tmr-&gt;timeri)
 		return -EINVAL;
 	if (tmr-&gt;running)
<span class="p_del">-		snd_seq_timer_stop(tmr);</span>
<span class="p_del">-	snd_seq_timer_reset(tmr);</span>
<span class="p_add">+		seq_timer_stop(tmr);</span>
<span class="p_add">+	seq_timer_reset(tmr);</span>
 	if (initialize_timer(tmr) &lt; 0)
 		return -EINVAL;
 	snd_timer_start(tmr-&gt;timeri, tmr-&gt;ticks);
<span class="p_chunk">@@ -373,14 +396,25 @@</span> <span class="p_context"> int snd_seq_timer_start(struct snd_seq_timer * tmr)</span>
 	return 0;
 }
 
<span class="p_del">-int snd_seq_timer_continue(struct snd_seq_timer * tmr)</span>
<span class="p_add">+int snd_seq_timer_start(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	err = seq_timer_start(tmr);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int seq_timer_continue(struct snd_seq_timer *tmr)</span>
 {
 	if (! tmr-&gt;timeri)
 		return -EINVAL;
 	if (tmr-&gt;running)
 		return -EBUSY;
 	if (! tmr-&gt;initialized) {
<span class="p_del">-		snd_seq_timer_reset(tmr);</span>
<span class="p_add">+		seq_timer_reset(tmr);</span>
 		if (initialize_timer(tmr) &lt; 0)
 			return -EINVAL;
 	}
<span class="p_chunk">@@ -390,11 +424,24 @@</span> <span class="p_context"> int snd_seq_timer_continue(struct snd_seq_timer * tmr)</span>
 	return 0;
 }
 
<span class="p_add">+int snd_seq_timer_continue(struct snd_seq_timer *tmr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	err = seq_timer_continue(tmr);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* return current &#39;real&#39; time. use timeofday() to get better granularity. */
 snd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)
 {
 	snd_seq_real_time_t cur_time;
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	spin_lock_irqsave(&amp;tmr-&gt;lock, flags);</span>
 	cur_time = tmr-&gt;cur_time;
 	if (tmr-&gt;running) { 
 		struct timeval tm;
<span class="p_chunk">@@ -410,7 +457,7 @@</span> <span class="p_context"> snd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)</span>
 		}
 		snd_seq_sanity_real_time(&amp;cur_time);
 	}
<span class="p_del">-                </span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);</span>
 	return cur_time;	
 }
 
<span class="p_header">diff --git a/sound/core/seq/seq_virmidi.c b/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">index 56e0f4cd3f82..81134e067184 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_virmidi.c</span>
<span class="p_chunk">@@ -155,21 +155,26 @@</span> <span class="p_context"> static void snd_virmidi_output_trigger(struct snd_rawmidi_substream *substream,</span>
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
 	int count, res;
 	unsigned char buf[32], *pbuf;
<span class="p_add">+	unsigned long flags;</span>
 
 	if (up) {
 		vmidi-&gt;trigger = 1;
 		if (vmidi-&gt;seq_mode == SNDRV_VIRMIDI_SEQ_DISPATCH &amp;&amp;
 		    !(vmidi-&gt;rdev-&gt;flags &amp; SNDRV_VIRMIDI_SUBSCRIBE)) {
<span class="p_del">-			snd_rawmidi_transmit_ack(substream, substream-&gt;runtime-&gt;buffer_size - substream-&gt;runtime-&gt;avail);</span>
<span class="p_del">-			return;		/* ignored */</span>
<span class="p_add">+			while (snd_rawmidi_transmit(substream, buf,</span>
<span class="p_add">+						    sizeof(buf)) &gt; 0) {</span>
<span class="p_add">+				/* ignored */</span>
<span class="p_add">+			}</span>
<span class="p_add">+			return;</span>
 		}
 		if (vmidi-&gt;event.type != SNDRV_SEQ_EVENT_NONE) {
 			if (snd_seq_kernel_client_dispatch(vmidi-&gt;client, &amp;vmidi-&gt;event, in_atomic(), 0) &lt; 0)
 				return;
 			vmidi-&gt;event.type = SNDRV_SEQ_EVENT_NONE;
 		}
<span class="p_add">+		spin_lock_irqsave(&amp;substream-&gt;runtime-&gt;lock, flags);</span>
 		while (1) {
<span class="p_del">-			count = snd_rawmidi_transmit_peek(substream, buf, sizeof(buf));</span>
<span class="p_add">+			count = __snd_rawmidi_transmit_peek(substream, buf, sizeof(buf));</span>
 			if (count &lt;= 0)
 				break;
 			pbuf = buf;
<span class="p_chunk">@@ -179,16 +184,18 @@</span> <span class="p_context"> static void snd_virmidi_output_trigger(struct snd_rawmidi_substream *substream,</span>
 					snd_midi_event_reset_encode(vmidi-&gt;parser);
 					continue;
 				}
<span class="p_del">-				snd_rawmidi_transmit_ack(substream, res);</span>
<span class="p_add">+				__snd_rawmidi_transmit_ack(substream, res);</span>
 				pbuf += res;
 				count -= res;
 				if (vmidi-&gt;event.type != SNDRV_SEQ_EVENT_NONE) {
 					if (snd_seq_kernel_client_dispatch(vmidi-&gt;client, &amp;vmidi-&gt;event, in_atomic(), 0) &lt; 0)
<span class="p_del">-						return;</span>
<span class="p_add">+						goto out;</span>
 					vmidi-&gt;event.type = SNDRV_SEQ_EVENT_NONE;
 				}
 			}
 		}
<span class="p_add">+	out:</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;substream-&gt;runtime-&gt;lock, flags);</span>
 	} else {
 		vmidi-&gt;trigger = 0;
 	}
<span class="p_chunk">@@ -254,9 +261,13 @@</span> <span class="p_context"> static int snd_virmidi_output_open(struct snd_rawmidi_substream *substream)</span>
  */
 static int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)
 {
<span class="p_add">+	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;</span>
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
<span class="p_del">-	snd_midi_event_free(vmidi-&gt;parser);</span>
<span class="p_add">+</span>
<span class="p_add">+	write_lock_irq(&amp;rdev-&gt;filelist_lock);</span>
 	list_del(&amp;vmidi-&gt;list);
<span class="p_add">+	write_unlock_irq(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	snd_midi_event_free(vmidi-&gt;parser);</span>
 	substream-&gt;runtime-&gt;private_data = NULL;
 	kfree(vmidi);
 	return 0;
<span class="p_header">diff --git a/sound/core/timer.c b/sound/core/timer.c</span>
<span class="p_header">index 0a049c4578f1..f24c9fccf008 100644</span>
<span class="p_header">--- a/sound/core/timer.c</span>
<span class="p_header">+++ b/sound/core/timer.c</span>
<span class="p_chunk">@@ -305,8 +305,7 @@</span> <span class="p_context"> int snd_timer_open(struct snd_timer_instance **ti,</span>
 	return 0;
 }
 
<span class="p_del">-static int _snd_timer_stop(struct snd_timer_instance *timeri,</span>
<span class="p_del">-			   int keep_flag, int event);</span>
<span class="p_add">+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event);</span>
 
 /*
  * close a timer instance
<span class="p_chunk">@@ -348,7 +347,7 @@</span> <span class="p_context"> int snd_timer_close(struct snd_timer_instance *timeri)</span>
 		spin_unlock_irq(&amp;timer-&gt;lock);
 		mutex_lock(&amp;register_mutex);
 		list_del(&amp;timeri-&gt;open_list);
<span class="p_del">-		if (timer &amp;&amp; list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
<span class="p_add">+		if (list_empty(&amp;timer-&gt;open_list_head) &amp;&amp;</span>
 		    timer-&gt;hw.close)
 			timer-&gt;hw.close(timer);
 		/* remove slave links */
<span class="p_chunk">@@ -423,7 +422,7 @@</span> <span class="p_context"> static void snd_timer_notify1(struct snd_timer_instance *ti, int event)</span>
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
 	list_for_each_entry(ts, &amp;ti-&gt;slave_active_head, active_list)
 		if (ts-&gt;ccallback)
<span class="p_del">-			ts-&gt;ccallback(ti, event + 100, &amp;tstamp, resolution);</span>
<span class="p_add">+			ts-&gt;ccallback(ts, event + 100, &amp;tstamp, resolution);</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
 }
 
<span class="p_chunk">@@ -452,6 +451,10 @@</span> <span class="p_context"> static int snd_timer_start_slave(struct snd_timer_instance *timeri)</span>
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;slave_active_lock, flags);
<span class="p_add">+	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;slave_active_lock, flags);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
 	timeri-&gt;flags |= SNDRV_TIMER_IFLG_RUNNING;
 	if (timeri-&gt;master &amp;&amp; timeri-&gt;timer) {
 		spin_lock(&amp;timeri-&gt;timer-&gt;lock);
<span class="p_chunk">@@ -476,7 +479,8 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 		return -EINVAL;
 	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE) {
 		result = snd_timer_start_slave(timeri);
<span class="p_del">-		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
<span class="p_add">+		if (result &gt;= 0)</span>
<span class="p_add">+			snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
 		return result;
 	}
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -485,16 +489,22 @@</span> <span class="p_context"> int snd_timer_start(struct snd_timer_instance *timeri, unsigned int ticks)</span>
 	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)
 		return -ENODEV;
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
<span class="p_add">+	if (timeri-&gt;flags &amp; (SNDRV_TIMER_IFLG_RUNNING |</span>
<span class="p_add">+			     SNDRV_TIMER_IFLG_START)) {</span>
<span class="p_add">+		result = -EBUSY;</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+	}</span>
 	timeri-&gt;ticks = timeri-&gt;cticks = ticks;
 	timeri-&gt;pticks = 0;
 	result = snd_timer_start1(timer, timeri, ticks);
<span class="p_add">+ unlock:</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
<span class="p_del">-	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
<span class="p_add">+	if (result &gt;= 0)</span>
<span class="p_add">+		snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_START);</span>
 	return result;
 }
 
<span class="p_del">-static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
<span class="p_del">-			   int keep_flag, int event)</span>
<span class="p_add">+static int _snd_timer_stop(struct snd_timer_instance *timeri, int event)</span>
 {
 	struct snd_timer *timer;
 	unsigned long flags;
<span class="p_chunk">@@ -503,19 +513,30 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 		return -ENXIO;
 
 	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_SLAVE) {
<span class="p_del">-		if (!keep_flag) {</span>
<span class="p_del">-			spin_lock_irqsave(&amp;slave_active_lock, flags);</span>
<span class="p_del">-			timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;</span>
<span class="p_del">-			list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_del">-			list_del_init(&amp;timeri-&gt;active_list);</span>
<span class="p_add">+		spin_lock_irqsave(&amp;slave_active_lock, flags);</span>
<span class="p_add">+		if (!(timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING)) {</span>
 			spin_unlock_irqrestore(&amp;slave_active_lock, flags);
<span class="p_add">+			return -EBUSY;</span>
 		}
<span class="p_add">+		if (timeri-&gt;timer)</span>
<span class="p_add">+			spin_lock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+		timeri-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;</span>
<span class="p_add">+		list_del_init(&amp;timeri-&gt;ack_list);</span>
<span class="p_add">+		list_del_init(&amp;timeri-&gt;active_list);</span>
<span class="p_add">+		if (timeri-&gt;timer)</span>
<span class="p_add">+			spin_unlock(&amp;timeri-&gt;timer-&gt;lock);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;slave_active_lock, flags);</span>
 		goto __end;
 	}
 	timer = timeri-&gt;timer;
 	if (!timer)
 		return -EINVAL;
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
<span class="p_add">+	if (!(timeri-&gt;flags &amp; (SNDRV_TIMER_IFLG_RUNNING |</span>
<span class="p_add">+			       SNDRV_TIMER_IFLG_START))) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
 	list_del_init(&amp;timeri-&gt;ack_list);
 	list_del_init(&amp;timeri-&gt;active_list);
 	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown) {
<span class="p_chunk">@@ -534,9 +555,7 @@</span> <span class="p_context"> static int _snd_timer_stop(struct snd_timer_instance * timeri,</span>
 			}
 		}
 	}
<span class="p_del">-	if (!keep_flag)</span>
<span class="p_del">-		timeri-&gt;flags &amp;=</span>
<span class="p_del">-			~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);</span>
<span class="p_add">+	timeri-&gt;flags &amp;= ~(SNDRV_TIMER_IFLG_RUNNING | SNDRV_TIMER_IFLG_START);</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
       __end:
 	if (event != SNDRV_TIMER_EVENT_RESOLUTION)
<span class="p_chunk">@@ -555,7 +574,7 @@</span> <span class="p_context"> int snd_timer_stop(struct snd_timer_instance *timeri)</span>
 	unsigned long flags;
 	int err;
 
<span class="p_del">-	err = _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_STOP);</span>
<span class="p_add">+	err = _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_STOP);</span>
 	if (err &lt; 0)
 		return err;
 	timer = timeri-&gt;timer;
<span class="p_chunk">@@ -587,10 +606,15 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
 	if (timer-&gt;card &amp;&amp; timer-&gt;card-&gt;shutdown)
 		return -ENODEV;
 	spin_lock_irqsave(&amp;timer-&gt;lock, flags);
<span class="p_add">+	if (timeri-&gt;flags &amp; SNDRV_TIMER_IFLG_RUNNING) {</span>
<span class="p_add">+		result = -EBUSY;</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+	}</span>
 	if (!timeri-&gt;cticks)
 		timeri-&gt;cticks = 1;
 	timeri-&gt;pticks = 0;
 	result = snd_timer_start1(timer, timeri, timer-&gt;sticks);
<span class="p_add">+ unlock:</span>
 	spin_unlock_irqrestore(&amp;timer-&gt;lock, flags);
 	snd_timer_notify1(timeri, SNDRV_TIMER_EVENT_CONTINUE);
 	return result;
<span class="p_chunk">@@ -601,7 +625,7 @@</span> <span class="p_context"> int snd_timer_continue(struct snd_timer_instance *timeri)</span>
  */
 int snd_timer_pause(struct snd_timer_instance * timeri)
 {
<span class="p_del">-	return _snd_timer_stop(timeri, 0, SNDRV_TIMER_EVENT_PAUSE);</span>
<span class="p_add">+	return _snd_timer_stop(timeri, SNDRV_TIMER_EVENT_PAUSE);</span>
 }
 
 /*
<span class="p_chunk">@@ -724,8 +748,8 @@</span> <span class="p_context"> void snd_timer_interrupt(struct snd_timer * timer, unsigned long ticks_left)</span>
 			ti-&gt;cticks = ti-&gt;ticks;
 		} else {
 			ti-&gt;flags &amp;= ~SNDRV_TIMER_IFLG_RUNNING;
<span class="p_del">-			if (--timer-&gt;running)</span>
<span class="p_del">-				list_del_init(&amp;ti-&gt;active_list);</span>
<span class="p_add">+			--timer-&gt;running;</span>
<span class="p_add">+			list_del_init(&amp;ti-&gt;active_list);</span>
 		}
 		if ((timer-&gt;hw.flags &amp; SNDRV_TIMER_HW_TASKLET) ||
 		    (ti-&gt;flags &amp; SNDRV_TIMER_IFLG_FAST))
<span class="p_chunk">@@ -1900,6 +1924,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 {
 	struct snd_timer_user *tu;
 	long result = 0, unit;
<span class="p_add">+	int qhead;</span>
 	int err = 0;
 
 	tu = file-&gt;private_data;
<span class="p_chunk">@@ -1911,7 +1936,7 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 			if ((file-&gt;f_flags &amp; O_NONBLOCK) != 0 || result &gt; 0) {
 				err = -EAGAIN;
<span class="p_del">-				break;</span>
<span class="p_add">+				goto _error;</span>
 			}
 
 			set_current_state(TASK_INTERRUPTIBLE);
<span class="p_chunk">@@ -1926,42 +1951,37 @@</span> <span class="p_context"> static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,</span>
 
 			if (tu-&gt;disconnected) {
 				err = -ENODEV;
<span class="p_del">-				break;</span>
<span class="p_add">+				goto _error;</span>
 			}
 			if (signal_pending(current)) {
 				err = -ERESTARTSYS;
<span class="p_del">-				break;</span>
<span class="p_add">+				goto _error;</span>
 			}
 		}
 
<span class="p_add">+		qhead = tu-&gt;qhead++;</span>
<span class="p_add">+		tu-&gt;qhead %= tu-&gt;queue_size;</span>
 		spin_unlock_irq(&amp;tu-&gt;qlock);
<span class="p_del">-		if (err &lt; 0)</span>
<span class="p_del">-			goto _error;</span>
 
 		if (tu-&gt;tread) {
<span class="p_del">-			if (copy_to_user(buffer, &amp;tu-&gt;tqueue[tu-&gt;qhead++],</span>
<span class="p_del">-					 sizeof(struct snd_timer_tread))) {</span>
<span class="p_add">+			if (copy_to_user(buffer, &amp;tu-&gt;tqueue[qhead],</span>
<span class="p_add">+					 sizeof(struct snd_timer_tread)))</span>
 				err = -EFAULT;
<span class="p_del">-				goto _error;</span>
<span class="p_del">-			}</span>
 		} else {
<span class="p_del">-			if (copy_to_user(buffer, &amp;tu-&gt;queue[tu-&gt;qhead++],</span>
<span class="p_del">-					 sizeof(struct snd_timer_read))) {</span>
<span class="p_add">+			if (copy_to_user(buffer, &amp;tu-&gt;queue[qhead],</span>
<span class="p_add">+					 sizeof(struct snd_timer_read)))</span>
 				err = -EFAULT;
<span class="p_del">-				goto _error;</span>
<span class="p_del">-			}</span>
 		}
 
<span class="p_del">-		tu-&gt;qhead %= tu-&gt;queue_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		result += unit;</span>
<span class="p_del">-		buffer += unit;</span>
<span class="p_del">-</span>
 		spin_lock_irq(&amp;tu-&gt;qlock);
 		tu-&gt;qused--;
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto _error;</span>
<span class="p_add">+		result += unit;</span>
<span class="p_add">+		buffer += unit;</span>
 	}
<span class="p_del">-	spin_unlock_irq(&amp;tu-&gt;qlock);</span>
  _error:
<span class="p_add">+	spin_unlock_irq(&amp;tu-&gt;qlock);</span>
 	return result &gt; 0 ? result : err;
 }
 
<span class="p_header">diff --git a/sound/drivers/dummy.c b/sound/drivers/dummy.c</span>
<span class="p_header">index 016e451ed506..a9f7a75702d2 100644</span>
<span class="p_header">--- a/sound/drivers/dummy.c</span>
<span class="p_header">+++ b/sound/drivers/dummy.c</span>
<span class="p_chunk">@@ -109,6 +109,9 @@</span> <span class="p_context"> struct dummy_timer_ops {</span>
 	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
 };
 
<span class="p_add">+#define get_dummy_ops(substream) \</span>
<span class="p_add">+	(*(const struct dummy_timer_ops **)(substream)-&gt;runtime-&gt;private_data)</span>
<span class="p_add">+</span>
 struct dummy_model {
 	const char *name;
 	int (*playback_constraints)(struct snd_pcm_runtime *runtime);
<span class="p_chunk">@@ -137,7 +140,6 @@</span> <span class="p_context"> struct snd_dummy {</span>
 	int iobox;
 	struct snd_kcontrol *cd_volume_ctl;
 	struct snd_kcontrol *cd_switch_ctl;
<span class="p_del">-	const struct dummy_timer_ops *timer_ops;</span>
 };
 
 /*
<span class="p_chunk">@@ -231,6 +233,8 @@</span> <span class="p_context"> static struct dummy_model *dummy_models[] = {</span>
  */
 
 struct dummy_systimer_pcm {
<span class="p_add">+	/* ops must be the first item */</span>
<span class="p_add">+	const struct dummy_timer_ops *timer_ops;</span>
 	spinlock_t lock;
 	struct timer_list timer;
 	unsigned long base_time;
<span class="p_chunk">@@ -366,6 +370,8 @@</span> <span class="p_context"> static struct dummy_timer_ops dummy_systimer_ops = {</span>
  */
 
 struct dummy_hrtimer_pcm {
<span class="p_add">+	/* ops must be the first item */</span>
<span class="p_add">+	const struct dummy_timer_ops *timer_ops;</span>
 	ktime_t base_time;
 	ktime_t period_time;
 	atomic_t running;
<span class="p_chunk">@@ -492,31 +498,25 @@</span> <span class="p_context"> static struct dummy_timer_ops dummy_hrtimer_ops = {</span>
 
 static int dummy_pcm_trigger(struct snd_pcm_substream *substream, int cmd)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-</span>
 	switch (cmd) {
 	case SNDRV_PCM_TRIGGER_START:
 	case SNDRV_PCM_TRIGGER_RESUME:
<span class="p_del">-		return dummy-&gt;timer_ops-&gt;start(substream);</span>
<span class="p_add">+		return get_dummy_ops(substream)-&gt;start(substream);</span>
 	case SNDRV_PCM_TRIGGER_STOP:
 	case SNDRV_PCM_TRIGGER_SUSPEND:
<span class="p_del">-		return dummy-&gt;timer_ops-&gt;stop(substream);</span>
<span class="p_add">+		return get_dummy_ops(substream)-&gt;stop(substream);</span>
 	}
 	return -EINVAL;
 }
 
 static int dummy_pcm_prepare(struct snd_pcm_substream *substream)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-</span>
<span class="p_del">-	return dummy-&gt;timer_ops-&gt;prepare(substream);</span>
<span class="p_add">+	return get_dummy_ops(substream)-&gt;prepare(substream);</span>
 }
 
 static snd_pcm_uframes_t dummy_pcm_pointer(struct snd_pcm_substream *substream)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-</span>
<span class="p_del">-	return dummy-&gt;timer_ops-&gt;pointer(substream);</span>
<span class="p_add">+	return get_dummy_ops(substream)-&gt;pointer(substream);</span>
 }
 
 static struct snd_pcm_hardware dummy_pcm_hardware = {
<span class="p_chunk">@@ -562,17 +562,19 @@</span> <span class="p_context"> static int dummy_pcm_open(struct snd_pcm_substream *substream)</span>
 	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);
 	struct dummy_model *model = dummy-&gt;model;
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
<span class="p_add">+	const struct dummy_timer_ops *ops;</span>
 	int err;
 
<span class="p_del">-	dummy-&gt;timer_ops = &amp;dummy_systimer_ops;</span>
<span class="p_add">+	ops = &amp;dummy_systimer_ops;</span>
 #ifdef CONFIG_HIGH_RES_TIMERS
 	if (hrtimer)
<span class="p_del">-		dummy-&gt;timer_ops = &amp;dummy_hrtimer_ops;</span>
<span class="p_add">+		ops = &amp;dummy_hrtimer_ops;</span>
 #endif
 
<span class="p_del">-	err = dummy-&gt;timer_ops-&gt;create(substream);</span>
<span class="p_add">+	err = ops-&gt;create(substream);</span>
 	if (err &lt; 0)
 		return err;
<span class="p_add">+	get_dummy_ops(substream) = ops;</span>
 
 	runtime-&gt;hw = dummy-&gt;pcm_hw;
 	if (substream-&gt;pcm-&gt;device &amp; 1) {
<span class="p_chunk">@@ -594,7 +596,7 @@</span> <span class="p_context"> static int dummy_pcm_open(struct snd_pcm_substream *substream)</span>
 			err = model-&gt;capture_constraints(substream-&gt;runtime);
 	}
 	if (err &lt; 0) {
<span class="p_del">-		dummy-&gt;timer_ops-&gt;free(substream);</span>
<span class="p_add">+		get_dummy_ops(substream)-&gt;free(substream);</span>
 		return err;
 	}
 	return 0;
<span class="p_chunk">@@ -602,8 +604,7 @@</span> <span class="p_context"> static int dummy_pcm_open(struct snd_pcm_substream *substream)</span>
 
 static int dummy_pcm_close(struct snd_pcm_substream *substream)
 {
<span class="p_del">-	struct snd_dummy *dummy = snd_pcm_substream_chip(substream);</span>
<span class="p_del">-	dummy-&gt;timer_ops-&gt;free(substream);</span>
<span class="p_add">+	get_dummy_ops(substream)-&gt;free(substream);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/firewire/bebob/bebob_stream.c b/sound/firewire/bebob/bebob_stream.c</span>
<span class="p_header">index 926e5dcbb66a..5022c9b97ddf 100644</span>
<span class="p_header">--- a/sound/firewire/bebob/bebob_stream.c</span>
<span class="p_header">+++ b/sound/firewire/bebob/bebob_stream.c</span>
<span class="p_chunk">@@ -47,14 +47,16 @@</span> <span class="p_context"> static const unsigned int bridgeco_freq_table[] = {</span>
 	[6] = 0x07,
 };
 
<span class="p_del">-static unsigned int</span>
<span class="p_del">-get_formation_index(unsigned int rate)</span>
<span class="p_add">+static int</span>
<span class="p_add">+get_formation_index(unsigned int rate, unsigned int *index)</span>
 {
 	unsigned int i;
 
 	for (i = 0; i &lt; ARRAY_SIZE(snd_bebob_rate_table); i++) {
<span class="p_del">-		if (snd_bebob_rate_table[i] == rate)</span>
<span class="p_del">-			return i;</span>
<span class="p_add">+		if (snd_bebob_rate_table[i] == rate) {</span>
<span class="p_add">+			*index = i;</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	}
 	return -EINVAL;
 }
<span class="p_chunk">@@ -425,7 +427,9 @@</span> <span class="p_context"> make_both_connections(struct snd_bebob *bebob, unsigned int rate)</span>
 		goto end;
 
 	/* confirm params for both streams */
<span class="p_del">-	index = get_formation_index(rate);</span>
<span class="p_add">+	err = get_formation_index(rate, &amp;index);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto end;</span>
 	pcm_channels = bebob-&gt;tx_stream_formations[index].pcm;
 	midi_channels = bebob-&gt;tx_stream_formations[index].midi;
 	err = amdtp_am824_set_parameters(&amp;bebob-&gt;tx_stream, rate,
<span class="p_header">diff --git a/sound/isa/Kconfig b/sound/isa/Kconfig</span>
<span class="p_header">index 0216475fc759..37adcc6cbe6b 100644</span>
<span class="p_header">--- a/sound/isa/Kconfig</span>
<span class="p_header">+++ b/sound/isa/Kconfig</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 config SND_WSS_LIB
         tristate
         select SND_PCM
<span class="p_add">+	select SND_TIMER</span>
 
 config SND_SB_COMMON
         tristate
<span class="p_chunk">@@ -42,6 +43,7 @@</span> <span class="p_context"> config SND_AD1816A</span>
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_PCM
<span class="p_add">+	select SND_TIMER</span>
 	help
 	  Say Y here to include support for Analog Devices SoundPort
 	  AD1816A or compatible sound chips.
<span class="p_chunk">@@ -209,6 +211,7 @@</span> <span class="p_context"> config SND_GUSCLASSIC</span>
 	tristate &quot;Gravis UltraSound Classic&quot;
 	select SND_RAWMIDI
 	select SND_PCM
<span class="p_add">+	select SND_TIMER</span>
 	help
 	  Say Y here to include support for Gravis UltraSound Classic
 	  soundcards.
<span class="p_chunk">@@ -221,6 +224,7 @@</span> <span class="p_context"> config SND_GUSEXTREME</span>
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_PCM
<span class="p_add">+	select SND_TIMER</span>
 	help
 	  Say Y here to include support for Gravis UltraSound Extreme
 	  soundcards.
<span class="p_header">diff --git a/sound/pci/Kconfig b/sound/pci/Kconfig</span>
<span class="p_header">index 656ce39bddbc..8f6594a7d37f 100644</span>
<span class="p_header">--- a/sound/pci/Kconfig</span>
<span class="p_header">+++ b/sound/pci/Kconfig</span>
<span class="p_chunk">@@ -155,6 +155,7 @@</span> <span class="p_context"> config SND_AZT3328</span>
 	select SND_PCM
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
<span class="p_add">+	select SND_TIMER</span>
 	depends on ZONE_DMA
 	help
 	  Say Y here to include support for Aztech AZF3328 (PCI168)
<span class="p_chunk">@@ -463,6 +464,7 @@</span> <span class="p_context"> config SND_EMU10K1</span>
 	select SND_HWDEP
 	select SND_RAWMIDI
 	select SND_AC97_CODEC
<span class="p_add">+	select SND_TIMER</span>
 	depends on ZONE_DMA
 	help
 	  Say Y to include support for Sound Blaster PCI 512, Live!,
<span class="p_chunk">@@ -889,6 +891,7 @@</span> <span class="p_context"> config SND_YMFPCI</span>
 	select SND_OPL3_LIB
 	select SND_MPU401_UART
 	select SND_AC97_CODEC
<span class="p_add">+	select SND_TIMER</span>
 	help
 	  Say Y here to include support for Yamaha PCI audio chips -
 	  YMF724, YMF724F, YMF740, YMF740C, YMF744, YMF754.
<span class="p_header">diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c</span>
<span class="p_header">index c6e8a651cea1..5c4fa8eba1d0 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_generic.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_generic.c</span>
<span class="p_chunk">@@ -771,9 +771,6 @@</span> <span class="p_context"> static void activate_amp(struct hda_codec *codec, hda_nid_t nid, int dir,</span>
 	unsigned int caps;
 	unsigned int mask, val;
 
<span class="p_del">-	if (!enable &amp;&amp; is_active_nid(codec, nid, dir, idx_to_check))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	caps = query_amp_caps(codec, nid, dir);
 	val = get_amp_val_to_activate(codec, nid, dir, caps, enable);
 	mask = get_amp_mask_to_modify(codec, nid, dir, idx_to_check, caps);
<span class="p_chunk">@@ -784,12 +781,22 @@</span> <span class="p_context"> static void activate_amp(struct hda_codec *codec, hda_nid_t nid, int dir,</span>
 	update_amp(codec, nid, dir, idx, mask, val);
 }
 
<span class="p_add">+static void check_and_activate_amp(struct hda_codec *codec, hda_nid_t nid,</span>
<span class="p_add">+				   int dir, int idx, int idx_to_check,</span>
<span class="p_add">+				   bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* check whether the given amp is still used by others */</span>
<span class="p_add">+	if (!enable &amp;&amp; is_active_nid(codec, nid, dir, idx_to_check))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	activate_amp(codec, nid, dir, idx, idx_to_check, enable);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void activate_amp_out(struct hda_codec *codec, struct nid_path *path,
 			     int i, bool enable)
 {
 	hda_nid_t nid = path-&gt;path[i];
 	init_amp(codec, nid, HDA_OUTPUT, 0);
<span class="p_del">-	activate_amp(codec, nid, HDA_OUTPUT, 0, 0, enable);</span>
<span class="p_add">+	check_and_activate_amp(codec, nid, HDA_OUTPUT, 0, 0, enable);</span>
 }
 
 static void activate_amp_in(struct hda_codec *codec, struct nid_path *path,
<span class="p_chunk">@@ -817,9 +824,16 @@</span> <span class="p_context"> static void activate_amp_in(struct hda_codec *codec, struct nid_path *path,</span>
 	 * when aa-mixer is available, we need to enable the path as well
 	 */
 	for (n = 0; n &lt; nums; n++) {
<span class="p_del">-		if (n != idx &amp;&amp; (!add_aamix || conn[n] != spec-&gt;mixer_merge_nid))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		activate_amp(codec, nid, HDA_INPUT, n, idx, enable);</span>
<span class="p_add">+		if (n != idx) {</span>
<span class="p_add">+			if (conn[n] != spec-&gt;mixer_merge_nid)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			/* when aamix is disabled, force to off */</span>
<span class="p_add">+			if (!add_aamix) {</span>
<span class="p_add">+				activate_amp(codec, nid, HDA_INPUT, n, n, false);</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		check_and_activate_amp(codec, nid, HDA_INPUT, n, idx, enable);</span>
 	}
 }
 
<span class="p_chunk">@@ -1580,6 +1594,12 @@</span> <span class="p_context"> static bool map_singles(struct hda_codec *codec, int outs,</span>
 	return found;
 }
 
<span class="p_add">+static inline bool has_aamix_out_paths(struct hda_gen_spec *spec)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return spec-&gt;aamix_out_paths[0] || spec-&gt;aamix_out_paths[1] ||</span>
<span class="p_add">+		spec-&gt;aamix_out_paths[2];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* create a new path including aamix if available, and return its index */
 static int check_aamix_out_path(struct hda_codec *codec, int path_idx)
 {
<span class="p_chunk">@@ -2422,25 +2442,51 @@</span> <span class="p_context"> static void update_aamix_paths(struct hda_codec *codec, bool do_mix,</span>
 	}
 }
 
<span class="p_add">+/* re-initialize the output paths; only called from loopback_mixing_put() */</span>
<span class="p_add">+static void update_output_paths(struct hda_codec *codec, int num_outs,</span>
<span class="p_add">+				const int *paths)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hda_gen_spec *spec = codec-&gt;spec;</span>
<span class="p_add">+	struct nid_path *path;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_outs; i++) {</span>
<span class="p_add">+		path = snd_hda_get_path_from_idx(codec, paths[i]);</span>
<span class="p_add">+		if (path)</span>
<span class="p_add">+			snd_hda_activate_path(codec, path, path-&gt;active,</span>
<span class="p_add">+					      spec-&gt;aamix_mode);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int loopback_mixing_put(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
 	struct hda_codec *codec = snd_kcontrol_chip(kcontrol);
 	struct hda_gen_spec *spec = codec-&gt;spec;
<span class="p_add">+	const struct auto_pin_cfg *cfg = &amp;spec-&gt;autocfg;</span>
 	unsigned int val = ucontrol-&gt;value.enumerated.item[0];
 
 	if (val == spec-&gt;aamix_mode)
 		return 0;
 	spec-&gt;aamix_mode = val;
<span class="p_del">-	update_aamix_paths(codec, val, spec-&gt;out_paths[0],</span>
<span class="p_del">-			   spec-&gt;aamix_out_paths[0],</span>
<span class="p_del">-			   spec-&gt;autocfg.line_out_type);</span>
<span class="p_del">-	update_aamix_paths(codec, val, spec-&gt;hp_paths[0],</span>
<span class="p_del">-			   spec-&gt;aamix_out_paths[1],</span>
<span class="p_del">-			   AUTO_PIN_HP_OUT);</span>
<span class="p_del">-	update_aamix_paths(codec, val, spec-&gt;speaker_paths[0],</span>
<span class="p_del">-			   spec-&gt;aamix_out_paths[2],</span>
<span class="p_del">-			   AUTO_PIN_SPEAKER_OUT);</span>
<span class="p_add">+	if (has_aamix_out_paths(spec)) {</span>
<span class="p_add">+		update_aamix_paths(codec, val, spec-&gt;out_paths[0],</span>
<span class="p_add">+				   spec-&gt;aamix_out_paths[0],</span>
<span class="p_add">+				   cfg-&gt;line_out_type);</span>
<span class="p_add">+		update_aamix_paths(codec, val, spec-&gt;hp_paths[0],</span>
<span class="p_add">+				   spec-&gt;aamix_out_paths[1],</span>
<span class="p_add">+				   AUTO_PIN_HP_OUT);</span>
<span class="p_add">+		update_aamix_paths(codec, val, spec-&gt;speaker_paths[0],</span>
<span class="p_add">+				   spec-&gt;aamix_out_paths[2],</span>
<span class="p_add">+				   AUTO_PIN_SPEAKER_OUT);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		update_output_paths(codec, cfg-&gt;line_outs, spec-&gt;out_paths);</span>
<span class="p_add">+		if (cfg-&gt;line_out_type != AUTO_PIN_HP_OUT)</span>
<span class="p_add">+			update_output_paths(codec, cfg-&gt;hp_outs, spec-&gt;hp_paths);</span>
<span class="p_add">+		if (cfg-&gt;line_out_type != AUTO_PIN_SPEAKER_OUT)</span>
<span class="p_add">+			update_output_paths(codec, cfg-&gt;speaker_outs,</span>
<span class="p_add">+					    spec-&gt;speaker_paths);</span>
<span class="p_add">+	}</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -2458,12 +2504,13 @@</span> <span class="p_context"> static int create_loopback_mixing_ctl(struct hda_codec *codec)</span>
 
 	if (!spec-&gt;mixer_nid)
 		return 0;
<span class="p_del">-	if (!(spec-&gt;aamix_out_paths[0] || spec-&gt;aamix_out_paths[1] ||</span>
<span class="p_del">-	      spec-&gt;aamix_out_paths[2]))</span>
<span class="p_del">-		return 0;</span>
 	if (!snd_hda_gen_add_kctl(spec, NULL, &amp;loopback_mixing_enum))
 		return -ENOMEM;
 	spec-&gt;have_aamix_ctl = 1;
<span class="p_add">+	/* if no explicit aamix path is present (e.g. for Realtek codecs),</span>
<span class="p_add">+	 * enable aamix as default -- just for compatibility</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spec-&gt;aamix_mode = !has_aamix_out_paths(spec);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3998,9 +4045,9 @@</span> <span class="p_context"> static void pin_power_callback(struct hda_codec *codec,</span>
 			       struct hda_jack_callback *jack,
 			       bool on)
 {
<span class="p_del">-	if (jack &amp;&amp; jack-&gt;tbl-&gt;nid)</span>
<span class="p_add">+	if (jack &amp;&amp; jack-&gt;nid)</span>
 		sync_power_state_change(codec,
<span class="p_del">-					set_pin_power_jack(codec, jack-&gt;tbl-&gt;nid, on));</span>
<span class="p_add">+					set_pin_power_jack(codec, jack-&gt;nid, on));</span>
 }
 
 /* callback only doing power up -- called at first */
<span class="p_chunk">@@ -5664,6 +5711,8 @@</span> <span class="p_context"> static void init_aamix_paths(struct hda_codec *codec)</span>
 
 	if (!spec-&gt;have_aamix_ctl)
 		return;
<span class="p_add">+	if (!has_aamix_out_paths(spec))</span>
<span class="p_add">+		return;</span>
 	update_aamix_paths(codec, spec-&gt;aamix_mode, spec-&gt;out_paths[0],
 			   spec-&gt;aamix_out_paths[0],
 			   spec-&gt;autocfg.line_out_type);
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 614baff1f5d7..02a86ba5ba22 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -90,6 +90,8 @@</span> <span class="p_context"> enum {</span>
 #define NVIDIA_HDA_ENABLE_COHBIT      0x01
 
 /* Defines for Intel SCH HDA snoop control */
<span class="p_add">+#define INTEL_HDA_CGCTL	 0x48</span>
<span class="p_add">+#define INTEL_HDA_CGCTL_MISCBDCGE        (0x1 &lt;&lt; 6)</span>
 #define INTEL_SCH_HDA_DEVC      0x78
 #define INTEL_SCH_HDA_DEVC_NOSNOOP       (0x1&lt;&lt;11)
 
<span class="p_chunk">@@ -528,10 +530,21 @@</span> <span class="p_context"> static void hda_intel_init_chip(struct azx *chip, bool full_reset)</span>
 {
 	struct hdac_bus *bus = azx_bus(chip);
 	struct pci_dev *pci = chip-&gt;pci;
<span class="p_add">+	u32 val;</span>
 
 	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL)
 		snd_hdac_set_codec_wakeup(bus, true);
<span class="p_add">+	if (IS_BROXTON(pci)) {</span>
<span class="p_add">+		pci_read_config_dword(pci, INTEL_HDA_CGCTL, &amp;val);</span>
<span class="p_add">+		val = val &amp; ~INTEL_HDA_CGCTL_MISCBDCGE;</span>
<span class="p_add">+		pci_write_config_dword(pci, INTEL_HDA_CGCTL, val);</span>
<span class="p_add">+	}</span>
 	azx_init_chip(chip, full_reset);
<span class="p_add">+	if (IS_BROXTON(pci)) {</span>
<span class="p_add">+		pci_read_config_dword(pci, INTEL_HDA_CGCTL, &amp;val);</span>
<span class="p_add">+		val = val | INTEL_HDA_CGCTL_MISCBDCGE;</span>
<span class="p_add">+		pci_write_config_dword(pci, INTEL_HDA_CGCTL, val);</span>
<span class="p_add">+	}</span>
 	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL)
 		snd_hdac_set_codec_wakeup(bus, false);
 
<span class="p_header">diff --git a/sound/pci/hda/hda_jack.c b/sound/pci/hda/hda_jack.c</span>
<span class="p_header">index c945e257d368..a33234e04d4f 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_jack.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_jack.c</span>
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> snd_hda_jack_detect_enable_callback(struct hda_codec *codec, hda_nid_t nid,</span>
 		if (!callback)
 			return ERR_PTR(-ENOMEM);
 		callback-&gt;func = func;
<span class="p_del">-		callback-&gt;tbl = jack;</span>
<span class="p_add">+		callback-&gt;nid = jack-&gt;nid;</span>
 		callback-&gt;next = jack-&gt;callback;
 		jack-&gt;callback = callback;
 	}
<span class="p_header">diff --git a/sound/pci/hda/hda_jack.h b/sound/pci/hda/hda_jack.h</span>
<span class="p_header">index 858708a044f5..e9814c0168ea 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_jack.h</span>
<span class="p_header">+++ b/sound/pci/hda/hda_jack.h</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"> struct hda_jack_callback;</span>
 typedef void (*hda_jack_callback_fn) (struct hda_codec *, struct hda_jack_callback *);
 
 struct hda_jack_callback {
<span class="p_del">-	struct hda_jack_tbl *tbl;</span>
<span class="p_add">+	hda_nid_t nid;</span>
 	hda_jack_callback_fn func;
 	unsigned int private_data;	/* arbitrary data */
 	struct hda_jack_callback *next;
<span class="p_header">diff --git a/sound/pci/hda/patch_ca0132.c b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">index 4ef2259f88ca..9ceb2bc36e68 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_ca0132.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_ca0132.c</span>
<span class="p_chunk">@@ -4427,13 +4427,16 @@</span> <span class="p_context"> static void ca0132_process_dsp_response(struct hda_codec *codec,</span>
 static void hp_callback(struct hda_codec *codec, struct hda_jack_callback *cb)
 {
 	struct ca0132_spec *spec = codec-&gt;spec;
<span class="p_add">+	struct hda_jack_tbl *tbl;</span>
 
 	/* Delay enabling the HP amp, to let the mic-detection
 	 * state machine run.
 	 */
 	cancel_delayed_work_sync(&amp;spec-&gt;unsol_hp_work);
 	schedule_delayed_work(&amp;spec-&gt;unsol_hp_work, msecs_to_jiffies(500));
<span class="p_del">-	cb-&gt;tbl-&gt;block_report = 1;</span>
<span class="p_add">+	tbl = snd_hda_jack_tbl_get(codec, cb-&gt;nid);</span>
<span class="p_add">+	if (tbl)</span>
<span class="p_add">+		tbl-&gt;block_report = 1;</span>
 }
 
 static void amic_callback(struct hda_codec *codec, struct hda_jack_callback *cb)
<span class="p_header">diff --git a/sound/pci/hda/patch_cirrus.c b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">index a12ae8ac0914..c1c855a6c0af 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_cirrus.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_cirrus.c</span>
<span class="p_chunk">@@ -614,6 +614,7 @@</span> <span class="p_context"> enum {</span>
 	CS4208_MAC_AUTO,
 	CS4208_MBA6,
 	CS4208_MBP11,
<span class="p_add">+	CS4208_MACMINI,</span>
 	CS4208_GPIO0,
 };
 
<span class="p_chunk">@@ -621,6 +622,7 @@</span> <span class="p_context"> static const struct hda_model_fixup cs4208_models[] = {</span>
 	{ .id = CS4208_GPIO0, .name = &quot;gpio0&quot; },
 	{ .id = CS4208_MBA6, .name = &quot;mba6&quot; },
 	{ .id = CS4208_MBP11, .name = &quot;mbp11&quot; },
<span class="p_add">+	{ .id = CS4208_MACMINI, .name = &quot;macmini&quot; },</span>
 	{}
 };
 
<span class="p_chunk">@@ -632,6 +634,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cs4208_fixup_tbl[] = {</span>
 /* codec SSID matching */
 static const struct snd_pci_quirk cs4208_mac_fixup_tbl[] = {
 	SND_PCI_QUIRK(0x106b, 0x5e00, &quot;MacBookPro 11,2&quot;, CS4208_MBP11),
<span class="p_add">+	SND_PCI_QUIRK(0x106b, 0x6c00, &quot;MacMini 7,1&quot;, CS4208_MACMINI),</span>
 	SND_PCI_QUIRK(0x106b, 0x7100, &quot;MacBookAir 6,1&quot;, CS4208_MBA6),
 	SND_PCI_QUIRK(0x106b, 0x7200, &quot;MacBookAir 6,2&quot;, CS4208_MBA6),
 	SND_PCI_QUIRK(0x106b, 0x7b00, &quot;MacBookPro 12,1&quot;, CS4208_MBP11),
<span class="p_chunk">@@ -666,6 +669,24 @@</span> <span class="p_context"> static void cs4208_fixup_mac(struct hda_codec *codec,</span>
 	snd_hda_apply_fixup(codec, action);
 }
 
<span class="p_add">+/* MacMini 7,1 has the inverted jack detection */</span>
<span class="p_add">+static void cs4208_fixup_macmini(struct hda_codec *codec,</span>
<span class="p_add">+				 const struct hda_fixup *fix, int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static const struct hda_pintbl pincfgs[] = {</span>
<span class="p_add">+		{ 0x18, 0x00ab9150 }, /* mic (audio-in) jack: disable detect */</span>
<span class="p_add">+		{ 0x21, 0x004be140 }, /* SPDIF: disable detect */</span>
<span class="p_add">+		{ }</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {</span>
<span class="p_add">+		/* HP pin (0x10) has an inverted detection */</span>
<span class="p_add">+		codec-&gt;inv_jack_detect = 1;</span>
<span class="p_add">+		/* disable the bogus Mic and SPDIF jack detections */</span>
<span class="p_add">+		snd_hda_apply_pincfgs(codec, pincfgs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int cs4208_spdif_sw_put(struct snd_kcontrol *kcontrol,
 			       struct snd_ctl_elem_value *ucontrol)
 {
<span class="p_chunk">@@ -709,6 +730,12 @@</span> <span class="p_context"> static const struct hda_fixup cs4208_fixups[] = {</span>
 		.chained = true,
 		.chain_id = CS4208_GPIO0,
 	},
<span class="p_add">+	[CS4208_MACMINI] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = cs4208_fixup_macmini,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = CS4208_GPIO0,</span>
<span class="p_add">+	},</span>
 	[CS4208_GPIO0] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cs4208_fixup_gpio0,
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index 4b6fb668c91c..70c945603379 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -438,7 +438,8 @@</span> <span class="p_context"> static int hdmi_eld_ctl_get(struct snd_kcontrol *kcontrol,</span>
 	eld = &amp;per_pin-&gt;sink_eld;
 
 	mutex_lock(&amp;per_pin-&gt;lock);
<span class="p_del">-	if (eld-&gt;eld_size &gt; ARRAY_SIZE(ucontrol-&gt;value.bytes.data)) {</span>
<span class="p_add">+	if (eld-&gt;eld_size &gt; ARRAY_SIZE(ucontrol-&gt;value.bytes.data) ||</span>
<span class="p_add">+	    eld-&gt;eld_size &gt; ELD_MAX_SIZE) {</span>
 		mutex_unlock(&amp;per_pin-&gt;lock);
 		snd_BUG();
 		return -EINVAL;
<span class="p_chunk">@@ -1183,7 +1184,7 @@</span> <span class="p_context"> static void check_presence_and_report(struct hda_codec *codec, hda_nid_t nid)</span>
 static void jack_callback(struct hda_codec *codec,
 			  struct hda_jack_callback *jack)
 {
<span class="p_del">-	check_presence_and_report(codec, jack-&gt;tbl-&gt;nid);</span>
<span class="p_add">+	check_presence_and_report(codec, jack-&gt;nid);</span>
 }
 
 static void hdmi_intrinsic_event(struct hda_codec *codec, unsigned int res)
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 33753244f48f..efd4980cffb8 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static void alc_update_knob_master(struct hda_codec *codec,</span>
 	uctl = kzalloc(sizeof(*uctl), GFP_KERNEL);
 	if (!uctl)
 		return;
<span class="p_del">-	val = snd_hda_codec_read(codec, jack-&gt;tbl-&gt;nid, 0,</span>
<span class="p_add">+	val = snd_hda_codec_read(codec, jack-&gt;nid, 0,</span>
 				 AC_VERB_GET_VOLUME_KNOB_CONTROL, 0);
 	val &amp;= HDA_AMP_VOLMASK;
 	uctl-&gt;value.integer.value[0] = val;
<span class="p_chunk">@@ -327,6 +327,7 @@</span> <span class="p_context"> static void alc_fill_eapd_coef(struct hda_codec *codec)</span>
 	case 0x10ec0292:
 		alc_update_coef_idx(codec, 0x4, 1&lt;&lt;15, 0);
 		break;
<span class="p_add">+	case 0x10ec0225:</span>
 	case 0x10ec0233:
 	case 0x10ec0255:
 	case 0x10ec0256:
<span class="p_chunk">@@ -900,6 +901,7 @@</span> <span class="p_context"> static struct alc_codec_rename_pci_table rename_pci_tbl[] = {</span>
 	{ 0x10ec0899, 0x1028, 0, &quot;ALC3861&quot; },
 	{ 0x10ec0298, 0x1028, 0, &quot;ALC3266&quot; },
 	{ 0x10ec0256, 0x1028, 0, &quot;ALC3246&quot; },
<span class="p_add">+	{ 0x10ec0225, 0x1028, 0, &quot;ALC3253&quot; },</span>
 	{ 0x10ec0670, 0x1025, 0, &quot;ALC669X&quot; },
 	{ 0x10ec0676, 0x1025, 0, &quot;ALC679X&quot; },
 	{ 0x10ec0282, 0x1043, 0, &quot;ALC3229&quot; },
<span class="p_chunk">@@ -1785,7 +1787,6 @@</span> <span class="p_context"> enum {</span>
 	ALC882_FIXUP_NO_PRIMARY_HP,
 	ALC887_FIXUP_ASUS_BASS,
 	ALC887_FIXUP_BASS_CHMAP,
<span class="p_del">-	ALC882_FIXUP_DISABLE_AAMIX,</span>
 };
 
 static void alc889_fixup_coef(struct hda_codec *codec,
<span class="p_chunk">@@ -1947,8 +1948,6 @@</span> <span class="p_context"> static void alc882_fixup_no_primary_hp(struct hda_codec *codec,</span>
 
 static void alc_fixup_bass_chmap(struct hda_codec *codec,
 				 const struct hda_fixup *fix, int action);
<span class="p_del">-static void alc_fixup_disable_aamix(struct hda_codec *codec,</span>
<span class="p_del">-				    const struct hda_fixup *fix, int action);</span>
 
 static const struct hda_fixup alc882_fixups[] = {
 	[ALC882_FIXUP_ABIT_AW9D_MAX] = {
<span class="p_chunk">@@ -2186,10 +2185,6 @@</span> <span class="p_context"> static const struct hda_fixup alc882_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_bass_chmap,
 	},
<span class="p_del">-	[ALC882_FIXUP_DISABLE_AAMIX] = {</span>
<span class="p_del">-		.type = HDA_FIXUP_FUNC,</span>
<span class="p_del">-		.v.func = alc_fixup_disable_aamix,</span>
<span class="p_del">-	},</span>
 };
 
 static const struct snd_pci_quirk alc882_fixup_tbl[] = {
<span class="p_chunk">@@ -2228,6 +2223,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9047, &quot;Sony Vaio TT&quot;, ALC889_FIXUP_VAIO_TT),
 	SND_PCI_QUIRK(0x104d, 0x905a, &quot;Sony Vaio Z&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
 	SND_PCI_QUIRK(0x104d, 0x9043, &quot;Sony Vaio VGC-LN51JGB&quot;, ALC882_FIXUP_NO_PRIMARY_HP),
<span class="p_add">+	SND_PCI_QUIRK(0x104d, 0x9044, &quot;Sony VAIO AiO&quot;, ALC882_FIXUP_NO_PRIMARY_HP),</span>
 
 	/* All Apple entries are in codec SSIDs */
 	SND_PCI_QUIRK(0x106b, 0x00a0, &quot;MacBookPro 3,1&quot;, ALC889_FIXUP_MBP_VREF),
<span class="p_chunk">@@ -2257,7 +2253,6 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc882_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1462, 0x7350, &quot;MSI-7350&quot;, ALC889_FIXUP_CD),
 	SND_PCI_QUIRK_VENDOR(0x1462, &quot;MSI&quot;, ALC882_FIXUP_GPIO3),
 	SND_PCI_QUIRK(0x1458, 0xa002, &quot;Gigabyte EP45-DS3/Z87X-UD3H&quot;, ALC889_FIXUP_FRONT_HP_NO_PRESENCE),
<span class="p_del">-	SND_PCI_QUIRK(0x1458, 0xa182, &quot;Gigabyte Z170X-UD3&quot;, ALC882_FIXUP_DISABLE_AAMIX),</span>
 	SND_PCI_QUIRK(0x147b, 0x107a, &quot;Abit AW9D-MAX&quot;, ALC882_FIXUP_ABIT_AW9D_MAX),
 	SND_PCI_QUIRK_VENDOR(0x1558, &quot;Clevo laptop&quot;, ALC882_FIXUP_EAPD),
 	SND_PCI_QUIRK(0x161f, 0x2054, &quot;Medion laptop&quot;, ALC883_FIXUP_EAPD),
<span class="p_chunk">@@ -2651,6 +2646,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_TYPE_ALC298,
 	ALC269_TYPE_ALC255,
 	ALC269_TYPE_ALC256,
<span class="p_add">+	ALC269_TYPE_ALC225,</span>
 };
 
 /*
<span class="p_chunk">@@ -2680,6 +2676,7 @@</span> <span class="p_context"> static int alc269_parse_auto_config(struct hda_codec *codec)</span>
 	case ALC269_TYPE_ALC298:
 	case ALC269_TYPE_ALC255:
 	case ALC269_TYPE_ALC256:
<span class="p_add">+	case ALC269_TYPE_ALC225:</span>
 		ssids = alc269_ssids;
 		break;
 	default:
<span class="p_chunk">@@ -3658,6 +3655,16 @@</span> <span class="p_context"> static void alc_headset_mode_unplugged(struct hda_codec *codec)</span>
 		WRITE_COEF(0xb7, 0x802b),
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0225[] = {</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 1&lt;&lt;8, 0),</span>
<span class="p_add">+		UPDATE_COEFEX(0x57, 0x05, 1&lt;&lt;14, 0),</span>
<span class="p_add">+		UPDATE_COEF(0x63, 3&lt;&lt;14, 3&lt;&lt;14),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 3&lt;&lt;4, 2&lt;&lt;4),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 3&lt;&lt;10, 3&lt;&lt;10),</span>
<span class="p_add">+		UPDATE_COEF(0x45, 0x3f&lt;&lt;10, 0x34&lt;&lt;10),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 3&lt;&lt;10, 0),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_chunk">@@ -3682,6 +3689,9 @@</span> <span class="p_context"> static void alc_headset_mode_unplugged(struct hda_codec *codec)</span>
 	case 0x10ec0668:
 		alc_process_coef_fw(codec, coef0668);
 		break;
<span class="p_add">+	case 0x10ec0225:</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0225);</span>
<span class="p_add">+		break;</span>
 	}
 	codec_dbg(codec, &quot;Headset jack set to unplugged mode.\n&quot;);
 }
<span class="p_chunk">@@ -3727,6 +3737,13 @@</span> <span class="p_context"> static void alc_headset_mode_mic_in(struct hda_codec *codec, hda_nid_t hp_pin,</span>
 		UPDATE_COEF(0xc3, 0, 1&lt;&lt;12),
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0225[] = {</span>
<span class="p_add">+		UPDATE_COEFEX(0x57, 0x05, 1&lt;&lt;14, 1&lt;&lt;14),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 3&lt;&lt;4, 2&lt;&lt;4),</span>
<span class="p_add">+		UPDATE_COEF(0x63, 3&lt;&lt;14, 0),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_chunk">@@ -3772,6 +3789,12 @@</span> <span class="p_context"> static void alc_headset_mode_mic_in(struct hda_codec *codec, hda_nid_t hp_pin,</span>
 		alc_process_coef_fw(codec, coef0688);
 		snd_hda_set_pin_ctl_cache(codec, mic_pin, PIN_VREF50);
 		break;
<span class="p_add">+	case 0x10ec0225:</span>
<span class="p_add">+		alc_update_coef_idx(codec, 0x45, 0x3f&lt;&lt;10, 0x31&lt;&lt;10);</span>
<span class="p_add">+		snd_hda_set_pin_ctl_cache(codec, hp_pin, 0);</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0225);</span>
<span class="p_add">+		snd_hda_set_pin_ctl_cache(codec, mic_pin, PIN_VREF50);</span>
<span class="p_add">+		break;</span>
 	}
 	codec_dbg(codec, &quot;Headset jack set to mic-in mode.\n&quot;);
 }
<span class="p_chunk">@@ -3884,6 +3907,13 @@</span> <span class="p_context"> static void alc_headset_mode_ctia(struct hda_codec *codec)</span>
 		WRITE_COEF(0xc3, 0x0000),
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0225[] = {</span>
<span class="p_add">+		UPDATE_COEF(0x45, 0x3f&lt;&lt;10, 0x35&lt;&lt;10),</span>
<span class="p_add">+		UPDATE_COEF(0x49, 1&lt;&lt;8, 1&lt;&lt;8),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 7&lt;&lt;6, 7&lt;&lt;6),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 3&lt;&lt;4, 3&lt;&lt;4),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_chunk">@@ -3912,6 +3942,9 @@</span> <span class="p_context"> static void alc_headset_mode_ctia(struct hda_codec *codec)</span>
 	case 0x10ec0668:
 		alc_process_coef_fw(codec, coef0688);
 		break;
<span class="p_add">+	case 0x10ec0225:</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0225);</span>
<span class="p_add">+		break;</span>
 	}
 	codec_dbg(codec, &quot;Headset jack set to iPhone-style headset mode.\n&quot;);
 }
<span class="p_chunk">@@ -3955,6 +3988,13 @@</span> <span class="p_context"> static void alc_headset_mode_omtp(struct hda_codec *codec)</span>
 		WRITE_COEF(0xc3, 0x0000),
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0225[] = {</span>
<span class="p_add">+		UPDATE_COEF(0x45, 0x3f&lt;&lt;10, 0x39&lt;&lt;10),</span>
<span class="p_add">+		UPDATE_COEF(0x49, 1&lt;&lt;8, 1&lt;&lt;8),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 7&lt;&lt;6, 7&lt;&lt;6),</span>
<span class="p_add">+		UPDATE_COEF(0x4a, 3&lt;&lt;4, 3&lt;&lt;4),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_chunk">@@ -3983,6 +4023,9 @@</span> <span class="p_context"> static void alc_headset_mode_omtp(struct hda_codec *codec)</span>
 	case 0x10ec0668:
 		alc_process_coef_fw(codec, coef0688);
 		break;
<span class="p_add">+	case 0x10ec0225:</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0225);</span>
<span class="p_add">+		break;</span>
 	}
 	codec_dbg(codec, &quot;Headset jack set to Nokia-style headset mode.\n&quot;);
 }
<span class="p_chunk">@@ -4014,6 +4057,11 @@</span> <span class="p_context"> static void alc_determine_headset_type(struct hda_codec *codec)</span>
 		WRITE_COEF(0xc3, 0x0c00),
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0225[] = {</span>
<span class="p_add">+		UPDATE_COEF(0x45, 0x3f&lt;&lt;10, 0x34&lt;&lt;10),</span>
<span class="p_add">+		UPDATE_COEF(0x49, 1&lt;&lt;8, 1&lt;&lt;8),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_chunk">@@ -4058,6 +4106,12 @@</span> <span class="p_context"> static void alc_determine_headset_type(struct hda_codec *codec)</span>
 		val = alc_read_coef_idx(codec, 0xbe);
 		is_ctia = (val &amp; 0x1c02) == 0x1c02;
 		break;
<span class="p_add">+	case 0x10ec0225:</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0225);</span>
<span class="p_add">+		msleep(800);</span>
<span class="p_add">+		val = alc_read_coef_idx(codec, 0x46);</span>
<span class="p_add">+		is_ctia = (val &amp; 0x00f0) == 0x00f0;</span>
<span class="p_add">+		break;</span>
 	}
 
 	codec_dbg(codec, &quot;Headset jack detected iPhone-style headset: %s\n&quot;,
<span class="p_chunk">@@ -5560,6 +5614,9 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{.id = ALC292_FIXUP_TPT440, .name = &quot;tpt440&quot;},
 	{}
 };
<span class="p_add">+#define ALC225_STANDARD_PINS \</span>
<span class="p_add">+	{0x12, 0xb7a60130}, \</span>
<span class="p_add">+	{0x21, 0x04211020}</span>
 
 #define ALC256_STANDARD_PINS \
 	{0x12, 0x90a60140}, \
<span class="p_chunk">@@ -5581,6 +5638,12 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{0x21, 0x03211020}
 
 static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0225, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC225_STANDARD_PINS,</span>
<span class="p_add">+		{0x14, 0x901701a0}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0225, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC225_STANDARD_PINS,</span>
<span class="p_add">+		{0x14, 0x901701b0}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL2_MIC_NO_PRESENCE,
 		{0x14, 0x90170110},
 		{0x21, 0x02211020}),
<span class="p_chunk">@@ -5906,6 +5969,9 @@</span> <span class="p_context"> static int patch_alc269(struct hda_codec *codec)</span>
 		spec-&gt;gen.mixer_nid = 0; /* ALC256 does not have any loopback mixer path */
 		alc_update_coef_idx(codec, 0x36, 1 &lt;&lt; 13, 1 &lt;&lt; 5); /* Switch pcbeep path to Line in path*/
 		break;
<span class="p_add">+	case 0x10ec0225:</span>
<span class="p_add">+		spec-&gt;codec_variant = ALC269_TYPE_ALC225;</span>
<span class="p_add">+		break;</span>
 	}
 
 	if (snd_hda_codec_read(codec, 0x51, 0, AC_VERB_PARAMETERS, 0) == 0x10ec5505) {
<span class="p_chunk">@@ -6796,6 +6862,7 @@</span> <span class="p_context"> static int patch_alc680(struct hda_codec *codec)</span>
  */
 static const struct hda_device_id snd_hda_id_realtek[] = {
 	HDA_CODEC_ENTRY(0x10ec0221, &quot;ALC221&quot;, patch_alc269),
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0225, &quot;ALC225&quot;, patch_alc269),</span>
 	HDA_CODEC_ENTRY(0x10ec0231, &quot;ALC231&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0233, &quot;ALC233&quot;, patch_alc269),
 	HDA_CODEC_ENTRY(0x10ec0235, &quot;ALC233&quot;, patch_alc269),
<span class="p_header">diff --git a/sound/pci/hda/patch_sigmatel.c b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">index 2c7c5eb8b1e9..37b70f8e878f 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_sigmatel.c</span>
<span class="p_chunk">@@ -493,9 +493,9 @@</span> <span class="p_context"> static void jack_update_power(struct hda_codec *codec,</span>
 	if (!spec-&gt;num_pwrs)
 		return;
 
<span class="p_del">-	if (jack &amp;&amp; jack-&gt;tbl-&gt;nid) {</span>
<span class="p_del">-		stac_toggle_power_map(codec, jack-&gt;tbl-&gt;nid,</span>
<span class="p_del">-				      snd_hda_jack_detect(codec, jack-&gt;tbl-&gt;nid),</span>
<span class="p_add">+	if (jack &amp;&amp; jack-&gt;nid) {</span>
<span class="p_add">+		stac_toggle_power_map(codec, jack-&gt;nid,</span>
<span class="p_add">+				      snd_hda_jack_detect(codec, jack-&gt;nid),</span>
 				      true);
 		return;
 	}
<span class="p_header">diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c</span>
<span class="p_header">index 3e3c7f6be29d..b74840b5becf 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5645.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5645.c</span>
<span class="p_chunk">@@ -621,7 +621,7 @@</span> <span class="p_context"> static const struct snd_kcontrol_new rt5645_snd_controls[] = {</span>
 
 	/* IN1/IN2 Control */
 	SOC_SINGLE_TLV(&quot;IN1 Boost&quot;, RT5645_IN1_CTRL1,
<span class="p_del">-		RT5645_BST_SFT1, 8, 0, bst_tlv),</span>
<span class="p_add">+		RT5645_BST_SFT1, 12, 0, bst_tlv),</span>
 	SOC_SINGLE_TLV(&quot;IN2 Boost&quot;, RT5645_IN2_CTRL,
 		RT5645_BST_SFT2, 8, 0, bst_tlv),
 
<span class="p_header">diff --git a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c</span>
<span class="p_header">index c86dc96e8986..65b936e251ea 100644</span>
<span class="p_header">--- a/sound/soc/soc-pcm.c</span>
<span class="p_header">+++ b/sound/soc/soc-pcm.c</span>
<span class="p_chunk">@@ -1743,7 +1743,8 @@</span> <span class="p_context"> int dpcm_be_dai_hw_free(struct snd_soc_pcm_runtime *fe, int stream)</span>
 		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_PREPARE) &amp;&amp;
 		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_HW_FREE) &amp;&amp;
 		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_PAUSED) &amp;&amp;
<span class="p_del">-		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_STOP))</span>
<span class="p_add">+		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_STOP) &amp;&amp;</span>
<span class="p_add">+		    (be-&gt;dpcm[stream].state != SND_SOC_DPCM_STATE_SUSPEND))</span>
 			continue;
 
 		dev_dbg(be-&gt;dev, &quot;ASoC: hw_free BE %s\n&quot;,
<span class="p_header">diff --git a/sound/sparc/Kconfig b/sound/sparc/Kconfig</span>
<span class="p_header">index d75deba5617d..dfcd38647606 100644</span>
<span class="p_header">--- a/sound/sparc/Kconfig</span>
<span class="p_header">+++ b/sound/sparc/Kconfig</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"> config SND_SUN_AMD7930</span>
 config SND_SUN_CS4231
 	tristate &quot;Sun CS4231&quot;
 	select SND_PCM
<span class="p_add">+	select SND_TIMER</span>
 	help
 	  Say Y here to include support for CS4231 sound device on Sun.
 
<span class="p_header">diff --git a/sound/usb/midi.c b/sound/usb/midi.c</span>
<span class="p_header">index 5b4c58c3e2c5..b21b76690b31 100644</span>
<span class="p_header">--- a/sound/usb/midi.c</span>
<span class="p_header">+++ b/sound/usb/midi.c</span>
<span class="p_chunk">@@ -2454,7 +2454,6 @@</span> <span class="p_context"> int snd_usbmidi_create(struct snd_card *card,</span>
 	else
 		err = snd_usbmidi_create_endpoints(umidi, endpoints);
 	if (err &lt; 0) {
<span class="p_del">-		snd_usbmidi_free(umidi);</span>
 		return err;
 	}
 
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 23ea6d800c4c..4f6ce1cac8e2 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1121,6 +1121,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	switch (chip-&gt;usb_id) {
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
<span class="p_add">+	case USB_ID(0x045E, 0x076F): /* MS Lifecam HD-6000 */</span>
 	case USB_ID(0x045E, 0x0772): /* MS Lifecam Studio */
 	case USB_ID(0x045E, 0x0779): /* MS Lifecam HD-3000 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
<span class="p_chunk">@@ -1205,8 +1206,12 @@</span> <span class="p_context"> void snd_usb_set_interface_quirk(struct usb_device *dev)</span>
 	 * &quot;Playback Design&quot; products need a 50ms delay after setting the
 	 * USB interface.
 	 */
<span class="p_del">-	if (le16_to_cpu(dev-&gt;descriptor.idVendor) == 0x23ba)</span>
<span class="p_add">+	switch (le16_to_cpu(dev-&gt;descriptor.idVendor)) {</span>
<span class="p_add">+	case 0x23ba: /* Playback Design */</span>
<span class="p_add">+	case 0x0644: /* TEAC Corp. */</span>
 		mdelay(50);
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,
<span class="p_chunk">@@ -1221,6 +1226,14 @@</span> <span class="p_context"> void snd_usb_ctl_msg_quirk(struct usb_device *dev, unsigned int pipe,</span>
 	    (requesttype &amp; USB_TYPE_MASK) == USB_TYPE_CLASS)
 		mdelay(20);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * &quot;TEAC Corp.&quot; products need a 20ms delay after each</span>
<span class="p_add">+	 * class compliant request</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((le16_to_cpu(dev-&gt;descriptor.idVendor) == 0x0644) &amp;&amp;</span>
<span class="p_add">+	    (requesttype &amp; USB_TYPE_MASK) == USB_TYPE_CLASS)</span>
<span class="p_add">+		mdelay(20);</span>
<span class="p_add">+</span>
 	/* Marantz/Denon devices with USB DAC functionality need a delay
 	 * after each class compliant request
 	 */
<span class="p_chunk">@@ -1269,7 +1282,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	case USB_ID(0x20b1, 0x3008): /* iFi Audio micro/nano iDSD */
 	case USB_ID(0x20b1, 0x2008): /* Matrix Audio X-Sabre */
 	case USB_ID(0x20b1, 0x300a): /* Matrix Audio Mini-i Pro */
<span class="p_del">-	case USB_ID(0x22d8, 0x0416): /* OPPO HA-1*/</span>
<span class="p_add">+	case USB_ID(0x22d9, 0x0416): /* OPPO HA-1 */</span>
 		if (fp-&gt;altsetting == 2)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;
<span class="p_chunk">@@ -1278,6 +1291,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	case USB_ID(0x20b1, 0x2009): /* DIYINHK DSD DXD 384kHz USB to I2S/DSD */
 	case USB_ID(0x20b1, 0x2023): /* JLsounds I2SoverUSB */
 	case USB_ID(0x20b1, 0x3023): /* Aune X1S 32BIT/384 DSD DAC */
<span class="p_add">+	case USB_ID(0x2616, 0x0106): /* PS Audio NuWave DAC */</span>
 		if (fp-&gt;altsetting == 3)
 			return SNDRV_PCM_FMTBIT_DSD_U32_BE;
 		break;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



