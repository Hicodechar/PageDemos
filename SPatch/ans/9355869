
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,2/2] iommu/exynos: Add proper runtime pm support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,2/2] iommu/exynos: Add proper runtime pm support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=2061">Marek Szyprowski</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 29, 2016, 8:12 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1475136751-31340-3-git-send-email-m.szyprowski@samsung.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9355869/mbox/"
   >mbox</a>
|
   <a href="/patch/9355869/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9355869/">/patch/9355869/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	ABB316086A for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 29 Sep 2016 08:13:37 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9C761298B6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 29 Sep 2016 08:13:37 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 90A9E298B9; Thu, 29 Sep 2016 08:13:37 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D8B2E298B7
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 29 Sep 2016 08:13:36 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755392AbcI2IN1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 29 Sep 2016 04:13:27 -0400
Received: from mailout1.w1.samsung.com ([210.118.77.11]:27081 &quot;EHLO
	mailout1.w1.samsung.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753813AbcI2IMp (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 29 Sep 2016 04:12:45 -0400
Received: from eucas1p1.samsung.com (unknown [182.198.249.206])
	by mailout1.w1.samsung.com
	(Oracle Communications Messaging Server 7.0.5.31.0 64bit (built May 5
	2014))
	with ESMTP id &lt;0OE9002SRAT6D460@mailout1.w1.samsung.com&gt;; Thu,
	29 Sep 2016 09:12:42 +0100 (BST)
Received: from eusmges3.samsung.com (unknown [203.254.199.242])
	by     eucas1p1.samsung.com (KnoxPortal) with ESMTP id
	20160929081241eucas1p1b8f62221cb8d79935f107195fb1c003c~4vRGvPyUT1594315943eucas1p1M;
	Thu, 29 Sep 2016 08:12:41 +0000 (GMT)
Received: from eucas1p2.samsung.com ( [182.198.249.207])
	by eusmges3.samsung.com (EUCPMTA) with SMTP id 65.EF.11330.9FCCCE75;
	Thu, 29     Sep 2016 09:12:41 +0100 (BST)
Received: from eusmgms2.samsung.com (unknown [182.198.249.180])
	by     eucas1p2.samsung.com (KnoxPortal) with ESMTP id
	20160929081240eucas1p231c1ab5c5936886cbec6bc3f5267c940~4vRFvPIvM2192921929eucas1p2a;
	Thu, 29 Sep 2016 08:12:40 +0000 (GMT)
X-AuditID: cbfec7f2-f79556d000002c42-74-57ecccf914dd
Received: from eusync4.samsung.com ( [203.254.199.214])
	by eusmgms2.samsung.com (EUCPMTA) with SMTP id F8.71.10494.DCCCCE75;
	Thu, 29     Sep 2016 09:11:57 +0100 (BST)
Received: from AMDC2765.digital.local ([106.116.147.25])
	by eusync4.samsung.com (Oracle Communications Messaging Server
	7.0.5.31.0 64bit  (built May  5 2014))
	with ESMTPA id &lt;0OE90036ZASY3B80@eusync4.samsung.com&gt;; Thu,
	29 Sep 2016 09:12:40 +0100 (BST)
From: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;
To: linux-pm@vger.kernel.org, linux-kernel@vger.kernel.org,
	iommu@lists.linux-foundation.org, linux-samsung-soc@vger.kernel.org
Cc: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;,
	Joerg Roedel &lt;joro@8bytes.org&gt;,
	Inki Dae &lt;inki.dae@samsung.com&gt;, Kukjin Kim &lt;kgene@kernel.org&gt;,
	Krzysztof Kozlowski &lt;k.kozlowski@samsung.com&gt;,
	Bartlomiej Zolnierkiewicz &lt;b.zolnierkie@samsung.com&gt;,
	&quot;Rafael J. Wysocki&quot; &lt;rjw@rjwysocki.net&gt;, Mark Brown &lt;broonie@kernel.org&gt;,
	&quot;Luis R. Rodriguez&quot; &lt;mcgrof@kernel.org&gt;,
	Greg Kroah-Hartman &lt;gregkh@linuxfoundation.org&gt;,
	Tomeu Vizoso &lt;tomeu.vizoso@collabora.com&gt;,
	Lukas Wunner &lt;lukas@wunner.de&gt;, Kevin Hilman &lt;khilman@kernel.org&gt;,
	Tobias Jakobi &lt;tjakobi@math.uni-bielefeld.de&gt;
Subject: [PATCH v4 2/2] iommu/exynos: Add proper runtime pm support
Date: Thu, 29 Sep 2016 10:12:31 +0200
Message-id: &lt;1475136751-31340-3-git-send-email-m.szyprowski@samsung.com&gt;
X-Mailer: git-send-email 1.9.1
In-reply-to: &lt;1475136751-31340-1-git-send-email-m.szyprowski@samsung.com&gt;
X-Brightmail-Tracker: H4sIAAAAAAAAAzVSa0hTYRjuO+fs7DhaHuaoLzWjRX8KTVPow5UV+eMIggbhICtdelJpXthU
	sj9eKi+LVFziMKuJt7C8tKaY5X15YeJlNtJ0SuhQUytSKw0l3Zn/nofneZ/nfeGlcFEJz5WK
	S0hmlQlyhYQUEM29G8OeG4PLMu9Gsxi90TbwUPHXORLdr2ggUdFMIYF0HVKU97SRj5YWfFDB
	7BKObG9nMTTWWkai1cdGgLTD7RhamHdDdUYrH40X2gAaNJl5KPvVTx7KrzOTF0XMXNdzjGmx
	VgJGX5tHMh3PXvMZzXgNYLZ7+YzBkkMw+YZawKzqPRhtTjMvVHBNcC6aVcSlssrTAZGC2OZJ
	G0iqj7z7wtiGZ4DWEDVwoiDtByc3f/M4fBCOTDeQaiCgRHQVgEZLFc6RVQBNi/3E3sTGzBeH
	UA3gZnaHYyQDg92mJmzXRdI+UL2itgtiOhPAtdxKbJfgdA8BS/O27I0u9GU4XKez5xL0Cbhk
	WSd3sZBm4MficpLr84ADvRq734kOgqMWmz0V0ot8WF7/b2cRaoccgfpOnPMHws/1f/gcdoHf
	+gwO7A7HNI8cNxQAmPXwFIe1AA6tCDkshT19o/YunD4Ai5pLHPFCmJst4iwMbLHkO1a7BCea
	VjDu+jIANXPfyULgrgP7aoGYTVHFx7AqXy+VPF6VkhDjFZUYrwc772La7vvVAtb7/bsBTQHJ
	fqF3/5JMxJOnqtLiuwGkcIlYeGZgWSYSRsvT7rHKxAhlioJVdQM3ipAcEn7QfZKJ6Bh5MnuH
	ZZNY5Z6KUU6uGeB4YtPVkJvVhoBW39GmcBqqa5xvnQ0ZsYbdcMrMTFoTmOv4aWX+40Pz8png
	qYgpf6VEupXwpPRC0eGezo4483xFvSm5K9gUraBua9o9g/5ekRZ7jb6Pe4nlrenyHzi3Tfy4
	PpveFWmdywoPazMfe4eFBvotH003SAXTCiI06ryEUMXKfU7iSpX8P4n9WJ0qAwAA
X-Brightmail-Tracker: H4sIAAAAAAAAA+NgFtrOIsWRmVeSWpSXmKPExsVy+t/xa7pnz7wJN1jzRMFi44z1rBZTHz5h
	s2hevJ7NYtL9CSwWC/ZbW3TO3sBu8fqFoUX/49fMFk83P2ayuLxrDpvF594jjBYzzu9jsnjx
	XNpi7ZG77BY3JjxltDhz+hKrRdvqD6wWfWsvsTkIeTw5OI/JY8fdJYwem1Z1snnsn7uG3WPy
	jeWMHv+OsXtsudrO4tG3ZRWjx+dNch4z2rexBnBFudlkpCampBYppOYl56dk5qXbKoWGuOla
	KCnkJeam2ipF6PqGBCkplCXmlAJ5RgZowME5wD1YSd8uwS1j2+2njAXrEirmH9nL3MC4y7+L
	kZNDQsBE4uf9W8wQtpjEhXvr2boYuTiEBJYwSpx5e4cFwmlikvh1ZCo7SBWbgKFE19susCoR
	gUZGiW1bJ7KDOMwCx1kkLhzpYAWpEhZwlji/dgELiM0ioCrx+upXNhCbV8BD4ujUhWwQ++Qk
	Th6bDFbPKeApcfHqU7C4EFDNgSk72CYw8i5gZFjFKJJaWpybnltspFecmFtcmpeul5yfu4kR
	GGnbjv3csoOx613wIUYBDkYlHt6OU6/DhVgTy4orcw8xSnAwK4nwGp18Ey7Em5JYWZValB9f
	VJqTWnyI0RToqInMUqLJ+cAkkFcSb2hiaG5paGRsYWFuZKQkzjv1w5VwIYH0xJLU7NTUgtQi
	mD4mDk6pBsauOWKWPfzBuy6/Kdl1mM0heuM1p+Z3lydeLvVOF5SLc/IOTHlwS/Fp64m9TTOn
	8MiFqVRNfXd8xeGTEuctJILWz/FbuuaYhWbdlOjCj5OOaV218k36eiT6t+2xnlK5ktDrDjeM
	/E1XBvN4fTx8XkLFsdiKn9fnk2n3t88KWtq+Zt1drvsnzVViKc5INNRiLipOBACGkTAPygIA
	AA==
X-MTR: 20000000000000000@CPGS
X-CMS-MailID: 20160929081240eucas1p231c1ab5c5936886cbec6bc3f5267c940
X-Msg-Generator: CA
X-Sender-IP: 182.198.249.180
X-Local-Sender: =?UTF-8?B?TWFyZWsgU3p5cHJvd3NraRtTUlBPTC1LZXJuZWwgKFRQKRs=?=
	=?UTF-8?B?7IK87ISx7KCE7J6QG1NlbmlvciBTb2Z0d2FyZSBFbmdpbmVlcg==?=
X-Global-Sender: =?UTF-8?B?TWFyZWsgU3p5cHJvd3NraRtTUlBPTC1LZXJuZWwgKFRQKRtT?=
	=?UTF-8?B?YW1zdW5nIEVsZWN0cm9uaWNzG1NlbmlvciBTb2Z0d2FyZSBFbmdpbmVlcg==?=
X-Sender-Code: =?UTF-8?B?QzEwG0VIURtDMTBDRDAyQ0QwMjczOTI=?=
CMS-TYPE: 201P
X-HopCount: 7
X-CMS-RootMailID: 20160929081240eucas1p231c1ab5c5936886cbec6bc3f5267c940
X-RootMTR: 20160929081240eucas1p231c1ab5c5936886cbec6bc3f5267c940
References: &lt;1475136751-31340-1-git-send-email-m.szyprowski@samsung.com&gt;
	&lt;CGME20160929081240eucas1p231c1ab5c5936886cbec6bc3f5267c940@eucas1p2.samsung.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2061">Marek Szyprowski</a> - Sept. 29, 2016, 8:12 a.m.</div>
<pre class="content">
This patch uses recently introduced device links to track the runtime pm
state of the master&#39;s device. This way each SYSMMU controller is runtime
activated when its master&#39;s device is active and can save/restore its state
instead of being enabled all the time. This way SYSMMU controllers no
longer prevents respective power domains to be turned off when master&#39;s
device is not used.
<span class="signed-off-by">
Signed-off-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;</span>
---
 drivers/iommu/exynos-iommu.c | 225 ++++++++++++++++++-------------------------
 1 file changed, 94 insertions(+), 131 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=153261">Luis R. Rodriguez</a> - Oct. 6, 2016, 5:37 p.m.</div>
<pre class="content">
On Thu, Sep 29, 2016 at 10:12:31AM +0200, Marek Szyprowski wrote:
<span class="quote">&gt; This patch uses recently introduced device links to track the runtime pm</span>
<span class="quote">&gt; state of the master&#39;s device. This way each SYSMMU controller is runtime</span>
<span class="quote">&gt; activated when its master&#39;s device is active </span>

instead of?

BTW what is the master device of a SYSMMU? I have no clue about these
IOMMU devices here.
<span class="quote">
&gt; and can save/restore its state instead of being enabled all the time.</span>

I take it this means currently even if the master device is disabled
(whatever that is) all SYSMMU controllers are kept enabled, is that right?
The issue here is this wastes power? Or what is the issue?
<span class="quote">
&gt; This way SYSMMU controllers no</span>
<span class="quote">&gt; longer prevents respective power domains to be turned off when master&#39;s</span>
<span class="quote">&gt; device is not used.</span>

So when the master device is idle we want to also remove power from the
controllers ? How much power does this save on a typical device in the
market BTW ?
<span class="quote">
&gt; Signed-off-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/iommu/exynos-iommu.c | 225 ++++++++++++++++++-------------------------</span>
<span class="quote">&gt;  1 file changed, 94 insertions(+), 131 deletions(-)</span>

I&#39;m reviewing the device link patches now but since this is a demo of
use of that I&#39;ll note the changes here are pretty large and it makes
it terribly difficult for review. Is there any way this patch can be split
up in to logical atomic pieces that only do one task upon change ?

  Luis
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2061">Marek Szyprowski</a> - Oct. 10, 2016, 1:32 p.m.</div>
<pre class="content">
Hi Luis


On 2016-10-06 19:37, Luis R. Rodriguez wrote:
<span class="quote">&gt; On Thu, Sep 29, 2016 at 10:12:31AM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt;&gt; This patch uses recently introduced device links to track the runtime pm</span>
<span class="quote">&gt;&gt; state of the master&#39;s device. This way each SYSMMU controller is runtime</span>
<span class="quote">&gt;&gt; activated when its master&#39;s device is active</span>
<span class="quote">&gt; instead of?</span>

instead of keeping SYSMMU controller runtime active all the time.
<span class="quote">
&gt; BTW what is the master device of a SYSMMU? I have no clue about these</span>
<span class="quote">&gt; IOMMU devices here.</span>

Here is a more detailed description of IOMMU hardware I wrote a few days ago
for Ulf:
http://www.mail-archive.com/linux-kernel@vger.kernel.org/msg1231006.html

In short: there is a SYSMMU controller and its master device - a device,
which performs DMA operations. That SYSMMU sits in between system memory
and the master device, so it performs mapping of DMA addresses to physical
memory addresses on each DMA operation.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; and can save/restore its state instead of being enabled all the time.</span>
<span class="quote">&gt; I take it this means currently even if the master device is disabled</span>
<span class="quote">&gt; (whatever that is) all SYSMMU controllers are kept enabled, is that right?</span>
<span class="quote">&gt; The issue here is this wastes power? Or what is the issue?</span>

Yes, the issue here is the fact that SYSMMU is kept active all the time,
what in turn prevent the power domain for turning off even if master device
doesn&#39;t do anything and is already suspended. This directly (some clocks
enabled) and in-directly (leakage current) causes power looses.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; This way SYSMMU controllers no</span>
<span class="quote">&gt;&gt; longer prevents respective power domains to be turned off when master&#39;s</span>
<span class="quote">&gt;&gt; device is not used.</span>
<span class="quote">&gt; So when the master device is idle we want to also remove power from the</span>
<span class="quote">&gt; controllers ? How much power does this save on a typical device in the</span>
<span class="quote">&gt; market BTW ?</span>

The main purpose of this patchset is to let power domains to be turned off,
because with the current code all domains are all the time turned on, 
because
SYSMMU controllers prevent them from turning them off.

If you want I can measure the power consumption of the idle board with all
domains enabled and disabled if you want to see the numbers. On the 
other board
disabling most power domains in idle state (the clocks were already 
disabled)
gave me about 20mA savings (at 3.7V), what is a significant value for the
battery powered device.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;   drivers/iommu/exynos-iommu.c | 225 ++++++++++++++++++-------------------------</span>
<span class="quote">&gt;&gt;   1 file changed, 94 insertions(+), 131 deletions(-)</span>
<span class="quote">&gt; I&#39;m reviewing the device link patches now but since this is a demo of</span>
<span class="quote">&gt; use of that I&#39;ll note the changes here are pretty large and it makes</span>
<span class="quote">&gt; it terribly difficult for review. Is there any way this patch can be split</span>
<span class="quote">&gt; up in to logical atomic pieces that only do one task upon change ?</span>

I will try to split it a bit, but I cannot promise that much can be done
to improve readability for someone not very familiar with the driver
internals.

Best regards
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=153261">Luis R. Rodriguez</a> - Nov. 8, 2016, 10:14 p.m.</div>
<pre class="content">
On Mon, Oct 10, 2016 at 03:32:06PM +0200, Marek Szyprowski wrote:
<span class="quote">&gt; Hi Luis</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 2016-10-06 19:37, Luis R. Rodriguez wrote:</span>
<span class="quote">&gt; &gt; On Thu, Sep 29, 2016 at 10:12:31AM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt; &gt; &gt; This patch uses recently introduced device links to track the runtime pm</span>
<span class="quote">&gt; &gt; &gt; state of the master&#39;s device. This way each SYSMMU controller is runtime</span>
<span class="quote">&gt; &gt; &gt; activated when its master&#39;s device is active</span>
<span class="quote">&gt; &gt; instead of?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; instead of keeping SYSMMU controller runtime active all the time.</span>

I thought Rafael&#39;s work was for suspend/resume, not for runtime suspend.
Is it for both ? Because as far as I can tell this was painted to help
with suspend/resume ?
<span class="quote">
&gt; &gt; BTW what is the master device of a SYSMMU? I have no clue about these</span>
<span class="quote">&gt; &gt; IOMMU devices here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Here is a more detailed description of IOMMU hardware I wrote a few days ago</span>
<span class="quote">&gt; for Ulf:</span>
<span class="quote">&gt; http://www.mail-archive.com/linux-kernel@vger.kernel.org/msg1231006.html</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In short: there is a SYSMMU controller and its master device - a device,</span>
<span class="quote">&gt; which performs DMA operations. That SYSMMU sits in between system memory</span>
<span class="quote">&gt; and the master device, so it performs mapping of DMA addresses to physical</span>
<span class="quote">&gt; memory addresses on each DMA operation.</span>

So you seek a run time power optimization ? Or a fix on suspend? Or both?
<span class="quote">
&gt; &gt; &gt; and can save/restore its state instead of being enabled all the time.</span>
<span class="quote">&gt; &gt; I take it this means currently even if the master device is disabled</span>
<span class="quote">&gt; &gt; (whatever that is) all SYSMMU controllers are kept enabled, is that right?</span>
<span class="quote">&gt; &gt; The issue here is this wastes power? Or what is the issue?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yes, the issue here is the fact that SYSMMU is kept active all the time,</span>
<span class="quote">&gt; what in turn prevent the power domain for turning off even if master device</span>
<span class="quote">&gt; doesn&#39;t do anything and is already suspended. This directly (some clocks</span>
<span class="quote">&gt; enabled) and in-directly (leakage current) causes power looses.</span>

Thanks for the confirmation so really the biggest concern here was run time PM.
<span class="quote">
&gt; &gt; &gt; This way SYSMMU controllers no</span>
<span class="quote">&gt; &gt; &gt; longer prevents respective power domains to be turned off when master&#39;s</span>
<span class="quote">&gt; &gt; &gt; device is not used.</span>
<span class="quote">&gt; &gt; So when the master device is idle we want to also remove power from the</span>
<span class="quote">&gt; &gt; controllers ? How much power does this save on a typical device in the</span>
<span class="quote">&gt; &gt; market BTW ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The main purpose of this patchset is to let power domains to be turned off,</span>
<span class="quote">&gt; because with the current code all domains are all the time turned on,</span>
<span class="quote">&gt; because</span>
<span class="quote">&gt; SYSMMU controllers prevent them from turning them off.</span>

I see.. I think the audio folks already addressed this with DAPM, but granted
this was for audio. Then I was also referred to the DRM / Audio component
framework, has this been looked into? v4l folks have v4l async stuff but
its not clear if that help with run time PM. I&#39;m mentioning these given it&#39;d be
silly to re-invent the wheel, additionally if we now have a generic solution
everyone can jump on board with there is quite a bit of work we can do to
dump a lot of old legacy crap.
<span class="quote">
&gt; If you want I can measure the power consumption of the idle board with all</span>
<span class="quote">&gt; domains enabled and disabled if you want to see the numbers. On the other</span>
<span class="quote">&gt; board</span>
<span class="quote">&gt; disabling most power domains in idle state (the clocks were already</span>
<span class="quote">&gt; disabled)</span>
<span class="quote">&gt; gave me about 20mA savings (at 3.7V), what is a significant value for the</span>
<span class="quote">&gt; battery powered device.</span>

Thanks, this means nothing to me, however it would be value-add to the commit log
as anyone reviewing  this can understand what the goal / savings was for exactly.
<span class="quote">
&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Signed-off-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;</span>
<span class="quote">&gt; &gt; &gt; ---</span>
<span class="quote">&gt; &gt; &gt;   drivers/iommu/exynos-iommu.c | 225 ++++++++++++++++++-------------------------</span>
<span class="quote">&gt; &gt; &gt;   1 file changed, 94 insertions(+), 131 deletions(-)</span>
<span class="quote">&gt; &gt; I&#39;m reviewing the device link patches now but since this is a demo of</span>
<span class="quote">&gt; &gt; use of that I&#39;ll note the changes here are pretty large and it makes</span>
<span class="quote">&gt; &gt; it terribly difficult for review. Is there any way this patch can be split</span>
<span class="quote">&gt; &gt; up in to logical atomic pieces that only do one task upon change ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I will try to split it a bit, but I cannot promise that much can be done</span>
<span class="quote">&gt; to improve readability for someone not very familiar with the driver</span>
<span class="quote">&gt; internals.</span>

I&#39;ve heard this before, I don&#39;t buy it but lets see!

  Luis
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2061">Marek Szyprowski</a> - Nov. 9, 2016, 3:07 p.m.</div>
<pre class="content">
Hi Luis,


On 2016-11-08 23:14, Luis R. Rodriguez wrote:
<span class="quote">&gt; On Mon, Oct 10, 2016 at 03:32:06PM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt;&gt; Hi Luis</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 2016-10-06 19:37, Luis R. Rodriguez wrote:</span>
<span class="quote">&gt;&gt;&gt; On Thu, Sep 29, 2016 at 10:12:31AM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; This patch uses recently introduced device links to track the runtime pm</span>
<span class="quote">&gt;&gt;&gt;&gt; state of the master&#39;s device. This way each SYSMMU controller is runtime</span>
<span class="quote">&gt;&gt;&gt;&gt; activated when its master&#39;s device is active</span>
<span class="quote">&gt;&gt;&gt; instead of?</span>
<span class="quote">&gt;&gt; instead of keeping SYSMMU controller runtime active all the time.</span>
<span class="quote">&gt; I thought Rafael&#39;s work was for suspend/resume, not for runtime suspend.</span>
<span class="quote">&gt; Is it for both ?</span>

Yes, it solves both problems, although the suspend/resume was easy to 
workaround
just by using LATE_SLEEP_OPS.
<span class="quote">
&gt; Because as far as I can tell this was painted to help</span>
<span class="quote">&gt; with suspend/resume ?</span>

It also helped to remove the suspend/resume workaround.
<span class="quote">
&gt;&gt;&gt; BTW what is the master device of a SYSMMU? I have no clue about these</span>
<span class="quote">&gt;&gt;&gt; IOMMU devices here.</span>
<span class="quote">&gt;&gt; Here is a more detailed description of IOMMU hardware I wrote a few days ago</span>
<span class="quote">&gt;&gt; for Ulf:</span>
<span class="quote">&gt;&gt; http://www.mail-archive.com/linux-kernel@vger.kernel.org/msg1231006.html</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; In short: there is a SYSMMU controller and its master device - a device,</span>
<span class="quote">&gt;&gt; which performs DMA operations. That SYSMMU sits in between system memory</span>
<span class="quote">&gt;&gt; and the master device, so it performs mapping of DMA addresses to physical</span>
<span class="quote">&gt;&gt; memory addresses on each DMA operation.</span>
<span class="quote">&gt; So you seek a run time power optimization ? Or a fix on suspend? Or both?</span>

The main reason for using device links was to implement proper runtime power
optimization.
<span class="quote">
&gt;&gt;&gt;&gt; and can save/restore its state instead of being enabled all the time.</span>
<span class="quote">&gt;&gt;&gt; I take it this means currently even if the master device is disabled</span>
<span class="quote">&gt;&gt;&gt; (whatever that is) all SYSMMU controllers are kept enabled, is that right?</span>
<span class="quote">&gt;&gt;&gt; The issue here is this wastes power? Or what is the issue?</span>
<span class="quote">&gt;&gt; Yes, the issue here is the fact that SYSMMU is kept active all the time,</span>
<span class="quote">&gt;&gt; what in turn prevent the power domain for turning off even if master device</span>
<span class="quote">&gt;&gt; doesn&#39;t do anything and is already suspended. This directly (some clocks</span>
<span class="quote">&gt;&gt; enabled) and in-directly (leakage current) causes power looses.</span>
<span class="quote">&gt; Thanks for the confirmation so really the biggest concern here was run time PM.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; This way SYSMMU controllers no</span>
<span class="quote">&gt;&gt;&gt;&gt; longer prevents respective power domains to be turned off when master&#39;s</span>
<span class="quote">&gt;&gt;&gt;&gt; device is not used.</span>
<span class="quote">&gt;&gt;&gt; So when the master device is idle we want to also remove power from the</span>
<span class="quote">&gt;&gt;&gt; controllers ? How much power does this save on a typical device in the</span>
<span class="quote">&gt;&gt;&gt; market BTW ?</span>
<span class="quote">&gt;&gt; The main purpose of this patchset is to let power domains to be turned off,</span>
<span class="quote">&gt;&gt; because with the current code all domains are all the time turned on,</span>
<span class="quote">&gt;&gt; because</span>
<span class="quote">&gt;&gt; SYSMMU controllers prevent them from turning them off.</span>
<span class="quote">&gt; I see.. I think the audio folks already addressed this with DAPM, but granted</span>
<span class="quote">&gt; this was for audio. Then I was also referred to the DRM / Audio component</span>
<span class="quote">&gt; framework, has this been looked into? v4l folks have v4l async stuff but</span>
<span class="quote">&gt; its not clear if that help with run time PM. I&#39;m mentioning these given it&#39;d be</span>
<span class="quote">&gt; silly to re-invent the wheel, additionally if we now have a generic solution</span>
<span class="quote">&gt; everyone can jump on board with there is quite a bit of work we can do to</span>
<span class="quote">&gt; dump a lot of old legacy crap.</span>

Right, probably some workarounds here and there can be removed. However 
components
and v4l-async solutions are for resolving only probe and registration 
issues and they
are some kind of pool for grouping devices and triggering special 
callback once all
requested devices in the pool have probed.
<span class="quote">
&gt;&gt; If you want I can measure the power consumption of the idle board with all</span>
<span class="quote">&gt;&gt; domains enabled and disabled if you want to see the numbers. On the other</span>
<span class="quote">&gt;&gt; board</span>
<span class="quote">&gt;&gt; disabling most power domains in idle state (the clocks were already</span>
<span class="quote">&gt;&gt; disabled)</span>
<span class="quote">&gt;&gt; gave me about 20mA savings (at 3.7V), what is a significant value for the</span>
<span class="quote">&gt;&gt; battery powered device.</span>
<span class="quote">&gt; Thanks, this means nothing to me, however it would be value-add to the commit log</span>
<span class="quote">&gt; as anyone reviewing  this can understand what the goal / savings was for exactly.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Signed-off-by: Marek Szyprowski &lt;m.szyprowski@samsung.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; ---</span>
<span class="quote">&gt;&gt;&gt;&gt;    drivers/iommu/exynos-iommu.c | 225 ++++++++++++++++++-------------------------</span>
<span class="quote">&gt;&gt;&gt;&gt;    1 file changed, 94 insertions(+), 131 deletions(-)</span>
<span class="quote">&gt;&gt;&gt; I&#39;m reviewing the device link patches now but since this is a demo of</span>
<span class="quote">&gt;&gt;&gt; use of that I&#39;ll note the changes here are pretty large and it makes</span>
<span class="quote">&gt;&gt;&gt; it terribly difficult for review. Is there any way this patch can be split</span>
<span class="quote">&gt;&gt;&gt; up in to logical atomic pieces that only do one task upon change ?</span>
<span class="quote">&gt;&gt; I will try to split it a bit, but I cannot promise that much can be done</span>
<span class="quote">&gt;&gt; to improve readability for someone not very familiar with the driver</span>
<span class="quote">&gt;&gt; internals.</span>
<span class="quote">&gt; I&#39;ve heard this before, I don&#39;t buy it but lets see!</span>

Somehow I managed to split this all-in-one patch into several smaller 
changes
in v5 and v6 was posted yesterday ago.

Best regards
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=99561">Rafael J. Wysocki</a> - Nov. 10, 2016, 12:36 a.m.</div>
<pre class="content">
On Wed, Nov 9, 2016 at 4:07 PM, Marek Szyprowski
&lt;m.szyprowski@samsung.com&gt; wrote:
<span class="quote">&gt; Hi Luis,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On 2016-11-08 23:14, Luis R. Rodriguez wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Mon, Oct 10, 2016 at 03:32:06PM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Hi Luis</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On 2016-10-06 19:37, Luis R. Rodriguez wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; On Thu, Sep 29, 2016 at 10:12:31AM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; This patch uses recently introduced device links to track the runtime</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; pm</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; state of the master&#39;s device. This way each SYSMMU controller is</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; runtime</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; activated when its master&#39;s device is active</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; instead of?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; instead of keeping SYSMMU controller runtime active all the time.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I thought Rafael&#39;s work was for suspend/resume, not for runtime suspend.</span>
<span class="quote">&gt;&gt; Is it for both ?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Yes, it solves both problems, although the suspend/resume was easy to</span>
<span class="quote">&gt; workaround just by using LATE_SLEEP_OPS.</span>

Right, but that&#39;s just in this particular case, because the dependency
chain is of length 2. :-)

If you had a longer chain, you might in theory use  the _noirq() stage
somehow, but that has limitations.
<span class="quote">
&gt;&gt; Because as far as I can tell this was painted to help</span>
<span class="quote">&gt;&gt; with suspend/resume ?</span>

It helps with three things, (async) suspend/resume, runtime PM and
shutdown (that last part is the hardest to figure out).  The ordering
in which all of these are carried out is analogous and cannot be
determined correctly by the device registration ordering itself in
general (which has been a known fact for years, but some localized
workarounds were put in some places to work around that).

Moreover, even if the list ordering (of dpm_list, for instance) is
correct, it still doesn&#39;t guarantee the right ordering of actions that
are carried out asynchronously.  They are all started in the list
order, but they may be running in parallel with each other and
complete at different times.  For this reason, there needs to be a way
to ensure that, say, the suspend operations for consumer devices
complete before their suppliers will become unavailable and so on.

Both runtime PM and system suspend/resume have this problem.  It is
not present in the system shutdown case, but it still helps to get a
correct list ordering (ie. such that won&#39;t cause supplier devices to
be shut down before their consumers) in this case too.

Thanks,
Rafael
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=153261">Luis R. Rodriguez</a> - Nov. 10, 2016, 1:15 a.m.</div>
<pre class="content">
On Thu, Nov 10, 2016 at 01:36:29AM +0100, Rafael J. Wysocki wrote:
<span class="quote">&gt; On Wed, Nov 9, 2016 at 4:07 PM, Marek Szyprowski</span>
<span class="quote">&gt; &lt;m.szyprowski@samsung.com&gt; wrote:</span>
<span class="quote">&gt; &gt; Hi Luis,</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; On 2016-11-08 23:14, Luis R. Rodriguez wrote:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; On Mon, Oct 10, 2016 at 03:32:06PM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Hi Luis</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; On 2016-10-06 19:37, Luis R. Rodriguez wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; On Thu, Sep 29, 2016 at 10:12:31AM +0200, Marek Szyprowski wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; This patch uses recently introduced device links to track the runtime</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; pm</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; state of the master&#39;s device. This way each SYSMMU controller is</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; runtime</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; activated when its master&#39;s device is active</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; instead of?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; instead of keeping SYSMMU controller runtime active all the time.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I thought Rafael&#39;s work was for suspend/resume, not for runtime suspend.</span>
<span class="quote">&gt; &gt;&gt; Is it for both ?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Yes, it solves both problems, although the suspend/resume was easy to</span>
<span class="quote">&gt; &gt; workaround just by using LATE_SLEEP_OPS.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Right, but that&#39;s just in this particular case, because the dependency</span>
<span class="quote">&gt; chain is of length 2. :-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you had a longer chain, you might in theory use  the _noirq() stage</span>
<span class="quote">&gt; somehow, but that has limitations.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;&gt; Because as far as I can tell this was painted to help</span>
<span class="quote">&gt; &gt;&gt; with suspend/resume ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It helps with three things, (async) suspend/resume, runtime PM and</span>
<span class="quote">&gt; shutdown (that last part is the hardest to figure out).  The ordering</span>
<span class="quote">&gt; in which all of these are carried out is analogous and cannot be</span>
<span class="quote">&gt; determined correctly by the device registration ordering itself in</span>
<span class="quote">&gt; general (which has been a known fact for years, but some localized</span>
<span class="quote">&gt; workarounds were put in some places to work around that).</span>

Thanks for the clarification, this is due to the implicit sort you
had explained (and I provided notes for on ksummit-discuss) right?

Can you itemize a few of the workarounds that are used today?
As you clarify below, getting this order of device registration
correct does not necessarily guarantee devices will wait for their
provider to be ready.
<span class="quote">
&gt; Moreover, even if the list ordering (of dpm_list, for instance) is</span>
<span class="quote">&gt; correct, it still doesn&#39;t guarantee the right ordering of actions that</span>
<span class="quote">&gt; are carried out asynchronously.  They are all started in the list</span>
<span class="quote">&gt; order, but they may be running in parallel with each other and</span>
<span class="quote">&gt; complete at different times.  For this reason, there needs to be a way</span>
<span class="quote">&gt; to ensure that, say, the suspend operations for consumer devices</span>
<span class="quote">&gt; complete before their suppliers will become unavailable and so on.</span>

Thanks this helps as well!
<span class="quote">
&gt; Both runtime PM and system suspend/resume have this problem.  It is</span>
<span class="quote">&gt; not present in the system shutdown case, but it still helps to get a</span>
<span class="quote">&gt; correct list ordering (ie. such that won&#39;t cause supplier devices to</span>
<span class="quote">&gt; be shut down before their consumers) in this case too.</span>

Is the fact that its not on shutdown just because we don&#39;t care about
being sloppy about shutdown ? Shouldn&#39;t some devices care about that
order ?

  Luis
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index dfb44034b4ee..c8926e030713 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -206,6 +206,7 @@</span> <span class="p_context"> static const struct sysmmu_fault_info sysmmu_v5_faults[] = {</span>
 struct exynos_iommu_owner {
 	struct list_head controllers;	/* list of sysmmu_drvdata.owner_node */
 	struct iommu_domain *domain;	/* domain this device is attached */
<span class="p_add">+	struct mutex rpm_lock;		/* for runtime pm of all sysmmus */</span>
 };
 
 /*
<span class="p_chunk">@@ -237,8 +238,8 @@</span> <span class="p_context"> struct sysmmu_drvdata {</span>
 	struct clk *aclk;		/* SYSMMU&#39;s aclk clock */
 	struct clk *pclk;		/* SYSMMU&#39;s pclk clock */
 	struct clk *clk_master;		/* master&#39;s device clock */
<span class="p_del">-	int activations;		/* number of calls to sysmmu_enable */</span>
 	spinlock_t lock;		/* lock for modyfying state */
<span class="p_add">+	int active;			/* current status */</span>
 	struct exynos_iommu_domain *domain; /* domain we belong to */
 	struct list_head domain_node;	/* node for domain clients list */
 	struct list_head owner_node;	/* node for owner controllers list */
<span class="p_chunk">@@ -251,25 +252,6 @@</span> <span class="p_context"> static struct exynos_iommu_domain *to_exynos_domain(struct iommu_domain *dom)</span>
 	return container_of(dom, struct exynos_iommu_domain, domain);
 }
 
<span class="p_del">-static bool set_sysmmu_active(struct sysmmu_drvdata *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* return true if the System MMU was not active previously</span>
<span class="p_del">-	   and it needs to be initialized */</span>
<span class="p_del">-	return ++data-&gt;activations == 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool set_sysmmu_inactive(struct sysmmu_drvdata *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* return true if the System MMU is needed to be disabled */</span>
<span class="p_del">-	BUG_ON(data-&gt;activations &lt; 1);</span>
<span class="p_del">-	return --data-&gt;activations == 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool is_sysmmu_active(struct sysmmu_drvdata *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return data-&gt;activations &gt; 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void sysmmu_unblock(struct sysmmu_drvdata *data)
 {
 	writel(CTRL_ENABLE, data-&gt;sfrbase + REG_MMU_CTRL);
<span class="p_chunk">@@ -388,7 +370,7 @@</span> <span class="p_context"> static irqreturn_t exynos_sysmmu_irq(int irq, void *dev_id)</span>
 	unsigned short reg_status, reg_clear;
 	int ret = -ENOSYS;
 
<span class="p_del">-	WARN_ON(!is_sysmmu_active(data));</span>
<span class="p_add">+	WARN_ON(!data-&gt;active);</span>
 
 	if (MMU_MAJ_VER(data-&gt;version) &lt; 5) {
 		reg_status = REG_INT_STATUS;
<span class="p_chunk">@@ -434,40 +416,19 @@</span> <span class="p_context"> static irqreturn_t exynos_sysmmu_irq(int irq, void *dev_id)</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_del">-static void __sysmmu_disable_nocount(struct sysmmu_drvdata *data)</span>
<span class="p_add">+static void __sysmmu_disable(struct sysmmu_drvdata *data)</span>
 {
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
 	clk_enable(data-&gt;clk_master);
 
<span class="p_add">+	spin_lock_irqsave(&amp;data-&gt;lock, flags);</span>
 	writel(CTRL_DISABLE, data-&gt;sfrbase + REG_MMU_CTRL);
 	writel(0, data-&gt;sfrbase + REG_MMU_CFG);
<span class="p_del">-</span>
<span class="p_del">-	__sysmmu_disable_clocks(data);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool __sysmmu_disable(struct sysmmu_drvdata *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool disabled;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;data-&gt;lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	disabled = set_sysmmu_inactive(data);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (disabled) {</span>
<span class="p_del">-		data-&gt;pgtable = 0;</span>
<span class="p_del">-		data-&gt;domain = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		__sysmmu_disable_nocount(data);</span>
<span class="p_del">-</span>
<span class="p_del">-		dev_dbg(data-&gt;sysmmu, &quot;Disabled\n&quot;);</span>
<span class="p_del">-	} else  {</span>
<span class="p_del">-		dev_dbg(data-&gt;sysmmu, &quot;%d times left to disable\n&quot;,</span>
<span class="p_del">-					data-&gt;activations);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_add">+	data-&gt;active = false;</span>
 	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);
 
<span class="p_del">-	return disabled;</span>
<span class="p_add">+	__sysmmu_disable_clocks(data);</span>
 }
 
 static void __sysmmu_init_config(struct sysmmu_drvdata *data)
<span class="p_chunk">@@ -484,17 +445,19 @@</span> <span class="p_context"> static void __sysmmu_init_config(struct sysmmu_drvdata *data)</span>
 	writel(cfg, data-&gt;sfrbase + REG_MMU_CFG);
 }
 
<span class="p_del">-static void __sysmmu_enable_nocount(struct sysmmu_drvdata *data)</span>
<span class="p_add">+static void __sysmmu_enable(struct sysmmu_drvdata *data)</span>
 {
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
 	__sysmmu_enable_clocks(data);
 
<span class="p_add">+	spin_lock_irqsave(&amp;data-&gt;lock, flags);</span>
 	writel(CTRL_BLOCK, data-&gt;sfrbase + REG_MMU_CTRL);
<span class="p_del">-</span>
 	__sysmmu_init_config(data);
<span class="p_del">-</span>
 	__sysmmu_set_ptbase(data, data-&gt;pgtable);
<span class="p_del">-</span>
 	writel(CTRL_ENABLE, data-&gt;sfrbase + REG_MMU_CTRL);
<span class="p_add">+	data-&gt;active = true;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span>
 
 	/*
 	 * SYSMMU driver keeps master&#39;s clock enabled only for the short
<span class="p_chunk">@@ -505,48 +468,18 @@</span> <span class="p_context"> static void __sysmmu_enable_nocount(struct sysmmu_drvdata *data)</span>
 	clk_disable(data-&gt;clk_master);
 }
 
<span class="p_del">-static int __sysmmu_enable(struct sysmmu_drvdata *data, phys_addr_t pgtable,</span>
<span class="p_del">-			   struct exynos_iommu_domain *domain)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;data-&gt;lock, flags);</span>
<span class="p_del">-	if (set_sysmmu_active(data)) {</span>
<span class="p_del">-		data-&gt;pgtable = pgtable;</span>
<span class="p_del">-		data-&gt;domain = domain;</span>
<span class="p_del">-</span>
<span class="p_del">-		__sysmmu_enable_nocount(data);</span>
<span class="p_del">-</span>
<span class="p_del">-		dev_dbg(data-&gt;sysmmu, &quot;Enabled\n&quot;);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		ret = (pgtable == data-&gt;pgtable) ? 1 : -EBUSY;</span>
<span class="p_del">-</span>
<span class="p_del">-		dev_dbg(data-&gt;sysmmu, &quot;already enabled\n&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (WARN_ON(ret &lt; 0))</span>
<span class="p_del">-		set_sysmmu_inactive(data); /* decrement count */</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void sysmmu_tlb_invalidate_flpdcache(struct sysmmu_drvdata *data,
 					    sysmmu_iova_t iova)
 {
 	unsigned long flags;
 
<span class="p_del">-</span>
 	spin_lock_irqsave(&amp;data-&gt;lock, flags);
<span class="p_del">-	if (is_sysmmu_active(data) &amp;&amp; data-&gt;version &gt;= MAKE_MMU_VER(3, 3)) {</span>
<span class="p_add">+	if (data-&gt;active &amp;&amp; data-&gt;version &gt;= MAKE_MMU_VER(3, 3)) {</span>
 		clk_enable(data-&gt;clk_master);
 		__sysmmu_tlb_invalidate_entry(data, iova, 1);
 		clk_disable(data-&gt;clk_master);
 	}
 	spin_unlock_irqrestore(&amp;data-&gt;lock, flags);
<span class="p_del">-</span>
 }
 
 static void sysmmu_tlb_invalidate_entry(struct sysmmu_drvdata *data,
<span class="p_chunk">@@ -555,7 +488,7 @@</span> <span class="p_context"> static void sysmmu_tlb_invalidate_entry(struct sysmmu_drvdata *data,</span>
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;data-&gt;lock, flags);
<span class="p_del">-	if (is_sysmmu_active(data)) {</span>
<span class="p_add">+	if (data-&gt;active) {</span>
 		unsigned int num_inv = 1;
 
 		clk_enable(data-&gt;clk_master);
<span class="p_chunk">@@ -656,40 +589,55 @@</span> <span class="p_context"> static int __init exynos_sysmmu_probe(struct platform_device *pdev)</span>
 	}
 
 	pm_runtime_enable(dev);
<span class="p_del">-</span>
 	of_iommu_set_ops(dev-&gt;of_node, &amp;exynos_iommu_ops);
 
 	return 0;
 }
 
<span class="p_del">-#ifdef CONFIG_PM_SLEEP</span>
 static int exynos_sysmmu_suspend(struct device *dev)
 {
 	struct sysmmu_drvdata *data = dev_get_drvdata(dev);
<span class="p_add">+	struct exynos_iommu_owner *owner;</span>
 
<span class="p_del">-	dev_dbg(dev, &quot;suspend\n&quot;);</span>
<span class="p_del">-	if (is_sysmmu_active(data)) {</span>
<span class="p_del">-		__sysmmu_disable_nocount(data);</span>
<span class="p_del">-		pm_runtime_put(dev);</span>
<span class="p_add">+	if (!data-&gt;master)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	owner = data-&gt;master-&gt;archdata.iommu;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;owner-&gt;rpm_lock);</span>
<span class="p_add">+	if (data-&gt;domain) {</span>
<span class="p_add">+		dev_dbg(data-&gt;sysmmu, &quot;saving state\n&quot;);</span>
<span class="p_add">+		__sysmmu_disable(data);</span>
 	}
<span class="p_add">+	mutex_unlock(&amp;owner-&gt;rpm_lock);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
 static int exynos_sysmmu_resume(struct device *dev)
 {
 	struct sysmmu_drvdata *data = dev_get_drvdata(dev);
<span class="p_add">+	struct exynos_iommu_owner *owner;</span>
 
<span class="p_del">-	dev_dbg(dev, &quot;resume\n&quot;);</span>
<span class="p_del">-	if (is_sysmmu_active(data)) {</span>
<span class="p_del">-		pm_runtime_get_sync(dev);</span>
<span class="p_del">-		__sysmmu_enable_nocount(data);</span>
<span class="p_add">+	if (!data-&gt;master)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	owner = data-&gt;master-&gt;archdata.iommu;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;owner-&gt;rpm_lock);</span>
<span class="p_add">+	if (data-&gt;domain) {</span>
<span class="p_add">+		dev_dbg(data-&gt;sysmmu, &quot;restoring state\n&quot;);</span>
<span class="p_add">+		__sysmmu_enable(data);</span>
 	}
<span class="p_add">+	mutex_unlock(&amp;owner-&gt;rpm_lock);</span>
<span class="p_add">+</span>
 	return 0;
 }
<span class="p_del">-#endif</span>
 
 static const struct dev_pm_ops sysmmu_pm_ops = {
<span class="p_del">-	SET_LATE_SYSTEM_SLEEP_PM_OPS(exynos_sysmmu_suspend, exynos_sysmmu_resume)</span>
<span class="p_add">+	SET_RUNTIME_PM_OPS(exynos_sysmmu_suspend, exynos_sysmmu_resume, NULL)</span>
<span class="p_add">+	SET_LATE_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,</span>
<span class="p_add">+				     pm_runtime_force_resume)</span>
 };
 
 static const struct of_device_id sysmmu_of_match[] __initconst = {
<span class="p_chunk">@@ -793,9 +741,12 @@</span> <span class="p_context"> static void exynos_iommu_domain_free(struct iommu_domain *iommu_domain)</span>
 	spin_lock_irqsave(&amp;domain-&gt;lock, flags);
 
 	list_for_each_entry_safe(data, next, &amp;domain-&gt;clients, domain_node) {
<span class="p_del">-		if (__sysmmu_disable(data))</span>
<span class="p_del">-			data-&gt;master = NULL;</span>
<span class="p_add">+		spin_lock(&amp;data-&gt;lock);</span>
<span class="p_add">+		__sysmmu_disable(data);</span>
<span class="p_add">+		data-&gt;pgtable = 0;</span>
<span class="p_add">+		data-&gt;domain = NULL;</span>
 		list_del_init(&amp;data-&gt;domain_node);
<span class="p_add">+		spin_unlock(&amp;data-&gt;lock);</span>
 	}
 
 	spin_unlock_irqrestore(&amp;domain-&gt;lock, flags);
<span class="p_chunk">@@ -829,31 +780,32 @@</span> <span class="p_context"> static void exynos_iommu_detach_device(struct iommu_domain *iommu_domain,</span>
 	phys_addr_t pagetable = virt_to_phys(domain-&gt;pgtable);
 	struct sysmmu_drvdata *data, *next;
 	unsigned long flags;
<span class="p_del">-	bool found = false;</span>
 
 	if (!has_sysmmu(dev) || owner-&gt;domain != iommu_domain)
 		return;
 
<span class="p_add">+	mutex_lock(&amp;owner-&gt;rpm_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(data, &amp;owner-&gt;controllers, owner_node) {</span>
<span class="p_add">+		if (pm_runtime_active(data-&gt;sysmmu))</span>
<span class="p_add">+			__sysmmu_disable(data);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;domain-&gt;lock, flags);
 	list_for_each_entry_safe(data, next, &amp;domain-&gt;clients, domain_node) {
<span class="p_del">-		if (data-&gt;master == dev) {</span>
<span class="p_del">-			if (__sysmmu_disable(data)) {</span>
<span class="p_del">-				data-&gt;master = NULL;</span>
<span class="p_del">-				list_del_init(&amp;data-&gt;domain_node);</span>
<span class="p_del">-			}</span>
<span class="p_del">-			pm_runtime_put(data-&gt;sysmmu);</span>
<span class="p_del">-			found = true;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		spin_lock(&amp;data-&gt;lock);</span>
<span class="p_add">+		data-&gt;pgtable = 0;</span>
<span class="p_add">+		data-&gt;domain = NULL;</span>
<span class="p_add">+		list_del_init(&amp;data-&gt;domain_node);</span>
<span class="p_add">+		spin_unlock(&amp;data-&gt;lock);</span>
 	}
<span class="p_add">+	owner-&gt;domain = NULL;</span>
 	spin_unlock_irqrestore(&amp;domain-&gt;lock, flags);
 
<span class="p_del">-	owner-&gt;domain = NULL;</span>
<span class="p_add">+	mutex_unlock(&amp;owner-&gt;rpm_lock);</span>
 
<span class="p_del">-	if (found)</span>
<span class="p_del">-		dev_dbg(dev, &quot;%s: Detached IOMMU with pgtable %pa\n&quot;,</span>
<span class="p_del">-					__func__, &amp;pagetable);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		dev_err(dev, &quot;%s: No IOMMU is attached\n&quot;, __func__);</span>
<span class="p_add">+	dev_dbg(dev, &quot;%s: Detached IOMMU with pgtable %pa\n&quot;, __func__,</span>
<span class="p_add">+		&amp;pagetable);</span>
 }
 
 static int exynos_iommu_attach_device(struct iommu_domain *iommu_domain,
<span class="p_chunk">@@ -864,7 +816,6 @@</span> <span class="p_context"> static int exynos_iommu_attach_device(struct iommu_domain *iommu_domain,</span>
 	struct sysmmu_drvdata *data;
 	phys_addr_t pagetable = virt_to_phys(domain-&gt;pgtable);
 	unsigned long flags;
<span class="p_del">-	int ret = -ENODEV;</span>
 
 	if (!has_sysmmu(dev))
 		return -ENODEV;
<span class="p_chunk">@@ -872,29 +823,30 @@</span> <span class="p_context"> static int exynos_iommu_attach_device(struct iommu_domain *iommu_domain,</span>
 	if (owner-&gt;domain)
 		exynos_iommu_detach_device(owner-&gt;domain, dev);
 
<span class="p_add">+	mutex_lock(&amp;owner-&gt;rpm_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;domain-&gt;lock, flags);</span>
 	list_for_each_entry(data, &amp;owner-&gt;controllers, owner_node) {
<span class="p_del">-		pm_runtime_get_sync(data-&gt;sysmmu);</span>
<span class="p_del">-		ret = __sysmmu_enable(data, pagetable, domain);</span>
<span class="p_del">-		if (ret &gt;= 0) {</span>
<span class="p_del">-			data-&gt;master = dev;</span>
<span class="p_del">-</span>
<span class="p_del">-			spin_lock_irqsave(&amp;domain-&gt;lock, flags);</span>
<span class="p_del">-			list_add_tail(&amp;data-&gt;domain_node, &amp;domain-&gt;clients);</span>
<span class="p_del">-			spin_unlock_irqrestore(&amp;domain-&gt;lock, flags);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		spin_lock(&amp;data-&gt;lock);</span>
<span class="p_add">+		data-&gt;pgtable = pagetable;</span>
<span class="p_add">+		data-&gt;domain = domain;</span>
<span class="p_add">+		list_add_tail(&amp;data-&gt;domain_node, &amp;domain-&gt;clients);</span>
<span class="p_add">+		spin_unlock(&amp;data-&gt;lock);</span>
 	}
<span class="p_add">+	owner-&gt;domain = iommu_domain;</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;domain-&gt;lock, flags);</span>
 
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(dev, &quot;%s: Failed to attach IOMMU with pgtable %pa\n&quot;,</span>
<span class="p_del">-					__func__, &amp;pagetable);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	list_for_each_entry(data, &amp;owner-&gt;controllers, owner_node) {</span>
<span class="p_add">+		if (pm_runtime_active(data-&gt;sysmmu))</span>
<span class="p_add">+			__sysmmu_enable(data);</span>
 	}
 
<span class="p_del">-	owner-&gt;domain = iommu_domain;</span>
<span class="p_del">-	dev_dbg(dev, &quot;%s: Attached IOMMU with pgtable %pa %s\n&quot;,</span>
<span class="p_del">-		__func__, &amp;pagetable, (ret == 0) ? &quot;&quot; : &quot;, again&quot;);</span>
<span class="p_add">+	mutex_unlock(&amp;owner-&gt;rpm_lock);</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	dev_dbg(dev, &quot;%s: Attached IOMMU with pgtable %pa\n&quot;, __func__,</span>
<span class="p_add">+		&amp;pagetable);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static sysmmu_pte_t *alloc_lv2entry(struct exynos_iommu_domain *domain,
<span class="p_chunk">@@ -1265,10 +1217,21 @@</span> <span class="p_context"> static int exynos_iommu_of_xlate(struct device *dev,</span>
 			return -ENOMEM;
 
 		INIT_LIST_HEAD(&amp;owner-&gt;controllers);
<span class="p_add">+		mutex_init(&amp;owner-&gt;rpm_lock);</span>
 		dev-&gt;archdata.iommu = owner;
 	}
 
 	list_add_tail(&amp;data-&gt;owner_node, &amp;owner-&gt;controllers);
<span class="p_add">+	data-&gt;master = dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * SYSMMU will be runtime enabled via device link (dependency) to its</span>
<span class="p_add">+	 * master device, so there are no direct calls to pm_runtime_get/put</span>
<span class="p_add">+	 * in this driver.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	device_link_add(dev, data-&gt;sysmmu, DEVICE_LINK_AVAILABLE,</span>
<span class="p_add">+			DEVICE_LINK_PM_RUNTIME);</span>
<span class="p_add">+</span>
 	return 0;
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



