
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.7.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.7.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 30, 2016, 8:57 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160930085706.GB11443@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9357805/mbox/"
   >mbox</a>
|
   <a href="/patch/9357805/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9357805/">/patch/9357805/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AE8326075E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 30 Sep 2016 08:58:12 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9704F29F14
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 30 Sep 2016 08:58:12 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 88F8829F16; Fri, 30 Sep 2016 08:58:12 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 65D2129F18
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 30 Sep 2016 08:58:08 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932756AbcI3I56 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 30 Sep 2016 04:57:58 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:59007 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752806AbcI3I5D (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 30 Sep 2016 04:57:03 -0400
Received: from localhost (unknown [89.202.203.52])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 9F89F941;
	Fri, 30 Sep 2016 08:57:01 +0000 (UTC)
Date: Fri, 30 Sep 2016 10:57:06 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.7.6
Message-ID: &lt;20160930085706.GB11443@kroah.com&gt;
References: &lt;20160930085700.GA11443@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160930085700.GA11443@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 30, 2016, 8:57 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index dd755d199ad6..48b0120be59b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 7
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_chunk">@@ -370,7 +370,7 @@</span> <span class="p_context"> LDFLAGS_MODULE  =</span>
 CFLAGS_KERNEL	=
 AFLAGS_KERNEL	=
 LDFLAGS_vmlinux =
<span class="p_del">-CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage -fno-tree-loop-im -Wno-maybe-uninitialized</span>
<span class="p_add">+CFLAGS_GCOV	= -fprofile-arcs -ftest-coverage -fno-tree-loop-im</span>
 CFLAGS_KCOV	= -fsanitize-coverage=trace-pc
 
 
<span class="p_chunk">@@ -619,12 +619,13 @@</span> <span class="p_context"> ARCH_CFLAGS :=</span>
 include arch/$(SRCARCH)/Makefile
 
 KBUILD_CFLAGS	+= $(call cc-option,-fno-delete-null-pointer-checks,)
<span class="p_add">+KBUILD_CFLAGS	+= $(call cc-disable-warning,maybe-uninitialized,)</span>
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
<span class="p_del">-KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)</span>
<span class="p_add">+KBUILD_CFLAGS	+= -Os</span>
 else
 ifdef CONFIG_PROFILE_ALL_BRANCHES
<span class="p_del">-KBUILD_CFLAGS	+= -O2 $(call cc-disable-warning,maybe-uninitialized,)</span>
<span class="p_add">+KBUILD_CFLAGS	+= -O2</span>
 else
 KBUILD_CFLAGS   += -O2
 endif
<span class="p_header">diff --git a/arch/arc/Makefile b/arch/arc/Makefile</span>
<span class="p_header">index 85814e74677d..601ed173080b 100644</span>
<span class="p_header">--- a/arch/arc/Makefile</span>
<span class="p_header">+++ b/arch/arc/Makefile</span>
<span class="p_chunk">@@ -74,9 +74,7 @@</span> <span class="p_context"> endif</span>
 ifndef CONFIG_CC_OPTIMIZE_FOR_SIZE
 # Generic build system uses -O2, we want -O3
 # Note: No need to add to cflags-y as that happens anyways
<span class="p_del">-#</span>
<span class="p_del">-# Disable the false maybe-uninitialized warings gcc spits out at -O3</span>
<span class="p_del">-ARCH_CFLAGS += -O3 $(call cc-disable-warning,maybe-uninitialized,)</span>
<span class="p_add">+ARCH_CFLAGS += -O3</span>
 endif
 
 # small data is default for elf32 tool-chain. If not usable, disable it
<span class="p_header">diff --git a/arch/arm/crypto/aes-ce-glue.c b/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_header">index da3c0428507b..aef022a87c53 100644</span>
<span class="p_header">--- a/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_header">+++ b/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_chunk">@@ -284,7 +284,7 @@</span> <span class="p_context"> static int ctr_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,</span>
 		err = blkcipher_walk_done(desc, &amp;walk,
 					  walk.nbytes % AES_BLOCK_SIZE);
 	}
<span class="p_del">-	if (nbytes) {</span>
<span class="p_add">+	if (walk.nbytes % AES_BLOCK_SIZE) {</span>
 		u8 *tdst = walk.dst.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 *tsrc = walk.src.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 __aligned(8) tail[AES_BLOCK_SIZE];
<span class="p_header">diff --git a/arch/arm64/crypto/aes-glue.c b/arch/arm64/crypto/aes-glue.c</span>
<span class="p_header">index 5c888049d061..6b2aa0fd6cd0 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-glue.c</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-glue.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static int ctr_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,</span>
 		err = blkcipher_walk_done(desc, &amp;walk,
 					  walk.nbytes % AES_BLOCK_SIZE);
 	}
<span class="p_del">-	if (nbytes) {</span>
<span class="p_add">+	if (walk.nbytes % AES_BLOCK_SIZE) {</span>
 		u8 *tdst = walk.dst.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 *tsrc = walk.src.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 __aligned(8) tail[AES_BLOCK_SIZE];
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index 490db85dec23..95e32d9c6820 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -201,12 +201,6 @@</span> <span class="p_context"> int __cpu_up(unsigned int cpu, struct task_struct *idle)</span>
 	return ret;
 }
 
<span class="p_del">-static void smp_store_cpu_info(unsigned int cpuid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	store_cpu_topology(cpuid);</span>
<span class="p_del">-	numa_store_cpu_info(cpuid);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * This is the secondary CPU boot entry.  We&#39;re using this CPUs
  * idle thread stack, but a set of temporary page tables.
<span class="p_chunk">@@ -254,7 +248,7 @@</span> <span class="p_context"> asmlinkage void secondary_start_kernel(void)</span>
 	 */
 	notify_cpu_starting(cpu);
 
<span class="p_del">-	smp_store_cpu_info(cpu);</span>
<span class="p_add">+	store_cpu_topology(cpu);</span>
 
 	/*
 	 * OK, now it&#39;s safe to let the boot CPU continue.  Wait for
<span class="p_chunk">@@ -687,10 +681,13 @@</span> <span class="p_context"> void __init smp_prepare_cpus(unsigned int max_cpus)</span>
 {
 	int err;
 	unsigned int cpu;
<span class="p_add">+	unsigned int this_cpu;</span>
 
 	init_cpu_topology();
 
<span class="p_del">-	smp_store_cpu_info(smp_processor_id());</span>
<span class="p_add">+	this_cpu = smp_processor_id();</span>
<span class="p_add">+	store_cpu_topology(this_cpu);</span>
<span class="p_add">+	numa_store_cpu_info(this_cpu);</span>
 
 	/*
 	 * If UP is mandated by &quot;nosmp&quot; (which implies &quot;maxcpus=0&quot;), don&#39;t set
<span class="p_chunk">@@ -717,6 +714,7 @@</span> <span class="p_context"> void __init smp_prepare_cpus(unsigned int max_cpus)</span>
 			continue;
 
 		set_cpu_present(cpu, true);
<span class="p_add">+		numa_store_cpu_info(cpu);</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/mips/Kconfig.debug b/arch/mips/Kconfig.debug</span>
<span class="p_header">index f0e314ceb8ba..7f975b20b20c 100644</span>
<span class="p_header">--- a/arch/mips/Kconfig.debug</span>
<span class="p_header">+++ b/arch/mips/Kconfig.debug</span>
<span class="p_chunk">@@ -113,42 +113,6 @@</span> <span class="p_context"> config SPINLOCK_TEST</span>
 	help
 	  Add several files to the debugfs to test spinlock speed.
 
<span class="p_del">-if CPU_MIPSR6</span>
<span class="p_del">-</span>
<span class="p_del">-choice</span>
<span class="p_del">-	prompt &quot;Compact branch policy&quot;</span>
<span class="p_del">-	default MIPS_COMPACT_BRANCHES_OPTIMAL</span>
<span class="p_del">-</span>
<span class="p_del">-config MIPS_COMPACT_BRANCHES_NEVER</span>
<span class="p_del">-	bool &quot;Never (force delay slot branches)&quot;</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Pass the -mcompact-branches=never flag to the compiler in order to</span>
<span class="p_del">-	  force it to always emit branches with delay slots, and make no use</span>
<span class="p_del">-	  of the compact branch instructions introduced by MIPSr6. This is</span>
<span class="p_del">-	  useful if you suspect there may be an issue with compact branches in</span>
<span class="p_del">-	  either the compiler or the CPU.</span>
<span class="p_del">-</span>
<span class="p_del">-config MIPS_COMPACT_BRANCHES_OPTIMAL</span>
<span class="p_del">-	bool &quot;Optimal (use where beneficial)&quot;</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Pass the -mcompact-branches=optimal flag to the compiler in order for</span>
<span class="p_del">-	  it to make use of compact branch instructions where it deems them</span>
<span class="p_del">-	  beneficial, and use branches with delay slots elsewhere. This is the</span>
<span class="p_del">-	  default compiler behaviour, and should be used unless you have a</span>
<span class="p_del">-	  reason to choose otherwise.</span>
<span class="p_del">-</span>
<span class="p_del">-config MIPS_COMPACT_BRANCHES_ALWAYS</span>
<span class="p_del">-	bool &quot;Always (force compact branches)&quot;</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Pass the -mcompact-branches=always flag to the compiler in order to</span>
<span class="p_del">-	  force it to always emit compact branches, making no use of branch</span>
<span class="p_del">-	  instructions with delay slots. This can result in more compact code</span>
<span class="p_del">-	  which may be beneficial in some scenarios.</span>
<span class="p_del">-</span>
<span class="p_del">-endchoice</span>
<span class="p_del">-</span>
<span class="p_del">-endif # CPU_MIPSR6</span>
<span class="p_del">-</span>
 config SCACHE_DEBUGFS
 	bool &quot;L2 cache debugfs entries&quot;
 	depends on DEBUG_FS
<span class="p_header">diff --git a/arch/mips/Makefile b/arch/mips/Makefile</span>
<span class="p_header">index efd7a9dc93c4..598ab2930fce 100644</span>
<span class="p_header">--- a/arch/mips/Makefile</span>
<span class="p_header">+++ b/arch/mips/Makefile</span>
<span class="p_chunk">@@ -203,10 +203,6 @@</span> <span class="p_context"> endif</span>
 toolchain-virt				:= $(call cc-option-yn,$(mips-cflags) -mvirt)
 cflags-$(toolchain-virt)		+= -DTOOLCHAIN_SUPPORTS_VIRT
 
<span class="p_del">-cflags-$(CONFIG_MIPS_COMPACT_BRANCHES_NEVER)	+= -mcompact-branches=never</span>
<span class="p_del">-cflags-$(CONFIG_MIPS_COMPACT_BRANCHES_OPTIMAL)	+= -mcompact-branches=optimal</span>
<span class="p_del">-cflags-$(CONFIG_MIPS_COMPACT_BRANCHES_ALWAYS)	+= -mcompact-branches=always</span>
<span class="p_del">-</span>
 #
 # Firmware support
 #
<span class="p_header">diff --git a/arch/mips/include/asm/asmmacro.h b/arch/mips/include/asm/asmmacro.h</span>
<span class="p_header">index 56584a659183..83054f79f72a 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/asmmacro.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/asmmacro.h</span>
<span class="p_chunk">@@ -157,6 +157,7 @@</span> <span class="p_context"></span>
 	ldc1	$f28, THREAD_FPR28(\thread)
 	ldc1	$f30, THREAD_FPR30(\thread)
 	ctc1	\tmp, fcr31
<span class="p_add">+	.set	pop</span>
 	.endm
 
 	.macro	fpu_restore_16odd thread
<span class="p_header">diff --git a/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h b/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_header">index 2f82bfa3a773..c9f5769dfc8f 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_chunk">@@ -11,11 +11,13 @@</span> <span class="p_context"></span>
 #define CP0_EBASE $15, 1
 
 	.macro  kernel_entry_setup
<span class="p_add">+#ifdef CONFIG_SMP</span>
 	mfc0	t0, CP0_EBASE
 	andi	t0, t0, 0x3ff		# CPUNum
 	beqz	t0, 1f
 	# CPUs other than zero goto smp_bootstrap
 	j	smp_bootstrap
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 
 1:
 	.endm
<span class="p_header">diff --git a/arch/mips/kernel/mips-r2-to-r6-emul.c b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">index 7ff2a557f4aa..ae775758105f 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_chunk">@@ -1164,7 +1164,9 @@</span> <span class="p_context"> fpu_emul:</span>
 		regs-&gt;regs[31] = r31;
 		regs-&gt;cp0_epc = epc;
 		if (!used_math()) {     /* First time FPU user.  */
<span class="p_add">+			preempt_disable();</span>
 			err = init_fpu();
<span class="p_add">+			preempt_enable();</span>
 			set_used_math();
 		}
 		lose_fpu(1);    /* Save FPU state for the emulator. */
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index 813ed7829c61..45cff9fcf575 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -591,14 +591,14 @@</span> <span class="p_context"> int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)</span>
 		return -EOPNOTSUPP;
 
 	/* Avoid inadvertently triggering emulation */
<span class="p_del">-	if ((value &amp; PR_FP_MODE_FR) &amp;&amp; cpu_has_fpu &amp;&amp;</span>
<span class="p_del">-	    !(current_cpu_data.fpu_id &amp; MIPS_FPIR_F64))</span>
<span class="p_add">+	if ((value &amp; PR_FP_MODE_FR) &amp;&amp; raw_cpu_has_fpu &amp;&amp;</span>
<span class="p_add">+	    !(raw_current_cpu_data.fpu_id &amp; MIPS_FPIR_F64))</span>
 		return -EOPNOTSUPP;
<span class="p_del">-	if ((value &amp; PR_FP_MODE_FRE) &amp;&amp; cpu_has_fpu &amp;&amp; !cpu_has_fre)</span>
<span class="p_add">+	if ((value &amp; PR_FP_MODE_FRE) &amp;&amp; raw_cpu_has_fpu &amp;&amp; !cpu_has_fre)</span>
 		return -EOPNOTSUPP;
 
 	/* FR = 0 not supported in MIPS R6 */
<span class="p_del">-	if (!(value &amp; PR_FP_MODE_FR) &amp;&amp; cpu_has_fpu &amp;&amp; cpu_has_mips_r6)</span>
<span class="p_add">+	if (!(value &amp; PR_FP_MODE_FR) &amp;&amp; raw_cpu_has_fpu &amp;&amp; cpu_has_mips_r6)</span>
 		return -EOPNOTSUPP;
 
 	/* Proceed with the mode switch */
<span class="p_header">diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c</span>
<span class="p_header">index f9d01e953acb..dcf4a23ec074 100644</span>
<span class="p_header">--- a/arch/mips/kernel/smp.c</span>
<span class="p_header">+++ b/arch/mips/kernel/smp.c</span>
<span class="p_chunk">@@ -320,6 +320,9 @@</span> <span class="p_context"> asmlinkage void start_secondary(void)</span>
 	cpumask_set_cpu(cpu, &amp;cpu_coherent_mask);
 	notify_cpu_starting(cpu);
 
<span class="p_add">+	cpumask_set_cpu(cpu, &amp;cpu_callin_map);</span>
<span class="p_add">+	synchronise_count_slave(cpu);</span>
<span class="p_add">+</span>
 	set_cpu_online(cpu, true);
 
 	set_cpu_sibling_map(cpu);
<span class="p_chunk">@@ -327,10 +330,6 @@</span> <span class="p_context"> asmlinkage void start_secondary(void)</span>
 
 	calculate_cpu_foreign_map();
 
<span class="p_del">-	cpumask_set_cpu(cpu, &amp;cpu_callin_map);</span>
<span class="p_del">-</span>
<span class="p_del">-	synchronise_count_slave(cpu);</span>
<span class="p_del">-</span>
 	/*
 	 * irq will be enabled in -&gt;smp_finish(), enabling it too early
 	 * is dangerous.
<span class="p_header">diff --git a/arch/mips/kernel/vdso.c b/arch/mips/kernel/vdso.c</span>
<span class="p_header">index 54e1663ce639..0b30c02a5014 100644</span>
<span class="p_header">--- a/arch/mips/kernel/vdso.c</span>
<span class="p_header">+++ b/arch/mips/kernel/vdso.c</span>
<span class="p_chunk">@@ -39,16 +39,16 @@</span> <span class="p_context"> static struct vm_special_mapping vdso_vvar_mapping = {</span>
 static void __init init_vdso_image(struct mips_vdso_image *image)
 {
 	unsigned long num_pages, i;
<span class="p_add">+	unsigned long data_pfn;</span>
 
 	BUG_ON(!PAGE_ALIGNED(image-&gt;data));
 	BUG_ON(!PAGE_ALIGNED(image-&gt;size));
 
 	num_pages = image-&gt;size / PAGE_SIZE;
 
<span class="p_del">-	for (i = 0; i &lt; num_pages; i++) {</span>
<span class="p_del">-		image-&gt;mapping.pages[i] =</span>
<span class="p_del">-			virt_to_page(image-&gt;data + (i * PAGE_SIZE));</span>
<span class="p_del">-	}</span>
<span class="p_add">+	data_pfn = __phys_to_pfn(__pa_symbol(image-&gt;data));</span>
<span class="p_add">+	for (i = 0; i &lt; num_pages; i++)</span>
<span class="p_add">+		image-&gt;mapping.pages[i] = pfn_to_page(data_pfn + i);</span>
 }
 
 static int __init init_vdso(void)
<span class="p_header">diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c</span>
<span class="p_header">index 7a1f7bbf4105..b2659b9d0809 100644</span>
<span class="p_header">--- a/arch/x86/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/x86/mm/pageattr.c</span>
<span class="p_chunk">@@ -932,11 +932,11 @@</span> <span class="p_context"> static void populate_pte(struct cpa_data *cpa,</span>
 	}
 }
 
<span class="p_del">-static int populate_pmd(struct cpa_data *cpa,</span>
<span class="p_del">-			unsigned long start, unsigned long end,</span>
<span class="p_del">-			unsigned num_pages, pud_t *pud, pgprot_t pgprot)</span>
<span class="p_add">+static long populate_pmd(struct cpa_data *cpa,</span>
<span class="p_add">+			 unsigned long start, unsigned long end,</span>
<span class="p_add">+			 unsigned num_pages, pud_t *pud, pgprot_t pgprot)</span>
 {
<span class="p_del">-	unsigned int cur_pages = 0;</span>
<span class="p_add">+	long cur_pages = 0;</span>
 	pmd_t *pmd;
 	pgprot_t pmd_pgprot;
 
<span class="p_chunk">@@ -1006,12 +1006,12 @@</span> <span class="p_context"> static int populate_pmd(struct cpa_data *cpa,</span>
 	return num_pages;
 }
 
<span class="p_del">-static int populate_pud(struct cpa_data *cpa, unsigned long start, pgd_t *pgd,</span>
<span class="p_del">-			pgprot_t pgprot)</span>
<span class="p_add">+static long populate_pud(struct cpa_data *cpa, unsigned long start, pgd_t *pgd,</span>
<span class="p_add">+			 pgprot_t pgprot)</span>
 {
 	pud_t *pud;
 	unsigned long end;
<span class="p_del">-	int cur_pages = 0;</span>
<span class="p_add">+	long cur_pages = 0;</span>
 	pgprot_t pud_pgprot;
 
 	end = start + (cpa-&gt;numpages &lt;&lt; PAGE_SHIFT);
<span class="p_chunk">@@ -1067,7 +1067,7 @@</span> <span class="p_context"> static int populate_pud(struct cpa_data *cpa, unsigned long start, pgd_t *pgd,</span>
 
 	/* Map trailing leftover */
 	if (start &lt; end) {
<span class="p_del">-		int tmp;</span>
<span class="p_add">+		long tmp;</span>
 
 		pud = pud_offset(pgd, start);
 		if (pud_none(*pud))
<span class="p_chunk">@@ -1093,7 +1093,7 @@</span> <span class="p_context"> static int populate_pgd(struct cpa_data *cpa, unsigned long addr)</span>
 	pgprot_t pgprot = __pgprot(_KERNPG_TABLE);
 	pud_t *pud = NULL;	/* shut up gcc */
 	pgd_t *pgd_entry;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	long ret;</span>
 
 	pgd_entry = cpa-&gt;pgd + pgd_index(addr);
 
<span class="p_chunk">@@ -1336,7 +1336,8 @@</span> <span class="p_context"> static int cpa_process_alias(struct cpa_data *cpa)</span>
 
 static int __change_page_attr_set_clr(struct cpa_data *cpa, int checkalias)
 {
<span class="p_del">-	int ret, numpages = cpa-&gt;numpages;</span>
<span class="p_add">+	unsigned long numpages = cpa-&gt;numpages;</span>
<span class="p_add">+	int ret;</span>
 
 	while (numpages) {
 		/*
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index b226b3f497f1..964c7022d31d 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	 * text and allocate a new stack because we can&#39;t rely on the
 	 * stack pointer being &lt; 4GB.
 	 */
<span class="p_del">-	if (!IS_ENABLED(CONFIG_EFI_MIXED))</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_EFI_MIXED) || efi_is_native())</span>
 		return 0;
 
 	/*
<span class="p_header">diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c</span>
<span class="p_header">index 8cc1622b2ee0..dca7bc87dad9 100644</span>
<span class="p_header">--- a/crypto/blkcipher.c</span>
<span class="p_header">+++ b/crypto/blkcipher.c</span>
<span class="p_chunk">@@ -234,6 +234,8 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		return blkcipher_walk_done(desc, walk, -EINVAL);
 	}
 
<span class="p_add">+	bsize = min(walk-&gt;walk_blocksize, n);</span>
<span class="p_add">+</span>
 	walk-&gt;flags &amp;= ~(BLKCIPHER_WALK_SLOW | BLKCIPHER_WALK_COPY |
 			 BLKCIPHER_WALK_DIFF);
 	if (!scatterwalk_aligned(&amp;walk-&gt;in, walk-&gt;alignmask) ||
<span class="p_chunk">@@ -246,7 +248,6 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		}
 	}
 
<span class="p_del">-	bsize = min(walk-&gt;walk_blocksize, n);</span>
 	n = scatterwalk_clamp(&amp;walk-&gt;in, n);
 	n = scatterwalk_clamp(&amp;walk-&gt;out, n);
 
<span class="p_header">diff --git a/crypto/echainiv.c b/crypto/echainiv.c</span>
<span class="p_header">index b96a84560b67..343a74e96e2a 100644</span>
<span class="p_header">--- a/crypto/echainiv.c</span>
<span class="p_header">+++ b/crypto/echainiv.c</span>
<span class="p_chunk">@@ -1,8 +1,8 @@</span> <span class="p_context"></span>
 /*
  * echainiv: Encrypted Chain IV Generator
  *
<span class="p_del">- * This generator generates an IV based on a sequence number by xoring it</span>
<span class="p_del">- * with a salt and then encrypting it with the same key as used to encrypt</span>
<span class="p_add">+ * This generator generates an IV based on a sequence number by multiplying</span>
<span class="p_add">+ * it with a salt and then encrypting it with the same key as used to encrypt</span>
  * the plain text.  This algorithm requires that the block size be equal
  * to the IV size.  It is mainly useful for CBC.
  *
<span class="p_chunk">@@ -23,81 +23,17 @@</span> <span class="p_context"></span>
 #include &lt;linux/err.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/kernel.h&gt;
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
 #include &lt;linux/module.h&gt;
<span class="p_del">-#include &lt;linux/percpu.h&gt;</span>
<span class="p_del">-#include &lt;linux/spinlock.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 #include &lt;linux/string.h&gt;
 
<span class="p_del">-#define MAX_IV_SIZE 16</span>
<span class="p_del">-</span>
<span class="p_del">-static DEFINE_PER_CPU(u32 [MAX_IV_SIZE / sizeof(u32)], echainiv_iv);</span>
<span class="p_del">-</span>
<span class="p_del">-/* We don&#39;t care if we get preempted and read/write IVs from the next CPU. */</span>
<span class="p_del">-static void echainiv_read_iv(u8 *dst, unsigned size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 *a = (u32 *)dst;</span>
<span class="p_del">-	u32 __percpu *b = echainiv_iv;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (; size &gt;= 4; size -= 4) {</span>
<span class="p_del">-		*a++ = this_cpu_read(*b);</span>
<span class="p_del">-		b++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void echainiv_write_iv(const u8 *src, unsigned size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const u32 *a = (const u32 *)src;</span>
<span class="p_del">-	u32 __percpu *b = echainiv_iv;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (; size &gt;= 4; size -= 4) {</span>
<span class="p_del">-		this_cpu_write(*b, *a);</span>
<span class="p_del">-		a++;</span>
<span class="p_del">-		b++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void echainiv_encrypt_complete2(struct aead_request *req, int err)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct aead_request *subreq = aead_request_ctx(req);</span>
<span class="p_del">-	struct crypto_aead *geniv;</span>
<span class="p_del">-	unsigned int ivsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err == -EINPROGRESS)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	geniv = crypto_aead_reqtfm(req);</span>
<span class="p_del">-	ivsize = crypto_aead_ivsize(geniv);</span>
<span class="p_del">-</span>
<span class="p_del">-	echainiv_write_iv(subreq-&gt;iv, ivsize);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (req-&gt;iv != subreq-&gt;iv)</span>
<span class="p_del">-		memcpy(req-&gt;iv, subreq-&gt;iv, ivsize);</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	if (req-&gt;iv != subreq-&gt;iv)</span>
<span class="p_del">-		kzfree(subreq-&gt;iv);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void echainiv_encrypt_complete(struct crypto_async_request *base,</span>
<span class="p_del">-					 int err)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct aead_request *req = base-&gt;data;</span>
<span class="p_del">-</span>
<span class="p_del">-	echainiv_encrypt_complete2(req, err);</span>
<span class="p_del">-	aead_request_complete(req, err);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int echainiv_encrypt(struct aead_request *req)
 {
 	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
 	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
 	struct aead_request *subreq = aead_request_ctx(req);
<span class="p_del">-	crypto_completion_t compl;</span>
<span class="p_del">-	void *data;</span>
<span class="p_add">+	__be64 nseqno;</span>
<span class="p_add">+	u64 seqno;</span>
 	u8 *info;
 	unsigned int ivsize = crypto_aead_ivsize(geniv);
 	int err;
<span class="p_chunk">@@ -107,8 +43,6 @@</span> <span class="p_context"> static int echainiv_encrypt(struct aead_request *req)</span>
 
 	aead_request_set_tfm(subreq, ctx-&gt;child);
 
<span class="p_del">-	compl = echainiv_encrypt_complete;</span>
<span class="p_del">-	data = req;</span>
 	info = req-&gt;iv;
 
 	if (req-&gt;src != req-&gt;dst) {
<span class="p_chunk">@@ -123,29 +57,30 @@</span> <span class="p_context"> static int echainiv_encrypt(struct aead_request *req)</span>
 			return err;
 	}
 
<span class="p_del">-	if (unlikely(!IS_ALIGNED((unsigned long)info,</span>
<span class="p_del">-				 crypto_aead_alignmask(geniv) + 1))) {</span>
<span class="p_del">-		info = kmalloc(ivsize, req-&gt;base.flags &amp;</span>
<span class="p_del">-				       CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL:</span>
<span class="p_del">-								  GFP_ATOMIC);</span>
<span class="p_del">-		if (!info)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		memcpy(info, req-&gt;iv, ivsize);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	aead_request_set_callback(subreq, req-&gt;base.flags, compl, data);</span>
<span class="p_add">+	aead_request_set_callback(subreq, req-&gt;base.flags,</span>
<span class="p_add">+				  req-&gt;base.complete, req-&gt;base.data);</span>
 	aead_request_set_crypt(subreq, req-&gt;dst, req-&gt;dst,
 			       req-&gt;cryptlen, info);
 	aead_request_set_ad(subreq, req-&gt;assoclen);
 
<span class="p_del">-	crypto_xor(info, ctx-&gt;salt, ivsize);</span>
<span class="p_add">+	memcpy(&amp;nseqno, info + ivsize - 8, 8);</span>
<span class="p_add">+	seqno = be64_to_cpu(nseqno);</span>
<span class="p_add">+	memset(info, 0, ivsize);</span>
<span class="p_add">+</span>
 	scatterwalk_map_and_copy(info, req-&gt;dst, req-&gt;assoclen, ivsize, 1);
<span class="p_del">-	echainiv_read_iv(info, ivsize);</span>
 
<span class="p_del">-	err = crypto_aead_encrypt(subreq);</span>
<span class="p_del">-	echainiv_encrypt_complete2(req, err);</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		u64 a;</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(&amp;a, ctx-&gt;salt + ivsize - 8, 8);</span>
<span class="p_add">+</span>
<span class="p_add">+		a |= 1;</span>
<span class="p_add">+		a *= seqno;</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(info + ivsize - 8, &amp;a, 8);</span>
<span class="p_add">+	} while ((ivsize -= 8));</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_aead_encrypt(subreq);</span>
 }
 
 static int echainiv_decrypt(struct aead_request *req)
<span class="p_chunk">@@ -192,8 +127,7 @@</span> <span class="p_context"> static int echainiv_aead_create(struct crypto_template *tmpl,</span>
 	alg = crypto_spawn_aead_alg(spawn);
 
 	err = -EINVAL;
<span class="p_del">-	if (inst-&gt;alg.ivsize &amp; (sizeof(u32) - 1) ||</span>
<span class="p_del">-	    inst-&gt;alg.ivsize &gt; MAX_IV_SIZE)</span>
<span class="p_add">+	if (inst-&gt;alg.ivsize &amp; (sizeof(u64) - 1) || !inst-&gt;alg.ivsize)</span>
 		goto free_inst;
 
 	inst-&gt;alg.encrypt = echainiv_encrypt;
<span class="p_chunk">@@ -202,7 +136,6 @@</span> <span class="p_context"> static int echainiv_aead_create(struct crypto_template *tmpl,</span>
 	inst-&gt;alg.init = aead_init_geniv;
 	inst-&gt;alg.exit = aead_exit_geniv;
 
<span class="p_del">-	inst-&gt;alg.base.cra_alignmask |= __alignof__(u32) - 1;</span>
 	inst-&gt;alg.base.cra_ctxsize = sizeof(struct aead_geniv_ctx);
 	inst-&gt;alg.base.cra_ctxsize += inst-&gt;alg.ivsize;
 
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_draw.c b/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_header">index 56e1d633875e..6e6c76080d6a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_chunk">@@ -136,6 +136,8 @@</span> <span class="p_context"> static int qxl_palette_create_1bit(struct qxl_bo *palette_bo,</span>
 				 * correctly globaly, since that would require
 				 * tracking all of our palettes. */
 	ret = qxl_bo_kmap(palette_bo, (void **)&amp;pal);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	pal-&gt;num_ents = 2;
 	pal-&gt;unique = unique++;
 	if (visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-eg20t.c b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">index 137125b5eae7..5ce71ce7b6c4 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_chunk">@@ -773,13 +773,6 @@</span> <span class="p_context"> static int pch_i2c_probe(struct pci_dev *pdev,</span>
 	/* Set the number of I2C channel instance */
 	adap_info-&gt;ch_num = id-&gt;driver_data;
 
<span class="p_del">-	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_del">-		  KBUILD_MODNAME, adap_info);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_del">-		goto err_request_irq;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {
 		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;
 		adap_info-&gt;pch_i2c_suspended = false;
<span class="p_chunk">@@ -797,6 +790,17 @@</span> <span class="p_context"> static int pch_i2c_probe(struct pci_dev *pdev,</span>
 
 		pch_adap-&gt;dev.of_node = pdev-&gt;dev.of_node;
 		pch_adap-&gt;dev.parent = &amp;pdev-&gt;dev;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_add">+		  KBUILD_MODNAME, adap_info);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_add">+		goto err_request_irq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {</span>
<span class="p_add">+		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;</span>
 
 		pch_i2c_init(&amp;adap_info-&gt;pch_data[i]);
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-qup.c b/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_header">index 041050edd809..57256bb42fcd 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_chunk">@@ -1610,7 +1610,8 @@</span> <span class="p_context"> static int qup_i2c_pm_resume_runtime(struct device *device)</span>
 #ifdef CONFIG_PM_SLEEP
 static int qup_i2c_suspend(struct device *device)
 {
<span class="p_del">-	qup_i2c_pm_suspend_runtime(device);</span>
<span class="p_add">+	if (!pm_runtime_suspended(device))</span>
<span class="p_add">+		return qup_i2c_pm_suspend_runtime(device);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">index 528e755c468f..3278ebf1cc5c 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int pca954x_select_chan(struct i2c_mux_core *muxc, u32 chan)</span>
 	/* Only select the channel if its different from the last channel */
 	if (data-&gt;last_chan != regval) {
 		ret = pca954x_reg_write(muxc-&gt;parent, client, regval);
<span class="p_del">-		data-&gt;last_chan = regval;</span>
<span class="p_add">+		data-&gt;last_chan = ret ? 0 : regval;</span>
 	}
 
 	return ret;
<span class="p_header">diff --git a/drivers/infiniband/hw/cxgb4/cm.c b/drivers/infiniband/hw/cxgb4/cm.c</span>
<span class="p_header">index a3a67216bce6..be00c4bc0b70 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/cxgb4/cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/cxgb4/cm.c</span>
<span class="p_chunk">@@ -3011,9 +3011,9 @@</span> <span class="p_context"> static int fw4_ack(struct c4iw_dev *dev, struct sk_buff *skb)</span>
 		PDBG(&quot;%s last streaming msg ack ep %p tid %u state %u &quot;
 		     &quot;initiator %u freeing skb\n&quot;, __func__, ep, ep-&gt;hwtid,
 		     state_read(&amp;ep-&gt;com), ep-&gt;mpa_attr.initiator ? 1 : 0);
<span class="p_add">+		mutex_lock(&amp;ep-&gt;com.mutex);</span>
 		kfree_skb(ep-&gt;mpa_skb);
 		ep-&gt;mpa_skb = NULL;
<span class="p_del">-		mutex_lock(&amp;ep-&gt;com.mutex);</span>
 		if (test_bit(STOP_MPA_TIMER, &amp;ep-&gt;com.flags))
 			stop_ep_timer(ep);
 		mutex_unlock(&amp;ep-&gt;com.mutex);
<span class="p_chunk">@@ -3582,6 +3582,16 @@</span> <span class="p_context"> int c4iw_ep_disconnect(struct c4iw_ep *ep, int abrupt, gfp_t gfp)</span>
 			ep-&gt;com.state = ABORTING;
 		else {
 			ep-&gt;com.state = CLOSING;
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * if we close before we see the fw4_ack() then we fix</span>
<span class="p_add">+			 * up the timer state since we&#39;re reusing it.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (ep-&gt;mpa_skb &amp;&amp;</span>
<span class="p_add">+			    test_bit(STOP_MPA_TIMER, &amp;ep-&gt;com.flags)) {</span>
<span class="p_add">+				clear_bit(STOP_MPA_TIMER, &amp;ep-&gt;com.flags);</span>
<span class="p_add">+				stop_ep_timer(ep);</span>
<span class="p_add">+			}</span>
 			start_ep_timer(ep);
 		}
 		set_bit(CLOSE_SENT, &amp;ep-&gt;com.flags);
<span class="p_header">diff --git a/drivers/irqchip/irq-mips-gic.c b/drivers/irqchip/irq-mips-gic.c</span>
<span class="p_header">index d3ef0fcaaddf..6acf69ee0639 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-mips-gic.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-mips-gic.c</span>
<span class="p_chunk">@@ -638,27 +638,6 @@</span> <span class="p_context"> static int gic_local_irq_domain_map(struct irq_domain *d, unsigned int virq,</span>
 	if (!gic_local_irq_is_routable(intr))
 		return -EPERM;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * HACK: These are all really percpu interrupts, but the rest</span>
<span class="p_del">-	 * of the MIPS kernel code does not use the percpu IRQ API for</span>
<span class="p_del">-	 * the CP0 timer and performance counter interrupts.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	switch (intr) {</span>
<span class="p_del">-	case GIC_LOCAL_INT_TIMER:</span>
<span class="p_del">-	case GIC_LOCAL_INT_PERFCTR:</span>
<span class="p_del">-	case GIC_LOCAL_INT_FDC:</span>
<span class="p_del">-		irq_set_chip_and_handler(virq,</span>
<span class="p_del">-					 &amp;gic_all_vpes_local_irq_controller,</span>
<span class="p_del">-					 handle_percpu_irq);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		irq_set_chip_and_handler(virq,</span>
<span class="p_del">-					 &amp;gic_local_irq_controller,</span>
<span class="p_del">-					 handle_percpu_devid_irq);</span>
<span class="p_del">-		irq_set_percpu_devid(virq);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	spin_lock_irqsave(&amp;gic_lock, flags);
 	for (i = 0; i &lt; gic_vpes; i++) {
 		u32 val = GIC_MAP_TO_PIN_MSK | gic_cpu_pin;
<span class="p_chunk">@@ -724,16 +703,42 @@</span> <span class="p_context"> static int gic_shared_irq_domain_map(struct irq_domain *d, unsigned int virq,</span>
 	return 0;
 }
 
<span class="p_del">-static int gic_irq_domain_map(struct irq_domain *d, unsigned int virq,</span>
<span class="p_del">-			      irq_hw_number_t hw)</span>
<span class="p_add">+static int gic_setup_dev_chip(struct irq_domain *d, unsigned int virq,</span>
<span class="p_add">+			      unsigned int hwirq)</span>
 {
<span class="p_del">-	if (GIC_HWIRQ_TO_LOCAL(hw) &lt; GIC_NUM_LOCAL_INTRS)</span>
<span class="p_del">-		return gic_local_irq_domain_map(d, virq, hw);</span>
<span class="p_add">+	struct irq_chip *chip;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hwirq &gt;= GIC_SHARED_HWIRQ_BASE) {</span>
<span class="p_add">+		err = irq_domain_set_hwirq_and_chip(d, virq, hwirq,</span>
<span class="p_add">+						    &amp;gic_level_irq_controller,</span>
<span class="p_add">+						    NULL);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		switch (GIC_HWIRQ_TO_LOCAL(hwirq)) {</span>
<span class="p_add">+		case GIC_LOCAL_INT_TIMER:</span>
<span class="p_add">+		case GIC_LOCAL_INT_PERFCTR:</span>
<span class="p_add">+		case GIC_LOCAL_INT_FDC:</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * HACK: These are all really percpu interrupts, but</span>
<span class="p_add">+			 * the rest of the MIPS kernel code does not use the</span>
<span class="p_add">+			 * percpu IRQ API for them.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			chip = &amp;gic_all_vpes_local_irq_controller;</span>
<span class="p_add">+			irq_set_handler(virq, handle_percpu_irq);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			chip = &amp;gic_local_irq_controller;</span>
<span class="p_add">+			irq_set_handler(virq, handle_percpu_devid_irq);</span>
<span class="p_add">+			irq_set_percpu_devid(virq);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	irq_set_chip_and_handler(virq, &amp;gic_level_irq_controller,</span>
<span class="p_del">-				 handle_level_irq);</span>
<span class="p_add">+		err = irq_domain_set_hwirq_and_chip(d, virq, hwirq,</span>
<span class="p_add">+						    chip, NULL);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	return gic_shared_irq_domain_map(d, virq, hw, 0);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int gic_irq_domain_alloc(struct irq_domain *d, unsigned int virq,
<span class="p_chunk">@@ -744,15 +749,12 @@</span> <span class="p_context"> static int gic_irq_domain_alloc(struct irq_domain *d, unsigned int virq,</span>
 	int cpu, ret, i;
 
 	if (spec-&gt;type == GIC_DEVICE) {
<span class="p_del">-		/* verify that it doesn&#39;t conflict with an IPI irq */</span>
<span class="p_del">-		if (test_bit(spec-&gt;hwirq, ipi_resrv))</span>
<span class="p_add">+		/* verify that shared irqs don&#39;t conflict with an IPI irq */</span>
<span class="p_add">+		if ((spec-&gt;hwirq &gt;= GIC_SHARED_HWIRQ_BASE) &amp;&amp;</span>
<span class="p_add">+		    test_bit(GIC_HWIRQ_TO_SHARED(spec-&gt;hwirq), ipi_resrv))</span>
 			return -EBUSY;
 
<span class="p_del">-		hwirq = GIC_SHARED_TO_HWIRQ(spec-&gt;hwirq);</span>
<span class="p_del">-</span>
<span class="p_del">-		return irq_domain_set_hwirq_and_chip(d, virq, hwirq,</span>
<span class="p_del">-						     &amp;gic_level_irq_controller,</span>
<span class="p_del">-						     NULL);</span>
<span class="p_add">+		return gic_setup_dev_chip(d, virq, spec-&gt;hwirq);</span>
 	} else {
 		base_hwirq = find_first_bit(ipi_resrv, gic_shared_intrs);
 		if (base_hwirq == gic_shared_intrs) {
<span class="p_chunk">@@ -821,7 +823,6 @@</span> <span class="p_context"> int gic_irq_domain_match(struct irq_domain *d, struct device_node *node,</span>
 }
 
 static const struct irq_domain_ops gic_irq_domain_ops = {
<span class="p_del">-	.map = gic_irq_domain_map,</span>
 	.alloc = gic_irq_domain_alloc,
 	.free = gic_irq_domain_free,
 	.match = gic_irq_domain_match,
<span class="p_chunk">@@ -852,29 +853,20 @@</span> <span class="p_context"> static int gic_dev_domain_alloc(struct irq_domain *d, unsigned int virq,</span>
 	struct irq_fwspec *fwspec = arg;
 	struct gic_irq_spec spec = {
 		.type = GIC_DEVICE,
<span class="p_del">-		.hwirq = fwspec-&gt;param[1],</span>
 	};
 	int i, ret;
<span class="p_del">-	bool is_shared = fwspec-&gt;param[0] == GIC_SHARED;</span>
 
<span class="p_del">-	if (is_shared) {</span>
<span class="p_del">-		ret = irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &amp;spec);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; nr_irqs; i++) {</span>
<span class="p_del">-		irq_hw_number_t hwirq;</span>
<span class="p_add">+	if (fwspec-&gt;param[0] == GIC_SHARED)</span>
<span class="p_add">+		spec.hwirq = GIC_SHARED_TO_HWIRQ(fwspec-&gt;param[1]);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		spec.hwirq = GIC_LOCAL_TO_HWIRQ(fwspec-&gt;param[1]);</span>
 
<span class="p_del">-		if (is_shared)</span>
<span class="p_del">-			hwirq = GIC_SHARED_TO_HWIRQ(spec.hwirq + i);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			hwirq = GIC_LOCAL_TO_HWIRQ(spec.hwirq + i);</span>
<span class="p_add">+	ret = irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &amp;spec);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-		ret = irq_domain_set_hwirq_and_chip(d, virq + i,</span>
<span class="p_del">-						    hwirq,</span>
<span class="p_del">-						    &amp;gic_level_irq_controller,</span>
<span class="p_del">-						    NULL);</span>
<span class="p_add">+	for (i = 0; i &lt; nr_irqs; i++) {</span>
<span class="p_add">+		ret = gic_setup_dev_chip(d, virq + i, spec.hwirq + i);</span>
 		if (ret)
 			goto error;
 	}
<span class="p_chunk">@@ -896,7 +888,10 @@</span> <span class="p_context"> void gic_dev_domain_free(struct irq_domain *d, unsigned int virq,</span>
 static void gic_dev_domain_activate(struct irq_domain *domain,
 				    struct irq_data *d)
 {
<span class="p_del">-	gic_shared_irq_domain_map(domain, d-&gt;irq, d-&gt;hwirq, 0);</span>
<span class="p_add">+	if (GIC_HWIRQ_TO_LOCAL(d-&gt;hwirq) &lt; GIC_NUM_LOCAL_INTRS)</span>
<span class="p_add">+		gic_local_irq_domain_map(domain, d-&gt;irq, d-&gt;hwirq);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		gic_shared_irq_domain_map(domain, d-&gt;irq, d-&gt;hwirq, 0);</span>
 }
 
 static struct irq_domain_ops gic_dev_domain_ops = {
<span class="p_header">diff --git a/drivers/mtd/maps/pmcmsp-flash.c b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">index 744ca5cacc9b..f9fa3fad728e 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_chunk">@@ -75,15 +75,15 @@</span> <span class="p_context"> static int __init init_msp_flash(void)</span>
 
 	printk(KERN_NOTICE &quot;Found %d PMC flash devices\n&quot;, fcnt);
 
<span class="p_del">-	msp_flash = kmalloc(fcnt * sizeof(struct map_info *), GFP_KERNEL);</span>
<span class="p_add">+	msp_flash = kcalloc(fcnt, sizeof(*msp_flash), GFP_KERNEL);</span>
 	if (!msp_flash)
 		return -ENOMEM;
 
<span class="p_del">-	msp_parts = kmalloc(fcnt * sizeof(struct mtd_partition *), GFP_KERNEL);</span>
<span class="p_add">+	msp_parts = kcalloc(fcnt, sizeof(*msp_parts), GFP_KERNEL);</span>
 	if (!msp_parts)
 		goto free_msp_flash;
 
<span class="p_del">-	msp_maps = kcalloc(fcnt, sizeof(struct mtd_info), GFP_KERNEL);</span>
<span class="p_add">+	msp_maps = kcalloc(fcnt, sizeof(*msp_maps), GFP_KERNEL);</span>
 	if (!msp_maps)
 		goto free_msp_parts;
 
<span class="p_header">diff --git a/drivers/mtd/maps/sa1100-flash.c b/drivers/mtd/maps/sa1100-flash.c</span>
<span class="p_header">index 142fc3d79463..784c6e1a0391 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/sa1100-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/sa1100-flash.c</span>
<span class="p_chunk">@@ -230,8 +230,10 @@</span> <span class="p_context"> static struct sa_info *sa1100_setup_mtd(struct platform_device *pdev,</span>
 
 		info-&gt;mtd = mtd_concat_create(cdev, info-&gt;num_subdev,
 					      plat-&gt;name);
<span class="p_del">-		if (info-&gt;mtd == NULL)</span>
<span class="p_add">+		if (info-&gt;mtd == NULL) {</span>
 			ret = -ENXIO;
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 	}
 	info-&gt;mtd-&gt;dev.parent = &amp;pdev-&gt;dev;
 
<span class="p_header">diff --git a/drivers/mtd/nand/mxc_nand.c b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">index 5173fadc9a4e..57cbe2b83849 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_chunk">@@ -943,7 +943,7 @@</span> <span class="p_context"> static int mxc_v2_ooblayout_free(struct mtd_info *mtd, int section,</span>
 	struct nand_chip *nand_chip = mtd_to_nand(mtd);
 	int stepsize = nand_chip-&gt;ecc.bytes == 9 ? 16 : 26;
 
<span class="p_del">-	if (section &gt; nand_chip-&gt;ecc.steps)</span>
<span class="p_add">+	if (section &gt;= nand_chip-&gt;ecc.steps)</span>
 		return -ERANGE;
 
 	if (!section) {
<span class="p_header">diff --git a/drivers/mtd/spi-nor/spi-nor.c b/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_header">index c52e45594bfd..a6adb2785b14 100644</span>
<span class="p_header">--- a/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_header">+++ b/drivers/mtd/spi-nor/spi-nor.c</span>
<span class="p_chunk">@@ -661,7 +661,7 @@</span> <span class="p_context"> static int stm_unlock(struct spi_nor *nor, loff_t ofs, uint64_t len)</span>
 	status_new = (status_old &amp; ~mask &amp; ~SR_TB) | val;
 
 	/* Don&#39;t protect status register if we&#39;re fully unlocked */
<span class="p_del">-	if (lock_len == mtd-&gt;size)</span>
<span class="p_add">+	if (lock_len == 0)</span>
 		status_new &amp;= ~SR_SRWD;
 
 	if (!use_top)
<span class="p_header">diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c</span>
<span class="p_header">index 41c0fc9f3b14..16f7cadda5c3 100644</span>
<span class="p_header">--- a/drivers/net/can/flexcan.c</span>
<span class="p_header">+++ b/drivers/net/can/flexcan.c</span>
<span class="p_chunk">@@ -1268,11 +1268,10 @@</span> <span class="p_context"> static int __maybe_unused flexcan_suspend(struct device *device)</span>
 	struct flexcan_priv *priv = netdev_priv(dev);
 	int err;
 
<span class="p_del">-	err = flexcan_chip_disable(priv);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
 	if (netif_running(dev)) {
<span class="p_add">+		err = flexcan_chip_disable(priv);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 		netif_stop_queue(dev);
 		netif_device_detach(dev);
 	}
<span class="p_chunk">@@ -1285,13 +1284,17 @@</span> <span class="p_context"> static int __maybe_unused flexcan_resume(struct device *device)</span>
 {
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
<span class="p_add">+	int err;</span>
 
 	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
 	if (netif_running(dev)) {
 		netif_device_attach(dev);
 		netif_start_queue(dev);
<span class="p_add">+		err = flexcan_chip_enable(priv);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_del">-	return flexcan_chip_enable(priv);</span>
<span class="p_add">+	return 0;</span>
 }
 
 static SIMPLE_DEV_PM_OPS(flexcan_pm_ops, flexcan_suspend, flexcan_resume);
<span class="p_header">diff --git a/drivers/net/can/ifi_canfd/ifi_canfd.c b/drivers/net/can/ifi_canfd/ifi_canfd.c</span>
<span class="p_header">index 2d1d22eec750..368bb0710d8f 100644</span>
<span class="p_header">--- a/drivers/net/can/ifi_canfd/ifi_canfd.c</span>
<span class="p_header">+++ b/drivers/net/can/ifi_canfd/ifi_canfd.c</span>
<span class="p_chunk">@@ -81,6 +81,10 @@</span> <span class="p_context"></span>
 #define IFI_CANFD_TIME_SET_TIMEA_4_12_6_6	BIT(15)
 
 #define IFI_CANFD_TDELAY			0x1c
<span class="p_add">+#define IFI_CANFD_TDELAY_DEFAULT		0xb</span>
<span class="p_add">+#define IFI_CANFD_TDELAY_MASK			0x3fff</span>
<span class="p_add">+#define IFI_CANFD_TDELAY_ABS			BIT(14)</span>
<span class="p_add">+#define IFI_CANFD_TDELAY_EN			BIT(15)</span>
 
 #define IFI_CANFD_ERROR				0x20
 #define IFI_CANFD_ERROR_TX_OFFSET		0
<span class="p_chunk">@@ -641,7 +645,7 @@</span> <span class="p_context"> static void ifi_canfd_set_bittiming(struct net_device *ndev)</span>
 	struct ifi_canfd_priv *priv = netdev_priv(ndev);
 	const struct can_bittiming *bt = &amp;priv-&gt;can.bittiming;
 	const struct can_bittiming *dbt = &amp;priv-&gt;can.data_bittiming;
<span class="p_del">-	u16 brp, sjw, tseg1, tseg2;</span>
<span class="p_add">+	u16 brp, sjw, tseg1, tseg2, tdc;</span>
 
 	/* Configure bit timing */
 	brp = bt-&gt;brp - 2;
<span class="p_chunk">@@ -664,6 +668,11 @@</span> <span class="p_context"> static void ifi_canfd_set_bittiming(struct net_device *ndev)</span>
 	       (brp &lt;&lt; IFI_CANFD_TIME_PRESCALE_OFF) |
 	       (sjw &lt;&lt; IFI_CANFD_TIME_SJW_OFF_7_9_8_8),
 	       priv-&gt;base + IFI_CANFD_FTIME);
<span class="p_add">+</span>
<span class="p_add">+	/* Configure transmitter delay */</span>
<span class="p_add">+	tdc = (dbt-&gt;brp * (dbt-&gt;phase_seg1 + 1)) &amp; IFI_CANFD_TDELAY_MASK;</span>
<span class="p_add">+	writel(IFI_CANFD_TDELAY_EN | IFI_CANFD_TDELAY_ABS | tdc,</span>
<span class="p_add">+	       priv-&gt;base + IFI_CANFD_TDELAY);</span>
 }
 
 static void ifi_canfd_set_filter(struct net_device *ndev, const u32 id,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_ptp.c b/drivers/net/ethernet/intel/igb/igb_ptp.c</span>
<span class="p_header">index f097c5a8ab93..3c7bcdf76f1f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_ptp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_ptp.c</span>
<span class="p_chunk">@@ -743,7 +743,8 @@</span> <span class="p_context"> static void igb_ptp_tx_hwtstamp(struct igb_adapter *adapter)</span>
 		}
 	}
 
<span class="p_del">-	shhwtstamps.hwtstamp = ktime_sub_ns(shhwtstamps.hwtstamp, adjust);</span>
<span class="p_add">+	shhwtstamps.hwtstamp =</span>
<span class="p_add">+		ktime_add_ns(shhwtstamps.hwtstamp, adjust);</span>
 
 	skb_tstamp_tx(adapter-&gt;ptp_tx_skb, &amp;shhwtstamps);
 	dev_kfree_skb_any(adapter-&gt;ptp_tx_skb);
<span class="p_chunk">@@ -766,13 +767,32 @@</span> <span class="p_context"> void igb_ptp_rx_pktstamp(struct igb_q_vector *q_vector,</span>
 			 struct sk_buff *skb)
 {
 	__le64 *regval = (__le64 *)va;
<span class="p_add">+	struct igb_adapter *adapter = q_vector-&gt;adapter;</span>
<span class="p_add">+	int adjust = 0;</span>
 
 	/* The timestamp is recorded in little endian format.
 	 * DWORD: 0        1        2        3
 	 * Field: Reserved Reserved SYSTIML  SYSTIMH
 	 */
<span class="p_del">-	igb_ptp_systim_to_hwtstamp(q_vector-&gt;adapter, skb_hwtstamps(skb),</span>
<span class="p_add">+	igb_ptp_systim_to_hwtstamp(adapter, skb_hwtstamps(skb),</span>
 				   le64_to_cpu(regval[1]));
<span class="p_add">+</span>
<span class="p_add">+	/* adjust timestamp for the RX latency based on link speed */</span>
<span class="p_add">+	if (adapter-&gt;hw.mac.type == e1000_i210) {</span>
<span class="p_add">+		switch (adapter-&gt;link_speed) {</span>
<span class="p_add">+		case SPEED_10:</span>
<span class="p_add">+			adjust = IGB_I210_RX_LATENCY_10;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SPEED_100:</span>
<span class="p_add">+			adjust = IGB_I210_RX_LATENCY_100;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SPEED_1000:</span>
<span class="p_add">+			adjust = IGB_I210_RX_LATENCY_1000;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	skb_hwtstamps(skb)-&gt;hwtstamp =</span>
<span class="p_add">+		ktime_sub_ns(skb_hwtstamps(skb)-&gt;hwtstamp, adjust);</span>
 }
 
 /**
<span class="p_chunk">@@ -824,7 +844,7 @@</span> <span class="p_context"> void igb_ptp_rx_rgtstamp(struct igb_q_vector *q_vector,</span>
 		}
 	}
 	skb_hwtstamps(skb)-&gt;hwtstamp =
<span class="p_del">-		ktime_add_ns(skb_hwtstamps(skb)-&gt;hwtstamp, adjust);</span>
<span class="p_add">+		ktime_sub_ns(skb_hwtstamps(skb)-&gt;hwtstamp, adjust);</span>
 
 	/* Update the last_rx_timestamp timer in order to enable watchdog check
 	 * for error case of latched timestamp on a dropped packet.
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">index 8bebd862a54c..58153e818e81 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_chunk">@@ -4100,6 +4100,8 @@</span> <span class="p_context"> static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)</span>
 	struct ixgbe_hw *hw = &amp;adapter-&gt;hw;
 	u32 vlnctrl, i;
 
<span class="p_add">+	vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);</span>
<span class="p_add">+</span>
 	switch (hw-&gt;mac.type) {
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
<span class="p_chunk">@@ -4112,8 +4114,7 @@</span> <span class="p_context"> static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)</span>
 		/* fall through */
 	case ixgbe_mac_82598EB:
 		/* legacy case, we can just disable VLAN filtering */
<span class="p_del">-		vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);</span>
<span class="p_del">-		vlnctrl &amp;= ~(IXGBE_VLNCTRL_VFE | IXGBE_VLNCTRL_CFIEN);</span>
<span class="p_add">+		vlnctrl &amp;= ~IXGBE_VLNCTRL_VFE;</span>
 		IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);
 		return;
 	}
<span class="p_chunk">@@ -4125,6 +4126,10 @@</span> <span class="p_context"> static void ixgbe_vlan_promisc_enable(struct ixgbe_adapter *adapter)</span>
 	/* Set flag so we don&#39;t redo unnecessary work */
 	adapter-&gt;flags2 |= IXGBE_FLAG2_VLAN_PROMISC;
 
<span class="p_add">+	/* For VMDq and SR-IOV we must leave VLAN filtering enabled */</span>
<span class="p_add">+	vlnctrl |= IXGBE_VLNCTRL_VFE;</span>
<span class="p_add">+	IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);</span>
<span class="p_add">+</span>
 	/* Add PF to all active pools */
 	for (i = IXGBE_VLVF_ENTRIES; --i;) {
 		u32 reg_offset = IXGBE_VLVFB(i * 2 + VMDQ_P(0) / 32);
<span class="p_chunk">@@ -4191,6 +4196,11 @@</span> <span class="p_context"> static void ixgbe_vlan_promisc_disable(struct ixgbe_adapter *adapter)</span>
 	struct ixgbe_hw *hw = &amp;adapter-&gt;hw;
 	u32 vlnctrl, i;
 
<span class="p_add">+	/* Set VLAN filtering to enabled */</span>
<span class="p_add">+	vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);</span>
<span class="p_add">+	vlnctrl |= IXGBE_VLNCTRL_VFE;</span>
<span class="p_add">+	IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);</span>
<span class="p_add">+</span>
 	switch (hw-&gt;mac.type) {
 	case ixgbe_mac_82599EB:
 	case ixgbe_mac_X540:
<span class="p_chunk">@@ -4202,10 +4212,6 @@</span> <span class="p_context"> static void ixgbe_vlan_promisc_disable(struct ixgbe_adapter *adapter)</span>
 			break;
 		/* fall through */
 	case ixgbe_mac_82598EB:
<span class="p_del">-		vlnctrl = IXGBE_READ_REG(hw, IXGBE_VLNCTRL);</span>
<span class="p_del">-		vlnctrl &amp;= ~IXGBE_VLNCTRL_CFIEN;</span>
<span class="p_del">-		vlnctrl |= IXGBE_VLNCTRL_VFE;</span>
<span class="p_del">-		IXGBE_WRITE_REG(hw, IXGBE_VLNCTRL, vlnctrl);</span>
 		return;
 	}
 
<span class="p_chunk">@@ -9496,6 +9502,7 @@</span> <span class="p_context"> skip_sriov:</span>
 
 	/* copy netdev features into list of user selectable features */
 	netdev-&gt;hw_features |= netdev-&gt;features |
<span class="p_add">+			       NETIF_F_HW_VLAN_CTAG_FILTER |</span>
 			       NETIF_F_HW_VLAN_CTAG_RX |
 			       NETIF_F_HW_VLAN_CTAG_TX |
 			       NETIF_F_RXALL |
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">index 779bafcbc9a1..b92b75fea92f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_chunk">@@ -501,6 +501,15 @@</span> <span class="p_context"> int iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb)</span>
 	int hdrlen = ieee80211_hdrlen(hdr-&gt;frame_control);
 	int queue;
 
<span class="p_add">+	/* IWL_MVM_OFFCHANNEL_QUEUE is used for ROC packets that can be used</span>
<span class="p_add">+	 * in 2 different types of vifs, P2P &amp; STATION. P2P uses the offchannel</span>
<span class="p_add">+	 * queue. STATION (HS2.0) uses the auxiliary context of the FW,</span>
<span class="p_add">+	 * and hence needs to be sent on the aux queue</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IEEE80211_SKB_CB(skb)-&gt;hw_queue == IWL_MVM_OFFCHANNEL_QUEUE &amp;&amp;</span>
<span class="p_add">+	    skb_info-&gt;control.vif-&gt;type == NL80211_IFTYPE_STATION)</span>
<span class="p_add">+		IEEE80211_SKB_CB(skb)-&gt;hw_queue = mvm-&gt;aux_queue;</span>
<span class="p_add">+</span>
 	memcpy(&amp;info, skb-&gt;cb, sizeof(info));
 
 	if (WARN_ON_ONCE(info.flags &amp; IEEE80211_TX_CTL_AMPDU))
<span class="p_chunk">@@ -514,16 +523,6 @@</span> <span class="p_context"> int iwl_mvm_tx_skb_non_sta(struct iwl_mvm *mvm, struct sk_buff *skb)</span>
 	/* This holds the amsdu headers length */
 	skb_info-&gt;driver_data[0] = (void *)(uintptr_t)0;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * IWL_MVM_OFFCHANNEL_QUEUE is used for ROC packets that can be used</span>
<span class="p_del">-	 * in 2 different types of vifs, P2P &amp; STATION. P2P uses the offchannel</span>
<span class="p_del">-	 * queue. STATION (HS2.0) uses the auxiliary context of the FW,</span>
<span class="p_del">-	 * and hence needs to be sent on the aux queue</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (IEEE80211_SKB_CB(skb)-&gt;hw_queue == IWL_MVM_OFFCHANNEL_QUEUE &amp;&amp;</span>
<span class="p_del">-	    info.control.vif-&gt;type == NL80211_IFTYPE_STATION)</span>
<span class="p_del">-		IEEE80211_SKB_CB(skb)-&gt;hw_queue = mvm-&gt;aux_queue;</span>
<span class="p_del">-</span>
 	queue = info.hw_queue;
 
 	/*
<span class="p_header">diff --git a/drivers/power/max17042_battery.c b/drivers/power/max17042_battery.c</span>
<span class="p_header">index 9c65f134d447..da7a75f82489 100644</span>
<span class="p_header">--- a/drivers/power/max17042_battery.c</span>
<span class="p_header">+++ b/drivers/power/max17042_battery.c</span>
<span class="p_chunk">@@ -457,13 +457,16 @@</span> <span class="p_context"> static inline void max17042_write_model_data(struct max17042_chip *chip,</span>
 }
 
 static inline void max17042_read_model_data(struct max17042_chip *chip,
<span class="p_del">-					u8 addr, u32 *data, int size)</span>
<span class="p_add">+					u8 addr, u16 *data, int size)</span>
 {
 	struct regmap *map = chip-&gt;regmap;
 	int i;
<span class="p_add">+	u32 tmp;</span>
 
<span class="p_del">-	for (i = 0; i &lt; size; i++)</span>
<span class="p_del">-		regmap_read(map, addr + i, &amp;data[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; size; i++) {</span>
<span class="p_add">+		regmap_read(map, addr + i, &amp;tmp);</span>
<span class="p_add">+		data[i] = (u16)tmp;</span>
<span class="p_add">+	}</span>
 }
 
 static inline int max17042_model_data_compare(struct max17042_chip *chip,
<span class="p_chunk">@@ -486,7 +489,7 @@</span> <span class="p_context"> static int max17042_init_model(struct max17042_chip *chip)</span>
 {
 	int ret;
 	int table_size = ARRAY_SIZE(chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl);
<span class="p_del">-	u32 *temp_data;</span>
<span class="p_add">+	u16 *temp_data;</span>
 
 	temp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);
 	if (!temp_data)
<span class="p_chunk">@@ -501,7 +504,7 @@</span> <span class="p_context"> static int max17042_init_model(struct max17042_chip *chip)</span>
 	ret = max17042_model_data_compare(
 		chip,
 		chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl,
<span class="p_del">-		(u16 *)temp_data,</span>
<span class="p_add">+		temp_data,</span>
 		table_size);
 
 	max10742_lock_model(chip);
<span class="p_chunk">@@ -514,7 +517,7 @@</span> <span class="p_context"> static int max17042_verify_model_lock(struct max17042_chip *chip)</span>
 {
 	int i;
 	int table_size = ARRAY_SIZE(chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl);
<span class="p_del">-	u32 *temp_data;</span>
<span class="p_add">+	u16 *temp_data;</span>
 	int ret = 0;
 
 	temp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/power/reset/hisi-reboot.c b/drivers/power/reset/hisi-reboot.c</span>
<span class="p_header">index 9ab7f562a83b..f69387e12c1e 100644</span>
<span class="p_header">--- a/drivers/power/reset/hisi-reboot.c</span>
<span class="p_header">+++ b/drivers/power/reset/hisi-reboot.c</span>
<span class="p_chunk">@@ -53,13 +53,16 @@</span> <span class="p_context"> static int hisi_reboot_probe(struct platform_device *pdev)</span>
 
 	if (of_property_read_u32(np, &quot;reboot-offset&quot;, &amp;reboot_offset) &lt; 0) {
 		pr_err(&quot;failed to find reboot-offset property\n&quot;);
<span class="p_add">+		iounmap(base);</span>
 		return -EINVAL;
 	}
 
 	err = register_restart_handler(&amp;hisi_restart_nb);
<span class="p_del">-	if (err)</span>
<span class="p_add">+	if (err) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;cannot register restart handler (err=%d)\n&quot;,
 			err);
<span class="p_add">+		iounmap(base);</span>
<span class="p_add">+	}</span>
 
 	return err;
 }
<span class="p_header">diff --git a/drivers/power/tps65217_charger.c b/drivers/power/tps65217_charger.c</span>
<span class="p_header">index 73dfae41def8..4c56e54af6ac 100644</span>
<span class="p_header">--- a/drivers/power/tps65217_charger.c</span>
<span class="p_header">+++ b/drivers/power/tps65217_charger.c</span>
<span class="p_chunk">@@ -206,6 +206,7 @@</span> <span class="p_context"> static int tps65217_charger_probe(struct platform_device *pdev)</span>
 	if (!charger)
 		return -ENOMEM;
 
<span class="p_add">+	platform_set_drvdata(pdev, charger);</span>
 	charger-&gt;tps = tps;
 	charger-&gt;dev = &amp;pdev-&gt;dev;
 
<span class="p_header">diff --git a/drivers/rtc/rtc-ds1307.c b/drivers/rtc/rtc-ds1307.c</span>
<span class="p_header">index 821d9c089cdb..f25f7dce6e1f 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-ds1307.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-ds1307.c</span>
<span class="p_chunk">@@ -602,6 +602,8 @@</span> <span class="p_context"> static const struct rtc_class_ops ds13xx_rtc_ops = {</span>
  * Alarm support for mcp794xx devices.
  */
 
<span class="p_add">+#define MCP794XX_REG_WEEKDAY		0x3</span>
<span class="p_add">+#define MCP794XX_REG_WEEKDAY_WDAY_MASK	0x7</span>
 #define MCP794XX_REG_CONTROL		0x07
 #	define MCP794XX_BIT_ALM0_EN	0x10
 #	define MCP794XX_BIT_ALM1_EN	0x20
<span class="p_chunk">@@ -1231,13 +1233,16 @@</span> <span class="p_context"> static int ds1307_probe(struct i2c_client *client,</span>
 {
 	struct ds1307		*ds1307;
 	int			err = -ENODEV;
<span class="p_del">-	int			tmp;</span>
<span class="p_add">+	int			tmp, wday;</span>
 	struct chip_desc	*chip = &amp;chips[id-&gt;driver_data];
 	struct i2c_adapter	*adapter = to_i2c_adapter(client-&gt;dev.parent);
 	bool			want_irq = false;
 	bool			ds1307_can_wakeup_device = false;
 	unsigned char		*buf;
 	struct ds1307_platform_data *pdata = dev_get_platdata(&amp;client-&gt;dev);
<span class="p_add">+	struct rtc_time		tm;</span>
<span class="p_add">+	unsigned long		timestamp;</span>
<span class="p_add">+</span>
 	irq_handler_t	irq_handler = ds1307_irq;
 
 	static const int	bbsqi_bitpos[] = {
<span class="p_chunk">@@ -1526,6 +1531,27 @@</span> <span class="p_context"> read_rtc:</span>
 				bin2bcd(tmp));
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some IPs have weekday reset value = 0x1 which might not correct</span>
<span class="p_add">+	 * hence compute the wday using the current date/month/year values</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ds1307_get_time(&amp;client-&gt;dev, &amp;tm);</span>
<span class="p_add">+	wday = tm.tm_wday;</span>
<span class="p_add">+	timestamp = rtc_tm_to_time64(&amp;tm);</span>
<span class="p_add">+	rtc_time64_to_tm(timestamp, &amp;tm);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check if reset wday is different from the computed wday</span>
<span class="p_add">+	 * If different then set the wday which we computed using</span>
<span class="p_add">+	 * timestamp</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (wday != tm.tm_wday) {</span>
<span class="p_add">+		wday = i2c_smbus_read_byte_data(client, MCP794XX_REG_WEEKDAY);</span>
<span class="p_add">+		wday = wday &amp; ~MCP794XX_REG_WEEKDAY_WDAY_MASK;</span>
<span class="p_add">+		wday = wday | (tm.tm_wday + 1);</span>
<span class="p_add">+		i2c_smbus_write_byte_data(client, MCP794XX_REG_WEEKDAY, wday);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (want_irq) {
 		device_set_wakeup_capable(&amp;client-&gt;dev, true);
 		set_bit(HAS_ALARM, &amp;ds1307-&gt;flags);
<span class="p_header">diff --git a/drivers/soc/tegra/pmc.c b/drivers/soc/tegra/pmc.c</span>
<span class="p_header">index bb173456bbff..5031c89b0d0d 100644</span>
<span class="p_header">--- a/drivers/soc/tegra/pmc.c</span>
<span class="p_header">+++ b/drivers/soc/tegra/pmc.c</span>
<span class="p_chunk">@@ -1205,6 +1205,14 @@</span> <span class="p_context"> static int tegra_pmc_probe(struct platform_device *pdev)</span>
 	struct resource *res;
 	int err;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Early initialisation should have configured an initial</span>
<span class="p_add">+	 * register mapping and setup the soc data pointer. If these</span>
<span class="p_add">+	 * are not valid then something went badly wrong!</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (WARN_ON(!pmc-&gt;base || !pmc-&gt;soc))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	err = tegra_pmc_parse_dt(pmc, pdev-&gt;dev.of_node);
 	if (err &lt; 0)
 		return err;
<span class="p_header">diff --git a/fs/autofs4/expire.c b/fs/autofs4/expire.c</span>
<span class="p_header">index b493909e7492..d8e6d421c27f 100644</span>
<span class="p_header">--- a/fs/autofs4/expire.c</span>
<span class="p_header">+++ b/fs/autofs4/expire.c</span>
<span class="p_chunk">@@ -417,6 +417,7 @@</span> <span class="p_context"> static struct dentry *should_expire(struct dentry *dentry,</span>
 	}
 	return NULL;
 }
<span class="p_add">+</span>
 /*
  * Find an eligible tree to time-out
  * A tree is eligible if :-
<span class="p_chunk">@@ -432,6 +433,7 @@</span> <span class="p_context"> struct dentry *autofs4_expire_indirect(struct super_block *sb,</span>
 	struct dentry *root = sb-&gt;s_root;
 	struct dentry *dentry;
 	struct dentry *expired;
<span class="p_add">+	struct dentry *found;</span>
 	struct autofs_info *ino;
 
 	if (!root)
<span class="p_chunk">@@ -442,31 +444,46 @@</span> <span class="p_context"> struct dentry *autofs4_expire_indirect(struct super_block *sb,</span>
 
 	dentry = NULL;
 	while ((dentry = get_next_positive_subdir(dentry, root))) {
<span class="p_add">+		int flags = how;</span>
<span class="p_add">+</span>
 		spin_lock(&amp;sbi-&gt;fs_lock);
 		ino = autofs4_dentry_ino(dentry);
<span class="p_del">-		if (ino-&gt;flags &amp; AUTOFS_INF_WANT_EXPIRE)</span>
<span class="p_del">-			expired = NULL;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			expired = should_expire(dentry, mnt, timeout, how);</span>
<span class="p_del">-		if (!expired) {</span>
<span class="p_add">+		if (ino-&gt;flags &amp; AUTOFS_INF_WANT_EXPIRE) {</span>
 			spin_unlock(&amp;sbi-&gt;fs_lock);
 			continue;
 		}
<span class="p_add">+		spin_unlock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		expired = should_expire(dentry, mnt, timeout, flags);</span>
<span class="p_add">+		if (!expired)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;sbi-&gt;fs_lock);</span>
 		ino = autofs4_dentry_ino(expired);
 		ino-&gt;flags |= AUTOFS_INF_WANT_EXPIRE;
 		spin_unlock(&amp;sbi-&gt;fs_lock);
 		synchronize_rcu();
<span class="p_del">-		spin_lock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_del">-		if (should_expire(expired, mnt, timeout, how)) {</span>
<span class="p_del">-			if (expired != dentry)</span>
<span class="p_del">-				dput(dentry);</span>
<span class="p_del">-			goto found;</span>
<span class="p_del">-		}</span>
 
<span class="p_add">+		/* Make sure a reference is not taken on found if</span>
<span class="p_add">+		 * things have changed.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		flags &amp;= ~AUTOFS_EXP_LEAVES;</span>
<span class="p_add">+		found = should_expire(expired, mnt, timeout, how);</span>
<span class="p_add">+		if (!found || found != expired)</span>
<span class="p_add">+			/* Something has changed, continue */</span>
<span class="p_add">+			goto next;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (expired != dentry)</span>
<span class="p_add">+			dput(dentry);</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_add">+		goto found;</span>
<span class="p_add">+next:</span>
<span class="p_add">+		spin_lock(&amp;sbi-&gt;fs_lock);</span>
 		ino-&gt;flags &amp;= ~AUTOFS_INF_WANT_EXPIRE;
<span class="p_add">+		spin_unlock(&amp;sbi-&gt;fs_lock);</span>
 		if (expired != dentry)
 			dput(expired);
<span class="p_del">-		spin_unlock(&amp;sbi-&gt;fs_lock);</span>
 	}
 	return NULL;
 
<span class="p_chunk">@@ -483,6 +500,7 @@</span> <span class="p_context"> int autofs4_expire_wait(struct dentry *dentry, int rcu_walk)</span>
 	struct autofs_sb_info *sbi = autofs4_sbi(dentry-&gt;d_sb);
 	struct autofs_info *ino = autofs4_dentry_ino(dentry);
 	int status;
<span class="p_add">+	int state;</span>
 
 	/* Block on any pending expire */
 	if (!(ino-&gt;flags &amp; AUTOFS_INF_WANT_EXPIRE))
<span class="p_chunk">@@ -490,8 +508,19 @@</span> <span class="p_context"> int autofs4_expire_wait(struct dentry *dentry, int rcu_walk)</span>
 	if (rcu_walk)
 		return -ECHILD;
 
<span class="p_add">+retry:</span>
 	spin_lock(&amp;sbi-&gt;fs_lock);
<span class="p_del">-	if (ino-&gt;flags &amp; AUTOFS_INF_EXPIRING) {</span>
<span class="p_add">+	state = ino-&gt;flags &amp; (AUTOFS_INF_WANT_EXPIRE | AUTOFS_INF_EXPIRING);</span>
<span class="p_add">+	if (state == AUTOFS_INF_WANT_EXPIRE) {</span>
<span class="p_add">+		spin_unlock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Possibly being selected for expire, wait until</span>
<span class="p_add">+		 * it&#39;s selected or not.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		schedule_timeout_uninterruptible(HZ/10);</span>
<span class="p_add">+		goto retry;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (state &amp; AUTOFS_INF_EXPIRING) {</span>
 		spin_unlock(&amp;sbi-&gt;fs_lock);
 
 		pr_debug(&quot;waiting for expire %p name=%pd\n&quot;, dentry, dentry);
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 3722a1f65069..4ffcf0c27739 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -1634,6 +1634,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_transid(struct file *file,</span>
 	int namelen;
 	int ret = 0;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	ret = mnt_want_write_file(file);
 	if (ret)
 		goto out;
<span class="p_chunk">@@ -1691,6 +1694,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create(struct file *file,</span>
 	struct btrfs_ioctl_vol_args *vol_args;
 	int ret;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -1714,6 +1720,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_v2(struct file *file,</span>
 	bool readonly = false;
 	struct btrfs_qgroup_inherit *inherit = NULL;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -2358,6 +2367,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 	int ret;
 	int err = 0;
 
<span class="p_add">+	if (!S_ISDIR(dir-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_header">diff --git a/fs/ceph/file.c b/fs/ceph/file.c</span>
<span class="p_header">index 0daaf7ceedc5..b1b9b48a479d 100644</span>
<span class="p_header">--- a/fs/ceph/file.c</span>
<span class="p_header">+++ b/fs/ceph/file.c</span>
<span class="p_chunk">@@ -1448,16 +1448,14 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int whence)</span>
 {
 	struct inode *inode = file-&gt;f_mapping-&gt;host;
 	loff_t i_size;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	loff_t ret;</span>
 
 	inode_lock(inode);
 
 	if (whence == SEEK_END || whence == SEEK_DATA || whence == SEEK_HOLE) {
 		ret = ceph_do_getattr(inode, CEPH_STAT_CAP_SIZE, false);
<span class="p_del">-		if (ret &lt; 0) {</span>
<span class="p_del">-			offset = ret;</span>
<span class="p_add">+		if (ret &lt; 0)</span>
 			goto out;
<span class="p_del">-		}</span>
 	}
 
 	i_size = i_size_read(inode);
<span class="p_chunk">@@ -1473,7 +1471,7 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int whence)</span>
 		 * write() or lseek() might have altered it
 		 */
 		if (offset == 0) {
<span class="p_del">-			offset = file-&gt;f_pos;</span>
<span class="p_add">+			ret = file-&gt;f_pos;</span>
 			goto out;
 		}
 		offset += file-&gt;f_pos;
<span class="p_chunk">@@ -1493,11 +1491,11 @@</span> <span class="p_context"> static loff_t ceph_llseek(struct file *file, loff_t offset, int whence)</span>
 		break;
 	}
 
<span class="p_del">-	offset = vfs_setpos(file, offset, inode-&gt;i_sb-&gt;s_maxbytes);</span>
<span class="p_add">+	ret = vfs_setpos(file, offset, inode-&gt;i_sb-&gt;s_maxbytes);</span>
 
 out:
 	inode_unlock(inode);
<span class="p_del">-	return offset;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static inline void ceph_zero_partial_page(
<span class="p_header">diff --git a/fs/ceph/ioctl.c b/fs/ceph/ioctl.c</span>
<span class="p_header">index be6b1657b1af..0946f2d4a81f 100644</span>
<span class="p_header">--- a/fs/ceph/ioctl.c</span>
<span class="p_header">+++ b/fs/ceph/ioctl.c</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static long ceph_ioctl_get_dataloc(struct file *file, void __user *arg)</span>
 	struct ceph_osd_client *osdc =
 		&amp;ceph_sb_to_client(inode-&gt;i_sb)-&gt;client-&gt;osdc;
 	struct ceph_object_locator oloc;
<span class="p_del">-	struct ceph_object_id oid;</span>
<span class="p_add">+	CEPH_DEFINE_OID_ONSTACK(oid);</span>
 	u64 len = 1, olen;
 	u64 tmp;
 	struct ceph_pg pgid;
<span class="p_header">diff --git a/fs/configfs/file.c b/fs/configfs/file.c</span>
<span class="p_header">index bbc1252a59f5..2ddfa05d71f5 100644</span>
<span class="p_header">--- a/fs/configfs/file.c</span>
<span class="p_header">+++ b/fs/configfs/file.c</span>
<span class="p_chunk">@@ -333,6 +333,7 @@</span> <span class="p_context"> configfs_write_bin_file(struct file *file, const char __user *buf,</span>
 		if (bin_attr-&gt;cb_max_size &amp;&amp;
 			*ppos + count &gt; bin_attr-&gt;cb_max_size) {
 			len = -EFBIG;
<span class="p_add">+			goto out;</span>
 		}
 
 		tbuf = vmalloc(*ppos + count);
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 5c57654927a6..90e46cd752fe 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -959,10 +959,11 @@</span> <span class="p_context"> static int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)</span>
 
 	if (S_ISLNK(root_inode-&gt;i_mode)) {
 		char *name = follow_link(host_root_path);
<span class="p_del">-		if (IS_ERR(name))</span>
<span class="p_add">+		if (IS_ERR(name)) {</span>
 			err = PTR_ERR(name);
<span class="p_del">-		else</span>
<span class="p_del">-			err = read_name(root_inode, name);</span>
<span class="p_add">+			goto out_put;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = read_name(root_inode, name);</span>
 		kfree(name);
 		if (err)
 			goto out_put;
<span class="p_header">diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c</span>
<span class="p_header">index d2f97ecca6a5..e0e5f7c3c99f 100644</span>
<span class="p_header">--- a/fs/notify/fanotify/fanotify.c</span>
<span class="p_header">+++ b/fs/notify/fanotify/fanotify.c</span>
<span class="p_chunk">@@ -67,18 +67,7 @@</span> <span class="p_context"> static int fanotify_get_response(struct fsnotify_group *group,</span>
 
 	pr_debug(&quot;%s: group=%p event=%p\n&quot;, __func__, group, event);
 
<span class="p_del">-	wait_event(group-&gt;fanotify_data.access_waitq, event-&gt;response ||</span>
<span class="p_del">-				atomic_read(&amp;group-&gt;fanotify_data.bypass_perm));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!event-&gt;response) {	/* bypass_perm set */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Event was canceled because group is being destroyed. Remove</span>
<span class="p_del">-		 * it from group&#39;s event list because we are responsible for</span>
<span class="p_del">-		 * freeing the permission event.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		fsnotify_remove_event(group, &amp;event-&gt;fae.fse);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	wait_event(group-&gt;fanotify_data.access_waitq, event-&gt;response);</span>
 
 	/* userspace responded, convert to something usable */
 	switch (event-&gt;response) {
<span class="p_header">diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">index 8e8e6bcd1d43..a64313868d3a 100644</span>
<span class="p_header">--- a/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">+++ b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_chunk">@@ -358,16 +358,20 @@</span> <span class="p_context"> static int fanotify_release(struct inode *ignored, struct file *file)</span>
 
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 	struct fanotify_perm_event_info *event, *next;
<span class="p_add">+	struct fsnotify_event *fsn_event;</span>
 
 	/*
<span class="p_del">-	 * There may be still new events arriving in the notification queue</span>
<span class="p_del">-	 * but since userspace cannot use fanotify fd anymore, no event can</span>
<span class="p_del">-	 * enter or leave access_list by now.</span>
<span class="p_add">+	 * Stop new events from arriving in the notification queue. since</span>
<span class="p_add">+	 * userspace cannot use fanotify fd anymore, no event can enter or</span>
<span class="p_add">+	 * leave access_list by now either.</span>
 	 */
<span class="p_del">-	spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	atomic_inc(&amp;group-&gt;fanotify_data.bypass_perm);</span>
<span class="p_add">+	fsnotify_group_stop_queueing(group);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Process all permission events on access_list and notification queue</span>
<span class="p_add">+	 * and simulate reply from userspace.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
 	list_for_each_entry_safe(event, next, &amp;group-&gt;fanotify_data.access_list,
 				 fae.fse.list) {
 		pr_debug(&quot;%s: found group=%p event=%p\n&quot;, __func__, group,
<span class="p_chunk">@@ -379,12 +383,21 @@</span> <span class="p_context"> static int fanotify_release(struct inode *ignored, struct file *file)</span>
 	spin_unlock(&amp;group-&gt;fanotify_data.access_lock);
 
 	/*
<span class="p_del">-	 * Since bypass_perm is set, newly queued events will not wait for</span>
<span class="p_del">-	 * access response. Wake up the already sleeping ones now.</span>
<span class="p_del">-	 * synchronize_srcu() in fsnotify_destroy_group() will wait for all</span>
<span class="p_del">-	 * processes sleeping in fanotify_handle_event() waiting for access</span>
<span class="p_del">-	 * response and thus also for all permission events to be freed.</span>
<span class="p_add">+	 * Destroy all non-permission events. For permission events just</span>
<span class="p_add">+	 * dequeue them and set the response. They will be freed once the</span>
<span class="p_add">+	 * response is consumed and fanotify_get_response() returns.</span>
 	 */
<span class="p_add">+	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+	while (!fsnotify_notify_queue_is_empty(group)) {</span>
<span class="p_add">+		fsn_event = fsnotify_remove_first_event(group);</span>
<span class="p_add">+		if (!(fsn_event-&gt;mask &amp; FAN_ALL_PERM_EVENTS))</span>
<span class="p_add">+			fsnotify_destroy_event(group, fsn_event);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			FANOTIFY_PE(fsn_event)-&gt;response = FAN_ALLOW;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Response for all permission events it set, wakeup waiters */</span>
 	wake_up(&amp;group-&gt;fanotify_data.access_waitq);
 #endif
 
<span class="p_chunk">@@ -755,7 +768,6 @@</span> <span class="p_context"> SYSCALL_DEFINE2(fanotify_init, unsigned int, flags, unsigned int, event_f_flags)</span>
 	spin_lock_init(&amp;group-&gt;fanotify_data.access_lock);
 	init_waitqueue_head(&amp;group-&gt;fanotify_data.access_waitq);
 	INIT_LIST_HEAD(&amp;group-&gt;fanotify_data.access_list);
<span class="p_del">-	atomic_set(&amp;group-&gt;fanotify_data.bypass_perm, 0);</span>
 #endif
 	switch (flags &amp; FAN_ALL_CLASS_BITS) {
 	case FAN_CLASS_NOTIF:
<span class="p_header">diff --git a/fs/notify/group.c b/fs/notify/group.c</span>
<span class="p_header">index 3e2dd85be5dd..b47f7cfdcaa4 100644</span>
<span class="p_header">--- a/fs/notify/group.c</span>
<span class="p_header">+++ b/fs/notify/group.c</span>
<span class="p_chunk">@@ -40,6 +40,17 @@</span> <span class="p_context"> static void fsnotify_final_destroy_group(struct fsnotify_group *group)</span>
 }
 
 /*
<span class="p_add">+ * Stop queueing new events for this group. Once this function returns</span>
<span class="p_add">+ * fsnotify_add_event() will not add any new events to the group&#39;s queue.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void fsnotify_group_stop_queueing(struct fsnotify_group *group)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+	group-&gt;shutdown = true;</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Trying to get rid of a group. Remove all marks, flush all events and release
  * the group reference.
  * Note that another thread calling fsnotify_clear_marks_by_group() may still
<span class="p_chunk">@@ -47,6 +58,14 @@</span> <span class="p_context"> static void fsnotify_final_destroy_group(struct fsnotify_group *group)</span>
  */
 void fsnotify_destroy_group(struct fsnotify_group *group)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Stop queueing new events. The code below is careful enough to not</span>
<span class="p_add">+	 * require this but fanotify needs to stop queuing events even before</span>
<span class="p_add">+	 * fsnotify_destroy_group() is called and this makes the other callers</span>
<span class="p_add">+	 * of fsnotify_destroy_group() to see the same behavior.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fsnotify_group_stop_queueing(group);</span>
<span class="p_add">+</span>
 	/* clear all inode marks for this group, attach them to destroy_list */
 	fsnotify_detach_group_marks(group);
 
<span class="p_header">diff --git a/fs/notify/notification.c b/fs/notify/notification.c</span>
<span class="p_header">index a95d8e037aeb..e455e83ceeeb 100644</span>
<span class="p_header">--- a/fs/notify/notification.c</span>
<span class="p_header">+++ b/fs/notify/notification.c</span>
<span class="p_chunk">@@ -82,7 +82,8 @@</span> <span class="p_context"> void fsnotify_destroy_event(struct fsnotify_group *group,</span>
  * Add an event to the group notification queue.  The group can later pull this
  * event off the queue to deal with.  The function returns 0 if the event was
  * added to the queue, 1 if the event was merged with some other queued event,
<span class="p_del">- * 2 if the queue of events has overflown.</span>
<span class="p_add">+ * 2 if the event was not queued - either the queue of events has overflown</span>
<span class="p_add">+ * or the group is shutting down.</span>
  */
 int fsnotify_add_event(struct fsnotify_group *group,
 		       struct fsnotify_event *event,
<span class="p_chunk">@@ -96,6 +97,11 @@</span> <span class="p_context"> int fsnotify_add_event(struct fsnotify_group *group,</span>
 
 	mutex_lock(&amp;group-&gt;notification_mutex);
 
<span class="p_add">+	if (group-&gt;shutdown) {</span>
<span class="p_add">+		mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+		return 2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (group-&gt;q_len &gt;= group-&gt;max_events) {
 		ret = 2;
 		/* Queue overflow event only if it isn&#39;t already queued */
<span class="p_chunk">@@ -126,21 +132,6 @@</span> <span class="p_context"> queue:</span>
 }
 
 /*
<span class="p_del">- * Remove @event from group&#39;s notification queue. It is the responsibility of</span>
<span class="p_del">- * the caller to destroy the event.</span>
<span class="p_del">- */</span>
<span class="p_del">-void fsnotify_remove_event(struct fsnotify_group *group,</span>
<span class="p_del">-			   struct fsnotify_event *event)</span>
<span class="p_del">-{</span>
<span class="p_del">-	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_del">-	if (!list_empty(&amp;event-&gt;list)) {</span>
<span class="p_del">-		list_del_init(&amp;event-&gt;list);</span>
<span class="p_del">-		group-&gt;q_len--;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * Remove and return the first event from the notification list.  It is the
  * responsibility of the caller to destroy the obtained event
  */
<span class="p_header">diff --git a/fs/ocfs2/cluster/tcp_internal.h b/fs/ocfs2/cluster/tcp_internal.h</span>
<span class="p_header">index 94b18369b1cc..b95e7df5b76a 100644</span>
<span class="p_header">--- a/fs/ocfs2/cluster/tcp_internal.h</span>
<span class="p_header">+++ b/fs/ocfs2/cluster/tcp_internal.h</span>
<span class="p_chunk">@@ -44,9 +44,6 @@</span> <span class="p_context"></span>
  * version here in tcp_internal.h should not need to be bumped for
  * filesystem locking changes.
  *
<span class="p_del">- * New in version 12</span>
<span class="p_del">- *	- Negotiate hb timeout when storage is down.</span>
<span class="p_del">- *</span>
  * New in version 11
  * 	- Negotiation of filesystem locking in the dlm join.
  *
<span class="p_chunk">@@ -78,7 +75,7 @@</span> <span class="p_context"></span>
  * 	- full 64 bit i_size in the metadata lock lvbs
  * 	- introduction of &quot;rw&quot; lock and pushing meta/data locking down
  */
<span class="p_del">-#define O2NET_PROTOCOL_VERSION 12ULL</span>
<span class="p_add">+#define O2NET_PROTOCOL_VERSION 11ULL</span>
 struct o2net_handshake {
 	__be64	protocol_version;
 	__be64	connector_id;
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmconvert.c b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">index cdeafb4e7ed6..0bb128659d4b 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_chunk">@@ -268,7 +268,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 				  struct dlm_lock *lock, int flags, int type)
 {
 	enum dlm_status status;
<span class="p_del">-	u8 old_owner = res-&gt;owner;</span>
 
 	mlog(0, &quot;type=%d, convert_type=%d, busy=%d\n&quot;, lock-&gt;ml.type,
 	     lock-&gt;ml.convert_type, res-&gt;state &amp; DLM_LOCK_RES_IN_PROGRESS);
<span class="p_chunk">@@ -335,7 +334,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 
 	spin_lock(&amp;res-&gt;spinlock);
 	res-&gt;state &amp;= ~DLM_LOCK_RES_IN_PROGRESS;
<span class="p_del">-	lock-&gt;convert_pending = 0;</span>
 	/* if it failed, move it back to granted queue.
 	 * if master returns DLM_NORMAL and then down before sending ast,
 	 * it may have already been moved to granted queue, reset to
<span class="p_chunk">@@ -344,12 +342,14 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 		if (status != DLM_NOTQUEUED)
 			dlm_error(status);
 		dlm_revert_pending_convert(res, lock);
<span class="p_del">-	} else if ((res-&gt;state &amp; DLM_LOCK_RES_RECOVERING) ||</span>
<span class="p_del">-			(old_owner != res-&gt;owner)) {</span>
<span class="p_del">-		mlog(0, &quot;res %.*s is in recovering or has been recovered.\n&quot;,</span>
<span class="p_del">-				res-&gt;lockname.len, res-&gt;lockname.name);</span>
<span class="p_add">+	} else if (!lock-&gt;convert_pending) {</span>
<span class="p_add">+		mlog(0, &quot;%s: res %.*s, owner died and lock has been moved back &quot;</span>
<span class="p_add">+				&quot;to granted list, retry convert.\n&quot;,</span>
<span class="p_add">+				dlm-&gt;name, res-&gt;lockname.len, res-&gt;lockname.name);</span>
 		status = DLM_RECOVERING;
 	}
<span class="p_add">+</span>
<span class="p_add">+	lock-&gt;convert_pending = 0;</span>
 bail:
 	spin_unlock(&amp;res-&gt;spinlock);
 
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index 4e7b0dc22450..0b055bfb8e86 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -1506,7 +1506,8 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 				       u64 start, u64 len)
 {
 	int ret = 0;
<span class="p_del">-	u64 tmpend, end = start + len;</span>
<span class="p_add">+	u64 tmpend = 0;</span>
<span class="p_add">+	u64 end = start + len;</span>
 	struct ocfs2_super *osb = OCFS2_SB(inode-&gt;i_sb);
 	unsigned int csize = osb-&gt;s_clustersize;
 	handle_t *handle;
<span class="p_chunk">@@ -1538,18 +1539,31 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 	}
 
 	/*
<span class="p_del">-	 * We want to get the byte offset of the end of the 1st cluster.</span>
<span class="p_add">+	 * If start is on a cluster boundary and end is somewhere in another</span>
<span class="p_add">+	 * cluster, we have not COWed the cluster starting at start, unless</span>
<span class="p_add">+	 * end is also within the same cluster. So, in this case, we skip this</span>
<span class="p_add">+	 * first call to ocfs2_zero_range_for_truncate() truncate and move on</span>
<span class="p_add">+	 * to the next one.</span>
 	 */
<span class="p_del">-	tmpend = (u64)osb-&gt;s_clustersize + (start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_del">-	if (tmpend &gt; end)</span>
<span class="p_del">-		tmpend = end;</span>
<span class="p_add">+	if ((start &amp; (csize - 1)) != 0) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We want to get the byte offset of the end of the 1st</span>
<span class="p_add">+		 * cluster.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmpend = (u64)osb-&gt;s_clustersize +</span>
<span class="p_add">+			(start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_add">+		if (tmpend &gt; end)</span>
<span class="p_add">+			tmpend = end;</span>
 
<span class="p_del">-	trace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,</span>
<span class="p_del">-						 (unsigned long long)tmpend);</span>
<span class="p_add">+		trace_ocfs2_zero_partial_clusters_range1(</span>
<span class="p_add">+			(unsigned long long)start,</span>
<span class="p_add">+			(unsigned long long)tmpend);</span>
 
<span class="p_del">-	ret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		mlog_errno(ret);</span>
<span class="p_add">+		ret = ocfs2_zero_range_for_truncate(inode, handle, start,</span>
<span class="p_add">+						    tmpend);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			mlog_errno(ret);</span>
<span class="p_add">+	}</span>
 
 	if (tmpend &lt; end) {
 		/*
<span class="p_header">diff --git a/fs/reiserfs/ibalance.c b/fs/reiserfs/ibalance.c</span>
<span class="p_header">index b751eea32e20..5db6f45b3fed 100644</span>
<span class="p_header">--- a/fs/reiserfs/ibalance.c</span>
<span class="p_header">+++ b/fs/reiserfs/ibalance.c</span>
<span class="p_chunk">@@ -1153,8 +1153,9 @@</span> <span class="p_context"> int balance_internal(struct tree_balance *tb,</span>
 				       insert_ptr);
 	}
 
<span class="p_del">-	memcpy(new_insert_key_addr, &amp;new_insert_key, KEY_SIZE);</span>
 	insert_ptr[0] = new_insert_ptr;
<span class="p_add">+	if (new_insert_ptr)</span>
<span class="p_add">+		memcpy(new_insert_key_addr, &amp;new_insert_key, KEY_SIZE);</span>
 
 	return order;
 }
<span class="p_header">diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c</span>
<span class="p_header">index e71cfbd5acb3..41c20b66d4eb 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_buf.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_buf.c</span>
<span class="p_chunk">@@ -1531,7 +1531,7 @@</span> <span class="p_context"> xfs_wait_buftarg(</span>
 	 * ensure here that all reference counts have been dropped before we
 	 * start walking the LRU list.
 	 */
<span class="p_del">-	drain_workqueue(btp-&gt;bt_mount-&gt;m_buf_workqueue);</span>
<span class="p_add">+	flush_workqueue(btp-&gt;bt_mount-&gt;m_buf_workqueue);</span>
 
 	/* loop until there is nothing left on the lru list. */
 	while (list_lru_count(&amp;btp-&gt;bt_lru)) {
<span class="p_header">diff --git a/include/linux/ceph/libceph.h b/include/linux/ceph/libceph.h</span>
<span class="p_header">index 690985daad1c..6b79a6ba39ca 100644</span>
<span class="p_header">--- a/include/linux/ceph/libceph.h</span>
<span class="p_header">+++ b/include/linux/ceph/libceph.h</span>
<span class="p_chunk">@@ -214,8 +214,9 @@</span> <span class="p_context"> static void erase_##name(struct rb_root *root, type *t)			\</span>
 }
 
 #define DEFINE_RB_LOOKUP_FUNC(name, type, keyfld, nodefld)		\
<span class="p_add">+extern type __lookup_##name##_key;					\</span>
 static type *lookup_##name(struct rb_root *root,			\
<span class="p_del">-			   typeof(((type *)0)-&gt;keyfld) key)		\</span>
<span class="p_add">+			   typeof(__lookup_##name##_key.keyfld) key)	\</span>
 {									\
 	struct rb_node *n = root-&gt;rb_node;				\
 									\
<span class="p_header">diff --git a/include/linux/ceph/osdmap.h b/include/linux/ceph/osdmap.h</span>
<span class="p_header">index 9ccf4dbe55f8..21d7f048959f 100644</span>
<span class="p_header">--- a/include/linux/ceph/osdmap.h</span>
<span class="p_header">+++ b/include/linux/ceph/osdmap.h</span>
<span class="p_chunk">@@ -115,6 +115,11 @@</span> <span class="p_context"> static inline void ceph_oid_init(struct ceph_object_id *oid)</span>
 	oid-&gt;name_len = 0;
 }
 
<span class="p_add">+#define CEPH_OID_INIT_ONSTACK(oid)					\</span>
<span class="p_add">+    ({ ceph_oid_init(&amp;oid); oid; })</span>
<span class="p_add">+#define CEPH_DEFINE_OID_ONSTACK(oid)					\</span>
<span class="p_add">+	struct ceph_object_id oid = CEPH_OID_INIT_ONSTACK(oid)</span>
<span class="p_add">+</span>
 static inline bool ceph_oid_empty(const struct ceph_object_id *oid)
 {
 	return oid-&gt;name == oid-&gt;inline_name &amp;&amp; !oid-&gt;name_len;
<span class="p_header">diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h</span>
<span class="p_header">index 29f917517299..16af670a98ec 100644</span>
<span class="p_header">--- a/include/linux/fsnotify_backend.h</span>
<span class="p_header">+++ b/include/linux/fsnotify_backend.h</span>
<span class="p_chunk">@@ -148,6 +148,7 @@</span> <span class="p_context"> struct fsnotify_group {</span>
 	#define FS_PRIO_1	1 /* fanotify content based access control */
 	#define FS_PRIO_2	2 /* fanotify pre-content access */
 	unsigned int priority;
<span class="p_add">+	bool shutdown;		/* group is being shut down, don&#39;t queue more events */</span>
 
 	/* stores all fastpath marks assoc with this group so they can be cleaned on unregister */
 	struct mutex mark_mutex;	/* protect marks_list */
<span class="p_chunk">@@ -179,7 +180,6 @@</span> <span class="p_context"> struct fsnotify_group {</span>
 			spinlock_t access_lock;
 			struct list_head access_list;
 			wait_queue_head_t access_waitq;
<span class="p_del">-			atomic_t bypass_perm;</span>
 #endif /* CONFIG_FANOTIFY_ACCESS_PERMISSIONS */
 			int f_flags;
 			unsigned int max_marks;
<span class="p_chunk">@@ -303,6 +303,8 @@</span> <span class="p_context"> extern struct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *op</span>
 extern void fsnotify_get_group(struct fsnotify_group *group);
 /* drop reference on a group from fsnotify_alloc_group */
 extern void fsnotify_put_group(struct fsnotify_group *group);
<span class="p_add">+/* group destruction begins, stop queuing new events */</span>
<span class="p_add">+extern void fsnotify_group_stop_queueing(struct fsnotify_group *group);</span>
 /* destroy group */
 extern void fsnotify_destroy_group(struct fsnotify_group *group);
 /* fasync handler function */
<span class="p_chunk">@@ -315,8 +317,6 @@</span> <span class="p_context"> extern int fsnotify_add_event(struct fsnotify_group *group,</span>
 			      struct fsnotify_event *event,
 			      int (*merge)(struct list_head *,
 					   struct fsnotify_event *));
<span class="p_del">-/* Remove passed event from groups notification queue */</span>
<span class="p_del">-extern void fsnotify_remove_event(struct fsnotify_group *group, struct fsnotify_event *event);</span>
 /* true if the group notification queue is empty */
 extern bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group);
 /* return, but do not dequeue the first event on the notification queue */
<span class="p_header">diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h</span>
<span class="p_header">index 97354102794d..1f94053b3964 100644</span>
<span class="p_header">--- a/include/linux/pagemap.h</span>
<span class="p_header">+++ b/include/linux/pagemap.h</span>
<span class="p_chunk">@@ -571,56 +571,56 @@</span> <span class="p_context"> static inline int fault_in_pages_readable(const char __user *uaddr, int size)</span>
  */
 static inline int fault_in_multipages_writeable(char __user *uaddr, int size)
 {
<span class="p_del">-	int ret = 0;</span>
 	char __user *end = uaddr + size - 1;
 
 	if (unlikely(size == 0))
<span class="p_del">-		return ret;</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_add">+	if (unlikely(uaddr &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
 	/*
 	 * Writing zeroes into userspace here is OK, because we know that if
 	 * the zero gets there, we&#39;ll be overwriting it.
 	 */
<span class="p_del">-	while (uaddr &lt;= end) {</span>
<span class="p_del">-		ret = __put_user(0, uaddr);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (unlikely(__put_user(0, uaddr) != 0))</span>
<span class="p_add">+			return -EFAULT;</span>
 		uaddr += PAGE_SIZE;
<span class="p_del">-	}</span>
<span class="p_add">+	} while (uaddr &lt;= end);</span>
 
 	/* Check whether the range spilled into the next page. */
 	if (((unsigned long)uaddr &amp; PAGE_MASK) ==
 			((unsigned long)end &amp; PAGE_MASK))
<span class="p_del">-		ret = __put_user(0, end);</span>
<span class="p_add">+		return __put_user(0, end);</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static inline int fault_in_multipages_readable(const char __user *uaddr,
 					       int size)
 {
 	volatile char c;
<span class="p_del">-	int ret = 0;</span>
 	const char __user *end = uaddr + size - 1;
 
 	if (unlikely(size == 0))
<span class="p_del">-		return ret;</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	while (uaddr &lt;= end) {</span>
<span class="p_del">-		ret = __get_user(c, uaddr);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+	if (unlikely(uaddr &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (unlikely(__get_user(c, uaddr) != 0))</span>
<span class="p_add">+			return -EFAULT;</span>
 		uaddr += PAGE_SIZE;
<span class="p_del">-	}</span>
<span class="p_add">+	} while (uaddr &lt;= end);</span>
 
 	/* Check whether the range spilled into the next page. */
 	if (((unsigned long)uaddr &amp; PAGE_MASK) ==
 			((unsigned long)end &amp; PAGE_MASK)) {
<span class="p_del">-		ret = __get_user(c, end);</span>
<span class="p_del">-		(void)c;</span>
<span class="p_add">+		return __get_user(c, end);</span>
 	}
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
<span class="p_header">diff --git a/include/linux/reset.h b/include/linux/reset.h</span>
<span class="p_header">index 45a4abeb6acb..5daff15722d3 100644</span>
<span class="p_header">--- a/include/linux/reset.h</span>
<span class="p_header">+++ b/include/linux/reset.h</span>
<span class="p_chunk">@@ -71,14 +71,14 @@</span> <span class="p_context"> static inline struct reset_control *__of_reset_control_get(</span>
 					struct device_node *node,
 					const char *id, int index, int shared)
 {
<span class="p_del">-	return ERR_PTR(-EINVAL);</span>
<span class="p_add">+	return ERR_PTR(-ENOTSUPP);</span>
 }
 
 static inline struct reset_control *__devm_reset_control_get(
 					struct device *dev,
 					const char *id, int index, int shared)
 {
<span class="p_del">-	return ERR_PTR(-EINVAL);</span>
<span class="p_add">+	return ERR_PTR(-ENOTSUPP);</span>
 }
 
 #endif /* CONFIG_RESET_CONTROLLER */
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index e0be49fc382f..129a7ca5f159 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -6240,6 +6240,12 @@</span> <span class="p_context"> void cgroup_sk_alloc(struct sock_cgroup_data *skcd)</span>
 	if (cgroup_sk_alloc_disabled)
 		return;
 
<span class="p_add">+	/* Socket clone path */</span>
<span class="p_add">+	if (skcd-&gt;val) {</span>
<span class="p_add">+		cgroup_get(sock_cgroup_ptr(skcd));</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rcu_read_lock();
 
 	while (true) {
<span class="p_header">diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c</span>
<span class="p_header">index fca9254280ee..2fc1177383a0 100644</span>
<span class="p_header">--- a/kernel/power/hibernate.c</span>
<span class="p_header">+++ b/kernel/power/hibernate.c</span>
<span class="p_chunk">@@ -299,12 +299,12 @@</span> <span class="p_context"> static int create_image(int platform_mode)</span>
 	save_processor_state();
 	trace_suspend_resume(TPS(&quot;machine_suspend&quot;), PM_EVENT_HIBERNATE, true);
 	error = swsusp_arch_suspend();
<span class="p_add">+	/* Restore control flow magically appears here */</span>
<span class="p_add">+	restore_processor_state();</span>
 	trace_suspend_resume(TPS(&quot;machine_suspend&quot;), PM_EVENT_HIBERNATE, false);
 	if (error)
 		printk(KERN_ERR &quot;PM: Error %d creating hibernation image\n&quot;,
 			error);
<span class="p_del">-	/* Restore control flow magically appears here */</span>
<span class="p_del">-	restore_processor_state();</span>
 	if (!in_suspend)
 		events_check_enabled = false;
 
<span class="p_header">diff --git a/kernel/power/snapshot.c b/kernel/power/snapshot.c</span>
<span class="p_header">index 3a970604308f..f155c62f1f2c 100644</span>
<span class="p_header">--- a/kernel/power/snapshot.c</span>
<span class="p_header">+++ b/kernel/power/snapshot.c</span>
<span class="p_chunk">@@ -765,9 +765,9 @@</span> <span class="p_context"> static bool memory_bm_pfn_present(struct memory_bitmap *bm, unsigned long pfn)</span>
  */
 static bool rtree_next_node(struct memory_bitmap *bm)
 {
<span class="p_del">-	bm-&gt;cur.node = list_entry(bm-&gt;cur.node-&gt;list.next,</span>
<span class="p_del">-				  struct rtree_node, list);</span>
<span class="p_del">-	if (&amp;bm-&gt;cur.node-&gt;list != &amp;bm-&gt;cur.zone-&gt;leaves) {</span>
<span class="p_add">+	if (!list_is_last(&amp;bm-&gt;cur.node-&gt;list, &amp;bm-&gt;cur.zone-&gt;leaves)) {</span>
<span class="p_add">+		bm-&gt;cur.node = list_entry(bm-&gt;cur.node-&gt;list.next,</span>
<span class="p_add">+					  struct rtree_node, list);</span>
 		bm-&gt;cur.node_pfn += BM_BITS_PER_BLOCK;
 		bm-&gt;cur.node_bit  = 0;
 		touch_softlockup_watchdog();
<span class="p_chunk">@@ -775,9 +775,9 @@</span> <span class="p_context"> static bool rtree_next_node(struct memory_bitmap *bm)</span>
 	}
 
 	/* No more nodes, goto next zone */
<span class="p_del">-	bm-&gt;cur.zone = list_entry(bm-&gt;cur.zone-&gt;list.next,</span>
<span class="p_add">+	if (!list_is_last(&amp;bm-&gt;cur.zone-&gt;list, &amp;bm-&gt;zones)) {</span>
<span class="p_add">+		bm-&gt;cur.zone = list_entry(bm-&gt;cur.zone-&gt;list.next,</span>
 				  struct mem_zone_bm_rtree, list);
<span class="p_del">-	if (&amp;bm-&gt;cur.zone-&gt;list != &amp;bm-&gt;zones) {</span>
 		bm-&gt;cur.node = list_entry(bm-&gt;cur.zone-&gt;leaves.next,
 					  struct rtree_node, list);
 		bm-&gt;cur.node_pfn = 0;
<span class="p_header">diff --git a/kernel/trace/Makefile b/kernel/trace/Makefile</span>
<span class="p_header">index 979e7bfbde7a..d0a1617b52b4 100644</span>
<span class="p_header">--- a/kernel/trace/Makefile</span>
<span class="p_header">+++ b/kernel/trace/Makefile</span>
<span class="p_chunk">@@ -1,4 +1,8 @@</span> <span class="p_context"></span>
 
<span class="p_add">+# We are fully aware of the dangers of __builtin_return_address()</span>
<span class="p_add">+FRAME_CFLAGS := $(call cc-disable-warning,frame-address)</span>
<span class="p_add">+KBUILD_CFLAGS += $(FRAME_CFLAGS)</span>
<span class="p_add">+</span>
 # Do not instrument the tracer itself:
 
 ifdef CONFIG_FUNCTION_TRACER
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 8a4bd6b68a0b..77eeab2776ef 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -4890,19 +4890,20 @@</span> <span class="p_context"> tracing_read_pipe(struct file *filp, char __user *ubuf,</span>
 	struct trace_iterator *iter = filp-&gt;private_data;
 	ssize_t sret;
 
<span class="p_del">-	/* return any leftover data */</span>
<span class="p_del">-	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_del">-	if (sret != -EBUSY)</span>
<span class="p_del">-		return sret;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_del">-</span>
 	/*
 	 * Avoid more than one consumer on a single file descriptor
 	 * This is just a matter of traces coherency, the ring buffer itself
 	 * is protected.
 	 */
 	mutex_lock(&amp;iter-&gt;mutex);
<span class="p_add">+</span>
<span class="p_add">+	/* return any leftover data */</span>
<span class="p_add">+	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_add">+	if (sret != -EBUSY)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_add">+</span>
 	if (iter-&gt;trace-&gt;read) {
 		sret = iter-&gt;trace-&gt;read(iter, filp, ubuf, cnt, ppos);
 		if (sret)
<span class="p_chunk">@@ -5929,9 +5930,6 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 		return -EBUSY;
 #endif
 
<span class="p_del">-	if (splice_grow_spd(pipe, &amp;spd))</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
 	if (*ppos &amp; (PAGE_SIZE - 1))
 		return -EINVAL;
 
<span class="p_chunk">@@ -5941,6 +5939,9 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 		len &amp;= PAGE_MASK;
 	}
 
<span class="p_add">+	if (splice_grow_spd(pipe, &amp;spd))</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
  again:
 	trace_access_lock(iter-&gt;cpu_file);
 	entries = ring_buffer_entries_cpu(iter-&gt;trace_buffer-&gt;buffer, iter-&gt;cpu_file);
<span class="p_chunk">@@ -5998,19 +5999,21 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 	/* did we read anything? */
 	if (!spd.nr_pages) {
 		if (ret)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out;</span>
 
<span class="p_add">+		ret = -EAGAIN;</span>
 		if ((file-&gt;f_flags &amp; O_NONBLOCK) || (flags &amp; SPLICE_F_NONBLOCK))
<span class="p_del">-			return -EAGAIN;</span>
<span class="p_add">+			goto out;</span>
 
 		ret = wait_on_pipe(iter, true);
 		if (ret)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out;</span>
 
 		goto again;
 	}
 
 	ret = splice_to_pipe(pipe, &amp;spd);
<span class="p_add">+out:</span>
 	splice_shrink_spd(&amp;spd);
 
 	return ret;
<span class="p_header">diff --git a/mm/kasan/kasan.c b/mm/kasan/kasan.c</span>
<span class="p_header">index 6845f9294696..50e92c585407 100644</span>
<span class="p_header">--- a/mm/kasan/kasan.c</span>
<span class="p_header">+++ b/mm/kasan/kasan.c</span>
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> void kasan_kmalloc(struct kmem_cache *cache, const void *object, size_t size,</span>
 	unsigned long redzone_start;
 	unsigned long redzone_end;
 
<span class="p_del">-	if (flags &amp; __GFP_RECLAIM)</span>
<span class="p_add">+	if (gfpflags_allow_blocking(flags))</span>
 		quarantine_reduce();
 
 	if (unlikely(object == NULL))
<span class="p_chunk">@@ -595,7 +595,7 @@</span> <span class="p_context"> void kasan_kmalloc_large(const void *ptr, size_t size, gfp_t flags)</span>
 	unsigned long redzone_start;
 	unsigned long redzone_end;
 
<span class="p_del">-	if (flags &amp; __GFP_RECLAIM)</span>
<span class="p_add">+	if (gfpflags_allow_blocking(flags))</span>
 		quarantine_reduce();
 
 	if (unlikely(ptr == NULL))
<span class="p_header">diff --git a/mm/kasan/quarantine.c b/mm/kasan/quarantine.c</span>
<span class="p_header">index 65793f150d1f..a04887c624ed 100644</span>
<span class="p_header">--- a/mm/kasan/quarantine.c</span>
<span class="p_header">+++ b/mm/kasan/quarantine.c</span>
<span class="p_chunk">@@ -196,7 +196,7 @@</span> <span class="p_context"> void quarantine_put(struct kasan_free_meta *info, struct kmem_cache *cache)</span>
 
 void quarantine_reduce(void)
 {
<span class="p_del">-	size_t new_quarantine_size;</span>
<span class="p_add">+	size_t new_quarantine_size, percpu_quarantines;</span>
 	unsigned long flags;
 	struct qlist_head to_free = QLIST_INIT;
 	size_t size_to_free = 0;
<span class="p_chunk">@@ -214,7 +214,12 @@</span> <span class="p_context"> void quarantine_reduce(void)</span>
 	 */
 	new_quarantine_size = (READ_ONCE(totalram_pages) &lt;&lt; PAGE_SHIFT) /
 		QUARANTINE_FRACTION;
<span class="p_del">-	new_quarantine_size -= QUARANTINE_PERCPU_SIZE * num_online_cpus();</span>
<span class="p_add">+	percpu_quarantines = QUARANTINE_PERCPU_SIZE * num_online_cpus();</span>
<span class="p_add">+	if (WARN_ONCE(new_quarantine_size &lt; percpu_quarantines,</span>
<span class="p_add">+		&quot;Too little memory, disabling global KASAN quarantine.\n&quot;))</span>
<span class="p_add">+		new_quarantine_size = 0;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		new_quarantine_size -= percpu_quarantines;</span>
 	WRITE_ONCE(quarantine_size, new_quarantine_size);
 
 	last = global_quarantine.head;
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index ca847d96a980..fcb5b8cb43fe 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -1797,17 +1797,22 @@</span> <span class="p_context"> static DEFINE_MUTEX(percpu_charge_mutex);</span>
 static bool consume_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 {
 	struct memcg_stock_pcp *stock;
<span class="p_add">+	unsigned long flags;</span>
 	bool ret = false;
 
 	if (nr_pages &gt; CHARGE_BATCH)
 		return ret;
 
<span class="p_del">-	stock = &amp;get_cpu_var(memcg_stock);</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	stock = this_cpu_ptr(&amp;memcg_stock);</span>
 	if (memcg == stock-&gt;cached &amp;&amp; stock-&gt;nr_pages &gt;= nr_pages) {
 		stock-&gt;nr_pages -= nr_pages;
 		ret = true;
 	}
<span class="p_del">-	put_cpu_var(memcg_stock);</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1828,15 +1833,18 @@</span> <span class="p_context"> static void drain_stock(struct memcg_stock_pcp *stock)</span>
 	stock-&gt;cached = NULL;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * This must be called under preempt disabled or must be called by</span>
<span class="p_del">- * a thread which is pinned to local cpu.</span>
<span class="p_del">- */</span>
 static void drain_local_stock(struct work_struct *dummy)
 {
<span class="p_del">-	struct memcg_stock_pcp *stock = this_cpu_ptr(&amp;memcg_stock);</span>
<span class="p_add">+	struct memcg_stock_pcp *stock;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	stock = this_cpu_ptr(&amp;memcg_stock);</span>
 	drain_stock(stock);
 	clear_bit(FLUSHING_CACHED_CHARGE, &amp;stock-&gt;flags);
<span class="p_add">+</span>
<span class="p_add">+	local_irq_restore(flags);</span>
 }
 
 /*
<span class="p_chunk">@@ -1845,14 +1853,19 @@</span> <span class="p_context"> static void drain_local_stock(struct work_struct *dummy)</span>
  */
 static void refill_stock(struct mem_cgroup *memcg, unsigned int nr_pages)
 {
<span class="p_del">-	struct memcg_stock_pcp *stock = &amp;get_cpu_var(memcg_stock);</span>
<span class="p_add">+	struct memcg_stock_pcp *stock;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
 
<span class="p_add">+	stock = this_cpu_ptr(&amp;memcg_stock);</span>
 	if (stock-&gt;cached != memcg) { /* reset if necessary */
 		drain_stock(stock);
 		stock-&gt;cached = memcg;
 	}
 	stock-&gt;nr_pages += nr_pages;
<span class="p_del">-	put_cpu_var(memcg_stock);</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_restore(flags);</span>
 }
 
 /*
<span class="p_header">diff --git a/mm/page_io.c b/mm/page_io.c</span>
<span class="p_header">index 242dba07545b..dc1af1e63221 100644</span>
<span class="p_header">--- a/mm/page_io.c</span>
<span class="p_header">+++ b/mm/page_io.c</span>
<span class="p_chunk">@@ -262,6 +262,7 @@</span> <span class="p_context"> int __swap_writepage(struct page *page, struct writeback_control *wbc,</span>
 	int ret, rw = WRITE;
 	struct swap_info_struct *sis = page_swap_info(page);
 
<span class="p_add">+	BUG_ON(!PageSwapCache(page));</span>
 	if (sis-&gt;flags &amp; SWP_FILE) {
 		struct kiocb kiocb;
 		struct file *swap_file = sis-&gt;swap_file;
<span class="p_chunk">@@ -333,6 +334,7 @@</span> <span class="p_context"> int swap_readpage(struct page *page)</span>
 	int ret = 0;
 	struct swap_info_struct *sis = page_swap_info(page);
 
<span class="p_add">+	BUG_ON(!PageSwapCache(page));</span>
 	VM_BUG_ON_PAGE(!PageLocked(page), page);
 	VM_BUG_ON_PAGE(PageUptodate(page), page);
 	if (frontswap_load(page) == 0) {
<span class="p_chunk">@@ -381,6 +383,7 @@</span> <span class="p_context"> int swap_set_page_dirty(struct page *page)</span>
 
 	if (sis-&gt;flags &amp; SWP_FILE) {
 		struct address_space *mapping = sis-&gt;swap_file-&gt;f_mapping;
<span class="p_add">+		BUG_ON(!PageSwapCache(page));</span>
 		return mapping-&gt;a_ops-&gt;set_page_dirty(page);
 	} else {
 		return __set_page_dirty_no_writeback(page);
<span class="p_header">diff --git a/mm/swapfile.c b/mm/swapfile.c</span>
<span class="p_header">index 031713ab40ce..46502f551ac4 100644</span>
<span class="p_header">--- a/mm/swapfile.c</span>
<span class="p_header">+++ b/mm/swapfile.c</span>
<span class="p_chunk">@@ -2724,7 +2724,6 @@</span> <span class="p_context"> int swapcache_prepare(swp_entry_t entry)</span>
 struct swap_info_struct *page_swap_info(struct page *page)
 {
 	swp_entry_t swap = { .val = page_private(page) };
<span class="p_del">-	BUG_ON(!PageSwapCache(page));</span>
 	return swap_info[swp_type(swap)];
 }
 
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index c4a2f4512fca..38a2691a6367 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -2150,23 +2150,6 @@</span> <span class="p_context"> out:</span>
 	}
 }
 
<span class="p_del">-#ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span>
<span class="p_del">-static void init_tlb_ubc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This deliberately does not clear the cpumask as it&#39;s expensive</span>
<span class="p_del">-	 * and unnecessary. If there happens to be data in there then the</span>
<span class="p_del">-	 * first SWAP_CLUSTER_MAX pages will send an unnecessary IPI and</span>
<span class="p_del">-	 * then will be cleared.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	current-&gt;tlb_ubc.flush_required = false;</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline void init_tlb_ubc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif /* CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH */</span>
<span class="p_del">-</span>
 /*
  * This is a basic per-zone page freer.  Used by both kswapd and direct reclaim.
  */
<span class="p_chunk">@@ -2202,8 +2185,6 @@</span> <span class="p_context"> static void shrink_zone_memcg(struct zone *zone, struct mem_cgroup *memcg,</span>
 	scan_adjusted = (global_reclaim(sc) &amp;&amp; !current_is_kswapd() &amp;&amp;
 			 sc-&gt;priority == DEF_PRIORITY);
 
<span class="p_del">-	init_tlb_ubc();</span>
<span class="p_del">-</span>
 	blk_start_plug(&amp;plug);
 	while (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||
 					nr[LRU_INACTIVE_FILE]) {
<span class="p_header">diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c</span>
<span class="p_header">index 89469592076c..aee117f831c6 100644</span>
<span class="p_header">--- a/net/ceph/osd_client.c</span>
<span class="p_header">+++ b/net/ceph/osd_client.c</span>
<span class="p_chunk">@@ -4187,7 +4187,7 @@</span> <span class="p_context"> static struct ceph_msg *alloc_msg_with_page_vector(struct ceph_msg_header *hdr)</span>
 
 		pages = ceph_alloc_page_vector(calc_pages_for(0, data_len),
 					       GFP_NOIO);
<span class="p_del">-		if (!pages) {</span>
<span class="p_add">+		if (IS_ERR(pages)) {</span>
 			ceph_msg_put(m);
 			return NULL;
 		}
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index 25dab8b60223..fd7b41edf1ce 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1362,7 +1362,6 @@</span> <span class="p_context"> static struct sock *sk_prot_alloc(struct proto *prot, gfp_t priority,</span>
 		if (!try_module_get(prot-&gt;owner))
 			goto out_free_sec;
 		sk_tx_queue_clear(sk);
<span class="p_del">-		cgroup_sk_alloc(&amp;sk-&gt;sk_cgrp_data);</span>
 	}
 
 	return sk;
<span class="p_chunk">@@ -1422,6 +1421,7 @@</span> <span class="p_context"> struct sock *sk_alloc(struct net *net, int family, gfp_t priority,</span>
 		sock_net_set(sk, net);
 		atomic_set(&amp;sk-&gt;sk_wmem_alloc, 1);
 
<span class="p_add">+		cgroup_sk_alloc(&amp;sk-&gt;sk_cgrp_data);</span>
 		sock_update_classid(&amp;sk-&gt;sk_cgrp_data);
 		sock_update_netprioidx(&amp;sk-&gt;sk_cgrp_data);
 	}
<span class="p_chunk">@@ -1566,6 +1566,9 @@</span> <span class="p_context"> struct sock *sk_clone_lock(const struct sock *sk, const gfp_t priority)</span>
 		newsk-&gt;sk_priority = 0;
 		newsk-&gt;sk_incoming_cpu = raw_smp_processor_id();
 		atomic64_set(&amp;newsk-&gt;sk_cookie, 0);
<span class="p_add">+</span>
<span class="p_add">+		cgroup_sk_alloc(&amp;newsk-&gt;sk_cgrp_data);</span>
<span class="p_add">+</span>
 		/*
 		 * Before updating sk_refcnt, we must commit prior changes to memory
 		 * (Documentation/RCU/rculist_nulls.txt for details)
<span class="p_header">diff --git a/net/mac80211/agg-rx.c b/net/mac80211/agg-rx.c</span>
<span class="p_header">index 3a8f881b22f1..0a7305a97918 100644</span>
<span class="p_header">--- a/net/mac80211/agg-rx.c</span>
<span class="p_header">+++ b/net/mac80211/agg-rx.c</span>
<span class="p_chunk">@@ -261,10 +261,16 @@</span> <span class="p_context"> void __ieee80211_start_rx_ba_session(struct sta_info *sta,</span>
 		.timeout = timeout,
 		.ssn = start_seq_num,
 	};
<span class="p_del">-</span>
 	int i, ret = -EOPNOTSUPP;
 	u16 status = WLAN_STATUS_REQUEST_DECLINED;
 
<span class="p_add">+	if (tid &gt;= IEEE80211_FIRST_TSPEC_TSID) {</span>
<span class="p_add">+		ht_dbg(sta-&gt;sdata,</span>
<span class="p_add">+		       &quot;STA %pM requests BA session on unsupported tid %d\n&quot;,</span>
<span class="p_add">+		       sta-&gt;sta.addr, tid);</span>
<span class="p_add">+		goto end_no_lock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!sta-&gt;sta.ht_cap.ht_supported) {
 		ht_dbg(sta-&gt;sdata,
 		       &quot;STA %pM erroneously requests BA session on tid %d w/o QoS\n&quot;,
<span class="p_header">diff --git a/net/mac80211/agg-tx.c b/net/mac80211/agg-tx.c</span>
<span class="p_header">index 42fa81031dfa..744ad1c0bc02 100644</span>
<span class="p_header">--- a/net/mac80211/agg-tx.c</span>
<span class="p_header">+++ b/net/mac80211/agg-tx.c</span>
<span class="p_chunk">@@ -580,6 +580,9 @@</span> <span class="p_context"> int ieee80211_start_tx_ba_session(struct ieee80211_sta *pubsta, u16 tid,</span>
 	    ieee80211_hw_check(&amp;local-&gt;hw, TX_AMPDU_SETUP_IN_HW))
 		return -EINVAL;
 
<span class="p_add">+	if (WARN_ON(tid &gt;= IEEE80211_FIRST_TSPEC_TSID))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	ht_dbg(sdata, &quot;Open BA session requested for %pM tid %u\n&quot;,
 	       pubsta-&gt;addr, tid);
 
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 7d72283901a3..7d38dd6971a8 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -6811,7 +6811,7 @@</span> <span class="p_context"> static int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)</span>
 
 		params.n_counter_offsets_presp = len / sizeof(u16);
 		if (rdev-&gt;wiphy.max_num_csa_counters &amp;&amp;
<span class="p_del">-		    (params.n_counter_offsets_beacon &gt;</span>
<span class="p_add">+		    (params.n_counter_offsets_presp &gt;</span>
 		     rdev-&gt;wiphy.max_num_csa_counters))
 			return -EINVAL;
 
<span class="p_header">diff --git a/scripts/Makefile.ubsan b/scripts/Makefile.ubsan</span>
<span class="p_header">index 77ce538268b5..8ab68679cfb5 100644</span>
<span class="p_header">--- a/scripts/Makefile.ubsan</span>
<span class="p_header">+++ b/scripts/Makefile.ubsan</span>
<span class="p_chunk">@@ -14,8 +14,4 @@</span> <span class="p_context"> ifdef CONFIG_UBSAN</span>
 ifdef CONFIG_UBSAN_ALIGNMENT
       CFLAGS_UBSAN += $(call cc-option, -fsanitize=alignment)
 endif
<span class="p_del">-</span>
<span class="p_del">-      # -fsanitize=* options makes GCC less smart than usual and</span>
<span class="p_del">-      # increase number of &#39;maybe-uninitialized false-positives</span>
<span class="p_del">-      CFLAGS_UBSAN += $(call cc-option, -Wno-maybe-uninitialized)</span>
 endif
<span class="p_header">diff --git a/scripts/package/builddeb b/scripts/package/builddeb</span>
<span class="p_header">index 86e56fef7473..202d6e7db859 100755</span>
<span class="p_header">--- a/scripts/package/builddeb</span>
<span class="p_header">+++ b/scripts/package/builddeb</span>
<span class="p_chunk">@@ -322,12 +322,12 @@</span> <span class="p_context"> fi</span>
 
 # Build kernel header package
 (cd $srctree; find . -name Makefile\* -o -name Kconfig\* -o -name \*.pl) &gt; &quot;$objtree/debian/hdrsrcfiles&quot;
<span class="p_del">-if grep -q &#39;^CONFIG_STACK_VALIDATION=y&#39; $KCONFIG_CONFIG ; then</span>
<span class="p_del">-	(cd $srctree; find tools/objtool -type f -executable) &gt;&gt; &quot;$objtree/debian/hdrsrcfiles&quot;</span>
<span class="p_del">-fi</span>
 (cd $srctree; find arch/*/include include scripts -type f) &gt;&gt; &quot;$objtree/debian/hdrsrcfiles&quot;
 (cd $srctree; find arch/$SRCARCH -name module.lds -o -name Kbuild.platforms -o -name Platform) &gt;&gt; &quot;$objtree/debian/hdrsrcfiles&quot;
 (cd $srctree; find $(find arch/$SRCARCH -name include -o -name scripts -type d) -type f) &gt;&gt; &quot;$objtree/debian/hdrsrcfiles&quot;
<span class="p_add">+if grep -q &#39;^CONFIG_STACK_VALIDATION=y&#39; $KCONFIG_CONFIG ; then</span>
<span class="p_add">+	(cd $objtree; find tools/objtool -type f -executable) &gt;&gt; &quot;$objtree/debian/hdrobjfiles&quot;</span>
<span class="p_add">+fi</span>
 (cd $objtree; find arch/$SRCARCH/include Module.symvers include scripts -type f) &gt;&gt; &quot;$objtree/debian/hdrobjfiles&quot;
 destdir=$kernel_headers_dir/usr/src/linux-headers-$version
 mkdir -p &quot;$destdir&quot;
<span class="p_header">diff --git a/security/keys/encrypted-keys/encrypted.c b/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_header">index 5adbfc32242f..17a06105ccb6 100644</span>
<span class="p_header">--- a/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_header">+++ b/security/keys/encrypted-keys/encrypted.c</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/scatterlist.h&gt;
 #include &lt;linux/ctype.h&gt;
<span class="p_add">+#include &lt;crypto/aes.h&gt;</span>
 #include &lt;crypto/hash.h&gt;
 #include &lt;crypto/sha.h&gt;
 #include &lt;crypto/skcipher.h&gt;
<span class="p_chunk">@@ -478,6 +479,7 @@</span> <span class="p_context"> static int derived_key_encrypt(struct encrypted_key_payload *epayload,</span>
 	struct crypto_skcipher *tfm;
 	struct skcipher_request *req;
 	unsigned int encrypted_datalen;
<span class="p_add">+	u8 iv[AES_BLOCK_SIZE];</span>
 	unsigned int padlen;
 	char pad[16];
 	int ret;
<span class="p_chunk">@@ -500,8 +502,8 @@</span> <span class="p_context"> static int derived_key_encrypt(struct encrypted_key_payload *epayload,</span>
 	sg_init_table(sg_out, 1);
 	sg_set_buf(sg_out, epayload-&gt;encrypted_data, encrypted_datalen);
 
<span class="p_del">-	skcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen,</span>
<span class="p_del">-				   epayload-&gt;iv);</span>
<span class="p_add">+	memcpy(iv, epayload-&gt;iv, sizeof(iv));</span>
<span class="p_add">+	skcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);</span>
 	ret = crypto_skcipher_encrypt(req);
 	tfm = crypto_skcipher_reqtfm(req);
 	skcipher_request_free(req);
<span class="p_chunk">@@ -581,6 +583,7 @@</span> <span class="p_context"> static int derived_key_decrypt(struct encrypted_key_payload *epayload,</span>
 	struct crypto_skcipher *tfm;
 	struct skcipher_request *req;
 	unsigned int encrypted_datalen;
<span class="p_add">+	u8 iv[AES_BLOCK_SIZE];</span>
 	char pad[16];
 	int ret;
 
<span class="p_chunk">@@ -599,8 +602,8 @@</span> <span class="p_context"> static int derived_key_decrypt(struct encrypted_key_payload *epayload,</span>
 		   epayload-&gt;decrypted_datalen);
 	sg_set_buf(&amp;sg_out[1], pad, sizeof pad);
 
<span class="p_del">-	skcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen,</span>
<span class="p_del">-				   epayload-&gt;iv);</span>
<span class="p_add">+	memcpy(iv, epayload-&gt;iv, sizeof(iv));</span>
<span class="p_add">+	skcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);</span>
 	ret = crypto_skcipher_decrypt(req);
 	tfm = crypto_skcipher_reqtfm(req);
 	skcipher_request_free(req);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



