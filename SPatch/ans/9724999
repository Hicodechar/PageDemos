
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3] x86/efi: Correct ident mapping of efi old_map when kalsr enabled - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3] x86/efi: Correct ident mapping of efi old_map when kalsr enabled</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=73061">Baoquan He</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 13, 2017, 3:56 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1494647799-20600-1-git-send-email-bhe@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9724999/mbox/"
   >mbox</a>
|
   <a href="/patch/9724999/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9724999/">/patch/9724999/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	F2069601E7 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 13 May 2017 03:57:07 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 88E8A2883D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 13 May 2017 03:57:07 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6A782288A8; Sat, 13 May 2017 03:57:07 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9D53E2883D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 13 May 2017 03:57:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751607AbdEMD4v (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 12 May 2017 23:56:51 -0400
Received: from mx1.redhat.com ([209.132.183.28]:58152 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1750884AbdEMD4t (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 12 May 2017 23:56:49 -0400
Received: from smtp.corp.redhat.com
	(int-mx06.intmail.prod.int.phx2.redhat.com [10.5.11.16])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id 8A99B4E4CB;
	Sat, 13 May 2017 03:56:48 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.3.2 mx1.redhat.com 8A99B4E4CB
Authentication-Results: ext-mx09.extmail.prod.ext.phx2.redhat.com;
	dmarc=none (p=none dis=none) header.from=redhat.com
Authentication-Results: ext-mx09.extmail.prod.ext.phx2.redhat.com;
	spf=pass smtp.mailfrom=bhe@redhat.com
DKIM-Filter: OpenDKIM Filter v2.11.0 mx1.redhat.com 8A99B4E4CB
Received: from x1.redhat.com (vpn1-5-35.pek2.redhat.com [10.72.5.35])
	by smtp.corp.redhat.com (Postfix) with ESMTP id BA70C5C890;
	Sat, 13 May 2017 03:56:41 +0000 (UTC)
From: Baoquan He &lt;bhe@redhat.com&gt;
To: linux-kernel@vger.kernel.org
Cc: bp@alien8.de, bhsharma@redhat.com, rja@hpe.com,
	Baoquan He &lt;bhe@redhat.com&gt;, Dave Young &lt;dyoung@redhat.com&gt;,
	Matt Fleming &lt;matt@codeblueprint.co.uk&gt;,
	Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;, Thomas Garnier &lt;thgarnie@google.com&gt;,
	Kees Cook &lt;keescook@chromium.org&gt;, x86@kernel.org,
	linux-efi@vger.kernel.org
Subject: [PATCH v3] x86/efi: Correct ident mapping of efi old_map when kalsr
	enabled
Date: Sat, 13 May 2017 11:56:39 +0800
Message-Id: &lt;1494647799-20600-1-git-send-email-bhe@redhat.com&gt;
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.16
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.38]);
	Sat, 13 May 2017 03:56:48 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - May 13, 2017, 3:56 a.m.</div>
<pre class="content">
For EFI with &#39;efi=old_map&#39; kernel option specified, Kernel will panic
when kaslr is enabled.

The back trace is:

BUG: unable to handle kernel paging request at 000000007febd57e
IP: 0x7febd57e
PGD 1025a067
PUD 0

Oops: 0010 [#1] SMP
[ ... ]
Call Trace:
 ? efi_call+0x58/0x90
 ? printk+0x58/0x6f
 efi_enter_virtual_mode+0x3c5/0x50d
 start_kernel+0x40f/0x4b8
 ? set_init_arg+0x55/0x55
 ? early_idt_handler_array+0x120/0x120
 x86_64_start_reservations+0x24/0x26
 x86_64_start_kernel+0x14c/0x16f
 start_cpu+0x14/0x14

The root cause is the ident mapping is not built correctly in old_map case.

For nokaslr kernel, PAGE_OFFSET is 0xffff880000000000 which is PGDIR_SIZE
aligned. We can borrow the pud table from direct mapping safely. Given a
physical address X, we have pud_index(X) == pud_index(__va(X)). However,
for kaslr kernel, PAGE_OFFSET is PUD_SIZE aligned. For a given physical
address X, pud_index(X) != pud_index(__va(X)). We can&#39;t only copy pgd entry
from direct mapping to build ident mapping, instead need copy pud entry
one by one from direct mapping.

Fix it.
<span class="signed-off-by">
Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Dave Young &lt;dyoung@redhat.com&gt;</span>
Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;
Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;
Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;
Cc: Ingo Molnar &lt;mingo@redhat.com&gt;
Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;
Cc: Thomas Garnier &lt;thgarnie@google.com&gt;
Cc: Kees Cook &lt;keescook@chromium.org&gt;
Cc: x86@kernel.org
Cc: linux-efi@vger.kernel.org
---
v2-&gt;v3:
    1. Rewrite code to copy pud entry one by one so that code can be understood
    better. Usually we only have less than 1TB or several TB memory, pud entry
    copy one by one won&#39;t impact efficiency.

    2. Adding p4d page table handling.

v1-&gt;v2:
    Change code and add description according to Thomas&#39;s suggestion as below:

    1. Add checking if pud table is allocated successfully. If not just break
    the for loop.

    2. Add code comment to explain how the 1:1 mapping is built in efi_call_phys_prolog

    3. Other minor change

 arch/x86/platform/efi/efi_64.c | 69 +++++++++++++++++++++++++++++++++++++-----
 1 file changed, 61 insertions(+), 8 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=43581">Dave Young</a> - May 17, 2017, 2:55 a.m.</div>
<pre class="content">
Hi, Baoquan

On 05/13/17 at 11:56am, Baoquan He wrote:
<span class="quote">&gt; For EFI with &#39;efi=old_map&#39; kernel option specified, Kernel will panic</span>
<span class="quote">&gt; when kaslr is enabled.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The back trace is:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; BUG: unable to handle kernel paging request at 000000007febd57e</span>
<span class="quote">&gt; IP: 0x7febd57e</span>
<span class="quote">&gt; PGD 1025a067</span>
<span class="quote">&gt; PUD 0</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Oops: 0010 [#1] SMP</span>
<span class="quote">&gt; [ ... ]</span>
<span class="quote">&gt; Call Trace:</span>
<span class="quote">&gt;  ? efi_call+0x58/0x90</span>
<span class="quote">&gt;  ? printk+0x58/0x6f</span>
<span class="quote">&gt;  efi_enter_virtual_mode+0x3c5/0x50d</span>
<span class="quote">&gt;  start_kernel+0x40f/0x4b8</span>
<span class="quote">&gt;  ? set_init_arg+0x55/0x55</span>
<span class="quote">&gt;  ? early_idt_handler_array+0x120/0x120</span>
<span class="quote">&gt;  x86_64_start_reservations+0x24/0x26</span>
<span class="quote">&gt;  x86_64_start_kernel+0x14c/0x16f</span>
<span class="quote">&gt;  start_cpu+0x14/0x14</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The root cause is the ident mapping is not built correctly in old_map case.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For nokaslr kernel, PAGE_OFFSET is 0xffff880000000000 which is PGDIR_SIZE</span>
<span class="quote">&gt; aligned. We can borrow the pud table from direct mapping safely. Given a</span>
<span class="quote">&gt; physical address X, we have pud_index(X) == pud_index(__va(X)). However,</span>
<span class="quote">&gt; for kaslr kernel, PAGE_OFFSET is PUD_SIZE aligned. For a given physical</span>
<span class="quote">&gt; address X, pud_index(X) != pud_index(__va(X)). We can&#39;t only copy pgd entry</span>
<span class="quote">&gt; from direct mapping to build ident mapping, instead need copy pud entry</span>
<span class="quote">&gt; one by one from direct mapping.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fix it.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Baoquan He &lt;bhe@redhat.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Dave Young &lt;dyoung@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Matt Fleming &lt;matt@codeblueprint.co.uk&gt;</span>
<span class="quote">&gt; Cc: Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;</span>
<span class="quote">&gt; Cc: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
<span class="quote">&gt; Cc: Ingo Molnar &lt;mingo@redhat.com&gt;</span>
<span class="quote">&gt; Cc: &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="quote">&gt; Cc: Thomas Garnier &lt;thgarnie@google.com&gt;</span>
<span class="quote">&gt; Cc: Kees Cook &lt;keescook@chromium.org&gt;</span>
<span class="quote">&gt; Cc: x86@kernel.org</span>
<span class="quote">&gt; Cc: linux-efi@vger.kernel.org</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; v2-&gt;v3:</span>
<span class="quote">&gt;     1. Rewrite code to copy pud entry one by one so that code can be understood</span>
<span class="quote">&gt;     better. Usually we only have less than 1TB or several TB memory, pud entry</span>
<span class="quote">&gt;     copy one by one won&#39;t impact efficiency.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     2. Adding p4d page table handling.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; v1-&gt;v2:</span>
<span class="quote">&gt;     Change code and add description according to Thomas&#39;s suggestion as below:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     1. Add checking if pud table is allocated successfully. If not just break</span>
<span class="quote">&gt;     the for loop.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     2. Add code comment to explain how the 1:1 mapping is built in efi_call_phys_prolog</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     3. Other minor change</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  arch/x86/platform/efi/efi_64.c | 69 +++++++++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt;  1 file changed, 61 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; index c488625..c9dffec 100644</span>
<span class="quote">&gt; --- a/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; +++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; @@ -71,11 +71,13 @@ static void __init early_code_mapping_set_exec(int executable)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	unsigned long vaddress;</span>
<span class="quote">&gt; -	pgd_t *save_pgd;</span>
<span class="quote">&gt; +	unsigned long vaddr, addr_pgd, addr_p4d, addr_pud;</span>
<span class="quote">&gt; +	pgd_t *save_pgd, *pgd_k, *pgd_efi;</span>
<span class="quote">&gt; +	p4d_t *p4d, *p4d_k, *p4d_efi;</span>
<span class="quote">&gt; +	pud_t *pud;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	int pgd;</span>
<span class="quote">&gt; -	int n_pgds;</span>
<span class="quote">&gt; +	int n_pgds, i, j;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt;  		save_pgd = (pgd_t *)read_cr3();</span>
<span class="quote">&gt; @@ -88,10 +90,44 @@ pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt;  	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);</span>
<span class="quote">&gt;  	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Build 1:1 ident mapping for old_map usage. It needs to be noticed</span>
<span class="quote">&gt; +	 * that PAGE_OFFSET is PGDIR_SIZE aligned with KASLR disabled, while</span>
<span class="quote">&gt; +	 * PUD_SIZE ALIGNED with KASLR enabled. So for a given physical</span>
<span class="quote">&gt; +	 * address X, the pud_index(X) != pud_index(__va(X)), we can only copy</span>
<span class="quote">&gt; +	 * pud entry of __va(X) to fill in pud entry of X to build 1:1 mapping</span>
<span class="quote">&gt; +	 * . Means here we can only reuse pmd table of direct mapping.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt;  	for (pgd = 0; pgd &lt; n_pgds; pgd++) {</span>
<span class="quote">&gt; -		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; -		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; -		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="quote">&gt; +		addr_pgd = (unsigned long)(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; +		vaddr = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; +		pgd_efi = pgd_offset_k(addr_pgd);</span>
<span class="quote">&gt; +		save_pgd[pgd] = *pgd_efi;</span>
<span class="quote">&gt; +		p4d =  p4d_alloc(&amp;init_mm, pgd_efi, addr_pgd);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (!p4d) {</span>
<span class="quote">&gt; +			pr_err(&quot;Failed to allocate p4d table \n&quot;);</span>
<span class="quote">&gt; +			goto out;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>

There is code style issue here and other for loop later..
<span class="quote">
&gt; +			addr_p4d = addr_pgd + i * P4D_SIZE;</span>
<span class="quote">&gt; +			p4d_efi = p4d + p4d_index(addr_p4d);</span>
<span class="quote">&gt; +			pud = pud_alloc(&amp;init_mm, p4d_efi, addr_p4d);</span>
<span class="quote">&gt; +			if (!pud) {</span>
<span class="quote">&gt; +				pr_err(&quot;Failed to allocate pud table \n&quot;);</span>
<span class="quote">&gt; +				goto out;</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +			for(j=0; j&lt;PTRS_PER_PUD; j++) {</span>
<span class="quote">&gt; +				addr_pud = addr_p4d + j * PUD_SIZE;</span>
<span class="quote">&gt; +				if (addr_pud &gt; (max_pfn &lt;&lt; PAGE_SHIFT))</span>
<span class="quote">&gt; +					break;</span>
<span class="quote">&gt; +				vaddr = (unsigned long)__va(addr_pud);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +				pgd_k = pgd_offset_k(vaddr);</span>
<span class="quote">&gt; +				p4d_k = p4d_offset(pgd_k, vaddr);</span>
<span class="quote">&gt; +				pud[j] = *pud_offset(p4d_k, vaddr);</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  out:</span>
<span class="quote">&gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; @@ -104,8 +140,11 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * After the lock is released, the original page table is restored.</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt; -	int pgd_idx;</span>
<span class="quote">&gt; +	int pgd_idx, i;</span>
<span class="quote">&gt;  	int nr_pgds;</span>
<span class="quote">&gt; +	pgd_t *pgd;</span>
<span class="quote">&gt; +        p4d_t *p4d;</span>
<span class="quote">&gt; +        pud_t *pud;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt;  		write_cr3((unsigned long)save_pgd);</span>
<span class="quote">&gt; @@ -115,9 +154,23 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="quote">&gt; +	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="quote">&gt; +		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
<span class="quote">&gt;  		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +		if (!(pgd_val(*pgd) &amp; _PAGE_PRESENT))</span>
<span class="quote">&gt; +			continue;</span>
<span class="quote">&gt; +		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>
<span class="quote">&gt; +			p4d = p4d_offset(pgd, pgd_idx * PGDIR_SIZE + i * P4D_SIZE);</span>
<span class="quote">&gt; +			if (!(p4d_val(*p4d) &amp; _PAGE_PRESENT))</span>
<span class="quote">&gt; +				continue;</span>
<span class="quote">&gt; +			pud = (pud_t*)p4d_page_vaddr(*p4d);</span>
<span class="quote">&gt; +			pud_free(&amp;init_mm, pud);</span>
<span class="quote">&gt; +                }</span>
<span class="quote">&gt; +		p4d = (p4d_t*)pgd_page_vaddr(*pgd);</span>
<span class="quote">&gt; +		p4d_free(&amp;init_mm, p4d);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	kfree(save_pgd);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.5.5</span>
<span class="quote">&gt; </span>

Thanks
Dave
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - May 17, 2017, 3:35 a.m.</div>
<pre class="content">
On 05/17/17 at 10:55am, Dave Young wrote:
<span class="quote">&gt; Hi, Baoquan</span>
<span class="quote">&gt; &gt;  arch/x86/platform/efi/efi_64.c | 69 +++++++++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt; &gt;  1 file changed, 61 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; index c488625..c9dffec 100644</span>
<span class="quote">&gt; &gt; --- a/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; +++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; @@ -71,11 +71,13 @@ static void __init early_code_mapping_set_exec(int executable)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; -	unsigned long vaddress;</span>
<span class="quote">&gt; &gt; -	pgd_t *save_pgd;</span>
<span class="quote">&gt; &gt; +	unsigned long vaddr, addr_pgd, addr_p4d, addr_pud;</span>
<span class="quote">&gt; &gt; +	pgd_t *save_pgd, *pgd_k, *pgd_efi;</span>
<span class="quote">&gt; &gt; +	p4d_t *p4d, *p4d_k, *p4d_efi;</span>
<span class="quote">&gt; &gt; +	pud_t *pud;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	int pgd;</span>
<span class="quote">&gt; &gt; -	int n_pgds;</span>
<span class="quote">&gt; &gt; +	int n_pgds, i, j;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt; &gt;  		save_pgd = (pgd_t *)read_cr3();</span>
<span class="quote">&gt; &gt; @@ -88,10 +90,44 @@ pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt; &gt;  	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);</span>
<span class="quote">&gt; &gt;  	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; +	 * Build 1:1 ident mapping for old_map usage. It needs to be noticed</span>
<span class="quote">&gt; &gt; +	 * that PAGE_OFFSET is PGDIR_SIZE aligned with KASLR disabled, while</span>
<span class="quote">&gt; &gt; +	 * PUD_SIZE ALIGNED with KASLR enabled. So for a given physical</span>
<span class="quote">&gt; &gt; +	 * address X, the pud_index(X) != pud_index(__va(X)), we can only copy</span>
<span class="quote">&gt; &gt; +	 * pud entry of __va(X) to fill in pud entry of X to build 1:1 mapping</span>
<span class="quote">&gt; &gt; +	 * . Means here we can only reuse pmd table of direct mapping.</span>
<span class="quote">&gt; &gt; +	 */</span>
<span class="quote">&gt; &gt;  	for (pgd = 0; pgd &lt; n_pgds; pgd++) {</span>
<span class="quote">&gt; &gt; -		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; -		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; -		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="quote">&gt; &gt; +		addr_pgd = (unsigned long)(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; +		vaddr = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; +		pgd_efi = pgd_offset_k(addr_pgd);</span>
<span class="quote">&gt; &gt; +		save_pgd[pgd] = *pgd_efi;</span>
<span class="quote">&gt; &gt; +		p4d =  p4d_alloc(&amp;init_mm, pgd_efi, addr_pgd);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		if (!p4d) {</span>
<span class="quote">&gt; &gt; +			pr_err(&quot;Failed to allocate p4d table \n&quot;);</span>
<span class="quote">&gt; &gt; +			goto out;</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There is code style issue here and other for loop later..</span>

Oops, I forget running scripts/checkpatch.pl to check patch. Will change
and post v4. May post with sgi v4 fix about the sgi uv mmioh region
issue, have discussed with HPE SGI developer about that.

Thanks for pointing it out!

Thanks
Baoquan
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +			addr_p4d = addr_pgd + i * P4D_SIZE;</span>
<span class="quote">&gt; &gt; +			p4d_efi = p4d + p4d_index(addr_p4d);</span>
<span class="quote">&gt; &gt; +			pud = pud_alloc(&amp;init_mm, p4d_efi, addr_p4d);</span>
<span class="quote">&gt; &gt; +			if (!pud) {</span>
<span class="quote">&gt; &gt; +				pr_err(&quot;Failed to allocate pud table \n&quot;);</span>
<span class="quote">&gt; &gt; +				goto out;</span>
<span class="quote">&gt; &gt; +			}</span>
<span class="quote">&gt; &gt; +			for(j=0; j&lt;PTRS_PER_PUD; j++) {</span>
<span class="quote">&gt; &gt; +				addr_pud = addr_p4d + j * PUD_SIZE;</span>
<span class="quote">&gt; &gt; +				if (addr_pud &gt; (max_pfn &lt;&lt; PAGE_SHIFT))</span>
<span class="quote">&gt; &gt; +					break;</span>
<span class="quote">&gt; &gt; +				vaddr = (unsigned long)__va(addr_pud);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +				pgd_k = pgd_offset_k(vaddr);</span>
<span class="quote">&gt; &gt; +				p4d_k = p4d_offset(pgd_k, vaddr);</span>
<span class="quote">&gt; &gt; +				pud[j] = *pud_offset(p4d_k, vaddr);</span>
<span class="quote">&gt; &gt; +			}</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  out:</span>
<span class="quote">&gt; &gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; &gt; @@ -104,8 +140,11 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt; &gt;  	/*</span>
<span class="quote">&gt; &gt;  	 * After the lock is released, the original page table is restored.</span>
<span class="quote">&gt; &gt;  	 */</span>
<span class="quote">&gt; &gt; -	int pgd_idx;</span>
<span class="quote">&gt; &gt; +	int pgd_idx, i;</span>
<span class="quote">&gt; &gt;  	int nr_pgds;</span>
<span class="quote">&gt; &gt; +	pgd_t *pgd;</span>
<span class="quote">&gt; &gt; +        p4d_t *p4d;</span>
<span class="quote">&gt; &gt; +        pud_t *pud;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt; &gt;  		write_cr3((unsigned long)save_pgd);</span>
<span class="quote">&gt; &gt; @@ -115,9 +154,23 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="quote">&gt; &gt; +	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="quote">&gt; &gt; +		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt;  		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +		if (!(pgd_val(*pgd) &amp; _PAGE_PRESENT))</span>
<span class="quote">&gt; &gt; +			continue;</span>
<span class="quote">&gt; &gt; +		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>
<span class="quote">&gt; &gt; +			p4d = p4d_offset(pgd, pgd_idx * PGDIR_SIZE + i * P4D_SIZE);</span>
<span class="quote">&gt; &gt; +			if (!(p4d_val(*p4d) &amp; _PAGE_PRESENT))</span>
<span class="quote">&gt; &gt; +				continue;</span>
<span class="quote">&gt; &gt; +			pud = (pud_t*)p4d_page_vaddr(*p4d);</span>
<span class="quote">&gt; &gt; +			pud_free(&amp;init_mm, pud);</span>
<span class="quote">&gt; &gt; +                }</span>
<span class="quote">&gt; &gt; +		p4d = (p4d_t*)pgd_page_vaddr(*pgd);</span>
<span class="quote">&gt; &gt; +		p4d_free(&amp;init_mm, p4d);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  	kfree(save_pgd);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; &gt; -- </span>
<span class="quote">&gt; &gt; 2.5.5</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks</span>
<span class="quote">&gt; Dave</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=73061">Baoquan He</a> - May 17, 2017, 3:39 a.m.</div>
<pre class="content">
On 05/17/17 at 11:35am, Baoquan He wrote:
<span class="quote">&gt; On 05/17/17 at 10:55am, Dave Young wrote:</span>
<span class="quote">&gt; &gt; Hi, Baoquan</span>
<span class="quote">&gt; &gt; &gt;  arch/x86/platform/efi/efi_64.c | 69 +++++++++++++++++++++++++++++++++++++-----</span>
<span class="quote">&gt; &gt; &gt;  1 file changed, 61 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; &gt; index c488625..c9dffec 100644</span>
<span class="quote">&gt; &gt; &gt; --- a/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; &gt; +++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="quote">&gt; &gt; &gt; @@ -71,11 +71,13 @@ static void __init early_code_mapping_set_exec(int executable)</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt; &gt; &gt;  {</span>
<span class="quote">&gt; &gt; &gt; -	unsigned long vaddress;</span>
<span class="quote">&gt; &gt; &gt; -	pgd_t *save_pgd;</span>
<span class="quote">&gt; &gt; &gt; +	unsigned long vaddr, addr_pgd, addr_p4d, addr_pud;</span>
<span class="quote">&gt; &gt; &gt; +	pgd_t *save_pgd, *pgd_k, *pgd_efi;</span>
<span class="quote">&gt; &gt; &gt; +	p4d_t *p4d, *p4d_k, *p4d_efi;</span>
<span class="quote">&gt; &gt; &gt; +	pud_t *pud;</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	int pgd;</span>
<span class="quote">&gt; &gt; &gt; -	int n_pgds;</span>
<span class="quote">&gt; &gt; &gt; +	int n_pgds, i, j;</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt; &gt; &gt;  		save_pgd = (pgd_t *)read_cr3();</span>
<span class="quote">&gt; &gt; &gt; @@ -88,10 +90,44 @@ pgd_t * __init efi_call_phys_prolog(void)</span>
<span class="quote">&gt; &gt; &gt;  	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; &gt;  	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; +	/*</span>
<span class="quote">&gt; &gt; &gt; +	 * Build 1:1 ident mapping for old_map usage. It needs to be noticed</span>
<span class="quote">&gt; &gt; &gt; +	 * that PAGE_OFFSET is PGDIR_SIZE aligned with KASLR disabled, while</span>
<span class="quote">&gt; &gt; &gt; +	 * PUD_SIZE ALIGNED with KASLR enabled. So for a given physical</span>
<span class="quote">&gt; &gt; &gt; +	 * address X, the pud_index(X) != pud_index(__va(X)), we can only copy</span>
<span class="quote">&gt; &gt; &gt; +	 * pud entry of __va(X) to fill in pud entry of X to build 1:1 mapping</span>
<span class="quote">&gt; &gt; &gt; +	 * . Means here we can only reuse pmd table of direct mapping.</span>
<span class="quote">&gt; &gt; &gt; +	 */</span>
<span class="quote">&gt; &gt; &gt;  	for (pgd = 0; pgd &lt; n_pgds; pgd++) {</span>
<span class="quote">&gt; &gt; &gt; -		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; &gt; -		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; &gt; -		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="quote">&gt; &gt; &gt; +		addr_pgd = (unsigned long)(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; &gt; +		vaddr = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; &gt; +		pgd_efi = pgd_offset_k(addr_pgd);</span>
<span class="quote">&gt; &gt; &gt; +		save_pgd[pgd] = *pgd_efi;</span>
<span class="quote">&gt; &gt; &gt; +		p4d =  p4d_alloc(&amp;init_mm, pgd_efi, addr_pgd);</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +		if (!p4d) {</span>
<span class="quote">&gt; &gt; &gt; +			pr_err(&quot;Failed to allocate p4d table \n&quot;);</span>
<span class="quote">&gt; &gt; &gt; +			goto out;</span>
<span class="quote">&gt; &gt; &gt; +		}</span>
<span class="quote">&gt; &gt; &gt; +		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; There is code style issue here and other for loop later..</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Oops, I forget running scripts/checkpatch.pl to check patch. Will change</span>
<span class="quote">&gt; and post v4. May post with sgi v4 fix about the sgi uv mmioh region</span>
			     ~~~~~~sgi uv
<span class="quote">&gt; issue, have discussed with HPE SGI developer about that.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks for pointing it out!</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks</span>
<span class="quote">&gt; Baoquan</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; +			addr_p4d = addr_pgd + i * P4D_SIZE;</span>
<span class="quote">&gt; &gt; &gt; +			p4d_efi = p4d + p4d_index(addr_p4d);</span>
<span class="quote">&gt; &gt; &gt; +			pud = pud_alloc(&amp;init_mm, p4d_efi, addr_p4d);</span>
<span class="quote">&gt; &gt; &gt; +			if (!pud) {</span>
<span class="quote">&gt; &gt; &gt; +				pr_err(&quot;Failed to allocate pud table \n&quot;);</span>
<span class="quote">&gt; &gt; &gt; +				goto out;</span>
<span class="quote">&gt; &gt; &gt; +			}</span>
<span class="quote">&gt; &gt; &gt; +			for(j=0; j&lt;PTRS_PER_PUD; j++) {</span>
<span class="quote">&gt; &gt; &gt; +				addr_pud = addr_p4d + j * PUD_SIZE;</span>
<span class="quote">&gt; &gt; &gt; +				if (addr_pud &gt; (max_pfn &lt;&lt; PAGE_SHIFT))</span>
<span class="quote">&gt; &gt; &gt; +					break;</span>
<span class="quote">&gt; &gt; &gt; +				vaddr = (unsigned long)__va(addr_pud);</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +				pgd_k = pgd_offset_k(vaddr);</span>
<span class="quote">&gt; &gt; &gt; +				p4d_k = p4d_offset(pgd_k, vaddr);</span>
<span class="quote">&gt; &gt; &gt; +				pud[j] = *pud_offset(p4d_k, vaddr);</span>
<span class="quote">&gt; &gt; &gt; +			}</span>
<span class="quote">&gt; &gt; &gt; +		}</span>
<span class="quote">&gt; &gt; &gt;  	}</span>
<span class="quote">&gt; &gt; &gt;  out:</span>
<span class="quote">&gt; &gt; &gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; &gt; &gt; @@ -104,8 +140,11 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt; &gt; &gt;  	/*</span>
<span class="quote">&gt; &gt; &gt;  	 * After the lock is released, the original page table is restored.</span>
<span class="quote">&gt; &gt; &gt;  	 */</span>
<span class="quote">&gt; &gt; &gt; -	int pgd_idx;</span>
<span class="quote">&gt; &gt; &gt; +	int pgd_idx, i;</span>
<span class="quote">&gt; &gt; &gt;  	int nr_pgds;</span>
<span class="quote">&gt; &gt; &gt; +	pgd_t *pgd;</span>
<span class="quote">&gt; &gt; &gt; +        p4d_t *p4d;</span>
<span class="quote">&gt; &gt; &gt; +        pud_t *pud;</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="quote">&gt; &gt; &gt;  		write_cr3((unsigned long)save_pgd);</span>
<span class="quote">&gt; &gt; &gt; @@ -115,9 +154,23 @@ void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; -	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="quote">&gt; &gt; &gt; +	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="quote">&gt; &gt; &gt; +		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
<span class="quote">&gt; &gt; &gt;  		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; +		if (!(pgd_val(*pgd) &amp; _PAGE_PRESENT))</span>
<span class="quote">&gt; &gt; &gt; +			continue;</span>
<span class="quote">&gt; &gt; &gt; +		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>
<span class="quote">&gt; &gt; &gt; +			p4d = p4d_offset(pgd, pgd_idx * PGDIR_SIZE + i * P4D_SIZE);</span>
<span class="quote">&gt; &gt; &gt; +			if (!(p4d_val(*p4d) &amp; _PAGE_PRESENT))</span>
<span class="quote">&gt; &gt; &gt; +				continue;</span>
<span class="quote">&gt; &gt; &gt; +			pud = (pud_t*)p4d_page_vaddr(*p4d);</span>
<span class="quote">&gt; &gt; &gt; +			pud_free(&amp;init_mm, pud);</span>
<span class="quote">&gt; &gt; &gt; +                }</span>
<span class="quote">&gt; &gt; &gt; +		p4d = (p4d_t*)pgd_page_vaddr(*pgd);</span>
<span class="quote">&gt; &gt; &gt; +		p4d_free(&amp;init_mm, p4d);</span>
<span class="quote">&gt; &gt; &gt; +	}</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt;  	kfree(save_pgd);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	__flush_tlb_all();</span>
<span class="quote">&gt; &gt; &gt; -- </span>
<span class="quote">&gt; &gt; &gt; 2.5.5</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Thanks</span>
<span class="quote">&gt; &gt; Dave</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index c488625..c9dffec 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -71,11 +71,13 @@</span> <span class="p_context"> static void __init early_code_mapping_set_exec(int executable)</span>
 
 pgd_t * __init efi_call_phys_prolog(void)
 {
<span class="p_del">-	unsigned long vaddress;</span>
<span class="p_del">-	pgd_t *save_pgd;</span>
<span class="p_add">+	unsigned long vaddr, addr_pgd, addr_p4d, addr_pud;</span>
<span class="p_add">+	pgd_t *save_pgd, *pgd_k, *pgd_efi;</span>
<span class="p_add">+	p4d_t *p4d, *p4d_k, *p4d_efi;</span>
<span class="p_add">+	pud_t *pud;</span>
 
 	int pgd;
<span class="p_del">-	int n_pgds;</span>
<span class="p_add">+	int n_pgds, i, j;</span>
 
 	if (!efi_enabled(EFI_OLD_MEMMAP)) {
 		save_pgd = (pgd_t *)read_cr3();
<span class="p_chunk">@@ -88,10 +90,44 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 	n_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT), PGDIR_SIZE);
 	save_pgd = kmalloc_array(n_pgds, sizeof(*save_pgd), GFP_KERNEL);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Build 1:1 ident mapping for old_map usage. It needs to be noticed</span>
<span class="p_add">+	 * that PAGE_OFFSET is PGDIR_SIZE aligned with KASLR disabled, while</span>
<span class="p_add">+	 * PUD_SIZE ALIGNED with KASLR enabled. So for a given physical</span>
<span class="p_add">+	 * address X, the pud_index(X) != pud_index(__va(X)), we can only copy</span>
<span class="p_add">+	 * pud entry of __va(X) to fill in pud entry of X to build 1:1 mapping</span>
<span class="p_add">+	 * . Means here we can only reuse pmd table of direct mapping.</span>
<span class="p_add">+	 */</span>
 	for (pgd = 0; pgd &lt; n_pgds; pgd++) {
<span class="p_del">-		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);</span>
<span class="p_del">-		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="p_del">-		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));</span>
<span class="p_add">+		addr_pgd = (unsigned long)(pgd * PGDIR_SIZE);</span>
<span class="p_add">+		vaddr = (unsigned long)__va(pgd * PGDIR_SIZE);</span>
<span class="p_add">+		pgd_efi = pgd_offset_k(addr_pgd);</span>
<span class="p_add">+		save_pgd[pgd] = *pgd_efi;</span>
<span class="p_add">+		p4d =  p4d_alloc(&amp;init_mm, pgd_efi, addr_pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!p4d) {</span>
<span class="p_add">+			pr_err(&quot;Failed to allocate p4d table \n&quot;);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>
<span class="p_add">+			addr_p4d = addr_pgd + i * P4D_SIZE;</span>
<span class="p_add">+			p4d_efi = p4d + p4d_index(addr_p4d);</span>
<span class="p_add">+			pud = pud_alloc(&amp;init_mm, p4d_efi, addr_p4d);</span>
<span class="p_add">+			if (!pud) {</span>
<span class="p_add">+				pr_err(&quot;Failed to allocate pud table \n&quot;);</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			for(j=0; j&lt;PTRS_PER_PUD; j++) {</span>
<span class="p_add">+				addr_pud = addr_p4d + j * PUD_SIZE;</span>
<span class="p_add">+				if (addr_pud &gt; (max_pfn &lt;&lt; PAGE_SHIFT))</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				vaddr = (unsigned long)__va(addr_pud);</span>
<span class="p_add">+</span>
<span class="p_add">+				pgd_k = pgd_offset_k(vaddr);</span>
<span class="p_add">+				p4d_k = p4d_offset(pgd_k, vaddr);</span>
<span class="p_add">+				pud[j] = *pud_offset(p4d_k, vaddr);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 out:
 	__flush_tlb_all();
<span class="p_chunk">@@ -104,8 +140,11 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	/*
 	 * After the lock is released, the original page table is restored.
 	 */
<span class="p_del">-	int pgd_idx;</span>
<span class="p_add">+	int pgd_idx, i;</span>
 	int nr_pgds;
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+        p4d_t *p4d;</span>
<span class="p_add">+        pud_t *pud;</span>
 
 	if (!efi_enabled(EFI_OLD_MEMMAP)) {
 		write_cr3((unsigned long)save_pgd);
<span class="p_chunk">@@ -115,9 +154,23 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 
 	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);
 
<span class="p_del">-	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++)</span>
<span class="p_add">+	for (pgd_idx = 0; pgd_idx &lt; nr_pgds; pgd_idx++) {</span>
<span class="p_add">+		pgd = pgd_offset_k(pgd_idx * PGDIR_SIZE);</span>
 		set_pgd(pgd_offset_k(pgd_idx * PGDIR_SIZE), save_pgd[pgd_idx]);
 
<span class="p_add">+		if (!(pgd_val(*pgd) &amp; _PAGE_PRESENT))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		for(i=0; i&lt;PTRS_PER_P4D; i++) {</span>
<span class="p_add">+			p4d = p4d_offset(pgd, pgd_idx * PGDIR_SIZE + i * P4D_SIZE);</span>
<span class="p_add">+			if (!(p4d_val(*p4d) &amp; _PAGE_PRESENT))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			pud = (pud_t*)p4d_page_vaddr(*p4d);</span>
<span class="p_add">+			pud_free(&amp;init_mm, pud);</span>
<span class="p_add">+                }</span>
<span class="p_add">+		p4d = (p4d_t*)pgd_page_vaddr(*pgd);</span>
<span class="p_add">+		p4d_free(&amp;init_mm, p4d);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(save_pgd);
 
 	__flush_tlb_all();

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



