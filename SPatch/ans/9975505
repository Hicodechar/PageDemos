
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.89 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.89</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 28, 2017, 8:31 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170928083108.GB10777@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9975505/mbox/"
   >mbox</a>
|
   <a href="/patch/9975505/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9975505/">/patch/9975505/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DB6616034B for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Sep 2017 08:31:26 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B37FA2933B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Sep 2017 08:31:26 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A614D29503; Thu, 28 Sep 2017 08:31:26 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 5E3712933B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 28 Sep 2017 08:31:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752595AbdI1IbU (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 28 Sep 2017 04:31:20 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:56208 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751816AbdI1IbM (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 28 Sep 2017 04:31:12 -0400
Received: from localhost (unknown [195.81.232.10])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 4CD468FF;
	Thu, 28 Sep 2017 08:31:11 +0000 (UTC)
Date: Thu, 28 Sep 2017 10:31:08 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.89
Message-ID: &lt;20170928083108.GB10777@kroah.com&gt;
References: &lt;20170928083103.GA10777@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170928083103.GA10777@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 28, 2017, 8:31 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 788d90a0051b..7e4c46b375b3 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 88</span>
<span class="p_add">+SUBLEVEL = 89</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arc/kernel/entry.S b/arch/arc/kernel/entry.S</span>
<span class="p_header">index 2efb0625331d..db1eee5fe502 100644</span>
<span class="p_header">--- a/arch/arc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arc/kernel/entry.S</span>
<span class="p_chunk">@@ -104,6 +104,12 @@</span> <span class="p_context"> ENTRY(EV_MachineCheck)</span>
 	lr  r0, [efa]
 	mov r1, sp
 
<span class="p_add">+	; hardware auto-disables MMU, re-enable it to allow kernel vaddr</span>
<span class="p_add">+	; access for say stack unwinding of modules for crash dumps</span>
<span class="p_add">+	lr	r3, [ARC_REG_PID]</span>
<span class="p_add">+	or	r3, r3, MMU_ENABLE</span>
<span class="p_add">+	sr	r3, [ARC_REG_PID]</span>
<span class="p_add">+</span>
 	lsr  	r3, r2, 8
 	bmsk 	r3, r3, 7
 	brne    r3, ECR_C_MCHK_DUP_TLB, 1f
<span class="p_header">diff --git a/arch/arc/mm/tlb.c b/arch/arc/mm/tlb.c</span>
<span class="p_header">index daf2bf52b984..97e9582dcf99 100644</span>
<span class="p_header">--- a/arch/arc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/arc/mm/tlb.c</span>
<span class="p_chunk">@@ -885,9 +885,6 @@</span> <span class="p_context"> void do_tlb_overlap_fault(unsigned long cause, unsigned long address,</span>
 
 	local_irq_save(flags);
 
<span class="p_del">-	/* re-enable the MMU */</span>
<span class="p_del">-	write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID));</span>
<span class="p_del">-</span>
 	/* loop thru all sets of TLB */
 	for (set = 0; set &lt; mmu-&gt;sets; set++) {
 
<span class="p_header">diff --git a/arch/mips/math-emu/dp_fmax.c b/arch/mips/math-emu/dp_fmax.c</span>
<span class="p_header">index fd71b8daaaf2..5bec64f2884e 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/dp_fmax.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/dp_fmax.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmax(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmax(union ieee754dp x, union ieee754dp y)</span>
 		return ys ? x : y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmax(union ieee754dp x, union ieee754dp y)</span>
 	else if (xs &lt; ys)
 		return x;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_add">+	/* Signs of inputs are equal, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return y;</span>
<span class="p_del">-	return x;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
 
 union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,6 +202,9 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754dp_inf(xs &amp; ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -171,7 +212,6 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
<span class="p_chunk">@@ -180,9 +220,7 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 		return y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmaxa(union ieee754dp x, union ieee754dp y)</span>
 		return y;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
 		return y;
<span class="p_del">-	return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xs == 0)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
<span class="p_header">diff --git a/arch/mips/math-emu/dp_fmin.c b/arch/mips/math-emu/dp_fmin.c</span>
<span class="p_header">index c1072b0dfb95..a287b23818d8 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/dp_fmin.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/dp_fmin.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmin(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmin(union ieee754dp x, union ieee754dp y)</span>
 		return ys ? y : x;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmin(union ieee754dp x, union ieee754dp y)</span>
 	else if (xs &lt; ys)
 		return y;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_add">+	/* Signs of inputs are the same, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return x;</span>
<span class="p_del">-	return y;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	return x;</span>
 }
 
 union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754dp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,25 +202,25 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754dp_inf(xs | ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
<span class="p_del">-		return x;</span>
<span class="p_add">+		return y;</span>
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_DNORM):
<span class="p_del">-		return y;</span>
<span class="p_add">+		return x;</span>
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754dp_zero(1);</span>
<span class="p_add">+		return ieee754dp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		DPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754dp ieee754dp_fmina(union ieee754dp x, union ieee754dp y)</span>
 		return x;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	else if (xs == 1)</span>
 		return x;
 	return y;
 }
<span class="p_header">diff --git a/arch/mips/math-emu/sp_fmax.c b/arch/mips/math-emu/sp_fmax.c</span>
<span class="p_header">index 4d000844e48e..74a5a00d2f22 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/sp_fmax.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/sp_fmax.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmax(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmax(union ieee754sp x, union ieee754sp y)</span>
 		return ys ? x : y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmax(union ieee754sp x, union ieee754sp y)</span>
 	else if (xs &lt; ys)
 		return x;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_add">+	/* Signs of inputs are equal, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return y;</span>
<span class="p_del">-	return x;</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
 
 union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,6 +202,9 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754sp_inf(xs &amp; ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -171,7 +212,6 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
<span class="p_chunk">@@ -180,9 +220,7 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 		return y;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs &amp; ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmaxa(union ieee754sp x, union ieee754sp y)</span>
 		return y;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
 		return y;
<span class="p_del">-	return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xs == 0)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	return y;</span>
 }
<span class="p_header">diff --git a/arch/mips/math-emu/sp_fmin.c b/arch/mips/math-emu/sp_fmin.c</span>
<span class="p_header">index 4eb1bb9e9dec..c51385f46b09 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/sp_fmin.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/sp_fmin.c</span>
<span class="p_chunk">@@ -47,14 +47,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmin(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -80,9 +92,7 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmin(union ieee754sp x, union ieee754sp y)</span>
 		return ys ? y : x;
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -106,16 +116,32 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmin(union ieee754sp x, union ieee754sp y)</span>
 	else if (xs &lt; ys)
 		return y;
 
<span class="p_del">-	/* Compare exponent */</span>
<span class="p_del">-	if (xe &gt; ye)</span>
<span class="p_del">-		return y;</span>
<span class="p_del">-	else if (xe &lt; ye)</span>
<span class="p_del">-		return x;</span>
<span class="p_add">+	/* Signs of inputs are the same, let&#39;s compare exponents */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Inputs are both negative */</span>
<span class="p_add">+		if (xe &gt; ye)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		else if (xe &lt; ye)</span>
<span class="p_add">+			return y;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Compare mantissa */</span>
<span class="p_add">+	/* Signs and exponents of inputs are equal, let&#39;s compare mantissas */</span>
<span class="p_add">+	if (xs == 0) {</span>
<span class="p_add">+		/* Inputs are both positive, with equal signs and exponents */</span>
<span class="p_add">+		if (xm &lt;= ym)</span>
<span class="p_add">+			return x;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Inputs are both negative, with equal signs and exponents */</span>
 	if (xm &lt;= ym)
<span class="p_del">-		return x;</span>
<span class="p_del">-	return y;</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	return x;</span>
 }
 
 union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)
<span class="p_chunk">@@ -147,14 +173,26 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)</span>
 	case CLPAIR(IEEE754_CLASS_SNAN, IEEE754_CLASS_INF):
 		return ieee754sp_nanxcpt(x);
 
<span class="p_del">-	/* numbers are preferred to NaNs */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Quiet NaN handling</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The case of both inputs quiet NaNs</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 *    The cases of exactly one input quiet NaN (numbers</span>
<span class="p_add">+	 *    are here preferred as returned values to NaNs)</span>
<span class="p_add">+	 */</span>
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_QNAN):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_QNAN):
 		return x;
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_QNAN):</span>
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_QNAN, IEEE754_CLASS_DNORM):
<span class="p_chunk">@@ -164,25 +202,25 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)</span>
 	/*
 	 * Infinity and zero handling
 	 */
<span class="p_add">+	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
<span class="p_add">+		return ieee754sp_inf(xs | ys);</span>
<span class="p_add">+</span>
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_DNORM):
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_ZERO):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_ZERO):
<span class="p_del">-		return x;</span>
<span class="p_add">+		return y;</span>
 
<span class="p_del">-	case CLPAIR(IEEE754_CLASS_INF, IEEE754_CLASS_INF):</span>
 	case CLPAIR(IEEE754_CLASS_NORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_INF):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_NORM):
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_DNORM):
<span class="p_del">-		return y;</span>
<span class="p_add">+		return x;</span>
 
 	case CLPAIR(IEEE754_CLASS_ZERO, IEEE754_CLASS_ZERO):
<span class="p_del">-		if (xs == ys)</span>
<span class="p_del">-			return x;</span>
<span class="p_del">-		return ieee754sp_zero(1);</span>
<span class="p_add">+		return ieee754sp_zero(xs | ys);</span>
 
 	case CLPAIR(IEEE754_CLASS_DNORM, IEEE754_CLASS_DNORM):
 		SPDNORMX;
<span class="p_chunk">@@ -207,7 +245,11 @@</span> <span class="p_context"> union ieee754sp ieee754sp_fmina(union ieee754sp x, union ieee754sp y)</span>
 		return x;
 
 	/* Compare mantissa */
<span class="p_del">-	if (xm &lt;= ym)</span>
<span class="p_add">+	if (xm &lt; ym)</span>
<span class="p_add">+		return x;</span>
<span class="p_add">+	else if (xm &gt; ym)</span>
<span class="p_add">+		return y;</span>
<span class="p_add">+	else if (xs == 1)</span>
 		return x;
 	return y;
 }
<span class="p_header">diff --git a/arch/powerpc/kernel/align.c b/arch/powerpc/kernel/align.c</span>
<span class="p_header">index 91e5c1758b5c..64e016abb2a5 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/align.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/align.c</span>
<span class="p_chunk">@@ -236,6 +236,28 @@</span> <span class="p_context"> static int emulate_dcbz(struct pt_regs *regs, unsigned char __user *addr)</span>
 
 #define SWIZ_PTR(p)		((unsigned char __user *)((p) ^ swiz))
 
<span class="p_add">+#define __get_user_or_set_dar(_regs, _dest, _addr)		\</span>
<span class="p_add">+	({							\</span>
<span class="p_add">+		int rc = 0;					\</span>
<span class="p_add">+		typeof(_addr) __addr = (_addr);			\</span>
<span class="p_add">+		if (__get_user_inatomic(_dest, __addr)) {	\</span>
<span class="p_add">+			_regs-&gt;dar = (unsigned long)__addr;	\</span>
<span class="p_add">+			rc = -EFAULT;				\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+		rc;						\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
<span class="p_add">+#define __put_user_or_set_dar(_regs, _src, _addr)		\</span>
<span class="p_add">+	({							\</span>
<span class="p_add">+		int rc = 0;					\</span>
<span class="p_add">+		typeof(_addr) __addr = (_addr);			\</span>
<span class="p_add">+		if (__put_user_inatomic(_src, __addr)) {	\</span>
<span class="p_add">+			_regs-&gt;dar = (unsigned long)__addr;	\</span>
<span class="p_add">+			rc = -EFAULT;				\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+		rc;						\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
 static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,
 			    unsigned int reg, unsigned int nb,
 			    unsigned int flags, unsigned int instr,
<span class="p_chunk">@@ -264,9 +286,10 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
 		} else {
 			unsigned long pc = regs-&gt;nip ^ (swiz &amp; 4);
 
<span class="p_del">-			if (__get_user_inatomic(instr,</span>
<span class="p_del">-						(unsigned int __user *)pc))</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, instr,</span>
<span class="p_add">+						  (unsigned int __user *)pc))</span>
 				return -EFAULT;
<span class="p_add">+</span>
 			if (swiz == 0 &amp;&amp; (flags &amp; SW))
 				instr = cpu_to_le32(instr);
 			nb = (instr &gt;&gt; 11) &amp; 0x1f;
<span class="p_chunk">@@ -310,31 +333,31 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
 			       ((nb0 + 3) / 4) * sizeof(unsigned long));
 
 		for (i = 0; i &lt; nb; ++i, ++p)
<span class="p_del">-			if (__get_user_inatomic(REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_del">-						SWIZ_PTR(p)))</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+						  SWIZ_PTR(p)))</span>
 				return -EFAULT;
 		if (nb0 &gt; 0) {
 			rptr = &amp;regs-&gt;gpr[0];
 			addr += nb;
 			for (i = 0; i &lt; nb0; ++i, ++p)
<span class="p_del">-				if (__get_user_inatomic(REG_BYTE(rptr,</span>
<span class="p_del">-								 i ^ bswiz),</span>
<span class="p_del">-							SWIZ_PTR(p)))</span>
<span class="p_add">+				if (__get_user_or_set_dar(regs,</span>
<span class="p_add">+							  REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+							  SWIZ_PTR(p)))</span>
 					return -EFAULT;
 		}
 
 	} else {
 		for (i = 0; i &lt; nb; ++i, ++p)
<span class="p_del">-			if (__put_user_inatomic(REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_del">-						SWIZ_PTR(p)))</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+						  SWIZ_PTR(p)))</span>
 				return -EFAULT;
 		if (nb0 &gt; 0) {
 			rptr = &amp;regs-&gt;gpr[0];
 			addr += nb;
 			for (i = 0; i &lt; nb0; ++i, ++p)
<span class="p_del">-				if (__put_user_inatomic(REG_BYTE(rptr,</span>
<span class="p_del">-								 i ^ bswiz),</span>
<span class="p_del">-							SWIZ_PTR(p)))</span>
<span class="p_add">+				if (__put_user_or_set_dar(regs,</span>
<span class="p_add">+							  REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+							  SWIZ_PTR(p)))</span>
 					return -EFAULT;
 		}
 	}
<span class="p_chunk">@@ -346,29 +369,32 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
  * Only POWER6 has these instructions, and it does true little-endian,
  * so we don&#39;t need the address swizzling.
  */
<span class="p_del">-static int emulate_fp_pair(unsigned char __user *addr, unsigned int reg,</span>
<span class="p_del">-			   unsigned int flags)</span>
<span class="p_add">+static int emulate_fp_pair(struct pt_regs *regs, unsigned char __user *addr,</span>
<span class="p_add">+			   unsigned int reg, unsigned int flags)</span>
 {
 	char *ptr0 = (char *) &amp;current-&gt;thread.TS_FPR(reg);
 	char *ptr1 = (char *) &amp;current-&gt;thread.TS_FPR(reg+1);
<span class="p_del">-	int i, ret, sw = 0;</span>
<span class="p_add">+	int i, sw = 0;</span>
 
 	if (reg &amp; 1)
 		return 0;	/* invalid form: FRS/FRT must be even */
 	if (flags &amp; SW)
 		sw = 7;
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; 8; ++i) {
 		if (!(flags &amp; ST)) {
<span class="p_del">-			ret |= __get_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __get_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		} else {
<span class="p_del">-			ret |= __put_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __put_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		}
 	}
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+</span>
 	return 1;	/* exception handled and fixed up */
 }
 
<span class="p_chunk">@@ -378,24 +404,27 @@</span> <span class="p_context"> static int emulate_lq_stq(struct pt_regs *regs, unsigned char __user *addr,</span>
 {
 	char *ptr0 = (char *)&amp;regs-&gt;gpr[reg];
 	char *ptr1 = (char *)&amp;regs-&gt;gpr[reg+1];
<span class="p_del">-	int i, ret, sw = 0;</span>
<span class="p_add">+	int i, sw = 0;</span>
 
 	if (reg &amp; 1)
 		return 0;	/* invalid form: GPR must be even */
 	if (flags &amp; SW)
 		sw = 7;
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; 8; ++i) {
 		if (!(flags &amp; ST)) {
<span class="p_del">-			ret |= __get_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __get_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		} else {
<span class="p_del">-			ret |= __put_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __put_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		}
 	}
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+</span>
 	return 1;	/* exception handled and fixed up */
 }
 #endif /* CONFIG_PPC64 */
<span class="p_chunk">@@ -688,9 +717,14 @@</span> <span class="p_context"> static int emulate_vsx(unsigned char __user *addr, unsigned int reg,</span>
 	for (j = 0; j &lt; length; j += elsize) {
 		for (i = 0; i &lt; elsize; ++i) {
 			if (flags &amp; ST)
<span class="p_del">-				ret |= __put_user(ptr[i^sw], addr + i);</span>
<span class="p_add">+				ret = __put_user_or_set_dar(regs, ptr[i^sw],</span>
<span class="p_add">+							    addr + i);</span>
 			else
<span class="p_del">-				ret |= __get_user(ptr[i^sw], addr + i);</span>
<span class="p_add">+				ret = __get_user_or_set_dar(regs, ptr[i^sw],</span>
<span class="p_add">+							    addr + i);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 		}
 		ptr  += elsize;
 #ifdef __LITTLE_ENDIAN__
<span class="p_chunk">@@ -740,7 +774,7 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 	unsigned int dsisr;
 	unsigned char __user *addr;
 	unsigned long p, swiz;
<span class="p_del">-	int ret, i;</span>
<span class="p_add">+	int i;</span>
 	union data {
 		u64 ll;
 		double dd;
<span class="p_chunk">@@ -923,7 +957,7 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 		if (flags &amp; F) {
 			/* Special case for 16-byte FP loads and stores */
 			PPC_WARN_ALIGNMENT(fp_pair, regs);
<span class="p_del">-			return emulate_fp_pair(addr, reg, flags);</span>
<span class="p_add">+			return emulate_fp_pair(regs, addr, reg, flags);</span>
 		} else {
 #ifdef CONFIG_PPC64
 			/* Special case for 16-byte loads and stores */
<span class="p_chunk">@@ -953,15 +987,12 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 		}
 
 		data.ll = 0;
<span class="p_del">-		ret = 0;</span>
 		p = (unsigned long)addr;
 
 		for (i = 0; i &lt; nb; i++)
<span class="p_del">-			ret |= __get_user_inatomic(data.v[start + i],</span>
<span class="p_del">-						   SWIZ_PTR(p++));</span>
<span class="p_del">-</span>
<span class="p_del">-		if (unlikely(ret))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, data.v[start + i],</span>
<span class="p_add">+						  SWIZ_PTR(p++)))</span>
<span class="p_add">+				return -EFAULT;</span>
 
 	} else if (flags &amp; F) {
 		data.ll = current-&gt;thread.TS_FPR(reg);
<span class="p_chunk">@@ -1031,15 +1062,13 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 			break;
 		}
 
<span class="p_del">-		ret = 0;</span>
 		p = (unsigned long)addr;
 
 		for (i = 0; i &lt; nb; i++)
<span class="p_del">-			ret |= __put_user_inatomic(data.v[start + i],</span>
<span class="p_del">-						   SWIZ_PTR(p++));</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, data.v[start + i],</span>
<span class="p_add">+						  SWIZ_PTR(p++)))</span>
<span class="p_add">+				return -EFAULT;</span>
 
<span class="p_del">-		if (unlikely(ret))</span>
<span class="p_del">-			return -EFAULT;</span>
 	} else if (flags &amp; F)
 		current-&gt;thread.TS_FPR(reg) = data.ll;
 	else
<span class="p_header">diff --git a/arch/x86/include/asm/elf.h b/arch/x86/include/asm/elf.h</span>
<span class="p_header">index bcd3d6199464..bb16a58cf7e4 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/elf.h</span>
<span class="p_chunk">@@ -204,6 +204,7 @@</span> <span class="p_context"> void set_personality_ia32(bool);</span>
 
 #define ELF_CORE_COPY_REGS(pr_reg, regs)			\
 do {								\
<span class="p_add">+	unsigned long base;					\</span>
 	unsigned v;						\
 	(pr_reg)[0] = (regs)-&gt;r15;				\
 	(pr_reg)[1] = (regs)-&gt;r14;				\
<span class="p_chunk">@@ -226,8 +227,8 @@</span> <span class="p_context"> do {								\</span>
 	(pr_reg)[18] = (regs)-&gt;flags;				\
 	(pr_reg)[19] = (regs)-&gt;sp;				\
 	(pr_reg)[20] = (regs)-&gt;ss;				\
<span class="p_del">-	(pr_reg)[21] = current-&gt;thread.fs;			\</span>
<span class="p_del">-	(pr_reg)[22] = current-&gt;thread.gs;			\</span>
<span class="p_add">+	rdmsrl(MSR_FS_BASE, base); (pr_reg)[21] = base;		\</span>
<span class="p_add">+	rdmsrl(MSR_KERNEL_GS_BASE, base); (pr_reg)[22] = base;	\</span>
 	asm(&quot;movl %%ds,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[23] = v;	\
 	asm(&quot;movl %%es,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[24] = v;	\
 	asm(&quot;movl %%fs,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[25] = v;	\
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index ef083e7a37c5..119658534dfd 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -233,7 +233,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_start_queue_async);</span>
  **/
 void blk_start_queue(struct request_queue *q)
 {
<span class="p_del">-	WARN_ON(!irqs_disabled());</span>
<span class="p_add">+	WARN_ON(!in_interrupt() &amp;&amp; !irqs_disabled());</span>
 
 	queue_flag_clear(QUEUE_FLAG_STOPPED, q);
 	__blk_run_queue(q);
<span class="p_header">diff --git a/crypto/algif_skcipher.c b/crypto/algif_skcipher.c</span>
<span class="p_header">index b3b0004ea8ac..d12782dc9683 100644</span>
<span class="p_header">--- a/crypto/algif_skcipher.c</span>
<span class="p_header">+++ b/crypto/algif_skcipher.c</span>
<span class="p_chunk">@@ -143,8 +143,10 @@</span> <span class="p_context"> static int skcipher_alloc_sgl(struct sock *sk)</span>
 		sg_init_table(sgl-&gt;sg, MAX_SGL_ENTS + 1);
 		sgl-&gt;cur = 0;
 
<span class="p_del">-		if (sg)</span>
<span class="p_add">+		if (sg) {</span>
 			sg_chain(sg, MAX_SGL_ENTS + 1, sgl-&gt;sg);
<span class="p_add">+			sg_unmark_end(sg + (MAX_SGL_ENTS - 1));</span>
<span class="p_add">+		}</span>
 
 		list_add_tail(&amp;sgl-&gt;list, &amp;ctx-&gt;tsgl);
 	}
<span class="p_header">diff --git a/drivers/block/skd_main.c b/drivers/block/skd_main.c</span>
<span class="p_header">index 586f9168ffa4..47d1e834f3f4 100644</span>
<span class="p_header">--- a/drivers/block/skd_main.c</span>
<span class="p_header">+++ b/drivers/block/skd_main.c</span>
<span class="p_chunk">@@ -2214,6 +2214,9 @@</span> <span class="p_context"> static void skd_send_fitmsg(struct skd_device *skdev,</span>
 		 */
 		qcmd |= FIT_QCMD_MSGSIZE_64;
 
<span class="p_add">+	/* Make sure skd_msg_buf is written before the doorbell is triggered. */</span>
<span class="p_add">+	smp_wmb();</span>
<span class="p_add">+</span>
 	SKD_WRITEQ(skdev, qcmd, FIT_Q_COMMAND);
 
 }
<span class="p_chunk">@@ -2260,6 +2263,9 @@</span> <span class="p_context"> static void skd_send_special_fitmsg(struct skd_device *skdev,</span>
 	qcmd = skspcl-&gt;mb_dma_address;
 	qcmd |= FIT_QCMD_QID_NORMAL + FIT_QCMD_MSGSIZE_128;
 
<span class="p_add">+	/* Make sure skd_msg_buf is written before the doorbell is triggered. */</span>
<span class="p_add">+	smp_wmb();</span>
<span class="p_add">+</span>
 	SKD_WRITEQ(skdev, qcmd, FIT_Q_COMMAND);
 }
 
<span class="p_chunk">@@ -4679,15 +4685,16 @@</span> <span class="p_context"> static void skd_free_disk(struct skd_device *skdev)</span>
 {
 	struct gendisk *disk = skdev-&gt;disk;
 
<span class="p_del">-	if (disk != NULL) {</span>
<span class="p_del">-		struct request_queue *q = disk-&gt;queue;</span>
<span class="p_add">+	if (disk &amp;&amp; (disk-&gt;flags &amp; GENHD_FL_UP))</span>
<span class="p_add">+		del_gendisk(disk);</span>
 
<span class="p_del">-		if (disk-&gt;flags &amp; GENHD_FL_UP)</span>
<span class="p_del">-			del_gendisk(disk);</span>
<span class="p_del">-		if (q)</span>
<span class="p_del">-			blk_cleanup_queue(q);</span>
<span class="p_del">-		put_disk(disk);</span>
<span class="p_add">+	if (skdev-&gt;queue) {</span>
<span class="p_add">+		blk_cleanup_queue(skdev-&gt;queue);</span>
<span class="p_add">+		skdev-&gt;queue = NULL;</span>
<span class="p_add">+		disk-&gt;queue = NULL;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	put_disk(disk);</span>
 	skdev-&gt;disk = NULL;
 }
 
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index 5be14ad29d46..dbf09836ff30 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -904,6 +904,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_kbdreset_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P34&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Gigabyte P57 - Elantech touchpad */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;GIGABYTE&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P57&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{
 		/* Schenker XMG C504 - Elantech touchpad */
 		.matches = {
<span class="p_header">diff --git a/drivers/md/bcache/bcache.h b/drivers/md/bcache/bcache.h</span>
<span class="p_header">index c3ea03c9a1a8..02619cabda8b 100644</span>
<span class="p_header">--- a/drivers/md/bcache/bcache.h</span>
<span class="p_header">+++ b/drivers/md/bcache/bcache.h</span>
<span class="p_chunk">@@ -333,6 +333,7 @@</span> <span class="p_context"> struct cached_dev {</span>
 	/* Limit number of writeback bios in flight */
 	struct semaphore	in_flight;
 	struct task_struct	*writeback_thread;
<span class="p_add">+	struct workqueue_struct	*writeback_write_wq;</span>
 
 	struct keybuf		writeback_keys;
 
<span class="p_header">diff --git a/drivers/md/bcache/request.c b/drivers/md/bcache/request.c</span>
<span class="p_header">index 2410df1c2a05..6c4c7caea693 100644</span>
<span class="p_header">--- a/drivers/md/bcache/request.c</span>
<span class="p_header">+++ b/drivers/md/bcache/request.c</span>
<span class="p_chunk">@@ -196,12 +196,12 @@</span> <span class="p_context"> static void bch_data_insert_start(struct closure *cl)</span>
 	struct data_insert_op *op = container_of(cl, struct data_insert_op, cl);
 	struct bio *bio = op-&gt;bio, *n;
 
<span class="p_del">-	if (atomic_sub_return(bio_sectors(bio), &amp;op-&gt;c-&gt;sectors_to_gc) &lt; 0)</span>
<span class="p_del">-		wake_up_gc(op-&gt;c);</span>
<span class="p_del">-</span>
 	if (op-&gt;bypass)
 		return bch_data_invalidate(cl);
 
<span class="p_add">+	if (atomic_sub_return(bio_sectors(bio), &amp;op-&gt;c-&gt;sectors_to_gc) &lt; 0)</span>
<span class="p_add">+		wake_up_gc(op-&gt;c);</span>
<span class="p_add">+</span>
 	/*
 	 * Journal writes are marked REQ_FLUSH; if the original write was a
 	 * flush, it&#39;ll wait on the journal write.
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index 7b5880b8874c..c5ceea9222ff 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1023,7 +1023,7 @@</span> <span class="p_context"> int bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c)</span>
 	}
 
 	if (BDEV_STATE(&amp;dc-&gt;sb) == BDEV_STATE_DIRTY) {
<span class="p_del">-		bch_sectors_dirty_init(dc);</span>
<span class="p_add">+		bch_sectors_dirty_init(&amp;dc-&gt;disk);</span>
 		atomic_set(&amp;dc-&gt;has_dirty, 1);
 		atomic_inc(&amp;dc-&gt;count);
 		bch_writeback_queue(dc);
<span class="p_chunk">@@ -1056,6 +1056,8 @@</span> <span class="p_context"> static void cached_dev_free(struct closure *cl)</span>
 	cancel_delayed_work_sync(&amp;dc-&gt;writeback_rate_update);
 	if (!IS_ERR_OR_NULL(dc-&gt;writeback_thread))
 		kthread_stop(dc-&gt;writeback_thread);
<span class="p_add">+	if (dc-&gt;writeback_write_wq)</span>
<span class="p_add">+		destroy_workqueue(dc-&gt;writeback_write_wq);</span>
 
 	mutex_lock(&amp;bch_register_lock);
 
<span class="p_chunk">@@ -1227,6 +1229,7 @@</span> <span class="p_context"> static int flash_dev_run(struct cache_set *c, struct uuid_entry *u)</span>
 		goto err;
 
 	bcache_device_attach(d, c, u - c-&gt;uuids);
<span class="p_add">+	bch_sectors_dirty_init(d);</span>
 	bch_flash_dev_request_init(d);
 	add_disk(d-&gt;disk);
 
<span class="p_chunk">@@ -1959,6 +1962,8 @@</span> <span class="p_context"> static ssize_t register_bcache(struct kobject *k, struct kobj_attribute *attr,</span>
 			else
 				err = &quot;device busy&quot;;
 			mutex_unlock(&amp;bch_register_lock);
<span class="p_add">+			if (!IS_ERR(bdev))</span>
<span class="p_add">+				bdput(bdev);</span>
 			if (attr == &amp;ksysfs_register_quiet)
 				goto out;
 		}
<span class="p_header">diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.c</span>
<span class="p_header">index b3ff57d61dde..4fbb5532f24c 100644</span>
<span class="p_header">--- a/drivers/md/bcache/sysfs.c</span>
<span class="p_header">+++ b/drivers/md/bcache/sysfs.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> STORE(__cached_dev)</span>
 {
 	struct cached_dev *dc = container_of(kobj, struct cached_dev,
 					     disk.kobj);
<span class="p_del">-	unsigned v = size;</span>
<span class="p_add">+	ssize_t v = size;</span>
 	struct cache_set *c;
 	struct kobj_uevent_env *env;
 
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> STORE(__cached_dev)</span>
 		bch_cached_dev_run(dc);
 
 	if (attr == &amp;sysfs_cache_mode) {
<span class="p_del">-		ssize_t v = bch_read_string_list(buf, bch_cache_modes + 1);</span>
<span class="p_add">+		v = bch_read_string_list(buf, bch_cache_modes + 1);</span>
 
 		if (v &lt; 0)
 			return v;
<span class="p_header">diff --git a/drivers/md/bcache/util.c b/drivers/md/bcache/util.c</span>
<span class="p_header">index db3ae4c2b223..6c18e3ec3e48 100644</span>
<span class="p_header">--- a/drivers/md/bcache/util.c</span>
<span class="p_header">+++ b/drivers/md/bcache/util.c</span>
<span class="p_chunk">@@ -73,24 +73,44 @@</span> <span class="p_context"> STRTO_H(strtouint, unsigned int)</span>
 STRTO_H(strtoll, long long)
 STRTO_H(strtoull, unsigned long long)
 
<span class="p_add">+/**</span>
<span class="p_add">+ * bch_hprint() - formats @v to human readable string for sysfs.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @v - signed 64 bit integer</span>
<span class="p_add">+ * @buf - the (at least 8 byte) buffer to format the result into.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the number of bytes used by format.</span>
<span class="p_add">+ */</span>
 ssize_t bch_hprint(char *buf, int64_t v)
 {
 	static const char units[] = &quot;?kMGTPEZY&quot;;
<span class="p_del">-	char dec[4] = &quot;&quot;;</span>
<span class="p_del">-	int u, t = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (u = 0; v &gt;= 1024 || v &lt;= -1024; u++) {</span>
<span class="p_del">-		t = v &amp; ~(~0 &lt;&lt; 10);</span>
<span class="p_del">-		v &gt;&gt;= 10;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!u)</span>
<span class="p_del">-		return sprintf(buf, &quot;%llu&quot;, v);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (v &lt; 100 &amp;&amp; v &gt; -100)</span>
<span class="p_del">-		snprintf(dec, sizeof(dec), &quot;.%i&quot;, t / 100);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sprintf(buf, &quot;%lli%s%c&quot;, v, dec, units[u]);</span>
<span class="p_add">+	int u = 0, t;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint64_t q;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (v &lt; 0)</span>
<span class="p_add">+		q = -v;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		q = v;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* For as long as the number is more than 3 digits, but at least</span>
<span class="p_add">+	 * once, shift right / divide by 1024.  Keep the remainder for</span>
<span class="p_add">+	 * a digit after the decimal point.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		u++;</span>
<span class="p_add">+</span>
<span class="p_add">+		t = q &amp; ~(~0 &lt;&lt; 10);</span>
<span class="p_add">+		q &gt;&gt;= 10;</span>
<span class="p_add">+	} while (q &gt;= 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (v &lt; 0)</span>
<span class="p_add">+		/* &#39;-&#39;, up to 3 digits, &#39;.&#39;, 1 digit, 1 character, null;</span>
<span class="p_add">+		 * yields 8 bytes.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return sprintf(buf, &quot;-%llu.%i%c&quot;, q, t * 10 / 1024, units[u]);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return sprintf(buf, &quot;%llu.%i%c&quot;, q, t * 10 / 1024, units[u]);</span>
 }
 
 ssize_t bch_snprint_string_list(char *buf, size_t size, const char * const list[],
<span class="p_header">diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.c</span>
<span class="p_header">index b9346cd9cda1..bbb1dc9e1639 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.c</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.c</span>
<span class="p_chunk">@@ -21,7 +21,8 @@</span> <span class="p_context"></span>
 static void __update_writeback_rate(struct cached_dev *dc)
 {
 	struct cache_set *c = dc-&gt;disk.c;
<span class="p_del">-	uint64_t cache_sectors = c-&gt;nbuckets * c-&gt;sb.bucket_size;</span>
<span class="p_add">+	uint64_t cache_sectors = c-&gt;nbuckets * c-&gt;sb.bucket_size -</span>
<span class="p_add">+				bcache_flash_devs_sectors_dirty(c);</span>
 	uint64_t cache_dirty_target =
 		div_u64(cache_sectors * dc-&gt;writeback_percent, 100);
 
<span class="p_chunk">@@ -190,7 +191,7 @@</span> <span class="p_context"> static void write_dirty(struct closure *cl)</span>
 
 	closure_bio_submit(&amp;io-&gt;bio, cl);
 
<span class="p_del">-	continue_at(cl, write_dirty_finish, system_wq);</span>
<span class="p_add">+	continue_at(cl, write_dirty_finish, io-&gt;dc-&gt;writeback_write_wq);</span>
 }
 
 static void read_dirty_endio(struct bio *bio)
<span class="p_chunk">@@ -210,7 +211,7 @@</span> <span class="p_context"> static void read_dirty_submit(struct closure *cl)</span>
 
 	closure_bio_submit(&amp;io-&gt;bio, cl);
 
<span class="p_del">-	continue_at(cl, write_dirty, system_wq);</span>
<span class="p_add">+	continue_at(cl, write_dirty, io-&gt;dc-&gt;writeback_write_wq);</span>
 }
 
 static void read_dirty(struct cached_dev *dc)
<span class="p_chunk">@@ -488,17 +489,17 @@</span> <span class="p_context"> static int sectors_dirty_init_fn(struct btree_op *_op, struct btree *b,</span>
 	return MAP_CONTINUE;
 }
 
<span class="p_del">-void bch_sectors_dirty_init(struct cached_dev *dc)</span>
<span class="p_add">+void bch_sectors_dirty_init(struct bcache_device *d)</span>
 {
 	struct sectors_dirty_init op;
 
 	bch_btree_op_init(&amp;op.op, -1);
<span class="p_del">-	op.inode = dc-&gt;disk.id;</span>
<span class="p_add">+	op.inode = d-&gt;id;</span>
 
<span class="p_del">-	bch_btree_map_keys(&amp;op.op, dc-&gt;disk.c, &amp;KEY(op.inode, 0, 0),</span>
<span class="p_add">+	bch_btree_map_keys(&amp;op.op, d-&gt;c, &amp;KEY(op.inode, 0, 0),</span>
 			   sectors_dirty_init_fn, 0);
 
<span class="p_del">-	dc-&gt;disk.sectors_dirty_last = bcache_dev_sectors_dirty(&amp;dc-&gt;disk);</span>
<span class="p_add">+	d-&gt;sectors_dirty_last = bcache_dev_sectors_dirty(d);</span>
 }
 
 void bch_cached_dev_writeback_init(struct cached_dev *dc)
<span class="p_chunk">@@ -522,6 +523,11 @@</span> <span class="p_context"> void bch_cached_dev_writeback_init(struct cached_dev *dc)</span>
 
 int bch_cached_dev_writeback_start(struct cached_dev *dc)
 {
<span class="p_add">+	dc-&gt;writeback_write_wq = alloc_workqueue(&quot;bcache_writeback_wq&quot;,</span>
<span class="p_add">+						WQ_MEM_RECLAIM, 0);</span>
<span class="p_add">+	if (!dc-&gt;writeback_write_wq)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	dc-&gt;writeback_thread = kthread_create(bch_writeback_thread, dc,
 					      &quot;bcache_writeback&quot;);
 	if (IS_ERR(dc-&gt;writeback_thread))
<span class="p_header">diff --git a/drivers/md/bcache/writeback.h b/drivers/md/bcache/writeback.h</span>
<span class="p_header">index 073a042aed24..daec4fd782ea 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.h</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.h</span>
<span class="p_chunk">@@ -14,6 +14,25 @@</span> <span class="p_context"> static inline uint64_t bcache_dev_sectors_dirty(struct bcache_device *d)</span>
 	return ret;
 }
 
<span class="p_add">+static inline uint64_t  bcache_flash_devs_sectors_dirty(struct cache_set *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint64_t i, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;bch_register_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; c-&gt;nr_uuids; i++) {</span>
<span class="p_add">+		struct bcache_device *d = c-&gt;devices[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!d || !UUID_FLASH_ONLY(&amp;c-&gt;uuids[i]))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+	   ret += bcache_dev_sectors_dirty(d);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;bch_register_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned offset_to_stripe(struct bcache_device *d,
 					uint64_t offset)
 {
<span class="p_chunk">@@ -85,7 +104,7 @@</span> <span class="p_context"> static inline void bch_writeback_add(struct cached_dev *dc)</span>
 
 void bcache_dev_sectors_dirty_add(struct cache_set *, unsigned, uint64_t, int);
 
<span class="p_del">-void bch_sectors_dirty_init(struct cached_dev *dc);</span>
<span class="p_add">+void bch_sectors_dirty_init(struct bcache_device *);</span>
 void bch_cached_dev_writeback_init(struct cached_dev *);
 int bch_cached_dev_writeback_start(struct cached_dev *);
 
<span class="p_header">diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c</span>
<span class="p_header">index 4f22e919787a..7a50728b9389 100644</span>
<span class="p_header">--- a/drivers/md/bitmap.c</span>
<span class="p_header">+++ b/drivers/md/bitmap.c</span>
<span class="p_chunk">@@ -1960,6 +1960,11 @@</span> <span class="p_context"> int bitmap_resize(struct bitmap *bitmap, sector_t blocks,</span>
 	long pages;
 	struct bitmap_page *new_bp;
 
<span class="p_add">+	if (bitmap-&gt;storage.file &amp;&amp; !init) {</span>
<span class="p_add">+		pr_info(&quot;md: cannot resize file-based bitmap\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (chunksize == 0) {
 		/* If there is enough space, leave the chunk size unchanged,
 		 * else increase by factor of two until there is enough space.
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 8f60520c8392..5eac08ffc697 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -5822,6 +5822,8 @@</span> <span class="p_context"> static void raid5_do_work(struct work_struct *work)</span>
 
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
 
<span class="p_add">+	r5l_flush_stripe_to_raid(conf-&gt;log);</span>
<span class="p_add">+</span>
 	async_tx_issue_pending_all();
 	blk_finish_plug(&amp;plug);
 
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_ctrl.c b/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_header">index 3e59b288b8a8..618e4e2b4207 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_chunk">@@ -2001,6 +2001,13 @@</span> <span class="p_context"> int uvc_ctrl_add_mapping(struct uvc_video_chain *chain,</span>
 		goto done;
 	}
 
<span class="p_add">+	/* Validate the user-provided bit-size and offset */</span>
<span class="p_add">+	if (mapping-&gt;size &gt; 32 ||</span>
<span class="p_add">+	    mapping-&gt;offset + mapping-&gt;size &gt; ctrl-&gt;info.size * 8) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_for_each_entry(map, &amp;ctrl-&gt;info.mappings, list) {
 		if (mapping-&gt;id == map-&gt;id) {
 			uvc_trace(UVC_TRACE_CONTROL, &quot;Can&#39;t add mapping &#39;%s&#39;, &quot;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">index 109f687d1cbd..4379b949bb93 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_chunk">@@ -773,7 +773,8 @@</span> <span class="p_context"> static int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *u</span>
 		copy_to_user(&amp;up-&gt;u, &amp;kp-&gt;u, sizeof(kp-&gt;u)) ||
 		put_user(kp-&gt;pending, &amp;up-&gt;pending) ||
 		put_user(kp-&gt;sequence, &amp;up-&gt;sequence) ||
<span class="p_del">-		compat_put_timespec(&amp;kp-&gt;timestamp, &amp;up-&gt;timestamp) ||</span>
<span class="p_add">+		put_user(kp-&gt;timestamp.tv_sec, &amp;up-&gt;timestamp.tv_sec) ||</span>
<span class="p_add">+		put_user(kp-&gt;timestamp.tv_nsec, &amp;up-&gt;timestamp.tv_nsec) ||</span>
 		put_user(kp-&gt;id, &amp;up-&gt;id) ||
 		copy_to_user(up-&gt;reserved, kp-&gt;reserved, 8 * sizeof(__u32)))
 			return -EFAULT;
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">index 4cd2a7d0124f..7923bfdc9b30 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_chunk">@@ -3676,7 +3676,7 @@</span> <span class="p_context"> static noinline void gfar_update_link_state(struct gfar_private *priv)</span>
 		u32 tempval1 = gfar_read(&amp;regs-&gt;maccfg1);
 		u32 tempval = gfar_read(&amp;regs-&gt;maccfg2);
 		u32 ecntrl = gfar_read(&amp;regs-&gt;ecntrl);
<span class="p_del">-		u32 tx_flow_oldval = (tempval &amp; MACCFG1_TX_FLOW);</span>
<span class="p_add">+		u32 tx_flow_oldval = (tempval1 &amp; MACCFG1_TX_FLOW);</span>
 
 		if (phydev-&gt;duplex != priv-&gt;oldduplex) {
 			if (!(phydev-&gt;duplex))
<span class="p_header">diff --git a/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c b/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_header">index 829be21f97b2..be258d90de9e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qlogic/qlge/qlge_dbg.c</span>
<span class="p_chunk">@@ -724,7 +724,7 @@</span> <span class="p_context"> static void ql_build_coredump_seg_header(</span>
 	seg_hdr-&gt;cookie = MPI_COREDUMP_COOKIE;
 	seg_hdr-&gt;segNum = seg_number;
 	seg_hdr-&gt;segSize = seg_size;
<span class="p_del">-	memcpy(seg_hdr-&gt;description, desc, (sizeof(seg_hdr-&gt;description)) - 1);</span>
<span class="p_add">+	strncpy(seg_hdr-&gt;description, desc, (sizeof(seg_hdr-&gt;description)) - 1);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index 49d9f0a789fe..7d0690433ee0 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -541,9 +541,6 @@</span> <span class="p_context"> void phy_stop_machine(struct phy_device *phydev)</span>
 	if (phydev-&gt;state &gt; PHY_UP &amp;&amp; phydev-&gt;state != PHY_HALTED)
 		phydev-&gt;state = PHY_UP;
 	mutex_unlock(&amp;phydev-&gt;lock);
<span class="p_del">-</span>
<span class="p_del">-	/* Now we can run the state machine synchronously */</span>
<span class="p_del">-	phy_state_machine(&amp;phydev-&gt;state_queue.work);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/pci/hotplug/shpchp_hpc.c b/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_header">index 7d223e9080ef..77dddee2753a 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_chunk">@@ -1062,6 +1062,8 @@</span> <span class="p_context"> int shpc_init(struct controller *ctrl, struct pci_dev *pdev)</span>
 		if (rc) {
 			ctrl_info(ctrl, &quot;Can&#39;t get msi for the hotplug controller\n&quot;);
 			ctrl_info(ctrl, &quot;Use INTx for the hotplug controller\n&quot;);
<span class="p_add">+		} else {</span>
<span class="p_add">+			pci_set_master(pdev);</span>
 		}
 
 		rc = request_irq(ctrl-&gt;pci_dev-&gt;irq, shpc_isr, IRQF_SHARED,
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">index d5bf36ec8a75..34367d172961 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Debug traces for zfcp.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2017</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -447,6 +447,7 @@</span> <span class="p_context"> static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
 	struct fc_ct_hdr *reqh = sg_virt(ct_els-&gt;req);
 	struct fc_ns_gid_ft *reqn = (struct fc_ns_gid_ft *)(reqh + 1);
 	struct scatterlist *resp_entry = ct_els-&gt;resp;
<span class="p_add">+	struct fc_ct_hdr *resph;</span>
 	struct fc_gpn_ft_resp *acc;
 	int max_entries, x, last = 0;
 
<span class="p_chunk">@@ -473,6 +474,13 @@</span> <span class="p_context"> static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
 		return len; /* not GPN_FT response so do not cap */
 
 	acc = sg_virt(resp_entry);
<span class="p_add">+</span>
<span class="p_add">+	/* cap all but accept CT responses to at least the CT header */</span>
<span class="p_add">+	resph = (struct fc_ct_hdr *)acc;</span>
<span class="p_add">+	if ((ct_els-&gt;status) ||</span>
<span class="p_add">+	    (resph-&gt;ct_cmd != cpu_to_be16(FC_FS_ACC)))</span>
<span class="p_add">+		return max(FC_CT_HDR_LEN, ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_add">+</span>
 	max_entries = (reqh-&gt;ct_mr_size * 4 / sizeof(struct fc_gpn_ft_resp))
 		+ 1 /* zfcp_fc_scan_ports: bytes correct, entries off-by-one
 		     * to account for header as 1st pseudo &quot;entry&quot; */;
<span class="p_chunk">@@ -555,8 +563,8 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
 	rec-&gt;scsi_retries = sc-&gt;retries;
 	rec-&gt;scsi_allowed = sc-&gt;allowed;
 	rec-&gt;scsi_id = sc-&gt;device-&gt;id;
<span class="p_del">-	/* struct zfcp_dbf_scsi needs to be updated to handle 64bit LUNs */</span>
 	rec-&gt;scsi_lun = (u32)sc-&gt;device-&gt;lun;
<span class="p_add">+	rec-&gt;scsi_lun_64_hi = (u32)(sc-&gt;device-&gt;lun &gt;&gt; 32);</span>
 	rec-&gt;host_scribble = (unsigned long)sc-&gt;host_scribble;
 
 	memcpy(rec-&gt;scsi_opcode, sc-&gt;cmnd,
<span class="p_chunk">@@ -564,19 +572,32 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
 
 	if (fsf) {
 		rec-&gt;fsf_req_id = fsf-&gt;req_id;
<span class="p_add">+		rec-&gt;pl_len = FCP_RESP_WITH_EXT;</span>
 		fcp_rsp = (struct fcp_resp_with_ext *)
 				&amp;(fsf-&gt;qtcb-&gt;bottom.io.fcp_rsp);
<span class="p_add">+		/* mandatory parts of FCP_RSP IU in this SCSI record */</span>
 		memcpy(&amp;rec-&gt;fcp_rsp, fcp_rsp, FCP_RESP_WITH_EXT);
 		if (fcp_rsp-&gt;resp.fr_flags &amp; FCP_RSP_LEN_VAL) {
 			fcp_rsp_info = (struct fcp_resp_rsp_info *) &amp;fcp_rsp[1];
 			rec-&gt;fcp_rsp_info = fcp_rsp_info-&gt;rsp_code;
<span class="p_add">+			rec-&gt;pl_len += be32_to_cpu(fcp_rsp-&gt;ext.fr_rsp_len);</span>
 		}
 		if (fcp_rsp-&gt;resp.fr_flags &amp; FCP_SNS_LEN_VAL) {
<span class="p_del">-			rec-&gt;pl_len = min((u16)SCSI_SENSE_BUFFERSIZE,</span>
<span class="p_del">-					  (u16)ZFCP_DBF_PAY_MAX_REC);</span>
<span class="p_del">-			zfcp_dbf_pl_write(dbf, sc-&gt;sense_buffer, rec-&gt;pl_len,</span>
<span class="p_del">-					  &quot;fcp_sns&quot;, fsf-&gt;req_id);</span>
<span class="p_add">+			rec-&gt;pl_len += be32_to_cpu(fcp_rsp-&gt;ext.fr_sns_len);</span>
 		}
<span class="p_add">+		/* complete FCP_RSP IU in associated PAYload record</span>
<span class="p_add">+		 * but only if there are optional parts</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (fcp_rsp-&gt;resp.fr_flags != 0)</span>
<span class="p_add">+			zfcp_dbf_pl_write(</span>
<span class="p_add">+				dbf, fcp_rsp,</span>
<span class="p_add">+				/* at least one full PAY record</span>
<span class="p_add">+				 * but not beyond hardware response field</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				min_t(u16, max_t(u16, rec-&gt;pl_len,</span>
<span class="p_add">+						 ZFCP_DBF_PAY_MAX_REC),</span>
<span class="p_add">+				      FSF_FCP_RSP_SIZE),</span>
<span class="p_add">+				&quot;fcp_riu&quot;, fsf-&gt;req_id);</span>
 	}
 
 	debug_event(dbf-&gt;scsi, level, rec, sizeof(*rec));
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">index db186d44cfaf..b60667c145fd 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
  * zfcp device driver
  * debug feature declarations
  *
<span class="p_del">- * Copyright IBM Corp. 2008, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2008, 2017</span>
  */
 
 #ifndef ZFCP_DBF_H
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> enum zfcp_dbf_scsi_id {</span>
  * @id: unique number of recovery record type
  * @tag: identifier string specifying the location of initiation
  * @scsi_id: scsi device id
<span class="p_del">- * @scsi_lun: scsi device logical unit number</span>
<span class="p_add">+ * @scsi_lun: scsi device logical unit number, low part of 64 bit, old 32 bit</span>
  * @scsi_result: scsi result
  * @scsi_retries: current retry number of scsi request
  * @scsi_allowed: allowed retries
<span class="p_chunk">@@ -214,6 +214,7 @@</span> <span class="p_context"> enum zfcp_dbf_scsi_id {</span>
  * @host_scribble: LLD specific data attached to SCSI request
  * @pl_len: length of paload stored as zfcp_dbf_pay
  * @fsf_rsp: response for fsf request
<span class="p_add">+ * @scsi_lun_64_hi: scsi device logical unit number, high part of 64 bit</span>
  */
 struct zfcp_dbf_scsi {
 	u8 id;
<span class="p_chunk">@@ -230,6 +231,7 @@</span> <span class="p_context"> struct zfcp_dbf_scsi {</span>
 	u64 host_scribble;
 	u16 pl_len;
 	struct fcp_resp_with_ext fcp_rsp;
<span class="p_add">+	u32 scsi_lun_64_hi;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -323,7 +325,11 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)</span>
 {
 	struct fsf_qtcb *qtcb = req-&gt;qtcb;
 
<span class="p_del">-	if ((qtcb-&gt;prefix.prot_status != FSF_PROT_GOOD) &amp;&amp;</span>
<span class="p_add">+	if (unlikely(req-&gt;status &amp; (ZFCP_STATUS_FSFREQ_DISMISSED |</span>
<span class="p_add">+				    ZFCP_STATUS_FSFREQ_ERROR))) {</span>
<span class="p_add">+		zfcp_dbf_hba_fsf_resp(&quot;fs_rerr&quot;, 3, req);</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if ((qtcb-&gt;prefix.prot_status != FSF_PROT_GOOD) &amp;&amp;</span>
 	    (qtcb-&gt;prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {
 		zfcp_dbf_hba_fsf_resp(&quot;fs_perr&quot;, 1, req);
 
<span class="p_chunk">@@ -401,7 +407,8 @@</span> <span class="p_context"> void zfcp_dbf_scsi_abort(char *tag, struct scsi_cmnd *scmd,</span>
  * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
  */
 static inline
<span class="p_del">-void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)</span>
<span class="p_add">+void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag,</span>
<span class="p_add">+			    struct zfcp_fsf_req *fsf_req)</span>
 {
 	char tmp_tag[ZFCP_DBF_TAG_LEN];
 
<span class="p_chunk">@@ -411,7 +418,7 @@</span> <span class="p_context"> void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)</span>
 		memcpy(tmp_tag, &quot;lr_&quot;, 3);
 
 	memcpy(&amp;tmp_tag[3], tag, 4);
<span class="p_del">-	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, NULL);</span>
<span class="p_add">+	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, fsf_req);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fc.h b/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_header">index df2b541c8287..a2275825186f 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_chunk">@@ -4,7 +4,7 @@</span> <span class="p_context"></span>
  * Fibre Channel related definitions and inline functions for the zfcp
  * device driver
  *
<span class="p_del">- * Copyright IBM Corp. 2009</span>
<span class="p_add">+ * Copyright IBM Corp. 2009, 2017</span>
  */
 
 #ifndef ZFCP_FC_H
<span class="p_chunk">@@ -279,6 +279,10 @@</span> <span class="p_context"> void zfcp_fc_eval_fcp_rsp(struct fcp_resp_with_ext *fcp_rsp,</span>
 		     !(rsp_flags &amp; FCP_SNS_LEN_VAL) &amp;&amp;
 		     fcp_rsp-&gt;resp.fr_status == SAM_STAT_GOOD)
 			set_host_byte(scsi, DID_ERROR);
<span class="p_add">+	} else if (unlikely(rsp_flags &amp; FCP_RESID_OVER)) {</span>
<span class="p_add">+		/* FCP_DL was not sufficient for SCSI data length */</span>
<span class="p_add">+		if (fcp_rsp-&gt;resp.fr_status == SAM_STAT_GOOD)</span>
<span class="p_add">+			set_host_byte(scsi, DID_ERROR);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">index 27ff38f839fc..1964391db904 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_chunk">@@ -928,8 +928,8 @@</span> <span class="p_context"> static void zfcp_fsf_send_ct_handler(struct zfcp_fsf_req *req)</span>
 
 	switch (header-&gt;fsf_status) {
         case FSF_GOOD:
<span class="p_del">-		zfcp_dbf_san_res(&quot;fsscth2&quot;, req);</span>
 		ct-&gt;status = 0;
<span class="p_add">+		zfcp_dbf_san_res(&quot;fsscth2&quot;, req);</span>
 		break;
         case FSF_SERVICE_CLASS_NOT_SUPPORTED:
 		zfcp_fsf_class_not_supp(req);
<span class="p_chunk">@@ -1109,8 +1109,8 @@</span> <span class="p_context"> static void zfcp_fsf_send_els_handler(struct zfcp_fsf_req *req)</span>
 
 	switch (header-&gt;fsf_status) {
 	case FSF_GOOD:
<span class="p_del">-		zfcp_dbf_san_res(&quot;fsselh1&quot;, req);</span>
 		send_els-&gt;status = 0;
<span class="p_add">+		zfcp_dbf_san_res(&quot;fsselh1&quot;, req);</span>
 		break;
 	case FSF_SERVICE_CLASS_NOT_SUPPORTED:
 		zfcp_fsf_class_not_supp(req);
<span class="p_chunk">@@ -2258,7 +2258,8 @@</span> <span class="p_context"> int zfcp_fsf_fcp_cmnd(struct scsi_cmnd *scsi_cmnd)</span>
 	fcp_cmnd = (struct fcp_cmnd *) &amp;req-&gt;qtcb-&gt;bottom.io.fcp_cmnd;
 	zfcp_fc_scsi_to_fcp(fcp_cmnd, scsi_cmnd, 0);
 
<span class="p_del">-	if (scsi_prot_sg_count(scsi_cmnd)) {</span>
<span class="p_add">+	if ((scsi_get_prot_op(scsi_cmnd) != SCSI_PROT_NORMAL) &amp;&amp;</span>
<span class="p_add">+	    scsi_prot_sg_count(scsi_cmnd)) {</span>
 		zfcp_qdio_set_data_div(qdio, &amp;req-&gt;qdio_req,
 				       scsi_prot_sg_count(scsi_cmnd));
 		retval = zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req,
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index 07ffdbb5107f..9bd9b9a29dfc 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to Linux SCSI midlayer.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2017</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -273,25 +273,29 @@</span> <span class="p_context"> static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)</span>
 
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			zfcp_dbf_scsi_devreset(&quot;fiof&quot;, scpnt, tm_flags, NULL);</span>
 			return ret;
<span class="p_add">+		}</span>
 
 		if (!(atomic_read(&amp;adapter-&gt;status) &amp;
 		      ZFCP_STATUS_COMMON_RUNNING)) {
<span class="p_del">-			zfcp_dbf_scsi_devreset(&quot;nres&quot;, scpnt, tm_flags);</span>
<span class="p_add">+			zfcp_dbf_scsi_devreset(&quot;nres&quot;, scpnt, tm_flags, NULL);</span>
 			return SUCCESS;
 		}
 	}
<span class="p_del">-	if (!fsf_req)</span>
<span class="p_add">+	if (!fsf_req) {</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;reqf&quot;, scpnt, tm_flags, NULL);</span>
 		return FAILED;
<span class="p_add">+	}</span>
 
 	wait_for_completion(&amp;fsf_req-&gt;completion);
 
 	if (fsf_req-&gt;status &amp; ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
<span class="p_del">-		zfcp_dbf_scsi_devreset(&quot;fail&quot;, scpnt, tm_flags);</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;fail&quot;, scpnt, tm_flags, fsf_req);</span>
 		retval = FAILED;
 	} else {
<span class="p_del">-		zfcp_dbf_scsi_devreset(&quot;okay&quot;, scpnt, tm_flags);</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;okay&quot;, scpnt, tm_flags, fsf_req);</span>
 		zfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);
 	}
 
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 17c440b9d086..6835bae33ec4 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -1824,9 +1824,12 @@</span> <span class="p_context"> static void megasas_complete_outstanding_ioctls(struct megasas_instance *instanc</span>
 			if (cmd_fusion-&gt;sync_cmd_idx != (u32)ULONG_MAX) {
 				cmd_mfi = instance-&gt;cmd_list[cmd_fusion-&gt;sync_cmd_idx];
 				if (cmd_mfi-&gt;sync_cmd &amp;&amp;
<span class="p_del">-					cmd_mfi-&gt;frame-&gt;hdr.cmd != MFI_CMD_ABORT)</span>
<span class="p_add">+				    (cmd_mfi-&gt;frame-&gt;hdr.cmd != MFI_CMD_ABORT)) {</span>
<span class="p_add">+					cmd_mfi-&gt;frame-&gt;hdr.cmd_status =</span>
<span class="p_add">+							MFI_STAT_WRONG_STATE;</span>
 					megasas_complete_cmd(instance,
 							     cmd_mfi, DID_OK);
<span class="p_add">+				}</span>
 			}
 		}
 	} else {
<span class="p_chunk">@@ -5094,6 +5097,14 @@</span> <span class="p_context"> megasas_register_aen(struct megasas_instance *instance, u32 seq_num,</span>
 		prev_aen.word =
 			le32_to_cpu(instance-&gt;aen_cmd-&gt;frame-&gt;dcmd.mbox.w[1]);
 
<span class="p_add">+		if ((curr_aen.members.class &lt; MFI_EVT_CLASS_DEBUG) ||</span>
<span class="p_add">+		    (curr_aen.members.class &gt; MFI_EVT_CLASS_DEAD)) {</span>
<span class="p_add">+			dev_info(&amp;instance-&gt;pdev-&gt;dev,</span>
<span class="p_add">+				 &quot;%s %d out of range class %d send by application\n&quot;,</span>
<span class="p_add">+				 __func__, __LINE__, curr_aen.members.class);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/*
 		 * A class whose enum value is smaller is inclusive of all
 		 * higher values. If a PROGRESS (= -1) was previously
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">index 1ed85dfc008d..ac12ee844bfc 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_chunk">@@ -404,6 +404,8 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		return -EINVAL;
 	if (start &gt; ha-&gt;optrom_size)
 		return -EINVAL;
<span class="p_add">+	if (size &gt; ha-&gt;optrom_size - start)</span>
<span class="p_add">+		size = ha-&gt;optrom_size - start;</span>
 
 	mutex_lock(&amp;ha-&gt;optrom_mutex);
 	switch (val) {
<span class="p_chunk">@@ -429,8 +431,7 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		}
 
 		ha-&gt;optrom_region_start = start;
<span class="p_del">-		ha-&gt;optrom_region_size = start + size &gt; ha-&gt;optrom_size ?</span>
<span class="p_del">-		    ha-&gt;optrom_size - start : size;</span>
<span class="p_add">+		ha-&gt;optrom_region_size = start + size;</span>
 
 		ha-&gt;optrom_state = QLA_SREADING;
 		ha-&gt;optrom_buffer = vmalloc(ha-&gt;optrom_region_size);
<span class="p_chunk">@@ -503,8 +504,7 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		}
 
 		ha-&gt;optrom_region_start = start;
<span class="p_del">-		ha-&gt;optrom_region_size = start + size &gt; ha-&gt;optrom_size ?</span>
<span class="p_del">-		    ha-&gt;optrom_size - start : size;</span>
<span class="p_add">+		ha-&gt;optrom_region_size = start + size;</span>
 
 		ha-&gt;optrom_state = QLA_SWRITING;
 		ha-&gt;optrom_buffer = vmalloc(ha-&gt;optrom_region_size);
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index 71325972e503..39e8b5dc23fa 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> struct sg_device;		/* forward declarations */</span>
 struct sg_fd;
 
 typedef struct sg_request {	/* SG_MAX_QUEUE requests outstanding per file */
<span class="p_del">-	struct sg_request *nextrp;	/* NULL -&gt; tail request (slist) */</span>
<span class="p_add">+	struct list_head entry;	/* list entry */</span>
 	struct sg_fd *parentfp;	/* NULL -&gt; not in use */
 	Sg_scatter_hold data;	/* hold buffer, perhaps scatter list */
 	sg_io_hdr_t header;	/* scsi command+info, see &lt;scsi/sg.h&gt; */
<span class="p_chunk">@@ -157,8 +157,7 @@</span> <span class="p_context"> typedef struct sg_fd {		/* holds the state of a file descriptor */</span>
 	int timeout;		/* defaults to SG_DEFAULT_TIMEOUT      */
 	int timeout_user;	/* defaults to SG_DEFAULT_TIMEOUT_USER */
 	Sg_scatter_hold reserve;	/* buffer held for this file descriptor */
<span class="p_del">-	unsigned save_scat_len;	/* original length of trunc. scat. element */</span>
<span class="p_del">-	Sg_request *headrp;	/* head of request slist, NULL-&gt;empty */</span>
<span class="p_add">+	struct list_head rq_list; /* head of request list */</span>
 	struct fasync_struct *async_qp;	/* used by asynchronous notification */
 	Sg_request req_arr[SG_MAX_QUEUE];	/* used as singly-linked list */
 	char low_dma;		/* as in parent but possibly overridden to 1 */
<span class="p_chunk">@@ -840,6 +839,39 @@</span> <span class="p_context"> static int max_sectors_bytes(struct request_queue *q)</span>
 	return max_sectors &lt;&lt; 9;
 }
 
<span class="p_add">+static void</span>
<span class="p_add">+sg_fill_request_table(Sg_fd *sfp, sg_req_info_t *rinfo)</span>
<span class="p_add">+{</span>
<span class="p_add">+	Sg_request *srp;</span>
<span class="p_add">+	int val;</span>
<span class="p_add">+	unsigned int ms;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = 0;</span>
<span class="p_add">+	list_for_each_entry(srp, &amp;sfp-&gt;rq_list, entry) {</span>
<span class="p_add">+		if (val &gt; SG_MAX_QUEUE)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		rinfo[val].req_state = srp-&gt;done + 1;</span>
<span class="p_add">+		rinfo[val].problem =</span>
<span class="p_add">+			srp-&gt;header.masked_status &amp;</span>
<span class="p_add">+			srp-&gt;header.host_status &amp;</span>
<span class="p_add">+			srp-&gt;header.driver_status;</span>
<span class="p_add">+		if (srp-&gt;done)</span>
<span class="p_add">+			rinfo[val].duration =</span>
<span class="p_add">+				srp-&gt;header.duration;</span>
<span class="p_add">+		else {</span>
<span class="p_add">+			ms = jiffies_to_msecs(jiffies);</span>
<span class="p_add">+			rinfo[val].duration =</span>
<span class="p_add">+				(ms &gt; srp-&gt;header.duration) ?</span>
<span class="p_add">+				(ms - srp-&gt;header.duration) : 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		rinfo[val].orphan = srp-&gt;orphan;</span>
<span class="p_add">+		rinfo[val].sg_io_owned = srp-&gt;sg_io_owned;</span>
<span class="p_add">+		rinfo[val].pack_id = srp-&gt;header.pack_id;</span>
<span class="p_add">+		rinfo[val].usr_ptr = srp-&gt;header.usr_ptr;</span>
<span class="p_add">+		val++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static long
 sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)
 {
<span class="p_chunk">@@ -951,7 +983,7 @@</span> <span class="p_context"> sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)</span>
 		if (!access_ok(VERIFY_WRITE, ip, sizeof (int)))
 			return -EFAULT;
 		read_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-		for (srp = sfp-&gt;headrp; srp; srp = srp-&gt;nextrp) {</span>
<span class="p_add">+		list_for_each_entry(srp, &amp;sfp-&gt;rq_list, entry) {</span>
 			if ((1 == srp-&gt;done) &amp;&amp; (!srp-&gt;sg_io_owned)) {
 				read_unlock_irqrestore(&amp;sfp-&gt;rq_list_lock,
 						       iflags);
<span class="p_chunk">@@ -964,7 +996,8 @@</span> <span class="p_context"> sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)</span>
 		return 0;
 	case SG_GET_NUM_WAITING:
 		read_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-		for (val = 0, srp = sfp-&gt;headrp; srp; srp = srp-&gt;nextrp) {</span>
<span class="p_add">+		val = 0;</span>
<span class="p_add">+		list_for_each_entry(srp, &amp;sfp-&gt;rq_list, entry) {</span>
 			if ((1 == srp-&gt;done) &amp;&amp; (!srp-&gt;sg_io_owned))
 				++val;
 		}
<span class="p_chunk">@@ -1032,42 +1065,15 @@</span> <span class="p_context"> sg_ioctl(struct file *filp, unsigned int cmd_in, unsigned long arg)</span>
 			return -EFAULT;
 		else {
 			sg_req_info_t *rinfo;
<span class="p_del">-			unsigned int ms;</span>
 
<span class="p_del">-			rinfo = kmalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,</span>
<span class="p_del">-								GFP_KERNEL);</span>
<span class="p_add">+			rinfo = kzalloc(SZ_SG_REQ_INFO * SG_MAX_QUEUE,</span>
<span class="p_add">+					GFP_KERNEL);</span>
 			if (!rinfo)
 				return -ENOMEM;
 			read_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-			for (srp = sfp-&gt;headrp, val = 0; val &lt; SG_MAX_QUEUE;</span>
<span class="p_del">-			     ++val, srp = srp ? srp-&gt;nextrp : srp) {</span>
<span class="p_del">-				memset(&amp;rinfo[val], 0, SZ_SG_REQ_INFO);</span>
<span class="p_del">-				if (srp) {</span>
<span class="p_del">-					rinfo[val].req_state = srp-&gt;done + 1;</span>
<span class="p_del">-					rinfo[val].problem =</span>
<span class="p_del">-					    srp-&gt;header.masked_status &amp; </span>
<span class="p_del">-					    srp-&gt;header.host_status &amp; </span>
<span class="p_del">-					    srp-&gt;header.driver_status;</span>
<span class="p_del">-					if (srp-&gt;done)</span>
<span class="p_del">-						rinfo[val].duration =</span>
<span class="p_del">-							srp-&gt;header.duration;</span>
<span class="p_del">-					else {</span>
<span class="p_del">-						ms = jiffies_to_msecs(jiffies);</span>
<span class="p_del">-						rinfo[val].duration =</span>
<span class="p_del">-						    (ms &gt; srp-&gt;header.duration) ?</span>
<span class="p_del">-						    (ms - srp-&gt;header.duration) : 0;</span>
<span class="p_del">-					}</span>
<span class="p_del">-					rinfo[val].orphan = srp-&gt;orphan;</span>
<span class="p_del">-					rinfo[val].sg_io_owned =</span>
<span class="p_del">-							srp-&gt;sg_io_owned;</span>
<span class="p_del">-					rinfo[val].pack_id =</span>
<span class="p_del">-							srp-&gt;header.pack_id;</span>
<span class="p_del">-					rinfo[val].usr_ptr =</span>
<span class="p_del">-							srp-&gt;header.usr_ptr;</span>
<span class="p_del">-				}</span>
<span class="p_del">-			}</span>
<span class="p_add">+			sg_fill_request_table(sfp, rinfo);</span>
 			read_unlock_irqrestore(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-			result = __copy_to_user(p, rinfo, </span>
<span class="p_add">+			result = __copy_to_user(p, rinfo,</span>
 						SZ_SG_REQ_INFO * SG_MAX_QUEUE);
 			result = result ? -EFAULT : 0;
 			kfree(rinfo);
<span class="p_chunk">@@ -1173,7 +1179,7 @@</span> <span class="p_context"> sg_poll(struct file *filp, poll_table * wait)</span>
 		return POLLERR;
 	poll_wait(filp, &amp;sfp-&gt;read_wait, wait);
 	read_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-	for (srp = sfp-&gt;headrp; srp; srp = srp-&gt;nextrp) {</span>
<span class="p_add">+	list_for_each_entry(srp, &amp;sfp-&gt;rq_list, entry) {</span>
 		/* if any read waiting, flag it */
 		if ((0 == res) &amp;&amp; (1 == srp-&gt;done) &amp;&amp; (!srp-&gt;sg_io_owned))
 			res = POLLIN | POLLRDNORM;
<span class="p_chunk">@@ -2059,7 +2065,6 @@</span> <span class="p_context"> sg_unlink_reserve(Sg_fd * sfp, Sg_request * srp)</span>
 	req_schp-&gt;pages = NULL;
 	req_schp-&gt;page_order = 0;
 	req_schp-&gt;sglist_len = 0;
<span class="p_del">-	sfp-&gt;save_scat_len = 0;</span>
 	srp-&gt;res_used = 0;
 	/* Called without mutex lock to avoid deadlock */
 	sfp-&gt;res_in_use = 0;
<span class="p_chunk">@@ -2072,7 +2077,7 @@</span> <span class="p_context"> sg_get_rq_mark(Sg_fd * sfp, int pack_id)</span>
 	unsigned long iflags;
 
 	write_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-	for (resp = sfp-&gt;headrp; resp; resp = resp-&gt;nextrp) {</span>
<span class="p_add">+	list_for_each_entry(resp, &amp;sfp-&gt;rq_list, entry) {</span>
 		/* look for requests that are ready + not SG_IO owned */
 		if ((1 == resp-&gt;done) &amp;&amp; (!resp-&gt;sg_io_owned) &amp;&amp;
 		    ((-1 == pack_id) || (resp-&gt;header.pack_id == pack_id))) {
<span class="p_chunk">@@ -2090,70 +2095,45 @@</span> <span class="p_context"> sg_add_request(Sg_fd * sfp)</span>
 {
 	int k;
 	unsigned long iflags;
<span class="p_del">-	Sg_request *resp;</span>
 	Sg_request *rp = sfp-&gt;req_arr;
 
 	write_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-	resp = sfp-&gt;headrp;</span>
<span class="p_del">-	if (!resp) {</span>
<span class="p_del">-		memset(rp, 0, sizeof (Sg_request));</span>
<span class="p_del">-		rp-&gt;parentfp = sfp;</span>
<span class="p_del">-		resp = rp;</span>
<span class="p_del">-		sfp-&gt;headrp = resp;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (0 == sfp-&gt;cmd_q)</span>
<span class="p_del">-			resp = NULL;	/* command queuing disallowed */</span>
<span class="p_del">-		else {</span>
<span class="p_del">-			for (k = 0; k &lt; SG_MAX_QUEUE; ++k, ++rp) {</span>
<span class="p_del">-				if (!rp-&gt;parentfp)</span>
<span class="p_del">-					break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (k &lt; SG_MAX_QUEUE) {</span>
<span class="p_del">-				memset(rp, 0, sizeof (Sg_request));</span>
<span class="p_del">-				rp-&gt;parentfp = sfp;</span>
<span class="p_del">-				while (resp-&gt;nextrp)</span>
<span class="p_del">-					resp = resp-&gt;nextrp;</span>
<span class="p_del">-				resp-&gt;nextrp = rp;</span>
<span class="p_del">-				resp = rp;</span>
<span class="p_del">-			} else</span>
<span class="p_del">-				resp = NULL;</span>
<span class="p_add">+	if (!list_empty(&amp;sfp-&gt;rq_list)) {</span>
<span class="p_add">+		if (!sfp-&gt;cmd_q)</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (k = 0; k &lt; SG_MAX_QUEUE; ++k, ++rp) {</span>
<span class="p_add">+			if (!rp-&gt;parentfp)</span>
<span class="p_add">+				break;</span>
 		}
<span class="p_add">+		if (k &gt;= SG_MAX_QUEUE)</span>
<span class="p_add">+			goto out_unlock;</span>
 	}
<span class="p_del">-	if (resp) {</span>
<span class="p_del">-		resp-&gt;nextrp = NULL;</span>
<span class="p_del">-		resp-&gt;header.duration = jiffies_to_msecs(jiffies);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	memset(rp, 0, sizeof (Sg_request));</span>
<span class="p_add">+	rp-&gt;parentfp = sfp;</span>
<span class="p_add">+	rp-&gt;header.duration = jiffies_to_msecs(jiffies);</span>
<span class="p_add">+	list_add_tail(&amp;rp-&gt;entry, &amp;sfp-&gt;rq_list);</span>
 	write_unlock_irqrestore(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-	return resp;</span>
<span class="p_add">+	return rp;</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	write_unlock_irqrestore(&amp;sfp-&gt;rq_list_lock, iflags);</span>
<span class="p_add">+	return NULL;</span>
 }
 
 /* Return of 1 for found; 0 for not found */
 static int
 sg_remove_request(Sg_fd * sfp, Sg_request * srp)
 {
<span class="p_del">-	Sg_request *prev_rp;</span>
<span class="p_del">-	Sg_request *rp;</span>
 	unsigned long iflags;
 	int res = 0;
 
<span class="p_del">-	if ((!sfp) || (!srp) || (!sfp-&gt;headrp))</span>
<span class="p_add">+	if (!sfp || !srp || list_empty(&amp;sfp-&gt;rq_list))</span>
 		return res;
 	write_lock_irqsave(&amp;sfp-&gt;rq_list_lock, iflags);
<span class="p_del">-	prev_rp = sfp-&gt;headrp;</span>
<span class="p_del">-	if (srp == prev_rp) {</span>
<span class="p_del">-		sfp-&gt;headrp = prev_rp-&gt;nextrp;</span>
<span class="p_del">-		prev_rp-&gt;parentfp = NULL;</span>
<span class="p_add">+	if (!list_empty(&amp;srp-&gt;entry)) {</span>
<span class="p_add">+		list_del(&amp;srp-&gt;entry);</span>
<span class="p_add">+		srp-&gt;parentfp = NULL;</span>
 		res = 1;
<span class="p_del">-	} else {</span>
<span class="p_del">-		while ((rp = prev_rp-&gt;nextrp)) {</span>
<span class="p_del">-			if (srp == rp) {</span>
<span class="p_del">-				prev_rp-&gt;nextrp = rp-&gt;nextrp;</span>
<span class="p_del">-				rp-&gt;parentfp = NULL;</span>
<span class="p_del">-				res = 1;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			prev_rp = rp;</span>
<span class="p_del">-		}</span>
 	}
 	write_unlock_irqrestore(&amp;sfp-&gt;rq_list_lock, iflags);
 	return res;
<span class="p_chunk">@@ -2172,7 +2152,7 @@</span> <span class="p_context"> sg_add_sfp(Sg_device * sdp)</span>
 
 	init_waitqueue_head(&amp;sfp-&gt;read_wait);
 	rwlock_init(&amp;sfp-&gt;rq_list_lock);
<span class="p_del">-</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;sfp-&gt;rq_list);</span>
 	kref_init(&amp;sfp-&gt;f_ref);
 	mutex_init(&amp;sfp-&gt;f_mutex);
 	sfp-&gt;timeout = SG_DEFAULT_TIMEOUT;
<span class="p_chunk">@@ -2213,10 +2193,13 @@</span> <span class="p_context"> sg_remove_sfp_usercontext(struct work_struct *work)</span>
 {
 	struct sg_fd *sfp = container_of(work, struct sg_fd, ew.work);
 	struct sg_device *sdp = sfp-&gt;parentdp;
<span class="p_add">+	Sg_request *srp;</span>
 
 	/* Cleanup any responses which were never read(). */
<span class="p_del">-	while (sfp-&gt;headrp)</span>
<span class="p_del">-		sg_finish_rem_req(sfp-&gt;headrp);</span>
<span class="p_add">+	while (!list_empty(&amp;sfp-&gt;rq_list)) {</span>
<span class="p_add">+		srp = list_first_entry(&amp;sfp-&gt;rq_list, Sg_request, entry);</span>
<span class="p_add">+		sg_finish_rem_req(srp);</span>
<span class="p_add">+	}</span>
 
 	if (sfp-&gt;reserve.bufflen &gt; 0) {
 		SCSI_LOG_TIMEOUT(6, sg_printk(KERN_INFO, sdp,
<span class="p_chunk">@@ -2619,7 +2602,7 @@</span> <span class="p_context"> static int sg_proc_seq_show_devstrs(struct seq_file *s, void *v)</span>
 /* must be called while holding sg_index_lock */
 static void sg_proc_debug_helper(struct seq_file *s, Sg_device * sdp)
 {
<span class="p_del">-	int k, m, new_interface, blen, usg;</span>
<span class="p_add">+	int k, new_interface, blen, usg;</span>
 	Sg_request *srp;
 	Sg_fd *fp;
 	const sg_io_hdr_t *hp;
<span class="p_chunk">@@ -2639,13 +2622,11 @@</span> <span class="p_context"> static void sg_proc_debug_helper(struct seq_file *s, Sg_device * sdp)</span>
 		seq_printf(s, &quot;   cmd_q=%d f_packid=%d k_orphan=%d closed=0\n&quot;,
 			   (int) fp-&gt;cmd_q, (int) fp-&gt;force_packid,
 			   (int) fp-&gt;keep_orphan);
<span class="p_del">-		for (m = 0, srp = fp-&gt;headrp;</span>
<span class="p_del">-				srp != NULL;</span>
<span class="p_del">-				++m, srp = srp-&gt;nextrp) {</span>
<span class="p_add">+		list_for_each_entry(srp, &amp;fp-&gt;rq_list, entry) {</span>
 			hp = &amp;srp-&gt;header;
 			new_interface = (hp-&gt;interface_id == &#39;\0&#39;) ? 0 : 1;
 			if (srp-&gt;res_used) {
<span class="p_del">-				if (new_interface &amp;&amp; </span>
<span class="p_add">+				if (new_interface &amp;&amp;</span>
 				    (SG_FLAG_MMAP_IO &amp; hp-&gt;flags))
 					cp = &quot;     mmap&gt;&gt; &quot;;
 				else
<span class="p_chunk">@@ -2676,7 +2657,7 @@</span> <span class="p_context"> static void sg_proc_debug_helper(struct seq_file *s, Sg_device * sdp)</span>
 			seq_printf(s, &quot;ms sgat=%d op=0x%02x\n&quot;, usg,
 				   (int) srp-&gt;data.cmd_opcode);
 		}
<span class="p_del">-		if (0 == m)</span>
<span class="p_add">+		if (list_empty(&amp;fp-&gt;rq_list))</span>
 			seq_puts(s, &quot;     No requests active\n&quot;);
 		read_unlock(&amp;fp-&gt;rq_list_lock);
 	}
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index cd5c1c060481..6df2841cb7f9 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -1511,6 +1511,8 @@</span> <span class="p_context"> static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)</span>
 	ret = storvsc_do_io(dev, cmd_request);
 
 	if (ret == -EAGAIN) {
<span class="p_add">+		if (payload_sz &gt; sizeof(cmd_request-&gt;mpb))</span>
<span class="p_add">+			kfree(payload);</span>
 		/* no more space */
 		return SCSI_MLQUEUE_DEVICE_BUSY;
 	}
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index fb31eecb708d..8f3566cde3eb 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -361,6 +361,32 @@</span> <span class="p_context"> int tty_insert_flip_string_flags(struct tty_port *port,</span>
 }
 EXPORT_SYMBOL(tty_insert_flip_string_flags);
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	__tty_insert_flip_char   -	Add one character to the tty buffer</span>
<span class="p_add">+ *	@port: tty port</span>
<span class="p_add">+ *	@ch: character</span>
<span class="p_add">+ *	@flag: flag byte</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Queue a single byte to the tty buffering, with an optional flag.</span>
<span class="p_add">+ *	This is the slow path of tty_insert_flip_char.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __tty_insert_flip_char(struct tty_port *port, unsigned char ch, char flag)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct tty_buffer *tb;</span>
<span class="p_add">+	int flags = (flag == TTY_NORMAL) ? TTYB_NORMAL : 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!__tty_buffer_request_room(port, 1, flags))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	tb = port-&gt;buf.tail;</span>
<span class="p_add">+	if (~tb-&gt;flags &amp; TTYB_NORMAL)</span>
<span class="p_add">+		*flag_buf_ptr(tb, tb-&gt;used) = flag;</span>
<span class="p_add">+	*char_buf_ptr(tb, tb-&gt;used++) = ch;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__tty_insert_flip_char);</span>
<span class="p_add">+</span>
 /**
  *	tty_schedule_flip	-	push characters to ldisc
  *	@port: tty port to push from
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 68345a9e59b8..32941cd6d34b 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -2205,6 +2205,7 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 	unsigned int s_flags = sb-&gt;s_flags;
 	int nr_orphans = 0, nr_truncates = 0;
 #ifdef CONFIG_QUOTA
<span class="p_add">+	int quota_update = 0;</span>
 	int i;
 #endif
 	if (!es-&gt;s_last_orphan) {
<span class="p_chunk">@@ -2243,14 +2244,32 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 #ifdef CONFIG_QUOTA
 	/* Needed for iput() to work correctly and not trash data */
 	sb-&gt;s_flags |= MS_ACTIVE;
<span class="p_del">-	/* Turn on quotas so that they are updated correctly */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Turn on quotas which were not enabled for read-only mounts if</span>
<span class="p_add">+	 * filesystem has quota feature, so that they are updated correctly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ext4_has_feature_quota(sb) &amp;&amp; (s_flags &amp; MS_RDONLY)) {</span>
<span class="p_add">+		int ret = ext4_enable_quotas(sb);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			quota_update = 1;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR,</span>
<span class="p_add">+				&quot;Cannot turn on quotas: error %d&quot;, ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on journaled quotas used for old sytle */</span>
 	for (i = 0; i &lt; EXT4_MAXQUOTAS; i++) {
 		if (EXT4_SB(sb)-&gt;s_qf_names[i]) {
 			int ret = ext4_quota_on_mount(sb, i);
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				quota_update = 1;</span>
<span class="p_add">+			else</span>
 				ext4_msg(sb, KERN_ERR,
 					&quot;Cannot turn on journaled &quot;
<span class="p_del">-					&quot;quota: error %d&quot;, ret);</span>
<span class="p_add">+					&quot;quota: type %d: error %d&quot;, i, ret);</span>
 		}
 	}
 #endif
<span class="p_chunk">@@ -2309,10 +2328,12 @@</span> <span class="p_context"> static void ext4_orphan_cleanup(struct super_block *sb,</span>
 		ext4_msg(sb, KERN_INFO, &quot;%d truncate%s cleaned up&quot;,
 		       PLURAL(nr_truncates));
 #ifdef CONFIG_QUOTA
<span class="p_del">-	/* Turn quotas off */</span>
<span class="p_del">-	for (i = 0; i &lt; EXT4_MAXQUOTAS; i++) {</span>
<span class="p_del">-		if (sb_dqopt(sb)-&gt;files[i])</span>
<span class="p_del">-			dquot_quota_off(sb, i);</span>
<span class="p_add">+	/* Turn off quotas if they were enabled for orphan cleanup */</span>
<span class="p_add">+	if (quota_update) {</span>
<span class="p_add">+		for (i = 0; i &lt; EXT4_MAXQUOTAS; i++) {</span>
<span class="p_add">+			if (sb_dqopt(sb)-&gt;files[i])</span>
<span class="p_add">+				dquot_quota_off(sb, i);</span>
<span class="p_add">+		}</span>
 	}
 #endif
 	sb-&gt;s_flags = s_flags; /* Restore MS_RDONLY status */
<span class="p_chunk">@@ -5120,6 +5141,9 @@</span> <span class="p_context"> static int ext4_enable_quotas(struct super_block *sb)</span>
 			err = ext4_quota_enable(sb, type, QFMT_VFS_V1,
 						DQUOT_USAGE_ENABLED);
 			if (err) {
<span class="p_add">+				for (type--; type &gt;= 0; type--)</span>
<span class="p_add">+					dquot_quota_off(sb, type);</span>
<span class="p_add">+</span>
 				ext4_warning(sb,
 					&quot;Failed to enable quota tracking &quot;
 					&quot;(type=%d, err=%d). Please run &quot;
<span class="p_header">diff --git a/fs/f2fs/recovery.c b/fs/f2fs/recovery.c</span>
<span class="p_header">index cbf74f47cce8..e32f349f341b 100644</span>
<span class="p_header">--- a/fs/f2fs/recovery.c</span>
<span class="p_header">+++ b/fs/f2fs/recovery.c</span>
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> static int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,</span>
 		return 0;
 
 	/* Get the previous summary */
<span class="p_del">-	for (i = CURSEG_WARM_DATA; i &lt;= CURSEG_COLD_DATA; i++) {</span>
<span class="p_add">+	for (i = CURSEG_HOT_DATA; i &lt;= CURSEG_COLD_DATA; i++) {</span>
 		struct curseg_info *curseg = CURSEG_I(sbi, i);
 		if (curseg-&gt;segno == segno) {
 			sum = curseg-&gt;sum_blk-&gt;entries[blkoff];
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index c7f1ce41442a..9e5a6842346e 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -1145,9 +1145,7 @@</span> <span class="p_context"> static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,</span>
 
 static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)
 {
<span class="p_del">-	struct nfs4_openowner *oo = openowner(stp-&gt;st_openstp-&gt;st_stateowner);</span>
<span class="p_del">-</span>
<span class="p_del">-	lockdep_assert_held(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);</span>
<span class="p_add">+	lockdep_assert_held(&amp;stp-&gt;st_stid.sc_client-&gt;cl_lock);</span>
 
 	list_del_init(&amp;stp-&gt;st_locks);
 	nfs4_unhash_stid(&amp;stp-&gt;st_stid);
<span class="p_chunk">@@ -1156,12 +1154,12 @@</span> <span class="p_context"> static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)</span>
 
 static void release_lock_stateid(struct nfs4_ol_stateid *stp)
 {
<span class="p_del">-	struct nfs4_openowner *oo = openowner(stp-&gt;st_openstp-&gt;st_stateowner);</span>
<span class="p_add">+	struct nfs4_client *clp = stp-&gt;st_stid.sc_client;</span>
 	bool unhashed;
 
<span class="p_del">-	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);</span>
<span class="p_add">+	spin_lock(&amp;clp-&gt;cl_lock);</span>
 	unhashed = unhash_lock_stateid(stp);
<span class="p_del">-	spin_unlock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);</span>
<span class="p_add">+	spin_unlock(&amp;clp-&gt;cl_lock);</span>
 	if (unhashed)
 		nfs4_put_stid(&amp;stp-&gt;st_stid);
 }
<span class="p_header">diff --git a/include/linux/tty_flip.h b/include/linux/tty_flip.h</span>
<span class="p_header">index c28dd523f96e..d43837f2ce3a 100644</span>
<span class="p_header">--- a/include/linux/tty_flip.h</span>
<span class="p_header">+++ b/include/linux/tty_flip.h</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"> extern int tty_prepare_flip_string(struct tty_port *port,</span>
 		unsigned char **chars, size_t size);
 extern void tty_flip_buffer_push(struct tty_port *port);
 void tty_schedule_flip(struct tty_port *port);
<span class="p_add">+int __tty_insert_flip_char(struct tty_port *port, unsigned char ch, char flag);</span>
 
 static inline int tty_insert_flip_char(struct tty_port *port,
 					unsigned char ch, char flag)
<span class="p_chunk">@@ -26,7 +27,7 @@</span> <span class="p_context"> static inline int tty_insert_flip_char(struct tty_port *port,</span>
 		*char_buf_ptr(tb, tb-&gt;used++) = ch;
 		return 1;
 	}
<span class="p_del">-	return tty_insert_flip_string_flags(port, &amp;ch, &amp;flag, 1);</span>
<span class="p_add">+	return __tty_insert_flip_char(port, ch, flag);</span>
 }
 
 static inline int tty_insert_flip_string(struct tty_port *port,
<span class="p_header">diff --git a/include/net/inet_frag.h b/include/net/inet_frag.h</span>
<span class="p_header">index ac42bbb37b2d..c26a6e4dc306 100644</span>
<span class="p_header">--- a/include/net/inet_frag.h</span>
<span class="p_header">+++ b/include/net/inet_frag.h</span>
<span class="p_chunk">@@ -1,14 +1,9 @@</span> <span class="p_context"></span>
 #ifndef __NET_FRAG_H__
 #define __NET_FRAG_H__
 
<span class="p_del">-#include &lt;linux/percpu_counter.h&gt;</span>
<span class="p_del">-</span>
 struct netns_frags {
<span class="p_del">-	/* The percpu_counter &quot;mem&quot; need to be cacheline aligned.</span>
<span class="p_del">-	 *  mem.count must not share cacheline with other writers</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	struct percpu_counter   mem ____cacheline_aligned_in_smp;</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Keep atomic mem on separate cachelines in structs that include it */</span>
<span class="p_add">+	atomic_t		mem ____cacheline_aligned_in_smp;</span>
 	/* sysctls */
 	int			timeout;
 	int			high_thresh;
<span class="p_chunk">@@ -108,15 +103,10 @@</span> <span class="p_context"> struct inet_frags {</span>
 int inet_frags_init(struct inet_frags *);
 void inet_frags_fini(struct inet_frags *);
 
<span class="p_del">-static inline int inet_frags_init_net(struct netns_frags *nf)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return percpu_counter_init(&amp;nf-&gt;mem, 0, GFP_KERNEL);</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void inet_frags_uninit_net(struct netns_frags *nf)</span>
<span class="p_add">+static inline void inet_frags_init_net(struct netns_frags *nf)</span>
 {
<span class="p_del">-	percpu_counter_destroy(&amp;nf-&gt;mem);</span>
<span class="p_add">+	atomic_set(&amp;nf-&gt;mem, 0);</span>
 }
<span class="p_del">-</span>
 void inet_frags_exit_net(struct netns_frags *nf, struct inet_frags *f);
 
 void inet_frag_kill(struct inet_frag_queue *q, struct inet_frags *f);
<span class="p_chunk">@@ -140,37 +130,24 @@</span> <span class="p_context"> static inline bool inet_frag_evicting(struct inet_frag_queue *q)</span>
 
 /* Memory Tracking Functions. */
 
<span class="p_del">-/* The default percpu_counter batch size is not big enough to scale to</span>
<span class="p_del">- * fragmentation mem acct sizes.</span>
<span class="p_del">- * The mem size of a 64K fragment is approx:</span>
<span class="p_del">- *  (44 fragments * 2944 truesize) + frag_queue struct(200) = 129736 bytes</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned int frag_percpu_counter_batch = 130000;</span>
<span class="p_del">-</span>
 static inline int frag_mem_limit(struct netns_frags *nf)
 {
<span class="p_del">-	return percpu_counter_read(&amp;nf-&gt;mem);</span>
<span class="p_add">+	return atomic_read(&amp;nf-&gt;mem);</span>
 }
 
 static inline void sub_frag_mem_limit(struct netns_frags *nf, int i)
 {
<span class="p_del">-	__percpu_counter_add(&amp;nf-&gt;mem, -i, frag_percpu_counter_batch);</span>
<span class="p_add">+	atomic_sub(i, &amp;nf-&gt;mem);</span>
 }
 
 static inline void add_frag_mem_limit(struct netns_frags *nf, int i)
 {
<span class="p_del">-	__percpu_counter_add(&amp;nf-&gt;mem, i, frag_percpu_counter_batch);</span>
<span class="p_add">+	atomic_add(i, &amp;nf-&gt;mem);</span>
 }
 
<span class="p_del">-static inline unsigned int sum_frag_mem_limit(struct netns_frags *nf)</span>
<span class="p_add">+static inline int sum_frag_mem_limit(struct netns_frags *nf)</span>
 {
<span class="p_del">-	unsigned int res;</span>
<span class="p_del">-</span>
<span class="p_del">-	local_bh_disable();</span>
<span class="p_del">-	res = percpu_counter_sum_positive(&amp;nf-&gt;mem);</span>
<span class="p_del">-	local_bh_enable();</span>
<span class="p_del">-</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	return atomic_read(&amp;nf-&gt;mem);</span>
 }
 
 /* RFC 3168 support :
<span class="p_header">diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h</span>
<span class="p_header">index fb961a576abe..fa5e703a14ed 100644</span>
<span class="p_header">--- a/include/net/ip6_fib.h</span>
<span class="p_header">+++ b/include/net/ip6_fib.h</span>
<span class="p_chunk">@@ -68,6 +68,7 @@</span> <span class="p_context"> struct fib6_node {</span>
 	__u16			fn_flags;
 	int			fn_sernum;
 	struct rt6_info		*rr_ptr;
<span class="p_add">+	struct rcu_head		rcu;</span>
 };
 
 #ifndef CONFIG_IPV6_SUBTREES
<span class="p_chunk">@@ -102,7 +103,7 @@</span> <span class="p_context"> struct rt6_info {</span>
 	 * the same cache line.
 	 */
 	struct fib6_table		*rt6i_table;
<span class="p_del">-	struct fib6_node		*rt6i_node;</span>
<span class="p_add">+	struct fib6_node __rcu		*rt6i_node;</span>
 
 	struct in6_addr			rt6i_gateway;
 
<span class="p_chunk">@@ -165,13 +166,40 @@</span> <span class="p_context"> static inline void rt6_update_expires(struct rt6_info *rt0, int timeout)</span>
 	rt0-&gt;rt6i_flags |= RTF_EXPIRES;
 }
 
<span class="p_add">+/* Function to safely get fn-&gt;sernum for passed in rt</span>
<span class="p_add">+ * and store result in passed in cookie.</span>
<span class="p_add">+ * Return true if we can get cookie safely</span>
<span class="p_add">+ * Return false if not</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool rt6_get_cookie_safe(const struct rt6_info *rt,</span>
<span class="p_add">+				       u32 *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct fib6_node *fn;</span>
<span class="p_add">+	bool status = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	fn = rcu_dereference(rt-&gt;rt6i_node);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fn) {</span>
<span class="p_add">+		*cookie = fn-&gt;fn_sernum;</span>
<span class="p_add">+		status = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return status;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u32 rt6_get_cookie(const struct rt6_info *rt)
 {
<span class="p_add">+	u32 cookie = 0;</span>
<span class="p_add">+</span>
 	if (rt-&gt;rt6i_flags &amp; RTF_PCPU ||
 	    (unlikely(rt-&gt;dst.flags &amp; DST_NOCACHE) &amp;&amp; rt-&gt;dst.from))
 		rt = (struct rt6_info *)(rt-&gt;dst.from);
 
<span class="p_del">-	return rt-&gt;rt6i_node ? rt-&gt;rt6i_node-&gt;fn_sernum : 0;</span>
<span class="p_add">+	rt6_get_cookie_safe(rt, &amp;cookie);</span>
<span class="p_add">+</span>
<span class="p_add">+	return cookie;</span>
 }
 
 static inline void ip6_rt_put(struct rt6_info *rt)
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index eba904bae48c..38d73a6e2857 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -2667,13 +2667,14 @@</span> <span class="p_context"> static int ftrace_shutdown(struct ftrace_ops *ops, int command)</span>
 
 	if (!command || !ftrace_enabled) {
 		/*
<span class="p_del">-		 * If these are control ops, they still need their</span>
<span class="p_del">-		 * per_cpu field freed. Since, function tracing is</span>
<span class="p_add">+		 * If these are dynamic or control ops, they still</span>
<span class="p_add">+		 * need their data freed. Since, function tracing is</span>
 		 * not currently active, we can just free them
 		 * without synchronizing all CPUs.
 		 */
<span class="p_del">-		if (ops-&gt;flags &amp; FTRACE_OPS_FL_CONTROL)</span>
<span class="p_del">-			control_ops_free(ops);</span>
<span class="p_add">+		if (ops-&gt;flags &amp; (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_CONTROL))</span>
<span class="p_add">+			goto free_ops;</span>
<span class="p_add">+</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -2728,6 +2729,7 @@</span> <span class="p_context"> static int ftrace_shutdown(struct ftrace_ops *ops, int command)</span>
 	if (ops-&gt;flags &amp; (FTRACE_OPS_FL_DYNAMIC | FTRACE_OPS_FL_CONTROL)) {
 		schedule_on_each_cpu(ftrace_sync);
 
<span class="p_add">+ free_ops:</span>
 		arch_ftrace_trampoline_free(ops);
 
 		if (ops-&gt;flags &amp; FTRACE_OPS_FL_CONTROL)
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index d59ebd9d21df..4743066010c4 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -5237,7 +5237,7 @@</span> <span class="p_context"> static int tracing_set_clock(struct trace_array *tr, const char *clockstr)</span>
 	tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);
 
 #ifdef CONFIG_TRACER_MAX_TRACE
<span class="p_del">-	if (tr-&gt;flags &amp; TRACE_ARRAY_FL_GLOBAL &amp;&amp; tr-&gt;max_buffer.buffer)</span>
<span class="p_add">+	if (tr-&gt;max_buffer.buffer)</span>
 		ring_buffer_set_clock(tr-&gt;max_buffer.buffer, trace_clocks[i].func);
 	tracing_reset_online_cpus(&amp;tr-&gt;max_buffer);
 #endif
<span class="p_header">diff --git a/kernel/trace/trace_selftest.c b/kernel/trace/trace_selftest.c</span>
<span class="p_header">index b0f86ea77881..ca70d11b8aa7 100644</span>
<span class="p_header">--- a/kernel/trace/trace_selftest.c</span>
<span class="p_header">+++ b/kernel/trace/trace_selftest.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> static int trace_selftest_ops(struct trace_array *tr, int cnt)</span>
 		goto out_free;
 	if (cnt &gt; 1) {
 		if (trace_selftest_test_global_cnt == 0)
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto out_free;</span>
 	}
 	if (trace_selftest_test_dyn_cnt == 0)
 		goto out_free;
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 53286b2f5b1c..6b5421ae86c6 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -1748,13 +1748,25 @@</span> <span class="p_context"> static void unreserve_highatomic_pageblock(const struct alloc_context *ac)</span>
 						struct page, lru);
 
 			/*
<span class="p_del">-			 * It should never happen but changes to locking could</span>
<span class="p_del">-			 * inadvertently allow a per-cpu drain to add pages</span>
<span class="p_del">-			 * to MIGRATE_HIGHATOMIC while unreserving so be safe</span>
<span class="p_del">-			 * and watch for underflows.</span>
<span class="p_add">+			 * In page freeing path, migratetype change is racy so</span>
<span class="p_add">+			 * we can counter several free pages in a pageblock</span>
<span class="p_add">+			 * in this loop althoug we changed the pageblock type</span>
<span class="p_add">+			 * from highatomic to ac-&gt;migratetype. So we should</span>
<span class="p_add">+			 * adjust the count once.</span>
 			 */
<span class="p_del">-			zone-&gt;nr_reserved_highatomic -= min(pageblock_nr_pages,</span>
<span class="p_del">-				zone-&gt;nr_reserved_highatomic);</span>
<span class="p_add">+			if (get_pageblock_migratetype(page) ==</span>
<span class="p_add">+							MIGRATE_HIGHATOMIC) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * It should never happen but changes to</span>
<span class="p_add">+				 * locking could inadvertently allow a per-cpu</span>
<span class="p_add">+				 * drain to add pages to MIGRATE_HIGHATOMIC</span>
<span class="p_add">+				 * while unreserving so be safe and watch for</span>
<span class="p_add">+				 * underflows.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				zone-&gt;nr_reserved_highatomic -= min(</span>
<span class="p_add">+						pageblock_nr_pages,</span>
<span class="p_add">+						zone-&gt;nr_reserved_highatomic);</span>
<span class="p_add">+			}</span>
 
 			/*
 			 * Convert to ac-&gt;migratetype and avoid the normal
<span class="p_header">diff --git a/net/ieee802154/6lowpan/reassembly.c b/net/ieee802154/6lowpan/reassembly.c</span>
<span class="p_header">index 6b437e8760d3..12e8cf4bda9f 100644</span>
<span class="p_header">--- a/net/ieee802154/6lowpan/reassembly.c</span>
<span class="p_header">+++ b/net/ieee802154/6lowpan/reassembly.c</span>
<span class="p_chunk">@@ -580,19 +580,14 @@</span> <span class="p_context"> static int __net_init lowpan_frags_init_net(struct net *net)</span>
 {
 	struct netns_ieee802154_lowpan *ieee802154_lowpan =
 		net_ieee802154_lowpan(net);
<span class="p_del">-	int res;</span>
 
 	ieee802154_lowpan-&gt;frags.high_thresh = IPV6_FRAG_HIGH_THRESH;
 	ieee802154_lowpan-&gt;frags.low_thresh = IPV6_FRAG_LOW_THRESH;
 	ieee802154_lowpan-&gt;frags.timeout = IPV6_FRAG_TIMEOUT;
 
<span class="p_del">-	res = inet_frags_init_net(&amp;ieee802154_lowpan-&gt;frags);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		return res;</span>
<span class="p_del">-	res = lowpan_frags_ns_sysctl_register(net);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		inet_frags_uninit_net(&amp;ieee802154_lowpan-&gt;frags);</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	inet_frags_init_net(&amp;ieee802154_lowpan-&gt;frags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return lowpan_frags_ns_sysctl_register(net);</span>
 }
 
 static void __net_exit lowpan_frags_exit_net(struct net *net)
<span class="p_header">diff --git a/net/ipv4/inet_fragment.c b/net/ipv4/inet_fragment.c</span>
<span class="p_header">index fe144dae7372..c5fb2f694ed0 100644</span>
<span class="p_header">--- a/net/ipv4/inet_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/inet_fragment.c</span>
<span class="p_chunk">@@ -234,10 +234,8 @@</span> <span class="p_context"> evict_again:</span>
 	cond_resched();
 
 	if (read_seqretry(&amp;f-&gt;rnd_seqlock, seq) ||
<span class="p_del">-	    percpu_counter_sum(&amp;nf-&gt;mem))</span>
<span class="p_add">+	    sum_frag_mem_limit(nf))</span>
 		goto evict_again;
<span class="p_del">-</span>
<span class="p_del">-	percpu_counter_destroy(&amp;nf-&gt;mem);</span>
 }
 EXPORT_SYMBOL(inet_frags_exit_net);
 
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index b8a0607dab96..e2e162432aa3 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -840,8 +840,6 @@</span> <span class="p_context"> static void __init ip4_frags_ctl_register(void)</span>
 
 static int __net_init ipv4_frags_init_net(struct net *net)
 {
<span class="p_del">-	int res;</span>
<span class="p_del">-</span>
 	/* Fragment cache limits.
 	 *
 	 * The fragment memory accounting code, (tries to) account for
<span class="p_chunk">@@ -865,13 +863,9 @@</span> <span class="p_context"> static int __net_init ipv4_frags_init_net(struct net *net)</span>
 	 */
 	net-&gt;ipv4.frags.timeout = IP_FRAG_TIME;
 
<span class="p_del">-	res = inet_frags_init_net(&amp;net-&gt;ipv4.frags);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		return res;</span>
<span class="p_del">-	res = ip4_frags_ns_ctl_register(net);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		inet_frags_uninit_net(&amp;net-&gt;ipv4.frags);</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	inet_frags_init_net(&amp;net-&gt;ipv4.frags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ip4_frags_ns_ctl_register(net);</span>
 }
 
 static void __net_exit ipv4_frags_exit_net(struct net *net)
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index 0870a86e9d96..5597120c8ffd 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -2260,6 +2260,10 @@</span> <span class="p_context"> int tcp_disconnect(struct sock *sk, int flags)</span>
 	tcp_set_ca_state(sk, TCP_CA_Open);
 	tcp_clear_retrans(tp);
 	inet_csk_delack_init(sk);
<span class="p_add">+	/* Initialize rcv_mss to TCP_MIN_MSS to avoid division by 0</span>
<span class="p_add">+	 * issue in __tcp_select_window()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	icsk-&gt;icsk_ack.rcv_mss = TCP_MIN_MSS;</span>
 	tcp_init_send_head(sk);
 	memset(&amp;tp-&gt;rx_opt, 0, sizeof(tp-&gt;rx_opt));
 	__sk_dst_reset(sk);
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 735b22b1b4ea..92174881844d 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -5152,7 +5152,7 @@</span> <span class="p_context"> static void __ipv6_ifa_notify(int event, struct inet6_ifaddr *ifp)</span>
 		 * our DAD process, so we don&#39;t need
 		 * to do it again
 		 */
<span class="p_del">-		if (!(ifp-&gt;rt-&gt;rt6i_node))</span>
<span class="p_add">+		if (!rcu_access_pointer(ifp-&gt;rt-&gt;rt6i_node))</span>
 			ip6_ins_rt(ifp-&gt;rt);
 		if (ifp-&gt;idev-&gt;cnf.forwarding)
 			addrconf_join_anycast(ifp);
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index aad8cdf15472..c23e02a7ccb0 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -150,11 +150,23 @@</span> <span class="p_context"> static struct fib6_node *node_alloc(void)</span>
 	return fn;
 }
 
<span class="p_del">-static void node_free(struct fib6_node *fn)</span>
<span class="p_add">+static void node_free_immediate(struct fib6_node *fn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kmem_cache_free(fib6_node_kmem, fn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void node_free_rcu(struct rcu_head *head)</span>
 {
<span class="p_add">+	struct fib6_node *fn = container_of(head, struct fib6_node, rcu);</span>
<span class="p_add">+</span>
 	kmem_cache_free(fib6_node_kmem, fn);
 }
 
<span class="p_add">+static void node_free(struct fib6_node *fn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	call_rcu(&amp;fn-&gt;rcu, node_free_rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void rt6_rcu_free(struct rt6_info *rt)
 {
 	call_rcu(&amp;rt-&gt;dst.rcu_head, dst_rcu_free);
<span class="p_chunk">@@ -191,6 +203,12 @@</span> <span class="p_context"> static void rt6_release(struct rt6_info *rt)</span>
 	}
 }
 
<span class="p_add">+static void fib6_free_table(struct fib6_table *table)</span>
<span class="p_add">+{</span>
<span class="p_add">+	inetpeer_invalidate_tree(&amp;table-&gt;tb6_peers);</span>
<span class="p_add">+	kfree(table);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void fib6_link_table(struct net *net, struct fib6_table *tb)
 {
 	unsigned int h;
<span class="p_chunk">@@ -588,9 +606,9 @@</span> <span class="p_context"> insert_above:</span>
 
 		if (!in || !ln) {
 			if (in)
<span class="p_del">-				node_free(in);</span>
<span class="p_add">+				node_free_immediate(in);</span>
 			if (ln)
<span class="p_del">-				node_free(ln);</span>
<span class="p_add">+				node_free_immediate(ln);</span>
 			return ERR_PTR(-ENOMEM);
 		}
 
<span class="p_chunk">@@ -857,7 +875,7 @@</span> <span class="p_context"> add:</span>
 
 		rt-&gt;dst.rt6_next = iter;
 		*ins = rt;
<span class="p_del">-		rt-&gt;rt6i_node = fn;</span>
<span class="p_add">+		rcu_assign_pointer(rt-&gt;rt6i_node, fn);</span>
 		atomic_inc(&amp;rt-&gt;rt6i_ref);
 		inet6_rt_notify(RTM_NEWROUTE, rt, info, 0);
 		info-&gt;nl_net-&gt;ipv6.rt6_stats-&gt;fib_rt_entries++;
<span class="p_chunk">@@ -882,7 +900,7 @@</span> <span class="p_context"> add:</span>
 			return err;
 
 		*ins = rt;
<span class="p_del">-		rt-&gt;rt6i_node = fn;</span>
<span class="p_add">+		rcu_assign_pointer(rt-&gt;rt6i_node, fn);</span>
 		rt-&gt;dst.rt6_next = iter-&gt;dst.rt6_next;
 		atomic_inc(&amp;rt-&gt;rt6i_ref);
 		inet6_rt_notify(RTM_NEWROUTE, rt, info, NLM_F_REPLACE);
<span class="p_chunk">@@ -1015,7 +1033,7 @@</span> <span class="p_context"> int fib6_add(struct fib6_node *root, struct rt6_info *rt,</span>
 				   root, and then (in failure) stale node
 				   in main tree.
 				 */
<span class="p_del">-				node_free(sfn);</span>
<span class="p_add">+				node_free_immediate(sfn);</span>
 				err = PTR_ERR(sn);
 				goto failure;
 			}
<span class="p_chunk">@@ -1442,8 +1460,9 @@</span> <span class="p_context"> static void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,</span>
 
 int fib6_del(struct rt6_info *rt, struct nl_info *info)
 {
<span class="p_add">+	struct fib6_node *fn = rcu_dereference_protected(rt-&gt;rt6i_node,</span>
<span class="p_add">+				    lockdep_is_held(&amp;rt-&gt;rt6i_table-&gt;tb6_lock));</span>
 	struct net *net = info-&gt;nl_net;
<span class="p_del">-	struct fib6_node *fn = rt-&gt;rt6i_node;</span>
 	struct rt6_info **rtp;
 
 #if RT6_DEBUG &gt;= 2
<span class="p_chunk">@@ -1632,7 +1651,9 @@</span> <span class="p_context"> static int fib6_clean_node(struct fib6_walker *w)</span>
 			if (res) {
 #if RT6_DEBUG &gt;= 2
 				pr_debug(&quot;%s: del failed: rt=%p@%p err=%d\n&quot;,
<span class="p_del">-					 __func__, rt, rt-&gt;rt6i_node, res);</span>
<span class="p_add">+					 __func__, rt,</span>
<span class="p_add">+					 rcu_access_pointer(rt-&gt;rt6i_node),</span>
<span class="p_add">+					 res);</span>
 #endif
 				continue;
 			}
<span class="p_chunk">@@ -1870,15 +1891,22 @@</span> <span class="p_context"> out_timer:</span>
 
 static void fib6_net_exit(struct net *net)
 {
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
 	rt6_ifdown(net, NULL);
 	del_timer_sync(&amp;net-&gt;ipv6.ip6_fib_timer);
 
<span class="p_del">-#ifdef CONFIG_IPV6_MULTIPLE_TABLES</span>
<span class="p_del">-	inetpeer_invalidate_tree(&amp;net-&gt;ipv6.fib6_local_tbl-&gt;tb6_peers);</span>
<span class="p_del">-	kfree(net-&gt;ipv6.fib6_local_tbl);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	inetpeer_invalidate_tree(&amp;net-&gt;ipv6.fib6_main_tbl-&gt;tb6_peers);</span>
<span class="p_del">-	kfree(net-&gt;ipv6.fib6_main_tbl);</span>
<span class="p_add">+	for (i = 0; i &lt; FIB6_TABLE_HASHSZ; i++) {</span>
<span class="p_add">+		struct hlist_head *head = &amp;net-&gt;ipv6.fib_table_hash[i];</span>
<span class="p_add">+		struct hlist_node *tmp;</span>
<span class="p_add">+		struct fib6_table *tb;</span>
<span class="p_add">+</span>
<span class="p_add">+		hlist_for_each_entry_safe(tb, tmp, head, tb6_hlist) {</span>
<span class="p_add">+			hlist_del(&amp;tb-&gt;tb6_hlist);</span>
<span class="p_add">+			fib6_free_table(tb);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(net-&gt;ipv6.fib_table_hash);
 	kfree(net-&gt;ipv6.rt6_stats);
 }
<span class="p_header">diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c</span>
<span class="p_header">index bab4441ed4e4..eb2dc39f7066 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/nf_conntrack_reasm.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c</span>
<span class="p_chunk">@@ -649,18 +649,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nf_ct_frag6_consume_orig);</span>
 
 static int nf_ct_net_init(struct net *net)
 {
<span class="p_del">-	int res;</span>
<span class="p_del">-</span>
 	net-&gt;nf_frag.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;
 	net-&gt;nf_frag.frags.low_thresh = IPV6_FRAG_LOW_THRESH;
 	net-&gt;nf_frag.frags.timeout = IPV6_FRAG_TIMEOUT;
<span class="p_del">-	res = inet_frags_init_net(&amp;net-&gt;nf_frag.frags);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		return res;</span>
<span class="p_del">-	res = nf_ct_frag6_sysctl_register(net);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		inet_frags_uninit_net(&amp;net-&gt;nf_frag.frags);</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	inet_frags_init_net(&amp;net-&gt;nf_frag.frags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return nf_ct_frag6_sysctl_register(net);</span>
 }
 
 static void nf_ct_net_exit(struct net *net)
<span class="p_header">diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c</span>
<span class="p_header">index f9f02581c4ca..f99a04674419 100644</span>
<span class="p_header">--- a/net/ipv6/output_core.c</span>
<span class="p_header">+++ b/net/ipv6/output_core.c</span>
<span class="p_chunk">@@ -86,7 +86,6 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 	while (offset &lt;= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
<span class="p_del">-		unsigned int len;</span>
 
 		switch (**nexthdr) {
 
<span class="p_chunk">@@ -112,10 +111,9 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
<span class="p_del">-		len = ipv6_optlen(exthdr);</span>
<span class="p_del">-		if (len + offset &gt;= IPV6_MAXPLEN)</span>
<span class="p_add">+		offset += ipv6_optlen(exthdr);</span>
<span class="p_add">+		if (offset &gt; IPV6_MAXPLEN)</span>
 			return -EINVAL;
<span class="p_del">-		offset += len;</span>
 		*nexthdr = &amp;exthdr-&gt;nexthdr;
 	}
 
<span class="p_header">diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c</span>
<span class="p_header">index a234552a7e3d..58f2139ebb5e 100644</span>
<span class="p_header">--- a/net/ipv6/reassembly.c</span>
<span class="p_header">+++ b/net/ipv6/reassembly.c</span>
<span class="p_chunk">@@ -708,19 +708,13 @@</span> <span class="p_context"> static void ip6_frags_sysctl_unregister(void)</span>
 
 static int __net_init ipv6_frags_init_net(struct net *net)
 {
<span class="p_del">-	int res;</span>
<span class="p_del">-</span>
 	net-&gt;ipv6.frags.high_thresh = IPV6_FRAG_HIGH_THRESH;
 	net-&gt;ipv6.frags.low_thresh = IPV6_FRAG_LOW_THRESH;
 	net-&gt;ipv6.frags.timeout = IPV6_FRAG_TIMEOUT;
 
<span class="p_del">-	res = inet_frags_init_net(&amp;net-&gt;ipv6.frags);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		return res;</span>
<span class="p_del">-	res = ip6_frags_ns_sysctl_register(net);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		inet_frags_uninit_net(&amp;net-&gt;ipv6.frags);</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	inet_frags_init_net(&amp;net-&gt;ipv6.frags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ip6_frags_ns_sysctl_register(net);</span>
 }
 
 static void __net_exit ipv6_frags_exit_net(struct net *net)
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index ef335070e98a..48917437550e 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -1248,7 +1248,9 @@</span> <span class="p_context"> static void rt6_dst_from_metrics_check(struct rt6_info *rt)</span>
 
 static struct dst_entry *rt6_check(struct rt6_info *rt, u32 cookie)
 {
<span class="p_del">-	if (!rt-&gt;rt6i_node || (rt-&gt;rt6i_node-&gt;fn_sernum != cookie))</span>
<span class="p_add">+	u32 rt_cookie;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rt6_get_cookie_safe(rt, &amp;rt_cookie) || rt_cookie != cookie)</span>
 		return NULL;
 
 	if (rt6_check_expired(rt))
<span class="p_chunk">@@ -1316,8 +1318,14 @@</span> <span class="p_context"> static void ip6_link_failure(struct sk_buff *skb)</span>
 		if (rt-&gt;rt6i_flags &amp; RTF_CACHE) {
 			dst_hold(&amp;rt-&gt;dst);
 			ip6_del_rt(rt);
<span class="p_del">-		} else if (rt-&gt;rt6i_node &amp;&amp; (rt-&gt;rt6i_flags &amp; RTF_DEFAULT)) {</span>
<span class="p_del">-			rt-&gt;rt6i_node-&gt;fn_sernum = -1;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			struct fib6_node *fn;</span>
<span class="p_add">+</span>
<span class="p_add">+			rcu_read_lock();</span>
<span class="p_add">+			fn = rcu_dereference(rt-&gt;rt6i_node);</span>
<span class="p_add">+			if (fn &amp;&amp; (rt-&gt;rt6i_flags &amp; RTF_DEFAULT))</span>
<span class="p_add">+				fn-&gt;fn_sernum = -1;</span>
<span class="p_add">+			rcu_read_unlock();</span>
 		}
 	}
 }
<span class="p_chunk">@@ -1334,7 +1342,8 @@</span> <span class="p_context"> static void rt6_do_update_pmtu(struct rt6_info *rt, u32 mtu)</span>
 static bool rt6_cache_allowed_for_pmtu(const struct rt6_info *rt)
 {
 	return !(rt-&gt;rt6i_flags &amp; RTF_CACHE) &amp;&amp;
<span class="p_del">-		(rt-&gt;rt6i_flags &amp; RTF_PCPU || rt-&gt;rt6i_node);</span>
<span class="p_add">+		(rt-&gt;rt6i_flags &amp; RTF_PCPU ||</span>
<span class="p_add">+		 rcu_access_pointer(rt-&gt;rt6i_node));</span>
 }
 
 static void __ip6_rt_update_pmtu(struct dst_entry *dst, const struct sock *sk,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



