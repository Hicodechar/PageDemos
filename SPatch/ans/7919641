
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.2,00/77] 3.2.75-rc1 review - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.2,00/77] 3.2.75-rc1 review</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 24, 2015, 4:40 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1450975207.23005.23.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7919641/mbox/"
   >mbox</a>
|
   <a href="/patch/7919641/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7919641/">/patch/7919641/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 50509BEEE5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 24 Dec 2015 16:40:38 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id D4D1A20592
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 24 Dec 2015 16:40:32 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 1A55D2052D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 24 Dec 2015 16:40:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755462AbbLXQkW (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 24 Dec 2015 11:40:22 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:51989 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1753050AbbLXQkQ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 24 Dec 2015 11:40:16 -0500
Received: from deadeye.wl.decadent.org.uk ([192.168.4.247] helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_128_GCM_SHA256:128) (Exim 4.84)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1aC8w1-0002dQ-09; Thu, 24 Dec 2015 16:40:13 +0000
Received: from ben by deadeye with local (Exim 4.86)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1aC8vv-0001YK-S7; Thu, 24 Dec 2015 16:40:07 +0000
Message-ID: &lt;1450975207.23005.23.camel@decadent.org.uk&gt;
Subject: Re: [PATCH 3.2 00/77] 3.2.75-rc1 review
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org
Cc: torvalds@linux-foundation.org, Guenter Roeck &lt;linux@roeck-us.net&gt;,
	Phil Jensen &lt;pjensen@evernote.com&gt;, akpm@linux-foundation.org
Date: Thu, 24 Dec 2015 16:40:07 +0000
In-Reply-To: &lt;lsq.1450971462.68643062@decadent.org.uk&gt;
References: &lt;lsq.1450971462.68643062@decadent.org.uk&gt;
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-IF2J/iFme+ufSgmngeat&quot;
X-Mailer: Evolution 3.18.2-1 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 192.168.4.247
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD, T_TVD_MIME_EPI,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Dec. 24, 2015, 4:40 p.m.</div>
<pre class="content">
This is the combined diff for 3.2.75-rc1 relative to 3.2.74.

Ben.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 89a7d05..d7073cb 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 74</span>
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_add">+SUBLEVEL = 75</span>
<span class="p_add">+EXTRAVERSION = -rc1</span>
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/sh/include/asm/unistd_64.h b/arch/sh/include/asm/unistd_64.h</span>
<span class="p_header">index c330c23..424f089 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/unistd_64.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/unistd_64.h</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"></span>
 #define __NR_fsetxattr		256
 #define __NR_getxattr		257
 #define __NR_lgetxattr		258
<span class="p_del">-#define __NR_fgetxattr		269</span>
<span class="p_add">+#define __NR_fgetxattr		259</span>
 #define __NR_listxattr		260
 #define __NR_llistxattr		261
 #define __NR_flistxattr		262
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index 41ffb8c..fa3eca3 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1226,6 +1226,15 @@</span> <span class="p_context"> static int ahci_exec_polled_cmd(struct ata_port *ap, int pmp,</span>
 	ata_tf_to_fis(tf, pmp, is_cmd, fis);
 	ahci_fill_cmd_slot(pp, 0, cmd_fis_len | flags | (pmp &lt;&lt; 12));
 
<span class="p_add">+	/* set port value for softreset of Port Multiplier */</span>
<span class="p_add">+	if (pp-&gt;fbs_enabled &amp;&amp; pp-&gt;fbs_last_dev != pmp) {</span>
<span class="p_add">+		tmp = readl(port_mmio + PORT_FBS);</span>
<span class="p_add">+		tmp &amp;= ~(PORT_FBS_DEV_MASK | PORT_FBS_DEC);</span>
<span class="p_add">+		tmp |= pmp &lt;&lt; PORT_FBS_DEV_OFFSET;</span>
<span class="p_add">+		writel(tmp, port_mmio + PORT_FBS);</span>
<span class="p_add">+		pp-&gt;fbs_last_dev = pmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* issue &amp; wait */
 	writel(1, port_mmio + PORT_CMD_ISSUE);
 
<span class="p_header">diff --git a/drivers/ata/sata_sil.c b/drivers/ata/sata_sil.c</span>
<span class="p_header">index 0c4ed89..7f0c7f0 100644</span>
<span class="p_header">--- a/drivers/ata/sata_sil.c</span>
<span class="p_header">+++ b/drivers/ata/sata_sil.c</span>
<span class="p_chunk">@@ -631,6 +631,9 @@</span> <span class="p_context"> static void sil_dev_config(struct ata_device *dev)</span>
 	unsigned int n, quirks = 0;
 	unsigned char model_num[ATA_ID_PROD_LEN + 1];
 
<span class="p_add">+	/* This controller doesn&#39;t support trim */</span>
<span class="p_add">+	dev-&gt;horkage |= ATA_HORKAGE_NOTRIM;</span>
<span class="p_add">+</span>
 	ata_id_c_string(dev-&gt;id, model_num, ATA_ID_PROD, sizeof(model_num));
 
 	for (n = 0; sil_blacklist[n].product; n++)
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 9397ab4..636a8dd 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -1148,15 +1148,15 @@</span> <span class="p_context"> static int smi_start_processing(void       *send_info,</span>
 
 	new_smi-&gt;intf = intf;
 
<span class="p_del">-	/* Try to claim any interrupts. */</span>
<span class="p_del">-	if (new_smi-&gt;irq_setup)</span>
<span class="p_del">-		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_del">-</span>
 	/* Set up the timer that drives the interface. */
 	setup_timer(&amp;new_smi-&gt;si_timer, smi_timeout, (long)new_smi);
 	new_smi-&gt;last_timeout_jiffies = jiffies;
 	mod_timer(&amp;new_smi-&gt;si_timer, jiffies + SI_TIMEOUT_JIFFIES);
 
<span class="p_add">+	/* Try to claim any interrupts. */</span>
<span class="p_add">+	if (new_smi-&gt;irq_setup)</span>
<span class="p_add">+		new_smi-&gt;irq_setup(new_smi);</span>
<span class="p_add">+</span>
 	/*
 	 * Check if the user forcefully enabled the daemon.
 	 */
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fops.c b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">index 020b103..5f1a653 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fops.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fops.c</span>
<span class="p_chunk">@@ -219,6 +219,62 @@</span> <span class="p_context"> static int drm_cpu_valid(void)</span>
 }
 
 /**
<span class="p_add">+ * drm_new_set_master - Allocate a new master object and become master for the</span>
<span class="p_add">+ * associated master realm.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @dev: The associated device.</span>
<span class="p_add">+ * @fpriv: File private identifying the client.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function must be called with dev::struct_mutex held.</span>
<span class="p_add">+ * Returns negative error code on failure. Zero on success.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_master *old_master;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held_once(&amp;dev-&gt;struct_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* create a new master */</span>
<span class="p_add">+	fpriv-&gt;minor-&gt;master = drm_master_create(fpriv-&gt;minor);</span>
<span class="p_add">+	if (!fpriv-&gt;minor-&gt;master)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* take another reference for the copy in the local file priv */</span>
<span class="p_add">+	old_master = fpriv-&gt;master;</span>
<span class="p_add">+	fpriv-&gt;master = drm_master_get(fpriv-&gt;minor-&gt;master);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev-&gt;driver-&gt;master_create) {</span>
<span class="p_add">+		mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_add">+		ret = dev-&gt;driver-&gt;master_create(dev, fpriv-&gt;master);</span>
<span class="p_add">+		mutex_lock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (dev-&gt;driver-&gt;master_set) {</span>
<span class="p_add">+		ret = dev-&gt;driver-&gt;master_set(dev, fpriv, true);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	fpriv-&gt;is_master = 1;</span>
<span class="p_add">+	fpriv-&gt;allowed_master = 1;</span>
<span class="p_add">+	fpriv-&gt;authenticated = 1;</span>
<span class="p_add">+	if (old_master)</span>
<span class="p_add">+		drm_master_put(&amp;old_master);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	/* drop both references and restore old master on failure */</span>
<span class="p_add">+	drm_master_put(&amp;fpriv-&gt;minor-&gt;master);</span>
<span class="p_add">+	drm_master_put(&amp;fpriv-&gt;master);</span>
<span class="p_add">+	fpriv-&gt;master = old_master;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * Called whenever a process opens /dev/drm.
  *
  * \param inode device inode.
<span class="p_chunk">@@ -279,43 +335,10 @@</span> <span class="p_context"> static int drm_open_helper(struct inode *inode, struct file *filp,</span>
 	mutex_lock(&amp;dev-&gt;struct_mutex);
 	if (!priv-&gt;minor-&gt;master) {
 		/* create a new master */
<span class="p_del">-		priv-&gt;minor-&gt;master = drm_master_create(priv-&gt;minor);</span>
<span class="p_del">-		if (!priv-&gt;minor-&gt;master) {</span>
<span class="p_del">-			mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-			ret = -ENOMEM;</span>
<span class="p_del">-			goto out_free;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		priv-&gt;is_master = 1;</span>
<span class="p_del">-		/* take another reference for the copy in the local file priv */</span>
<span class="p_del">-		priv-&gt;master = drm_master_get(priv-&gt;minor-&gt;master);</span>
<span class="p_del">-</span>
<span class="p_del">-		priv-&gt;authenticated = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-		mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-		if (dev-&gt;driver-&gt;master_create) {</span>
<span class="p_del">-			ret = dev-&gt;driver-&gt;master_create(dev, priv-&gt;master);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				mutex_lock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-				/* drop both references if this fails */</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;minor-&gt;master);</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;master);</span>
<span class="p_del">-				mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-				goto out_free;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-		mutex_lock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-		if (dev-&gt;driver-&gt;master_set) {</span>
<span class="p_del">-			ret = dev-&gt;driver-&gt;master_set(dev, priv, true);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				/* drop both references if this fails */</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;minor-&gt;master);</span>
<span class="p_del">-				drm_master_put(&amp;priv-&gt;master);</span>
<span class="p_del">-				mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-				goto out_free;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+		ret = drm_new_set_master(dev, priv);</span>
 		mutex_unlock(&amp;dev-&gt;struct_mutex);
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_free;</span>
 	} else {
 		/* get a reference to the master */
 		priv-&gt;master = drm_master_get(priv-&gt;minor-&gt;master);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_stub.c b/drivers/gpu/drm/drm_stub.c</span>
<span class="p_header">index 6d7b083..6c1f6ce 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_stub.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_stub.c</span>
<span class="p_chunk">@@ -225,6 +225,10 @@</span> <span class="p_context"> int drm_setmaster_ioctl(struct drm_device *dev, void *data,</span>
 	if (!file_priv-&gt;minor-&gt;master &amp;&amp;
 	    file_priv-&gt;minor-&gt;master != file_priv-&gt;master) {
 		mutex_lock(&amp;dev-&gt;struct_mutex);
<span class="p_add">+		if (!file_priv-&gt;allowed_master) {</span>
<span class="p_add">+			ret = drm_new_set_master(dev, file_priv);</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
 		file_priv-&gt;minor-&gt;master = drm_master_get(file_priv-&gt;master);
 		file_priv-&gt;is_master = 1;
 		if (dev-&gt;driver-&gt;master_set) {
<span class="p_chunk">@@ -234,10 +238,11 @@</span> <span class="p_context"> int drm_setmaster_ioctl(struct drm_device *dev, void *data,</span>
 				drm_master_put(&amp;file_priv-&gt;minor-&gt;master);
 			}
 		}
<span class="p_add">+	out_unlock:</span>
 		mutex_unlock(&amp;dev-&gt;struct_mutex);
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 int drm_dropmaster_ioctl(struct drm_device *dev, void *data,
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_lock.c b/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_header">index 075daf4..9934b4d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_lock.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> int ttm_write_lock(struct ttm_lock *lock, bool interruptible)</span>
 			spin_unlock(&amp;lock-&gt;lock);
 		}
 	} else
<span class="p_del">-		wait_event(lock-&gt;queue, __ttm_read_lock(lock));</span>
<span class="p_add">+		wait_event(lock-&gt;queue, __ttm_write_lock(lock));</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/gpu/vga/vgaarb.c b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">index 111d956..6a46d6e 100644</span>
<span class="p_header">--- a/drivers/gpu/vga/vgaarb.c</span>
<span class="p_header">+++ b/drivers/gpu/vga/vgaarb.c</span>
<span class="p_chunk">@@ -381,8 +381,10 @@</span> <span class="p_context"> int vga_get(struct pci_dev *pdev, unsigned int rsrc, int interruptible)</span>
 		set_current_state(interruptible ?
 				  TASK_INTERRUPTIBLE :
 				  TASK_UNINTERRUPTIBLE);
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_del">-			rc = -EINTR;</span>
<span class="p_add">+		if (interruptible &amp;&amp; signal_pending(current)) {</span>
<span class="p_add">+			__set_current_state(TASK_RUNNING);</span>
<span class="p_add">+			remove_wait_queue(&amp;vga_wait_queue, &amp;wait);</span>
<span class="p_add">+			rc = -ERESTARTSYS;</span>
 			break;
 		}
 		schedule();
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_ppp.c b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">index 1b002b0..3604aa7 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_ppp.c</span>
<span class="p_chunk">@@ -301,6 +301,8 @@</span> <span class="p_context"> isdn_ppp_open(int min, struct file *file)</span>
 	is-&gt;compflags = 0;
 
 	is-&gt;reset = isdn_ppp_ccp_reset_alloc(is);
<span class="p_add">+	if (!is-&gt;reset)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	is-&gt;lp = NULL;
 	is-&gt;mp_seqno = 0;       /* MP sequence number */
<span class="p_chunk">@@ -320,6 +322,10 @@</span> <span class="p_context"> isdn_ppp_open(int min, struct file *file)</span>
 	 * VJ header compression init
 	 */
 	is-&gt;slcomp = slhc_init(16, 16);	/* not necessary for 2. link in bundle */
<span class="p_add">+	if (IS_ERR(is-&gt;slcomp)) {</span>
<span class="p_add">+		isdn_ppp_ccp_reset_free(is);</span>
<span class="p_add">+		return PTR_ERR(is-&gt;slcomp);</span>
<span class="p_add">+	}</span>
 #endif
 #ifdef CONFIG_IPPP_FILTER
 	is-&gt;pass_filter = NULL;
<span class="p_chunk">@@ -568,10 +574,8 @@</span> <span class="p_context"> isdn_ppp_ioctl(int min, struct file *file, unsigned int cmd, unsigned long arg)</span>
 				is-&gt;maxcid = val;
 #ifdef CONFIG_ISDN_PPP_VJ
 				sltmp = slhc_init(16, val);
<span class="p_del">-				if (!sltmp) {</span>
<span class="p_del">-					printk(KERN_ERR &quot;ippp, can&#39;t realloc slhc struct\n&quot;);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (IS_ERR(sltmp))</span>
<span class="p_add">+					return PTR_ERR(sltmp);</span>
 				if (is-&gt;slcomp)
 					slhc_free(is-&gt;slcomp);
 				is-&gt;slcomp = sltmp;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 29e423f..a8f4f7e 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -231,6 +231,16 @@</span> <span class="p_context"> static void pop_frame(struct del_stack *s)</span>
 	dm_tm_unlock(s-&gt;tm, f-&gt;b);
 }
 
<span class="p_add">+static void unlock_all_frames(struct del_stack *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct frame *f;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (unprocessed_frames(s)) {</span>
<span class="p_add">+		f = s-&gt;spine + s-&gt;top--;</span>
<span class="p_add">+		dm_tm_unlock(s-&gt;tm, f-&gt;b);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int dm_btree_del(struct dm_btree_info *info, dm_block_t root)
 {
 	int r;
<span class="p_chunk">@@ -286,9 +296,13 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 			f-&gt;current_child = f-&gt;nr_children;
 		}
 	}
<span class="p_del">-</span>
 out:
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		/* cleanup all frames of del_stack */</span>
<span class="p_add">+		unlock_all_frames(s);</span>
<span class="p_add">+	}</span>
 	kfree(s);
<span class="p_add">+</span>
 	return r;
 }
 EXPORT_SYMBOL_GPL(dm_btree_del);
<span class="p_chunk">@@ -451,8 +465,10 @@</span> <span class="p_context"> static int btree_split_sibling(struct shadow_spine *s, dm_block_t root,</span>
 
 	r = insert_at(sizeof(__le64), pn, parent_index + 1,
 		      le64_to_cpu(rn-&gt;keys[0]), &amp;location);
<span class="p_del">-	if (r)</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		unlock_block(s-&gt;info, right);</span>
 		return r;
<span class="p_add">+	}</span>
 
 	if (key &lt; le64_to_cpu(rn-&gt;keys[0])) {
 		unlock_block(s-&gt;info, right);
<span class="p_header">diff --git a/drivers/net/can/sja1000/sja1000.c b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">index 568b821..faff53b 100644</span>
<span class="p_header">--- a/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_header">+++ b/drivers/net/can/sja1000/sja1000.c</span>
<span class="p_chunk">@@ -177,6 +177,9 @@</span> <span class="p_context"> static void sja1000_start(struct net_device *dev)</span>
 	priv-&gt;write_reg(priv, REG_RXERR, 0x0);
 	priv-&gt;read_reg(priv, REG_ECC);
 
<span class="p_add">+	/* clear interrupt flags */</span>
<span class="p_add">+	priv-&gt;read_reg(priv, REG_IR);</span>
<span class="p_add">+</span>
 	/* leave reset mode */
 	set_normal_mode(dev);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c</span>
<span class="p_header">index 5ae7df7..790f643 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/atheros/atl1c/atl1c_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/atheros/atl1c/atl1c_main.c</span>
<span class="p_chunk">@@ -981,13 +981,12 @@</span> <span class="p_context"> static int atl1c_setup_ring_resources(struct atl1c_adapter *adapter)</span>
 		sizeof(struct atl1c_hw_stats) +
 		8 * 4 + 8 * 2 * num_rx_queues;
 
<span class="p_del">-	ring_header-&gt;desc = pci_alloc_consistent(pdev, ring_header-&gt;size,</span>
<span class="p_del">-				&amp;ring_header-&gt;dma);</span>
<span class="p_add">+	ring_header-&gt;desc = dma_zalloc_coherent(&amp;pdev-&gt;dev, ring_header-&gt;size,</span>
<span class="p_add">+						&amp;ring_header-&gt;dma, GFP_KERNEL);</span>
 	if (unlikely(!ring_header-&gt;desc)) {
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;pci_alloc_consistend failed\n&quot;);</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;could not get memory for DMA buffer\n&quot;);</span>
 		goto err_nomem;
 	}
<span class="p_del">-	memset(ring_header-&gt;desc, 0, ring_header-&gt;size);</span>
 	/* init TPD ring */
 
 	tpd_ring[0].dma = roundup(ring_header-&gt;dma, 8);
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">index b2077ca..e49208d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_chunk">@@ -911,6 +911,7 @@</span> <span class="p_context"> static int sh_eth_rx(struct net_device *ndev)</span>
 		if (!(desc_status &amp; RDFEND))
 			mdp-&gt;stats.rx_length_errors++;
 
<span class="p_add">+		skb = mdp-&gt;rx_skbuff[entry];</span>
 		if (desc_status &amp; (RD_RFS1 | RD_RFS2 | RD_RFS3 | RD_RFS4 |
 				   RD_RFS5 | RD_RFS6 | RD_RFS10)) {
 			mdp-&gt;stats.rx_errors++;
<span class="p_chunk">@@ -926,12 +927,11 @@</span> <span class="p_context"> static int sh_eth_rx(struct net_device *ndev)</span>
 				mdp-&gt;stats.rx_missed_errors++;
 			if (desc_status &amp; RD_RFS10)
 				mdp-&gt;stats.rx_over_errors++;
<span class="p_del">-		} else {</span>
<span class="p_add">+		} else	if (skb) {</span>
 			if (!mdp-&gt;cd-&gt;hw_swap)
 				sh_eth_soft_swap(
 					phys_to_virt(ALIGN(rxdesc-&gt;addr, 4)),
 					pkt_len + 2);
<span class="p_del">-			skb = mdp-&gt;rx_skbuff[entry];</span>
 			mdp-&gt;rx_skbuff[entry] = NULL;
 			if (mdp-&gt;cd-&gt;rpadir)
 				skb_reserve(skb, NET_IP_ALIGN);
<span class="p_header">diff --git a/drivers/net/macvlan.c b/drivers/net/macvlan.c</span>
<span class="p_header">index fed39de..f85441d 100644</span>
<span class="p_header">--- a/drivers/net/macvlan.c</span>
<span class="p_header">+++ b/drivers/net/macvlan.c</span>
<span class="p_chunk">@@ -172,6 +172,7 @@</span> <span class="p_context"> static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)</span>
 		skb = ip_check_defrag(skb, IP_DEFRAG_MACVLAN);
 		if (!skb)
 			return RX_HANDLER_CONSUMED;
<span class="p_add">+		*pskb = skb;</span>
 		eth = eth_hdr(skb);
 		src = macvlan_hash_lookup(port, eth-&gt;h_source);
 		if (!src)
<span class="p_chunk">@@ -221,6 +222,7 @@</span> <span class="p_context"> static rx_handler_result_t macvlan_handle_frame(struct sk_buff **pskb)</span>
 	if (!skb)
 		goto out;
 
<span class="p_add">+	*pskb = skb;</span>
 	skb-&gt;dev = dev;
 	skb-&gt;pkt_type = PACKET_HOST;
 
<span class="p_header">diff --git a/drivers/net/phy/broadcom.c b/drivers/net/phy/broadcom.c</span>
<span class="p_header">index e8be47d..3456737 100644</span>
<span class="p_header">--- a/drivers/net/phy/broadcom.c</span>
<span class="p_header">+++ b/drivers/net/phy/broadcom.c</span>
<span class="p_chunk">@@ -935,7 +935,7 @@</span> <span class="p_context"> static struct mdio_device_id __maybe_unused broadcom_tbl[] = {</span>
 	{ PHY_ID_BCM5421, 0xfffffff0 },
 	{ PHY_ID_BCM5461, 0xfffffff0 },
 	{ PHY_ID_BCM5464, 0xfffffff0 },
<span class="p_del">-	{ PHY_ID_BCM5482, 0xfffffff0 },</span>
<span class="p_add">+	{ PHY_ID_BCM5481, 0xfffffff0 },</span>
 	{ PHY_ID_BCM5482, 0xfffffff0 },
 	{ PHY_ID_BCM50610, 0xfffffff0 },
 	{ PHY_ID_BCM50610M, 0xfffffff0 },
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index 4782d79..82d4421 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -703,10 +703,8 @@</span> <span class="p_context"> static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 			val &amp;= 0xffff;
 		}
 		vj = slhc_init(val2+1, val+1);
<span class="p_del">-		if (!vj) {</span>
<span class="p_del">-			netdev_err(ppp-&gt;dev,</span>
<span class="p_del">-				   &quot;PPP: no memory (VJ compressor)\n&quot;);</span>
<span class="p_del">-			err = -ENOMEM;</span>
<span class="p_add">+		if (IS_ERR(vj)) {</span>
<span class="p_add">+			err = PTR_ERR(vj);</span>
 			break;
 		}
 		ppp_lock(ppp);
<span class="p_header">diff --git a/drivers/net/ppp/pptp.c b/drivers/net/ppp/pptp.c</span>
<span class="p_header">index c974581..165ee14 100644</span>
<span class="p_header">--- a/drivers/net/ppp/pptp.c</span>
<span class="p_header">+++ b/drivers/net/ppp/pptp.c</span>
<span class="p_chunk">@@ -420,6 +420,9 @@</span> <span class="p_context"> static int pptp_bind(struct socket *sock, struct sockaddr *uservaddr,</span>
 	struct pptp_opt *opt = &amp;po-&gt;proto.pptp;
 	int error = 0;
 
<span class="p_add">+	if (sockaddr_len &lt; sizeof(struct sockaddr_pppox))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	lock_sock(sk);
 
 	opt-&gt;src_addr = sp-&gt;sa_addr.pptp;
<span class="p_chunk">@@ -441,6 +444,9 @@</span> <span class="p_context"> static int pptp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	struct flowi4 fl4;
 	int error = 0;
 
<span class="p_add">+	if (sockaddr_len &lt; sizeof(struct sockaddr_pppox))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (sp-&gt;sa_protocol != PX_PROTO_PPTP)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/net/slip/slhc.c b/drivers/net/slip/slhc.c</span>
<span class="p_header">index 0a0a664..042425e 100644</span>
<span class="p_header">--- a/drivers/net/slip/slhc.c</span>
<span class="p_header">+++ b/drivers/net/slip/slhc.c</span>
<span class="p_chunk">@@ -85,8 +85,9 @@</span> <span class="p_context"> static long decode(unsigned char **cpp);</span>
 static unsigned char * put16(unsigned char *cp, unsigned short x);
 static unsigned short pull16(unsigned char **cpp);
 
<span class="p_del">-/* Initialize compression data structure</span>
<span class="p_add">+/* Allocate compression data structure</span>
  *	slots must be in range 0 to 255 (zero meaning no compression)
<span class="p_add">+ * Returns pointer to structure or ERR_PTR() on error.</span>
  */
 struct slcompress *
 slhc_init(int rslots, int tslots)
<span class="p_chunk">@@ -95,11 +96,14 @@</span> <span class="p_context"> slhc_init(int rslots, int tslots)</span>
 	register struct cstate *ts;
 	struct slcompress *comp;
 
<span class="p_add">+	if (rslots &lt; 0 || rslots &gt; 255 || tslots &lt; 0 || tslots &gt; 255)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	comp = kzalloc(sizeof(struct slcompress), GFP_KERNEL);
 	if (! comp)
 		goto out_fail;
 
<span class="p_del">-	if ( rslots &gt; 0  &amp;&amp;  rslots &lt; 256 ) {</span>
<span class="p_add">+	if (rslots &gt; 0) {</span>
 		size_t rsize = rslots * sizeof(struct cstate);
 		comp-&gt;rstate = kzalloc(rsize, GFP_KERNEL);
 		if (! comp-&gt;rstate)
<span class="p_chunk">@@ -107,7 +111,7 @@</span> <span class="p_context"> slhc_init(int rslots, int tslots)</span>
 		comp-&gt;rslot_limit = rslots - 1;
 	}
 
<span class="p_del">-	if ( tslots &gt; 0  &amp;&amp;  tslots &lt; 256 ) {</span>
<span class="p_add">+	if (tslots &gt; 0) {</span>
 		size_t tsize = tslots * sizeof(struct cstate);
 		comp-&gt;tstate = kzalloc(tsize, GFP_KERNEL);
 		if (! comp-&gt;tstate)
<span class="p_chunk">@@ -142,7 +146,7 @@</span> <span class="p_context"> out_free2:</span>
 out_free:
 	kfree(comp);
 out_fail:
<span class="p_del">-	return NULL;</span>
<span class="p_add">+	return ERR_PTR(-ENOMEM);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/net/slip/slip.c b/drivers/net/slip/slip.c</span>
<span class="p_header">index ba08341..1a6e2ea 100644</span>
<span class="p_header">--- a/drivers/net/slip/slip.c</span>
<span class="p_header">+++ b/drivers/net/slip/slip.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static int sl_alloc_bufs(struct slip *sl, int mtu)</span>
 	if (cbuff == NULL)
 		goto err_exit;
 	slcomp = slhc_init(16, 16);
<span class="p_del">-	if (slcomp == NULL)</span>
<span class="p_add">+	if (IS_ERR(slcomp))</span>
 		goto err_exit;
 #endif
 	spin_lock_bh(&amp;sl-&gt;lock);
<span class="p_header">diff --git a/drivers/net/wan/x25_asy.c b/drivers/net/wan/x25_asy.c</span>
<span class="p_header">index 8a10bb7..b80cab2 100644</span>
<span class="p_header">--- a/drivers/net/wan/x25_asy.c</span>
<span class="p_header">+++ b/drivers/net/wan/x25_asy.c</span>
<span class="p_chunk">@@ -547,16 +547,12 @@</span> <span class="p_context"> static void x25_asy_receive_buf(struct tty_struct *tty,</span>
 
 static int x25_asy_open_tty(struct tty_struct *tty)
 {
<span class="p_del">-	struct x25_asy *sl = tty-&gt;disc_data;</span>
<span class="p_add">+	struct x25_asy *sl;</span>
 	int err;
 
 	if (tty-&gt;ops-&gt;write == NULL)
 		return -EOPNOTSUPP;
 
<span class="p_del">-	/* First make sure we&#39;re not already connected. */</span>
<span class="p_del">-	if (sl &amp;&amp; sl-&gt;magic == X25_ASY_MAGIC)</span>
<span class="p_del">-		return -EEXIST;</span>
<span class="p_del">-</span>
 	/* OK.  Find a free X.25 channel to use. */
 	sl = x25_asy_alloc();
 	if (sl == NULL)
<span class="p_header">diff --git a/drivers/parisc/iommu-helpers.h b/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">index 8c33491..c6aa388 100644</span>
<span class="p_header">--- a/drivers/parisc/iommu-helpers.h</span>
<span class="p_header">+++ b/drivers/parisc/iommu-helpers.h</span>
<span class="p_chunk">@@ -104,7 +104,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 	struct scatterlist *contig_sg;	   /* contig chunk head */
 	unsigned long dma_offset, dma_len; /* start/len of DMA stream */
 	unsigned int n_mappings = 0;
<span class="p_del">-	unsigned int max_seg_size = dma_get_max_seg_size(dev);</span>
<span class="p_add">+	unsigned int max_seg_size = min(dma_get_max_seg_size(dev),</span>
<span class="p_add">+					(unsigned)DMA_CHUNK_SIZE);</span>
<span class="p_add">+	unsigned int max_seg_boundary = dma_get_seg_boundary(dev) + 1;</span>
<span class="p_add">+	if (max_seg_boundary)	/* check if the addition above didn&#39;t overflow */</span>
<span class="p_add">+		max_seg_size = min(max_seg_size, max_seg_boundary);</span>
 
 	while (nents &gt; 0) {
 
<span class="p_chunk">@@ -139,14 +143,11 @@</span> <span class="p_context"> iommu_coalesce_chunks(struct ioc *ioc, struct device *dev,</span>
 
 			/*
 			** First make sure current dma stream won&#39;t
<span class="p_del">-			** exceed DMA_CHUNK_SIZE if we coalesce the</span>
<span class="p_add">+			** exceed max_seg_size if we coalesce the</span>
 			** next entry.
 			*/   
<span class="p_del">-			if(unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length,</span>
<span class="p_del">-					    IOVP_SIZE) &gt; DMA_CHUNK_SIZE))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (startsg-&gt;length + dma_len &gt; max_seg_size)</span>
<span class="p_add">+			if (unlikely(ALIGN(dma_len + dma_offset + startsg-&gt;length, IOVP_SIZE) &gt;</span>
<span class="p_add">+				     max_seg_size))</span>
 				break;
 
 			/*
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index ca666d0..660c334 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -916,6 +916,10 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 
 	/* normal quirks */
 	quirks = (unsigned long)id-&gt;driver_info;
<span class="p_add">+</span>
<span class="p_add">+	if (quirks == IGNORE_DEVICE)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	num_rx_buf = (quirks == SINGLE_RX_URB) ? 1 : ACM_NR;
 
 	/* handle quirks deadly to normal probing*/
<span class="p_chunk">@@ -1662,6 +1666,11 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	.driver_info = NO_DATA_INTERFACE,
 	},
 
<span class="p_add">+	/* Exclude Infineon Flash Loader utility */</span>
<span class="p_add">+	{ USB_DEVICE(0x058b, 0x0041),</span>
<span class="p_add">+	.driver_info = IGNORE_DEVICE,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* control interfaces without any protocol set */
 	{ USB_INTERFACE_INFO(USB_CLASS_COMM, USB_CDC_SUBCLASS_ACM,
 		USB_CDC_PROTO_NONE) },
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index 7aa5e9a..9af5ad2 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -127,4 +127,5 @@</span> <span class="p_context"> struct acm {</span>
 #define NO_CAP_LINE			4
 #define NOT_A_MODEM			8
 #define NO_DATA_INTERFACE		16
<span class="p_add">+#define IGNORE_DEVICE			32</span>
 #define CLEAR_HALT_CONDITIONS		BIT(7)
<span class="p_header">diff --git a/drivers/usb/class/usblp.c b/drivers/usb/class/usblp.c</span>
<span class="p_header">index cb3a932..a84c857 100644</span>
<span class="p_header">--- a/drivers/usb/class/usblp.c</span>
<span class="p_header">+++ b/drivers/usb/class/usblp.c</span>
<span class="p_chunk">@@ -861,11 +861,11 @@</span> <span class="p_context"> static int usblp_wwait(struct usblp *usblp, int nonblock)</span>
 
 	add_wait_queue(&amp;usblp-&gt;wwait, &amp;waita);
 	for (;;) {
<span class="p_del">-		set_current_state(TASK_INTERRUPTIBLE);</span>
 		if (mutex_lock_interruptible(&amp;usblp-&gt;mut)) {
 			rc = -EINTR;
 			break;
 		}
<span class="p_add">+		set_current_state(TASK_INTERRUPTIBLE);</span>
 		rc = usblp_wtest(usblp, nonblock);
 		mutex_unlock(&amp;usblp-&gt;mut);
 		if (rc &lt;= 0)
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 478d71b..ffc6989 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -117,7 +117,8 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 		   USB_SS_MULT(desc-&gt;bmAttributes) &gt; 3) {
 		dev_warn(ddev, &quot;Isoc endpoint has Mult of %d in &quot;
 				&quot;config %d interface %d altsetting %d ep %d: &quot;
<span class="p_del">-				&quot;setting to 3\n&quot;, desc-&gt;bmAttributes + 1,</span>
<span class="p_add">+				&quot;setting to 3\n&quot;,</span>
<span class="p_add">+				USB_SS_MULT(desc-&gt;bmAttributes),</span>
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		ep-&gt;ss_ep_comp.bmAttributes = 2;
 	}
<span class="p_header">diff --git a/drivers/usb/host/whci/qset.c b/drivers/usb/host/whci/qset.c</span>
<span class="p_header">index 76083ae..412b4fe 100644</span>
<span class="p_header">--- a/drivers/usb/host/whci/qset.c</span>
<span class="p_header">+++ b/drivers/usb/host/whci/qset.c</span>
<span class="p_chunk">@@ -377,6 +377,10 @@</span> <span class="p_context"> static int qset_fill_page_list(struct whc *whc, struct whc_std *std, gfp_t mem_f</span>
 	if (std-&gt;pl_virt == NULL)
 		return -ENOMEM;
 	std-&gt;dma_addr = dma_map_single(whc-&gt;wusbhc.dev, std-&gt;pl_virt, pl_len, DMA_TO_DEVICE);
<span class="p_add">+	if (dma_mapping_error(whc-&gt;wusbhc.dev, std-&gt;dma_addr)) {</span>
<span class="p_add">+		kfree(std-&gt;pl_virt);</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
 
 	for (p = 0; p &lt; std-&gt;num_pointers; p++) {
 		std-&gt;pl_virt[p].buf_ptr = cpu_to_le64(dma_addr);
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index a42ef09..5223884 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -106,6 +106,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;
 
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)
<span class="p_add">+		xhci-&gt;quirks |= XHCI_INTEL_HOST;</span>
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL)</span>
 		xhci-&gt;quirks |= XHCI_AVOID_BEI;
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 			pdev-&gt;device == PCI_DEVICE_ID_INTEL_PANTHERPOINT_XHCI) {
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 2f51dec..d7ddb5a 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -170,6 +170,16 @@</span> <span class="p_context"> int xhci_reset(struct xhci_hcd *xhci)</span>
 	command |= CMD_RESET;
 	xhci_writel(xhci, command, &amp;xhci-&gt;op_regs-&gt;command);
 
<span class="p_add">+	/* Existing Intel xHCI controllers require a delay of 1 mS,</span>
<span class="p_add">+	 * after setting the CMD_RESET bit, and before accessing any</span>
<span class="p_add">+	 * HC registers. This allows the HC to complete the</span>
<span class="p_add">+	 * reset operation and be ready for HC register access.</span>
<span class="p_add">+	 * Without this delay, the subsequent HC register access,</span>
<span class="p_add">+	 * may result in a system hang very rarely.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xhci-&gt;quirks &amp; XHCI_INTEL_HOST)</span>
<span class="p_add">+		udelay(1000);</span>
<span class="p_add">+</span>
 	ret = handshake(xhci, &amp;xhci-&gt;op_regs-&gt;command,
 			CMD_RESET, 0, 10 * 1000 * 1000);
 	if (ret)
<span class="p_chunk">@@ -4120,8 +4130,16 @@</span> <span class="p_context"> int xhci_update_hub_device(struct usb_hcd *hcd, struct usb_device *hdev,</span>
 	ctrl_ctx-&gt;add_flags |= cpu_to_le32(SLOT_FLAG);
 	slot_ctx = xhci_get_slot_ctx(xhci, config_cmd-&gt;in_ctx);
 	slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_HUB);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * refer to section 6.2.2: MTT should be 0 for full speed hub,</span>
<span class="p_add">+	 * but it may be already set to 1 when setup an xHCI virtual</span>
<span class="p_add">+	 * device, so clear it anyway.</span>
<span class="p_add">+	 */</span>
 	if (tt-&gt;multi)
 		slot_ctx-&gt;dev_info |= cpu_to_le32(DEV_MTT);
<span class="p_add">+	else if (hdev-&gt;speed == USB_SPEED_FULL)</span>
<span class="p_add">+		slot_ctx-&gt;dev_info &amp;= cpu_to_le32(~DEV_MTT);</span>
<span class="p_add">+</span>
 	if (xhci-&gt;hci_version &gt; 0x95) {
 		xhci_dbg(xhci, &quot;xHCI version %x needs hub &quot;
 				&quot;TT think time and number of ports\n&quot;,
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index d676ae0..15f58d1 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1492,6 +1492,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define	XHCI_SW_BW_CHECKING	(1 &lt;&lt; 8)
 #define XHCI_AMD_0x96_HOST	(1 &lt;&lt; 9)
 #define XHCI_TRUST_TX_LENGTH	(1 &lt;&lt; 10)
<span class="p_add">+#define XHCI_INTEL_HOST		(1 &lt;&lt; 12)</span>
 #define XHCI_SPURIOUS_REBOOT	(1 &lt;&lt; 13)
 #define XHCI_COMP_MODE_QUIRK	(1 &lt;&lt; 14)
 #define XHCI_AVOID_BEI		(1 &lt;&lt; 15)
<span class="p_header">diff --git a/drivers/usb/musb/musb_core.c b/drivers/usb/musb/musb_core.c</span>
<span class="p_header">index 6f7d84e..fb05cac 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_core.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_core.c</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"> static inline struct musb *dev_to_musb(struct device *dev)</span>
 /*-------------------------------------------------------------------------*/
 
 #ifndef CONFIG_BLACKFIN
<span class="p_del">-static int musb_ulpi_read(struct otg_transceiver *otg, u32 offset)</span>
<span class="p_add">+static int musb_ulpi_read(struct otg_transceiver *otg, u32 reg)</span>
 {
 	void __iomem *addr = otg-&gt;io_priv;
 	int	i = 0;
<span class="p_chunk">@@ -147,7 +147,7 @@</span> <span class="p_context"> static int musb_ulpi_read(struct otg_transceiver *otg, u32 offset)</span>
 	 * ULPICarKitControlDisableUTMI after clearing POWER_SUSPENDM.
 	 */
 
<span class="p_del">-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);</span>
<span class="p_add">+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);</span>
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL,
 			MUSB_ULPI_REG_REQ | MUSB_ULPI_RDN_WR);
 
<span class="p_chunk">@@ -165,8 +165,7 @@</span> <span class="p_context"> static int musb_ulpi_read(struct otg_transceiver *otg, u32 offset)</span>
 	return musb_readb(addr, MUSB_ULPI_REG_DATA);
 }
 
<span class="p_del">-static int musb_ulpi_write(struct otg_transceiver *otg,</span>
<span class="p_del">-		u32 offset, u32 data)</span>
<span class="p_add">+static int musb_ulpi_write(struct otg_transceiver *otg, u32 val, u32 reg)</span>
 {
 	void __iomem *addr = otg-&gt;io_priv;
 	int	i = 0;
<span class="p_chunk">@@ -178,8 +177,8 @@</span> <span class="p_context"> static int musb_ulpi_write(struct otg_transceiver *otg,</span>
 	power &amp;= ~MUSB_POWER_SUSPENDM;
 	musb_writeb(addr, MUSB_POWER, power);
 
<span class="p_del">-	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)offset);</span>
<span class="p_del">-	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)data);</span>
<span class="p_add">+	musb_writeb(addr, MUSB_ULPI_REG_ADDR, (u8)reg);</span>
<span class="p_add">+	musb_writeb(addr, MUSB_ULPI_REG_DATA, (u8)val);</span>
 	musb_writeb(addr, MUSB_ULPI_REG_CONTROL, MUSB_ULPI_REG_REQ);
 
 	while (!(musb_readb(addr, MUSB_ULPI_REG_CONTROL)
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 1a19724..1398597 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -138,7 +138,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_del">-	{ USB_DEVICE(0x10C4, 0xEA80) }, /* Silicon Labs factory default */</span>
 	{ USB_DEVICE(0x10C4, 0xEA71) }, /* Infinity GPS-MIC-1 Radio Monophone */
 	{ USB_DEVICE(0x10C4, 0xF001) }, /* Elan Digital Systems USBscope50 */
 	{ USB_DEVICE(0x10C4, 0xF002) }, /* Elan Digital Systems USBwave12 */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 7e6d2ec..5a31169 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -162,6 +162,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define NOVATELWIRELESS_PRODUCT_HSPA_EMBEDDED_HIGHSPEED	0x9001
 #define NOVATELWIRELESS_PRODUCT_E362		0x9010
 #define NOVATELWIRELESS_PRODUCT_E371		0x9011
<span class="p_add">+#define NOVATELWIRELESS_PRODUCT_U620L		0x9022</span>
 #define NOVATELWIRELESS_PRODUCT_G2		0xA010
 #define NOVATELWIRELESS_PRODUCT_MC551		0xB001
 
<span class="p_chunk">@@ -355,6 +356,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 /* This is the 4G XS Stick W14 a.k.a. Mobilcom Debitel Surf-Stick *
  * It seems to contain a Qualcomm QSC6240/6290 chipset            */
 #define FOUR_G_SYSTEMS_PRODUCT_W14		0x9603
<span class="p_add">+#define FOUR_G_SYSTEMS_PRODUCT_W100		0x9b01</span>
 
 /* iBall 3.5G connect wireless modem */
 #define IBALL_3_5G_CONNECT			0x9605
<span class="p_chunk">@@ -525,6 +527,11 @@</span> <span class="p_context"> static const struct option_blacklist_info four_g_w14_blacklist = {</span>
 	.sendsetup = BIT(0) | BIT(1),
 };
 
<span class="p_add">+static const struct option_blacklist_info four_g_w100_blacklist = {</span>
<span class="p_add">+	.sendsetup = BIT(1) | BIT(2),</span>
<span class="p_add">+	.reserved = BIT(3),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info alcatel_x200_blacklist = {
 	.sendsetup = BIT(0) | BIT(1),
 	.reserved = BIT(4),
<span class="p_chunk">@@ -1058,6 +1065,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_MC551, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E362, 0xff, 0xff, 0xff) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_E371, 0xff, 0xff, 0xff) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(NOVATELWIRELESS_VENDOR_ID, NOVATELWIRELESS_PRODUCT_U620L, 0xff, 0x00, 0x00) },</span>
 
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01) },
 	{ USB_DEVICE(AMOI_VENDOR_ID, AMOI_PRODUCT_H01A) },
<span class="p_chunk">@@ -1640,6 +1648,9 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W14),
   	  .driver_info = (kernel_ulong_t)&amp;four_g_w14_blacklist
   	},
<span class="p_add">+	{ USB_DEVICE(LONGCHEER_VENDOR_ID, FOUR_G_SYSTEMS_PRODUCT_W100),</span>
<span class="p_add">+	  .driver_info = (kernel_ulong_t)&amp;four_g_w100_blacklist</span>
<span class="p_add">+	},</span>
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, ZOOM_PRODUCT_4597) },
 	{ USB_DEVICE(LONGCHEER_VENDOR_ID, IBALL_3_5G_CONNECT) },
 	{ USB_DEVICE(HAIER_VENDOR_ID, HAIER_PRODUCT_CE100) },
<span class="p_header">diff --git a/drivers/usb/serial/ti_usb_3410_5052.c b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">index 885d15d..ad0445a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ti_usb_3410_5052.c</span>
<span class="p_chunk">@@ -164,7 +164,7 @@</span> <span class="p_context"> static unsigned int product_5052_count;</span>
 /* the array dimension is the number of default entries plus */
 /* TI_EXTRA_VID_PID_COUNT user defined entries plus 1 terminating */
 /* null entry */
<span class="p_del">-static struct usb_device_id ti_id_table_3410[15+TI_EXTRA_VID_PID_COUNT+1] = {</span>
<span class="p_add">+static struct usb_device_id ti_id_table_3410[17+TI_EXTRA_VID_PID_COUNT+1] = {</span>
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_PRODUCT_ID) },
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_EZ430_ID) },
 	{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_NO_FW_PRODUCT_ID) },
<span class="p_chunk">@@ -181,6 +181,7 @@</span> <span class="p_context"> static struct usb_device_id ti_id_table_3410[15+TI_EXTRA_VID_PID_COUNT+1] = {</span>
 	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STEREO_PLUG_ID) },
 	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STRIP_PORT_ID) },
 	{ USB_DEVICE(TI_VENDOR_ID, FRI2_PRODUCT_ID) },
<span class="p_add">+	{ USB_DEVICE(HONEYWELL_VENDOR_ID, HONEYWELL_HGI80_PRODUCT_ID) },</span>
 };
 
 static struct usb_device_id ti_id_table_5052[5+TI_EXTRA_VID_PID_COUNT+1] = {
<span class="p_chunk">@@ -190,7 +191,7 @@</span> <span class="p_context"> static struct usb_device_id ti_id_table_5052[5+TI_EXTRA_VID_PID_COUNT+1] = {</span>
 	{ USB_DEVICE(TI_VENDOR_ID, TI_5052_FIRMWARE_PRODUCT_ID) },
 };
 
<span class="p_del">-static struct usb_device_id ti_id_table_combined[19+2*TI_EXTRA_VID_PID_COUNT+1] = {</span>
<span class="p_add">+static struct usb_device_id ti_id_table_combined[21+2*TI_EXTRA_VID_PID_COUNT+1] = {</span>
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_PRODUCT_ID) },
 	{ USB_DEVICE(TI_VENDOR_ID, TI_3410_EZ430_ID) },
 	{ USB_DEVICE(MTS_VENDOR_ID, MTS_GSM_NO_FW_PRODUCT_ID) },
<span class="p_chunk">@@ -209,7 +210,9 @@</span> <span class="p_context"> static struct usb_device_id ti_id_table_combined[19+2*TI_EXTRA_VID_PID_COUNT+1]</span>
 	{ USB_DEVICE(IBM_VENDOR_ID, IBM_454B_PRODUCT_ID) },
 	{ USB_DEVICE(IBM_VENDOR_ID, IBM_454C_PRODUCT_ID) },
 	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_PRODUCT_ID) },
<span class="p_add">+	{ USB_DEVICE(ABBOTT_VENDOR_ID, ABBOTT_STRIP_PORT_ID) },</span>
 	{ USB_DEVICE(TI_VENDOR_ID, FRI2_PRODUCT_ID) },
<span class="p_add">+	{ USB_DEVICE(HONEYWELL_VENDOR_ID, HONEYWELL_HGI80_PRODUCT_ID) },</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ti_usb_3410_5052.h b/drivers/usb/serial/ti_usb_3410_5052.h</span>
<span class="p_header">index 4a2423e..98f35c6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ti_usb_3410_5052.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ti_usb_3410_5052.h</span>
<span class="p_chunk">@@ -56,6 +56,10 @@</span> <span class="p_context"></span>
 #define ABBOTT_PRODUCT_ID		ABBOTT_STEREO_PLUG_ID
 #define ABBOTT_STRIP_PORT_ID		0x3420
 
<span class="p_add">+/* Honeywell vendor and product IDs */</span>
<span class="p_add">+#define HONEYWELL_VENDOR_ID		0x10ac</span>
<span class="p_add">+#define HONEYWELL_HGI80_PRODUCT_ID	0x0102  /* Honeywell HGI80 */</span>
<span class="p_add">+</span>
 /* Commands */
 #define TI_GET_VERSION			0x01
 #define TI_GET_PORT_STATUS		0x02
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index bf1df72..adedfd4 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -435,9 +435,9 @@</span> <span class="p_context"> void v9fs_evict_inode(struct inode *inode)</span>
 {
 	struct v9fs_inode *v9inode = V9FS_I(inode);
 
<span class="p_del">-	truncate_inode_pages(inode-&gt;i_mapping, 0);</span>
<span class="p_add">+	truncate_inode_pages(&amp;inode-&gt;i_data, 0);</span>
 	end_writeback(inode);
<span class="p_del">-	filemap_fdatawrite(inode-&gt;i_mapping);</span>
<span class="p_add">+	filemap_fdatawrite(&amp;inode-&gt;i_data);</span>
 
 #ifdef CONFIG_9P_FSCACHE
 	v9fs_cache_inode_put_cookie(inode);
<span class="p_header">diff --git a/fs/cachefiles/rdwr.c b/fs/cachefiles/rdwr.c</span>
<span class="p_header">index 00d9425..8c4292b 100644</span>
<span class="p_header">--- a/fs/cachefiles/rdwr.c</span>
<span class="p_header">+++ b/fs/cachefiles/rdwr.c</span>
<span class="p_chunk">@@ -894,7 +894,7 @@</span> <span class="p_context"> int cachefiles_write_page(struct fscache_storage *op, struct page *page)</span>
 	loff_t pos, eof;
 	size_t len;
 	void *data;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = -ENOBUFS;</span>
 
 	ASSERT(op != NULL);
 	ASSERT(page != NULL);
<span class="p_header">diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h</span>
<span class="p_header">index 6858d9d..8c8115c 100644</span>
<span class="p_header">--- a/fs/ext4/ext4.h</span>
<span class="p_header">+++ b/fs/ext4/ext4.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/seqlock.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/timer.h&gt;
<span class="p_add">+#include &lt;linux/version.h&gt;</span>
 #include &lt;linux/wait.h&gt;
 #include &lt;linux/blockgroup_lock.h&gt;
 #include &lt;linux/percpu_counter.h&gt;
<span class="p_chunk">@@ -698,19 +699,55 @@</span> <span class="p_context"> struct move_extent {</span>
 	&lt;= (EXT4_GOOD_OLD_INODE_SIZE +			\
 	    (einode)-&gt;i_extra_isize))			\
 
<span class="p_add">+/*</span>
<span class="p_add">+ * We use an encoding that preserves the times for extra epoch &quot;00&quot;:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * extra  msb of                         adjust for signed</span>
<span class="p_add">+ * epoch  32-bit                         32-bit tv_sec to</span>
<span class="p_add">+ * bits   time    decoded 64-bit tv_sec  64-bit tv_sec      valid time range</span>
<span class="p_add">+ * 0 0    1    -0x80000000..-0x00000001  0x000000000 1901-12-13..1969-12-31</span>
<span class="p_add">+ * 0 0    0    0x000000000..0x07fffffff  0x000000000 1970-01-01..2038-01-19</span>
<span class="p_add">+ * 0 1    1    0x080000000..0x0ffffffff  0x100000000 2038-01-19..2106-02-07</span>
<span class="p_add">+ * 0 1    0    0x100000000..0x17fffffff  0x100000000 2106-02-07..2174-02-25</span>
<span class="p_add">+ * 1 0    1    0x180000000..0x1ffffffff  0x200000000 2174-02-25..2242-03-16</span>
<span class="p_add">+ * 1 0    0    0x200000000..0x27fffffff  0x200000000 2242-03-16..2310-04-04</span>
<span class="p_add">+ * 1 1    1    0x280000000..0x2ffffffff  0x300000000 2310-04-04..2378-04-22</span>
<span class="p_add">+ * 1 1    0    0x300000000..0x37fffffff  0x300000000 2378-04-22..2446-05-10</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that previous versions of the kernel on 64-bit systems would</span>
<span class="p_add">+ * incorrectly use extra epoch bits 1,1 for dates between 1901 and</span>
<span class="p_add">+ * 1970.  e2fsck will correct this, assuming that it is run on the</span>
<span class="p_add">+ * affected filesystem before 2242.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 static inline __le32 ext4_encode_extra_time(struct timespec *time)
 {
<span class="p_del">-       return cpu_to_le32((sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_del">-			   (time-&gt;tv_sec &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0) |</span>
<span class="p_del">-                          ((time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS) &amp; EXT4_NSEC_MASK));</span>
<span class="p_add">+	u32 extra = sizeof(time-&gt;tv_sec) &gt; 4 ?</span>
<span class="p_add">+		((time-&gt;tv_sec - (s32)time-&gt;tv_sec) &gt;&gt; 32) &amp; EXT4_EPOCH_MASK : 0;</span>
<span class="p_add">+	return cpu_to_le32(extra | (time-&gt;tv_nsec &lt;&lt; EXT4_EPOCH_BITS));</span>
 }
 
 static inline void ext4_decode_extra_time(struct timespec *time, __le32 extra)
 {
<span class="p_del">-       if (sizeof(time-&gt;tv_sec) &gt; 4)</span>
<span class="p_del">-	       time-&gt;tv_sec |= (__u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK)</span>
<span class="p_del">-			       &lt;&lt; 32;</span>
<span class="p_del">-       time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
<span class="p_add">+	if (unlikely(sizeof(time-&gt;tv_sec) &gt; 4 &amp;&amp;</span>
<span class="p_add">+			(extra &amp; cpu_to_le32(EXT4_EPOCH_MASK)))) {</span>
<span class="p_add">+#if LINUX_VERSION_CODE &lt; KERNEL_VERSION(4,20,0)</span>
<span class="p_add">+		/* Handle legacy encoding of pre-1970 dates with epoch</span>
<span class="p_add">+		 * bits 1,1.  We assume that by kernel version 4.20,</span>
<span class="p_add">+		 * everyone will have run fsck over the affected</span>
<span class="p_add">+		 * filesystems to correct the problem.  (This</span>
<span class="p_add">+		 * backwards compatibility may be removed before this</span>
<span class="p_add">+		 * time, at the discretion of the ext4 developers.)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		u64 extra_bits = le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK;</span>
<span class="p_add">+		if (extra_bits == 3 &amp;&amp; ((time-&gt;tv_sec) &amp; 0x80000000) != 0)</span>
<span class="p_add">+			extra_bits = 0;</span>
<span class="p_add">+		time-&gt;tv_sec += extra_bits &lt;&lt; 32;</span>
<span class="p_add">+#else</span>
<span class="p_add">+		time-&gt;tv_sec += (u64)(le32_to_cpu(extra) &amp; EXT4_EPOCH_MASK) &lt;&lt; 32;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+	time-&gt;tv_nsec = (le32_to_cpu(extra) &amp; EXT4_NSEC_MASK) &gt;&gt; EXT4_EPOCH_BITS;</span>
 }
 
 #define EXT4_INODE_SET_XTIME(xtime, inode, raw_inode)			       \
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index 510d4aa..f507e6220 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -850,6 +850,7 @@</span> <span class="p_context"> static ssize_t fuse_fill_write_pages(struct fuse_req *req,</span>
 
 		mark_page_accessed(page);
 
<span class="p_add">+		iov_iter_advance(ii, tmp);</span>
 		if (!tmp) {
 			unlock_page(page);
 			page_cache_release(page);
<span class="p_chunk">@@ -861,7 +862,6 @@</span> <span class="p_context"> static ssize_t fuse_fill_write_pages(struct fuse_req *req,</span>
 		req-&gt;pages[req-&gt;num_pages] = page;
 		req-&gt;num_pages++;
 
<span class="p_del">-		iov_iter_advance(ii, tmp);</span>
 		count += tmp;
 		pos += tmp;
 		offset += tmp;
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 86dc68a..e3c41c5 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -1876,6 +1876,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)</span>
 
 		if (!buffer_dirty(bh)) {
 			/* bdflush has written it.  We can drop it now */
<span class="p_add">+			__jbd2_journal_remove_checkpoint(jh);</span>
 			goto zap_buffer;
 		}
 
<span class="p_chunk">@@ -1913,6 +1914,7 @@</span> <span class="p_context"> static int journal_unmap_buffer(journal_t *journal, struct buffer_head *bh)</span>
 				/* The orphan record&#39;s transaction has
 				 * committed.  We can cleanse this buffer */
 				clear_buffer_jbddirty(bh);
<span class="p_add">+				__jbd2_journal_remove_checkpoint(jh);</span>
 				goto zap_buffer;
 			}
 		}
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index b78b5b6..a1503a7 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1389,7 +1389,11 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			nfsi-&gt;attrtimeo_timestamp = now;
 		}
 	}
<span class="p_del">-	invalid &amp;= ~NFS_INO_INVALID_ATTR;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Don&#39;t declare attrcache up to date if there were no attrs! */</span>
<span class="p_add">+	if (fattr-&gt;valid != 0)</span>
<span class="p_add">+		invalid &amp;= ~NFS_INO_INVALID_ATTR;</span>
<span class="p_add">+</span>
 	/* Don&#39;t invalidate the data if we were to blame */
 	if (!(S_ISREG(inode-&gt;i_mode) || S_ISDIR(inode-&gt;i_mode)
 				|| S_ISLNK(inode-&gt;i_mode)))
<span class="p_header">diff --git a/fs/partitions/mac.c b/fs/partitions/mac.c</span>
<span class="p_header">index 11f688b..f51c930 100644</span>
<span class="p_header">--- a/fs/partitions/mac.c</span>
<span class="p_header">+++ b/fs/partitions/mac.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	Sector sect;
 	unsigned char *data;
 	int slot, blocks_in_map;
<span class="p_del">-	unsigned secsize;</span>
<span class="p_add">+	unsigned secsize, datasize, partoffset;</span>
 #ifdef CONFIG_PPC_PMAC
 	int found_root = 0;
 	int found_root_goodness = 0;
<span class="p_chunk">@@ -50,10 +50,14 @@</span> <span class="p_context"> int mac_partition(struct parsed_partitions *state)</span>
 	}
 	secsize = be16_to_cpu(md-&gt;block_size);
 	put_dev_sector(sect);
<span class="p_del">-	data = read_part_sector(state, secsize/512, &amp;sect);</span>
<span class="p_add">+	datasize = round_down(secsize, 512);</span>
<span class="p_add">+	data = read_part_sector(state, datasize / 512, &amp;sect);</span>
 	if (!data)
 		return -1;
<span class="p_del">-	part = (struct mac_partition *) (data + secsize%512);</span>
<span class="p_add">+	partoffset = secsize % 512;</span>
<span class="p_add">+	if (partoffset + sizeof(*part) &gt; datasize)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+	part = (struct mac_partition *) (data + partoffset);</span>
 	if (be16_to_cpu(part-&gt;signature) != MAC_PARTITION_MAGIC) {
 		put_dev_sector(sect);
 		return 0;		/* not a MacOS disk */
<span class="p_header">diff --git a/fs/splice.c b/fs/splice.c</span>
<span class="p_header">index 8357b82..71c80f4 100644</span>
<span class="p_header">--- a/fs/splice.c</span>
<span class="p_header">+++ b/fs/splice.c</span>
<span class="p_chunk">@@ -872,6 +872,13 @@</span> <span class="p_context"> EXPORT_SYMBOL(splice_from_pipe_feed);</span>
  */
 int splice_from_pipe_next(struct pipe_inode_info *pipe, struct splice_desc *sd)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for signal early to make process killable when there are</span>
<span class="p_add">+	 * always buffers available</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (signal_pending(current))</span>
<span class="p_add">+		return -ERESTARTSYS;</span>
<span class="p_add">+</span>
 	while (!pipe-&gt;nrbufs) {
 		if (!pipe-&gt;writers)
 			return 0;
<span class="p_chunk">@@ -950,6 +957,7 @@</span> <span class="p_context"> ssize_t __splice_from_pipe(struct pipe_inode_info *pipe, struct splice_desc *sd,</span>
 
 	splice_from_pipe_begin(sd);
 	do {
<span class="p_add">+		cond_resched();</span>
 		ret = splice_from_pipe_next(pipe, sd);
 		if (ret &gt; 0)
 			ret = splice_from_pipe_feed(pipe, sd, actor);
<span class="p_header">diff --git a/fs/sysv/Makefile b/fs/sysv/Makefile</span>
<span class="p_header">index 3591f9d..7a75e70 100644</span>
<span class="p_header">--- a/fs/sysv/Makefile</span>
<span class="p_header">+++ b/fs/sysv/Makefile</span>
<span class="p_chunk">@@ -5,4 +5,4 @@</span> <span class="p_context"></span>
 obj-$(CONFIG_SYSV_FS) += sysv.o
 
 sysv-objs := ialloc.o balloc.o inode.o itree.o file.o dir.o \
<span class="p_del">-	     namei.o super.o symlink.o</span>
<span class="p_add">+	     namei.o super.o</span>
<span class="p_header">diff --git a/fs/sysv/inode.c b/fs/sysv/inode.c</span>
<span class="p_header">index 25ffb3e..dacc1e1 100644</span>
<span class="p_header">--- a/fs/sysv/inode.c</span>
<span class="p_header">+++ b/fs/sysv/inode.c</span>
<span class="p_chunk">@@ -176,14 +176,8 @@</span> <span class="p_context"> void sysv_set_inode(struct inode *inode, dev_t rdev)</span>
 		inode-&gt;i_fop = &amp;sysv_dir_operations;
 		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;
 	} else if (S_ISLNK(inode-&gt;i_mode)) {
<span class="p_del">-		if (inode-&gt;i_blocks) {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_del">-			inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			inode-&gt;i_op = &amp;sysv_fast_symlink_inode_operations;</span>
<span class="p_del">-			nd_terminate_link(SYSV_I(inode)-&gt;i_data, inode-&gt;i_size,</span>
<span class="p_del">-				sizeof(SYSV_I(inode)-&gt;i_data) - 1);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		inode-&gt;i_op = &amp;sysv_symlink_inode_operations;</span>
<span class="p_add">+		inode-&gt;i_mapping-&gt;a_ops = &amp;sysv_aops;</span>
 	} else
 		init_special_inode(inode, inode-&gt;i_mode, rdev);
 }
<span class="p_header">diff --git a/fs/sysv/symlink.c b/fs/sysv/symlink.c</span>
deleted file mode 100644
<span class="p_header">index 00d2f8a..0000000</span>
<span class="p_header">--- a/fs/sysv/symlink.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,20 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- *  linux/fs/sysv/symlink.c</span>
<span class="p_del">- *</span>
<span class="p_del">- *  Handling of System V filesystem fast symlinks extensions.</span>
<span class="p_del">- *  Aug 2001, Christoph Hellwig (hch@infradead.org)</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &quot;sysv.h&quot;</span>
<span class="p_del">-#include &lt;linux/namei.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-static void *sysv_follow_link(struct dentry *dentry, struct nameidata *nd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	nd_set_link(nd, (char *)SYSV_I(dentry-&gt;d_inode)-&gt;i_data);</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-const struct inode_operations sysv_fast_symlink_inode_operations = {</span>
<span class="p_del">-	.readlink	= generic_readlink,</span>
<span class="p_del">-	.follow_link	= sysv_follow_link,</span>
<span class="p_del">-};</span>
<span class="p_header">diff --git a/include/drm/drmP.h b/include/drm/drmP.h</span>
<span class="p_header">index bf4b2dc..e7cd03c 100644</span>
<span class="p_header">--- a/include/drm/drmP.h</span>
<span class="p_header">+++ b/include/drm/drmP.h</span>
<span class="p_chunk">@@ -430,6 +430,11 @@</span> <span class="p_context"> struct drm_file {</span>
 	void *driver_priv;
 
 	int is_master; /* this file private is a master for a minor */
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This client is allowed to gain master privileges for @master.</span>
<span class="p_add">+	 * Protected by struct drm_device::struct_mutex.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	unsigned allowed_master:1;</span>
 	struct drm_master *master; /* master this node is currently associated with
 				      N.B. not always minor-&gt;master */
 	struct list_head fbs;
<span class="p_chunk">@@ -1254,6 +1259,7 @@</span> <span class="p_context"> extern int drm_fasync(int fd, struct file *filp, int on);</span>
 extern ssize_t drm_read(struct file *filp, char __user *buffer,
 			size_t count, loff_t *offset);
 extern int drm_release(struct inode *inode, struct file *filp);
<span class="p_add">+extern int drm_new_set_master(struct drm_device *dev, struct drm_file *fpriv);</span>
 
 				/* Mapping support (drm_vm.h) */
 extern int drm_mmap(struct file *filp, struct vm_area_struct *vma);
<span class="p_header">diff --git a/include/linux/ipv6.h b/include/linux/ipv6.h</span>
<span class="p_header">index 84b1447..00ef00d 100644</span>
<span class="p_header">--- a/include/linux/ipv6.h</span>
<span class="p_header">+++ b/include/linux/ipv6.h</span>
<span class="p_chunk">@@ -369,7 +369,7 @@</span> <span class="p_context"> struct ipv6_pinfo {</span>
 	struct ipv6_ac_socklist	*ipv6_ac_list;
 	struct ipv6_fl_socklist *ipv6_fl_list;
 
<span class="p_del">-	struct ipv6_txoptions	*opt;</span>
<span class="p_add">+	struct ipv6_txoptions __rcu	*opt;</span>
 	struct sk_buff		*pktoptions;
 	struct sk_buff		*rxpmtu;
 	struct {
<span class="p_header">diff --git a/include/linux/lockdep.h b/include/linux/lockdep.h</span>
<span class="p_header">index b6a56e3..8b9bbf1 100644</span>
<span class="p_header">--- a/include/linux/lockdep.h</span>
<span class="p_header">+++ b/include/linux/lockdep.h</span>
<span class="p_chunk">@@ -342,6 +342,9 @@</span> <span class="p_context"> extern void lockdep_trace_alloc(gfp_t mask);</span>
 #define lockdep_depth(tsk)	(debug_locks ? (tsk)-&gt;lockdep_depth : 0)
 
 #define lockdep_assert_held(l)	WARN_ON(debug_locks &amp;&amp; !lockdep_is_held(l))
<span class="p_add">+#define lockdep_assert_held_once(l)	do {				\</span>
<span class="p_add">+		WARN_ON_ONCE(debug_locks &amp;&amp; !lockdep_is_held(l));	\</span>
<span class="p_add">+	} while (0)</span>
 
 #else /* !LOCKDEP */
 
<span class="p_chunk">@@ -362,6 +365,7 @@</span> <span class="p_context"> static inline void lockdep_on(void)</span>
 # define lockdep_trace_alloc(g)			do { } while (0)
 # define lockdep_init()				do { } while (0)
 # define lockdep_info()				do { } while (0)
<span class="p_add">+</span>
 # define lockdep_init_map(lock, name, key, sub) \
 		do { (void)(name); (void)(key); } while (0)
 # define lockdep_set_class(lock, key)		do { (void)(key); } while (0)
<span class="p_chunk">@@ -391,6 +395,7 @@</span> <span class="p_context"> struct lock_class_key { };</span>
 #define lockdep_depth(tsk)	(0)
 
 #define lockdep_assert_held(l)			do { } while (0)
<span class="p_add">+#define lockdep_assert_held_once(l)		do { (void)(l); } while (0)</span>
 
 #endif /* !LOCKDEP */
 
<span class="p_header">diff --git a/include/net/af_unix.h b/include/net/af_unix.h</span>
<span class="p_header">index 91ab5b0..f4842f7 100644</span>
<span class="p_header">--- a/include/net/af_unix.h</span>
<span class="p_header">+++ b/include/net/af_unix.h</span>
<span class="p_chunk">@@ -54,10 +54,12 @@</span> <span class="p_context"> struct unix_sock {</span>
 	struct list_head	link;
 	atomic_long_t		inflight;
 	spinlock_t		lock;
<span class="p_del">-	unsigned int		gc_candidate : 1;</span>
<span class="p_del">-	unsigned int		gc_maybe_cycle : 1;</span>
 	unsigned char		recursion_level;
<span class="p_add">+	unsigned long		gc_flags;</span>
<span class="p_add">+#define UNIX_GC_CANDIDATE	0</span>
<span class="p_add">+#define UNIX_GC_MAYBE_CYCLE	1</span>
 	struct socket_wq	peer_wq;
<span class="p_add">+	wait_queue_t		peer_wake;</span>
 };
 #define unix_sk(__sk) ((struct unix_sock *)__sk)
 
<span class="p_header">diff --git a/include/net/ipv6.h b/include/net/ipv6.h</span>
<span class="p_header">index ab2e6d7..25f0491 100644</span>
<span class="p_header">--- a/include/net/ipv6.h</span>
<span class="p_header">+++ b/include/net/ipv6.h</span>
<span class="p_chunk">@@ -191,6 +191,7 @@</span> <span class="p_context"> extern rwlock_t ip6_ra_lock;</span>
  */
 
 struct ipv6_txoptions {
<span class="p_add">+	atomic_t		refcnt;</span>
 	/* Length of this structure */
 	int			tot_len;
 
<span class="p_chunk">@@ -203,7 +204,7 @@</span> <span class="p_context"> struct ipv6_txoptions {</span>
 	struct ipv6_opt_hdr	*dst0opt;
 	struct ipv6_rt_hdr	*srcrt;	/* Routing Header */
 	struct ipv6_opt_hdr	*dst1opt;
<span class="p_del">-</span>
<span class="p_add">+	struct rcu_head		rcu;</span>
 	/* Option buffer, as read by IPV6_PKTOPTIONS, starts here. */
 };
 
<span class="p_chunk">@@ -229,6 +230,24 @@</span> <span class="p_context"> struct ipv6_fl_socklist {</span>
 	struct ip6_flowlabel	*fl;
 };
 
<span class="p_add">+static inline struct ipv6_txoptions *txopt_get(const struct ipv6_pinfo *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ipv6_txoptions *opt;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	opt = rcu_dereference(np-&gt;opt);</span>
<span class="p_add">+	if (opt &amp;&amp; !atomic_inc_not_zero(&amp;opt-&gt;refcnt))</span>
<span class="p_add">+		opt = NULL;</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return opt;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void txopt_put(struct ipv6_txoptions *opt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (opt &amp;&amp; atomic_dec_and_test(&amp;opt-&gt;refcnt))</span>
<span class="p_add">+		kfree_rcu(opt, rcu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern struct ip6_flowlabel	*fl6_sock_lookup(struct sock *sk, __be32 label);
 extern struct ipv6_txoptions	*fl6_merge_options(struct ipv6_txoptions * opt_space,
 						   struct ip6_flowlabel * fl,
<span class="p_chunk">@@ -382,6 +401,7 @@</span> <span class="p_context"> struct ip6_create_arg {</span>
 	u32 user;
 	const struct in6_addr *src;
 	const struct in6_addr *dst;
<span class="p_add">+	int iif;</span>
 };
 
 void ip6_frag_init(struct inet_frag_queue *q, void *a);
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index c8dcbb8..ce6f641 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -302,6 +302,7 @@</span> <span class="p_context"> struct sock {</span>
 				sk_no_check  : 2,
 				sk_userlocks : 4,
 				sk_protocol  : 8,
<span class="p_add">+#define SK_PROTOCOL_MAX ((u8)~0U)</span>
 				sk_type      : 16;
 	kmemcheck_bitfield_end(flags);
 	int			sk_wmem_queued;
<span class="p_chunk">@@ -565,6 +566,8 @@</span> <span class="p_context"> enum sock_flags {</span>
 	SOCK_ZEROCOPY, /* buffers from userspace */
 };
 
<span class="p_add">+#define SK_FLAGS_TIMESTAMP ((1UL &lt;&lt; SOCK_TIMESTAMP) | (1UL &lt;&lt; SOCK_TIMESTAMPING_RX_SOFTWARE))</span>
<span class="p_add">+</span>
 static inline void sock_copy_flags(struct sock *nsk, struct sock *osk)
 {
 	nsk-&gt;sk_flags = osk-&gt;sk_flags;
<span class="p_header">diff --git a/kernel/sched.c b/kernel/sched.c</span>
<span class="p_header">index 27c3092..a7a40b5 100644</span>
<span class="p_header">--- a/kernel/sched.c</span>
<span class="p_header">+++ b/kernel/sched.c</span>
<span class="p_chunk">@@ -2932,7 +2932,6 @@</span> <span class="p_context"> out:</span>
  */
 int wake_up_process(struct task_struct *p)
 {
<span class="p_del">-	WARN_ON(task_is_stopped_or_traced(p));</span>
 	return try_to_wake_up(p, TASK_NORMAL, 0);
 }
 EXPORT_SYMBOL(wake_up_process);
<span class="p_chunk">@@ -7171,11 +7170,11 @@</span> <span class="p_context"> static int init_rootdomain(struct root_domain *rd)</span>
 {
 	memset(rd, 0, sizeof(*rd));
 
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))</span>
 		goto out;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;online, GFP_KERNEL))</span>
 		goto free_span;
<span class="p_del">-	if (!alloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
<span class="p_add">+	if (!zalloc_cpumask_var(&amp;rd-&gt;rto_mask, GFP_KERNEL))</span>
 		goto free_online;
 
 	if (cpupri_init(&amp;rd-&gt;cpupri) != 0)
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index b252661..2a6f853 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -1581,12 +1581,6 @@</span> <span class="p_context"> rb_set_commit_to_write(struct ring_buffer_per_cpu *cpu_buffer)</span>
 		goto again;
 }
 
<span class="p_del">-static void rb_reset_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpu_buffer-&gt;read_stamp = cpu_buffer-&gt;reader_page-&gt;page-&gt;time_stamp;</span>
<span class="p_del">-	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rb_inc_iter(struct ring_buffer_iter *iter)
 {
 	struct ring_buffer_per_cpu *cpu_buffer = iter-&gt;cpu_buffer;
<span class="p_chunk">@@ -3064,7 +3058,7 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 
 	/* Finally update the reader page to the new head */
 	cpu_buffer-&gt;reader_page = reader;
<span class="p_del">-	rb_reset_reader_page(cpu_buffer);</span>
<span class="p_add">+	cpu_buffer-&gt;reader_page-&gt;read = 0;</span>
 
 	if (overwrite != cpu_buffer-&gt;last_overrun) {
 		cpu_buffer-&gt;lost_events = overwrite - cpu_buffer-&gt;last_overrun;
<span class="p_chunk">@@ -3074,6 +3068,10 @@</span> <span class="p_context"> rb_get_reader_page(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	goto again;
 
  out:
<span class="p_add">+	/* Update the read_stamp on the first event */</span>
<span class="p_add">+	if (reader &amp;&amp; reader-&gt;read == 0)</span>
<span class="p_add">+		cpu_buffer-&gt;read_stamp = reader-&gt;page-&gt;time_stamp;</span>
<span class="p_add">+</span>
 	arch_spin_unlock(&amp;cpu_buffer-&gt;lock);
 	local_irq_restore(flags);
 
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index 2b49dd2..17f5403 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -847,8 +847,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(congestion_wait);</span>
  * jiffies for either a BDI to exit congestion of the given @sync queue
  * or a write to complete.
  *
<span class="p_del">- * In the absence of zone congestion, cond_resched() is called to yield</span>
<span class="p_del">- * the processor if necessary but otherwise does not sleep.</span>
<span class="p_add">+ * In the absence of zone congestion, a short sleep or a cond_resched is</span>
<span class="p_add">+ * performed to yield the processor and to allow other subsystems to make</span>
<span class="p_add">+ * a forward progress.</span>
  *
  * The return value is 0 if the sleep is for the full timeout. Otherwise,
  * it is the number of jiffies that were still remaining when the function
<span class="p_chunk">@@ -868,7 +869,19 @@</span> <span class="p_context"> long wait_iff_congested(struct zone *zone, int sync, long timeout)</span>
 	 */
 	if (atomic_read(&amp;nr_bdi_congested[sync]) == 0 ||
 			!zone_is_reclaim_congested(zone)) {
<span class="p_del">-		cond_resched();</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Memory allocation/reclaim might be called from a WQ</span>
<span class="p_add">+		 * context and the current implementation of the WQ</span>
<span class="p_add">+		 * concurrency control doesn&#39;t recognize that a particular</span>
<span class="p_add">+		 * WQ is congested if the worker thread is looping without</span>
<span class="p_add">+		 * ever sleeping. Therefore we have to do a short sleep</span>
<span class="p_add">+		 * here rather than calling cond_resched().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (current-&gt;flags &amp; PF_WQ_WORKER)</span>
<span class="p_add">+			schedule_timeout(1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			cond_resched();</span>
 
 		/* In case we scheduled, work out time remaining */
 		ret = timeout - (jiffies - start);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 776c630..9256590 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -2818,12 +2818,12 @@</span> <span class="p_context"> int hugetlb_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		} else if (unlikely(is_hugetlb_entry_hwpoisoned(entry)))
 			return VM_FAULT_HWPOISON_LARGE |
 			       VM_FAULT_SET_HINDEX(h - hstates);
<span class="p_add">+	} else {</span>
<span class="p_add">+		ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_add">+		if (!ptep)</span>
<span class="p_add">+			return VM_FAULT_OOM;</span>
 	}
 
<span class="p_del">-	ptep = huge_pte_alloc(mm, address, huge_page_size(h));</span>
<span class="p_del">-	if (!ptep)</span>
<span class="p_del">-		return VM_FAULT_OOM;</span>
<span class="p_del">-</span>
 	/*
 	 * Serialize hugepage allocation and instantiation, so that we don&#39;t
 	 * get spurious allocation failures if two CPUs race to instantiate
<span class="p_header">diff --git a/mm/vmstat.c b/mm/vmstat.c</span>
<span class="p_header">index 8fd603b..14d8cb4 100644</span>
<span class="p_header">--- a/mm/vmstat.c</span>
<span class="p_header">+++ b/mm/vmstat.c</span>
<span class="p_chunk">@@ -1139,13 +1139,14 @@</span> <span class="p_context"> static const struct file_operations proc_vmstat_file_operations = {</span>
 #endif /* CONFIG_PROC_FS */
 
 #ifdef CONFIG_SMP
<span class="p_add">+static struct workqueue_struct *vmstat_wq;</span>
 static DEFINE_PER_CPU(struct delayed_work, vmstat_work);
 int sysctl_stat_interval __read_mostly = HZ;
 
 static void vmstat_update(struct work_struct *w)
 {
 	refresh_cpu_vm_stats(smp_processor_id());
<span class="p_del">-	schedule_delayed_work(&amp;__get_cpu_var(vmstat_work),</span>
<span class="p_add">+	queue_delayed_work(vmstat_wq, &amp;__get_cpu_var(vmstat_work),</span>
 		round_jiffies_relative(sysctl_stat_interval));
 }
 
<span class="p_chunk">@@ -1154,7 +1155,7 @@</span> <span class="p_context"> static void __cpuinit start_cpu_timer(int cpu)</span>
 	struct delayed_work *work = &amp;per_cpu(vmstat_work, cpu);
 
 	INIT_DELAYED_WORK_DEFERRABLE(work, vmstat_update);
<span class="p_del">-	schedule_delayed_work_on(cpu, work, __round_jiffies_relative(HZ, cpu));</span>
<span class="p_add">+	queue_delayed_work_on(cpu, vmstat_wq, work, __round_jiffies_relative(HZ, cpu));</span>
 }
 
 /*
<span class="p_chunk">@@ -1204,6 +1205,7 @@</span> <span class="p_context"> static int __init setup_vmstat(void)</span>
 
 	register_cpu_notifier(&amp;vmstat_notifier);
 
<span class="p_add">+	vmstat_wq = alloc_workqueue(&quot;vmstat&quot;, WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);</span>
 	for_each_online_cpu(cpu)
 		start_cpu_timer(cpu);
 #endif
<span class="p_header">diff --git a/net/ax25/af_ax25.c b/net/ax25/af_ax25.c</span>
<span class="p_header">index 7b8db0e..a314cfd 100644</span>
<span class="p_header">--- a/net/ax25/af_ax25.c</span>
<span class="p_header">+++ b/net/ax25/af_ax25.c</span>
<span class="p_chunk">@@ -806,6 +806,9 @@</span> <span class="p_context"> static int ax25_create(struct net *net, struct socket *sock, int protocol,</span>
 	struct sock *sk;
 	ax25_cb *ax25;
 
<span class="p_add">+	if (protocol &lt; 0 || protocol &gt; SK_PROTOCOL_MAX)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (!net_eq(net, &amp;init_net))
 		return -EAFNOSUPPORT;
 
<span class="p_header">diff --git a/net/bluetooth/sco.c b/net/bluetooth/sco.c</span>
<span class="p_header">index 2e80aee7..9f0e5a4 100644</span>
<span class="p_header">--- a/net/bluetooth/sco.c</span>
<span class="p_header">+++ b/net/bluetooth/sco.c</span>
<span class="p_chunk">@@ -475,6 +475,9 @@</span> <span class="p_context"> static int sco_sock_bind(struct socket *sock, struct sockaddr *addr, int addr_le</span>
 	if (!addr || addr-&gt;sa_family != AF_BLUETOOTH)
 		return -EINVAL;
 
<span class="p_add">+	if (addr_len &lt; sizeof(struct sockaddr_sco))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	lock_sock(sk);
 
 	if (sk-&gt;sk_state != BT_OPEN) {
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 7f43202..9a95205 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -5446,7 +5446,7 @@</span> <span class="p_context"> int __netdev_update_features(struct net_device *dev)</span>
 		netdev_err(dev,
 			&quot;set_features() failed (%d); wanted 0x%08x, left 0x%08x\n&quot;,
 			err, features, dev-&gt;features);
<span class="p_del">-		return -1;</span>
<span class="p_add">+		return 0;</span>
 	}
 
 	if (!err)
<span class="p_header">diff --git a/net/core/scm.c b/net/core/scm.c</span>
<span class="p_header">index ff52ad0..51b4d52 100644</span>
<span class="p_header">--- a/net/core/scm.c</span>
<span class="p_header">+++ b/net/core/scm.c</span>
<span class="p_chunk">@@ -311,6 +311,8 @@</span> <span class="p_context"> void scm_detach_fds(struct msghdr *msg, struct scm_cookie *scm)</span>
 			err = put_user(cmlen, &amp;cm-&gt;cmsg_len);
 		if (!err) {
 			cmlen = CMSG_SPACE(i*sizeof(int));
<span class="p_add">+			if (msg-&gt;msg_controllen &lt; cmlen)</span>
<span class="p_add">+				cmlen = msg-&gt;msg_controllen;</span>
 			msg-&gt;msg_control += cmlen;
 			msg-&gt;msg_controllen -= cmlen;
 		}
<span class="p_header">diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c</span>
<span class="p_header">index 592b78c..0987c89 100644</span>
<span class="p_header">--- a/net/dccp/ipv6.c</span>
<span class="p_header">+++ b/net/dccp/ipv6.c</span>
<span class="p_chunk">@@ -236,7 +236,6 @@</span> <span class="p_context"> static int dccp_v6_send_response(struct sock *sk, struct request_sock *req,</span>
 	struct inet6_request_sock *ireq6 = inet6_rsk(req);
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sk_buff *skb;
<span class="p_del">-	struct ipv6_txoptions *opt = NULL;</span>
 	struct in6_addr *final_p, final;
 	struct flowi6 fl6;
 	int err = -1;
<span class="p_chunk">@@ -252,9 +251,10 @@</span> <span class="p_context"> static int dccp_v6_send_response(struct sock *sk, struct request_sock *req,</span>
 	fl6.fl6_sport = inet_rsk(req)-&gt;loc_port;
 	security_req_classify_flow(req, flowi6_to_flowi(&amp;fl6));
 
<span class="p_del">-	opt = np-&gt;opt;</span>
 
<span class="p_del">-	final_p = fl6_update_dst(&amp;fl6, opt, &amp;final);</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	final_p = fl6_update_dst(&amp;fl6, rcu_dereference(np-&gt;opt), &amp;final);</span>
<span class="p_add">+	rcu_read_unlock();</span>
 
 	dst = ip6_dst_lookup_flow(sk, &amp;fl6, final_p, false);
 	if (IS_ERR(dst)) {
<span class="p_chunk">@@ -271,13 +271,14 @@</span> <span class="p_context"> static int dccp_v6_send_response(struct sock *sk, struct request_sock *req,</span>
 							 &amp;ireq6-&gt;loc_addr,
 							 &amp;ireq6-&gt;rmt_addr);
 		ipv6_addr_copy(&amp;fl6.daddr, &amp;ireq6-&gt;rmt_addr);
<span class="p_del">-		err = ip6_xmit(sk, skb, &amp;fl6, opt, np-&gt;tclass);</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		err = ip6_xmit(sk, skb, &amp;fl6, rcu_dereference(np-&gt;opt),</span>
<span class="p_add">+			       np-&gt;tclass);</span>
<span class="p_add">+		rcu_read_unlock();</span>
 		err = net_xmit_eval(err);
 	}
 
 done:
<span class="p_del">-	if (opt != NULL &amp;&amp; opt != np-&gt;opt)</span>
<span class="p_del">-		sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
 	dst_release(dst);
 	return err;
 }
<span class="p_chunk">@@ -467,10 +468,10 @@</span> <span class="p_context"> static struct sock *dccp_v6_request_recv_sock(struct sock *sk,</span>
 {
 	struct inet6_request_sock *ireq6 = inet6_rsk(req);
 	struct ipv6_pinfo *newnp, *np = inet6_sk(sk);
<span class="p_add">+	struct ipv6_txoptions *opt;</span>
 	struct inet_sock *newinet;
 	struct dccp6_sock *newdp6;
 	struct sock *newsk;
<span class="p_del">-	struct ipv6_txoptions *opt;</span>
 
 	if (skb-&gt;protocol == htons(ETH_P_IP)) {
 		/*
<span class="p_chunk">@@ -515,7 +516,6 @@</span> <span class="p_context"> static struct sock *dccp_v6_request_recv_sock(struct sock *sk,</span>
 		return newsk;
 	}
 
<span class="p_del">-	opt = np-&gt;opt;</span>
 
 	if (sk_acceptq_is_full(sk))
 		goto out_overflow;
<span class="p_chunk">@@ -527,7 +527,7 @@</span> <span class="p_context"> static struct sock *dccp_v6_request_recv_sock(struct sock *sk,</span>
 		memset(&amp;fl6, 0, sizeof(fl6));
 		fl6.flowi6_proto = IPPROTO_DCCP;
 		ipv6_addr_copy(&amp;fl6.daddr, &amp;ireq6-&gt;rmt_addr);
<span class="p_del">-		final_p = fl6_update_dst(&amp;fl6, opt, &amp;final);</span>
<span class="p_add">+		final_p = fl6_update_dst(&amp;fl6, np-&gt;opt, &amp;final);</span>
 		ipv6_addr_copy(&amp;fl6.saddr, &amp;ireq6-&gt;loc_addr);
 		fl6.flowi6_oif = sk-&gt;sk_bound_dev_if;
 		fl6.fl6_dport = inet_rsk(req)-&gt;rmt_port;
<span class="p_chunk">@@ -592,16 +592,15 @@</span> <span class="p_context"> static struct sock *dccp_v6_request_recv_sock(struct sock *sk,</span>
 	 * Yes, keeping reference count would be much more clever, but we make
 	 * one more one thing there: reattach optmem to newsk.
 	 */
<span class="p_del">-	if (opt != NULL) {</span>
<span class="p_del">-		newnp-&gt;opt = ipv6_dup_options(newsk, opt);</span>
<span class="p_del">-		if (opt != np-&gt;opt)</span>
<span class="p_del">-			sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
<span class="p_add">+	opt = rcu_dereference(np-&gt;opt);</span>
<span class="p_add">+	if (opt) {</span>
<span class="p_add">+		opt = ipv6_dup_options(newsk, opt);</span>
<span class="p_add">+		RCU_INIT_POINTER(newnp-&gt;opt, opt);</span>
 	}
<span class="p_del">-</span>
 	inet_csk(newsk)-&gt;icsk_ext_hdr_len = 0;
<span class="p_del">-	if (newnp-&gt;opt != NULL)</span>
<span class="p_del">-		inet_csk(newsk)-&gt;icsk_ext_hdr_len = (newnp-&gt;opt-&gt;opt_nflen +</span>
<span class="p_del">-						     newnp-&gt;opt-&gt;opt_flen);</span>
<span class="p_add">+	if (opt)</span>
<span class="p_add">+		inet_csk(newsk)-&gt;icsk_ext_hdr_len = opt-&gt;opt_nflen +</span>
<span class="p_add">+						    opt-&gt;opt_flen;</span>
 
 	dccp_sync_mss(newsk, dst_mtu(dst));
 
<span class="p_chunk">@@ -623,8 +622,6 @@</span> <span class="p_context"> out_nonewsk:</span>
 	dst_release(dst);
 out:
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);
<span class="p_del">-	if (opt != NULL &amp;&amp; opt != np-&gt;opt)</span>
<span class="p_del">-		sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
 	return NULL;
 }
 
<span class="p_chunk">@@ -855,6 +852,7 @@</span> <span class="p_context"> static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct dccp_sock *dp = dccp_sk(sk);
 	struct in6_addr *saddr = NULL, *final_p, final;
<span class="p_add">+	struct ipv6_txoptions *opt;</span>
 	struct flowi6 fl6;
 	struct dst_entry *dst;
 	int addr_type;
<span class="p_chunk">@@ -957,7 +955,8 @@</span> <span class="p_context"> static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	fl6.fl6_sport = inet-&gt;inet_sport;
 	security_sk_classify_flow(sk, flowi6_to_flowi(&amp;fl6));
 
<span class="p_del">-	final_p = fl6_update_dst(&amp;fl6, np-&gt;opt, &amp;final);</span>
<span class="p_add">+	opt = rcu_dereference_protected(np-&gt;opt, sock_owned_by_user(sk));</span>
<span class="p_add">+	final_p = fl6_update_dst(&amp;fl6, opt, &amp;final);</span>
 
 	dst = ip6_dst_lookup_flow(sk, &amp;fl6, final_p, true);
 	if (IS_ERR(dst)) {
<span class="p_chunk">@@ -977,9 +976,8 @@</span> <span class="p_context"> static int dccp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	__ip6_dst_store(sk, dst, NULL, NULL);
 
 	icsk-&gt;icsk_ext_hdr_len = 0;
<span class="p_del">-	if (np-&gt;opt != NULL)</span>
<span class="p_del">-		icsk-&gt;icsk_ext_hdr_len = (np-&gt;opt-&gt;opt_flen +</span>
<span class="p_del">-					  np-&gt;opt-&gt;opt_nflen);</span>
<span class="p_add">+	if (opt)</span>
<span class="p_add">+		icsk-&gt;icsk_ext_hdr_len = opt-&gt;opt_flen + opt-&gt;opt_nflen;</span>
 
 	inet-&gt;inet_dport = usin-&gt;sin6_port;
 
<span class="p_header">diff --git a/net/decnet/af_decnet.c b/net/decnet/af_decnet.c</span>
<span class="p_header">index 16fbf8c..c0486c8 100644</span>
<span class="p_header">--- a/net/decnet/af_decnet.c</span>
<span class="p_header">+++ b/net/decnet/af_decnet.c</span>
<span class="p_chunk">@@ -681,6 +681,9 @@</span> <span class="p_context"> static int dn_create(struct net *net, struct socket *sock, int protocol,</span>
 {
 	struct sock *sk;
 
<span class="p_add">+	if (protocol &lt; 0 || protocol &gt; SK_PROTOCOL_MAX)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (!net_eq(net, &amp;init_net))
 		return -EAFNOSUPPORT;
 
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index 5d228de..e2ab968 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -279,6 +279,9 @@</span> <span class="p_context"> static int inet_create(struct net *net, struct socket *sock, int protocol,</span>
 	int try_loading_module = 0;
 	int err;
 
<span class="p_add">+	if (protocol &lt; 0 || protocol &gt;= IPPROTO_MAX)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (unlikely(!inet_ehash_secret))
 		if (sock-&gt;type != SOCK_RAW &amp;&amp; sock-&gt;type != SOCK_DGRAM)
 			build_ehash_secret();
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 03e9486..d9c1d58 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -1866,7 +1866,7 @@</span> <span class="p_context"> int ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)</span>
 
 	rtnl_lock();
 	in_dev = ip_mc_find_dev(net, imr);
<span class="p_del">-	if (!in_dev) {</span>
<span class="p_add">+	if (!imr-&gt;imr_ifindex &amp;&amp; !imr-&gt;imr_address.s_addr &amp;&amp; !in_dev) {</span>
 		ret = -ENODEV;
 		goto out;
 	}
<span class="p_chunk">@@ -1887,7 +1887,8 @@</span> <span class="p_context"> int ip_mc_leave_group(struct sock *sk, struct ip_mreqn *imr)</span>
 
 		*imlp = iml-&gt;next_rcu;
 
<span class="p_del">-		ip_mc_dec_group(in_dev, group);</span>
<span class="p_add">+		if (in_dev)</span>
<span class="p_add">+			ip_mc_dec_group(in_dev, group);</span>
 		rtnl_unlock();
 		/* decrease mem now to avoid the memleak warning */
 		atomic_sub(sizeof(*iml), &amp;sk-&gt;sk_omem_alloc);
<span class="p_header">diff --git a/net/ipv4/ipmr.c b/net/ipv4/ipmr.c</span>
<span class="p_header">index 581dcb3..95b47ff 100644</span>
<span class="p_header">--- a/net/ipv4/ipmr.c</span>
<span class="p_header">+++ b/net/ipv4/ipmr.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> static int ipmr_cache_report(struct mr_table *mrt,</span>
 			     struct sk_buff *pkt, vifi_t vifi, int assert);
 static int __ipmr_fill_mroute(struct mr_table *mrt, struct sk_buff *skb,
 			      struct mfc_cache *c, struct rtmsg *rtm);
<span class="p_del">-static void mroute_clean_tables(struct mr_table *mrt);</span>
<span class="p_add">+static void mroute_clean_tables(struct mr_table *mrt, bool all);</span>
 static void ipmr_expire_process(unsigned long arg);
 
 #ifdef CONFIG_IP_MROUTE_MULTIPLE_TABLES
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static struct mr_table *ipmr_new_table(struct net *net, u32 id)</span>
 static void ipmr_free_table(struct mr_table *mrt)
 {
 	del_timer_sync(&amp;mrt-&gt;ipmr_expire_timer);
<span class="p_del">-	mroute_clean_tables(mrt);</span>
<span class="p_add">+	mroute_clean_tables(mrt, true);</span>
 	kfree(mrt);
 }
 
<span class="p_chunk">@@ -1143,7 +1143,7 @@</span> <span class="p_context"> static int ipmr_mfc_add(struct net *net, struct mr_table *mrt,</span>
  *	Close the multicast socket, and clear the vif tables etc
  */
 
<span class="p_del">-static void mroute_clean_tables(struct mr_table *mrt)</span>
<span class="p_add">+static void mroute_clean_tables(struct mr_table *mrt, bool all)</span>
 {
 	int i;
 	LIST_HEAD(list);
<span class="p_chunk">@@ -1152,8 +1152,9 @@</span> <span class="p_context"> static void mroute_clean_tables(struct mr_table *mrt)</span>
 	/* Shut down all active vif entries */
 
 	for (i = 0; i &lt; mrt-&gt;maxvif; i++) {
<span class="p_del">-		if (!(mrt-&gt;vif_table[i].flags &amp; VIFF_STATIC))</span>
<span class="p_del">-			vif_delete(mrt, i, 0, &amp;list);</span>
<span class="p_add">+		if (!all &amp;&amp; (mrt-&gt;vif_table[i].flags &amp; VIFF_STATIC))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		vif_delete(mrt, i, 0, &amp;list);</span>
 	}
 	unregister_netdevice_many(&amp;list);
 
<span class="p_chunk">@@ -1161,7 +1162,7 @@</span> <span class="p_context"> static void mroute_clean_tables(struct mr_table *mrt)</span>
 
 	for (i = 0; i &lt; MFC_LINES; i++) {
 		list_for_each_entry_safe(c, next, &amp;mrt-&gt;mfc_cache_array[i], list) {
<span class="p_del">-			if (c-&gt;mfc_flags &amp; MFC_STATIC)</span>
<span class="p_add">+			if (!all &amp;&amp; (c-&gt;mfc_flags &amp; MFC_STATIC))</span>
 				continue;
 			list_del_rcu(&amp;c-&gt;list);
 			ipmr_cache_free(c);
<span class="p_chunk">@@ -1191,7 +1192,7 @@</span> <span class="p_context"> static void mrtsock_destruct(struct sock *sk)</span>
 		if (sk == rtnl_dereference(mrt-&gt;mroute_sk)) {
 			IPV4_DEVCONF_ALL(net, MC_FORWARDING)--;
 			RCU_INIT_POINTER(mrt-&gt;mroute_sk, NULL);
<span class="p_del">-			mroute_clean_tables(mrt);</span>
<span class="p_add">+			mroute_clean_tables(mrt, false);</span>
 		}
 	}
 	rtnl_unlock();
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index f8b5899..3877e16 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -5811,6 +5811,7 @@</span> <span class="p_context"> discard:</span>
 		}
 
 		tp-&gt;rcv_nxt = TCP_SKB_CB(skb)-&gt;seq + 1;
<span class="p_add">+		tp-&gt;copied_seq = tp-&gt;rcv_nxt;</span>
 		tp-&gt;rcv_wup = TCP_SKB_CB(skb)-&gt;seq + 1;
 
 		/* RFC1323: The window in SYN &amp; SYN/ACK segments is
<span class="p_header">diff --git a/net/ipv6/af_inet6.c b/net/ipv6/af_inet6.c</span>
<span class="p_header">index d27c797..d578137 100644</span>
<span class="p_header">--- a/net/ipv6/af_inet6.c</span>
<span class="p_header">+++ b/net/ipv6/af_inet6.c</span>
<span class="p_chunk">@@ -109,6 +109,9 @@</span> <span class="p_context"> static int inet6_create(struct net *net, struct socket *sock, int protocol,</span>
 	int try_loading_module = 0;
 	int err;
 
<span class="p_add">+	if (protocol &lt; 0 || protocol &gt;= IPPROTO_MAX)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (sock-&gt;type != SOCK_RAW &amp;&amp;
 	    sock-&gt;type != SOCK_DGRAM &amp;&amp;
 	    !inet_ehash_secret)
<span class="p_chunk">@@ -430,8 +433,11 @@</span> <span class="p_context"> void inet6_destroy_sock(struct sock *sk)</span>
 
 	/* Free tx options */
 
<span class="p_del">-	if ((opt = xchg(&amp;np-&gt;opt, NULL)) != NULL)</span>
<span class="p_del">-		sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
<span class="p_add">+	opt = xchg((__force struct ipv6_txoptions **)&amp;np-&gt;opt, NULL);</span>
<span class="p_add">+	if (opt) {</span>
<span class="p_add">+		atomic_sub(opt-&gt;tot_len, &amp;sk-&gt;sk_omem_alloc);</span>
<span class="p_add">+		txopt_put(opt);</span>
<span class="p_add">+	}</span>
 }
 
 EXPORT_SYMBOL_GPL(inet6_destroy_sock);
<span class="p_chunk">@@ -669,7 +675,10 @@</span> <span class="p_context"> int inet6_sk_rebuild_header(struct sock *sk)</span>
 		fl6.fl6_sport = inet-&gt;inet_sport;
 		security_sk_classify_flow(sk, flowi6_to_flowi(&amp;fl6));
 
<span class="p_del">-		final_p = fl6_update_dst(&amp;fl6, np-&gt;opt, &amp;final);</span>
<span class="p_add">+		rcu_read_lock();</span>
<span class="p_add">+		final_p = fl6_update_dst(&amp;fl6, rcu_dereference(np-&gt;opt),</span>
<span class="p_add">+					 &amp;final);</span>
<span class="p_add">+		rcu_read_unlock();</span>
 
 		dst = ip6_dst_lookup_flow(sk, &amp;fl6, final_p, false);
 		if (IS_ERR(dst)) {
<span class="p_header">diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c</span>
<span class="p_header">index 67f3632..9e4bacc 100644</span>
<span class="p_header">--- a/net/ipv6/datagram.c</span>
<span class="p_header">+++ b/net/ipv6/datagram.c</span>
<span class="p_chunk">@@ -166,8 +166,10 @@</span> <span class="p_context"> ipv4_connected:</span>
 
 	security_sk_classify_flow(sk, flowi6_to_flowi(&amp;fl6));
 
<span class="p_del">-	opt = flowlabel ? flowlabel-&gt;opt : np-&gt;opt;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	opt = flowlabel ? flowlabel-&gt;opt : rcu_dereference(np-&gt;opt);</span>
 	final_p = fl6_update_dst(&amp;fl6, opt, &amp;final);
<span class="p_add">+	rcu_read_unlock();</span>
 
 	dst = ip6_dst_lookup_flow(sk, &amp;fl6, final_p, true);
 	err = 0;
<span class="p_header">diff --git a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c</span>
<span class="p_header">index bf22a22..ef7b872 100644</span>
<span class="p_header">--- a/net/ipv6/exthdrs.c</span>
<span class="p_header">+++ b/net/ipv6/exthdrs.c</span>
<span class="p_chunk">@@ -748,6 +748,7 @@</span> <span class="p_context"> ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)</span>
 			*((char**)&amp;opt2-&gt;dst1opt) += dif;
 		if (opt2-&gt;srcrt)
 			*((char**)&amp;opt2-&gt;srcrt) += dif;
<span class="p_add">+		atomic_set(&amp;opt2-&gt;refcnt, 1);</span>
 	}
 	return opt2;
 }
<span class="p_chunk">@@ -812,7 +813,7 @@</span> <span class="p_context"> ipv6_renew_options(struct sock *sk, struct ipv6_txoptions *opt,</span>
 		return ERR_PTR(-ENOBUFS);
 
 	memset(opt2, 0, tot_len);
<span class="p_del">-</span>
<span class="p_add">+	atomic_set(&amp;opt2-&gt;refcnt, 1);</span>
 	opt2-&gt;tot_len = tot_len;
 	p = (char *)(opt2 + 1);
 
<span class="p_header">diff --git a/net/ipv6/inet6_connection_sock.c b/net/ipv6/inet6_connection_sock.c</span>
<span class="p_header">index 1567fb1..a232371 100644</span>
<span class="p_header">--- a/net/ipv6/inet6_connection_sock.c</span>
<span class="p_header">+++ b/net/ipv6/inet6_connection_sock.c</span>
<span class="p_chunk">@@ -66,7 +66,9 @@</span> <span class="p_context"> struct dst_entry *inet6_csk_route_req(struct sock *sk,</span>
 	memset(&amp;fl6, 0, sizeof(fl6));
 	fl6.flowi6_proto = IPPROTO_TCP;
 	ipv6_addr_copy(&amp;fl6.daddr, &amp;treq-&gt;rmt_addr);
<span class="p_del">-	final_p = fl6_update_dst(&amp;fl6, np-&gt;opt, &amp;final);</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	final_p = fl6_update_dst(&amp;fl6, rcu_dereference(np-&gt;opt), &amp;final);</span>
<span class="p_add">+	rcu_read_unlock();</span>
 	ipv6_addr_copy(&amp;fl6.saddr, &amp;treq-&gt;loc_addr);
 	fl6.flowi6_oif = sk-&gt;sk_bound_dev_if;
 	fl6.flowi6_mark = sk-&gt;sk_mark;
<span class="p_chunk">@@ -225,7 +227,9 @@</span> <span class="p_context"> int inet6_csk_xmit(struct sk_buff *skb, struct flowi *fl_unused)</span>
 	fl6.fl6_dport = inet-&gt;inet_dport;
 	security_sk_classify_flow(sk, flowi6_to_flowi(&amp;fl6));
 
<span class="p_del">-	final_p = fl6_update_dst(&amp;fl6, np-&gt;opt, &amp;final);</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	final_p = fl6_update_dst(&amp;fl6, rcu_dereference(np-&gt;opt), &amp;final);</span>
<span class="p_add">+	rcu_read_unlock();</span>
 
 	dst = __inet6_csk_dst_check(sk, np-&gt;dst_cookie);
 
<span class="p_chunk">@@ -248,7 +252,8 @@</span> <span class="p_context"> int inet6_csk_xmit(struct sk_buff *skb, struct flowi *fl_unused)</span>
 	/* Restore final destination back after routing done */
 	ipv6_addr_copy(&amp;fl6.daddr, &amp;np-&gt;daddr);
 
<span class="p_del">-	res = ip6_xmit(sk, skb, &amp;fl6, np-&gt;opt, np-&gt;tclass);</span>
<span class="p_add">+	res = ip6_xmit(sk, skb, &amp;fl6, rcu_dereference(np-&gt;opt),</span>
<span class="p_add">+		       np-&gt;tclass);</span>
 	rcu_read_unlock();
 	return res;
 }
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index 99ee86d..02b3c82 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -118,7 +118,7 @@</span> <span class="p_context"> static int __ip6mr_fill_mroute(struct mr6_table *mrt, struct sk_buff *skb,</span>
 			       struct mfc6_cache *c, struct rtmsg *rtm);
 static int ip6mr_rtm_dumproute(struct sk_buff *skb,
 			       struct netlink_callback *cb);
<span class="p_del">-static void mroute_clean_tables(struct mr6_table *mrt);</span>
<span class="p_add">+static void mroute_clean_tables(struct mr6_table *mrt, bool all);</span>
 static void ipmr_expire_process(unsigned long arg);
 
 #ifdef CONFIG_IPV6_MROUTE_MULTIPLE_TABLES
<span class="p_chunk">@@ -334,8 +334,8 @@</span> <span class="p_context"> static struct mr6_table *ip6mr_new_table(struct net *net, u32 id)</span>
 
 static void ip6mr_free_table(struct mr6_table *mrt)
 {
<span class="p_del">-	del_timer(&amp;mrt-&gt;ipmr_expire_timer);</span>
<span class="p_del">-	mroute_clean_tables(mrt);</span>
<span class="p_add">+	del_timer_sync(&amp;mrt-&gt;ipmr_expire_timer);</span>
<span class="p_add">+	mroute_clean_tables(mrt, true);</span>
 	kfree(mrt);
 }
 
<span class="p_chunk">@@ -1473,7 +1473,7 @@</span> <span class="p_context"> static int ip6mr_mfc_add(struct net *net, struct mr6_table *mrt,</span>
  *	Close the multicast socket, and clear the vif tables etc
  */
 
<span class="p_del">-static void mroute_clean_tables(struct mr6_table *mrt)</span>
<span class="p_add">+static void mroute_clean_tables(struct mr6_table *mrt, bool all)</span>
 {
 	int i;
 	LIST_HEAD(list);
<span class="p_chunk">@@ -1483,8 +1483,9 @@</span> <span class="p_context"> static void mroute_clean_tables(struct mr6_table *mrt)</span>
 	 *	Shut down all active vif entries
 	 */
 	for (i = 0; i &lt; mrt-&gt;maxvif; i++) {
<span class="p_del">-		if (!(mrt-&gt;vif6_table[i].flags &amp; VIFF_STATIC))</span>
<span class="p_del">-			mif6_delete(mrt, i, &amp;list);</span>
<span class="p_add">+		if (!all &amp;&amp; (mrt-&gt;vif6_table[i].flags &amp; VIFF_STATIC))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		mif6_delete(mrt, i, &amp;list);</span>
 	}
 	unregister_netdevice_many(&amp;list);
 
<span class="p_chunk">@@ -1493,7 +1494,7 @@</span> <span class="p_context"> static void mroute_clean_tables(struct mr6_table *mrt)</span>
 	 */
 	for (i = 0; i &lt; MFC6_LINES; i++) {
 		list_for_each_entry_safe(c, next, &amp;mrt-&gt;mfc6_cache_array[i], list) {
<span class="p_del">-			if (c-&gt;mfc_flags &amp; MFC_STATIC)</span>
<span class="p_add">+			if (!all &amp;&amp; (c-&gt;mfc_flags &amp; MFC_STATIC))</span>
 				continue;
 			write_lock_bh(&amp;mrt_lock);
 			list_del(&amp;c-&gt;list);
<span class="p_chunk">@@ -1547,7 +1548,7 @@</span> <span class="p_context"> int ip6mr_sk_done(struct sock *sk)</span>
 			net-&gt;ipv6.devconf_all-&gt;mc_forwarding--;
 			write_unlock_bh(&amp;mrt_lock);
 
<span class="p_del">-			mroute_clean_tables(mrt);</span>
<span class="p_add">+			mroute_clean_tables(mrt, false);</span>
 			err = 0;
 			break;
 		}
<span class="p_header">diff --git a/net/ipv6/ipv6_sockglue.c b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">index b204df8..9af3f5c 100644</span>
<span class="p_header">--- a/net/ipv6/ipv6_sockglue.c</span>
<span class="p_header">+++ b/net/ipv6/ipv6_sockglue.c</span>
<span class="p_chunk">@@ -110,10 +110,12 @@</span> <span class="p_context"> struct ipv6_txoptions *ipv6_update_options(struct sock *sk,</span>
 			icsk-&gt;icsk_ext_hdr_len = opt-&gt;opt_flen + opt-&gt;opt_nflen;
 			icsk-&gt;icsk_sync_mss(sk, icsk-&gt;icsk_pmtu_cookie);
 		}
<span class="p_del">-		opt = xchg(&amp;inet6_sk(sk)-&gt;opt, opt);</span>
<span class="p_add">+		opt = xchg((__force struct ipv6_txoptions **)&amp;inet6_sk(sk)-&gt;opt,</span>
<span class="p_add">+			   opt);</span>
 	} else {
 		spin_lock(&amp;sk-&gt;sk_dst_lock);
<span class="p_del">-		opt = xchg(&amp;inet6_sk(sk)-&gt;opt, opt);</span>
<span class="p_add">+		opt = xchg((__force struct ipv6_txoptions **)&amp;inet6_sk(sk)-&gt;opt,</span>
<span class="p_add">+			   opt);</span>
 		spin_unlock(&amp;sk-&gt;sk_dst_lock);
 	}
 	sk_dst_reset(sk);
<span class="p_chunk">@@ -213,9 +215,12 @@</span> <span class="p_context"> static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,</span>
 				sk-&gt;sk_socket-&gt;ops = &amp;inet_dgram_ops;
 				sk-&gt;sk_family = PF_INET;
 			}
<span class="p_del">-			opt = xchg(&amp;np-&gt;opt, NULL);</span>
<span class="p_del">-			if (opt)</span>
<span class="p_del">-				sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
<span class="p_add">+			opt = xchg((__force struct ipv6_txoptions **)&amp;np-&gt;opt,</span>
<span class="p_add">+				   NULL);</span>
<span class="p_add">+			if (opt) {</span>
<span class="p_add">+				atomic_sub(opt-&gt;tot_len, &amp;sk-&gt;sk_omem_alloc);</span>
<span class="p_add">+				txopt_put(opt);</span>
<span class="p_add">+			}</span>
 			pktopt = xchg(&amp;np-&gt;pktoptions, NULL);
 			kfree_skb(pktopt);
 
<span class="p_chunk">@@ -384,7 +389,8 @@</span> <span class="p_context"> static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,</span>
 		if (optname != IPV6_RTHDR &amp;&amp; !capable(CAP_NET_RAW))
 			break;
 
<span class="p_del">-		opt = ipv6_renew_options(sk, np-&gt;opt, optname,</span>
<span class="p_add">+		opt = rcu_dereference_protected(np-&gt;opt, sock_owned_by_user(sk));</span>
<span class="p_add">+		opt = ipv6_renew_options(sk, opt, optname,</span>
 					 (struct ipv6_opt_hdr __user *)optval,
 					 optlen);
 		if (IS_ERR(opt)) {
<span class="p_chunk">@@ -413,8 +419,10 @@</span> <span class="p_context"> static int do_ipv6_setsockopt(struct sock *sk, int level, int optname,</span>
 		retv = 0;
 		opt = ipv6_update_options(sk, opt);
 sticky_done:
<span class="p_del">-		if (opt)</span>
<span class="p_del">-			sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
<span class="p_add">+		if (opt) {</span>
<span class="p_add">+			atomic_sub(opt-&gt;tot_len, &amp;sk-&gt;sk_omem_alloc);</span>
<span class="p_add">+			txopt_put(opt);</span>
<span class="p_add">+		}</span>
 		break;
 	}
 
<span class="p_chunk">@@ -467,6 +475,7 @@</span> <span class="p_context"> sticky_done:</span>
 			break;
 
 		memset(opt, 0, sizeof(*opt));
<span class="p_add">+		atomic_set(&amp;opt-&gt;refcnt, 1);</span>
 		opt-&gt;tot_len = sizeof(*opt) + optlen;
 		retv = -EFAULT;
 		if (copy_from_user(opt+1, optval, optlen))
<span class="p_chunk">@@ -483,8 +492,10 @@</span> <span class="p_context"> update:</span>
 		retv = 0;
 		opt = ipv6_update_options(sk, opt);
 done:
<span class="p_del">-		if (opt)</span>
<span class="p_del">-			sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
<span class="p_add">+		if (opt) {</span>
<span class="p_add">+			atomic_sub(opt-&gt;tot_len, &amp;sk-&gt;sk_omem_alloc);</span>
<span class="p_add">+			txopt_put(opt);</span>
<span class="p_add">+		}</span>
 		break;
 	}
 	case IPV6_UNICAST_HOPS:
<span class="p_chunk">@@ -1053,10 +1064,11 @@</span> <span class="p_context"> static int do_ipv6_getsockopt(struct sock *sk, int level, int optname,</span>
 	case IPV6_RTHDR:
 	case IPV6_DSTOPTS:
 	{
<span class="p_add">+		struct ipv6_txoptions *opt;</span>
 
 		lock_sock(sk);
<span class="p_del">-		len = ipv6_getsockopt_sticky(sk, np-&gt;opt,</span>
<span class="p_del">-					     optname, optval, len);</span>
<span class="p_add">+		opt = rcu_dereference_protected(np-&gt;opt, sock_owned_by_user(sk));</span>
<span class="p_add">+		len = ipv6_getsockopt_sticky(sk, opt, optname, optval, len);</span>
 		release_sock(sk);
 		/* check if ipv6_getsockopt_sticky() returns err code */
 		if (len &lt; 0)
<span class="p_header">diff --git a/net/ipv6/mcast.c b/net/ipv6/mcast.c</span>
<span class="p_header">index 7bb6644..9129a7c 100644</span>
<span class="p_header">--- a/net/ipv6/mcast.c</span>
<span class="p_header">+++ b/net/ipv6/mcast.c</span>
<span class="p_chunk">@@ -1441,7 +1441,6 @@</span> <span class="p_context"> out:</span>
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS(net, idev, ICMPV6_MLD2_REPORT);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
<span class="p_del">-		IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, payload_len);</span>
 	} else {
 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
 	}
<span class="p_chunk">@@ -1811,7 +1810,6 @@</span> <span class="p_context"> out:</span>
 	if (!err) {
 		ICMP6MSGOUT_INC_STATS(net, idev, type);
 		ICMP6_INC_STATS(net, idev, ICMP6_MIB_OUTMSGS);
<span class="p_del">-		IP6_UPD_PO_STATS(net, idev, IPSTATS_MIB_OUTMCAST, full_len);</span>
 	} else
 		IP6_INC_STATS(net, idev, IPSTATS_MIB_OUTDISCARDS);
 
<span class="p_header">diff --git a/net/ipv6/netfilter/nf_conntrack_reasm.c b/net/ipv6/netfilter/nf_conntrack_reasm.c</span>
<span class="p_header">index 52e2f65..2252b87 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/nf_conntrack_reasm.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/nf_conntrack_reasm.c</span>
<span class="p_chunk">@@ -162,7 +162,7 @@</span> <span class="p_context"> out:</span>
 /* Creation primitives. */
 
 static __inline__ struct nf_ct_frag6_queue *
<span class="p_del">-fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)</span>
<span class="p_add">+fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst, int iif)</span>
 {
 	struct inet_frag_queue *q;
 	struct ip6_create_arg arg;
<span class="p_chunk">@@ -172,6 +172,7 @@</span> <span class="p_context"> fq_find(__be32 id, u32 user, struct in6_addr *src, struct in6_addr *dst)</span>
 	arg.user = user;
 	arg.src = src;
 	arg.dst = dst;
<span class="p_add">+	arg.iif = iif;</span>
 
 	read_lock_bh(&amp;nf_frags.lock);
 	hash = inet6_hash_frag(id, src, dst, nf_frags.rnd);
<span class="p_chunk">@@ -558,7 +559,8 @@</span> <span class="p_context"> struct sk_buff *nf_ct_frag6_gather(struct sk_buff *skb, u32 user)</span>
 	if (atomic_read(&amp;nf_init_frags.mem) &gt; nf_init_frags.high_thresh)
 		nf_ct_frag6_evictor();
 
<span class="p_del">-	fq = fq_find(fhdr-&gt;identification, user, &amp;hdr-&gt;saddr, &amp;hdr-&gt;daddr);</span>
<span class="p_add">+	fq = fq_find(fhdr-&gt;identification, user, &amp;hdr-&gt;saddr, &amp;hdr-&gt;daddr,</span>
<span class="p_add">+		     skb-&gt;dev ? skb-&gt;dev-&gt;ifindex : 0);</span>
 	if (fq == NULL) {
 		pr_debug(&quot;Can&#39;t find and can&#39;t create new queue\n&quot;);
 		goto ret_orig;
<span class="p_header">diff --git a/net/ipv6/raw.c b/net/ipv6/raw.c</span>
<span class="p_header">index 240c102f..d1e528c 100644</span>
<span class="p_header">--- a/net/ipv6/raw.c</span>
<span class="p_header">+++ b/net/ipv6/raw.c</span>
<span class="p_chunk">@@ -724,6 +724,7 @@</span> <span class="p_context"> static int rawv6_probe_proto_opt(struct flowi6 *fl6, struct msghdr *msg)</span>
 static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,
 		   struct msghdr *msg, size_t len)
 {
<span class="p_add">+	struct ipv6_txoptions *opt_to_free = NULL;</span>
 	struct ipv6_txoptions opt_space;
 	struct sockaddr_in6 * sin6 = (struct sockaddr_in6 *) msg-&gt;msg_name;
 	struct in6_addr *daddr, *final_p, final;
<span class="p_chunk">@@ -830,8 +831,10 @@</span> <span class="p_context"> static int rawv6_sendmsg(struct kiocb *iocb, struct sock *sk,</span>
 		if (!(opt-&gt;opt_nflen|opt-&gt;opt_flen))
 			opt = NULL;
 	}
<span class="p_del">-	if (opt == NULL)</span>
<span class="p_del">-		opt = np-&gt;opt;</span>
<span class="p_add">+	if (!opt) {</span>
<span class="p_add">+		opt = txopt_get(np);</span>
<span class="p_add">+		opt_to_free = opt;</span>
<span class="p_add">+	}</span>
 	if (flowlabel)
 		opt = fl6_merge_options(&amp;opt_space, flowlabel, opt);
 	opt = ipv6_fixup_options(&amp;opt_space, opt);
<span class="p_chunk">@@ -896,6 +899,7 @@</span> <span class="p_context"> done:</span>
 	dst_release(dst);
 out:
 	fl6_sock_release(flowlabel);
<span class="p_add">+	txopt_put(opt_to_free);</span>
 	return err&lt;0?err:len;
 do_confirm:
 	dst_confirm(dst);
<span class="p_header">diff --git a/net/ipv6/reassembly.c b/net/ipv6/reassembly.c</span>
<span class="p_header">index eba5deb..5378faa 100644</span>
<span class="p_header">--- a/net/ipv6/reassembly.c</span>
<span class="p_header">+++ b/net/ipv6/reassembly.c</span>
<span class="p_chunk">@@ -144,8 +144,11 @@</span> <span class="p_context"> int ip6_frag_match(struct inet_frag_queue *q, void *a)</span>
 
 	fq = container_of(q, struct frag_queue, q);
 	return (fq-&gt;id == arg-&gt;id &amp;&amp; fq-&gt;user == arg-&gt;user &amp;&amp;
<span class="p_del">-			ipv6_addr_equal(&amp;fq-&gt;saddr, arg-&gt;src) &amp;&amp;</span>
<span class="p_del">-			ipv6_addr_equal(&amp;fq-&gt;daddr, arg-&gt;dst));</span>
<span class="p_add">+		ipv6_addr_equal(&amp;fq-&gt;saddr, arg-&gt;src) &amp;&amp;</span>
<span class="p_add">+		ipv6_addr_equal(&amp;fq-&gt;daddr, arg-&gt;dst) &amp;&amp;</span>
<span class="p_add">+		(arg-&gt;iif == fq-&gt;iif ||</span>
<span class="p_add">+		 !(ipv6_addr_type(arg-&gt;dst) &amp; (IPV6_ADDR_MULTICAST |</span>
<span class="p_add">+					       IPV6_ADDR_LINKLOCAL))));</span>
 }
 EXPORT_SYMBOL(ip6_frag_match);
 
<span class="p_chunk">@@ -228,7 +231,8 @@</span> <span class="p_context"> out:</span>
 }
 
 static __inline__ struct frag_queue *
<span class="p_del">-fq_find(struct net *net, __be32 id, const struct in6_addr *src, const struct in6_addr *dst)</span>
<span class="p_add">+fq_find(struct net *net, __be32 id, const struct in6_addr *src,</span>
<span class="p_add">+	const struct in6_addr *dst, int iif)</span>
 {
 	struct inet_frag_queue *q;
 	struct ip6_create_arg arg;
<span class="p_chunk">@@ -238,6 +242,7 @@</span> <span class="p_context"> fq_find(struct net *net, __be32 id, const struct in6_addr *src, const struct in6</span>
 	arg.user = IP6_DEFRAG_LOCAL_DELIVER;
 	arg.src = src;
 	arg.dst = dst;
<span class="p_add">+	arg.iif = iif;</span>
 
 	read_lock(&amp;ip6_frags.lock);
 	hash = inet6_hash_frag(id, src, dst, ip6_frags.rnd);
<span class="p_chunk">@@ -583,7 +588,8 @@</span> <span class="p_context"> static int ipv6_frag_rcv(struct sk_buff *skb)</span>
 	if (atomic_read(&amp;net-&gt;ipv6.frags.mem) &gt; net-&gt;ipv6.frags.high_thresh)
 		ip6_evictor(net, ip6_dst_idev(skb_dst(skb)));
 
<span class="p_del">-	fq = fq_find(net, fhdr-&gt;identification, &amp;hdr-&gt;saddr, &amp;hdr-&gt;daddr);</span>
<span class="p_add">+	fq = fq_find(net, fhdr-&gt;identification, &amp;hdr-&gt;saddr, &amp;hdr-&gt;daddr,</span>
<span class="p_add">+		     skb-&gt;dev ? skb-&gt;dev-&gt;ifindex : 0);</span>
 	if (fq != NULL) {
 		int ret;
 
<span class="p_header">diff --git a/net/ipv6/syncookies.c b/net/ipv6/syncookies.c</span>
<span class="p_header">index 5a0d664..cfc6284 100644</span>
<span class="p_header">--- a/net/ipv6/syncookies.c</span>
<span class="p_header">+++ b/net/ipv6/syncookies.c</span>
<span class="p_chunk">@@ -238,7 +238,7 @@</span> <span class="p_context"> struct sock *cookie_v6_check(struct sock *sk, struct sk_buff *skb)</span>
 		memset(&amp;fl6, 0, sizeof(fl6));
 		fl6.flowi6_proto = IPPROTO_TCP;
 		ipv6_addr_copy(&amp;fl6.daddr, &amp;ireq6-&gt;rmt_addr);
<span class="p_del">-		final_p = fl6_update_dst(&amp;fl6, np-&gt;opt, &amp;final);</span>
<span class="p_add">+		final_p = fl6_update_dst(&amp;fl6, rcu_dereference(np-&gt;opt), &amp;final);</span>
 		ipv6_addr_copy(&amp;fl6.saddr, &amp;ireq6-&gt;loc_addr);
 		fl6.flowi6_oif = sk-&gt;sk_bound_dev_if;
 		fl6.flowi6_mark = sk-&gt;sk_mark;
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 655cc60..0170679 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -131,6 +131,7 @@</span> <span class="p_context"> static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct in6_addr *saddr = NULL, *final_p, final;
<span class="p_add">+	struct ipv6_txoptions *opt;</span>
 	struct rt6_info *rt;
 	struct flowi6 fl6;
 	struct dst_entry *dst;
<span class="p_chunk">@@ -252,7 +253,8 @@</span> <span class="p_context"> static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	fl6.fl6_dport = usin-&gt;sin6_port;
 	fl6.fl6_sport = inet-&gt;inet_sport;
 
<span class="p_del">-	final_p = fl6_update_dst(&amp;fl6, np-&gt;opt, &amp;final);</span>
<span class="p_add">+	opt = rcu_dereference_protected(np-&gt;opt, sock_owned_by_user(sk));</span>
<span class="p_add">+	final_p = fl6_update_dst(&amp;fl6, opt, &amp;final);</span>
 
 	security_sk_classify_flow(sk, flowi6_to_flowi(&amp;fl6));
 
<span class="p_chunk">@@ -295,9 +297,9 @@</span> <span class="p_context"> static int tcp_v6_connect(struct sock *sk, struct sockaddr *uaddr,</span>
 	}
 
 	icsk-&gt;icsk_ext_hdr_len = 0;
<span class="p_del">-	if (np-&gt;opt)</span>
<span class="p_del">-		icsk-&gt;icsk_ext_hdr_len = (np-&gt;opt-&gt;opt_flen +</span>
<span class="p_del">-					  np-&gt;opt-&gt;opt_nflen);</span>
<span class="p_add">+	if (opt)</span>
<span class="p_add">+		icsk-&gt;icsk_ext_hdr_len = opt-&gt;opt_flen +</span>
<span class="p_add">+					 opt-&gt;opt_nflen;</span>
 
 	tp-&gt;rx_opt.mss_clamp = IPV6_MIN_MTU - sizeof(struct tcphdr) - sizeof(struct ipv6hdr);
 
<span class="p_chunk">@@ -481,7 +483,6 @@</span> <span class="p_context"> static int tcp_v6_send_synack(struct sock *sk, struct request_sock *req,</span>
 	struct inet6_request_sock *treq = inet6_rsk(req);
 	struct ipv6_pinfo *np = inet6_sk(sk);
 	struct sk_buff * skb;
<span class="p_del">-	struct ipv6_txoptions *opt = NULL;</span>
 	struct in6_addr * final_p, final;
 	struct flowi6 fl6;
 	struct dst_entry *dst;
<span class="p_chunk">@@ -498,8 +499,7 @@</span> <span class="p_context"> static int tcp_v6_send_synack(struct sock *sk, struct request_sock *req,</span>
 	fl6.fl6_sport = inet_rsk(req)-&gt;loc_port;
 	security_req_classify_flow(req, flowi6_to_flowi(&amp;fl6));
 
<span class="p_del">-	opt = np-&gt;opt;</span>
<span class="p_del">-	final_p = fl6_update_dst(&amp;fl6, opt, &amp;final);</span>
<span class="p_add">+	final_p = fl6_update_dst(&amp;fl6, rcu_dereference(np-&gt;opt), &amp;final);</span>
 
 	dst = ip6_dst_lookup_flow(sk, &amp;fl6, final_p, false);
 	if (IS_ERR(dst)) {
<span class="p_chunk">@@ -513,13 +513,12 @@</span> <span class="p_context"> static int tcp_v6_send_synack(struct sock *sk, struct request_sock *req,</span>
 		__tcp_v6_send_check(skb, &amp;treq-&gt;loc_addr, &amp;treq-&gt;rmt_addr);
 
 		ipv6_addr_copy(&amp;fl6.daddr, &amp;treq-&gt;rmt_addr);
<span class="p_del">-		err = ip6_xmit(sk, skb, &amp;fl6, opt, np-&gt;tclass);</span>
<span class="p_add">+		err = ip6_xmit(sk, skb, &amp;fl6, rcu_dereference(np-&gt;opt),</span>
<span class="p_add">+			       np-&gt;tclass);</span>
 		err = net_xmit_eval(err);
 	}
 
 done:
<span class="p_del">-	if (opt &amp;&amp; opt != np-&gt;opt)</span>
<span class="p_del">-		sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
 	dst_release(dst);
 	return err;
 }
<span class="p_chunk">@@ -1408,7 +1407,6 @@</span> <span class="p_context"> static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,</span>
 	}
 
 	treq = inet6_rsk(req);
<span class="p_del">-	opt = np-&gt;opt;</span>
 
 	if (sk_acceptq_is_full(sk))
 		goto out_overflow;
<span class="p_chunk">@@ -1476,16 +1474,15 @@</span> <span class="p_context"> static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,</span>
 	   but we make one more one thing there: reattach optmem
 	   to newsk.
 	 */
<span class="p_add">+	opt = rcu_dereference(np-&gt;opt);</span>
 	if (opt) {
<span class="p_del">-		newnp-&gt;opt = ipv6_dup_options(newsk, opt);</span>
<span class="p_del">-		if (opt != np-&gt;opt)</span>
<span class="p_del">-			sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
<span class="p_add">+		opt = ipv6_dup_options(newsk, opt);</span>
<span class="p_add">+		RCU_INIT_POINTER(newnp-&gt;opt, opt);</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	inet_csk(newsk)-&gt;icsk_ext_hdr_len = 0;</span>
<span class="p_del">-	if (newnp-&gt;opt)</span>
<span class="p_del">-		inet_csk(newsk)-&gt;icsk_ext_hdr_len = (newnp-&gt;opt-&gt;opt_nflen +</span>
<span class="p_del">-						     newnp-&gt;opt-&gt;opt_flen);</span>
<span class="p_add">+ 	inet_csk(newsk)-&gt;icsk_ext_hdr_len = 0;</span>
<span class="p_add">+	if (opt)</span>
<span class="p_add">+		inet_csk(newsk)-&gt;icsk_ext_hdr_len = opt-&gt;opt_nflen +</span>
<span class="p_add">+						    opt-&gt;opt_flen;</span>
 
 	tcp_mtup_init(newsk);
 	tcp_sync_mss(newsk, dst_mtu(dst));
<span class="p_chunk">@@ -1530,8 +1527,6 @@</span> <span class="p_context"> static struct sock * tcp_v6_syn_recv_sock(struct sock *sk, struct sk_buff *skb,</span>
 out_overflow:
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENOVERFLOWS);
 out_nonewsk:
<span class="p_del">-	if (opt &amp;&amp; opt != np-&gt;opt)</span>
<span class="p_del">-		sock_kfree_s(sk, opt, opt-&gt;tot_len);</span>
 	dst_release(dst);
 out:
 	NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_LISTENDROPS);
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index 888892e..3308803 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -954,6 +954,7 @@</span> <span class="p_context"> int udpv6_sendmsg(struct kiocb *iocb, struct sock *sk,</span>
 	struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *) msg-&gt;msg_name;
 	struct in6_addr *daddr, *final_p, final;
 	struct ipv6_txoptions *opt = NULL;
<span class="p_add">+	struct ipv6_txoptions *opt_to_free = NULL;</span>
 	struct ip6_flowlabel *flowlabel = NULL;
 	struct flowi6 fl6;
 	struct dst_entry *dst;
<span class="p_chunk">@@ -1107,8 +1108,10 @@</span> <span class="p_context"> do_udp_sendmsg:</span>
 			opt = NULL;
 		connected = 0;
 	}
<span class="p_del">-	if (opt == NULL)</span>
<span class="p_del">-		opt = np-&gt;opt;</span>
<span class="p_add">+	if (!opt) {</span>
<span class="p_add">+		opt = txopt_get(np);</span>
<span class="p_add">+		opt_to_free = opt;</span>
<span class="p_add">+	}</span>
 	if (flowlabel)
 		opt = fl6_merge_options(&amp;opt_space, flowlabel, opt);
 	opt = ipv6_fixup_options(&amp;opt_space, opt);
<span class="p_chunk">@@ -1208,6 +1211,7 @@</span> <span class="p_context"> do_append_data:</span>
 out:
 	dst_release(dst);
 	fl6_sock_release(flowlabel);
<span class="p_add">+	txopt_put(opt_to_free);</span>
 	if (!err)
 		return len;
 	/*
<span class="p_header">diff --git a/net/irda/af_irda.c b/net/irda/af_irda.c</span>
<span class="p_header">index f5d011a..03c8ea9 100644</span>
<span class="p_header">--- a/net/irda/af_irda.c</span>
<span class="p_header">+++ b/net/irda/af_irda.c</span>
<span class="p_chunk">@@ -1106,6 +1106,9 @@</span> <span class="p_context"> static int irda_create(struct net *net, struct socket *sock, int protocol,</span>
 
 	IRDA_DEBUG(2, &quot;%s()\n&quot;, __func__);
 
<span class="p_add">+	if (protocol &lt; 0 || protocol &gt; SK_PROTOCOL_MAX)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (net != &amp;init_net)
 		return -EAFNOSUPPORT;
 
<span class="p_header">diff --git a/net/mac80211/mesh_pathtbl.c b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">index 7f54c50..806157d 100644</span>
<span class="p_header">--- a/net/mac80211/mesh_pathtbl.c</span>
<span class="p_header">+++ b/net/mac80211/mesh_pathtbl.c</span>
<span class="p_chunk">@@ -779,10 +779,8 @@</span> <span class="p_context"> void mesh_plink_broken(struct sta_info *sta)</span>
 static void mesh_path_node_reclaim(struct rcu_head *rp)
 {
 	struct mpath_node *node = container_of(rp, struct mpath_node, rcu);
<span class="p_del">-	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
 
 	del_timer_sync(&amp;node-&gt;mpath-&gt;timer);
<span class="p_del">-	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	kfree(node-&gt;mpath);
 	kfree(node);
 }
<span class="p_chunk">@@ -790,8 +788,9 @@</span> <span class="p_context"> static void mesh_path_node_reclaim(struct rcu_head *rp)</span>
 /* needs to be called with the corresponding hashwlock taken */
 static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)
 {
<span class="p_del">-	struct mesh_path *mpath;</span>
<span class="p_del">-	mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct mesh_path *mpath = node-&gt;mpath;</span>
<span class="p_add">+	struct ieee80211_sub_if_data *sdata = node-&gt;mpath-&gt;sdata;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;mpath-&gt;state_lock);
 	mpath-&gt;flags |= MESH_PATH_RESOLVING;
 	if (mpath-&gt;is_gate)
<span class="p_chunk">@@ -799,6 +798,7 @@</span> <span class="p_context"> static void __mesh_path_del(struct mesh_table *tbl, struct mpath_node *node)</span>
 	hlist_del_rcu(&amp;node-&gt;list);
 	call_rcu(&amp;node-&gt;rcu, mesh_path_node_reclaim);
 	spin_unlock(&amp;mpath-&gt;state_lock);
<span class="p_add">+	atomic_dec(&amp;sdata-&gt;u.mesh.mpaths);</span>
 	atomic_dec(&amp;tbl-&gt;entries);
 }
 
<span class="p_header">diff --git a/net/rds/connection.c b/net/rds/connection.c</span>
<span class="p_header">index be3eecd..9e07c75 100644</span>
<span class="p_header">--- a/net/rds/connection.c</span>
<span class="p_header">+++ b/net/rds/connection.c</span>
<span class="p_chunk">@@ -178,12 +178,6 @@</span> <span class="p_context"> static struct rds_connection *__rds_conn_create(__be32 laddr, __be32 faddr,</span>
 		}
 	}
 
<span class="p_del">-	if (trans == NULL) {</span>
<span class="p_del">-		kmem_cache_free(rds_conn_slab, conn);</span>
<span class="p_del">-		conn = ERR_PTR(-ENODEV);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	conn-&gt;c_trans = trans;
 
 	ret = trans-&gt;conn_alloc(conn, gfp);
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index 88eace5..31c9fa4 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -955,11 +955,13 @@</span> <span class="p_context"> int rds_sendmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,</span>
 		release_sock(sk);
 	}
 
<span class="p_del">-	/* racing with another thread binding seems ok here */</span>
<span class="p_add">+	lock_sock(sk);</span>
 	if (daddr == 0 || rs-&gt;rs_bound_addr == 0) {
<span class="p_add">+		release_sock(sk);</span>
 		ret = -ENOTCONN; /* XXX not a great errno */
 		goto out;
 	}
<span class="p_add">+	release_sock(sk);</span>
 
 	/* size of rm including all sgs */
 	ret = rds_rm_size(msg, payload_len);
<span class="p_header">diff --git a/net/sctp/auth.c b/net/sctp/auth.c</span>
<span class="p_header">index 53d455c..c428d9e 100644</span>
<span class="p_header">--- a/net/sctp/auth.c</span>
<span class="p_header">+++ b/net/sctp/auth.c</span>
<span class="p_chunk">@@ -804,8 +804,8 @@</span> <span class="p_context"> int sctp_auth_ep_set_hmacs(struct sctp_endpoint *ep,</span>
 	if (!has_sha1)
 		return -EINVAL;
 
<span class="p_del">-	memcpy(ep-&gt;auth_hmacs_list-&gt;hmac_ids, &amp;hmacs-&gt;shmac_idents[0],</span>
<span class="p_del">-		hmacs-&gt;shmac_num_idents * sizeof(__u16));</span>
<span class="p_add">+	for (i = 0; i &lt; hmacs-&gt;shmac_num_idents; i++)</span>
<span class="p_add">+		ep-&gt;auth_hmacs_list-&gt;hmac_ids[i] = htons(hmacs-&gt;shmac_idents[i]);</span>
 	ep-&gt;auth_hmacs_list-&gt;param_hdr.length = htons(sizeof(sctp_paramhdr_t) +
 				hmacs-&gt;shmac_num_idents * sizeof(__u16));
 	return 0;
<span class="p_header">diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c</span>
<span class="p_header">index 0b6a391..1f9a6f7 100644</span>
<span class="p_header">--- a/net/sctp/ipv6.c</span>
<span class="p_header">+++ b/net/sctp/ipv6.c</span>
<span class="p_chunk">@@ -635,6 +635,7 @@</span> <span class="p_context"> static struct sock *sctp_v6_create_accept_sk(struct sock *sk,</span>
 	struct sock *newsk;
 	struct ipv6_pinfo *newnp, *np = inet6_sk(sk);
 	struct sctp6_sock *newsctp6sk;
<span class="p_add">+	struct ipv6_txoptions *opt;</span>
 
 	newsk = sk_alloc(sock_net(sk), PF_INET6, GFP_KERNEL, sk-&gt;sk_prot);
 	if (!newsk)
<span class="p_chunk">@@ -654,6 +655,13 @@</span> <span class="p_context"> static struct sock *sctp_v6_create_accept_sk(struct sock *sk,</span>
 
 	memcpy(newnp, np, sizeof(struct ipv6_pinfo));
 
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	opt = rcu_dereference(np-&gt;opt);</span>
<span class="p_add">+	if (opt)</span>
<span class="p_add">+		opt = ipv6_dup_options(newsk, opt);</span>
<span class="p_add">+	RCU_INIT_POINTER(newnp-&gt;opt, opt);</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	/* Initialize sk&#39;s sport, dport, rcv_saddr and daddr for getsockname()
 	 * and getpeername().
 	 */
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 24e88af..396283b 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -6731,6 +6731,9 @@</span> <span class="p_context"> void sctp_copy_sock(struct sock *newsk, struct sock *sk,</span>
 	newinet-&gt;mc_ttl = 1;
 	newinet-&gt;mc_index = 0;
 	newinet-&gt;mc_list = NULL;
<span class="p_add">+</span>
<span class="p_add">+	if (newsk-&gt;sk_flags &amp; SK_FLAGS_TIMESTAMP)</span>
<span class="p_add">+		net_enable_timestamp();</span>
 }
 
 static inline void sctp_copy_descendant(struct sock *sk_to,
<span class="p_chunk">@@ -6910,6 +6913,13 @@</span> <span class="p_context"> struct proto sctp_prot = {</span>
 
 #if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
 
<span class="p_add">+#include &lt;net/transp_v6.h&gt;</span>
<span class="p_add">+static void sctp_v6_destroy_sock(struct sock *sk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sctp_destroy_sock(sk);</span>
<span class="p_add">+	inet6_destroy_sock(sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct proto sctpv6_prot = {
 	.name		= &quot;SCTPv6&quot;,
 	.owner		= THIS_MODULE,
<span class="p_chunk">@@ -6919,7 +6929,7 @@</span> <span class="p_context"> struct proto sctpv6_prot = {</span>
 	.accept		= sctp_accept,
 	.ioctl		= sctp_ioctl,
 	.init		= sctp_init_sock,
<span class="p_del">-	.destroy	= sctp_destroy_sock,</span>
<span class="p_add">+	.destroy	= sctp_v6_destroy_sock,</span>
 	.shutdown	= sctp_shutdown,
 	.setsockopt	= sctp_setsockopt,
 	.getsockopt	= sctp_getsockopt,
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 9b1f371..e60fbcd 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -303,6 +303,118 @@</span> <span class="p_context"> found:</span>
 	return s;
 }
 
<span class="p_add">+/* Support code for asymmetrically connected dgram sockets</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If a datagram socket is connected to a socket not itself connected</span>
<span class="p_add">+ * to the first socket (eg, /dev/log), clients may only enqueue more</span>
<span class="p_add">+ * messages if the present receive queue of the server socket is not</span>
<span class="p_add">+ * &quot;too large&quot;. This means there&#39;s a second writeability condition</span>
<span class="p_add">+ * poll and sendmsg need to test. The dgram recv code will do a wake</span>
<span class="p_add">+ * up on the peer_wait wait queue of a socket upon reception of a</span>
<span class="p_add">+ * datagram which needs to be propagated to sleeping would-be writers</span>
<span class="p_add">+ * since these might not have sent anything so far. This can&#39;t be</span>
<span class="p_add">+ * accomplished via poll_wait because the lifetime of the server</span>
<span class="p_add">+ * socket might be less than that of its clients if these break their</span>
<span class="p_add">+ * association with it or if the server socket is closed while clients</span>
<span class="p_add">+ * are still connected to it and there&#39;s no way to inform &quot;a polling</span>
<span class="p_add">+ * implementation&quot; that it should let go of a certain wait queue</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to propagate a wake up, a wait_queue_t of the client</span>
<span class="p_add">+ * socket is enqueued on the peer_wait queue of the server socket</span>
<span class="p_add">+ * whose wake function does a wake_up on the ordinary client socket</span>
<span class="p_add">+ * wait queue. This connection is established whenever a write (or</span>
<span class="p_add">+ * poll for write) hit the flow control condition and broken when the</span>
<span class="p_add">+ * association to the server socket is dissolved or after a wake up</span>
<span class="p_add">+ * was relayed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,</span>
<span class="p_add">+				      void *key)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct unix_sock *u;</span>
<span class="p_add">+	wait_queue_head_t *u_sleep;</span>
<span class="p_add">+</span>
<span class="p_add">+	u = container_of(q, struct unix_sock, peer_wake);</span>
<span class="p_add">+</span>
<span class="p_add">+	__remove_wait_queue(&amp;unix_sk(u-&gt;peer_wake.private)-&gt;peer_wait,</span>
<span class="p_add">+			    q);</span>
<span class="p_add">+	u-&gt;peer_wake.private = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* relaying can only happen while the wq still exists */</span>
<span class="p_add">+	u_sleep = sk_sleep(&amp;u-&gt;sk);</span>
<span class="p_add">+	if (u_sleep)</span>
<span class="p_add">+		wake_up_interruptible_poll(u_sleep, key);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct unix_sock *u, *u_other;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	u = unix_sk(sk);</span>
<span class="p_add">+	u_other = unix_sk(other);</span>
<span class="p_add">+	rc = 0;</span>
<span class="p_add">+	spin_lock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!u-&gt;peer_wake.private) {</span>
<span class="p_add">+		u-&gt;peer_wake.private = other;</span>
<span class="p_add">+		__add_wait_queue(&amp;u_other-&gt;peer_wait, &amp;u-&gt;peer_wake);</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void unix_dgram_peer_wake_disconnect(struct sock *sk,</span>
<span class="p_add">+					    struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct unix_sock *u, *u_other;</span>
<span class="p_add">+</span>
<span class="p_add">+	u = unix_sk(sk);</span>
<span class="p_add">+	u_other = unix_sk(other);</span>
<span class="p_add">+	spin_lock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (u-&gt;peer_wake.private == other) {</span>
<span class="p_add">+		__remove_wait_queue(&amp;u_other-&gt;peer_wait, &amp;u-&gt;peer_wake);</span>
<span class="p_add">+		u-&gt;peer_wake.private = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;u_other-&gt;peer_wait.lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void unix_dgram_peer_wake_disconnect_wakeup(struct sock *sk,</span>
<span class="p_add">+						   struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unix_dgram_peer_wake_disconnect(sk, other);</span>
<span class="p_add">+	wake_up_interruptible_poll(sk_sleep(sk),</span>
<span class="p_add">+				   POLLOUT |</span>
<span class="p_add">+				   POLLWRNORM |</span>
<span class="p_add">+				   POLLWRBAND);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* preconditions:</span>
<span class="p_add">+ *	- unix_peer(sk) == other</span>
<span class="p_add">+ *	- association is stable</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int unix_dgram_peer_wake_me(struct sock *sk, struct sock *other)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int connected;</span>
<span class="p_add">+</span>
<span class="p_add">+	connected = unix_dgram_peer_wake_connect(sk, other);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unix_recvq_full(other))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (connected)</span>
<span class="p_add">+		unix_dgram_peer_wake_disconnect(sk, other);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int unix_writable(struct sock *sk)
 {
 	return (atomic_read(&amp;sk-&gt;sk_wmem_alloc) &lt;&lt; 2) &lt;= sk-&gt;sk_sndbuf;
<span class="p_chunk">@@ -409,6 +521,8 @@</span> <span class="p_context"> static void unix_release_sock(struct sock *sk, int embrion)</span>
 			skpair-&gt;sk_state_change(skpair);
 			sk_wake_async(skpair, SOCK_WAKE_WAITD, POLL_HUP);
 		}
<span class="p_add">+</span>
<span class="p_add">+		unix_dgram_peer_wake_disconnect(sk, skpair);</span>
 		sock_put(skpair); /* It may now die */
 		unix_peer(sk) = NULL;
 	}
<span class="p_chunk">@@ -630,6 +744,7 @@</span> <span class="p_context"> static struct sock *unix_create1(struct net *net, struct socket *sock)</span>
 	INIT_LIST_HEAD(&amp;u-&gt;link);
 	mutex_init(&amp;u-&gt;readlock); /* single task reading lock */
 	init_waitqueue_head(&amp;u-&gt;peer_wait);
<span class="p_add">+	init_waitqueue_func_entry(&amp;u-&gt;peer_wake, unix_dgram_peer_wake_relay);</span>
 	unix_insert_socket(unix_sockets_unbound, sk);
 out:
 	if (sk == NULL)
<span class="p_chunk">@@ -1005,6 +1120,8 @@</span> <span class="p_context"> restart:</span>
 	if (unix_peer(sk)) {
 		struct sock *old_peer = unix_peer(sk);
 		unix_peer(sk) = other;
<span class="p_add">+		unix_dgram_peer_wake_disconnect_wakeup(sk, old_peer);</span>
<span class="p_add">+</span>
 		unix_state_double_unlock(sk, other);
 
 		if (other != old_peer)
<span class="p_chunk">@@ -1444,6 +1561,7 @@</span> <span class="p_context"> static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,</span>
 	long timeo;
 	struct scm_cookie tmp_scm;
 	int max_level;
<span class="p_add">+	int sk_locked;</span>
 
 	if (NULL == siocb-&gt;scm)
 		siocb-&gt;scm = &amp;tmp_scm;
<span class="p_chunk">@@ -1512,12 +1630,14 @@</span> <span class="p_context"> restart:</span>
 		goto out_free;
 	}
 
<span class="p_add">+	sk_locked = 0;</span>
 	unix_state_lock(other);
<span class="p_add">+restart_locked:</span>
 	err = -EPERM;
 	if (!unix_may_send(sk, other))
 		goto out_unlock;
 
<span class="p_del">-	if (sock_flag(other, SOCK_DEAD)) {</span>
<span class="p_add">+	if (unlikely(sock_flag(other, SOCK_DEAD))) {</span>
 		/*
 		 *	Check with 1003.1g - what should
 		 *	datagram error
<span class="p_chunk">@@ -1525,10 +1645,14 @@</span> <span class="p_context"> restart:</span>
 		unix_state_unlock(other);
 		sock_put(other);
 
<span class="p_add">+		if (!sk_locked)</span>
<span class="p_add">+			unix_state_lock(sk);</span>
<span class="p_add">+</span>
 		err = 0;
<span class="p_del">-		unix_state_lock(sk);</span>
 		if (unix_peer(sk) == other) {
 			unix_peer(sk) = NULL;
<span class="p_add">+			unix_dgram_peer_wake_disconnect_wakeup(sk, other);</span>
<span class="p_add">+</span>
 			unix_state_unlock(sk);
 
 			unix_dgram_disconnected(sk, other);
<span class="p_chunk">@@ -1554,21 +1678,38 @@</span> <span class="p_context"> restart:</span>
 			goto out_unlock;
 	}
 
<span class="p_del">-	if (unix_peer(other) != sk &amp;&amp; unix_recvq_full(other)) {</span>
<span class="p_del">-		if (!timeo) {</span>
<span class="p_del">-			err = -EAGAIN;</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_add">+	if (unlikely(unix_peer(other) != sk &amp;&amp; unix_recvq_full(other))) {</span>
<span class="p_add">+		if (timeo) {</span>
<span class="p_add">+			timeo = unix_wait_for_peer(other, timeo);</span>
<span class="p_add">+</span>
<span class="p_add">+			err = sock_intr_errno(timeo);</span>
<span class="p_add">+			if (signal_pending(current))</span>
<span class="p_add">+				goto out_free;</span>
<span class="p_add">+</span>
<span class="p_add">+			goto restart;</span>
 		}
 
<span class="p_del">-		timeo = unix_wait_for_peer(other, timeo);</span>
<span class="p_add">+		if (!sk_locked) {</span>
<span class="p_add">+			unix_state_unlock(other);</span>
<span class="p_add">+			unix_state_double_lock(sk, other);</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		err = sock_intr_errno(timeo);</span>
<span class="p_del">-		if (signal_pending(current))</span>
<span class="p_del">-			goto out_free;</span>
<span class="p_add">+		if (unix_peer(sk) != other ||</span>
<span class="p_add">+		    unix_dgram_peer_wake_me(sk, other)) {</span>
<span class="p_add">+			err = -EAGAIN;</span>
<span class="p_add">+			sk_locked = 1;</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		goto restart;</span>
<span class="p_add">+		if (!sk_locked) {</span>
<span class="p_add">+			sk_locked = 1;</span>
<span class="p_add">+			goto restart_locked;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_add">+	if (unlikely(sk_locked))</span>
<span class="p_add">+		unix_state_unlock(sk);</span>
<span class="p_add">+</span>
 	if (sock_flag(other, SOCK_RCVTSTAMP))
 		__net_timestamp(skb);
 	maybe_add_creds(skb, sock, other);
<span class="p_chunk">@@ -1582,6 +1723,8 @@</span> <span class="p_context"> restart:</span>
 	return len;
 
 out_unlock:
<span class="p_add">+	if (sk_locked)</span>
<span class="p_add">+		unix_state_unlock(sk);</span>
 	unix_state_unlock(other);
 out_free:
 	kfree_skb(skb);
<span class="p_chunk">@@ -1770,14 +1913,7 @@</span> <span class="p_context"> static int unix_dgram_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 	if (flags&amp;MSG_OOB)
 		goto out;
 
<span class="p_del">-	err = mutex_lock_interruptible(&amp;u-&gt;readlock);</span>
<span class="p_del">-	if (unlikely(err)) {</span>
<span class="p_del">-		/* recvmsg() in non blocking mode is supposed to return -EAGAIN</span>
<span class="p_del">-		 * sk_rcvtimeo is not honored by mutex_lock_interruptible()</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		err = noblock ? -EAGAIN : -ERESTARTSYS;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	mutex_lock(&amp;u-&gt;readlock);</span>
 
 	skb = skb_recv_datagram(sk, flags, noblock, &amp;err);
 	if (!skb) {
<span class="p_chunk">@@ -1962,12 +2098,12 @@</span> <span class="p_context"> static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 
 			timeo = unix_stream_data_wait(sk, timeo);
 
<span class="p_del">-			if (signal_pending(current)</span>
<span class="p_del">-			    ||  mutex_lock_interruptible(&amp;u-&gt;readlock)) {</span>
<span class="p_add">+			if (signal_pending(current)) {</span>
 				err = sock_intr_errno(timeo);
 				goto out;
 			}
 
<span class="p_add">+			mutex_lock(&amp;u-&gt;readlock);</span>
 			continue;
  unlock:
 			unix_state_unlock(sk);
<span class="p_chunk">@@ -2186,14 +2322,16 @@</span> <span class="p_context"> static unsigned int unix_dgram_poll(struct file *file, struct socket *sock,</span>
 		return mask;
 
 	writable = unix_writable(sk);
<span class="p_del">-	other = unix_peer_get(sk);</span>
<span class="p_del">-	if (other) {</span>
<span class="p_del">-		if (unix_peer(other) != sk) {</span>
<span class="p_del">-			sock_poll_wait(file, &amp;unix_sk(other)-&gt;peer_wait, wait);</span>
<span class="p_del">-			if (unix_recvq_full(other))</span>
<span class="p_del">-				writable = 0;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		sock_put(other);</span>
<span class="p_add">+	if (writable) {</span>
<span class="p_add">+		unix_state_lock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+		other = unix_peer(sk);</span>
<span class="p_add">+		if (other &amp;&amp; unix_peer(other) != sk &amp;&amp;</span>
<span class="p_add">+		    unix_recvq_full(other) &amp;&amp;</span>
<span class="p_add">+		    unix_dgram_peer_wake_me(sk, other))</span>
<span class="p_add">+			writable = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		unix_state_unlock(sk);</span>
 	}
 
 	if (writable)
<span class="p_header">diff --git a/net/unix/garbage.c b/net/unix/garbage.c</span>
<span class="p_header">index b6f4b99..00d3e56 100644</span>
<span class="p_header">--- a/net/unix/garbage.c</span>
<span class="p_header">+++ b/net/unix/garbage.c</span>
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> static void scan_inflight(struct sock *x, void (*func)(struct unix_sock *),</span>
 					 * have been added to the queues after
 					 * starting the garbage collection
 					 */
<span class="p_del">-					if (u-&gt;gc_candidate) {</span>
<span class="p_add">+					if (test_bit(UNIX_GC_CANDIDATE, &amp;u-&gt;gc_flags)) {</span>
 						hit = true;
 						func(u);
 					}
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> static void inc_inflight_move_tail(struct unix_sock *u)</span>
 	 * of the list, so that it&#39;s checked even if it was already
 	 * passed over
 	 */
<span class="p_del">-	if (u-&gt;gc_maybe_cycle)</span>
<span class="p_add">+	if (test_bit(UNIX_GC_MAYBE_CYCLE, &amp;u-&gt;gc_flags))</span>
 		list_move_tail(&amp;u-&gt;link, &amp;gc_candidates);
 }
 
<span class="p_chunk">@@ -315,8 +315,8 @@</span> <span class="p_context"> void unix_gc(void)</span>
 		BUG_ON(total_refs &lt; inflight_refs);
 		if (total_refs == inflight_refs) {
 			list_move_tail(&amp;u-&gt;link, &amp;gc_candidates);
<span class="p_del">-			u-&gt;gc_candidate = 1;</span>
<span class="p_del">-			u-&gt;gc_maybe_cycle = 1;</span>
<span class="p_add">+			__set_bit(UNIX_GC_CANDIDATE, &amp;u-&gt;gc_flags);</span>
<span class="p_add">+			__set_bit(UNIX_GC_MAYBE_CYCLE, &amp;u-&gt;gc_flags);</span>
 		}
 	}
 
<span class="p_chunk">@@ -344,7 +344,7 @@</span> <span class="p_context"> void unix_gc(void)</span>
 
 		if (atomic_long_read(&amp;u-&gt;inflight) &gt; 0) {
 			list_move_tail(&amp;u-&gt;link, &amp;not_cycle_list);
<span class="p_del">-			u-&gt;gc_maybe_cycle = 0;</span>
<span class="p_add">+			__clear_bit(UNIX_GC_MAYBE_CYCLE, &amp;u-&gt;gc_flags);</span>
 			scan_children(&amp;u-&gt;sk, inc_inflight_move_tail, NULL);
 		}
 	}
<span class="p_chunk">@@ -356,7 +356,7 @@</span> <span class="p_context"> void unix_gc(void)</span>
 	 */
 	while (!list_empty(&amp;not_cycle_list)) {
 		u = list_entry(not_cycle_list.next, struct unix_sock, link);
<span class="p_del">-		u-&gt;gc_candidate = 0;</span>
<span class="p_add">+		__clear_bit(UNIX_GC_CANDIDATE, &amp;u-&gt;gc_flags);</span>
 		list_move_tail(&amp;u-&gt;link, &amp;gc_inflight_list);
 	}
 
<span class="p_header">diff --git a/sound/pci/rme96.c b/sound/pci/rme96.c</span>
<span class="p_header">index 4585c97..3240ee7 100644</span>
<span class="p_header">--- a/sound/pci/rme96.c</span>
<span class="p_header">+++ b/sound/pci/rme96.c</span>
<span class="p_chunk">@@ -704,10 +704,11 @@</span> <span class="p_context"> snd_rme96_playback_setrate(struct rme96 *rme96,</span>
 	{
 		/* change to/from double-speed: reset the DAC (if available) */
 		snd_rme96_reset_dac(rme96);
<span class="p_add">+		return 1; /* need to restore volume */</span>
 	} else {
 		writel(rme96-&gt;wcreg, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
<span class="p_add">+		return 0;</span>
 	}
<span class="p_del">-	return 0;</span>
 }
 
 static int
<span class="p_chunk">@@ -945,6 +946,7 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	struct rme96 *rme96 = snd_pcm_substream_chip(substream);
 	struct snd_pcm_runtime *runtime = substream-&gt;runtime;
 	int err, rate, dummy;
<span class="p_add">+	bool apply_dac_volume = false;</span>
 
 	runtime-&gt;dma_area = (void __force *)(rme96-&gt;iobase +
 					     RME96_IO_PLAY_BUFFER);
<span class="p_chunk">@@ -958,24 +960,26 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 	{
                 /* slave clock */
                 if ((int)params_rate(params) != rate) {
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EIO;                    </span>
<span class="p_del">-                }</span>
<span class="p_del">-	} else if ((err = snd_rme96_playback_setrate(rme96, params_rate(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((err = snd_rme96_playback_setformat(rme96, params_format(params))) &lt; 0) {</span>
<span class="p_del">-		spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+			err = -EIO;</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = snd_rme96_playback_setrate(rme96, params_rate(params));</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		apply_dac_volume = err &gt; 0; /* need to restore volume later? */</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = snd_rme96_playback_setformat(rme96, params_format(params));</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto error;</span>
 	snd_rme96_setframelog(rme96, params_channels(params), 1);
 	if (rme96-&gt;capture_periodsize != 0) {
 		if (params_period_size(params) &lt;&lt; rme96-&gt;playback_frlog !=
 		    rme96-&gt;capture_periodsize)
 		{
<span class="p_del">-			spin_unlock_irq(&amp;rme96-&gt;lock);</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_add">+			err = -EBUSY;</span>
<span class="p_add">+			goto error;</span>
 		}
 	}
 	rme96-&gt;playback_periodsize =
<span class="p_chunk">@@ -986,9 +990,16 @@</span> <span class="p_context"> snd_rme96_playback_hw_params(struct snd_pcm_substream *substream,</span>
 		rme96-&gt;wcreg &amp;= ~(RME96_WCR_PRO | RME96_WCR_DOLBY | RME96_WCR_EMP);
 		writel(rme96-&gt;wcreg |= rme96-&gt;wcreg_spdif_stream, rme96-&gt;iobase + RME96_IO_CONTROL_REGISTER);
 	}
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+ error:</span>
 	spin_unlock_irq(&amp;rme96-&gt;lock);
<span class="p_del">-		</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (apply_dac_volume) {</span>
<span class="p_add">+		usleep_range(3000, 10000);</span>
<span class="p_add">+		snd_rme96_apply_dac_volume(rme96);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static int
<span class="p_header">diff --git a/sound/soc/codecs/wm8962.c b/sound/soc/codecs/wm8962.c</span>
<span class="p_header">index 8b687da..c79bd83 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8962.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8962.c</span>
<span class="p_chunk">@@ -373,8 +373,8 @@</span> <span class="p_context"> static const u16 wm8962_reg[WM8962_MAX_REGISTER + 1] = {</span>
 	[16924] = 0x0059,     /* R16924 - HDBASS_PG_1 */
 	[16925] = 0x999A,     /* R16925 - HDBASS_PG_0 */
 
<span class="p_del">-	[17048] = 0x0083,     /* R17408 - HPF_C_1 */</span>
<span class="p_del">-	[17049] = 0x98AD,     /* R17409 - HPF_C_0 */</span>
<span class="p_add">+	[17408] = 0x0083,     /* R17408 - HPF_C_1 */</span>
<span class="p_add">+	[17409] = 0x98AD,     /* R17409 - HPF_C_0 */</span>
 
 	[17920] = 0x007F,     /* R17920 - ADCL_RETUNE_C1_1 */
 	[17921] = 0xFFFF,     /* R17921 - ADCL_RETUNE_C1_0 */
<span class="p_header">diff --git a/sound/usb/midi.c b/sound/usb/midi.c</span>
<span class="p_header">index de86e74..075f324 100644</span>
<span class="p_header">--- a/sound/usb/midi.c</span>
<span class="p_header">+++ b/sound/usb/midi.c</span>
<span class="p_chunk">@@ -174,6 +174,8 @@</span> <span class="p_context"> struct snd_usb_midi_in_endpoint {</span>
 		u8 running_status_length;
 	} ports[0x10];
 	u8 seen_f5;
<span class="p_add">+	bool in_sysex;</span>
<span class="p_add">+	u8 last_cin;</span>
 	u8 error_resubmit;
 	int current_port;
 };
<span class="p_chunk">@@ -465,6 +467,39 @@</span> <span class="p_context"> static void snd_usbmidi_maudio_broken_running_status_input(</span>
 }
 
 /*
<span class="p_add">+ * QinHeng CH345 is buggy: every second packet inside a SysEx has not CIN 4</span>
<span class="p_add">+ * but the previously seen CIN, but still with three data bytes.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void ch345_broken_sysex_input(struct snd_usb_midi_in_endpoint *ep,</span>
<span class="p_add">+				     uint8_t *buffer, int buffer_length)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i, cin, length;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i + 3 &lt; buffer_length; i += 4) {</span>
<span class="p_add">+		if (buffer[i] == 0 &amp;&amp; i &gt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		cin = buffer[i] &amp; 0x0f;</span>
<span class="p_add">+		if (ep-&gt;in_sysex &amp;&amp;</span>
<span class="p_add">+		    cin == ep-&gt;last_cin &amp;&amp;</span>
<span class="p_add">+		    (buffer[i + 1 + (cin == 0x6)] &amp; 0x80) == 0)</span>
<span class="p_add">+			cin = 0x4;</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+		if (buffer[i + 1] == 0x90) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Either a corrupted running status or a real note-on</span>
<span class="p_add">+			 * message; impossible to detect reliably.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+		}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		length = snd_usbmidi_cin_length[cin];</span>
<span class="p_add">+		snd_usbmidi_input_data(ep, 0, &amp;buffer[i + 1], length);</span>
<span class="p_add">+		ep-&gt;in_sysex = cin == 0x4;</span>
<span class="p_add">+		if (!ep-&gt;in_sysex)</span>
<span class="p_add">+			ep-&gt;last_cin = cin;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * CME protocol: like the standard protocol, but SysEx commands are sent as a
  * single USB packet preceded by a 0x0F byte.
  */
<span class="p_chunk">@@ -650,6 +685,12 @@</span> <span class="p_context"> static struct usb_protocol_ops snd_usbmidi_cme_ops = {</span>
 	.output_packet = snd_usbmidi_output_standard_packet,
 };
 
<span class="p_add">+static struct usb_protocol_ops snd_usbmidi_ch345_broken_sysex_ops = {</span>
<span class="p_add">+	.input = ch345_broken_sysex_input,</span>
<span class="p_add">+	.output = snd_usbmidi_standard_output,</span>
<span class="p_add">+	.output_packet = snd_usbmidi_output_standard_packet,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * AKAI MPD16 protocol:
  *
<span class="p_chunk">@@ -1326,6 +1367,7 @@</span> <span class="p_context"> static int snd_usbmidi_out_endpoint_create(struct snd_usb_midi* umidi,</span>
 		 * Various chips declare a packet size larger than 4 bytes, but
 		 * do not actually work with larger packets:
 		 */
<span class="p_add">+	case USB_ID(0x0a67, 0x5011): /* Medeli DD305 */</span>
 	case USB_ID(0x0a92, 0x1020): /* ESI M4U */
 	case USB_ID(0x1430, 0x474b): /* RedOctane GH MIDI INTERFACE */
 	case USB_ID(0x15ca, 0x0101): /* Textech USB Midi Cable */
<span class="p_chunk">@@ -2214,6 +2256,10 @@</span> <span class="p_context"> int snd_usbmidi_create(struct snd_card *card,</span>
 
 		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);
 		break;
<span class="p_add">+	case QUIRK_MIDI_CH345:</span>
<span class="p_add">+		umidi-&gt;usb_protocol_ops = &amp;snd_usbmidi_ch345_broken_sysex_ops;</span>
<span class="p_add">+		err = snd_usbmidi_detect_per_port_endpoints(umidi, endpoints);</span>
<span class="p_add">+		break;</span>
 	default:
 		snd_printd(KERN_ERR &quot;invalid quirk type %d\n&quot;, quirk-&gt;type);
 		err = -ENXIO;
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index c014f00..0f18c75 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -2611,6 +2611,17 @@</span> <span class="p_context"> YAMAHA_DEVICE(0x7010, &quot;UB99&quot;),</span>
 	.idProduct = 0x1020,
 },
 
<span class="p_add">+/* QinHeng devices */</span>
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE(0x1a86, 0x752d),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp;(const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.vendor_name = &quot;QinHeng&quot;,</span>
<span class="p_add">+		.product_name = &quot;CH345&quot;,</span>
<span class="p_add">+		.ifnum = 1,</span>
<span class="p_add">+		.type = QUIRK_MIDI_CH345</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* KeithMcMillen Stringport */
 {
 	USB_DEVICE(0x1f38, 0x0001),
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 9c82f8b..b01d3cf 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -311,6 +311,7 @@</span> <span class="p_context"> int snd_usb_create_quirk(struct snd_usb_audio *chip,</span>
 		[QUIRK_MIDI_CME] = create_any_midi_quirk,
 		[QUIRK_MIDI_AKAI] = create_any_midi_quirk,
 		[QUIRK_MIDI_FTDI] = create_any_midi_quirk,
<span class="p_add">+		[QUIRK_MIDI_CH345] = create_any_midi_quirk,</span>
 		[QUIRK_AUDIO_STANDARD_INTERFACE] = create_standard_audio_quirk,
 		[QUIRK_AUDIO_FIXED_ENDPOINT] = create_fixed_stream_quirk,
 		[QUIRK_AUDIO_EDIROL_UAXX] = create_uaxx_quirk,
<span class="p_header">diff --git a/sound/usb/usbaudio.h b/sound/usb/usbaudio.h</span>
<span class="p_header">index 6c805a5..5e0e58a 100644</span>
<span class="p_header">--- a/sound/usb/usbaudio.h</span>
<span class="p_header">+++ b/sound/usb/usbaudio.h</span>
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"> enum quirk_type {</span>
 	QUIRK_MIDI_AKAI,
 	QUIRK_MIDI_US122L,
 	QUIRK_MIDI_FTDI,
<span class="p_add">+	QUIRK_MIDI_CH345,</span>
 	QUIRK_AUDIO_STANDARD_INTERFACE,
 	QUIRK_AUDIO_FIXED_ENDPOINT,
 	QUIRK_AUDIO_EDIROL_UAXX,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



