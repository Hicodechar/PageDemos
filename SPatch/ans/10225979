
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[05/17] trace doc: convert trace/ftrace.txt to rst format - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [05/17] trace doc: convert trace/ftrace.txt to rst format</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=125281">Du, Changbin</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 17, 2018, 5:39 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1518845990-20733-6-git-send-email-changbin.du@intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10225979/mbox/"
   >mbox</a>
|
   <a href="/patch/10225979/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10225979/">/patch/10225979/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4D1EF601D4 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 17 Feb 2018 05:51:33 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1C32928B4A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 17 Feb 2018 05:51:33 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 0D0E429496; Sat, 17 Feb 2018 05:51:33 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,LOTS_OF_MONEY,
	RCVD_IN_DNSWL_HI, TVD_PH_BODY_ACCOUNTS_PRE autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id ACF7E28B4A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 17 Feb 2018 05:51:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751160AbeBQFtU (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 17 Feb 2018 00:49:20 -0500
Received: from mga18.intel.com ([134.134.136.126]:1052 &quot;EHLO mga18.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751131AbeBQFtJ (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 17 Feb 2018 00:49:09 -0500
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from fmsmga002.fm.intel.com ([10.253.24.26])
	by orsmga106.jf.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384;
	16 Feb 2018 21:49:07 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.46,523,1511856000&quot;; d=&quot;scan&#39;208&quot;;a=&quot;20863347&quot;
Received: from gvt-dell.bj.intel.com (HELO gvt-dell-host.bj.intel.com)
	([10.238.154.59])
	by fmsmga002.fm.intel.com with ESMTP; 16 Feb 2018 21:49:04 -0800
From: changbin.du@intel.com
To: corbet@lwn.net, rostedt@goodmis.org
Cc: mingo@kernel.org, linux-doc@vger.kernel.org,
	linux-kernel@vger.kernel.org, Changbin Du &lt;changbin.du@intel.com&gt;
Subject: [PATCH 05/17] trace doc: convert trace/ftrace.txt to rst format
Date: Sat, 17 Feb 2018 13:39:38 +0800
Message-Id: &lt;1518845990-20733-6-git-send-email-changbin.du@intel.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1518845990-20733-1-git-send-email-changbin.du@intel.com&gt;
References: &lt;1518845990-20733-1-git-send-email-changbin.du@intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=125281">Du, Changbin</a> - Feb. 17, 2018, 5:39 a.m.</div>
<pre class="content">
<span class="from">From: Changbin Du &lt;changbin.du@intel.com&gt;</span>

This converts the plain text documentation to reStructuredText format and
add it into Sphinx TOC tree. No essential content change.

Cc: Steven Rostedt &lt;rostedt@goodmis.org&gt;
<span class="signed-off-by">Signed-off-by: Changbin Du &lt;changbin.du@intel.com&gt;</span>
---
 Documentation/trace/ftrace.rst | 3332 ++++++++++++++++++++++++++++++++++++++++
 Documentation/trace/ftrace.txt | 3220 --------------------------------------
 Documentation/trace/index.rst  |    1 +
 3 files changed, 3333 insertions(+), 3220 deletions(-)
 create mode 100644 Documentation/trace/ftrace.rst
 delete mode 100644 Documentation/trace/ftrace.txt
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176903">Philippe Ombredanne</a> - Feb. 20, 2018, 7:28 a.m.</div>
<pre class="content">
Changbin, Steven,

On Sat, Feb 17, 2018 at 6:39 AM,  &lt;changbin.du@intel.com&gt; wrote:
<span class="quote">&gt; From: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This converts the plain text documentation to reStructuredText format and</span>
<span class="quote">&gt; add it into Sphinx TOC tree. No essential content change.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Cc: Steven Rostedt &lt;rostedt@goodmis.org&gt;</span>
<span class="quote">&gt; Signed-off-by: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  Documentation/trace/ftrace.rst | 3332 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  Documentation/trace/ftrace.txt | 3220 --------------------------------------</span>
<span class="quote">&gt;  Documentation/trace/index.rst  |    1 +</span>
<span class="quote">&gt;  3 files changed, 3333 insertions(+), 3220 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 Documentation/trace/ftrace.rst</span>
<span class="quote">&gt;  delete mode 100644 Documentation/trace/ftrace.txt</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/Documentation/trace/ftrace.rst b/Documentation/trace/ftrace.rst</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..636aa9bf</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/Documentation/trace/ftrace.rst</span>
<span class="quote">&gt; @@ -0,0 +1,3332 @@</span>
<span class="quote">&gt; +========================</span>
<span class="quote">&gt; +ftrace - Function Tracer</span>
<span class="quote">&gt; +========================</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +Copyright 2008 Red Hat Inc.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +:Author:   Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="quote">&gt; +:License:  The GNU Free Documentation License, Version 1.2</span>
<span class="quote">&gt; +          (dual licensed under the GPL v2)</span>


Do you mind using an SPDX id per [1] rather that this?

Steven, are you OK with this? Can you ack?

[1] https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/license-rules.rst
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=125281">Du, Changbin</a> - Feb. 20, 2018, 1:27 p.m.</div>
<pre class="content">
Hi,
On Tue, Feb 20, 2018 at 08:28:24AM +0100, Philippe Ombredanne wrote:
<span class="quote">&gt; Changbin, Steven,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Sat, Feb 17, 2018 at 6:39 AM,  &lt;changbin.du@intel.com&gt; wrote:</span>
<span class="quote">&gt; &gt; From: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This converts the plain text documentation to reStructuredText format and</span>
<span class="quote">&gt; &gt; add it into Sphinx TOC tree. No essential content change.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Cc: Steven Rostedt &lt;rostedt@goodmis.org&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  Documentation/trace/ftrace.rst | 3332 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  Documentation/trace/ftrace.txt | 3220 --------------------------------------</span>
<span class="quote">&gt; &gt;  Documentation/trace/index.rst  |    1 +</span>
<span class="quote">&gt; &gt;  3 files changed, 3333 insertions(+), 3220 deletions(-)</span>
<span class="quote">&gt; &gt;  create mode 100644 Documentation/trace/ftrace.rst</span>
<span class="quote">&gt; &gt;  delete mode 100644 Documentation/trace/ftrace.txt</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; diff --git a/Documentation/trace/ftrace.rst b/Documentation/trace/ftrace.rst</span>
<span class="quote">&gt; &gt; new file mode 100644</span>
<span class="quote">&gt; &gt; index 0000000..636aa9bf</span>
<span class="quote">&gt; &gt; --- /dev/null</span>
<span class="quote">&gt; &gt; +++ b/Documentation/trace/ftrace.rst</span>
<span class="quote">&gt; &gt; @@ -0,0 +1,3332 @@</span>
<span class="quote">&gt; &gt; +========================</span>
<span class="quote">&gt; &gt; +ftrace - Function Tracer</span>
<span class="quote">&gt; &gt; +========================</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +Copyright 2008 Red Hat Inc.</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +:Author:   Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="quote">&gt; &gt; +:License:  The GNU Free Documentation License, Version 1.2</span>
<span class="quote">&gt; &gt; +          (dual licensed under the GPL v2)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Do you mind using an SPDX id per [1] rather that this?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Steven, are you OK with this? Can you ack?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [1] https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/Documentation/process/license-rules.rst</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; Cordially</span>
<span class="quote">&gt; Philippe Ombredanne</span>

I leave this to Steven, since I just converted the format of this doc.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=310">Steven Rostedt</a> - Feb. 20, 2018, 3:26 p.m.</div>
<pre class="content">
On Tue, 20 Feb 2018 21:27:00 +0800
&quot;Du, Changbin&quot; &lt;changbin.du@intel.com&gt; wrote:
<span class="quote">
&gt; &gt; &gt; @@ -0,0 +1,3332 @@</span>
<span class="quote">&gt; &gt; &gt; +========================</span>
<span class="quote">&gt; &gt; &gt; +ftrace - Function Tracer</span>
<span class="quote">&gt; &gt; &gt; +========================</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +Copyright 2008 Red Hat Inc.</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +:Author:   Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="quote">&gt; &gt; &gt; +:License:  The GNU Free Documentation License, Version 1.2</span>
<span class="quote">&gt; &gt; &gt; +          (dual licensed under the GPL v2)  </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Do you mind using an SPDX id per [1] rather that this?</span>

One it should be a separate patch. Two, how does SPDX deal with dual
licenses?

-- Steve
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=94">Jonathan Corbet</a> - Feb. 20, 2018, 4:36 p.m.</div>
<pre class="content">
On Tue, 20 Feb 2018 10:26:44 -0500
Steven Rostedt &lt;rostedt@goodmis.org&gt; wrote:
<span class="quote">
&gt; One it should be a separate patch. Two, how does SPDX deal with dual</span>
<span class="quote">&gt; licenses?</span>

Separate them with &quot;OR&quot; on a single line.  See
Documentation/process/license-rules.rst for details.

jon
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/trace/ftrace.rst b/Documentation/trace/ftrace.rst</span>
new file mode 100644
<span class="p_header">index 0000000..636aa9bf</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/trace/ftrace.rst</span>
<span class="p_chunk">@@ -0,0 +1,3332 @@</span> <span class="p_context"></span>
<span class="p_add">+========================</span>
<span class="p_add">+ftrace - Function Tracer</span>
<span class="p_add">+========================</span>
<span class="p_add">+</span>
<span class="p_add">+Copyright 2008 Red Hat Inc.</span>
<span class="p_add">+</span>
<span class="p_add">+:Author:   Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="p_add">+:License:  The GNU Free Documentation License, Version 1.2</span>
<span class="p_add">+          (dual licensed under the GPL v2)</span>
<span class="p_add">+:Original Reviewers:  Elias Oltmanns, Randy Dunlap, Andrew Morton,</span>
<span class="p_add">+		      John Kacur, and David Teigland.</span>
<span class="p_add">+</span>
<span class="p_add">+- Written for: 2.6.28-rc2</span>
<span class="p_add">+- Updated for: 3.10</span>
<span class="p_add">+- Updated for: 4.13 - Copyright 2017 VMware Inc. Steven Rostedt</span>
<span class="p_add">+- Converted to rst format - Changbin Du &lt;changbin.du@intel.com&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+Introduction</span>
<span class="p_add">+------------</span>
<span class="p_add">+</span>
<span class="p_add">+Ftrace is an internal tracer designed to help out developers and</span>
<span class="p_add">+designers of systems to find what is going on inside the kernel.</span>
<span class="p_add">+It can be used for debugging or analyzing latencies and</span>
<span class="p_add">+performance issues that take place outside of user-space.</span>
<span class="p_add">+</span>
<span class="p_add">+Although ftrace is typically considered the function tracer, it</span>
<span class="p_add">+is really a frame work of several assorted tracing utilities.</span>
<span class="p_add">+There&#39;s latency tracing to examine what occurs between interrupts</span>
<span class="p_add">+disabled and enabled, as well as for preemption and from a time</span>
<span class="p_add">+a task is woken to the task is actually scheduled in.</span>
<span class="p_add">+</span>
<span class="p_add">+One of the most common uses of ftrace is the event tracing.</span>
<span class="p_add">+Through out the kernel is hundreds of static event points that</span>
<span class="p_add">+can be enabled via the tracefs file system to see what is</span>
<span class="p_add">+going on in certain parts of the kernel.</span>
<span class="p_add">+</span>
<span class="p_add">+See events.txt for more information.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Implementation Details</span>
<span class="p_add">+----------------------</span>
<span class="p_add">+</span>
<span class="p_add">+See :doc:`ftrace-design` for details for arch porters and such.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+The File System</span>
<span class="p_add">+---------------</span>
<span class="p_add">+</span>
<span class="p_add">+Ftrace uses the tracefs file system to hold the control files as</span>
<span class="p_add">+well as the files to display output.</span>
<span class="p_add">+</span>
<span class="p_add">+When tracefs is configured into the kernel (which selecting any ftrace</span>
<span class="p_add">+option will do) the directory /sys/kernel/tracing will be created. To mount</span>
<span class="p_add">+this directory, you can add to your /etc/fstab file::</span>
<span class="p_add">+</span>
<span class="p_add">+ tracefs       /sys/kernel/tracing       tracefs defaults        0       0</span>
<span class="p_add">+</span>
<span class="p_add">+Or you can mount it at run time with::</span>
<span class="p_add">+</span>
<span class="p_add">+ mount -t tracefs nodev /sys/kernel/tracing</span>
<span class="p_add">+</span>
<span class="p_add">+For quicker access to that directory you may want to make a soft link to</span>
<span class="p_add">+it::</span>
<span class="p_add">+</span>
<span class="p_add">+ ln -s /sys/kernel/tracing /tracing</span>
<span class="p_add">+</span>
<span class="p_add">+.. attention::</span>
<span class="p_add">+</span>
<span class="p_add">+  Before 4.1, all ftrace tracing control files were within the debugfs</span>
<span class="p_add">+  file system, which is typically located at /sys/kernel/debug/tracing.</span>
<span class="p_add">+  For backward compatibility, when mounting the debugfs file system,</span>
<span class="p_add">+  the tracefs file system will be automatically mounted at:</span>
<span class="p_add">+</span>
<span class="p_add">+  /sys/kernel/debug/tracing</span>
<span class="p_add">+</span>
<span class="p_add">+  All files located in the tracefs file system will be located in that</span>
<span class="p_add">+  debugfs file system directory as well.</span>
<span class="p_add">+</span>
<span class="p_add">+.. attention::</span>
<span class="p_add">+</span>
<span class="p_add">+  Any selected ftrace option will also create the tracefs file system.</span>
<span class="p_add">+  The rest of the document will assume that you are in the ftrace directory</span>
<span class="p_add">+  (cd /sys/kernel/tracing) and will only concentrate on the files within that</span>
<span class="p_add">+  directory and not distract from the content with the extended</span>
<span class="p_add">+  &quot;/sys/kernel/tracing&quot; path name.</span>
<span class="p_add">+</span>
<span class="p_add">+That&#39;s it! (assuming that you have ftrace configured into your kernel)</span>
<span class="p_add">+</span>
<span class="p_add">+After mounting tracefs you will have access to the control and output files</span>
<span class="p_add">+of ftrace. Here is a list of some of the key files:</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+ Note: all time values are in microseconds.</span>
<span class="p_add">+</span>
<span class="p_add">+  current_tracer:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is used to set or display the current tracer</span>
<span class="p_add">+	that is configured.</span>
<span class="p_add">+</span>
<span class="p_add">+  available_tracers:</span>
<span class="p_add">+</span>
<span class="p_add">+	This holds the different types of tracers that</span>
<span class="p_add">+	have been compiled into the kernel. The</span>
<span class="p_add">+	tracers listed here can be configured by</span>
<span class="p_add">+	echoing their name into current_tracer.</span>
<span class="p_add">+</span>
<span class="p_add">+  tracing_on:</span>
<span class="p_add">+</span>
<span class="p_add">+	This sets or displays whether writing to the trace</span>
<span class="p_add">+	ring buffer is enabled. Echo 0 into this file to disable</span>
<span class="p_add">+	the tracer or 1 to enable it. Note, this only disables</span>
<span class="p_add">+	writing to the ring buffer, the tracing overhead may</span>
<span class="p_add">+	still be occurring.</span>
<span class="p_add">+</span>
<span class="p_add">+	The kernel function tracing_off() can be used within the</span>
<span class="p_add">+	kernel to disable writing to the ring buffer, which will</span>
<span class="p_add">+	set this file to &quot;0&quot;. User space can re-enable tracing by</span>
<span class="p_add">+	echoing &quot;1&quot; into the file.</span>
<span class="p_add">+</span>
<span class="p_add">+	Note, the function and event trigger &quot;traceoff&quot; will also</span>
<span class="p_add">+	set this file to zero and stop tracing. Which can also</span>
<span class="p_add">+	be re-enabled by user space using this file.</span>
<span class="p_add">+</span>
<span class="p_add">+  trace:</span>
<span class="p_add">+</span>
<span class="p_add">+	This file holds the output of the trace in a human</span>
<span class="p_add">+	readable format (described below). Note, tracing is temporarily</span>
<span class="p_add">+	disabled while this file is being read (opened).</span>
<span class="p_add">+</span>
<span class="p_add">+  trace_pipe:</span>
<span class="p_add">+</span>
<span class="p_add">+	The output is the same as the &quot;trace&quot; file but this</span>
<span class="p_add">+	file is meant to be streamed with live tracing.</span>
<span class="p_add">+	Reads from this file will block until new data is</span>
<span class="p_add">+	retrieved.  Unlike the &quot;trace&quot; file, this file is a</span>
<span class="p_add">+	consumer. This means reading from this file causes</span>
<span class="p_add">+	sequential reads to display more current data. Once</span>
<span class="p_add">+	data is read from this file, it is consumed, and</span>
<span class="p_add">+	will not be read again with a sequential read. The</span>
<span class="p_add">+	&quot;trace&quot; file is static, and if the tracer is not</span>
<span class="p_add">+	adding more data, it will display the same</span>
<span class="p_add">+	information every time it is read. This file will not</span>
<span class="p_add">+	disable tracing while being read.</span>
<span class="p_add">+</span>
<span class="p_add">+  trace_options:</span>
<span class="p_add">+</span>
<span class="p_add">+	This file lets the user control the amount of data</span>
<span class="p_add">+	that is displayed in one of the above output</span>
<span class="p_add">+	files. Options also exist to modify how a tracer</span>
<span class="p_add">+	or events work (stack traces, timestamps, etc).</span>
<span class="p_add">+</span>
<span class="p_add">+  options:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is a directory that has a file for every available</span>
<span class="p_add">+	trace option (also in trace_options). Options may also be set</span>
<span class="p_add">+	or cleared by writing a &quot;1&quot; or &quot;0&quot; respectively into the</span>
<span class="p_add">+	corresponding file with the option name.</span>
<span class="p_add">+</span>
<span class="p_add">+  tracing_max_latency:</span>
<span class="p_add">+</span>
<span class="p_add">+	Some of the tracers record the max latency.</span>
<span class="p_add">+	For example, the maximum time that interrupts are disabled.</span>
<span class="p_add">+	The maximum time is saved in this file. The max trace will also be</span>
<span class="p_add">+	stored,	and displayed by &quot;trace&quot;. A new max trace will only be</span>
<span class="p_add">+	recorded if the latency is greater than the value in this file</span>
<span class="p_add">+	(in microseconds).</span>
<span class="p_add">+</span>
<span class="p_add">+	By echoing in a time into this file, no latency will be recorded</span>
<span class="p_add">+	unless it is greater than the time in this file.</span>
<span class="p_add">+</span>
<span class="p_add">+  tracing_thresh:</span>
<span class="p_add">+</span>
<span class="p_add">+	Some latency tracers will record a trace whenever the</span>
<span class="p_add">+	latency is greater than the number in this file.</span>
<span class="p_add">+	Only active when the file contains a number greater than 0.</span>
<span class="p_add">+	(in microseconds)</span>
<span class="p_add">+</span>
<span class="p_add">+  buffer_size_kb:</span>
<span class="p_add">+</span>
<span class="p_add">+	This sets or displays the number of kilobytes each CPU</span>
<span class="p_add">+	buffer holds. By default, the trace buffers are the same size</span>
<span class="p_add">+	for each CPU. The displayed number is the size of the</span>
<span class="p_add">+	CPU buffer and not total size of all buffers. The</span>
<span class="p_add">+	trace buffers are allocated in pages (blocks of memory</span>
<span class="p_add">+	that the kernel uses for allocation, usually 4 KB in size).</span>
<span class="p_add">+	If the last page allocated has room for more bytes</span>
<span class="p_add">+	than requested, the rest of the page will be used,</span>
<span class="p_add">+	making the actual allocation bigger than requested or shown.</span>
<span class="p_add">+	( Note, the size may not be a multiple of the page size</span>
<span class="p_add">+	due to buffer management meta-data. )</span>
<span class="p_add">+</span>
<span class="p_add">+	Buffer sizes for individual CPUs may vary</span>
<span class="p_add">+	(see &quot;per_cpu/cpu0/buffer_size_kb&quot; below), and if they do</span>
<span class="p_add">+	this file will show &quot;X&quot;.</span>
<span class="p_add">+</span>
<span class="p_add">+  buffer_total_size_kb:</span>
<span class="p_add">+</span>
<span class="p_add">+	This displays the total combined size of all the trace buffers.</span>
<span class="p_add">+</span>
<span class="p_add">+  free_buffer:</span>
<span class="p_add">+</span>
<span class="p_add">+	If a process is performing tracing, and the ring buffer	should be</span>
<span class="p_add">+	shrunk &quot;freed&quot; when the process is finished, even if it were to be</span>
<span class="p_add">+	killed by a signal, this file can be used for that purpose. On close</span>
<span class="p_add">+	of this file, the ring buffer will be resized to its minimum size.</span>
<span class="p_add">+	Having a process that is tracing also open this file, when the process</span>
<span class="p_add">+	exits its file descriptor for this file will be closed, and in doing so,</span>
<span class="p_add">+	the ring buffer will be &quot;freed&quot;.</span>
<span class="p_add">+</span>
<span class="p_add">+	It may also stop tracing if disable_on_free option is set.</span>
<span class="p_add">+</span>
<span class="p_add">+  tracing_cpumask:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is a mask that lets the user only trace on specified CPUs.</span>
<span class="p_add">+	The format is a hex string representing the CPUs.</span>
<span class="p_add">+</span>
<span class="p_add">+  set_ftrace_filter:</span>
<span class="p_add">+</span>
<span class="p_add">+	When dynamic ftrace is configured in (see the</span>
<span class="p_add">+	section below &quot;dynamic ftrace&quot;), the code is dynamically</span>
<span class="p_add">+	modified (code text rewrite) to disable calling of the</span>
<span class="p_add">+	function profiler (mcount). This lets tracing be configured</span>
<span class="p_add">+	in with practically no overhead in performance.  This also</span>
<span class="p_add">+	has a side effect of enabling or disabling specific functions</span>
<span class="p_add">+	to be traced. Echoing names of functions into this file</span>
<span class="p_add">+	will limit the trace to only those functions.</span>
<span class="p_add">+</span>
<span class="p_add">+	The functions listed in &quot;available_filter_functions&quot; are what</span>
<span class="p_add">+	can be written into this file.</span>
<span class="p_add">+</span>
<span class="p_add">+	This interface also allows for commands to be used. See the</span>
<span class="p_add">+	&quot;Filter commands&quot; section for more details.</span>
<span class="p_add">+</span>
<span class="p_add">+  set_ftrace_notrace:</span>
<span class="p_add">+</span>
<span class="p_add">+	This has an effect opposite to that of</span>
<span class="p_add">+	set_ftrace_filter. Any function that is added here will not</span>
<span class="p_add">+	be traced. If a function exists in both set_ftrace_filter</span>
<span class="p_add">+	and set_ftrace_notrace,	the function will _not_ be traced.</span>
<span class="p_add">+</span>
<span class="p_add">+  set_ftrace_pid:</span>
<span class="p_add">+</span>
<span class="p_add">+	Have the function tracer only trace the threads whose PID are</span>
<span class="p_add">+	listed in this file.</span>
<span class="p_add">+</span>
<span class="p_add">+	If the &quot;function-fork&quot; option is set, then when a task whose</span>
<span class="p_add">+	PID is listed in this file forks, the child&#39;s PID will</span>
<span class="p_add">+	automatically be added to this file, and the child will be</span>
<span class="p_add">+	traced by the function tracer as well. This option will also</span>
<span class="p_add">+	cause PIDs of tasks that exit to be removed from the file.</span>
<span class="p_add">+</span>
<span class="p_add">+  set_event_pid:</span>
<span class="p_add">+</span>
<span class="p_add">+	Have the events only trace a task with a PID listed in this file.</span>
<span class="p_add">+	Note, sched_switch and sched_wake_up will also trace events</span>
<span class="p_add">+	listed in this file.</span>
<span class="p_add">+</span>
<span class="p_add">+	To have the PIDs of children of tasks with their PID in this file</span>
<span class="p_add">+	added on fork, enable the &quot;event-fork&quot; option. That option will also</span>
<span class="p_add">+	cause the PIDs of tasks to be removed from this file when the task</span>
<span class="p_add">+	exits.</span>
<span class="p_add">+</span>
<span class="p_add">+  set_graph_function:</span>
<span class="p_add">+</span>
<span class="p_add">+	Functions listed in this file will cause the function graph</span>
<span class="p_add">+	tracer to only trace these functions and the functions that</span>
<span class="p_add">+	they call. (See the section &quot;dynamic ftrace&quot; for more details).</span>
<span class="p_add">+</span>
<span class="p_add">+  set_graph_notrace:</span>
<span class="p_add">+</span>
<span class="p_add">+	Similar to set_graph_function, but will disable function graph</span>
<span class="p_add">+	tracing when the function is hit until it exits the function.</span>
<span class="p_add">+	This makes it possible to ignore tracing functions that are called</span>
<span class="p_add">+	by a specific function.</span>
<span class="p_add">+</span>
<span class="p_add">+  available_filter_functions:</span>
<span class="p_add">+</span>
<span class="p_add">+	This lists the functions that ftrace has processed and can trace.</span>
<span class="p_add">+	These are the function names that you can pass to</span>
<span class="p_add">+	&quot;set_ftrace_filter&quot; or &quot;set_ftrace_notrace&quot;.</span>
<span class="p_add">+	(See the section &quot;dynamic ftrace&quot; below for more details.)</span>
<span class="p_add">+</span>
<span class="p_add">+  dyn_ftrace_total_info:</span>
<span class="p_add">+</span>
<span class="p_add">+	This file is for debugging purposes. The number of functions that</span>
<span class="p_add">+	have been converted to nops and are available to be traced.</span>
<span class="p_add">+</span>
<span class="p_add">+  enabled_functions:</span>
<span class="p_add">+</span>
<span class="p_add">+	This file is more for debugging ftrace, but can also be useful</span>
<span class="p_add">+	in seeing if any function has a callback attached to it.</span>
<span class="p_add">+	Not only does the trace infrastructure use ftrace function</span>
<span class="p_add">+	trace utility, but other subsystems might too. This file</span>
<span class="p_add">+	displays all functions that have a callback attached to them</span>
<span class="p_add">+	as well as the number of callbacks that have been attached.</span>
<span class="p_add">+	Note, a callback may also call multiple functions which will</span>
<span class="p_add">+	not be listed in this count.</span>
<span class="p_add">+</span>
<span class="p_add">+	If the callback registered to be traced by a function with</span>
<span class="p_add">+	the &quot;save regs&quot; attribute (thus even more overhead), a &#39;R&#39;</span>
<span class="p_add">+	will be displayed on the same line as the function that</span>
<span class="p_add">+	is returning registers.</span>
<span class="p_add">+</span>
<span class="p_add">+	If the callback registered to be traced by a function with</span>
<span class="p_add">+	the &quot;ip modify&quot; attribute (thus the regs-&gt;ip can be changed),</span>
<span class="p_add">+	an &#39;I&#39; will be displayed on the same line as the function that</span>
<span class="p_add">+	can be overridden.</span>
<span class="p_add">+</span>
<span class="p_add">+	If the architecture supports it, it will also show what callback</span>
<span class="p_add">+	is being directly called by the function. If the count is greater</span>
<span class="p_add">+	than 1 it most likely will be ftrace_ops_list_func().</span>
<span class="p_add">+</span>
<span class="p_add">+	If the callback of the function jumps to a trampoline that is</span>
<span class="p_add">+	specific to a the callback and not the standard trampoline,</span>
<span class="p_add">+	its address will be printed as well as the function that the</span>
<span class="p_add">+	trampoline calls.</span>
<span class="p_add">+</span>
<span class="p_add">+  function_profile_enabled:</span>
<span class="p_add">+</span>
<span class="p_add">+	When set it will enable all functions with either the function</span>
<span class="p_add">+	tracer, or if configured, the function graph tracer. It will</span>
<span class="p_add">+	keep a histogram of the number of functions that were called</span>
<span class="p_add">+	and if the function graph tracer was configured, it will also keep</span>
<span class="p_add">+	track of the time spent in those functions. The histogram</span>
<span class="p_add">+	content can be displayed in the files:</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_stats/function&lt;cpu&gt; ( function0, function1, etc).</span>
<span class="p_add">+</span>
<span class="p_add">+  trace_stats:</span>
<span class="p_add">+</span>
<span class="p_add">+	A directory that holds different tracing stats.</span>
<span class="p_add">+</span>
<span class="p_add">+  kprobe_events:</span>
<span class="p_add">+</span>
<span class="p_add">+	Enable dynamic trace points. See kprobetrace.txt.</span>
<span class="p_add">+</span>
<span class="p_add">+  kprobe_profile:</span>
<span class="p_add">+</span>
<span class="p_add">+	Dynamic trace points stats. See kprobetrace.txt.</span>
<span class="p_add">+</span>
<span class="p_add">+  max_graph_depth:</span>
<span class="p_add">+</span>
<span class="p_add">+	Used with the function graph tracer. This is the max depth</span>
<span class="p_add">+	it will trace into a function. Setting this to a value of</span>
<span class="p_add">+	one will show only the first kernel function that is called</span>
<span class="p_add">+	from user space.</span>
<span class="p_add">+</span>
<span class="p_add">+  printk_formats:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is for tools that read the raw format files. If an event in</span>
<span class="p_add">+	the ring buffer references a string, only a pointer to the string</span>
<span class="p_add">+	is recorded into the buffer and not the string itself. This prevents</span>
<span class="p_add">+	tools from knowing what that string was. This file displays the string</span>
<span class="p_add">+	and address for	the string allowing tools to map the pointers to what</span>
<span class="p_add">+	the strings were.</span>
<span class="p_add">+</span>
<span class="p_add">+  saved_cmdlines:</span>
<span class="p_add">+</span>
<span class="p_add">+	Only the pid of the task is recorded in a trace event unless</span>
<span class="p_add">+	the event specifically saves the task comm as well. Ftrace</span>
<span class="p_add">+	makes a cache of pid mappings to comms to try to display</span>
<span class="p_add">+	comms for events. If a pid for a comm is not listed, then</span>
<span class="p_add">+	&quot;&lt;...&gt;&quot; is displayed in the output.</span>
<span class="p_add">+</span>
<span class="p_add">+	If the option &quot;record-cmd&quot; is set to &quot;0&quot;, then comms of tasks</span>
<span class="p_add">+	will not be saved during recording. By default, it is enabled.</span>
<span class="p_add">+</span>
<span class="p_add">+  saved_cmdlines_size:</span>
<span class="p_add">+</span>
<span class="p_add">+	By default, 128 comms are saved (see &quot;saved_cmdlines&quot; above). To</span>
<span class="p_add">+	increase or decrease the amount of comms that are cached, echo</span>
<span class="p_add">+	in a the number of comms to cache, into this file.</span>
<span class="p_add">+</span>
<span class="p_add">+  saved_tgids:</span>
<span class="p_add">+</span>
<span class="p_add">+	If the option &quot;record-tgid&quot; is set, on each scheduling context switch</span>
<span class="p_add">+	the Task Group ID of a task is saved in a table mapping the PID of</span>
<span class="p_add">+	the thread to its TGID. By default, the &quot;record-tgid&quot; option is</span>
<span class="p_add">+	disabled.</span>
<span class="p_add">+</span>
<span class="p_add">+  snapshot:</span>
<span class="p_add">+</span>
<span class="p_add">+	This displays the &quot;snapshot&quot; buffer and also lets the user</span>
<span class="p_add">+	take a snapshot of the current running trace.</span>
<span class="p_add">+	See the &quot;Snapshot&quot; section below for more details.</span>
<span class="p_add">+</span>
<span class="p_add">+  stack_max_size:</span>
<span class="p_add">+</span>
<span class="p_add">+	When the stack tracer is activated, this will display the</span>
<span class="p_add">+	maximum stack size it has encountered.</span>
<span class="p_add">+	See the &quot;Stack Trace&quot; section below.</span>
<span class="p_add">+</span>
<span class="p_add">+  stack_trace:</span>
<span class="p_add">+</span>
<span class="p_add">+	This displays the stack back trace of the largest stack</span>
<span class="p_add">+	that was encountered when the stack tracer is activated.</span>
<span class="p_add">+	See the &quot;Stack Trace&quot; section below.</span>
<span class="p_add">+</span>
<span class="p_add">+  stack_trace_filter:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is similar to &quot;set_ftrace_filter&quot; but it limits what</span>
<span class="p_add">+	functions the stack tracer will check.</span>
<span class="p_add">+</span>
<span class="p_add">+  trace_clock:</span>
<span class="p_add">+</span>
<span class="p_add">+	Whenever an event is recorded into the ring buffer, a</span>
<span class="p_add">+	&quot;timestamp&quot; is added. This stamp comes from a specified</span>
<span class="p_add">+	clock. By default, ftrace uses the &quot;local&quot; clock. This</span>
<span class="p_add">+	clock is very fast and strictly per cpu, but on some</span>
<span class="p_add">+	systems it may not be monotonic with respect to other</span>
<span class="p_add">+	CPUs. In other words, the local clocks may not be in sync</span>
<span class="p_add">+	with local clocks on other CPUs.</span>
<span class="p_add">+</span>
<span class="p_add">+	Usual clocks for tracing::</span>
<span class="p_add">+</span>
<span class="p_add">+	  # cat trace_clock</span>
<span class="p_add">+	  [local] global counter x86-tsc</span>
<span class="p_add">+</span>
<span class="p_add">+	The clock with the square brackets around it is the one in effect.</span>
<span class="p_add">+</span>
<span class="p_add">+	local:</span>
<span class="p_add">+		Default clock, but may not be in sync across CPUs</span>
<span class="p_add">+</span>
<span class="p_add">+	global:</span>
<span class="p_add">+		This clock is in sync with all CPUs but may</span>
<span class="p_add">+		be a bit slower than the local clock.</span>
<span class="p_add">+</span>
<span class="p_add">+	counter:</span>
<span class="p_add">+		This is not a clock at all, but literally an atomic</span>
<span class="p_add">+		counter. It counts up one by one, but is in sync</span>
<span class="p_add">+		with all CPUs. This is useful when you need to</span>
<span class="p_add">+		know exactly the order events occurred with respect to</span>
<span class="p_add">+		each other on different CPUs.</span>
<span class="p_add">+</span>
<span class="p_add">+	uptime:</span>
<span class="p_add">+		This uses the jiffies counter and the time stamp</span>
<span class="p_add">+		is relative to the time since boot up.</span>
<span class="p_add">+</span>
<span class="p_add">+	perf:</span>
<span class="p_add">+		This makes ftrace use the same clock that perf uses.</span>
<span class="p_add">+		Eventually perf will be able to read ftrace buffers</span>
<span class="p_add">+		and this will help out in interleaving the data.</span>
<span class="p_add">+</span>
<span class="p_add">+	x86-tsc:</span>
<span class="p_add">+		Architectures may define their own clocks. For</span>
<span class="p_add">+		example, x86 uses its own TSC cycle clock here.</span>
<span class="p_add">+</span>
<span class="p_add">+	ppc-tb:</span>
<span class="p_add">+		This uses the powerpc timebase register value.</span>
<span class="p_add">+		This is in sync across CPUs and can also be used</span>
<span class="p_add">+		to correlate events across hypervisor/guest if</span>
<span class="p_add">+		tb_offset is known.</span>
<span class="p_add">+</span>
<span class="p_add">+	mono:</span>
<span class="p_add">+		This uses the fast monotonic clock (CLOCK_MONOTONIC)</span>
<span class="p_add">+		which is monotonic and is subject to NTP rate adjustments.</span>
<span class="p_add">+</span>
<span class="p_add">+	mono_raw:</span>
<span class="p_add">+		This is the raw monotonic clock (CLOCK_MONOTONIC_RAW)</span>
<span class="p_add">+		which is montonic but is not subject to any rate adjustments</span>
<span class="p_add">+		and ticks at the same rate as the hardware clocksource.</span>
<span class="p_add">+</span>
<span class="p_add">+	boot:</span>
<span class="p_add">+		This is the boot clock (CLOCK_BOOTTIME) and is based on the</span>
<span class="p_add">+		fast monotonic clock, but also accounts for time spent in</span>
<span class="p_add">+		suspend. Since the clock access is designed for use in</span>
<span class="p_add">+		tracing in the suspend path, some side effects are possible</span>
<span class="p_add">+		if clock is accessed after the suspend time is accounted before</span>
<span class="p_add">+		the fast mono clock is updated. In this case, the clock update</span>
<span class="p_add">+		appears to happen slightly sooner than it normally would have.</span>
<span class="p_add">+		Also on 32-bit systems, it&#39;s possible that the 64-bit boot offset</span>
<span class="p_add">+		sees a partial update. These effects are rare and post</span>
<span class="p_add">+		processing should be able to handle them. See comments in the</span>
<span class="p_add">+		ktime_get_boot_fast_ns() function for more information.</span>
<span class="p_add">+</span>
<span class="p_add">+		To set a clock, simply echo the clock name into this file::</span>
<span class="p_add">+</span>
<span class="p_add">+		  echo global &gt; trace_clock</span>
<span class="p_add">+</span>
<span class="p_add">+  trace_marker:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is a very useful file for synchronizing user space</span>
<span class="p_add">+	with events happening in the kernel. Writing strings into</span>
<span class="p_add">+	this file will be written into the ftrace buffer.</span>
<span class="p_add">+</span>
<span class="p_add">+	It is useful in applications to open this file at the start</span>
<span class="p_add">+	of the application and just reference the file descriptor</span>
<span class="p_add">+	for the file::</span>
<span class="p_add">+</span>
<span class="p_add">+		void trace_write(const char *fmt, ...)</span>
<span class="p_add">+		{</span>
<span class="p_add">+			va_list ap;</span>
<span class="p_add">+			char buf[256];</span>
<span class="p_add">+			int n;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (trace_fd &lt; 0)</span>
<span class="p_add">+				return;</span>
<span class="p_add">+</span>
<span class="p_add">+			va_start(ap, fmt);</span>
<span class="p_add">+			n = vsnprintf(buf, 256, fmt, ap);</span>
<span class="p_add">+			va_end(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+			write(trace_fd, buf, n);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	start::</span>
<span class="p_add">+</span>
<span class="p_add">+		trace_fd = open(&quot;trace_marker&quot;, WR_ONLY);</span>
<span class="p_add">+</span>
<span class="p_add">+  trace_marker_raw:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is similar to trace_marker above, but is meant for for binary data</span>
<span class="p_add">+	to be written to it, where a tool can be used to parse the data</span>
<span class="p_add">+	from trace_pipe_raw.</span>
<span class="p_add">+</span>
<span class="p_add">+  uprobe_events:</span>
<span class="p_add">+</span>
<span class="p_add">+	Add dynamic tracepoints in programs.</span>
<span class="p_add">+	See uprobetracer.txt</span>
<span class="p_add">+</span>
<span class="p_add">+  uprobe_profile:</span>
<span class="p_add">+</span>
<span class="p_add">+	Uprobe statistics. See uprobetrace.txt</span>
<span class="p_add">+</span>
<span class="p_add">+  instances:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is a way to make multiple trace buffers where different</span>
<span class="p_add">+	events can be recorded in different buffers.</span>
<span class="p_add">+	See &quot;Instances&quot; section below.</span>
<span class="p_add">+</span>
<span class="p_add">+  events:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is the trace event directory. It holds event tracepoints</span>
<span class="p_add">+	(also known as static tracepoints) that have been compiled</span>
<span class="p_add">+	into the kernel. It shows what event tracepoints exist</span>
<span class="p_add">+	and how they are grouped by system. There are &quot;enable&quot;</span>
<span class="p_add">+	files at various levels that can enable the tracepoints</span>
<span class="p_add">+	when a &quot;1&quot; is written to them.</span>
<span class="p_add">+</span>
<span class="p_add">+	See events.txt for more information.</span>
<span class="p_add">+</span>
<span class="p_add">+  set_event:</span>
<span class="p_add">+</span>
<span class="p_add">+	By echoing in the event into this file, will enable that event.</span>
<span class="p_add">+</span>
<span class="p_add">+	See events.txt for more information.</span>
<span class="p_add">+</span>
<span class="p_add">+  available_events:</span>
<span class="p_add">+</span>
<span class="p_add">+	A list of events that can be enabled in tracing.</span>
<span class="p_add">+</span>
<span class="p_add">+	See events.txt for more information.</span>
<span class="p_add">+</span>
<span class="p_add">+  hwlat_detector:</span>
<span class="p_add">+</span>
<span class="p_add">+	Directory for the Hardware Latency Detector.</span>
<span class="p_add">+	See &quot;Hardware Latency Detector&quot; section below.</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is a directory that contains the trace per_cpu information.</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu/cpu0/buffer_size_kb:</span>
<span class="p_add">+</span>
<span class="p_add">+	The ftrace buffer is defined per_cpu. That is, there&#39;s a separate</span>
<span class="p_add">+	buffer for each CPU to allow writes to be done atomically,</span>
<span class="p_add">+	and free from cache bouncing. These buffers may have different</span>
<span class="p_add">+	size buffers. This file is similar to the buffer_size_kb</span>
<span class="p_add">+	file, but it only displays or sets the buffer size for the</span>
<span class="p_add">+	specific CPU. (here cpu0).</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu/cpu0/trace:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is similar to the &quot;trace&quot; file, but it will only display</span>
<span class="p_add">+	the data specific for the CPU. If written to, it only clears</span>
<span class="p_add">+	the specific CPU buffer.</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu/cpu0/trace_pipe</span>
<span class="p_add">+</span>
<span class="p_add">+	This is similar to the &quot;trace_pipe&quot; file, and is a consuming</span>
<span class="p_add">+	read, but it will only display (and consume) the data specific</span>
<span class="p_add">+	for the CPU.</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu/cpu0/trace_pipe_raw</span>
<span class="p_add">+</span>
<span class="p_add">+	For tools that can parse the ftrace ring buffer binary format,</span>
<span class="p_add">+	the trace_pipe_raw file can be used to extract the data</span>
<span class="p_add">+	from the ring buffer directly. With the use of the splice()</span>
<span class="p_add">+	system call, the buffer data can be quickly transferred to</span>
<span class="p_add">+	a file or to the network where a server is collecting the</span>
<span class="p_add">+	data.</span>
<span class="p_add">+</span>
<span class="p_add">+	Like trace_pipe, this is a consuming reader, where multiple</span>
<span class="p_add">+	reads will always produce different data.</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu/cpu0/snapshot:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is similar to the main &quot;snapshot&quot; file, but will only</span>
<span class="p_add">+	snapshot the current CPU (if supported). It only displays</span>
<span class="p_add">+	the content of the snapshot for a given CPU, and if</span>
<span class="p_add">+	written to, only clears this CPU buffer.</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu/cpu0/snapshot_raw:</span>
<span class="p_add">+</span>
<span class="p_add">+	Similar to the trace_pipe_raw, but will read the binary format</span>
<span class="p_add">+	from the snapshot buffer for the given CPU.</span>
<span class="p_add">+</span>
<span class="p_add">+  per_cpu/cpu0/stats:</span>
<span class="p_add">+</span>
<span class="p_add">+	This displays certain stats about the ring buffer:</span>
<span class="p_add">+</span>
<span class="p_add">+	entries:</span>
<span class="p_add">+		The number of events that are still in the buffer.</span>
<span class="p_add">+</span>
<span class="p_add">+	overrun:</span>
<span class="p_add">+		The number of lost events due to overwriting when</span>
<span class="p_add">+		the buffer was full.</span>
<span class="p_add">+</span>
<span class="p_add">+	commit overrun:</span>
<span class="p_add">+		Should always be zero.</span>
<span class="p_add">+		This gets set if so many events happened within a nested</span>
<span class="p_add">+		event (ring buffer is re-entrant), that it fills the</span>
<span class="p_add">+		buffer and starts dropping events.</span>
<span class="p_add">+</span>
<span class="p_add">+	bytes:</span>
<span class="p_add">+		Bytes actually read (not overwritten).</span>
<span class="p_add">+</span>
<span class="p_add">+	oldest event ts:</span>
<span class="p_add">+		The oldest timestamp in the buffer</span>
<span class="p_add">+</span>
<span class="p_add">+	now ts:</span>
<span class="p_add">+		The current timestamp</span>
<span class="p_add">+</span>
<span class="p_add">+	dropped events:</span>
<span class="p_add">+		Events lost due to overwrite option being off.</span>
<span class="p_add">+</span>
<span class="p_add">+	read events:</span>
<span class="p_add">+		The number of events read.</span>
<span class="p_add">+</span>
<span class="p_add">+The Tracers</span>
<span class="p_add">+-----------</span>
<span class="p_add">+</span>
<span class="p_add">+Here is the list of current tracers that may be configured.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;function&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	Function call tracer to trace all kernel functions.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;function_graph&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	Similar to the function tracer except that the</span>
<span class="p_add">+	function tracer probes the functions on their entry</span>
<span class="p_add">+	whereas the function graph tracer traces on both entry</span>
<span class="p_add">+	and exit of the functions. It then provides the ability</span>
<span class="p_add">+	to draw a graph of function calls similar to C code</span>
<span class="p_add">+	source.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;blk&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	The block tracer. The tracer used by the blktrace user</span>
<span class="p_add">+	application.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;hwlat&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	The Hardware Latency tracer is used to detect if the hardware</span>
<span class="p_add">+	produces any latency. See &quot;Hardware Latency Detector&quot; section</span>
<span class="p_add">+	below.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;irqsoff&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	Traces the areas that disable interrupts and saves</span>
<span class="p_add">+	the trace with the longest max latency.</span>
<span class="p_add">+	See tracing_max_latency. When a new max is recorded,</span>
<span class="p_add">+	it replaces the old trace. It is best to view this</span>
<span class="p_add">+	trace with the latency-format option enabled, which</span>
<span class="p_add">+	happens automatically when the tracer is selected.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;preemptoff&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	Similar to irqsoff but traces and records the amount of</span>
<span class="p_add">+	time for which preemption is disabled.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;preemptirqsoff&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	Similar to irqsoff and preemptoff, but traces and</span>
<span class="p_add">+	records the largest time for which irqs and/or preemption</span>
<span class="p_add">+	is disabled.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;wakeup&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	Traces and records the max latency that it takes for</span>
<span class="p_add">+	the highest priority task to get scheduled after</span>
<span class="p_add">+	it has been woken up.</span>
<span class="p_add">+        Traces all tasks as an average developer would expect.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;wakeup_rt&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+        Traces and records the max latency that it takes for just</span>
<span class="p_add">+        RT tasks (as the current &quot;wakeup&quot; does). This is useful</span>
<span class="p_add">+        for those interested in wake up timings of RT tasks.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;wakeup_dl&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	Traces and records the max latency that it takes for</span>
<span class="p_add">+	a SCHED_DEADLINE task to be woken (as the &quot;wakeup&quot; and</span>
<span class="p_add">+	&quot;wakeup_rt&quot; does).</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;mmiotrace&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	A special tracer that is used to trace binary module.</span>
<span class="p_add">+	It will trace all the calls that a module makes to the</span>
<span class="p_add">+	hardware. Everything it writes and reads from the I/O</span>
<span class="p_add">+	as well.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;branch&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	This tracer can be configured when tracing likely/unlikely</span>
<span class="p_add">+	calls within the kernel. It will trace when a likely and</span>
<span class="p_add">+	unlikely branch is hit and if it was correct in its prediction</span>
<span class="p_add">+	of being correct.</span>
<span class="p_add">+</span>
<span class="p_add">+  &quot;nop&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	This is the &quot;trace nothing&quot; tracer. To remove all</span>
<span class="p_add">+	tracers from tracing simply echo &quot;nop&quot; into</span>
<span class="p_add">+	current_tracer.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Examples of using the tracer</span>
<span class="p_add">+----------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Here are typical examples of using the tracers when controlling</span>
<span class="p_add">+them only with the tracefs interface (without using any</span>
<span class="p_add">+user-land utilities).</span>
<span class="p_add">+</span>
<span class="p_add">+Output format:</span>
<span class="p_add">+--------------</span>
<span class="p_add">+</span>
<span class="p_add">+Here is an example of the output format of the file &quot;trace&quot;::</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 140080/250280   #P:4</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+              bash-1977  [000] .... 17284.993652: sys_close &lt;-system_call_fastpath</span>
<span class="p_add">+              bash-1977  [000] .... 17284.993653: __close_fd &lt;-sys_close</span>
<span class="p_add">+              bash-1977  [000] .... 17284.993653: _raw_spin_lock &lt;-__close_fd</span>
<span class="p_add">+              sshd-1974  [003] .... 17284.993653: __srcu_read_unlock &lt;-fsnotify</span>
<span class="p_add">+              bash-1977  [000] .... 17284.993654: add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_add">+              bash-1977  [000] ...1 17284.993655: _raw_spin_unlock &lt;-__close_fd</span>
<span class="p_add">+              bash-1977  [000] ...1 17284.993656: sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+              bash-1977  [000] .... 17284.993657: filp_close &lt;-__close_fd</span>
<span class="p_add">+              bash-1977  [000] .... 17284.993657: dnotify_flush &lt;-filp_close</span>
<span class="p_add">+              sshd-1974  [003] .... 17284.993658: sys_select &lt;-system_call_fastpath</span>
<span class="p_add">+              ....</span>
<span class="p_add">+</span>
<span class="p_add">+A header is printed with the tracer name that is represented by</span>
<span class="p_add">+the trace. In this case the tracer is &quot;function&quot;. Then it shows the</span>
<span class="p_add">+number of events in the buffer as well as the total number of entries</span>
<span class="p_add">+that were written. The difference is the number of entries that were</span>
<span class="p_add">+lost due to the buffer filling up (250280 - 140080 = 110200 events</span>
<span class="p_add">+lost).</span>
<span class="p_add">+</span>
<span class="p_add">+The header explains the content of the events. Task name &quot;bash&quot;, the task</span>
<span class="p_add">+PID &quot;1977&quot;, the CPU that it was running on &quot;000&quot;, the latency format</span>
<span class="p_add">+(explained below), the timestamp in &lt;secs&gt;.&lt;usecs&gt; format, the</span>
<span class="p_add">+function name that was traced &quot;sys_close&quot; and the parent function that</span>
<span class="p_add">+called this function &quot;system_call_fastpath&quot;. The timestamp is the time</span>
<span class="p_add">+at which the function was entered.</span>
<span class="p_add">+</span>
<span class="p_add">+Latency trace format</span>
<span class="p_add">+--------------------</span>
<span class="p_add">+</span>
<span class="p_add">+When the latency-format option is enabled or when one of the latency</span>
<span class="p_add">+tracers is set, the trace file gives somewhat more information to see</span>
<span class="p_add">+why a latency happened. Here is a typical trace::</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: irqsoff</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # irqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 259 us, #4/4, CPU#2 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: ps-6143 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #  =&gt; started at: __lock_task_sighand</span>
<span class="p_add">+  #  =&gt; ended at:   _raw_spin_unlock_irqrestore</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+        ps-6143    2d...    0us!: trace_hardirqs_off &lt;-__lock_task_sighand</span>
<span class="p_add">+        ps-6143    2d..1  259us+: trace_hardirqs_on &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_add">+        ps-6143    2d..1  263us+: time_hardirqs_on &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_add">+        ps-6143    2d..1  306us : &lt;stack trace&gt;</span>
<span class="p_add">+   =&gt; trace_hardirqs_on_caller</span>
<span class="p_add">+   =&gt; trace_hardirqs_on</span>
<span class="p_add">+   =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_add">+   =&gt; do_task_stat</span>
<span class="p_add">+   =&gt; proc_tgid_stat</span>
<span class="p_add">+   =&gt; proc_single_show</span>
<span class="p_add">+   =&gt; seq_read</span>
<span class="p_add">+   =&gt; vfs_read</span>
<span class="p_add">+   =&gt; sys_read</span>
<span class="p_add">+   =&gt; system_call_fastpath</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+This shows that the current tracer is &quot;irqsoff&quot; tracing the time</span>
<span class="p_add">+for which interrupts were disabled. It gives the trace version (which</span>
<span class="p_add">+never changes) and the version of the kernel upon which this was executed on</span>
<span class="p_add">+(3.8). Then it displays the max latency in microseconds (259 us). The number</span>
<span class="p_add">+of trace entries displayed and the total number (both are four: #4/4).</span>
<span class="p_add">+VP, KP, SP, and HP are always zero and are reserved for later use.</span>
<span class="p_add">+#P is the number of online CPUs (#P:4).</span>
<span class="p_add">+</span>
<span class="p_add">+The task is the process that was running when the latency</span>
<span class="p_add">+occurred. (ps pid: 6143).</span>
<span class="p_add">+</span>
<span class="p_add">+The start and stop (the functions in which the interrupts were</span>
<span class="p_add">+disabled and enabled respectively) that caused the latencies:</span>
<span class="p_add">+</span>
<span class="p_add">+  - __lock_task_sighand is where the interrupts were disabled.</span>
<span class="p_add">+  - _raw_spin_unlock_irqrestore is where they were enabled again.</span>
<span class="p_add">+</span>
<span class="p_add">+The next lines after the header are the trace itself. The header</span>
<span class="p_add">+explains which is which.</span>
<span class="p_add">+</span>
<span class="p_add">+  cmd: The name of the process in the trace.</span>
<span class="p_add">+</span>
<span class="p_add">+  pid: The PID of that process.</span>
<span class="p_add">+</span>
<span class="p_add">+  CPU#: The CPU which the process was running on.</span>
<span class="p_add">+</span>
<span class="p_add">+  irqs-off: &#39;d&#39; interrupts are disabled. &#39;.&#39; otherwise.</span>
<span class="p_add">+	.. caution:: If the architecture does not support a way to</span>
<span class="p_add">+		read the irq flags variable, an &#39;X&#39; will always</span>
<span class="p_add">+		be printed here.</span>
<span class="p_add">+</span>
<span class="p_add">+  need-resched:</span>
<span class="p_add">+	- &#39;N&#39; both TIF_NEED_RESCHED and PREEMPT_NEED_RESCHED is set,</span>
<span class="p_add">+	- &#39;n&#39; only TIF_NEED_RESCHED is set,</span>
<span class="p_add">+	- &#39;p&#39; only PREEMPT_NEED_RESCHED is set,</span>
<span class="p_add">+	- &#39;.&#39; otherwise.</span>
<span class="p_add">+</span>
<span class="p_add">+  hardirq/softirq:</span>
<span class="p_add">+	- &#39;Z&#39; - NMI occurred inside a hardirq</span>
<span class="p_add">+	- &#39;z&#39; - NMI is running</span>
<span class="p_add">+	- &#39;H&#39; - hard irq occurred inside a softirq.</span>
<span class="p_add">+	- &#39;h&#39; - hard irq is running</span>
<span class="p_add">+	- &#39;s&#39; - soft irq is running</span>
<span class="p_add">+	- &#39;.&#39; - normal context.</span>
<span class="p_add">+</span>
<span class="p_add">+  preempt-depth: The level of preempt_disabled</span>
<span class="p_add">+</span>
<span class="p_add">+The above is mostly meaningful for kernel developers.</span>
<span class="p_add">+</span>
<span class="p_add">+  time:</span>
<span class="p_add">+	When the latency-format option is enabled, the trace file</span>
<span class="p_add">+	output includes a timestamp relative to the start of the</span>
<span class="p_add">+	trace. This differs from the output when latency-format</span>
<span class="p_add">+	is disabled, which includes an absolute timestamp.</span>
<span class="p_add">+</span>
<span class="p_add">+  delay:</span>
<span class="p_add">+	This is just to help catch your eye a bit better. And</span>
<span class="p_add">+	needs to be fixed to be only relative to the same CPU.</span>
<span class="p_add">+	The marks are determined by the difference between this</span>
<span class="p_add">+	current trace and the next trace.</span>
<span class="p_add">+</span>
<span class="p_add">+	  - &#39;$&#39; - greater than 1 second</span>
<span class="p_add">+	  - &#39;@&#39; - greater than 100 milisecond</span>
<span class="p_add">+	  - &#39;*&#39; - greater than 10 milisecond</span>
<span class="p_add">+	  - &#39;#&#39; - greater than 1000 microsecond</span>
<span class="p_add">+	  - &#39;!&#39; - greater than 100 microsecond</span>
<span class="p_add">+	  - &#39;+&#39; - greater than 10 microsecond</span>
<span class="p_add">+	  - &#39; &#39; - less than or equal to 10 microsecond.</span>
<span class="p_add">+</span>
<span class="p_add">+  The rest is the same as the &#39;trace&#39; file.</span>
<span class="p_add">+</span>
<span class="p_add">+  Note, the latency tracers will usually end with a back trace</span>
<span class="p_add">+  to easily find where the latency occurred.</span>
<span class="p_add">+</span>
<span class="p_add">+trace_options</span>
<span class="p_add">+-------------</span>
<span class="p_add">+</span>
<span class="p_add">+The trace_options file (or the options directory) is used to control</span>
<span class="p_add">+what gets printed in the trace output, or manipulate the tracers.</span>
<span class="p_add">+To see what is available, simply cat the file::</span>
<span class="p_add">+</span>
<span class="p_add">+  cat trace_options</span>
<span class="p_add">+	print-parent</span>
<span class="p_add">+	nosym-offset</span>
<span class="p_add">+	nosym-addr</span>
<span class="p_add">+	noverbose</span>
<span class="p_add">+	noraw</span>
<span class="p_add">+	nohex</span>
<span class="p_add">+	nobin</span>
<span class="p_add">+	noblock</span>
<span class="p_add">+	trace_printk</span>
<span class="p_add">+	annotate</span>
<span class="p_add">+	nouserstacktrace</span>
<span class="p_add">+	nosym-userobj</span>
<span class="p_add">+	noprintk-msg-only</span>
<span class="p_add">+	context-info</span>
<span class="p_add">+	nolatency-format</span>
<span class="p_add">+	record-cmd</span>
<span class="p_add">+	norecord-tgid</span>
<span class="p_add">+	overwrite</span>
<span class="p_add">+	nodisable_on_free</span>
<span class="p_add">+	irq-info</span>
<span class="p_add">+	markers</span>
<span class="p_add">+	noevent-fork</span>
<span class="p_add">+	function-trace</span>
<span class="p_add">+	nofunction-fork</span>
<span class="p_add">+	nodisplay-graph</span>
<span class="p_add">+	nostacktrace</span>
<span class="p_add">+	nobranch</span>
<span class="p_add">+</span>
<span class="p_add">+To disable one of the options, echo in the option prepended with</span>
<span class="p_add">+&quot;no&quot;::</span>
<span class="p_add">+</span>
<span class="p_add">+  echo noprint-parent &gt; trace_options</span>
<span class="p_add">+</span>
<span class="p_add">+To enable an option, leave off the &quot;no&quot;::</span>
<span class="p_add">+</span>
<span class="p_add">+  echo sym-offset &gt; trace_options</span>
<span class="p_add">+</span>
<span class="p_add">+Here are the available options:</span>
<span class="p_add">+</span>
<span class="p_add">+  print-parent</span>
<span class="p_add">+	On function traces, display the calling (parent)</span>
<span class="p_add">+	function as well as the function being traced.</span>
<span class="p_add">+	::</span>
<span class="p_add">+</span>
<span class="p_add">+	  print-parent:</span>
<span class="p_add">+	   bash-4000  [01]  1477.606694: simple_strtoul &lt;-kstrtoul</span>
<span class="p_add">+</span>
<span class="p_add">+	  noprint-parent:</span>
<span class="p_add">+	   bash-4000  [01]  1477.606694: simple_strtoul</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+  sym-offset</span>
<span class="p_add">+	Display not only the function name, but also the</span>
<span class="p_add">+	offset in the function. For example, instead of</span>
<span class="p_add">+	seeing just &quot;ktime_get&quot;, you will see</span>
<span class="p_add">+	&quot;ktime_get+0xb/0x20&quot;.</span>
<span class="p_add">+	::</span>
<span class="p_add">+</span>
<span class="p_add">+	  sym-offset:</span>
<span class="p_add">+	   bash-4000  [01]  1477.606694: simple_strtoul+0x6/0xa0</span>
<span class="p_add">+</span>
<span class="p_add">+  sym-addr</span>
<span class="p_add">+	This will also display the function address as well</span>
<span class="p_add">+	as the function name.</span>
<span class="p_add">+	::</span>
<span class="p_add">+</span>
<span class="p_add">+	  sym-addr:</span>
<span class="p_add">+	   bash-4000  [01]  1477.606694: simple_strtoul &lt;c0339346&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+  verbose</span>
<span class="p_add">+	This deals with the trace file when the</span>
<span class="p_add">+        latency-format option is enabled.</span>
<span class="p_add">+	::</span>
<span class="p_add">+</span>
<span class="p_add">+	    bash  4000 1 0 00000000 00010a95 [58127d26] 1720.415ms \</span>
<span class="p_add">+	    (+0.000ms): simple_strtoul (kstrtoul)</span>
<span class="p_add">+</span>
<span class="p_add">+  raw</span>
<span class="p_add">+	This will display raw numbers. This option is best for</span>
<span class="p_add">+	use with user applications that can translate the raw</span>
<span class="p_add">+	numbers better than having it done in the kernel.</span>
<span class="p_add">+</span>
<span class="p_add">+  hex</span>
<span class="p_add">+	Similar to raw, but the numbers will be in a hexadecimal format.</span>
<span class="p_add">+</span>
<span class="p_add">+  bin</span>
<span class="p_add">+	This will print out the formats in raw binary.</span>
<span class="p_add">+</span>
<span class="p_add">+  block</span>
<span class="p_add">+	When set, reading trace_pipe will not block when polled.</span>
<span class="p_add">+</span>
<span class="p_add">+  trace_printk</span>
<span class="p_add">+	Can disable trace_printk() from writing into the buffer.</span>
<span class="p_add">+</span>
<span class="p_add">+  annotate</span>
<span class="p_add">+	It is sometimes confusing when the CPU buffers are full</span>
<span class="p_add">+	and one CPU buffer had a lot of events recently, thus</span>
<span class="p_add">+	a shorter time frame, were another CPU may have only had</span>
<span class="p_add">+	a few events, which lets it have older events. When</span>
<span class="p_add">+	the trace is reported, it shows the oldest events first,</span>
<span class="p_add">+	and it may look like only one CPU ran (the one with the</span>
<span class="p_add">+	oldest events). When the annotate option is set, it will</span>
<span class="p_add">+	display when a new CPU buffer started::</span>
<span class="p_add">+</span>
<span class="p_add">+			  &lt;idle&gt;-0     [001] dNs4 21169.031481: wake_up_idle_cpu &lt;-add_timer_on</span>
<span class="p_add">+			  &lt;idle&gt;-0     [001] dNs4 21169.031482: _raw_spin_unlock_irqrestore &lt;-add_timer_on</span>
<span class="p_add">+			  &lt;idle&gt;-0     [001] .Ns4 21169.031484: sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_add">+		##### CPU 2 buffer started ####</span>
<span class="p_add">+			  &lt;idle&gt;-0     [002] .N.1 21169.031484: rcu_idle_exit &lt;-cpu_idle</span>
<span class="p_add">+			  &lt;idle&gt;-0     [001] .Ns3 21169.031484: _raw_spin_unlock &lt;-clocksource_watchdog</span>
<span class="p_add">+			  &lt;idle&gt;-0     [001] .Ns3 21169.031485: sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+</span>
<span class="p_add">+  userstacktrace</span>
<span class="p_add">+	This option changes the trace. It records a</span>
<span class="p_add">+	stacktrace of the current user space thread after</span>
<span class="p_add">+	each trace event.</span>
<span class="p_add">+</span>
<span class="p_add">+  sym-userobj</span>
<span class="p_add">+	when user stacktrace are enabled, look up which</span>
<span class="p_add">+	object the address belongs to, and print a</span>
<span class="p_add">+	relative address. This is especially useful when</span>
<span class="p_add">+	ASLR is on, otherwise you don&#39;t get a chance to</span>
<span class="p_add">+	resolve the address to object/file/line after</span>
<span class="p_add">+	the app is no longer running</span>
<span class="p_add">+</span>
<span class="p_add">+	The lookup is performed when you read</span>
<span class="p_add">+	trace,trace_pipe. Example::</span>
<span class="p_add">+</span>
<span class="p_add">+		  a.out-1623  [000] 40874.465068: /root/a.out[+0x480] &lt;-/root/a.out[+0</span>
<span class="p_add">+		  x494] &lt;- /root/a.out[+0x4a8] &lt;- /lib/libc-2.7.so[+0x1e1a6]</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+  printk-msg-only</span>
<span class="p_add">+	When set, trace_printk()s will only show the format</span>
<span class="p_add">+	and not their parameters (if trace_bprintk() or</span>
<span class="p_add">+	trace_bputs() was used to save the trace_printk()).</span>
<span class="p_add">+</span>
<span class="p_add">+  context-info</span>
<span class="p_add">+	Show only the event data. Hides the comm, PID,</span>
<span class="p_add">+	timestamp, CPU, and other useful data.</span>
<span class="p_add">+</span>
<span class="p_add">+  latency-format</span>
<span class="p_add">+	This option changes the trace output. When it is enabled,</span>
<span class="p_add">+	the trace displays additional information about the</span>
<span class="p_add">+	latency, as described in &quot;Latency trace format&quot;.</span>
<span class="p_add">+</span>
<span class="p_add">+  record-cmd</span>
<span class="p_add">+	When any event or tracer is enabled, a hook is enabled</span>
<span class="p_add">+	in the sched_switch trace point to fill comm cache</span>
<span class="p_add">+	with mapped pids and comms. But this may cause some</span>
<span class="p_add">+	overhead, and if you only care about pids, and not the</span>
<span class="p_add">+	name of the task, disabling this option can lower the</span>
<span class="p_add">+	impact of tracing. See &quot;saved_cmdlines&quot;.</span>
<span class="p_add">+</span>
<span class="p_add">+  record-tgid</span>
<span class="p_add">+	When any event or tracer is enabled, a hook is enabled</span>
<span class="p_add">+	in the sched_switch trace point to fill the cache of</span>
<span class="p_add">+	mapped Thread Group IDs (TGID) mapping to pids. See</span>
<span class="p_add">+	&quot;saved_tgids&quot;.</span>
<span class="p_add">+</span>
<span class="p_add">+  overwrite</span>
<span class="p_add">+	This controls what happens when the trace buffer is</span>
<span class="p_add">+	full. If &quot;1&quot; (default), the oldest events are</span>
<span class="p_add">+	discarded and overwritten. If &quot;0&quot;, then the newest</span>
<span class="p_add">+	events are discarded.</span>
<span class="p_add">+	(see per_cpu/cpu0/stats for overrun and dropped)</span>
<span class="p_add">+</span>
<span class="p_add">+  disable_on_free</span>
<span class="p_add">+	When the free_buffer is closed, tracing will</span>
<span class="p_add">+	stop (tracing_on set to 0).</span>
<span class="p_add">+</span>
<span class="p_add">+  irq-info</span>
<span class="p_add">+	Shows the interrupt, preempt count, need resched data.</span>
<span class="p_add">+	When disabled, the trace looks like::</span>
<span class="p_add">+</span>
<span class="p_add">+		# tracer: function</span>
<span class="p_add">+		#</span>
<span class="p_add">+		# entries-in-buffer/entries-written: 144405/9452052   #P:4</span>
<span class="p_add">+		#</span>
<span class="p_add">+		#           TASK-PID   CPU#      TIMESTAMP  FUNCTION</span>
<span class="p_add">+		#              | |       |          |         |</span>
<span class="p_add">+			  &lt;idle&gt;-0     [002]  23636.756054: ttwu_do_activate.constprop.89 &lt;-try_to_wake_up</span>
<span class="p_add">+			  &lt;idle&gt;-0     [002]  23636.756054: activate_task &lt;-ttwu_do_activate.constprop.89</span>
<span class="p_add">+			  &lt;idle&gt;-0     [002]  23636.756055: enqueue_task &lt;-activate_task</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+  markers</span>
<span class="p_add">+	When set, the trace_marker is writable (only by root).</span>
<span class="p_add">+	When disabled, the trace_marker will error with EINVAL</span>
<span class="p_add">+	on write.</span>
<span class="p_add">+</span>
<span class="p_add">+  event-fork</span>
<span class="p_add">+	When set, tasks with PIDs listed in set_event_pid will have</span>
<span class="p_add">+	the PIDs of their children added to set_event_pid when those</span>
<span class="p_add">+	tasks fork. Also, when tasks with PIDs in set_event_pid exit,</span>
<span class="p_add">+	their PIDs will be removed from the file.</span>
<span class="p_add">+</span>
<span class="p_add">+  function-trace</span>
<span class="p_add">+	The latency tracers will enable function tracing</span>
<span class="p_add">+	if this option is enabled (default it is). When</span>
<span class="p_add">+	it is disabled, the latency tracers do not trace</span>
<span class="p_add">+	functions. This keeps the overhead of the tracer down</span>
<span class="p_add">+	when performing latency tests.</span>
<span class="p_add">+</span>
<span class="p_add">+  function-fork</span>
<span class="p_add">+	When set, tasks with PIDs listed in set_ftrace_pid will</span>
<span class="p_add">+	have the PIDs of their children added to set_ftrace_pid</span>
<span class="p_add">+	when those tasks fork. Also, when tasks with PIDs in</span>
<span class="p_add">+	set_ftrace_pid exit, their PIDs will be removed from the</span>
<span class="p_add">+	file.</span>
<span class="p_add">+</span>
<span class="p_add">+  display-graph</span>
<span class="p_add">+	When set, the latency tracers (irqsoff, wakeup, etc) will</span>
<span class="p_add">+	use function graph tracing instead of function tracing.</span>
<span class="p_add">+</span>
<span class="p_add">+  stacktrace</span>
<span class="p_add">+	When set, a stack trace is recorded after any trace event</span>
<span class="p_add">+	is recorded.</span>
<span class="p_add">+</span>
<span class="p_add">+  branch</span>
<span class="p_add">+	Enable branch tracing with the tracer. This enables branch</span>
<span class="p_add">+	tracer along with the currently set tracer. Enabling this</span>
<span class="p_add">+	with the &quot;nop&quot; tracer is the same as just enabling the</span>
<span class="p_add">+	&quot;branch&quot; tracer.</span>
<span class="p_add">+</span>
<span class="p_add">+.. tip:: Some tracers have their own options. They only appear in this</span>
<span class="p_add">+       file when the tracer is active. They always appear in the</span>
<span class="p_add">+       options directory.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Here are the per tracer options:</span>
<span class="p_add">+</span>
<span class="p_add">+Options for function tracer:</span>
<span class="p_add">+</span>
<span class="p_add">+  func_stack_trace</span>
<span class="p_add">+	When set, a stack trace is recorded after every</span>
<span class="p_add">+	function that is recorded. NOTE! Limit the functions</span>
<span class="p_add">+	that are recorded before enabling this, with</span>
<span class="p_add">+	&quot;set_ftrace_filter&quot; otherwise the system performance</span>
<span class="p_add">+	will be critically degraded. Remember to disable</span>
<span class="p_add">+	this option before clearing the function filter.</span>
<span class="p_add">+</span>
<span class="p_add">+Options for function_graph tracer:</span>
<span class="p_add">+</span>
<span class="p_add">+ Since the function_graph tracer has a slightly different output</span>
<span class="p_add">+ it has its own options to control what is displayed.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-overrun</span>
<span class="p_add">+	When set, the &quot;overrun&quot; of the graph stack is</span>
<span class="p_add">+	displayed after each function traced. The</span>
<span class="p_add">+	overrun, is when the stack depth of the calls</span>
<span class="p_add">+	is greater than what is reserved for each task.</span>
<span class="p_add">+	Each task has a fixed array of functions to</span>
<span class="p_add">+	trace in the call graph. If the depth of the</span>
<span class="p_add">+	calls exceeds that, the function is not traced.</span>
<span class="p_add">+	The overrun is the number of functions missed</span>
<span class="p_add">+	due to exceeding this array.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-cpu</span>
<span class="p_add">+	When set, the CPU number of the CPU where the trace</span>
<span class="p_add">+	occurred is displayed.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-overhead</span>
<span class="p_add">+	When set, if the function takes longer than</span>
<span class="p_add">+	A certain amount, then a delay marker is</span>
<span class="p_add">+	displayed. See &quot;delay&quot; above, under the</span>
<span class="p_add">+	header description.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-proc</span>
<span class="p_add">+	Unlike other tracers, the process&#39; command line</span>
<span class="p_add">+	is not displayed by default, but instead only</span>
<span class="p_add">+	when a task is traced in and out during a context</span>
<span class="p_add">+	switch. Enabling this options has the command</span>
<span class="p_add">+	of each process displayed at every line.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-duration</span>
<span class="p_add">+	At the end of each function (the return)</span>
<span class="p_add">+	the duration of the amount of time in the</span>
<span class="p_add">+	function is displayed in microseconds.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-abstime</span>
<span class="p_add">+	When set, the timestamp is displayed at each line.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-irqs</span>
<span class="p_add">+	When disabled, functions that happen inside an</span>
<span class="p_add">+	interrupt will not be traced.</span>
<span class="p_add">+</span>
<span class="p_add">+  funcgraph-tail</span>
<span class="p_add">+	When set, the return event will include the function</span>
<span class="p_add">+	that it represents. By default this is off, and</span>
<span class="p_add">+	only a closing curly bracket &quot;}&quot; is displayed for</span>
<span class="p_add">+	the return of a function.</span>
<span class="p_add">+</span>
<span class="p_add">+  sleep-time</span>
<span class="p_add">+	When running function graph tracer, to include</span>
<span class="p_add">+	the time a task schedules out in its function.</span>
<span class="p_add">+	When enabled, it will account time the task has been</span>
<span class="p_add">+	scheduled out as part of the function call.</span>
<span class="p_add">+</span>
<span class="p_add">+  graph-time</span>
<span class="p_add">+	When running function profiler with function graph tracer,</span>
<span class="p_add">+	to include the time to call nested functions. When this is</span>
<span class="p_add">+	not set, the time reported for the function will only</span>
<span class="p_add">+	include the time the function itself executed for, not the</span>
<span class="p_add">+	time for functions that it called.</span>
<span class="p_add">+</span>
<span class="p_add">+Options for blk tracer:</span>
<span class="p_add">+</span>
<span class="p_add">+  blk_classic</span>
<span class="p_add">+	Shows a more minimalistic output.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+irqsoff</span>
<span class="p_add">+-------</span>
<span class="p_add">+</span>
<span class="p_add">+When interrupts are disabled, the CPU can not react to any other</span>
<span class="p_add">+external event (besides NMIs and SMIs). This prevents the timer</span>
<span class="p_add">+interrupt from triggering or the mouse interrupt from letting</span>
<span class="p_add">+the kernel know of a new mouse event. The result is a latency</span>
<span class="p_add">+with the reaction time.</span>
<span class="p_add">+</span>
<span class="p_add">+The irqsoff tracer tracks the time for which interrupts are</span>
<span class="p_add">+disabled. When a new maximum latency is hit, the tracer saves</span>
<span class="p_add">+the trace leading up to that latency point so that every time a</span>
<span class="p_add">+new maximum is reached, the old saved trace is discarded and the</span>
<span class="p_add">+new trace is saved.</span>
<span class="p_add">+</span>
<span class="p_add">+To reset the maximum, echo 0 into tracing_max_latency. Here is</span>
<span class="p_add">+an example::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 0 &gt; options/function-trace</span>
<span class="p_add">+  # echo irqsoff &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # echo 0 &gt; tracing_max_latency</span>
<span class="p_add">+  # ls -ltr</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: irqsoff</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # irqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 16 us, #4/4, CPU#0 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: swapper/0-0 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #  =&gt; started at: run_timer_softirq</span>
<span class="p_add">+  #  =&gt; ended at:   run_timer_softirq</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+    &lt;idle&gt;-0       0d.s2    0us+: _raw_spin_lock_irq &lt;-run_timer_softirq</span>
<span class="p_add">+    &lt;idle&gt;-0       0dNs3   17us : _raw_spin_unlock_irq &lt;-run_timer_softirq</span>
<span class="p_add">+    &lt;idle&gt;-0       0dNs3   17us+: trace_hardirqs_on &lt;-run_timer_softirq</span>
<span class="p_add">+    &lt;idle&gt;-0       0dNs3   25us : &lt;stack trace&gt;</span>
<span class="p_add">+   =&gt; _raw_spin_unlock_irq</span>
<span class="p_add">+   =&gt; run_timer_softirq</span>
<span class="p_add">+   =&gt; __do_softirq</span>
<span class="p_add">+   =&gt; call_softirq</span>
<span class="p_add">+   =&gt; do_softirq</span>
<span class="p_add">+   =&gt; irq_exit</span>
<span class="p_add">+   =&gt; smp_apic_timer_interrupt</span>
<span class="p_add">+   =&gt; apic_timer_interrupt</span>
<span class="p_add">+   =&gt; rcu_idle_exit</span>
<span class="p_add">+   =&gt; cpu_idle</span>
<span class="p_add">+   =&gt; rest_init</span>
<span class="p_add">+   =&gt; start_kernel</span>
<span class="p_add">+   =&gt; x86_64_start_reservations</span>
<span class="p_add">+   =&gt; x86_64_start_kernel</span>
<span class="p_add">+</span>
<span class="p_add">+Here we see that that we had a latency of 16 microseconds (which is</span>
<span class="p_add">+very good). The _raw_spin_lock_irq in run_timer_softirq disabled</span>
<span class="p_add">+interrupts. The difference between the 16 and the displayed</span>
<span class="p_add">+timestamp 25us occurred because the clock was incremented</span>
<span class="p_add">+between the time of recording the max latency and the time of</span>
<span class="p_add">+recording the function that had that latency.</span>
<span class="p_add">+</span>
<span class="p_add">+Note the above example had function-trace not set. If we set</span>
<span class="p_add">+function-trace, we get a much larger output::</span>
<span class="p_add">+</span>
<span class="p_add">+ with echo 1 &gt; options/function-trace</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: irqsoff</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # irqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 71 us, #168/168, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: bash-2042 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #  =&gt; started at: ata_scsi_queuecmd</span>
<span class="p_add">+  #  =&gt; ended at:   ata_scsi_queuecmd</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+      bash-2042    3d...    0us : _raw_spin_lock_irqsave &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d...    0us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_add">+      bash-2042    3d..1    1us : ata_scsi_find_dev &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d..1    1us : __ata_scsi_find_dev &lt;-ata_scsi_find_dev</span>
<span class="p_add">+      bash-2042    3d..1    2us : ata_find_dev.part.14 &lt;-__ata_scsi_find_dev</span>
<span class="p_add">+      bash-2042    3d..1    2us : ata_qc_new_init &lt;-__ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d..1    3us : ata_sg_init &lt;-__ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d..1    4us : ata_scsi_rw_xlat &lt;-__ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d..1    4us : ata_build_rw_tf &lt;-ata_scsi_rw_xlat</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+      bash-2042    3d..1   67us : delay_tsc &lt;-__delay</span>
<span class="p_add">+      bash-2042    3d..1   67us : add_preempt_count &lt;-delay_tsc</span>
<span class="p_add">+      bash-2042    3d..2   67us : sub_preempt_count &lt;-delay_tsc</span>
<span class="p_add">+      bash-2042    3d..1   67us : add_preempt_count &lt;-delay_tsc</span>
<span class="p_add">+      bash-2042    3d..2   68us : sub_preempt_count &lt;-delay_tsc</span>
<span class="p_add">+      bash-2042    3d..1   68us+: ata_bmdma_start &lt;-ata_bmdma_qc_issue</span>
<span class="p_add">+      bash-2042    3d..1   71us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d..1   71us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d..1   72us+: trace_hardirqs_on &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+      bash-2042    3d..1  120us : &lt;stack trace&gt;</span>
<span class="p_add">+   =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_add">+   =&gt; ata_scsi_queuecmd</span>
<span class="p_add">+   =&gt; scsi_dispatch_cmd</span>
<span class="p_add">+   =&gt; scsi_request_fn</span>
<span class="p_add">+   =&gt; __blk_run_queue_uncond</span>
<span class="p_add">+   =&gt; __blk_run_queue</span>
<span class="p_add">+   =&gt; blk_queue_bio</span>
<span class="p_add">+   =&gt; generic_make_request</span>
<span class="p_add">+   =&gt; submit_bio</span>
<span class="p_add">+   =&gt; submit_bh</span>
<span class="p_add">+   =&gt; __ext3_get_inode_loc</span>
<span class="p_add">+   =&gt; ext3_iget</span>
<span class="p_add">+   =&gt; ext3_lookup</span>
<span class="p_add">+   =&gt; lookup_real</span>
<span class="p_add">+   =&gt; __lookup_hash</span>
<span class="p_add">+   =&gt; walk_component</span>
<span class="p_add">+   =&gt; lookup_last</span>
<span class="p_add">+   =&gt; path_lookupat</span>
<span class="p_add">+   =&gt; filename_lookup</span>
<span class="p_add">+   =&gt; user_path_at_empty</span>
<span class="p_add">+   =&gt; user_path_at</span>
<span class="p_add">+   =&gt; vfs_fstatat</span>
<span class="p_add">+   =&gt; vfs_stat</span>
<span class="p_add">+   =&gt; sys_newstat</span>
<span class="p_add">+   =&gt; system_call_fastpath</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Here we traced a 71 microsecond latency. But we also see all the</span>
<span class="p_add">+functions that were called during that time. Note that by</span>
<span class="p_add">+enabling function tracing, we incur an added overhead. This</span>
<span class="p_add">+overhead may extend the latency times. But nevertheless, this</span>
<span class="p_add">+trace has provided some very helpful debugging information.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+preemptoff</span>
<span class="p_add">+----------</span>
<span class="p_add">+</span>
<span class="p_add">+When preemption is disabled, we may be able to receive</span>
<span class="p_add">+interrupts but the task cannot be preempted and a higher</span>
<span class="p_add">+priority task must wait for preemption to be enabled again</span>
<span class="p_add">+before it can preempt a lower priority task.</span>
<span class="p_add">+</span>
<span class="p_add">+The preemptoff tracer traces the places that disable preemption.</span>
<span class="p_add">+Like the irqsoff tracer, it records the maximum latency for</span>
<span class="p_add">+which preemption was disabled. The control of preemptoff tracer</span>
<span class="p_add">+is much like the irqsoff tracer.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 0 &gt; options/function-trace</span>
<span class="p_add">+  # echo preemptoff &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # echo 0 &gt; tracing_max_latency</span>
<span class="p_add">+  # ls -ltr</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: preemptoff</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # preemptoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 46 us, #4/4, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: sshd-1991 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #  =&gt; started at: do_IRQ</span>
<span class="p_add">+  #  =&gt; ended at:   do_IRQ</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+      sshd-1991    1d.h.    0us+: irq_enter &lt;-do_IRQ</span>
<span class="p_add">+      sshd-1991    1d..1   46us : irq_exit &lt;-do_IRQ</span>
<span class="p_add">+      sshd-1991    1d..1   47us+: trace_preempt_on &lt;-do_IRQ</span>
<span class="p_add">+      sshd-1991    1d..1   52us : &lt;stack trace&gt;</span>
<span class="p_add">+   =&gt; sub_preempt_count</span>
<span class="p_add">+   =&gt; irq_exit</span>
<span class="p_add">+   =&gt; do_IRQ</span>
<span class="p_add">+   =&gt; ret_from_intr</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+This has some more changes. Preemption was disabled when an</span>
<span class="p_add">+interrupt came in (notice the &#39;h&#39;), and was enabled on exit.</span>
<span class="p_add">+But we also see that interrupts have been disabled when entering</span>
<span class="p_add">+the preempt off section and leaving it (the &#39;d&#39;). We do not know if</span>
<span class="p_add">+interrupts were enabled in the mean time or shortly after this</span>
<span class="p_add">+was over.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: preemptoff</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # preemptoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 83 us, #241/241, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: bash-1994 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #  =&gt; started at: wake_up_new_task</span>
<span class="p_add">+  #  =&gt; ended at:   task_rq_unlock</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+      bash-1994    1d..1    0us : _raw_spin_lock_irqsave &lt;-wake_up_new_task</span>
<span class="p_add">+      bash-1994    1d..1    0us : select_task_rq_fair &lt;-select_task_rq</span>
<span class="p_add">+      bash-1994    1d..1    1us : __rcu_read_lock &lt;-select_task_rq_fair</span>
<span class="p_add">+      bash-1994    1d..1    1us : source_load &lt;-select_task_rq_fair</span>
<span class="p_add">+      bash-1994    1d..1    1us : source_load &lt;-select_task_rq_fair</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+      bash-1994    1d..1   12us : irq_enter &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+      bash-1994    1d..1   12us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_add">+      bash-1994    1d..1   13us : add_preempt_count &lt;-irq_enter</span>
<span class="p_add">+      bash-1994    1d.h1   13us : exit_idle &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+      bash-1994    1d.h1   13us : hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+      bash-1994    1d.h1   13us : _raw_spin_lock &lt;-hrtimer_interrupt</span>
<span class="p_add">+      bash-1994    1d.h1   14us : add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_add">+      bash-1994    1d.h2   14us : ktime_get_update_offsets &lt;-hrtimer_interrupt</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+      bash-1994    1d.h1   35us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_add">+      bash-1994    1d.h1   35us : irq_exit &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+      bash-1994    1d.h1   36us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_add">+      bash-1994    1d..2   36us : do_softirq &lt;-irq_exit</span>
<span class="p_add">+      bash-1994    1d..2   36us : __do_softirq &lt;-call_softirq</span>
<span class="p_add">+      bash-1994    1d..2   36us : __local_bh_disable &lt;-__do_softirq</span>
<span class="p_add">+      bash-1994    1d.s2   37us : add_preempt_count &lt;-_raw_spin_lock_irq</span>
<span class="p_add">+      bash-1994    1d.s3   38us : _raw_spin_unlock &lt;-run_timer_softirq</span>
<span class="p_add">+      bash-1994    1d.s3   39us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+      bash-1994    1d.s2   39us : call_timer_fn &lt;-run_timer_softirq</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+      bash-1994    1dNs2   81us : cpu_needs_another_gp &lt;-rcu_process_callbacks</span>
<span class="p_add">+      bash-1994    1dNs2   82us : __local_bh_enable &lt;-__do_softirq</span>
<span class="p_add">+      bash-1994    1dNs2   82us : sub_preempt_count &lt;-__local_bh_enable</span>
<span class="p_add">+      bash-1994    1dN.2   82us : idle_cpu &lt;-irq_exit</span>
<span class="p_add">+      bash-1994    1dN.2   83us : rcu_irq_exit &lt;-irq_exit</span>
<span class="p_add">+      bash-1994    1dN.2   83us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_add">+      bash-1994    1.N.1   84us : _raw_spin_unlock_irqrestore &lt;-task_rq_unlock</span>
<span class="p_add">+      bash-1994    1.N.1   84us+: trace_preempt_on &lt;-task_rq_unlock</span>
<span class="p_add">+      bash-1994    1.N.1  104us : &lt;stack trace&gt;</span>
<span class="p_add">+   =&gt; sub_preempt_count</span>
<span class="p_add">+   =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_add">+   =&gt; task_rq_unlock</span>
<span class="p_add">+   =&gt; wake_up_new_task</span>
<span class="p_add">+   =&gt; do_fork</span>
<span class="p_add">+   =&gt; sys_clone</span>
<span class="p_add">+   =&gt; stub_clone</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+The above is an example of the preemptoff trace with</span>
<span class="p_add">+function-trace set. Here we see that interrupts were not disabled</span>
<span class="p_add">+the entire time. The irq_enter code lets us know that we entered</span>
<span class="p_add">+an interrupt &#39;h&#39;. Before that, the functions being traced still</span>
<span class="p_add">+show that it is not in an interrupt, but we can see from the</span>
<span class="p_add">+functions themselves that this is not the case.</span>
<span class="p_add">+</span>
<span class="p_add">+preemptirqsoff</span>
<span class="p_add">+--------------</span>
<span class="p_add">+</span>
<span class="p_add">+Knowing the locations that have interrupts disabled or</span>
<span class="p_add">+preemption disabled for the longest times is helpful. But</span>
<span class="p_add">+sometimes we would like to know when either preemption and/or</span>
<span class="p_add">+interrupts are disabled.</span>
<span class="p_add">+</span>
<span class="p_add">+Consider the following code::</span>
<span class="p_add">+</span>
<span class="p_add">+    local_irq_disable();</span>
<span class="p_add">+    call_function_with_irqs_off();</span>
<span class="p_add">+    preempt_disable();</span>
<span class="p_add">+    call_function_with_irqs_and_preemption_off();</span>
<span class="p_add">+    local_irq_enable();</span>
<span class="p_add">+    call_function_with_preemption_off();</span>
<span class="p_add">+    preempt_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+The irqsoff tracer will record the total length of</span>
<span class="p_add">+call_function_with_irqs_off() and</span>
<span class="p_add">+call_function_with_irqs_and_preemption_off().</span>
<span class="p_add">+</span>
<span class="p_add">+The preemptoff tracer will record the total length of</span>
<span class="p_add">+call_function_with_irqs_and_preemption_off() and</span>
<span class="p_add">+call_function_with_preemption_off().</span>
<span class="p_add">+</span>
<span class="p_add">+But neither will trace the time that interrupts and/or</span>
<span class="p_add">+preemption is disabled. This total time is the time that we can</span>
<span class="p_add">+not schedule. To record this time, use the preemptirqsoff</span>
<span class="p_add">+tracer.</span>
<span class="p_add">+</span>
<span class="p_add">+Again, using this trace is much like the irqsoff and preemptoff</span>
<span class="p_add">+tracers.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 0 &gt; options/function-trace</span>
<span class="p_add">+  # echo preemptirqsoff &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # echo 0 &gt; tracing_max_latency</span>
<span class="p_add">+  # ls -ltr</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: preemptirqsoff</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # preemptirqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 100 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: ls-2230 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #  =&gt; started at: ata_scsi_queuecmd</span>
<span class="p_add">+  #  =&gt; ended at:   ata_scsi_queuecmd</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+        ls-2230    3d...    0us+: _raw_spin_lock_irqsave &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+        ls-2230    3...1  100us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+        ls-2230    3...1  101us+: trace_preempt_on &lt;-ata_scsi_queuecmd</span>
<span class="p_add">+        ls-2230    3...1  111us : &lt;stack trace&gt;</span>
<span class="p_add">+   =&gt; sub_preempt_count</span>
<span class="p_add">+   =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_add">+   =&gt; ata_scsi_queuecmd</span>
<span class="p_add">+   =&gt; scsi_dispatch_cmd</span>
<span class="p_add">+   =&gt; scsi_request_fn</span>
<span class="p_add">+   =&gt; __blk_run_queue_uncond</span>
<span class="p_add">+   =&gt; __blk_run_queue</span>
<span class="p_add">+   =&gt; blk_queue_bio</span>
<span class="p_add">+   =&gt; generic_make_request</span>
<span class="p_add">+   =&gt; submit_bio</span>
<span class="p_add">+   =&gt; submit_bh</span>
<span class="p_add">+   =&gt; ext3_bread</span>
<span class="p_add">+   =&gt; ext3_dir_bread</span>
<span class="p_add">+   =&gt; htree_dirblock_to_tree</span>
<span class="p_add">+   =&gt; ext3_htree_fill_tree</span>
<span class="p_add">+   =&gt; ext3_readdir</span>
<span class="p_add">+   =&gt; vfs_readdir</span>
<span class="p_add">+   =&gt; sys_getdents</span>
<span class="p_add">+   =&gt; system_call_fastpath</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+The trace_hardirqs_off_thunk is called from assembly on x86 when</span>
<span class="p_add">+interrupts are disabled in the assembly code. Without the</span>
<span class="p_add">+function tracing, we do not know if interrupts were enabled</span>
<span class="p_add">+within the preemption points. We do see that it started with</span>
<span class="p_add">+preemption enabled.</span>
<span class="p_add">+</span>
<span class="p_add">+Here is a trace with function-trace set::</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: preemptirqsoff</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # preemptirqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 161 us, #339/339, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: ls-2269 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #  =&gt; started at: schedule</span>
<span class="p_add">+  #  =&gt; ended at:   mutex_unlock</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+  kworker/-59      3...1    0us : __schedule &lt;-schedule</span>
<span class="p_add">+  kworker/-59      3d..1    0us : rcu_preempt_qs &lt;-rcu_note_context_switch</span>
<span class="p_add">+  kworker/-59      3d..1    1us : add_preempt_count &lt;-_raw_spin_lock_irq</span>
<span class="p_add">+  kworker/-59      3d..2    1us : deactivate_task &lt;-__schedule</span>
<span class="p_add">+  kworker/-59      3d..2    1us : dequeue_task &lt;-deactivate_task</span>
<span class="p_add">+  kworker/-59      3d..2    2us : update_rq_clock &lt;-dequeue_task</span>
<span class="p_add">+  kworker/-59      3d..2    2us : dequeue_task_fair &lt;-dequeue_task</span>
<span class="p_add">+  kworker/-59      3d..2    2us : update_curr &lt;-dequeue_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    2us : update_min_vruntime &lt;-update_curr</span>
<span class="p_add">+  kworker/-59      3d..2    3us : cpuacct_charge &lt;-update_curr</span>
<span class="p_add">+  kworker/-59      3d..2    3us : __rcu_read_lock &lt;-cpuacct_charge</span>
<span class="p_add">+  kworker/-59      3d..2    3us : __rcu_read_unlock &lt;-cpuacct_charge</span>
<span class="p_add">+  kworker/-59      3d..2    3us : update_cfs_rq_blocked_load &lt;-dequeue_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    4us : clear_buddies &lt;-dequeue_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    4us : account_entity_dequeue &lt;-dequeue_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    4us : update_min_vruntime &lt;-dequeue_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    4us : update_cfs_shares &lt;-dequeue_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    5us : hrtick_update &lt;-dequeue_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    5us : wq_worker_sleeping &lt;-__schedule</span>
<span class="p_add">+  kworker/-59      3d..2    5us : kthread_data &lt;-wq_worker_sleeping</span>
<span class="p_add">+  kworker/-59      3d..2    5us : put_prev_task_fair &lt;-__schedule</span>
<span class="p_add">+  kworker/-59      3d..2    6us : pick_next_task_fair &lt;-pick_next_task</span>
<span class="p_add">+  kworker/-59      3d..2    6us : clear_buddies &lt;-pick_next_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    6us : set_next_entity &lt;-pick_next_task_fair</span>
<span class="p_add">+  kworker/-59      3d..2    6us : update_stats_wait_end &lt;-set_next_entity</span>
<span class="p_add">+        ls-2269    3d..2    7us : finish_task_switch &lt;-__schedule</span>
<span class="p_add">+        ls-2269    3d..2    7us : _raw_spin_unlock_irq &lt;-finish_task_switch</span>
<span class="p_add">+        ls-2269    3d..2    8us : do_IRQ &lt;-ret_from_intr</span>
<span class="p_add">+        ls-2269    3d..2    8us : irq_enter &lt;-do_IRQ</span>
<span class="p_add">+        ls-2269    3d..2    8us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_add">+        ls-2269    3d..2    9us : add_preempt_count &lt;-irq_enter</span>
<span class="p_add">+        ls-2269    3d.h2    9us : exit_idle &lt;-do_IRQ</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+        ls-2269    3d.h3   20us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+        ls-2269    3d.h2   20us : irq_exit &lt;-do_IRQ</span>
<span class="p_add">+        ls-2269    3d.h2   21us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_add">+        ls-2269    3d..3   21us : do_softirq &lt;-irq_exit</span>
<span class="p_add">+        ls-2269    3d..3   21us : __do_softirq &lt;-call_softirq</span>
<span class="p_add">+        ls-2269    3d..3   21us+: __local_bh_disable &lt;-__do_softirq</span>
<span class="p_add">+        ls-2269    3d.s4   29us : sub_preempt_count &lt;-_local_bh_enable_ip</span>
<span class="p_add">+        ls-2269    3d.s5   29us : sub_preempt_count &lt;-_local_bh_enable_ip</span>
<span class="p_add">+        ls-2269    3d.s5   31us : do_IRQ &lt;-ret_from_intr</span>
<span class="p_add">+        ls-2269    3d.s5   31us : irq_enter &lt;-do_IRQ</span>
<span class="p_add">+        ls-2269    3d.s5   31us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+        ls-2269    3d.s5   31us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_add">+        ls-2269    3d.s5   32us : add_preempt_count &lt;-irq_enter</span>
<span class="p_add">+        ls-2269    3d.H5   32us : exit_idle &lt;-do_IRQ</span>
<span class="p_add">+        ls-2269    3d.H5   32us : handle_irq &lt;-do_IRQ</span>
<span class="p_add">+        ls-2269    3d.H5   32us : irq_to_desc &lt;-handle_irq</span>
<span class="p_add">+        ls-2269    3d.H5   33us : handle_fasteoi_irq &lt;-handle_irq</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+        ls-2269    3d.s5  158us : _raw_spin_unlock_irqrestore &lt;-rtl8139_poll</span>
<span class="p_add">+        ls-2269    3d.s3  158us : net_rps_action_and_irq_enable.isra.65 &lt;-net_rx_action</span>
<span class="p_add">+        ls-2269    3d.s3  159us : __local_bh_enable &lt;-__do_softirq</span>
<span class="p_add">+        ls-2269    3d.s3  159us : sub_preempt_count &lt;-__local_bh_enable</span>
<span class="p_add">+        ls-2269    3d..3  159us : idle_cpu &lt;-irq_exit</span>
<span class="p_add">+        ls-2269    3d..3  159us : rcu_irq_exit &lt;-irq_exit</span>
<span class="p_add">+        ls-2269    3d..3  160us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_add">+        ls-2269    3d...  161us : __mutex_unlock_slowpath &lt;-mutex_unlock</span>
<span class="p_add">+        ls-2269    3d...  162us+: trace_hardirqs_on &lt;-mutex_unlock</span>
<span class="p_add">+        ls-2269    3d...  186us : &lt;stack trace&gt;</span>
<span class="p_add">+   =&gt; __mutex_unlock_slowpath</span>
<span class="p_add">+   =&gt; mutex_unlock</span>
<span class="p_add">+   =&gt; process_output</span>
<span class="p_add">+   =&gt; n_tty_write</span>
<span class="p_add">+   =&gt; tty_write</span>
<span class="p_add">+   =&gt; vfs_write</span>
<span class="p_add">+   =&gt; sys_write</span>
<span class="p_add">+   =&gt; system_call_fastpath</span>
<span class="p_add">+</span>
<span class="p_add">+This is an interesting trace. It started with kworker running and</span>
<span class="p_add">+scheduling out and ls taking over. But as soon as ls released the</span>
<span class="p_add">+rq lock and enabled interrupts (but not preemption) an interrupt</span>
<span class="p_add">+triggered. When the interrupt finished, it started running softirqs.</span>
<span class="p_add">+But while the softirq was running, another interrupt triggered.</span>
<span class="p_add">+When an interrupt is running inside a softirq, the annotation is &#39;H&#39;.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+wakeup</span>
<span class="p_add">+------</span>
<span class="p_add">+</span>
<span class="p_add">+One common case that people are interested in tracing is the</span>
<span class="p_add">+time it takes for a task that is woken to actually wake up.</span>
<span class="p_add">+Now for non Real-Time tasks, this can be arbitrary. But tracing</span>
<span class="p_add">+it none the less can be interesting. </span>
<span class="p_add">+</span>
<span class="p_add">+Without function tracing::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 0 &gt; options/function-trace</span>
<span class="p_add">+  # echo wakeup &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # echo 0 &gt; tracing_max_latency</span>
<span class="p_add">+  # chrt -f 5 sleep 1</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: wakeup</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # wakeup latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 15 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: kworker/3:1H-312 (uid:0 nice:-20 policy:0 rt_prio:0)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+    &lt;idle&gt;-0       3dNs7    0us :      0:120:R   + [003]   312:100:R kworker/3:1H</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNs7    1us+: ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_add">+    &lt;idle&gt;-0       3d..3   15us : __schedule &lt;-schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3d..3   15us :      0:120:R ==&gt; [003]   312:100:R kworker/3:1H</span>
<span class="p_add">+</span>
<span class="p_add">+The tracer only traces the highest priority task in the system</span>
<span class="p_add">+to avoid tracing the normal circumstances. Here we see that</span>
<span class="p_add">+the kworker with a nice priority of -20 (not very nice), took</span>
<span class="p_add">+just 15 microseconds from the time it woke up, to the time it</span>
<span class="p_add">+ran.</span>
<span class="p_add">+</span>
<span class="p_add">+Non Real-Time tasks are not that interesting. A more interesting</span>
<span class="p_add">+trace is to concentrate only on Real-Time tasks.</span>
<span class="p_add">+</span>
<span class="p_add">+wakeup_rt</span>
<span class="p_add">+---------</span>
<span class="p_add">+</span>
<span class="p_add">+In a Real-Time environment it is very important to know the</span>
<span class="p_add">+wakeup time it takes for the highest priority task that is woken</span>
<span class="p_add">+up to the time that it executes. This is also known as &quot;schedule</span>
<span class="p_add">+latency&quot;. I stress the point that this is about RT tasks. It is</span>
<span class="p_add">+also important to know the scheduling latency of non-RT tasks,</span>
<span class="p_add">+but the average schedule latency is better for non-RT tasks.</span>
<span class="p_add">+Tools like LatencyTop are more appropriate for such</span>
<span class="p_add">+measurements.</span>
<span class="p_add">+</span>
<span class="p_add">+Real-Time environments are interested in the worst case latency.</span>
<span class="p_add">+That is the longest latency it takes for something to happen,</span>
<span class="p_add">+and not the average. We can have a very fast scheduler that may</span>
<span class="p_add">+only have a large latency once in a while, but that would not</span>
<span class="p_add">+work well with Real-Time tasks.  The wakeup_rt tracer was designed</span>
<span class="p_add">+to record the worst case wakeups of RT tasks. Non-RT tasks are</span>
<span class="p_add">+not recorded because the tracer only records one worst case and</span>
<span class="p_add">+tracing non-RT tasks that are unpredictable will overwrite the</span>
<span class="p_add">+worst case latency of RT tasks (just run the normal wakeup</span>
<span class="p_add">+tracer for a while to see that effect).</span>
<span class="p_add">+</span>
<span class="p_add">+Since this tracer only deals with RT tasks, we will run this</span>
<span class="p_add">+slightly differently than we did with the previous tracers.</span>
<span class="p_add">+Instead of performing an &#39;ls&#39;, we will run &#39;sleep 1&#39; under</span>
<span class="p_add">+&#39;chrt&#39; which changes the priority of the task.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 0 &gt; options/function-trace</span>
<span class="p_add">+  # echo wakeup_rt &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # echo 0 &gt; tracing_max_latency</span>
<span class="p_add">+  # chrt -f 5 sleep 1</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: wakeup</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # tracer: wakeup_rt</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 5 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: sleep-2389 (uid:0 nice:0 policy:1 rt_prio:5)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+    &lt;idle&gt;-0       3d.h4    0us :      0:120:R   + [003]  2389: 94:R sleep</span>
<span class="p_add">+    &lt;idle&gt;-0       3d.h4    1us+: ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_add">+    &lt;idle&gt;-0       3d..3    5us : __schedule &lt;-schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3d..3    5us :      0:120:R ==&gt; [003]  2389: 94:R sleep</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Running this on an idle system, we see that it only took 5 microseconds</span>
<span class="p_add">+to perform the task switch.  Note, since the trace point in the schedule</span>
<span class="p_add">+is before the actual &quot;switch&quot;, we stop the tracing when the recorded task</span>
<span class="p_add">+is about to schedule in. This may change if we add a new marker at the</span>
<span class="p_add">+end of the scheduler.</span>
<span class="p_add">+</span>
<span class="p_add">+Notice that the recorded task is &#39;sleep&#39; with the PID of 2389</span>
<span class="p_add">+and it has an rt_prio of 5. This priority is user-space priority</span>
<span class="p_add">+and not the internal kernel priority. The policy is 1 for</span>
<span class="p_add">+SCHED_FIFO and 2 for SCHED_RR.</span>
<span class="p_add">+</span>
<span class="p_add">+Note, that the trace data shows the internal priority (99 - rtprio).</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  &lt;idle&gt;-0       3d..3    5us :      0:120:R ==&gt; [003]  2389: 94:R sleep</span>
<span class="p_add">+</span>
<span class="p_add">+The 0:120:R means idle was running with a nice priority of 0 (120 - 120)</span>
<span class="p_add">+and in the running state &#39;R&#39;. The sleep task was scheduled in with</span>
<span class="p_add">+2389: 94:R. That is the priority is the kernel rtprio (99 - 5 = 94)</span>
<span class="p_add">+and it too is in the running state.</span>
<span class="p_add">+</span>
<span class="p_add">+Doing the same with chrt -r 5 and function-trace set.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  echo 1 &gt; options/function-trace</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: wakeup_rt</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 29 us, #85/85, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: sleep-2448 (uid:0 nice:0 policy:1 rt_prio:5)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+    &lt;idle&gt;-0       3d.h4    1us+:      0:120:R   + [003]  2448: 94:R sleep</span>
<span class="p_add">+    &lt;idle&gt;-0       3d.h4    2us : ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_add">+    &lt;idle&gt;-0       3d.h3    3us : check_preempt_curr &lt;-ttwu_do_wakeup</span>
<span class="p_add">+    &lt;idle&gt;-0       3d.h3    3us : resched_curr &lt;-check_preempt_curr</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh3    4us : task_woken_rt &lt;-ttwu_do_wakeup</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh3    4us : _raw_spin_unlock &lt;-try_to_wake_up</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh3    4us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh2    5us : ttwu_stat &lt;-try_to_wake_up</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh2    5us : _raw_spin_unlock_irqrestore &lt;-try_to_wake_up</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh2    6us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    6us : _raw_spin_lock &lt;-__run_hrtimer</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    6us : add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh2    7us : _raw_spin_unlock &lt;-hrtimer_interrupt</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh2    7us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    7us : tick_program_event &lt;-hrtimer_interrupt</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    7us : clockevents_program_event &lt;-tick_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    8us : ktime_get &lt;-clockevents_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    8us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    8us : irq_exit &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+    &lt;idle&gt;-0       3dNh1    9us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2    9us : idle_cpu &lt;-irq_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2    9us : rcu_irq_exit &lt;-irq_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   10us : rcu_eqs_enter_common.isra.45 &lt;-rcu_irq_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   10us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N.1   11us : rcu_idle_exit &lt;-cpu_idle</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   11us : rcu_eqs_exit_common.isra.43 &lt;-rcu_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N.1   11us : tick_nohz_idle_exit &lt;-cpu_idle</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   12us : menu_hrtimer_cancel &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   12us : ktime_get &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   12us : tick_do_update_jiffies64 &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   13us : cpu_load_update_nohz &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   13us : _raw_spin_lock &lt;-cpu_load_update_nohz</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   13us : add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   13us : __cpu_load_update &lt;-cpu_load_update_nohz</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   14us : sched_avg_update &lt;-__cpu_load_update</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   14us : _raw_spin_unlock &lt;-cpu_load_update_nohz</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   14us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   15us : calc_load_nohz_stop &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   15us : touch_softlockup_watchdog &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   15us : hrtimer_cancel &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   15us : hrtimer_try_to_cancel &lt;-hrtimer_cancel</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   16us : lock_hrtimer_base.isra.18 &lt;-hrtimer_try_to_cancel</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   16us : _raw_spin_lock_irqsave &lt;-lock_hrtimer_base.isra.18</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   16us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   17us : __remove_hrtimer &lt;-remove_hrtimer.part.16</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   17us : hrtimer_force_reprogram &lt;-__remove_hrtimer</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   17us : tick_program_event &lt;-hrtimer_force_reprogram</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   18us : clockevents_program_event &lt;-tick_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   18us : ktime_get &lt;-clockevents_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   18us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   19us : _raw_spin_unlock_irqrestore &lt;-hrtimer_try_to_cancel</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   19us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   19us : hrtimer_forward &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   20us : ktime_add_safe &lt;-hrtimer_forward</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   20us : ktime_add_safe &lt;-hrtimer_forward</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   20us : hrtimer_start_range_ns &lt;-hrtimer_start_expires.constprop.11</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   20us : __hrtimer_start_range_ns &lt;-hrtimer_start_range_ns</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   21us : lock_hrtimer_base.isra.18 &lt;-__hrtimer_start_range_ns</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   21us : _raw_spin_lock_irqsave &lt;-lock_hrtimer_base.isra.18</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   21us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   22us : ktime_add_safe &lt;-__hrtimer_start_range_ns</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   22us : enqueue_hrtimer &lt;-__hrtimer_start_range_ns</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   22us : tick_program_event &lt;-__hrtimer_start_range_ns</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   23us : clockevents_program_event &lt;-tick_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   23us : ktime_get &lt;-clockevents_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   23us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   24us : _raw_spin_unlock_irqrestore &lt;-__hrtimer_start_range_ns</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   24us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   24us : account_idle_ticks &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   24us : account_idle_time &lt;-account_idle_ticks</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N.1   25us : sub_preempt_count &lt;-cpu_idle</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N..   25us : schedule &lt;-cpu_idle</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N..   25us : __schedule &lt;-preempt_schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N..   26us : add_preempt_count &lt;-__schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N.1   26us : rcu_note_context_switch &lt;-__schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N.1   26us : rcu_sched_qs &lt;-rcu_note_context_switch</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   27us : rcu_preempt_qs &lt;-rcu_note_context_switch</span>
<span class="p_add">+    &lt;idle&gt;-0       3.N.1   27us : _raw_spin_lock_irq &lt;-__schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.1   27us : add_preempt_count &lt;-_raw_spin_lock_irq</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   28us : put_prev_task_idle &lt;-__schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   28us : pick_next_task_stop &lt;-pick_next_task</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   28us : pick_next_task_rt &lt;-pick_next_task</span>
<span class="p_add">+    &lt;idle&gt;-0       3dN.2   29us : dequeue_pushable_task &lt;-pick_next_task_rt</span>
<span class="p_add">+    &lt;idle&gt;-0       3d..3   29us : __schedule &lt;-preempt_schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       3d..3   30us :      0:120:R ==&gt; [003]  2448: 94:R sleep</span>
<span class="p_add">+</span>
<span class="p_add">+This isn&#39;t that big of a trace, even with function tracing enabled,</span>
<span class="p_add">+so I included the entire trace.</span>
<span class="p_add">+</span>
<span class="p_add">+The interrupt went off while when the system was idle. Somewhere</span>
<span class="p_add">+before task_woken_rt() was called, the NEED_RESCHED flag was set,</span>
<span class="p_add">+this is indicated by the first occurrence of the &#39;N&#39; flag.</span>
<span class="p_add">+</span>
<span class="p_add">+Latency tracing and events</span>
<span class="p_add">+--------------------------</span>
<span class="p_add">+As function tracing can induce a much larger latency, but without</span>
<span class="p_add">+seeing what happens within the latency it is hard to know what</span>
<span class="p_add">+caused it. There is a middle ground, and that is with enabling</span>
<span class="p_add">+events.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 0 &gt; options/function-trace</span>
<span class="p_add">+  # echo wakeup_rt &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; events/enable</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # echo 0 &gt; tracing_max_latency</span>
<span class="p_add">+  # chrt -f 5 sleep 1</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: wakeup_rt</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_add">+  # --------------------------------------------------------------------</span>
<span class="p_add">+  # latency: 6 us, #12/12, CPU#2 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #    | task: sleep-5882 (uid:0 nice:0 policy:1 rt_prio:5)</span>
<span class="p_add">+  #    -----------------</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                  _------=&gt; CPU#            </span>
<span class="p_add">+  #                 / _-----=&gt; irqs-off        </span>
<span class="p_add">+  #                | / _----=&gt; need-resched    </span>
<span class="p_add">+  #                || / _---=&gt; hardirq/softirq </span>
<span class="p_add">+  #                ||| / _--=&gt; preempt-depth   </span>
<span class="p_add">+  #                |||| /     delay             </span>
<span class="p_add">+  #  cmd     pid   ||||| time  |   caller      </span>
<span class="p_add">+  #     \   /      |||||  \    |   /           </span>
<span class="p_add">+    &lt;idle&gt;-0       2d.h4    0us :      0:120:R   + [002]  5882: 94:R sleep</span>
<span class="p_add">+    &lt;idle&gt;-0       2d.h4    0us : ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_add">+    &lt;idle&gt;-0       2d.h4    1us : sched_wakeup: comm=sleep pid=5882 prio=94 success=1 target_cpu=002</span>
<span class="p_add">+    &lt;idle&gt;-0       2dNh2    1us : hrtimer_expire_exit: hrtimer=ffff88007796feb8</span>
<span class="p_add">+    &lt;idle&gt;-0       2.N.2    2us : power_end: cpu_id=2</span>
<span class="p_add">+    &lt;idle&gt;-0       2.N.2    3us : cpu_idle: state=4294967295 cpu_id=2</span>
<span class="p_add">+    &lt;idle&gt;-0       2dN.3    4us : hrtimer_cancel: hrtimer=ffff88007d50d5e0</span>
<span class="p_add">+    &lt;idle&gt;-0       2dN.3    4us : hrtimer_start: hrtimer=ffff88007d50d5e0 function=tick_sched_timer expires=34311211000000 softexpires=34311211000000</span>
<span class="p_add">+    &lt;idle&gt;-0       2.N.2    5us : rcu_utilization: Start context switch</span>
<span class="p_add">+    &lt;idle&gt;-0       2.N.2    5us : rcu_utilization: End context switch</span>
<span class="p_add">+    &lt;idle&gt;-0       2d..3    6us : __schedule &lt;-schedule</span>
<span class="p_add">+    &lt;idle&gt;-0       2d..3    6us :      0:120:R ==&gt; [002]  5882: 94:R sleep</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Hardware Latency Detector</span>
<span class="p_add">+-------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+The hardware latency detector is executed by enabling the &quot;hwlat&quot; tracer.</span>
<span class="p_add">+</span>
<span class="p_add">+NOTE, this tracer will affect the performance of the system as it will</span>
<span class="p_add">+periodically make a CPU constantly busy with interrupts disabled.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo hwlat &gt; current_tracer</span>
<span class="p_add">+  # sleep 100</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: hwlat</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+             &lt;...&gt;-3638  [001] d... 19452.055471: #1     inner/outer(us):   12/14    ts:1499801089.066141940</span>
<span class="p_add">+             &lt;...&gt;-3638  [003] d... 19454.071354: #2     inner/outer(us):   11/9     ts:1499801091.082164365</span>
<span class="p_add">+             &lt;...&gt;-3638  [002] dn.. 19461.126852: #3     inner/outer(us):   12/9     ts:1499801098.138150062</span>
<span class="p_add">+             &lt;...&gt;-3638  [001] d... 19488.340960: #4     inner/outer(us):    8/12    ts:1499801125.354139633</span>
<span class="p_add">+             &lt;...&gt;-3638  [003] d... 19494.388553: #5     inner/outer(us):    8/12    ts:1499801131.402150961</span>
<span class="p_add">+             &lt;...&gt;-3638  [003] d... 19501.283419: #6     inner/outer(us):    0/12    ts:1499801138.297435289 nmi-total:4 nmi-count:1</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+The above output is somewhat the same in the header. All events will have</span>
<span class="p_add">+interrupts disabled &#39;d&#39;. Under the FUNCTION title there is:</span>
<span class="p_add">+</span>
<span class="p_add">+ #1</span>
<span class="p_add">+	This is the count of events recorded that were greater than the</span>
<span class="p_add">+	tracing_threshold (See below).</span>
<span class="p_add">+</span>
<span class="p_add">+ inner/outer(us):   12/14</span>
<span class="p_add">+</span>
<span class="p_add">+      This shows two numbers as &quot;inner latency&quot; and &quot;outer latency&quot;. The test</span>
<span class="p_add">+      runs in a loop checking a timestamp twice. The latency detected within</span>
<span class="p_add">+      the two timestamps is the &quot;inner latency&quot; and the latency detected</span>
<span class="p_add">+      after the previous timestamp and the next timestamp in the loop is</span>
<span class="p_add">+      the &quot;outer latency&quot;.</span>
<span class="p_add">+</span>
<span class="p_add">+ ts:1499801089.066141940</span>
<span class="p_add">+</span>
<span class="p_add">+      The absolute timestamp that the event happened.</span>
<span class="p_add">+</span>
<span class="p_add">+ nmi-total:4 nmi-count:1</span>
<span class="p_add">+</span>
<span class="p_add">+      On architectures that support it, if an NMI comes in during the</span>
<span class="p_add">+      test, the time spent in NMI is reported in &quot;nmi-total&quot; (in</span>
<span class="p_add">+      microseconds).</span>
<span class="p_add">+</span>
<span class="p_add">+      All architectures that have NMIs will show the &quot;nmi-count&quot; if an</span>
<span class="p_add">+      NMI comes in during the test.</span>
<span class="p_add">+</span>
<span class="p_add">+hwlat files:</span>
<span class="p_add">+</span>
<span class="p_add">+  tracing_threshold</span>
<span class="p_add">+	This gets automatically set to &quot;10&quot; to represent 10</span>
<span class="p_add">+	microseconds. This is the threshold of latency that</span>
<span class="p_add">+	needs to be detected before the trace will be recorded.</span>
<span class="p_add">+</span>
<span class="p_add">+	Note, when hwlat tracer is finished (another tracer is</span>
<span class="p_add">+	written into &quot;current_tracer&quot;), the original value for</span>
<span class="p_add">+	tracing_threshold is placed back into this file.</span>
<span class="p_add">+</span>
<span class="p_add">+  hwlat_detector/width</span>
<span class="p_add">+	The length of time the test runs with interrupts disabled.</span>
<span class="p_add">+</span>
<span class="p_add">+  hwlat_detector/window</span>
<span class="p_add">+	The length of time of the window which the test</span>
<span class="p_add">+	runs. That is, the test will run for &quot;width&quot;</span>
<span class="p_add">+	microseconds per &quot;window&quot; microseconds</span>
<span class="p_add">+</span>
<span class="p_add">+  tracing_cpumask</span>
<span class="p_add">+	When the test is started. A kernel thread is created that</span>
<span class="p_add">+	runs the test. This thread will alternate between CPUs</span>
<span class="p_add">+	listed in the tracing_cpumask between each period</span>
<span class="p_add">+	(one &quot;window&quot;). To limit the test to specific CPUs</span>
<span class="p_add">+	set the mask in this file to only the CPUs that the test</span>
<span class="p_add">+	should run on.</span>
<span class="p_add">+</span>
<span class="p_add">+function</span>
<span class="p_add">+--------</span>
<span class="p_add">+</span>
<span class="p_add">+This tracer is the function tracer. Enabling the function tracer</span>
<span class="p_add">+can be done from the debug file system. Make sure the</span>
<span class="p_add">+ftrace_enabled is set; otherwise this tracer is a nop.</span>
<span class="p_add">+See the &quot;ftrace_enabled&quot; section below.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # sysctl kernel.ftrace_enabled=1</span>
<span class="p_add">+  # echo function &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # usleep 1</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 24799/24799   #P:4</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+              bash-1994  [002] ....  3082.063030: mutex_unlock &lt;-rb_simple_write</span>
<span class="p_add">+              bash-1994  [002] ....  3082.063031: __mutex_unlock_slowpath &lt;-mutex_unlock</span>
<span class="p_add">+              bash-1994  [002] ....  3082.063031: __fsnotify_parent &lt;-fsnotify_modify</span>
<span class="p_add">+              bash-1994  [002] ....  3082.063032: fsnotify &lt;-fsnotify_modify</span>
<span class="p_add">+              bash-1994  [002] ....  3082.063032: __srcu_read_lock &lt;-fsnotify</span>
<span class="p_add">+              bash-1994  [002] ....  3082.063032: add_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_add">+              bash-1994  [002] ...1  3082.063032: sub_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_add">+              bash-1994  [002] ....  3082.063033: __srcu_read_unlock &lt;-fsnotify</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Note: function tracer uses ring buffers to store the above</span>
<span class="p_add">+entries. The newest data may overwrite the oldest data.</span>
<span class="p_add">+Sometimes using echo to stop the trace is not sufficient because</span>
<span class="p_add">+the tracing could have overwritten the data that you wanted to</span>
<span class="p_add">+record. For this reason, it is sometimes better to disable</span>
<span class="p_add">+tracing directly from a program. This allows you to stop the</span>
<span class="p_add">+tracing at the point that you hit the part that you are</span>
<span class="p_add">+interested in. To disable the tracing directly from a C program,</span>
<span class="p_add">+something like following code snippet can be used::</span>
<span class="p_add">+</span>
<span class="p_add">+	int trace_fd;</span>
<span class="p_add">+	[...]</span>
<span class="p_add">+	int main(int argc, char *argv[]) {</span>
<span class="p_add">+		[...]</span>
<span class="p_add">+		trace_fd = open(tracing_file(&quot;tracing_on&quot;), O_WRONLY);</span>
<span class="p_add">+		[...]</span>
<span class="p_add">+		if (condition_hit()) {</span>
<span class="p_add">+			write(trace_fd, &quot;0&quot;, 1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		[...]</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Single thread tracing</span>
<span class="p_add">+---------------------</span>
<span class="p_add">+</span>
<span class="p_add">+By writing into set_ftrace_pid you can trace a</span>
<span class="p_add">+single thread. For example::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat set_ftrace_pid</span>
<span class="p_add">+  no pid</span>
<span class="p_add">+  # echo 3111 &gt; set_ftrace_pid</span>
<span class="p_add">+  # cat set_ftrace_pid</span>
<span class="p_add">+  3111</span>
<span class="p_add">+  # echo function &gt; current_tracer</span>
<span class="p_add">+  # cat trace | head</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |          |         |</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1637.254676: finish_task_switch &lt;-thread_return</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1637.254681: hrtimer_cancel &lt;-schedule_hrtimeout_range</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1637.254682: hrtimer_try_to_cancel &lt;-hrtimer_cancel</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1637.254683: lock_hrtimer_base &lt;-hrtimer_try_to_cancel</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1637.254685: fget_light &lt;-do_sys_poll</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1637.254686: pipe_poll &lt;-do_sys_poll</span>
<span class="p_add">+  # echo &gt; set_ftrace_pid</span>
<span class="p_add">+  # cat trace |head</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |          |         |</span>
<span class="p_add">+  ##### CPU 3 buffer started ####</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1701.957688: free_poll_entry &lt;-poll_freewait</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1701.957689: remove_wait_queue &lt;-free_poll_entry</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1701.957691: fput &lt;-free_poll_entry</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1701.957692: audit_syscall_exit &lt;-sysret_audit</span>
<span class="p_add">+      yum-updatesd-3111  [003]  1701.957693: path_put &lt;-audit_syscall_exit</span>
<span class="p_add">+</span>
<span class="p_add">+If you want to trace a function when executing, you could use</span>
<span class="p_add">+something like this simple program.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+	#include &lt;stdio.h&gt;</span>
<span class="p_add">+	#include &lt;stdlib.h&gt;</span>
<span class="p_add">+	#include &lt;sys/types.h&gt;</span>
<span class="p_add">+	#include &lt;sys/stat.h&gt;</span>
<span class="p_add">+	#include &lt;fcntl.h&gt;</span>
<span class="p_add">+	#include &lt;unistd.h&gt;</span>
<span class="p_add">+	#include &lt;string.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	#define _STR(x) #x</span>
<span class="p_add">+	#define STR(x) _STR(x)</span>
<span class="p_add">+	#define MAX_PATH 256</span>
<span class="p_add">+</span>
<span class="p_add">+	const char *find_tracefs(void)</span>
<span class="p_add">+	{</span>
<span class="p_add">+	       static char tracefs[MAX_PATH+1];</span>
<span class="p_add">+	       static int tracefs_found;</span>
<span class="p_add">+	       char type[100];</span>
<span class="p_add">+	       FILE *fp;</span>
<span class="p_add">+</span>
<span class="p_add">+	       if (tracefs_found)</span>
<span class="p_add">+		       return tracefs;</span>
<span class="p_add">+</span>
<span class="p_add">+	       if ((fp = fopen(&quot;/proc/mounts&quot;,&quot;r&quot;)) == NULL) {</span>
<span class="p_add">+		       perror(&quot;/proc/mounts&quot;);</span>
<span class="p_add">+		       return NULL;</span>
<span class="p_add">+	       }</span>
<span class="p_add">+</span>
<span class="p_add">+	       while (fscanf(fp, &quot;%*s %&quot;</span>
<span class="p_add">+		             STR(MAX_PATH)</span>
<span class="p_add">+		             &quot;s %99s %*s %*d %*d\n&quot;,</span>
<span class="p_add">+		             tracefs, type) == 2) {</span>
<span class="p_add">+		       if (strcmp(type, &quot;tracefs&quot;) == 0)</span>
<span class="p_add">+		               break;</span>
<span class="p_add">+	       }</span>
<span class="p_add">+	       fclose(fp);</span>
<span class="p_add">+</span>
<span class="p_add">+	       if (strcmp(type, &quot;tracefs&quot;) != 0) {</span>
<span class="p_add">+		       fprintf(stderr, &quot;tracefs not mounted&quot;);</span>
<span class="p_add">+		       return NULL;</span>
<span class="p_add">+	       }</span>
<span class="p_add">+</span>
<span class="p_add">+	       strcat(tracefs, &quot;/tracing/&quot;);</span>
<span class="p_add">+	       tracefs_found = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	       return tracefs;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	const char *tracing_file(const char *file_name)</span>
<span class="p_add">+	{</span>
<span class="p_add">+	       static char trace_file[MAX_PATH+1];</span>
<span class="p_add">+	       snprintf(trace_file, MAX_PATH, &quot;%s/%s&quot;, find_tracefs(), file_name);</span>
<span class="p_add">+	       return trace_file;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	int main (int argc, char **argv)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		if (argc &lt; 1)</span>
<span class="p_add">+		        exit(-1);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (fork() &gt; 0) {</span>
<span class="p_add">+		        int fd, ffd;</span>
<span class="p_add">+		        char line[64];</span>
<span class="p_add">+		        int s;</span>
<span class="p_add">+</span>
<span class="p_add">+		        ffd = open(tracing_file(&quot;current_tracer&quot;), O_WRONLY);</span>
<span class="p_add">+		        if (ffd &lt; 0)</span>
<span class="p_add">+		                exit(-1);</span>
<span class="p_add">+		        write(ffd, &quot;nop&quot;, 3);</span>
<span class="p_add">+</span>
<span class="p_add">+		        fd = open(tracing_file(&quot;set_ftrace_pid&quot;), O_WRONLY);</span>
<span class="p_add">+		        s = sprintf(line, &quot;%d\n&quot;, getpid());</span>
<span class="p_add">+		        write(fd, line, s);</span>
<span class="p_add">+</span>
<span class="p_add">+		        write(ffd, &quot;function&quot;, 8);</span>
<span class="p_add">+</span>
<span class="p_add">+		        close(fd);</span>
<span class="p_add">+		        close(ffd);</span>
<span class="p_add">+</span>
<span class="p_add">+		        execvp(argv[1], argv+1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+Or this simple script!</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  #!/bin/bash</span>
<span class="p_add">+</span>
<span class="p_add">+  tracefs=`sed -ne &#39;s/^tracefs \(.*\) tracefs.*/\1/p&#39; /proc/mounts`</span>
<span class="p_add">+  echo nop &gt; $tracefs/tracing/current_tracer</span>
<span class="p_add">+  echo 0 &gt; $tracefs/tracing/tracing_on</span>
<span class="p_add">+  echo $$ &gt; $tracefs/tracing/set_ftrace_pid</span>
<span class="p_add">+  echo function &gt; $tracefs/tracing/current_tracer</span>
<span class="p_add">+  echo 1 &gt; $tracefs/tracing/tracing_on</span>
<span class="p_add">+  exec &quot;$@&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+function graph tracer</span>
<span class="p_add">+---------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+This tracer is similar to the function tracer except that it</span>
<span class="p_add">+probes a function on its entry and its exit. This is done by</span>
<span class="p_add">+using a dynamically allocated stack of return addresses in each</span>
<span class="p_add">+task_struct. On function entry the tracer overwrites the return</span>
<span class="p_add">+address of each function traced to set a custom probe. Thus the</span>
<span class="p_add">+original return address is stored on the stack of return address</span>
<span class="p_add">+in the task_struct.</span>
<span class="p_add">+</span>
<span class="p_add">+Probing on both ends of a function leads to special features</span>
<span class="p_add">+such as:</span>
<span class="p_add">+</span>
<span class="p_add">+- measure of a function&#39;s time execution</span>
<span class="p_add">+- having a reliable call stack to draw function calls graph</span>
<span class="p_add">+</span>
<span class="p_add">+This tracer is useful in several situations:</span>
<span class="p_add">+</span>
<span class="p_add">+- you want to find the reason of a strange kernel behavior and</span>
<span class="p_add">+  need to see what happens in detail on any areas (or specific</span>
<span class="p_add">+  ones).</span>
<span class="p_add">+</span>
<span class="p_add">+- you are experiencing weird latencies but it&#39;s difficult to</span>
<span class="p_add">+  find its origin.</span>
<span class="p_add">+</span>
<span class="p_add">+- you want to find quickly which path is taken by a specific</span>
<span class="p_add">+  function</span>
<span class="p_add">+</span>
<span class="p_add">+- you just want to peek inside a working kernel and want to see</span>
<span class="p_add">+  what happens there.</span>
<span class="p_add">+</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: function_graph</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # CPU  DURATION                  FUNCTION CALLS</span>
<span class="p_add">+  # |     |   |                     |   |   |   |</span>
<span class="p_add">+</span>
<span class="p_add">+   0)               |  sys_open() {</span>
<span class="p_add">+   0)               |    do_sys_open() {</span>
<span class="p_add">+   0)               |      getname() {</span>
<span class="p_add">+   0)               |        kmem_cache_alloc() {</span>
<span class="p_add">+   0)   1.382 us    |          __might_sleep();</span>
<span class="p_add">+   0)   2.478 us    |        }</span>
<span class="p_add">+   0)               |        strncpy_from_user() {</span>
<span class="p_add">+   0)               |          might_fault() {</span>
<span class="p_add">+   0)   1.389 us    |            __might_sleep();</span>
<span class="p_add">+   0)   2.553 us    |          }</span>
<span class="p_add">+   0)   3.807 us    |        }</span>
<span class="p_add">+   0)   7.876 us    |      }</span>
<span class="p_add">+   0)               |      alloc_fd() {</span>
<span class="p_add">+   0)   0.668 us    |        _spin_lock();</span>
<span class="p_add">+   0)   0.570 us    |        expand_files();</span>
<span class="p_add">+   0)   0.586 us    |        _spin_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+There are several columns that can be dynamically</span>
<span class="p_add">+enabled/disabled. You can use every combination of options you</span>
<span class="p_add">+want, depending on your needs.</span>
<span class="p_add">+</span>
<span class="p_add">+- The cpu number on which the function executed is default</span>
<span class="p_add">+  enabled.  It is sometimes better to only trace one cpu (see</span>
<span class="p_add">+  tracing_cpu_mask file) or you might sometimes see unordered</span>
<span class="p_add">+  function calls while cpu tracing switch.</span>
<span class="p_add">+</span>
<span class="p_add">+	- hide: echo nofuncgraph-cpu &gt; trace_options</span>
<span class="p_add">+	- show: echo funcgraph-cpu &gt; trace_options</span>
<span class="p_add">+</span>
<span class="p_add">+- The duration (function&#39;s time of execution) is displayed on</span>
<span class="p_add">+  the closing bracket line of a function or on the same line</span>
<span class="p_add">+  than the current function in case of a leaf one. It is default</span>
<span class="p_add">+  enabled.</span>
<span class="p_add">+</span>
<span class="p_add">+	- hide: echo nofuncgraph-duration &gt; trace_options</span>
<span class="p_add">+	- show: echo funcgraph-duration &gt; trace_options</span>
<span class="p_add">+</span>
<span class="p_add">+- The overhead field precedes the duration field in case of</span>
<span class="p_add">+  reached duration thresholds.</span>
<span class="p_add">+</span>
<span class="p_add">+	- hide: echo nofuncgraph-overhead &gt; trace_options</span>
<span class="p_add">+	- show: echo funcgraph-overhead &gt; trace_options</span>
<span class="p_add">+	- depends on: funcgraph-duration</span>
<span class="p_add">+</span>
<span class="p_add">+  ie::</span>
<span class="p_add">+</span>
<span class="p_add">+    3) # 1837.709 us |          } /* __switch_to */</span>
<span class="p_add">+    3)               |          finish_task_switch() {</span>
<span class="p_add">+    3)   0.313 us    |            _raw_spin_unlock_irq();</span>
<span class="p_add">+    3)   3.177 us    |          }</span>
<span class="p_add">+    3) # 1889.063 us |        } /* __schedule */</span>
<span class="p_add">+    3) ! 140.417 us  |      } /* __schedule */</span>
<span class="p_add">+    3) # 2034.948 us |    } /* schedule */</span>
<span class="p_add">+    3) * 33998.59 us |  } /* schedule_preempt_disabled */</span>
<span class="p_add">+</span>
<span class="p_add">+    [...]</span>
<span class="p_add">+</span>
<span class="p_add">+    1)   0.260 us    |              msecs_to_jiffies();</span>
<span class="p_add">+    1)   0.313 us    |              __rcu_read_unlock();</span>
<span class="p_add">+    1) + 61.770 us   |            }</span>
<span class="p_add">+    1) + 64.479 us   |          }</span>
<span class="p_add">+    1)   0.313 us    |          rcu_bh_qs();</span>
<span class="p_add">+    1)   0.313 us    |          __local_bh_enable();</span>
<span class="p_add">+    1) ! 217.240 us  |        }</span>
<span class="p_add">+    1)   0.365 us    |        idle_cpu();</span>
<span class="p_add">+    1)               |        rcu_irq_exit() {</span>
<span class="p_add">+    1)   0.417 us    |          rcu_eqs_enter_common.isra.47();</span>
<span class="p_add">+    1)   3.125 us    |        }</span>
<span class="p_add">+    1) ! 227.812 us  |      }</span>
<span class="p_add">+    1) ! 457.395 us  |    }</span>
<span class="p_add">+    1) @ 119760.2 us |  }</span>
<span class="p_add">+</span>
<span class="p_add">+    [...]</span>
<span class="p_add">+</span>
<span class="p_add">+    2)               |    handle_IPI() {</span>
<span class="p_add">+    1)   6.979 us    |                  }</span>
<span class="p_add">+    2)   0.417 us    |      scheduler_ipi();</span>
<span class="p_add">+    1)   9.791 us    |                }</span>
<span class="p_add">+    1) + 12.917 us   |              }</span>
<span class="p_add">+    2)   3.490 us    |    }</span>
<span class="p_add">+    1) + 15.729 us   |            }</span>
<span class="p_add">+    1) + 18.542 us   |          }</span>
<span class="p_add">+    2) $ 3594274 us  |  }</span>
<span class="p_add">+</span>
<span class="p_add">+Flags::</span>
<span class="p_add">+</span>
<span class="p_add">+  + means that the function exceeded 10 usecs.</span>
<span class="p_add">+  ! means that the function exceeded 100 usecs.</span>
<span class="p_add">+  # means that the function exceeded 1000 usecs.</span>
<span class="p_add">+  * means that the function exceeded 10 msecs.</span>
<span class="p_add">+  @ means that the function exceeded 100 msecs.</span>
<span class="p_add">+  $ means that the function exceeded 1 sec.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+- The task/pid field displays the thread cmdline and pid which</span>
<span class="p_add">+  executed the function. It is default disabled.</span>
<span class="p_add">+</span>
<span class="p_add">+	- hide: echo nofuncgraph-proc &gt; trace_options</span>
<span class="p_add">+	- show: echo funcgraph-proc &gt; trace_options</span>
<span class="p_add">+</span>
<span class="p_add">+  ie::</span>
<span class="p_add">+</span>
<span class="p_add">+    # tracer: function_graph</span>
<span class="p_add">+    #</span>
<span class="p_add">+    # CPU  TASK/PID        DURATION                  FUNCTION CALLS</span>
<span class="p_add">+    # |    |    |           |   |                     |   |   |   |</span>
<span class="p_add">+    0)    sh-4802     |               |                  d_free() {</span>
<span class="p_add">+    0)    sh-4802     |               |                    call_rcu() {</span>
<span class="p_add">+    0)    sh-4802     |               |                      __call_rcu() {</span>
<span class="p_add">+    0)    sh-4802     |   0.616 us    |                        rcu_process_gp_end();</span>
<span class="p_add">+    0)    sh-4802     |   0.586 us    |                        check_for_new_grace_period();</span>
<span class="p_add">+    0)    sh-4802     |   2.899 us    |                      }</span>
<span class="p_add">+    0)    sh-4802     |   4.040 us    |                    }</span>
<span class="p_add">+    0)    sh-4802     |   5.151 us    |                  }</span>
<span class="p_add">+    0)    sh-4802     | + 49.370 us   |                }</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+- The absolute time field is an absolute timestamp given by the</span>
<span class="p_add">+  system clock since it started. A snapshot of this time is</span>
<span class="p_add">+  given on each entry/exit of functions</span>
<span class="p_add">+</span>
<span class="p_add">+	- hide: echo nofuncgraph-abstime &gt; trace_options</span>
<span class="p_add">+	- show: echo funcgraph-abstime &gt; trace_options</span>
<span class="p_add">+</span>
<span class="p_add">+  ie::</span>
<span class="p_add">+</span>
<span class="p_add">+    #</span>
<span class="p_add">+    #      TIME       CPU  DURATION                  FUNCTION CALLS</span>
<span class="p_add">+    #       |         |     |   |                     |   |   |   |</span>
<span class="p_add">+    360.774522 |   1)   0.541 us    |                                          }</span>
<span class="p_add">+    360.774522 |   1)   4.663 us    |                                        }</span>
<span class="p_add">+    360.774523 |   1)   0.541 us    |                                        __wake_up_bit();</span>
<span class="p_add">+    360.774524 |   1)   6.796 us    |                                      }</span>
<span class="p_add">+    360.774524 |   1)   7.952 us    |                                    }</span>
<span class="p_add">+    360.774525 |   1)   9.063 us    |                                  }</span>
<span class="p_add">+    360.774525 |   1)   0.615 us    |                                  journal_mark_dirty();</span>
<span class="p_add">+    360.774527 |   1)   0.578 us    |                                  __brelse();</span>
<span class="p_add">+    360.774528 |   1)               |                                  reiserfs_prepare_for_journal() {</span>
<span class="p_add">+    360.774528 |   1)               |                                    unlock_buffer() {</span>
<span class="p_add">+    360.774529 |   1)               |                                      wake_up_bit() {</span>
<span class="p_add">+    360.774529 |   1)               |                                        bit_waitqueue() {</span>
<span class="p_add">+    360.774530 |   1)   0.594 us    |                                          __phys_addr();</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+The function name is always displayed after the closing bracket</span>
<span class="p_add">+for a function if the start of that function is not in the</span>
<span class="p_add">+trace buffer.</span>
<span class="p_add">+</span>
<span class="p_add">+Display of the function name after the closing bracket may be</span>
<span class="p_add">+enabled for functions whose start is in the trace buffer,</span>
<span class="p_add">+allowing easier searching with grep for function durations.</span>
<span class="p_add">+It is default disabled.</span>
<span class="p_add">+</span>
<span class="p_add">+	- hide: echo nofuncgraph-tail &gt; trace_options</span>
<span class="p_add">+	- show: echo funcgraph-tail &gt; trace_options</span>
<span class="p_add">+</span>
<span class="p_add">+  Example with nofuncgraph-tail (default)::</span>
<span class="p_add">+</span>
<span class="p_add">+    0)               |      putname() {</span>
<span class="p_add">+    0)               |        kmem_cache_free() {</span>
<span class="p_add">+    0)   0.518 us    |          __phys_addr();</span>
<span class="p_add">+    0)   1.757 us    |        }</span>
<span class="p_add">+    0)   2.861 us    |      }</span>
<span class="p_add">+</span>
<span class="p_add">+  Example with funcgraph-tail::</span>
<span class="p_add">+</span>
<span class="p_add">+    0)               |      putname() {</span>
<span class="p_add">+    0)               |        kmem_cache_free() {</span>
<span class="p_add">+    0)   0.518 us    |          __phys_addr();</span>
<span class="p_add">+    0)   1.757 us    |        } /* kmem_cache_free() */</span>
<span class="p_add">+    0)   2.861 us    |      } /* putname() */</span>
<span class="p_add">+</span>
<span class="p_add">+You can put some comments on specific functions by using</span>
<span class="p_add">+trace_printk() For example, if you want to put a comment inside</span>
<span class="p_add">+the __might_sleep() function, you just have to include</span>
<span class="p_add">+&lt;linux/ftrace.h&gt; and call trace_printk() inside __might_sleep()::</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_printk(&quot;I&#39;m a comment!\n&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+will produce::</span>
<span class="p_add">+</span>
<span class="p_add">+   1)               |             __might_sleep() {</span>
<span class="p_add">+   1)               |                /* I&#39;m a comment! */</span>
<span class="p_add">+   1)   1.449 us    |             }</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+You might find other useful features for this tracer in the</span>
<span class="p_add">+following &quot;dynamic ftrace&quot; section such as tracing only specific</span>
<span class="p_add">+functions or tasks.</span>
<span class="p_add">+</span>
<span class="p_add">+dynamic ftrace</span>
<span class="p_add">+--------------</span>
<span class="p_add">+</span>
<span class="p_add">+If CONFIG_DYNAMIC_FTRACE is set, the system will run with</span>
<span class="p_add">+virtually no overhead when function tracing is disabled. The way</span>
<span class="p_add">+this works is the mcount function call (placed at the start of</span>
<span class="p_add">+every kernel function, produced by the -pg switch in gcc),</span>
<span class="p_add">+starts of pointing to a simple return. (Enabling FTRACE will</span>
<span class="p_add">+include the -pg switch in the compiling of the kernel.)</span>
<span class="p_add">+</span>
<span class="p_add">+At compile time every C file object is run through the</span>
<span class="p_add">+recordmcount program (located in the scripts directory). This</span>
<span class="p_add">+program will parse the ELF headers in the C object to find all</span>
<span class="p_add">+the locations in the .text section that call mcount. Starting</span>
<span class="p_add">+with gcc verson 4.6, the -mfentry has been added for x86, which</span>
<span class="p_add">+calls &quot;__fentry__&quot; instead of &quot;mcount&quot;. Which is called before</span>
<span class="p_add">+the creation of the stack frame.</span>
<span class="p_add">+</span>
<span class="p_add">+Note, not all sections are traced. They may be prevented by either</span>
<span class="p_add">+a notrace, or blocked another way and all inline functions are not</span>
<span class="p_add">+traced. Check the &quot;available_filter_functions&quot; file to see what functions</span>
<span class="p_add">+can be traced.</span>
<span class="p_add">+</span>
<span class="p_add">+A section called &quot;__mcount_loc&quot; is created that holds</span>
<span class="p_add">+references to all the mcount/fentry call sites in the .text section.</span>
<span class="p_add">+The recordmcount program re-links this section back into the</span>
<span class="p_add">+original object. The final linking stage of the kernel will add all these</span>
<span class="p_add">+references into a single table.</span>
<span class="p_add">+</span>
<span class="p_add">+On boot up, before SMP is initialized, the dynamic ftrace code</span>
<span class="p_add">+scans this table and updates all the locations into nops. It</span>
<span class="p_add">+also records the locations, which are added to the</span>
<span class="p_add">+available_filter_functions list.  Modules are processed as they</span>
<span class="p_add">+are loaded and before they are executed.  When a module is</span>
<span class="p_add">+unloaded, it also removes its functions from the ftrace function</span>
<span class="p_add">+list. This is automatic in the module unload code, and the</span>
<span class="p_add">+module author does not need to worry about it.</span>
<span class="p_add">+</span>
<span class="p_add">+When tracing is enabled, the process of modifying the function</span>
<span class="p_add">+tracepoints is dependent on architecture. The old method is to use</span>
<span class="p_add">+kstop_machine to prevent races with the CPUs executing code being</span>
<span class="p_add">+modified (which can cause the CPU to do undesirable things, especially</span>
<span class="p_add">+if the modified code crosses cache (or page) boundaries), and the nops are</span>
<span class="p_add">+patched back to calls. But this time, they do not call mcount</span>
<span class="p_add">+(which is just a function stub). They now call into the ftrace</span>
<span class="p_add">+infrastructure.</span>
<span class="p_add">+</span>
<span class="p_add">+The new method of modifying the function tracepoints is to place</span>
<span class="p_add">+a breakpoint at the location to be modified, sync all CPUs, modify</span>
<span class="p_add">+the rest of the instruction not covered by the breakpoint. Sync</span>
<span class="p_add">+all CPUs again, and then remove the breakpoint with the finished</span>
<span class="p_add">+version to the ftrace call site.</span>
<span class="p_add">+</span>
<span class="p_add">+Some archs do not even need to monkey around with the synchronization,</span>
<span class="p_add">+and can just slap the new code on top of the old without any</span>
<span class="p_add">+problems with other CPUs executing it at the same time.</span>
<span class="p_add">+</span>
<span class="p_add">+One special side-effect to the recording of the functions being</span>
<span class="p_add">+traced is that we can now selectively choose which functions we</span>
<span class="p_add">+wish to trace and which ones we want the mcount calls to remain</span>
<span class="p_add">+as nops.</span>
<span class="p_add">+</span>
<span class="p_add">+Two files are used, one for enabling and one for disabling the</span>
<span class="p_add">+tracing of specified functions. They are:</span>
<span class="p_add">+</span>
<span class="p_add">+  set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+and</span>
<span class="p_add">+</span>
<span class="p_add">+  set_ftrace_notrace</span>
<span class="p_add">+</span>
<span class="p_add">+A list of available functions that you can add to these files is</span>
<span class="p_add">+listed in:</span>
<span class="p_add">+</span>
<span class="p_add">+   available_filter_functions</span>
<span class="p_add">+</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat available_filter_functions</span>
<span class="p_add">+  put_prev_task_idle</span>
<span class="p_add">+  kmem_cache_create</span>
<span class="p_add">+  pick_next_task_rt</span>
<span class="p_add">+  get_online_cpus</span>
<span class="p_add">+  pick_next_task_fair</span>
<span class="p_add">+  mutex_lock</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+</span>
<span class="p_add">+If I am only interested in sys_nanosleep and hrtimer_interrupt::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo sys_nanosleep hrtimer_interrupt &gt; set_ftrace_filter</span>
<span class="p_add">+  # echo function &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # usleep 1</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 5/5   #P:4</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+            usleep-2665  [001] ....  4186.475355: sys_nanosleep &lt;-system_call_fastpath</span>
<span class="p_add">+            &lt;idle&gt;-0     [001] d.h1  4186.475409: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+            usleep-2665  [001] d.h1  4186.475426: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] d.h1  4186.475426: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+            &lt;idle&gt;-0     [002] d.h1  4186.475427: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_add">+</span>
<span class="p_add">+To see which functions are being traced, you can cat the file:</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat set_ftrace_filter</span>
<span class="p_add">+  hrtimer_interrupt</span>
<span class="p_add">+  sys_nanosleep</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Perhaps this is not enough. The filters also allow glob(7) matching.</span>
<span class="p_add">+</span>
<span class="p_add">+  &lt;match&gt;*</span>
<span class="p_add">+	will match functions that begin with &lt;match&gt;</span>
<span class="p_add">+  *&lt;match&gt;</span>
<span class="p_add">+	will match functions that end with &lt;match&gt;</span>
<span class="p_add">+  *&lt;match&gt;*</span>
<span class="p_add">+	will match functions that have &lt;match&gt; in it</span>
<span class="p_add">+  &lt;match1&gt;*&lt;match2&gt;</span>
<span class="p_add">+	will match functions that begin with &lt;match1&gt; and end with &lt;match2&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+.. note::</span>
<span class="p_add">+      It is better to use quotes to enclose the wild cards,</span>
<span class="p_add">+      otherwise the shell may expand the parameters into names</span>
<span class="p_add">+      of files in the local directory.</span>
<span class="p_add">+</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo &#39;hrtimer_*&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+Produces::</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 897/897   #P:4</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] dN.1  4228.547803: hrtimer_cancel &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] dN.1  4228.547804: hrtimer_try_to_cancel &lt;-hrtimer_cancel</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] dN.2  4228.547805: hrtimer_force_reprogram &lt;-__remove_hrtimer</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] dN.1  4228.547805: hrtimer_forward &lt;-tick_nohz_idle_exit</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] dN.1  4228.547805: hrtimer_start_range_ns &lt;-hrtimer_start_expires.constprop.11</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] d..1  4228.547858: hrtimer_get_next_event &lt;-get_next_timer_interrupt</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] d..1  4228.547859: hrtimer_start &lt;-__tick_nohz_idle_enter</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] d..2  4228.547860: hrtimer_force_reprogram &lt;-__rem</span>
<span class="p_add">+</span>
<span class="p_add">+Notice that we lost the sys_nanosleep.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat set_ftrace_filter</span>
<span class="p_add">+  hrtimer_run_queues</span>
<span class="p_add">+  hrtimer_run_pending</span>
<span class="p_add">+  hrtimer_init</span>
<span class="p_add">+  hrtimer_cancel</span>
<span class="p_add">+  hrtimer_try_to_cancel</span>
<span class="p_add">+  hrtimer_forward</span>
<span class="p_add">+  hrtimer_start</span>
<span class="p_add">+  hrtimer_reprogram</span>
<span class="p_add">+  hrtimer_force_reprogram</span>
<span class="p_add">+  hrtimer_get_next_event</span>
<span class="p_add">+  hrtimer_interrupt</span>
<span class="p_add">+  hrtimer_nanosleep</span>
<span class="p_add">+  hrtimer_wakeup</span>
<span class="p_add">+  hrtimer_get_remaining</span>
<span class="p_add">+  hrtimer_get_res</span>
<span class="p_add">+  hrtimer_init_sleeper</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+This is because the &#39;&gt;&#39; and &#39;&gt;&gt;&#39; act just like they do in bash.</span>
<span class="p_add">+To rewrite the filters, use &#39;&gt;&#39;</span>
<span class="p_add">+To append to the filters, use &#39;&gt;&gt;&#39;</span>
<span class="p_add">+</span>
<span class="p_add">+To clear out a filter so that all functions will be recorded</span>
<span class="p_add">+again::</span>
<span class="p_add">+</span>
<span class="p_add">+ # echo &gt; set_ftrace_filter</span>
<span class="p_add">+ # cat set_ftrace_filter</span>
<span class="p_add">+ #</span>
<span class="p_add">+</span>
<span class="p_add">+Again, now we want to append.</span>
<span class="p_add">+</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo sys_nanosleep &gt; set_ftrace_filter</span>
<span class="p_add">+  # cat set_ftrace_filter</span>
<span class="p_add">+  sys_nanosleep</span>
<span class="p_add">+  # echo &#39;hrtimer_*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_add">+  # cat set_ftrace_filter</span>
<span class="p_add">+  hrtimer_run_queues</span>
<span class="p_add">+  hrtimer_run_pending</span>
<span class="p_add">+  hrtimer_init</span>
<span class="p_add">+  hrtimer_cancel</span>
<span class="p_add">+  hrtimer_try_to_cancel</span>
<span class="p_add">+  hrtimer_forward</span>
<span class="p_add">+  hrtimer_start</span>
<span class="p_add">+  hrtimer_reprogram</span>
<span class="p_add">+  hrtimer_force_reprogram</span>
<span class="p_add">+  hrtimer_get_next_event</span>
<span class="p_add">+  hrtimer_interrupt</span>
<span class="p_add">+  sys_nanosleep</span>
<span class="p_add">+  hrtimer_nanosleep</span>
<span class="p_add">+  hrtimer_wakeup</span>
<span class="p_add">+  hrtimer_get_remaining</span>
<span class="p_add">+  hrtimer_get_res</span>
<span class="p_add">+  hrtimer_init_sleeper</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+The set_ftrace_notrace prevents those functions from being</span>
<span class="p_add">+traced.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo &#39;*preempt*&#39; &#39;*lock*&#39; &gt; set_ftrace_notrace</span>
<span class="p_add">+</span>
<span class="p_add">+Produces::</span>
<span class="p_add">+</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 39608/39608   #P:4</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324896: file_ra_state_init &lt;-do_dentry_open</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324897: open_check_o_direct &lt;-do_last</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324897: ima_file_check &lt;-do_last</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324898: process_measurement &lt;-ima_file_check</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324898: ima_get_action &lt;-process_measurement</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324898: ima_match_policy &lt;-ima_get_action</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324899: do_truncate &lt;-do_last</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324899: should_remove_suid &lt;-do_truncate</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324899: notify_change &lt;-do_truncate</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324900: current_fs_time &lt;-notify_change</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324900: current_kernel_time &lt;-current_fs_time</span>
<span class="p_add">+              bash-1994  [000] ....  4342.324900: timespec_trunc &lt;-current_fs_time</span>
<span class="p_add">+</span>
<span class="p_add">+We can see that there&#39;s no more lock or preempt tracing.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Dynamic ftrace with the function graph tracer</span>
<span class="p_add">+---------------------------------------------</span>
<span class="p_add">+</span>
<span class="p_add">+Although what has been explained above concerns both the</span>
<span class="p_add">+function tracer and the function-graph-tracer, there are some</span>
<span class="p_add">+special features only available in the function-graph tracer.</span>
<span class="p_add">+</span>
<span class="p_add">+If you want to trace only one function and all of its children,</span>
<span class="p_add">+you just have to echo its name into set_graph_function::</span>
<span class="p_add">+</span>
<span class="p_add">+ echo __do_fault &gt; set_graph_function</span>
<span class="p_add">+</span>
<span class="p_add">+will produce the following &quot;expanded&quot; trace of the __do_fault()</span>
<span class="p_add">+function::</span>
<span class="p_add">+</span>
<span class="p_add">+   0)               |  __do_fault() {</span>
<span class="p_add">+   0)               |    filemap_fault() {</span>
<span class="p_add">+   0)               |      find_lock_page() {</span>
<span class="p_add">+   0)   0.804 us    |        find_get_page();</span>
<span class="p_add">+   0)               |        __might_sleep() {</span>
<span class="p_add">+   0)   1.329 us    |        }</span>
<span class="p_add">+   0)   3.904 us    |      }</span>
<span class="p_add">+   0)   4.979 us    |    }</span>
<span class="p_add">+   0)   0.653 us    |    _spin_lock();</span>
<span class="p_add">+   0)   0.578 us    |    page_add_file_rmap();</span>
<span class="p_add">+   0)   0.525 us    |    native_set_pte_at();</span>
<span class="p_add">+   0)   0.585 us    |    _spin_unlock();</span>
<span class="p_add">+   0)               |    unlock_page() {</span>
<span class="p_add">+   0)   0.541 us    |      page_waitqueue();</span>
<span class="p_add">+   0)   0.639 us    |      __wake_up_bit();</span>
<span class="p_add">+   0)   2.786 us    |    }</span>
<span class="p_add">+   0) + 14.237 us   |  }</span>
<span class="p_add">+   0)               |  __do_fault() {</span>
<span class="p_add">+   0)               |    filemap_fault() {</span>
<span class="p_add">+   0)               |      find_lock_page() {</span>
<span class="p_add">+   0)   0.698 us    |        find_get_page();</span>
<span class="p_add">+   0)               |        __might_sleep() {</span>
<span class="p_add">+   0)   1.412 us    |        }</span>
<span class="p_add">+   0)   3.950 us    |      }</span>
<span class="p_add">+   0)   5.098 us    |    }</span>
<span class="p_add">+   0)   0.631 us    |    _spin_lock();</span>
<span class="p_add">+   0)   0.571 us    |    page_add_file_rmap();</span>
<span class="p_add">+   0)   0.526 us    |    native_set_pte_at();</span>
<span class="p_add">+   0)   0.586 us    |    _spin_unlock();</span>
<span class="p_add">+   0)               |    unlock_page() {</span>
<span class="p_add">+   0)   0.533 us    |      page_waitqueue();</span>
<span class="p_add">+   0)   0.638 us    |      __wake_up_bit();</span>
<span class="p_add">+   0)   2.793 us    |    }</span>
<span class="p_add">+   0) + 14.012 us   |  }</span>
<span class="p_add">+</span>
<span class="p_add">+You can also expand several functions at once::</span>
<span class="p_add">+</span>
<span class="p_add">+ echo sys_open &gt; set_graph_function</span>
<span class="p_add">+ echo sys_close &gt;&gt; set_graph_function</span>
<span class="p_add">+</span>
<span class="p_add">+Now if you want to go back to trace all functions you can clear</span>
<span class="p_add">+this special filter via::</span>
<span class="p_add">+</span>
<span class="p_add">+ echo &gt; set_graph_function</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+ftrace_enabled</span>
<span class="p_add">+--------------</span>
<span class="p_add">+</span>
<span class="p_add">+Note, the proc sysctl ftrace_enable is a big on/off switch for the</span>
<span class="p_add">+function tracer. By default it is enabled (when function tracing is</span>
<span class="p_add">+enabled in the kernel). If it is disabled, all function tracing is</span>
<span class="p_add">+disabled. This includes not only the function tracers for ftrace, but</span>
<span class="p_add">+also for any other uses (perf, kprobes, stack tracing, profiling, etc).</span>
<span class="p_add">+</span>
<span class="p_add">+Please disable this with care.</span>
<span class="p_add">+</span>
<span class="p_add">+This can be disable (and enabled) with::</span>
<span class="p_add">+</span>
<span class="p_add">+  sysctl kernel.ftrace_enabled=0</span>
<span class="p_add">+  sysctl kernel.ftrace_enabled=1</span>
<span class="p_add">+</span>
<span class="p_add">+ or</span>
<span class="p_add">+</span>
<span class="p_add">+  echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span class="p_add">+  echo 1 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Filter commands</span>
<span class="p_add">+---------------</span>
<span class="p_add">+</span>
<span class="p_add">+A few commands are supported by the set_ftrace_filter interface.</span>
<span class="p_add">+Trace commands have the following format::</span>
<span class="p_add">+</span>
<span class="p_add">+  &lt;function&gt;:&lt;command&gt;:&lt;parameter&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+The following commands are supported:</span>
<span class="p_add">+</span>
<span class="p_add">+- mod:</span>
<span class="p_add">+  This command enables function filtering per module. The</span>
<span class="p_add">+  parameter defines the module. For example, if only the write*</span>
<span class="p_add">+  functions in the ext3 module are desired, run:</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;write*:mod:ext3&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  This command interacts with the filter in the same way as</span>
<span class="p_add">+  filtering based on function names. Thus, adding more functions</span>
<span class="p_add">+  in a different module is accomplished by appending (&gt;&gt;) to the</span>
<span class="p_add">+  filter file. Remove specific module functions by prepending</span>
<span class="p_add">+  &#39;!&#39;::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;!writeback*:mod:ext3&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  Mod command supports module globbing. Disable tracing for all</span>
<span class="p_add">+  functions except a specific module::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;!*:mod:!ext3&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  Disable tracing for all modules, but still trace kernel::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;!*:mod:*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  Enable filter only for kernel::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;*write*:mod:!*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  Enable filter for module globbing::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;*write*:mod:*snd*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+- traceon/traceoff:</span>
<span class="p_add">+  These commands turn tracing on and off when the specified</span>
<span class="p_add">+  functions are hit. The parameter determines how many times the</span>
<span class="p_add">+  tracing system is turned on and off. If unspecified, there is</span>
<span class="p_add">+  no limit. For example, to disable tracing when a schedule bug</span>
<span class="p_add">+  is hit the first 5 times, run::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;__schedule_bug:traceoff:5&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  To always disable tracing when __schedule_bug is hit::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;__schedule_bug:traceoff&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  These commands are cumulative whether or not they are appended</span>
<span class="p_add">+  to set_ftrace_filter. To remove a command, prepend it by &#39;!&#39;</span>
<span class="p_add">+  and drop the parameter::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;!__schedule_bug:traceoff:0&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  The above removes the traceoff command for __schedule_bug</span>
<span class="p_add">+  that have a counter. To remove commands without counters::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;!__schedule_bug:traceoff&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+- snapshot:</span>
<span class="p_add">+  Will cause a snapshot to be triggered when the function is hit.</span>
<span class="p_add">+  ::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;native_flush_tlb_others:snapshot&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  To only snapshot once:</span>
<span class="p_add">+  ::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;native_flush_tlb_others:snapshot:1&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  To remove the above commands::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;!native_flush_tlb_others:snapshot&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+   echo &#39;!native_flush_tlb_others:snapshot:0&#39; &gt; set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+- enable_event/disable_event:</span>
<span class="p_add">+  These commands can enable or disable a trace event. Note, because</span>
<span class="p_add">+  function tracing callbacks are very sensitive, when these commands</span>
<span class="p_add">+  are registered, the trace point is activated, but disabled in</span>
<span class="p_add">+  a &quot;soft&quot; mode. That is, the tracepoint will be called, but</span>
<span class="p_add">+  just will not be traced. The event tracepoint stays in this mode</span>
<span class="p_add">+  as long as there&#39;s a command that triggers it.</span>
<span class="p_add">+  ::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;try_to_wake_up:enable_event:sched:sched_switch:2&#39; &gt; \</span>
<span class="p_add">+   	 set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+  The format is::</span>
<span class="p_add">+</span>
<span class="p_add">+    &lt;function&gt;:enable_event:&lt;system&gt;:&lt;event&gt;[:count]</span>
<span class="p_add">+    &lt;function&gt;:disable_event:&lt;system&gt;:&lt;event&gt;[:count]</span>
<span class="p_add">+</span>
<span class="p_add">+  To remove the events commands::</span>
<span class="p_add">+</span>
<span class="p_add">+   echo &#39;!try_to_wake_up:enable_event:sched:sched_switch:0&#39; &gt; \</span>
<span class="p_add">+   	 set_ftrace_filter</span>
<span class="p_add">+   echo &#39;!schedule:disable_event:sched:sched_switch&#39; &gt; \</span>
<span class="p_add">+   	 set_ftrace_filter</span>
<span class="p_add">+</span>
<span class="p_add">+- dump:</span>
<span class="p_add">+  When the function is hit, it will dump the contents of the ftrace</span>
<span class="p_add">+  ring buffer to the console. This is useful if you need to debug</span>
<span class="p_add">+  something, and want to dump the trace when a certain function</span>
<span class="p_add">+  is hit. Perhaps its a function that is called before a tripple</span>
<span class="p_add">+  fault happens and does not allow you to get a regular dump.</span>
<span class="p_add">+</span>
<span class="p_add">+- cpudump:</span>
<span class="p_add">+  When the function is hit, it will dump the contents of the ftrace</span>
<span class="p_add">+  ring buffer for the current CPU to the console. Unlike the &quot;dump&quot;</span>
<span class="p_add">+  command, it only prints out the contents of the ring buffer for the</span>
<span class="p_add">+  CPU that executed the function that triggered the dump.</span>
<span class="p_add">+</span>
<span class="p_add">+trace_pipe</span>
<span class="p_add">+----------</span>
<span class="p_add">+</span>
<span class="p_add">+The trace_pipe outputs the same content as the trace file, but</span>
<span class="p_add">+the effect on the tracing is different. Every read from</span>
<span class="p_add">+trace_pipe is consumed. This means that subsequent reads will be</span>
<span class="p_add">+different. The trace is live.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo function &gt; current_tracer</span>
<span class="p_add">+  # cat trace_pipe &gt; /tmp/trace.out &amp;</span>
<span class="p_add">+  [1] 4153</span>
<span class="p_add">+  # echo 1 &gt; tracing_on</span>
<span class="p_add">+  # usleep 1</span>
<span class="p_add">+  # echo 0 &gt; tracing_on</span>
<span class="p_add">+  # cat trace</span>
<span class="p_add">+  # tracer: function</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 0/0   #P:4</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # cat /tmp/trace.out</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568961: mutex_unlock &lt;-rb_simple_write</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568963: __mutex_unlock_slowpath &lt;-mutex_unlock</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568963: __fsnotify_parent &lt;-fsnotify_modify</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568964: fsnotify &lt;-fsnotify_modify</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568964: __srcu_read_lock &lt;-fsnotify</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568964: add_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_add">+             bash-1994  [000] ...1  5281.568965: sub_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568965: __srcu_read_unlock &lt;-fsnotify</span>
<span class="p_add">+             bash-1994  [000] ....  5281.568967: sys_dup2 &lt;-system_call_fastpath</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Note, reading the trace_pipe file will block until more input is</span>
<span class="p_add">+added.</span>
<span class="p_add">+</span>
<span class="p_add">+trace entries</span>
<span class="p_add">+-------------</span>
<span class="p_add">+</span>
<span class="p_add">+Having too much or not enough data can be troublesome in</span>
<span class="p_add">+diagnosing an issue in the kernel. The file buffer_size_kb is</span>
<span class="p_add">+used to modify the size of the internal trace buffers. The</span>
<span class="p_add">+number listed is the number of entries that can be recorded per</span>
<span class="p_add">+CPU. To know the full size, multiply the number of possible CPUs</span>
<span class="p_add">+with the number of entries.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat buffer_size_kb</span>
<span class="p_add">+  1408 (units kilobytes)</span>
<span class="p_add">+</span>
<span class="p_add">+Or simply read buffer_total_size_kb</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat buffer_total_size_kb </span>
<span class="p_add">+  5632</span>
<span class="p_add">+</span>
<span class="p_add">+To modify the buffer, simple echo in a number (in 1024 byte segments).</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 10000 &gt; buffer_size_kb</span>
<span class="p_add">+  # cat buffer_size_kb</span>
<span class="p_add">+  10000 (units kilobytes)</span>
<span class="p_add">+</span>
<span class="p_add">+It will try to allocate as much as possible. If you allocate too</span>
<span class="p_add">+much, it can cause Out-Of-Memory to trigger.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 1000000000000 &gt; buffer_size_kb</span>
<span class="p_add">+  -bash: echo: write error: Cannot allocate memory</span>
<span class="p_add">+  # cat buffer_size_kb</span>
<span class="p_add">+  85</span>
<span class="p_add">+</span>
<span class="p_add">+The per_cpu buffers can be changed individually as well:</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 10000 &gt; per_cpu/cpu0/buffer_size_kb</span>
<span class="p_add">+  # echo 100 &gt; per_cpu/cpu1/buffer_size_kb</span>
<span class="p_add">+</span>
<span class="p_add">+When the per_cpu buffers are not the same, the buffer_size_kb</span>
<span class="p_add">+at the top level will just show an X</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat buffer_size_kb</span>
<span class="p_add">+  X</span>
<span class="p_add">+</span>
<span class="p_add">+This is where the buffer_total_size_kb is useful:</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat buffer_total_size_kb </span>
<span class="p_add">+  12916</span>
<span class="p_add">+</span>
<span class="p_add">+Writing to the top level buffer_size_kb will reset all the buffers</span>
<span class="p_add">+to be the same again.</span>
<span class="p_add">+</span>
<span class="p_add">+Snapshot</span>
<span class="p_add">+--------</span>
<span class="p_add">+CONFIG_TRACER_SNAPSHOT makes a generic snapshot feature</span>
<span class="p_add">+available to all non latency tracers. (Latency tracers which</span>
<span class="p_add">+record max latency, such as &quot;irqsoff&quot; or &quot;wakeup&quot;, can&#39;t use</span>
<span class="p_add">+this feature, since those are already using the snapshot</span>
<span class="p_add">+mechanism internally.)</span>
<span class="p_add">+</span>
<span class="p_add">+Snapshot preserves a current trace buffer at a particular point</span>
<span class="p_add">+in time without stopping tracing. Ftrace swaps the current</span>
<span class="p_add">+buffer with a spare buffer, and tracing continues in the new</span>
<span class="p_add">+current (=previous spare) buffer.</span>
<span class="p_add">+</span>
<span class="p_add">+The following tracefs files in &quot;tracing&quot; are related to this</span>
<span class="p_add">+feature:</span>
<span class="p_add">+</span>
<span class="p_add">+  snapshot:</span>
<span class="p_add">+</span>
<span class="p_add">+	This is used to take a snapshot and to read the output</span>
<span class="p_add">+	of the snapshot. Echo 1 into this file to allocate a</span>
<span class="p_add">+	spare buffer and to take a snapshot (swap), then read</span>
<span class="p_add">+	the snapshot from this file in the same format as</span>
<span class="p_add">+	&quot;trace&quot; (described above in the section &quot;The File</span>
<span class="p_add">+	System&quot;). Both reads snapshot and tracing are executable</span>
<span class="p_add">+	in parallel. When the spare buffer is allocated, echoing</span>
<span class="p_add">+	0 frees it, and echoing else (positive) values clear the</span>
<span class="p_add">+	snapshot contents.</span>
<span class="p_add">+	More details are shown in the table below.</span>
<span class="p_add">+</span>
<span class="p_add">+	+--------------+------------+------------+------------+</span>
<span class="p_add">+	|status\\input |     0      |     1      |    else    |</span>
<span class="p_add">+	+==============+============+============+============+</span>
<span class="p_add">+	|not allocated |(do nothing)| alloc+swap |(do nothing)|</span>
<span class="p_add">+	+--------------+------------+------------+------------+</span>
<span class="p_add">+	|allocated     |    free    |    swap    |   clear    |</span>
<span class="p_add">+	+--------------+------------+------------+------------+</span>
<span class="p_add">+</span>
<span class="p_add">+Here is an example of using the snapshot feature.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo 1 &gt; events/sched/enable</span>
<span class="p_add">+  # echo 1 &gt; snapshot</span>
<span class="p_add">+  # cat snapshot</span>
<span class="p_add">+  # tracer: nop</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 71/71   #P:8</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+            &lt;idle&gt;-0     [005] d...  2440.603828: sched_switch: prev_comm=swapper/5 prev_pid=0 prev_prio=120   prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2242 next_prio=120</span>
<span class="p_add">+             sleep-2242  [005] d...  2440.603846: sched_switch: prev_comm=snapshot-test-2 prev_pid=2242 prev_prio=120   prev_state=R ==&gt; next_comm=kworker/5:1 next_pid=60 next_prio=120</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+          &lt;idle&gt;-0     [002] d...  2440.707230: sched_switch: prev_comm=swapper/2 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2229 next_prio=120  </span>
<span class="p_add">+</span>
<span class="p_add">+  # cat trace  </span>
<span class="p_add">+  # tracer: nop</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 77/77   #P:8</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+            &lt;idle&gt;-0     [007] d...  2440.707395: sched_switch: prev_comm=swapper/7 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2243 next_prio=120</span>
<span class="p_add">+   snapshot-test-2-2229  [002] d...  2440.707438: sched_switch: prev_comm=snapshot-test-2 prev_pid=2229 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/2 next_pid=0 next_prio=120</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+If you try to use this snapshot feature when current tracer is</span>
<span class="p_add">+one of the latency tracers, you will get the following results.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # echo wakeup &gt; current_tracer</span>
<span class="p_add">+  # echo 1 &gt; snapshot</span>
<span class="p_add">+  bash: echo: write error: Device or resource busy</span>
<span class="p_add">+  # cat snapshot</span>
<span class="p_add">+  cat: snapshot: Device or resource busy</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Instances</span>
<span class="p_add">+---------</span>
<span class="p_add">+In the tracefs tracing directory is a directory called &quot;instances&quot;.</span>
<span class="p_add">+This directory can have new directories created inside of it using</span>
<span class="p_add">+mkdir, and removing directories with rmdir. The directory created</span>
<span class="p_add">+with mkdir in this directory will already contain files and other</span>
<span class="p_add">+directories after it is created.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # mkdir instances/foo</span>
<span class="p_add">+  # ls instances/foo</span>
<span class="p_add">+  buffer_size_kb  buffer_total_size_kb  events  free_buffer  per_cpu</span>
<span class="p_add">+  set_event  snapshot  trace  trace_clock  trace_marker  trace_options</span>
<span class="p_add">+  trace_pipe  tracing_on</span>
<span class="p_add">+</span>
<span class="p_add">+As you can see, the new directory looks similar to the tracing directory</span>
<span class="p_add">+itself. In fact, it is very similar, except that the buffer and</span>
<span class="p_add">+events are agnostic from the main director, or from any other</span>
<span class="p_add">+instances that are created.</span>
<span class="p_add">+</span>
<span class="p_add">+The files in the new directory work just like the files with the</span>
<span class="p_add">+same name in the tracing directory except the buffer that is used</span>
<span class="p_add">+is a separate and new buffer. The files affect that buffer but do not</span>
<span class="p_add">+affect the main buffer with the exception of trace_options. Currently,</span>
<span class="p_add">+the trace_options affect all instances and the top level buffer</span>
<span class="p_add">+the same, but this may change in future releases. That is, options</span>
<span class="p_add">+may become specific to the instance they reside in.</span>
<span class="p_add">+</span>
<span class="p_add">+Notice that none of the function tracer files are there, nor is</span>
<span class="p_add">+current_tracer and available_tracers. This is because the buffers</span>
<span class="p_add">+can currently only have events enabled for them.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # mkdir instances/foo</span>
<span class="p_add">+  # mkdir instances/bar</span>
<span class="p_add">+  # mkdir instances/zoot</span>
<span class="p_add">+  # echo 100000 &gt; buffer_size_kb</span>
<span class="p_add">+  # echo 1000 &gt; instances/foo/buffer_size_kb</span>
<span class="p_add">+  # echo 5000 &gt; instances/bar/per_cpu/cpu1/buffer_size_kb</span>
<span class="p_add">+  # echo function &gt; current_trace</span>
<span class="p_add">+  # echo 1 &gt; instances/foo/events/sched/sched_wakeup/enable</span>
<span class="p_add">+  # echo 1 &gt; instances/foo/events/sched/sched_wakeup_new/enable</span>
<span class="p_add">+  # echo 1 &gt; instances/foo/events/sched/sched_switch/enable</span>
<span class="p_add">+  # echo 1 &gt; instances/bar/events/irq/enable</span>
<span class="p_add">+  # echo 1 &gt; instances/zoot/events/syscalls/enable</span>
<span class="p_add">+  # cat trace_pipe</span>
<span class="p_add">+  CPU:2 [LOST 11745 EVENTS]</span>
<span class="p_add">+              bash-2044  [002] .... 10594.481032: _raw_spin_lock_irqsave &lt;-get_page_from_freelist</span>
<span class="p_add">+              bash-2044  [002] d... 10594.481032: add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_add">+              bash-2044  [002] d..1 10594.481032: __rmqueue &lt;-get_page_from_freelist</span>
<span class="p_add">+              bash-2044  [002] d..1 10594.481033: _raw_spin_unlock &lt;-get_page_from_freelist</span>
<span class="p_add">+              bash-2044  [002] d..1 10594.481033: sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_add">+              bash-2044  [002] d... 10594.481033: get_pageblock_flags_group &lt;-get_pageblock_migratetype</span>
<span class="p_add">+              bash-2044  [002] d... 10594.481034: __mod_zone_page_state &lt;-get_page_from_freelist</span>
<span class="p_add">+              bash-2044  [002] d... 10594.481034: zone_statistics &lt;-get_page_from_freelist</span>
<span class="p_add">+              bash-2044  [002] d... 10594.481034: __inc_zone_state &lt;-zone_statistics</span>
<span class="p_add">+              bash-2044  [002] d... 10594.481034: __inc_zone_state &lt;-zone_statistics</span>
<span class="p_add">+              bash-2044  [002] .... 10594.481035: arch_dup_task_struct &lt;-copy_process</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat instances/foo/trace_pipe</span>
<span class="p_add">+              bash-1998  [000] d..4   136.676759: sched_wakeup: comm=kworker/0:1 pid=59 prio=120 success=1 target_cpu=000</span>
<span class="p_add">+              bash-1998  [000] dN.4   136.676760: sched_wakeup: comm=bash pid=1998 prio=120 success=1 target_cpu=000</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] d.h3   136.676906: sched_wakeup: comm=rcu_preempt pid=9 prio=120 success=1 target_cpu=003</span>
<span class="p_add">+            &lt;idle&gt;-0     [003] d..3   136.676909: sched_switch: prev_comm=swapper/3 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=rcu_preempt next_pid=9 next_prio=120</span>
<span class="p_add">+       rcu_preempt-9     [003] d..3   136.676916: sched_switch: prev_comm=rcu_preempt prev_pid=9 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/3 next_pid=0 next_prio=120</span>
<span class="p_add">+              bash-1998  [000] d..4   136.677014: sched_wakeup: comm=kworker/0:1 pid=59 prio=120 success=1 target_cpu=000</span>
<span class="p_add">+              bash-1998  [000] dN.4   136.677016: sched_wakeup: comm=bash pid=1998 prio=120 success=1 target_cpu=000</span>
<span class="p_add">+              bash-1998  [000] d..3   136.677018: sched_switch: prev_comm=bash prev_pid=1998 prev_prio=120 prev_state=R+ ==&gt; next_comm=kworker/0:1 next_pid=59 next_prio=120</span>
<span class="p_add">+       kworker/0:1-59    [000] d..4   136.677022: sched_wakeup: comm=sshd pid=1995 prio=120 success=1 target_cpu=001</span>
<span class="p_add">+       kworker/0:1-59    [000] d..3   136.677025: sched_switch: prev_comm=kworker/0:1 prev_pid=59 prev_prio=120 prev_state=S ==&gt; next_comm=bash next_pid=1998 next_prio=120</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat instances/bar/trace_pipe</span>
<span class="p_add">+       migration/1-14    [001] d.h3   138.732674: softirq_raise: vec=3 [action=NET_RX]</span>
<span class="p_add">+            &lt;idle&gt;-0     [001] dNh3   138.732725: softirq_raise: vec=3 [action=NET_RX]</span>
<span class="p_add">+              bash-1998  [000] d.h1   138.733101: softirq_raise: vec=1 [action=TIMER]</span>
<span class="p_add">+              bash-1998  [000] d.h1   138.733102: softirq_raise: vec=9 [action=RCU]</span>
<span class="p_add">+              bash-1998  [000] ..s2   138.733105: softirq_entry: vec=1 [action=TIMER]</span>
<span class="p_add">+              bash-1998  [000] ..s2   138.733106: softirq_exit: vec=1 [action=TIMER]</span>
<span class="p_add">+              bash-1998  [000] ..s2   138.733106: softirq_entry: vec=9 [action=RCU]</span>
<span class="p_add">+              bash-1998  [000] ..s2   138.733109: softirq_exit: vec=9 [action=RCU]</span>
<span class="p_add">+              sshd-1995  [001] d.h1   138.733278: irq_handler_entry: irq=21 name=uhci_hcd:usb4</span>
<span class="p_add">+              sshd-1995  [001] d.h1   138.733280: irq_handler_exit: irq=21 ret=unhandled</span>
<span class="p_add">+              sshd-1995  [001] d.h1   138.733281: irq_handler_entry: irq=21 name=eth0</span>
<span class="p_add">+              sshd-1995  [001] d.h1   138.733283: irq_handler_exit: irq=21 ret=handled</span>
<span class="p_add">+  [...]</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat instances/zoot/trace</span>
<span class="p_add">+  # tracer: nop</span>
<span class="p_add">+  #</span>
<span class="p_add">+  # entries-in-buffer/entries-written: 18996/18996   #P:4</span>
<span class="p_add">+  #</span>
<span class="p_add">+  #                              _-----=&gt; irqs-off</span>
<span class="p_add">+  #                             / _----=&gt; need-resched</span>
<span class="p_add">+  #                            | / _---=&gt; hardirq/softirq</span>
<span class="p_add">+  #                            || / _--=&gt; preempt-depth</span>
<span class="p_add">+  #                            ||| /     delay</span>
<span class="p_add">+  #           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_add">+  #              | |       |   ||||       |         |</span>
<span class="p_add">+              bash-1998  [000] d...   140.733501: sys_write -&gt; 0x2</span>
<span class="p_add">+              bash-1998  [000] d...   140.733504: sys_dup2(oldfd: a, newfd: 1)</span>
<span class="p_add">+              bash-1998  [000] d...   140.733506: sys_dup2 -&gt; 0x1</span>
<span class="p_add">+              bash-1998  [000] d...   140.733508: sys_fcntl(fd: a, cmd: 1, arg: 0)</span>
<span class="p_add">+              bash-1998  [000] d...   140.733509: sys_fcntl -&gt; 0x1</span>
<span class="p_add">+              bash-1998  [000] d...   140.733510: sys_close(fd: a)</span>
<span class="p_add">+              bash-1998  [000] d...   140.733510: sys_close -&gt; 0x0</span>
<span class="p_add">+              bash-1998  [000] d...   140.733514: sys_rt_sigprocmask(how: 0, nset: 0, oset: 6e2768, sigsetsize: 8)</span>
<span class="p_add">+              bash-1998  [000] d...   140.733515: sys_rt_sigprocmask -&gt; 0x0</span>
<span class="p_add">+              bash-1998  [000] d...   140.733516: sys_rt_sigaction(sig: 2, act: 7fff718846f0, oact: 7fff71884650, sigsetsize: 8)</span>
<span class="p_add">+              bash-1998  [000] d...   140.733516: sys_rt_sigaction -&gt; 0x0</span>
<span class="p_add">+</span>
<span class="p_add">+You can see that the trace of the top most trace buffer shows only</span>
<span class="p_add">+the function tracing. The foo instance displays wakeups and task</span>
<span class="p_add">+switches.</span>
<span class="p_add">+</span>
<span class="p_add">+To remove the instances, simply delete their directories:</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # rmdir instances/foo</span>
<span class="p_add">+  # rmdir instances/bar</span>
<span class="p_add">+  # rmdir instances/zoot</span>
<span class="p_add">+</span>
<span class="p_add">+Note, if a process has a trace file open in one of the instance</span>
<span class="p_add">+directories, the rmdir will fail with EBUSY.</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+Stack trace</span>
<span class="p_add">+-----------</span>
<span class="p_add">+Since the kernel has a fixed sized stack, it is important not to</span>
<span class="p_add">+waste it in functions. A kernel developer must be conscience of</span>
<span class="p_add">+what they allocate on the stack. If they add too much, the system</span>
<span class="p_add">+can be in danger of a stack overflow, and corruption will occur,</span>
<span class="p_add">+usually leading to a system panic.</span>
<span class="p_add">+</span>
<span class="p_add">+There are some tools that check this, usually with interrupts</span>
<span class="p_add">+periodically checking usage. But if you can perform a check</span>
<span class="p_add">+at every function call that will become very useful. As ftrace provides</span>
<span class="p_add">+a function tracer, it makes it convenient to check the stack size</span>
<span class="p_add">+at every function call. This is enabled via the stack tracer.</span>
<span class="p_add">+</span>
<span class="p_add">+CONFIG_STACK_TRACER enables the ftrace stack tracing functionality.</span>
<span class="p_add">+To enable it, write a &#39;1&#39; into /proc/sys/kernel/stack_tracer_enabled.</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+ # echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled</span>
<span class="p_add">+</span>
<span class="p_add">+You can also enable it from the kernel command line to trace</span>
<span class="p_add">+the stack size of the kernel during boot up, by adding &quot;stacktrace&quot;</span>
<span class="p_add">+to the kernel command line parameter.</span>
<span class="p_add">+</span>
<span class="p_add">+After running it for a few minutes, the output looks like:</span>
<span class="p_add">+::</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat stack_max_size</span>
<span class="p_add">+  2928</span>
<span class="p_add">+</span>
<span class="p_add">+  # cat stack_trace</span>
<span class="p_add">+          Depth    Size   Location    (18 entries)</span>
<span class="p_add">+          -----    ----   --------</span>
<span class="p_add">+    0)     2928     224   update_sd_lb_stats+0xbc/0x4ac</span>
<span class="p_add">+    1)     2704     160   find_busiest_group+0x31/0x1f1</span>
<span class="p_add">+    2)     2544     256   load_balance+0xd9/0x662</span>
<span class="p_add">+    3)     2288      80   idle_balance+0xbb/0x130</span>
<span class="p_add">+    4)     2208     128   __schedule+0x26e/0x5b9</span>
<span class="p_add">+    5)     2080      16   schedule+0x64/0x66</span>
<span class="p_add">+    6)     2064     128   schedule_timeout+0x34/0xe0</span>
<span class="p_add">+    7)     1936     112   wait_for_common+0x97/0xf1</span>
<span class="p_add">+    8)     1824      16   wait_for_completion+0x1d/0x1f</span>
<span class="p_add">+    9)     1808     128   flush_work+0xfe/0x119</span>
<span class="p_add">+   10)     1680      16   tty_flush_to_ldisc+0x1e/0x20</span>
<span class="p_add">+   11)     1664      48   input_available_p+0x1d/0x5c</span>
<span class="p_add">+   12)     1616      48   n_tty_poll+0x6d/0x134</span>
<span class="p_add">+   13)     1568      64   tty_poll+0x64/0x7f</span>
<span class="p_add">+   14)     1504     880   do_select+0x31e/0x511</span>
<span class="p_add">+   15)      624     400   core_sys_select+0x177/0x216</span>
<span class="p_add">+   16)      224      96   sys_select+0x91/0xb9</span>
<span class="p_add">+   17)      128     128   system_call_fastpath+0x16/0x1b</span>
<span class="p_add">+</span>
<span class="p_add">+Note, if -mfentry is being used by gcc, functions get traced before</span>
<span class="p_add">+they set up the stack frame. This means that leaf level functions</span>
<span class="p_add">+are not tested by the stack tracer when -mfentry is used.</span>
<span class="p_add">+</span>
<span class="p_add">+Currently, -mfentry is used by gcc 4.6.0 and above on x86 only.</span>
<span class="p_add">+</span>
<span class="p_add">+More</span>
<span class="p_add">+----</span>
<span class="p_add">+More details can be found in the source code, in the `kernel/trace/*.c` files.</span>
<span class="p_header">diff --git a/Documentation/trace/ftrace.txt b/Documentation/trace/ftrace.txt</span>
deleted file mode 100644
<span class="p_header">index d4601df..0000000</span>
<span class="p_header">--- a/Documentation/trace/ftrace.txt</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,3220 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-		ftrace - Function Tracer</span>
<span class="p_del">-		========================</span>
<span class="p_del">-</span>
<span class="p_del">-Copyright 2008 Red Hat Inc.</span>
<span class="p_del">-   Author:   Steven Rostedt &lt;srostedt@redhat.com&gt;</span>
<span class="p_del">-  License:   The GNU Free Documentation License, Version 1.2</span>
<span class="p_del">-               (dual licensed under the GPL v2)</span>
<span class="p_del">-Original Reviewers:   Elias Oltmanns, Randy Dunlap, Andrew Morton,</span>
<span class="p_del">-		      John Kacur, and David Teigland.</span>
<span class="p_del">-Written for: 2.6.28-rc2</span>
<span class="p_del">-Updated for: 3.10</span>
<span class="p_del">-Updated for: 4.13 - Copyright 2017 VMware Inc. Steven Rostedt</span>
<span class="p_del">-</span>
<span class="p_del">-Introduction</span>
<span class="p_del">-------------</span>
<span class="p_del">-</span>
<span class="p_del">-Ftrace is an internal tracer designed to help out developers and</span>
<span class="p_del">-designers of systems to find what is going on inside the kernel.</span>
<span class="p_del">-It can be used for debugging or analyzing latencies and</span>
<span class="p_del">-performance issues that take place outside of user-space.</span>
<span class="p_del">-</span>
<span class="p_del">-Although ftrace is typically considered the function tracer, it</span>
<span class="p_del">-is really a frame work of several assorted tracing utilities.</span>
<span class="p_del">-There&#39;s latency tracing to examine what occurs between interrupts</span>
<span class="p_del">-disabled and enabled, as well as for preemption and from a time</span>
<span class="p_del">-a task is woken to the task is actually scheduled in.</span>
<span class="p_del">-</span>
<span class="p_del">-One of the most common uses of ftrace is the event tracing.</span>
<span class="p_del">-Through out the kernel is hundreds of static event points that</span>
<span class="p_del">-can be enabled via the tracefs file system to see what is</span>
<span class="p_del">-going on in certain parts of the kernel.</span>
<span class="p_del">-</span>
<span class="p_del">-See events.txt for more information.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Implementation Details</span>
<span class="p_del">-----------------------</span>
<span class="p_del">-</span>
<span class="p_del">-See ftrace-design.txt for details for arch porters and such.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-The File System</span>
<span class="p_del">----------------</span>
<span class="p_del">-</span>
<span class="p_del">-Ftrace uses the tracefs file system to hold the control files as</span>
<span class="p_del">-well as the files to display output.</span>
<span class="p_del">-</span>
<span class="p_del">-When tracefs is configured into the kernel (which selecting any ftrace</span>
<span class="p_del">-option will do) the directory /sys/kernel/tracing will be created. To mount</span>
<span class="p_del">-this directory, you can add to your /etc/fstab file:</span>
<span class="p_del">-</span>
<span class="p_del">- tracefs       /sys/kernel/tracing       tracefs defaults        0       0</span>
<span class="p_del">-</span>
<span class="p_del">-Or you can mount it at run time with:</span>
<span class="p_del">-</span>
<span class="p_del">- mount -t tracefs nodev /sys/kernel/tracing</span>
<span class="p_del">-</span>
<span class="p_del">-For quicker access to that directory you may want to make a soft link to</span>
<span class="p_del">-it:</span>
<span class="p_del">-</span>
<span class="p_del">- ln -s /sys/kernel/tracing /tracing</span>
<span class="p_del">-</span>
<span class="p_del">-     *** NOTICE ***</span>
<span class="p_del">-</span>
<span class="p_del">-Before 4.1, all ftrace tracing control files were within the debugfs</span>
<span class="p_del">-file system, which is typically located at /sys/kernel/debug/tracing.</span>
<span class="p_del">-For backward compatibility, when mounting the debugfs file system,</span>
<span class="p_del">-the tracefs file system will be automatically mounted at:</span>
<span class="p_del">-</span>
<span class="p_del">- /sys/kernel/debug/tracing</span>
<span class="p_del">-</span>
<span class="p_del">-All files located in the tracefs file system will be located in that</span>
<span class="p_del">-debugfs file system directory as well.</span>
<span class="p_del">-</span>
<span class="p_del">-     *** NOTICE ***</span>
<span class="p_del">-</span>
<span class="p_del">-Any selected ftrace option will also create the tracefs file system.</span>
<span class="p_del">-The rest of the document will assume that you are in the ftrace directory</span>
<span class="p_del">-(cd /sys/kernel/tracing) and will only concentrate on the files within that</span>
<span class="p_del">-directory and not distract from the content with the extended</span>
<span class="p_del">-&quot;/sys/kernel/tracing&quot; path name.</span>
<span class="p_del">-</span>
<span class="p_del">-That&#39;s it! (assuming that you have ftrace configured into your kernel)</span>
<span class="p_del">-</span>
<span class="p_del">-After mounting tracefs you will have access to the control and output files</span>
<span class="p_del">-of ftrace. Here is a list of some of the key files:</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">- Note: all time values are in microseconds.</span>
<span class="p_del">-</span>
<span class="p_del">-  current_tracer:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is used to set or display the current tracer</span>
<span class="p_del">-	that is configured.</span>
<span class="p_del">-</span>
<span class="p_del">-  available_tracers:</span>
<span class="p_del">-</span>
<span class="p_del">-	This holds the different types of tracers that</span>
<span class="p_del">-	have been compiled into the kernel. The</span>
<span class="p_del">-	tracers listed here can be configured by</span>
<span class="p_del">-	echoing their name into current_tracer.</span>
<span class="p_del">-</span>
<span class="p_del">-  tracing_on:</span>
<span class="p_del">-</span>
<span class="p_del">-	This sets or displays whether writing to the trace</span>
<span class="p_del">-	ring buffer is enabled. Echo 0 into this file to disable</span>
<span class="p_del">-	the tracer or 1 to enable it. Note, this only disables</span>
<span class="p_del">-	writing to the ring buffer, the tracing overhead may</span>
<span class="p_del">-	still be occurring.</span>
<span class="p_del">-</span>
<span class="p_del">-	The kernel function tracing_off() can be used within the</span>
<span class="p_del">-	kernel to disable writing to the ring buffer, which will</span>
<span class="p_del">-	set this file to &quot;0&quot;. User space can re-enable tracing by</span>
<span class="p_del">-	echoing &quot;1&quot; into the file.</span>
<span class="p_del">-</span>
<span class="p_del">-	Note, the function and event trigger &quot;traceoff&quot; will also</span>
<span class="p_del">-	set this file to zero and stop tracing. Which can also</span>
<span class="p_del">-	be re-enabled by user space using this file.</span>
<span class="p_del">-</span>
<span class="p_del">-  trace:</span>
<span class="p_del">-</span>
<span class="p_del">-	This file holds the output of the trace in a human</span>
<span class="p_del">-	readable format (described below). Note, tracing is temporarily</span>
<span class="p_del">-	disabled while this file is being read (opened).</span>
<span class="p_del">-</span>
<span class="p_del">-  trace_pipe:</span>
<span class="p_del">-</span>
<span class="p_del">-	The output is the same as the &quot;trace&quot; file but this</span>
<span class="p_del">-	file is meant to be streamed with live tracing.</span>
<span class="p_del">-	Reads from this file will block until new data is</span>
<span class="p_del">-	retrieved.  Unlike the &quot;trace&quot; file, this file is a</span>
<span class="p_del">-	consumer. This means reading from this file causes</span>
<span class="p_del">-	sequential reads to display more current data. Once</span>
<span class="p_del">-	data is read from this file, it is consumed, and</span>
<span class="p_del">-	will not be read again with a sequential read. The</span>
<span class="p_del">-	&quot;trace&quot; file is static, and if the tracer is not</span>
<span class="p_del">-	adding more data, it will display the same</span>
<span class="p_del">-	information every time it is read. This file will not</span>
<span class="p_del">-	disable tracing while being read.</span>
<span class="p_del">-</span>
<span class="p_del">-  trace_options:</span>
<span class="p_del">-</span>
<span class="p_del">-	This file lets the user control the amount of data</span>
<span class="p_del">-	that is displayed in one of the above output</span>
<span class="p_del">-	files. Options also exist to modify how a tracer</span>
<span class="p_del">-	or events work (stack traces, timestamps, etc).</span>
<span class="p_del">-</span>
<span class="p_del">-  options:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is a directory that has a file for every available</span>
<span class="p_del">-	trace option (also in trace_options). Options may also be set</span>
<span class="p_del">-	or cleared by writing a &quot;1&quot; or &quot;0&quot; respectively into the</span>
<span class="p_del">-	corresponding file with the option name.</span>
<span class="p_del">-</span>
<span class="p_del">-  tracing_max_latency:</span>
<span class="p_del">-</span>
<span class="p_del">-	Some of the tracers record the max latency.</span>
<span class="p_del">-	For example, the maximum time that interrupts are disabled.</span>
<span class="p_del">-	The maximum time is saved in this file. The max trace will also be</span>
<span class="p_del">-	stored,	and displayed by &quot;trace&quot;. A new max trace will only be</span>
<span class="p_del">-	recorded if the latency is greater than the value in this file</span>
<span class="p_del">-	(in microseconds).</span>
<span class="p_del">-</span>
<span class="p_del">-	By echoing in a time into this file, no latency will be recorded</span>
<span class="p_del">-	unless it is greater than the time in this file.</span>
<span class="p_del">-</span>
<span class="p_del">-  tracing_thresh:</span>
<span class="p_del">-</span>
<span class="p_del">-	Some latency tracers will record a trace whenever the</span>
<span class="p_del">-	latency is greater than the number in this file.</span>
<span class="p_del">-	Only active when the file contains a number greater than 0.</span>
<span class="p_del">-	(in microseconds)</span>
<span class="p_del">-</span>
<span class="p_del">-  buffer_size_kb:</span>
<span class="p_del">-</span>
<span class="p_del">-	This sets or displays the number of kilobytes each CPU</span>
<span class="p_del">-	buffer holds. By default, the trace buffers are the same size</span>
<span class="p_del">-	for each CPU. The displayed number is the size of the</span>
<span class="p_del">-	CPU buffer and not total size of all buffers. The</span>
<span class="p_del">-	trace buffers are allocated in pages (blocks of memory</span>
<span class="p_del">-	that the kernel uses for allocation, usually 4 KB in size).</span>
<span class="p_del">-	If the last page allocated has room for more bytes</span>
<span class="p_del">-	than requested, the rest of the page will be used,</span>
<span class="p_del">-	making the actual allocation bigger than requested or shown.</span>
<span class="p_del">-	( Note, the size may not be a multiple of the page size</span>
<span class="p_del">-	  due to buffer management meta-data. )</span>
<span class="p_del">-</span>
<span class="p_del">-	Buffer sizes for individual CPUs may vary</span>
<span class="p_del">-	(see &quot;per_cpu/cpu0/buffer_size_kb&quot; below), and if they do</span>
<span class="p_del">-	this file will show &quot;X&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-  buffer_total_size_kb:</span>
<span class="p_del">-</span>
<span class="p_del">-	This displays the total combined size of all the trace buffers.</span>
<span class="p_del">-</span>
<span class="p_del">-  free_buffer:</span>
<span class="p_del">-</span>
<span class="p_del">-	If a process is performing tracing, and the ring buffer	should be</span>
<span class="p_del">-	shrunk &quot;freed&quot; when the process is finished, even if it were to be</span>
<span class="p_del">-	killed by a signal, this file can be used for that purpose. On close</span>
<span class="p_del">-	of this file, the ring buffer will be resized to its minimum size.</span>
<span class="p_del">-	Having a process that is tracing also open this file, when the process</span>
<span class="p_del">-	exits its file descriptor for this file will be closed, and in doing so,</span>
<span class="p_del">-	the ring buffer will be &quot;freed&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-	It may also stop tracing if disable_on_free option is set.</span>
<span class="p_del">-</span>
<span class="p_del">-  tracing_cpumask:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is a mask that lets the user only trace on specified CPUs.</span>
<span class="p_del">-	The format is a hex string representing the CPUs.</span>
<span class="p_del">-</span>
<span class="p_del">-  set_ftrace_filter:</span>
<span class="p_del">-</span>
<span class="p_del">-	When dynamic ftrace is configured in (see the</span>
<span class="p_del">-	section below &quot;dynamic ftrace&quot;), the code is dynamically</span>
<span class="p_del">-	modified (code text rewrite) to disable calling of the</span>
<span class="p_del">-	function profiler (mcount). This lets tracing be configured</span>
<span class="p_del">-	in with practically no overhead in performance.  This also</span>
<span class="p_del">-	has a side effect of enabling or disabling specific functions</span>
<span class="p_del">-	to be traced. Echoing names of functions into this file</span>
<span class="p_del">-	will limit the trace to only those functions.</span>
<span class="p_del">-</span>
<span class="p_del">-	The functions listed in &quot;available_filter_functions&quot; are what</span>
<span class="p_del">-	can be written into this file.</span>
<span class="p_del">-</span>
<span class="p_del">-	This interface also allows for commands to be used. See the</span>
<span class="p_del">-	&quot;Filter commands&quot; section for more details.</span>
<span class="p_del">-</span>
<span class="p_del">-  set_ftrace_notrace:</span>
<span class="p_del">-</span>
<span class="p_del">-	This has an effect opposite to that of</span>
<span class="p_del">-	set_ftrace_filter. Any function that is added here will not</span>
<span class="p_del">-	be traced. If a function exists in both set_ftrace_filter</span>
<span class="p_del">-	and set_ftrace_notrace,	the function will _not_ be traced.</span>
<span class="p_del">-</span>
<span class="p_del">-  set_ftrace_pid:</span>
<span class="p_del">-</span>
<span class="p_del">-	Have the function tracer only trace the threads whose PID are</span>
<span class="p_del">-	listed in this file.</span>
<span class="p_del">-</span>
<span class="p_del">-	If the &quot;function-fork&quot; option is set, then when a task whose</span>
<span class="p_del">-	PID is listed in this file forks, the child&#39;s PID will</span>
<span class="p_del">-	automatically be added to this file, and the child will be</span>
<span class="p_del">-	traced by the function tracer as well. This option will also</span>
<span class="p_del">-	cause PIDs of tasks that exit to be removed from the file.</span>
<span class="p_del">-</span>
<span class="p_del">-  set_event_pid:</span>
<span class="p_del">-</span>
<span class="p_del">-	Have the events only trace a task with a PID listed in this file.</span>
<span class="p_del">-	Note, sched_switch and sched_wake_up will also trace events</span>
<span class="p_del">-	listed in this file.</span>
<span class="p_del">-</span>
<span class="p_del">-	To have the PIDs of children of tasks with their PID in this file</span>
<span class="p_del">-	added on fork, enable the &quot;event-fork&quot; option. That option will also</span>
<span class="p_del">-	cause the PIDs of tasks to be removed from this file when the task</span>
<span class="p_del">-	exits.</span>
<span class="p_del">-</span>
<span class="p_del">-  set_graph_function:</span>
<span class="p_del">-</span>
<span class="p_del">-	Functions listed in this file will cause the function graph</span>
<span class="p_del">-	tracer to only trace these functions and the functions that</span>
<span class="p_del">-	they call. (See the section &quot;dynamic ftrace&quot; for more details).</span>
<span class="p_del">-</span>
<span class="p_del">-  set_graph_notrace:</span>
<span class="p_del">-</span>
<span class="p_del">-	Similar to set_graph_function, but will disable function graph</span>
<span class="p_del">-	tracing when the function is hit until it exits the function.</span>
<span class="p_del">-	This makes it possible to ignore tracing functions that are called</span>
<span class="p_del">-	by a specific function.</span>
<span class="p_del">-</span>
<span class="p_del">-  available_filter_functions:</span>
<span class="p_del">-</span>
<span class="p_del">-	This lists the functions that ftrace has processed and can trace.</span>
<span class="p_del">-	These are the function names that you can pass to</span>
<span class="p_del">-	&quot;set_ftrace_filter&quot; or &quot;set_ftrace_notrace&quot;.</span>
<span class="p_del">-	(See the section &quot;dynamic ftrace&quot; below for more details.)</span>
<span class="p_del">-</span>
<span class="p_del">-  dyn_ftrace_total_info:</span>
<span class="p_del">-</span>
<span class="p_del">-	This file is for debugging purposes. The number of functions that</span>
<span class="p_del">-	have been converted to nops and are available to be traced.</span>
<span class="p_del">-</span>
<span class="p_del">-  enabled_functions:</span>
<span class="p_del">-</span>
<span class="p_del">-	This file is more for debugging ftrace, but can also be useful</span>
<span class="p_del">-	in seeing if any function has a callback attached to it.</span>
<span class="p_del">-	Not only does the trace infrastructure use ftrace function</span>
<span class="p_del">-	trace utility, but other subsystems might too. This file</span>
<span class="p_del">-	displays all functions that have a callback attached to them</span>
<span class="p_del">-	as well as the number of callbacks that have been attached.</span>
<span class="p_del">-	Note, a callback may also call multiple functions which will</span>
<span class="p_del">-	not be listed in this count.</span>
<span class="p_del">-</span>
<span class="p_del">-	If the callback registered to be traced by a function with</span>
<span class="p_del">-	the &quot;save regs&quot; attribute (thus even more overhead), a &#39;R&#39;</span>
<span class="p_del">-	will be displayed on the same line as the function that</span>
<span class="p_del">-	is returning registers.</span>
<span class="p_del">-</span>
<span class="p_del">-	If the callback registered to be traced by a function with</span>
<span class="p_del">-	the &quot;ip modify&quot; attribute (thus the regs-&gt;ip can be changed),</span>
<span class="p_del">-	an &#39;I&#39; will be displayed on the same line as the function that</span>
<span class="p_del">-	can be overridden.</span>
<span class="p_del">-</span>
<span class="p_del">-	If the architecture supports it, it will also show what callback</span>
<span class="p_del">-	is being directly called by the function. If the count is greater</span>
<span class="p_del">-	than 1 it most likely will be ftrace_ops_list_func().</span>
<span class="p_del">-</span>
<span class="p_del">-	If the callback of the function jumps to a trampoline that is</span>
<span class="p_del">-	specific to a the callback and not the standard trampoline,</span>
<span class="p_del">-	its address will be printed as well as the function that the</span>
<span class="p_del">-	trampoline calls.</span>
<span class="p_del">-</span>
<span class="p_del">-  function_profile_enabled:</span>
<span class="p_del">-</span>
<span class="p_del">-	When set it will enable all functions with either the function</span>
<span class="p_del">-	tracer, or if configured, the function graph tracer. It will</span>
<span class="p_del">-	keep a histogram of the number of functions that were called</span>
<span class="p_del">-	and if the function graph tracer was configured, it will also keep</span>
<span class="p_del">-	track of the time spent in those functions. The histogram</span>
<span class="p_del">-	content can be displayed in the files:</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_stats/function&lt;cpu&gt; ( function0, function1, etc).</span>
<span class="p_del">-</span>
<span class="p_del">-  trace_stats:</span>
<span class="p_del">-</span>
<span class="p_del">-	A directory that holds different tracing stats.</span>
<span class="p_del">-</span>
<span class="p_del">-  kprobe_events:</span>
<span class="p_del">- </span>
<span class="p_del">-	Enable dynamic trace points. See kprobetrace.txt.</span>
<span class="p_del">-</span>
<span class="p_del">-  kprobe_profile:</span>
<span class="p_del">-</span>
<span class="p_del">-	Dynamic trace points stats. See kprobetrace.txt.</span>
<span class="p_del">-</span>
<span class="p_del">-  max_graph_depth:</span>
<span class="p_del">-</span>
<span class="p_del">-	Used with the function graph tracer. This is the max depth</span>
<span class="p_del">-	it will trace into a function. Setting this to a value of</span>
<span class="p_del">-	one will show only the first kernel function that is called</span>
<span class="p_del">-	from user space.</span>
<span class="p_del">-</span>
<span class="p_del">-  printk_formats:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is for tools that read the raw format files. If an event in</span>
<span class="p_del">-	the ring buffer references a string, only a pointer to the string</span>
<span class="p_del">-	is recorded into the buffer and not the string itself. This prevents</span>
<span class="p_del">-	tools from knowing what that string was. This file displays the string</span>
<span class="p_del">-	and address for	the string allowing tools to map the pointers to what</span>
<span class="p_del">-	the strings were.</span>
<span class="p_del">-</span>
<span class="p_del">-  saved_cmdlines:</span>
<span class="p_del">-</span>
<span class="p_del">-	Only the pid of the task is recorded in a trace event unless</span>
<span class="p_del">-	the event specifically saves the task comm as well. Ftrace</span>
<span class="p_del">-	makes a cache of pid mappings to comms to try to display</span>
<span class="p_del">-	comms for events. If a pid for a comm is not listed, then</span>
<span class="p_del">-	&quot;&lt;...&gt;&quot; is displayed in the output.</span>
<span class="p_del">-</span>
<span class="p_del">-	If the option &quot;record-cmd&quot; is set to &quot;0&quot;, then comms of tasks</span>
<span class="p_del">-	will not be saved during recording. By default, it is enabled.</span>
<span class="p_del">-</span>
<span class="p_del">-  saved_cmdlines_size:</span>
<span class="p_del">-</span>
<span class="p_del">-	By default, 128 comms are saved (see &quot;saved_cmdlines&quot; above). To</span>
<span class="p_del">-	increase or decrease the amount of comms that are cached, echo</span>
<span class="p_del">-	in a the number of comms to cache, into this file.</span>
<span class="p_del">-</span>
<span class="p_del">-  saved_tgids:</span>
<span class="p_del">-</span>
<span class="p_del">-	If the option &quot;record-tgid&quot; is set, on each scheduling context switch</span>
<span class="p_del">-	the Task Group ID of a task is saved in a table mapping the PID of</span>
<span class="p_del">-	the thread to its TGID. By default, the &quot;record-tgid&quot; option is</span>
<span class="p_del">-	disabled.</span>
<span class="p_del">-</span>
<span class="p_del">-  snapshot:</span>
<span class="p_del">-</span>
<span class="p_del">-	This displays the &quot;snapshot&quot; buffer and also lets the user</span>
<span class="p_del">-	take a snapshot of the current running trace.</span>
<span class="p_del">-	See the &quot;Snapshot&quot; section below for more details.</span>
<span class="p_del">-</span>
<span class="p_del">-  stack_max_size:</span>
<span class="p_del">-</span>
<span class="p_del">-	When the stack tracer is activated, this will display the</span>
<span class="p_del">-	maximum stack size it has encountered.</span>
<span class="p_del">-	See the &quot;Stack Trace&quot; section below.</span>
<span class="p_del">-</span>
<span class="p_del">-  stack_trace:</span>
<span class="p_del">-</span>
<span class="p_del">-	This displays the stack back trace of the largest stack</span>
<span class="p_del">-	that was encountered when the stack tracer is activated.</span>
<span class="p_del">-	See the &quot;Stack Trace&quot; section below.</span>
<span class="p_del">-</span>
<span class="p_del">-  stack_trace_filter:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is similar to &quot;set_ftrace_filter&quot; but it limits what</span>
<span class="p_del">-	functions the stack tracer will check.</span>
<span class="p_del">-</span>
<span class="p_del">-  trace_clock:</span>
<span class="p_del">-</span>
<span class="p_del">-	Whenever an event is recorded into the ring buffer, a</span>
<span class="p_del">-	&quot;timestamp&quot; is added. This stamp comes from a specified</span>
<span class="p_del">-	clock. By default, ftrace uses the &quot;local&quot; clock. This</span>
<span class="p_del">-	clock is very fast and strictly per cpu, but on some</span>
<span class="p_del">-	systems it may not be monotonic with respect to other</span>
<span class="p_del">-	CPUs. In other words, the local clocks may not be in sync</span>
<span class="p_del">-	with local clocks on other CPUs.</span>
<span class="p_del">-</span>
<span class="p_del">-	Usual clocks for tracing:</span>
<span class="p_del">-</span>
<span class="p_del">-	  # cat trace_clock</span>
<span class="p_del">-	  [local] global counter x86-tsc</span>
<span class="p_del">-</span>
<span class="p_del">-	  The clock with the square brackets around it is the one</span>
<span class="p_del">-	  in effect.</span>
<span class="p_del">-</span>
<span class="p_del">-	  local: Default clock, but may not be in sync across CPUs</span>
<span class="p_del">-</span>
<span class="p_del">-	  global: This clock is in sync with all CPUs but may</span>
<span class="p_del">-	  	  be a bit slower than the local clock.</span>
<span class="p_del">-</span>
<span class="p_del">-	  counter: This is not a clock at all, but literally an atomic</span>
<span class="p_del">-	  	   counter. It counts up one by one, but is in sync</span>
<span class="p_del">-		   with all CPUs. This is useful when you need to</span>
<span class="p_del">-		   know exactly the order events occurred with respect to</span>
<span class="p_del">-		   each other on different CPUs.</span>
<span class="p_del">-</span>
<span class="p_del">-	  uptime: This uses the jiffies counter and the time stamp</span>
<span class="p_del">-	  	  is relative to the time since boot up.</span>
<span class="p_del">-</span>
<span class="p_del">-	  perf: This makes ftrace use the same clock that perf uses.</span>
<span class="p_del">-	  	Eventually perf will be able to read ftrace buffers</span>
<span class="p_del">-		and this will help out in interleaving the data.</span>
<span class="p_del">-</span>
<span class="p_del">-	  x86-tsc: Architectures may define their own clocks. For</span>
<span class="p_del">-	  	   example, x86 uses its own TSC cycle clock here.</span>
<span class="p_del">-</span>
<span class="p_del">-	  ppc-tb: This uses the powerpc timebase register value.</span>
<span class="p_del">-		  This is in sync across CPUs and can also be used</span>
<span class="p_del">-		  to correlate events across hypervisor/guest if</span>
<span class="p_del">-		  tb_offset is known.</span>
<span class="p_del">-</span>
<span class="p_del">-	  mono: This uses the fast monotonic clock (CLOCK_MONOTONIC)</span>
<span class="p_del">-		which is monotonic and is subject to NTP rate adjustments.</span>
<span class="p_del">-</span>
<span class="p_del">-	  mono_raw:</span>
<span class="p_del">-		This is the raw monotonic clock (CLOCK_MONOTONIC_RAW)</span>
<span class="p_del">-		which is montonic but is not subject to any rate adjustments</span>
<span class="p_del">-		and ticks at the same rate as the hardware clocksource.</span>
<span class="p_del">-</span>
<span class="p_del">-	  boot: This is the boot clock (CLOCK_BOOTTIME) and is based on the</span>
<span class="p_del">-		fast monotonic clock, but also accounts for time spent in</span>
<span class="p_del">-		suspend. Since the clock access is designed for use in</span>
<span class="p_del">-		tracing in the suspend path, some side effects are possible</span>
<span class="p_del">-		if clock is accessed after the suspend time is accounted before</span>
<span class="p_del">-		the fast mono clock is updated. In this case, the clock update</span>
<span class="p_del">-		appears to happen slightly sooner than it normally would have.</span>
<span class="p_del">-		Also on 32-bit systems, it&#39;s possible that the 64-bit boot offset</span>
<span class="p_del">-		sees a partial update. These effects are rare and post</span>
<span class="p_del">-		processing should be able to handle them. See comments in the</span>
<span class="p_del">-		ktime_get_boot_fast_ns() function for more information.</span>
<span class="p_del">-</span>
<span class="p_del">-	To set a clock, simply echo the clock name into this file.</span>
<span class="p_del">-</span>
<span class="p_del">-	  echo global &gt; trace_clock</span>
<span class="p_del">-</span>
<span class="p_del">-  trace_marker:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is a very useful file for synchronizing user space</span>
<span class="p_del">-	with events happening in the kernel. Writing strings into</span>
<span class="p_del">-	this file will be written into the ftrace buffer.</span>
<span class="p_del">-</span>
<span class="p_del">-	It is useful in applications to open this file at the start</span>
<span class="p_del">-	of the application and just reference the file descriptor</span>
<span class="p_del">-	for the file.</span>
<span class="p_del">-</span>
<span class="p_del">-	void trace_write(const char *fmt, ...)</span>
<span class="p_del">-	{</span>
<span class="p_del">-		va_list ap;</span>
<span class="p_del">-		char buf[256];</span>
<span class="p_del">-		int n;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (trace_fd &lt; 0)</span>
<span class="p_del">-			return;</span>
<span class="p_del">-</span>
<span class="p_del">-		va_start(ap, fmt);</span>
<span class="p_del">-		n = vsnprintf(buf, 256, fmt, ap);</span>
<span class="p_del">-		va_end(ap);</span>
<span class="p_del">-</span>
<span class="p_del">-		write(trace_fd, buf, n);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	start:</span>
<span class="p_del">-</span>
<span class="p_del">-		trace_fd = open(&quot;trace_marker&quot;, WR_ONLY);</span>
<span class="p_del">-</span>
<span class="p_del">-  trace_marker_raw:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is similar to trace_marker above, but is meant for for binary data</span>
<span class="p_del">-	to be written to it, where a tool can be used to parse the data</span>
<span class="p_del">-	from trace_pipe_raw.</span>
<span class="p_del">-</span>
<span class="p_del">-  uprobe_events:</span>
<span class="p_del">- </span>
<span class="p_del">-	Add dynamic tracepoints in programs.</span>
<span class="p_del">-	See uprobetracer.txt</span>
<span class="p_del">-</span>
<span class="p_del">-  uprobe_profile:</span>
<span class="p_del">-</span>
<span class="p_del">-	Uprobe statistics. See uprobetrace.txt</span>
<span class="p_del">-</span>
<span class="p_del">-  instances:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is a way to make multiple trace buffers where different</span>
<span class="p_del">-	events can be recorded in different buffers.</span>
<span class="p_del">-	See &quot;Instances&quot; section below.</span>
<span class="p_del">-</span>
<span class="p_del">-  events:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is the trace event directory. It holds event tracepoints</span>
<span class="p_del">-	(also known as static tracepoints) that have been compiled</span>
<span class="p_del">-	into the kernel. It shows what event tracepoints exist</span>
<span class="p_del">-	and how they are grouped by system. There are &quot;enable&quot;</span>
<span class="p_del">-	files at various levels that can enable the tracepoints</span>
<span class="p_del">-	when a &quot;1&quot; is written to them.</span>
<span class="p_del">-</span>
<span class="p_del">-	See events.txt for more information.</span>
<span class="p_del">-</span>
<span class="p_del">-  set_event:</span>
<span class="p_del">-</span>
<span class="p_del">-	By echoing in the event into this file, will enable that event.</span>
<span class="p_del">-</span>
<span class="p_del">-	See events.txt for more information.</span>
<span class="p_del">-</span>
<span class="p_del">-  available_events:</span>
<span class="p_del">-</span>
<span class="p_del">-	A list of events that can be enabled in tracing.</span>
<span class="p_del">-</span>
<span class="p_del">-	See events.txt for more information.</span>
<span class="p_del">-</span>
<span class="p_del">-  hwlat_detector:</span>
<span class="p_del">-</span>
<span class="p_del">-	Directory for the Hardware Latency Detector.</span>
<span class="p_del">-	See &quot;Hardware Latency Detector&quot; section below.</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is a directory that contains the trace per_cpu information.</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu/cpu0/buffer_size_kb:</span>
<span class="p_del">-</span>
<span class="p_del">-	The ftrace buffer is defined per_cpu. That is, there&#39;s a separate</span>
<span class="p_del">-	buffer for each CPU to allow writes to be done atomically,</span>
<span class="p_del">-	and free from cache bouncing. These buffers may have different</span>
<span class="p_del">-	size buffers. This file is similar to the buffer_size_kb</span>
<span class="p_del">-	file, but it only displays or sets the buffer size for the</span>
<span class="p_del">-	specific CPU. (here cpu0).</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu/cpu0/trace:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is similar to the &quot;trace&quot; file, but it will only display</span>
<span class="p_del">-	the data specific for the CPU. If written to, it only clears</span>
<span class="p_del">-	the specific CPU buffer.</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu/cpu0/trace_pipe</span>
<span class="p_del">-</span>
<span class="p_del">-	This is similar to the &quot;trace_pipe&quot; file, and is a consuming</span>
<span class="p_del">-	read, but it will only display (and consume) the data specific</span>
<span class="p_del">-	for the CPU.</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu/cpu0/trace_pipe_raw</span>
<span class="p_del">-</span>
<span class="p_del">-	For tools that can parse the ftrace ring buffer binary format,</span>
<span class="p_del">-	the trace_pipe_raw file can be used to extract the data</span>
<span class="p_del">-	from the ring buffer directly. With the use of the splice()</span>
<span class="p_del">-	system call, the buffer data can be quickly transferred to</span>
<span class="p_del">-	a file or to the network where a server is collecting the</span>
<span class="p_del">-	data.</span>
<span class="p_del">-</span>
<span class="p_del">-	Like trace_pipe, this is a consuming reader, where multiple</span>
<span class="p_del">-	reads will always produce different data.</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu/cpu0/snapshot:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is similar to the main &quot;snapshot&quot; file, but will only</span>
<span class="p_del">-	snapshot the current CPU (if supported). It only displays</span>
<span class="p_del">-	the content of the snapshot for a given CPU, and if</span>
<span class="p_del">-	written to, only clears this CPU buffer.</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu/cpu0/snapshot_raw:</span>
<span class="p_del">-</span>
<span class="p_del">-	Similar to the trace_pipe_raw, but will read the binary format</span>
<span class="p_del">-	from the snapshot buffer for the given CPU.</span>
<span class="p_del">-</span>
<span class="p_del">-  per_cpu/cpu0/stats:</span>
<span class="p_del">-</span>
<span class="p_del">-	This displays certain stats about the ring buffer:</span>
<span class="p_del">-</span>
<span class="p_del">-	 entries: The number of events that are still in the buffer.</span>
<span class="p_del">-</span>
<span class="p_del">-	 overrun: The number of lost events due to overwriting when</span>
<span class="p_del">-	 	  the buffer was full.</span>
<span class="p_del">-</span>
<span class="p_del">-	 commit overrun: Should always be zero.</span>
<span class="p_del">-	 	This gets set if so many events happened within a nested</span>
<span class="p_del">-		event (ring buffer is re-entrant), that it fills the</span>
<span class="p_del">-		buffer and starts dropping events.</span>
<span class="p_del">-</span>
<span class="p_del">-	 bytes: Bytes actually read (not overwritten).</span>
<span class="p_del">-</span>
<span class="p_del">-	 oldest event ts: The oldest timestamp in the buffer</span>
<span class="p_del">-</span>
<span class="p_del">-	 now ts: The current timestamp</span>
<span class="p_del">-</span>
<span class="p_del">-	 dropped events: Events lost due to overwrite option being off.</span>
<span class="p_del">-</span>
<span class="p_del">-	 read events: The number of events read.</span>
<span class="p_del">-</span>
<span class="p_del">-The Tracers</span>
<span class="p_del">------------</span>
<span class="p_del">-</span>
<span class="p_del">-Here is the list of current tracers that may be configured.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;function&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	Function call tracer to trace all kernel functions.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;function_graph&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	Similar to the function tracer except that the</span>
<span class="p_del">-	function tracer probes the functions on their entry</span>
<span class="p_del">-	whereas the function graph tracer traces on both entry</span>
<span class="p_del">-	and exit of the functions. It then provides the ability</span>
<span class="p_del">-	to draw a graph of function calls similar to C code</span>
<span class="p_del">-	source.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;blk&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	The block tracer. The tracer used by the blktrace user</span>
<span class="p_del">-	application.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;hwlat&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	The Hardware Latency tracer is used to detect if the hardware</span>
<span class="p_del">-	produces any latency. See &quot;Hardware Latency Detector&quot; section</span>
<span class="p_del">-	below.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;irqsoff&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	Traces the areas that disable interrupts and saves</span>
<span class="p_del">-	the trace with the longest max latency.</span>
<span class="p_del">-	See tracing_max_latency. When a new max is recorded,</span>
<span class="p_del">-	it replaces the old trace. It is best to view this</span>
<span class="p_del">-	trace with the latency-format option enabled, which</span>
<span class="p_del">-	happens automatically when the tracer is selected.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;preemptoff&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	Similar to irqsoff but traces and records the amount of</span>
<span class="p_del">-	time for which preemption is disabled.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;preemptirqsoff&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	Similar to irqsoff and preemptoff, but traces and</span>
<span class="p_del">-	records the largest time for which irqs and/or preemption</span>
<span class="p_del">-	is disabled.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;wakeup&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	Traces and records the max latency that it takes for</span>
<span class="p_del">-	the highest priority task to get scheduled after</span>
<span class="p_del">-	it has been woken up.</span>
<span class="p_del">-        Traces all tasks as an average developer would expect.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;wakeup_rt&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-        Traces and records the max latency that it takes for just</span>
<span class="p_del">-        RT tasks (as the current &quot;wakeup&quot; does). This is useful</span>
<span class="p_del">-        for those interested in wake up timings of RT tasks.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;wakeup_dl&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	Traces and records the max latency that it takes for</span>
<span class="p_del">-	a SCHED_DEADLINE task to be woken (as the &quot;wakeup&quot; and</span>
<span class="p_del">-	&quot;wakeup_rt&quot; does).</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;mmiotrace&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	A special tracer that is used to trace binary module.</span>
<span class="p_del">-	It will trace all the calls that a module makes to the</span>
<span class="p_del">-	hardware. Everything it writes and reads from the I/O</span>
<span class="p_del">-	as well.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;branch&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	This tracer can be configured when tracing likely/unlikely</span>
<span class="p_del">-	calls within the kernel. It will trace when a likely and</span>
<span class="p_del">-	unlikely branch is hit and if it was correct in its prediction</span>
<span class="p_del">-	of being correct.</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;nop&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-	This is the &quot;trace nothing&quot; tracer. To remove all</span>
<span class="p_del">-	tracers from tracing simply echo &quot;nop&quot; into</span>
<span class="p_del">-	current_tracer.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Examples of using the tracer</span>
<span class="p_del">-----------------------------</span>
<span class="p_del">-</span>
<span class="p_del">-Here are typical examples of using the tracers when controlling</span>
<span class="p_del">-them only with the tracefs interface (without using any</span>
<span class="p_del">-user-land utilities).</span>
<span class="p_del">-</span>
<span class="p_del">-Output format:</span>
<span class="p_del">---------------</span>
<span class="p_del">-</span>
<span class="p_del">-Here is an example of the output format of the file &quot;trace&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-                             --------</span>
<span class="p_del">-# tracer: function</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 140080/250280   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-            bash-1977  [000] .... 17284.993652: sys_close &lt;-system_call_fastpath</span>
<span class="p_del">-            bash-1977  [000] .... 17284.993653: __close_fd &lt;-sys_close</span>
<span class="p_del">-            bash-1977  [000] .... 17284.993653: _raw_spin_lock &lt;-__close_fd</span>
<span class="p_del">-            sshd-1974  [003] .... 17284.993653: __srcu_read_unlock &lt;-fsnotify</span>
<span class="p_del">-            bash-1977  [000] .... 17284.993654: add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_del">-            bash-1977  [000] ...1 17284.993655: _raw_spin_unlock &lt;-__close_fd</span>
<span class="p_del">-            bash-1977  [000] ...1 17284.993656: sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-            bash-1977  [000] .... 17284.993657: filp_close &lt;-__close_fd</span>
<span class="p_del">-            bash-1977  [000] .... 17284.993657: dnotify_flush &lt;-filp_close</span>
<span class="p_del">-            sshd-1974  [003] .... 17284.993658: sys_select &lt;-system_call_fastpath</span>
<span class="p_del">-                             --------</span>
<span class="p_del">-</span>
<span class="p_del">-A header is printed with the tracer name that is represented by</span>
<span class="p_del">-the trace. In this case the tracer is &quot;function&quot;. Then it shows the</span>
<span class="p_del">-number of events in the buffer as well as the total number of entries</span>
<span class="p_del">-that were written. The difference is the number of entries that were</span>
<span class="p_del">-lost due to the buffer filling up (250280 - 140080 = 110200 events</span>
<span class="p_del">-lost).</span>
<span class="p_del">-</span>
<span class="p_del">-The header explains the content of the events. Task name &quot;bash&quot;, the task</span>
<span class="p_del">-PID &quot;1977&quot;, the CPU that it was running on &quot;000&quot;, the latency format</span>
<span class="p_del">-(explained below), the timestamp in &lt;secs&gt;.&lt;usecs&gt; format, the</span>
<span class="p_del">-function name that was traced &quot;sys_close&quot; and the parent function that</span>
<span class="p_del">-called this function &quot;system_call_fastpath&quot;. The timestamp is the time</span>
<span class="p_del">-at which the function was entered.</span>
<span class="p_del">-</span>
<span class="p_del">-Latency trace format</span>
<span class="p_del">---------------------</span>
<span class="p_del">-</span>
<span class="p_del">-When the latency-format option is enabled or when one of the latency</span>
<span class="p_del">-tracers is set, the trace file gives somewhat more information to see</span>
<span class="p_del">-why a latency happened. Here is a typical trace.</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: irqsoff</span>
<span class="p_del">-#</span>
<span class="p_del">-# irqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 259 us, #4/4, CPU#2 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: ps-6143 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#  =&gt; started at: __lock_task_sighand</span>
<span class="p_del">-#  =&gt; ended at:   _raw_spin_unlock_irqrestore</span>
<span class="p_del">-#</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-      ps-6143    2d...    0us!: trace_hardirqs_off &lt;-__lock_task_sighand</span>
<span class="p_del">-      ps-6143    2d..1  259us+: trace_hardirqs_on &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_del">-      ps-6143    2d..1  263us+: time_hardirqs_on &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_del">-      ps-6143    2d..1  306us : &lt;stack trace&gt;</span>
<span class="p_del">- =&gt; trace_hardirqs_on_caller</span>
<span class="p_del">- =&gt; trace_hardirqs_on</span>
<span class="p_del">- =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_del">- =&gt; do_task_stat</span>
<span class="p_del">- =&gt; proc_tgid_stat</span>
<span class="p_del">- =&gt; proc_single_show</span>
<span class="p_del">- =&gt; seq_read</span>
<span class="p_del">- =&gt; vfs_read</span>
<span class="p_del">- =&gt; sys_read</span>
<span class="p_del">- =&gt; system_call_fastpath</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-This shows that the current tracer is &quot;irqsoff&quot; tracing the time</span>
<span class="p_del">-for which interrupts were disabled. It gives the trace version (which</span>
<span class="p_del">-never changes) and the version of the kernel upon which this was executed on</span>
<span class="p_del">-(3.8). Then it displays the max latency in microseconds (259 us). The number</span>
<span class="p_del">-of trace entries displayed and the total number (both are four: #4/4).</span>
<span class="p_del">-VP, KP, SP, and HP are always zero and are reserved for later use.</span>
<span class="p_del">-#P is the number of online CPUs (#P:4).</span>
<span class="p_del">-</span>
<span class="p_del">-The task is the process that was running when the latency</span>
<span class="p_del">-occurred. (ps pid: 6143).</span>
<span class="p_del">-</span>
<span class="p_del">-The start and stop (the functions in which the interrupts were</span>
<span class="p_del">-disabled and enabled respectively) that caused the latencies:</span>
<span class="p_del">-</span>
<span class="p_del">- __lock_task_sighand is where the interrupts were disabled.</span>
<span class="p_del">- _raw_spin_unlock_irqrestore is where they were enabled again.</span>
<span class="p_del">-</span>
<span class="p_del">-The next lines after the header are the trace itself. The header</span>
<span class="p_del">-explains which is which.</span>
<span class="p_del">-</span>
<span class="p_del">-  cmd: The name of the process in the trace.</span>
<span class="p_del">-</span>
<span class="p_del">-  pid: The PID of that process.</span>
<span class="p_del">-</span>
<span class="p_del">-  CPU#: The CPU which the process was running on.</span>
<span class="p_del">-</span>
<span class="p_del">-  irqs-off: &#39;d&#39; interrupts are disabled. &#39;.&#39; otherwise.</span>
<span class="p_del">-	    Note: If the architecture does not support a way to</span>
<span class="p_del">-		  read the irq flags variable, an &#39;X&#39; will always</span>
<span class="p_del">-		  be printed here.</span>
<span class="p_del">-</span>
<span class="p_del">-  need-resched:</span>
<span class="p_del">-	&#39;N&#39; both TIF_NEED_RESCHED and PREEMPT_NEED_RESCHED is set,</span>
<span class="p_del">-	&#39;n&#39; only TIF_NEED_RESCHED is set,</span>
<span class="p_del">-	&#39;p&#39; only PREEMPT_NEED_RESCHED is set,</span>
<span class="p_del">-	&#39;.&#39; otherwise.</span>
<span class="p_del">-</span>
<span class="p_del">-  hardirq/softirq:</span>
<span class="p_del">-	&#39;Z&#39; - NMI occurred inside a hardirq</span>
<span class="p_del">-	&#39;z&#39; - NMI is running</span>
<span class="p_del">-	&#39;H&#39; - hard irq occurred inside a softirq.</span>
<span class="p_del">-	&#39;h&#39; - hard irq is running</span>
<span class="p_del">-	&#39;s&#39; - soft irq is running</span>
<span class="p_del">-	&#39;.&#39; - normal context.</span>
<span class="p_del">-</span>
<span class="p_del">-  preempt-depth: The level of preempt_disabled</span>
<span class="p_del">-</span>
<span class="p_del">-The above is mostly meaningful for kernel developers.</span>
<span class="p_del">-</span>
<span class="p_del">-  time: When the latency-format option is enabled, the trace file</span>
<span class="p_del">-	output includes a timestamp relative to the start of the</span>
<span class="p_del">-	trace. This differs from the output when latency-format</span>
<span class="p_del">-	is disabled, which includes an absolute timestamp.</span>
<span class="p_del">-</span>
<span class="p_del">-  delay: This is just to help catch your eye a bit better. And</span>
<span class="p_del">-	 needs to be fixed to be only relative to the same CPU.</span>
<span class="p_del">-	 The marks are determined by the difference between this</span>
<span class="p_del">-	 current trace and the next trace.</span>
<span class="p_del">-	  &#39;$&#39; - greater than 1 second</span>
<span class="p_del">-	  &#39;@&#39; - greater than 100 milisecond</span>
<span class="p_del">-	  &#39;*&#39; - greater than 10 milisecond</span>
<span class="p_del">-	  &#39;#&#39; - greater than 1000 microsecond</span>
<span class="p_del">-	  &#39;!&#39; - greater than 100 microsecond</span>
<span class="p_del">-	  &#39;+&#39; - greater than 10 microsecond</span>
<span class="p_del">-	  &#39; &#39; - less than or equal to 10 microsecond.</span>
<span class="p_del">-</span>
<span class="p_del">-  The rest is the same as the &#39;trace&#39; file.</span>
<span class="p_del">-</span>
<span class="p_del">-  Note, the latency tracers will usually end with a back trace</span>
<span class="p_del">-  to easily find where the latency occurred.</span>
<span class="p_del">-</span>
<span class="p_del">-trace_options</span>
<span class="p_del">--------------</span>
<span class="p_del">-</span>
<span class="p_del">-The trace_options file (or the options directory) is used to control</span>
<span class="p_del">-what gets printed in the trace output, or manipulate the tracers.</span>
<span class="p_del">-To see what is available, simply cat the file:</span>
<span class="p_del">-</span>
<span class="p_del">-  cat trace_options</span>
<span class="p_del">-print-parent</span>
<span class="p_del">-nosym-offset</span>
<span class="p_del">-nosym-addr</span>
<span class="p_del">-noverbose</span>
<span class="p_del">-noraw</span>
<span class="p_del">-nohex</span>
<span class="p_del">-nobin</span>
<span class="p_del">-noblock</span>
<span class="p_del">-trace_printk</span>
<span class="p_del">-annotate</span>
<span class="p_del">-nouserstacktrace</span>
<span class="p_del">-nosym-userobj</span>
<span class="p_del">-noprintk-msg-only</span>
<span class="p_del">-context-info</span>
<span class="p_del">-nolatency-format</span>
<span class="p_del">-record-cmd</span>
<span class="p_del">-norecord-tgid</span>
<span class="p_del">-overwrite</span>
<span class="p_del">-nodisable_on_free</span>
<span class="p_del">-irq-info</span>
<span class="p_del">-markers</span>
<span class="p_del">-noevent-fork</span>
<span class="p_del">-function-trace</span>
<span class="p_del">-nofunction-fork</span>
<span class="p_del">-nodisplay-graph</span>
<span class="p_del">-nostacktrace</span>
<span class="p_del">-nobranch</span>
<span class="p_del">-</span>
<span class="p_del">-To disable one of the options, echo in the option prepended with</span>
<span class="p_del">-&quot;no&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-  echo noprint-parent &gt; trace_options</span>
<span class="p_del">-</span>
<span class="p_del">-To enable an option, leave off the &quot;no&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-  echo sym-offset &gt; trace_options</span>
<span class="p_del">-</span>
<span class="p_del">-Here are the available options:</span>
<span class="p_del">-</span>
<span class="p_del">-  print-parent - On function traces, display the calling (parent)</span>
<span class="p_del">-		 function as well as the function being traced.</span>
<span class="p_del">-</span>
<span class="p_del">-  print-parent:</span>
<span class="p_del">-   bash-4000  [01]  1477.606694: simple_strtoul &lt;-kstrtoul</span>
<span class="p_del">-</span>
<span class="p_del">-  noprint-parent:</span>
<span class="p_del">-   bash-4000  [01]  1477.606694: simple_strtoul</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-  sym-offset - Display not only the function name, but also the</span>
<span class="p_del">-	       offset in the function. For example, instead of</span>
<span class="p_del">-	       seeing just &quot;ktime_get&quot;, you will see</span>
<span class="p_del">-	       &quot;ktime_get+0xb/0x20&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-  sym-offset:</span>
<span class="p_del">-   bash-4000  [01]  1477.606694: simple_strtoul+0x6/0xa0</span>
<span class="p_del">-</span>
<span class="p_del">-  sym-addr - this will also display the function address as well</span>
<span class="p_del">-	     as the function name.</span>
<span class="p_del">-</span>
<span class="p_del">-  sym-addr:</span>
<span class="p_del">-   bash-4000  [01]  1477.606694: simple_strtoul &lt;c0339346&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-  verbose - This deals with the trace file when the</span>
<span class="p_del">-            latency-format option is enabled.</span>
<span class="p_del">-</span>
<span class="p_del">-    bash  4000 1 0 00000000 00010a95 [58127d26] 1720.415ms \</span>
<span class="p_del">-    (+0.000ms): simple_strtoul (kstrtoul)</span>
<span class="p_del">-</span>
<span class="p_del">-  raw - This will display raw numbers. This option is best for</span>
<span class="p_del">-	use with user applications that can translate the raw</span>
<span class="p_del">-	numbers better than having it done in the kernel.</span>
<span class="p_del">-</span>
<span class="p_del">-  hex - Similar to raw, but the numbers will be in a hexadecimal</span>
<span class="p_del">-	format.</span>
<span class="p_del">-</span>
<span class="p_del">-  bin - This will print out the formats in raw binary.</span>
<span class="p_del">-</span>
<span class="p_del">-  block - When set, reading trace_pipe will not block when polled.</span>
<span class="p_del">-</span>
<span class="p_del">-  trace_printk - Can disable trace_printk() from writing into the buffer.</span>
<span class="p_del">-</span>
<span class="p_del">-  annotate - It is sometimes confusing when the CPU buffers are full</span>
<span class="p_del">-  	     and one CPU buffer had a lot of events recently, thus</span>
<span class="p_del">-	     a shorter time frame, were another CPU may have only had</span>
<span class="p_del">-	     a few events, which lets it have older events. When</span>
<span class="p_del">-	     the trace is reported, it shows the oldest events first,</span>
<span class="p_del">-	     and it may look like only one CPU ran (the one with the</span>
<span class="p_del">-	     oldest events). When the annotate option is set, it will</span>
<span class="p_del">-	     display when a new CPU buffer started:</span>
<span class="p_del">-</span>
<span class="p_del">-          &lt;idle&gt;-0     [001] dNs4 21169.031481: wake_up_idle_cpu &lt;-add_timer_on</span>
<span class="p_del">-          &lt;idle&gt;-0     [001] dNs4 21169.031482: _raw_spin_unlock_irqrestore &lt;-add_timer_on</span>
<span class="p_del">-          &lt;idle&gt;-0     [001] .Ns4 21169.031484: sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_del">-##### CPU 2 buffer started ####</span>
<span class="p_del">-          &lt;idle&gt;-0     [002] .N.1 21169.031484: rcu_idle_exit &lt;-cpu_idle</span>
<span class="p_del">-          &lt;idle&gt;-0     [001] .Ns3 21169.031484: _raw_spin_unlock &lt;-clocksource_watchdog</span>
<span class="p_del">-          &lt;idle&gt;-0     [001] .Ns3 21169.031485: sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-</span>
<span class="p_del">-  userstacktrace - This option changes the trace. It records a</span>
<span class="p_del">-		   stacktrace of the current user space thread after</span>
<span class="p_del">-		   each trace event.</span>
<span class="p_del">-</span>
<span class="p_del">-  sym-userobj - when user stacktrace are enabled, look up which</span>
<span class="p_del">-		object the address belongs to, and print a</span>
<span class="p_del">-		relative address. This is especially useful when</span>
<span class="p_del">-		ASLR is on, otherwise you don&#39;t get a chance to</span>
<span class="p_del">-		resolve the address to object/file/line after</span>
<span class="p_del">-		the app is no longer running</span>
<span class="p_del">-</span>
<span class="p_del">-		The lookup is performed when you read</span>
<span class="p_del">-		trace,trace_pipe. Example:</span>
<span class="p_del">-</span>
<span class="p_del">-		a.out-1623  [000] 40874.465068: /root/a.out[+0x480] &lt;-/root/a.out[+0</span>
<span class="p_del">-x494] &lt;- /root/a.out[+0x4a8] &lt;- /lib/libc-2.7.so[+0x1e1a6]</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-  printk-msg-only - When set, trace_printk()s will only show the format</span>
<span class="p_del">-  		    and not their parameters (if trace_bprintk() or</span>
<span class="p_del">-		    trace_bputs() was used to save the trace_printk()).</span>
<span class="p_del">-</span>
<span class="p_del">-  context-info - Show only the event data. Hides the comm, PID,</span>
<span class="p_del">-  	         timestamp, CPU, and other useful data.</span>
<span class="p_del">-</span>
<span class="p_del">-  latency-format - This option changes the trace output. When it is enabled,</span>
<span class="p_del">-		   the trace displays additional information about the</span>
<span class="p_del">-		   latency, as described in &quot;Latency trace format&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-  record-cmd - When any event or tracer is enabled, a hook is enabled</span>
<span class="p_del">-	       in the sched_switch trace point to fill comm cache</span>
<span class="p_del">-	       with mapped pids and comms. But this may cause some</span>
<span class="p_del">-	       overhead, and if you only care about pids, and not the</span>
<span class="p_del">-	       name of the task, disabling this option can lower the</span>
<span class="p_del">-	       impact of tracing. See &quot;saved_cmdlines&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-  record-tgid - When any event or tracer is enabled, a hook is enabled</span>
<span class="p_del">-	        in the sched_switch trace point to fill the cache of</span>
<span class="p_del">-		mapped Thread Group IDs (TGID) mapping to pids. See</span>
<span class="p_del">-		&quot;saved_tgids&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-  overwrite - This controls what happens when the trace buffer is</span>
<span class="p_del">-              full. If &quot;1&quot; (default), the oldest events are</span>
<span class="p_del">-              discarded and overwritten. If &quot;0&quot;, then the newest</span>
<span class="p_del">-              events are discarded.</span>
<span class="p_del">-	        (see per_cpu/cpu0/stats for overrun and dropped)</span>
<span class="p_del">-</span>
<span class="p_del">-  disable_on_free - When the free_buffer is closed, tracing will</span>
<span class="p_del">-  		    stop (tracing_on set to 0).</span>
<span class="p_del">-</span>
<span class="p_del">-  irq-info - Shows the interrupt, preempt count, need resched data.</span>
<span class="p_del">-  	     When disabled, the trace looks like:</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: function</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 144405/9452052   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#           TASK-PID   CPU#      TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |          |         |</span>
<span class="p_del">-          &lt;idle&gt;-0     [002]  23636.756054: ttwu_do_activate.constprop.89 &lt;-try_to_wake_up</span>
<span class="p_del">-          &lt;idle&gt;-0     [002]  23636.756054: activate_task &lt;-ttwu_do_activate.constprop.89</span>
<span class="p_del">-          &lt;idle&gt;-0     [002]  23636.756055: enqueue_task &lt;-activate_task</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-  markers - When set, the trace_marker is writable (only by root).</span>
<span class="p_del">-  	    When disabled, the trace_marker will error with EINVAL</span>
<span class="p_del">-	    on write.</span>
<span class="p_del">-</span>
<span class="p_del">-  event-fork - When set, tasks with PIDs listed in set_event_pid will have</span>
<span class="p_del">-	       the PIDs of their children added to set_event_pid when those</span>
<span class="p_del">-	       tasks fork. Also, when tasks with PIDs in set_event_pid exit,</span>
<span class="p_del">-	       their PIDs will be removed from the file.</span>
<span class="p_del">-</span>
<span class="p_del">-  function-trace - The latency tracers will enable function tracing</span>
<span class="p_del">-  	    if this option is enabled (default it is). When</span>
<span class="p_del">-	    it is disabled, the latency tracers do not trace</span>
<span class="p_del">-	    functions. This keeps the overhead of the tracer down</span>
<span class="p_del">-	    when performing latency tests.</span>
<span class="p_del">-</span>
<span class="p_del">-  function-fork - When set, tasks with PIDs listed in set_ftrace_pid will</span>
<span class="p_del">-		  have the PIDs of their children added to set_ftrace_pid</span>
<span class="p_del">-		  when those tasks fork. Also, when tasks with PIDs in</span>
<span class="p_del">-		  set_ftrace_pid exit, their PIDs will be removed from the</span>
<span class="p_del">-		  file.</span>
<span class="p_del">-</span>
<span class="p_del">-  display-graph - When set, the latency tracers (irqsoff, wakeup, etc) will</span>
<span class="p_del">-	          use function graph tracing instead of function tracing.</span>
<span class="p_del">-</span>
<span class="p_del">-  stacktrace - When set, a stack trace is recorded after any trace event</span>
<span class="p_del">-	       is recorded.</span>
<span class="p_del">-</span>
<span class="p_del">-  branch - Enable branch tracing with the tracer. This enables branch</span>
<span class="p_del">-	   tracer along with the currently set tracer. Enabling this</span>
<span class="p_del">-	   with the &quot;nop&quot; tracer is the same as just enabling the</span>
<span class="p_del">-	   &quot;branch&quot; tracer.</span>
<span class="p_del">-</span>
<span class="p_del">- Note: Some tracers have their own options. They only appear in this</span>
<span class="p_del">-       file when the tracer is active. They always appear in the</span>
<span class="p_del">-       options directory.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Here are the per tracer options:</span>
<span class="p_del">-</span>
<span class="p_del">-Options for function tracer:</span>
<span class="p_del">-</span>
<span class="p_del">-  func_stack_trace - When set, a stack trace is recorded after every</span>
<span class="p_del">-		     function that is recorded. NOTE! Limit the functions</span>
<span class="p_del">-		     that are recorded before enabling this, with</span>
<span class="p_del">-		     &quot;set_ftrace_filter&quot; otherwise the system performance</span>
<span class="p_del">-		     will be critically degraded. Remember to disable</span>
<span class="p_del">-		     this option before clearing the function filter.</span>
<span class="p_del">-</span>
<span class="p_del">-Options for function_graph tracer:</span>
<span class="p_del">-</span>
<span class="p_del">- Since the function_graph tracer has a slightly different output</span>
<span class="p_del">- it has its own options to control what is displayed.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-overrun - When set, the &quot;overrun&quot; of the graph stack is</span>
<span class="p_del">-		      displayed after each function traced. The</span>
<span class="p_del">-		      overrun, is when the stack depth of the calls</span>
<span class="p_del">-		      is greater than what is reserved for each task.</span>
<span class="p_del">-		      Each task has a fixed array of functions to</span>
<span class="p_del">-		      trace in the call graph. If the depth of the</span>
<span class="p_del">-		      calls exceeds that, the function is not traced.</span>
<span class="p_del">-		      The overrun is the number of functions missed</span>
<span class="p_del">-		      due to exceeding this array.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-cpu - When set, the CPU number of the CPU where the trace</span>
<span class="p_del">-		  occurred is displayed.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-overhead - When set, if the function takes longer than</span>
<span class="p_del">-		       A certain amount, then a delay marker is</span>
<span class="p_del">-		       displayed. See &quot;delay&quot; above, under the</span>
<span class="p_del">-		       header description.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-proc - Unlike other tracers, the process&#39; command line</span>
<span class="p_del">-		   is not displayed by default, but instead only</span>
<span class="p_del">-		   when a task is traced in and out during a context</span>
<span class="p_del">-		   switch. Enabling this options has the command</span>
<span class="p_del">-		   of each process displayed at every line.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-duration - At the end of each function (the return)</span>
<span class="p_del">-		       the duration of the amount of time in the</span>
<span class="p_del">-		       function is displayed in microseconds.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-abstime - When set, the timestamp is displayed at each</span>
<span class="p_del">-		      line.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-irqs - When disabled, functions that happen inside an</span>
<span class="p_del">-		   interrupt will not be traced.</span>
<span class="p_del">-</span>
<span class="p_del">-  funcgraph-tail - When set, the return event will include the function</span>
<span class="p_del">-		   that it represents. By default this is off, and</span>
<span class="p_del">-		   only a closing curly bracket &quot;}&quot; is displayed for</span>
<span class="p_del">-		   the return of a function.</span>
<span class="p_del">-</span>
<span class="p_del">-  sleep-time - When running function graph tracer, to include</span>
<span class="p_del">-	       the time a task schedules out in its function.</span>
<span class="p_del">-	       When enabled, it will account time the task has been</span>
<span class="p_del">-	       scheduled out as part of the function call.</span>
<span class="p_del">-</span>
<span class="p_del">-  graph-time - When running function profiler with function graph tracer,</span>
<span class="p_del">-	       to include the time to call nested functions. When this is</span>
<span class="p_del">-	       not set, the time reported for the function will only</span>
<span class="p_del">-	       include the time the function itself executed for, not the</span>
<span class="p_del">-	       time for functions that it called.</span>
<span class="p_del">-</span>
<span class="p_del">-Options for blk tracer:</span>
<span class="p_del">-</span>
<span class="p_del">-  blk_classic - Shows a more minimalistic output.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-irqsoff</span>
<span class="p_del">--------</span>
<span class="p_del">-</span>
<span class="p_del">-When interrupts are disabled, the CPU can not react to any other</span>
<span class="p_del">-external event (besides NMIs and SMIs). This prevents the timer</span>
<span class="p_del">-interrupt from triggering or the mouse interrupt from letting</span>
<span class="p_del">-the kernel know of a new mouse event. The result is a latency</span>
<span class="p_del">-with the reaction time.</span>
<span class="p_del">-</span>
<span class="p_del">-The irqsoff tracer tracks the time for which interrupts are</span>
<span class="p_del">-disabled. When a new maximum latency is hit, the tracer saves</span>
<span class="p_del">-the trace leading up to that latency point so that every time a</span>
<span class="p_del">-new maximum is reached, the old saved trace is discarded and the</span>
<span class="p_del">-new trace is saved.</span>
<span class="p_del">-</span>
<span class="p_del">-To reset the maximum, echo 0 into tracing_max_latency. Here is</span>
<span class="p_del">-an example:</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 0 &gt; options/function-trace</span>
<span class="p_del">- # echo irqsoff &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # echo 0 &gt; tracing_max_latency</span>
<span class="p_del">- # ls -ltr</span>
<span class="p_del">- [...]</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: irqsoff</span>
<span class="p_del">-#</span>
<span class="p_del">-# irqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 16 us, #4/4, CPU#0 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: swapper/0-0 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#  =&gt; started at: run_timer_softirq</span>
<span class="p_del">-#  =&gt; ended at:   run_timer_softirq</span>
<span class="p_del">-#</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-  &lt;idle&gt;-0       0d.s2    0us+: _raw_spin_lock_irq &lt;-run_timer_softirq</span>
<span class="p_del">-  &lt;idle&gt;-0       0dNs3   17us : _raw_spin_unlock_irq &lt;-run_timer_softirq</span>
<span class="p_del">-  &lt;idle&gt;-0       0dNs3   17us+: trace_hardirqs_on &lt;-run_timer_softirq</span>
<span class="p_del">-  &lt;idle&gt;-0       0dNs3   25us : &lt;stack trace&gt;</span>
<span class="p_del">- =&gt; _raw_spin_unlock_irq</span>
<span class="p_del">- =&gt; run_timer_softirq</span>
<span class="p_del">- =&gt; __do_softirq</span>
<span class="p_del">- =&gt; call_softirq</span>
<span class="p_del">- =&gt; do_softirq</span>
<span class="p_del">- =&gt; irq_exit</span>
<span class="p_del">- =&gt; smp_apic_timer_interrupt</span>
<span class="p_del">- =&gt; apic_timer_interrupt</span>
<span class="p_del">- =&gt; rcu_idle_exit</span>
<span class="p_del">- =&gt; cpu_idle</span>
<span class="p_del">- =&gt; rest_init</span>
<span class="p_del">- =&gt; start_kernel</span>
<span class="p_del">- =&gt; x86_64_start_reservations</span>
<span class="p_del">- =&gt; x86_64_start_kernel</span>
<span class="p_del">-</span>
<span class="p_del">-Here we see that that we had a latency of 16 microseconds (which is</span>
<span class="p_del">-very good). The _raw_spin_lock_irq in run_timer_softirq disabled</span>
<span class="p_del">-interrupts. The difference between the 16 and the displayed</span>
<span class="p_del">-timestamp 25us occurred because the clock was incremented</span>
<span class="p_del">-between the time of recording the max latency and the time of</span>
<span class="p_del">-recording the function that had that latency.</span>
<span class="p_del">-</span>
<span class="p_del">-Note the above example had function-trace not set. If we set</span>
<span class="p_del">-function-trace, we get a much larger output:</span>
<span class="p_del">-</span>
<span class="p_del">- with echo 1 &gt; options/function-trace</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: irqsoff</span>
<span class="p_del">-#</span>
<span class="p_del">-# irqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 71 us, #168/168, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: bash-2042 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#  =&gt; started at: ata_scsi_queuecmd</span>
<span class="p_del">-#  =&gt; ended at:   ata_scsi_queuecmd</span>
<span class="p_del">-#</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-    bash-2042    3d...    0us : _raw_spin_lock_irqsave &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d...    0us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_del">-    bash-2042    3d..1    1us : ata_scsi_find_dev &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d..1    1us : __ata_scsi_find_dev &lt;-ata_scsi_find_dev</span>
<span class="p_del">-    bash-2042    3d..1    2us : ata_find_dev.part.14 &lt;-__ata_scsi_find_dev</span>
<span class="p_del">-    bash-2042    3d..1    2us : ata_qc_new_init &lt;-__ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d..1    3us : ata_sg_init &lt;-__ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d..1    4us : ata_scsi_rw_xlat &lt;-__ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d..1    4us : ata_build_rw_tf &lt;-ata_scsi_rw_xlat</span>
<span class="p_del">-[...]</span>
<span class="p_del">-    bash-2042    3d..1   67us : delay_tsc &lt;-__delay</span>
<span class="p_del">-    bash-2042    3d..1   67us : add_preempt_count &lt;-delay_tsc</span>
<span class="p_del">-    bash-2042    3d..2   67us : sub_preempt_count &lt;-delay_tsc</span>
<span class="p_del">-    bash-2042    3d..1   67us : add_preempt_count &lt;-delay_tsc</span>
<span class="p_del">-    bash-2042    3d..2   68us : sub_preempt_count &lt;-delay_tsc</span>
<span class="p_del">-    bash-2042    3d..1   68us+: ata_bmdma_start &lt;-ata_bmdma_qc_issue</span>
<span class="p_del">-    bash-2042    3d..1   71us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d..1   71us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d..1   72us+: trace_hardirqs_on &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-    bash-2042    3d..1  120us : &lt;stack trace&gt;</span>
<span class="p_del">- =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_del">- =&gt; ata_scsi_queuecmd</span>
<span class="p_del">- =&gt; scsi_dispatch_cmd</span>
<span class="p_del">- =&gt; scsi_request_fn</span>
<span class="p_del">- =&gt; __blk_run_queue_uncond</span>
<span class="p_del">- =&gt; __blk_run_queue</span>
<span class="p_del">- =&gt; blk_queue_bio</span>
<span class="p_del">- =&gt; generic_make_request</span>
<span class="p_del">- =&gt; submit_bio</span>
<span class="p_del">- =&gt; submit_bh</span>
<span class="p_del">- =&gt; __ext3_get_inode_loc</span>
<span class="p_del">- =&gt; ext3_iget</span>
<span class="p_del">- =&gt; ext3_lookup</span>
<span class="p_del">- =&gt; lookup_real</span>
<span class="p_del">- =&gt; __lookup_hash</span>
<span class="p_del">- =&gt; walk_component</span>
<span class="p_del">- =&gt; lookup_last</span>
<span class="p_del">- =&gt; path_lookupat</span>
<span class="p_del">- =&gt; filename_lookup</span>
<span class="p_del">- =&gt; user_path_at_empty</span>
<span class="p_del">- =&gt; user_path_at</span>
<span class="p_del">- =&gt; vfs_fstatat</span>
<span class="p_del">- =&gt; vfs_stat</span>
<span class="p_del">- =&gt; sys_newstat</span>
<span class="p_del">- =&gt; system_call_fastpath</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Here we traced a 71 microsecond latency. But we also see all the</span>
<span class="p_del">-functions that were called during that time. Note that by</span>
<span class="p_del">-enabling function tracing, we incur an added overhead. This</span>
<span class="p_del">-overhead may extend the latency times. But nevertheless, this</span>
<span class="p_del">-trace has provided some very helpful debugging information.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-preemptoff</span>
<span class="p_del">-----------</span>
<span class="p_del">-</span>
<span class="p_del">-When preemption is disabled, we may be able to receive</span>
<span class="p_del">-interrupts but the task cannot be preempted and a higher</span>
<span class="p_del">-priority task must wait for preemption to be enabled again</span>
<span class="p_del">-before it can preempt a lower priority task.</span>
<span class="p_del">-</span>
<span class="p_del">-The preemptoff tracer traces the places that disable preemption.</span>
<span class="p_del">-Like the irqsoff tracer, it records the maximum latency for</span>
<span class="p_del">-which preemption was disabled. The control of preemptoff tracer</span>
<span class="p_del">-is much like the irqsoff tracer.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 0 &gt; options/function-trace</span>
<span class="p_del">- # echo preemptoff &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # echo 0 &gt; tracing_max_latency</span>
<span class="p_del">- # ls -ltr</span>
<span class="p_del">- [...]</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: preemptoff</span>
<span class="p_del">-#</span>
<span class="p_del">-# preemptoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 46 us, #4/4, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: sshd-1991 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#  =&gt; started at: do_IRQ</span>
<span class="p_del">-#  =&gt; ended at:   do_IRQ</span>
<span class="p_del">-#</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-    sshd-1991    1d.h.    0us+: irq_enter &lt;-do_IRQ</span>
<span class="p_del">-    sshd-1991    1d..1   46us : irq_exit &lt;-do_IRQ</span>
<span class="p_del">-    sshd-1991    1d..1   47us+: trace_preempt_on &lt;-do_IRQ</span>
<span class="p_del">-    sshd-1991    1d..1   52us : &lt;stack trace&gt;</span>
<span class="p_del">- =&gt; sub_preempt_count</span>
<span class="p_del">- =&gt; irq_exit</span>
<span class="p_del">- =&gt; do_IRQ</span>
<span class="p_del">- =&gt; ret_from_intr</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-This has some more changes. Preemption was disabled when an</span>
<span class="p_del">-interrupt came in (notice the &#39;h&#39;), and was enabled on exit.</span>
<span class="p_del">-But we also see that interrupts have been disabled when entering</span>
<span class="p_del">-the preempt off section and leaving it (the &#39;d&#39;). We do not know if</span>
<span class="p_del">-interrupts were enabled in the mean time or shortly after this</span>
<span class="p_del">-was over.</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: preemptoff</span>
<span class="p_del">-#</span>
<span class="p_del">-# preemptoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 83 us, #241/241, CPU#1 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: bash-1994 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#  =&gt; started at: wake_up_new_task</span>
<span class="p_del">-#  =&gt; ended at:   task_rq_unlock</span>
<span class="p_del">-#</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-    bash-1994    1d..1    0us : _raw_spin_lock_irqsave &lt;-wake_up_new_task</span>
<span class="p_del">-    bash-1994    1d..1    0us : select_task_rq_fair &lt;-select_task_rq</span>
<span class="p_del">-    bash-1994    1d..1    1us : __rcu_read_lock &lt;-select_task_rq_fair</span>
<span class="p_del">-    bash-1994    1d..1    1us : source_load &lt;-select_task_rq_fair</span>
<span class="p_del">-    bash-1994    1d..1    1us : source_load &lt;-select_task_rq_fair</span>
<span class="p_del">-[...]</span>
<span class="p_del">-    bash-1994    1d..1   12us : irq_enter &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-    bash-1994    1d..1   12us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_del">-    bash-1994    1d..1   13us : add_preempt_count &lt;-irq_enter</span>
<span class="p_del">-    bash-1994    1d.h1   13us : exit_idle &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-    bash-1994    1d.h1   13us : hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-    bash-1994    1d.h1   13us : _raw_spin_lock &lt;-hrtimer_interrupt</span>
<span class="p_del">-    bash-1994    1d.h1   14us : add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_del">-    bash-1994    1d.h2   14us : ktime_get_update_offsets &lt;-hrtimer_interrupt</span>
<span class="p_del">-[...]</span>
<span class="p_del">-    bash-1994    1d.h1   35us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_del">-    bash-1994    1d.h1   35us : irq_exit &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-    bash-1994    1d.h1   36us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_del">-    bash-1994    1d..2   36us : do_softirq &lt;-irq_exit</span>
<span class="p_del">-    bash-1994    1d..2   36us : __do_softirq &lt;-call_softirq</span>
<span class="p_del">-    bash-1994    1d..2   36us : __local_bh_disable &lt;-__do_softirq</span>
<span class="p_del">-    bash-1994    1d.s2   37us : add_preempt_count &lt;-_raw_spin_lock_irq</span>
<span class="p_del">-    bash-1994    1d.s3   38us : _raw_spin_unlock &lt;-run_timer_softirq</span>
<span class="p_del">-    bash-1994    1d.s3   39us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-    bash-1994    1d.s2   39us : call_timer_fn &lt;-run_timer_softirq</span>
<span class="p_del">-[...]</span>
<span class="p_del">-    bash-1994    1dNs2   81us : cpu_needs_another_gp &lt;-rcu_process_callbacks</span>
<span class="p_del">-    bash-1994    1dNs2   82us : __local_bh_enable &lt;-__do_softirq</span>
<span class="p_del">-    bash-1994    1dNs2   82us : sub_preempt_count &lt;-__local_bh_enable</span>
<span class="p_del">-    bash-1994    1dN.2   82us : idle_cpu &lt;-irq_exit</span>
<span class="p_del">-    bash-1994    1dN.2   83us : rcu_irq_exit &lt;-irq_exit</span>
<span class="p_del">-    bash-1994    1dN.2   83us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_del">-    bash-1994    1.N.1   84us : _raw_spin_unlock_irqrestore &lt;-task_rq_unlock</span>
<span class="p_del">-    bash-1994    1.N.1   84us+: trace_preempt_on &lt;-task_rq_unlock</span>
<span class="p_del">-    bash-1994    1.N.1  104us : &lt;stack trace&gt;</span>
<span class="p_del">- =&gt; sub_preempt_count</span>
<span class="p_del">- =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_del">- =&gt; task_rq_unlock</span>
<span class="p_del">- =&gt; wake_up_new_task</span>
<span class="p_del">- =&gt; do_fork</span>
<span class="p_del">- =&gt; sys_clone</span>
<span class="p_del">- =&gt; stub_clone</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-The above is an example of the preemptoff trace with</span>
<span class="p_del">-function-trace set. Here we see that interrupts were not disabled</span>
<span class="p_del">-the entire time. The irq_enter code lets us know that we entered</span>
<span class="p_del">-an interrupt &#39;h&#39;. Before that, the functions being traced still</span>
<span class="p_del">-show that it is not in an interrupt, but we can see from the</span>
<span class="p_del">-functions themselves that this is not the case.</span>
<span class="p_del">-</span>
<span class="p_del">-preemptirqsoff</span>
<span class="p_del">---------------</span>
<span class="p_del">-</span>
<span class="p_del">-Knowing the locations that have interrupts disabled or</span>
<span class="p_del">-preemption disabled for the longest times is helpful. But</span>
<span class="p_del">-sometimes we would like to know when either preemption and/or</span>
<span class="p_del">-interrupts are disabled.</span>
<span class="p_del">-</span>
<span class="p_del">-Consider the following code:</span>
<span class="p_del">-</span>
<span class="p_del">-    local_irq_disable();</span>
<span class="p_del">-    call_function_with_irqs_off();</span>
<span class="p_del">-    preempt_disable();</span>
<span class="p_del">-    call_function_with_irqs_and_preemption_off();</span>
<span class="p_del">-    local_irq_enable();</span>
<span class="p_del">-    call_function_with_preemption_off();</span>
<span class="p_del">-    preempt_enable();</span>
<span class="p_del">-</span>
<span class="p_del">-The irqsoff tracer will record the total length of</span>
<span class="p_del">-call_function_with_irqs_off() and</span>
<span class="p_del">-call_function_with_irqs_and_preemption_off().</span>
<span class="p_del">-</span>
<span class="p_del">-The preemptoff tracer will record the total length of</span>
<span class="p_del">-call_function_with_irqs_and_preemption_off() and</span>
<span class="p_del">-call_function_with_preemption_off().</span>
<span class="p_del">-</span>
<span class="p_del">-But neither will trace the time that interrupts and/or</span>
<span class="p_del">-preemption is disabled. This total time is the time that we can</span>
<span class="p_del">-not schedule. To record this time, use the preemptirqsoff</span>
<span class="p_del">-tracer.</span>
<span class="p_del">-</span>
<span class="p_del">-Again, using this trace is much like the irqsoff and preemptoff</span>
<span class="p_del">-tracers.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 0 &gt; options/function-trace</span>
<span class="p_del">- # echo preemptirqsoff &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # echo 0 &gt; tracing_max_latency</span>
<span class="p_del">- # ls -ltr</span>
<span class="p_del">- [...]</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: preemptirqsoff</span>
<span class="p_del">-#</span>
<span class="p_del">-# preemptirqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 100 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: ls-2230 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#  =&gt; started at: ata_scsi_queuecmd</span>
<span class="p_del">-#  =&gt; ended at:   ata_scsi_queuecmd</span>
<span class="p_del">-#</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-      ls-2230    3d...    0us+: _raw_spin_lock_irqsave &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-      ls-2230    3...1  100us : _raw_spin_unlock_irqrestore &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-      ls-2230    3...1  101us+: trace_preempt_on &lt;-ata_scsi_queuecmd</span>
<span class="p_del">-      ls-2230    3...1  111us : &lt;stack trace&gt;</span>
<span class="p_del">- =&gt; sub_preempt_count</span>
<span class="p_del">- =&gt; _raw_spin_unlock_irqrestore</span>
<span class="p_del">- =&gt; ata_scsi_queuecmd</span>
<span class="p_del">- =&gt; scsi_dispatch_cmd</span>
<span class="p_del">- =&gt; scsi_request_fn</span>
<span class="p_del">- =&gt; __blk_run_queue_uncond</span>
<span class="p_del">- =&gt; __blk_run_queue</span>
<span class="p_del">- =&gt; blk_queue_bio</span>
<span class="p_del">- =&gt; generic_make_request</span>
<span class="p_del">- =&gt; submit_bio</span>
<span class="p_del">- =&gt; submit_bh</span>
<span class="p_del">- =&gt; ext3_bread</span>
<span class="p_del">- =&gt; ext3_dir_bread</span>
<span class="p_del">- =&gt; htree_dirblock_to_tree</span>
<span class="p_del">- =&gt; ext3_htree_fill_tree</span>
<span class="p_del">- =&gt; ext3_readdir</span>
<span class="p_del">- =&gt; vfs_readdir</span>
<span class="p_del">- =&gt; sys_getdents</span>
<span class="p_del">- =&gt; system_call_fastpath</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-The trace_hardirqs_off_thunk is called from assembly on x86 when</span>
<span class="p_del">-interrupts are disabled in the assembly code. Without the</span>
<span class="p_del">-function tracing, we do not know if interrupts were enabled</span>
<span class="p_del">-within the preemption points. We do see that it started with</span>
<span class="p_del">-preemption enabled.</span>
<span class="p_del">-</span>
<span class="p_del">-Here is a trace with function-trace set:</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: preemptirqsoff</span>
<span class="p_del">-#</span>
<span class="p_del">-# preemptirqsoff latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 161 us, #339/339, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: ls-2269 (uid:0 nice:0 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#  =&gt; started at: schedule</span>
<span class="p_del">-#  =&gt; ended at:   mutex_unlock</span>
<span class="p_del">-#</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-kworker/-59      3...1    0us : __schedule &lt;-schedule</span>
<span class="p_del">-kworker/-59      3d..1    0us : rcu_preempt_qs &lt;-rcu_note_context_switch</span>
<span class="p_del">-kworker/-59      3d..1    1us : add_preempt_count &lt;-_raw_spin_lock_irq</span>
<span class="p_del">-kworker/-59      3d..2    1us : deactivate_task &lt;-__schedule</span>
<span class="p_del">-kworker/-59      3d..2    1us : dequeue_task &lt;-deactivate_task</span>
<span class="p_del">-kworker/-59      3d..2    2us : update_rq_clock &lt;-dequeue_task</span>
<span class="p_del">-kworker/-59      3d..2    2us : dequeue_task_fair &lt;-dequeue_task</span>
<span class="p_del">-kworker/-59      3d..2    2us : update_curr &lt;-dequeue_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    2us : update_min_vruntime &lt;-update_curr</span>
<span class="p_del">-kworker/-59      3d..2    3us : cpuacct_charge &lt;-update_curr</span>
<span class="p_del">-kworker/-59      3d..2    3us : __rcu_read_lock &lt;-cpuacct_charge</span>
<span class="p_del">-kworker/-59      3d..2    3us : __rcu_read_unlock &lt;-cpuacct_charge</span>
<span class="p_del">-kworker/-59      3d..2    3us : update_cfs_rq_blocked_load &lt;-dequeue_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    4us : clear_buddies &lt;-dequeue_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    4us : account_entity_dequeue &lt;-dequeue_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    4us : update_min_vruntime &lt;-dequeue_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    4us : update_cfs_shares &lt;-dequeue_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    5us : hrtick_update &lt;-dequeue_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    5us : wq_worker_sleeping &lt;-__schedule</span>
<span class="p_del">-kworker/-59      3d..2    5us : kthread_data &lt;-wq_worker_sleeping</span>
<span class="p_del">-kworker/-59      3d..2    5us : put_prev_task_fair &lt;-__schedule</span>
<span class="p_del">-kworker/-59      3d..2    6us : pick_next_task_fair &lt;-pick_next_task</span>
<span class="p_del">-kworker/-59      3d..2    6us : clear_buddies &lt;-pick_next_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    6us : set_next_entity &lt;-pick_next_task_fair</span>
<span class="p_del">-kworker/-59      3d..2    6us : update_stats_wait_end &lt;-set_next_entity</span>
<span class="p_del">-      ls-2269    3d..2    7us : finish_task_switch &lt;-__schedule</span>
<span class="p_del">-      ls-2269    3d..2    7us : _raw_spin_unlock_irq &lt;-finish_task_switch</span>
<span class="p_del">-      ls-2269    3d..2    8us : do_IRQ &lt;-ret_from_intr</span>
<span class="p_del">-      ls-2269    3d..2    8us : irq_enter &lt;-do_IRQ</span>
<span class="p_del">-      ls-2269    3d..2    8us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_del">-      ls-2269    3d..2    9us : add_preempt_count &lt;-irq_enter</span>
<span class="p_del">-      ls-2269    3d.h2    9us : exit_idle &lt;-do_IRQ</span>
<span class="p_del">-[...]</span>
<span class="p_del">-      ls-2269    3d.h3   20us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-      ls-2269    3d.h2   20us : irq_exit &lt;-do_IRQ</span>
<span class="p_del">-      ls-2269    3d.h2   21us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_del">-      ls-2269    3d..3   21us : do_softirq &lt;-irq_exit</span>
<span class="p_del">-      ls-2269    3d..3   21us : __do_softirq &lt;-call_softirq</span>
<span class="p_del">-      ls-2269    3d..3   21us+: __local_bh_disable &lt;-__do_softirq</span>
<span class="p_del">-      ls-2269    3d.s4   29us : sub_preempt_count &lt;-_local_bh_enable_ip</span>
<span class="p_del">-      ls-2269    3d.s5   29us : sub_preempt_count &lt;-_local_bh_enable_ip</span>
<span class="p_del">-      ls-2269    3d.s5   31us : do_IRQ &lt;-ret_from_intr</span>
<span class="p_del">-      ls-2269    3d.s5   31us : irq_enter &lt;-do_IRQ</span>
<span class="p_del">-      ls-2269    3d.s5   31us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_del">-[...]</span>
<span class="p_del">-      ls-2269    3d.s5   31us : rcu_irq_enter &lt;-irq_enter</span>
<span class="p_del">-      ls-2269    3d.s5   32us : add_preempt_count &lt;-irq_enter</span>
<span class="p_del">-      ls-2269    3d.H5   32us : exit_idle &lt;-do_IRQ</span>
<span class="p_del">-      ls-2269    3d.H5   32us : handle_irq &lt;-do_IRQ</span>
<span class="p_del">-      ls-2269    3d.H5   32us : irq_to_desc &lt;-handle_irq</span>
<span class="p_del">-      ls-2269    3d.H5   33us : handle_fasteoi_irq &lt;-handle_irq</span>
<span class="p_del">-[...]</span>
<span class="p_del">-      ls-2269    3d.s5  158us : _raw_spin_unlock_irqrestore &lt;-rtl8139_poll</span>
<span class="p_del">-      ls-2269    3d.s3  158us : net_rps_action_and_irq_enable.isra.65 &lt;-net_rx_action</span>
<span class="p_del">-      ls-2269    3d.s3  159us : __local_bh_enable &lt;-__do_softirq</span>
<span class="p_del">-      ls-2269    3d.s3  159us : sub_preempt_count &lt;-__local_bh_enable</span>
<span class="p_del">-      ls-2269    3d..3  159us : idle_cpu &lt;-irq_exit</span>
<span class="p_del">-      ls-2269    3d..3  159us : rcu_irq_exit &lt;-irq_exit</span>
<span class="p_del">-      ls-2269    3d..3  160us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_del">-      ls-2269    3d...  161us : __mutex_unlock_slowpath &lt;-mutex_unlock</span>
<span class="p_del">-      ls-2269    3d...  162us+: trace_hardirqs_on &lt;-mutex_unlock</span>
<span class="p_del">-      ls-2269    3d...  186us : &lt;stack trace&gt;</span>
<span class="p_del">- =&gt; __mutex_unlock_slowpath</span>
<span class="p_del">- =&gt; mutex_unlock</span>
<span class="p_del">- =&gt; process_output</span>
<span class="p_del">- =&gt; n_tty_write</span>
<span class="p_del">- =&gt; tty_write</span>
<span class="p_del">- =&gt; vfs_write</span>
<span class="p_del">- =&gt; sys_write</span>
<span class="p_del">- =&gt; system_call_fastpath</span>
<span class="p_del">-</span>
<span class="p_del">-This is an interesting trace. It started with kworker running and</span>
<span class="p_del">-scheduling out and ls taking over. But as soon as ls released the</span>
<span class="p_del">-rq lock and enabled interrupts (but not preemption) an interrupt</span>
<span class="p_del">-triggered. When the interrupt finished, it started running softirqs.</span>
<span class="p_del">-But while the softirq was running, another interrupt triggered.</span>
<span class="p_del">-When an interrupt is running inside a softirq, the annotation is &#39;H&#39;.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-wakeup</span>
<span class="p_del">-------</span>
<span class="p_del">-</span>
<span class="p_del">-One common case that people are interested in tracing is the</span>
<span class="p_del">-time it takes for a task that is woken to actually wake up.</span>
<span class="p_del">-Now for non Real-Time tasks, this can be arbitrary. But tracing</span>
<span class="p_del">-it none the less can be interesting. </span>
<span class="p_del">-</span>
<span class="p_del">-Without function tracing:</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 0 &gt; options/function-trace</span>
<span class="p_del">- # echo wakeup &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # echo 0 &gt; tracing_max_latency</span>
<span class="p_del">- # chrt -f 5 sleep 1</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: wakeup</span>
<span class="p_del">-#</span>
<span class="p_del">-# wakeup latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 15 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: kworker/3:1H-312 (uid:0 nice:-20 policy:0 rt_prio:0)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-  &lt;idle&gt;-0       3dNs7    0us :      0:120:R   + [003]   312:100:R kworker/3:1H</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNs7    1us+: ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_del">-  &lt;idle&gt;-0       3d..3   15us : __schedule &lt;-schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3d..3   15us :      0:120:R ==&gt; [003]   312:100:R kworker/3:1H</span>
<span class="p_del">-</span>
<span class="p_del">-The tracer only traces the highest priority task in the system</span>
<span class="p_del">-to avoid tracing the normal circumstances. Here we see that</span>
<span class="p_del">-the kworker with a nice priority of -20 (not very nice), took</span>
<span class="p_del">-just 15 microseconds from the time it woke up, to the time it</span>
<span class="p_del">-ran.</span>
<span class="p_del">-</span>
<span class="p_del">-Non Real-Time tasks are not that interesting. A more interesting</span>
<span class="p_del">-trace is to concentrate only on Real-Time tasks.</span>
<span class="p_del">-</span>
<span class="p_del">-wakeup_rt</span>
<span class="p_del">----------</span>
<span class="p_del">-</span>
<span class="p_del">-In a Real-Time environment it is very important to know the</span>
<span class="p_del">-wakeup time it takes for the highest priority task that is woken</span>
<span class="p_del">-up to the time that it executes. This is also known as &quot;schedule</span>
<span class="p_del">-latency&quot;. I stress the point that this is about RT tasks. It is</span>
<span class="p_del">-also important to know the scheduling latency of non-RT tasks,</span>
<span class="p_del">-but the average schedule latency is better for non-RT tasks.</span>
<span class="p_del">-Tools like LatencyTop are more appropriate for such</span>
<span class="p_del">-measurements.</span>
<span class="p_del">-</span>
<span class="p_del">-Real-Time environments are interested in the worst case latency.</span>
<span class="p_del">-That is the longest latency it takes for something to happen,</span>
<span class="p_del">-and not the average. We can have a very fast scheduler that may</span>
<span class="p_del">-only have a large latency once in a while, but that would not</span>
<span class="p_del">-work well with Real-Time tasks.  The wakeup_rt tracer was designed</span>
<span class="p_del">-to record the worst case wakeups of RT tasks. Non-RT tasks are</span>
<span class="p_del">-not recorded because the tracer only records one worst case and</span>
<span class="p_del">-tracing non-RT tasks that are unpredictable will overwrite the</span>
<span class="p_del">-worst case latency of RT tasks (just run the normal wakeup</span>
<span class="p_del">-tracer for a while to see that effect).</span>
<span class="p_del">-</span>
<span class="p_del">-Since this tracer only deals with RT tasks, we will run this</span>
<span class="p_del">-slightly differently than we did with the previous tracers.</span>
<span class="p_del">-Instead of performing an &#39;ls&#39;, we will run &#39;sleep 1&#39; under</span>
<span class="p_del">-&#39;chrt&#39; which changes the priority of the task.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 0 &gt; options/function-trace</span>
<span class="p_del">- # echo wakeup_rt &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # echo 0 &gt; tracing_max_latency</span>
<span class="p_del">- # chrt -f 5 sleep 1</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: wakeup</span>
<span class="p_del">-#</span>
<span class="p_del">-# tracer: wakeup_rt</span>
<span class="p_del">-#</span>
<span class="p_del">-# wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 5 us, #4/4, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: sleep-2389 (uid:0 nice:0 policy:1 rt_prio:5)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-  &lt;idle&gt;-0       3d.h4    0us :      0:120:R   + [003]  2389: 94:R sleep</span>
<span class="p_del">-  &lt;idle&gt;-0       3d.h4    1us+: ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_del">-  &lt;idle&gt;-0       3d..3    5us : __schedule &lt;-schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3d..3    5us :      0:120:R ==&gt; [003]  2389: 94:R sleep</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Running this on an idle system, we see that it only took 5 microseconds</span>
<span class="p_del">-to perform the task switch.  Note, since the trace point in the schedule</span>
<span class="p_del">-is before the actual &quot;switch&quot;, we stop the tracing when the recorded task</span>
<span class="p_del">-is about to schedule in. This may change if we add a new marker at the</span>
<span class="p_del">-end of the scheduler.</span>
<span class="p_del">-</span>
<span class="p_del">-Notice that the recorded task is &#39;sleep&#39; with the PID of 2389</span>
<span class="p_del">-and it has an rt_prio of 5. This priority is user-space priority</span>
<span class="p_del">-and not the internal kernel priority. The policy is 1 for</span>
<span class="p_del">-SCHED_FIFO and 2 for SCHED_RR.</span>
<span class="p_del">-</span>
<span class="p_del">-Note, that the trace data shows the internal priority (99 - rtprio).</span>
<span class="p_del">-</span>
<span class="p_del">-  &lt;idle&gt;-0       3d..3    5us :      0:120:R ==&gt; [003]  2389: 94:R sleep</span>
<span class="p_del">-</span>
<span class="p_del">-The 0:120:R means idle was running with a nice priority of 0 (120 - 120)</span>
<span class="p_del">-and in the running state &#39;R&#39;. The sleep task was scheduled in with</span>
<span class="p_del">-2389: 94:R. That is the priority is the kernel rtprio (99 - 5 = 94)</span>
<span class="p_del">-and it too is in the running state.</span>
<span class="p_del">-</span>
<span class="p_del">-Doing the same with chrt -r 5 and function-trace set.</span>
<span class="p_del">-</span>
<span class="p_del">-  echo 1 &gt; options/function-trace</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: wakeup_rt</span>
<span class="p_del">-#</span>
<span class="p_del">-# wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 29 us, #85/85, CPU#3 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: sleep-2448 (uid:0 nice:0 policy:1 rt_prio:5)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-  &lt;idle&gt;-0       3d.h4    1us+:      0:120:R   + [003]  2448: 94:R sleep</span>
<span class="p_del">-  &lt;idle&gt;-0       3d.h4    2us : ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_del">-  &lt;idle&gt;-0       3d.h3    3us : check_preempt_curr &lt;-ttwu_do_wakeup</span>
<span class="p_del">-  &lt;idle&gt;-0       3d.h3    3us : resched_curr &lt;-check_preempt_curr</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh3    4us : task_woken_rt &lt;-ttwu_do_wakeup</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh3    4us : _raw_spin_unlock &lt;-try_to_wake_up</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh3    4us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh2    5us : ttwu_stat &lt;-try_to_wake_up</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh2    5us : _raw_spin_unlock_irqrestore &lt;-try_to_wake_up</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh2    6us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    6us : _raw_spin_lock &lt;-__run_hrtimer</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    6us : add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh2    7us : _raw_spin_unlock &lt;-hrtimer_interrupt</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh2    7us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    7us : tick_program_event &lt;-hrtimer_interrupt</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    7us : clockevents_program_event &lt;-tick_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    8us : ktime_get &lt;-clockevents_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    8us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    8us : irq_exit &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-  &lt;idle&gt;-0       3dNh1    9us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2    9us : idle_cpu &lt;-irq_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2    9us : rcu_irq_exit &lt;-irq_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   10us : rcu_eqs_enter_common.isra.45 &lt;-rcu_irq_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   10us : sub_preempt_count &lt;-irq_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N.1   11us : rcu_idle_exit &lt;-cpu_idle</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   11us : rcu_eqs_exit_common.isra.43 &lt;-rcu_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N.1   11us : tick_nohz_idle_exit &lt;-cpu_idle</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   12us : menu_hrtimer_cancel &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   12us : ktime_get &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   12us : tick_do_update_jiffies64 &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   13us : cpu_load_update_nohz &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   13us : _raw_spin_lock &lt;-cpu_load_update_nohz</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   13us : add_preempt_count &lt;-_raw_spin_lock</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   13us : __cpu_load_update &lt;-cpu_load_update_nohz</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   14us : sched_avg_update &lt;-__cpu_load_update</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   14us : _raw_spin_unlock &lt;-cpu_load_update_nohz</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   14us : sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   15us : calc_load_nohz_stop &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   15us : touch_softlockup_watchdog &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   15us : hrtimer_cancel &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   15us : hrtimer_try_to_cancel &lt;-hrtimer_cancel</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   16us : lock_hrtimer_base.isra.18 &lt;-hrtimer_try_to_cancel</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   16us : _raw_spin_lock_irqsave &lt;-lock_hrtimer_base.isra.18</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   16us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   17us : __remove_hrtimer &lt;-remove_hrtimer.part.16</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   17us : hrtimer_force_reprogram &lt;-__remove_hrtimer</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   17us : tick_program_event &lt;-hrtimer_force_reprogram</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   18us : clockevents_program_event &lt;-tick_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   18us : ktime_get &lt;-clockevents_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   18us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   19us : _raw_spin_unlock_irqrestore &lt;-hrtimer_try_to_cancel</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   19us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   19us : hrtimer_forward &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   20us : ktime_add_safe &lt;-hrtimer_forward</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   20us : ktime_add_safe &lt;-hrtimer_forward</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   20us : hrtimer_start_range_ns &lt;-hrtimer_start_expires.constprop.11</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   20us : __hrtimer_start_range_ns &lt;-hrtimer_start_range_ns</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   21us : lock_hrtimer_base.isra.18 &lt;-__hrtimer_start_range_ns</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   21us : _raw_spin_lock_irqsave &lt;-lock_hrtimer_base.isra.18</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   21us : add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   22us : ktime_add_safe &lt;-__hrtimer_start_range_ns</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   22us : enqueue_hrtimer &lt;-__hrtimer_start_range_ns</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   22us : tick_program_event &lt;-__hrtimer_start_range_ns</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   23us : clockevents_program_event &lt;-tick_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   23us : ktime_get &lt;-clockevents_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   23us : lapic_next_event &lt;-clockevents_program_event</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   24us : _raw_spin_unlock_irqrestore &lt;-__hrtimer_start_range_ns</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   24us : sub_preempt_count &lt;-_raw_spin_unlock_irqrestore</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   24us : account_idle_ticks &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   24us : account_idle_time &lt;-account_idle_ticks</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N.1   25us : sub_preempt_count &lt;-cpu_idle</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N..   25us : schedule &lt;-cpu_idle</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N..   25us : __schedule &lt;-preempt_schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N..   26us : add_preempt_count &lt;-__schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N.1   26us : rcu_note_context_switch &lt;-__schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N.1   26us : rcu_sched_qs &lt;-rcu_note_context_switch</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   27us : rcu_preempt_qs &lt;-rcu_note_context_switch</span>
<span class="p_del">-  &lt;idle&gt;-0       3.N.1   27us : _raw_spin_lock_irq &lt;-__schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.1   27us : add_preempt_count &lt;-_raw_spin_lock_irq</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   28us : put_prev_task_idle &lt;-__schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   28us : pick_next_task_stop &lt;-pick_next_task</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   28us : pick_next_task_rt &lt;-pick_next_task</span>
<span class="p_del">-  &lt;idle&gt;-0       3dN.2   29us : dequeue_pushable_task &lt;-pick_next_task_rt</span>
<span class="p_del">-  &lt;idle&gt;-0       3d..3   29us : __schedule &lt;-preempt_schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       3d..3   30us :      0:120:R ==&gt; [003]  2448: 94:R sleep</span>
<span class="p_del">-</span>
<span class="p_del">-This isn&#39;t that big of a trace, even with function tracing enabled,</span>
<span class="p_del">-so I included the entire trace.</span>
<span class="p_del">-</span>
<span class="p_del">-The interrupt went off while when the system was idle. Somewhere</span>
<span class="p_del">-before task_woken_rt() was called, the NEED_RESCHED flag was set,</span>
<span class="p_del">-this is indicated by the first occurrence of the &#39;N&#39; flag.</span>
<span class="p_del">-</span>
<span class="p_del">-Latency tracing and events</span>
<span class="p_del">---------------------------</span>
<span class="p_del">-As function tracing can induce a much larger latency, but without</span>
<span class="p_del">-seeing what happens within the latency it is hard to know what</span>
<span class="p_del">-caused it. There is a middle ground, and that is with enabling</span>
<span class="p_del">-events.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 0 &gt; options/function-trace</span>
<span class="p_del">- # echo wakeup_rt &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; events/enable</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # echo 0 &gt; tracing_max_latency</span>
<span class="p_del">- # chrt -f 5 sleep 1</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: wakeup_rt</span>
<span class="p_del">-#</span>
<span class="p_del">-# wakeup_rt latency trace v1.1.5 on 3.8.0-test+</span>
<span class="p_del">-# --------------------------------------------------------------------</span>
<span class="p_del">-# latency: 6 us, #12/12, CPU#2 | (M:preempt VP:0, KP:0, SP:0 HP:0 #P:4)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#    | task: sleep-5882 (uid:0 nice:0 policy:1 rt_prio:5)</span>
<span class="p_del">-#    -----------------</span>
<span class="p_del">-#</span>
<span class="p_del">-#                  _------=&gt; CPU#            </span>
<span class="p_del">-#                 / _-----=&gt; irqs-off        </span>
<span class="p_del">-#                | / _----=&gt; need-resched    </span>
<span class="p_del">-#                || / _---=&gt; hardirq/softirq </span>
<span class="p_del">-#                ||| / _--=&gt; preempt-depth   </span>
<span class="p_del">-#                |||| /     delay             </span>
<span class="p_del">-#  cmd     pid   ||||| time  |   caller      </span>
<span class="p_del">-#     \   /      |||||  \    |   /           </span>
<span class="p_del">-  &lt;idle&gt;-0       2d.h4    0us :      0:120:R   + [002]  5882: 94:R sleep</span>
<span class="p_del">-  &lt;idle&gt;-0       2d.h4    0us : ttwu_do_activate.constprop.87 &lt;-try_to_wake_up</span>
<span class="p_del">-  &lt;idle&gt;-0       2d.h4    1us : sched_wakeup: comm=sleep pid=5882 prio=94 success=1 target_cpu=002</span>
<span class="p_del">-  &lt;idle&gt;-0       2dNh2    1us : hrtimer_expire_exit: hrtimer=ffff88007796feb8</span>
<span class="p_del">-  &lt;idle&gt;-0       2.N.2    2us : power_end: cpu_id=2</span>
<span class="p_del">-  &lt;idle&gt;-0       2.N.2    3us : cpu_idle: state=4294967295 cpu_id=2</span>
<span class="p_del">-  &lt;idle&gt;-0       2dN.3    4us : hrtimer_cancel: hrtimer=ffff88007d50d5e0</span>
<span class="p_del">-  &lt;idle&gt;-0       2dN.3    4us : hrtimer_start: hrtimer=ffff88007d50d5e0 function=tick_sched_timer expires=34311211000000 softexpires=34311211000000</span>
<span class="p_del">-  &lt;idle&gt;-0       2.N.2    5us : rcu_utilization: Start context switch</span>
<span class="p_del">-  &lt;idle&gt;-0       2.N.2    5us : rcu_utilization: End context switch</span>
<span class="p_del">-  &lt;idle&gt;-0       2d..3    6us : __schedule &lt;-schedule</span>
<span class="p_del">-  &lt;idle&gt;-0       2d..3    6us :      0:120:R ==&gt; [002]  5882: 94:R sleep</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Hardware Latency Detector</span>
<span class="p_del">--------------------------</span>
<span class="p_del">-</span>
<span class="p_del">-The hardware latency detector is executed by enabling the &quot;hwlat&quot; tracer.</span>
<span class="p_del">-</span>
<span class="p_del">-NOTE, this tracer will affect the performance of the system as it will</span>
<span class="p_del">-periodically make a CPU constantly busy with interrupts disabled.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo hwlat &gt; current_tracer</span>
<span class="p_del">- # sleep 100</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: hwlat</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-           &lt;...&gt;-3638  [001] d... 19452.055471: #1     inner/outer(us):   12/14    ts:1499801089.066141940</span>
<span class="p_del">-           &lt;...&gt;-3638  [003] d... 19454.071354: #2     inner/outer(us):   11/9     ts:1499801091.082164365</span>
<span class="p_del">-           &lt;...&gt;-3638  [002] dn.. 19461.126852: #3     inner/outer(us):   12/9     ts:1499801098.138150062</span>
<span class="p_del">-           &lt;...&gt;-3638  [001] d... 19488.340960: #4     inner/outer(us):    8/12    ts:1499801125.354139633</span>
<span class="p_del">-           &lt;...&gt;-3638  [003] d... 19494.388553: #5     inner/outer(us):    8/12    ts:1499801131.402150961</span>
<span class="p_del">-           &lt;...&gt;-3638  [003] d... 19501.283419: #6     inner/outer(us):    0/12    ts:1499801138.297435289 nmi-total:4 nmi-count:1</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-The above output is somewhat the same in the header. All events will have</span>
<span class="p_del">-interrupts disabled &#39;d&#39;. Under the FUNCTION title there is:</span>
<span class="p_del">-</span>
<span class="p_del">- #1 - This is the count of events recorded that were greater than the</span>
<span class="p_del">-      tracing_threshold (See below).</span>
<span class="p_del">-</span>
<span class="p_del">- inner/outer(us):   12/14</span>
<span class="p_del">-</span>
<span class="p_del">-      This shows two numbers as &quot;inner latency&quot; and &quot;outer latency&quot;. The test</span>
<span class="p_del">-      runs in a loop checking a timestamp twice. The latency detected within</span>
<span class="p_del">-      the two timestamps is the &quot;inner latency&quot; and the latency detected</span>
<span class="p_del">-      after the previous timestamp and the next timestamp in the loop is</span>
<span class="p_del">-      the &quot;outer latency&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">- ts:1499801089.066141940</span>
<span class="p_del">-</span>
<span class="p_del">-      The absolute timestamp that the event happened.</span>
<span class="p_del">-</span>
<span class="p_del">- nmi-total:4 nmi-count:1</span>
<span class="p_del">-</span>
<span class="p_del">-      On architectures that support it, if an NMI comes in during the</span>
<span class="p_del">-      test, the time spent in NMI is reported in &quot;nmi-total&quot; (in</span>
<span class="p_del">-      microseconds).</span>
<span class="p_del">-</span>
<span class="p_del">-      All architectures that have NMIs will show the &quot;nmi-count&quot; if an</span>
<span class="p_del">-      NMI comes in during the test.</span>
<span class="p_del">-</span>
<span class="p_del">-hwlat files:</span>
<span class="p_del">-</span>
<span class="p_del">-  tracing_threshold - This gets automatically set to &quot;10&quot; to represent 10</span>
<span class="p_del">-		      microseconds. This is the threshold of latency that</span>
<span class="p_del">-		      needs to be detected before the trace will be recorded.</span>
<span class="p_del">-</span>
<span class="p_del">-		      Note, when hwlat tracer is finished (another tracer is</span>
<span class="p_del">-		      written into &quot;current_tracer&quot;), the original value for</span>
<span class="p_del">-		      tracing_threshold is placed back into this file.</span>
<span class="p_del">-</span>
<span class="p_del">-  hwlat_detector/width - The length of time the test runs with interrupts</span>
<span class="p_del">-			 disabled.</span>
<span class="p_del">-</span>
<span class="p_del">-  hwlat_detector/window - The length of time of the window which the test</span>
<span class="p_del">-			  runs. That is, the test will run for &quot;width&quot;</span>
<span class="p_del">-			  microseconds per &quot;window&quot; microseconds</span>
<span class="p_del">-</span>
<span class="p_del">-  tracing_cpumask - When the test is started. A kernel thread is created that</span>
<span class="p_del">-		    runs the test. This thread will alternate between CPUs</span>
<span class="p_del">-		    listed in the tracing_cpumask between each period</span>
<span class="p_del">-		    (one &quot;window&quot;). To limit the test to specific CPUs</span>
<span class="p_del">-		    set the mask in this file to only the CPUs that the test</span>
<span class="p_del">-		    should run on.</span>
<span class="p_del">-</span>
<span class="p_del">-function</span>
<span class="p_del">---------</span>
<span class="p_del">-</span>
<span class="p_del">-This tracer is the function tracer. Enabling the function tracer</span>
<span class="p_del">-can be done from the debug file system. Make sure the</span>
<span class="p_del">-ftrace_enabled is set; otherwise this tracer is a nop.</span>
<span class="p_del">-See the &quot;ftrace_enabled&quot; section below.</span>
<span class="p_del">-</span>
<span class="p_del">- # sysctl kernel.ftrace_enabled=1</span>
<span class="p_del">- # echo function &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # usleep 1</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: function</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 24799/24799   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-            bash-1994  [002] ....  3082.063030: mutex_unlock &lt;-rb_simple_write</span>
<span class="p_del">-            bash-1994  [002] ....  3082.063031: __mutex_unlock_slowpath &lt;-mutex_unlock</span>
<span class="p_del">-            bash-1994  [002] ....  3082.063031: __fsnotify_parent &lt;-fsnotify_modify</span>
<span class="p_del">-            bash-1994  [002] ....  3082.063032: fsnotify &lt;-fsnotify_modify</span>
<span class="p_del">-            bash-1994  [002] ....  3082.063032: __srcu_read_lock &lt;-fsnotify</span>
<span class="p_del">-            bash-1994  [002] ....  3082.063032: add_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_del">-            bash-1994  [002] ...1  3082.063032: sub_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_del">-            bash-1994  [002] ....  3082.063033: __srcu_read_unlock &lt;-fsnotify</span>
<span class="p_del">-[...]</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Note: function tracer uses ring buffers to store the above</span>
<span class="p_del">-entries. The newest data may overwrite the oldest data.</span>
<span class="p_del">-Sometimes using echo to stop the trace is not sufficient because</span>
<span class="p_del">-the tracing could have overwritten the data that you wanted to</span>
<span class="p_del">-record. For this reason, it is sometimes better to disable</span>
<span class="p_del">-tracing directly from a program. This allows you to stop the</span>
<span class="p_del">-tracing at the point that you hit the part that you are</span>
<span class="p_del">-interested in. To disable the tracing directly from a C program,</span>
<span class="p_del">-something like following code snippet can be used:</span>
<span class="p_del">-</span>
<span class="p_del">-int trace_fd;</span>
<span class="p_del">-[...]</span>
<span class="p_del">-int main(int argc, char *argv[]) {</span>
<span class="p_del">-	[...]</span>
<span class="p_del">-	trace_fd = open(tracing_file(&quot;tracing_on&quot;), O_WRONLY);</span>
<span class="p_del">-	[...]</span>
<span class="p_del">-	if (condition_hit()) {</span>
<span class="p_del">-		write(trace_fd, &quot;0&quot;, 1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	[...]</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Single thread tracing</span>
<span class="p_del">----------------------</span>
<span class="p_del">-</span>
<span class="p_del">-By writing into set_ftrace_pid you can trace a</span>
<span class="p_del">-single thread. For example:</span>
<span class="p_del">-</span>
<span class="p_del">-# cat set_ftrace_pid</span>
<span class="p_del">-no pid</span>
<span class="p_del">-# echo 3111 &gt; set_ftrace_pid</span>
<span class="p_del">-# cat set_ftrace_pid</span>
<span class="p_del">-3111</span>
<span class="p_del">-# echo function &gt; current_tracer</span>
<span class="p_del">-# cat trace | head</span>
<span class="p_del">- # tracer: function</span>
<span class="p_del">- #</span>
<span class="p_del">- #           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span>
<span class="p_del">- #              | |       |          |         |</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1637.254676: finish_task_switch &lt;-thread_return</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1637.254681: hrtimer_cancel &lt;-schedule_hrtimeout_range</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1637.254682: hrtimer_try_to_cancel &lt;-hrtimer_cancel</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1637.254683: lock_hrtimer_base &lt;-hrtimer_try_to_cancel</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1637.254685: fget_light &lt;-do_sys_poll</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1637.254686: pipe_poll &lt;-do_sys_poll</span>
<span class="p_del">-# echo &gt; set_ftrace_pid</span>
<span class="p_del">-# cat trace |head</span>
<span class="p_del">- # tracer: function</span>
<span class="p_del">- #</span>
<span class="p_del">- #           TASK-PID    CPU#    TIMESTAMP  FUNCTION</span>
<span class="p_del">- #              | |       |          |         |</span>
<span class="p_del">- ##### CPU 3 buffer started ####</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1701.957688: free_poll_entry &lt;-poll_freewait</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1701.957689: remove_wait_queue &lt;-free_poll_entry</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1701.957691: fput &lt;-free_poll_entry</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1701.957692: audit_syscall_exit &lt;-sysret_audit</span>
<span class="p_del">-     yum-updatesd-3111  [003]  1701.957693: path_put &lt;-audit_syscall_exit</span>
<span class="p_del">-</span>
<span class="p_del">-If you want to trace a function when executing, you could use</span>
<span class="p_del">-something like this simple program:</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;stdio.h&gt;</span>
<span class="p_del">-#include &lt;stdlib.h&gt;</span>
<span class="p_del">-#include &lt;sys/types.h&gt;</span>
<span class="p_del">-#include &lt;sys/stat.h&gt;</span>
<span class="p_del">-#include &lt;fcntl.h&gt;</span>
<span class="p_del">-#include &lt;unistd.h&gt;</span>
<span class="p_del">-#include &lt;string.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#define _STR(x) #x</span>
<span class="p_del">-#define STR(x) _STR(x)</span>
<span class="p_del">-#define MAX_PATH 256</span>
<span class="p_del">-</span>
<span class="p_del">-const char *find_tracefs(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-       static char tracefs[MAX_PATH+1];</span>
<span class="p_del">-       static int tracefs_found;</span>
<span class="p_del">-       char type[100];</span>
<span class="p_del">-       FILE *fp;</span>
<span class="p_del">-</span>
<span class="p_del">-       if (tracefs_found)</span>
<span class="p_del">-               return tracefs;</span>
<span class="p_del">-</span>
<span class="p_del">-       if ((fp = fopen(&quot;/proc/mounts&quot;,&quot;r&quot;)) == NULL) {</span>
<span class="p_del">-               perror(&quot;/proc/mounts&quot;);</span>
<span class="p_del">-               return NULL;</span>
<span class="p_del">-       }</span>
<span class="p_del">-</span>
<span class="p_del">-       while (fscanf(fp, &quot;%*s %&quot;</span>
<span class="p_del">-                     STR(MAX_PATH)</span>
<span class="p_del">-                     &quot;s %99s %*s %*d %*d\n&quot;,</span>
<span class="p_del">-                     tracefs, type) == 2) {</span>
<span class="p_del">-               if (strcmp(type, &quot;tracefs&quot;) == 0)</span>
<span class="p_del">-                       break;</span>
<span class="p_del">-       }</span>
<span class="p_del">-       fclose(fp);</span>
<span class="p_del">-</span>
<span class="p_del">-       if (strcmp(type, &quot;tracefs&quot;) != 0) {</span>
<span class="p_del">-               fprintf(stderr, &quot;tracefs not mounted&quot;);</span>
<span class="p_del">-               return NULL;</span>
<span class="p_del">-       }</span>
<span class="p_del">-</span>
<span class="p_del">-       strcat(tracefs, &quot;/tracing/&quot;);</span>
<span class="p_del">-       tracefs_found = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-       return tracefs;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-const char *tracing_file(const char *file_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-       static char trace_file[MAX_PATH+1];</span>
<span class="p_del">-       snprintf(trace_file, MAX_PATH, &quot;%s/%s&quot;, find_tracefs(), file_name);</span>
<span class="p_del">-       return trace_file;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int main (int argc, char **argv)</span>
<span class="p_del">-{</span>
<span class="p_del">-        if (argc &lt; 1)</span>
<span class="p_del">-                exit(-1);</span>
<span class="p_del">-</span>
<span class="p_del">-        if (fork() &gt; 0) {</span>
<span class="p_del">-                int fd, ffd;</span>
<span class="p_del">-                char line[64];</span>
<span class="p_del">-                int s;</span>
<span class="p_del">-</span>
<span class="p_del">-                ffd = open(tracing_file(&quot;current_tracer&quot;), O_WRONLY);</span>
<span class="p_del">-                if (ffd &lt; 0)</span>
<span class="p_del">-                        exit(-1);</span>
<span class="p_del">-                write(ffd, &quot;nop&quot;, 3);</span>
<span class="p_del">-</span>
<span class="p_del">-                fd = open(tracing_file(&quot;set_ftrace_pid&quot;), O_WRONLY);</span>
<span class="p_del">-                s = sprintf(line, &quot;%d\n&quot;, getpid());</span>
<span class="p_del">-                write(fd, line, s);</span>
<span class="p_del">-</span>
<span class="p_del">-                write(ffd, &quot;function&quot;, 8);</span>
<span class="p_del">-</span>
<span class="p_del">-                close(fd);</span>
<span class="p_del">-                close(ffd);</span>
<span class="p_del">-</span>
<span class="p_del">-                execvp(argv[1], argv+1);</span>
<span class="p_del">-        }</span>
<span class="p_del">-</span>
<span class="p_del">-        return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-Or this simple script!</span>
<span class="p_del">-</span>
<span class="p_del">-------</span>
<span class="p_del">-#!/bin/bash</span>
<span class="p_del">-</span>
<span class="p_del">-tracefs=`sed -ne &#39;s/^tracefs \(.*\) tracefs.*/\1/p&#39; /proc/mounts`</span>
<span class="p_del">-echo nop &gt; $tracefs/tracing/current_tracer</span>
<span class="p_del">-echo 0 &gt; $tracefs/tracing/tracing_on</span>
<span class="p_del">-echo $$ &gt; $tracefs/tracing/set_ftrace_pid</span>
<span class="p_del">-echo function &gt; $tracefs/tracing/current_tracer</span>
<span class="p_del">-echo 1 &gt; $tracefs/tracing/tracing_on</span>
<span class="p_del">-exec &quot;$@&quot;</span>
<span class="p_del">-------</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-function graph tracer</span>
<span class="p_del">----------------------------</span>
<span class="p_del">-</span>
<span class="p_del">-This tracer is similar to the function tracer except that it</span>
<span class="p_del">-probes a function on its entry and its exit. This is done by</span>
<span class="p_del">-using a dynamically allocated stack of return addresses in each</span>
<span class="p_del">-task_struct. On function entry the tracer overwrites the return</span>
<span class="p_del">-address of each function traced to set a custom probe. Thus the</span>
<span class="p_del">-original return address is stored on the stack of return address</span>
<span class="p_del">-in the task_struct.</span>
<span class="p_del">-</span>
<span class="p_del">-Probing on both ends of a function leads to special features</span>
<span class="p_del">-such as:</span>
<span class="p_del">-</span>
<span class="p_del">-- measure of a function&#39;s time execution</span>
<span class="p_del">-- having a reliable call stack to draw function calls graph</span>
<span class="p_del">-</span>
<span class="p_del">-This tracer is useful in several situations:</span>
<span class="p_del">-</span>
<span class="p_del">-- you want to find the reason of a strange kernel behavior and</span>
<span class="p_del">-  need to see what happens in detail on any areas (or specific</span>
<span class="p_del">-  ones).</span>
<span class="p_del">-</span>
<span class="p_del">-- you are experiencing weird latencies but it&#39;s difficult to</span>
<span class="p_del">-  find its origin.</span>
<span class="p_del">-</span>
<span class="p_del">-- you want to find quickly which path is taken by a specific</span>
<span class="p_del">-  function</span>
<span class="p_del">-</span>
<span class="p_del">-- you just want to peek inside a working kernel and want to see</span>
<span class="p_del">-  what happens there.</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: function_graph</span>
<span class="p_del">-#</span>
<span class="p_del">-# CPU  DURATION                  FUNCTION CALLS</span>
<span class="p_del">-# |     |   |                     |   |   |   |</span>
<span class="p_del">-</span>
<span class="p_del">- 0)               |  sys_open() {</span>
<span class="p_del">- 0)               |    do_sys_open() {</span>
<span class="p_del">- 0)               |      getname() {</span>
<span class="p_del">- 0)               |        kmem_cache_alloc() {</span>
<span class="p_del">- 0)   1.382 us    |          __might_sleep();</span>
<span class="p_del">- 0)   2.478 us    |        }</span>
<span class="p_del">- 0)               |        strncpy_from_user() {</span>
<span class="p_del">- 0)               |          might_fault() {</span>
<span class="p_del">- 0)   1.389 us    |            __might_sleep();</span>
<span class="p_del">- 0)   2.553 us    |          }</span>
<span class="p_del">- 0)   3.807 us    |        }</span>
<span class="p_del">- 0)   7.876 us    |      }</span>
<span class="p_del">- 0)               |      alloc_fd() {</span>
<span class="p_del">- 0)   0.668 us    |        _spin_lock();</span>
<span class="p_del">- 0)   0.570 us    |        expand_files();</span>
<span class="p_del">- 0)   0.586 us    |        _spin_unlock();</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-There are several columns that can be dynamically</span>
<span class="p_del">-enabled/disabled. You can use every combination of options you</span>
<span class="p_del">-want, depending on your needs.</span>
<span class="p_del">-</span>
<span class="p_del">-- The cpu number on which the function executed is default</span>
<span class="p_del">-  enabled.  It is sometimes better to only trace one cpu (see</span>
<span class="p_del">-  tracing_cpu_mask file) or you might sometimes see unordered</span>
<span class="p_del">-  function calls while cpu tracing switch.</span>
<span class="p_del">-</span>
<span class="p_del">-	hide: echo nofuncgraph-cpu &gt; trace_options</span>
<span class="p_del">-	show: echo funcgraph-cpu &gt; trace_options</span>
<span class="p_del">-</span>
<span class="p_del">-- The duration (function&#39;s time of execution) is displayed on</span>
<span class="p_del">-  the closing bracket line of a function or on the same line</span>
<span class="p_del">-  than the current function in case of a leaf one. It is default</span>
<span class="p_del">-  enabled.</span>
<span class="p_del">-</span>
<span class="p_del">-	hide: echo nofuncgraph-duration &gt; trace_options</span>
<span class="p_del">-	show: echo funcgraph-duration &gt; trace_options</span>
<span class="p_del">-</span>
<span class="p_del">-- The overhead field precedes the duration field in case of</span>
<span class="p_del">-  reached duration thresholds.</span>
<span class="p_del">-</span>
<span class="p_del">-	hide: echo nofuncgraph-overhead &gt; trace_options</span>
<span class="p_del">-	show: echo funcgraph-overhead &gt; trace_options</span>
<span class="p_del">-	depends on: funcgraph-duration</span>
<span class="p_del">-</span>
<span class="p_del">-  ie:</span>
<span class="p_del">-</span>
<span class="p_del">-  3) # 1837.709 us |          } /* __switch_to */</span>
<span class="p_del">-  3)               |          finish_task_switch() {</span>
<span class="p_del">-  3)   0.313 us    |            _raw_spin_unlock_irq();</span>
<span class="p_del">-  3)   3.177 us    |          }</span>
<span class="p_del">-  3) # 1889.063 us |        } /* __schedule */</span>
<span class="p_del">-  3) ! 140.417 us  |      } /* __schedule */</span>
<span class="p_del">-  3) # 2034.948 us |    } /* schedule */</span>
<span class="p_del">-  3) * 33998.59 us |  } /* schedule_preempt_disabled */</span>
<span class="p_del">-</span>
<span class="p_del">-  [...]</span>
<span class="p_del">-</span>
<span class="p_del">-  1)   0.260 us    |              msecs_to_jiffies();</span>
<span class="p_del">-  1)   0.313 us    |              __rcu_read_unlock();</span>
<span class="p_del">-  1) + 61.770 us   |            }</span>
<span class="p_del">-  1) + 64.479 us   |          }</span>
<span class="p_del">-  1)   0.313 us    |          rcu_bh_qs();</span>
<span class="p_del">-  1)   0.313 us    |          __local_bh_enable();</span>
<span class="p_del">-  1) ! 217.240 us  |        }</span>
<span class="p_del">-  1)   0.365 us    |        idle_cpu();</span>
<span class="p_del">-  1)               |        rcu_irq_exit() {</span>
<span class="p_del">-  1)   0.417 us    |          rcu_eqs_enter_common.isra.47();</span>
<span class="p_del">-  1)   3.125 us    |        }</span>
<span class="p_del">-  1) ! 227.812 us  |      }</span>
<span class="p_del">-  1) ! 457.395 us  |    }</span>
<span class="p_del">-  1) @ 119760.2 us |  }</span>
<span class="p_del">-</span>
<span class="p_del">-  [...]</span>
<span class="p_del">-</span>
<span class="p_del">-  2)               |    handle_IPI() {</span>
<span class="p_del">-  1)   6.979 us    |                  }</span>
<span class="p_del">-  2)   0.417 us    |      scheduler_ipi();</span>
<span class="p_del">-  1)   9.791 us    |                }</span>
<span class="p_del">-  1) + 12.917 us   |              }</span>
<span class="p_del">-  2)   3.490 us    |    }</span>
<span class="p_del">-  1) + 15.729 us   |            }</span>
<span class="p_del">-  1) + 18.542 us   |          }</span>
<span class="p_del">-  2) $ 3594274 us  |  }</span>
<span class="p_del">-</span>
<span class="p_del">-  + means that the function exceeded 10 usecs.</span>
<span class="p_del">-  ! means that the function exceeded 100 usecs.</span>
<span class="p_del">-  # means that the function exceeded 1000 usecs.</span>
<span class="p_del">-  * means that the function exceeded 10 msecs.</span>
<span class="p_del">-  @ means that the function exceeded 100 msecs.</span>
<span class="p_del">-  $ means that the function exceeded 1 sec.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-- The task/pid field displays the thread cmdline and pid which</span>
<span class="p_del">-  executed the function. It is default disabled.</span>
<span class="p_del">-</span>
<span class="p_del">-	hide: echo nofuncgraph-proc &gt; trace_options</span>
<span class="p_del">-	show: echo funcgraph-proc &gt; trace_options</span>
<span class="p_del">-</span>
<span class="p_del">-  ie:</span>
<span class="p_del">-</span>
<span class="p_del">-  # tracer: function_graph</span>
<span class="p_del">-  #</span>
<span class="p_del">-  # CPU  TASK/PID        DURATION                  FUNCTION CALLS</span>
<span class="p_del">-  # |    |    |           |   |                     |   |   |   |</span>
<span class="p_del">-  0)    sh-4802     |               |                  d_free() {</span>
<span class="p_del">-  0)    sh-4802     |               |                    call_rcu() {</span>
<span class="p_del">-  0)    sh-4802     |               |                      __call_rcu() {</span>
<span class="p_del">-  0)    sh-4802     |   0.616 us    |                        rcu_process_gp_end();</span>
<span class="p_del">-  0)    sh-4802     |   0.586 us    |                        check_for_new_grace_period();</span>
<span class="p_del">-  0)    sh-4802     |   2.899 us    |                      }</span>
<span class="p_del">-  0)    sh-4802     |   4.040 us    |                    }</span>
<span class="p_del">-  0)    sh-4802     |   5.151 us    |                  }</span>
<span class="p_del">-  0)    sh-4802     | + 49.370 us   |                }</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-- The absolute time field is an absolute timestamp given by the</span>
<span class="p_del">-  system clock since it started. A snapshot of this time is</span>
<span class="p_del">-  given on each entry/exit of functions</span>
<span class="p_del">-</span>
<span class="p_del">-	hide: echo nofuncgraph-abstime &gt; trace_options</span>
<span class="p_del">-	show: echo funcgraph-abstime &gt; trace_options</span>
<span class="p_del">-</span>
<span class="p_del">-  ie:</span>
<span class="p_del">-</span>
<span class="p_del">-  #</span>
<span class="p_del">-  #      TIME       CPU  DURATION                  FUNCTION CALLS</span>
<span class="p_del">-  #       |         |     |   |                     |   |   |   |</span>
<span class="p_del">-  360.774522 |   1)   0.541 us    |                                          }</span>
<span class="p_del">-  360.774522 |   1)   4.663 us    |                                        }</span>
<span class="p_del">-  360.774523 |   1)   0.541 us    |                                        __wake_up_bit();</span>
<span class="p_del">-  360.774524 |   1)   6.796 us    |                                      }</span>
<span class="p_del">-  360.774524 |   1)   7.952 us    |                                    }</span>
<span class="p_del">-  360.774525 |   1)   9.063 us    |                                  }</span>
<span class="p_del">-  360.774525 |   1)   0.615 us    |                                  journal_mark_dirty();</span>
<span class="p_del">-  360.774527 |   1)   0.578 us    |                                  __brelse();</span>
<span class="p_del">-  360.774528 |   1)               |                                  reiserfs_prepare_for_journal() {</span>
<span class="p_del">-  360.774528 |   1)               |                                    unlock_buffer() {</span>
<span class="p_del">-  360.774529 |   1)               |                                      wake_up_bit() {</span>
<span class="p_del">-  360.774529 |   1)               |                                        bit_waitqueue() {</span>
<span class="p_del">-  360.774530 |   1)   0.594 us    |                                          __phys_addr();</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-The function name is always displayed after the closing bracket</span>
<span class="p_del">-for a function if the start of that function is not in the</span>
<span class="p_del">-trace buffer.</span>
<span class="p_del">-</span>
<span class="p_del">-Display of the function name after the closing bracket may be</span>
<span class="p_del">-enabled for functions whose start is in the trace buffer,</span>
<span class="p_del">-allowing easier searching with grep for function durations.</span>
<span class="p_del">-It is default disabled.</span>
<span class="p_del">-</span>
<span class="p_del">-	hide: echo nofuncgraph-tail &gt; trace_options</span>
<span class="p_del">-	show: echo funcgraph-tail &gt; trace_options</span>
<span class="p_del">-</span>
<span class="p_del">-  Example with nofuncgraph-tail (default):</span>
<span class="p_del">-  0)               |      putname() {</span>
<span class="p_del">-  0)               |        kmem_cache_free() {</span>
<span class="p_del">-  0)   0.518 us    |          __phys_addr();</span>
<span class="p_del">-  0)   1.757 us    |        }</span>
<span class="p_del">-  0)   2.861 us    |      }</span>
<span class="p_del">-</span>
<span class="p_del">-  Example with funcgraph-tail:</span>
<span class="p_del">-  0)               |      putname() {</span>
<span class="p_del">-  0)               |        kmem_cache_free() {</span>
<span class="p_del">-  0)   0.518 us    |          __phys_addr();</span>
<span class="p_del">-  0)   1.757 us    |        } /* kmem_cache_free() */</span>
<span class="p_del">-  0)   2.861 us    |      } /* putname() */</span>
<span class="p_del">-</span>
<span class="p_del">-You can put some comments on specific functions by using</span>
<span class="p_del">-trace_printk() For example, if you want to put a comment inside</span>
<span class="p_del">-the __might_sleep() function, you just have to include</span>
<span class="p_del">-&lt;linux/ftrace.h&gt; and call trace_printk() inside __might_sleep()</span>
<span class="p_del">-</span>
<span class="p_del">-trace_printk(&quot;I&#39;m a comment!\n&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-will produce:</span>
<span class="p_del">-</span>
<span class="p_del">- 1)               |             __might_sleep() {</span>
<span class="p_del">- 1)               |                /* I&#39;m a comment! */</span>
<span class="p_del">- 1)   1.449 us    |             }</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-You might find other useful features for this tracer in the</span>
<span class="p_del">-following &quot;dynamic ftrace&quot; section such as tracing only specific</span>
<span class="p_del">-functions or tasks.</span>
<span class="p_del">-</span>
<span class="p_del">-dynamic ftrace</span>
<span class="p_del">---------------</span>
<span class="p_del">-</span>
<span class="p_del">-If CONFIG_DYNAMIC_FTRACE is set, the system will run with</span>
<span class="p_del">-virtually no overhead when function tracing is disabled. The way</span>
<span class="p_del">-this works is the mcount function call (placed at the start of</span>
<span class="p_del">-every kernel function, produced by the -pg switch in gcc),</span>
<span class="p_del">-starts of pointing to a simple return. (Enabling FTRACE will</span>
<span class="p_del">-include the -pg switch in the compiling of the kernel.)</span>
<span class="p_del">-</span>
<span class="p_del">-At compile time every C file object is run through the</span>
<span class="p_del">-recordmcount program (located in the scripts directory). This</span>
<span class="p_del">-program will parse the ELF headers in the C object to find all</span>
<span class="p_del">-the locations in the .text section that call mcount. Starting</span>
<span class="p_del">-with gcc verson 4.6, the -mfentry has been added for x86, which</span>
<span class="p_del">-calls &quot;__fentry__&quot; instead of &quot;mcount&quot;. Which is called before</span>
<span class="p_del">-the creation of the stack frame.</span>
<span class="p_del">-</span>
<span class="p_del">-Note, not all sections are traced. They may be prevented by either</span>
<span class="p_del">-a notrace, or blocked another way and all inline functions are not</span>
<span class="p_del">-traced. Check the &quot;available_filter_functions&quot; file to see what functions</span>
<span class="p_del">-can be traced.</span>
<span class="p_del">-</span>
<span class="p_del">-A section called &quot;__mcount_loc&quot; is created that holds</span>
<span class="p_del">-references to all the mcount/fentry call sites in the .text section.</span>
<span class="p_del">-The recordmcount program re-links this section back into the</span>
<span class="p_del">-original object. The final linking stage of the kernel will add all these</span>
<span class="p_del">-references into a single table.</span>
<span class="p_del">-</span>
<span class="p_del">-On boot up, before SMP is initialized, the dynamic ftrace code</span>
<span class="p_del">-scans this table and updates all the locations into nops. It</span>
<span class="p_del">-also records the locations, which are added to the</span>
<span class="p_del">-available_filter_functions list.  Modules are processed as they</span>
<span class="p_del">-are loaded and before they are executed.  When a module is</span>
<span class="p_del">-unloaded, it also removes its functions from the ftrace function</span>
<span class="p_del">-list. This is automatic in the module unload code, and the</span>
<span class="p_del">-module author does not need to worry about it.</span>
<span class="p_del">-</span>
<span class="p_del">-When tracing is enabled, the process of modifying the function</span>
<span class="p_del">-tracepoints is dependent on architecture. The old method is to use</span>
<span class="p_del">-kstop_machine to prevent races with the CPUs executing code being</span>
<span class="p_del">-modified (which can cause the CPU to do undesirable things, especially</span>
<span class="p_del">-if the modified code crosses cache (or page) boundaries), and the nops are</span>
<span class="p_del">-patched back to calls. But this time, they do not call mcount</span>
<span class="p_del">-(which is just a function stub). They now call into the ftrace</span>
<span class="p_del">-infrastructure.</span>
<span class="p_del">-</span>
<span class="p_del">-The new method of modifying the function tracepoints is to place</span>
<span class="p_del">-a breakpoint at the location to be modified, sync all CPUs, modify</span>
<span class="p_del">-the rest of the instruction not covered by the breakpoint. Sync</span>
<span class="p_del">-all CPUs again, and then remove the breakpoint with the finished</span>
<span class="p_del">-version to the ftrace call site.</span>
<span class="p_del">-</span>
<span class="p_del">-Some archs do not even need to monkey around with the synchronization,</span>
<span class="p_del">-and can just slap the new code on top of the old without any</span>
<span class="p_del">-problems with other CPUs executing it at the same time.</span>
<span class="p_del">-</span>
<span class="p_del">-One special side-effect to the recording of the functions being</span>
<span class="p_del">-traced is that we can now selectively choose which functions we</span>
<span class="p_del">-wish to trace and which ones we want the mcount calls to remain</span>
<span class="p_del">-as nops.</span>
<span class="p_del">-</span>
<span class="p_del">-Two files are used, one for enabling and one for disabling the</span>
<span class="p_del">-tracing of specified functions. They are:</span>
<span class="p_del">-</span>
<span class="p_del">-  set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-and</span>
<span class="p_del">-</span>
<span class="p_del">-  set_ftrace_notrace</span>
<span class="p_del">-</span>
<span class="p_del">-A list of available functions that you can add to these files is</span>
<span class="p_del">-listed in:</span>
<span class="p_del">-</span>
<span class="p_del">-   available_filter_functions</span>
<span class="p_del">-</span>
<span class="p_del">- # cat available_filter_functions</span>
<span class="p_del">-put_prev_task_idle</span>
<span class="p_del">-kmem_cache_create</span>
<span class="p_del">-pick_next_task_rt</span>
<span class="p_del">-get_online_cpus</span>
<span class="p_del">-pick_next_task_fair</span>
<span class="p_del">-mutex_lock</span>
<span class="p_del">-[...]</span>
<span class="p_del">-</span>
<span class="p_del">-If I am only interested in sys_nanosleep and hrtimer_interrupt:</span>
<span class="p_del">-</span>
<span class="p_del">- # echo sys_nanosleep hrtimer_interrupt &gt; set_ftrace_filter</span>
<span class="p_del">- # echo function &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # usleep 1</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: function</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 5/5   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-          usleep-2665  [001] ....  4186.475355: sys_nanosleep &lt;-system_call_fastpath</span>
<span class="p_del">-          &lt;idle&gt;-0     [001] d.h1  4186.475409: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-          usleep-2665  [001] d.h1  4186.475426: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] d.h1  4186.475426: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-          &lt;idle&gt;-0     [002] d.h1  4186.475427: hrtimer_interrupt &lt;-smp_apic_timer_interrupt</span>
<span class="p_del">-</span>
<span class="p_del">-To see which functions are being traced, you can cat the file:</span>
<span class="p_del">-</span>
<span class="p_del">- # cat set_ftrace_filter</span>
<span class="p_del">-hrtimer_interrupt</span>
<span class="p_del">-sys_nanosleep</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Perhaps this is not enough. The filters also allow glob(7) matching.</span>
<span class="p_del">-</span>
<span class="p_del">-  &lt;match&gt;*  - will match functions that begin with &lt;match&gt;</span>
<span class="p_del">-  *&lt;match&gt;  - will match functions that end with &lt;match&gt;</span>
<span class="p_del">-  *&lt;match&gt;* - will match functions that have &lt;match&gt; in it</span>
<span class="p_del">-  &lt;match1&gt;*&lt;match2&gt; - will match functions that begin with</span>
<span class="p_del">-                      &lt;match1&gt; and end with &lt;match2&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-Note: It is better to use quotes to enclose the wild cards,</span>
<span class="p_del">-      otherwise the shell may expand the parameters into names</span>
<span class="p_del">-      of files in the local directory.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo &#39;hrtimer_*&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-Produces:</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: function</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 897/897   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] dN.1  4228.547803: hrtimer_cancel &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] dN.1  4228.547804: hrtimer_try_to_cancel &lt;-hrtimer_cancel</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] dN.2  4228.547805: hrtimer_force_reprogram &lt;-__remove_hrtimer</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] dN.1  4228.547805: hrtimer_forward &lt;-tick_nohz_idle_exit</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] dN.1  4228.547805: hrtimer_start_range_ns &lt;-hrtimer_start_expires.constprop.11</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] d..1  4228.547858: hrtimer_get_next_event &lt;-get_next_timer_interrupt</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] d..1  4228.547859: hrtimer_start &lt;-__tick_nohz_idle_enter</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] d..2  4228.547860: hrtimer_force_reprogram &lt;-__rem</span>
<span class="p_del">-</span>
<span class="p_del">-Notice that we lost the sys_nanosleep.</span>
<span class="p_del">-</span>
<span class="p_del">- # cat set_ftrace_filter</span>
<span class="p_del">-hrtimer_run_queues</span>
<span class="p_del">-hrtimer_run_pending</span>
<span class="p_del">-hrtimer_init</span>
<span class="p_del">-hrtimer_cancel</span>
<span class="p_del">-hrtimer_try_to_cancel</span>
<span class="p_del">-hrtimer_forward</span>
<span class="p_del">-hrtimer_start</span>
<span class="p_del">-hrtimer_reprogram</span>
<span class="p_del">-hrtimer_force_reprogram</span>
<span class="p_del">-hrtimer_get_next_event</span>
<span class="p_del">-hrtimer_interrupt</span>
<span class="p_del">-hrtimer_nanosleep</span>
<span class="p_del">-hrtimer_wakeup</span>
<span class="p_del">-hrtimer_get_remaining</span>
<span class="p_del">-hrtimer_get_res</span>
<span class="p_del">-hrtimer_init_sleeper</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-This is because the &#39;&gt;&#39; and &#39;&gt;&gt;&#39; act just like they do in bash.</span>
<span class="p_del">-To rewrite the filters, use &#39;&gt;&#39;</span>
<span class="p_del">-To append to the filters, use &#39;&gt;&gt;&#39;</span>
<span class="p_del">-</span>
<span class="p_del">-To clear out a filter so that all functions will be recorded</span>
<span class="p_del">-again:</span>
<span class="p_del">-</span>
<span class="p_del">- # echo &gt; set_ftrace_filter</span>
<span class="p_del">- # cat set_ftrace_filter</span>
<span class="p_del">- #</span>
<span class="p_del">-</span>
<span class="p_del">-Again, now we want to append.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo sys_nanosleep &gt; set_ftrace_filter</span>
<span class="p_del">- # cat set_ftrace_filter</span>
<span class="p_del">-sys_nanosleep</span>
<span class="p_del">- # echo &#39;hrtimer_*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_del">- # cat set_ftrace_filter</span>
<span class="p_del">-hrtimer_run_queues</span>
<span class="p_del">-hrtimer_run_pending</span>
<span class="p_del">-hrtimer_init</span>
<span class="p_del">-hrtimer_cancel</span>
<span class="p_del">-hrtimer_try_to_cancel</span>
<span class="p_del">-hrtimer_forward</span>
<span class="p_del">-hrtimer_start</span>
<span class="p_del">-hrtimer_reprogram</span>
<span class="p_del">-hrtimer_force_reprogram</span>
<span class="p_del">-hrtimer_get_next_event</span>
<span class="p_del">-hrtimer_interrupt</span>
<span class="p_del">-sys_nanosleep</span>
<span class="p_del">-hrtimer_nanosleep</span>
<span class="p_del">-hrtimer_wakeup</span>
<span class="p_del">-hrtimer_get_remaining</span>
<span class="p_del">-hrtimer_get_res</span>
<span class="p_del">-hrtimer_init_sleeper</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-The set_ftrace_notrace prevents those functions from being</span>
<span class="p_del">-traced.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo &#39;*preempt*&#39; &#39;*lock*&#39; &gt; set_ftrace_notrace</span>
<span class="p_del">-</span>
<span class="p_del">-Produces:</span>
<span class="p_del">-</span>
<span class="p_del">-# tracer: function</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 39608/39608   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324896: file_ra_state_init &lt;-do_dentry_open</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324897: open_check_o_direct &lt;-do_last</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324897: ima_file_check &lt;-do_last</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324898: process_measurement &lt;-ima_file_check</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324898: ima_get_action &lt;-process_measurement</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324898: ima_match_policy &lt;-ima_get_action</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324899: do_truncate &lt;-do_last</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324899: should_remove_suid &lt;-do_truncate</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324899: notify_change &lt;-do_truncate</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324900: current_fs_time &lt;-notify_change</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324900: current_kernel_time &lt;-current_fs_time</span>
<span class="p_del">-            bash-1994  [000] ....  4342.324900: timespec_trunc &lt;-current_fs_time</span>
<span class="p_del">-</span>
<span class="p_del">-We can see that there&#39;s no more lock or preempt tracing.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Dynamic ftrace with the function graph tracer</span>
<span class="p_del">----------------------------------------------</span>
<span class="p_del">-</span>
<span class="p_del">-Although what has been explained above concerns both the</span>
<span class="p_del">-function tracer and the function-graph-tracer, there are some</span>
<span class="p_del">-special features only available in the function-graph tracer.</span>
<span class="p_del">-</span>
<span class="p_del">-If you want to trace only one function and all of its children,</span>
<span class="p_del">-you just have to echo its name into set_graph_function:</span>
<span class="p_del">-</span>
<span class="p_del">- echo __do_fault &gt; set_graph_function</span>
<span class="p_del">-</span>
<span class="p_del">-will produce the following &quot;expanded&quot; trace of the __do_fault()</span>
<span class="p_del">-function:</span>
<span class="p_del">-</span>
<span class="p_del">- 0)               |  __do_fault() {</span>
<span class="p_del">- 0)               |    filemap_fault() {</span>
<span class="p_del">- 0)               |      find_lock_page() {</span>
<span class="p_del">- 0)   0.804 us    |        find_get_page();</span>
<span class="p_del">- 0)               |        __might_sleep() {</span>
<span class="p_del">- 0)   1.329 us    |        }</span>
<span class="p_del">- 0)   3.904 us    |      }</span>
<span class="p_del">- 0)   4.979 us    |    }</span>
<span class="p_del">- 0)   0.653 us    |    _spin_lock();</span>
<span class="p_del">- 0)   0.578 us    |    page_add_file_rmap();</span>
<span class="p_del">- 0)   0.525 us    |    native_set_pte_at();</span>
<span class="p_del">- 0)   0.585 us    |    _spin_unlock();</span>
<span class="p_del">- 0)               |    unlock_page() {</span>
<span class="p_del">- 0)   0.541 us    |      page_waitqueue();</span>
<span class="p_del">- 0)   0.639 us    |      __wake_up_bit();</span>
<span class="p_del">- 0)   2.786 us    |    }</span>
<span class="p_del">- 0) + 14.237 us   |  }</span>
<span class="p_del">- 0)               |  __do_fault() {</span>
<span class="p_del">- 0)               |    filemap_fault() {</span>
<span class="p_del">- 0)               |      find_lock_page() {</span>
<span class="p_del">- 0)   0.698 us    |        find_get_page();</span>
<span class="p_del">- 0)               |        __might_sleep() {</span>
<span class="p_del">- 0)   1.412 us    |        }</span>
<span class="p_del">- 0)   3.950 us    |      }</span>
<span class="p_del">- 0)   5.098 us    |    }</span>
<span class="p_del">- 0)   0.631 us    |    _spin_lock();</span>
<span class="p_del">- 0)   0.571 us    |    page_add_file_rmap();</span>
<span class="p_del">- 0)   0.526 us    |    native_set_pte_at();</span>
<span class="p_del">- 0)   0.586 us    |    _spin_unlock();</span>
<span class="p_del">- 0)               |    unlock_page() {</span>
<span class="p_del">- 0)   0.533 us    |      page_waitqueue();</span>
<span class="p_del">- 0)   0.638 us    |      __wake_up_bit();</span>
<span class="p_del">- 0)   2.793 us    |    }</span>
<span class="p_del">- 0) + 14.012 us   |  }</span>
<span class="p_del">-</span>
<span class="p_del">-You can also expand several functions at once:</span>
<span class="p_del">-</span>
<span class="p_del">- echo sys_open &gt; set_graph_function</span>
<span class="p_del">- echo sys_close &gt;&gt; set_graph_function</span>
<span class="p_del">-</span>
<span class="p_del">-Now if you want to go back to trace all functions you can clear</span>
<span class="p_del">-this special filter via:</span>
<span class="p_del">-</span>
<span class="p_del">- echo &gt; set_graph_function</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-ftrace_enabled</span>
<span class="p_del">---------------</span>
<span class="p_del">-</span>
<span class="p_del">-Note, the proc sysctl ftrace_enable is a big on/off switch for the</span>
<span class="p_del">-function tracer. By default it is enabled (when function tracing is</span>
<span class="p_del">-enabled in the kernel). If it is disabled, all function tracing is</span>
<span class="p_del">-disabled. This includes not only the function tracers for ftrace, but</span>
<span class="p_del">-also for any other uses (perf, kprobes, stack tracing, profiling, etc).</span>
<span class="p_del">-</span>
<span class="p_del">-Please disable this with care.</span>
<span class="p_del">-</span>
<span class="p_del">-This can be disable (and enabled) with:</span>
<span class="p_del">-</span>
<span class="p_del">-  sysctl kernel.ftrace_enabled=0</span>
<span class="p_del">-  sysctl kernel.ftrace_enabled=1</span>
<span class="p_del">-</span>
<span class="p_del">- or</span>
<span class="p_del">-</span>
<span class="p_del">-  echo 0 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span class="p_del">-  echo 1 &gt; /proc/sys/kernel/ftrace_enabled</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Filter commands</span>
<span class="p_del">----------------</span>
<span class="p_del">-</span>
<span class="p_del">-A few commands are supported by the set_ftrace_filter interface.</span>
<span class="p_del">-Trace commands have the following format:</span>
<span class="p_del">-</span>
<span class="p_del">-&lt;function&gt;:&lt;command&gt;:&lt;parameter&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-The following commands are supported:</span>
<span class="p_del">-</span>
<span class="p_del">-- mod</span>
<span class="p_del">-  This command enables function filtering per module. The</span>
<span class="p_del">-  parameter defines the module. For example, if only the write*</span>
<span class="p_del">-  functions in the ext3 module are desired, run:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;write*:mod:ext3&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  This command interacts with the filter in the same way as</span>
<span class="p_del">-  filtering based on function names. Thus, adding more functions</span>
<span class="p_del">-  in a different module is accomplished by appending (&gt;&gt;) to the</span>
<span class="p_del">-  filter file. Remove specific module functions by prepending</span>
<span class="p_del">-  &#39;!&#39;:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;!writeback*:mod:ext3&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  Mod command supports module globbing. Disable tracing for all</span>
<span class="p_del">-  functions except a specific module:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;!*:mod:!ext3&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  Disable tracing for all modules, but still trace kernel:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;!*:mod:*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  Enable filter only for kernel:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;*write*:mod:!*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  Enable filter for module globbing:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;*write*:mod:*snd*&#39; &gt;&gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-- traceon/traceoff</span>
<span class="p_del">-  These commands turn tracing on and off when the specified</span>
<span class="p_del">-  functions are hit. The parameter determines how many times the</span>
<span class="p_del">-  tracing system is turned on and off. If unspecified, there is</span>
<span class="p_del">-  no limit. For example, to disable tracing when a schedule bug</span>
<span class="p_del">-  is hit the first 5 times, run:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;__schedule_bug:traceoff:5&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  To always disable tracing when __schedule_bug is hit:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;__schedule_bug:traceoff&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  These commands are cumulative whether or not they are appended</span>
<span class="p_del">-  to set_ftrace_filter. To remove a command, prepend it by &#39;!&#39;</span>
<span class="p_del">-  and drop the parameter:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;!__schedule_bug:traceoff:0&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-    The above removes the traceoff command for __schedule_bug</span>
<span class="p_del">-    that have a counter. To remove commands without counters:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;!__schedule_bug:traceoff&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-- snapshot</span>
<span class="p_del">-  Will cause a snapshot to be triggered when the function is hit.</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;native_flush_tlb_others:snapshot&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  To only snapshot once:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;native_flush_tlb_others:snapshot:1&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  To remove the above commands:</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;!native_flush_tlb_others:snapshot&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-   echo &#39;!native_flush_tlb_others:snapshot:0&#39; &gt; set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-- enable_event/disable_event</span>
<span class="p_del">-  These commands can enable or disable a trace event. Note, because</span>
<span class="p_del">-  function tracing callbacks are very sensitive, when these commands</span>
<span class="p_del">-  are registered, the trace point is activated, but disabled in</span>
<span class="p_del">-  a &quot;soft&quot; mode. That is, the tracepoint will be called, but</span>
<span class="p_del">-  just will not be traced. The event tracepoint stays in this mode</span>
<span class="p_del">-  as long as there&#39;s a command that triggers it.</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;try_to_wake_up:enable_event:sched:sched_switch:2&#39; &gt; \</span>
<span class="p_del">-   	 set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-  The format is:</span>
<span class="p_del">-</span>
<span class="p_del">-    &lt;function&gt;:enable_event:&lt;system&gt;:&lt;event&gt;[:count]</span>
<span class="p_del">-    &lt;function&gt;:disable_event:&lt;system&gt;:&lt;event&gt;[:count]</span>
<span class="p_del">-</span>
<span class="p_del">-  To remove the events commands:</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-   echo &#39;!try_to_wake_up:enable_event:sched:sched_switch:0&#39; &gt; \</span>
<span class="p_del">-   	 set_ftrace_filter</span>
<span class="p_del">-   echo &#39;!schedule:disable_event:sched:sched_switch&#39; &gt; \</span>
<span class="p_del">-   	 set_ftrace_filter</span>
<span class="p_del">-</span>
<span class="p_del">-- dump</span>
<span class="p_del">-  When the function is hit, it will dump the contents of the ftrace</span>
<span class="p_del">-  ring buffer to the console. This is useful if you need to debug</span>
<span class="p_del">-  something, and want to dump the trace when a certain function</span>
<span class="p_del">-  is hit. Perhaps its a function that is called before a tripple</span>
<span class="p_del">-  fault happens and does not allow you to get a regular dump.</span>
<span class="p_del">-</span>
<span class="p_del">-- cpudump</span>
<span class="p_del">-  When the function is hit, it will dump the contents of the ftrace</span>
<span class="p_del">-  ring buffer for the current CPU to the console. Unlike the &quot;dump&quot;</span>
<span class="p_del">-  command, it only prints out the contents of the ring buffer for the</span>
<span class="p_del">-  CPU that executed the function that triggered the dump.</span>
<span class="p_del">-</span>
<span class="p_del">-trace_pipe</span>
<span class="p_del">-----------</span>
<span class="p_del">-</span>
<span class="p_del">-The trace_pipe outputs the same content as the trace file, but</span>
<span class="p_del">-the effect on the tracing is different. Every read from</span>
<span class="p_del">-trace_pipe is consumed. This means that subsequent reads will be</span>
<span class="p_del">-different. The trace is live.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo function &gt; current_tracer</span>
<span class="p_del">- # cat trace_pipe &gt; /tmp/trace.out &amp;</span>
<span class="p_del">-[1] 4153</span>
<span class="p_del">- # echo 1 &gt; tracing_on</span>
<span class="p_del">- # usleep 1</span>
<span class="p_del">- # echo 0 &gt; tracing_on</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: function</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 0/0   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-</span>
<span class="p_del">- #</span>
<span class="p_del">- # cat /tmp/trace.out</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568961: mutex_unlock &lt;-rb_simple_write</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568963: __mutex_unlock_slowpath &lt;-mutex_unlock</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568963: __fsnotify_parent &lt;-fsnotify_modify</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568964: fsnotify &lt;-fsnotify_modify</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568964: __srcu_read_lock &lt;-fsnotify</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568964: add_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_del">-            bash-1994  [000] ...1  5281.568965: sub_preempt_count &lt;-__srcu_read_lock</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568965: __srcu_read_unlock &lt;-fsnotify</span>
<span class="p_del">-            bash-1994  [000] ....  5281.568967: sys_dup2 &lt;-system_call_fastpath</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Note, reading the trace_pipe file will block until more input is</span>
<span class="p_del">-added.</span>
<span class="p_del">-</span>
<span class="p_del">-trace entries</span>
<span class="p_del">--------------</span>
<span class="p_del">-</span>
<span class="p_del">-Having too much or not enough data can be troublesome in</span>
<span class="p_del">-diagnosing an issue in the kernel. The file buffer_size_kb is</span>
<span class="p_del">-used to modify the size of the internal trace buffers. The</span>
<span class="p_del">-number listed is the number of entries that can be recorded per</span>
<span class="p_del">-CPU. To know the full size, multiply the number of possible CPUs</span>
<span class="p_del">-with the number of entries.</span>
<span class="p_del">-</span>
<span class="p_del">- # cat buffer_size_kb</span>
<span class="p_del">-1408 (units kilobytes)</span>
<span class="p_del">-</span>
<span class="p_del">-Or simply read buffer_total_size_kb</span>
<span class="p_del">-</span>
<span class="p_del">- # cat buffer_total_size_kb </span>
<span class="p_del">-5632</span>
<span class="p_del">-</span>
<span class="p_del">-To modify the buffer, simple echo in a number (in 1024 byte segments).</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 10000 &gt; buffer_size_kb</span>
<span class="p_del">- # cat buffer_size_kb</span>
<span class="p_del">-10000 (units kilobytes)</span>
<span class="p_del">-</span>
<span class="p_del">-It will try to allocate as much as possible. If you allocate too</span>
<span class="p_del">-much, it can cause Out-Of-Memory to trigger.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 1000000000000 &gt; buffer_size_kb</span>
<span class="p_del">--bash: echo: write error: Cannot allocate memory</span>
<span class="p_del">- # cat buffer_size_kb</span>
<span class="p_del">-85</span>
<span class="p_del">-</span>
<span class="p_del">-The per_cpu buffers can be changed individually as well:</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 10000 &gt; per_cpu/cpu0/buffer_size_kb</span>
<span class="p_del">- # echo 100 &gt; per_cpu/cpu1/buffer_size_kb</span>
<span class="p_del">-</span>
<span class="p_del">-When the per_cpu buffers are not the same, the buffer_size_kb</span>
<span class="p_del">-at the top level will just show an X</span>
<span class="p_del">-</span>
<span class="p_del">- # cat buffer_size_kb</span>
<span class="p_del">-X</span>
<span class="p_del">-</span>
<span class="p_del">-This is where the buffer_total_size_kb is useful:</span>
<span class="p_del">-</span>
<span class="p_del">- # cat buffer_total_size_kb </span>
<span class="p_del">-12916</span>
<span class="p_del">-</span>
<span class="p_del">-Writing to the top level buffer_size_kb will reset all the buffers</span>
<span class="p_del">-to be the same again.</span>
<span class="p_del">-</span>
<span class="p_del">-Snapshot</span>
<span class="p_del">---------</span>
<span class="p_del">-CONFIG_TRACER_SNAPSHOT makes a generic snapshot feature</span>
<span class="p_del">-available to all non latency tracers. (Latency tracers which</span>
<span class="p_del">-record max latency, such as &quot;irqsoff&quot; or &quot;wakeup&quot;, can&#39;t use</span>
<span class="p_del">-this feature, since those are already using the snapshot</span>
<span class="p_del">-mechanism internally.)</span>
<span class="p_del">-</span>
<span class="p_del">-Snapshot preserves a current trace buffer at a particular point</span>
<span class="p_del">-in time without stopping tracing. Ftrace swaps the current</span>
<span class="p_del">-buffer with a spare buffer, and tracing continues in the new</span>
<span class="p_del">-current (=previous spare) buffer.</span>
<span class="p_del">-</span>
<span class="p_del">-The following tracefs files in &quot;tracing&quot; are related to this</span>
<span class="p_del">-feature:</span>
<span class="p_del">-</span>
<span class="p_del">-  snapshot:</span>
<span class="p_del">-</span>
<span class="p_del">-	This is used to take a snapshot and to read the output</span>
<span class="p_del">-	of the snapshot. Echo 1 into this file to allocate a</span>
<span class="p_del">-	spare buffer and to take a snapshot (swap), then read</span>
<span class="p_del">-	the snapshot from this file in the same format as</span>
<span class="p_del">-	&quot;trace&quot; (described above in the section &quot;The File</span>
<span class="p_del">-	System&quot;). Both reads snapshot and tracing are executable</span>
<span class="p_del">-	in parallel. When the spare buffer is allocated, echoing</span>
<span class="p_del">-	0 frees it, and echoing else (positive) values clear the</span>
<span class="p_del">-	snapshot contents.</span>
<span class="p_del">-	More details are shown in the table below.</span>
<span class="p_del">-</span>
<span class="p_del">-	status\input  |     0      |     1      |    else    |</span>
<span class="p_del">-	--------------+------------+------------+------------+</span>
<span class="p_del">-	not allocated |(do nothing)| alloc+swap |(do nothing)|</span>
<span class="p_del">-	--------------+------------+------------+------------+</span>
<span class="p_del">-	allocated     |    free    |    swap    |   clear    |</span>
<span class="p_del">-	--------------+------------+------------+------------+</span>
<span class="p_del">-</span>
<span class="p_del">-Here is an example of using the snapshot feature.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 1 &gt; events/sched/enable</span>
<span class="p_del">- # echo 1 &gt; snapshot</span>
<span class="p_del">- # cat snapshot</span>
<span class="p_del">-# tracer: nop</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 71/71   #P:8</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-          &lt;idle&gt;-0     [005] d...  2440.603828: sched_switch: prev_comm=swapper/5 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2242 next_prio=120</span>
<span class="p_del">-           sleep-2242  [005] d...  2440.603846: sched_switch: prev_comm=snapshot-test-2 prev_pid=2242 prev_prio=120 prev_state=R ==&gt; next_comm=kworker/5:1 next_pid=60 next_prio=120</span>
<span class="p_del">-[...]</span>
<span class="p_del">-          &lt;idle&gt;-0     [002] d...  2440.707230: sched_switch: prev_comm=swapper/2 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2229 next_prio=120</span>
<span class="p_del">-</span>
<span class="p_del">- # cat trace</span>
<span class="p_del">-# tracer: nop</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 77/77   #P:8</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-          &lt;idle&gt;-0     [007] d...  2440.707395: sched_switch: prev_comm=swapper/7 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=snapshot-test-2 next_pid=2243 next_prio=120</span>
<span class="p_del">- snapshot-test-2-2229  [002] d...  2440.707438: sched_switch: prev_comm=snapshot-test-2 prev_pid=2229 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/2 next_pid=0 next_prio=120</span>
<span class="p_del">-[...]</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-If you try to use this snapshot feature when current tracer is</span>
<span class="p_del">-one of the latency tracers, you will get the following results.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo wakeup &gt; current_tracer</span>
<span class="p_del">- # echo 1 &gt; snapshot</span>
<span class="p_del">-bash: echo: write error: Device or resource busy</span>
<span class="p_del">- # cat snapshot</span>
<span class="p_del">-cat: snapshot: Device or resource busy</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Instances</span>
<span class="p_del">----------</span>
<span class="p_del">-In the tracefs tracing directory is a directory called &quot;instances&quot;.</span>
<span class="p_del">-This directory can have new directories created inside of it using</span>
<span class="p_del">-mkdir, and removing directories with rmdir. The directory created</span>
<span class="p_del">-with mkdir in this directory will already contain files and other</span>
<span class="p_del">-directories after it is created.</span>
<span class="p_del">-</span>
<span class="p_del">- # mkdir instances/foo</span>
<span class="p_del">- # ls instances/foo</span>
<span class="p_del">-buffer_size_kb  buffer_total_size_kb  events  free_buffer  per_cpu</span>
<span class="p_del">-set_event  snapshot  trace  trace_clock  trace_marker  trace_options</span>
<span class="p_del">-trace_pipe  tracing_on</span>
<span class="p_del">-</span>
<span class="p_del">-As you can see, the new directory looks similar to the tracing directory</span>
<span class="p_del">-itself. In fact, it is very similar, except that the buffer and</span>
<span class="p_del">-events are agnostic from the main director, or from any other</span>
<span class="p_del">-instances that are created.</span>
<span class="p_del">-</span>
<span class="p_del">-The files in the new directory work just like the files with the</span>
<span class="p_del">-same name in the tracing directory except the buffer that is used</span>
<span class="p_del">-is a separate and new buffer. The files affect that buffer but do not</span>
<span class="p_del">-affect the main buffer with the exception of trace_options. Currently,</span>
<span class="p_del">-the trace_options affect all instances and the top level buffer</span>
<span class="p_del">-the same, but this may change in future releases. That is, options</span>
<span class="p_del">-may become specific to the instance they reside in.</span>
<span class="p_del">-</span>
<span class="p_del">-Notice that none of the function tracer files are there, nor is</span>
<span class="p_del">-current_tracer and available_tracers. This is because the buffers</span>
<span class="p_del">-can currently only have events enabled for them.</span>
<span class="p_del">-</span>
<span class="p_del">- # mkdir instances/foo</span>
<span class="p_del">- # mkdir instances/bar</span>
<span class="p_del">- # mkdir instances/zoot</span>
<span class="p_del">- # echo 100000 &gt; buffer_size_kb</span>
<span class="p_del">- # echo 1000 &gt; instances/foo/buffer_size_kb</span>
<span class="p_del">- # echo 5000 &gt; instances/bar/per_cpu/cpu1/buffer_size_kb</span>
<span class="p_del">- # echo function &gt; current_trace</span>
<span class="p_del">- # echo 1 &gt; instances/foo/events/sched/sched_wakeup/enable</span>
<span class="p_del">- # echo 1 &gt; instances/foo/events/sched/sched_wakeup_new/enable</span>
<span class="p_del">- # echo 1 &gt; instances/foo/events/sched/sched_switch/enable</span>
<span class="p_del">- # echo 1 &gt; instances/bar/events/irq/enable</span>
<span class="p_del">- # echo 1 &gt; instances/zoot/events/syscalls/enable</span>
<span class="p_del">- # cat trace_pipe</span>
<span class="p_del">-CPU:2 [LOST 11745 EVENTS]</span>
<span class="p_del">-            bash-2044  [002] .... 10594.481032: _raw_spin_lock_irqsave &lt;-get_page_from_freelist</span>
<span class="p_del">-            bash-2044  [002] d... 10594.481032: add_preempt_count &lt;-_raw_spin_lock_irqsave</span>
<span class="p_del">-            bash-2044  [002] d..1 10594.481032: __rmqueue &lt;-get_page_from_freelist</span>
<span class="p_del">-            bash-2044  [002] d..1 10594.481033: _raw_spin_unlock &lt;-get_page_from_freelist</span>
<span class="p_del">-            bash-2044  [002] d..1 10594.481033: sub_preempt_count &lt;-_raw_spin_unlock</span>
<span class="p_del">-            bash-2044  [002] d... 10594.481033: get_pageblock_flags_group &lt;-get_pageblock_migratetype</span>
<span class="p_del">-            bash-2044  [002] d... 10594.481034: __mod_zone_page_state &lt;-get_page_from_freelist</span>
<span class="p_del">-            bash-2044  [002] d... 10594.481034: zone_statistics &lt;-get_page_from_freelist</span>
<span class="p_del">-            bash-2044  [002] d... 10594.481034: __inc_zone_state &lt;-zone_statistics</span>
<span class="p_del">-            bash-2044  [002] d... 10594.481034: __inc_zone_state &lt;-zone_statistics</span>
<span class="p_del">-            bash-2044  [002] .... 10594.481035: arch_dup_task_struct &lt;-copy_process</span>
<span class="p_del">-[...]</span>
<span class="p_del">-</span>
<span class="p_del">- # cat instances/foo/trace_pipe</span>
<span class="p_del">-            bash-1998  [000] d..4   136.676759: sched_wakeup: comm=kworker/0:1 pid=59 prio=120 success=1 target_cpu=000</span>
<span class="p_del">-            bash-1998  [000] dN.4   136.676760: sched_wakeup: comm=bash pid=1998 prio=120 success=1 target_cpu=000</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] d.h3   136.676906: sched_wakeup: comm=rcu_preempt pid=9 prio=120 success=1 target_cpu=003</span>
<span class="p_del">-          &lt;idle&gt;-0     [003] d..3   136.676909: sched_switch: prev_comm=swapper/3 prev_pid=0 prev_prio=120 prev_state=R ==&gt; next_comm=rcu_preempt next_pid=9 next_prio=120</span>
<span class="p_del">-     rcu_preempt-9     [003] d..3   136.676916: sched_switch: prev_comm=rcu_preempt prev_pid=9 prev_prio=120 prev_state=S ==&gt; next_comm=swapper/3 next_pid=0 next_prio=120</span>
<span class="p_del">-            bash-1998  [000] d..4   136.677014: sched_wakeup: comm=kworker/0:1 pid=59 prio=120 success=1 target_cpu=000</span>
<span class="p_del">-            bash-1998  [000] dN.4   136.677016: sched_wakeup: comm=bash pid=1998 prio=120 success=1 target_cpu=000</span>
<span class="p_del">-            bash-1998  [000] d..3   136.677018: sched_switch: prev_comm=bash prev_pid=1998 prev_prio=120 prev_state=R+ ==&gt; next_comm=kworker/0:1 next_pid=59 next_prio=120</span>
<span class="p_del">-     kworker/0:1-59    [000] d..4   136.677022: sched_wakeup: comm=sshd pid=1995 prio=120 success=1 target_cpu=001</span>
<span class="p_del">-     kworker/0:1-59    [000] d..3   136.677025: sched_switch: prev_comm=kworker/0:1 prev_pid=59 prev_prio=120 prev_state=S ==&gt; next_comm=bash next_pid=1998 next_prio=120</span>
<span class="p_del">-[...]</span>
<span class="p_del">-</span>
<span class="p_del">- # cat instances/bar/trace_pipe</span>
<span class="p_del">-     migration/1-14    [001] d.h3   138.732674: softirq_raise: vec=3 [action=NET_RX]</span>
<span class="p_del">-          &lt;idle&gt;-0     [001] dNh3   138.732725: softirq_raise: vec=3 [action=NET_RX]</span>
<span class="p_del">-            bash-1998  [000] d.h1   138.733101: softirq_raise: vec=1 [action=TIMER]</span>
<span class="p_del">-            bash-1998  [000] d.h1   138.733102: softirq_raise: vec=9 [action=RCU]</span>
<span class="p_del">-            bash-1998  [000] ..s2   138.733105: softirq_entry: vec=1 [action=TIMER]</span>
<span class="p_del">-            bash-1998  [000] ..s2   138.733106: softirq_exit: vec=1 [action=TIMER]</span>
<span class="p_del">-            bash-1998  [000] ..s2   138.733106: softirq_entry: vec=9 [action=RCU]</span>
<span class="p_del">-            bash-1998  [000] ..s2   138.733109: softirq_exit: vec=9 [action=RCU]</span>
<span class="p_del">-            sshd-1995  [001] d.h1   138.733278: irq_handler_entry: irq=21 name=uhci_hcd:usb4</span>
<span class="p_del">-            sshd-1995  [001] d.h1   138.733280: irq_handler_exit: irq=21 ret=unhandled</span>
<span class="p_del">-            sshd-1995  [001] d.h1   138.733281: irq_handler_entry: irq=21 name=eth0</span>
<span class="p_del">-            sshd-1995  [001] d.h1   138.733283: irq_handler_exit: irq=21 ret=handled</span>
<span class="p_del">-[...]</span>
<span class="p_del">-</span>
<span class="p_del">- # cat instances/zoot/trace</span>
<span class="p_del">-# tracer: nop</span>
<span class="p_del">-#</span>
<span class="p_del">-# entries-in-buffer/entries-written: 18996/18996   #P:4</span>
<span class="p_del">-#</span>
<span class="p_del">-#                              _-----=&gt; irqs-off</span>
<span class="p_del">-#                             / _----=&gt; need-resched</span>
<span class="p_del">-#                            | / _---=&gt; hardirq/softirq</span>
<span class="p_del">-#                            || / _--=&gt; preempt-depth</span>
<span class="p_del">-#                            ||| /     delay</span>
<span class="p_del">-#           TASK-PID   CPU#  ||||    TIMESTAMP  FUNCTION</span>
<span class="p_del">-#              | |       |   ||||       |         |</span>
<span class="p_del">-            bash-1998  [000] d...   140.733501: sys_write -&gt; 0x2</span>
<span class="p_del">-            bash-1998  [000] d...   140.733504: sys_dup2(oldfd: a, newfd: 1)</span>
<span class="p_del">-            bash-1998  [000] d...   140.733506: sys_dup2 -&gt; 0x1</span>
<span class="p_del">-            bash-1998  [000] d...   140.733508: sys_fcntl(fd: a, cmd: 1, arg: 0)</span>
<span class="p_del">-            bash-1998  [000] d...   140.733509: sys_fcntl -&gt; 0x1</span>
<span class="p_del">-            bash-1998  [000] d...   140.733510: sys_close(fd: a)</span>
<span class="p_del">-            bash-1998  [000] d...   140.733510: sys_close -&gt; 0x0</span>
<span class="p_del">-            bash-1998  [000] d...   140.733514: sys_rt_sigprocmask(how: 0, nset: 0, oset: 6e2768, sigsetsize: 8)</span>
<span class="p_del">-            bash-1998  [000] d...   140.733515: sys_rt_sigprocmask -&gt; 0x0</span>
<span class="p_del">-            bash-1998  [000] d...   140.733516: sys_rt_sigaction(sig: 2, act: 7fff718846f0, oact: 7fff71884650, sigsetsize: 8)</span>
<span class="p_del">-            bash-1998  [000] d...   140.733516: sys_rt_sigaction -&gt; 0x0</span>
<span class="p_del">-</span>
<span class="p_del">-You can see that the trace of the top most trace buffer shows only</span>
<span class="p_del">-the function tracing. The foo instance displays wakeups and task</span>
<span class="p_del">-switches.</span>
<span class="p_del">-</span>
<span class="p_del">-To remove the instances, simply delete their directories:</span>
<span class="p_del">-</span>
<span class="p_del">- # rmdir instances/foo</span>
<span class="p_del">- # rmdir instances/bar</span>
<span class="p_del">- # rmdir instances/zoot</span>
<span class="p_del">-</span>
<span class="p_del">-Note, if a process has a trace file open in one of the instance</span>
<span class="p_del">-directories, the rmdir will fail with EBUSY.</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-Stack trace</span>
<span class="p_del">------------</span>
<span class="p_del">-Since the kernel has a fixed sized stack, it is important not to</span>
<span class="p_del">-waste it in functions. A kernel developer must be conscience of</span>
<span class="p_del">-what they allocate on the stack. If they add too much, the system</span>
<span class="p_del">-can be in danger of a stack overflow, and corruption will occur,</span>
<span class="p_del">-usually leading to a system panic.</span>
<span class="p_del">-</span>
<span class="p_del">-There are some tools that check this, usually with interrupts</span>
<span class="p_del">-periodically checking usage. But if you can perform a check</span>
<span class="p_del">-at every function call that will become very useful. As ftrace provides</span>
<span class="p_del">-a function tracer, it makes it convenient to check the stack size</span>
<span class="p_del">-at every function call. This is enabled via the stack tracer.</span>
<span class="p_del">-</span>
<span class="p_del">-CONFIG_STACK_TRACER enables the ftrace stack tracing functionality.</span>
<span class="p_del">-To enable it, write a &#39;1&#39; into /proc/sys/kernel/stack_tracer_enabled.</span>
<span class="p_del">-</span>
<span class="p_del">- # echo 1 &gt; /proc/sys/kernel/stack_tracer_enabled</span>
<span class="p_del">-</span>
<span class="p_del">-You can also enable it from the kernel command line to trace</span>
<span class="p_del">-the stack size of the kernel during boot up, by adding &quot;stacktrace&quot;</span>
<span class="p_del">-to the kernel command line parameter.</span>
<span class="p_del">-</span>
<span class="p_del">-After running it for a few minutes, the output looks like:</span>
<span class="p_del">-</span>
<span class="p_del">- # cat stack_max_size</span>
<span class="p_del">-2928</span>
<span class="p_del">-</span>
<span class="p_del">- # cat stack_trace</span>
<span class="p_del">-        Depth    Size   Location    (18 entries)</span>
<span class="p_del">-        -----    ----   --------</span>
<span class="p_del">-  0)     2928     224   update_sd_lb_stats+0xbc/0x4ac</span>
<span class="p_del">-  1)     2704     160   find_busiest_group+0x31/0x1f1</span>
<span class="p_del">-  2)     2544     256   load_balance+0xd9/0x662</span>
<span class="p_del">-  3)     2288      80   idle_balance+0xbb/0x130</span>
<span class="p_del">-  4)     2208     128   __schedule+0x26e/0x5b9</span>
<span class="p_del">-  5)     2080      16   schedule+0x64/0x66</span>
<span class="p_del">-  6)     2064     128   schedule_timeout+0x34/0xe0</span>
<span class="p_del">-  7)     1936     112   wait_for_common+0x97/0xf1</span>
<span class="p_del">-  8)     1824      16   wait_for_completion+0x1d/0x1f</span>
<span class="p_del">-  9)     1808     128   flush_work+0xfe/0x119</span>
<span class="p_del">- 10)     1680      16   tty_flush_to_ldisc+0x1e/0x20</span>
<span class="p_del">- 11)     1664      48   input_available_p+0x1d/0x5c</span>
<span class="p_del">- 12)     1616      48   n_tty_poll+0x6d/0x134</span>
<span class="p_del">- 13)     1568      64   tty_poll+0x64/0x7f</span>
<span class="p_del">- 14)     1504     880   do_select+0x31e/0x511</span>
<span class="p_del">- 15)      624     400   core_sys_select+0x177/0x216</span>
<span class="p_del">- 16)      224      96   sys_select+0x91/0xb9</span>
<span class="p_del">- 17)      128     128   system_call_fastpath+0x16/0x1b</span>
<span class="p_del">-</span>
<span class="p_del">-Note, if -mfentry is being used by gcc, functions get traced before</span>
<span class="p_del">-they set up the stack frame. This means that leaf level functions</span>
<span class="p_del">-are not tested by the stack tracer when -mfentry is used.</span>
<span class="p_del">-</span>
<span class="p_del">-Currently, -mfentry is used by gcc 4.6.0 and above on x86 only.</span>
<span class="p_del">-</span>
<span class="p_del">----------</span>
<span class="p_del">-</span>
<span class="p_del">-More details can be found in the source code, in the</span>
<span class="p_del">-kernel/trace/*.c files.</span>
<span class="p_header">diff --git a/Documentation/trace/index.rst b/Documentation/trace/index.rst</span>
<span class="p_header">index 61b5551..947c6db 100644</span>
<span class="p_header">--- a/Documentation/trace/index.rst</span>
<span class="p_header">+++ b/Documentation/trace/index.rst</span>
<span class="p_chunk">@@ -7,4 +7,5 @@</span> <span class="p_context"> Linux Tracing Technologies</span>
 
    ftrace-design
    tracepoint-analysis
<span class="p_add">+   ftrace</span>
    ftrace-uses

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



