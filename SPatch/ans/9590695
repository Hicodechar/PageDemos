
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3/5] x86/xen: put setup.c, mmu.c and p2m.c under CONFIG_XEN_PV - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3/5] x86/xen: put setup.c, mmu.c and p2m.c under CONFIG_XEN_PV</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=99981">Vitaly Kuznetsov</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 24, 2017, 4:14 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170224161440.2136-4-vkuznets@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9590695/mbox/"
   >mbox</a>
|
   <a href="/patch/9590695/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9590695/">/patch/9590695/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	C1017604A2 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Feb 2017 16:16:52 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BCAEE286E0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Feb 2017 16:16:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B070F2871F; Fri, 24 Feb 2017 16:16:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D5DCE286E0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Feb 2017 16:16:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751808AbdBXQQm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 24 Feb 2017 11:16:42 -0500
Received: from mx1.redhat.com ([209.132.183.28]:38394 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751315AbdBXQOt (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 24 Feb 2017 11:14:49 -0500
Received: from int-mx10.intmail.prod.int.phx2.redhat.com
	(int-mx10.intmail.prod.int.phx2.redhat.com [10.5.11.23])
	(using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256
	bits)) (No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id D0DBA8048F;
	Fri, 24 Feb 2017 16:14:49 +0000 (UTC)
Received: from vitty.brq.redhat.com (vitty.brq.redhat.com [10.34.26.3])
	by int-mx10.intmail.prod.int.phx2.redhat.com (8.14.4/8.14.4) with
	ESMTP id v1OGEfpJ012338; Fri, 24 Feb 2017 11:14:47 -0500
From: Vitaly Kuznetsov &lt;vkuznets@redhat.com&gt;
To: xen-devel@lists.xenproject.org
Cc: x86@kernel.org, linux-kernel@vger.kernel.org,
	Boris Ostrovsky &lt;boris.ostrovsky@oracle.com&gt;,
	Juergen Gross &lt;jgross@suse.com&gt;, Andrew Jones &lt;drjones@redhat.com&gt;
Subject: [PATCH 3/5] x86/xen: put setup.c,
	mmu.c and p2m.c under CONFIG_XEN_PV
Date: Fri, 24 Feb 2017 17:14:38 +0100
Message-Id: &lt;20170224161440.2136-4-vkuznets@redhat.com&gt;
In-Reply-To: &lt;20170224161440.2136-1-vkuznets@redhat.com&gt;
References: &lt;20170224161440.2136-1-vkuznets@redhat.com&gt;
X-Scanned-By: MIMEDefang 2.68 on 10.5.11.23
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.28]);
	Fri, 24 Feb 2017 16:14:49 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=99981">Vitaly Kuznetsov</a> - Feb. 24, 2017, 4:14 p.m.</div>
<pre class="content">
These three files (mmu.c, p2m.c, setup.c) are mostly required to support
PV guests, in fact p2m.c and setup.c have no code for PVHVM at all. mmu.c
has some, split the file into mmu.c, mmu_pv.c and mmu_hvm.c.

Some additional changes are required:
- In the balloon driver we can&#39;t use xen_start_info, xen_released_pages
  and xen_extra_mem it is PV-only. Decorate it with #ifdef CONFIG_XEN_PV

- Some PV-only functions are used by drivers and for PVHVM guests these
  functions have &#39;if (xen_feature(XENFEAT_auto_translated_physmap))&#39; check
  in the beginning. Create required stubs for PVHVM-only builds.
<span class="signed-off-by">
Signed-off-by: Vitaly Kuznetsov &lt;vkuznets@redhat.com&gt;</span>
---
 arch/x86/include/asm/xen/page.h |   44 +-
 arch/x86/xen/Makefile           |   12 +-
 arch/x86/xen/mmu.c              | 2778 +--------------------------------------
 arch/x86/xen/mmu_hvm.c          |   77 ++
 arch/x86/xen/mmu_pv.c           | 2636 +++++++++++++++++++++++++++++++++++++
 drivers/xen/balloon.c           |   30 +-
 include/xen/xen-ops.h           |   13 +
 7 files changed, 2831 insertions(+), 2759 deletions(-)
 create mode 100644 arch/x86/xen/mmu_hvm.c
 create mode 100644 arch/x86/xen/mmu_pv.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=100191">Juergen Gross</a> - March 1, 2017, 6:25 a.m.</div>
<pre class="content">
On 24/02/17 17:14, Vitaly Kuznetsov wrote:
<span class="quote">&gt; These three files (mmu.c, p2m.c, setup.c) are mostly required to support</span>
<span class="quote">&gt; PV guests, in fact p2m.c and setup.c have no code for PVHVM at all. mmu.c</span>
<span class="quote">&gt; has some, split the file into mmu.c, mmu_pv.c and mmu_hvm.c.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Some additional changes are required:</span>
<span class="quote">&gt; - In the balloon driver we can&#39;t use xen_start_info, xen_released_pages</span>
<span class="quote">&gt;   and xen_extra_mem it is PV-only. Decorate it with #ifdef CONFIG_XEN_PV</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; - Some PV-only functions are used by drivers and for PVHVM guests these</span>
<span class="quote">&gt;   functions have &#39;if (xen_feature(XENFEAT_auto_translated_physmap))&#39; check</span>
<span class="quote">&gt;   in the beginning. Create required stubs for PVHVM-only builds.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Vitaly Kuznetsov &lt;vkuznets@redhat.com&gt;</span>

And again: split the patch up, please.


Juergen
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/xen/page.h b/arch/x86/include/asm/xen/page.h</span>
<span class="p_header">index 33cbd3d..c8a347f 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/xen/page.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/xen/page.h</span>
<span class="p_chunk">@@ -43,9 +43,10 @@</span> <span class="p_context"> extern unsigned long *xen_p2m_addr;</span>
 extern unsigned long  xen_p2m_size;
 extern unsigned long  xen_max_p2m_pfn;
 
<span class="p_del">-extern int xen_alloc_p2m_entry(unsigned long pfn);</span>
<span class="p_del">-</span>
 extern unsigned long get_phys_to_machine(unsigned long pfn);
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_XEN_PV</span>
<span class="p_add">+extern int xen_alloc_p2m_entry(unsigned long pfn);</span>
 extern bool set_phys_to_machine(unsigned long pfn, unsigned long mfn);
 extern bool __set_phys_to_machine(unsigned long pfn, unsigned long mfn);
 extern unsigned long __init set_phys_range_identity(unsigned long pfn_s,
<span class="p_chunk">@@ -57,6 +58,38 @@</span> <span class="p_context"> extern int set_foreign_p2m_mapping(struct gnttab_map_grant_ref *map_ops,</span>
 extern int clear_foreign_p2m_mapping(struct gnttab_unmap_grant_ref *unmap_ops,
 				     struct gnttab_unmap_grant_ref *kunmap_ops,
 				     struct page **pages, unsigned int count);
<span class="p_add">+#else /* CONFIG_XEN_PV */</span>
<span class="p_add">+static inline int xen_alloc_p2m_entry(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool set_phys_to_machine(unsigned long pfn, unsigned long mfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool __set_phys_to_machine(unsigned long pfn, unsigned long mfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+set_foreign_p2m_mapping(struct gnttab_map_grant_ref *map_ops,</span>
<span class="p_add">+			struct gnttab_map_grant_ref *kmap_ops,</span>
<span class="p_add">+			struct page **pages, unsigned int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+clear_foreign_p2m_mapping(struct gnttab_unmap_grant_ref *unmap_ops,</span>
<span class="p_add">+			  struct gnttab_unmap_grant_ref *kunmap_ops,</span>
<span class="p_add">+			  struct page **pages, unsigned int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_XEN_PV */</span>
 
 /*
  * Helper functions to write or read unsigned long values to/from
<span class="p_chunk">@@ -82,6 +115,7 @@</span> <span class="p_context"> static inline int xen_safe_read_ulong(unsigned long *addr, unsigned long *val)</span>
  * - get_phys_to_machine() is to be called by __pfn_to_mfn() only in special
  *   cases needing an extended handling.
  */
<span class="p_add">+#ifdef CONFIG_XEN_PV</span>
 static inline unsigned long __pfn_to_mfn(unsigned long pfn)
 {
 	unsigned long mfn;
<span class="p_chunk">@@ -98,6 +132,12 @@</span> <span class="p_context"> static inline unsigned long __pfn_to_mfn(unsigned long pfn)</span>
 
 	return mfn;
 }
<span class="p_add">+#else</span>
<span class="p_add">+static inline unsigned long __pfn_to_mfn(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pfn;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
 
 static inline unsigned long pfn_to_mfn(unsigned long pfn)
 {
<span class="p_header">diff --git a/arch/x86/xen/Makefile b/arch/x86/xen/Makefile</span>
<span class="p_header">index ed6f126..3bf840e 100644</span>
<span class="p_header">--- a/arch/x86/xen/Makefile</span>
<span class="p_header">+++ b/arch/x86/xen/Makefile</span>
<span class="p_chunk">@@ -8,15 +8,15 @@</span> <span class="p_context"> endif</span>
 # Make sure early boot has no stackprotector
 nostackp := $(call cc-option, -fno-stack-protector)
 CFLAGS_enlighten_pv.o		:= $(nostackp)
<span class="p_del">-CFLAGS_mmu.o			:= $(nostackp)</span>
<span class="p_add">+CFLAGS_mmu_pv.o			:= $(nostackp)</span>
 
<span class="p_del">-obj-y		:= enlighten.o setup.o multicalls.o \</span>
<span class="p_del">-			mmu.o irq.o time.o xen-asm.o xen-asm_$(BITS).o \</span>
<span class="p_add">+obj-y		:= enlighten.o multicalls.o \</span>
<span class="p_add">+			irq.o time.o xen-asm.o xen-asm_$(BITS).o \</span>
 			grant-table.o suspend.o platform-pci-unplug.o \
<span class="p_del">-			p2m.o apic.o pmu.o</span>
<span class="p_add">+			apic.o pmu.o mmu.o</span>
 
<span class="p_del">-obj-$(CONFIG_XEN_PV)		+= enlighten_pv.o</span>
<span class="p_del">-obj-$(CONFIG_XEN_PVHVM)		+= enlighten_hvm.o</span>
<span class="p_add">+obj-$(CONFIG_XEN_PV)		+= enlighten_pv.o setup.o mmu_pv.o p2m.o</span>
<span class="p_add">+obj-$(CONFIG_XEN_PVHVM)		+= enlighten_hvm.o mmu_hvm.o</span>
 obj-$(CONFIG_XEN_PVH)		+= enlighten_pvh.o
 
 obj-$(CONFIG_EVENT_TRACING) += trace.o
<span class="p_header">diff --git a/arch/x86/xen/mmu.c b/arch/x86/xen/mmu.c</span>
<span class="p_header">index 881baac..5e375a5 100644</span>
<span class="p_header">--- a/arch/x86/xen/mmu.c</span>
<span class="p_header">+++ b/arch/x86/xen/mmu.c</span>
<span class="p_chunk">@@ -1,2769 +1,66 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Xen mmu operations</span>
<span class="p_del">- *</span>
<span class="p_del">- * This file contains the various mmu fetch and update operations.</span>
<span class="p_del">- * The most important job they must perform is the mapping between the</span>
<span class="p_del">- * domain&#39;s pfn and the overall machine mfns.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Xen allows guests to directly update the pagetable, in a controlled</span>
<span class="p_del">- * fashion.  In other words, the guest modifies the same pagetable</span>
<span class="p_del">- * that the CPU actually uses, which eliminates the overhead of having</span>
<span class="p_del">- * a separate shadow pagetable.</span>
<span class="p_del">- *</span>
<span class="p_del">- * In order to allow this, it falls on the guest domain to map its</span>
<span class="p_del">- * notion of a &quot;physical&quot; pfn - which is just a domain-local linear</span>
<span class="p_del">- * address - into a real &quot;machine address&quot; which the CPU&#39;s MMU can</span>
<span class="p_del">- * use.</span>
<span class="p_del">- *</span>
<span class="p_del">- * A pgd_t/pmd_t/pte_t will typically contain an mfn, and so can be</span>
<span class="p_del">- * inserted directly into the pagetable.  When creating a new</span>
<span class="p_del">- * pte/pmd/pgd, it converts the passed pfn into an mfn.  Conversely,</span>
<span class="p_del">- * when reading the content back with __(pgd|pmd|pte)_val, it converts</span>
<span class="p_del">- * the mfn back into a pfn.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The other constraint is that all pages which make up a pagetable</span>
<span class="p_del">- * must be mapped read-only in the guest.  This prevents uncontrolled</span>
<span class="p_del">- * guest updates to the pagetable.  Xen strictly enforces this, and</span>
<span class="p_del">- * will disallow any pagetable update which will end up mapping a</span>
<span class="p_del">- * pagetable page RW, and will disallow using any writable page as a</span>
<span class="p_del">- * pagetable.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Naively, when loading %cr3 with the base of a new pagetable, Xen</span>
<span class="p_del">- * would need to validate the whole pagetable before going on.</span>
<span class="p_del">- * Naturally, this is quite slow.  The solution is to &quot;pin&quot; a</span>
<span class="p_del">- * pagetable, which enforces all the constraints on the pagetable even</span>
<span class="p_del">- * when it is not actively in use.  This menas that Xen can be assured</span>
<span class="p_del">- * that it is still valid when you do load it into %cr3, and doesn&#39;t</span>
<span class="p_del">- * need to revalidate it.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Jeremy Fitzhardinge &lt;jeremy@xensource.com&gt;, XenSource Inc, 2007</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &lt;linux/sched.h&gt;</span>
<span class="p_del">-#include &lt;linux/highmem.h&gt;</span>
<span class="p_del">-#include &lt;linux/debugfs.h&gt;</span>
<span class="p_del">-#include &lt;linux/bug.h&gt;</span>
<span class="p_del">-#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_del">-#include &lt;linux/export.h&gt;</span>
<span class="p_del">-#include &lt;linux/init.h&gt;</span>
<span class="p_del">-#include &lt;linux/gfp.h&gt;</span>
<span class="p_del">-#include &lt;linux/memblock.h&gt;</span>
<span class="p_del">-#include &lt;linux/seq_file.h&gt;</span>
<span class="p_del">-#include &lt;linux/crash_dump.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;trace/events/xen.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/pgtable.h&gt;</span>
<span class="p_del">-#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_del">-#include &lt;asm/fixmap.h&gt;</span>
<span class="p_del">-#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_del">-#include &lt;asm/setup.h&gt;</span>
<span class="p_del">-#include &lt;asm/paravirt.h&gt;</span>
<span class="p_del">-#include &lt;asm/e820.h&gt;</span>
<span class="p_del">-#include &lt;asm/linkage.h&gt;</span>
<span class="p_del">-#include &lt;asm/page.h&gt;</span>
<span class="p_del">-#include &lt;asm/init.h&gt;</span>
<span class="p_del">-#include &lt;asm/pat.h&gt;</span>
<span class="p_del">-#include &lt;asm/smp.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/xen/hypercall.h&gt;</span>
<span class="p_del">-#include &lt;asm/xen/hypervisor.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;xen/xen.h&gt;</span>
<span class="p_del">-#include &lt;xen/page.h&gt;</span>
<span class="p_del">-#include &lt;xen/interface/xen.h&gt;</span>
<span class="p_del">-#include &lt;xen/interface/hvm/hvm_op.h&gt;</span>
<span class="p_del">-#include &lt;xen/interface/version.h&gt;</span>
<span class="p_del">-#include &lt;xen/interface/memory.h&gt;</span>
<span class="p_del">-#include &lt;xen/hvc-console.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &quot;multicalls.h&quot;</span>
<span class="p_del">-#include &quot;mmu.h&quot;</span>
<span class="p_del">-#include &quot;debugfs.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Protects atomic reservation decrease/increase against concurrent increases.</span>
<span class="p_del">- * Also protects non-atomic updates of current_pages and balloon lists.</span>
<span class="p_del">- */</span>
<span class="p_del">-DEFINE_SPINLOCK(xen_reservation_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Identity map, in addition to plain kernel map.  This needs to be</span>
<span class="p_del">- * large enough to allocate page table pages to allocate the rest.</span>
<span class="p_del">- * Each page can map 2MB.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define LEVEL1_IDENT_ENTRIES	(PTRS_PER_PTE * 4)</span>
<span class="p_del">-static RESERVE_BRK_ARRAY(pte_t, level1_ident_pgt, LEVEL1_IDENT_ENTRIES);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-/* l3 pud for userspace vsyscall mapping */</span>
<span class="p_del">-static pud_t level3_user_vsyscall[PTRS_PER_PUD] __page_aligned_bss;</span>
<span class="p_del">-#endif /* CONFIG_X86_64 */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Note about cr3 (pagetable base) values:</span>
<span class="p_del">- *</span>
<span class="p_del">- * xen_cr3 contains the current logical cr3 value; it contains the</span>
<span class="p_del">- * last set cr3.  This may not be the current effective cr3, because</span>
<span class="p_del">- * its update may be being lazily deferred.  However, a vcpu looking</span>
<span class="p_del">- * at its own cr3 can use this value knowing that it everything will</span>
<span class="p_del">- * be self-consistent.</span>
<span class="p_del">- *</span>
<span class="p_del">- * xen_current_cr3 contains the actual vcpu cr3; it is set once the</span>
<span class="p_del">- * hypercall to set the vcpu cr3 is complete (so it may be a little</span>
<span class="p_del">- * out of date, but it will never be set early).  If one vcpu is</span>
<span class="p_del">- * looking at another vcpu&#39;s cr3 value, it should use this variable.</span>
<span class="p_del">- */</span>
<span class="p_del">-DEFINE_PER_CPU(unsigned long, xen_cr3);	 /* cr3 stored as physaddr */</span>
<span class="p_del">-DEFINE_PER_CPU(unsigned long, xen_current_cr3);	 /* actual vcpu cr3 */</span>
<span class="p_del">-</span>
<span class="p_del">-static phys_addr_t xen_pt_base, xen_pt_size __initdata;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Just beyond the highest usermode address.  STACK_TOP_MAX has a</span>
<span class="p_del">- * redzone above it, so round it up to a PGD boundary.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define USER_LIMIT	((STACK_TOP_MAX + PGDIR_SIZE - 1) &amp; PGDIR_MASK)</span>
<span class="p_del">-</span>
<span class="p_del">-unsigned long arbitrary_virt_to_mfn(void *vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xmaddr_t maddr = arbitrary_virt_to_machine(vaddr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return PFN_DOWN(maddr.maddr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-xmaddr_t arbitrary_virt_to_machine(void *vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long address = (unsigned long)vaddr;</span>
<span class="p_del">-	unsigned int level;</span>
<span class="p_del">-	pte_t *pte;</span>
<span class="p_del">-	unsigned offset;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * if the PFN is in the linear mapped vaddr range, we can just use</span>
<span class="p_del">-	 * the (quick) virt_to_machine() p2m lookup</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (virt_addr_valid(vaddr))</span>
<span class="p_del">-		return virt_to_machine(vaddr);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* otherwise we have to do a (slower) full page-table walk */</span>
<span class="p_del">-</span>
<span class="p_del">-	pte = lookup_address(address, &amp;level);</span>
<span class="p_del">-	BUG_ON(pte == NULL);</span>
<span class="p_del">-	offset = address &amp; ~PAGE_MASK;</span>
<span class="p_del">-	return XMADDR(((phys_addr_t)pte_mfn(*pte) &lt;&lt; PAGE_SHIFT) + offset);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(arbitrary_virt_to_machine);</span>
<span class="p_del">-</span>
<span class="p_del">-void make_lowmem_page_readonly(void *vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pte_t *pte, ptev;</span>
<span class="p_del">-	unsigned long address = (unsigned long)vaddr;</span>
<span class="p_del">-	unsigned int level;</span>
<span class="p_del">-</span>
<span class="p_del">-	pte = lookup_address(address, &amp;level);</span>
<span class="p_del">-	if (pte == NULL)</span>
<span class="p_del">-		return;		/* vaddr missing */</span>
<span class="p_del">-</span>
<span class="p_del">-	ptev = pte_wrprotect(*pte);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (HYPERVISOR_update_va_mapping(address, ptev, 0))</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void make_lowmem_page_readwrite(void *vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pte_t *pte, ptev;</span>
<span class="p_del">-	unsigned long address = (unsigned long)vaddr;</span>
<span class="p_del">-	unsigned int level;</span>
<span class="p_del">-</span>
<span class="p_del">-	pte = lookup_address(address, &amp;level);</span>
<span class="p_del">-	if (pte == NULL)</span>
<span class="p_del">-		return;		/* vaddr missing */</span>
<span class="p_del">-</span>
<span class="p_del">-	ptev = pte_mkwrite(*pte);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (HYPERVISOR_update_va_mapping(address, ptev, 0))</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-static bool xen_page_pinned(void *ptr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct page *page = virt_to_page(ptr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return PagePinned(page);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void xen_set_domain_pte(pte_t *ptep, pte_t pteval, unsigned domid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-	struct mmu_update *u;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_set_domain_pte(ptep, pteval, domid);</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = xen_mc_entry(sizeof(*u));</span>
<span class="p_del">-	u = mcs.args;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* ptep might be kmapped when using 32-bit HIGHPTE */</span>
<span class="p_del">-	u-&gt;ptr = virt_to_machine(ptep).maddr;</span>
<span class="p_del">-	u-&gt;val = pte_val_ma(pteval);</span>
<span class="p_del">-</span>
<span class="p_del">-	MULTI_mmu_update(mcs.mc, mcs.args, 1, NULL, domid);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(xen_set_domain_pte);</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_extend_mmu_update(const struct mmu_update *update)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-	struct mmu_update *u;</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = xen_mc_extend_args(__HYPERVISOR_mmu_update, sizeof(*u));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mcs.mc != NULL) {</span>
<span class="p_del">-		mcs.mc-&gt;args[1]++;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		mcs = __xen_mc_entry(sizeof(*u));</span>
<span class="p_del">-		MULTI_mmu_update(mcs.mc, mcs.args, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	u = mcs.args;</span>
<span class="p_del">-	*u = *update;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_extend_mmuext_op(const struct mmuext_op *op)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-	struct mmuext_op *u;</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = xen_mc_extend_args(__HYPERVISOR_mmuext_op, sizeof(*u));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mcs.mc != NULL) {</span>
<span class="p_del">-		mcs.mc-&gt;args[1]++;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		mcs = __xen_mc_entry(sizeof(*u));</span>
<span class="p_del">-		MULTI_mmuext_op(mcs.mc, mcs.args, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	u = mcs.args;</span>
<span class="p_del">-	*u = *op;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_pmd_hyper(pmd_t *ptr, pmd_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmu_update u;</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* ptr may be ioremapped for 64-bit pagetable setup */</span>
<span class="p_del">-	u.ptr = arbitrary_virt_to_machine(ptr).maddr;</span>
<span class="p_del">-	u.val = pmd_val_ma(val);</span>
<span class="p_del">-	xen_extend_mmu_update(&amp;u);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_pmd(pmd_t *ptr, pmd_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_set_pmd(ptr, val);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If page is not pinned, we can just update the entry</span>
<span class="p_del">-	   directly */</span>
<span class="p_del">-	if (!xen_page_pinned(ptr)) {</span>
<span class="p_del">-		*ptr = val;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_set_pmd_hyper(ptr, val);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Associate a virtual page frame with a given physical page frame</span>
<span class="p_del">- * and protection flags for that frame.</span>
<span class="p_del">- */</span>
<span class="p_del">-void set_pte_mfn(unsigned long vaddr, unsigned long mfn, pgprot_t flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	set_pte_vaddr(vaddr, mfn_pte(mfn, flags));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool xen_batched_set_pte(pte_t *ptep, pte_t pteval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmu_update u;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (paravirt_get_lazy_mode() != PARAVIRT_LAZY_MMU)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	u.ptr = virt_to_machine(ptep).maddr | MMU_NORMAL_PT_UPDATE;</span>
<span class="p_del">-	u.val = pte_val_ma(pteval);</span>
<span class="p_del">-	xen_extend_mmu_update(&amp;u);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __xen_set_pte(pte_t *ptep, pte_t pteval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!xen_batched_set_pte(ptep, pteval)) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Could call native_set_pte() here and trap and</span>
<span class="p_del">-		 * emulate the PTE write but with 32-bit guests this</span>
<span class="p_del">-		 * needs two traps (one for each of the two 32-bit</span>
<span class="p_del">-		 * words in the PTE) so do one hypercall directly</span>
<span class="p_del">-		 * instead.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		struct mmu_update u;</span>
<span class="p_del">-</span>
<span class="p_del">-		u.ptr = virt_to_machine(ptep).maddr | MMU_NORMAL_PT_UPDATE;</span>
<span class="p_del">-		u.val = pte_val_ma(pteval);</span>
<span class="p_del">-		HYPERVISOR_mmu_update(&amp;u, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_pte(pte_t *ptep, pte_t pteval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_set_pte(ptep, pteval);</span>
<span class="p_del">-	__xen_set_pte(ptep, pteval);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-		    pte_t *ptep, pte_t pteval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_set_pte_at(mm, addr, ptep, pteval);</span>
<span class="p_del">-	__xen_set_pte(ptep, pteval);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-pte_t xen_ptep_modify_prot_start(struct mm_struct *mm,</span>
<span class="p_del">-				 unsigned long addr, pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Just return the pte as-is.  We preserve the bits on commit */</span>
<span class="p_del">-	trace_xen_mmu_ptep_modify_prot_start(mm, addr, ptep, *ptep);</span>
<span class="p_del">-	return *ptep;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void xen_ptep_modify_prot_commit(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-				 pte_t *ptep, pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmu_update u;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_ptep_modify_prot_commit(mm, addr, ptep, pte);</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	u.ptr = virt_to_machine(ptep).maddr | MMU_PT_UPDATE_PRESERVE_AD;</span>
<span class="p_del">-	u.val = pte_val_ma(pte);</span>
<span class="p_del">-	xen_extend_mmu_update(&amp;u);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Assume pteval_t is equivalent to all the other *val_t types. */</span>
<span class="p_del">-static pteval_t pte_mfn_to_pfn(pteval_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (val &amp; _PAGE_PRESENT) {</span>
<span class="p_del">-		unsigned long mfn = (val &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-		unsigned long pfn = mfn_to_pfn(mfn);</span>
<span class="p_del">-</span>
<span class="p_del">-		pteval_t flags = val &amp; PTE_FLAGS_MASK;</span>
<span class="p_del">-		if (unlikely(pfn == ~0))</span>
<span class="p_del">-			val = flags &amp; ~_PAGE_PRESENT;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			val = ((pteval_t)pfn &lt;&lt; PAGE_SHIFT) | flags;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return val;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static pteval_t pte_pfn_to_mfn(pteval_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (val &amp; _PAGE_PRESENT) {</span>
<span class="p_del">-		unsigned long pfn = (val &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-		pteval_t flags = val &amp; PTE_FLAGS_MASK;</span>
<span class="p_del">-		unsigned long mfn;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-			mfn = __pfn_to_mfn(pfn);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			mfn = pfn;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If there&#39;s no mfn for the pfn, then just create an</span>
<span class="p_del">-		 * empty non-present pte.  Unfortunately this loses</span>
<span class="p_del">-		 * information about the original pfn, so</span>
<span class="p_del">-		 * pte_mfn_to_pfn is asymmetric.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (unlikely(mfn == INVALID_P2M_ENTRY)) {</span>
<span class="p_del">-			mfn = 0;</span>
<span class="p_del">-			flags = 0;</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			mfn &amp;= ~(FOREIGN_FRAME_BIT | IDENTITY_FRAME_BIT);</span>
<span class="p_del">-		val = ((pteval_t)mfn &lt;&lt; PAGE_SHIFT) | flags;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return val;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-__visible pteval_t xen_pte_val(pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pteval_t pteval = pte.pte;</span>
<span class="p_del">-</span>
<span class="p_del">-	return pte_mfn_to_pfn(pteval);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_pte_val);</span>
<span class="p_del">-</span>
<span class="p_del">-__visible pgdval_t xen_pgd_val(pgd_t pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return pte_mfn_to_pfn(pgd.pgd);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_pgd_val);</span>
<span class="p_del">-</span>
<span class="p_del">-__visible pte_t xen_make_pte(pteval_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pte = pte_pfn_to_mfn(pte);</span>
<span class="p_del">-</span>
<span class="p_del">-	return native_make_pte(pte);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_make_pte);</span>
<span class="p_del">-</span>
<span class="p_del">-__visible pgd_t xen_make_pgd(pgdval_t pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd = pte_pfn_to_mfn(pgd);</span>
<span class="p_del">-	return native_make_pgd(pgd);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_make_pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-__visible pmdval_t xen_pmd_val(pmd_t pmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return pte_mfn_to_pfn(pmd.pmd);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_pmd_val);</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_pud_hyper(pud_t *ptr, pud_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmu_update u;</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* ptr may be ioremapped for 64-bit pagetable setup */</span>
<span class="p_del">-	u.ptr = arbitrary_virt_to_machine(ptr).maddr;</span>
<span class="p_del">-	u.val = pud_val_ma(val);</span>
<span class="p_del">-	xen_extend_mmu_update(&amp;u);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_pud(pud_t *ptr, pud_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_set_pud(ptr, val);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If page is not pinned, we can just update the entry</span>
<span class="p_del">-	   directly */</span>
<span class="p_del">-	if (!xen_page_pinned(ptr)) {</span>
<span class="p_del">-		*ptr = val;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_set_pud_hyper(ptr, val);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-static void xen_set_pte_atomic(pte_t *ptep, pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_set_pte_atomic(ptep, pte);</span>
<span class="p_del">-	set_64bit((u64 *)ptep, native_pte_val(pte));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_pte_clear(mm, addr, ptep);</span>
<span class="p_del">-	if (!xen_batched_set_pte(ptep, native_make_pte(0)))</span>
<span class="p_del">-		native_pte_clear(mm, addr, ptep);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_pmd_clear(pmd_t *pmdp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_pmd_clear(pmdp);</span>
<span class="p_del">-	set_pmd(pmdp, __pmd(0));</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif	/* CONFIG_X86_PAE */</span>
<span class="p_del">-</span>
<span class="p_del">-__visible pmd_t xen_make_pmd(pmdval_t pmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pmd = pte_pfn_to_mfn(pmd);</span>
<span class="p_del">-	return native_make_pmd(pmd);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_make_pmd);</span>
<span class="p_del">-</span>
<span class="p_del">-#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_del">-__visible pudval_t xen_pud_val(pud_t pud)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return pte_mfn_to_pfn(pud.pud);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_pud_val);</span>
<span class="p_del">-</span>
<span class="p_del">-__visible pud_t xen_make_pud(pudval_t pud)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pud = pte_pfn_to_mfn(pud);</span>
<span class="p_del">-</span>
<span class="p_del">-	return native_make_pud(pud);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_make_pud);</span>
<span class="p_del">-</span>
<span class="p_del">-static pgd_t *xen_get_user_pgd(pgd_t *pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *pgd_page = (pgd_t *)(((unsigned long)pgd) &amp; PAGE_MASK);</span>
<span class="p_del">-	unsigned offset = pgd - pgd_page;</span>
<span class="p_del">-	pgd_t *user_ptr = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (offset &lt; pgd_index(USER_LIMIT)) {</span>
<span class="p_del">-		struct page *page = virt_to_page(pgd_page);</span>
<span class="p_del">-		user_ptr = (pgd_t *)page-&gt;private;</span>
<span class="p_del">-		if (user_ptr)</span>
<span class="p_del">-			user_ptr += offset;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return user_ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __xen_set_pgd_hyper(pgd_t *ptr, pgd_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmu_update u;</span>
<span class="p_del">-</span>
<span class="p_del">-	u.ptr = virt_to_machine(ptr).maddr;</span>
<span class="p_del">-	u.val = pgd_val_ma(val);</span>
<span class="p_del">-	xen_extend_mmu_update(&amp;u);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Raw hypercall-based set_pgd, intended for in early boot before</span>
<span class="p_del">- * there&#39;s a page structure.  This implies:</span>
<span class="p_del">- *  1. The only existing pagetable is the kernel&#39;s</span>
<span class="p_del">- *  2. It is always pinned</span>
<span class="p_del">- *  3. It has no user pagetable attached to it</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __init xen_set_pgd_hyper(pgd_t *ptr, pgd_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	__xen_set_pgd_hyper(ptr, val);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_pgd(pgd_t *ptr, pgd_t val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *user_ptr = xen_get_user_pgd(ptr);</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_set_pgd(ptr, user_ptr, val);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If page is not pinned, we can just update the entry</span>
<span class="p_del">-	   directly */</span>
<span class="p_del">-	if (!xen_page_pinned(ptr)) {</span>
<span class="p_del">-		*ptr = val;</span>
<span class="p_del">-		if (user_ptr) {</span>
<span class="p_del">-			WARN_ON(xen_page_pinned(user_ptr));</span>
<span class="p_del">-			*user_ptr = val;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If it&#39;s pinned, then we can at least batch the kernel and</span>
<span class="p_del">-	   user updates together. */</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	__xen_set_pgd_hyper(ptr, val);</span>
<span class="p_del">-	if (user_ptr)</span>
<span class="p_del">-		__xen_set_pgd_hyper(user_ptr, val);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif	/* CONFIG_PGTABLE_LEVELS == 4 */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * (Yet another) pagetable walker.  This one is intended for pinning a</span>
<span class="p_del">- * pagetable.  This means that it walks a pagetable and calls the</span>
<span class="p_del">- * callback function on each page it finds making up the page table,</span>
<span class="p_del">- * at every level.  It walks the entire pagetable, but it only bothers</span>
<span class="p_del">- * pinning pte pages which are below limit.  In the normal case this</span>
<span class="p_del">- * will be STACK_TOP_MAX, but at boot we need to pin up to</span>
<span class="p_del">- * FIXADDR_TOP.</span>
<span class="p_del">- *</span>
<span class="p_del">- * For 32-bit the important bit is that we don&#39;t pin beyond there,</span>
<span class="p_del">- * because then we start getting into Xen&#39;s ptes.</span>
<span class="p_del">- *</span>
<span class="p_del">- * For 64-bit, we must skip the Xen hole in the middle of the address</span>
<span class="p_del">- * space, just after the big x86-64 virtual hole.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int __xen_pgd_walk(struct mm_struct *mm, pgd_t *pgd,</span>
<span class="p_del">-			  int (*func)(struct mm_struct *mm, struct page *,</span>
<span class="p_del">-				      enum pt_level),</span>
<span class="p_del">-			  unsigned long limit)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int flush = 0;</span>
<span class="p_del">-	unsigned hole_low, hole_high;</span>
<span class="p_del">-	unsigned pgdidx_limit, pudidx_limit, pmdidx_limit;</span>
<span class="p_del">-	unsigned pgdidx, pudidx, pmdidx;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The limit is the last byte to be touched */</span>
<span class="p_del">-	limit--;</span>
<span class="p_del">-	BUG_ON(limit &gt;= FIXADDR_TOP);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 64-bit has a great big hole in the middle of the address</span>
<span class="p_del">-	 * space, which contains the Xen mappings.  On 32-bit these</span>
<span class="p_del">-	 * will end up making a zero-sized hole and so is a no-op.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	hole_low = pgd_index(USER_LIMIT);</span>
<span class="p_del">-	hole_high = pgd_index(PAGE_OFFSET);</span>
<span class="p_del">-</span>
<span class="p_del">-	pgdidx_limit = pgd_index(limit);</span>
<span class="p_del">-#if PTRS_PER_PUD &gt; 1</span>
<span class="p_del">-	pudidx_limit = pud_index(limit);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	pudidx_limit = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#if PTRS_PER_PMD &gt; 1</span>
<span class="p_del">-	pmdidx_limit = pmd_index(limit);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	pmdidx_limit = 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	for (pgdidx = 0; pgdidx &lt;= pgdidx_limit; pgdidx++) {</span>
<span class="p_del">-		pud_t *pud;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (pgdidx &gt;= hole_low &amp;&amp; pgdidx &lt; hole_high)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!pgd_val(pgd[pgdidx]))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		pud = pud_offset(&amp;pgd[pgdidx], 0);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (PTRS_PER_PUD &gt; 1) /* not folded */</span>
<span class="p_del">-			flush |= (*func)(mm, virt_to_page(pud), PT_PUD);</span>
<span class="p_del">-</span>
<span class="p_del">-		for (pudidx = 0; pudidx &lt; PTRS_PER_PUD; pudidx++) {</span>
<span class="p_del">-			pmd_t *pmd;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (pgdidx == pgdidx_limit &amp;&amp;</span>
<span class="p_del">-			    pudidx &gt; pudidx_limit)</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (pud_none(pud[pudidx]))</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-</span>
<span class="p_del">-			pmd = pmd_offset(&amp;pud[pudidx], 0);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (PTRS_PER_PMD &gt; 1) /* not folded */</span>
<span class="p_del">-				flush |= (*func)(mm, virt_to_page(pmd), PT_PMD);</span>
<span class="p_del">-</span>
<span class="p_del">-			for (pmdidx = 0; pmdidx &lt; PTRS_PER_PMD; pmdidx++) {</span>
<span class="p_del">-				struct page *pte;</span>
<span class="p_del">-</span>
<span class="p_del">-				if (pgdidx == pgdidx_limit &amp;&amp;</span>
<span class="p_del">-				    pudidx == pudidx_limit &amp;&amp;</span>
<span class="p_del">-				    pmdidx &gt; pmdidx_limit)</span>
<span class="p_del">-					goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-				if (pmd_none(pmd[pmdidx]))</span>
<span class="p_del">-					continue;</span>
<span class="p_del">-</span>
<span class="p_del">-				pte = pmd_page(pmd[pmdidx]);</span>
<span class="p_del">-				flush |= (*func)(mm, pte, PT_PTE);</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	/* Do the top level last, so that the callbacks can use it as</span>
<span class="p_del">-	   a cue to do final things like tlb flushes. */</span>
<span class="p_del">-	flush |= (*func)(mm, virt_to_page(pgd), PT_PGD);</span>
<span class="p_del">-</span>
<span class="p_del">-	return flush;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int xen_pgd_walk(struct mm_struct *mm,</span>
<span class="p_del">-			int (*func)(struct mm_struct *mm, struct page *,</span>
<span class="p_del">-				    enum pt_level),</span>
<span class="p_del">-			unsigned long limit)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __xen_pgd_walk(mm, mm-&gt;pgd, func, limit);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* If we&#39;re using split pte locks, then take the page&#39;s lock and</span>
<span class="p_del">-   return a pointer to it.  Otherwise return NULL. */</span>
<span class="p_del">-static spinlock_t *xen_pte_lock(struct page *page, struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spinlock_t *ptl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-#if USE_SPLIT_PTE_PTLOCKS</span>
<span class="p_del">-	ptl = ptlock_ptr(page);</span>
<span class="p_del">-	spin_lock_nest_lock(ptl, &amp;mm-&gt;page_table_lock);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	return ptl;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_pte_unlock(void *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spinlock_t *ptl = v;</span>
<span class="p_del">-	spin_unlock(ptl);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_do_pin(unsigned level, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmuext_op op;</span>
<span class="p_del">-</span>
<span class="p_del">-	op.cmd = level;</span>
<span class="p_del">-	op.arg1.mfn = pfn_to_mfn(pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_extend_mmuext_op(&amp;op);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int xen_pin_page(struct mm_struct *mm, struct page *page,</span>
<span class="p_del">-			enum pt_level level)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned pgfl = TestSetPagePinned(page);</span>
<span class="p_del">-	int flush;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pgfl)</span>
<span class="p_del">-		flush = 0;		/* already pinned */</span>
<span class="p_del">-	else if (PageHighMem(page))</span>
<span class="p_del">-		/* kmaps need flushing if we found an unpinned</span>
<span class="p_del">-		   highpage */</span>
<span class="p_del">-		flush = 1;</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		void *pt = lowmem_page_address(page);</span>
<span class="p_del">-		unsigned long pfn = page_to_pfn(page);</span>
<span class="p_del">-		struct multicall_space mcs = __xen_mc_entry(0);</span>
<span class="p_del">-		spinlock_t *ptl;</span>
<span class="p_del">-</span>
<span class="p_del">-		flush = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We need to hold the pagetable lock between the time</span>
<span class="p_del">-		 * we make the pagetable RO and when we actually pin</span>
<span class="p_del">-		 * it.  If we don&#39;t, then other users may come in and</span>
<span class="p_del">-		 * attempt to update the pagetable by writing it,</span>
<span class="p_del">-		 * which will fail because the memory is RO but not</span>
<span class="p_del">-		 * pinned, so Xen won&#39;t do the trap&#39;n&#39;emulate.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * If we&#39;re using split pte locks, we can&#39;t hold the</span>
<span class="p_del">-		 * entire pagetable&#39;s worth of locks during the</span>
<span class="p_del">-		 * traverse, because we may wrap the preempt count (8</span>
<span class="p_del">-		 * bits).  The solution is to mark RO and pin each PTE</span>
<span class="p_del">-		 * page while holding the lock.  This means the number</span>
<span class="p_del">-		 * of locks we end up holding is never more than a</span>
<span class="p_del">-		 * batch size (~32 entries, at present).</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * If we&#39;re not using split pte locks, we needn&#39;t pin</span>
<span class="p_del">-		 * the PTE pages independently, because we&#39;re</span>
<span class="p_del">-		 * protected by the overall pagetable lock.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		ptl = NULL;</span>
<span class="p_del">-		if (level == PT_PTE)</span>
<span class="p_del">-			ptl = xen_pte_lock(page, mm);</span>
<span class="p_del">-</span>
<span class="p_del">-		MULTI_update_va_mapping(mcs.mc, (unsigned long)pt,</span>
<span class="p_del">-					pfn_pte(pfn, PAGE_KERNEL_RO),</span>
<span class="p_del">-					level == PT_PGD ? UVMF_TLB_FLUSH : 0);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (ptl) {</span>
<span class="p_del">-			xen_do_pin(MMUEXT_PIN_L1_TABLE, pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-			/* Queue a deferred unlock for when this batch</span>
<span class="p_del">-			   is completed. */</span>
<span class="p_del">-			xen_mc_callback(xen_pte_unlock, ptl);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return flush;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is called just after a mm has been created, but it has not</span>
<span class="p_del">-   been used yet.  We need to make sure that its pagetable is all</span>
<span class="p_del">-   read-only, and can be pinned. */</span>
<span class="p_del">-static void __xen_pgd_pin(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_pgd_pin(mm, pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (__xen_pgd_walk(mm, pgd, xen_pin_page, USER_LIMIT)) {</span>
<span class="p_del">-		/* re-enable interrupts for flushing */</span>
<span class="p_del">-		xen_mc_issue(0);</span>
<span class="p_del">-</span>
<span class="p_del">-		kmap_flush_unused();</span>
<span class="p_del">-</span>
<span class="p_del">-		xen_mc_batch();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	{</span>
<span class="p_del">-		pgd_t *user_pgd = xen_get_user_pgd(pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-		xen_do_pin(MMUEXT_PIN_L4_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_del">-</span>
<span class="p_del">-		if (user_pgd) {</span>
<span class="p_del">-			xen_pin_page(mm, virt_to_page(user_pgd), PT_PGD);</span>
<span class="p_del">-			xen_do_pin(MMUEXT_PIN_L4_TABLE,</span>
<span class="p_del">-				   PFN_DOWN(__pa(user_pgd)));</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-#else /* CONFIG_X86_32 */</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	/* Need to make sure unshared kernel PMD is pinnable */</span>
<span class="p_del">-	xen_pin_page(mm, pgd_page(pgd[pgd_index(TASK_SIZE)]),</span>
<span class="p_del">-		     PT_PMD);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	xen_do_pin(MMUEXT_PIN_L3_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_del">-#endif /* CONFIG_X86_64 */</span>
<span class="p_del">-	xen_mc_issue(0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_pgd_pin(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__xen_pgd_pin(mm, mm-&gt;pgd);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * On save, we need to pin all pagetables to make sure they get their</span>
<span class="p_del">- * mfns turned into pfns.  Search the list for any unpinned pgds and pin</span>
<span class="p_del">- * them (unpinned pgds are not currently in use, probably because the</span>
<span class="p_del">- * process is under construction or destruction).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Expected to be called in stop_machine() (&quot;equivalent to taking</span>
<span class="p_del">- * every spinlock in the system&quot;), so the locking doesn&#39;t really</span>
<span class="p_del">- * matter all that much.</span>
<span class="p_del">- */</span>
<span class="p_del">-void xen_mm_pin_all(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct page *page;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock(&amp;pgd_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(page, &amp;pgd_list, lru) {</span>
<span class="p_del">-		if (!PagePinned(page)) {</span>
<span class="p_del">-			__xen_pgd_pin(&amp;init_mm, (pgd_t *)page_address(page));</span>
<span class="p_del">-			SetPageSavePinned(page);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock(&amp;pgd_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The init_mm pagetable is really pinned as soon as its created, but</span>
<span class="p_del">- * that&#39;s before we have page structures to store the bits.  So do all</span>
<span class="p_del">- * the book-keeping now.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int __init xen_mark_pinned(struct mm_struct *mm, struct page *page,</span>
<span class="p_del">-				  enum pt_level level)</span>
<span class="p_del">-{</span>
<span class="p_del">-	SetPagePinned(page);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_mark_init_mm_pinned(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xen_pgd_walk(&amp;init_mm, xen_mark_pinned, FIXADDR_TOP);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int xen_unpin_page(struct mm_struct *mm, struct page *page,</span>
<span class="p_del">-			  enum pt_level level)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned pgfl = TestClearPagePinned(page);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pgfl &amp;&amp; !PageHighMem(page)) {</span>
<span class="p_del">-		void *pt = lowmem_page_address(page);</span>
<span class="p_del">-		unsigned long pfn = page_to_pfn(page);</span>
<span class="p_del">-		spinlock_t *ptl = NULL;</span>
<span class="p_del">-		struct multicall_space mcs;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Do the converse to pin_page.  If we&#39;re using split</span>
<span class="p_del">-		 * pte locks, we must be holding the lock for while</span>
<span class="p_del">-		 * the pte page is unpinned but still RO to prevent</span>
<span class="p_del">-		 * concurrent updates from seeing it in this</span>
<span class="p_del">-		 * partially-pinned state.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (level == PT_PTE) {</span>
<span class="p_del">-			ptl = xen_pte_lock(page, mm);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (ptl)</span>
<span class="p_del">-				xen_do_pin(MMUEXT_UNPIN_TABLE, pfn);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		mcs = __xen_mc_entry(0);</span>
<span class="p_del">-</span>
<span class="p_del">-		MULTI_update_va_mapping(mcs.mc, (unsigned long)pt,</span>
<span class="p_del">-					pfn_pte(pfn, PAGE_KERNEL),</span>
<span class="p_del">-					level == PT_PGD ? UVMF_TLB_FLUSH : 0);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (ptl) {</span>
<span class="p_del">-			/* unlock when batch completed */</span>
<span class="p_del">-			xen_mc_callback(xen_pte_unlock, ptl);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;		/* never need to flush on unpin */</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Release a pagetables pages back as normal RW */</span>
<span class="p_del">-static void __xen_pgd_unpin(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	trace_xen_mmu_pgd_unpin(mm, pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_do_pin(MMUEXT_UNPIN_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	{</span>
<span class="p_del">-		pgd_t *user_pgd = xen_get_user_pgd(pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (user_pgd) {</span>
<span class="p_del">-			xen_do_pin(MMUEXT_UNPIN_TABLE,</span>
<span class="p_del">-				   PFN_DOWN(__pa(user_pgd)));</span>
<span class="p_del">-			xen_unpin_page(mm, virt_to_page(user_pgd), PT_PGD);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	/* Need to make sure unshared kernel PMD is unpinned */</span>
<span class="p_del">-	xen_unpin_page(mm, pgd_page(pgd[pgd_index(TASK_SIZE)]),</span>
<span class="p_del">-		       PT_PMD);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	__xen_pgd_walk(mm, pgd, xen_unpin_page, USER_LIMIT);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_pgd_unpin(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__xen_pgd_unpin(mm, mm-&gt;pgd);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * On resume, undo any pinning done at save, so that the rest of the</span>
<span class="p_del">- * kernel doesn&#39;t see any unexpected pinned pagetables.</span>
<span class="p_del">- */</span>
<span class="p_del">-void xen_mm_unpin_all(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct page *page;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock(&amp;pgd_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(page, &amp;pgd_list, lru) {</span>
<span class="p_del">-		if (PageSavePinned(page)) {</span>
<span class="p_del">-			BUG_ON(!PagePinned(page));</span>
<span class="p_del">-			__xen_pgd_unpin(&amp;init_mm, (pgd_t *)page_address(page));</span>
<span class="p_del">-			ClearPageSavePinned(page);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock(&amp;pgd_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_activate_mm(struct mm_struct *prev, struct mm_struct *next)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spin_lock(&amp;next-&gt;page_table_lock);</span>
<span class="p_del">-	xen_pgd_pin(next);</span>
<span class="p_del">-	spin_unlock(&amp;next-&gt;page_table_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_dup_mmap(struct mm_struct *oldmm, struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_del">-	xen_pgd_pin(mm);</span>
<span class="p_del">-	spin_unlock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-/* Another cpu may still have their %cr3 pointing at the pagetable, so</span>
<span class="p_del">-   we need to repoint it somewhere else before we can unpin it. */</span>
<span class="p_del">-static void drop_other_mm_ref(void *info)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mm_struct *mm = info;</span>
<span class="p_del">-	struct mm_struct *active_mm;</span>
<span class="p_del">-</span>
<span class="p_del">-	active_mm = this_cpu_read(cpu_tlbstate.active_mm);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (active_mm == mm &amp;&amp; this_cpu_read(cpu_tlbstate.state) != TLBSTATE_OK)</span>
<span class="p_del">-		leave_mm(smp_processor_id());</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If this cpu still has a stale cr3 reference, then make sure</span>
<span class="p_del">-	   it has been flushed. */</span>
<span class="p_del">-	if (this_cpu_read(xen_current_cr3) == __pa(mm-&gt;pgd))</span>
<span class="p_del">-		load_cr3(swapper_pg_dir);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_drop_mm_ref(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpumask_var_t mask;</span>
<span class="p_del">-	unsigned cpu;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (current-&gt;active_mm == mm) {</span>
<span class="p_del">-		if (current-&gt;mm == mm)</span>
<span class="p_del">-			load_cr3(swapper_pg_dir);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			leave_mm(smp_processor_id());</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get the &quot;official&quot; set of cpus referring to our pagetable. */</span>
<span class="p_del">-	if (!alloc_cpumask_var(&amp;mask, GFP_ATOMIC)) {</span>
<span class="p_del">-		for_each_online_cpu(cpu) {</span>
<span class="p_del">-			if (!cpumask_test_cpu(cpu, mm_cpumask(mm))</span>
<span class="p_del">-			    &amp;&amp; per_cpu(xen_current_cr3, cpu) != __pa(mm-&gt;pgd))</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			smp_call_function_single(cpu, drop_other_mm_ref, mm, 1);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	cpumask_copy(mask, mm_cpumask(mm));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* It&#39;s possible that a vcpu may have a stale reference to our</span>
<span class="p_del">-	   cr3, because its in lazy mode, and it hasn&#39;t yet flushed</span>
<span class="p_del">-	   its set of pending hypercalls yet.  In this case, we can</span>
<span class="p_del">-	   look at its actual current cr3 value, and force it to flush</span>
<span class="p_del">-	   if needed. */</span>
<span class="p_del">-	for_each_online_cpu(cpu) {</span>
<span class="p_del">-		if (per_cpu(xen_current_cr3, cpu) == __pa(mm-&gt;pgd))</span>
<span class="p_del">-			cpumask_set_cpu(cpu, mask);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!cpumask_empty(mask))</span>
<span class="p_del">-		smp_call_function_many(mask, drop_other_mm_ref, mm, 1);</span>
<span class="p_del">-	free_cpumask_var(mask);</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-static void xen_drop_mm_ref(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (current-&gt;active_mm == mm)</span>
<span class="p_del">-		load_cr3(swapper_pg_dir);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * While a process runs, Xen pins its pagetables, which means that the</span>
<span class="p_del">- * hypervisor forces it to be read-only, and it controls all updates</span>
<span class="p_del">- * to it.  This means that all pagetable updates have to go via the</span>
<span class="p_del">- * hypervisor, which is moderately expensive.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Since we&#39;re pulling the pagetable down, we switch to use init_mm,</span>
<span class="p_del">- * unpin old process pagetable and mark it all read-write, which</span>
<span class="p_del">- * allows further operations on it to be simple memory accesses.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The only subtle point is that another CPU may be still using the</span>
<span class="p_del">- * pagetable because of lazy tlb flushing.  This means we need need to</span>
<span class="p_del">- * switch all CPUs off this pagetable before we can unpin it.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void xen_exit_mmap(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	get_cpu();		/* make sure we don&#39;t move around */</span>
<span class="p_del">-	xen_drop_mm_ref(mm);</span>
<span class="p_del">-	put_cpu();</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* pgd may not be pinned in the error exit path of execve */</span>
<span class="p_del">-	if (xen_page_pinned(mm-&gt;pgd))</span>
<span class="p_del">-		xen_pgd_unpin(mm);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_post_allocator_init(void);</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init pin_pagetable_pfn(unsigned cmd, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmuext_op op;</span>
<span class="p_del">-</span>
<span class="p_del">-	op.cmd = cmd;</span>
<span class="p_del">-	op.arg1.mfn = pfn_to_mfn(pfn);</span>
<span class="p_del">-	if (HYPERVISOR_mmuext_op(&amp;op, 1, NULL, DOMID_SELF))</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-static void __init xen_cleanhighmap(unsigned long vaddr,</span>
<span class="p_del">-				    unsigned long vaddr_end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long kernel_end = roundup((unsigned long)_brk_end, PMD_SIZE) - 1;</span>
<span class="p_del">-	pmd_t *pmd = level2_kernel_pgt + pmd_index(vaddr);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* NOTE: The loop is more greedy than the cleanup_highmap variant.</span>
<span class="p_del">-	 * We include the PMD passed in on _both_ boundaries. */</span>
<span class="p_del">-	for (; vaddr &lt;= vaddr_end &amp;&amp; (pmd &lt; (level2_kernel_pgt + PTRS_PER_PMD));</span>
<span class="p_del">-			pmd++, vaddr += PMD_SIZE) {</span>
<span class="p_del">-		if (pmd_none(*pmd))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (vaddr &lt; (unsigned long) _text || vaddr &gt; kernel_end)</span>
<span class="p_del">-			set_pmd(pmd, __pmd(0));</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* In case we did something silly, we should crash in this function</span>
<span class="p_del">-	 * instead of somewhere later and be confusing. */</span>
<span class="p_del">-	xen_mc_flush();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Make a page range writeable and free it.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __init xen_free_ro_pages(unsigned long paddr, unsigned long size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void *vaddr = __va(paddr);</span>
<span class="p_del">-	void *vaddr_end = vaddr + size;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (; vaddr &lt; vaddr_end; vaddr += PAGE_SIZE)</span>
<span class="p_del">-		make_lowmem_page_readwrite(vaddr);</span>
<span class="p_del">-</span>
<span class="p_del">-	memblock_free(paddr, size);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_cleanmfnmap_free_pgtbl(void *pgtbl, bool unpin)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long pa = __pa(pgtbl) &amp; PHYSICAL_PAGE_MASK;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unpin)</span>
<span class="p_del">-		pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, PFN_DOWN(pa));</span>
<span class="p_del">-	ClearPagePinned(virt_to_page(__va(pa)));</span>
<span class="p_del">-	xen_free_ro_pages(pa, PAGE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Since it is well isolated we can (and since it is perhaps large we should)</span>
<span class="p_del">- * also free the page tables mapping the initial P-&gt;M table.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __init xen_cleanmfnmap(unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long va = vaddr &amp; PMD_MASK;</span>
<span class="p_del">-	unsigned long pa;</span>
<span class="p_del">-	pgd_t *pgd = pgd_offset_k(va);</span>
<span class="p_del">-	pud_t *pud_page = pud_offset(pgd, 0);</span>
<span class="p_del">-	pud_t *pud;</span>
<span class="p_del">-	pmd_t *pmd;</span>
<span class="p_del">-	pte_t *pte;</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-	bool unpin;</span>
<span class="p_del">-</span>
<span class="p_del">-	unpin = (vaddr == 2 * PGDIR_SIZE);</span>
<span class="p_del">-	set_pgd(pgd, __pgd(0));</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		pud = pud_page + pud_index(va);</span>
<span class="p_del">-		if (pud_none(*pud)) {</span>
<span class="p_del">-			va += PUD_SIZE;</span>
<span class="p_del">-		} else if (pud_large(*pud)) {</span>
<span class="p_del">-			pa = pud_val(*pud) &amp; PHYSICAL_PAGE_MASK;</span>
<span class="p_del">-			xen_free_ro_pages(pa, PUD_SIZE);</span>
<span class="p_del">-			va += PUD_SIZE;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			pmd = pmd_offset(pud, va);</span>
<span class="p_del">-			if (pmd_large(*pmd)) {</span>
<span class="p_del">-				pa = pmd_val(*pmd) &amp; PHYSICAL_PAGE_MASK;</span>
<span class="p_del">-				xen_free_ro_pages(pa, PMD_SIZE);</span>
<span class="p_del">-			} else if (!pmd_none(*pmd)) {</span>
<span class="p_del">-				pte = pte_offset_kernel(pmd, va);</span>
<span class="p_del">-				set_pmd(pmd, __pmd(0));</span>
<span class="p_del">-				for (i = 0; i &lt; PTRS_PER_PTE; ++i) {</span>
<span class="p_del">-					if (pte_none(pte[i]))</span>
<span class="p_del">-						break;</span>
<span class="p_del">-					pa = pte_pfn(pte[i]) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-					xen_free_ro_pages(pa, PAGE_SIZE);</span>
<span class="p_del">-				}</span>
<span class="p_del">-				xen_cleanmfnmap_free_pgtbl(pte, unpin);</span>
<span class="p_del">-			}</span>
<span class="p_del">-			va += PMD_SIZE;</span>
<span class="p_del">-			if (pmd_index(va))</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			set_pud(pud, __pud(0));</span>
<span class="p_del">-			xen_cleanmfnmap_free_pgtbl(pmd, unpin);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	} while (pud_index(va) || pmd_index(va));</span>
<span class="p_del">-	xen_cleanmfnmap_free_pgtbl(pud_page, unpin);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_pagetable_p2m_free(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long size;</span>
<span class="p_del">-	unsigned long addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	size = PAGE_ALIGN(xen_start_info-&gt;nr_pages * sizeof(unsigned long));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* No memory or already called. */</span>
<span class="p_del">-	if ((unsigned long)xen_p2m_addr == xen_start_info-&gt;mfn_list)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* using __ka address and sticking INVALID_P2M_ENTRY! */</span>
<span class="p_del">-	memset((void *)xen_start_info-&gt;mfn_list, 0xff, size);</span>
<span class="p_del">-</span>
<span class="p_del">-	addr = xen_start_info-&gt;mfn_list;</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We could be in __ka space.</span>
<span class="p_del">-	 * We roundup to the PMD, which means that if anybody at this stage is</span>
<span class="p_del">-	 * using the __ka address of xen_start_info or</span>
<span class="p_del">-	 * xen_start_info-&gt;shared_info they are in going to crash. Fortunatly</span>
<span class="p_del">-	 * we have already revectored in xen_setup_kernel_pagetable and in</span>
<span class="p_del">-	 * xen_setup_shared_info.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	size = roundup(size, PMD_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (addr &gt;= __START_KERNEL_map) {</span>
<span class="p_del">-		xen_cleanhighmap(addr, addr + size);</span>
<span class="p_del">-		size = PAGE_ALIGN(xen_start_info-&gt;nr_pages *</span>
<span class="p_del">-				  sizeof(unsigned long));</span>
<span class="p_del">-		memblock_free(__pa(addr), size);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		xen_cleanmfnmap(addr);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_pagetable_cleanhighmap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long size;</span>
<span class="p_del">-	unsigned long addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* At this stage, cleanup_highmap has already cleaned __ka space</span>
<span class="p_del">-	 * from _brk_limit way up to the max_pfn_mapped (which is the end of</span>
<span class="p_del">-	 * the ramdisk). We continue on, erasing PMD entries that point to page</span>
<span class="p_del">-	 * tables - do note that they are accessible at this stage via __va.</span>
<span class="p_del">-	 * For good measure we also round up to the PMD - which means that if</span>
<span class="p_del">-	 * anybody is using __ka address to the initial boot-stack - and try</span>
<span class="p_del">-	 * to use it - they are going to crash. The xen_start_info has been</span>
<span class="p_del">-	 * taken care of already in xen_setup_kernel_pagetable. */</span>
<span class="p_del">-	addr = xen_start_info-&gt;pt_base;</span>
<span class="p_del">-	size = roundup(xen_start_info-&gt;nr_pt_frames * PAGE_SIZE, PMD_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_cleanhighmap(addr, addr + size);</span>
<span class="p_del">-	xen_start_info-&gt;pt_base = (unsigned long)__va(__pa(xen_start_info-&gt;pt_base));</span>
<span class="p_del">-#ifdef DEBUG</span>
<span class="p_del">-	/* This is superfluous and is not necessary, but you know what</span>
<span class="p_del">-	 * lets do it. The MODULES_VADDR -&gt; MODULES_END should be clear of</span>
<span class="p_del">-	 * anything at this stage. */</span>
<span class="p_del">-	xen_cleanhighmap(MODULES_VADDR, roundup(MODULES_VADDR, PUD_SIZE) - 1);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_pagetable_p2m_setup(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_vmalloc_p2m_tree();</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	xen_pagetable_p2m_free();</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_pagetable_cleanhighmap();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	/* And revector! Bye bye old array */</span>
<span class="p_del">-	xen_start_info-&gt;mfn_list = (unsigned long)xen_p2m_addr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_pagetable_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	paging_init();</span>
<span class="p_del">-	xen_post_allocator_init();</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_pagetable_p2m_setup();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Allocate and initialize top and mid mfn levels for p2m structure */</span>
<span class="p_del">-	xen_build_mfn_list_list();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Remap memory freed due to conflicts with E820 map */</span>
<span class="p_del">-	if (!xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-		xen_remap_memory();</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_XEN_PV</span>
<span class="p_del">-	xen_setup_shared_info();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-static void xen_write_cr2(unsigned long cr2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	this_cpu_read(xen_vcpu)-&gt;arch.cr2 = cr2;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned long xen_read_cr2(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return this_cpu_read(xen_vcpu)-&gt;arch.cr2;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-unsigned long xen_read_cr2_direct(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return this_cpu_read(xen_vcpu_info.arch.cr2);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void xen_flush_tlb_all(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmuext_op *op;</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_flush_tlb_all(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = xen_mc_entry(sizeof(*op));</span>
<span class="p_del">-</span>
<span class="p_del">-	op = mcs.args;</span>
<span class="p_del">-	op-&gt;cmd = MMUEXT_TLB_FLUSH_ALL;</span>
<span class="p_del">-	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-static void xen_flush_tlb(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmuext_op *op;</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_flush_tlb(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = xen_mc_entry(sizeof(*op));</span>
<span class="p_del">-</span>
<span class="p_del">-	op = mcs.args;</span>
<span class="p_del">-	op-&gt;cmd = MMUEXT_TLB_FLUSH_LOCAL;</span>
<span class="p_del">-	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_flush_tlb_single(unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmuext_op *op;</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_flush_tlb_single(addr);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = xen_mc_entry(sizeof(*op));</span>
<span class="p_del">-	op = mcs.args;</span>
<span class="p_del">-	op-&gt;cmd = MMUEXT_INVLPG_LOCAL;</span>
<span class="p_del">-	op-&gt;arg1.linear_addr = addr &amp; PAGE_MASK;</span>
<span class="p_del">-	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_flush_tlb_others(const struct cpumask *cpus,</span>
<span class="p_del">-				 struct mm_struct *mm, unsigned long start,</span>
<span class="p_del">-				 unsigned long end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct {</span>
<span class="p_del">-		struct mmuext_op op;</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-		DECLARE_BITMAP(mask, num_processors);</span>
<span class="p_del">-#else</span>
<span class="p_del">-		DECLARE_BITMAP(mask, NR_CPUS);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	} *args;</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_flush_tlb_others(cpus, mm, start, end);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cpumask_empty(cpus))</span>
<span class="p_del">-		return;		/* nothing to do */</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = xen_mc_entry(sizeof(*args));</span>
<span class="p_del">-	args = mcs.args;</span>
<span class="p_del">-	args-&gt;op.arg2.vcpumask = to_cpumask(args-&gt;mask);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Remove us, and any offline CPUS. */</span>
<span class="p_del">-	cpumask_and(to_cpumask(args-&gt;mask), cpus, cpu_online_mask);</span>
<span class="p_del">-	cpumask_clear_cpu(smp_processor_id(), to_cpumask(args-&gt;mask));</span>
<span class="p_del">-</span>
<span class="p_del">-	args-&gt;op.cmd = MMUEXT_TLB_FLUSH_MULTI;</span>
<span class="p_del">-	if (end != TLB_FLUSH_ALL &amp;&amp; (end - start) &lt;= PAGE_SIZE) {</span>
<span class="p_del">-		args-&gt;op.cmd = MMUEXT_INVLPG_MULTI;</span>
<span class="p_del">-		args-&gt;op.arg1.linear_addr = start;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	MULTI_mmuext_op(mcs.mc, &amp;args-&gt;op, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned long xen_read_cr3(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return this_cpu_read(xen_cr3);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void set_current_cr3(void *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	this_cpu_write(xen_current_cr3, (unsigned long)v);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __xen_write_cr3(bool kernel, unsigned long cr3)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mmuext_op op;</span>
<span class="p_del">-	unsigned long mfn;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_write_cr3(kernel, cr3);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cr3)</span>
<span class="p_del">-		mfn = pfn_to_mfn(PFN_DOWN(cr3));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		mfn = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	WARN_ON(mfn == 0 &amp;&amp; kernel);</span>
<span class="p_del">-</span>
<span class="p_del">-	op.cmd = kernel ? MMUEXT_NEW_BASEPTR : MMUEXT_NEW_USER_BASEPTR;</span>
<span class="p_del">-	op.arg1.mfn = mfn;</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_extend_mmuext_op(&amp;op);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (kernel) {</span>
<span class="p_del">-		this_cpu_write(xen_cr3, cr3);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Update xen_current_cr3 once the batch has actually</span>
<span class="p_del">-		   been submitted. */</span>
<span class="p_del">-		xen_mc_callback(set_current_cr3, (void *)cr3);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-static void xen_write_cr3(unsigned long cr3)</span>
<span class="p_del">-{</span>
<span class="p_del">-	BUG_ON(preemptible());</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();  /* disables interrupts */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Update while interrupts are disabled, so its atomic with</span>
<span class="p_del">-	   respect to ipis */</span>
<span class="p_del">-	this_cpu_write(xen_cr3, cr3);</span>
<span class="p_del">-</span>
<span class="p_del">-	__xen_write_cr3(true, cr3);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	{</span>
<span class="p_del">-		pgd_t *user_pgd = xen_get_user_pgd(__va(cr3));</span>
<span class="p_del">-		if (user_pgd)</span>
<span class="p_del">-			__xen_write_cr3(false, __pa(user_pgd));</span>
<span class="p_del">-		else</span>
<span class="p_del">-			__xen_write_cr3(false, 0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_CPU);  /* interrupts restored */</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-/*</span>
<span class="p_del">- * At the start of the day - when Xen launches a guest, it has already</span>
<span class="p_del">- * built pagetables for the guest. We diligently look over them</span>
<span class="p_del">- * in xen_setup_kernel_pagetable and graft as appropriate them in the</span>
<span class="p_del">- * init_level4_pgt and its friends. Then when we are happy we load</span>
<span class="p_del">- * the new init_level4_pgt - and continue on.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The generic code starts (start_kernel) and &#39;init_mem_mapping&#39; sets</span>
<span class="p_del">- * up the rest of the pagetables. When it has completed it loads the cr3.</span>
<span class="p_del">- * N.B. that baremetal would start at &#39;start_kernel&#39; (and the early</span>
<span class="p_del">- * #PF handler would create bootstrap pagetables) - so we are running</span>
<span class="p_del">- * with the same assumptions as what to do when write_cr3 is executed</span>
<span class="p_del">- * at this point.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Since there are no user-page tables at all, we have two variants</span>
<span class="p_del">- * of xen_write_cr3 - the early bootup (this one), and the late one</span>
<span class="p_del">- * (xen_write_cr3). The reason we have to do that is that in 64-bit</span>
<span class="p_del">- * the Linux kernel and user-space are both in ring 3 while the</span>
<span class="p_del">- * hypervisor is in ring 0.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __init xen_write_cr3_init(unsigned long cr3)</span>
<span class="p_del">-{</span>
<span class="p_del">-	BUG_ON(preemptible());</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();  /* disables interrupts */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Update while interrupts are disabled, so its atomic with</span>
<span class="p_del">-	   respect to ipis */</span>
<span class="p_del">-	this_cpu_write(xen_cr3, cr3);</span>
<span class="p_del">-</span>
<span class="p_del">-	__xen_write_cr3(true, cr3);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(PARAVIRT_LAZY_CPU);  /* interrupts restored */</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static int xen_pgd_alloc(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *pgd = mm-&gt;pgd;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(PagePinned(virt_to_page(pgd)));</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	{</span>
<span class="p_del">-		struct page *page = virt_to_page(pgd);</span>
<span class="p_del">-		pgd_t *user_pgd;</span>
<span class="p_del">-</span>
<span class="p_del">-		BUG_ON(page-&gt;private != 0);</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		user_pgd = (pgd_t *)__get_free_page(GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_del">-		page-&gt;private = (unsigned long)user_pgd;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (user_pgd != NULL) {</span>
<span class="p_del">-#ifdef CONFIG_X86_VSYSCALL_EMULATION</span>
<span class="p_del">-			user_pgd[pgd_index(VSYSCALL_ADDR)] =</span>
<span class="p_del">-				__pgd(__pa(level3_user_vsyscall) | _PAGE_TABLE);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-			ret = 0;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		BUG_ON(PagePinned(virt_to_page(xen_get_user_pgd(pgd))));</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	pgd_t *user_pgd = xen_get_user_pgd(pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (user_pgd)</span>
<span class="p_del">-		free_page((unsigned long)user_pgd);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Init-time set_pte while constructing initial pagetables, which</span>
<span class="p_del">- * doesn&#39;t allow RO page table pages to be remapped RW.</span>
<span class="p_del">- *</span>
<span class="p_del">- * If there is no MFN for this PFN then this page is initially</span>
<span class="p_del">- * ballooned out so clear the PTE (as in decrease_reservation() in</span>
<span class="p_del">- * drivers/xen/balloon.c).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Many of these PTE updates are done on unpinned and writable pages</span>
<span class="p_del">- * and doing a hypercall for these is unnecessary and expensive.  At</span>
<span class="p_del">- * this point it is not possible to tell if a page is pinned or not,</span>
<span class="p_del">- * so always write the PTE directly and rely on Xen trapping and</span>
<span class="p_del">- * emulating any updates as necessary.</span>
<span class="p_del">- */</span>
<span class="p_del">-__visible pte_t xen_make_pte_init(pteval_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	unsigned long pfn;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Pages belonging to the initial p2m list mapped outside the default</span>
<span class="p_del">-	 * address range must be mapped read-only. This region contains the</span>
<span class="p_del">-	 * page tables for mapping the p2m list, too, and page tables MUST be</span>
<span class="p_del">-	 * mapped read-only.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pfn = (pte &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	if (xen_start_info-&gt;mfn_list &lt; __START_KERNEL_map &amp;&amp;</span>
<span class="p_del">-	    pfn &gt;= xen_start_info-&gt;first_p2m_pfn &amp;&amp;</span>
<span class="p_del">-	    pfn &lt; xen_start_info-&gt;first_p2m_pfn + xen_start_info-&gt;nr_p2m_frames)</span>
<span class="p_del">-		pte &amp;= ~_PAGE_RW;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	pte = pte_pfn_to_mfn(pte);</span>
<span class="p_del">-	return native_make_pte(pte);</span>
<span class="p_del">-}</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(xen_make_pte_init);</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_set_pte_init(pte_t *ptep, pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	/* If there&#39;s an existing pte, then don&#39;t allow _PAGE_RW to be set */</span>
<span class="p_del">-	if (pte_mfn(pte) != INVALID_P2M_ENTRY</span>
<span class="p_del">-	    &amp;&amp; pte_val_ma(*ptep) &amp; _PAGE_PRESENT)</span>
<span class="p_del">-		pte = __pte_ma(((pte_val_ma(*ptep) &amp; _PAGE_RW) | ~_PAGE_RW) &amp;</span>
<span class="p_del">-			       pte_val_ma(pte));</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	native_set_pte(ptep, pte);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Early in boot, while setting up the initial pagetable, assume</span>
<span class="p_del">-   everything is pinned. */</span>
<span class="p_del">-static void __init xen_alloc_pte_init(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_FLATMEM</span>
<span class="p_del">-	BUG_ON(mem_map);	/* should only be used early */</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	make_lowmem_page_readonly(__va(PFN_PHYS(pfn)));</span>
<span class="p_del">-	pin_pagetable_pfn(MMUEXT_PIN_L1_TABLE, pfn);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Used for pmd and pud */</span>
<span class="p_del">-static void __init xen_alloc_pmd_init(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_FLATMEM</span>
<span class="p_del">-	BUG_ON(mem_map);	/* should only be used early */</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	make_lowmem_page_readonly(__va(PFN_PHYS(pfn)));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Early release_pte assumes that all pts are pinned, since there&#39;s</span>
<span class="p_del">-   only init_mm and anything attached to that is pinned. */</span>
<span class="p_del">-static void __init xen_release_pte_init(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, pfn);</span>
<span class="p_del">-	make_lowmem_page_readwrite(__va(PFN_PHYS(pfn)));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_release_pmd_init(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	make_lowmem_page_readwrite(__va(PFN_PHYS(pfn)));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __pin_pagetable_pfn(unsigned cmd, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-	struct mmuext_op *op;</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = __xen_mc_entry(sizeof(*op));</span>
<span class="p_del">-	op = mcs.args;</span>
<span class="p_del">-	op-&gt;cmd = cmd;</span>
<span class="p_del">-	op-&gt;arg1.mfn = pfn_to_mfn(pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-	MULTI_mmuext_op(mcs.mc, mcs.args, 1, NULL, DOMID_SELF);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void __set_pfn_prot(unsigned long pfn, pgprot_t prot)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct multicall_space mcs;</span>
<span class="p_del">-	unsigned long addr = (unsigned long)__va(pfn &lt;&lt; PAGE_SHIFT);</span>
<span class="p_del">-</span>
<span class="p_del">-	mcs = __xen_mc_entry(0);</span>
<span class="p_del">-	MULTI_update_va_mapping(mcs.mc, (unsigned long)addr,</span>
<span class="p_del">-				pfn_pte(pfn, prot), 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This needs to make sure the new pte page is pinned iff its being</span>
<span class="p_del">-   attached to a pinned pagetable. */</span>
<span class="p_del">-static inline void xen_alloc_ptpage(struct mm_struct *mm, unsigned long pfn,</span>
<span class="p_del">-				    unsigned level)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool pinned = PagePinned(virt_to_page(mm-&gt;pgd));</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_alloc_ptpage(mm, pfn, level, pinned);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pinned) {</span>
<span class="p_del">-		struct page *page = pfn_to_page(pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-		SetPagePinned(page);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!PageHighMem(page)) {</span>
<span class="p_del">-			xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-			__set_pfn_prot(pfn, PAGE_KERNEL_RO);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (level == PT_PTE &amp;&amp; USE_SPLIT_PTE_PTLOCKS)</span>
<span class="p_del">-				__pin_pagetable_pfn(MMUEXT_PIN_L1_TABLE, pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-			xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			/* make sure there are no stray mappings of</span>
<span class="p_del">-			   this page */</span>
<span class="p_del">-			kmap_flush_unused();</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_alloc_pte(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xen_alloc_ptpage(mm, pfn, PT_PTE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_alloc_pmd(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xen_alloc_ptpage(mm, pfn, PT_PMD);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This should never happen until we&#39;re OK to use struct page */</span>
<span class="p_del">-static inline void xen_release_ptpage(unsigned long pfn, unsigned level)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct page *page = pfn_to_page(pfn);</span>
<span class="p_del">-	bool pinned = PagePinned(page);</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_xen_mmu_release_ptpage(pfn, level, pinned);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pinned) {</span>
<span class="p_del">-		if (!PageHighMem(page)) {</span>
<span class="p_del">-			xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-			if (level == PT_PTE &amp;&amp; USE_SPLIT_PTE_PTLOCKS)</span>
<span class="p_del">-				__pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-			__set_pfn_prot(pfn, PAGE_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-			xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		ClearPagePinned(page);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_release_pte(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xen_release_ptpage(pfn, PT_PTE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_release_pmd(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xen_release_ptpage(pfn, PT_PMD);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_del">-static void xen_alloc_pud(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xen_alloc_ptpage(mm, pfn, PT_PUD);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_release_pud(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	xen_release_ptpage(pfn, PT_PUD);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-void __init xen_reserve_top(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	unsigned long top = HYPERVISOR_VIRT_START;</span>
<span class="p_del">-	struct xen_platform_parameters pp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (HYPERVISOR_xen_version(XENVER_platform_parameters, &amp;pp) == 0)</span>
<span class="p_del">-		top = pp.virt_start;</span>
<span class="p_del">-</span>
<span class="p_del">-	reserve_top_address(-top);</span>
<span class="p_del">-#endif	/* CONFIG_X86_32 */</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Like __va(), but returns address in the kernel mapping (which is</span>
<span class="p_del">- * all we have until the physical memory mapping has been set up.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void * __init __ka(phys_addr_t paddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	return (void *)(paddr + __START_KERNEL_map);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return __va(paddr);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Convert a machine address to physical address */</span>
<span class="p_del">-static unsigned long __init m2p(phys_addr_t maddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	phys_addr_t paddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	maddr &amp;= PTE_PFN_MASK;</span>
<span class="p_del">-	paddr = mfn_to_pfn(maddr &gt;&gt; PAGE_SHIFT) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_del">-	return paddr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Convert a machine address to kernel virtual */</span>
<span class="p_del">-static void * __init m2v(phys_addr_t maddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __ka(m2p(maddr));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Set the page permissions on an identity-mapped pages */</span>
<span class="p_del">-static void __init set_page_prot_flags(void *addr, pgprot_t prot,</span>
<span class="p_del">-				       unsigned long flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long pfn = __pa(addr) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	pte_t pte = pfn_pte(pfn, prot);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (HYPERVISOR_update_va_mapping((unsigned long)addr, pte, flags))</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-}</span>
<span class="p_del">-static void __init set_page_prot(void *addr, pgprot_t prot)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return set_page_prot_flags(addr, prot, UVMF_NONE);</span>
<span class="p_del">-}</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-static void __init xen_map_identity_early(pmd_t *pmd, unsigned long max_pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned pmdidx, pteidx;</span>
<span class="p_del">-	unsigned ident_pte;</span>
<span class="p_del">-	unsigned long pfn;</span>
<span class="p_del">-</span>
<span class="p_del">-	level1_ident_pgt = extend_brk(sizeof(pte_t) * LEVEL1_IDENT_ENTRIES,</span>
<span class="p_del">-				      PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	ident_pte = 0;</span>
<span class="p_del">-	pfn = 0;</span>
<span class="p_del">-	for (pmdidx = 0; pmdidx &lt; PTRS_PER_PMD &amp;&amp; pfn &lt; max_pfn; pmdidx++) {</span>
<span class="p_del">-		pte_t *pte_page;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Reuse or allocate a page of ptes */</span>
<span class="p_del">-		if (pmd_present(pmd[pmdidx]))</span>
<span class="p_del">-			pte_page = m2v(pmd[pmdidx].pmd);</span>
<span class="p_del">-		else {</span>
<span class="p_del">-			/* Check for free pte pages */</span>
<span class="p_del">-			if (ident_pte == LEVEL1_IDENT_ENTRIES)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-</span>
<span class="p_del">-			pte_page = &amp;level1_ident_pgt[ident_pte];</span>
<span class="p_del">-			ident_pte += PTRS_PER_PTE;</span>
<span class="p_del">-</span>
<span class="p_del">-			pmd[pmdidx] = __pmd(__pa(pte_page) | _PAGE_TABLE);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Install mappings */</span>
<span class="p_del">-		for (pteidx = 0; pteidx &lt; PTRS_PER_PTE; pteidx++, pfn++) {</span>
<span class="p_del">-			pte_t pte;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (pfn &gt; max_pfn_mapped)</span>
<span class="p_del">-				max_pfn_mapped = pfn;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!pte_none(pte_page[pteidx]))</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-</span>
<span class="p_del">-			pte = pfn_pte(pfn, PAGE_KERNEL_EXEC);</span>
<span class="p_del">-			pte_page[pteidx] = pte;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	for (pteidx = 0; pteidx &lt; ident_pte; pteidx += PTRS_PER_PTE)</span>
<span class="p_del">-		set_page_prot(&amp;level1_ident_pgt[pteidx], PAGE_KERNEL_RO);</span>
<span class="p_del">-</span>
<span class="p_del">-	set_page_prot(pmd, PAGE_KERNEL_RO);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-void __init xen_setup_machphys_mapping(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xen_machphys_mapping mapping;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (HYPERVISOR_memory_op(XENMEM_machphys_mapping, &amp;mapping) == 0) {</span>
<span class="p_del">-		machine_to_phys_mapping = (unsigned long *)mapping.v_start;</span>
<span class="p_del">-		machine_to_phys_nr = mapping.max_mfn + 1;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		machine_to_phys_nr = MACH2PHYS_NR_ENTRIES;</span>
<span class="p_del">-	}</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	WARN_ON((machine_to_phys_mapping + (machine_to_phys_nr - 1))</span>
<span class="p_del">-		&lt; machine_to_phys_mapping);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-static void __init convert_pfn_mfn(void *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pte_t *pte = v;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* All levels are converted the same way, so just treat them</span>
<span class="p_del">-	   as ptes. */</span>
<span class="p_del">-	for (i = 0; i &lt; PTRS_PER_PTE; i++)</span>
<span class="p_del">-		pte[i] = xen_make_pte(pte[i].pte);</span>
<span class="p_del">-}</span>
<span class="p_del">-static void __init check_pt_base(unsigned long *pt_base, unsigned long *pt_end,</span>
<span class="p_del">-				 unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (*pt_base == PFN_DOWN(__pa(addr))) {</span>
<span class="p_del">-		set_page_prot_flags((void *)addr, PAGE_KERNEL, UVMF_INVLPG);</span>
<span class="p_del">-		clear_page((void *)addr);</span>
<span class="p_del">-		(*pt_base)++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (*pt_end == PFN_DOWN(__pa(addr))) {</span>
<span class="p_del">-		set_page_prot_flags((void *)addr, PAGE_KERNEL, UVMF_INVLPG);</span>
<span class="p_del">-		clear_page((void *)addr);</span>
<span class="p_del">-		(*pt_end)--;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Set up the initial kernel pagetable.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We can construct this by grafting the Xen provided pagetable into</span>
<span class="p_del">- * head_64.S&#39;s preconstructed pagetables.  We copy the Xen L2&#39;s into</span>
<span class="p_del">- * level2_ident_pgt, and level2_kernel_pgt.  This means that only the</span>
<span class="p_del">- * kernel has a physical mapping to start with - but that&#39;s enough to</span>
<span class="p_del">- * get __va working.  We need to fill in the rest of the physical</span>
<span class="p_del">- * mapping once some sort of allocator has been set up.</span>
<span class="p_del">- */</span>
<span class="p_del">-void __init xen_setup_kernel_pagetable(pgd_t *pgd, unsigned long max_pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pud_t *l3;</span>
<span class="p_del">-	pmd_t *l2;</span>
<span class="p_del">-	unsigned long addr[3];</span>
<span class="p_del">-	unsigned long pt_base, pt_end;</span>
<span class="p_del">-	unsigned i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* max_pfn_mapped is the last pfn mapped in the initial memory</span>
<span class="p_del">-	 * mappings. Considering that on Xen after the kernel mappings we</span>
<span class="p_del">-	 * have the mappings of some pages that don&#39;t exist in pfn space, we</span>
<span class="p_del">-	 * set max_pfn_mapped to the last real pfn mapped. */</span>
<span class="p_del">-	if (xen_start_info-&gt;mfn_list &lt; __START_KERNEL_map)</span>
<span class="p_del">-		max_pfn_mapped = xen_start_info-&gt;first_p2m_pfn;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		max_pfn_mapped = PFN_DOWN(__pa(xen_start_info-&gt;mfn_list));</span>
<span class="p_del">-</span>
<span class="p_del">-	pt_base = PFN_DOWN(__pa(xen_start_info-&gt;pt_base));</span>
<span class="p_del">-	pt_end = pt_base + xen_start_info-&gt;nr_pt_frames;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Zap identity mapping */</span>
<span class="p_del">-	init_level4_pgt[0] = __pgd(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!xen_feature(XENFEAT_auto_translated_physmap)) {</span>
<span class="p_del">-		/* Pre-constructed entries are in pfn, so convert to mfn */</span>
<span class="p_del">-		/* L4[272] -&gt; level3_ident_pgt</span>
<span class="p_del">-		 * L4[511] -&gt; level3_kernel_pgt */</span>
<span class="p_del">-		convert_pfn_mfn(init_level4_pgt);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* L3_i[0] -&gt; level2_ident_pgt */</span>
<span class="p_del">-		convert_pfn_mfn(level3_ident_pgt);</span>
<span class="p_del">-		/* L3_k[510] -&gt; level2_kernel_pgt</span>
<span class="p_del">-		 * L3_k[511] -&gt; level2_fixmap_pgt */</span>
<span class="p_del">-		convert_pfn_mfn(level3_kernel_pgt);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* L3_k[511][506] -&gt; level1_fixmap_pgt */</span>
<span class="p_del">-		convert_pfn_mfn(level2_fixmap_pgt);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* We get [511][511] and have Xen&#39;s version of level2_kernel_pgt */</span>
<span class="p_del">-	l3 = m2v(pgd[pgd_index(__START_KERNEL_map)].pgd);</span>
<span class="p_del">-	l2 = m2v(l3[pud_index(__START_KERNEL_map)].pud);</span>
<span class="p_del">-</span>
<span class="p_del">-	addr[0] = (unsigned long)pgd;</span>
<span class="p_del">-	addr[1] = (unsigned long)l3;</span>
<span class="p_del">-	addr[2] = (unsigned long)l2;</span>
<span class="p_del">-	/* Graft it onto L4[272][0]. Note that we creating an aliasing problem:</span>
<span class="p_del">-	 * Both L4[272][0] and L4[511][510] have entries that point to the same</span>
<span class="p_del">-	 * L2 (PMD) tables. Meaning that if you modify it in __va space</span>
<span class="p_del">-	 * it will be also modified in the __ka space! (But if you just</span>
<span class="p_del">-	 * modify the PMD table to point to other PTE&#39;s or none, then you</span>
<span class="p_del">-	 * are OK - which is what cleanup_highmap does) */</span>
<span class="p_del">-	copy_page(level2_ident_pgt, l2);</span>
<span class="p_del">-	/* Graft it onto L4[511][510] */</span>
<span class="p_del">-	copy_page(level2_kernel_pgt, l2);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Copy the initial P-&gt;M table mappings if necessary. */</span>
<span class="p_del">-	i = pgd_index(xen_start_info-&gt;mfn_list);</span>
<span class="p_del">-	if (i &amp;&amp; i &lt; pgd_index(__START_KERNEL_map))</span>
<span class="p_del">-		init_level4_pgt[i] = ((pgd_t *)xen_start_info-&gt;pt_base)[i];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!xen_feature(XENFEAT_auto_translated_physmap)) {</span>
<span class="p_del">-		/* Make pagetable pieces RO */</span>
<span class="p_del">-		set_page_prot(init_level4_pgt, PAGE_KERNEL_RO);</span>
<span class="p_del">-		set_page_prot(level3_ident_pgt, PAGE_KERNEL_RO);</span>
<span class="p_del">-		set_page_prot(level3_kernel_pgt, PAGE_KERNEL_RO);</span>
<span class="p_del">-		set_page_prot(level3_user_vsyscall, PAGE_KERNEL_RO);</span>
<span class="p_del">-		set_page_prot(level2_ident_pgt, PAGE_KERNEL_RO);</span>
<span class="p_del">-		set_page_prot(level2_kernel_pgt, PAGE_KERNEL_RO);</span>
<span class="p_del">-		set_page_prot(level2_fixmap_pgt, PAGE_KERNEL_RO);</span>
<span class="p_del">-		set_page_prot(level1_fixmap_pgt, PAGE_KERNEL_RO);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Pin down new L4 */</span>
<span class="p_del">-		pin_pagetable_pfn(MMUEXT_PIN_L4_TABLE,</span>
<span class="p_del">-				  PFN_DOWN(__pa_symbol(init_level4_pgt)));</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Unpin Xen-provided one */</span>
<span class="p_del">-		pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * At this stage there can be no user pgd, and no page</span>
<span class="p_del">-		 * structure to attach it to, so make sure we just set kernel</span>
<span class="p_del">-		 * pgd.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		xen_mc_batch();</span>
<span class="p_del">-		__xen_write_cr3(true, __pa(init_level4_pgt));</span>
<span class="p_del">-		xen_mc_issue(PARAVIRT_LAZY_CPU);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		native_write_cr3(__pa(init_level4_pgt));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We can&#39;t that easily rip out L3 and L2, as the Xen pagetables are</span>
<span class="p_del">-	 * set out this way: [L4], [L1], [L2], [L3], [L1], [L1] ...  for</span>
<span class="p_del">-	 * the initial domain. For guests using the toolstack, they are in:</span>
<span class="p_del">-	 * [L4], [L3], [L2], [L1], [L1], order .. So for dom0 we can only</span>
<span class="p_del">-	 * rip out the [L4] (pgd), but for guests we shave off three pages.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(addr); i++)</span>
<span class="p_del">-		check_pt_base(&amp;pt_base, &amp;pt_end, addr[i]);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Our (by three pages) smaller Xen pagetable that we are using */</span>
<span class="p_del">-	xen_pt_base = PFN_PHYS(pt_base);</span>
<span class="p_del">-	xen_pt_size = (pt_end - pt_base) * PAGE_SIZE;</span>
<span class="p_del">-	memblock_reserve(xen_pt_base, xen_pt_size);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Revector the xen_start_info */</span>
<span class="p_del">-	xen_start_info = (struct start_info *)__va(__pa(xen_start_info));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Read a value from a physical address.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long __init xen_read_phys_ulong(phys_addr_t addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long *vaddr;</span>
<span class="p_del">-	unsigned long val;</span>
<span class="p_add">+#include &lt;linux/pfn.h&gt;</span>
<span class="p_add">+#include &lt;asm/xen/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/xen/hypercall.h&gt;</span>
<span class="p_add">+#include &lt;xen/interface/memory.h&gt;</span>
 
<span class="p_del">-	vaddr = early_memremap_ro(addr, sizeof(val));</span>
<span class="p_del">-	val = *vaddr;</span>
<span class="p_del">-	early_memunmap(vaddr, sizeof(val));</span>
<span class="p_del">-	return val;</span>
<span class="p_del">-}</span>
<span class="p_add">+#include &quot;multicalls.h&quot;</span>
<span class="p_add">+#include &quot;mmu.h&quot;</span>
 
 /*
<span class="p_del">- * Translate a virtual address to a physical one without relying on mapped</span>
<span class="p_del">- * page tables.</span>
<span class="p_add">+ * Protects atomic reservation decrease/increase against concurrent increases.</span>
<span class="p_add">+ * Also protects non-atomic updates of current_pages and balloon lists.</span>
  */
<span class="p_del">-static phys_addr_t __init xen_early_virt_to_phys(unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	phys_addr_t pa;</span>
<span class="p_del">-	pgd_t pgd;</span>
<span class="p_del">-	pud_t pud;</span>
<span class="p_del">-	pmd_t pmd;</span>
<span class="p_del">-	pte_t pte;</span>
<span class="p_del">-</span>
<span class="p_del">-	pa = read_cr3();</span>
<span class="p_del">-	pgd = native_make_pgd(xen_read_phys_ulong(pa + pgd_index(vaddr) *</span>
<span class="p_del">-						       sizeof(pgd)));</span>
<span class="p_del">-	if (!pgd_present(pgd))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	pa = pgd_val(pgd) &amp; PTE_PFN_MASK;</span>
<span class="p_del">-	pud = native_make_pud(xen_read_phys_ulong(pa + pud_index(vaddr) *</span>
<span class="p_del">-						       sizeof(pud)));</span>
<span class="p_del">-	if (!pud_present(pud))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	pa = pud_pfn(pud) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-	if (pud_large(pud))</span>
<span class="p_del">-		return pa + (vaddr &amp; ~PUD_MASK);</span>
<span class="p_del">-</span>
<span class="p_del">-	pmd = native_make_pmd(xen_read_phys_ulong(pa + pmd_index(vaddr) *</span>
<span class="p_del">-						       sizeof(pmd)));</span>
<span class="p_del">-	if (!pmd_present(pmd))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	pa = pmd_pfn(pmd) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-	if (pmd_large(pmd))</span>
<span class="p_del">-		return pa + (vaddr &amp; ~PMD_MASK);</span>
<span class="p_del">-</span>
<span class="p_del">-	pte = native_make_pte(xen_read_phys_ulong(pa + pte_index(vaddr) *</span>
<span class="p_del">-						       sizeof(pte)));</span>
<span class="p_del">-	if (!pte_present(pte))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	pa = pte_pfn(pte) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_del">-	return pa | (vaddr &amp; ~PAGE_MASK);</span>
<span class="p_del">-}</span>
<span class="p_add">+DEFINE_SPINLOCK(xen_reservation_lock);</span>
 
<span class="p_del">-/*</span>
<span class="p_del">- * Find a new area for the hypervisor supplied p2m list and relocate the p2m to</span>
<span class="p_del">- * this area.</span>
<span class="p_del">- */</span>
<span class="p_del">-void __init xen_relocate_p2m(void)</span>
<span class="p_add">+unsigned long arbitrary_virt_to_mfn(void *vaddr)</span>
 {
<span class="p_del">-	phys_addr_t size, new_area, pt_phys, pmd_phys, pud_phys;</span>
<span class="p_del">-	unsigned long p2m_pfn, p2m_pfn_end, n_frames, pfn, pfn_end;</span>
<span class="p_del">-	int n_pte, n_pt, n_pmd, n_pud, idx_pte, idx_pt, idx_pmd, idx_pud;</span>
<span class="p_del">-	pte_t *pt;</span>
<span class="p_del">-	pmd_t *pmd;</span>
<span class="p_del">-	pud_t *pud;</span>
<span class="p_del">-	pgd_t *pgd;</span>
<span class="p_del">-	unsigned long *new_p2m;</span>
<span class="p_del">-</span>
<span class="p_del">-	size = PAGE_ALIGN(xen_start_info-&gt;nr_pages * sizeof(unsigned long));</span>
<span class="p_del">-	n_pte = roundup(size, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_del">-	n_pt = roundup(size, PMD_SIZE) &gt;&gt; PMD_SHIFT;</span>
<span class="p_del">-	n_pmd = roundup(size, PUD_SIZE) &gt;&gt; PUD_SHIFT;</span>
<span class="p_del">-	n_pud = roundup(size, PGDIR_SIZE) &gt;&gt; PGDIR_SHIFT;</span>
<span class="p_del">-	n_frames = n_pte + n_pt + n_pmd + n_pud;</span>
<span class="p_del">-</span>
<span class="p_del">-	new_area = xen_find_free_area(PFN_PHYS(n_frames));</span>
<span class="p_del">-	if (!new_area) {</span>
<span class="p_del">-		xen_raw_console_write(&quot;Can&#39;t find new memory area for p2m needed due to E820 map conflict\n&quot;);</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Setup the page tables for addressing the new p2m list.</span>
<span class="p_del">-	 * We have asked the hypervisor to map the p2m list at the user address</span>
<span class="p_del">-	 * PUD_SIZE. It may have done so, or it may have used a kernel space</span>
<span class="p_del">-	 * address depending on the Xen version.</span>
<span class="p_del">-	 * To avoid any possible virtual address collision, just use</span>
<span class="p_del">-	 * 2 * PUD_SIZE for the new area.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pud_phys = new_area;</span>
<span class="p_del">-	pmd_phys = pud_phys + PFN_PHYS(n_pud);</span>
<span class="p_del">-	pt_phys = pmd_phys + PFN_PHYS(n_pmd);</span>
<span class="p_del">-	p2m_pfn = PFN_DOWN(pt_phys) + n_pt;</span>
<span class="p_del">-</span>
<span class="p_del">-	pgd = __va(read_cr3());</span>
<span class="p_del">-	new_p2m = (unsigned long *)(2 * PGDIR_SIZE);</span>
<span class="p_del">-	for (idx_pud = 0; idx_pud &lt; n_pud; idx_pud++) {</span>
<span class="p_del">-		pud = early_memremap(pud_phys, PAGE_SIZE);</span>
<span class="p_del">-		clear_page(pud);</span>
<span class="p_del">-		for (idx_pmd = 0; idx_pmd &lt; min(n_pmd, PTRS_PER_PUD);</span>
<span class="p_del">-		     idx_pmd++) {</span>
<span class="p_del">-			pmd = early_memremap(pmd_phys, PAGE_SIZE);</span>
<span class="p_del">-			clear_page(pmd);</span>
<span class="p_del">-			for (idx_pt = 0; idx_pt &lt; min(n_pt, PTRS_PER_PMD);</span>
<span class="p_del">-			     idx_pt++) {</span>
<span class="p_del">-				pt = early_memremap(pt_phys, PAGE_SIZE);</span>
<span class="p_del">-				clear_page(pt);</span>
<span class="p_del">-				for (idx_pte = 0;</span>
<span class="p_del">-				     idx_pte &lt; min(n_pte, PTRS_PER_PTE);</span>
<span class="p_del">-				     idx_pte++) {</span>
<span class="p_del">-					set_pte(pt + idx_pte,</span>
<span class="p_del">-						pfn_pte(p2m_pfn, PAGE_KERNEL));</span>
<span class="p_del">-					p2m_pfn++;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				n_pte -= PTRS_PER_PTE;</span>
<span class="p_del">-				early_memunmap(pt, PAGE_SIZE);</span>
<span class="p_del">-				make_lowmem_page_readonly(__va(pt_phys));</span>
<span class="p_del">-				pin_pagetable_pfn(MMUEXT_PIN_L1_TABLE,</span>
<span class="p_del">-						  PFN_DOWN(pt_phys));</span>
<span class="p_del">-				set_pmd(pmd + idx_pt,</span>
<span class="p_del">-					__pmd(_PAGE_TABLE | pt_phys));</span>
<span class="p_del">-				pt_phys += PAGE_SIZE;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			n_pt -= PTRS_PER_PMD;</span>
<span class="p_del">-			early_memunmap(pmd, PAGE_SIZE);</span>
<span class="p_del">-			make_lowmem_page_readonly(__va(pmd_phys));</span>
<span class="p_del">-			pin_pagetable_pfn(MMUEXT_PIN_L2_TABLE,</span>
<span class="p_del">-					  PFN_DOWN(pmd_phys));</span>
<span class="p_del">-			set_pud(pud + idx_pmd, __pud(_PAGE_TABLE | pmd_phys));</span>
<span class="p_del">-			pmd_phys += PAGE_SIZE;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		n_pmd -= PTRS_PER_PUD;</span>
<span class="p_del">-		early_memunmap(pud, PAGE_SIZE);</span>
<span class="p_del">-		make_lowmem_page_readonly(__va(pud_phys));</span>
<span class="p_del">-		pin_pagetable_pfn(MMUEXT_PIN_L3_TABLE, PFN_DOWN(pud_phys));</span>
<span class="p_del">-		set_pgd(pgd + 2 + idx_pud, __pgd(_PAGE_TABLE | pud_phys));</span>
<span class="p_del">-		pud_phys += PAGE_SIZE;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now copy the old p2m info to the new area. */</span>
<span class="p_del">-	memcpy(new_p2m, xen_p2m_addr, size);</span>
<span class="p_del">-	xen_p2m_addr = new_p2m;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Release the old p2m list and set new list info. */</span>
<span class="p_del">-	p2m_pfn = PFN_DOWN(xen_early_virt_to_phys(xen_start_info-&gt;mfn_list));</span>
<span class="p_del">-	BUG_ON(!p2m_pfn);</span>
<span class="p_del">-	p2m_pfn_end = p2m_pfn + PFN_DOWN(size);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (xen_start_info-&gt;mfn_list &lt; __START_KERNEL_map) {</span>
<span class="p_del">-		pfn = xen_start_info-&gt;first_p2m_pfn;</span>
<span class="p_del">-		pfn_end = xen_start_info-&gt;first_p2m_pfn +</span>
<span class="p_del">-			  xen_start_info-&gt;nr_p2m_frames;</span>
<span class="p_del">-		set_pgd(pgd + 1, __pgd(0));</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pfn = p2m_pfn;</span>
<span class="p_del">-		pfn_end = p2m_pfn_end;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	memblock_free(PFN_PHYS(pfn), PAGE_SIZE * (pfn_end - pfn));</span>
<span class="p_del">-	while (pfn &lt; pfn_end) {</span>
<span class="p_del">-		if (pfn == p2m_pfn) {</span>
<span class="p_del">-			pfn = p2m_pfn_end;</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		make_lowmem_page_readwrite(__va(PFN_PHYS(pfn)));</span>
<span class="p_del">-		pfn++;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	xmaddr_t maddr = arbitrary_virt_to_machine(vaddr);</span>
 
<span class="p_del">-	xen_start_info-&gt;mfn_list = (unsigned long)xen_p2m_addr;</span>
<span class="p_del">-	xen_start_info-&gt;first_p2m_pfn =  PFN_DOWN(new_area);</span>
<span class="p_del">-	xen_start_info-&gt;nr_p2m_frames = n_frames;</span>
<span class="p_add">+	return PFN_DOWN(maddr.maddr);</span>
 }
 
<span class="p_del">-#else	/* !CONFIG_X86_64 */</span>
<span class="p_del">-static RESERVE_BRK_ARRAY(pmd_t, initial_kernel_pmd, PTRS_PER_PMD);</span>
<span class="p_del">-static RESERVE_BRK_ARRAY(pmd_t, swapper_kernel_pmd, PTRS_PER_PMD);</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_write_cr3_init(unsigned long cr3)</span>
<span class="p_add">+xmaddr_t arbitrary_virt_to_machine(void *vaddr)</span>
 {
<span class="p_del">-	unsigned long pfn = PFN_DOWN(__pa(swapper_pg_dir));</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(read_cr3() != __pa(initial_page_table));</span>
<span class="p_del">-	BUG_ON(cr3 != __pa(swapper_pg_dir));</span>
<span class="p_add">+	unsigned long address = (unsigned long)vaddr;</span>
<span class="p_add">+	unsigned int level;</span>
<span class="p_add">+	pte_t *pte;</span>
<span class="p_add">+	unsigned offset;</span>
 
 	/*
<span class="p_del">-	 * We are switching to swapper_pg_dir for the first time (from</span>
<span class="p_del">-	 * initial_page_table) and therefore need to mark that page</span>
<span class="p_del">-	 * read-only and then pin it.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Xen disallows sharing of kernel PMDs for PAE</span>
<span class="p_del">-	 * guests. Therefore we must copy the kernel PMD from</span>
<span class="p_del">-	 * initial_page_table into a new kernel PMD to be used in</span>
<span class="p_del">-	 * swapper_pg_dir.</span>
<span class="p_add">+	 * if the PFN is in the linear mapped vaddr range, we can just use</span>
<span class="p_add">+	 * the (quick) virt_to_machine() p2m lookup</span>
 	 */
<span class="p_del">-	swapper_kernel_pmd =</span>
<span class="p_del">-		extend_brk(sizeof(pmd_t) * PTRS_PER_PMD, PAGE_SIZE);</span>
<span class="p_del">-	copy_page(swapper_kernel_pmd, initial_kernel_pmd);</span>
<span class="p_del">-	swapper_pg_dir[KERNEL_PGD_BOUNDARY] =</span>
<span class="p_del">-		__pgd(__pa(swapper_kernel_pmd) | _PAGE_PRESENT);</span>
<span class="p_del">-	set_page_prot(swapper_kernel_pmd, PAGE_KERNEL_RO);</span>
<span class="p_del">-</span>
<span class="p_del">-	set_page_prot(swapper_pg_dir, PAGE_KERNEL_RO);</span>
<span class="p_del">-	xen_write_cr3(cr3);</span>
<span class="p_del">-	pin_pagetable_pfn(MMUEXT_PIN_L3_TABLE, pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-	pin_pagetable_pfn(MMUEXT_UNPIN_TABLE,</span>
<span class="p_del">-			  PFN_DOWN(__pa(initial_page_table)));</span>
<span class="p_del">-	set_page_prot(initial_page_table, PAGE_KERNEL);</span>
<span class="p_del">-	set_page_prot(initial_kernel_pmd, PAGE_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	pv_mmu_ops.write_cr3 = &amp;xen_write_cr3;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * For 32 bit domains xen_start_info-&gt;pt_base is the pgd address which might be</span>
<span class="p_del">- * not the first page table in the page table pool.</span>
<span class="p_del">- * Iterate through the initial page tables to find the real page table base.</span>
<span class="p_del">- */</span>
<span class="p_del">-static phys_addr_t xen_find_pt_base(pmd_t *pmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	phys_addr_t pt_base, paddr;</span>
<span class="p_del">-	unsigned pmdidx;</span>
<span class="p_del">-</span>
<span class="p_del">-	pt_base = min(__pa(xen_start_info-&gt;pt_base), __pa(pmd));</span>
<span class="p_del">-</span>
<span class="p_del">-	for (pmdidx = 0; pmdidx &lt; PTRS_PER_PMD; pmdidx++)</span>
<span class="p_del">-		if (pmd_present(pmd[pmdidx]) &amp;&amp; !pmd_large(pmd[pmdidx])) {</span>
<span class="p_del">-			paddr = m2p(pmd[pmdidx].pmd);</span>
<span class="p_del">-			pt_base = min(pt_base, paddr);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	return pt_base;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init xen_setup_kernel_pagetable(pgd_t *pgd, unsigned long max_pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pmd_t *kernel_pmd;</span>
<span class="p_del">-</span>
<span class="p_del">-	kernel_pmd = m2v(pgd[KERNEL_PGD_BOUNDARY].pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_pt_base = xen_find_pt_base(kernel_pmd);</span>
<span class="p_del">-	xen_pt_size = xen_start_info-&gt;nr_pt_frames * PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	initial_kernel_pmd =</span>
<span class="p_del">-		extend_brk(sizeof(pmd_t) * PTRS_PER_PMD, PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	max_pfn_mapped = PFN_DOWN(xen_pt_base + xen_pt_size + 512 * 1024);</span>
<span class="p_del">-</span>
<span class="p_del">-	copy_page(initial_kernel_pmd, kernel_pmd);</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_map_identity_early(initial_kernel_pmd, max_pfn);</span>
<span class="p_del">-</span>
<span class="p_del">-	copy_page(initial_page_table, pgd);</span>
<span class="p_del">-	initial_page_table[KERNEL_PGD_BOUNDARY] =</span>
<span class="p_del">-		__pgd(__pa(initial_kernel_pmd) | _PAGE_PRESENT);</span>
<span class="p_del">-</span>
<span class="p_del">-	set_page_prot(initial_kernel_pmd, PAGE_KERNEL_RO);</span>
<span class="p_del">-	set_page_prot(initial_page_table, PAGE_KERNEL_RO);</span>
<span class="p_del">-	set_page_prot(empty_zero_page, PAGE_KERNEL_RO);</span>
<span class="p_del">-</span>
<span class="p_del">-	pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_del">-</span>
<span class="p_del">-	pin_pagetable_pfn(MMUEXT_PIN_L3_TABLE,</span>
<span class="p_del">-			  PFN_DOWN(__pa(initial_page_table)));</span>
<span class="p_del">-	xen_write_cr3(__pa(initial_page_table));</span>
<span class="p_del">-</span>
<span class="p_del">-	memblock_reserve(xen_pt_base, xen_pt_size);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif	/* CONFIG_X86_64 */</span>
<span class="p_del">-</span>
<span class="p_del">-void __init xen_reserve_special_pages(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	phys_addr_t paddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	memblock_reserve(__pa(xen_start_info), PAGE_SIZE);</span>
<span class="p_del">-	if (xen_start_info-&gt;store_mfn) {</span>
<span class="p_del">-		paddr = PFN_PHYS(mfn_to_pfn(xen_start_info-&gt;store_mfn));</span>
<span class="p_del">-		memblock_reserve(paddr, PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (!xen_initial_domain()) {</span>
<span class="p_del">-		paddr = PFN_PHYS(mfn_to_pfn(xen_start_info-&gt;console.domU.mfn));</span>
<span class="p_del">-		memblock_reserve(paddr, PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init xen_pt_check_e820(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (xen_is_e820_reserved(xen_pt_base, xen_pt_size)) {</span>
<span class="p_del">-		xen_raw_console_write(&quot;Xen hypervisor allocated page table memory conflicts with E820 map\n&quot;);</span>
<span class="p_del">-		BUG();</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned char dummy_mapping[PAGE_SIZE] __page_aligned_bss;</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_set_fixmap(unsigned idx, phys_addr_t phys, pgprot_t prot)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pte_t pte;</span>
<span class="p_del">-</span>
<span class="p_del">-	phys &gt;&gt;= PAGE_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (idx) {</span>
<span class="p_del">-	case FIX_BTMAP_END ... FIX_BTMAP_BEGIN:</span>
<span class="p_del">-	case FIX_RO_IDT:</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	case FIX_WP_TEST:</span>
<span class="p_del">-# ifdef CONFIG_HIGHMEM</span>
<span class="p_del">-	case FIX_KMAP_BEGIN ... FIX_KMAP_END:</span>
<span class="p_del">-# endif</span>
<span class="p_del">-#elif defined(CONFIG_X86_VSYSCALL_EMULATION)</span>
<span class="p_del">-	case VSYSCALL_PAGE:</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	case FIX_TEXT_POKE0:</span>
<span class="p_del">-	case FIX_TEXT_POKE1:</span>
<span class="p_del">-		/* All local page mappings */</span>
<span class="p_del">-		pte = pfn_pte(phys, prot);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="p_del">-	case FIX_APIC_BASE:	/* maps dummy local APIC */</span>
<span class="p_del">-		pte = pfn_pte(PFN_DOWN(__pa(dummy_mapping)), PAGE_KERNEL);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_IO_APIC</span>
<span class="p_del">-	case FIX_IO_APIC_BASE_0 ... FIX_IO_APIC_BASE_END:</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We just don&#39;t map the IO APIC - all access is via</span>
<span class="p_del">-		 * hypercalls.  Keep the address in the pte for reference.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		pte = pfn_pte(PFN_DOWN(__pa(dummy_mapping)), PAGE_KERNEL);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	case FIX_PARAVIRT_BOOTMAP:</span>
<span class="p_del">-		/* This is an MFN, but it isn&#39;t an IO mapping from the</span>
<span class="p_del">-		   IO domain */</span>
<span class="p_del">-		pte = mfn_pte(phys, prot);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* By default, set_fixmap is used for hardware mappings */</span>
<span class="p_del">-		pte = mfn_pte(phys, prot);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	__native_set_fixmap(idx, pte);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_VSYSCALL_EMULATION</span>
<span class="p_del">-	/* Replicate changes to map the vsyscall page into the user</span>
<span class="p_del">-	   pagetable vsyscall mapping. */</span>
<span class="p_del">-	if (idx == VSYSCALL_PAGE) {</span>
<span class="p_del">-		unsigned long vaddr = __fix_to_virt(idx);</span>
<span class="p_del">-		set_pte_vaddr_pud(level3_user_vsyscall, vaddr, pte);</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init xen_post_allocator_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	pv_mmu_ops.set_pte = xen_set_pte;</span>
<span class="p_del">-	pv_mmu_ops.set_pmd = xen_set_pmd;</span>
<span class="p_del">-	pv_mmu_ops.set_pud = xen_set_pud;</span>
<span class="p_del">-#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_del">-	pv_mmu_ops.set_pgd = xen_set_pgd;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This will work as long as patching hasn&#39;t happened yet</span>
<span class="p_del">-	   (which it hasn&#39;t) */</span>
<span class="p_del">-	pv_mmu_ops.alloc_pte = xen_alloc_pte;</span>
<span class="p_del">-	pv_mmu_ops.alloc_pmd = xen_alloc_pmd;</span>
<span class="p_del">-	pv_mmu_ops.release_pte = xen_release_pte;</span>
<span class="p_del">-	pv_mmu_ops.release_pmd = xen_release_pmd;</span>
<span class="p_del">-#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_del">-	pv_mmu_ops.alloc_pud = xen_alloc_pud;</span>
<span class="p_del">-	pv_mmu_ops.release_pud = xen_release_pud;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	pv_mmu_ops.make_pte = PV_CALLEE_SAVE(xen_make_pte);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	pv_mmu_ops.write_cr3 = &amp;xen_write_cr3;</span>
<span class="p_del">-	SetPagePinned(virt_to_page(level3_user_vsyscall));</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	xen_mark_init_mm_pinned();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void xen_leave_lazy_mmu(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-	xen_mc_flush();</span>
<span class="p_del">-	paravirt_leave_lazy_mmu();</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct pv_mmu_ops xen_mmu_ops __initconst = {</span>
<span class="p_del">-	.read_cr2 = xen_read_cr2,</span>
<span class="p_del">-	.write_cr2 = xen_write_cr2,</span>
<span class="p_del">-</span>
<span class="p_del">-	.read_cr3 = xen_read_cr3,</span>
<span class="p_del">-	.write_cr3 = xen_write_cr3_init,</span>
<span class="p_del">-</span>
<span class="p_del">-	.flush_tlb_user = xen_flush_tlb,</span>
<span class="p_del">-	.flush_tlb_kernel = xen_flush_tlb,</span>
<span class="p_del">-	.flush_tlb_single = xen_flush_tlb_single,</span>
<span class="p_del">-	.flush_tlb_others = xen_flush_tlb_others,</span>
<span class="p_del">-</span>
<span class="p_del">-	.pte_update = paravirt_nop,</span>
<span class="p_del">-</span>
<span class="p_del">-	.pgd_alloc = xen_pgd_alloc,</span>
<span class="p_del">-	.pgd_free = xen_pgd_free,</span>
<span class="p_del">-</span>
<span class="p_del">-	.alloc_pte = xen_alloc_pte_init,</span>
<span class="p_del">-	.release_pte = xen_release_pte_init,</span>
<span class="p_del">-	.alloc_pmd = xen_alloc_pmd_init,</span>
<span class="p_del">-	.release_pmd = xen_release_pmd_init,</span>
<span class="p_del">-</span>
<span class="p_del">-	.set_pte = xen_set_pte_init,</span>
<span class="p_del">-	.set_pte_at = xen_set_pte_at,</span>
<span class="p_del">-	.set_pmd = xen_set_pmd_hyper,</span>
<span class="p_del">-</span>
<span class="p_del">-	.ptep_modify_prot_start = __ptep_modify_prot_start,</span>
<span class="p_del">-	.ptep_modify_prot_commit = __ptep_modify_prot_commit,</span>
<span class="p_del">-</span>
<span class="p_del">-	.pte_val = PV_CALLEE_SAVE(xen_pte_val),</span>
<span class="p_del">-	.pgd_val = PV_CALLEE_SAVE(xen_pgd_val),</span>
<span class="p_del">-</span>
<span class="p_del">-	.make_pte = PV_CALLEE_SAVE(xen_make_pte_init),</span>
<span class="p_del">-	.make_pgd = PV_CALLEE_SAVE(xen_make_pgd),</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	.set_pte_atomic = xen_set_pte_atomic,</span>
<span class="p_del">-	.pte_clear = xen_pte_clear,</span>
<span class="p_del">-	.pmd_clear = xen_pmd_clear,</span>
<span class="p_del">-#endif	/* CONFIG_X86_PAE */</span>
<span class="p_del">-	.set_pud = xen_set_pud_hyper,</span>
<span class="p_del">-</span>
<span class="p_del">-	.make_pmd = PV_CALLEE_SAVE(xen_make_pmd),</span>
<span class="p_del">-	.pmd_val = PV_CALLEE_SAVE(xen_pmd_val),</span>
<span class="p_del">-</span>
<span class="p_del">-#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_del">-	.pud_val = PV_CALLEE_SAVE(xen_pud_val),</span>
<span class="p_del">-	.make_pud = PV_CALLEE_SAVE(xen_make_pud),</span>
<span class="p_del">-	.set_pgd = xen_set_pgd_hyper,</span>
<span class="p_del">-</span>
<span class="p_del">-	.alloc_pud = xen_alloc_pmd_init,</span>
<span class="p_del">-	.release_pud = xen_release_pmd_init,</span>
<span class="p_del">-#endif	/* CONFIG_PGTABLE_LEVELS == 4 */</span>
<span class="p_del">-</span>
<span class="p_del">-	.activate_mm = xen_activate_mm,</span>
<span class="p_del">-	.dup_mmap = xen_dup_mmap,</span>
<span class="p_del">-	.exit_mmap = xen_exit_mmap,</span>
<span class="p_del">-</span>
<span class="p_del">-	.lazy_mode = {</span>
<span class="p_del">-		.enter = paravirt_enter_lazy_mmu,</span>
<span class="p_del">-		.leave = xen_leave_lazy_mmu,</span>
<span class="p_del">-		.flush = paravirt_flush_lazy_mmu,</span>
<span class="p_del">-	},</span>
<span class="p_del">-</span>
<span class="p_del">-	.set_fixmap = xen_set_fixmap,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-void __init xen_init_mmu_ops(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	x86_init.paging.pagetable_init = xen_pagetable_init;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	if (virt_addr_valid(vaddr))</span>
<span class="p_add">+		return virt_to_machine(vaddr);</span>
 
<span class="p_del">-	pv_mmu_ops = xen_mmu_ops;</span>
<span class="p_add">+	/* otherwise we have to do a (slower) full page-table walk */</span>
 
<span class="p_del">-	memset(dummy_mapping, 0xff, PAGE_SIZE);</span>
<span class="p_add">+	pte = lookup_address(address, &amp;level);</span>
<span class="p_add">+	BUG_ON(pte == NULL);</span>
<span class="p_add">+	offset = address &amp; ~PAGE_MASK;</span>
<span class="p_add">+	return XMADDR(((phys_addr_t)pte_mfn(*pte) &lt;&lt; PAGE_SHIFT) + offset);</span>
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(arbitrary_virt_to_machine);</span>
 
<span class="p_del">-/* Protected by xen_reservation_lock. */</span>
<span class="p_del">-#define MAX_CONTIG_ORDER 9 /* 2MB */</span>
<span class="p_del">-static unsigned long discontig_frames[1&lt;&lt;MAX_CONTIG_ORDER];</span>
<span class="p_del">-</span>
<span class="p_del">-#define VOID_PTE (mfn_pte(0, __pgprot(0)))</span>
<span class="p_del">-static void xen_zap_pfn_range(unsigned long vaddr, unsigned int order,</span>
<span class="p_del">-				unsigned long *in_frames,</span>
<span class="p_del">-				unsigned long *out_frames)</span>
<span class="p_add">+void xen_flush_tlb_all(void)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	struct mmuext_op *op;</span>
 	struct multicall_space mcs;
 
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-	for (i = 0; i &lt; (1UL&lt;&lt;order); i++, vaddr += PAGE_SIZE) {</span>
<span class="p_del">-		mcs = __xen_mc_entry(0);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (in_frames)</span>
<span class="p_del">-			in_frames[i] = virt_to_mfn(vaddr);</span>
<span class="p_del">-</span>
<span class="p_del">-		MULTI_update_va_mapping(mcs.mc, vaddr, VOID_PTE, 0);</span>
<span class="p_del">-		__set_phys_to_machine(virt_to_pfn(vaddr), INVALID_P2M_ENTRY);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (out_frames)</span>
<span class="p_del">-			out_frames[i] = virt_to_pfn(vaddr);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	xen_mc_issue(0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Update the pfn-to-mfn mappings for a virtual address range, either to</span>
<span class="p_del">- * point to an array of mfns, or contiguously from a single starting</span>
<span class="p_del">- * mfn.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void xen_remap_exchanged_ptes(unsigned long vaddr, int order,</span>
<span class="p_del">-				     unsigned long *mfns,</span>
<span class="p_del">-				     unsigned long first_mfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned i, limit;</span>
<span class="p_del">-	unsigned long mfn;</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_batch();</span>
<span class="p_del">-</span>
<span class="p_del">-	limit = 1u &lt;&lt; order;</span>
<span class="p_del">-	for (i = 0; i &lt; limit; i++, vaddr += PAGE_SIZE) {</span>
<span class="p_del">-		struct multicall_space mcs;</span>
<span class="p_del">-		unsigned flags;</span>
<span class="p_del">-</span>
<span class="p_del">-		mcs = __xen_mc_entry(0);</span>
<span class="p_del">-		if (mfns)</span>
<span class="p_del">-			mfn = mfns[i];</span>
<span class="p_del">-		else</span>
<span class="p_del">-			mfn = first_mfn + i;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (i &lt; (limit - 1))</span>
<span class="p_del">-			flags = 0;</span>
<span class="p_del">-		else {</span>
<span class="p_del">-			if (order == 0)</span>
<span class="p_del">-				flags = UVMF_INVLPG | UVMF_ALL;</span>
<span class="p_del">-			else</span>
<span class="p_del">-				flags = UVMF_TLB_FLUSH | UVMF_ALL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		MULTI_update_va_mapping(mcs.mc, vaddr,</span>
<span class="p_del">-				mfn_pte(mfn, PAGE_KERNEL), flags);</span>
<span class="p_del">-</span>
<span class="p_del">-		set_phys_to_machine(virt_to_pfn(vaddr), mfn);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	xen_mc_issue(0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Perform the hypercall to exchange a region of our pfns to point to</span>
<span class="p_del">- * memory with the required contiguous alignment.  Takes the pfns as</span>
<span class="p_del">- * input, and populates mfns as output.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Returns a success code indicating whether the hypervisor was able to</span>
<span class="p_del">- * satisfy the request or not.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int xen_exchange_memory(unsigned long extents_in, unsigned int order_in,</span>
<span class="p_del">-			       unsigned long *pfns_in,</span>
<span class="p_del">-			       unsigned long extents_out,</span>
<span class="p_del">-			       unsigned int order_out,</span>
<span class="p_del">-			       unsigned long *mfns_out,</span>
<span class="p_del">-			       unsigned int address_bits)</span>
<span class="p_del">-{</span>
<span class="p_del">-	long rc;</span>
<span class="p_del">-	int success;</span>
<span class="p_del">-</span>
<span class="p_del">-	struct xen_memory_exchange exchange = {</span>
<span class="p_del">-		.in = {</span>
<span class="p_del">-			.nr_extents   = extents_in,</span>
<span class="p_del">-			.extent_order = order_in,</span>
<span class="p_del">-			.extent_start = pfns_in,</span>
<span class="p_del">-			.domid        = DOMID_SELF</span>
<span class="p_del">-		},</span>
<span class="p_del">-		.out = {</span>
<span class="p_del">-			.nr_extents   = extents_out,</span>
<span class="p_del">-			.extent_order = order_out,</span>
<span class="p_del">-			.extent_start = mfns_out,</span>
<span class="p_del">-			.address_bits = address_bits,</span>
<span class="p_del">-			.domid        = DOMID_SELF</span>
<span class="p_del">-		}</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(extents_in &lt;&lt; order_in != extents_out &lt;&lt; order_out);</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = HYPERVISOR_memory_op(XENMEM_exchange, &amp;exchange);</span>
<span class="p_del">-	success = (exchange.nr_exchanged == extents_in);</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(!success &amp;&amp; ((exchange.nr_exchanged != 0) || (rc == 0)));</span>
<span class="p_del">-	BUG_ON(success &amp;&amp; (rc != 0));</span>
<span class="p_del">-</span>
<span class="p_del">-	return success;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int xen_create_contiguous_region(phys_addr_t pstart, unsigned int order,</span>
<span class="p_del">-				 unsigned int address_bits,</span>
<span class="p_del">-				 dma_addr_t *dma_handle)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long *in_frames = discontig_frames, out_frame;</span>
<span class="p_del">-	unsigned long  flags;</span>
<span class="p_del">-	int            success;</span>
<span class="p_del">-	unsigned long vstart = (unsigned long)phys_to_virt(pstart);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Currently an auto-translated guest will not perform I/O, nor will</span>
<span class="p_del">-	 * it require PAE page directories below 4GB. Therefore any calls to</span>
<span class="p_del">-	 * this function are redundant and can be ignored.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(order &gt; MAX_CONTIG_ORDER))</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset((void *) vstart, 0, PAGE_SIZE &lt;&lt; order);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;xen_reservation_lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 1. Zap current PTEs, remembering MFNs. */</span>
<span class="p_del">-	xen_zap_pfn_range(vstart, order, in_frames, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 2. Get a new contiguous memory extent. */</span>
<span class="p_del">-	out_frame = virt_to_pfn(vstart);</span>
<span class="p_del">-	success = xen_exchange_memory(1UL &lt;&lt; order, 0, in_frames,</span>
<span class="p_del">-				      1, order, &amp;out_frame,</span>
<span class="p_del">-				      address_bits);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 3. Map the new extent in place of old pages. */</span>
<span class="p_del">-	if (success)</span>
<span class="p_del">-		xen_remap_exchanged_ptes(vstart, order, NULL, out_frame);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		xen_remap_exchanged_ptes(vstart, order, in_frames, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;xen_reservation_lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	*dma_handle = virt_to_machine(vstart).maddr;</span>
<span class="p_del">-	return success ? 0 : -ENOMEM;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(xen_create_contiguous_region);</span>
<span class="p_del">-</span>
<span class="p_del">-void xen_destroy_contiguous_region(phys_addr_t pstart, unsigned int order)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long *out_frames = discontig_frames, in_frame;</span>
<span class="p_del">-	unsigned long  flags;</span>
<span class="p_del">-	int success;</span>
<span class="p_del">-	unsigned long vstart;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(order &gt; MAX_CONTIG_ORDER))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	vstart = (unsigned long)phys_to_virt(pstart);</span>
<span class="p_del">-	memset((void *) vstart, 0, PAGE_SIZE &lt;&lt; order);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;xen_reservation_lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 1. Find start MFN of contiguous extent. */</span>
<span class="p_del">-	in_frame = virt_to_mfn(vstart);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 2. Zap current PTEs. */</span>
<span class="p_del">-	xen_zap_pfn_range(vstart, order, NULL, out_frames);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 3. Do the exchange for non-contiguous MFNs. */</span>
<span class="p_del">-	success = xen_exchange_memory(1, order, &amp;in_frame, 1UL &lt;&lt; order,</span>
<span class="p_del">-					0, out_frames, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 4. Map new pages in place of old pages. */</span>
<span class="p_del">-	if (success)</span>
<span class="p_del">-		xen_remap_exchanged_ptes(vstart, order, out_frames, 0);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		xen_remap_exchanged_ptes(vstart, order, NULL, in_frame);</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;xen_reservation_lock, flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(xen_destroy_contiguous_region);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_XEN_PVHVM</span>
<span class="p_del">-#ifdef CONFIG_PROC_VMCORE</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This function is used in two contexts:</span>
<span class="p_del">- * - the kdump kernel has to check whether a pfn of the crashed kernel</span>
<span class="p_del">- *   was a ballooned page. vmcore is using this function to decide</span>
<span class="p_del">- *   whether to access a pfn of the crashed kernel.</span>
<span class="p_del">- * - the kexec kernel has to check whether a pfn was ballooned by the</span>
<span class="p_del">- *   previous kernel. If the pfn is ballooned, handle it properly.</span>
<span class="p_del">- * Returns 0 if the pfn is not backed by a RAM page, the caller may</span>
<span class="p_del">- * handle the pfn special in this case.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int xen_oldmem_pfn_is_ram(unsigned long pfn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xen_hvm_get_mem_type a = {</span>
<span class="p_del">-		.domid = DOMID_SELF,</span>
<span class="p_del">-		.pfn = pfn,</span>
<span class="p_del">-	};</span>
<span class="p_del">-	int ram;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (HYPERVISOR_hvm_op(HVMOP_get_mem_type, &amp;a))</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (a.mem_type) {</span>
<span class="p_del">-		case HVMMEM_mmio_dm:</span>
<span class="p_del">-			ram = 0;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case HVMMEM_ram_rw:</span>
<span class="p_del">-		case HVMMEM_ram_ro:</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			ram = 1;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return ram;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	trace_xen_mmu_flush_tlb_all(0);</span>
 
<span class="p_del">-static void xen_hvm_exit_mmap(struct mm_struct *mm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xen_hvm_pagetable_dying a;</span>
<span class="p_del">-	int rc;</span>
<span class="p_add">+	preempt_disable();</span>
 
<span class="p_del">-	a.domid = DOMID_SELF;</span>
<span class="p_del">-	a.gpa = __pa(mm-&gt;pgd);</span>
<span class="p_del">-	rc = HYPERVISOR_hvm_op(HVMOP_pagetable_dying, &amp;a);</span>
<span class="p_del">-	WARN_ON_ONCE(rc &lt; 0);</span>
<span class="p_del">-}</span>
<span class="p_add">+	mcs = xen_mc_entry(sizeof(*op));</span>
 
<span class="p_del">-static int is_pagetable_dying_supported(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xen_hvm_pagetable_dying a;</span>
<span class="p_del">-	int rc = 0;</span>
<span class="p_add">+	op = mcs.args;</span>
<span class="p_add">+	op-&gt;cmd = MMUEXT_TLB_FLUSH_ALL;</span>
<span class="p_add">+	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);</span>
 
<span class="p_del">-	a.domid = DOMID_SELF;</span>
<span class="p_del">-	a.gpa = 0x00;</span>
<span class="p_del">-	rc = HYPERVISOR_hvm_op(HVMOP_pagetable_dying, &amp;a);</span>
<span class="p_del">-	if (rc &lt; 0) {</span>
<span class="p_del">-		printk(KERN_DEBUG &quot;HVMOP_pagetable_dying not supported\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
 
<span class="p_del">-void __init xen_hvm_init_mmu_ops(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (is_pagetable_dying_supported())</span>
<span class="p_del">-		pv_mmu_ops.exit_mmap = xen_hvm_exit_mmap;</span>
<span class="p_del">-#ifdef CONFIG_PROC_VMCORE</span>
<span class="p_del">-	register_oldmem_pfn_is_ram(&amp;xen_oldmem_pfn_is_ram);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	preempt_enable();</span>
 }
<span class="p_del">-#endif</span>
 
 #define REMAP_BATCH_SIZE 16
 
<span class="p_chunk">@@ -2894,7 +191,6 @@</span> <span class="p_context"> int xen_remap_domain_gfn_array(struct vm_area_struct *vma,</span>
 }
 EXPORT_SYMBOL_GPL(xen_remap_domain_gfn_array);
 
<span class="p_del">-</span>
 /* Returns: 0 success */
 int xen_unmap_domain_gfn_range(struct vm_area_struct *vma,
 			       int numpgs, struct page **pages)
<span class="p_header">diff --git a/arch/x86/xen/mmu_hvm.c b/arch/x86/xen/mmu_hvm.c</span>
new file mode 100644
<span class="p_header">index 0000000..c0ecb92</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/xen/mmu_hvm.c</span>
<span class="p_chunk">@@ -0,0 +1,77 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;linux/crash_dump.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;xen/interface/xen.h&gt;</span>
<span class="p_add">+#include &lt;xen/hvm.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_VMCORE</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function is used in two contexts:</span>
<span class="p_add">+ * - the kdump kernel has to check whether a pfn of the crashed kernel</span>
<span class="p_add">+ *   was a ballooned page. vmcore is using this function to decide</span>
<span class="p_add">+ *   whether to access a pfn of the crashed kernel.</span>
<span class="p_add">+ * - the kexec kernel has to check whether a pfn was ballooned by the</span>
<span class="p_add">+ *   previous kernel. If the pfn is ballooned, handle it properly.</span>
<span class="p_add">+ * Returns 0 if the pfn is not backed by a RAM page, the caller may</span>
<span class="p_add">+ * handle the pfn special in this case.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int xen_oldmem_pfn_is_ram(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xen_hvm_get_mem_type a = {</span>
<span class="p_add">+		.domid = DOMID_SELF,</span>
<span class="p_add">+		.pfn = pfn,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	int ram;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (HYPERVISOR_hvm_op(HVMOP_get_mem_type, &amp;a))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (a.mem_type) {</span>
<span class="p_add">+	case HVMMEM_mmio_dm:</span>
<span class="p_add">+		ram = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case HVMMEM_ram_rw:</span>
<span class="p_add">+	case HVMMEM_ram_ro:</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		ram = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ram;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_hvm_exit_mmap(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xen_hvm_pagetable_dying a;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	a.domid = DOMID_SELF;</span>
<span class="p_add">+	a.gpa = __pa(mm-&gt;pgd);</span>
<span class="p_add">+	rc = HYPERVISOR_hvm_op(HVMOP_pagetable_dying, &amp;a);</span>
<span class="p_add">+	WARN_ON_ONCE(rc &lt; 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int is_pagetable_dying_supported(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xen_hvm_pagetable_dying a;</span>
<span class="p_add">+	int rc = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	a.domid = DOMID_SELF;</span>
<span class="p_add">+	a.gpa = 0x00;</span>
<span class="p_add">+	rc = HYPERVISOR_hvm_op(HVMOP_pagetable_dying, &amp;a);</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		printk(KERN_DEBUG &quot;HVMOP_pagetable_dying not supported\n&quot;);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init xen_hvm_init_mmu_ops(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (is_pagetable_dying_supported())</span>
<span class="p_add">+		pv_mmu_ops.exit_mmap = xen_hvm_exit_mmap;</span>
<span class="p_add">+#ifdef CONFIG_PROC_VMCORE</span>
<span class="p_add">+	register_oldmem_pfn_is_ram(&amp;xen_oldmem_pfn_is_ram);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/xen/mmu_pv.c b/arch/x86/xen/mmu_pv.c</span>
new file mode 100644
<span class="p_header">index 0000000..80b5362</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/xen/mmu_pv.c</span>
<span class="p_chunk">@@ -0,0 +1,2636 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Xen mmu operations</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This file contains the various mmu fetch and update operations.</span>
<span class="p_add">+ * The most important job they must perform is the mapping between the</span>
<span class="p_add">+ * domain&#39;s pfn and the overall machine mfns.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Xen allows guests to directly update the pagetable, in a controlled</span>
<span class="p_add">+ * fashion.  In other words, the guest modifies the same pagetable</span>
<span class="p_add">+ * that the CPU actually uses, which eliminates the overhead of having</span>
<span class="p_add">+ * a separate shadow pagetable.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to allow this, it falls on the guest domain to map its</span>
<span class="p_add">+ * notion of a &quot;physical&quot; pfn - which is just a domain-local linear</span>
<span class="p_add">+ * address - into a real &quot;machine address&quot; which the CPU&#39;s MMU can</span>
<span class="p_add">+ * use.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A pgd_t/pmd_t/pte_t will typically contain an mfn, and so can be</span>
<span class="p_add">+ * inserted directly into the pagetable.  When creating a new</span>
<span class="p_add">+ * pte/pmd/pgd, it converts the passed pfn into an mfn.  Conversely,</span>
<span class="p_add">+ * when reading the content back with __(pgd|pmd|pte)_val, it converts</span>
<span class="p_add">+ * the mfn back into a pfn.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The other constraint is that all pages which make up a pagetable</span>
<span class="p_add">+ * must be mapped read-only in the guest.  This prevents uncontrolled</span>
<span class="p_add">+ * guest updates to the pagetable.  Xen strictly enforces this, and</span>
<span class="p_add">+ * will disallow any pagetable update which will end up mapping a</span>
<span class="p_add">+ * pagetable page RW, and will disallow using any writable page as a</span>
<span class="p_add">+ * pagetable.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Naively, when loading %cr3 with the base of a new pagetable, Xen</span>
<span class="p_add">+ * would need to validate the whole pagetable before going on.</span>
<span class="p_add">+ * Naturally, this is quite slow.  The solution is to &quot;pin&quot; a</span>
<span class="p_add">+ * pagetable, which enforces all the constraints on the pagetable even</span>
<span class="p_add">+ * when it is not actively in use.  This menas that Xen can be assured</span>
<span class="p_add">+ * that it is still valid when you do load it into %cr3, and doesn&#39;t</span>
<span class="p_add">+ * need to revalidate it.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Jeremy Fitzhardinge &lt;jeremy@xensource.com&gt;, XenSource Inc, 2007</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/highmem.h&gt;</span>
<span class="p_add">+#include &lt;linux/debugfs.h&gt;</span>
<span class="p_add">+#include &lt;linux/bug.h&gt;</span>
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/gfp.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;trace/events/xen.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/fixmap.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/paravirt.h&gt;</span>
<span class="p_add">+#include &lt;asm/e820.h&gt;</span>
<span class="p_add">+#include &lt;asm/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/init.h&gt;</span>
<span class="p_add">+#include &lt;asm/pat.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/xen/hypercall.h&gt;</span>
<span class="p_add">+#include &lt;asm/xen/hypervisor.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;xen/xen.h&gt;</span>
<span class="p_add">+#include &lt;xen/page.h&gt;</span>
<span class="p_add">+#include &lt;xen/interface/xen.h&gt;</span>
<span class="p_add">+#include &lt;xen/interface/hvm/hvm_op.h&gt;</span>
<span class="p_add">+#include &lt;xen/interface/version.h&gt;</span>
<span class="p_add">+#include &lt;xen/interface/memory.h&gt;</span>
<span class="p_add">+#include &lt;xen/hvc-console.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;multicalls.h&quot;</span>
<span class="p_add">+#include &quot;mmu.h&quot;</span>
<span class="p_add">+#include &quot;debugfs.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Identity map, in addition to plain kernel map.  This needs to be</span>
<span class="p_add">+ * large enough to allocate page table pages to allocate the rest.</span>
<span class="p_add">+ * Each page can map 2MB.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define LEVEL1_IDENT_ENTRIES	(PTRS_PER_PTE * 4)</span>
<span class="p_add">+static RESERVE_BRK_ARRAY(pte_t, level1_ident_pgt, LEVEL1_IDENT_ENTRIES);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+/* l3 pud for userspace vsyscall mapping */</span>
<span class="p_add">+static pud_t level3_user_vsyscall[PTRS_PER_PUD] __page_aligned_bss;</span>
<span class="p_add">+#endif /* CONFIG_X86_64 */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Note about cr3 (pagetable base) values:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * xen_cr3 contains the current logical cr3 value; it contains the</span>
<span class="p_add">+ * last set cr3.  This may not be the current effective cr3, because</span>
<span class="p_add">+ * its update may be being lazily deferred.  However, a vcpu looking</span>
<span class="p_add">+ * at its own cr3 can use this value knowing that it everything will</span>
<span class="p_add">+ * be self-consistent.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * xen_current_cr3 contains the actual vcpu cr3; it is set once the</span>
<span class="p_add">+ * hypercall to set the vcpu cr3 is complete (so it may be a little</span>
<span class="p_add">+ * out of date, but it will never be set early).  If one vcpu is</span>
<span class="p_add">+ * looking at another vcpu&#39;s cr3 value, it should use this variable.</span>
<span class="p_add">+ */</span>
<span class="p_add">+DEFINE_PER_CPU(unsigned long, xen_cr3);	 /* cr3 stored as physaddr */</span>
<span class="p_add">+DEFINE_PER_CPU(unsigned long, xen_current_cr3);	 /* actual vcpu cr3 */</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t xen_pt_base, xen_pt_size __initdata;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Just beyond the highest usermode address.  STACK_TOP_MAX has a</span>
<span class="p_add">+ * redzone above it, so round it up to a PGD boundary.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USER_LIMIT	((STACK_TOP_MAX + PGDIR_SIZE - 1) &amp; PGDIR_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+void make_lowmem_page_readonly(void *vaddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t *pte, ptev;</span>
<span class="p_add">+	unsigned long address = (unsigned long)vaddr;</span>
<span class="p_add">+	unsigned int level;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = lookup_address(address, &amp;level);</span>
<span class="p_add">+	if (pte == NULL)</span>
<span class="p_add">+		return;		/* vaddr missing */</span>
<span class="p_add">+</span>
<span class="p_add">+	ptev = pte_wrprotect(*pte);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (HYPERVISOR_update_va_mapping(address, ptev, 0))</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void make_lowmem_page_readwrite(void *vaddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t *pte, ptev;</span>
<span class="p_add">+	unsigned long address = (unsigned long)vaddr;</span>
<span class="p_add">+	unsigned int level;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = lookup_address(address, &amp;level);</span>
<span class="p_add">+	if (pte == NULL)</span>
<span class="p_add">+		return;		/* vaddr missing */</span>
<span class="p_add">+</span>
<span class="p_add">+	ptev = pte_mkwrite(*pte);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (HYPERVISOR_update_va_mapping(address, ptev, 0))</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static bool xen_page_pinned(void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *page = virt_to_page(ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+	return PagePinned(page);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void xen_set_domain_pte(pte_t *ptep, pte_t pteval, unsigned domid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+	struct mmu_update *u;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_set_domain_pte(ptep, pteval, domid);</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = xen_mc_entry(sizeof(*u));</span>
<span class="p_add">+	u = mcs.args;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ptep might be kmapped when using 32-bit HIGHPTE */</span>
<span class="p_add">+	u-&gt;ptr = virt_to_machine(ptep).maddr;</span>
<span class="p_add">+	u-&gt;val = pte_val_ma(pteval);</span>
<span class="p_add">+</span>
<span class="p_add">+	MULTI_mmu_update(mcs.mc, mcs.args, 1, NULL, domid);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(xen_set_domain_pte);</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_extend_mmu_update(const struct mmu_update *update)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+	struct mmu_update *u;</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = xen_mc_extend_args(__HYPERVISOR_mmu_update, sizeof(*u));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mcs.mc != NULL) {</span>
<span class="p_add">+		mcs.mc-&gt;args[1]++;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mcs = __xen_mc_entry(sizeof(*u));</span>
<span class="p_add">+		MULTI_mmu_update(mcs.mc, mcs.args, 1, NULL, DOMID_SELF);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	u = mcs.args;</span>
<span class="p_add">+	*u = *update;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_extend_mmuext_op(const struct mmuext_op *op)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+	struct mmuext_op *u;</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = xen_mc_extend_args(__HYPERVISOR_mmuext_op, sizeof(*u));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mcs.mc != NULL) {</span>
<span class="p_add">+		mcs.mc-&gt;args[1]++;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mcs = __xen_mc_entry(sizeof(*u));</span>
<span class="p_add">+		MULTI_mmuext_op(mcs.mc, mcs.args, 1, NULL, DOMID_SELF);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	u = mcs.args;</span>
<span class="p_add">+	*u = *op;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_pmd_hyper(pmd_t *ptr, pmd_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmu_update u;</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ptr may be ioremapped for 64-bit pagetable setup */</span>
<span class="p_add">+	u.ptr = arbitrary_virt_to_machine(ptr).maddr;</span>
<span class="p_add">+	u.val = pmd_val_ma(val);</span>
<span class="p_add">+	xen_extend_mmu_update(&amp;u);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_pmd(pmd_t *ptr, pmd_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_set_pmd(ptr, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If page is not pinned, we can just update the entry</span>
<span class="p_add">+	   directly */</span>
<span class="p_add">+	if (!xen_page_pinned(ptr)) {</span>
<span class="p_add">+		*ptr = val;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_set_pmd_hyper(ptr, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Associate a virtual page frame with a given physical page frame</span>
<span class="p_add">+ * and protection flags for that frame.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void set_pte_mfn(unsigned long vaddr, unsigned long mfn, pgprot_t flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_pte_vaddr(vaddr, mfn_pte(mfn, flags));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool xen_batched_set_pte(pte_t *ptep, pte_t pteval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmu_update u;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (paravirt_get_lazy_mode() != PARAVIRT_LAZY_MMU)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	u.ptr = virt_to_machine(ptep).maddr | MMU_NORMAL_PT_UPDATE;</span>
<span class="p_add">+	u.val = pte_val_ma(pteval);</span>
<span class="p_add">+	xen_extend_mmu_update(&amp;u);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __xen_set_pte(pte_t *ptep, pte_t pteval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!xen_batched_set_pte(ptep, pteval)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Could call native_set_pte() here and trap and</span>
<span class="p_add">+		 * emulate the PTE write but with 32-bit guests this</span>
<span class="p_add">+		 * needs two traps (one for each of the two 32-bit</span>
<span class="p_add">+		 * words in the PTE) so do one hypercall directly</span>
<span class="p_add">+		 * instead.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		struct mmu_update u;</span>
<span class="p_add">+</span>
<span class="p_add">+		u.ptr = virt_to_machine(ptep).maddr | MMU_NORMAL_PT_UPDATE;</span>
<span class="p_add">+		u.val = pte_val_ma(pteval);</span>
<span class="p_add">+		HYPERVISOR_mmu_update(&amp;u, 1, NULL, DOMID_SELF);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_pte(pte_t *ptep, pte_t pteval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_set_pte(ptep, pteval);</span>
<span class="p_add">+	__xen_set_pte(ptep, pteval);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+		    pte_t *ptep, pte_t pteval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_set_pte_at(mm, addr, ptep, pteval);</span>
<span class="p_add">+	__xen_set_pte(ptep, pteval);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+pte_t xen_ptep_modify_prot_start(struct mm_struct *mm,</span>
<span class="p_add">+				 unsigned long addr, pte_t *ptep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Just return the pte as-is.  We preserve the bits on commit */</span>
<span class="p_add">+	trace_xen_mmu_ptep_modify_prot_start(mm, addr, ptep, *ptep);</span>
<span class="p_add">+	return *ptep;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void xen_ptep_modify_prot_commit(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+				 pte_t *ptep, pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmu_update u;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_ptep_modify_prot_commit(mm, addr, ptep, pte);</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	u.ptr = virt_to_machine(ptep).maddr | MMU_PT_UPDATE_PRESERVE_AD;</span>
<span class="p_add">+	u.val = pte_val_ma(pte);</span>
<span class="p_add">+	xen_extend_mmu_update(&amp;u);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Assume pteval_t is equivalent to all the other *val_t types. */</span>
<span class="p_add">+static pteval_t pte_mfn_to_pfn(pteval_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (val &amp; _PAGE_PRESENT) {</span>
<span class="p_add">+		unsigned long mfn = (val &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		unsigned long pfn = mfn_to_pfn(mfn);</span>
<span class="p_add">+</span>
<span class="p_add">+		pteval_t flags = val &amp; PTE_FLAGS_MASK;</span>
<span class="p_add">+		if (unlikely(pfn == ~0))</span>
<span class="p_add">+			val = flags &amp; ~_PAGE_PRESENT;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			val = ((pteval_t)pfn &lt;&lt; PAGE_SHIFT) | flags;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return val;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static pteval_t pte_pfn_to_mfn(pteval_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (val &amp; _PAGE_PRESENT) {</span>
<span class="p_add">+		unsigned long pfn = (val &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		pteval_t flags = val &amp; PTE_FLAGS_MASK;</span>
<span class="p_add">+		unsigned long mfn;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+			mfn = __pfn_to_mfn(pfn);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			mfn = pfn;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If there&#39;s no mfn for the pfn, then just create an</span>
<span class="p_add">+		 * empty non-present pte.  Unfortunately this loses</span>
<span class="p_add">+		 * information about the original pfn, so</span>
<span class="p_add">+		 * pte_mfn_to_pfn is asymmetric.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (unlikely(mfn == INVALID_P2M_ENTRY)) {</span>
<span class="p_add">+			mfn = 0;</span>
<span class="p_add">+			flags = 0;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			mfn &amp;= ~(FOREIGN_FRAME_BIT | IDENTITY_FRAME_BIT);</span>
<span class="p_add">+		val = ((pteval_t)mfn &lt;&lt; PAGE_SHIFT) | flags;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return val;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+__visible pteval_t xen_pte_val(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pteval_t pteval = pte.pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	return pte_mfn_to_pfn(pteval);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_pte_val);</span>
<span class="p_add">+</span>
<span class="p_add">+__visible pgdval_t xen_pgd_val(pgd_t pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pte_mfn_to_pfn(pgd.pgd);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_pgd_val);</span>
<span class="p_add">+</span>
<span class="p_add">+__visible pte_t xen_make_pte(pteval_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte = pte_pfn_to_mfn(pte);</span>
<span class="p_add">+</span>
<span class="p_add">+	return native_make_pte(pte);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_make_pte);</span>
<span class="p_add">+</span>
<span class="p_add">+__visible pgd_t xen_make_pgd(pgdval_t pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd = pte_pfn_to_mfn(pgd);</span>
<span class="p_add">+	return native_make_pgd(pgd);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_make_pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+__visible pmdval_t xen_pmd_val(pmd_t pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pte_mfn_to_pfn(pmd.pmd);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_pmd_val);</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_pud_hyper(pud_t *ptr, pud_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmu_update u;</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ptr may be ioremapped for 64-bit pagetable setup */</span>
<span class="p_add">+	u.ptr = arbitrary_virt_to_machine(ptr).maddr;</span>
<span class="p_add">+	u.val = pud_val_ma(val);</span>
<span class="p_add">+	xen_extend_mmu_update(&amp;u);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_pud(pud_t *ptr, pud_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_set_pud(ptr, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If page is not pinned, we can just update the entry</span>
<span class="p_add">+	   directly */</span>
<span class="p_add">+	if (!xen_page_pinned(ptr)) {</span>
<span class="p_add">+		*ptr = val;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_set_pud_hyper(ptr, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_PAE</span>
<span class="p_add">+static void xen_set_pte_atomic(pte_t *ptep, pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_set_pte_atomic(ptep, pte);</span>
<span class="p_add">+	set_64bit((u64 *)ptep, native_pte_val(pte));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_pte_clear(struct mm_struct *mm, unsigned long addr, pte_t *ptep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_pte_clear(mm, addr, ptep);</span>
<span class="p_add">+	if (!xen_batched_set_pte(ptep, native_make_pte(0)))</span>
<span class="p_add">+		native_pte_clear(mm, addr, ptep);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_pmd_clear(pmd_t *pmdp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_pmd_clear(pmdp);</span>
<span class="p_add">+	set_pmd(pmdp, __pmd(0));</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif	/* CONFIG_X86_PAE */</span>
<span class="p_add">+</span>
<span class="p_add">+__visible pmd_t xen_make_pmd(pmdval_t pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd = pte_pfn_to_mfn(pmd);</span>
<span class="p_add">+	return native_make_pmd(pmd);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_make_pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_add">+__visible pudval_t xen_pud_val(pud_t pud)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return pte_mfn_to_pfn(pud.pud);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_pud_val);</span>
<span class="p_add">+</span>
<span class="p_add">+__visible pud_t xen_make_pud(pudval_t pud)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pud = pte_pfn_to_mfn(pud);</span>
<span class="p_add">+</span>
<span class="p_add">+	return native_make_pud(pud);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_make_pud);</span>
<span class="p_add">+</span>
<span class="p_add">+static pgd_t *xen_get_user_pgd(pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd_page = (pgd_t *)(((unsigned long)pgd) &amp; PAGE_MASK);</span>
<span class="p_add">+	unsigned offset = pgd - pgd_page;</span>
<span class="p_add">+	pgd_t *user_ptr = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (offset &lt; pgd_index(USER_LIMIT)) {</span>
<span class="p_add">+		struct page *page = virt_to_page(pgd_page);</span>
<span class="p_add">+		user_ptr = (pgd_t *)page-&gt;private;</span>
<span class="p_add">+		if (user_ptr)</span>
<span class="p_add">+			user_ptr += offset;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return user_ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __xen_set_pgd_hyper(pgd_t *ptr, pgd_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmu_update u;</span>
<span class="p_add">+</span>
<span class="p_add">+	u.ptr = virt_to_machine(ptr).maddr;</span>
<span class="p_add">+	u.val = pgd_val_ma(val);</span>
<span class="p_add">+	xen_extend_mmu_update(&amp;u);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Raw hypercall-based set_pgd, intended for in early boot before</span>
<span class="p_add">+ * there&#39;s a page structure.  This implies:</span>
<span class="p_add">+ *  1. The only existing pagetable is the kernel&#39;s</span>
<span class="p_add">+ *  2. It is always pinned</span>
<span class="p_add">+ *  3. It has no user pagetable attached to it</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void __init xen_set_pgd_hyper(pgd_t *ptr, pgd_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	__xen_set_pgd_hyper(ptr, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_pgd(pgd_t *ptr, pgd_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *user_ptr = xen_get_user_pgd(ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_set_pgd(ptr, user_ptr, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If page is not pinned, we can just update the entry</span>
<span class="p_add">+	   directly */</span>
<span class="p_add">+	if (!xen_page_pinned(ptr)) {</span>
<span class="p_add">+		*ptr = val;</span>
<span class="p_add">+		if (user_ptr) {</span>
<span class="p_add">+			WARN_ON(xen_page_pinned(user_ptr));</span>
<span class="p_add">+			*user_ptr = val;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If it&#39;s pinned, then we can at least batch the kernel and</span>
<span class="p_add">+	   user updates together. */</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	__xen_set_pgd_hyper(ptr, val);</span>
<span class="p_add">+	if (user_ptr)</span>
<span class="p_add">+		__xen_set_pgd_hyper(user_ptr, val);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif	/* CONFIG_PGTABLE_LEVELS == 4 */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * (Yet another) pagetable walker.  This one is intended for pinning a</span>
<span class="p_add">+ * pagetable.  This means that it walks a pagetable and calls the</span>
<span class="p_add">+ * callback function on each page it finds making up the page table,</span>
<span class="p_add">+ * at every level.  It walks the entire pagetable, but it only bothers</span>
<span class="p_add">+ * pinning pte pages which are below limit.  In the normal case this</span>
<span class="p_add">+ * will be STACK_TOP_MAX, but at boot we need to pin up to</span>
<span class="p_add">+ * FIXADDR_TOP.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * For 32-bit the important bit is that we don&#39;t pin beyond there,</span>
<span class="p_add">+ * because then we start getting into Xen&#39;s ptes.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * For 64-bit, we must skip the Xen hole in the middle of the address</span>
<span class="p_add">+ * space, just after the big x86-64 virtual hole.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int __xen_pgd_walk(struct mm_struct *mm, pgd_t *pgd,</span>
<span class="p_add">+			  int (*func)(struct mm_struct *mm, struct page *,</span>
<span class="p_add">+				      enum pt_level),</span>
<span class="p_add">+			  unsigned long limit)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int flush = 0;</span>
<span class="p_add">+	unsigned hole_low, hole_high;</span>
<span class="p_add">+	unsigned pgdidx_limit, pudidx_limit, pmdidx_limit;</span>
<span class="p_add">+	unsigned pgdidx, pudidx, pmdidx;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The limit is the last byte to be touched */</span>
<span class="p_add">+	limit--;</span>
<span class="p_add">+	BUG_ON(limit &gt;= FIXADDR_TOP);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 64-bit has a great big hole in the middle of the address</span>
<span class="p_add">+	 * space, which contains the Xen mappings.  On 32-bit these</span>
<span class="p_add">+	 * will end up making a zero-sized hole and so is a no-op.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	hole_low = pgd_index(USER_LIMIT);</span>
<span class="p_add">+	hole_high = pgd_index(PAGE_OFFSET);</span>
<span class="p_add">+</span>
<span class="p_add">+	pgdidx_limit = pgd_index(limit);</span>
<span class="p_add">+#if PTRS_PER_PUD &gt; 1</span>
<span class="p_add">+	pudidx_limit = pud_index(limit);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	pudidx_limit = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#if PTRS_PER_PMD &gt; 1</span>
<span class="p_add">+	pmdidx_limit = pmd_index(limit);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	pmdidx_limit = 0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	for (pgdidx = 0; pgdidx &lt;= pgdidx_limit; pgdidx++) {</span>
<span class="p_add">+		pud_t *pud;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pgdidx &gt;= hole_low &amp;&amp; pgdidx &lt; hole_high)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!pgd_val(pgd[pgdidx]))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		pud = pud_offset(&amp;pgd[pgdidx], 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (PTRS_PER_PUD &gt; 1) /* not folded */</span>
<span class="p_add">+			flush |= (*func)(mm, virt_to_page(pud), PT_PUD);</span>
<span class="p_add">+</span>
<span class="p_add">+		for (pudidx = 0; pudidx &lt; PTRS_PER_PUD; pudidx++) {</span>
<span class="p_add">+			pmd_t *pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (pgdidx == pgdidx_limit &amp;&amp;</span>
<span class="p_add">+			    pudidx &gt; pudidx_limit)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (pud_none(pud[pudidx]))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			pmd = pmd_offset(&amp;pud[pudidx], 0);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (PTRS_PER_PMD &gt; 1) /* not folded */</span>
<span class="p_add">+				flush |= (*func)(mm, virt_to_page(pmd), PT_PMD);</span>
<span class="p_add">+</span>
<span class="p_add">+			for (pmdidx = 0; pmdidx &lt; PTRS_PER_PMD; pmdidx++) {</span>
<span class="p_add">+				struct page *pte;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (pgdidx == pgdidx_limit &amp;&amp;</span>
<span class="p_add">+				    pudidx == pudidx_limit &amp;&amp;</span>
<span class="p_add">+				    pmdidx &gt; pmdidx_limit)</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (pmd_none(pmd[pmdidx]))</span>
<span class="p_add">+					continue;</span>
<span class="p_add">+</span>
<span class="p_add">+				pte = pmd_page(pmd[pmdidx]);</span>
<span class="p_add">+				flush |= (*func)(mm, pte, PT_PTE);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	/* Do the top level last, so that the callbacks can use it as</span>
<span class="p_add">+	   a cue to do final things like tlb flushes. */</span>
<span class="p_add">+	flush |= (*func)(mm, virt_to_page(pgd), PT_PGD);</span>
<span class="p_add">+</span>
<span class="p_add">+	return flush;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int xen_pgd_walk(struct mm_struct *mm,</span>
<span class="p_add">+			int (*func)(struct mm_struct *mm, struct page *,</span>
<span class="p_add">+				    enum pt_level),</span>
<span class="p_add">+			unsigned long limit)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __xen_pgd_walk(mm, mm-&gt;pgd, func, limit);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* If we&#39;re using split pte locks, then take the page&#39;s lock and</span>
<span class="p_add">+   return a pointer to it.  Otherwise return NULL. */</span>
<span class="p_add">+static spinlock_t *xen_pte_lock(struct page *page, struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spinlock_t *ptl = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+#if USE_SPLIT_PTE_PTLOCKS</span>
<span class="p_add">+	ptl = ptlock_ptr(page);</span>
<span class="p_add">+	spin_lock_nest_lock(ptl, &amp;mm-&gt;page_table_lock);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	return ptl;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_pte_unlock(void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spinlock_t *ptl = v;</span>
<span class="p_add">+	spin_unlock(ptl);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_do_pin(unsigned level, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmuext_op op;</span>
<span class="p_add">+</span>
<span class="p_add">+	op.cmd = level;</span>
<span class="p_add">+	op.arg1.mfn = pfn_to_mfn(pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_extend_mmuext_op(&amp;op);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int xen_pin_page(struct mm_struct *mm, struct page *page,</span>
<span class="p_add">+			enum pt_level level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned pgfl = TestSetPagePinned(page);</span>
<span class="p_add">+	int flush;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pgfl)</span>
<span class="p_add">+		flush = 0;		/* already pinned */</span>
<span class="p_add">+	else if (PageHighMem(page))</span>
<span class="p_add">+		/* kmaps need flushing if we found an unpinned</span>
<span class="p_add">+		   highpage */</span>
<span class="p_add">+		flush = 1;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		void *pt = lowmem_page_address(page);</span>
<span class="p_add">+		unsigned long pfn = page_to_pfn(page);</span>
<span class="p_add">+		struct multicall_space mcs = __xen_mc_entry(0);</span>
<span class="p_add">+		spinlock_t *ptl;</span>
<span class="p_add">+</span>
<span class="p_add">+		flush = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need to hold the pagetable lock between the time</span>
<span class="p_add">+		 * we make the pagetable RO and when we actually pin</span>
<span class="p_add">+		 * it.  If we don&#39;t, then other users may come in and</span>
<span class="p_add">+		 * attempt to update the pagetable by writing it,</span>
<span class="p_add">+		 * which will fail because the memory is RO but not</span>
<span class="p_add">+		 * pinned, so Xen won&#39;t do the trap&#39;n&#39;emulate.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * If we&#39;re using split pte locks, we can&#39;t hold the</span>
<span class="p_add">+		 * entire pagetable&#39;s worth of locks during the</span>
<span class="p_add">+		 * traverse, because we may wrap the preempt count (8</span>
<span class="p_add">+		 * bits).  The solution is to mark RO and pin each PTE</span>
<span class="p_add">+		 * page while holding the lock.  This means the number</span>
<span class="p_add">+		 * of locks we end up holding is never more than a</span>
<span class="p_add">+		 * batch size (~32 entries, at present).</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * If we&#39;re not using split pte locks, we needn&#39;t pin</span>
<span class="p_add">+		 * the PTE pages independently, because we&#39;re</span>
<span class="p_add">+		 * protected by the overall pagetable lock.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ptl = NULL;</span>
<span class="p_add">+		if (level == PT_PTE)</span>
<span class="p_add">+			ptl = xen_pte_lock(page, mm);</span>
<span class="p_add">+</span>
<span class="p_add">+		MULTI_update_va_mapping(mcs.mc, (unsigned long)pt,</span>
<span class="p_add">+					pfn_pte(pfn, PAGE_KERNEL_RO),</span>
<span class="p_add">+					level == PT_PGD ? UVMF_TLB_FLUSH : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ptl) {</span>
<span class="p_add">+			xen_do_pin(MMUEXT_PIN_L1_TABLE, pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Queue a deferred unlock for when this batch</span>
<span class="p_add">+			   is completed. */</span>
<span class="p_add">+			xen_mc_callback(xen_pte_unlock, ptl);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return flush;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* This is called just after a mm has been created, but it has not</span>
<span class="p_add">+   been used yet.  We need to make sure that its pagetable is all</span>
<span class="p_add">+   read-only, and can be pinned. */</span>
<span class="p_add">+static void __xen_pgd_pin(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_pgd_pin(mm, pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__xen_pgd_walk(mm, pgd, xen_pin_page, USER_LIMIT)) {</span>
<span class="p_add">+		/* re-enable interrupts for flushing */</span>
<span class="p_add">+		xen_mc_issue(0);</span>
<span class="p_add">+</span>
<span class="p_add">+		kmap_flush_unused();</span>
<span class="p_add">+</span>
<span class="p_add">+		xen_mc_batch();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	{</span>
<span class="p_add">+		pgd_t *user_pgd = xen_get_user_pgd(pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+		xen_do_pin(MMUEXT_PIN_L4_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_add">+</span>
<span class="p_add">+		if (user_pgd) {</span>
<span class="p_add">+			xen_pin_page(mm, virt_to_page(user_pgd), PT_PGD);</span>
<span class="p_add">+			xen_do_pin(MMUEXT_PIN_L4_TABLE,</span>
<span class="p_add">+				   PFN_DOWN(__pa(user_pgd)));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#else /* CONFIG_X86_32 */</span>
<span class="p_add">+#ifdef CONFIG_X86_PAE</span>
<span class="p_add">+	/* Need to make sure unshared kernel PMD is pinnable */</span>
<span class="p_add">+	xen_pin_page(mm, pgd_page(pgd[pgd_index(TASK_SIZE)]),</span>
<span class="p_add">+		     PT_PMD);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	xen_do_pin(MMUEXT_PIN_L3_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_add">+#endif /* CONFIG_X86_64 */</span>
<span class="p_add">+	xen_mc_issue(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_pgd_pin(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__xen_pgd_pin(mm, mm-&gt;pgd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * On save, we need to pin all pagetables to make sure they get their</span>
<span class="p_add">+ * mfns turned into pfns.  Search the list for any unpinned pgds and pin</span>
<span class="p_add">+ * them (unpinned pgds are not currently in use, probably because the</span>
<span class="p_add">+ * process is under construction or destruction).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Expected to be called in stop_machine() (&quot;equivalent to taking</span>
<span class="p_add">+ * every spinlock in the system&quot;), so the locking doesn&#39;t really</span>
<span class="p_add">+ * matter all that much.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void xen_mm_pin_all(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *page;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;pgd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(page, &amp;pgd_list, lru) {</span>
<span class="p_add">+		if (!PagePinned(page)) {</span>
<span class="p_add">+			__xen_pgd_pin(&amp;init_mm, (pgd_t *)page_address(page));</span>
<span class="p_add">+			SetPageSavePinned(page);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;pgd_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The init_mm pagetable is really pinned as soon as its created, but</span>
<span class="p_add">+ * that&#39;s before we have page structures to store the bits.  So do all</span>
<span class="p_add">+ * the book-keeping now.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int __init xen_mark_pinned(struct mm_struct *mm, struct page *page,</span>
<span class="p_add">+				  enum pt_level level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	SetPagePinned(page);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_mark_init_mm_pinned(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xen_pgd_walk(&amp;init_mm, xen_mark_pinned, FIXADDR_TOP);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int xen_unpin_page(struct mm_struct *mm, struct page *page,</span>
<span class="p_add">+			  enum pt_level level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned pgfl = TestClearPagePinned(page);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pgfl &amp;&amp; !PageHighMem(page)) {</span>
<span class="p_add">+		void *pt = lowmem_page_address(page);</span>
<span class="p_add">+		unsigned long pfn = page_to_pfn(page);</span>
<span class="p_add">+		spinlock_t *ptl = NULL;</span>
<span class="p_add">+		struct multicall_space mcs;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do the converse to pin_page.  If we&#39;re using split</span>
<span class="p_add">+		 * pte locks, we must be holding the lock for while</span>
<span class="p_add">+		 * the pte page is unpinned but still RO to prevent</span>
<span class="p_add">+		 * concurrent updates from seeing it in this</span>
<span class="p_add">+		 * partially-pinned state.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (level == PT_PTE) {</span>
<span class="p_add">+			ptl = xen_pte_lock(page, mm);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ptl)</span>
<span class="p_add">+				xen_do_pin(MMUEXT_UNPIN_TABLE, pfn);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mcs = __xen_mc_entry(0);</span>
<span class="p_add">+</span>
<span class="p_add">+		MULTI_update_va_mapping(mcs.mc, (unsigned long)pt,</span>
<span class="p_add">+					pfn_pte(pfn, PAGE_KERNEL),</span>
<span class="p_add">+					level == PT_PGD ? UVMF_TLB_FLUSH : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ptl) {</span>
<span class="p_add">+			/* unlock when batch completed */</span>
<span class="p_add">+			xen_mc_callback(xen_pte_unlock, ptl);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;		/* never need to flush on unpin */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Release a pagetables pages back as normal RW */</span>
<span class="p_add">+static void __xen_pgd_unpin(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	trace_xen_mmu_pgd_unpin(mm, pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_do_pin(MMUEXT_UNPIN_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	{</span>
<span class="p_add">+		pgd_t *user_pgd = xen_get_user_pgd(pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (user_pgd) {</span>
<span class="p_add">+			xen_do_pin(MMUEXT_UNPIN_TABLE,</span>
<span class="p_add">+				   PFN_DOWN(__pa(user_pgd)));</span>
<span class="p_add">+			xen_unpin_page(mm, virt_to_page(user_pgd), PT_PGD);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_PAE</span>
<span class="p_add">+	/* Need to make sure unshared kernel PMD is unpinned */</span>
<span class="p_add">+	xen_unpin_page(mm, pgd_page(pgd[pgd_index(TASK_SIZE)]),</span>
<span class="p_add">+		       PT_PMD);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	__xen_pgd_walk(mm, pgd, xen_unpin_page, USER_LIMIT);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_pgd_unpin(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__xen_pgd_unpin(mm, mm-&gt;pgd);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * On resume, undo any pinning done at save, so that the rest of the</span>
<span class="p_add">+ * kernel doesn&#39;t see any unexpected pinned pagetables.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void xen_mm_unpin_all(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *page;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;pgd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(page, &amp;pgd_list, lru) {</span>
<span class="p_add">+		if (PageSavePinned(page)) {</span>
<span class="p_add">+			BUG_ON(!PagePinned(page));</span>
<span class="p_add">+			__xen_pgd_unpin(&amp;init_mm, (pgd_t *)page_address(page));</span>
<span class="p_add">+			ClearPageSavePinned(page);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;pgd_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_activate_mm(struct mm_struct *prev, struct mm_struct *next)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spin_lock(&amp;next-&gt;page_table_lock);</span>
<span class="p_add">+	xen_pgd_pin(next);</span>
<span class="p_add">+	spin_unlock(&amp;next-&gt;page_table_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_dup_mmap(struct mm_struct *oldmm, struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_add">+	xen_pgd_pin(mm);</span>
<span class="p_add">+	spin_unlock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+/* Another cpu may still have their %cr3 pointing at the pagetable, so</span>
<span class="p_add">+   we need to repoint it somewhere else before we can unpin it. */</span>
<span class="p_add">+static void drop_other_mm_ref(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = info;</span>
<span class="p_add">+	struct mm_struct *active_mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	active_mm = this_cpu_read(cpu_tlbstate.active_mm);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (active_mm == mm &amp;&amp; this_cpu_read(cpu_tlbstate.state) != TLBSTATE_OK)</span>
<span class="p_add">+		leave_mm(smp_processor_id());</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If this cpu still has a stale cr3 reference, then make sure</span>
<span class="p_add">+	   it has been flushed. */</span>
<span class="p_add">+	if (this_cpu_read(xen_current_cr3) == __pa(mm-&gt;pgd))</span>
<span class="p_add">+		load_cr3(swapper_pg_dir);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_drop_mm_ref(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	cpumask_var_t mask;</span>
<span class="p_add">+	unsigned cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;active_mm == mm) {</span>
<span class="p_add">+		if (current-&gt;mm == mm)</span>
<span class="p_add">+			load_cr3(swapper_pg_dir);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			leave_mm(smp_processor_id());</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the &quot;official&quot; set of cpus referring to our pagetable. */</span>
<span class="p_add">+	if (!alloc_cpumask_var(&amp;mask, GFP_ATOMIC)) {</span>
<span class="p_add">+		for_each_online_cpu(cpu) {</span>
<span class="p_add">+			if (!cpumask_test_cpu(cpu, mm_cpumask(mm))</span>
<span class="p_add">+			    &amp;&amp; per_cpu(xen_current_cr3, cpu) != __pa(mm-&gt;pgd))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			smp_call_function_single(cpu, drop_other_mm_ref, mm, 1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cpumask_copy(mask, mm_cpumask(mm));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It&#39;s possible that a vcpu may have a stale reference to our</span>
<span class="p_add">+	   cr3, because its in lazy mode, and it hasn&#39;t yet flushed</span>
<span class="p_add">+	   its set of pending hypercalls yet.  In this case, we can</span>
<span class="p_add">+	   look at its actual current cr3 value, and force it to flush</span>
<span class="p_add">+	   if needed. */</span>
<span class="p_add">+	for_each_online_cpu(cpu) {</span>
<span class="p_add">+		if (per_cpu(xen_current_cr3, cpu) == __pa(mm-&gt;pgd))</span>
<span class="p_add">+			cpumask_set_cpu(cpu, mask);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpumask_empty(mask))</span>
<span class="p_add">+		smp_call_function_many(mask, drop_other_mm_ref, mm, 1);</span>
<span class="p_add">+	free_cpumask_var(mask);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static void xen_drop_mm_ref(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (current-&gt;active_mm == mm)</span>
<span class="p_add">+		load_cr3(swapper_pg_dir);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * While a process runs, Xen pins its pagetables, which means that the</span>
<span class="p_add">+ * hypervisor forces it to be read-only, and it controls all updates</span>
<span class="p_add">+ * to it.  This means that all pagetable updates have to go via the</span>
<span class="p_add">+ * hypervisor, which is moderately expensive.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Since we&#39;re pulling the pagetable down, we switch to use init_mm,</span>
<span class="p_add">+ * unpin old process pagetable and mark it all read-write, which</span>
<span class="p_add">+ * allows further operations on it to be simple memory accesses.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The only subtle point is that another CPU may be still using the</span>
<span class="p_add">+ * pagetable because of lazy tlb flushing.  This means we need need to</span>
<span class="p_add">+ * switch all CPUs off this pagetable before we can unpin it.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void xen_exit_mmap(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	get_cpu();		/* make sure we don&#39;t move around */</span>
<span class="p_add">+	xen_drop_mm_ref(mm);</span>
<span class="p_add">+	put_cpu();</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* pgd may not be pinned in the error exit path of execve */</span>
<span class="p_add">+	if (xen_page_pinned(mm-&gt;pgd))</span>
<span class="p_add">+		xen_pgd_unpin(mm);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;mm-&gt;page_table_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_post_allocator_init(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init pin_pagetable_pfn(unsigned cmd, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmuext_op op;</span>
<span class="p_add">+</span>
<span class="p_add">+	op.cmd = cmd;</span>
<span class="p_add">+	op.arg1.mfn = pfn_to_mfn(pfn);</span>
<span class="p_add">+	if (HYPERVISOR_mmuext_op(&amp;op, 1, NULL, DOMID_SELF))</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static void __init xen_cleanhighmap(unsigned long vaddr,</span>
<span class="p_add">+				    unsigned long vaddr_end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long kernel_end = roundup((unsigned long)_brk_end, PMD_SIZE) - 1;</span>
<span class="p_add">+	pmd_t *pmd = level2_kernel_pgt + pmd_index(vaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: The loop is more greedy than the cleanup_highmap variant.</span>
<span class="p_add">+	 * We include the PMD passed in on _both_ boundaries. */</span>
<span class="p_add">+	for (; vaddr &lt;= vaddr_end &amp;&amp; (pmd &lt; (level2_kernel_pgt + PTRS_PER_PMD));</span>
<span class="p_add">+			pmd++, vaddr += PMD_SIZE) {</span>
<span class="p_add">+		if (pmd_none(*pmd))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (vaddr &lt; (unsigned long) _text || vaddr &gt; kernel_end)</span>
<span class="p_add">+			set_pmd(pmd, __pmd(0));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* In case we did something silly, we should crash in this function</span>
<span class="p_add">+	 * instead of somewhere later and be confusing. */</span>
<span class="p_add">+	xen_mc_flush();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Make a page range writeable and free it.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void __init xen_free_ro_pages(unsigned long paddr, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *vaddr = __va(paddr);</span>
<span class="p_add">+	void *vaddr_end = vaddr + size;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (; vaddr &lt; vaddr_end; vaddr += PAGE_SIZE)</span>
<span class="p_add">+		make_lowmem_page_readwrite(vaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	memblock_free(paddr, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_cleanmfnmap_free_pgtbl(void *pgtbl, bool unpin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pa = __pa(pgtbl) &amp; PHYSICAL_PAGE_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unpin)</span>
<span class="p_add">+		pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, PFN_DOWN(pa));</span>
<span class="p_add">+	ClearPagePinned(virt_to_page(__va(pa)));</span>
<span class="p_add">+	xen_free_ro_pages(pa, PAGE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Since it is well isolated we can (and since it is perhaps large we should)</span>
<span class="p_add">+ * also free the page tables mapping the initial P-&gt;M table.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void __init xen_cleanmfnmap(unsigned long vaddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long va = vaddr &amp; PMD_MASK;</span>
<span class="p_add">+	unsigned long pa;</span>
<span class="p_add">+	pgd_t *pgd = pgd_offset_k(va);</span>
<span class="p_add">+	pud_t *pud_page = pud_offset(pgd, 0);</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+	pte_t *pte;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+	bool unpin;</span>
<span class="p_add">+</span>
<span class="p_add">+	unpin = (vaddr == 2 * PGDIR_SIZE);</span>
<span class="p_add">+	set_pgd(pgd, __pgd(0));</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		pud = pud_page + pud_index(va);</span>
<span class="p_add">+		if (pud_none(*pud)) {</span>
<span class="p_add">+			va += PUD_SIZE;</span>
<span class="p_add">+		} else if (pud_large(*pud)) {</span>
<span class="p_add">+			pa = pud_val(*pud) &amp; PHYSICAL_PAGE_MASK;</span>
<span class="p_add">+			xen_free_ro_pages(pa, PUD_SIZE);</span>
<span class="p_add">+			va += PUD_SIZE;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pmd = pmd_offset(pud, va);</span>
<span class="p_add">+			if (pmd_large(*pmd)) {</span>
<span class="p_add">+				pa = pmd_val(*pmd) &amp; PHYSICAL_PAGE_MASK;</span>
<span class="p_add">+				xen_free_ro_pages(pa, PMD_SIZE);</span>
<span class="p_add">+			} else if (!pmd_none(*pmd)) {</span>
<span class="p_add">+				pte = pte_offset_kernel(pmd, va);</span>
<span class="p_add">+				set_pmd(pmd, __pmd(0));</span>
<span class="p_add">+				for (i = 0; i &lt; PTRS_PER_PTE; ++i) {</span>
<span class="p_add">+					if (pte_none(pte[i]))</span>
<span class="p_add">+						break;</span>
<span class="p_add">+					pa = pte_pfn(pte[i]) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+					xen_free_ro_pages(pa, PAGE_SIZE);</span>
<span class="p_add">+				}</span>
<span class="p_add">+				xen_cleanmfnmap_free_pgtbl(pte, unpin);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			va += PMD_SIZE;</span>
<span class="p_add">+			if (pmd_index(va))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			set_pud(pud, __pud(0));</span>
<span class="p_add">+			xen_cleanmfnmap_free_pgtbl(pmd, unpin);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	} while (pud_index(va) || pmd_index(va));</span>
<span class="p_add">+	xen_cleanmfnmap_free_pgtbl(pud_page, unpin);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_pagetable_p2m_free(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+	unsigned long addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = PAGE_ALIGN(xen_start_info-&gt;nr_pages * sizeof(unsigned long));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* No memory or already called. */</span>
<span class="p_add">+	if ((unsigned long)xen_p2m_addr == xen_start_info-&gt;mfn_list)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* using __ka address and sticking INVALID_P2M_ENTRY! */</span>
<span class="p_add">+	memset((void *)xen_start_info-&gt;mfn_list, 0xff, size);</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = xen_start_info-&gt;mfn_list;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We could be in __ka space.</span>
<span class="p_add">+	 * We roundup to the PMD, which means that if anybody at this stage is</span>
<span class="p_add">+	 * using the __ka address of xen_start_info or</span>
<span class="p_add">+	 * xen_start_info-&gt;shared_info they are in going to crash. Fortunatly</span>
<span class="p_add">+	 * we have already revectored in xen_setup_kernel_pagetable and in</span>
<span class="p_add">+	 * xen_setup_shared_info.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	size = roundup(size, PMD_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (addr &gt;= __START_KERNEL_map) {</span>
<span class="p_add">+		xen_cleanhighmap(addr, addr + size);</span>
<span class="p_add">+		size = PAGE_ALIGN(xen_start_info-&gt;nr_pages *</span>
<span class="p_add">+				  sizeof(unsigned long));</span>
<span class="p_add">+		memblock_free(__pa(addr), size);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		xen_cleanmfnmap(addr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_pagetable_cleanhighmap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+	unsigned long addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* At this stage, cleanup_highmap has already cleaned __ka space</span>
<span class="p_add">+	 * from _brk_limit way up to the max_pfn_mapped (which is the end of</span>
<span class="p_add">+	 * the ramdisk). We continue on, erasing PMD entries that point to page</span>
<span class="p_add">+	 * tables - do note that they are accessible at this stage via __va.</span>
<span class="p_add">+	 * For good measure we also round up to the PMD - which means that if</span>
<span class="p_add">+	 * anybody is using __ka address to the initial boot-stack - and try</span>
<span class="p_add">+	 * to use it - they are going to crash. The xen_start_info has been</span>
<span class="p_add">+	 * taken care of already in xen_setup_kernel_pagetable. */</span>
<span class="p_add">+	addr = xen_start_info-&gt;pt_base;</span>
<span class="p_add">+	size = roundup(xen_start_info-&gt;nr_pt_frames * PAGE_SIZE, PMD_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_cleanhighmap(addr, addr + size);</span>
<span class="p_add">+	xen_start_info-&gt;pt_base = (unsigned long)__va(__pa(xen_start_info-&gt;pt_base));</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+	/* This is superfluous and is not necessary, but you know what</span>
<span class="p_add">+	 * lets do it. The MODULES_VADDR -&gt; MODULES_END should be clear of</span>
<span class="p_add">+	 * anything at this stage. */</span>
<span class="p_add">+	xen_cleanhighmap(MODULES_VADDR, roundup(MODULES_VADDR, PUD_SIZE) - 1);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_pagetable_p2m_setup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_vmalloc_p2m_tree();</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	xen_pagetable_p2m_free();</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_pagetable_cleanhighmap();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	/* And revector! Bye bye old array */</span>
<span class="p_add">+	xen_start_info-&gt;mfn_list = (unsigned long)xen_p2m_addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_pagetable_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	paging_init();</span>
<span class="p_add">+	xen_post_allocator_init();</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_pagetable_p2m_setup();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Allocate and initialize top and mid mfn levels for p2m structure */</span>
<span class="p_add">+	xen_build_mfn_list_list();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Remap memory freed due to conflicts with E820 map */</span>
<span class="p_add">+	if (!xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+		xen_remap_memory();</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_XEN_PV</span>
<span class="p_add">+	xen_setup_shared_info();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+static void xen_write_cr2(unsigned long cr2)</span>
<span class="p_add">+{</span>
<span class="p_add">+	this_cpu_read(xen_vcpu)-&gt;arch.cr2 = cr2;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long xen_read_cr2(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return this_cpu_read(xen_vcpu)-&gt;arch.cr2;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long xen_read_cr2_direct(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return this_cpu_read(xen_vcpu_info.arch.cr2);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_flush_tlb(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmuext_op *op;</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_flush_tlb(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = xen_mc_entry(sizeof(*op));</span>
<span class="p_add">+</span>
<span class="p_add">+	op = mcs.args;</span>
<span class="p_add">+	op-&gt;cmd = MMUEXT_TLB_FLUSH_LOCAL;</span>
<span class="p_add">+	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_flush_tlb_single(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmuext_op *op;</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_flush_tlb_single(addr);</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = xen_mc_entry(sizeof(*op));</span>
<span class="p_add">+	op = mcs.args;</span>
<span class="p_add">+	op-&gt;cmd = MMUEXT_INVLPG_LOCAL;</span>
<span class="p_add">+	op-&gt;arg1.linear_addr = addr &amp; PAGE_MASK;</span>
<span class="p_add">+	MULTI_mmuext_op(mcs.mc, op, 1, NULL, DOMID_SELF);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_flush_tlb_others(const struct cpumask *cpus,</span>
<span class="p_add">+				 struct mm_struct *mm, unsigned long start,</span>
<span class="p_add">+				 unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		struct mmuext_op op;</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+		DECLARE_BITMAP(mask, num_processors);</span>
<span class="p_add">+#else</span>
<span class="p_add">+		DECLARE_BITMAP(mask, NR_CPUS);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	} *args;</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_flush_tlb_others(cpus, mm, start, end);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpumask_empty(cpus))</span>
<span class="p_add">+		return;		/* nothing to do */</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = xen_mc_entry(sizeof(*args));</span>
<span class="p_add">+	args = mcs.args;</span>
<span class="p_add">+	args-&gt;op.arg2.vcpumask = to_cpumask(args-&gt;mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Remove us, and any offline CPUS. */</span>
<span class="p_add">+	cpumask_and(to_cpumask(args-&gt;mask), cpus, cpu_online_mask);</span>
<span class="p_add">+	cpumask_clear_cpu(smp_processor_id(), to_cpumask(args-&gt;mask));</span>
<span class="p_add">+</span>
<span class="p_add">+	args-&gt;op.cmd = MMUEXT_TLB_FLUSH_MULTI;</span>
<span class="p_add">+	if (end != TLB_FLUSH_ALL &amp;&amp; (end - start) &lt;= PAGE_SIZE) {</span>
<span class="p_add">+		args-&gt;op.cmd = MMUEXT_INVLPG_MULTI;</span>
<span class="p_add">+		args-&gt;op.arg1.linear_addr = start;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	MULTI_mmuext_op(mcs.mc, &amp;args-&gt;op, 1, NULL, DOMID_SELF);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long xen_read_cr3(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return this_cpu_read(xen_cr3);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void set_current_cr3(void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	this_cpu_write(xen_current_cr3, (unsigned long)v);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __xen_write_cr3(bool kernel, unsigned long cr3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmuext_op op;</span>
<span class="p_add">+	unsigned long mfn;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_write_cr3(kernel, cr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cr3)</span>
<span class="p_add">+		mfn = pfn_to_mfn(PFN_DOWN(cr3));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mfn = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(mfn == 0 &amp;&amp; kernel);</span>
<span class="p_add">+</span>
<span class="p_add">+	op.cmd = kernel ? MMUEXT_NEW_BASEPTR : MMUEXT_NEW_USER_BASEPTR;</span>
<span class="p_add">+	op.arg1.mfn = mfn;</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_extend_mmuext_op(&amp;op);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kernel) {</span>
<span class="p_add">+		this_cpu_write(xen_cr3, cr3);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Update xen_current_cr3 once the batch has actually</span>
<span class="p_add">+		   been submitted. */</span>
<span class="p_add">+		xen_mc_callback(set_current_cr3, (void *)cr3);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+static void xen_write_cr3(unsigned long cr3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(preemptible());</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();  /* disables interrupts */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Update while interrupts are disabled, so its atomic with</span>
<span class="p_add">+	   respect to ipis */</span>
<span class="p_add">+	this_cpu_write(xen_cr3, cr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	__xen_write_cr3(true, cr3);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	{</span>
<span class="p_add">+		pgd_t *user_pgd = xen_get_user_pgd(__va(cr3));</span>
<span class="p_add">+		if (user_pgd)</span>
<span class="p_add">+			__xen_write_cr3(false, __pa(user_pgd));</span>
<span class="p_add">+		else</span>
<span class="p_add">+			__xen_write_cr3(false, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_CPU);  /* interrupts restored */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * At the start of the day - when Xen launches a guest, it has already</span>
<span class="p_add">+ * built pagetables for the guest. We diligently look over them</span>
<span class="p_add">+ * in xen_setup_kernel_pagetable and graft as appropriate them in the</span>
<span class="p_add">+ * init_level4_pgt and its friends. Then when we are happy we load</span>
<span class="p_add">+ * the new init_level4_pgt - and continue on.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The generic code starts (start_kernel) and &#39;init_mem_mapping&#39; sets</span>
<span class="p_add">+ * up the rest of the pagetables. When it has completed it loads the cr3.</span>
<span class="p_add">+ * N.B. that baremetal would start at &#39;start_kernel&#39; (and the early</span>
<span class="p_add">+ * #PF handler would create bootstrap pagetables) - so we are running</span>
<span class="p_add">+ * with the same assumptions as what to do when write_cr3 is executed</span>
<span class="p_add">+ * at this point.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Since there are no user-page tables at all, we have two variants</span>
<span class="p_add">+ * of xen_write_cr3 - the early bootup (this one), and the late one</span>
<span class="p_add">+ * (xen_write_cr3). The reason we have to do that is that in 64-bit</span>
<span class="p_add">+ * the Linux kernel and user-space are both in ring 3 while the</span>
<span class="p_add">+ * hypervisor is in ring 0.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void __init xen_write_cr3_init(unsigned long cr3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(preemptible());</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();  /* disables interrupts */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Update while interrupts are disabled, so its atomic with</span>
<span class="p_add">+	   respect to ipis */</span>
<span class="p_add">+	this_cpu_write(xen_cr3, cr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	__xen_write_cr3(true, cr3);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(PARAVIRT_LAZY_CPU);  /* interrupts restored */</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int xen_pgd_alloc(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd = mm-&gt;pgd;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(PagePinned(virt_to_page(pgd)));</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	{</span>
<span class="p_add">+		struct page *page = virt_to_page(pgd);</span>
<span class="p_add">+		pgd_t *user_pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON(page-&gt;private != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		user_pgd = (pgd_t *)__get_free_page(GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+		page-&gt;private = (unsigned long)user_pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (user_pgd != NULL) {</span>
<span class="p_add">+#ifdef CONFIG_X86_VSYSCALL_EMULATION</span>
<span class="p_add">+			user_pgd[pgd_index(VSYSCALL_ADDR)] =</span>
<span class="p_add">+				__pgd(__pa(level3_user_vsyscall) | _PAGE_TABLE);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON(PagePinned(virt_to_page(xen_get_user_pgd(pgd))));</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_pgd_free(struct mm_struct *mm, pgd_t *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	pgd_t *user_pgd = xen_get_user_pgd(pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (user_pgd)</span>
<span class="p_add">+		free_page((unsigned long)user_pgd);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Init-time set_pte while constructing initial pagetables, which</span>
<span class="p_add">+ * doesn&#39;t allow RO page table pages to be remapped RW.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If there is no MFN for this PFN then this page is initially</span>
<span class="p_add">+ * ballooned out so clear the PTE (as in decrease_reservation() in</span>
<span class="p_add">+ * drivers/xen/balloon.c).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Many of these PTE updates are done on unpinned and writable pages</span>
<span class="p_add">+ * and doing a hypercall for these is unnecessary and expensive.  At</span>
<span class="p_add">+ * this point it is not possible to tell if a page is pinned or not,</span>
<span class="p_add">+ * so always write the PTE directly and rely on Xen trapping and</span>
<span class="p_add">+ * emulating any updates as necessary.</span>
<span class="p_add">+ */</span>
<span class="p_add">+__visible pte_t xen_make_pte_init(pteval_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	unsigned long pfn;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Pages belonging to the initial p2m list mapped outside the default</span>
<span class="p_add">+	 * address range must be mapped read-only. This region contains the</span>
<span class="p_add">+	 * page tables for mapping the p2m list, too, and page tables MUST be</span>
<span class="p_add">+	 * mapped read-only.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pfn = (pte &amp; PTE_PFN_MASK) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (xen_start_info-&gt;mfn_list &lt; __START_KERNEL_map &amp;&amp;</span>
<span class="p_add">+	    pfn &gt;= xen_start_info-&gt;first_p2m_pfn &amp;&amp;</span>
<span class="p_add">+	    pfn &lt; xen_start_info-&gt;first_p2m_pfn + xen_start_info-&gt;nr_p2m_frames)</span>
<span class="p_add">+		pte &amp;= ~_PAGE_RW;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	pte = pte_pfn_to_mfn(pte);</span>
<span class="p_add">+	return native_make_pte(pte);</span>
<span class="p_add">+}</span>
<span class="p_add">+PV_CALLEE_SAVE_REGS_THUNK(xen_make_pte_init);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_set_pte_init(pte_t *ptep, pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	/* If there&#39;s an existing pte, then don&#39;t allow _PAGE_RW to be set */</span>
<span class="p_add">+	if (pte_mfn(pte) != INVALID_P2M_ENTRY</span>
<span class="p_add">+	    &amp;&amp; pte_val_ma(*ptep) &amp; _PAGE_PRESENT)</span>
<span class="p_add">+		pte = __pte_ma(((pte_val_ma(*ptep) &amp; _PAGE_RW) | ~_PAGE_RW) &amp;</span>
<span class="p_add">+			       pte_val_ma(pte));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	native_set_pte(ptep, pte);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Early in boot, while setting up the initial pagetable, assume</span>
<span class="p_add">+   everything is pinned. */</span>
<span class="p_add">+static void __init xen_alloc_pte_init(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_FLATMEM</span>
<span class="p_add">+	BUG_ON(mem_map);	/* should only be used early */</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	make_lowmem_page_readonly(__va(PFN_PHYS(pfn)));</span>
<span class="p_add">+	pin_pagetable_pfn(MMUEXT_PIN_L1_TABLE, pfn);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Used for pmd and pud */</span>
<span class="p_add">+static void __init xen_alloc_pmd_init(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_FLATMEM</span>
<span class="p_add">+	BUG_ON(mem_map);	/* should only be used early */</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	make_lowmem_page_readonly(__va(PFN_PHYS(pfn)));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Early release_pte assumes that all pts are pinned, since there&#39;s</span>
<span class="p_add">+   only init_mm and anything attached to that is pinned. */</span>
<span class="p_add">+static void __init xen_release_pte_init(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, pfn);</span>
<span class="p_add">+	make_lowmem_page_readwrite(__va(PFN_PHYS(pfn)));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_release_pmd_init(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	make_lowmem_page_readwrite(__va(PFN_PHYS(pfn)));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __pin_pagetable_pfn(unsigned cmd, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+	struct mmuext_op *op;</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = __xen_mc_entry(sizeof(*op));</span>
<span class="p_add">+	op = mcs.args;</span>
<span class="p_add">+	op-&gt;cmd = cmd;</span>
<span class="p_add">+	op-&gt;arg1.mfn = pfn_to_mfn(pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+	MULTI_mmuext_op(mcs.mc, mcs.args, 1, NULL, DOMID_SELF);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __set_pfn_prot(unsigned long pfn, pgprot_t prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+	unsigned long addr = (unsigned long)__va(pfn &lt;&lt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
<span class="p_add">+	mcs = __xen_mc_entry(0);</span>
<span class="p_add">+	MULTI_update_va_mapping(mcs.mc, (unsigned long)addr,</span>
<span class="p_add">+				pfn_pte(pfn, prot), 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* This needs to make sure the new pte page is pinned iff its being</span>
<span class="p_add">+   attached to a pinned pagetable. */</span>
<span class="p_add">+static inline void xen_alloc_ptpage(struct mm_struct *mm, unsigned long pfn,</span>
<span class="p_add">+				    unsigned level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool pinned = PagePinned(virt_to_page(mm-&gt;pgd));</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_alloc_ptpage(mm, pfn, level, pinned);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pinned) {</span>
<span class="p_add">+		struct page *page = pfn_to_page(pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+		SetPagePinned(page);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!PageHighMem(page)) {</span>
<span class="p_add">+			xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+			__set_pfn_prot(pfn, PAGE_KERNEL_RO);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (level == PT_PTE &amp;&amp; USE_SPLIT_PTE_PTLOCKS)</span>
<span class="p_add">+				__pin_pagetable_pfn(MMUEXT_PIN_L1_TABLE, pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+			xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* make sure there are no stray mappings of</span>
<span class="p_add">+			   this page */</span>
<span class="p_add">+			kmap_flush_unused();</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_alloc_pte(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xen_alloc_ptpage(mm, pfn, PT_PTE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_alloc_pmd(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xen_alloc_ptpage(mm, pfn, PT_PMD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* This should never happen until we&#39;re OK to use struct page */</span>
<span class="p_add">+static inline void xen_release_ptpage(unsigned long pfn, unsigned level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct page *page = pfn_to_page(pfn);</span>
<span class="p_add">+	bool pinned = PagePinned(page);</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xen_mmu_release_ptpage(pfn, level, pinned);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pinned) {</span>
<span class="p_add">+		if (!PageHighMem(page)) {</span>
<span class="p_add">+			xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+			if (level == PT_PTE &amp;&amp; USE_SPLIT_PTE_PTLOCKS)</span>
<span class="p_add">+				__pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+			__set_pfn_prot(pfn, PAGE_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+			xen_mc_issue(PARAVIRT_LAZY_MMU);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ClearPagePinned(page);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_release_pte(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xen_release_ptpage(pfn, PT_PTE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_release_pmd(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xen_release_ptpage(pfn, PT_PMD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_add">+static void xen_alloc_pud(struct mm_struct *mm, unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xen_alloc_ptpage(mm, pfn, PT_PUD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_release_pud(unsigned long pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	xen_release_ptpage(pfn, PT_PUD);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+void __init xen_reserve_top(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	unsigned long top = HYPERVISOR_VIRT_START;</span>
<span class="p_add">+	struct xen_platform_parameters pp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (HYPERVISOR_xen_version(XENVER_platform_parameters, &amp;pp) == 0)</span>
<span class="p_add">+		top = pp.virt_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	reserve_top_address(-top);</span>
<span class="p_add">+#endif	/* CONFIG_X86_32 */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Like __va(), but returns address in the kernel mapping (which is</span>
<span class="p_add">+ * all we have until the physical memory mapping has been set up.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void * __init __ka(phys_addr_t paddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	return (void *)(paddr + __START_KERNEL_map);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return __va(paddr);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Convert a machine address to physical address */</span>
<span class="p_add">+static unsigned long __init m2p(phys_addr_t maddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+	maddr &amp;= PTE_PFN_MASK;</span>
<span class="p_add">+	paddr = mfn_to_pfn(maddr &gt;&gt; PAGE_SHIFT) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return paddr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Convert a machine address to kernel virtual */</span>
<span class="p_add">+static void * __init m2v(phys_addr_t maddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __ka(m2p(maddr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Set the page permissions on an identity-mapped pages */</span>
<span class="p_add">+static void __init set_page_prot_flags(void *addr, pgprot_t prot,</span>
<span class="p_add">+				       unsigned long flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pfn = __pa(addr) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	pte_t pte = pfn_pte(pfn, prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (HYPERVISOR_update_va_mapping((unsigned long)addr, pte, flags))</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+static void __init set_page_prot(void *addr, pgprot_t prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return set_page_prot_flags(addr, prot, UVMF_NONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+static void __init xen_map_identity_early(pmd_t *pmd, unsigned long max_pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned pmdidx, pteidx;</span>
<span class="p_add">+	unsigned ident_pte;</span>
<span class="p_add">+	unsigned long pfn;</span>
<span class="p_add">+</span>
<span class="p_add">+	level1_ident_pgt = extend_brk(sizeof(pte_t) * LEVEL1_IDENT_ENTRIES,</span>
<span class="p_add">+				      PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	ident_pte = 0;</span>
<span class="p_add">+	pfn = 0;</span>
<span class="p_add">+	for (pmdidx = 0; pmdidx &lt; PTRS_PER_PMD &amp;&amp; pfn &lt; max_pfn; pmdidx++) {</span>
<span class="p_add">+		pte_t *pte_page;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Reuse or allocate a page of ptes */</span>
<span class="p_add">+		if (pmd_present(pmd[pmdidx]))</span>
<span class="p_add">+			pte_page = m2v(pmd[pmdidx].pmd);</span>
<span class="p_add">+		else {</span>
<span class="p_add">+			/* Check for free pte pages */</span>
<span class="p_add">+			if (ident_pte == LEVEL1_IDENT_ENTRIES)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+</span>
<span class="p_add">+			pte_page = &amp;level1_ident_pgt[ident_pte];</span>
<span class="p_add">+			ident_pte += PTRS_PER_PTE;</span>
<span class="p_add">+</span>
<span class="p_add">+			pmd[pmdidx] = __pmd(__pa(pte_page) | _PAGE_TABLE);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Install mappings */</span>
<span class="p_add">+		for (pteidx = 0; pteidx &lt; PTRS_PER_PTE; pteidx++, pfn++) {</span>
<span class="p_add">+			pte_t pte;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (pfn &gt; max_pfn_mapped)</span>
<span class="p_add">+				max_pfn_mapped = pfn;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!pte_none(pte_page[pteidx]))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			pte = pfn_pte(pfn, PAGE_KERNEL_EXEC);</span>
<span class="p_add">+			pte_page[pteidx] = pte;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (pteidx = 0; pteidx &lt; ident_pte; pteidx += PTRS_PER_PTE)</span>
<span class="p_add">+		set_page_prot(&amp;level1_ident_pgt[pteidx], PAGE_KERNEL_RO);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_page_prot(pmd, PAGE_KERNEL_RO);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+void __init xen_setup_machphys_mapping(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xen_machphys_mapping mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (HYPERVISOR_memory_op(XENMEM_machphys_mapping, &amp;mapping) == 0) {</span>
<span class="p_add">+		machine_to_phys_mapping = (unsigned long *)mapping.v_start;</span>
<span class="p_add">+		machine_to_phys_nr = mapping.max_mfn + 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		machine_to_phys_nr = MACH2PHYS_NR_ENTRIES;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	WARN_ON((machine_to_phys_mapping + (machine_to_phys_nr - 1))</span>
<span class="p_add">+		&lt; machine_to_phys_mapping);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+static void __init convert_pfn_mfn(void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t *pte = v;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All levels are converted the same way, so just treat them</span>
<span class="p_add">+	   as ptes. */</span>
<span class="p_add">+	for (i = 0; i &lt; PTRS_PER_PTE; i++)</span>
<span class="p_add">+		pte[i] = xen_make_pte(pte[i].pte);</span>
<span class="p_add">+}</span>
<span class="p_add">+static void __init check_pt_base(unsigned long *pt_base, unsigned long *pt_end,</span>
<span class="p_add">+				 unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (*pt_base == PFN_DOWN(__pa(addr))) {</span>
<span class="p_add">+		set_page_prot_flags((void *)addr, PAGE_KERNEL, UVMF_INVLPG);</span>
<span class="p_add">+		clear_page((void *)addr);</span>
<span class="p_add">+		(*pt_base)++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (*pt_end == PFN_DOWN(__pa(addr))) {</span>
<span class="p_add">+		set_page_prot_flags((void *)addr, PAGE_KERNEL, UVMF_INVLPG);</span>
<span class="p_add">+		clear_page((void *)addr);</span>
<span class="p_add">+		(*pt_end)--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Set up the initial kernel pagetable.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * We can construct this by grafting the Xen provided pagetable into</span>
<span class="p_add">+ * head_64.S&#39;s preconstructed pagetables.  We copy the Xen L2&#39;s into</span>
<span class="p_add">+ * level2_ident_pgt, and level2_kernel_pgt.  This means that only the</span>
<span class="p_add">+ * kernel has a physical mapping to start with - but that&#39;s enough to</span>
<span class="p_add">+ * get __va working.  We need to fill in the rest of the physical</span>
<span class="p_add">+ * mapping once some sort of allocator has been set up.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init xen_setup_kernel_pagetable(pgd_t *pgd, unsigned long max_pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pud_t *l3;</span>
<span class="p_add">+	pmd_t *l2;</span>
<span class="p_add">+	unsigned long addr[3];</span>
<span class="p_add">+	unsigned long pt_base, pt_end;</span>
<span class="p_add">+	unsigned i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* max_pfn_mapped is the last pfn mapped in the initial memory</span>
<span class="p_add">+	 * mappings. Considering that on Xen after the kernel mappings we</span>
<span class="p_add">+	 * have the mappings of some pages that don&#39;t exist in pfn space, we</span>
<span class="p_add">+	 * set max_pfn_mapped to the last real pfn mapped. */</span>
<span class="p_add">+	if (xen_start_info-&gt;mfn_list &lt; __START_KERNEL_map)</span>
<span class="p_add">+		max_pfn_mapped = xen_start_info-&gt;first_p2m_pfn;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		max_pfn_mapped = PFN_DOWN(__pa(xen_start_info-&gt;mfn_list));</span>
<span class="p_add">+</span>
<span class="p_add">+	pt_base = PFN_DOWN(__pa(xen_start_info-&gt;pt_base));</span>
<span class="p_add">+	pt_end = pt_base + xen_start_info-&gt;nr_pt_frames;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zap identity mapping */</span>
<span class="p_add">+	init_level4_pgt[0] = __pgd(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!xen_feature(XENFEAT_auto_translated_physmap)) {</span>
<span class="p_add">+		/* Pre-constructed entries are in pfn, so convert to mfn */</span>
<span class="p_add">+		/* L4[272] -&gt; level3_ident_pgt</span>
<span class="p_add">+		 * L4[511] -&gt; level3_kernel_pgt */</span>
<span class="p_add">+		convert_pfn_mfn(init_level4_pgt);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* L3_i[0] -&gt; level2_ident_pgt */</span>
<span class="p_add">+		convert_pfn_mfn(level3_ident_pgt);</span>
<span class="p_add">+		/* L3_k[510] -&gt; level2_kernel_pgt</span>
<span class="p_add">+		 * L3_k[511] -&gt; level2_fixmap_pgt */</span>
<span class="p_add">+		convert_pfn_mfn(level3_kernel_pgt);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* L3_k[511][506] -&gt; level1_fixmap_pgt */</span>
<span class="p_add">+		convert_pfn_mfn(level2_fixmap_pgt);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* We get [511][511] and have Xen&#39;s version of level2_kernel_pgt */</span>
<span class="p_add">+	l3 = m2v(pgd[pgd_index(__START_KERNEL_map)].pgd);</span>
<span class="p_add">+	l2 = m2v(l3[pud_index(__START_KERNEL_map)].pud);</span>
<span class="p_add">+</span>
<span class="p_add">+	addr[0] = (unsigned long)pgd;</span>
<span class="p_add">+	addr[1] = (unsigned long)l3;</span>
<span class="p_add">+	addr[2] = (unsigned long)l2;</span>
<span class="p_add">+	/* Graft it onto L4[272][0]. Note that we creating an aliasing problem:</span>
<span class="p_add">+	 * Both L4[272][0] and L4[511][510] have entries that point to the same</span>
<span class="p_add">+	 * L2 (PMD) tables. Meaning that if you modify it in __va space</span>
<span class="p_add">+	 * it will be also modified in the __ka space! (But if you just</span>
<span class="p_add">+	 * modify the PMD table to point to other PTE&#39;s or none, then you</span>
<span class="p_add">+	 * are OK - which is what cleanup_highmap does) */</span>
<span class="p_add">+	copy_page(level2_ident_pgt, l2);</span>
<span class="p_add">+	/* Graft it onto L4[511][510] */</span>
<span class="p_add">+	copy_page(level2_kernel_pgt, l2);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Copy the initial P-&gt;M table mappings if necessary. */</span>
<span class="p_add">+	i = pgd_index(xen_start_info-&gt;mfn_list);</span>
<span class="p_add">+	if (i &amp;&amp; i &lt; pgd_index(__START_KERNEL_map))</span>
<span class="p_add">+		init_level4_pgt[i] = ((pgd_t *)xen_start_info-&gt;pt_base)[i];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!xen_feature(XENFEAT_auto_translated_physmap)) {</span>
<span class="p_add">+		/* Make pagetable pieces RO */</span>
<span class="p_add">+		set_page_prot(init_level4_pgt, PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_page_prot(level3_ident_pgt, PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_page_prot(level3_kernel_pgt, PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_page_prot(level3_user_vsyscall, PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_page_prot(level2_ident_pgt, PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_page_prot(level2_kernel_pgt, PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_page_prot(level2_fixmap_pgt, PAGE_KERNEL_RO);</span>
<span class="p_add">+		set_page_prot(level1_fixmap_pgt, PAGE_KERNEL_RO);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Pin down new L4 */</span>
<span class="p_add">+		pin_pagetable_pfn(MMUEXT_PIN_L4_TABLE,</span>
<span class="p_add">+				  PFN_DOWN(__pa_symbol(init_level4_pgt)));</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Unpin Xen-provided one */</span>
<span class="p_add">+		pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * At this stage there can be no user pgd, and no page</span>
<span class="p_add">+		 * structure to attach it to, so make sure we just set kernel</span>
<span class="p_add">+		 * pgd.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		xen_mc_batch();</span>
<span class="p_add">+		__xen_write_cr3(true, __pa(init_level4_pgt));</span>
<span class="p_add">+		xen_mc_issue(PARAVIRT_LAZY_CPU);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		native_write_cr3(__pa(init_level4_pgt));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We can&#39;t that easily rip out L3 and L2, as the Xen pagetables are</span>
<span class="p_add">+	 * set out this way: [L4], [L1], [L2], [L3], [L1], [L1] ...  for</span>
<span class="p_add">+	 * the initial domain. For guests using the toolstack, they are in:</span>
<span class="p_add">+	 * [L4], [L3], [L2], [L1], [L1], order .. So for dom0 we can only</span>
<span class="p_add">+	 * rip out the [L4] (pgd), but for guests we shave off three pages.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(addr); i++)</span>
<span class="p_add">+		check_pt_base(&amp;pt_base, &amp;pt_end, addr[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Our (by three pages) smaller Xen pagetable that we are using */</span>
<span class="p_add">+	xen_pt_base = PFN_PHYS(pt_base);</span>
<span class="p_add">+	xen_pt_size = (pt_end - pt_base) * PAGE_SIZE;</span>
<span class="p_add">+	memblock_reserve(xen_pt_base, xen_pt_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Revector the xen_start_info */</span>
<span class="p_add">+	xen_start_info = (struct start_info *)__va(__pa(xen_start_info));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Read a value from a physical address.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned long __init xen_read_phys_ulong(phys_addr_t addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *vaddr;</span>
<span class="p_add">+	unsigned long val;</span>
<span class="p_add">+</span>
<span class="p_add">+	vaddr = early_memremap_ro(addr, sizeof(val));</span>
<span class="p_add">+	val = *vaddr;</span>
<span class="p_add">+	early_memunmap(vaddr, sizeof(val));</span>
<span class="p_add">+	return val;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Translate a virtual address to a physical one without relying on mapped</span>
<span class="p_add">+ * page tables.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static phys_addr_t __init xen_early_virt_to_phys(unsigned long vaddr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+	pgd_t pgd;</span>
<span class="p_add">+	pud_t pud;</span>
<span class="p_add">+	pmd_t pmd;</span>
<span class="p_add">+	pte_t pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	pa = read_cr3();</span>
<span class="p_add">+	pgd = native_make_pgd(xen_read_phys_ulong(pa + pgd_index(vaddr) *</span>
<span class="p_add">+						       sizeof(pgd)));</span>
<span class="p_add">+	if (!pgd_present(pgd))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pa = pgd_val(pgd) &amp; PTE_PFN_MASK;</span>
<span class="p_add">+	pud = native_make_pud(xen_read_phys_ulong(pa + pud_index(vaddr) *</span>
<span class="p_add">+						       sizeof(pud)));</span>
<span class="p_add">+	if (!pud_present(pud))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	pa = pud_pfn(pud) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	if (pud_large(pud))</span>
<span class="p_add">+		return pa + (vaddr &amp; ~PUD_MASK);</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd = native_make_pmd(xen_read_phys_ulong(pa + pmd_index(vaddr) *</span>
<span class="p_add">+						       sizeof(pmd)));</span>
<span class="p_add">+	if (!pmd_present(pmd))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	pa = pmd_pfn(pmd) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	if (pmd_large(pmd))</span>
<span class="p_add">+		return pa + (vaddr &amp; ~PMD_MASK);</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = native_make_pte(xen_read_phys_ulong(pa + pte_index(vaddr) *</span>
<span class="p_add">+						       sizeof(pte)));</span>
<span class="p_add">+	if (!pte_present(pte))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	pa = pte_pfn(pte) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa | (vaddr &amp; ~PAGE_MASK);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Find a new area for the hypervisor supplied p2m list and relocate the p2m to</span>
<span class="p_add">+ * this area.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init xen_relocate_p2m(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t size, new_area, pt_phys, pmd_phys, pud_phys;</span>
<span class="p_add">+	unsigned long p2m_pfn, p2m_pfn_end, n_frames, pfn, pfn_end;</span>
<span class="p_add">+	int n_pte, n_pt, n_pmd, n_pud, idx_pte, idx_pt, idx_pmd, idx_pud;</span>
<span class="p_add">+	pte_t *pt;</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	unsigned long *new_p2m;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = PAGE_ALIGN(xen_start_info-&gt;nr_pages * sizeof(unsigned long));</span>
<span class="p_add">+	n_pte = roundup(size, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	n_pt = roundup(size, PMD_SIZE) &gt;&gt; PMD_SHIFT;</span>
<span class="p_add">+	n_pmd = roundup(size, PUD_SIZE) &gt;&gt; PUD_SHIFT;</span>
<span class="p_add">+	n_pud = roundup(size, PGDIR_SIZE) &gt;&gt; PGDIR_SHIFT;</span>
<span class="p_add">+	n_frames = n_pte + n_pt + n_pmd + n_pud;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_area = xen_find_free_area(PFN_PHYS(n_frames));</span>
<span class="p_add">+	if (!new_area) {</span>
<span class="p_add">+		xen_raw_console_write(&quot;Can&#39;t find new memory area for p2m needed due to E820 map conflict\n&quot;);</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Setup the page tables for addressing the new p2m list.</span>
<span class="p_add">+	 * We have asked the hypervisor to map the p2m list at the user address</span>
<span class="p_add">+	 * PUD_SIZE. It may have done so, or it may have used a kernel space</span>
<span class="p_add">+	 * address depending on the Xen version.</span>
<span class="p_add">+	 * To avoid any possible virtual address collision, just use</span>
<span class="p_add">+	 * 2 * PUD_SIZE for the new area.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pud_phys = new_area;</span>
<span class="p_add">+	pmd_phys = pud_phys + PFN_PHYS(n_pud);</span>
<span class="p_add">+	pt_phys = pmd_phys + PFN_PHYS(n_pmd);</span>
<span class="p_add">+	p2m_pfn = PFN_DOWN(pt_phys) + n_pt;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = __va(read_cr3());</span>
<span class="p_add">+	new_p2m = (unsigned long *)(2 * PGDIR_SIZE);</span>
<span class="p_add">+	for (idx_pud = 0; idx_pud &lt; n_pud; idx_pud++) {</span>
<span class="p_add">+		pud = early_memremap(pud_phys, PAGE_SIZE);</span>
<span class="p_add">+		clear_page(pud);</span>
<span class="p_add">+		for (idx_pmd = 0; idx_pmd &lt; min(n_pmd, PTRS_PER_PUD);</span>
<span class="p_add">+		     idx_pmd++) {</span>
<span class="p_add">+			pmd = early_memremap(pmd_phys, PAGE_SIZE);</span>
<span class="p_add">+			clear_page(pmd);</span>
<span class="p_add">+			for (idx_pt = 0; idx_pt &lt; min(n_pt, PTRS_PER_PMD);</span>
<span class="p_add">+			     idx_pt++) {</span>
<span class="p_add">+				pt = early_memremap(pt_phys, PAGE_SIZE);</span>
<span class="p_add">+				clear_page(pt);</span>
<span class="p_add">+				for (idx_pte = 0;</span>
<span class="p_add">+				     idx_pte &lt; min(n_pte, PTRS_PER_PTE);</span>
<span class="p_add">+				     idx_pte++) {</span>
<span class="p_add">+					set_pte(pt + idx_pte,</span>
<span class="p_add">+						pfn_pte(p2m_pfn, PAGE_KERNEL));</span>
<span class="p_add">+					p2m_pfn++;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				n_pte -= PTRS_PER_PTE;</span>
<span class="p_add">+				early_memunmap(pt, PAGE_SIZE);</span>
<span class="p_add">+				make_lowmem_page_readonly(__va(pt_phys));</span>
<span class="p_add">+				pin_pagetable_pfn(MMUEXT_PIN_L1_TABLE,</span>
<span class="p_add">+						  PFN_DOWN(pt_phys));</span>
<span class="p_add">+				set_pmd(pmd + idx_pt,</span>
<span class="p_add">+					__pmd(_PAGE_TABLE | pt_phys));</span>
<span class="p_add">+				pt_phys += PAGE_SIZE;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			n_pt -= PTRS_PER_PMD;</span>
<span class="p_add">+			early_memunmap(pmd, PAGE_SIZE);</span>
<span class="p_add">+			make_lowmem_page_readonly(__va(pmd_phys));</span>
<span class="p_add">+			pin_pagetable_pfn(MMUEXT_PIN_L2_TABLE,</span>
<span class="p_add">+					  PFN_DOWN(pmd_phys));</span>
<span class="p_add">+			set_pud(pud + idx_pmd, __pud(_PAGE_TABLE | pmd_phys));</span>
<span class="p_add">+			pmd_phys += PAGE_SIZE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		n_pmd -= PTRS_PER_PUD;</span>
<span class="p_add">+		early_memunmap(pud, PAGE_SIZE);</span>
<span class="p_add">+		make_lowmem_page_readonly(__va(pud_phys));</span>
<span class="p_add">+		pin_pagetable_pfn(MMUEXT_PIN_L3_TABLE, PFN_DOWN(pud_phys));</span>
<span class="p_add">+		set_pgd(pgd + 2 + idx_pud, __pgd(_PAGE_TABLE | pud_phys));</span>
<span class="p_add">+		pud_phys += PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Now copy the old p2m info to the new area. */</span>
<span class="p_add">+	memcpy(new_p2m, xen_p2m_addr, size);</span>
<span class="p_add">+	xen_p2m_addr = new_p2m;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Release the old p2m list and set new list info. */</span>
<span class="p_add">+	p2m_pfn = PFN_DOWN(xen_early_virt_to_phys(xen_start_info-&gt;mfn_list));</span>
<span class="p_add">+	BUG_ON(!p2m_pfn);</span>
<span class="p_add">+	p2m_pfn_end = p2m_pfn + PFN_DOWN(size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xen_start_info-&gt;mfn_list &lt; __START_KERNEL_map) {</span>
<span class="p_add">+		pfn = xen_start_info-&gt;first_p2m_pfn;</span>
<span class="p_add">+		pfn_end = xen_start_info-&gt;first_p2m_pfn +</span>
<span class="p_add">+			  xen_start_info-&gt;nr_p2m_frames;</span>
<span class="p_add">+		set_pgd(pgd + 1, __pgd(0));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pfn = p2m_pfn;</span>
<span class="p_add">+		pfn_end = p2m_pfn_end;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	memblock_free(PFN_PHYS(pfn), PAGE_SIZE * (pfn_end - pfn));</span>
<span class="p_add">+	while (pfn &lt; pfn_end) {</span>
<span class="p_add">+		if (pfn == p2m_pfn) {</span>
<span class="p_add">+			pfn = p2m_pfn_end;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		make_lowmem_page_readwrite(__va(PFN_PHYS(pfn)));</span>
<span class="p_add">+		pfn++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_start_info-&gt;mfn_list = (unsigned long)xen_p2m_addr;</span>
<span class="p_add">+	xen_start_info-&gt;first_p2m_pfn =  PFN_DOWN(new_area);</span>
<span class="p_add">+	xen_start_info-&gt;nr_p2m_frames = n_frames;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#else	/* !CONFIG_X86_64 */</span>
<span class="p_add">+static RESERVE_BRK_ARRAY(pmd_t, initial_kernel_pmd, PTRS_PER_PMD);</span>
<span class="p_add">+static RESERVE_BRK_ARRAY(pmd_t, swapper_kernel_pmd, PTRS_PER_PMD);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_write_cr3_init(unsigned long cr3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pfn = PFN_DOWN(__pa(swapper_pg_dir));</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(read_cr3() != __pa(initial_page_table));</span>
<span class="p_add">+	BUG_ON(cr3 != __pa(swapper_pg_dir));</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We are switching to swapper_pg_dir for the first time (from</span>
<span class="p_add">+	 * initial_page_table) and therefore need to mark that page</span>
<span class="p_add">+	 * read-only and then pin it.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Xen disallows sharing of kernel PMDs for PAE</span>
<span class="p_add">+	 * guests. Therefore we must copy the kernel PMD from</span>
<span class="p_add">+	 * initial_page_table into a new kernel PMD to be used in</span>
<span class="p_add">+	 * swapper_pg_dir.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	swapper_kernel_pmd =</span>
<span class="p_add">+		extend_brk(sizeof(pmd_t) * PTRS_PER_PMD, PAGE_SIZE);</span>
<span class="p_add">+	copy_page(swapper_kernel_pmd, initial_kernel_pmd);</span>
<span class="p_add">+	swapper_pg_dir[KERNEL_PGD_BOUNDARY] =</span>
<span class="p_add">+		__pgd(__pa(swapper_kernel_pmd) | _PAGE_PRESENT);</span>
<span class="p_add">+	set_page_prot(swapper_kernel_pmd, PAGE_KERNEL_RO);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_page_prot(swapper_pg_dir, PAGE_KERNEL_RO);</span>
<span class="p_add">+	xen_write_cr3(cr3);</span>
<span class="p_add">+	pin_pagetable_pfn(MMUEXT_PIN_L3_TABLE, pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+	pin_pagetable_pfn(MMUEXT_UNPIN_TABLE,</span>
<span class="p_add">+			  PFN_DOWN(__pa(initial_page_table)));</span>
<span class="p_add">+	set_page_prot(initial_page_table, PAGE_KERNEL);</span>
<span class="p_add">+	set_page_prot(initial_kernel_pmd, PAGE_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	pv_mmu_ops.write_cr3 = &amp;xen_write_cr3;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * For 32 bit domains xen_start_info-&gt;pt_base is the pgd address which might be</span>
<span class="p_add">+ * not the first page table in the page table pool.</span>
<span class="p_add">+ * Iterate through the initial page tables to find the real page table base.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static phys_addr_t xen_find_pt_base(pmd_t *pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t pt_base, paddr;</span>
<span class="p_add">+	unsigned pmdidx;</span>
<span class="p_add">+</span>
<span class="p_add">+	pt_base = min(__pa(xen_start_info-&gt;pt_base), __pa(pmd));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (pmdidx = 0; pmdidx &lt; PTRS_PER_PMD; pmdidx++)</span>
<span class="p_add">+		if (pmd_present(pmd[pmdidx]) &amp;&amp; !pmd_large(pmd[pmdidx])) {</span>
<span class="p_add">+			paddr = m2p(pmd[pmdidx].pmd);</span>
<span class="p_add">+			pt_base = min(pt_base, paddr);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	return pt_base;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init xen_setup_kernel_pagetable(pgd_t *pgd, unsigned long max_pfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *kernel_pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	kernel_pmd = m2v(pgd[KERNEL_PGD_BOUNDARY].pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_pt_base = xen_find_pt_base(kernel_pmd);</span>
<span class="p_add">+	xen_pt_size = xen_start_info-&gt;nr_pt_frames * PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	initial_kernel_pmd =</span>
<span class="p_add">+		extend_brk(sizeof(pmd_t) * PTRS_PER_PMD, PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	max_pfn_mapped = PFN_DOWN(xen_pt_base + xen_pt_size + 512 * 1024);</span>
<span class="p_add">+</span>
<span class="p_add">+	copy_page(initial_kernel_pmd, kernel_pmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_map_identity_early(initial_kernel_pmd, max_pfn);</span>
<span class="p_add">+</span>
<span class="p_add">+	copy_page(initial_page_table, pgd);</span>
<span class="p_add">+	initial_page_table[KERNEL_PGD_BOUNDARY] =</span>
<span class="p_add">+		__pgd(__pa(initial_kernel_pmd) | _PAGE_PRESENT);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_page_prot(initial_kernel_pmd, PAGE_KERNEL_RO);</span>
<span class="p_add">+	set_page_prot(initial_page_table, PAGE_KERNEL_RO);</span>
<span class="p_add">+	set_page_prot(empty_zero_page, PAGE_KERNEL_RO);</span>
<span class="p_add">+</span>
<span class="p_add">+	pin_pagetable_pfn(MMUEXT_UNPIN_TABLE, PFN_DOWN(__pa(pgd)));</span>
<span class="p_add">+</span>
<span class="p_add">+	pin_pagetable_pfn(MMUEXT_PIN_L3_TABLE,</span>
<span class="p_add">+			  PFN_DOWN(__pa(initial_page_table)));</span>
<span class="p_add">+	xen_write_cr3(__pa(initial_page_table));</span>
<span class="p_add">+</span>
<span class="p_add">+	memblock_reserve(xen_pt_base, xen_pt_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif	/* CONFIG_X86_64 */</span>
<span class="p_add">+</span>
<span class="p_add">+void __init xen_reserve_special_pages(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+	memblock_reserve(__pa(xen_start_info), PAGE_SIZE);</span>
<span class="p_add">+	if (xen_start_info-&gt;store_mfn) {</span>
<span class="p_add">+		paddr = PFN_PHYS(mfn_to_pfn(xen_start_info-&gt;store_mfn));</span>
<span class="p_add">+		memblock_reserve(paddr, PAGE_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!xen_initial_domain()) {</span>
<span class="p_add">+		paddr = PFN_PHYS(mfn_to_pfn(xen_start_info-&gt;console.domU.mfn));</span>
<span class="p_add">+		memblock_reserve(paddr, PAGE_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init xen_pt_check_e820(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (xen_is_e820_reserved(xen_pt_base, xen_pt_size)) {</span>
<span class="p_add">+		xen_raw_console_write(&quot;Xen hypervisor allocated page table memory conflicts with E820 map\n&quot;);</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned char dummy_mapping[PAGE_SIZE] __page_aligned_bss;</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_set_fixmap(unsigned idx, phys_addr_t phys, pgprot_t prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	phys &gt;&gt;= PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (idx) {</span>
<span class="p_add">+	case FIX_BTMAP_END ... FIX_BTMAP_BEGIN:</span>
<span class="p_add">+	case FIX_RO_IDT:</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	case FIX_WP_TEST:</span>
<span class="p_add">+# ifdef CONFIG_HIGHMEM</span>
<span class="p_add">+	case FIX_KMAP_BEGIN ... FIX_KMAP_END:</span>
<span class="p_add">+# endif</span>
<span class="p_add">+#elif defined(CONFIG_X86_VSYSCALL_EMULATION)</span>
<span class="p_add">+	case VSYSCALL_PAGE:</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	case FIX_TEXT_POKE0:</span>
<span class="p_add">+	case FIX_TEXT_POKE1:</span>
<span class="p_add">+		/* All local page mappings */</span>
<span class="p_add">+		pte = pfn_pte(phys, prot);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="p_add">+	case FIX_APIC_BASE:	/* maps dummy local APIC */</span>
<span class="p_add">+		pte = pfn_pte(PFN_DOWN(__pa(dummy_mapping)), PAGE_KERNEL);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_IO_APIC</span>
<span class="p_add">+	case FIX_IO_APIC_BASE_0 ... FIX_IO_APIC_BASE_END:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We just don&#39;t map the IO APIC - all access is via</span>
<span class="p_add">+		 * hypercalls.  Keep the address in the pte for reference.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pte = pfn_pte(PFN_DOWN(__pa(dummy_mapping)), PAGE_KERNEL);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	case FIX_PARAVIRT_BOOTMAP:</span>
<span class="p_add">+		/* This is an MFN, but it isn&#39;t an IO mapping from the</span>
<span class="p_add">+		   IO domain */</span>
<span class="p_add">+		pte = mfn_pte(phys, prot);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		/* By default, set_fixmap is used for hardware mappings */</span>
<span class="p_add">+		pte = mfn_pte(phys, prot);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	__native_set_fixmap(idx, pte);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_VSYSCALL_EMULATION</span>
<span class="p_add">+	/* Replicate changes to map the vsyscall page into the user</span>
<span class="p_add">+	   pagetable vsyscall mapping. */</span>
<span class="p_add">+	if (idx == VSYSCALL_PAGE) {</span>
<span class="p_add">+		unsigned long vaddr = __fix_to_virt(idx);</span>
<span class="p_add">+		set_pte_vaddr_pud(level3_user_vsyscall, vaddr, pte);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init xen_post_allocator_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pv_mmu_ops.set_pte = xen_set_pte;</span>
<span class="p_add">+	pv_mmu_ops.set_pmd = xen_set_pmd;</span>
<span class="p_add">+	pv_mmu_ops.set_pud = xen_set_pud;</span>
<span class="p_add">+#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_add">+	pv_mmu_ops.set_pgd = xen_set_pgd;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* This will work as long as patching hasn&#39;t happened yet</span>
<span class="p_add">+	   (which it hasn&#39;t) */</span>
<span class="p_add">+	pv_mmu_ops.alloc_pte = xen_alloc_pte;</span>
<span class="p_add">+	pv_mmu_ops.alloc_pmd = xen_alloc_pmd;</span>
<span class="p_add">+	pv_mmu_ops.release_pte = xen_release_pte;</span>
<span class="p_add">+	pv_mmu_ops.release_pmd = xen_release_pmd;</span>
<span class="p_add">+#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_add">+	pv_mmu_ops.alloc_pud = xen_alloc_pud;</span>
<span class="p_add">+	pv_mmu_ops.release_pud = xen_release_pud;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	pv_mmu_ops.make_pte = PV_CALLEE_SAVE(xen_make_pte);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	pv_mmu_ops.write_cr3 = &amp;xen_write_cr3;</span>
<span class="p_add">+	SetPagePinned(virt_to_page(level3_user_vsyscall));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	xen_mark_init_mm_pinned();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void xen_leave_lazy_mmu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	xen_mc_flush();</span>
<span class="p_add">+	paravirt_leave_lazy_mmu();</span>
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct pv_mmu_ops xen_mmu_ops __initconst = {</span>
<span class="p_add">+	.read_cr2 = xen_read_cr2,</span>
<span class="p_add">+	.write_cr2 = xen_write_cr2,</span>
<span class="p_add">+</span>
<span class="p_add">+	.read_cr3 = xen_read_cr3,</span>
<span class="p_add">+	.write_cr3 = xen_write_cr3_init,</span>
<span class="p_add">+</span>
<span class="p_add">+	.flush_tlb_user = xen_flush_tlb,</span>
<span class="p_add">+	.flush_tlb_kernel = xen_flush_tlb,</span>
<span class="p_add">+	.flush_tlb_single = xen_flush_tlb_single,</span>
<span class="p_add">+	.flush_tlb_others = xen_flush_tlb_others,</span>
<span class="p_add">+</span>
<span class="p_add">+	.pte_update = paravirt_nop,</span>
<span class="p_add">+</span>
<span class="p_add">+	.pgd_alloc = xen_pgd_alloc,</span>
<span class="p_add">+	.pgd_free = xen_pgd_free,</span>
<span class="p_add">+</span>
<span class="p_add">+	.alloc_pte = xen_alloc_pte_init,</span>
<span class="p_add">+	.release_pte = xen_release_pte_init,</span>
<span class="p_add">+	.alloc_pmd = xen_alloc_pmd_init,</span>
<span class="p_add">+	.release_pmd = xen_release_pmd_init,</span>
<span class="p_add">+</span>
<span class="p_add">+	.set_pte = xen_set_pte_init,</span>
<span class="p_add">+	.set_pte_at = xen_set_pte_at,</span>
<span class="p_add">+	.set_pmd = xen_set_pmd_hyper,</span>
<span class="p_add">+</span>
<span class="p_add">+	.ptep_modify_prot_start = __ptep_modify_prot_start,</span>
<span class="p_add">+	.ptep_modify_prot_commit = __ptep_modify_prot_commit,</span>
<span class="p_add">+</span>
<span class="p_add">+	.pte_val = PV_CALLEE_SAVE(xen_pte_val),</span>
<span class="p_add">+	.pgd_val = PV_CALLEE_SAVE(xen_pgd_val),</span>
<span class="p_add">+</span>
<span class="p_add">+	.make_pte = PV_CALLEE_SAVE(xen_make_pte_init),</span>
<span class="p_add">+	.make_pgd = PV_CALLEE_SAVE(xen_make_pgd),</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_PAE</span>
<span class="p_add">+	.set_pte_atomic = xen_set_pte_atomic,</span>
<span class="p_add">+	.pte_clear = xen_pte_clear,</span>
<span class="p_add">+	.pmd_clear = xen_pmd_clear,</span>
<span class="p_add">+#endif	/* CONFIG_X86_PAE */</span>
<span class="p_add">+	.set_pud = xen_set_pud_hyper,</span>
<span class="p_add">+</span>
<span class="p_add">+	.make_pmd = PV_CALLEE_SAVE(xen_make_pmd),</span>
<span class="p_add">+	.pmd_val = PV_CALLEE_SAVE(xen_pmd_val),</span>
<span class="p_add">+</span>
<span class="p_add">+#if CONFIG_PGTABLE_LEVELS == 4</span>
<span class="p_add">+	.pud_val = PV_CALLEE_SAVE(xen_pud_val),</span>
<span class="p_add">+	.make_pud = PV_CALLEE_SAVE(xen_make_pud),</span>
<span class="p_add">+	.set_pgd = xen_set_pgd_hyper,</span>
<span class="p_add">+</span>
<span class="p_add">+	.alloc_pud = xen_alloc_pmd_init,</span>
<span class="p_add">+	.release_pud = xen_release_pmd_init,</span>
<span class="p_add">+#endif	/* CONFIG_PGTABLE_LEVELS == 4 */</span>
<span class="p_add">+</span>
<span class="p_add">+	.activate_mm = xen_activate_mm,</span>
<span class="p_add">+	.dup_mmap = xen_dup_mmap,</span>
<span class="p_add">+	.exit_mmap = xen_exit_mmap,</span>
<span class="p_add">+</span>
<span class="p_add">+	.lazy_mode = {</span>
<span class="p_add">+		.enter = paravirt_enter_lazy_mmu,</span>
<span class="p_add">+		.leave = xen_leave_lazy_mmu,</span>
<span class="p_add">+		.flush = paravirt_flush_lazy_mmu,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
<span class="p_add">+	.set_fixmap = xen_set_fixmap,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void __init xen_init_mmu_ops(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	x86_init.paging.pagetable_init = xen_pagetable_init;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pv_mmu_ops = xen_mmu_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(dummy_mapping, 0xff, PAGE_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Protected by xen_reservation_lock. */</span>
<span class="p_add">+#define MAX_CONTIG_ORDER 9 /* 2MB */</span>
<span class="p_add">+static unsigned long discontig_frames[1&lt;&lt;MAX_CONTIG_ORDER];</span>
<span class="p_add">+</span>
<span class="p_add">+#define VOID_PTE (mfn_pte(0, __pgprot(0)))</span>
<span class="p_add">+static void xen_zap_pfn_range(unsigned long vaddr, unsigned int order,</span>
<span class="p_add">+				unsigned long *in_frames,</span>
<span class="p_add">+				unsigned long *out_frames)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	struct multicall_space mcs;</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+	for (i = 0; i &lt; (1UL&lt;&lt;order); i++, vaddr += PAGE_SIZE) {</span>
<span class="p_add">+		mcs = __xen_mc_entry(0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (in_frames)</span>
<span class="p_add">+			in_frames[i] = virt_to_mfn(vaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+		MULTI_update_va_mapping(mcs.mc, vaddr, VOID_PTE, 0);</span>
<span class="p_add">+		__set_phys_to_machine(virt_to_pfn(vaddr), INVALID_P2M_ENTRY);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (out_frames)</span>
<span class="p_add">+			out_frames[i] = virt_to_pfn(vaddr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	xen_mc_issue(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Update the pfn-to-mfn mappings for a virtual address range, either to</span>
<span class="p_add">+ * point to an array of mfns, or contiguously from a single starting</span>
<span class="p_add">+ * mfn.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void xen_remap_exchanged_ptes(unsigned long vaddr, int order,</span>
<span class="p_add">+				     unsigned long *mfns,</span>
<span class="p_add">+				     unsigned long first_mfn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned i, limit;</span>
<span class="p_add">+	unsigned long mfn;</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_batch();</span>
<span class="p_add">+</span>
<span class="p_add">+	limit = 1u &lt;&lt; order;</span>
<span class="p_add">+	for (i = 0; i &lt; limit; i++, vaddr += PAGE_SIZE) {</span>
<span class="p_add">+		struct multicall_space mcs;</span>
<span class="p_add">+		unsigned flags;</span>
<span class="p_add">+</span>
<span class="p_add">+		mcs = __xen_mc_entry(0);</span>
<span class="p_add">+		if (mfns)</span>
<span class="p_add">+			mfn = mfns[i];</span>
<span class="p_add">+		else</span>
<span class="p_add">+			mfn = first_mfn + i;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (i &lt; (limit - 1))</span>
<span class="p_add">+			flags = 0;</span>
<span class="p_add">+		else {</span>
<span class="p_add">+			if (order == 0)</span>
<span class="p_add">+				flags = UVMF_INVLPG | UVMF_ALL;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				flags = UVMF_TLB_FLUSH | UVMF_ALL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		MULTI_update_va_mapping(mcs.mc, vaddr,</span>
<span class="p_add">+				mfn_pte(mfn, PAGE_KERNEL), flags);</span>
<span class="p_add">+</span>
<span class="p_add">+		set_phys_to_machine(virt_to_pfn(vaddr), mfn);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	xen_mc_issue(0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Perform the hypercall to exchange a region of our pfns to point to</span>
<span class="p_add">+ * memory with the required contiguous alignment.  Takes the pfns as</span>
<span class="p_add">+ * input, and populates mfns as output.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns a success code indicating whether the hypervisor was able to</span>
<span class="p_add">+ * satisfy the request or not.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int xen_exchange_memory(unsigned long extents_in, unsigned int order_in,</span>
<span class="p_add">+			       unsigned long *pfns_in,</span>
<span class="p_add">+			       unsigned long extents_out,</span>
<span class="p_add">+			       unsigned int order_out,</span>
<span class="p_add">+			       unsigned long *mfns_out,</span>
<span class="p_add">+			       unsigned int address_bits)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long rc;</span>
<span class="p_add">+	int success;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct xen_memory_exchange exchange = {</span>
<span class="p_add">+		.in = {</span>
<span class="p_add">+			.nr_extents   = extents_in,</span>
<span class="p_add">+			.extent_order = order_in,</span>
<span class="p_add">+			.extent_start = pfns_in,</span>
<span class="p_add">+			.domid        = DOMID_SELF</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.out = {</span>
<span class="p_add">+			.nr_extents   = extents_out,</span>
<span class="p_add">+			.extent_order = order_out,</span>
<span class="p_add">+			.extent_start = mfns_out,</span>
<span class="p_add">+			.address_bits = address_bits,</span>
<span class="p_add">+			.domid        = DOMID_SELF</span>
<span class="p_add">+		}</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(extents_in &lt;&lt; order_in != extents_out &lt;&lt; order_out);</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = HYPERVISOR_memory_op(XENMEM_exchange, &amp;exchange);</span>
<span class="p_add">+	success = (exchange.nr_exchanged == extents_in);</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!success &amp;&amp; ((exchange.nr_exchanged != 0) || (rc == 0)));</span>
<span class="p_add">+	BUG_ON(success &amp;&amp; (rc != 0));</span>
<span class="p_add">+</span>
<span class="p_add">+	return success;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int xen_create_contiguous_region(phys_addr_t pstart, unsigned int order,</span>
<span class="p_add">+				 unsigned int address_bits,</span>
<span class="p_add">+				 dma_addr_t *dma_handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *in_frames = discontig_frames, out_frame;</span>
<span class="p_add">+	unsigned long  flags;</span>
<span class="p_add">+	int            success;</span>
<span class="p_add">+	unsigned long vstart = (unsigned long)phys_to_virt(pstart);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Currently an auto-translated guest will not perform I/O, nor will</span>
<span class="p_add">+	 * it require PAE page directories below 4GB. Therefore any calls to</span>
<span class="p_add">+	 * this function are redundant and can be ignored.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(order &gt; MAX_CONTIG_ORDER))</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset((void *) vstart, 0, PAGE_SIZE &lt;&lt; order);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;xen_reservation_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 1. Zap current PTEs, remembering MFNs. */</span>
<span class="p_add">+	xen_zap_pfn_range(vstart, order, in_frames, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 2. Get a new contiguous memory extent. */</span>
<span class="p_add">+	out_frame = virt_to_pfn(vstart);</span>
<span class="p_add">+	success = xen_exchange_memory(1UL &lt;&lt; order, 0, in_frames,</span>
<span class="p_add">+				      1, order, &amp;out_frame,</span>
<span class="p_add">+				      address_bits);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 3. Map the new extent in place of old pages. */</span>
<span class="p_add">+	if (success)</span>
<span class="p_add">+		xen_remap_exchanged_ptes(vstart, order, NULL, out_frame);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		xen_remap_exchanged_ptes(vstart, order, in_frames, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;xen_reservation_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	*dma_handle = virt_to_machine(vstart).maddr;</span>
<span class="p_add">+	return success ? 0 : -ENOMEM;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(xen_create_contiguous_region);</span>
<span class="p_add">+</span>
<span class="p_add">+void xen_destroy_contiguous_region(phys_addr_t pstart, unsigned int order)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *out_frames = discontig_frames, in_frame;</span>
<span class="p_add">+	unsigned long  flags;</span>
<span class="p_add">+	int success;</span>
<span class="p_add">+	unsigned long vstart;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xen_feature(XENFEAT_auto_translated_physmap))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(order &gt; MAX_CONTIG_ORDER))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	vstart = (unsigned long)phys_to_virt(pstart);</span>
<span class="p_add">+	memset((void *) vstart, 0, PAGE_SIZE &lt;&lt; order);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;xen_reservation_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 1. Find start MFN of contiguous extent. */</span>
<span class="p_add">+	in_frame = virt_to_mfn(vstart);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 2. Zap current PTEs. */</span>
<span class="p_add">+	xen_zap_pfn_range(vstart, order, NULL, out_frames);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 3. Do the exchange for non-contiguous MFNs. */</span>
<span class="p_add">+	success = xen_exchange_memory(1, order, &amp;in_frame, 1UL &lt;&lt; order,</span>
<span class="p_add">+					0, out_frames, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* 4. Map new pages in place of old pages. */</span>
<span class="p_add">+	if (success)</span>
<span class="p_add">+		xen_remap_exchanged_ptes(vstart, order, out_frames, 0);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		xen_remap_exchanged_ptes(vstart, order, NULL, in_frame);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;xen_reservation_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(xen_destroy_contiguous_region);</span>
<span class="p_header">diff --git a/drivers/xen/balloon.c b/drivers/xen/balloon.c</span>
<span class="p_header">index db107fa..b11ca75 100644</span>
<span class="p_header">--- a/drivers/xen/balloon.c</span>
<span class="p_header">+++ b/drivers/xen/balloon.c</span>
<span class="p_chunk">@@ -708,6 +708,7 @@</span> <span class="p_context"> void free_xenballooned_pages(int nr_pages, struct page **pages)</span>
 }
 EXPORT_SYMBOL(free_xenballooned_pages);
 
<span class="p_add">+#ifdef CONFIG_XEN_PV</span>
 static void __init balloon_add_region(unsigned long start_pfn,
 				      unsigned long pages)
 {
<span class="p_chunk">@@ -731,19 +732,22 @@</span> <span class="p_context"> static void __init balloon_add_region(unsigned long start_pfn,</span>
 
 	balloon_stats.total_pages += extra_pfn_end - start_pfn;
 }
<span class="p_add">+#endif</span>
 
 static int __init balloon_init(void)
 {
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
 	if (!xen_domain())
 		return -ENODEV;
 
 	pr_info(&quot;Initialising balloon driver\n&quot;);
 
<span class="p_add">+#ifdef CONFIG_XEN_PV</span>
 	balloon_stats.current_pages = xen_pv_domain()
 		? min(xen_start_info-&gt;nr_pages - xen_released_pages, max_pfn)
 		: get_num_physpages();
<span class="p_add">+#else</span>
<span class="p_add">+	balloon_stats.current_pages = get_num_physpages();</span>
<span class="p_add">+#endif</span>
 	balloon_stats.target_pages  = balloon_stats.current_pages;
 	balloon_stats.balloon_low   = 0;
 	balloon_stats.balloon_high  = 0;
<span class="p_chunk">@@ -760,14 +764,20 @@</span> <span class="p_context"> static int __init balloon_init(void)</span>
 	register_sysctl_table(xen_root);
 #endif
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Initialize the balloon with pages from the extra memory</span>
<span class="p_del">-	 * regions (see arch/x86/xen/setup.c).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; XEN_EXTRA_MEM_MAX_REGIONS; i++)</span>
<span class="p_del">-		if (xen_extra_mem[i].n_pfns)</span>
<span class="p_del">-			balloon_add_region(xen_extra_mem[i].start_pfn,</span>
<span class="p_del">-					   xen_extra_mem[i].n_pfns);</span>
<span class="p_add">+#ifdef CONFIG_XEN_PV</span>
<span class="p_add">+	{</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Initialize the balloon with pages from the extra memory</span>
<span class="p_add">+		 * regions (see arch/x86/xen/setup.c).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (i = 0; i &lt; XEN_EXTRA_MEM_MAX_REGIONS; i++)</span>
<span class="p_add">+			if (xen_extra_mem[i].n_pfns)</span>
<span class="p_add">+				balloon_add_region(xen_extra_mem[i].start_pfn,</span>
<span class="p_add">+						   xen_extra_mem[i].n_pfns);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/include/xen/xen-ops.h b/include/xen/xen-ops.h</span>
<span class="p_header">index 4e562de..f9e0e23 100644</span>
<span class="p_header">--- a/include/xen/xen-ops.h</span>
<span class="p_header">+++ b/include/xen/xen-ops.h</span>
<span class="p_chunk">@@ -40,11 +40,24 @@</span> <span class="p_context"> void xen_reboot(int reason);</span>
 void xen_emergency_restart(void);
 
 extern unsigned long *xen_contiguous_bitmap;
<span class="p_add">+#ifdef CONFIG_XEN_PV</span>
 int xen_create_contiguous_region(phys_addr_t pstart, unsigned int order,
 				unsigned int address_bits,
 				dma_addr_t *dma_handle);
 
 void xen_destroy_contiguous_region(phys_addr_t pstart, unsigned int order);
<span class="p_add">+#else</span>
<span class="p_add">+static inline int xen_create_contiguous_region(phys_addr_t pstart,</span>
<span class="p_add">+					       unsigned int order,</span>
<span class="p_add">+					       unsigned int address_bits,</span>
<span class="p_add">+					       dma_addr_t *dma_handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void xen_destroy_contiguous_region(phys_addr_t pstart,</span>
<span class="p_add">+						 unsigned int order) { }</span>
<span class="p_add">+#endif</span>
 
 struct vm_area_struct;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



