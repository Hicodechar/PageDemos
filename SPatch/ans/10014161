
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.13.8 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.13.8</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 18, 2017, 8:43 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171018084338.GB11027@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10014161/mbox/"
   >mbox</a>
|
   <a href="/patch/10014161/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10014161/">/patch/10014161/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9AC6E60211 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 18 Oct 2017 08:43:50 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7B59A28AB8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 18 Oct 2017 08:43:50 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6FDC528AE6; Wed, 18 Oct 2017 08:43:50 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 771AE28AB8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 18 Oct 2017 08:43:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S965352AbdJRInp (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 18 Oct 2017 04:43:45 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:33242 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1759069AbdJRInb (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 18 Oct 2017 04:43:31 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 2F19D89E;
	Wed, 18 Oct 2017 08:43:30 +0000 (UTC)
Date: Wed, 18 Oct 2017 10:43:38 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.13.8
Message-ID: &lt;20171018084338.GB11027@kroah.com&gt;
References: &lt;20171018084331.GA11027@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171018084331.GA11027@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 18, 2017, 8:43 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 0d4f1b19869d..66ec023da822 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 13
<span class="p_del">-SUBLEVEL = 7</span>
<span class="p_add">+SUBLEVEL = 8</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index f08a7b4facb9..4f0a1a6f7589 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -2387,7 +2387,6 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 					break;
 				default:
 					/* Reserved R6 ops */
<span class="p_del">-					pr_err(&quot;Reserved MIPS R6 CMP.condn.S operation\n&quot;);</span>
 					return SIGILL;
 				}
 			}
<span class="p_chunk">@@ -2461,7 +2460,6 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 					break;
 				default:
 					/* Reserved R6 ops */
<span class="p_del">-					pr_err(&quot;Reserved MIPS R6 CMP.condn.D operation\n&quot;);</span>
 					return SIGILL;
 				}
 			}
<span class="p_header">diff --git a/arch/mips/net/ebpf_jit.c b/arch/mips/net/ebpf_jit.c</span>
<span class="p_header">index 3f87b96da5c4..401776f92288 100644</span>
<span class="p_header">--- a/arch/mips/net/ebpf_jit.c</span>
<span class="p_header">+++ b/arch/mips/net/ebpf_jit.c</span>
<span class="p_chunk">@@ -679,7 +679,7 @@</span> <span class="p_context"> static int build_one_insn(const struct bpf_insn *insn, struct jit_ctx *ctx,</span>
 {
 	int src, dst, r, td, ts, mem_off, b_off;
 	bool need_swap, did_move, cmp_eq;
<span class="p_del">-	unsigned int target;</span>
<span class="p_add">+	unsigned int target = 0;</span>
 	u64 t64;
 	s64 t64s;
 
<span class="p_header">diff --git a/arch/x86/include/asm/alternative-asm.h b/arch/x86/include/asm/alternative-asm.h</span>
<span class="p_header">index e7636bac7372..6c98821fef5e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/alternative-asm.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/alternative-asm.h</span>
<span class="p_chunk">@@ -62,8 +62,10 @@</span> <span class="p_context"></span>
 #define new_len2		145f-144f
 
 /*
<span class="p_del">- * max without conditionals. Idea adapted from:</span>
<span class="p_add">+ * gas compatible max based on the idea from:</span>
  * http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax
<span class="p_add">+ *</span>
<span class="p_add">+ * The additional &quot;-&quot; is needed because gas uses a &quot;true&quot; value of -1.</span>
  */
 #define alt_max_short(a, b)	((a) ^ (((a) ^ (b)) &amp; -(-((a) &lt; (b)))))
 
<span class="p_header">diff --git a/arch/x86/include/asm/alternative.h b/arch/x86/include/asm/alternative.h</span>
<span class="p_header">index 1b020381ab38..d4aea31eec03 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/alternative.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/alternative.h</span>
<span class="p_chunk">@@ -103,12 +103,12 @@</span> <span class="p_context"> static inline int alternatives_text_reserved(void *start, void *end)</span>
 	alt_end_marker &quot;:\n&quot;
 
 /*
<span class="p_del">- * max without conditionals. Idea adapted from:</span>
<span class="p_add">+ * gas compatible max based on the idea from:</span>
  * http://graphics.stanford.edu/~seander/bithacks.html#IntegerMinOrMax
  *
<span class="p_del">- * The additional &quot;-&quot; is needed because gas works with s32s.</span>
<span class="p_add">+ * The additional &quot;-&quot; is needed because gas uses a &quot;true&quot; value of -1.</span>
  */
<span class="p_del">-#define alt_max_short(a, b)	&quot;((&quot; a &quot;) ^ (((&quot; a &quot;) ^ (&quot; b &quot;)) &amp; -(-((&quot; a &quot;) - (&quot; b &quot;)))))&quot;</span>
<span class="p_add">+#define alt_max_short(a, b)	&quot;((&quot; a &quot;) ^ (((&quot; a &quot;) ^ (&quot; b &quot;)) &amp; -(-((&quot; a &quot;) &lt; (&quot; b &quot;)))))&quot;</span>
 
 /*
  * Pad the second replacement alternative with additional NOPs if it is
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/core.c b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">index 86e8f0b2537b..c4fa4a85d4cb 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_chunk">@@ -122,9 +122,6 @@</span> <span class="p_context"> static bool __init check_loader_disabled_bsp(void)</span>
 	bool *res = &amp;dis_ucode_ldr;
 #endif
 
<span class="p_del">-	if (!have_cpuid_p())</span>
<span class="p_del">-		return *res;</span>
<span class="p_del">-</span>
 	/*
 	 * CPUID(1).ECX[31]: reserved for hypervisor use. This is still not
 	 * completely accurate as xen pv guests don&#39;t see that CPUID bit set but
<span class="p_chunk">@@ -166,24 +163,36 @@</span> <span class="p_context"> bool get_builtin_firmware(struct cpio_data *cd, const char *name)</span>
 void __init load_ucode_bsp(void)
 {
 	unsigned int cpuid_1_eax;
<span class="p_add">+	bool intel = true;</span>
 
<span class="p_del">-	if (check_loader_disabled_bsp())</span>
<span class="p_add">+	if (!have_cpuid_p())</span>
 		return;
 
 	cpuid_1_eax = native_cpuid_eax(1);
 
 	switch (x86_cpuid_vendor()) {
 	case X86_VENDOR_INTEL:
<span class="p_del">-		if (x86_family(cpuid_1_eax) &gt;= 6)</span>
<span class="p_del">-			load_ucode_intel_bsp();</span>
<span class="p_add">+		if (x86_family(cpuid_1_eax) &lt; 6)</span>
<span class="p_add">+			return;</span>
 		break;
<span class="p_add">+</span>
 	case X86_VENDOR_AMD:
<span class="p_del">-		if (x86_family(cpuid_1_eax) &gt;= 0x10)</span>
<span class="p_del">-			load_ucode_amd_bsp(cpuid_1_eax);</span>
<span class="p_add">+		if (x86_family(cpuid_1_eax) &lt; 0x10)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		intel = false;</span>
 		break;
<span class="p_add">+</span>
 	default:
<span class="p_del">-		break;</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (check_loader_disabled_bsp())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (intel)</span>
<span class="p_add">+		load_ucode_intel_bsp();</span>
<span class="p_add">+	else</span>
<span class="p_add">+		load_ucode_amd_bsp(cpuid_1_eax);</span>
 }
 
 static bool check_loader_disabled_ap(void)
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 7558531c1215..bd4e058c25a4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3934,13 +3934,6 @@</span> <span class="p_context"> static bool sync_mmio_spte(struct kvm_vcpu *vcpu, u64 *sptep, gfn_t gfn,</span>
 static inline bool is_last_gpte(struct kvm_mmu *mmu,
 				unsigned level, unsigned gpte)
 {
<span class="p_del">-	/*</span>
<span class="p_del">-	 * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set</span>
<span class="p_del">-	 * iff level &lt;= PT_PAGE_TABLE_LEVEL, which for our purpose means</span>
<span class="p_del">-	 * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	gpte |= level - PT_PAGE_TABLE_LEVEL - 1;</span>
<span class="p_del">-</span>
 	/*
 	 * The RHS has bit 7 set iff level &lt; mmu-&gt;last_nonleaf_level.
 	 * If it is clear, there are no large pages at this level, so clear
<span class="p_chunk">@@ -3948,6 +3941,13 @@</span> <span class="p_context"> static inline bool is_last_gpte(struct kvm_mmu *mmu,</span>
 	 */
 	gpte &amp;= level - mmu-&gt;last_nonleaf_level;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * PT_PAGE_TABLE_LEVEL always terminates.  The RHS has bit 7 set</span>
<span class="p_add">+	 * iff level &lt;= PT_PAGE_TABLE_LEVEL, which for our purpose means</span>
<span class="p_add">+	 * level == PT_PAGE_TABLE_LEVEL; set PT_PAGE_SIZE_MASK in gpte then.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	gpte |= level - PT_PAGE_TABLE_LEVEL - 1;</span>
<span class="p_add">+</span>
 	return gpte &amp; PT_PAGE_SIZE_MASK;
 }
 
<span class="p_chunk">@@ -4459,6 +4459,7 @@</span> <span class="p_context"> void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, bool execonly,</span>
 
 	update_permission_bitmask(vcpu, context, true);
 	update_pkru_bitmask(vcpu, context, true);
<span class="p_add">+	update_last_nonleaf_level(vcpu, context);</span>
 	reset_rsvds_bits_mask_ept(vcpu, context, execonly);
 	reset_ept_shadow_zero_bits_mask(vcpu, context, execonly);
 }
<span class="p_header">diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">index b0454c7e4cff..da06dc8c4fc4 100644</span>
<span class="p_header">--- a/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">+++ b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_chunk">@@ -334,10 +334,11 @@</span> <span class="p_context"> static int FNAME(walk_addr_generic)(struct guest_walker *walker,</span>
 		--walker-&gt;level;
 
 		index = PT_INDEX(addr, walker-&gt;level);
<span class="p_del">-</span>
 		table_gfn = gpte_to_gfn(pte);
 		offset    = index * sizeof(pt_element_t);
 		pte_gpa   = gfn_to_gpa(table_gfn) + offset;
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON(walker-&gt;level &lt; 1);</span>
 		walker-&gt;table_gfn[walker-&gt;level - 1] = table_gfn;
 		walker-&gt;pte_gpa[walker-&gt;level - 1] = pte_gpa;
 
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 95796e2efc38..118709e7597d 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -11013,7 +11013,7 @@</span> <span class="p_context"> static void load_vmcs12_host_state(struct kvm_vcpu *vcpu,</span>
 
 	/* Same as above - no reason to call set_cr4_guest_host_mask().  */
 	vcpu-&gt;arch.cr4_guest_owned_bits = ~vmcs_readl(CR4_GUEST_HOST_MASK);
<span class="p_del">-	kvm_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
<span class="p_add">+	vmx_set_cr4(vcpu, vmcs12-&gt;host_cr4);</span>
 
 	nested_ept_uninit_mmu_context(vcpu);
 
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index 9a63597aaacc..30f56b8b1fb2 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1235,8 +1235,8 @@</span> <span class="p_context"> struct bio *bio_copy_user_iov(struct request_queue *q,</span>
 	 */
 	bmd-&gt;is_our_pages = map_data ? 0 : 1;
 	memcpy(bmd-&gt;iov, iter-&gt;iov, sizeof(struct iovec) * iter-&gt;nr_segs);
<span class="p_del">-	iov_iter_init(&amp;bmd-&gt;iter, iter-&gt;type, bmd-&gt;iov,</span>
<span class="p_del">-			iter-&gt;nr_segs, iter-&gt;count);</span>
<span class="p_add">+	bmd-&gt;iter = *iter;</span>
<span class="p_add">+	bmd-&gt;iter.iov = bmd-&gt;iov;</span>
 
 	ret = -ENOMEM;
 	bio = bio_kmalloc(gfp_mask, nr_pages);
<span class="p_chunk">@@ -1327,6 +1327,7 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 	int ret, offset;
 	struct iov_iter i;
 	struct iovec iov;
<span class="p_add">+	struct bio_vec *bvec;</span>
 
 	iov_for_each(iov, i, *iter) {
 		unsigned long uaddr = (unsigned long) iov.iov_base;
<span class="p_chunk">@@ -1371,7 +1372,12 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 		ret = get_user_pages_fast(uaddr, local_nr_pages,
 				(iter-&gt;type &amp; WRITE) != WRITE,
 				&amp;pages[cur_page]);
<span class="p_del">-		if (ret &lt; local_nr_pages) {</span>
<span class="p_add">+		if (unlikely(ret &lt; local_nr_pages)) {</span>
<span class="p_add">+			for (j = cur_page; j &lt; page_limit; j++) {</span>
<span class="p_add">+				if (!pages[j])</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+			}</span>
 			ret = -EFAULT;
 			goto out_unmap;
 		}
<span class="p_chunk">@@ -1379,6 +1385,7 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 		offset = offset_in_page(uaddr);
 		for (j = cur_page; j &lt; page_limit; j++) {
 			unsigned int bytes = PAGE_SIZE - offset;
<span class="p_add">+			unsigned short prev_bi_vcnt = bio-&gt;bi_vcnt;</span>
 
 			if (len &lt;= 0)
 				break;
<span class="p_chunk">@@ -1393,6 +1400,13 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 					    bytes)
 				break;
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * check if vector was merged with previous</span>
<span class="p_add">+			 * drop page reference if needed</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (bio-&gt;bi_vcnt == prev_bi_vcnt)</span>
<span class="p_add">+				put_page(pages[j]);</span>
<span class="p_add">+</span>
 			len -= bytes;
 			offset = 0;
 		}
<span class="p_chunk">@@ -1419,10 +1433,8 @@</span> <span class="p_context"> struct bio *bio_map_user_iov(struct request_queue *q,</span>
 	return bio;
 
  out_unmap:
<span class="p_del">-	for (j = 0; j &lt; nr_pages; j++) {</span>
<span class="p_del">-		if (!pages[j])</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		put_page(pages[j]);</span>
<span class="p_add">+	bio_for_each_segment_all(bvec, bio, j) {</span>
<span class="p_add">+		put_page(bvec-&gt;bv_page);</span>
 	}
  out:
 	kfree(pages);
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index 5e31c8d776df..f4161f3cfed6 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -275,12 +275,14 @@</span> <span class="p_context"> static int shash_async_finup(struct ahash_request *req)</span>
 
 int shash_ahash_digest(struct ahash_request *req, struct shash_desc *desc)
 {
<span class="p_del">-	struct scatterlist *sg = req-&gt;src;</span>
<span class="p_del">-	unsigned int offset = sg-&gt;offset;</span>
 	unsigned int nbytes = req-&gt;nbytes;
<span class="p_add">+	struct scatterlist *sg;</span>
<span class="p_add">+	unsigned int offset;</span>
 	int err;
 
<span class="p_del">-	if (nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset)) {</span>
<span class="p_add">+	if (nbytes &amp;&amp;</span>
<span class="p_add">+	    (sg = req-&gt;src, offset = sg-&gt;offset,</span>
<span class="p_add">+	     nbytes &lt; min(sg-&gt;length, ((unsigned int)(PAGE_SIZE)) - offset))) {</span>
 		void *data;
 
 		data = kmap_atomic(sg_page(sg));
<span class="p_header">diff --git a/crypto/skcipher.c b/crypto/skcipher.c</span>
<span class="p_header">index 4faa0fd53b0c..d5692e35fab1 100644</span>
<span class="p_header">--- a/crypto/skcipher.c</span>
<span class="p_header">+++ b/crypto/skcipher.c</span>
<span class="p_chunk">@@ -426,14 +426,9 @@</span> <span class="p_context"> static int skcipher_copy_iv(struct skcipher_walk *walk)</span>
 
 static int skcipher_walk_first(struct skcipher_walk *walk)
 {
<span class="p_del">-	walk-&gt;nbytes = 0;</span>
<span class="p_del">-</span>
 	if (WARN_ON_ONCE(in_irq()))
 		return -EDEADLK;
 
<span class="p_del">-	if (unlikely(!walk-&gt;total))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	walk-&gt;buffer = NULL;
 	if (unlikely(((unsigned long)walk-&gt;iv &amp; walk-&gt;alignmask))) {
 		int err = skcipher_copy_iv(walk);
<span class="p_chunk">@@ -452,10 +447,15 @@</span> <span class="p_context"> static int skcipher_walk_skcipher(struct skcipher_walk *walk,</span>
 {
 	struct crypto_skcipher *tfm = crypto_skcipher_reqtfm(req);
 
<span class="p_add">+	walk-&gt;total = req-&gt;cryptlen;</span>
<span class="p_add">+	walk-&gt;nbytes = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!walk-&gt;total))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	scatterwalk_start(&amp;walk-&gt;in, req-&gt;src);
 	scatterwalk_start(&amp;walk-&gt;out, req-&gt;dst);
 
<span class="p_del">-	walk-&gt;total = req-&gt;cryptlen;</span>
 	walk-&gt;iv = req-&gt;iv;
 	walk-&gt;oiv = req-&gt;iv;
 
<span class="p_chunk">@@ -509,6 +509,11 @@</span> <span class="p_context"> static int skcipher_walk_aead_common(struct skcipher_walk *walk,</span>
 	struct crypto_aead *tfm = crypto_aead_reqtfm(req);
 	int err;
 
<span class="p_add">+	walk-&gt;nbytes = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(!walk-&gt;total))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	walk-&gt;flags &amp;= ~SKCIPHER_WALK_PHYS;
 
 	scatterwalk_start(&amp;walk-&gt;in, req-&gt;src);
<span class="p_header">diff --git a/drivers/base/property.c b/drivers/base/property.c</span>
<span class="p_header">index edf02c1b5845..5d0c26a53876 100644</span>
<span class="p_header">--- a/drivers/base/property.c</span>
<span class="p_header">+++ b/drivers/base/property.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/phy.h&gt;
 
 struct property_set {
<span class="p_add">+	struct device *dev;</span>
 	struct fwnode_handle fwnode;
 	const struct property_entry *properties;
 };
<span class="p_chunk">@@ -855,6 +856,7 @@</span> <span class="p_context"> static struct property_set *pset_copy_set(const struct property_set *pset)</span>
 void device_remove_properties(struct device *dev)
 {
 	struct fwnode_handle *fwnode;
<span class="p_add">+	struct property_set *pset;</span>
 
 	fwnode = dev_fwnode(dev);
 	if (!fwnode)
<span class="p_chunk">@@ -864,16 +866,16 @@</span> <span class="p_context"> void device_remove_properties(struct device *dev)</span>
 	 * the pset. If there is no real firmware node (ACPI/DT) primary
 	 * will hold the pset.
 	 */
<span class="p_del">-	if (is_pset_node(fwnode)) {</span>
<span class="p_add">+	pset = to_pset_node(fwnode);</span>
<span class="p_add">+	if (pset) {</span>
 		set_primary_fwnode(dev, NULL);
<span class="p_del">-		pset_free_set(to_pset_node(fwnode));</span>
 	} else {
<span class="p_del">-		fwnode = fwnode-&gt;secondary;</span>
<span class="p_del">-		if (!IS_ERR(fwnode) &amp;&amp; is_pset_node(fwnode)) {</span>
<span class="p_add">+		pset = to_pset_node(fwnode-&gt;secondary);</span>
<span class="p_add">+		if (pset &amp;&amp; dev == pset-&gt;dev)</span>
 			set_secondary_fwnode(dev, NULL);
<span class="p_del">-			pset_free_set(to_pset_node(fwnode));</span>
<span class="p_del">-		}</span>
 	}
<span class="p_add">+	if (pset &amp;&amp; dev == pset-&gt;dev)</span>
<span class="p_add">+		pset_free_set(pset);</span>
 }
 EXPORT_SYMBOL_GPL(device_remove_properties);
 
<span class="p_chunk">@@ -903,6 +905,7 @@</span> <span class="p_context"> int device_add_properties(struct device *dev,</span>
 	p-&gt;fwnode.type = FWNODE_PDATA;
 	p-&gt;fwnode.ops = &amp;pset_fwnode_ops;
 	set_secondary_fwnode(dev, &amp;p-&gt;fwnode);
<span class="p_add">+	p-&gt;dev = dev;</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(device_add_properties);
<span class="p_header">diff --git a/drivers/dma/edma.c b/drivers/dma/edma.c</span>
<span class="p_header">index 3879f80a4815..a7ea20e7b8e9 100644</span>
<span class="p_header">--- a/drivers/dma/edma.c</span>
<span class="p_header">+++ b/drivers/dma/edma.c</span>
<span class="p_chunk">@@ -1143,11 +1143,24 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *edma_prep_dma_memcpy(</span>
 	struct edma_desc *edesc;
 	struct device *dev = chan-&gt;device-&gt;dev;
 	struct edma_chan *echan = to_edma_chan(chan);
<span class="p_del">-	unsigned int width, pset_len;</span>
<span class="p_add">+	unsigned int width, pset_len, array_size;</span>
 
 	if (unlikely(!echan || !len))
 		return NULL;
 
<span class="p_add">+	/* Align the array size (acnt block) with the transfer properties */</span>
<span class="p_add">+	switch (__ffs((src | dest | len))) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		array_size = SZ_32K - 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		array_size = SZ_32K - 2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		array_size = SZ_32K - 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (len &lt; SZ_64K) {
 		/*
 		 * Transfer size less than 64K can be handled with one paRAM
<span class="p_chunk">@@ -1169,7 +1182,7 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *edma_prep_dma_memcpy(</span>
 		 * When the full_length is multibple of 32767 one slot can be
 		 * used to complete the transfer.
 		 */
<span class="p_del">-		width = SZ_32K - 1;</span>
<span class="p_add">+		width = array_size;</span>
 		pset_len = rounddown(len, width);
 		/* One slot is enough for lengths multiple of (SZ_32K -1) */
 		if (unlikely(pset_len == len))
<span class="p_chunk">@@ -1217,7 +1230,7 @@</span> <span class="p_context"> static struct dma_async_tx_descriptor *edma_prep_dma_memcpy(</span>
 		}
 		dest += pset_len;
 		src += pset_len;
<span class="p_del">-		pset_len = width = len % (SZ_32K - 1);</span>
<span class="p_add">+		pset_len = width = len % array_size;</span>
 
 		ret = edma_config_pset(chan, &amp;edesc-&gt;pset[1], src, dest, 1,
 				       width, pset_len, DMA_MEM_TO_MEM);
<span class="p_header">diff --git a/drivers/dma/ti-dma-crossbar.c b/drivers/dma/ti-dma-crossbar.c</span>
<span class="p_header">index 2403475a37cf..88a00d06def6 100644</span>
<span class="p_header">--- a/drivers/dma/ti-dma-crossbar.c</span>
<span class="p_header">+++ b/drivers/dma/ti-dma-crossbar.c</span>
<span class="p_chunk">@@ -262,13 +262,14 @@</span> <span class="p_context"> static void *ti_dra7_xbar_route_allocate(struct of_phandle_args *dma_spec,</span>
 	mutex_lock(&amp;xbar-&gt;mutex);
 	map-&gt;xbar_out = find_first_zero_bit(xbar-&gt;dma_inuse,
 					    xbar-&gt;dma_requests);
<span class="p_del">-	mutex_unlock(&amp;xbar-&gt;mutex);</span>
 	if (map-&gt;xbar_out == xbar-&gt;dma_requests) {
<span class="p_add">+		mutex_unlock(&amp;xbar-&gt;mutex);</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;Run out of free DMA requests\n&quot;);
 		kfree(map);
 		return ERR_PTR(-ENOMEM);
 	}
 	set_bit(map-&gt;xbar_out, xbar-&gt;dma_inuse);
<span class="p_add">+	mutex_unlock(&amp;xbar-&gt;mutex);</span>
 
 	map-&gt;xbar_in = (u16)dma_spec-&gt;args[0];
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_atomic_helper.c b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">index 86d3093c6c9b..c73763959945 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_atomic_helper.c</span>
<span class="p_chunk">@@ -2756,6 +2756,7 @@</span> <span class="p_context"> int drm_atomic_helper_resume(struct drm_device *dev,</span>
 		drm_modeset_backoff(&amp;ctx);
 	}
 
<span class="p_add">+	drm_atomic_state_put(state);</span>
 	drm_modeset_drop_locks(&amp;ctx);
 	drm_modeset_acquire_fini(&amp;ctx);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">index 645488071944..f814359c86c9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_chunk">@@ -1231,7 +1231,7 @@</span> <span class="p_context"> static void parse_ddi_ports(struct drm_i915_private *dev_priv,</span>
 {
 	enum port port;
 
<span class="p_del">-	if (!HAS_DDI(dev_priv))</span>
<span class="p_add">+	if (!HAS_DDI(dev_priv) &amp;&amp; !IS_CHERRYVIEW(dev_priv))</span>
 		return;
 
 	if (!dev_priv-&gt;vbt.child_dev_num)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_color.c b/drivers/gpu/drm/i915/intel_color.c</span>
<span class="p_header">index 17c4ae7e4e7c..824042ed04f6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_color.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_color.c</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"></span>
 #define I9XX_CSC_COEFF_1_0		\
 	((7 &lt;&lt; 12) | I9XX_CSC_COEFF_FP(CTM_COEFF_1_0, 8))
 
<span class="p_del">-static bool crtc_state_is_legacy(struct drm_crtc_state *state)</span>
<span class="p_add">+static bool crtc_state_is_legacy_gamma(struct drm_crtc_state *state)</span>
 {
 	return !state-&gt;degamma_lut &amp;&amp;
 		!state-&gt;ctm &amp;&amp;
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> static void cherryview_load_csc_matrix(struct drm_crtc_state *state)</span>
 	}
 
 	mode = (state-&gt;ctm ? CGM_PIPE_MODE_CSC : 0);
<span class="p_del">-	if (!crtc_state_is_legacy(state)) {</span>
<span class="p_add">+	if (!crtc_state_is_legacy_gamma(state)) {</span>
 		mode |= (state-&gt;degamma_lut ? CGM_PIPE_MODE_DEGAMMA : 0) |
 			(state-&gt;gamma_lut ? CGM_PIPE_MODE_GAMMA : 0);
 	}
<span class="p_chunk">@@ -426,7 +426,7 @@</span> <span class="p_context"> static void broadwell_load_luts(struct drm_crtc_state *state)</span>
 	struct intel_crtc_state *intel_state = to_intel_crtc_state(state);
 	enum pipe pipe = to_intel_crtc(state-&gt;crtc)-&gt;pipe;
 
<span class="p_del">-	if (crtc_state_is_legacy(state)) {</span>
<span class="p_add">+	if (crtc_state_is_legacy_gamma(state)) {</span>
 		haswell_load_luts(state);
 		return;
 	}
<span class="p_chunk">@@ -486,7 +486,7 @@</span> <span class="p_context"> static void glk_load_luts(struct drm_crtc_state *state)</span>
 
 	glk_load_degamma_lut(state);
 
<span class="p_del">-	if (crtc_state_is_legacy(state)) {</span>
<span class="p_add">+	if (crtc_state_is_legacy_gamma(state)) {</span>
 		haswell_load_luts(state);
 		return;
 	}
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> static void cherryview_load_luts(struct drm_crtc_state *state)</span>
 	uint32_t i, lut_size;
 	uint32_t word0, word1;
 
<span class="p_del">-	if (crtc_state_is_legacy(state)) {</span>
<span class="p_add">+	if (crtc_state_is_legacy_gamma(state)) {</span>
 		/* Turn off degamma/gamma on CGM block. */
 		I915_WRITE(CGM_PIPE_MODE(pipe),
 			   (state-&gt;ctm ? CGM_PIPE_MODE_CSC : 0));
<span class="p_chunk">@@ -589,12 +589,10 @@</span> <span class="p_context"> int intel_color_check(struct drm_crtc *crtc,</span>
 		return 0;
 
 	/*
<span class="p_del">-	 * We also allow no degamma lut and a gamma lut at the legacy</span>
<span class="p_add">+	 * We also allow no degamma lut/ctm and a gamma lut at the legacy</span>
 	 * size (256 entries).
 	 */
<span class="p_del">-	if (!crtc_state-&gt;degamma_lut &amp;&amp;</span>
<span class="p_del">-	    crtc_state-&gt;gamma_lut &amp;&amp;</span>
<span class="p_del">-	    crtc_state-&gt;gamma_lut-&gt;length == LEGACY_LUT_LENGTH)</span>
<span class="p_add">+	if (crtc_state_is_legacy_gamma(crtc_state))</span>
 		return 0;
 
 	return -EINVAL;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index cc484b56eeaa..20b458551157 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -10059,13 +10059,10 @@</span> <span class="p_context"> struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
<span class="p_del">-	enum transcoder cpu_transcoder = intel_crtc-&gt;config-&gt;cpu_transcoder;</span>
<span class="p_add">+	enum transcoder cpu_transcoder;</span>
 	struct drm_display_mode *mode;
 	struct intel_crtc_state *pipe_config;
<span class="p_del">-	int htot = I915_READ(HTOTAL(cpu_transcoder));</span>
<span class="p_del">-	int hsync = I915_READ(HSYNC(cpu_transcoder));</span>
<span class="p_del">-	int vtot = I915_READ(VTOTAL(cpu_transcoder));</span>
<span class="p_del">-	int vsync = I915_READ(VSYNC(cpu_transcoder));</span>
<span class="p_add">+	u32 htot, hsync, vtot, vsync;</span>
 	enum pipe pipe = intel_crtc-&gt;pipe;
 
 	mode = kzalloc(sizeof(*mode), GFP_KERNEL);
<span class="p_chunk">@@ -10093,6 +10090,13 @@</span> <span class="p_context"> struct drm_display_mode *intel_crtc_mode_get(struct drm_device *dev,</span>
 	i9xx_crtc_clock_get(intel_crtc, pipe_config);
 
 	mode-&gt;clock = pipe_config-&gt;port_clock / pipe_config-&gt;pixel_multiplier;
<span class="p_add">+</span>
<span class="p_add">+	cpu_transcoder = pipe_config-&gt;cpu_transcoder;</span>
<span class="p_add">+	htot = I915_READ(HTOTAL(cpu_transcoder));</span>
<span class="p_add">+	hsync = I915_READ(HSYNC(cpu_transcoder));</span>
<span class="p_add">+	vtot = I915_READ(VTOTAL(cpu_transcoder));</span>
<span class="p_add">+	vsync = I915_READ(VSYNC(cpu_transcoder));</span>
<span class="p_add">+</span>
 	mode-&gt;hdisplay = (htot &amp; 0xffff) + 1;
 	mode-&gt;htotal = ((htot &amp; 0xffff0000) &gt;&gt; 16) + 1;
 	mode-&gt;hsync_start = (hsync &amp; 0xffff) + 1;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 64fa774c855b..61c313e21a91 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -2263,8 +2263,8 @@</span> <span class="p_context"> static void edp_panel_off(struct intel_dp *intel_dp)</span>
 	I915_WRITE(pp_ctrl_reg, pp);
 	POSTING_READ(pp_ctrl_reg);
 
<span class="p_del">-	intel_dp-&gt;panel_power_off_time = ktime_get_boottime();</span>
 	wait_panel_off(intel_dp);
<span class="p_add">+	intel_dp-&gt;panel_power_off_time = ktime_get_boottime();</span>
 
 	/* We got a reference when we enabled the VDD. */
 	intel_display_power_put(dev_priv, intel_dp-&gt;aux_power_domain);
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-core.c b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">index c008847e0b20..3f11b02f9857 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-core.c</span>
<span class="p_chunk">@@ -975,6 +975,8 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 	unsigned int rsize = 0;
 	char *rdesc;
 	int ret, n;
<span class="p_add">+	int num_descriptors;</span>
<span class="p_add">+	size_t offset = offsetof(struct hid_descriptor, desc);</span>
 
 	quirks = usbhid_lookup_quirk(le16_to_cpu(dev-&gt;descriptor.idVendor),
 			le16_to_cpu(dev-&gt;descriptor.idProduct));
<span class="p_chunk">@@ -997,10 +999,18 @@</span> <span class="p_context"> static int usbhid_parse(struct hid_device *hid)</span>
 		return -ENODEV;
 	}
 
<span class="p_add">+	if (hdesc-&gt;bLength &lt; sizeof(struct hid_descriptor)) {</span>
<span class="p_add">+		dbg_hid(&quot;hid descriptor is too short\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	hid-&gt;version = le16_to_cpu(hdesc-&gt;bcdHID);
 	hid-&gt;country = hdesc-&gt;bCountryCode;
 
<span class="p_del">-	for (n = 0; n &lt; hdesc-&gt;bNumDescriptors; n++)</span>
<span class="p_add">+	num_descriptors = min_t(int, hdesc-&gt;bNumDescriptors,</span>
<span class="p_add">+	       (hdesc-&gt;bLength - offset) / sizeof(struct hid_class_descriptor));</span>
<span class="p_add">+</span>
<span class="p_add">+	for (n = 0; n &lt; num_descriptors; n++)</span>
 		if (hdesc-&gt;desc[n].bDescriptorType == HID_DT_REPORT)
 			rsize = le16_to_cpu(hdesc-&gt;desc[n].wDescriptorLength);
 
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 354cbd6392cd..632643939147 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -3262,6 +3262,7 @@</span> <span class="p_context"> static size_t amd_iommu_unmap(struct iommu_domain *dom, unsigned long iova,</span>
 	mutex_unlock(&amp;domain-&gt;api_lock);
 
 	domain_flush_tlb_pde(domain);
<span class="p_add">+	domain_flush_complete(domain);</span>
 
 	return unmap_size;
 }
<span class="p_header">diff --git a/drivers/misc/mei/pci-me.c b/drivers/misc/mei/pci-me.c</span>
<span class="p_header">index bac33311f55a..1d37a4782c78 100644</span>
<span class="p_header">--- a/drivers/misc/mei/pci-me.c</span>
<span class="p_header">+++ b/drivers/misc/mei/pci-me.c</span>
<span class="p_chunk">@@ -222,12 +222,15 @@</span> <span class="p_context"> static int mei_me_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	pdev-&gt;dev_flags |= PCI_DEV_FLAGS_NEEDS_RESUME;
 
 	/*
<span class="p_del">-	* For not wake-able HW runtime pm framework</span>
<span class="p_del">-	* can&#39;t be used on pci device level.</span>
<span class="p_del">-	* Use domain runtime pm callbacks instead.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	if (!pci_dev_run_wake(pdev))</span>
<span class="p_del">-		mei_me_set_pm_domain(dev);</span>
<span class="p_add">+	 * ME maps runtime suspend/resume to D0i states,</span>
<span class="p_add">+	 * hence we need to go around native PCI runtime service which</span>
<span class="p_add">+	 * eventually brings the device into D3cold/hot state,</span>
<span class="p_add">+	 * but the mei device cannot wake up from D3 unlike from D0i3.</span>
<span class="p_add">+	 * To get around the PCI device native runtime pm,</span>
<span class="p_add">+	 * ME uses runtime pm domain handlers which take precedence</span>
<span class="p_add">+	 * over the driver&#39;s pm handlers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mei_me_set_pm_domain(dev);</span>
 
 	if (mei_pg_is_enabled(dev))
 		pm_runtime_put_noidle(&amp;pdev-&gt;dev);
<span class="p_chunk">@@ -267,8 +270,7 @@</span> <span class="p_context"> static void mei_me_shutdown(struct pci_dev *pdev)</span>
 	dev_dbg(&amp;pdev-&gt;dev, &quot;shutdown\n&quot;);
 	mei_stop(dev);
 
<span class="p_del">-	if (!pci_dev_run_wake(pdev))</span>
<span class="p_del">-		mei_me_unset_pm_domain(dev);</span>
<span class="p_add">+	mei_me_unset_pm_domain(dev);</span>
 
 	mei_disable_interrupts(dev);
 	free_irq(pdev-&gt;irq, dev);
<span class="p_chunk">@@ -296,8 +298,7 @@</span> <span class="p_context"> static void mei_me_remove(struct pci_dev *pdev)</span>
 	dev_dbg(&amp;pdev-&gt;dev, &quot;stop\n&quot;);
 	mei_stop(dev);
 
<span class="p_del">-	if (!pci_dev_run_wake(pdev))</span>
<span class="p_del">-		mei_me_unset_pm_domain(dev);</span>
<span class="p_add">+	mei_me_unset_pm_domain(dev);</span>
 
 	mei_disable_interrupts(dev);
 
<span class="p_header">diff --git a/drivers/misc/mei/pci-txe.c b/drivers/misc/mei/pci-txe.c</span>
<span class="p_header">index e38a5f144373..0566f9bfa7de 100644</span>
<span class="p_header">--- a/drivers/misc/mei/pci-txe.c</span>
<span class="p_header">+++ b/drivers/misc/mei/pci-txe.c</span>
<span class="p_chunk">@@ -144,12 +144,14 @@</span> <span class="p_context"> static int mei_txe_probe(struct pci_dev *pdev, const struct pci_device_id *ent)</span>
 	pdev-&gt;dev_flags |= PCI_DEV_FLAGS_NEEDS_RESUME;
 
 	/*
<span class="p_del">-	* For not wake-able HW runtime pm framework</span>
<span class="p_del">-	* can&#39;t be used on pci device level.</span>
<span class="p_del">-	* Use domain runtime pm callbacks instead.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	if (!pci_dev_run_wake(pdev))</span>
<span class="p_del">-		mei_txe_set_pm_domain(dev);</span>
<span class="p_add">+	 * TXE maps runtime suspend/resume to own power gating states,</span>
<span class="p_add">+	 * hence we need to go around native PCI runtime service which</span>
<span class="p_add">+	 * eventually brings the device into D3cold/hot state.</span>
<span class="p_add">+	 * But the TXE device cannot wake up from D3 unlike from own</span>
<span class="p_add">+	 * power gating. To get around PCI device native runtime pm,</span>
<span class="p_add">+	 * TXE uses runtime pm domain handlers which take precedence.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mei_txe_set_pm_domain(dev);</span>
 
 	pm_runtime_put_noidle(&amp;pdev-&gt;dev);
 
<span class="p_chunk">@@ -186,8 +188,7 @@</span> <span class="p_context"> static void mei_txe_shutdown(struct pci_dev *pdev)</span>
 	dev_dbg(&amp;pdev-&gt;dev, &quot;shutdown\n&quot;);
 	mei_stop(dev);
 
<span class="p_del">-	if (!pci_dev_run_wake(pdev))</span>
<span class="p_del">-		mei_txe_unset_pm_domain(dev);</span>
<span class="p_add">+	mei_txe_unset_pm_domain(dev);</span>
 
 	mei_disable_interrupts(dev);
 	free_irq(pdev-&gt;irq, dev);
<span class="p_chunk">@@ -215,8 +216,7 @@</span> <span class="p_context"> static void mei_txe_remove(struct pci_dev *pdev)</span>
 
 	mei_stop(dev);
 
<span class="p_del">-	if (!pci_dev_run_wake(pdev))</span>
<span class="p_del">-		mei_txe_unset_pm_domain(dev);</span>
<span class="p_add">+	mei_txe_unset_pm_domain(dev);</span>
 
 	mei_disable_interrupts(dev);
 	free_irq(pdev-&gt;irq, dev);
<span class="p_chunk">@@ -318,15 +318,7 @@</span> <span class="p_context"> static int mei_txe_pm_runtime_suspend(struct device *device)</span>
 	else
 		ret = -EAGAIN;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If everything is okay we&#39;re about to enter PCI low</span>
<span class="p_del">-	 * power state (D3) therefor we need to disable the</span>
<span class="p_del">-	 * interrupts towards host.</span>
<span class="p_del">-	 * However if device is not wakeable we do not enter</span>
<span class="p_del">-	 * D-low state and we need to keep the interrupt kicking</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!ret &amp;&amp; pci_dev_run_wake(pdev))</span>
<span class="p_del">-		mei_disable_interrupts(dev);</span>
<span class="p_add">+	/* keep irq on we are staying in D0 */</span>
 
 	dev_dbg(&amp;pdev-&gt;dev, &quot;rpm: txe: runtime suspend ret=%d\n&quot;, ret);
 
<span class="p_header">diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c</span>
<span class="p_header">index 5fb9b620ac78..20f1d048582f 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-aardvark.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-aardvark.c</span>
<span class="p_chunk">@@ -936,6 +936,8 @@</span> <span class="p_context"> static int advk_pcie_probe(struct platform_device *pdev)</span>
 	bridge-&gt;sysdata = pcie;
 	bridge-&gt;busnr = 0;
 	bridge-&gt;ops = &amp;advk_pcie_ops;
<span class="p_add">+	bridge-&gt;map_irq = of_irq_parse_and_map_pci;</span>
<span class="p_add">+	bridge-&gt;swizzle_irq = pci_common_swizzle;</span>
 
 	ret = pci_scan_root_bus_bridge(bridge);
 	if (ret &lt; 0) {
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index b3722b7709df..1d1d87e8bcbf 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -233,6 +233,7 @@</span> <span class="p_context"> struct tegra_msi {</span>
 	struct msi_controller chip;
 	DECLARE_BITMAP(used, INT_PCI_MSI_NR);
 	struct irq_domain *domain;
<span class="p_add">+	unsigned long pages;</span>
 	struct mutex lock;
 	u64 phys;
 	int irq;
<span class="p_chunk">@@ -1529,22 +1530,9 @@</span> <span class="p_context"> static int tegra_pcie_enable_msi(struct tegra_pcie *pcie)</span>
 		goto err;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The PCI host bridge on Tegra contains some logic that intercepts</span>
<span class="p_del">-	 * MSI writes, which means that the MSI target address doesn&#39;t have</span>
<span class="p_del">-	 * to point to actual physical memory. Rather than allocating one 4</span>
<span class="p_del">-	 * KiB page of system memory that&#39;s never used, we can simply pick</span>
<span class="p_del">-	 * an arbitrary address within an area reserved for system memory</span>
<span class="p_del">-	 * in the FPCI address map.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * However, in order to avoid confusion, we pick an address that</span>
<span class="p_del">-	 * doesn&#39;t map to physical memory. The FPCI address map reserves a</span>
<span class="p_del">-	 * 1012 GiB region for system memory and memory-mapped I/O. Since</span>
<span class="p_del">-	 * none of the Tegra SoCs that contain this PCI host bridge can</span>
<span class="p_del">-	 * address more than 16 GiB of system memory, the last 4 KiB of</span>
<span class="p_del">-	 * these 1012 GiB is a good candidate.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	msi-&gt;phys = 0xfcfffff000;</span>
<span class="p_add">+	/* setup AFI/FPCI range */</span>
<span class="p_add">+	msi-&gt;pages = __get_free_pages(GFP_KERNEL, 0);</span>
<span class="p_add">+	msi-&gt;phys = virt_to_phys((void *)msi-&gt;pages);</span>
 
 	afi_writel(pcie, msi-&gt;phys &gt;&gt; soc-&gt;msi_base_shift, AFI_MSI_FPCI_BAR_ST);
 	afi_writel(pcie, msi-&gt;phys, AFI_MSI_AXI_BAR_ST);
<span class="p_chunk">@@ -1596,6 +1584,8 @@</span> <span class="p_context"> static int tegra_pcie_disable_msi(struct tegra_pcie *pcie)</span>
 	afi_writel(pcie, 0, AFI_MSI_EN_VEC6);
 	afi_writel(pcie, 0, AFI_MSI_EN_VEC7);
 
<span class="p_add">+	free_pages(msi-&gt;pages, 0);</span>
<span class="p_add">+</span>
 	if (msi-&gt;irq &gt; 0)
 		free_irq(msi-&gt;irq, pcie);
 
<span class="p_header">diff --git a/drivers/pinctrl/Kconfig b/drivers/pinctrl/Kconfig</span>
<span class="p_header">index e14b46c7b37f..8c054f5ccc11 100644</span>
<span class="p_header">--- a/drivers/pinctrl/Kconfig</span>
<span class="p_header">+++ b/drivers/pinctrl/Kconfig</span>
<span class="p_chunk">@@ -100,6 +100,7 @@</span> <span class="p_context"> config PINCTRL_AMD</span>
 	tristate &quot;AMD GPIO pin control&quot;
 	depends on GPIOLIB
 	select GPIOLIB_IRQCHIP
<span class="p_add">+	select PINMUX</span>
 	select PINCONF
 	select GENERIC_PINCONF
 	help
<span class="p_header">diff --git a/drivers/ras/cec.c b/drivers/ras/cec.c</span>
<span class="p_header">index d0e5d6ee882c..e2c1988cd7c0 100644</span>
<span class="p_header">--- a/drivers/ras/cec.c</span>
<span class="p_header">+++ b/drivers/ras/cec.c</span>
<span class="p_chunk">@@ -523,7 +523,7 @@</span> <span class="p_context"> int __init parse_cec_param(char *str)</span>
 	if (*str == &#39;=&#39;)
 		str++;
 
<span class="p_del">-	if (!strncmp(str, &quot;cec_disable&quot;, 7))</span>
<span class="p_add">+	if (!strcmp(str, &quot;cec_disable&quot;))</span>
 		ce_arr.disabled = 1;
 	else
 		return 0;
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index dd74c99d6ce1..5d061b3d8224 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -2026,6 +2026,8 @@</span> <span class="p_context"> static DEVICE_ATTR_RO(suspended);</span>
 static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)
 {
 	struct usb_composite_dev	*cdev = get_gadget_data(gadget);
<span class="p_add">+	struct usb_gadget_strings	*gstr = cdev-&gt;driver-&gt;strings[0];</span>
<span class="p_add">+	struct usb_string		*dev_str = gstr-&gt;strings;</span>
 
 	/* composite_disconnect() must already have been called
 	 * by the underlying peripheral controller driver!
<span class="p_chunk">@@ -2045,6 +2047,9 @@</span> <span class="p_context"> static void __composite_unbind(struct usb_gadget *gadget, bool unbind_driver)</span>
 
 	composite_dev_cleanup(cdev);
 
<span class="p_add">+	if (dev_str[USB_GADGET_MANUFACTURER_IDX].s == cdev-&gt;def_manufacturer)</span>
<span class="p_add">+		dev_str[USB_GADGET_MANUFACTURER_IDX].s = &quot;&quot;;</span>
<span class="p_add">+</span>
 	kfree(cdev-&gt;def_manufacturer);
 	kfree(cdev);
 	set_gadget_data(gadget, NULL);
<span class="p_header">diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c</span>
<span class="p_header">index a22a892de7b7..aeb9f3c40521 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/configfs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/configfs.c</span>
<span class="p_chunk">@@ -1143,11 +1143,12 @@</span> <span class="p_context"> static struct configfs_attribute *interf_grp_attrs[] = {</span>
 	NULL
 };
 
<span class="p_del">-int usb_os_desc_prepare_interf_dir(struct config_group *parent,</span>
<span class="p_del">-				   int n_interf,</span>
<span class="p_del">-				   struct usb_os_desc **desc,</span>
<span class="p_del">-				   char **names,</span>
<span class="p_del">-				   struct module *owner)</span>
<span class="p_add">+struct config_group *usb_os_desc_prepare_interf_dir(</span>
<span class="p_add">+		struct config_group *parent,</span>
<span class="p_add">+		int n_interf,</span>
<span class="p_add">+		struct usb_os_desc **desc,</span>
<span class="p_add">+		char **names,</span>
<span class="p_add">+		struct module *owner)</span>
 {
 	struct config_group *os_desc_group;
 	struct config_item_type *os_desc_type, *interface_type;
<span class="p_chunk">@@ -1159,7 +1160,7 @@</span> <span class="p_context"> int usb_os_desc_prepare_interf_dir(struct config_group *parent,</span>
 
 	char *vlabuf = kzalloc(vla_group_size(data_chunk), GFP_KERNEL);
 	if (!vlabuf)
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
 
 	os_desc_group = vla_ptr(vlabuf, data_chunk, os_desc_group);
 	os_desc_type = vla_ptr(vlabuf, data_chunk, os_desc_type);
<span class="p_chunk">@@ -1184,7 +1185,7 @@</span> <span class="p_context"> int usb_os_desc_prepare_interf_dir(struct config_group *parent,</span>
 		configfs_add_default_group(&amp;d-&gt;group, os_desc_group);
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return os_desc_group;</span>
 }
 EXPORT_SYMBOL(usb_os_desc_prepare_interf_dir);
 
<span class="p_header">diff --git a/drivers/usb/gadget/configfs.h b/drivers/usb/gadget/configfs.h</span>
<span class="p_header">index 36c468c4f5e9..540d5e92ed22 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/configfs.h</span>
<span class="p_header">+++ b/drivers/usb/gadget/configfs.h</span>
<span class="p_chunk">@@ -5,11 +5,12 @@</span> <span class="p_context"></span>
 
 void unregister_gadget_item(struct config_item *item);
 
<span class="p_del">-int usb_os_desc_prepare_interf_dir(struct config_group *parent,</span>
<span class="p_del">-				   int n_interf,</span>
<span class="p_del">-				   struct usb_os_desc **desc,</span>
<span class="p_del">-				   char **names,</span>
<span class="p_del">-				   struct module *owner);</span>
<span class="p_add">+struct config_group *usb_os_desc_prepare_interf_dir(</span>
<span class="p_add">+		struct config_group *parent,</span>
<span class="p_add">+		int n_interf,</span>
<span class="p_add">+		struct usb_os_desc **desc,</span>
<span class="p_add">+		char **names,</span>
<span class="p_add">+		struct module *owner);</span>
 
 static inline struct usb_os_desc *to_usb_os_desc(struct config_item *item)
 {
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_rndis.c b/drivers/usb/gadget/function/f_rndis.c</span>
<span class="p_header">index 16562e461121..ba00cdb809d6 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_rndis.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_rndis.c</span>
<span class="p_chunk">@@ -892,6 +892,7 @@</span> <span class="p_context"> static void rndis_free_inst(struct usb_function_instance *f)</span>
 			free_netdev(opts-&gt;net);
 	}
 
<span class="p_add">+	kfree(opts-&gt;rndis_interf_group);	/* single VLA chunk */</span>
 	kfree(opts);
 }
 
<span class="p_chunk">@@ -900,6 +901,7 @@</span> <span class="p_context"> static struct usb_function_instance *rndis_alloc_inst(void)</span>
 	struct f_rndis_opts *opts;
 	struct usb_os_desc *descs[1];
 	char *names[1];
<span class="p_add">+	struct config_group *rndis_interf_group;</span>
 
 	opts = kzalloc(sizeof(*opts), GFP_KERNEL);
 	if (!opts)
<span class="p_chunk">@@ -920,8 +922,14 @@</span> <span class="p_context"> static struct usb_function_instance *rndis_alloc_inst(void)</span>
 	names[0] = &quot;rndis&quot;;
 	config_group_init_type_name(&amp;opts-&gt;func_inst.group, &quot;&quot;,
 				    &amp;rndis_func_type);
<span class="p_del">-	usb_os_desc_prepare_interf_dir(&amp;opts-&gt;func_inst.group, 1, descs,</span>
<span class="p_del">-				       names, THIS_MODULE);</span>
<span class="p_add">+	rndis_interf_group =</span>
<span class="p_add">+		usb_os_desc_prepare_interf_dir(&amp;opts-&gt;func_inst.group, 1, descs,</span>
<span class="p_add">+					       names, THIS_MODULE);</span>
<span class="p_add">+	if (IS_ERR(rndis_interf_group)) {</span>
<span class="p_add">+		rndis_free_inst(&amp;opts-&gt;func_inst);</span>
<span class="p_add">+		return ERR_CAST(rndis_interf_group);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	opts-&gt;rndis_interf_group = rndis_interf_group;</span>
 
 	return &amp;opts-&gt;func_inst;
 }
<span class="p_header">diff --git a/drivers/usb/gadget/function/u_rndis.h b/drivers/usb/gadget/function/u_rndis.h</span>
<span class="p_header">index 4eafd5050545..4e2ad04fe8d6 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/u_rndis.h</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/u_rndis.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> struct f_rndis_opts {</span>
 	bool				bound;
 	bool				borrowed_net;
 
<span class="p_add">+	struct config_group		*rndis_interf_group;</span>
 	struct usb_os_desc		rndis_os_desc;
 	char				rndis_ext_compat_id[16];
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index 374f85f612d9..1c6cfdf0457e 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -420,6 +420,7 @@</span> <span class="p_context"> static void set_link_state_by_speed(struct dummy_hcd *dum_hcd)</span>
 static void set_link_state(struct dummy_hcd *dum_hcd)
 {
 	struct dummy *dum = dum_hcd-&gt;dum;
<span class="p_add">+	unsigned int power_bit;</span>
 
 	dum_hcd-&gt;active = 0;
 	if (dum-&gt;pullup)
<span class="p_chunk">@@ -430,17 +431,19 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 			return;
 
 	set_link_state_by_speed(dum_hcd);
<span class="p_add">+	power_bit = (dummy_hcd_to_hcd(dum_hcd)-&gt;speed == HCD_USB3 ?</span>
<span class="p_add">+			USB_SS_PORT_STAT_POWER : USB_PORT_STAT_POWER);</span>
 
 	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_ENABLE) == 0 ||
 	     dum_hcd-&gt;active)
 		dum_hcd-&gt;resuming = 0;
 
 	/* Currently !connected or in reset */
<span class="p_del">-	if ((dum_hcd-&gt;port_status &amp; USB_PORT_STAT_CONNECTION) == 0 ||</span>
<span class="p_add">+	if ((dum_hcd-&gt;port_status &amp; power_bit) == 0 ||</span>
 			(dum_hcd-&gt;port_status &amp; USB_PORT_STAT_RESET) != 0) {
<span class="p_del">-		unsigned disconnect = USB_PORT_STAT_CONNECTION &amp;</span>
<span class="p_add">+		unsigned int disconnect = power_bit &amp;</span>
 				dum_hcd-&gt;old_status &amp; (~dum_hcd-&gt;port_status);
<span class="p_del">-		unsigned reset = USB_PORT_STAT_RESET &amp;</span>
<span class="p_add">+		unsigned int reset = USB_PORT_STAT_RESET &amp;</span>
 				(~dum_hcd-&gt;old_status) &amp; dum_hcd-&gt;port_status;
 
 		/* Report reset and disconnect events to the driver */
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index 68f26904c316..50285b01da92 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -857,9 +857,9 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 		fifo-&gt;name, usbhs_pipe_number(pipe), pkt-&gt;length, pkt-&gt;zero);
 
 	usbhs_pipe_running(pipe, 1);
<span class="p_del">-	usbhsf_dma_start(pipe, fifo);</span>
 	usbhs_pipe_set_trans_count_if_bulk(pipe, pkt-&gt;trans);
 	dma_async_issue_pending(chan);
<span class="p_add">+	usbhsf_dma_start(pipe, fifo);</span>
 	usbhs_pipe_enable(pipe);
 
 xfer_work_end:
<span class="p_header">diff --git a/drivers/usb/serial/console.c b/drivers/usb/serial/console.c</span>
<span class="p_header">index fdf89800ebc3..43a862a90a77 100644</span>
<span class="p_header">--- a/drivers/usb/serial/console.c</span>
<span class="p_header">+++ b/drivers/usb/serial/console.c</span>
<span class="p_chunk">@@ -186,6 +186,7 @@</span> <span class="p_context"> static int usb_console_setup(struct console *co, char *options)</span>
 	tty_kref_put(tty);
  reset_open_count:
 	port-&gt;port.count = 0;
<span class="p_add">+	info-&gt;port = NULL;</span>
 	usb_autopm_put_interface(serial-&gt;interface);
  error_get_interface:
 	usb_serial_put(serial);
<span class="p_chunk">@@ -265,7 +266,7 @@</span> <span class="p_context"> static struct console usbcons = {</span>
 
 void usb_serial_console_disconnect(struct usb_serial *serial)
 {
<span class="p_del">-	if (serial-&gt;port[0] == usbcons_info.port) {</span>
<span class="p_add">+	if (serial-&gt;port[0] &amp;&amp; serial-&gt;port[0] == usbcons_info.port) {</span>
 		usb_serial_console_exit();
 		usb_serial_put(serial);
 	}
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 2d945c9f975c..412f812522ee 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -177,6 +177,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1843, 0x0200) }, /* Vaisala USB Instrument Cable */
 	{ USB_DEVICE(0x18EF, 0xE00F) }, /* ELV USB-I2C-Interface */
 	{ USB_DEVICE(0x18EF, 0xE025) }, /* ELV Marble Sound Board 1 */
<span class="p_add">+	{ USB_DEVICE(0x18EF, 0xE032) }, /* ELV TFD500 Data Logger */</span>
 	{ USB_DEVICE(0x1901, 0x0190) }, /* GE B850 CP2105 Recorder interface */
 	{ USB_DEVICE(0x1901, 0x0193) }, /* GE B650 CP2104 PMC interface */
 	{ USB_DEVICE(0x1901, 0x0194) },	/* GE Healthcare Remote Alarm Box */
<span class="p_chunk">@@ -352,6 +353,7 @@</span> <span class="p_context"> static struct usb_serial_driver * const serial_drivers[] = {</span>
 #define CP210X_PARTNUM_CP2104	0x04
 #define CP210X_PARTNUM_CP2105	0x05
 #define CP210X_PARTNUM_CP2108	0x08
<span class="p_add">+#define CP210X_PARTNUM_UNKNOWN	0xFF</span>
 
 /* CP210X_GET_COMM_STATUS returns these 0x13 bytes */
 struct cp210x_comm_status {
<span class="p_chunk">@@ -1491,8 +1493,11 @@</span> <span class="p_context"> static int cp210x_attach(struct usb_serial *serial)</span>
 	result = cp210x_read_vendor_block(serial, REQTYPE_DEVICE_TO_HOST,
 					  CP210X_GET_PARTNUM, &amp;priv-&gt;partnum,
 					  sizeof(priv-&gt;partnum));
<span class="p_del">-	if (result &lt; 0)</span>
<span class="p_del">-		goto err_free_priv;</span>
<span class="p_add">+	if (result &lt; 0) {</span>
<span class="p_add">+		dev_warn(&amp;serial-&gt;interface-&gt;dev,</span>
<span class="p_add">+			 &quot;querying part number failed\n&quot;);</span>
<span class="p_add">+		priv-&gt;partnum = CP210X_PARTNUM_UNKNOWN;</span>
<span class="p_add">+	}</span>
 
 	usb_set_serial_data(serial, priv);
 
<span class="p_chunk">@@ -1505,10 +1510,6 @@</span> <span class="p_context"> static int cp210x_attach(struct usb_serial *serial)</span>
 	}
 
 	return 0;
<span class="p_del">-err_free_priv:</span>
<span class="p_del">-	kfree(priv);</span>
<span class="p_del">-</span>
<span class="p_del">-	return result;</span>
 }
 
 static void cp210x_disconnect(struct usb_serial *serial)
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 1cec03799cdf..49d1b2d4606d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -1015,6 +1015,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },
 	{ USB_DEVICE(TI_VID, TI_CC3200_LAUNCHPAD_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_BT_USB_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(CYPRESS_VID, CYPRESS_WICED_WL_USB_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 4fcf1cecb6d7..f9d15bd62785 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -609,6 +609,13 @@</span> <span class="p_context"></span>
 #define ADI_GNICE_PID		0xF000
 #define ADI_GNICEPLUS_PID	0xF001
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Cypress WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CYPRESS_VID			0x04B4</span>
<span class="p_add">+#define CYPRESS_WICED_BT_USB_PID	0x009B</span>
<span class="p_add">+#define CYPRESS_WICED_WL_USB_PID	0xF900</span>
<span class="p_add">+</span>
 /*
  * Microchip Technology, Inc.
  *
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 2a9944326210..db3d34c2c82e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -522,6 +522,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 
 /* TP-LINK Incorporated products */
 #define TPLINK_VENDOR_ID			0x2357
<span class="p_add">+#define TPLINK_PRODUCT_LTE			0x000D</span>
 #define TPLINK_PRODUCT_MA180			0x0201
 
 /* Changhong products */
<span class="p_chunk">@@ -2011,6 +2012,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE(CELLIENT_VENDOR_ID, CELLIENT_PRODUCT_MEN200) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600A) },
 	{ USB_DEVICE(PETATEL_VENDOR_ID, PETATEL_PRODUCT_NP10T_600E) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(TPLINK_VENDOR_ID, TPLINK_PRODUCT_LTE, 0xff, 0x00, 0x00) },	/* TP-Link LTE Module */</span>
 	{ USB_DEVICE(TPLINK_VENDOR_ID, TPLINK_PRODUCT_MA180),
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE(TPLINK_VENDOR_ID, 0x9000),					/* TP-Link MA260 */
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index ebc0beea69d6..eb9928963a53 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -174,6 +174,10 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x413c, 0x81b3)},	/* Dell Wireless 5809e Gobi(TM) 4G LTE Mobile Broadband Card (rev3) */
 	{DEVICE_SWI(0x413c, 0x81b5)},	/* Dell Wireless 5811e QDL */
 	{DEVICE_SWI(0x413c, 0x81b6)},	/* Dell Wireless 5811e QDL */
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81cf)},   /* Dell Wireless 5819 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d0)},   /* Dell Wireless 5819 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d1)},   /* Dell Wireless 5818 */</span>
<span class="p_add">+	{DEVICE_SWI(0x413c, 0x81d2)},   /* Dell Wireless 5818 */</span>
 
 	/* Huawei devices */
 	{DEVICE_HWI(0x03f0, 0x581d)},	/* HP lt4112 LTE/HSPA+ Gobi 4G Modem (Huawei me906e) */
<span class="p_header">diff --git a/fs/block_dev.c b/fs/block_dev.c</span>
<span class="p_header">index 9941dc8342df..3fbe75bdd257 100644</span>
<span class="p_header">--- a/fs/block_dev.c</span>
<span class="p_header">+++ b/fs/block_dev.c</span>
<span class="p_chunk">@@ -716,10 +716,12 @@</span> <span class="p_context"> int bdev_write_page(struct block_device *bdev, sector_t sector,</span>
 
 	set_page_writeback(page);
 	result = ops-&gt;rw_page(bdev, sector + get_start_sect(bdev), page, true);
<span class="p_del">-	if (result)</span>
<span class="p_add">+	if (result) {</span>
 		end_page_writeback(page);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		clean_page_buffers(page);</span>
 		unlock_page(page);
<span class="p_add">+	}</span>
 	blk_queue_exit(bdev-&gt;bd_queue);
 	return result;
 }
<span class="p_header">diff --git a/fs/direct-io.c b/fs/direct-io.c</span>
<span class="p_header">index 08cf27811e5a..ad379f082d83 100644</span>
<span class="p_header">--- a/fs/direct-io.c</span>
<span class="p_header">+++ b/fs/direct-io.c</span>
<span class="p_chunk">@@ -838,7 +838,8 @@</span> <span class="p_context"> submit_page_section(struct dio *dio, struct dio_submit *sdio, struct page *page,</span>
 	 */
 	if (sdio-&gt;boundary) {
 		ret = dio_send_cur_page(dio, sdio, map_bh);
<span class="p_del">-		dio_bio_submit(dio, sdio);</span>
<span class="p_add">+		if (sdio-&gt;bio)</span>
<span class="p_add">+			dio_bio_submit(dio, sdio);</span>
 		put_page(sdio-&gt;cur_page);
 		sdio-&gt;cur_page = NULL;
 	}
<span class="p_header">diff --git a/fs/mpage.c b/fs/mpage.c</span>
<span class="p_header">index 2e4c41ccb5c9..9feb169fbd5c 100644</span>
<span class="p_header">--- a/fs/mpage.c</span>
<span class="p_header">+++ b/fs/mpage.c</span>
<span class="p_chunk">@@ -468,6 +468,16 @@</span> <span class="p_context"> static void clean_buffers(struct page *page, unsigned first_unmapped)</span>
 		try_to_free_buffers(page);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * For situations where we want to clean all buffers attached to a page.</span>
<span class="p_add">+ * We don&#39;t need to calculate how many buffers are attached to the page,</span>
<span class="p_add">+ * we just need to specify a number larger than the maximum number of buffers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void clean_page_buffers(struct page *page)</span>
<span class="p_add">+{</span>
<span class="p_add">+	clean_buffers(page, ~0U);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __mpage_writepage(struct page *page, struct writeback_control *wbc,
 		      void *data)
 {
<span class="p_chunk">@@ -605,10 +615,8 @@</span> <span class="p_context"> static int __mpage_writepage(struct page *page, struct writeback_control *wbc,</span>
 	if (bio == NULL) {
 		if (first_unmapped == blocks_per_page) {
 			if (!bdev_write_page(bdev, blocks[0] &lt;&lt; (blkbits - 9),
<span class="p_del">-								page, wbc)) {</span>
<span class="p_del">-				clean_buffers(page, first_unmapped);</span>
<span class="p_add">+								page, wbc))</span>
 				goto out;
<span class="p_del">-			}</span>
 		}
 		bio = mpage_alloc(bdev, blocks[0] &lt;&lt; (blkbits - 9),
 				BIO_MAX_PAGES, GFP_NOFS|__GFP_HIGH);
<span class="p_header">diff --git a/fs/nfs/client.c b/fs/nfs/client.c</span>
<span class="p_header">index efebe6cf4378..22880ef6d8dd 100644</span>
<span class="p_header">--- a/fs/nfs/client.c</span>
<span class="p_header">+++ b/fs/nfs/client.c</span>
<span class="p_chunk">@@ -218,7 +218,6 @@</span> <span class="p_context"> static void nfs_cb_idr_remove_locked(struct nfs_client *clp)</span>
 static void pnfs_init_server(struct nfs_server *server)
 {
 	rpc_init_wait_queue(&amp;server-&gt;roc_rpcwaitq, &quot;pNFS ROC&quot;);
<span class="p_del">-	rpc_init_wait_queue(&amp;server-&gt;uoc_rpcwaitq, &quot;NFS UOC&quot;);</span>
 }
 
 #else
<span class="p_chunk">@@ -888,6 +887,7 @@</span> <span class="p_context"> struct nfs_server *nfs_alloc_server(void)</span>
 	ida_init(&amp;server-&gt;openowner_id);
 	ida_init(&amp;server-&gt;lockowner_id);
 	pnfs_init_server(server);
<span class="p_add">+	rpc_init_wait_queue(&amp;server-&gt;uoc_rpcwaitq, &quot;NFS UOC&quot;);</span>
 
 	return server;
 }
<span class="p_header">diff --git a/fs/nfs/filelayout/filelayout.c b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">index 44c638b7876c..508126eb49f9 100644</span>
<span class="p_header">--- a/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">+++ b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_chunk">@@ -745,7 +745,8 @@</span> <span class="p_context"> filelayout_free_lseg(struct pnfs_layout_segment *lseg)</span>
 	struct nfs4_filelayout_segment *fl = FILELAYOUT_LSEG(lseg);
 
 	dprintk(&quot;--&gt; %s\n&quot;, __func__);
<span class="p_del">-	nfs4_fl_put_deviceid(fl-&gt;dsaddr);</span>
<span class="p_add">+	if (fl-&gt;dsaddr != NULL)</span>
<span class="p_add">+		nfs4_fl_put_deviceid(fl-&gt;dsaddr);</span>
 	/* This assumes a single RW lseg */
 	if (lseg-&gt;pls_range.iomode == IOMODE_RW) {
 		struct nfs4_filelayout *flo;
<span class="p_header">diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h</span>
<span class="p_header">index c8dae555eccf..446b24cac67d 100644</span>
<span class="p_header">--- a/include/linux/buffer_head.h</span>
<span class="p_header">+++ b/include/linux/buffer_head.h</span>
<span class="p_chunk">@@ -232,6 +232,7 @@</span> <span class="p_context"> int generic_write_end(struct file *, struct address_space *,</span>
 				loff_t, unsigned, unsigned,
 				struct page *, void *);
 void page_zero_new_buffers(struct page *page, unsigned from, unsigned to);
<span class="p_add">+void clean_page_buffers(struct page *page);</span>
 int cont_write_begin(struct file *, struct address_space *, loff_t,
 			unsigned, unsigned, struct page **, void **,
 			get_block_t *, loff_t *);
<span class="p_header">diff --git a/include/sound/seq_virmidi.h b/include/sound/seq_virmidi.h</span>
<span class="p_header">index a03acd0d398a..695257ae64ac 100644</span>
<span class="p_header">--- a/include/sound/seq_virmidi.h</span>
<span class="p_header">+++ b/include/sound/seq_virmidi.h</span>
<span class="p_chunk">@@ -60,6 +60,7 @@</span> <span class="p_context"> struct snd_virmidi_dev {</span>
 	int port;			/* created/attached port */
 	unsigned int flags;		/* SNDRV_VIRMIDI_* */
 	rwlock_t filelist_lock;
<span class="p_add">+	struct rw_semaphore filelist_sem;</span>
 	struct list_head filelist;
 };
 
<span class="p_header">diff --git a/kernel/irq/chip.c b/kernel/irq/chip.c</span>
<span class="p_header">index 75a70a267029..406fc428d580 100644</span>
<span class="p_header">--- a/kernel/irq/chip.c</span>
<span class="p_header">+++ b/kernel/irq/chip.c</span>
<span class="p_chunk">@@ -265,8 +265,8 @@</span> <span class="p_context"> int irq_startup(struct irq_desc *desc, bool resend, bool force)</span>
 			irq_setup_affinity(desc);
 			break;
 		case IRQ_STARTUP_MANAGED:
<span class="p_add">+			irq_do_set_affinity(d, aff, false);</span>
 			ret = __irq_startup(desc);
<span class="p_del">-			irq_set_affinity_locked(d, aff, false);</span>
 			break;
 		case IRQ_STARTUP_ABORT:
 			return 0;
<span class="p_header">diff --git a/kernel/irq/cpuhotplug.c b/kernel/irq/cpuhotplug.c</span>
<span class="p_header">index 638eb9c83d9f..9eb09aef0313 100644</span>
<span class="p_header">--- a/kernel/irq/cpuhotplug.c</span>
<span class="p_header">+++ b/kernel/irq/cpuhotplug.c</span>
<span class="p_chunk">@@ -18,8 +18,34 @@</span> <span class="p_context"></span>
 static inline bool irq_needs_fixup(struct irq_data *d)
 {
 	const struct cpumask *m = irq_data_get_effective_affinity_mask(d);
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
 
<span class="p_del">-	return cpumask_test_cpu(smp_processor_id(), m);</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_IRQ_EFFECTIVE_AFF_MASK</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The cpumask_empty() check is a workaround for interrupt chips,</span>
<span class="p_add">+	 * which do not implement effective affinity, but the architecture has</span>
<span class="p_add">+	 * enabled the config switch. Use the general affinity mask instead.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpumask_empty(m))</span>
<span class="p_add">+		m = irq_data_get_affinity_mask(d);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Sanity check. If the mask is not empty when excluding the outgoing</span>
<span class="p_add">+	 * CPU then it must contain at least one online CPU. The outgoing CPU</span>
<span class="p_add">+	 * has been removed from the online mask already.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpumask_any_but(m, cpu) &lt; nr_cpu_ids &amp;&amp;</span>
<span class="p_add">+	    cpumask_any_and(m, cpu_online_mask) &gt;= nr_cpu_ids) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If this happens then there was a missed IRQ fixup at some</span>
<span class="p_add">+		 * point. Warn about it and enforce fixup.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pr_warn(&quot;Eff. affinity %*pbl of IRQ %u contains only offline CPUs after offlining CPU %u\n&quot;,</span>
<span class="p_add">+			cpumask_pr_args(m), d-&gt;irq, cpu);</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return cpumask_test_cpu(cpu, m);</span>
 }
 
 static bool migrate_one_irq(struct irq_desc *desc)
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index 1d1a5b945ab4..70dc8da8737f 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -175,6 +175,9 @@</span> <span class="p_context"> int irq_do_set_affinity(struct irq_data *data, const struct cpumask *mask,</span>
 	struct irq_chip *chip = irq_data_get_irq_chip(data);
 	int ret;
 
<span class="p_add">+	if (!chip || !chip-&gt;irq_set_affinity)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	ret = chip-&gt;irq_set_affinity(data, mask, force);
 	switch (ret) {
 	case IRQ_SET_MASK_OK:
<span class="p_header">diff --git a/mm/vmalloc.c b/mm/vmalloc.c</span>
<span class="p_header">index a47e3894c775..ceacc6e01904 100644</span>
<span class="p_header">--- a/mm/vmalloc.c</span>
<span class="p_header">+++ b/mm/vmalloc.c</span>
<span class="p_chunk">@@ -1697,11 +1697,6 @@</span> <span class="p_context"> static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,</span>
 	for (i = 0; i &lt; area-&gt;nr_pages; i++) {
 		struct page *page;
 
<span class="p_del">-		if (fatal_signal_pending(current)) {</span>
<span class="p_del">-			area-&gt;nr_pages = i;</span>
<span class="p_del">-			goto fail_no_warn;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		if (node == NUMA_NO_NODE)
 			page = alloc_page(alloc_mask|highmem_mask);
 		else
<span class="p_chunk">@@ -1725,7 +1720,6 @@</span> <span class="p_context"> static void *__vmalloc_area_node(struct vm_struct *area, gfp_t gfp_mask,</span>
 	warn_alloc(gfp_mask, NULL,
 			  &quot;vmalloc: allocation failure, allocated %ld of %ld bytes&quot;,
 			  (area-&gt;nr_pages*PAGE_SIZE), area-&gt;size);
<span class="p_del">-fail_no_warn:</span>
 	vfree(area-&gt;addr);
 	return NULL;
 }
<span class="p_header">diff --git a/sound/core/seq/seq_clientmgr.c b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">index ea2d0ae85bd3..6c9cba2166d9 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_clientmgr.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_clientmgr.c</span>
<span class="p_chunk">@@ -1259,6 +1259,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)</span>
 	struct snd_seq_port_info *info = arg;
 	struct snd_seq_client_port *port;
 	struct snd_seq_port_callback *callback;
<span class="p_add">+	int port_idx;</span>
 
 	/* it is not allowed to create the port for an another client */
 	if (info-&gt;addr.client != client-&gt;number)
<span class="p_chunk">@@ -1269,7 +1270,9 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)</span>
 		return -ENOMEM;
 
 	if (client-&gt;type == USER_CLIENT &amp;&amp; info-&gt;kernel) {
<span class="p_del">-		snd_seq_delete_port(client, port-&gt;addr.port);</span>
<span class="p_add">+		port_idx = port-&gt;addr.port;</span>
<span class="p_add">+		snd_seq_port_unlock(port);</span>
<span class="p_add">+		snd_seq_delete_port(client, port_idx);</span>
 		return -EINVAL;
 	}
 	if (client-&gt;type == KERNEL_CLIENT) {
<span class="p_chunk">@@ -1290,6 +1293,7 @@</span> <span class="p_context"> static int snd_seq_ioctl_create_port(struct snd_seq_client *client, void *arg)</span>
 
 	snd_seq_set_port_info(port, info);
 	snd_seq_system_client_ev_port_start(port-&gt;addr.client, port-&gt;addr.port);
<span class="p_add">+	snd_seq_port_unlock(port);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c</span>
<span class="p_header">index 0a7020c82bfc..d21ece9f8d73 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_ports.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_ports.c</span>
<span class="p_chunk">@@ -122,7 +122,9 @@</span> <span class="p_context"> static void port_subs_info_init(struct snd_seq_port_subs_info *grp)</span>
 }
 
 
<span class="p_del">-/* create a port, port number is returned (-1 on failure) */</span>
<span class="p_add">+/* create a port, port number is returned (-1 on failure);</span>
<span class="p_add">+ * the caller needs to unref the port via snd_seq_port_unlock() appropriately</span>
<span class="p_add">+ */</span>
 struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,
 						int port)
 {
<span class="p_chunk">@@ -151,6 +153,7 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	snd_use_lock_init(&amp;new_port-&gt;use_lock);
 	port_subs_info_init(&amp;new_port-&gt;c_src);
 	port_subs_info_init(&amp;new_port-&gt;c_dest);
<span class="p_add">+	snd_use_lock_use(&amp;new_port-&gt;use_lock);</span>
 
 	num = port &gt;= 0 ? port : 0;
 	mutex_lock(&amp;client-&gt;ports_mutex);
<span class="p_chunk">@@ -165,9 +168,9 @@</span> <span class="p_context"> struct snd_seq_client_port *snd_seq_create_port(struct snd_seq_client *client,</span>
 	list_add_tail(&amp;new_port-&gt;list, &amp;p-&gt;list);
 	client-&gt;num_ports++;
 	new_port-&gt;addr.port = num;	/* store the port number in the port */
<span class="p_add">+	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 	write_unlock_irqrestore(&amp;client-&gt;ports_lock, flags);
 	mutex_unlock(&amp;client-&gt;ports_mutex);
<span class="p_del">-	sprintf(new_port-&gt;name, &quot;port-%d&quot;, num);</span>
 
 	return new_port;
 }
<span class="p_header">diff --git a/sound/core/seq/seq_virmidi.c b/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">index 8d93a4021c78..f48a4cd24ffc 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_virmidi.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_virmidi.c</span>
<span class="p_chunk">@@ -77,13 +77,17 @@</span> <span class="p_context"> static void snd_virmidi_init_event(struct snd_virmidi *vmidi,</span>
  * decode input event and put to read buffer of each opened file
  */
 static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,
<span class="p_del">-					 struct snd_seq_event *ev)</span>
<span class="p_add">+					 struct snd_seq_event *ev,</span>
<span class="p_add">+					 bool atomic)</span>
 {
 	struct snd_virmidi *vmidi;
 	unsigned char msg[4];
 	int len;
 
<span class="p_del">-	read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_lock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		down_read(&amp;rdev-&gt;filelist_sem);</span>
 	list_for_each_entry(vmidi, &amp;rdev-&gt;filelist, list) {
 		if (!vmidi-&gt;trigger)
 			continue;
<span class="p_chunk">@@ -97,7 +101,10 @@</span> <span class="p_context"> static int snd_virmidi_dev_receive_event(struct snd_virmidi_dev *rdev,</span>
 				snd_rawmidi_receive(vmidi-&gt;substream, msg, len);
 		}
 	}
<span class="p_del">-	read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	if (atomic)</span>
<span class="p_add">+		read_unlock(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		up_read(&amp;rdev-&gt;filelist_sem);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -115,7 +122,7 @@</span> <span class="p_context"> int snd_virmidi_receive(struct snd_rawmidi *rmidi, struct snd_seq_event *ev)</span>
 	struct snd_virmidi_dev *rdev;
 
 	rdev = rmidi-&gt;private_data;
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, true);</span>
 }
 #endif  /*  0  */
 
<span class="p_chunk">@@ -130,7 +137,7 @@</span> <span class="p_context"> static int snd_virmidi_event_input(struct snd_seq_event *ev, int direct,</span>
 	rdev = private_data;
 	if (!(rdev-&gt;flags &amp; SNDRV_VIRMIDI_USE))
 		return 0; /* ignored */
<span class="p_del">-	return snd_virmidi_dev_receive_event(rdev, ev);</span>
<span class="p_add">+	return snd_virmidi_dev_receive_event(rdev, ev, atomic);</span>
 }
 
 /*
<span class="p_chunk">@@ -209,7 +216,6 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_rawmidi_runtime *runtime = substream-&gt;runtime;
 	struct snd_virmidi *vmidi;
<span class="p_del">-	unsigned long flags;</span>
 
 	vmidi = kzalloc(sizeof(*vmidi), GFP_KERNEL);
 	if (vmidi == NULL)
<span class="p_chunk">@@ -223,9 +229,11 @@</span> <span class="p_context"> static int snd_virmidi_input_open(struct snd_rawmidi_substream *substream)</span>
 	vmidi-&gt;client = rdev-&gt;client;
 	vmidi-&gt;port = rdev-&gt;port;	
 	runtime-&gt;private_data = vmidi;
<span class="p_del">-	write_lock_irqsave(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
<span class="p_add">+	write_lock_irq(&amp;rdev-&gt;filelist_lock);</span>
 	list_add_tail(&amp;vmidi-&gt;list, &amp;rdev-&gt;filelist);
<span class="p_del">-	write_unlock_irqrestore(&amp;rdev-&gt;filelist_lock, flags);</span>
<span class="p_add">+	write_unlock_irq(&amp;rdev-&gt;filelist_lock);</span>
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	vmidi-&gt;rdev = rdev;
 	return 0;
 }
<span class="p_chunk">@@ -264,9 +272,11 @@</span> <span class="p_context"> static int snd_virmidi_input_close(struct snd_rawmidi_substream *substream)</span>
 	struct snd_virmidi_dev *rdev = substream-&gt;rmidi-&gt;private_data;
 	struct snd_virmidi *vmidi = substream-&gt;runtime-&gt;private_data;
 
<span class="p_add">+	down_write(&amp;rdev-&gt;filelist_sem);</span>
 	write_lock_irq(&amp;rdev-&gt;filelist_lock);
 	list_del(&amp;vmidi-&gt;list);
 	write_unlock_irq(&amp;rdev-&gt;filelist_lock);
<span class="p_add">+	up_write(&amp;rdev-&gt;filelist_sem);</span>
 	snd_midi_event_free(vmidi-&gt;parser);
 	substream-&gt;runtime-&gt;private_data = NULL;
 	kfree(vmidi);
<span class="p_chunk">@@ -520,6 +530,7 @@</span> <span class="p_context"> int snd_virmidi_new(struct snd_card *card, int device, struct snd_rawmidi **rrmi</span>
 	rdev-&gt;rmidi = rmidi;
 	rdev-&gt;device = device;
 	rdev-&gt;client = -1;
<span class="p_add">+	init_rwsem(&amp;rdev-&gt;filelist_sem);</span>
 	rwlock_init(&amp;rdev-&gt;filelist_lock);
 	INIT_LIST_HEAD(&amp;rdev-&gt;filelist);
 	rdev-&gt;seq_mode = SNDRV_VIRMIDI_SEQ_DISPATCH;
<span class="p_header">diff --git a/sound/usb/caiaq/device.c b/sound/usb/caiaq/device.c</span>
<span class="p_header">index b871ba407e4e..4458190149d1 100644</span>
<span class="p_header">--- a/sound/usb/caiaq/device.c</span>
<span class="p_header">+++ b/sound/usb/caiaq/device.c</span>
<span class="p_chunk">@@ -469,10 +469,12 @@</span> <span class="p_context"> static int init_card(struct snd_usb_caiaqdev *cdev)</span>
 
 	err = snd_usb_caiaq_send_command(cdev, EP1_CMD_GET_DEVICE_INFO, NULL, 0);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto err_kill_urb;</span>
 
<span class="p_del">-	if (!wait_event_timeout(cdev-&gt;ep1_wait_queue, cdev-&gt;spec_received, HZ))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (!wait_event_timeout(cdev-&gt;ep1_wait_queue, cdev-&gt;spec_received, HZ)) {</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto err_kill_urb;</span>
<span class="p_add">+	}</span>
 
 	usb_string(usb_dev, usb_dev-&gt;descriptor.iManufacturer,
 		   cdev-&gt;vendor_name, CAIAQ_USB_STR_LEN);
<span class="p_chunk">@@ -507,6 +509,10 @@</span> <span class="p_context"> static int init_card(struct snd_usb_caiaqdev *cdev)</span>
 
 	setup_card(cdev);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+ err_kill_urb:</span>
<span class="p_add">+	usb_kill_urb(&amp;cdev-&gt;ep1_in_urb);</span>
<span class="p_add">+	return err;</span>
 }
 
 static int snd_probe(struct usb_interface *intf,
<span class="p_header">diff --git a/sound/usb/line6/driver.c b/sound/usb/line6/driver.c</span>
<span class="p_header">index 0ff5a7d2e19f..c8f723c3a033 100644</span>
<span class="p_header">--- a/sound/usb/line6/driver.c</span>
<span class="p_header">+++ b/sound/usb/line6/driver.c</span>
<span class="p_chunk">@@ -779,9 +779,10 @@</span> <span class="p_context"> int line6_probe(struct usb_interface *interface,</span>
 	return 0;
 
  error:
<span class="p_del">-	if (line6-&gt;disconnect)</span>
<span class="p_del">-		line6-&gt;disconnect(line6);</span>
<span class="p_del">-	snd_card_free(card);</span>
<span class="p_add">+	/* we can call disconnect callback here because no close-sync is</span>
<span class="p_add">+	 * needed yet at this point</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	line6_disconnect(interface);</span>
 	return ret;
 }
 EXPORT_SYMBOL_GPL(line6_probe);
<span class="p_header">diff --git a/sound/usb/line6/podhd.c b/sound/usb/line6/podhd.c</span>
<span class="p_header">index 956f847a96e4..451007c27743 100644</span>
<span class="p_header">--- a/sound/usb/line6/podhd.c</span>
<span class="p_header">+++ b/sound/usb/line6/podhd.c</span>
<span class="p_chunk">@@ -301,7 +301,8 @@</span> <span class="p_context"> static void podhd_disconnect(struct usb_line6 *line6)</span>
 
 		intf = usb_ifnum_to_if(line6-&gt;usbdev,
 					pod-&gt;line6.properties-&gt;ctrl_if);
<span class="p_del">-		usb_driver_release_interface(&amp;podhd_driver, intf);</span>
<span class="p_add">+		if (intf)</span>
<span class="p_add">+			usb_driver_release_interface(&amp;podhd_driver, intf);</span>
 	}
 }
 
<span class="p_chunk">@@ -317,6 +318,9 @@</span> <span class="p_context"> static int podhd_init(struct usb_line6 *line6,</span>
 
 	line6-&gt;disconnect = podhd_disconnect;
 
<span class="p_add">+	init_timer(&amp;pod-&gt;startup_timer);</span>
<span class="p_add">+	INIT_WORK(&amp;pod-&gt;startup_work, podhd_startup_workqueue);</span>
<span class="p_add">+</span>
 	if (pod-&gt;line6.properties-&gt;capabilities &amp; LINE6_CAP_CONTROL) {
 		/* claim the data interface */
 		intf = usb_ifnum_to_if(line6-&gt;usbdev,
<span class="p_chunk">@@ -358,8 +362,6 @@</span> <span class="p_context"> static int podhd_init(struct usb_line6 *line6,</span>
 	}
 
 	/* init device and delay registering */
<span class="p_del">-	init_timer(&amp;pod-&gt;startup_timer);</span>
<span class="p_del">-	INIT_WORK(&amp;pod-&gt;startup_work, podhd_startup_workqueue);</span>
 	podhd_startup(pod);
 	return 0;
 }
<span class="p_header">diff --git a/sound/usb/mixer.c b/sound/usb/mixer.c</span>
<span class="p_header">index e630813c5008..a08e90566edc 100644</span>
<span class="p_header">--- a/sound/usb/mixer.c</span>
<span class="p_header">+++ b/sound/usb/mixer.c</span>
<span class="p_chunk">@@ -2228,6 +2228,9 @@</span> <span class="p_context"> static int parse_audio_unit(struct mixer_build *state, int unitid)</span>
 
 static void snd_usb_mixer_free(struct usb_mixer_interface *mixer)
 {
<span class="p_add">+	/* kill pending URBs */</span>
<span class="p_add">+	snd_usb_mixer_disconnect(mixer);</span>
<span class="p_add">+</span>
 	kfree(mixer-&gt;id_elems);
 	if (mixer-&gt;urb) {
 		kfree(mixer-&gt;urb-&gt;transfer_buffer);
<span class="p_chunk">@@ -2578,8 +2581,13 @@</span> <span class="p_context"> int snd_usb_create_mixer(struct snd_usb_audio *chip, int ctrlif,</span>
 
 void snd_usb_mixer_disconnect(struct usb_mixer_interface *mixer)
 {
<span class="p_del">-	usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_del">-	usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	if (mixer-&gt;disconnected)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	if (mixer-&gt;urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;urb);</span>
<span class="p_add">+	if (mixer-&gt;rc_urb)</span>
<span class="p_add">+		usb_kill_urb(mixer-&gt;rc_urb);</span>
<span class="p_add">+	mixer-&gt;disconnected = true;</span>
 }
 
 #ifdef CONFIG_PM
<span class="p_header">diff --git a/sound/usb/mixer.h b/sound/usb/mixer.h</span>
<span class="p_header">index 2b4b067646ab..545d99b09706 100644</span>
<span class="p_header">--- a/sound/usb/mixer.h</span>
<span class="p_header">+++ b/sound/usb/mixer.h</span>
<span class="p_chunk">@@ -22,6 +22,8 @@</span> <span class="p_context"> struct usb_mixer_interface {</span>
 	struct urb *rc_urb;
 	struct usb_ctrlrequest *rc_setup_packet;
 	u8 rc_buffer[6];
<span class="p_add">+</span>
<span class="p_add">+	bool disconnected;</span>
 };
 
 #define MAX_CHANNELS	16	/* max logical channels */
<span class="p_header">diff --git a/tools/perf/builtin-script.c b/tools/perf/builtin-script.c</span>
<span class="p_header">index 83cdc0a61fd6..88a484c273e8 100644</span>
<span class="p_header">--- a/tools/perf/builtin-script.c</span>
<span class="p_header">+++ b/tools/perf/builtin-script.c</span>
<span class="p_chunk">@@ -578,7 +578,7 @@</span> <span class="p_context"> static void print_sample_brstack(struct perf_sample *sample,</span>
 			thread__find_addr_map(thread, sample-&gt;cpumode, MAP__FUNCTION, to, &amp;alt);
 		}
 
<span class="p_del">-		printf(&quot;0x%&quot;PRIx64, from);</span>
<span class="p_add">+		printf(&quot; 0x%&quot;PRIx64, from);</span>
 		if (PRINT_FIELD(DSO)) {
 			printf(&quot;(&quot;);
 			map__fprintf_dsoname(alf.map, stdout);
<span class="p_chunk">@@ -673,7 +673,7 @@</span> <span class="p_context"> static void print_sample_brstackoff(struct perf_sample *sample,</span>
 		if (alt.map &amp;&amp; !alt.map-&gt;dso-&gt;adjust_symbols)
 			to = map__map_ip(alt.map, to);
 
<span class="p_del">-		printf(&quot;0x%&quot;PRIx64, from);</span>
<span class="p_add">+		printf(&quot; 0x%&quot;PRIx64, from);</span>
 		if (PRINT_FIELD(DSO)) {
 			printf(&quot;(&quot;);
 			map__fprintf_dsoname(alf.map, stdout);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



