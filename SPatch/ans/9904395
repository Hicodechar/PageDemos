
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,2/2] x86/lguest: remove lguest support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,2/2] x86/lguest: remove lguest support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=100191">Juergen Gross</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 16, 2017, 5:31 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170816173157.8633-3-jgross@suse.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9904395/mbox/"
   >mbox</a>
|
   <a href="/patch/9904395/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9904395/">/patch/9904395/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	088C660244 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 16 Aug 2017 17:32:44 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C451D2892D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 16 Aug 2017 17:32:43 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B67B128A50; Wed, 16 Aug 2017 17:32:43 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 41B5D2892D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 16 Aug 2017 17:32:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752516AbdHPRcY (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 16 Aug 2017 13:32:24 -0400
Received: from mx2.suse.de ([195.135.220.15]:52206 &quot;EHLO mx1.suse.de&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1752272AbdHPRcG (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 16 Aug 2017 13:32:06 -0400
X-Virus-Scanned: by amavisd-new at test-mx.suse.de
Received: from relay1.suse.de (charybdis-ext.suse.de [195.135.220.254])
	by mx1.suse.de (Postfix) with ESMTP id E0CECAF11;
	Wed, 16 Aug 2017 17:32:02 +0000 (UTC)
From: Juergen Gross &lt;jgross@suse.com&gt;
To: linux-kernel@vger.kernel.org, xen-devel@lists.xenproject.org,
	x86@kernel.org, lguest@lists.ozlabs.org
Cc: boris.ostrovsky@oracle.com, hpa@zytor.com, tglx@linutronix.de,
	mingo@redhat.com, rusty@rustcorp.com.au, Juergen Gross &lt;jgross@suse.com&gt;
Subject: [PATCH v2 2/2] x86/lguest: remove lguest support
Date: Wed, 16 Aug 2017 19:31:57 +0200
Message-Id: &lt;20170816173157.8633-3-jgross@suse.com&gt;
X-Mailer: git-send-email 2.12.3
In-Reply-To: &lt;20170816173157.8633-1-jgross@suse.com&gt;
References: &lt;20170816173157.8633-1-jgross@suse.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=100191">Juergen Gross</a> - Aug. 16, 2017, 5:31 p.m.</div>
<pre class="content">
Lguest seems to be rather unused these days. It has seen only patches
ensuring it still builds the last two years and its official state is
&quot;Odd Fixes&quot;.

Nuke it in order to be able to clean up the paravirt code.
<span class="signed-off-by">
Signed-off-by: Juergen Gross &lt;jgross@suse.com&gt;</span>
---
 MAINTAINERS                           |   11 -
 arch/x86/Kbuild                       |    3 -
 arch/x86/Kconfig                      |    2 -
 arch/x86/include/asm/lguest.h         |   91 -
 arch/x86/include/asm/lguest_hcall.h   |   74 -
 arch/x86/include/asm/processor.h      |    2 +-
 arch/x86/include/uapi/asm/bootparam.h |    2 +-
 arch/x86/kernel/asm-offsets_32.c      |   20 -
 arch/x86/kernel/head_32.S             |    2 -
 arch/x86/kernel/platform-quirks.c     |    1 -
 arch/x86/kvm/Kconfig                  |    1 -
 arch/x86/lguest/Kconfig               |   14 -
 arch/x86/lguest/Makefile              |    2 -
 arch/x86/lguest/boot.c                | 1558 ---------------
 arch/x86/lguest/head_32.S             |  192 --
 drivers/Makefile                      |    1 -
 drivers/block/Kconfig                 |    2 +-
 drivers/char/Kconfig                  |    2 +-
 drivers/char/virtio_console.c         |    2 +-
 drivers/lguest/Kconfig                |   13 -
 drivers/lguest/Makefile               |   26 -
 drivers/lguest/README                 |   47 -
 drivers/lguest/core.c                 |  398 ----
 drivers/lguest/hypercalls.c           |  304 ---
 drivers/lguest/interrupts_and_traps.c |  706 -------
 drivers/lguest/lg.h                   |  258 ---
 drivers/lguest/lguest_user.c          |  446 -----
 drivers/lguest/page_tables.c          | 1239 ------------
 drivers/lguest/segments.c             |  228 ---
 drivers/lguest/x86/core.c             |  724 -------
 drivers/lguest/x86/switcher_32.S      |  388 ----
 drivers/net/Kconfig                   |    2 +-
 drivers/tty/hvc/Kconfig               |    2 +-
 drivers/virtio/Kconfig                |    4 +-
 include/linux/lguest.h                |   73 -
 include/linux/lguest_launcher.h       |   44 -
 include/uapi/linux/virtio_ring.h      |    4 +-
 tools/Makefile                        |   11 +-
 tools/lguest/.gitignore               |    2 -
 tools/lguest/Makefile                 |   14 -
 tools/lguest/extract                  |   58 -
 tools/lguest/lguest.c                 | 3420 ---------------------------------
 tools/lguest/lguest.txt               |  125 --
 43 files changed, 16 insertions(+), 10502 deletions(-)
 delete mode 100644 arch/x86/include/asm/lguest.h
 delete mode 100644 arch/x86/include/asm/lguest_hcall.h
 delete mode 100644 arch/x86/lguest/Kconfig
 delete mode 100644 arch/x86/lguest/Makefile
 delete mode 100644 arch/x86/lguest/boot.c
 delete mode 100644 arch/x86/lguest/head_32.S
 delete mode 100644 drivers/lguest/Kconfig
 delete mode 100644 drivers/lguest/Makefile
 delete mode 100644 drivers/lguest/README
 delete mode 100644 drivers/lguest/core.c
 delete mode 100644 drivers/lguest/hypercalls.c
 delete mode 100644 drivers/lguest/interrupts_and_traps.c
 delete mode 100644 drivers/lguest/lg.h
 delete mode 100644 drivers/lguest/lguest_user.c
 delete mode 100644 drivers/lguest/page_tables.c
 delete mode 100644 drivers/lguest/segments.c
 delete mode 100644 drivers/lguest/x86/core.c
 delete mode 100644 drivers/lguest/x86/switcher_32.S
 delete mode 100644 include/linux/lguest.h
 delete mode 100644 include/linux/lguest_launcher.h
 delete mode 100644 tools/lguest/.gitignore
 delete mode 100644 tools/lguest/Makefile
 delete mode 100644 tools/lguest/extract
 delete mode 100644 tools/lguest/lguest.c
 delete mode 100644 tools/lguest/lguest.txt
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 6f7721d1634c..60128e3a7052 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -7640,17 +7640,6 @@</span> <span class="p_context"> T:	git git://linuxtv.org/mkrufky/tuners.git</span>
 S:	Maintained
 F:	drivers/media/dvb-frontends/lgdt3305.*
 
<span class="p_del">-LGUEST</span>
<span class="p_del">-M:	Rusty Russell &lt;rusty@rustcorp.com.au&gt;</span>
<span class="p_del">-L:	lguest@lists.ozlabs.org</span>
<span class="p_del">-W:	http://lguest.ozlabs.org/</span>
<span class="p_del">-S:	Odd Fixes</span>
<span class="p_del">-F:	arch/x86/include/asm/lguest*.h</span>
<span class="p_del">-F:	arch/x86/lguest/</span>
<span class="p_del">-F:	drivers/lguest/</span>
<span class="p_del">-F:	include/linux/lguest*.h</span>
<span class="p_del">-F:	tools/lguest/</span>
<span class="p_del">-</span>
 LIBATA PATA ARASAN COMPACT FLASH CONTROLLER
 M:	Viresh Kumar &lt;vireshk@kernel.org&gt;
 L:	linux-ide@vger.kernel.org
<span class="p_header">diff --git a/arch/x86/Kbuild b/arch/x86/Kbuild</span>
<span class="p_header">index 586b786b3edf..f65a804b86f0 100644</span>
<span class="p_header">--- a/arch/x86/Kbuild</span>
<span class="p_header">+++ b/arch/x86/Kbuild</span>
<span class="p_chunk">@@ -10,9 +10,6 @@</span> <span class="p_context"> obj-$(CONFIG_XEN) += xen/</span>
 # Hyper-V paravirtualization support
 obj-$(CONFIG_HYPERVISOR_GUEST) += hyperv/
 
<span class="p_del">-# lguest paravirtualization support</span>
<span class="p_del">-obj-$(CONFIG_LGUEST_GUEST) += lguest/</span>
<span class="p_del">-</span>
 obj-y += realmode/
 obj-y += kernel/
 obj-y += mm/
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 781521b7cf9e..3fac2570a2e1 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -777,8 +777,6 @@</span> <span class="p_context"> config KVM_DEBUG_FS</span>
 	  Statistics are displayed in debugfs filesystem. Enabling this option
 	  may incur significant overhead.
 
<span class="p_del">-source &quot;arch/x86/lguest/Kconfig&quot;</span>
<span class="p_del">-</span>
 config PARAVIRT_TIME_ACCOUNTING
 	bool &quot;Paravirtual steal time accounting&quot;
 	depends on PARAVIRT
<span class="p_header">diff --git a/arch/x86/include/asm/lguest.h b/arch/x86/include/asm/lguest.h</span>
deleted file mode 100644
<span class="p_header">index 73d0c9b92087..000000000000</span>
<span class="p_header">--- a/arch/x86/include/asm/lguest.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,91 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _ASM_X86_LGUEST_H</span>
<span class="p_del">-#define _ASM_X86_LGUEST_H</span>
<span class="p_del">-</span>
<span class="p_del">-#define GDT_ENTRY_LGUEST_CS	10</span>
<span class="p_del">-#define GDT_ENTRY_LGUEST_DS	11</span>
<span class="p_del">-#define LGUEST_CS		(GDT_ENTRY_LGUEST_CS * 8)</span>
<span class="p_del">-#define LGUEST_DS		(GDT_ENTRY_LGUEST_DS * 8)</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef __ASSEMBLY__</span>
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#define GUEST_PL 1</span>
<span class="p_del">-</span>
<span class="p_del">-/* Page for Switcher text itself, then two pages per cpu */</span>
<span class="p_del">-#define SWITCHER_TEXT_PAGES (1)</span>
<span class="p_del">-#define SWITCHER_STACK_PAGES (2 * nr_cpu_ids)</span>
<span class="p_del">-#define TOTAL_SWITCHER_PAGES (SWITCHER_TEXT_PAGES + SWITCHER_STACK_PAGES)</span>
<span class="p_del">-</span>
<span class="p_del">-/* Where we map the Switcher, in both Host and Guest. */</span>
<span class="p_del">-extern unsigned long switcher_addr;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Found in switcher.S */</span>
<span class="p_del">-extern unsigned long default_idt_entries[];</span>
<span class="p_del">-</span>
<span class="p_del">-/* Declarations for definitions in arch/x86/lguest/head_32.S */</span>
<span class="p_del">-extern char lguest_noirq_iret[];</span>
<span class="p_del">-extern const char lgstart_cli[], lgend_cli[];</span>
<span class="p_del">-extern const char lgstart_pushf[], lgend_pushf[];</span>
<span class="p_del">-</span>
<span class="p_del">-extern void lguest_iret(void);</span>
<span class="p_del">-extern void lguest_init(void);</span>
<span class="p_del">-</span>
<span class="p_del">-struct lguest_regs {</span>
<span class="p_del">-	/* Manually saved part. */</span>
<span class="p_del">-	unsigned long eax, ebx, ecx, edx;</span>
<span class="p_del">-	unsigned long esi, edi, ebp;</span>
<span class="p_del">-	unsigned long gs;</span>
<span class="p_del">-	unsigned long fs, ds, es;</span>
<span class="p_del">-	unsigned long trapnum, errcode;</span>
<span class="p_del">-	/* Trap pushed part */</span>
<span class="p_del">-	unsigned long eip;</span>
<span class="p_del">-	unsigned long cs;</span>
<span class="p_del">-	unsigned long eflags;</span>
<span class="p_del">-	unsigned long esp;</span>
<span class="p_del">-	unsigned long ss;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is a guest-specific page (mapped ro) into the guest. */</span>
<span class="p_del">-struct lguest_ro_state {</span>
<span class="p_del">-	/* Host information we need to restore when we switch back. */</span>
<span class="p_del">-	u32 host_cr3;</span>
<span class="p_del">-	struct desc_ptr host_idt_desc;</span>
<span class="p_del">-	struct desc_ptr host_gdt_desc;</span>
<span class="p_del">-	u32 host_sp;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Fields which are used when guest is running. */</span>
<span class="p_del">-	struct desc_ptr guest_idt_desc;</span>
<span class="p_del">-	struct desc_ptr guest_gdt_desc;</span>
<span class="p_del">-	struct x86_hw_tss guest_tss;</span>
<span class="p_del">-	struct desc_struct guest_idt[IDT_ENTRIES];</span>
<span class="p_del">-	struct desc_struct guest_gdt[GDT_ENTRIES];</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct lg_cpu_arch {</span>
<span class="p_del">-	/* The GDT entries copied into lguest_ro_state when running. */</span>
<span class="p_del">-	struct desc_struct gdt[GDT_ENTRIES];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The IDT entries: some copied into lguest_ro_state when running. */</span>
<span class="p_del">-	struct desc_struct idt[IDT_ENTRIES];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The address of the last guest-visible pagefault (ie. cr2). */</span>
<span class="p_del">-	unsigned long last_pagefault;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void lguest_set_ts(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 cr0;</span>
<span class="p_del">-</span>
<span class="p_del">-	cr0 = read_cr0();</span>
<span class="p_del">-	if (!(cr0 &amp; 8))</span>
<span class="p_del">-		write_cr0(cr0 | 8);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Full 4G segment descriptors, suitable for CS and DS. */</span>
<span class="p_del">-#define FULL_EXEC_SEGMENT \</span>
<span class="p_del">-	((struct desc_struct)GDT_ENTRY_INIT(0xc09b, 0, 0xfffff))</span>
<span class="p_del">-#define FULL_SEGMENT ((struct desc_struct)GDT_ENTRY_INIT(0xc093, 0, 0xfffff))</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* __ASSEMBLY__ */</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _ASM_X86_LGUEST_H */</span>
<span class="p_header">diff --git a/arch/x86/include/asm/lguest_hcall.h b/arch/x86/include/asm/lguest_hcall.h</span>
deleted file mode 100644
<span class="p_header">index 6c119cfae218..000000000000</span>
<span class="p_header">--- a/arch/x86/include/asm/lguest_hcall.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,74 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/* Architecture specific portion of the lguest hypercalls */</span>
<span class="p_del">-#ifndef _ASM_X86_LGUEST_HCALL_H</span>
<span class="p_del">-#define _ASM_X86_LGUEST_HCALL_H</span>
<span class="p_del">-</span>
<span class="p_del">-#define LHCALL_FLUSH_ASYNC	0</span>
<span class="p_del">-#define LHCALL_LGUEST_INIT	1</span>
<span class="p_del">-#define LHCALL_SHUTDOWN		2</span>
<span class="p_del">-#define LHCALL_NEW_PGTABLE	4</span>
<span class="p_del">-#define LHCALL_FLUSH_TLB	5</span>
<span class="p_del">-#define LHCALL_LOAD_IDT_ENTRY	6</span>
<span class="p_del">-#define LHCALL_SET_STACK	7</span>
<span class="p_del">-#define LHCALL_SET_CLOCKEVENT	9</span>
<span class="p_del">-#define LHCALL_HALT		10</span>
<span class="p_del">-#define LHCALL_SET_PMD		13</span>
<span class="p_del">-#define LHCALL_SET_PTE		14</span>
<span class="p_del">-#define LHCALL_SET_PGD		15</span>
<span class="p_del">-#define LHCALL_LOAD_TLS		16</span>
<span class="p_del">-#define LHCALL_LOAD_GDT_ENTRY	18</span>
<span class="p_del">-#define LHCALL_SEND_INTERRUPTS	19</span>
<span class="p_del">-</span>
<span class="p_del">-#define LGUEST_TRAP_ENTRY 0x1F</span>
<span class="p_del">-</span>
<span class="p_del">-/* Argument number 3 to LHCALL_LGUEST_SHUTDOWN */</span>
<span class="p_del">-#define LGUEST_SHUTDOWN_POWEROFF	1</span>
<span class="p_del">-#define LGUEST_SHUTDOWN_RESTART		2</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef __ASSEMBLY__</span>
<span class="p_del">-#include &lt;asm/hw_irq.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:030</span>
<span class="p_del">- * But first, how does our Guest contact the Host to ask for privileged</span>
<span class="p_del">- * operations?  There are two ways: the direct way is to make a &quot;hypercall&quot;,</span>
<span class="p_del">- * to make requests of the Host Itself.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Our hypercall mechanism uses the highest unused trap code (traps 32 and</span>
<span class="p_del">- * above are used by real hardware interrupts).  Seventeen hypercalls are</span>
<span class="p_del">- * available: the hypercall number is put in the %eax register, and the</span>
<span class="p_del">- * arguments (when required) are placed in %ebx, %ecx, %edx and %esi.</span>
<span class="p_del">- * If a return value makes sense, it&#39;s returned in %eax.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Grossly invalid calls result in Sudden Death at the hands of the vengeful</span>
<span class="p_del">- * Host, rather than returning failure.  This reflects Winston Churchill&#39;s</span>
<span class="p_del">- * definition of a gentleman: &quot;someone who is only rude intentionally&quot;.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline unsigned long</span>
<span class="p_del">-hcall(unsigned long call,</span>
<span class="p_del">-      unsigned long arg1, unsigned long arg2, unsigned long arg3,</span>
<span class="p_del">-      unsigned long arg4)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* &quot;int&quot; is the Intel instruction to trigger a trap. */</span>
<span class="p_del">-	asm volatile(&quot;int $&quot; __stringify(LGUEST_TRAP_ENTRY)</span>
<span class="p_del">-		     /* The call in %eax (aka &quot;a&quot;) might be overwritten */</span>
<span class="p_del">-		     : &quot;=a&quot;(call)</span>
<span class="p_del">-		       /* The arguments are in %eax, %ebx, %ecx, %edx &amp; %esi */</span>
<span class="p_del">-		     : &quot;a&quot;(call), &quot;b&quot;(arg1), &quot;c&quot;(arg2), &quot;d&quot;(arg3), &quot;S&quot;(arg4)</span>
<span class="p_del">-		       /* &quot;memory&quot; means this might write somewhere in memory.</span>
<span class="p_del">-			* This isn&#39;t true for all calls, but it&#39;s safe to tell</span>
<span class="p_del">-			* gcc that it might happen so it doesn&#39;t get clever. */</span>
<span class="p_del">-		     : &quot;memory&quot;);</span>
<span class="p_del">-	return call;</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* Can&#39;t use our min() macro here: needs to be a constant */</span>
<span class="p_del">-#define LGUEST_IRQS (NR_IRQS &lt; 32 ? NR_IRQS: 32)</span>
<span class="p_del">-</span>
<span class="p_del">-#define LHCALL_RING_SIZE 64</span>
<span class="p_del">-struct hcall_args {</span>
<span class="p_del">-	/* These map directly onto eax/ebx/ecx/edx/esi in struct lguest_regs */</span>
<span class="p_del">-	unsigned long arg0, arg1, arg2, arg3, arg4;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* !__ASSEMBLY__ */</span>
<span class="p_del">-#endif /* _ASM_X86_LGUEST_HCALL_H */</span>
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index 028245e1c42b..410b62700129 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -661,7 +661,7 @@</span> <span class="p_context"> static inline void sync_core(void)</span>
 	 * In case NMI unmasking or performance ever becomes a problem,
 	 * the next best option appears to be MOV-to-CR2 and an
 	 * unconditional jump.  That sequence also works on all CPUs,
<span class="p_del">-	 * but it will fault at CPL3 (i.e. Xen PV and lguest).</span>
<span class="p_add">+	 * but it will fault at CPL3 (i.e. Xen PV).</span>
 	 *
 	 * CPUID is the conventional way, but it&#39;s nasty: it doesn&#39;t
 	 * exist on some 486-like CPUs, and it usually exits to a
<span class="p_header">diff --git a/arch/x86/include/uapi/asm/bootparam.h b/arch/x86/include/uapi/asm/bootparam.h</span>
<span class="p_header">index ddef37b16af2..66b8f93333d1 100644</span>
<span class="p_header">--- a/arch/x86/include/uapi/asm/bootparam.h</span>
<span class="p_header">+++ b/arch/x86/include/uapi/asm/bootparam.h</span>
<span class="p_chunk">@@ -201,7 +201,7 @@</span> <span class="p_context"> struct boot_params {</span>
  *
  * @X86_SUBARCH_PC: Should be used if the hardware is enumerable using standard
  *	PC mechanisms (PCI, ACPI) and doesn&#39;t need a special boot flow.
<span class="p_del">- * @X86_SUBARCH_LGUEST: Used for x86 hypervisor demo, lguest</span>
<span class="p_add">+ * @X86_SUBARCH_LGUEST: Used for x86 hypervisor demo, lguest, deprecated</span>
  * @X86_SUBARCH_XEN: Used for Xen guest types which follow the PV boot path,
  * 	which start at asm startup_xen() entry point and later jump to the C
  * 	xen_start_kernel() entry point. Both domU and dom0 type of guests are
<span class="p_header">diff --git a/arch/x86/kernel/asm-offsets_32.c b/arch/x86/kernel/asm-offsets_32.c</span>
<span class="p_header">index 880aa093268d..710edab9e644 100644</span>
<span class="p_header">--- a/arch/x86/kernel/asm-offsets_32.c</span>
<span class="p_header">+++ b/arch/x86/kernel/asm-offsets_32.c</span>
<span class="p_chunk">@@ -4,9 +4,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/ucontext.h&gt;
 
<span class="p_del">-#include &lt;linux/lguest.h&gt;</span>
<span class="p_del">-#include &quot;../../../drivers/lguest/lg.h&quot;</span>
<span class="p_del">-</span>
 #define __SYSCALL_I386(nr, sym, qual) [nr] = 1,
 static char syscalls[] = {
 #include &lt;asm/syscalls_32.h&gt;
<span class="p_chunk">@@ -62,23 +59,6 @@</span> <span class="p_context"> void foo(void)</span>
 	OFFSET(stack_canary_offset, stack_canary, canary);
 #endif
 
<span class="p_del">-#if defined(CONFIG_LGUEST) || defined(CONFIG_LGUEST_GUEST) || defined(CONFIG_LGUEST_MODULE)</span>
<span class="p_del">-	BLANK();</span>
<span class="p_del">-	OFFSET(LGUEST_DATA_irq_enabled, lguest_data, irq_enabled);</span>
<span class="p_del">-	OFFSET(LGUEST_DATA_irq_pending, lguest_data, irq_pending);</span>
<span class="p_del">-</span>
<span class="p_del">-	BLANK();</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_host_gdt_desc, lguest_pages, state.host_gdt_desc);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_host_idt_desc, lguest_pages, state.host_idt_desc);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_host_cr3, lguest_pages, state.host_cr3);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_host_sp, lguest_pages, state.host_sp);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_guest_gdt_desc, lguest_pages,state.guest_gdt_desc);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_guest_idt_desc, lguest_pages,state.guest_idt_desc);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_guest_gdt, lguest_pages, state.guest_gdt);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_regs_trapnum, lguest_pages, regs.trapnum);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_regs_errcode, lguest_pages, regs.errcode);</span>
<span class="p_del">-	OFFSET(LGUEST_PAGES_regs, lguest_pages, regs);</span>
<span class="p_del">-#endif</span>
 	BLANK();
 	DEFINE(__NR_syscall_max, sizeof(syscalls) - 1);
 	DEFINE(NR_syscalls, sizeof(syscalls));
<span class="p_header">diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S</span>
<span class="p_header">index 1f85ee8f9439..d7a2a6c64627 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_32.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_32.S</span>
<span class="p_chunk">@@ -155,7 +155,6 @@</span> <span class="p_context"> ENTRY(startup_32)</span>
 	jmp *%eax
 
 .Lbad_subarch:
<span class="p_del">-WEAK(lguest_entry)</span>
 WEAK(xen_entry)
 	/* Unknown implementation; there&#39;s really
 	   nothing we can do at this point. */
<span class="p_chunk">@@ -165,7 +164,6 @@</span> <span class="p_context"> WEAK(xen_entry)</span>
 
 subarch_entries:
 	.long .Ldefault_entry		/* normal x86/PC */
<span class="p_del">-	.long lguest_entry		/* lguest hypervisor */</span>
 	.long xen_entry			/* Xen hypervisor */
 	.long .Ldefault_entry		/* Moorestown MID */
 num_subarch_entries = (. - subarch_entries) / 4
<span class="p_header">diff --git a/arch/x86/kernel/platform-quirks.c b/arch/x86/kernel/platform-quirks.c</span>
<span class="p_header">index 91271122f0df..502a77d0adb0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/platform-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/platform-quirks.c</span>
<span class="p_chunk">@@ -16,7 +16,6 @@</span> <span class="p_context"> void __init x86_early_init_platform_quirks(void)</span>
 		x86_platform.legacy.reserve_bios_regions = 1;
 		break;
 	case X86_SUBARCH_XEN:
<span class="p_del">-	case X86_SUBARCH_LGUEST:</span>
 		x86_platform.legacy.devices.pnpbios = 0;
 		x86_platform.legacy.rtc = 0;
 		break;
<span class="p_header">diff --git a/arch/x86/kvm/Kconfig b/arch/x86/kvm/Kconfig</span>
<span class="p_header">index 2688c7dc5323..3ea624452f93 100644</span>
<span class="p_header">--- a/arch/x86/kvm/Kconfig</span>
<span class="p_header">+++ b/arch/x86/kvm/Kconfig</span>
<span class="p_chunk">@@ -89,6 +89,5 @@</span> <span class="p_context"> config KVM_MMU_AUDIT</span>
 # OK, it&#39;s a little counter-intuitive to do this, but it puts it neatly under
 # the virtualization menu.
 source drivers/vhost/Kconfig
<span class="p_del">-source drivers/lguest/Kconfig</span>
 
 endif # VIRTUALIZATION
<span class="p_header">diff --git a/arch/x86/lguest/Kconfig b/arch/x86/lguest/Kconfig</span>
deleted file mode 100644
<span class="p_header">index 08f41caada45..000000000000</span>
<span class="p_header">--- a/arch/x86/lguest/Kconfig</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,14 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-config LGUEST_GUEST</span>
<span class="p_del">-	bool &quot;Lguest guest support&quot;</span>
<span class="p_del">-	depends on X86_32 &amp;&amp; PARAVIRT &amp;&amp; PCI</span>
<span class="p_del">-	select TTY</span>
<span class="p_del">-	select VIRTUALIZATION</span>
<span class="p_del">-	select VIRTIO</span>
<span class="p_del">-	select VIRTIO_CONSOLE</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Lguest is a tiny in-kernel hypervisor.  Selecting this will</span>
<span class="p_del">-	  allow your kernel to boot under lguest.  This option will increase</span>
<span class="p_del">-	  your kernel size by about 10k.  If in doubt, say N.</span>
<span class="p_del">-</span>
<span class="p_del">-	  If you say Y here, make sure you say Y (or M) to the virtio block</span>
<span class="p_del">-	  and net drivers which lguest needs.</span>
<span class="p_header">diff --git a/arch/x86/lguest/Makefile b/arch/x86/lguest/Makefile</span>
deleted file mode 100644
<span class="p_header">index 8f38d577a2fa..000000000000</span>
<span class="p_header">--- a/arch/x86/lguest/Makefile</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,2 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-obj-y		:= head_32.o boot.o</span>
<span class="p_del">-CFLAGS_boot.o	:= $(call cc-option, -fno-stack-protector)</span>
<span class="p_header">diff --git a/arch/x86/lguest/boot.c b/arch/x86/lguest/boot.c</span>
deleted file mode 100644
<span class="p_header">index 99472698c931..000000000000</span>
<span class="p_header">--- a/arch/x86/lguest/boot.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,1558 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:010</span>
<span class="p_del">- * A hypervisor allows multiple Operating Systems to run on a single machine.</span>
<span class="p_del">- * To quote David Wheeler: &quot;Any problem in computer science can be solved with</span>
<span class="p_del">- * another layer of indirection.&quot;</span>
<span class="p_del">- *</span>
<span class="p_del">- * We keep things simple in two ways.  First, we start with a normal Linux</span>
<span class="p_del">- * kernel and insert a module (lg.ko) which allows us to run other Linux</span>
<span class="p_del">- * kernels the same way we&#39;d run processes.  We call the first kernel the Host,</span>
<span class="p_del">- * and the others the Guests.  The program which sets up and configures Guests</span>
<span class="p_del">- * (such as the example in tools/lguest/lguest.c) is called the Launcher.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Secondly, we only run specially modified Guests, not normal kernels: setting</span>
<span class="p_del">- * CONFIG_LGUEST_GUEST to &quot;y&quot; compiles this file into the kernel so it knows</span>
<span class="p_del">- * how to be a Guest at boot time.  This means that you can use the same kernel</span>
<span class="p_del">- * you boot normally (ie. as a Host) as a Guest.</span>
<span class="p_del">- *</span>
<span class="p_del">- * These Guests know that they cannot do privileged operations, such as disable</span>
<span class="p_del">- * interrupts, and that they have to ask the Host to do such things explicitly.</span>
<span class="p_del">- * This file consists of all the replacements for such low-level native</span>
<span class="p_del">- * hardware operations: these special Guest versions call the Host.</span>
<span class="p_del">- *</span>
<span class="p_del">- * So how does the kernel know it&#39;s a Guest?  We&#39;ll see that later, but let&#39;s</span>
<span class="p_del">- * just say that we end up here where we replace the native functions various</span>
<span class="p_del">- * &quot;paravirt&quot; structures with our Guest versions, then boot like normal.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2006, Rusty Russell &lt;rusty@rustcorp.com.au&gt; IBM Corporation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License as published by</span>
<span class="p_del">- * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">- * (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful, but</span>
<span class="p_del">- * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_del">- * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="p_del">- * details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &lt;linux/kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/start_kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/string.h&gt;</span>
<span class="p_del">-#include &lt;linux/console.h&gt;</span>
<span class="p_del">-#include &lt;linux/screen_info.h&gt;</span>
<span class="p_del">-#include &lt;linux/irq.h&gt;</span>
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/clocksource.h&gt;</span>
<span class="p_del">-#include &lt;linux/clockchips.h&gt;</span>
<span class="p_del">-#include &lt;linux/lguest.h&gt;</span>
<span class="p_del">-#include &lt;linux/lguest_launcher.h&gt;</span>
<span class="p_del">-#include &lt;linux/virtio_console.h&gt;</span>
<span class="p_del">-#include &lt;linux/pm.h&gt;</span>
<span class="p_del">-#include &lt;linux/export.h&gt;</span>
<span class="p_del">-#include &lt;linux/pci.h&gt;</span>
<span class="p_del">-#include &lt;linux/virtio_pci.h&gt;</span>
<span class="p_del">-#include &lt;asm/acpi.h&gt;</span>
<span class="p_del">-#include &lt;asm/apic.h&gt;</span>
<span class="p_del">-#include &lt;asm/lguest.h&gt;</span>
<span class="p_del">-#include &lt;asm/paravirt.h&gt;</span>
<span class="p_del">-#include &lt;asm/param.h&gt;</span>
<span class="p_del">-#include &lt;asm/page.h&gt;</span>
<span class="p_del">-#include &lt;asm/pgtable.h&gt;</span>
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
<span class="p_del">-#include &lt;asm/setup.h&gt;</span>
<span class="p_del">-#include &lt;asm/e820/api.h&gt;</span>
<span class="p_del">-#include &lt;asm/mce.h&gt;</span>
<span class="p_del">-#include &lt;asm/io.h&gt;</span>
<span class="p_del">-#include &lt;asm/fpu/api.h&gt;</span>
<span class="p_del">-#include &lt;asm/stackprotector.h&gt;</span>
<span class="p_del">-#include &lt;asm/reboot.h&gt;		/* for struct machine_ops */</span>
<span class="p_del">-#include &lt;asm/kvm_para.h&gt;</span>
<span class="p_del">-#include &lt;asm/pci_x86.h&gt;</span>
<span class="p_del">-#include &lt;asm/pci-direct.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:010</span>
<span class="p_del">- * Welcome to the Guest!</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Guest in our tale is a simple creature: identical to the Host but</span>
<span class="p_del">- * behaving in simplified but equivalent ways.  In particular, the Guest is the</span>
<span class="p_del">- * same kernel as the Host (or at least, built from the same source code).</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-struct lguest_data lguest_data = {</span>
<span class="p_del">-	.hcall_status = { [0 ... LHCALL_RING_SIZE-1] = 0xFF },</span>
<span class="p_del">-	.noirq_iret = (u32)lguest_noirq_iret,</span>
<span class="p_del">-	.kernel_address = PAGE_OFFSET,</span>
<span class="p_del">-	.blocked_interrupts = { 1 }, /* Block timer interrupts */</span>
<span class="p_del">-	.syscall_vec = IA32_SYSCALL_VECTOR,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:037</span>
<span class="p_del">- * async_hcall() is pretty simple: I&#39;m quite proud of it really.  We have a</span>
<span class="p_del">- * ring buffer of stored hypercalls which the Host will run though next time we</span>
<span class="p_del">- * do a normal hypercall.  Each entry in the ring has 5 slots for the hypercall</span>
<span class="p_del">- * arguments, and a &quot;hcall_status&quot; word which is 0 if the call is ready to go,</span>
<span class="p_del">- * and 255 once the Host has finished with it.</span>
<span class="p_del">- *</span>
<span class="p_del">- * If we come around to a slot which hasn&#39;t been finished, then the table is</span>
<span class="p_del">- * full and we just make the hypercall directly.  This has the nice side</span>
<span class="p_del">- * effect of causing the Host to run all the stored calls in the ring buffer</span>
<span class="p_del">- * which empties it for next time!</span>
<span class="p_del">- */</span>
<span class="p_del">-static void async_hcall(unsigned long call, unsigned long arg1,</span>
<span class="p_del">-			unsigned long arg2, unsigned long arg3,</span>
<span class="p_del">-			unsigned long arg4)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Note: This code assumes we&#39;re uniprocessor. */</span>
<span class="p_del">-	static unsigned int next_call;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Disable interrupts if not already disabled: we don&#39;t want an</span>
<span class="p_del">-	 * interrupt handler making a hypercall while we&#39;re already doing</span>
<span class="p_del">-	 * one!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_del">-	if (lguest_data.hcall_status[next_call] != 0xFF) {</span>
<span class="p_del">-		/* Table full, so do normal hcall which will flush table. */</span>
<span class="p_del">-		hcall(call, arg1, arg2, arg3, arg4);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		lguest_data.hcalls[next_call].arg0 = call;</span>
<span class="p_del">-		lguest_data.hcalls[next_call].arg1 = arg1;</span>
<span class="p_del">-		lguest_data.hcalls[next_call].arg2 = arg2;</span>
<span class="p_del">-		lguest_data.hcalls[next_call].arg3 = arg3;</span>
<span class="p_del">-		lguest_data.hcalls[next_call].arg4 = arg4;</span>
<span class="p_del">-		/* Arguments must all be written before we mark it to go */</span>
<span class="p_del">-		wmb();</span>
<span class="p_del">-		lguest_data.hcall_status[next_call] = 0;</span>
<span class="p_del">-		if (++next_call == LHCALL_RING_SIZE)</span>
<span class="p_del">-			next_call = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	local_irq_restore(flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:035</span>
<span class="p_del">- * Notice the lazy_hcall() above, rather than hcall().  This is our first real</span>
<span class="p_del">- * optimization trick!</span>
<span class="p_del">- *</span>
<span class="p_del">- * When lazy_mode is set, it means we&#39;re allowed to defer all hypercalls and do</span>
<span class="p_del">- * them as a batch when lazy_mode is eventually turned off.  Because hypercalls</span>
<span class="p_del">- * are reasonably expensive, batching them up makes sense.  For example, a</span>
<span class="p_del">- * large munmap might update dozens of page table entries: that code calls</span>
<span class="p_del">- * paravirt_enter_lazy_mmu(), does the dozen updates, then calls</span>
<span class="p_del">- * lguest_leave_lazy_mode().</span>
<span class="p_del">- *</span>
<span class="p_del">- * So, when we&#39;re in lazy mode, we call async_hcall() to store the call for</span>
<span class="p_del">- * future processing:</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lazy_hcall1(unsigned long call, unsigned long arg1)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE)</span>
<span class="p_del">-		hcall(call, arg1, 0, 0, 0);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		async_hcall(call, arg1, 0, 0, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* You can imagine what lazy_hcall2, 3 and 4 look like. :*/</span>
<span class="p_del">-static void lazy_hcall2(unsigned long call,</span>
<span class="p_del">-			unsigned long arg1,</span>
<span class="p_del">-			unsigned long arg2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE)</span>
<span class="p_del">-		hcall(call, arg1, arg2, 0, 0);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		async_hcall(call, arg1, arg2, 0, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lazy_hcall3(unsigned long call,</span>
<span class="p_del">-			unsigned long arg1,</span>
<span class="p_del">-			unsigned long arg2,</span>
<span class="p_del">-			unsigned long arg3)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE)</span>
<span class="p_del">-		hcall(call, arg1, arg2, arg3, 0);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		async_hcall(call, arg1, arg2, arg3, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-static void lazy_hcall4(unsigned long call,</span>
<span class="p_del">-			unsigned long arg1,</span>
<span class="p_del">-			unsigned long arg2,</span>
<span class="p_del">-			unsigned long arg3,</span>
<span class="p_del">-			unsigned long arg4)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (paravirt_get_lazy_mode() == PARAVIRT_LAZY_NONE)</span>
<span class="p_del">-		hcall(call, arg1, arg2, arg3, arg4);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		async_hcall(call, arg1, arg2, arg3, arg4);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:036</span>
<span class="p_del">- * When lazy mode is turned off, we issue the do-nothing hypercall to</span>
<span class="p_del">- * flush any stored calls, and call the generic helper to reset the</span>
<span class="p_del">- * per-cpu lazy mode variable.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_leave_lazy_mmu_mode(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hcall(LHCALL_FLUSH_ASYNC, 0, 0, 0, 0);</span>
<span class="p_del">-	paravirt_leave_lazy_mmu();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We also catch the end of context switch; we enter lazy mode for much of</span>
<span class="p_del">- * that too, so again we need to flush here.</span>
<span class="p_del">- *</span>
<span class="p_del">- * (Technically, this is lazy CPU mode, and normally we&#39;re in lazy MMU</span>
<span class="p_del">- * mode, but unlike Xen, lguest doesn&#39;t care about the difference).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_end_context_switch(struct task_struct *next)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hcall(LHCALL_FLUSH_ASYNC, 0, 0, 0, 0);</span>
<span class="p_del">-	paravirt_end_context_switch(next);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:032</span>
<span class="p_del">- * After that diversion we return to our first native-instruction</span>
<span class="p_del">- * replacements: four functions for interrupt control.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The simplest way of implementing these would be to have &quot;turn interrupts</span>
<span class="p_del">- * off&quot; and &quot;turn interrupts on&quot; hypercalls.  Unfortunately, this is too slow:</span>
<span class="p_del">- * these are by far the most commonly called functions of those we override.</span>
<span class="p_del">- *</span>
<span class="p_del">- * So instead we keep an &quot;irq_enabled&quot; field inside our &quot;struct lguest_data&quot;,</span>
<span class="p_del">- * which the Guest can update with a single instruction.  The Host knows to</span>
<span class="p_del">- * check there before it tries to deliver an interrupt.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * save_flags() is expected to return the processor state (ie. &quot;flags&quot;).  The</span>
<span class="p_del">- * flags word contains all kind of stuff, but in practice Linux only cares</span>
<span class="p_del">- * about the interrupt flag.  Our &quot;save_flags()&quot; just returns that.</span>
<span class="p_del">- */</span>
<span class="p_del">-asmlinkage __visible unsigned long lguest_save_fl(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return lguest_data.irq_enabled;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Interrupts go off... */</span>
<span class="p_del">-asmlinkage __visible void lguest_irq_disable(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	lguest_data.irq_enabled = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Let&#39;s pause a moment.  Remember how I said these are called so often?</span>
<span class="p_del">- * Jeremy Fitzhardinge optimized them so hard early in 2009 that he had to</span>
<span class="p_del">- * break some rules.  In particular, these functions are assumed to save their</span>
<span class="p_del">- * own registers if they need to: normal C functions assume they can trash the</span>
<span class="p_del">- * eax register.  To use normal C functions, we use</span>
<span class="p_del">- * PV_CALLEE_SAVE_REGS_THUNK(), which pushes %eax onto the stack, calls the</span>
<span class="p_del">- * C function, then restores it.</span>
<span class="p_del">- */</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(lguest_save_fl);</span>
<span class="p_del">-PV_CALLEE_SAVE_REGS_THUNK(lguest_irq_disable);</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* These are in head_32.S */</span>
<span class="p_del">-extern void lg_irq_enable(void);</span>
<span class="p_del">-extern void lg_restore_fl(unsigned long flags);</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:003</span>
<span class="p_del">- * We could be more efficient in our checking of outstanding interrupts, rather</span>
<span class="p_del">- * than using a branch.  One way would be to put the &quot;irq_enabled&quot; field in a</span>
<span class="p_del">- * page by itself, and have the Host write-protect it when an interrupt comes</span>
<span class="p_del">- * in when irqs are disabled.  There will then be a page fault as soon as</span>
<span class="p_del">- * interrupts are re-enabled.</span>
<span class="p_del">- *</span>
<span class="p_del">- * A better method is to implement soft interrupt disable generally for x86:</span>
<span class="p_del">- * instead of disabling interrupts, we set a flag.  If an interrupt does come</span>
<span class="p_del">- * in, we then disable them for real.  This is uncommon, so we could simply use</span>
<span class="p_del">- * a hypercall for interrupt control and not worry about efficiency.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:034</span>
<span class="p_del">- * The Interrupt Descriptor Table (IDT).</span>
<span class="p_del">- *</span>
<span class="p_del">- * The IDT tells the processor what to do when an interrupt comes in.  Each</span>
<span class="p_del">- * entry in the table is a 64-bit descriptor: this holds the privilege level,</span>
<span class="p_del">- * address of the handler, and... well, who cares?  The Guest just asks the</span>
<span class="p_del">- * Host to make the change anyway, because the Host controls the real IDT.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_write_idt_entry(gate_desc *dt,</span>
<span class="p_del">-				   int entrynum, const gate_desc *g)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The gate_desc structure is 8 bytes long: we hand it to the Host in</span>
<span class="p_del">-	 * two 32-bit chunks.  The whole 32-bit kernel used to hand descriptors</span>
<span class="p_del">-	 * around like this; typesafety wasn&#39;t a big concern in Linux&#39;s early</span>
<span class="p_del">-	 * years.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	u32 *desc = (u32 *)g;</span>
<span class="p_del">-	/* Keep the local copy up to date. */</span>
<span class="p_del">-	native_write_idt_entry(dt, entrynum, g);</span>
<span class="p_del">-	/* Tell Host about this new entry. */</span>
<span class="p_del">-	hcall(LHCALL_LOAD_IDT_ENTRY, entrynum, desc[0], desc[1], 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Changing to a different IDT is very rare: we keep the IDT up-to-date every</span>
<span class="p_del">- * time it is written, so we can simply loop through all entries and tell the</span>
<span class="p_del">- * Host about them.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_load_idt(const struct desc_ptr *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-	struct desc_struct *idt = (void *)desc-&gt;address;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; (desc-&gt;size+1)/8; i++)</span>
<span class="p_del">-		hcall(LHCALL_LOAD_IDT_ENTRY, i, idt[i].a, idt[i].b, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Global Descriptor Table.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Intel architecture defines another table, called the Global Descriptor</span>
<span class="p_del">- * Table (GDT).  You tell the CPU where it is (and its size) using the &quot;lgdt&quot;</span>
<span class="p_del">- * instruction, and then several other instructions refer to entries in the</span>
<span class="p_del">- * table.  There are three entries which the Switcher needs, so the Host simply</span>
<span class="p_del">- * controls the entire thing and the Guest asks it to make changes using the</span>
<span class="p_del">- * LOAD_GDT hypercall.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is the exactly like the IDT code.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_load_gdt(const struct desc_ptr *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-	struct desc_struct *gdt = (void *)desc-&gt;address;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; (desc-&gt;size+1)/8; i++)</span>
<span class="p_del">-		hcall(LHCALL_LOAD_GDT_ENTRY, i, gdt[i].a, gdt[i].b, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * For a single GDT entry which changes, we simply change our copy and</span>
<span class="p_del">- * then tell the host about it.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_write_gdt_entry(struct desc_struct *dt, int entrynum,</span>
<span class="p_del">-				   const void *desc, int type)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_write_gdt_entry(dt, entrynum, desc, type);</span>
<span class="p_del">-	/* Tell Host about this new entry. */</span>
<span class="p_del">-	hcall(LHCALL_LOAD_GDT_ENTRY, entrynum,</span>
<span class="p_del">-	      dt[entrynum].a, dt[entrynum].b, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * There are three &quot;thread local storage&quot; GDT entries which change</span>
<span class="p_del">- * on every context switch (these three entries are how glibc implements</span>
<span class="p_del">- * __thread variables).  As an optimization, we have a hypercall</span>
<span class="p_del">- * specifically for this case.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Wouldn&#39;t it be nicer to have a general LOAD_GDT_ENTRIES hypercall</span>
<span class="p_del">- * which took a range of entries?</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_load_tls(struct thread_struct *t, unsigned int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There&#39;s one problem which normal hardware doesn&#39;t have: the Host</span>
<span class="p_del">-	 * can&#39;t handle us removing entries we&#39;re currently using.  So we clear</span>
<span class="p_del">-	 * the GS register here: if it&#39;s needed it&#39;ll be reloaded anyway.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	lazy_load_gs(0);</span>
<span class="p_del">-	lazy_hcall2(LHCALL_LOAD_TLS, __pa(&amp;t-&gt;tls_array), cpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:038</span>
<span class="p_del">- * That&#39;s enough excitement for now, back to ploughing through each of the</span>
<span class="p_del">- * different pv_ops structures (we&#39;re about 1/3 of the way through).</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is the Local Descriptor Table, another weird Intel thingy.  Linux only</span>
<span class="p_del">- * uses this for some strange applications like Wine.  We don&#39;t do anything</span>
<span class="p_del">- * here, so they&#39;ll get an informative and friendly Segmentation Fault.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_set_ldt(const void *addr, unsigned entries)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This loads a GDT entry into the &quot;Task Register&quot;: that entry points to a</span>
<span class="p_del">- * structure called the Task State Segment.  Some comments scattered though the</span>
<span class="p_del">- * kernel code indicate that this used for task switching in ages past, along</span>
<span class="p_del">- * with blood sacrifice and astrology.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Now there&#39;s nothing interesting in here that we don&#39;t get told elsewhere.</span>
<span class="p_del">- * But the native version uses the &quot;ltr&quot; instruction, which makes the Host</span>
<span class="p_del">- * complain to the Guest about a Segmentation Fault and it&#39;ll oops.  So we</span>
<span class="p_del">- * override the native version with a do-nothing version.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_load_tr_desc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The &quot;cpuid&quot; instruction is a way of querying both the CPU identity</span>
<span class="p_del">- * (manufacturer, model, etc) and its features.  It was introduced before the</span>
<span class="p_del">- * Pentium in 1993 and keeps getting extended by both Intel, AMD and others.</span>
<span class="p_del">- * As you might imagine, after a decade and a half this treatment, it is now a</span>
<span class="p_del">- * giant ball of hair.  Its entry in the current Intel manual runs to 28 pages.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This instruction even it has its own Wikipedia entry.  The Wikipedia entry</span>
<span class="p_del">- * has been translated into 6 languages.  I am not making this up!</span>
<span class="p_del">- *</span>
<span class="p_del">- * We could get funky here and identify ourselves as &quot;GenuineLguest&quot;, but</span>
<span class="p_del">- * instead we just use the real &quot;cpuid&quot; instruction.  Then I pretty much turned</span>
<span class="p_del">- * off feature bits until the Guest booted.  (Don&#39;t say that: you&#39;ll damage</span>
<span class="p_del">- * lguest sales!)  Shut up, inner voice!  (Hey, just pointing out that this is</span>
<span class="p_del">- * hardly future proof.)  No one&#39;s listening!  They don&#39;t like you anyway,</span>
<span class="p_del">- * parenthetic weirdo!</span>
<span class="p_del">- *</span>
<span class="p_del">- * Replacing the cpuid so we can turn features off is great for the kernel, but</span>
<span class="p_del">- * anyone (including userspace) can just use the raw &quot;cpuid&quot; instruction and</span>
<span class="p_del">- * the Host won&#39;t even notice since it isn&#39;t privileged.  So we try not to get</span>
<span class="p_del">- * too worked up about it.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_cpuid(unsigned int *ax, unsigned int *bx,</span>
<span class="p_del">-			 unsigned int *cx, unsigned int *dx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int function = *ax;</span>
<span class="p_del">-</span>
<span class="p_del">-	native_cpuid(ax, bx, cx, dx);</span>
<span class="p_del">-	switch (function) {</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * CPUID 0 gives the highest legal CPUID number (and the ID string).</span>
<span class="p_del">-	 * We futureproof our code a little by sticking to known CPUID values.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		if (*ax &gt; 5)</span>
<span class="p_del">-			*ax = 5;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * CPUID 1 is a basic feature request.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * CX: we only allow kernel to see SSE3, CMPXCHG16B and SSSE3</span>
<span class="p_del">-	 * DX: SSE, SSE2, FXSR, MMX, CMOV, CMPXCHG8B, TSC, FPU and PAE.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	case 1:</span>
<span class="p_del">-		*cx &amp;= 0x00002201;</span>
<span class="p_del">-		*dx &amp;= 0x07808151;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The Host can do a nice optimization if it knows that the</span>
<span class="p_del">-		 * kernel mappings (addresses above 0xC0000000 or whatever</span>
<span class="p_del">-		 * PAGE_OFFSET is set to) haven&#39;t changed.  But Linux calls</span>
<span class="p_del">-		 * flush_tlb_user() for both user and kernel mappings unless</span>
<span class="p_del">-		 * the Page Global Enable (PGE) feature bit is set.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		*dx |= 0x00002000;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We also lie, and say we&#39;re family id 5.  6 or greater</span>
<span class="p_del">-		 * leads to a rdmsr in early_init_intel which we can&#39;t handle.</span>
<span class="p_del">-		 * Family ID is returned as bits 8-12 in ax.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		*ax &amp;= 0xFFFFF0FF;</span>
<span class="p_del">-		*ax |= 0x00000500;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This is used to detect if we&#39;re running under KVM.  We might be,</span>
<span class="p_del">-	 * but that&#39;s a Host matter, not us.  So say we&#39;re not.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	case KVM_CPUID_SIGNATURE:</span>
<span class="p_del">-		*bx = *cx = *dx = 0;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 0x80000000 returns the highest Extended Function, so we futureproof</span>
<span class="p_del">-	 * like we do above by limiting it to known fields.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	case 0x80000000:</span>
<span class="p_del">-		if (*ax &gt; 0x80000008)</span>
<span class="p_del">-			*ax = 0x80000008;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * PAE systems can mark pages as non-executable.  Linux calls this the</span>
<span class="p_del">-	 * NX bit.  Intel calls it XD (eXecute Disable), AMD EVP (Enhanced</span>
<span class="p_del">-	 * Virus Protection).  We just switch it off here, since we don&#39;t</span>
<span class="p_del">-	 * support it.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	case 0x80000001:</span>
<span class="p_del">-		*dx &amp;= ~(1 &lt;&lt; 20);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Intel has four control registers, imaginatively named cr0, cr2, cr3 and cr4.</span>
<span class="p_del">- * I assume there&#39;s a cr1, but it hasn&#39;t bothered us yet, so we&#39;ll not bother</span>
<span class="p_del">- * it.  The Host needs to know when the Guest wants to change them, so we have</span>
<span class="p_del">- * a whole series of functions like read_cr0() and write_cr0().</span>
<span class="p_del">- *</span>
<span class="p_del">- * We start with cr0.  cr0 allows you to turn on and off all kinds of basic</span>
<span class="p_del">- * features, but the only cr0 bit that Linux ever used at runtime was the</span>
<span class="p_del">- * horrifically-named Task Switched (TS) bit at bit 3 (ie. 8)</span>
<span class="p_del">- *</span>
<span class="p_del">- * What does the TS bit do?  Well, it causes the CPU to trap (interrupt 7) if</span>
<span class="p_del">- * the floating point unit is used.  Which allows us to restore FPU state</span>
<span class="p_del">- * lazily after a task switch if we wanted to, but wouldn&#39;t a name like</span>
<span class="p_del">- * &quot;FPUTRAP bit&quot; be a little less cryptic?</span>
<span class="p_del">- *</span>
<span class="p_del">- * Fortunately, Linux keeps it simple and doesn&#39;t use TS, so we can ignore</span>
<span class="p_del">- * cr0.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_write_cr0(unsigned long val)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned long lguest_read_cr0(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * cr2 is the virtual address of the last page fault, which the Guest only ever</span>
<span class="p_del">- * reads.  The Host kindly writes this into our &quot;struct lguest_data&quot;, so we</span>
<span class="p_del">- * just read it out of there.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long lguest_read_cr2(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return lguest_data.cr2;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* See lguest_set_pte() below. */</span>
<span class="p_del">-static bool cr3_changed = false;</span>
<span class="p_del">-static unsigned long current_cr3;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * cr3 is the current toplevel pagetable page: the principle is the same as</span>
<span class="p_del">- * cr0.  Keep a local copy, and tell the Host when it changes.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_write_cr3(unsigned long cr3)</span>
<span class="p_del">-{</span>
<span class="p_del">-	lazy_hcall1(LHCALL_NEW_PGTABLE, cr3);</span>
<span class="p_del">-	current_cr3 = cr3;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* These two page tables are simple, linear, and used during boot */</span>
<span class="p_del">-	if (cr3 != __pa_symbol(swapper_pg_dir) &amp;&amp;</span>
<span class="p_del">-	    cr3 != __pa_symbol(initial_page_table))</span>
<span class="p_del">-		cr3_changed = true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned long lguest_read_cr3(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return current_cr3;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* cr4 is used to enable and disable PGE, but we don&#39;t care. */</span>
<span class="p_del">-static unsigned long lguest_read_cr4(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lguest_write_cr4(unsigned long val)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Page Table Handling.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Now would be a good time to take a rest and grab a coffee or similarly</span>
<span class="p_del">- * relaxing stimulant.  The easy parts are behind us, and the trek gradually</span>
<span class="p_del">- * winds uphill from here.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Quick refresher: memory is divided into &quot;pages&quot; of 4096 bytes each.  The CPU</span>
<span class="p_del">- * maps virtual addresses to physical addresses using &quot;page tables&quot;.  We could</span>
<span class="p_del">- * use one huge index of 1 million entries: each address is 4 bytes, so that&#39;s</span>
<span class="p_del">- * 1024 pages just to hold the page tables.   But since most virtual addresses</span>
<span class="p_del">- * are unused, we use a two level index which saves space.  The cr3 register</span>
<span class="p_del">- * contains the physical address of the top level &quot;page directory&quot; page, which</span>
<span class="p_del">- * contains physical addresses of up to 1024 second-level pages.  Each of these</span>
<span class="p_del">- * second level pages contains up to 1024 physical addresses of actual pages,</span>
<span class="p_del">- * or Page Table Entries (PTEs).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Here&#39;s a diagram, where arrows indicate physical addresses:</span>
<span class="p_del">- *</span>
<span class="p_del">- * cr3 ---&gt; +---------+</span>
<span class="p_del">- *	    |  	   ---------&gt;+---------+</span>
<span class="p_del">- *	    |	      |	     | PADDR1  |</span>
<span class="p_del">- *	  Mid-level   |	     | PADDR2  |</span>
<span class="p_del">- *	  (PMD) page  |	     | 	       |</span>
<span class="p_del">- *	    |	      |	   Lower-level |</span>
<span class="p_del">- *	    |	      |	   (PTE) page  |</span>
<span class="p_del">- *	    |	      |	     |	       |</span>
<span class="p_del">- *	      ....    	     	 ....</span>
<span class="p_del">- *</span>
<span class="p_del">- * So to convert a virtual address to a physical address, we look up the top</span>
<span class="p_del">- * level, which points us to the second level, which gives us the physical</span>
<span class="p_del">- * address of that page.  If the top level entry was not present, or the second</span>
<span class="p_del">- * level entry was not present, then the virtual address is invalid (we</span>
<span class="p_del">- * say &quot;the page was not mapped&quot;).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Put another way, a 32-bit virtual address is divided up like so:</span>
<span class="p_del">- *</span>
<span class="p_del">- *  1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="p_del">- * |&lt;---- 10 bits ----&gt;|&lt;---- 10 bits ----&gt;|&lt;------ 12 bits ------&gt;|</span>
<span class="p_del">- *    Index into top     Index into second      Offset within page</span>
<span class="p_del">- *  page directory page    pagetable page</span>
<span class="p_del">- *</span>
<span class="p_del">- * Now, unfortunately, this isn&#39;t the whole story: Intel added Physical Address</span>
<span class="p_del">- * Extension (PAE) to allow 32 bit systems to use 64GB of memory (ie. 36 bits).</span>
<span class="p_del">- * These are held in 64-bit page table entries, so we can now only fit 512</span>
<span class="p_del">- * entries in a page, and the neat three-level tree breaks down.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The result is a four level page table:</span>
<span class="p_del">- *</span>
<span class="p_del">- * cr3 --&gt; [ 4 Upper  ]</span>
<span class="p_del">- *	   [   Level  ]</span>
<span class="p_del">- *	   [  Entries ]</span>
<span class="p_del">- *	   [(PUD Page)]---&gt; +---------+</span>
<span class="p_del">- *	 		    |  	   ---------&gt;+---------+</span>
<span class="p_del">- *	 		    |	      |	     | PADDR1  |</span>
<span class="p_del">- *	 		  Mid-level   |	     | PADDR2  |</span>
<span class="p_del">- *	 		  (PMD) page  |	     | 	       |</span>
<span class="p_del">- *	 		    |	      |	   Lower-level |</span>
<span class="p_del">- *	 		    |	      |	   (PTE) page  |</span>
<span class="p_del">- *	 		    |	      |	     |	       |</span>
<span class="p_del">- *	 		      ....    	     	 ....</span>
<span class="p_del">- *</span>
<span class="p_del">- *</span>
<span class="p_del">- * And the virtual address is decoded as:</span>
<span class="p_del">- *</span>
<span class="p_del">- *         1 1 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>
<span class="p_del">- *      |&lt;-2-&gt;|&lt;--- 9 bits ----&gt;|&lt;---- 9 bits ---&gt;|&lt;------ 12 bits ------&gt;|</span>
<span class="p_del">- * Index into    Index into mid    Index into lower    Offset within page</span>
<span class="p_del">- * top entries   directory page     pagetable page</span>
<span class="p_del">- *</span>
<span class="p_del">- * It&#39;s too hard to switch between these two formats at runtime, so Linux only</span>
<span class="p_del">- * supports one or the other depending on whether CONFIG_X86_PAE is set.  Many</span>
<span class="p_del">- * distributions turn it on, and not just for people with silly amounts of</span>
<span class="p_del">- * memory: the larger PTE entries allow room for the NX bit, which lets the</span>
<span class="p_del">- * kernel disable execution of pages and increase security.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This was a problem for lguest, which couldn&#39;t run on these distributions;</span>
<span class="p_del">- * then Matias Zabaljauregui figured it all out and implemented it, and only a</span>
<span class="p_del">- * handful of puppies were crushed in the process!</span>
<span class="p_del">- *</span>
<span class="p_del">- * Back to our point: the kernel spends a lot of time changing both the</span>
<span class="p_del">- * top-level page directory and lower-level pagetable pages.  The Guest doesn&#39;t</span>
<span class="p_del">- * know physical addresses, so while it maintains these page tables exactly</span>
<span class="p_del">- * like normal, it also needs to keep the Host informed whenever it makes a</span>
<span class="p_del">- * change: the Host will create the real page tables based on the Guests&#39;.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Guest calls this after it has set a second-level entry (pte), ie. to map</span>
<span class="p_del">- * a page into a process&#39; address space.  We tell the Host the toplevel and</span>
<span class="p_del">- * address this corresponds to.  The Guest uses one pagetable per process, so</span>
<span class="p_del">- * we need to tell the Host which one we&#39;re changing (mm-&gt;pgd).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_pte_update(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-			       pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	/* PAE needs to hand a 64 bit page table entry, so it uses two args. */</span>
<span class="p_del">-	lazy_hcall4(LHCALL_SET_PTE, __pa(mm-&gt;pgd), addr,</span>
<span class="p_del">-		    ptep-&gt;pte_low, ptep-&gt;pte_high);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	lazy_hcall3(LHCALL_SET_PTE, __pa(mm-&gt;pgd), addr, ptep-&gt;pte_low);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the &quot;set and update&quot; combo-meal-deal version. */</span>
<span class="p_del">-static void lguest_set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-			      pte_t *ptep, pte_t pteval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_set_pte(ptep, pteval);</span>
<span class="p_del">-	lguest_pte_update(mm, addr, ptep);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Guest calls lguest_set_pud to set a top-level entry and lguest_set_pmd</span>
<span class="p_del">- * to set a middle-level entry when PAE is activated.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Again, we set the entry then tell the Host which page we changed,</span>
<span class="p_del">- * and the index of the entry we changed.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-static void lguest_set_pud(pud_t *pudp, pud_t pudval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_set_pud(pudp, pudval);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 32 bytes aligned pdpt address and the index. */</span>
<span class="p_del">-	lazy_hcall2(LHCALL_SET_PGD, __pa(pudp) &amp; 0xFFFFFFE0,</span>
<span class="p_del">-		   (__pa(pudp) &amp; 0x1F) / sizeof(pud_t));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lguest_set_pmd(pmd_t *pmdp, pmd_t pmdval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_set_pmd(pmdp, pmdval);</span>
<span class="p_del">-	lazy_hcall2(LHCALL_SET_PMD, __pa(pmdp) &amp; PAGE_MASK,</span>
<span class="p_del">-		   (__pa(pmdp) &amp; (PAGE_SIZE - 1)) / sizeof(pmd_t));</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-</span>
<span class="p_del">-/* The Guest calls lguest_set_pmd to set a top-level entry when !PAE. */</span>
<span class="p_del">-static void lguest_set_pmd(pmd_t *pmdp, pmd_t pmdval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_set_pmd(pmdp, pmdval);</span>
<span class="p_del">-	lazy_hcall2(LHCALL_SET_PGD, __pa(pmdp) &amp; PAGE_MASK,</span>
<span class="p_del">-		   (__pa(pmdp) &amp; (PAGE_SIZE - 1)) / sizeof(pmd_t));</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * There are a couple of legacy places where the kernel sets a PTE, but we</span>
<span class="p_del">- * don&#39;t know the top level any more.  This is useless for us, since we don&#39;t</span>
<span class="p_del">- * know which pagetable is changing or what address, so we just tell the Host</span>
<span class="p_del">- * to forget all of them.  Fortunately, this is very rare.</span>
<span class="p_del">- *</span>
<span class="p_del">- * ... except in early boot when the kernel sets up the initial pagetables,</span>
<span class="p_del">- * which makes booting astonishingly slow: 48 seconds!  So we don&#39;t even tell</span>
<span class="p_del">- * the Host anything changed until we&#39;ve done the first real page table switch,</span>
<span class="p_del">- * which brings boot back to 4.3 seconds.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_set_pte(pte_t *ptep, pte_t pteval)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_set_pte(ptep, pteval);</span>
<span class="p_del">-	if (cr3_changed)</span>
<span class="p_del">-		lazy_hcall1(LHCALL_FLUSH_TLB, 1);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-/*</span>
<span class="p_del">- * With 64-bit PTE values, we need to be careful setting them: if we set 32</span>
<span class="p_del">- * bits at a time, the hardware could see a weird half-set entry.  These</span>
<span class="p_del">- * versions ensure we update all 64 bits at once.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_set_pte_atomic(pte_t *ptep, pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_set_pte_atomic(ptep, pte);</span>
<span class="p_del">-	if (cr3_changed)</span>
<span class="p_del">-		lazy_hcall1(LHCALL_FLUSH_TLB, 1);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lguest_pte_clear(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-			     pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-	native_pte_clear(mm, addr, ptep);</span>
<span class="p_del">-	lguest_pte_update(mm, addr, ptep);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lguest_pmd_clear(pmd_t *pmdp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	lguest_set_pmd(pmdp, __pmd(0));</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Unfortunately for Lguest, the pv_mmu_ops for page tables were based on</span>
<span class="p_del">- * native page table operations.  On native hardware you can set a new page</span>
<span class="p_del">- * table entry whenever you want, but if you want to remove one you have to do</span>
<span class="p_del">- * a TLB flush (a TLB is a little cache of page table entries kept by the CPU).</span>
<span class="p_del">- *</span>
<span class="p_del">- * So the lguest_set_pte_at() and lguest_set_pmd() functions above are only</span>
<span class="p_del">- * called when a valid entry is written, not when it&#39;s removed (ie. marked not</span>
<span class="p_del">- * present).  Instead, this is where we come when the Guest wants to remove a</span>
<span class="p_del">- * page table entry: we tell the Host to set that entry to 0 (ie. the present</span>
<span class="p_del">- * bit is zero).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_flush_tlb_single(unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Simply set it to zero: if it was not, it will fault back in. */</span>
<span class="p_del">-	lazy_hcall3(LHCALL_SET_PTE, current_cr3, addr, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is what happens after the Guest has removed a large number of entries.</span>
<span class="p_del">- * This tells the Host that any of the page table entries for userspace might</span>
<span class="p_del">- * have changed, ie. virtual addresses below PAGE_OFFSET.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_flush_tlb_user(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	lazy_hcall1(LHCALL_FLUSH_TLB, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is called when the kernel page tables have changed.  That&#39;s not very</span>
<span class="p_del">- * common (unless the Guest is using highmem, which makes the Guest extremely</span>
<span class="p_del">- * slow), so it&#39;s worth separating this from the user flushing above.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_flush_tlb_kernel(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	lazy_hcall1(LHCALL_FLUSH_TLB, 1);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Unadvanced Programmable Interrupt Controller.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is an attempt to implement the simplest possible interrupt controller.</span>
<span class="p_del">- * I spent some time looking though routines like set_irq_chip_and_handler,</span>
<span class="p_del">- * set_irq_chip_and_handler_name, set_irq_chip_data and set_phasers_to_stun and</span>
<span class="p_del">- * I *think* this is as simple as it gets.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We can tell the Host what interrupts we want blocked ready for using the</span>
<span class="p_del">- * lguest_data.interrupts bitmap, so disabling (aka &quot;masking&quot;) them is as</span>
<span class="p_del">- * simple as setting a bit.  We don&#39;t actually &quot;ack&quot; interrupts as such, we</span>
<span class="p_del">- * just mask and unmask them.  I wonder if we should be cleverer?</span>
<span class="p_del">- */</span>
<span class="p_del">-static void disable_lguest_irq(struct irq_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	set_bit(data-&gt;irq, lguest_data.blocked_interrupts);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void enable_lguest_irq(struct irq_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	clear_bit(data-&gt;irq, lguest_data.blocked_interrupts);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This structure describes the lguest IRQ controller. */</span>
<span class="p_del">-static struct irq_chip lguest_irq_controller = {</span>
<span class="p_del">-	.name		= &quot;lguest&quot;,</span>
<span class="p_del">-	.irq_mask	= disable_lguest_irq,</span>
<span class="p_del">-	.irq_mask_ack	= disable_lguest_irq,</span>
<span class="p_del">-	.irq_unmask	= enable_lguest_irq,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Interrupt descriptors are allocated as-needed, but low-numbered ones are</span>
<span class="p_del">- * reserved by the generic x86 code.  So we ignore irq_alloc_desc_at if it</span>
<span class="p_del">- * tells us the irq is already used: other errors (ie. ENOMEM) we take</span>
<span class="p_del">- * seriously.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int lguest_setup_irq(unsigned int irq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct irq_desc *desc;</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Returns -ve error or vector number. */</span>
<span class="p_del">-	err = irq_alloc_desc_at(irq, 0);</span>
<span class="p_del">-	if (err &lt; 0 &amp;&amp; err != -EEXIST)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Tell the Linux infrastructure that the interrupt is</span>
<span class="p_del">-	 * controlled by our level-based lguest interrupt controller.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	irq_set_chip_and_handler_name(irq, &amp;lguest_irq_controller,</span>
<span class="p_del">-				      handle_level_irq, &quot;level&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Some systems map &quot;vectors&quot; to interrupts weirdly.  Not us! */</span>
<span class="p_del">-	desc = irq_to_desc(irq);</span>
<span class="p_del">-	__this_cpu_write(vector_irq[FIRST_EXTERNAL_VECTOR + irq], desc);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int lguest_enable_irq(struct pci_dev *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-	u8 line = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We literally use the PCI interrupt line as the irq number. */</span>
<span class="p_del">-	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &amp;line);</span>
<span class="p_del">-	err = lguest_setup_irq(line);</span>
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		dev-&gt;irq = line;</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* We don&#39;t do hotplug PCI, so this shouldn&#39;t be called. */</span>
<span class="p_del">-static void lguest_disable_irq(struct pci_dev *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	WARN_ON(1);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This sets up the Interrupt Descriptor Table (IDT) entry for each hardware</span>
<span class="p_del">- * interrupt (except 128, which is used for system calls).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __init lguest_init_IRQ(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = FIRST_EXTERNAL_VECTOR; i &lt; FIRST_SYSTEM_VECTOR; i++) {</span>
<span class="p_del">-		if (i != IA32_SYSCALL_VECTOR)</span>
<span class="p_del">-			set_intr_gate(i, irq_entries_start +</span>
<span class="p_del">-					8 * (i - FIRST_EXTERNAL_VECTOR));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This call is required to set up for 4k stacks, where we have</span>
<span class="p_del">-	 * separate stacks for hard and soft interrupts.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	irq_ctx_init(smp_processor_id());</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Time.</span>
<span class="p_del">- *</span>
<span class="p_del">- * It would be far better for everyone if the Guest had its own clock, but</span>
<span class="p_del">- * until then the Host gives us the time on every interrupt.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_get_wallclock(struct timespec *now)</span>
<span class="p_del">-{</span>
<span class="p_del">-	*now = lguest_data.time;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The TSC is an Intel thing called the Time Stamp Counter.  The Host tells us</span>
<span class="p_del">- * what speed it runs at, or 0 if it&#39;s unusable as a reliable clock source.</span>
<span class="p_del">- * This matches what we want here: if we return 0 from this function, the x86</span>
<span class="p_del">- * TSC clock will give up and not register itself.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long lguest_tsc_khz(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return lguest_data.tsc_khz;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * If we can&#39;t use the TSC, the kernel falls back to our lower-priority</span>
<span class="p_del">- * &quot;lguest_clock&quot;, where we read the time value given to us by the Host.</span>
<span class="p_del">- */</span>
<span class="p_del">-static u64 lguest_clock_read(struct clocksource *cs)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long sec, nsec;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Since the time is in two parts (seconds and nanoseconds), we risk</span>
<span class="p_del">-	 * reading it just as it&#39;s changing from 99 &amp; 0.999999999 to 100 and 0,</span>
<span class="p_del">-	 * and getting 99 and 0.  As Linux tends to come apart under the stress</span>
<span class="p_del">-	 * of time travel, we must be careful:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		/* First we read the seconds part. */</span>
<span class="p_del">-		sec = lguest_data.time.tv_sec;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This read memory barrier tells the compiler and the CPU that</span>
<span class="p_del">-		 * this can&#39;t be reordered: we have to complete the above</span>
<span class="p_del">-		 * before going on.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		rmb();</span>
<span class="p_del">-		/* Now we read the nanoseconds part. */</span>
<span class="p_del">-		nsec = lguest_data.time.tv_nsec;</span>
<span class="p_del">-		/* Make sure we&#39;ve done that. */</span>
<span class="p_del">-		rmb();</span>
<span class="p_del">-		/* Now if the seconds part has changed, try again. */</span>
<span class="p_del">-	} while (unlikely(lguest_data.time.tv_sec != sec));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Our lguest clock is in real nanoseconds. */</span>
<span class="p_del">-	return sec*1000000000ULL + nsec;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the fallback clocksource: lower priority than the TSC clocksource. */</span>
<span class="p_del">-static struct clocksource lguest_clock = {</span>
<span class="p_del">-	.name		= &quot;lguest&quot;,</span>
<span class="p_del">-	.rating		= 200,</span>
<span class="p_del">-	.read		= lguest_clock_read,</span>
<span class="p_del">-	.mask		= CLOCKSOURCE_MASK(64),</span>
<span class="p_del">-	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We also need a &quot;struct clock_event_device&quot;: Linux asks us to set it to go</span>
<span class="p_del">- * off some time in the future.  Actually, James Morris figured all this out, I</span>
<span class="p_del">- * just applied the patch.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int lguest_clockevent_set_next_event(unsigned long delta,</span>
<span class="p_del">-                                           struct clock_event_device *evt)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* FIXME: I don&#39;t think this can ever happen, but James tells me he had</span>
<span class="p_del">-	 * to put this code in.  Maybe we should remove it now.  Anyone? */</span>
<span class="p_del">-	if (delta &lt; LG_CLOCK_MIN_DELTA) {</span>
<span class="p_del">-		if (printk_ratelimit())</span>
<span class="p_del">-			printk(KERN_DEBUG &quot;%s: small delta %lu ns\n&quot;,</span>
<span class="p_del">-			       __func__, delta);</span>
<span class="p_del">-		return -ETIME;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Please wake us this far in the future. */</span>
<span class="p_del">-	hcall(LHCALL_SET_CLOCKEVENT, delta, 0, 0, 0);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int lguest_clockevent_shutdown(struct clock_event_device *evt)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* A 0 argument shuts the clock down. */</span>
<span class="p_del">-	hcall(LHCALL_SET_CLOCKEVENT, 0, 0, 0, 0);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This describes our primitive timer chip. */</span>
<span class="p_del">-static struct clock_event_device lguest_clockevent = {</span>
<span class="p_del">-	.name                   = &quot;lguest&quot;,</span>
<span class="p_del">-	.features               = CLOCK_EVT_FEAT_ONESHOT,</span>
<span class="p_del">-	.set_next_event         = lguest_clockevent_set_next_event,</span>
<span class="p_del">-	.set_state_shutdown	= lguest_clockevent_shutdown,</span>
<span class="p_del">-	.rating                 = INT_MAX,</span>
<span class="p_del">-	.mult                   = 1,</span>
<span class="p_del">-	.shift                  = 0,</span>
<span class="p_del">-	.min_delta_ns           = LG_CLOCK_MIN_DELTA,</span>
<span class="p_del">-	.min_delta_ticks        = LG_CLOCK_MIN_DELTA,</span>
<span class="p_del">-	.max_delta_ns           = LG_CLOCK_MAX_DELTA,</span>
<span class="p_del">-	.max_delta_ticks        = LG_CLOCK_MAX_DELTA,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is the Guest timer interrupt handler (hardware interrupt 0).  We just</span>
<span class="p_del">- * call the clockevent infrastructure and it does whatever needs doing.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_time_irq(struct irq_desc *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Don&#39;t interrupt us while this is running. */</span>
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_del">-	lguest_clockevent.event_handler(&amp;lguest_clockevent);</span>
<span class="p_del">-	local_irq_restore(flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * At some point in the boot process, we get asked to set up our timing</span>
<span class="p_del">- * infrastructure.  The kernel doesn&#39;t expect timer interrupts before this, but</span>
<span class="p_del">- * we cleverly initialized the &quot;blocked_interrupts&quot; field of &quot;struct</span>
<span class="p_del">- * lguest_data&quot; so that timer interrupts were blocked until now.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_time_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Set up the timer interrupt (0) to go to our simple timer routine */</span>
<span class="p_del">-	if (lguest_setup_irq(0) != 0)</span>
<span class="p_del">-		panic(&quot;Could not set up timer irq&quot;);</span>
<span class="p_del">-	irq_set_handler(0, lguest_time_irq);</span>
<span class="p_del">-</span>
<span class="p_del">-	clocksource_register_hz(&amp;lguest_clock, NSEC_PER_SEC);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We can&#39;t set cpumask in the initializer: damn C limitations!  Set it</span>
<span class="p_del">-	 * here and register our timer device. */</span>
<span class="p_del">-	lguest_clockevent.cpumask = cpumask_of(0);</span>
<span class="p_del">-	clockevents_register_device(&amp;lguest_clockevent);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Finally, we unblock the timer interrupt. */</span>
<span class="p_del">-	clear_bit(0, lguest_data.blocked_interrupts);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Miscellaneous bits and pieces.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Here is an oddball collection of functions which the Guest needs for things</span>
<span class="p_del">- * to work.  They&#39;re pretty simple.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Guest needs to tell the Host what stack it expects traps to use.  For</span>
<span class="p_del">- * native hardware, this is part of the Task State Segment mentioned above in</span>
<span class="p_del">- * lguest_load_tr_desc(), but to help hypervisors there&#39;s this special call.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We tell the Host the segment we want to use (__KERNEL_DS is the kernel data</span>
<span class="p_del">- * segment), the privilege level (we&#39;re privilege level 1, the Host is 0 and</span>
<span class="p_del">- * will not tolerate us trying to use that), the stack pointer, and the number</span>
<span class="p_del">- * of pages in the stack.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_load_sp0(struct tss_struct *tss,</span>
<span class="p_del">-			    struct thread_struct *thread)</span>
<span class="p_del">-{</span>
<span class="p_del">-	lazy_hcall3(LHCALL_SET_STACK, __KERNEL_DS | 0x1, thread-&gt;sp0,</span>
<span class="p_del">-		   THREAD_SIZE / PAGE_SIZE);</span>
<span class="p_del">-	tss-&gt;x86_tss.sp0 = thread-&gt;sp0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Let&#39;s just say, I wouldn&#39;t do debugging under a Guest. */</span>
<span class="p_del">-static unsigned long lguest_get_debugreg(int regno)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* FIXME: Implement */</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lguest_set_debugreg(int regno, unsigned long value)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* FIXME: Implement */</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * There are times when the kernel wants to make sure that no memory writes are</span>
<span class="p_del">- * caught in the cache (that they&#39;ve all reached real hardware devices).  This</span>
<span class="p_del">- * doesn&#39;t matter for the Guest which has virtual hardware.</span>
<span class="p_del">- *</span>
<span class="p_del">- * On the Pentium 4 and above, cpuid() indicates that the Cache Line Flush</span>
<span class="p_del">- * (clflush) instruction is available and the kernel uses that.  Otherwise, it</span>
<span class="p_del">- * uses the older &quot;Write Back and Invalidate Cache&quot; (wbinvd) instruction.</span>
<span class="p_del">- * Unlike clflush, wbinvd can only be run at privilege level 0.  So we can</span>
<span class="p_del">- * ignore clflush, but replace wbinvd.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_wbinvd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * If the Guest expects to have an Advanced Programmable Interrupt Controller,</span>
<span class="p_del">- * we play dumb by ignoring writes and returning 0 for reads.  So it&#39;s no</span>
<span class="p_del">- * longer Programmable nor Controlling anything, and I don&#39;t think 8 lines of</span>
<span class="p_del">- * code qualifies for Advanced.  It will also never interrupt anything.  It</span>
<span class="p_del">- * does, however, allow us to get through the Linux boot code.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="p_del">-static void lguest_apic_write(u32 reg, u32 v)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 lguest_apic_read(u32 reg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static u64 lguest_apic_icr_read(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lguest_apic_icr_write(u32 low, u32 id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Warn to see if there&#39;s any stray references */</span>
<span class="p_del">-	WARN_ON(1);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void lguest_apic_wait_icr_idle(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 lguest_apic_safe_wait_icr_idle(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void set_lguest_basic_apic_ops(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	apic-&gt;read = lguest_apic_read;</span>
<span class="p_del">-	apic-&gt;write = lguest_apic_write;</span>
<span class="p_del">-	apic-&gt;icr_read = lguest_apic_icr_read;</span>
<span class="p_del">-	apic-&gt;icr_write = lguest_apic_icr_write;</span>
<span class="p_del">-	apic-&gt;wait_icr_idle = lguest_apic_wait_icr_idle;</span>
<span class="p_del">-	apic-&gt;safe_wait_icr_idle = lguest_apic_safe_wait_icr_idle;</span>
<span class="p_del">-};</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/* STOP!  Until an interrupt comes in. */</span>
<span class="p_del">-static void lguest_safe_halt(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hcall(LHCALL_HALT, 0, 0, 0, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The SHUTDOWN hypercall takes a string to describe what&#39;s happening, and</span>
<span class="p_del">- * an argument which says whether this to restart (reboot) the Guest or not.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Note that the Host always prefers that the Guest speak in physical addresses</span>
<span class="p_del">- * rather than virtual addresses, so we use __pa() here.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_power_off(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hcall(LHCALL_SHUTDOWN, __pa(&quot;Power down&quot;),</span>
<span class="p_del">-	      LGUEST_SHUTDOWN_POWEROFF, 0, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Panicing.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Don&#39;t.  But if you did, this is what happens.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int lguest_panic(struct notifier_block *nb, unsigned long l, void *p)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hcall(LHCALL_SHUTDOWN, __pa(p), LGUEST_SHUTDOWN_POWEROFF, 0, 0);</span>
<span class="p_del">-	/* The hcall won&#39;t return, but to keep gcc happy, we&#39;re &quot;done&quot;. */</span>
<span class="p_del">-	return NOTIFY_DONE;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct notifier_block paniced = {</span>
<span class="p_del">-	.notifier_call = lguest_panic</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* Setting up memory is fairly easy. */</span>
<span class="p_del">-static __init char *lguest_memory_setup(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Linux bootloader header contains an &quot;e820&quot; memory map: the</span>
<span class="p_del">-	 * Launcher populated the first entry with our memory limit.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	e820__range_add(boot_params.e820_table[0].addr,</span>
<span class="p_del">-			  boot_params.e820_table[0].size,</span>
<span class="p_del">-			  boot_params.e820_table[0].type);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This string is for the boot messages. */</span>
<span class="p_del">-	return &quot;LGUEST&quot;;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Offset within PCI config space of BAR access capability. */</span>
<span class="p_del">-static int console_cfg_offset = 0;</span>
<span class="p_del">-static int console_access_cap;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Set up so that we access off in bar0 (on bus 0, device 1, function 0) */</span>
<span class="p_del">-static void set_cfg_window(u32 cfg_offset, u32 off)</span>
<span class="p_del">-{</span>
<span class="p_del">-	write_pci_config_byte(0, 1, 0,</span>
<span class="p_del">-			      cfg_offset + offsetof(struct virtio_pci_cap, bar),</span>
<span class="p_del">-			      0);</span>
<span class="p_del">-	write_pci_config(0, 1, 0,</span>
<span class="p_del">-			 cfg_offset + offsetof(struct virtio_pci_cap, length),</span>
<span class="p_del">-			 4);</span>
<span class="p_del">-	write_pci_config(0, 1, 0,</span>
<span class="p_del">-			 cfg_offset + offsetof(struct virtio_pci_cap, offset),</span>
<span class="p_del">-			 off);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void write_bar_via_cfg(u32 cfg_offset, u32 off, u32 val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We could set this up once, then leave it; nothing else in the *</span>
<span class="p_del">-	 * kernel should touch these registers.  But if it went wrong, that</span>
<span class="p_del">-	 * would be a horrible bug to find.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	set_cfg_window(cfg_offset, off);</span>
<span class="p_del">-	write_pci_config(0, 1, 0,</span>
<span class="p_del">-			 cfg_offset + sizeof(struct virtio_pci_cap), val);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void probe_pci_console(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 cap, common_cap = 0, device_cap = 0;</span>
<span class="p_del">-	u32 device_len;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Avoid recursive printk into here. */</span>
<span class="p_del">-	console_cfg_offset = -1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!early_pci_allowed()) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;lguest: early PCI access not allowed!\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We expect a console PCI device at BUS0, slot 1. */</span>
<span class="p_del">-	if (read_pci_config(0, 1, 0, 0) != 0x10431AF4) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;lguest: PCI device is %#x!\n&quot;,</span>
<span class="p_del">-		       read_pci_config(0, 1, 0, 0));</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Find the capabilities we need (must be in bar0) */</span>
<span class="p_del">-	cap = read_pci_config_byte(0, 1, 0, PCI_CAPABILITY_LIST);</span>
<span class="p_del">-	while (cap) {</span>
<span class="p_del">-		u8 vndr = read_pci_config_byte(0, 1, 0, cap);</span>
<span class="p_del">-		if (vndr == PCI_CAP_ID_VNDR) {</span>
<span class="p_del">-			u8 type, bar;</span>
<span class="p_del">-</span>
<span class="p_del">-			type = read_pci_config_byte(0, 1, 0,</span>
<span class="p_del">-			    cap + offsetof(struct virtio_pci_cap, cfg_type));</span>
<span class="p_del">-			bar = read_pci_config_byte(0, 1, 0,</span>
<span class="p_del">-			    cap + offsetof(struct virtio_pci_cap, bar));</span>
<span class="p_del">-</span>
<span class="p_del">-			switch (type) {</span>
<span class="p_del">-			case VIRTIO_PCI_CAP_DEVICE_CFG:</span>
<span class="p_del">-				if (bar == 0)</span>
<span class="p_del">-					device_cap = cap;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case VIRTIO_PCI_CAP_PCI_CFG:</span>
<span class="p_del">-				console_access_cap = cap;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-		cap = read_pci_config_byte(0, 1, 0, cap + PCI_CAP_LIST_NEXT);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (!device_cap || !console_access_cap) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;lguest: No caps (%u/%u/%u) in console!\n&quot;,</span>
<span class="p_del">-		       common_cap, device_cap, console_access_cap);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Note that we can&#39;t check features, until we&#39;ve set the DRIVER</span>
<span class="p_del">-	 * status bit.  We don&#39;t want to do that until we have a real driver,</span>
<span class="p_del">-	 * so we just check that the device-specific config has room for</span>
<span class="p_del">-	 * emerg_wr.  If it doesn&#39;t support VIRTIO_CONSOLE_F_EMERG_WRITE</span>
<span class="p_del">-	 * it should ignore the access.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	device_len = read_pci_config(0, 1, 0,</span>
<span class="p_del">-			device_cap + offsetof(struct virtio_pci_cap, length));</span>
<span class="p_del">-	if (device_len &lt; (offsetof(struct virtio_console_config, emerg_wr)</span>
<span class="p_del">-			  + sizeof(u32))) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;lguest: console missing emerg_wr field\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	console_cfg_offset = read_pci_config(0, 1, 0,</span>
<span class="p_del">-			device_cap + offsetof(struct virtio_pci_cap, offset));</span>
<span class="p_del">-	printk(KERN_INFO &quot;lguest: Console via virtio-pci emerg_wr\n&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We will eventually use the virtio console device to produce console output,</span>
<span class="p_del">- * but before that is set up we use the virtio PCI console&#39;s backdoor mmio</span>
<span class="p_del">- * access and the &quot;emergency&quot; write facility (which is legal even before the</span>
<span class="p_del">- * device is configured).</span>
<span class="p_del">- */</span>
<span class="p_del">-static __init int early_put_chars(u32 vtermno, const char *buf, int count)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If we couldn&#39;t find PCI console, forget it. */</span>
<span class="p_del">-	if (console_cfg_offset &lt; 0)</span>
<span class="p_del">-		return count;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(!console_cfg_offset)) {</span>
<span class="p_del">-		probe_pci_console();</span>
<span class="p_del">-		if (console_cfg_offset &lt; 0)</span>
<span class="p_del">-			return count;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	write_bar_via_cfg(console_access_cap,</span>
<span class="p_del">-			  console_cfg_offset</span>
<span class="p_del">-			  + offsetof(struct virtio_console_config, emerg_wr),</span>
<span class="p_del">-			  buf[0]);</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Rebooting also tells the Host we&#39;re finished, but the RESTART flag tells the</span>
<span class="p_del">- * Launcher to reboot us.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void lguest_restart(char *reason)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hcall(LHCALL_SHUTDOWN, __pa(reason), LGUEST_SHUTDOWN_RESTART, 0, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:050</span>
<span class="p_del">- * Patching (Powerfully Placating Performance Pedants)</span>
<span class="p_del">- *</span>
<span class="p_del">- * We have already seen that pv_ops structures let us replace simple native</span>
<span class="p_del">- * instructions with calls to the appropriate back end all throughout the</span>
<span class="p_del">- * kernel.  This allows the same kernel to run as a Guest and as a native</span>
<span class="p_del">- * kernel, but it&#39;s slow because of all the indirect branches.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Remember that David Wheeler quote about &quot;Any problem in computer science can</span>
<span class="p_del">- * be solved with another layer of indirection&quot;?  The rest of that quote is</span>
<span class="p_del">- * &quot;... But that usually will create another problem.&quot;  This is the first of</span>
<span class="p_del">- * those problems.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Our current solution is to allow the paravirt back end to optionally patch</span>
<span class="p_del">- * over the indirect calls to replace them with something more efficient.  We</span>
<span class="p_del">- * patch two of the simplest of the most commonly called functions: disable</span>
<span class="p_del">- * interrupts and save interrupts.  We usually have 6 or 10 bytes to patch</span>
<span class="p_del">- * into: the Guest versions of these operations are small enough that we can</span>
<span class="p_del">- * fit comfortably.</span>
<span class="p_del">- *</span>
<span class="p_del">- * First we need assembly templates of each of the patchable Guest operations,</span>
<span class="p_del">- * and these are in head_32.S.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:060 We construct a table from the assembler templates: */</span>
<span class="p_del">-static const struct lguest_insns</span>
<span class="p_del">-{</span>
<span class="p_del">-	const char *start, *end;</span>
<span class="p_del">-} lguest_insns[] = {</span>
<span class="p_del">-	[PARAVIRT_PATCH(pv_irq_ops.irq_disable)] = { lgstart_cli, lgend_cli },</span>
<span class="p_del">-	[PARAVIRT_PATCH(pv_irq_ops.save_fl)] = { lgstart_pushf, lgend_pushf },</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Now our patch routine is fairly simple (based on the native one in</span>
<span class="p_del">- * paravirt.c).  If we have a replacement, we copy it in and return how much of</span>
<span class="p_del">- * the available space we used.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned lguest_patch(u8 type, u16 clobber, void *ibuf,</span>
<span class="p_del">-			     unsigned long addr, unsigned len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int insn_len;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Don&#39;t do anything special if we don&#39;t have a replacement */</span>
<span class="p_del">-	if (type &gt;= ARRAY_SIZE(lguest_insns) || !lguest_insns[type].start)</span>
<span class="p_del">-		return paravirt_patch_default(type, clobber, ibuf, addr, len);</span>
<span class="p_del">-</span>
<span class="p_del">-	insn_len = lguest_insns[type].end - lguest_insns[type].start;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Similarly if it can&#39;t fit (doesn&#39;t happen, but let&#39;s be thorough). */</span>
<span class="p_del">-	if (len &lt; insn_len)</span>
<span class="p_del">-		return paravirt_patch_default(type, clobber, ibuf, addr, len);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Copy in our instructions. */</span>
<span class="p_del">-	memcpy(ibuf, lguest_insns[type].start, insn_len);</span>
<span class="p_del">-	return insn_len;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:029</span>
<span class="p_del">- * Once we get to lguest_init(), we know we&#39;re a Guest.  The various</span>
<span class="p_del">- * pv_ops structures in the kernel provide points for (almost) every routine we</span>
<span class="p_del">- * have to override to avoid privileged instructions.</span>
<span class="p_del">- */</span>
<span class="p_del">-__init void lguest_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* We&#39;re under lguest. */</span>
<span class="p_del">-	pv_info.name = &quot;lguest&quot;;</span>
<span class="p_del">-	/* We&#39;re running at privilege level 1, not 0 as normal. */</span>
<span class="p_del">-	pv_info.kernel_rpl = 1;</span>
<span class="p_del">-	/* Everyone except Xen runs with this set. */</span>
<span class="p_del">-	pv_info.shared_kernel_pmd = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We set up all the lguest overrides for sensitive operations.  These</span>
<span class="p_del">-	 * are detailed with the operations themselves.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Interrupt-related operations */</span>
<span class="p_del">-	pv_irq_ops.save_fl = PV_CALLEE_SAVE(lguest_save_fl);</span>
<span class="p_del">-	pv_irq_ops.restore_fl = __PV_IS_CALLEE_SAVE(lg_restore_fl);</span>
<span class="p_del">-	pv_irq_ops.irq_disable = PV_CALLEE_SAVE(lguest_irq_disable);</span>
<span class="p_del">-	pv_irq_ops.irq_enable = __PV_IS_CALLEE_SAVE(lg_irq_enable);</span>
<span class="p_del">-	pv_irq_ops.safe_halt = lguest_safe_halt;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Setup operations */</span>
<span class="p_del">-	pv_init_ops.patch = lguest_patch;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Intercepts of various CPU instructions */</span>
<span class="p_del">-	pv_cpu_ops.load_gdt = lguest_load_gdt;</span>
<span class="p_del">-	pv_cpu_ops.cpuid = lguest_cpuid;</span>
<span class="p_del">-	pv_cpu_ops.load_idt = lguest_load_idt;</span>
<span class="p_del">-	pv_cpu_ops.iret = lguest_iret;</span>
<span class="p_del">-	pv_cpu_ops.load_sp0 = lguest_load_sp0;</span>
<span class="p_del">-	pv_cpu_ops.load_tr_desc = lguest_load_tr_desc;</span>
<span class="p_del">-	pv_cpu_ops.set_ldt = lguest_set_ldt;</span>
<span class="p_del">-	pv_cpu_ops.load_tls = lguest_load_tls;</span>
<span class="p_del">-	pv_cpu_ops.get_debugreg = lguest_get_debugreg;</span>
<span class="p_del">-	pv_cpu_ops.set_debugreg = lguest_set_debugreg;</span>
<span class="p_del">-	pv_cpu_ops.read_cr0 = lguest_read_cr0;</span>
<span class="p_del">-	pv_cpu_ops.write_cr0 = lguest_write_cr0;</span>
<span class="p_del">-	pv_cpu_ops.read_cr4 = lguest_read_cr4;</span>
<span class="p_del">-	pv_cpu_ops.write_cr4 = lguest_write_cr4;</span>
<span class="p_del">-	pv_cpu_ops.write_gdt_entry = lguest_write_gdt_entry;</span>
<span class="p_del">-	pv_cpu_ops.write_idt_entry = lguest_write_idt_entry;</span>
<span class="p_del">-	pv_cpu_ops.wbinvd = lguest_wbinvd;</span>
<span class="p_del">-	pv_cpu_ops.start_context_switch = paravirt_start_context_switch;</span>
<span class="p_del">-	pv_cpu_ops.end_context_switch = lguest_end_context_switch;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Pagetable management */</span>
<span class="p_del">-	pv_mmu_ops.write_cr3 = lguest_write_cr3;</span>
<span class="p_del">-	pv_mmu_ops.flush_tlb_user = lguest_flush_tlb_user;</span>
<span class="p_del">-	pv_mmu_ops.flush_tlb_single = lguest_flush_tlb_single;</span>
<span class="p_del">-	pv_mmu_ops.flush_tlb_kernel = lguest_flush_tlb_kernel;</span>
<span class="p_del">-	pv_mmu_ops.set_pte = lguest_set_pte;</span>
<span class="p_del">-	pv_mmu_ops.set_pte_at = lguest_set_pte_at;</span>
<span class="p_del">-	pv_mmu_ops.set_pmd = lguest_set_pmd;</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	pv_mmu_ops.set_pte_atomic = lguest_set_pte_atomic;</span>
<span class="p_del">-	pv_mmu_ops.pte_clear = lguest_pte_clear;</span>
<span class="p_del">-	pv_mmu_ops.pmd_clear = lguest_pmd_clear;</span>
<span class="p_del">-	pv_mmu_ops.set_pud = lguest_set_pud;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	pv_mmu_ops.read_cr2 = lguest_read_cr2;</span>
<span class="p_del">-	pv_mmu_ops.read_cr3 = lguest_read_cr3;</span>
<span class="p_del">-	pv_mmu_ops.lazy_mode.enter = paravirt_enter_lazy_mmu;</span>
<span class="p_del">-	pv_mmu_ops.lazy_mode.leave = lguest_leave_lazy_mmu_mode;</span>
<span class="p_del">-	pv_mmu_ops.lazy_mode.flush = paravirt_flush_lazy_mmu;</span>
<span class="p_del">-	pv_mmu_ops.pte_update = lguest_pte_update;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_LOCAL_APIC</span>
<span class="p_del">-	/* APIC read/write intercepts */</span>
<span class="p_del">-	set_lguest_basic_apic_ops();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	x86_init.resources.memory_setup = lguest_memory_setup;</span>
<span class="p_del">-	x86_init.irqs.intr_init = lguest_init_IRQ;</span>
<span class="p_del">-	x86_init.timers.timer_init = lguest_time_init;</span>
<span class="p_del">-	x86_platform.calibrate_tsc = lguest_tsc_khz;</span>
<span class="p_del">-	x86_platform.get_wallclock =  lguest_get_wallclock;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now is a good time to look at the implementations of these functions</span>
<span class="p_del">-	 * before returning to the rest of lguest_init().</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/*G:070</span>
<span class="p_del">-	 * Now we&#39;ve seen all the paravirt_ops, we return to</span>
<span class="p_del">-	 * lguest_init() where the rest of the fairly chaotic boot setup</span>
<span class="p_del">-	 * occurs.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The stack protector is a weird thing where gcc places a canary</span>
<span class="p_del">-	 * value on the stack and then checks it on return.  This file is</span>
<span class="p_del">-	 * compiled with -fno-stack-protector it, so we got this far without</span>
<span class="p_del">-	 * problems.  The value of the canary is kept at offset 20 from the</span>
<span class="p_del">-	 * %gs register, so we need to set that up before calling C functions</span>
<span class="p_del">-	 * in other files.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	setup_stack_canary_segment(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We could just call load_stack_canary_segment(), but we might as well</span>
<span class="p_del">-	 * call switch_to_new_gdt() which loads the whole table and sets up the</span>
<span class="p_del">-	 * per-cpu segment descriptor register %fs as well.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	switch_to_new_gdt(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Host&lt;-&gt;Guest Switcher lives at the top of our address space, and</span>
<span class="p_del">-	 * the Host told us how big it is when we made LGUEST_INIT hypercall:</span>
<span class="p_del">-	 * it put the answer in lguest_data.reserve_mem</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	reserve_top_address(lguest_data.reserve_mem);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Hook in our special panic hypercall code. */</span>
<span class="p_del">-	atomic_notifier_chain_register(&amp;panic_notifier_list, &amp;paniced);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This is messy CPU setup stuff which the native boot code does before</span>
<span class="p_del">-	 * start_kernel, so we have to do, too:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu_detect(&amp;new_cpu_data);</span>
<span class="p_del">-	/* head.S usually sets up the first capability word, so do it here. */</span>
<span class="p_del">-	new_cpu_data.x86_capability[CPUID_1_EDX] = cpuid_edx(1);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Math is always hard! */</span>
<span class="p_del">-	set_cpu_cap(&amp;new_cpu_data, X86_FEATURE_FPU);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We don&#39;t have features.  We have puppies!  Puppies! */</span>
<span class="p_del">-#ifdef CONFIG_X86_MCE</span>
<span class="p_del">-	mca_cfg.disabled = true;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_ACPI</span>
<span class="p_del">-	acpi_disabled = 1;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We set the preferred console to &quot;hvc&quot;.  This is the &quot;hypervisor</span>
<span class="p_del">-	 * virtual console&quot; driver written by the PowerPC people, which we also</span>
<span class="p_del">-	 * adapted for lguest&#39;s use.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	add_preferred_console(&quot;hvc&quot;, 0, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Register our very early console. */</span>
<span class="p_del">-	virtio_cons_early_init(early_put_chars);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Don&#39;t let ACPI try to control our PCI interrupts. */</span>
<span class="p_del">-	disable_acpi();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We control them ourselves, by overriding these two hooks. */</span>
<span class="p_del">-	pcibios_enable_irq = lguest_enable_irq;</span>
<span class="p_del">-	pcibios_disable_irq = lguest_disable_irq;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Last of all, we set the power management poweroff hook to point to</span>
<span class="p_del">-	 * the Guest routine to power off, and the reboot hook to our restart</span>
<span class="p_del">-	 * routine.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pm_power_off = lguest_power_off;</span>
<span class="p_del">-	machine_ops.restart = lguest_restart;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now we&#39;re set up, call i386_start_kernel() in head32.c and we proceed</span>
<span class="p_del">-	 * to boot as normal.  It never returns.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	i386_start_kernel();</span>
<span class="p_del">-}</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This marks the end of stage II of our journey, The Guest.</span>
<span class="p_del">- *</span>
<span class="p_del">- * It is now time for us to explore the layer of virtual drivers and complete</span>
<span class="p_del">- * our understanding of the Guest in &quot;make Drivers&quot;.</span>
<span class="p_del">- */</span>
<span class="p_header">diff --git a/arch/x86/lguest/head_32.S b/arch/x86/lguest/head_32.S</span>
deleted file mode 100644
<span class="p_header">index d5ae63f5ec5d..000000000000</span>
<span class="p_header">--- a/arch/x86/lguest/head_32.S</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,192 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#include &lt;linux/linkage.h&gt;</span>
<span class="p_del">-#include &lt;linux/lguest.h&gt;</span>
<span class="p_del">-#include &lt;asm/lguest_hcall.h&gt;</span>
<span class="p_del">-#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_del">-#include &lt;asm/thread_info.h&gt;</span>
<span class="p_del">-#include &lt;asm/processor-flags.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:020</span>
<span class="p_del">-</span>
<span class="p_del">- * Our story starts with the bzImage: booting starts at startup_32 in</span>
<span class="p_del">- * arch/x86/boot/compressed/head_32.S.  This merely uncompresses the real</span>
<span class="p_del">- * kernel in place and then jumps into it: startup_32 in</span>
<span class="p_del">- * arch/x86/kernel/head_32.S.  Both routines expects a boot header in the %esi</span>
<span class="p_del">- * register, which is created by the bootloader (the Launcher in our case).</span>
<span class="p_del">- *</span>
<span class="p_del">- * The startup_32 function does very little: it clears the uninitialized global</span>
<span class="p_del">- * C variables which we expect to be zero (ie. BSS) and then copies the boot</span>
<span class="p_del">- * header and kernel command line somewhere safe, and populates some initial</span>
<span class="p_del">- * page tables.  Finally it checks the &#39;hardware_subarch&#39; field.  This was</span>
<span class="p_del">- * introduced in 2.6.24 for lguest and Xen: if it&#39;s set to &#39;1&#39; (lguest&#39;s</span>
<span class="p_del">- * assigned number), then it calls us here.</span>
<span class="p_del">- *</span>
<span class="p_del">- * WARNING: be very careful here!  We&#39;re running at addresses equal to physical</span>
<span class="p_del">- * addresses (around 0), not above PAGE_OFFSET as most code expects</span>
<span class="p_del">- * (eg. 0xC0000000).  Jumps are relative, so they&#39;re OK, but we can&#39;t touch any</span>
<span class="p_del">- * data without remembering to subtract __PAGE_OFFSET!</span>
<span class="p_del">- *</span>
<span class="p_del">- * The .section line puts this code in .init.text so it will be discarded after</span>
<span class="p_del">- * boot.</span>
<span class="p_del">- */</span>
<span class="p_del">-.section .init.text, &quot;ax&quot;, @progbits</span>
<span class="p_del">-ENTRY(lguest_entry)</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We make the &quot;initialization&quot; hypercall now to tell the Host where</span>
<span class="p_del">-	 * our lguest_data struct is.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	movl $LHCALL_LGUEST_INIT, %eax</span>
<span class="p_del">-	movl $lguest_data - __PAGE_OFFSET, %ebx</span>
<span class="p_del">-	int $LGUEST_TRAP_ENTRY</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now turn our pagetables on; setup by arch/x86/kernel/head_32.S. */</span>
<span class="p_del">-	movl $LHCALL_NEW_PGTABLE, %eax</span>
<span class="p_del">-	movl $(initial_page_table - __PAGE_OFFSET), %ebx</span>
<span class="p_del">-	int $LGUEST_TRAP_ENTRY</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set up the initial stack so we can run C code. */</span>
<span class="p_del">-	movl $(init_thread_union+THREAD_SIZE),%esp</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Jumps are relative: we&#39;re running __PAGE_OFFSET too low. */</span>
<span class="p_del">-	jmp lguest_init+__PAGE_OFFSET</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:055</span>
<span class="p_del">- * We create a macro which puts the assembler code between lgstart_ and lgend_</span>
<span class="p_del">- * markers.  These templates are put in the .text section: they can&#39;t be</span>
<span class="p_del">- * discarded after boot as we may need to patch modules, too.</span>
<span class="p_del">- */</span>
<span class="p_del">-.text</span>
<span class="p_del">-#define LGUEST_PATCH(name, insns...)			\</span>
<span class="p_del">-	lgstart_##name:	insns; lgend_##name:;		\</span>
<span class="p_del">-	.globl lgstart_##name; .globl lgend_##name</span>
<span class="p_del">-</span>
<span class="p_del">-LGUEST_PATCH(cli, movl $0, lguest_data+LGUEST_DATA_irq_enabled)</span>
<span class="p_del">-LGUEST_PATCH(pushf, movl lguest_data+LGUEST_DATA_irq_enabled, %eax)</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:033</span>
<span class="p_del">- * But using those wrappers is inefficient (we&#39;ll see why that doesn&#39;t matter</span>
<span class="p_del">- * for save_fl and irq_disable later).  If we write our routines carefully in</span>
<span class="p_del">- * assembler, we can avoid clobbering any registers and avoid jumping through</span>
<span class="p_del">- * the wrapper functions.</span>
<span class="p_del">- *</span>
<span class="p_del">- * I skipped over our first piece of assembler, but this one is worth studying</span>
<span class="p_del">- * in a bit more detail so I&#39;ll describe in easy stages.  First, the routine to</span>
<span class="p_del">- * enable interrupts:</span>
<span class="p_del">- */</span>
<span class="p_del">-ENTRY(lg_irq_enable)</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The reverse of irq_disable, this sets lguest_data.irq_enabled to</span>
<span class="p_del">-	 * X86_EFLAGS_IF (ie. &quot;Interrupts enabled&quot;).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	movl $X86_EFLAGS_IF, lguest_data+LGUEST_DATA_irq_enabled</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * But now we need to check if the Host wants to know: there might have</span>
<span class="p_del">-	 * been interrupts waiting to be delivered, in which case it will have</span>
<span class="p_del">-	 * set lguest_data.irq_pending to X86_EFLAGS_IF.  If it&#39;s not zero, we</span>
<span class="p_del">-	 * jump to send_interrupts, otherwise we&#39;re done.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cmpl $0, lguest_data+LGUEST_DATA_irq_pending</span>
<span class="p_del">-	jnz send_interrupts</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * One cool thing about x86 is that you can do many things without using</span>
<span class="p_del">-	 * a register.  In this case, the normal path hasn&#39;t needed to save or</span>
<span class="p_del">-	 * restore any registers at all!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret</span>
<span class="p_del">-send_interrupts:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * OK, now we need a register: eax is used for the hypercall number,</span>
<span class="p_del">-	 * which is LHCALL_SEND_INTERRUPTS.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We used not to bother with this pending detection at all, which was</span>
<span class="p_del">-	 * much simpler.  Sooner or later the Host would realize it had to</span>
<span class="p_del">-	 * send us an interrupt.  But that turns out to make performance 7</span>
<span class="p_del">-	 * times worse on a simple tcp benchmark.  So now we do this the hard</span>
<span class="p_del">-	 * way.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pushl %eax</span>
<span class="p_del">-	movl $LHCALL_SEND_INTERRUPTS, %eax</span>
<span class="p_del">-	/* This is the actual hypercall trap. */</span>
<span class="p_del">-	int  $LGUEST_TRAP_ENTRY</span>
<span class="p_del">-	/* Put eax back the way we found it. */</span>
<span class="p_del">-	popl %eax</span>
<span class="p_del">-	ret</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Finally, the &quot;popf&quot; or &quot;restore flags&quot; routine.  The %eax register holds the</span>
<span class="p_del">- * flags (in practice, either X86_EFLAGS_IF or 0): if it&#39;s X86_EFLAGS_IF we&#39;re</span>
<span class="p_del">- * enabling interrupts again, if it&#39;s 0 we&#39;re leaving them off.</span>
<span class="p_del">- */</span>
<span class="p_del">-ENTRY(lg_restore_fl)</span>
<span class="p_del">-	/* This is just &quot;lguest_data.irq_enabled = flags;&quot; */</span>
<span class="p_del">-	movl %eax, lguest_data+LGUEST_DATA_irq_enabled</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now, if the %eax value has enabled interrupts and</span>
<span class="p_del">-	 * lguest_data.irq_pending is set, we want to tell the Host so it can</span>
<span class="p_del">-	 * deliver any outstanding interrupts.  Fortunately, both values will</span>
<span class="p_del">-	 * be X86_EFLAGS_IF (ie. 512) in that case, and the &quot;testl&quot;</span>
<span class="p_del">-	 * instruction will AND them together for us.  If both are set, we</span>
<span class="p_del">-	 * jump to send_interrupts.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	testl lguest_data+LGUEST_DATA_irq_pending, %eax</span>
<span class="p_del">-	jnz send_interrupts</span>
<span class="p_del">-	/* Again, the normal path has used no extra registers.  Clever, huh? */</span>
<span class="p_del">-	ret</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* These demark the EIP where host should never deliver interrupts. */</span>
<span class="p_del">-.global lguest_noirq_iret</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:004</span>
<span class="p_del">- * When the Host reflects a trap or injects an interrupt into the Guest, it</span>
<span class="p_del">- * sets the eflags interrupt bit on the stack based on lguest_data.irq_enabled,</span>
<span class="p_del">- * so the Guest iret logic does the right thing when restoring it.  However,</span>
<span class="p_del">- * when the Host sets the Guest up for direct traps, such as system calls, the</span>
<span class="p_del">- * processor is the one to push eflags onto the stack, and the interrupt bit</span>
<span class="p_del">- * will be 1 (in reality, interrupts are always enabled in the Guest).</span>
<span class="p_del">- *</span>
<span class="p_del">- * This turns out to be harmless: the only trap which should happen under Linux</span>
<span class="p_del">- * with interrupts disabled is Page Fault (due to our lazy mapping of vmalloc</span>
<span class="p_del">- * regions), which has to be reflected through the Host anyway.  If another</span>
<span class="p_del">- * trap *does* go off when interrupts are disabled, the Guest will panic, and</span>
<span class="p_del">- * we&#39;ll never get to this iret!</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:045</span>
<span class="p_del">- * There is one final paravirt_op that the Guest implements, and glancing at it</span>
<span class="p_del">- * you can see why I left it to last.  It&#39;s *cool*!  It&#39;s in *assembler*!</span>
<span class="p_del">- *</span>
<span class="p_del">- * The &quot;iret&quot; instruction is used to return from an interrupt or trap.  The</span>
<span class="p_del">- * stack looks like this:</span>
<span class="p_del">- *   old address</span>
<span class="p_del">- *   old code segment &amp; privilege level</span>
<span class="p_del">- *   old processor flags (&quot;eflags&quot;)</span>
<span class="p_del">- *</span>
<span class="p_del">- * The &quot;iret&quot; instruction pops those values off the stack and restores them all</span>
<span class="p_del">- * at once.  The only problem is that eflags includes the Interrupt Flag which</span>
<span class="p_del">- * the Guest can&#39;t change: the CPU will simply ignore it when we do an &quot;iret&quot;.</span>
<span class="p_del">- * So we have to copy eflags from the stack to lguest_data.irq_enabled before</span>
<span class="p_del">- * we do the &quot;iret&quot;.</span>
<span class="p_del">- *</span>
<span class="p_del">- * There are two problems with this: firstly, we can&#39;t clobber any registers</span>
<span class="p_del">- * and secondly, the whole thing needs to be atomic.  The first problem</span>
<span class="p_del">- * is solved by using &quot;push memory&quot;/&quot;pop memory&quot; instruction pair for copying.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The second is harder: copying eflags to lguest_data.irq_enabled will turn</span>
<span class="p_del">- * interrupts on before we&#39;re finished, so we could be interrupted before we</span>
<span class="p_del">- * return to userspace or wherever.  Our solution to this is to tell the</span>
<span class="p_del">- * Host that it is *never* to interrupt us there, even if interrupts seem to be</span>
<span class="p_del">- * enabled. (It&#39;s not necessary to protect pop instruction, since</span>
<span class="p_del">- * data gets updated only after it completes, so we only need to protect</span>
<span class="p_del">- * one instruction, iret).</span>
<span class="p_del">- */</span>
<span class="p_del">-ENTRY(lguest_iret)</span>
<span class="p_del">-	pushl	2*4(%esp)</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Note the %ss: segment prefix here.  Normal data accesses use the</span>
<span class="p_del">-	 * &quot;ds&quot; segment, but that will have already been restored for whatever</span>
<span class="p_del">-	 * we&#39;re returning to (such as userspace): we can&#39;t trust it.  The %ss:</span>
<span class="p_del">-	 * prefix makes sure we use the stack segment, which is still valid.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	popl	%ss:lguest_data+LGUEST_DATA_irq_enabled</span>
<span class="p_del">-lguest_noirq_iret:</span>
<span class="p_del">-	iret</span>
<span class="p_header">diff --git a/drivers/Makefile b/drivers/Makefile</span>
<span class="p_header">index dfdcda00bfe3..d90fdc413648 100644</span>
<span class="p_header">--- a/drivers/Makefile</span>
<span class="p_header">+++ b/drivers/Makefile</span>
<span class="p_chunk">@@ -125,7 +125,6 @@</span> <span class="p_context"> obj-$(CONFIG_ACCESSIBILITY)	+= accessibility/</span>
 obj-$(CONFIG_ISDN)		+= isdn/
 obj-$(CONFIG_EDAC)		+= edac/
 obj-$(CONFIG_EISA)		+= eisa/
<span class="p_del">-obj-y				+= lguest/</span>
 obj-$(CONFIG_CPU_FREQ)		+= cpufreq/
 obj-$(CONFIG_CPU_IDLE)		+= cpuidle/
 obj-y				+= mmc/
<span class="p_header">diff --git a/drivers/block/Kconfig b/drivers/block/Kconfig</span>
<span class="p_header">index 8ddc98279c8f..80aaf3420e12 100644</span>
<span class="p_header">--- a/drivers/block/Kconfig</span>
<span class="p_header">+++ b/drivers/block/Kconfig</span>
<span class="p_chunk">@@ -470,7 +470,7 @@</span> <span class="p_context"> config VIRTIO_BLK</span>
 	depends on VIRTIO
 	---help---
 	  This is the virtual block driver for virtio.  It can be used with
<span class="p_del">-          lguest or QEMU based VMMs (like KVM or Xen).  Say Y or M.</span>
<span class="p_add">+          QEMU based VMMs (like KVM or Xen).  Say Y or M.</span>
 
 config VIRTIO_BLK_SCSI
 	bool &quot;SCSI passthrough request for the Virtio block driver&quot;
<span class="p_header">diff --git a/drivers/char/Kconfig b/drivers/char/Kconfig</span>
<span class="p_header">index ccd239ab879f..623714344600 100644</span>
<span class="p_header">--- a/drivers/char/Kconfig</span>
<span class="p_header">+++ b/drivers/char/Kconfig</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> config VIRTIO_CONSOLE</span>
 	depends on VIRTIO &amp;&amp; TTY
 	select HVC_DRIVER
 	help
<span class="p_del">-	  Virtio console for use with lguest and other hypervisors.</span>
<span class="p_add">+	  Virtio console for use with hypervisors.</span>
 
 	  Also serves as a general-purpose serial device for data
 	  transfer between the guest and host.  Character devices at
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index ad843eb02ae7..4d229dde6522 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -1130,7 +1130,7 @@</span> <span class="p_context"> static const struct file_operations port_fops = {</span>
  * We turn the characters into a scatter-gather list, add it to the
  * output queue and then kick the Host.  Then we sit here waiting for
  * it to finish: inefficient in theory, but in practice
<span class="p_del">- * implementations will do it immediately (lguest&#39;s Launcher does).</span>
<span class="p_add">+ * implementations will do it immediately.</span>
  */
 static int put_chars(u32 vtermno, const char *buf, int count)
 {
<span class="p_header">diff --git a/drivers/lguest/Kconfig b/drivers/lguest/Kconfig</span>
deleted file mode 100644
<span class="p_header">index 169172d2ba05..000000000000</span>
<span class="p_header">--- a/drivers/lguest/Kconfig</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,13 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-config LGUEST</span>
<span class="p_del">-	tristate &quot;Linux hypervisor example code&quot;</span>
<span class="p_del">-	depends on X86_32 &amp;&amp; EVENTFD &amp;&amp; TTY &amp;&amp; PCI_DIRECT</span>
<span class="p_del">-	select HVC_DRIVER</span>
<span class="p_del">-	---help---</span>
<span class="p_del">-	  This is a very simple module which allows you to run</span>
<span class="p_del">-	  multiple instances of the same Linux kernel, using the</span>
<span class="p_del">-	  &quot;lguest&quot; command found in the tools/lguest directory.</span>
<span class="p_del">-</span>
<span class="p_del">-	  Note that &quot;lguest&quot; is pronounced to rhyme with &quot;fell quest&quot;,</span>
<span class="p_del">-	  not &quot;rustyvisor&quot;. See tools/lguest/lguest.txt.</span>
<span class="p_del">-</span>
<span class="p_del">-	  If unsure, say N.  If curious, say M.  If masochistic, say Y.</span>
<span class="p_header">diff --git a/drivers/lguest/Makefile b/drivers/lguest/Makefile</span>
deleted file mode 100644
<span class="p_header">index 16f52ee73994..000000000000</span>
<span class="p_header">--- a/drivers/lguest/Makefile</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,26 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-# Host requires the other files, which can be a module.</span>
<span class="p_del">-obj-$(CONFIG_LGUEST)	+= lg.o</span>
<span class="p_del">-lg-y = core.o hypercalls.o page_tables.o interrupts_and_traps.o \</span>
<span class="p_del">-	segments.o lguest_user.o</span>
<span class="p_del">-</span>
<span class="p_del">-lg-$(CONFIG_X86_32) += x86/switcher_32.o x86/core.o</span>
<span class="p_del">-</span>
<span class="p_del">-Preparation Preparation!: PREFIX=P</span>
<span class="p_del">-Guest: PREFIX=G</span>
<span class="p_del">-Drivers: PREFIX=D</span>
<span class="p_del">-Launcher: PREFIX=L</span>
<span class="p_del">-Host: PREFIX=H</span>
<span class="p_del">-Switcher: PREFIX=S</span>
<span class="p_del">-Mastery: PREFIX=M</span>
<span class="p_del">-Beer:</span>
<span class="p_del">-	@for f in Preparation Guest Drivers Launcher Host Switcher Mastery; do echo &quot;{==- $$f -==}&quot;; make -s $$f; done; echo &quot;{==-==}&quot;</span>
<span class="p_del">-Preparation Preparation! Guest Drivers Launcher Host Switcher Mastery:</span>
<span class="p_del">-	@sh ../../tools/lguest/extract $(PREFIX) `find ../../* -name &#39;*.[chS]&#39; -wholename &#39;*lguest*&#39;`</span>
<span class="p_del">-Puppy:</span>
<span class="p_del">-	@clear</span>
<span class="p_del">-	@printf &quot;      __  \n (___()&#39;\`;\n /,    /\`\n \\\\\\\&quot;--\\\\\\   \n&quot;</span>
<span class="p_del">-	@sleep 2; clear; printf &quot;\n\n   Sit!\n\n&quot;; sleep 1; clear</span>
<span class="p_del">-	@printf &quot;    __    \n   ()&#39;\`;  \n   /\\|\` \n  /  |  \n(/_)_|_   \n&quot;</span>
<span class="p_del">-	@sleep 2; clear; printf &quot;\n\n  Stand!\n\n&quot;; sleep 1; clear</span>
<span class="p_del">-	@printf &quot;    __    \n   ()&#39;\`;  \n   /\\|\` \n  /._.= \n /| /     \n(_\_)_    \n&quot;</span>
<span class="p_del">-	@sleep 2; clear; printf &quot;\n\n  Good puppy!\n\n&quot;; sleep 1; clear</span>
<span class="p_header">diff --git a/drivers/lguest/README b/drivers/lguest/README</span>
deleted file mode 100644
<span class="p_header">index b7db39a64c66..000000000000</span>
<span class="p_header">--- a/drivers/lguest/README</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,47 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-Welcome, friend reader, to lguest.</span>
<span class="p_del">-</span>
<span class="p_del">-Lguest is an adventure, with you, the reader, as Hero.  I can&#39;t think of many</span>
<span class="p_del">-5000-line projects which offer both such capability and glimpses of future</span>
<span class="p_del">-potential; it is an exciting time to be delving into the source!</span>
<span class="p_del">-</span>
<span class="p_del">-But be warned; this is an arduous journey of several hours or more!  And as we</span>
<span class="p_del">-know, all true Heroes are driven by a Noble Goal.  Thus I offer a Beer (or</span>
<span class="p_del">-equivalent) to anyone I meet who has completed this documentation.</span>
<span class="p_del">-</span>
<span class="p_del">-So get comfortable and keep your wits about you (both quick and humorous).</span>
<span class="p_del">-Along your way to the Noble Goal, you will also gain masterly insight into</span>
<span class="p_del">-lguest, and hypervisors and x86 virtualization in general.</span>
<span class="p_del">-</span>
<span class="p_del">-Our Quest is in seven parts: (best read with C highlighting turned on)</span>
<span class="p_del">-</span>
<span class="p_del">-I) Preparation</span>
<span class="p_del">-	- In which our potential hero is flown quickly over the landscape for a</span>
<span class="p_del">-	  taste of its scope.  Suitable for the armchair coders and other such</span>
<span class="p_del">-	  persons of faint constitution.</span>
<span class="p_del">-</span>
<span class="p_del">-II) Guest</span>
<span class="p_del">-	- Where we encounter the first tantalising wisps of code, and come to</span>
<span class="p_del">-	  understand the details of the life of a Guest kernel.</span>
<span class="p_del">-</span>
<span class="p_del">-III) Drivers</span>
<span class="p_del">-	- Whereby the Guest finds its voice and become useful, and our</span>
<span class="p_del">-	  understanding of the Guest is completed.</span>
<span class="p_del">-</span>
<span class="p_del">-IV) Launcher</span>
<span class="p_del">-	- Where we trace back to the creation of the Guest, and thus begin our</span>
<span class="p_del">-	  understanding of the Host.</span>
<span class="p_del">-</span>
<span class="p_del">-V) Host</span>
<span class="p_del">-	- Where we master the Host code, through a long and tortuous journey.</span>
<span class="p_del">-	  Indeed, it is here that our hero is tested in the Bit of Despair.</span>
<span class="p_del">-</span>
<span class="p_del">-VI) Switcher</span>
<span class="p_del">-	- Where our understanding of the intertwined nature of Guests and Hosts</span>
<span class="p_del">-	  is completed.</span>
<span class="p_del">-</span>
<span class="p_del">-VII) Mastery</span>
<span class="p_del">-	- Where our fully fledged hero grapples with the Great Question:</span>
<span class="p_del">-	  &quot;What next?&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-make Preparation!</span>
<span class="p_del">-Rusty Russell.</span>
<span class="p_header">diff --git a/drivers/lguest/core.c b/drivers/lguest/core.c</span>
deleted file mode 100644
<span class="p_header">index 395ed1961dbf..000000000000</span>
<span class="p_header">--- a/drivers/lguest/core.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,398 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:400</span>
<span class="p_del">- * This contains run_guest() which actually calls into the Host&lt;-&gt;Guest</span>
<span class="p_del">- * Switcher and analyzes the return, such as determining if the Guest wants the</span>
<span class="p_del">- * Host to do something.  This file also contains useful helper routines.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/stringify.h&gt;</span>
<span class="p_del">-#include &lt;linux/stddef.h&gt;</span>
<span class="p_del">-#include &lt;linux/io.h&gt;</span>
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
<span class="p_del">-#include &lt;linux/sched/signal.h&gt;</span>
<span class="p_del">-#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_del">-#include &lt;linux/cpu.h&gt;</span>
<span class="p_del">-#include &lt;linux/freezer.h&gt;</span>
<span class="p_del">-#include &lt;linux/highmem.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-#include &lt;asm/paravirt.h&gt;</span>
<span class="p_del">-#include &lt;asm/pgtable.h&gt;</span>
<span class="p_del">-#include &lt;linux/uaccess.h&gt;</span>
<span class="p_del">-#include &lt;asm/poll.h&gt;</span>
<span class="p_del">-#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_del">-#include &quot;lg.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-unsigned long switcher_addr;</span>
<span class="p_del">-struct page **lg_switcher_pages;</span>
<span class="p_del">-static struct vm_struct *switcher_text_vma;</span>
<span class="p_del">-static struct vm_struct *switcher_stacks_vma;</span>
<span class="p_del">-</span>
<span class="p_del">-/* This One Big lock protects all inter-guest data structures. */</span>
<span class="p_del">-DEFINE_MUTEX(lguest_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:010</span>
<span class="p_del">- * We need to set up the Switcher at a high virtual address.  Remember the</span>
<span class="p_del">- * Switcher is a few hundred bytes of assembler code which actually changes the</span>
<span class="p_del">- * CPU to run the Guest, and then changes back to the Host when a trap or</span>
<span class="p_del">- * interrupt happens.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Switcher code must be at the same virtual address in the Guest as the</span>
<span class="p_del">- * Host since it will be running as the switchover occurs.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Trying to map memory at a particular address is an unusual thing to do, so</span>
<span class="p_del">- * it&#39;s not a simple one-liner.</span>
<span class="p_del">- */</span>
<span class="p_del">-static __init int map_switcher(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, err;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Map the Switcher in to high memory.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * It turns out that if we choose the address 0xFFC00000 (4MB under the</span>
<span class="p_del">-	 * top virtual address), it makes setting up the page tables really</span>
<span class="p_del">-	 * easy.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We assume Switcher text fits into a single page. */</span>
<span class="p_del">-	if (end_switcher_text - start_switcher_text &gt; PAGE_SIZE) {</span>
<span class="p_del">-		printk(KERN_ERR &quot;lguest: switcher text too large (%zu)\n&quot;,</span>
<span class="p_del">-		       end_switcher_text - start_switcher_text);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We allocate an array of struct page pointers.  map_vm_area() wants</span>
<span class="p_del">-	 * this, rather than just an array of pages.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	lg_switcher_pages = kmalloc(sizeof(lg_switcher_pages[0])</span>
<span class="p_del">-				    * TOTAL_SWITCHER_PAGES,</span>
<span class="p_del">-				    GFP_KERNEL);</span>
<span class="p_del">-	if (!lg_switcher_pages) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now we actually allocate the pages.  The Guest will see these pages,</span>
<span class="p_del">-	 * so we make sure they&#39;re zeroed.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; TOTAL_SWITCHER_PAGES; i++) {</span>
<span class="p_del">-		lg_switcher_pages[i] = alloc_page(GFP_KERNEL|__GFP_ZERO);</span>
<span class="p_del">-		if (!lg_switcher_pages[i]) {</span>
<span class="p_del">-			err = -ENOMEM;</span>
<span class="p_del">-			goto free_some_pages;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Copy in the compiled-in Switcher code (from x86/switcher_32.S).</span>
<span class="p_del">-	 * It goes in the first page, which we map in momentarily.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	memcpy(kmap(lg_switcher_pages[0]), start_switcher_text,</span>
<span class="p_del">-	       end_switcher_text - start_switcher_text);</span>
<span class="p_del">-	kunmap(lg_switcher_pages[0]);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We place the Switcher underneath the fixmap area, which is the</span>
<span class="p_del">-	 * highest virtual address we can get.  This is important, since we</span>
<span class="p_del">-	 * tell the Guest it can&#39;t access this memory, so we want its ceiling</span>
<span class="p_del">-	 * as high as possible.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	switcher_addr = FIXADDR_START - TOTAL_SWITCHER_PAGES*PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now we reserve the &quot;virtual memory area&quot;s we want.  We might</span>
<span class="p_del">-	 * not get them in theory, but in practice it&#39;s worked so far.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We want the switcher text to be read-only and executable, and</span>
<span class="p_del">-	 * the stacks to be read-write and non-executable.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	switcher_text_vma = __get_vm_area(PAGE_SIZE, VM_ALLOC|VM_NO_GUARD,</span>
<span class="p_del">-					  switcher_addr,</span>
<span class="p_del">-					  switcher_addr + PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!switcher_text_vma) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		printk(&quot;lguest: could not map switcher pages high\n&quot;);</span>
<span class="p_del">-		goto free_pages;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	switcher_stacks_vma = __get_vm_area(SWITCHER_STACK_PAGES * PAGE_SIZE,</span>
<span class="p_del">-					    VM_ALLOC|VM_NO_GUARD,</span>
<span class="p_del">-					    switcher_addr + PAGE_SIZE,</span>
<span class="p_del">-					    switcher_addr + TOTAL_SWITCHER_PAGES * PAGE_SIZE);</span>
<span class="p_del">-	if (!switcher_stacks_vma) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		printk(&quot;lguest: could not map switcher pages high\n&quot;);</span>
<span class="p_del">-		goto free_text_vma;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This code actually sets up the pages we&#39;ve allocated to appear at</span>
<span class="p_del">-	 * switcher_addr.  map_vm_area() takes the vma we allocated above, the</span>
<span class="p_del">-	 * kind of pages we&#39;re mapping (kernel text pages and kernel writable</span>
<span class="p_del">-	 * pages respectively), and a pointer to our array of struct pages.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	err = map_vm_area(switcher_text_vma, PAGE_KERNEL_RX, lg_switcher_pages);</span>
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		printk(&quot;lguest: text map_vm_area failed: %i\n&quot;, err);</span>
<span class="p_del">-		goto free_vmas;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	err = map_vm_area(switcher_stacks_vma, PAGE_KERNEL,</span>
<span class="p_del">-			  lg_switcher_pages + SWITCHER_TEXT_PAGES);</span>
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		printk(&quot;lguest: stacks map_vm_area failed: %i\n&quot;, err);</span>
<span class="p_del">-		goto free_vmas;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now the Switcher is mapped at the right address, we can&#39;t fail!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	printk(KERN_INFO &quot;lguest: mapped switcher at %p\n&quot;,</span>
<span class="p_del">-	       switcher_text_vma-&gt;addr);</span>
<span class="p_del">-	/* And we succeeded... */</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-free_vmas:</span>
<span class="p_del">-	/* Undoes map_vm_area and __get_vm_area */</span>
<span class="p_del">-	vunmap(switcher_stacks_vma-&gt;addr);</span>
<span class="p_del">-free_text_vma:</span>
<span class="p_del">-	vunmap(switcher_text_vma-&gt;addr);</span>
<span class="p_del">-free_pages:</span>
<span class="p_del">-	i = TOTAL_SWITCHER_PAGES;</span>
<span class="p_del">-free_some_pages:</span>
<span class="p_del">-	for (--i; i &gt;= 0; i--)</span>
<span class="p_del">-		__free_pages(lg_switcher_pages[i], 0);</span>
<span class="p_del">-	kfree(lg_switcher_pages);</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* Cleaning up the mapping when the module is unloaded is almost... too easy. */</span>
<span class="p_del">-static void unmap_switcher(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* vunmap() undoes *both* map_vm_area() and __get_vm_area(). */</span>
<span class="p_del">-	vunmap(switcher_text_vma-&gt;addr);</span>
<span class="p_del">-	vunmap(switcher_stacks_vma-&gt;addr);</span>
<span class="p_del">-	/* Now we just need to free the pages we copied the switcher into */</span>
<span class="p_del">-	for (i = 0; i &lt; TOTAL_SWITCHER_PAGES; i++)</span>
<span class="p_del">-		__free_pages(lg_switcher_pages[i], 0);</span>
<span class="p_del">-	kfree(lg_switcher_pages);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:032</span>
<span class="p_del">- * Dealing With Guest Memory.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Before we go too much further into the Host, we need to grok the routines</span>
<span class="p_del">- * we use to deal with Guest memory.</span>
<span class="p_del">- *</span>
<span class="p_del">- * When the Guest gives us (what it thinks is) a physical address, we can use</span>
<span class="p_del">- * the normal copy_from_user() &amp; copy_to_user() on the corresponding place in</span>
<span class="p_del">- * the memory region allocated by the Launcher.</span>
<span class="p_del">- *</span>
<span class="p_del">- * But we can&#39;t trust the Guest: it might be trying to access the Launcher</span>
<span class="p_del">- * code.  We have to check that the range is below the pfn_limit the Launcher</span>
<span class="p_del">- * gave us.  We have to make sure that addr + len doesn&#39;t give us a false</span>
<span class="p_del">- * positive by overflowing, too.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool lguest_address_ok(const struct lguest *lg,</span>
<span class="p_del">-		       unsigned long addr, unsigned long len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return addr+len &lt;= lg-&gt;pfn_limit * PAGE_SIZE &amp;&amp; (addr+len &gt;= addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine copies memory from the Guest.  Here we can see how useful the</span>
<span class="p_del">- * kill_lguest() routine we met in the Launcher can be: we return a random</span>
<span class="p_del">- * value (all zeroes) instead of needing to return an error.</span>
<span class="p_del">- */</span>
<span class="p_del">-void __lgread(struct lg_cpu *cpu, void *b, unsigned long addr, unsigned bytes)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!lguest_address_ok(cpu-&gt;lg, addr, bytes)</span>
<span class="p_del">-	    || copy_from_user(b, cpu-&gt;lg-&gt;mem_base + addr, bytes) != 0) {</span>
<span class="p_del">-		/* copy_from_user should do this, but as we rely on it... */</span>
<span class="p_del">-		memset(b, 0, bytes);</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad read address %#lx len %u&quot;, addr, bytes);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the write (copy into Guest) version. */</span>
<span class="p_del">-void __lgwrite(struct lg_cpu *cpu, unsigned long addr, const void *b,</span>
<span class="p_del">-	       unsigned bytes)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!lguest_address_ok(cpu-&gt;lg, addr, bytes)</span>
<span class="p_del">-	    || copy_to_user(cpu-&gt;lg-&gt;mem_base + addr, b, bytes) != 0)</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad write address %#lx len %u&quot;, addr, bytes);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:030</span>
<span class="p_del">- * Let&#39;s jump straight to the the main loop which runs the Guest.</span>
<span class="p_del">- * Remember, this is called by the Launcher reading /dev/lguest, and we keep</span>
<span class="p_del">- * going around and around until something interesting happens.</span>
<span class="p_del">- */</span>
<span class="p_del">-int run_guest(struct lg_cpu *cpu, unsigned long __user *user)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If the launcher asked for a register with LHREQ_GETREG */</span>
<span class="p_del">-	if (cpu-&gt;reg_read) {</span>
<span class="p_del">-		if (put_user(*cpu-&gt;reg_read, user))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		cpu-&gt;reg_read = NULL;</span>
<span class="p_del">-		return sizeof(*cpu-&gt;reg_read);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We stop running once the Guest is dead. */</span>
<span class="p_del">-	while (!cpu-&gt;lg-&gt;dead) {</span>
<span class="p_del">-		unsigned int irq;</span>
<span class="p_del">-		bool more;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* First we run any hypercalls the Guest wants done. */</span>
<span class="p_del">-		if (cpu-&gt;hcall)</span>
<span class="p_del">-			do_hypercalls(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Do we have to tell the Launcher about a trap? */</span>
<span class="p_del">-		if (cpu-&gt;pending.trap) {</span>
<span class="p_del">-			if (copy_to_user(user, &amp;cpu-&gt;pending,</span>
<span class="p_del">-					 sizeof(cpu-&gt;pending)))</span>
<span class="p_del">-				return -EFAULT;</span>
<span class="p_del">-			return sizeof(cpu-&gt;pending);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * All long-lived kernel loops need to check with this horrible</span>
<span class="p_del">-		 * thing called the freezer.  If the Host is trying to suspend,</span>
<span class="p_del">-		 * it stops us.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		try_to_freeze();</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Check for signals */</span>
<span class="p_del">-		if (signal_pending(current))</span>
<span class="p_del">-			return -ERESTARTSYS;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Check if there are any interrupts which can be delivered now:</span>
<span class="p_del">-		 * if so, this sets up the hander to be executed when we next</span>
<span class="p_del">-		 * run the Guest.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		irq = interrupt_pending(cpu, &amp;more);</span>
<span class="p_del">-		if (irq &lt; LGUEST_IRQS)</span>
<span class="p_del">-			try_deliver_interrupt(cpu, irq, more);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Just make absolutely sure the Guest is still alive.  One of</span>
<span class="p_del">-		 * those hypercalls could have been fatal, for example.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (cpu-&gt;lg-&gt;dead)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If the Guest asked to be stopped, we sleep.  The Guest&#39;s</span>
<span class="p_del">-		 * clock timer will wake us.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (cpu-&gt;halted) {</span>
<span class="p_del">-			set_current_state(TASK_INTERRUPTIBLE);</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Just before we sleep, make sure no interrupt snuck in</span>
<span class="p_del">-			 * which we should be doing.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (interrupt_pending(cpu, &amp;more) &lt; LGUEST_IRQS)</span>
<span class="p_del">-				set_current_state(TASK_RUNNING);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				schedule();</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * OK, now we&#39;re ready to jump into the Guest.  First we put up</span>
<span class="p_del">-		 * the &quot;Do Not Disturb&quot; sign:</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		local_irq_disable();</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Actually run the Guest until something happens. */</span>
<span class="p_del">-		lguest_arch_run_guest(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Now we&#39;re ready to be interrupted or moved to other CPUs */</span>
<span class="p_del">-		local_irq_enable();</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Now we deal with whatever happened to the Guest. */</span>
<span class="p_del">-		lguest_arch_handle_trap(cpu);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Special case: Guest is &#39;dead&#39; but wants a reboot. */</span>
<span class="p_del">-	if (cpu-&gt;lg-&gt;dead == ERR_PTR(-ERESTART))</span>
<span class="p_del">-		return -ERESTART;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The Guest is dead =&gt; &quot;No such file or directory&quot; */</span>
<span class="p_del">-	return -ENOENT;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:000</span>
<span class="p_del">- * Welcome to the Host!</span>
<span class="p_del">- *</span>
<span class="p_del">- * By this point your brain has been tickled by the Guest code and numbed by</span>
<span class="p_del">- * the Launcher code; prepare for it to be stretched by the Host code.  This is</span>
<span class="p_del">- * the heart.  Let&#39;s begin at the initialization routine for the Host&#39;s lg</span>
<span class="p_del">- * module.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int __init init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Lguest can&#39;t run under Xen, VMI or itself.  It does Tricky Stuff. */</span>
<span class="p_del">-	if (get_kernel_rpl() != 0) {</span>
<span class="p_del">-		printk(&quot;lguest is afraid of being a guest\n&quot;);</span>
<span class="p_del">-		return -EPERM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First we put the Switcher up in very high virtual memory. */</span>
<span class="p_del">-	err = map_switcher();</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We might need to reserve an interrupt vector. */</span>
<span class="p_del">-	err = init_interrupts();</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto unmap;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* /dev/lguest needs to be registered. */</span>
<span class="p_del">-	err = lguest_device_init();</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto free_interrupts;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Finally we do some architecture-specific setup. */</span>
<span class="p_del">-	lguest_arch_host_init();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* All good! */</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-free_interrupts:</span>
<span class="p_del">-	free_interrupts();</span>
<span class="p_del">-unmap:</span>
<span class="p_del">-	unmap_switcher();</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Cleaning up is just the same code, backwards.  With a little French. */</span>
<span class="p_del">-static void __exit fini(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	lguest_device_remove();</span>
<span class="p_del">-	free_interrupts();</span>
<span class="p_del">-	unmap_switcher();</span>
<span class="p_del">-</span>
<span class="p_del">-	lguest_arch_host_fini();</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Host side of lguest can be a module.  This is a nice way for people to</span>
<span class="p_del">- * play with it.</span>
<span class="p_del">- */</span>
<span class="p_del">-module_init(init);</span>
<span class="p_del">-module_exit(fini);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_del">-MODULE_AUTHOR(&quot;Rusty Russell &lt;rusty@rustcorp.com.au&gt;&quot;);</span>
<span class="p_header">diff --git a/drivers/lguest/hypercalls.c b/drivers/lguest/hypercalls.c</span>
deleted file mode 100644
<span class="p_header">index 601f81c04873..000000000000</span>
<span class="p_header">--- a/drivers/lguest/hypercalls.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,304 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:500</span>
<span class="p_del">- * Just as userspace programs request kernel operations through a system</span>
<span class="p_del">- * call, the Guest requests Host operations through a &quot;hypercall&quot;.  You might</span>
<span class="p_del">- * notice this nomenclature doesn&#39;t really follow any logic, but the name has</span>
<span class="p_del">- * been around for long enough that we&#39;re stuck with it.  As you&#39;d expect, this</span>
<span class="p_del">- * code is basically a one big switch statement.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*  Copyright (C) 2006 Rusty Russell IBM Corporation</span>
<span class="p_del">-</span>
<span class="p_del">-    This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">-    it under the terms of the GNU General Public License as published by</span>
<span class="p_del">-    the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">-    (at your option) any later version.</span>
<span class="p_del">-</span>
<span class="p_del">-    This program is distributed in the hope that it will be useful,</span>
<span class="p_del">-    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">-    GNU General Public License for more details.</span>
<span class="p_del">-</span>
<span class="p_del">-    You should have received a copy of the GNU General Public License</span>
<span class="p_del">-    along with this program; if not, write to the Free Software</span>
<span class="p_del">-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA</span>
<span class="p_del">-*/</span>
<span class="p_del">-#include &lt;linux/uaccess.h&gt;</span>
<span class="p_del">-#include &lt;linux/syscalls.h&gt;</span>
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
<span class="p_del">-#include &lt;linux/ktime.h&gt;</span>
<span class="p_del">-#include &lt;asm/page.h&gt;</span>
<span class="p_del">-#include &lt;asm/pgtable.h&gt;</span>
<span class="p_del">-#include &quot;lg.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:120</span>
<span class="p_del">- * This is the core hypercall routine: where the Guest gets what it wants.</span>
<span class="p_del">- * Or gets killed.  Or, in the case of LHCALL_SHUTDOWN, both.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void do_hcall(struct lg_cpu *cpu, struct hcall_args *args)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (args-&gt;arg0) {</span>
<span class="p_del">-	case LHCALL_FLUSH_ASYNC:</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This call does nothing, except by breaking out of the Guest</span>
<span class="p_del">-		 * it makes us process all the asynchronous hypercalls.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_SEND_INTERRUPTS:</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This call does nothing too, but by breaking out of the Guest</span>
<span class="p_del">-		 * it makes us process any pending interrupts.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_LGUEST_INIT:</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * You can&#39;t get here unless you&#39;re already initialized.  Don&#39;t</span>
<span class="p_del">-		 * do that.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		kill_guest(cpu, &quot;already have lguest_data&quot;);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_SHUTDOWN: {</span>
<span class="p_del">-		char msg[128];</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Shutdown is such a trivial hypercall that we do it in five</span>
<span class="p_del">-		 * lines right here.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * If the lgread fails, it will call kill_guest() itself; the</span>
<span class="p_del">-		 * kill_guest() with the message will be ignored.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		__lgread(cpu, msg, args-&gt;arg1, sizeof(msg));</span>
<span class="p_del">-		msg[sizeof(msg)-1] = &#39;\0&#39;;</span>
<span class="p_del">-		kill_guest(cpu, &quot;CRASH: %s&quot;, msg);</span>
<span class="p_del">-		if (args-&gt;arg2 == LGUEST_SHUTDOWN_RESTART)</span>
<span class="p_del">-			cpu-&gt;lg-&gt;dead = ERR_PTR(-ERESTART);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	case LHCALL_FLUSH_TLB:</span>
<span class="p_del">-		/* FLUSH_TLB comes in two flavors, depending on the argument: */</span>
<span class="p_del">-		if (args-&gt;arg1)</span>
<span class="p_del">-			guest_pagetable_clear_all(cpu);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			guest_pagetable_flush_user(cpu);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * All these calls simply pass the arguments through to the right</span>
<span class="p_del">-	 * routines.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	case LHCALL_NEW_PGTABLE:</span>
<span class="p_del">-		guest_new_pagetable(cpu, args-&gt;arg1);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_SET_STACK:</span>
<span class="p_del">-		guest_set_stack(cpu, args-&gt;arg1, args-&gt;arg2, args-&gt;arg3);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_SET_PTE:</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-		guest_set_pte(cpu, args-&gt;arg1, args-&gt;arg2,</span>
<span class="p_del">-				__pte(args-&gt;arg3 | (u64)args-&gt;arg4 &lt;&lt; 32));</span>
<span class="p_del">-#else</span>
<span class="p_del">-		guest_set_pte(cpu, args-&gt;arg1, args-&gt;arg2, __pte(args-&gt;arg3));</span>
<span class="p_del">-#endif</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_SET_PGD:</span>
<span class="p_del">-		guest_set_pgd(cpu-&gt;lg, args-&gt;arg1, args-&gt;arg2);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	case LHCALL_SET_PMD:</span>
<span class="p_del">-		guest_set_pmd(cpu-&gt;lg, args-&gt;arg1, args-&gt;arg2);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	case LHCALL_SET_CLOCKEVENT:</span>
<span class="p_del">-		guest_set_clockevent(cpu, args-&gt;arg1);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_HALT:</span>
<span class="p_del">-		/* Similarly, this sets the halted flag for run_guest(). */</span>
<span class="p_del">-		cpu-&gt;halted = 1;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* It should be an architecture-specific hypercall. */</span>
<span class="p_del">-		if (lguest_arch_do_hcall(cpu, args))</span>
<span class="p_del">-			kill_guest(cpu, &quot;Bad hypercall %li\n&quot;, args-&gt;arg0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:124</span>
<span class="p_del">- * Asynchronous hypercalls are easy: we just look in the array in the</span>
<span class="p_del">- * Guest&#39;s &quot;struct lguest_data&quot; to see if any new ones are marked &quot;ready&quot;.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We are careful to do these in order: obviously we respect the order the</span>
<span class="p_del">- * Guest put them in the ring, but we also promise the Guest that they will</span>
<span class="p_del">- * happen before any normal hypercall (which is why we check this before</span>
<span class="p_del">- * checking for a normal hcall).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void do_async_hcalls(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-	u8 st[LHCALL_RING_SIZE];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* For simplicity, we copy the entire call status array in at once. */</span>
<span class="p_del">-	if (copy_from_user(&amp;st, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;hcall_status, sizeof(st)))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We process &quot;struct lguest_data&quot;s hcalls[] ring once. */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(st); i++) {</span>
<span class="p_del">-		struct hcall_args args;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We remember where we were up to from last time.  This makes</span>
<span class="p_del">-		 * sure that the hypercalls are done in the order the Guest</span>
<span class="p_del">-		 * places them in the ring.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		unsigned int n = cpu-&gt;next_hcall;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* 0xFF means there&#39;s no call here (yet). */</span>
<span class="p_del">-		if (st[n] == 0xFF)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * OK, we have hypercall.  Increment the &quot;next_hcall&quot; cursor,</span>
<span class="p_del">-		 * and wrap back to 0 if we reach the end.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (++cpu-&gt;next_hcall == LHCALL_RING_SIZE)</span>
<span class="p_del">-			cpu-&gt;next_hcall = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Copy the hypercall arguments into a local copy of the</span>
<span class="p_del">-		 * hcall_args struct.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (copy_from_user(&amp;args, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;hcalls[n],</span>
<span class="p_del">-				   sizeof(struct hcall_args))) {</span>
<span class="p_del">-			kill_guest(cpu, &quot;Fetching async hypercalls&quot;);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Do the hypercall, same as a normal one. */</span>
<span class="p_del">-		do_hcall(cpu, &amp;args);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Mark the hypercall done. */</span>
<span class="p_del">-		if (put_user(0xFF, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;hcall_status[n])) {</span>
<span class="p_del">-			kill_guest(cpu, &quot;Writing result for async hypercall&quot;);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Stop doing hypercalls if they want to notify the Launcher:</span>
<span class="p_del">-		 * it needs to service this first.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (cpu-&gt;pending.trap)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Last of all, we look at what happens first of all.  The very first time the</span>
<span class="p_del">- * Guest makes a hypercall, we end up here to set things up:</span>
<span class="p_del">- */</span>
<span class="p_del">-static void initialize(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * You can&#39;t do anything until you&#39;re initialized.  The Guest knows the</span>
<span class="p_del">-	 * rules, so we&#39;re unforgiving here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (cpu-&gt;hcall-&gt;arg0 != LHCALL_LGUEST_INIT) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;hypercall %li before INIT&quot;, cpu-&gt;hcall-&gt;arg0);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (lguest_arch_init_hypercalls(cpu))</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad guest page %p&quot;, cpu-&gt;lg-&gt;lguest_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Guest tells us where we&#39;re not to deliver interrupts by putting</span>
<span class="p_del">-	 * the instruction address into &quot;struct lguest_data&quot;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (get_user(cpu-&gt;lg-&gt;noirq_iret, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;noirq_iret))</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad guest page %p&quot;, cpu-&gt;lg-&gt;lguest_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We write the current time into the Guest&#39;s data page once so it can</span>
<span class="p_del">-	 * set its clock.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	write_timestamp(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* page_tables.c will also do some setup. */</span>
<span class="p_del">-	page_table_guest_data_init(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This is the one case where the above accesses might have been the</span>
<span class="p_del">-	 * first write to a Guest page.  This may have caused a copy-on-write</span>
<span class="p_del">-	 * fault, but the old page might be (read-only) in the Guest</span>
<span class="p_del">-	 * pagetable.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	guest_pagetable_clear_all(cpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:013</span>
<span class="p_del">- * If a Guest reads from a page (so creates a mapping) that it has never</span>
<span class="p_del">- * written to, and then the Launcher writes to it (ie. the output of a virtual</span>
<span class="p_del">- * device), the Guest will still see the old page.  In practice, this never</span>
<span class="p_del">- * happens: why would the Guest read a page which it has never written to?  But</span>
<span class="p_del">- * a similar scenario might one day bite us, so it&#39;s worth mentioning.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Note that if we used a shared anonymous mapping in the Launcher instead of</span>
<span class="p_del">- * mapping /dev/zero private, we wouldn&#39;t worry about cop-on-write.  And we</span>
<span class="p_del">- * need that to switch the Launcher to processes (away from threads) anyway.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:100</span>
<span class="p_del">- * Hypercalls</span>
<span class="p_del">- *</span>
<span class="p_del">- * Remember from the Guest, hypercalls come in two flavors: normal and</span>
<span class="p_del">- * asynchronous.  This file handles both of types.</span>
<span class="p_del">- */</span>
<span class="p_del">-void do_hypercalls(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Not initialized yet?  This hypercall must do it. */</span>
<span class="p_del">-	if (unlikely(!cpu-&gt;lg-&gt;lguest_data)) {</span>
<span class="p_del">-		/* Set up the &quot;struct lguest_data&quot; */</span>
<span class="p_del">-		initialize(cpu);</span>
<span class="p_del">-		/* Hcall is done. */</span>
<span class="p_del">-		cpu-&gt;hcall = NULL;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Guest has initialized.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Look in the hypercall ring for the async hypercalls:</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	do_async_hcalls(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If we stopped reading the hypercall ring because the Guest did a</span>
<span class="p_del">-	 * NOTIFY to the Launcher, we want to return now.  Otherwise we do</span>
<span class="p_del">-	 * the hypercall.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!cpu-&gt;pending.trap) {</span>
<span class="p_del">-		do_hcall(cpu, cpu-&gt;hcall);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Tricky point: we reset the hcall pointer to mark the</span>
<span class="p_del">-		 * hypercall as &quot;done&quot;.  We use the hcall pointer rather than</span>
<span class="p_del">-		 * the trap number to indicate a hypercall is pending.</span>
<span class="p_del">-		 * Normally it doesn&#39;t matter: the Guest will run again and</span>
<span class="p_del">-		 * update the trap number before we come back here.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * However, if we are signalled or the Guest sends I/O to the</span>
<span class="p_del">-		 * Launcher, the run_guest() loop will exit without running the</span>
<span class="p_del">-		 * Guest.  When it comes back it would try to re-run the</span>
<span class="p_del">-		 * hypercall.  Finding that bug sucked.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		cpu-&gt;hcall = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine supplies the Guest with time: it&#39;s used for wallclock time at</span>
<span class="p_del">- * initial boot and as a rough time source if the TSC isn&#39;t available.</span>
<span class="p_del">- */</span>
<span class="p_del">-void write_timestamp(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct timespec now;</span>
<span class="p_del">-	ktime_get_real_ts(&amp;now);</span>
<span class="p_del">-	if (copy_to_user(&amp;cpu-&gt;lg-&gt;lguest_data-&gt;time,</span>
<span class="p_del">-			 &amp;now, sizeof(struct timespec)))</span>
<span class="p_del">-		kill_guest(cpu, &quot;Writing timestamp&quot;);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/lguest/interrupts_and_traps.c b/drivers/lguest/interrupts_and_traps.c</span>
deleted file mode 100644
<span class="p_header">index 67392b6ab845..000000000000</span>
<span class="p_header">--- a/drivers/lguest/interrupts_and_traps.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,706 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:800</span>
<span class="p_del">- * Interrupts (traps) are complicated enough to earn their own file.</span>
<span class="p_del">- * There are three classes of interrupts:</span>
<span class="p_del">- *</span>
<span class="p_del">- * 1) Real hardware interrupts which occur while we&#39;re running the Guest,</span>
<span class="p_del">- * 2) Interrupts for virtual devices attached to the Guest, and</span>
<span class="p_del">- * 3) Traps and faults from the Guest.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Real hardware interrupts must be delivered to the Host, not the Guest.</span>
<span class="p_del">- * Virtual interrupts must be delivered to the Guest, but we make them look</span>
<span class="p_del">- * just like real hardware would deliver them.  Traps from the Guest can be set</span>
<span class="p_del">- * up to go directly back into the Guest, but sometimes the Host wants to see</span>
<span class="p_del">- * them first, so we also have a way of &quot;reflecting&quot; them into the Guest as if</span>
<span class="p_del">- * they had been delivered to it directly.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-#include &lt;linux/uaccess.h&gt;</span>
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/sched.h&gt;</span>
<span class="p_del">-#include &quot;lg.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Allow Guests to use a non-128 (ie. non-Linux) syscall trap. */</span>
<span class="p_del">-static unsigned int syscall_vector = IA32_SYSCALL_VECTOR;</span>
<span class="p_del">-module_param(syscall_vector, uint, 0444);</span>
<span class="p_del">-</span>
<span class="p_del">-/* The address of the interrupt handler is split into two bits: */</span>
<span class="p_del">-static unsigned long idt_address(u32 lo, u32 hi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (lo &amp; 0x0000FFFF) | (hi &amp; 0xFFFF0000);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The &quot;type&quot; of the interrupt handler is a 4 bit field: we only support a</span>
<span class="p_del">- * couple of types.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int idt_type(u32 lo, u32 hi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (hi &gt;&gt; 8) &amp; 0xF;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* An IDT entry can&#39;t be used unless the &quot;present&quot; bit is set. */</span>
<span class="p_del">-static bool idt_present(u32 lo, u32 hi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (hi &amp; 0x8000);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We need a helper to &quot;push&quot; a value onto the Guest&#39;s stack, since that&#39;s a</span>
<span class="p_del">- * big part of what delivering an interrupt does.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void push_guest_stack(struct lg_cpu *cpu, unsigned long *gstack, u32 val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Stack grows upwards: move stack then write value. */</span>
<span class="p_del">-	*gstack -= 4;</span>
<span class="p_del">-	lgwrite(cpu, *gstack, u32, val);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:210</span>
<span class="p_del">- * The push_guest_interrupt_stack() routine saves Guest state on the stack for</span>
<span class="p_del">- * an interrupt or trap.  The mechanics of delivering traps and interrupts to</span>
<span class="p_del">- * the Guest are the same, except some traps have an &quot;error code&quot; which gets</span>
<span class="p_del">- * pushed onto the stack as well: the caller tells us if this is one.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We set up the stack just like the CPU does for a real interrupt, so it&#39;s</span>
<span class="p_del">- * identical for the Guest (and the standard &quot;iret&quot; instruction will undo</span>
<span class="p_del">- * it).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void push_guest_interrupt_stack(struct lg_cpu *cpu, bool has_err)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long gstack, origstack;</span>
<span class="p_del">-	u32 eflags, ss, irq_enable;</span>
<span class="p_del">-	unsigned long virtstack;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There are two cases for interrupts: one where the Guest is already</span>
<span class="p_del">-	 * in the kernel, and a more complex one where the Guest is in</span>
<span class="p_del">-	 * userspace.  We check the privilege level to find out.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((cpu-&gt;regs-&gt;ss&amp;0x3) != GUEST_PL) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The Guest told us their kernel stack with the SET_STACK</span>
<span class="p_del">-		 * hypercall: both the virtual address and the segment.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		virtstack = cpu-&gt;esp1;</span>
<span class="p_del">-		ss = cpu-&gt;ss1;</span>
<span class="p_del">-</span>
<span class="p_del">-		origstack = gstack = guest_pa(cpu, virtstack);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We push the old stack segment and pointer onto the new</span>
<span class="p_del">-		 * stack: when the Guest does an &quot;iret&quot; back from the interrupt</span>
<span class="p_del">-		 * handler the CPU will notice they&#39;re dropping privilege</span>
<span class="p_del">-		 * levels and expect these here.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		push_guest_stack(cpu, &amp;gstack, cpu-&gt;regs-&gt;ss);</span>
<span class="p_del">-		push_guest_stack(cpu, &amp;gstack, cpu-&gt;regs-&gt;esp);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* We&#39;re staying on the same Guest (kernel) stack. */</span>
<span class="p_del">-		virtstack = cpu-&gt;regs-&gt;esp;</span>
<span class="p_del">-		ss = cpu-&gt;regs-&gt;ss;</span>
<span class="p_del">-</span>
<span class="p_del">-		origstack = gstack = guest_pa(cpu, virtstack);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Remember that we never let the Guest actually disable interrupts, so</span>
<span class="p_del">-	 * the &quot;Interrupt Flag&quot; bit is always set.  We copy that bit from the</span>
<span class="p_del">-	 * Guest&#39;s &quot;irq_enabled&quot; field into the eflags word: we saw the Guest</span>
<span class="p_del">-	 * copy it back in &quot;lguest_iret&quot;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	eflags = cpu-&gt;regs-&gt;eflags;</span>
<span class="p_del">-	if (get_user(irq_enable, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;irq_enabled) == 0</span>
<span class="p_del">-	    &amp;&amp; !(irq_enable &amp; X86_EFLAGS_IF))</span>
<span class="p_del">-		eflags &amp;= ~X86_EFLAGS_IF;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * An interrupt is expected to push three things on the stack: the old</span>
<span class="p_del">-	 * &quot;eflags&quot; word, the old code segment, and the old instruction</span>
<span class="p_del">-	 * pointer.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	push_guest_stack(cpu, &amp;gstack, eflags);</span>
<span class="p_del">-	push_guest_stack(cpu, &amp;gstack, cpu-&gt;regs-&gt;cs);</span>
<span class="p_del">-	push_guest_stack(cpu, &amp;gstack, cpu-&gt;regs-&gt;eip);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* For the six traps which supply an error code, we push that, too. */</span>
<span class="p_del">-	if (has_err)</span>
<span class="p_del">-		push_guest_stack(cpu, &amp;gstack, cpu-&gt;regs-&gt;errcode);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Adjust the stack pointer and stack segment. */</span>
<span class="p_del">-	cpu-&gt;regs-&gt;ss = ss;</span>
<span class="p_del">-	cpu-&gt;regs-&gt;esp = virtstack + (gstack - origstack);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This actually makes the Guest start executing the given interrupt/trap</span>
<span class="p_del">- * handler.</span>
<span class="p_del">- *</span>
<span class="p_del">- * &quot;lo&quot; and &quot;hi&quot; are the two parts of the Interrupt Descriptor Table for this</span>
<span class="p_del">- * interrupt or trap.  It&#39;s split into two parts for traditional reasons: gcc</span>
<span class="p_del">- * on i386 used to be frightened by 64 bit numbers.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void guest_run_interrupt(struct lg_cpu *cpu, u32 lo, u32 hi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If we&#39;re already in the kernel, we don&#39;t change stacks. */</span>
<span class="p_del">-	if ((cpu-&gt;regs-&gt;ss&amp;0x3) != GUEST_PL)</span>
<span class="p_del">-		cpu-&gt;regs-&gt;ss = cpu-&gt;esp1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set the code segment and the address to execute.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;regs-&gt;cs = (__KERNEL_CS|GUEST_PL);</span>
<span class="p_del">-	cpu-&gt;regs-&gt;eip = idt_address(lo, hi);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Trapping always clears these flags:</span>
<span class="p_del">-	 * TF: Trap flag</span>
<span class="p_del">-	 * VM: Virtual 8086 mode</span>
<span class="p_del">-	 * RF: Resume</span>
<span class="p_del">-	 * NT: Nested task.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;regs-&gt;eflags &amp;=</span>
<span class="p_del">-		~(X86_EFLAGS_TF|X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There are two kinds of interrupt handlers: 0xE is an &quot;interrupt</span>
<span class="p_del">-	 * gate&quot; which expects interrupts to be disabled on entry.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (idt_type(lo, hi) == 0xE)</span>
<span class="p_del">-		if (put_user(0, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;irq_enabled))</span>
<span class="p_del">-			kill_guest(cpu, &quot;Disabling interrupts&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This restores the eflags word which was pushed on the stack by a trap */</span>
<span class="p_del">-static void restore_eflags(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* This is the physical address of the stack. */</span>
<span class="p_del">-	unsigned long stack_pa = guest_pa(cpu, cpu-&gt;regs-&gt;esp);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Stack looks like this:</span>
<span class="p_del">-	 * Address	Contents</span>
<span class="p_del">-	 * esp		EIP</span>
<span class="p_del">-	 * esp + 4	CS</span>
<span class="p_del">-	 * esp + 8	EFLAGS</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;regs-&gt;eflags = lgread(cpu, stack_pa + 8, u32);</span>
<span class="p_del">-	cpu-&gt;regs-&gt;eflags &amp;=</span>
<span class="p_del">-		~(X86_EFLAGS_TF|X86_EFLAGS_VM|X86_EFLAGS_RF|X86_EFLAGS_NT);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:205</span>
<span class="p_del">- * Virtual Interrupts.</span>
<span class="p_del">- *</span>
<span class="p_del">- * interrupt_pending() returns the first pending interrupt which isn&#39;t blocked</span>
<span class="p_del">- * by the Guest.  It is called before every entry to the Guest, and just before</span>
<span class="p_del">- * we go to sleep when the Guest has halted itself.</span>
<span class="p_del">- */</span>
<span class="p_del">-unsigned int interrupt_pending(struct lg_cpu *cpu, bool *more)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int irq;</span>
<span class="p_del">-	DECLARE_BITMAP(blk, LGUEST_IRQS);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If the Guest hasn&#39;t even initialized yet, we can do nothing. */</span>
<span class="p_del">-	if (!cpu-&gt;lg-&gt;lguest_data)</span>
<span class="p_del">-		return LGUEST_IRQS;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Take our &quot;irqs_pending&quot; array and remove any interrupts the Guest</span>
<span class="p_del">-	 * wants blocked: the result ends up in &quot;blk&quot;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (copy_from_user(&amp;blk, cpu-&gt;lg-&gt;lguest_data-&gt;blocked_interrupts,</span>
<span class="p_del">-			   sizeof(blk)))</span>
<span class="p_del">-		return LGUEST_IRQS;</span>
<span class="p_del">-	bitmap_andnot(blk, cpu-&gt;irqs_pending, blk, LGUEST_IRQS);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Find the first interrupt. */</span>
<span class="p_del">-	irq = find_first_bit(blk, LGUEST_IRQS);</span>
<span class="p_del">-	*more = find_next_bit(blk, LGUEST_IRQS, irq+1);</span>
<span class="p_del">-</span>
<span class="p_del">-	return irq;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This actually diverts the Guest to running an interrupt handler, once an</span>
<span class="p_del">- * interrupt has been identified by interrupt_pending().</span>
<span class="p_del">- */</span>
<span class="p_del">-void try_deliver_interrupt(struct lg_cpu *cpu, unsigned int irq, bool more)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct desc_struct *idt;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(irq &gt;= LGUEST_IRQS);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If they&#39;re halted, interrupts restart them. */</span>
<span class="p_del">-	if (cpu-&gt;halted) {</span>
<span class="p_del">-		/* Re-enable interrupts. */</span>
<span class="p_del">-		if (put_user(X86_EFLAGS_IF, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;irq_enabled))</span>
<span class="p_del">-			kill_guest(cpu, &quot;Re-enabling interrupts&quot;);</span>
<span class="p_del">-		cpu-&gt;halted = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* Otherwise we check if they have interrupts disabled. */</span>
<span class="p_del">-		u32 irq_enabled;</span>
<span class="p_del">-		if (get_user(irq_enabled, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;irq_enabled))</span>
<span class="p_del">-			irq_enabled = 0;</span>
<span class="p_del">-		if (!irq_enabled) {</span>
<span class="p_del">-			/* Make sure they know an IRQ is pending. */</span>
<span class="p_del">-			put_user(X86_EFLAGS_IF,</span>
<span class="p_del">-				 &amp;cpu-&gt;lg-&gt;lguest_data-&gt;irq_pending);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Look at the IDT entry the Guest gave us for this interrupt.  The</span>
<span class="p_del">-	 * first 32 (FIRST_EXTERNAL_VECTOR) entries are for traps, so we skip</span>
<span class="p_del">-	 * over them.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	idt = &amp;cpu-&gt;arch.idt[FIRST_EXTERNAL_VECTOR+irq];</span>
<span class="p_del">-	/* If they don&#39;t have a handler (yet?), we just ignore it */</span>
<span class="p_del">-	if (idt_present(idt-&gt;a, idt-&gt;b)) {</span>
<span class="p_del">-		/* OK, mark it no longer pending and deliver it. */</span>
<span class="p_del">-		clear_bit(irq, cpu-&gt;irqs_pending);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * They may be about to iret, where they asked us never to</span>
<span class="p_del">-		 * deliver interrupts.  In this case, we can emulate that iret</span>
<span class="p_del">-		 * then immediately deliver the interrupt.  This is basically</span>
<span class="p_del">-		 * a noop: the iret would pop the interrupt frame and restore</span>
<span class="p_del">-		 * eflags, and then we&#39;d set it up again.  So just restore the</span>
<span class="p_del">-		 * eflags word and jump straight to the handler in this case.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Denys Vlasenko points out that this isn&#39;t quite right: if</span>
<span class="p_del">-		 * the iret was returning to userspace, then that interrupt</span>
<span class="p_del">-		 * would reset the stack pointer (which the Guest told us</span>
<span class="p_del">-		 * about via LHCALL_SET_STACK).  But unless the Guest is being</span>
<span class="p_del">-		 * *really* weird, that will be the same as the current stack</span>
<span class="p_del">-		 * anyway.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (cpu-&gt;regs-&gt;eip == cpu-&gt;lg-&gt;noirq_iret) {</span>
<span class="p_del">-			restore_eflags(cpu);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * set_guest_interrupt() takes a flag to say whether</span>
<span class="p_del">-			 * this interrupt pushes an error code onto the stack</span>
<span class="p_del">-			 * as well: virtual interrupts never do.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			push_guest_interrupt_stack(cpu, false);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* Actually make Guest cpu jump to handler. */</span>
<span class="p_del">-		guest_run_interrupt(cpu, idt-&gt;a, idt-&gt;b);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Every time we deliver an interrupt, we update the timestamp in the</span>
<span class="p_del">-	 * Guest&#39;s lguest_data struct.  It would be better for the Guest if we</span>
<span class="p_del">-	 * did this more often, but it can actually be quite slow: doing it</span>
<span class="p_del">-	 * here is a compromise which means at least it gets updated every</span>
<span class="p_del">-	 * timer interrupt.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	write_timestamp(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If there are no other interrupts we want to deliver, clear</span>
<span class="p_del">-	 * the pending flag.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!more)</span>
<span class="p_del">-		put_user(0, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;irq_pending);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* And this is the routine when we want to set an interrupt for the Guest. */</span>
<span class="p_del">-void set_interrupt(struct lg_cpu *cpu, unsigned int irq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Next time the Guest runs, the core code will see if it can deliver</span>
<span class="p_del">-	 * this interrupt.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	set_bit(irq, cpu-&gt;irqs_pending);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Make sure it sees it; it might be asleep (eg. halted), or running</span>
<span class="p_del">-	 * the Guest right now, in which case kick_process() will knock it out.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!wake_up_process(cpu-&gt;tsk))</span>
<span class="p_del">-		kick_process(cpu-&gt;tsk);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Linux uses trap 128 for system calls.  Plan9 uses 64, and Ron Minnich sent</span>
<span class="p_del">- * me a patch, so we support that too.  It&#39;d be a big step for lguest if half</span>
<span class="p_del">- * the Plan 9 user base were to start using it.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Actually now I think of it, it&#39;s possible that Ron *is* half the Plan 9</span>
<span class="p_del">- * userbase.  Oh well.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool could_be_syscall(unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Normal Linux IA32_SYSCALL_VECTOR or reserved vector? */</span>
<span class="p_del">-	return num == IA32_SYSCALL_VECTOR || num == syscall_vector;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* The syscall vector it wants must be unused by Host. */</span>
<span class="p_del">-bool check_syscall_vector(struct lguest *lg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 vector;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (get_user(vector, &amp;lg-&gt;lguest_data-&gt;syscall_vec))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	return could_be_syscall(vector);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int init_interrupts(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If they want some strange system call vector, reserve it now */</span>
<span class="p_del">-	if (syscall_vector != IA32_SYSCALL_VECTOR) {</span>
<span class="p_del">-		if (test_bit(syscall_vector, used_vectors) ||</span>
<span class="p_del">-		    vector_used_by_percpu_irq(syscall_vector)) {</span>
<span class="p_del">-			printk(KERN_ERR &quot;lg: couldn&#39;t reserve syscall %u\n&quot;,</span>
<span class="p_del">-				 syscall_vector);</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		set_bit(syscall_vector, used_vectors);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void free_interrupts(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (syscall_vector != IA32_SYSCALL_VECTOR)</span>
<span class="p_del">-		clear_bit(syscall_vector, used_vectors);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:220</span>
<span class="p_del">- * Now we&#39;ve got the routines to deliver interrupts, delivering traps like</span>
<span class="p_del">- * page fault is easy.  The only trick is that Intel decided that some traps</span>
<span class="p_del">- * should have error codes:</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool has_err(unsigned int trap)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (trap == 8 || (trap &gt;= 10 &amp;&amp; trap &lt;= 14) || trap == 17);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* deliver_trap() returns true if it could deliver the trap. */</span>
<span class="p_del">-bool deliver_trap(struct lg_cpu *cpu, unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Trap numbers are always 8 bit, but we set an impossible trap number</span>
<span class="p_del">-	 * for traps inside the Switcher, so check that here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (num &gt;= ARRAY_SIZE(cpu-&gt;arch.idt))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Early on the Guest hasn&#39;t set the IDT entries (or maybe it put a</span>
<span class="p_del">-	 * bogus one in): if we fail here, the Guest will be killed.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!idt_present(cpu-&gt;arch.idt[num].a, cpu-&gt;arch.idt[num].b))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	push_guest_interrupt_stack(cpu, has_err(num));</span>
<span class="p_del">-	guest_run_interrupt(cpu, cpu-&gt;arch.idt[num].a,</span>
<span class="p_del">-			    cpu-&gt;arch.idt[num].b);</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:250</span>
<span class="p_del">- * Here&#39;s the hard part: returning to the Host every time a trap happens</span>
<span class="p_del">- * and then calling deliver_trap() and re-entering the Guest is slow.</span>
<span class="p_del">- * Particularly because Guest userspace system calls are traps (usually trap</span>
<span class="p_del">- * 128).</span>
<span class="p_del">- *</span>
<span class="p_del">- * So we&#39;d like to set up the IDT to tell the CPU to deliver traps directly</span>
<span class="p_del">- * into the Guest.  This is possible, but the complexities cause the size of</span>
<span class="p_del">- * this file to double!  However, 150 lines of code is worth writing for taking</span>
<span class="p_del">- * system calls down from 1750ns to 270ns.  Plus, if lguest didn&#39;t do it, all</span>
<span class="p_del">- * the other hypervisors would beat it up at lunchtime.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This routine indicates if a particular trap number could be delivered</span>
<span class="p_del">- * directly.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Unfortunately, Linux 4.6 started using an interrupt gate instead of a</span>
<span class="p_del">- * trap gate for syscalls, so this trick is ineffective.  See Mastery for</span>
<span class="p_del">- * how we could do this anyway...</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool direct_trap(unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Hardware interrupts don&#39;t go to the Guest at all (except system</span>
<span class="p_del">-	 * call).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (num &gt;= FIRST_EXTERNAL_VECTOR &amp;&amp; !could_be_syscall(num))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Host needs to see page faults (for shadow paging and to save the</span>
<span class="p_del">-	 * fault address), general protection faults (in/out emulation) and</span>
<span class="p_del">-	 * device not available (TS handling) and of course, the hypercall trap.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return num != 14 &amp;&amp; num != 13 &amp;&amp; num != 7 &amp;&amp; num != LGUEST_TRAP_ENTRY;</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:005</span>
<span class="p_del">- * The Guest has the ability to turn its interrupt gates into trap gates,</span>
<span class="p_del">- * if it is careful.  The Host will let trap gates can go directly to the</span>
<span class="p_del">- * Guest, but the Guest needs the interrupts atomically disabled for an</span>
<span class="p_del">- * interrupt gate.  The Host could provide a mechanism to register more</span>
<span class="p_del">- * &quot;no-interrupt&quot; regions, and the Guest could point the trap gate at</span>
<span class="p_del">- * instructions within that region, where it can safely disable interrupts.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:006</span>
<span class="p_del">- * The Guests do not use the sysenter (fast system call) instruction,</span>
<span class="p_del">- * because it&#39;s hardcoded to enter privilege level 0 and so can&#39;t go direct.</span>
<span class="p_del">- * It&#39;s about twice as fast as the older &quot;int 0x80&quot; system call, so it might</span>
<span class="p_del">- * still be worthwhile to handle it in the Switcher and lcall down to the</span>
<span class="p_del">- * Guest.  The sysenter semantics are hairy tho: search for that keyword in</span>
<span class="p_del">- * entry.S</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:260</span>
<span class="p_del">- * When we make traps go directly into the Guest, we need to make sure</span>
<span class="p_del">- * the kernel stack is valid (ie. mapped in the page tables).  Otherwise, the</span>
<span class="p_del">- * CPU trying to deliver the trap will fault while trying to push the interrupt</span>
<span class="p_del">- * words on the stack: this is called a double fault, and it forces us to kill</span>
<span class="p_del">- * the Guest.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Which is deeply unfair, because (literally!) it wasn&#39;t the Guests&#39; fault.</span>
<span class="p_del">- */</span>
<span class="p_del">-void pin_stack_pages(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Depending on the CONFIG_4KSTACKS option, the Guest can have one or</span>
<span class="p_del">-	 * two pages of stack space.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; cpu-&gt;lg-&gt;stack_pages; i++)</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The stack grows *upwards*, so the address we&#39;re given is the</span>
<span class="p_del">-		 * start of the page after the kernel stack.  Subtract one to</span>
<span class="p_del">-		 * get back onto the first stack page, and keep subtracting to</span>
<span class="p_del">-		 * get to the rest of the stack pages.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		pin_page(cpu, cpu-&gt;esp1 - 1 - i * PAGE_SIZE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Direct traps also mean that we need to know whenever the Guest wants to use</span>
<span class="p_del">- * a different kernel stack, so we can change the guest TSS to use that</span>
<span class="p_del">- * stack.  The TSS entries expect a virtual address, so unlike most addresses</span>
<span class="p_del">- * the Guest gives us, the &quot;esp&quot; (stack pointer) value here is virtual, not</span>
<span class="p_del">- * physical.</span>
<span class="p_del">- *</span>
<span class="p_del">- * In Linux each process has its own kernel stack, so this happens a lot: we</span>
<span class="p_del">- * change stacks on each context switch.</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_set_stack(struct lg_cpu *cpu, u32 seg, u32 esp, unsigned int pages)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * You&#39;re not allowed a stack segment with privilege level 0: bad Guest!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((seg &amp; 0x3) != GUEST_PL)</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad stack segment %i&quot;, seg);</span>
<span class="p_del">-	/* We only expect one or two stack pages. */</span>
<span class="p_del">-	if (pages &gt; 2)</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad stack pages %u&quot;, pages);</span>
<span class="p_del">-	/* Save where the stack is, and how many pages */</span>
<span class="p_del">-	cpu-&gt;ss1 = seg;</span>
<span class="p_del">-	cpu-&gt;esp1 = esp;</span>
<span class="p_del">-	cpu-&gt;lg-&gt;stack_pages = pages;</span>
<span class="p_del">-	/* Make sure the new stack pages are mapped */</span>
<span class="p_del">-	pin_stack_pages(cpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * All this reference to mapping stacks leads us neatly into the other complex</span>
<span class="p_del">- * part of the Host: page table handling.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:235</span>
<span class="p_del">- * This is the routine which actually checks the Guest&#39;s IDT entry and</span>
<span class="p_del">- * transfers it into the entry in &quot;struct lguest&quot;:</span>
<span class="p_del">- */</span>
<span class="p_del">-static void set_trap(struct lg_cpu *cpu, struct desc_struct *trap,</span>
<span class="p_del">-		     unsigned int num, u32 lo, u32 hi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 type = idt_type(lo, hi);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We zero-out a not-present entry */</span>
<span class="p_del">-	if (!idt_present(lo, hi)) {</span>
<span class="p_del">-		trap-&gt;a = trap-&gt;b = 0;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We only support interrupt and trap gates. */</span>
<span class="p_del">-	if (type != 0xE &amp;&amp; type != 0xF)</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad IDT type %i&quot;, type);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We only copy the handler address, present bit, privilege level and</span>
<span class="p_del">-	 * type.  The privilege level controls where the trap can be triggered</span>
<span class="p_del">-	 * manually with an &quot;int&quot; instruction.  This is usually GUEST_PL,</span>
<span class="p_del">-	 * except for system calls which userspace can use.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	trap-&gt;a = ((__KERNEL_CS|GUEST_PL)&lt;&lt;16) | (lo&amp;0x0000FFFF);</span>
<span class="p_del">-	trap-&gt;b = (hi&amp;0xFFFFEF00);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:230</span>
<span class="p_del">- * While we&#39;re here, dealing with delivering traps and interrupts to the</span>
<span class="p_del">- * Guest, we might as well complete the picture: how the Guest tells us where</span>
<span class="p_del">- * it wants them to go.  This would be simple, except making traps fast</span>
<span class="p_del">- * requires some tricks.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We saw the Guest setting Interrupt Descriptor Table (IDT) entries with the</span>
<span class="p_del">- * LHCALL_LOAD_IDT_ENTRY hypercall before: that comes here.</span>
<span class="p_del">- */</span>
<span class="p_del">-void load_guest_idt_entry(struct lg_cpu *cpu, unsigned int num, u32 lo, u32 hi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Guest never handles: NMI, doublefault, spurious interrupt or</span>
<span class="p_del">-	 * hypercall.  We ignore when it tries to set them.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (num == 2 || num == 8 || num == 15 || num == LGUEST_TRAP_ENTRY)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Mark the IDT as changed: next time the Guest runs we&#39;ll know we have</span>
<span class="p_del">-	 * to copy this again.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;changed |= CHANGED_IDT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check that the Guest doesn&#39;t try to step outside the bounds. */</span>
<span class="p_del">-	if (num &gt;= ARRAY_SIZE(cpu-&gt;arch.idt))</span>
<span class="p_del">-		kill_guest(cpu, &quot;Setting idt entry %u&quot;, num);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		set_trap(cpu, &amp;cpu-&gt;arch.idt[num], num, lo, hi);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The default entry for each interrupt points into the Switcher routines which</span>
<span class="p_del">- * simply return to the Host.  The run_guest() loop will then call</span>
<span class="p_del">- * deliver_trap() to bounce it back into the Guest.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void default_idt_entry(struct desc_struct *idt,</span>
<span class="p_del">-			      int trap,</span>
<span class="p_del">-			      const unsigned long handler,</span>
<span class="p_del">-			      const struct desc_struct *base)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* A present interrupt gate. */</span>
<span class="p_del">-	u32 flags = 0x8e00;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set the privilege level on the entry for the hypercall: this allows</span>
<span class="p_del">-	 * the Guest to use the &quot;int&quot; instruction to trigger it.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (trap == LGUEST_TRAP_ENTRY)</span>
<span class="p_del">-		flags |= (GUEST_PL &lt;&lt; 13);</span>
<span class="p_del">-	else if (base)</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Copy privilege level from what Guest asked for.  This allows</span>
<span class="p_del">-		 * debug (int 3) traps from Guest userspace, for example.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		flags |= (base-&gt;b &amp; 0x6000);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now pack it into the IDT entry in its weird format. */</span>
<span class="p_del">-	idt-&gt;a = (LGUEST_CS&lt;&lt;16) | (handler&amp;0x0000FFFF);</span>
<span class="p_del">-	idt-&gt;b = (handler&amp;0xFFFF0000) | flags;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* When the Guest first starts, we put default entries into the IDT. */</span>
<span class="p_del">-void setup_default_idt_entries(struct lguest_ro_state *state,</span>
<span class="p_del">-			       const unsigned long *def)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(state-&gt;guest_idt); i++)</span>
<span class="p_del">-		default_idt_entry(&amp;state-&gt;guest_idt[i], i, def[i], NULL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:240</span>
<span class="p_del">- * We don&#39;t use the IDT entries in the &quot;struct lguest&quot; directly, instead</span>
<span class="p_del">- * we copy them into the IDT which we&#39;ve set up for Guests on this CPU, just</span>
<span class="p_del">- * before we run the Guest.  This routine does that copy.</span>
<span class="p_del">- */</span>
<span class="p_del">-void copy_traps(const struct lg_cpu *cpu, struct desc_struct *idt,</span>
<span class="p_del">-		const unsigned long *def)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We can simply copy the direct traps, otherwise we use the default</span>
<span class="p_del">-	 * ones in the Switcher: they will return to the Host.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(cpu-&gt;arch.idt); i++) {</span>
<span class="p_del">-		const struct desc_struct *gidt = &amp;cpu-&gt;arch.idt[i];</span>
<span class="p_del">-</span>
<span class="p_del">-		/* If no Guest can ever override this trap, leave it alone. */</span>
<span class="p_del">-		if (!direct_trap(i))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Only trap gates (type 15) can go direct to the Guest.</span>
<span class="p_del">-		 * Interrupt gates (type 14) disable interrupts as they are</span>
<span class="p_del">-		 * entered, which we never let the Guest do.  Not present</span>
<span class="p_del">-		 * entries (type 0x0) also can&#39;t go direct, of course.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * If it can&#39;t go direct, we still need to copy the priv. level:</span>
<span class="p_del">-		 * they might want to give userspace access to a software</span>
<span class="p_del">-		 * interrupt.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (idt_type(gidt-&gt;a, gidt-&gt;b) == 0xF)</span>
<span class="p_del">-			idt[i] = *gidt;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			default_idt_entry(&amp;idt[i], i, def[i], gidt);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:200</span>
<span class="p_del">- * The Guest Clock.</span>
<span class="p_del">- *</span>
<span class="p_del">- * There are two sources of virtual interrupts.  We saw one in lguest_user.c:</span>
<span class="p_del">- * the Launcher sending interrupts for virtual devices.  The other is the Guest</span>
<span class="p_del">- * timer interrupt.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Guest uses the LHCALL_SET_CLOCKEVENT hypercall to tell us how long to</span>
<span class="p_del">- * the next timer interrupt (in nanoseconds).  We use the high-resolution timer</span>
<span class="p_del">- * infrastructure to set a callback at that time.</span>
<span class="p_del">- *</span>
<span class="p_del">- * 0 means &quot;turn off the clock&quot;.</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_set_clockevent(struct lg_cpu *cpu, unsigned long delta)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ktime_t expires;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(delta == 0)) {</span>
<span class="p_del">-		/* Clock event device is shutting down. */</span>
<span class="p_del">-		hrtimer_cancel(&amp;cpu-&gt;hrt);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We use wallclock time here, so the Guest might not be running for</span>
<span class="p_del">-	 * all the time between now and the timer interrupt it asked for.  This</span>
<span class="p_del">-	 * is almost always the right thing to do.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	expires = ktime_add_ns(ktime_get_real(), delta);</span>
<span class="p_del">-	hrtimer_start(&amp;cpu-&gt;hrt, expires, HRTIMER_MODE_ABS);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the function called when the Guest&#39;s timer expires. */</span>
<span class="p_del">-static enum hrtimer_restart clockdev_fn(struct hrtimer *timer)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct lg_cpu *cpu = container_of(timer, struct lg_cpu, hrt);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Remember the first interrupt is the timer interrupt. */</span>
<span class="p_del">-	set_interrupt(cpu, 0);</span>
<span class="p_del">-	return HRTIMER_NORESTART;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This sets up the timer for this Guest. */</span>
<span class="p_del">-void init_clockdev(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hrtimer_init(&amp;cpu-&gt;hrt, CLOCK_REALTIME, HRTIMER_MODE_ABS);</span>
<span class="p_del">-	cpu-&gt;hrt.function = clockdev_fn;</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/lguest/lg.h b/drivers/lguest/lg.h</span>
deleted file mode 100644
<span class="p_header">index 2356a2318034..000000000000</span>
<span class="p_header">--- a/drivers/lguest/lg.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,258 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _LGUEST_H</span>
<span class="p_del">-#define _LGUEST_H</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef __ASSEMBLY__</span>
<span class="p_del">-#include &lt;linux/types.h&gt;</span>
<span class="p_del">-#include &lt;linux/init.h&gt;</span>
<span class="p_del">-#include &lt;linux/stringify.h&gt;</span>
<span class="p_del">-#include &lt;linux/lguest.h&gt;</span>
<span class="p_del">-#include &lt;linux/lguest_launcher.h&gt;</span>
<span class="p_del">-#include &lt;linux/wait.h&gt;</span>
<span class="p_del">-#include &lt;linux/hrtimer.h&gt;</span>
<span class="p_del">-#include &lt;linux/err.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/lguest.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-struct pgdir {</span>
<span class="p_del">-	unsigned long gpgdir;</span>
<span class="p_del">-	bool switcher_mapped;</span>
<span class="p_del">-	int last_host_cpu;</span>
<span class="p_del">-	pgd_t *pgdir;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* We have two pages shared with guests, per cpu.  */</span>
<span class="p_del">-struct lguest_pages {</span>
<span class="p_del">-	/* This is the stack page mapped rw in guest */</span>
<span class="p_del">-	char spare[PAGE_SIZE - sizeof(struct lguest_regs)];</span>
<span class="p_del">-	struct lguest_regs regs;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This is the host state &amp; guest descriptor page, ro in guest */</span>
<span class="p_del">-	struct lguest_ro_state state;</span>
<span class="p_del">-} __attribute__((aligned(PAGE_SIZE)));</span>
<span class="p_del">-</span>
<span class="p_del">-#define CHANGED_IDT		1</span>
<span class="p_del">-#define CHANGED_GDT		2</span>
<span class="p_del">-#define CHANGED_GDT_TLS		4 /* Actually a subset of CHANGED_GDT */</span>
<span class="p_del">-#define CHANGED_ALL	        3</span>
<span class="p_del">-</span>
<span class="p_del">-struct lg_cpu {</span>
<span class="p_del">-	unsigned int id;</span>
<span class="p_del">-	struct lguest *lg;</span>
<span class="p_del">-	struct task_struct *tsk;</span>
<span class="p_del">-	struct mm_struct *mm; 	/* == tsk-&gt;mm, but that becomes NULL on exit */</span>
<span class="p_del">-</span>
<span class="p_del">-	u32 cr2;</span>
<span class="p_del">-	u32 esp1;</span>
<span class="p_del">-	u16 ss1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Bitmap of what has changed: see CHANGED_* above. */</span>
<span class="p_del">-	int changed;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Pending operation. */</span>
<span class="p_del">-	struct lguest_pending pending;</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned long *reg_read; /* register from LHREQ_GETREG */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* At end of a page shared mapped over lguest_pages in guest. */</span>
<span class="p_del">-	unsigned long regs_page;</span>
<span class="p_del">-	struct lguest_regs *regs;</span>
<span class="p_del">-</span>
<span class="p_del">-	struct lguest_pages *last_pages;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialization mode: linear map everything. */</span>
<span class="p_del">-	bool linear_pages;</span>
<span class="p_del">-	int cpu_pgd; /* Which pgd this cpu is currently using */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If a hypercall was asked for, this points to the arguments. */</span>
<span class="p_del">-	struct hcall_args *hcall;</span>
<span class="p_del">-	u32 next_hcall;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Virtual clock device */</span>
<span class="p_del">-	struct hrtimer hrt;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Did the Guest tell us to halt? */</span>
<span class="p_del">-	int halted;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Pending virtual interrupts */</span>
<span class="p_del">-	DECLARE_BITMAP(irqs_pending, LGUEST_IRQS);</span>
<span class="p_del">-</span>
<span class="p_del">-	struct lg_cpu_arch arch;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* The private info the thread maintains about the guest. */</span>
<span class="p_del">-struct lguest {</span>
<span class="p_del">-	struct lguest_data __user *lguest_data;</span>
<span class="p_del">-	struct lg_cpu cpus[NR_CPUS];</span>
<span class="p_del">-	unsigned int nr_cpus;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Valid guest memory pages must be &lt; this. */</span>
<span class="p_del">-	u32 pfn_limit;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Device memory is &gt;= pfn_limit and &lt; device_limit. */</span>
<span class="p_del">-	u32 device_limit;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This provides the offset to the base of guest-physical memory in the</span>
<span class="p_del">-	 * Launcher.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	void __user *mem_base;</span>
<span class="p_del">-	unsigned long kernel_address;</span>
<span class="p_del">-</span>
<span class="p_del">-	struct pgdir pgdirs[4];</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned long noirq_iret;</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned int stack_pages;</span>
<span class="p_del">-	u32 tsc_khz;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Dead? */</span>
<span class="p_del">-	const char *dead;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-extern struct mutex lguest_lock;</span>
<span class="p_del">-</span>
<span class="p_del">-/* core.c: */</span>
<span class="p_del">-bool lguest_address_ok(const struct lguest *lg,</span>
<span class="p_del">-		       unsigned long addr, unsigned long len);</span>
<span class="p_del">-void __lgread(struct lg_cpu *, void *, unsigned long, unsigned);</span>
<span class="p_del">-void __lgwrite(struct lg_cpu *, unsigned long, const void *, unsigned);</span>
<span class="p_del">-extern struct page **lg_switcher_pages;</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:035</span>
<span class="p_del">- * Using memory-copy operations like that is usually inconvient, so we</span>
<span class="p_del">- * have the following helper macros which read and write a specific type (often</span>
<span class="p_del">- * an unsigned long).</span>
<span class="p_del">- *</span>
<span class="p_del">- * This reads into a variable of the given type then returns that.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define lgread(cpu, addr, type)						\</span>
<span class="p_del">-	({ type _v; __lgread((cpu), &amp;_v, (addr), sizeof(_v)); _v; })</span>
<span class="p_del">-</span>
<span class="p_del">-/* This checks that the variable is of the given type, then writes it out. */</span>
<span class="p_del">-#define lgwrite(cpu, addr, type, val)				\</span>
<span class="p_del">-	do {							\</span>
<span class="p_del">-		typecheck(type, val);				\</span>
<span class="p_del">-		__lgwrite((cpu), (addr), &amp;(val), sizeof(val));	\</span>
<span class="p_del">-	} while(0)</span>
<span class="p_del">-/* (end of memory access helper routines) :*/</span>
<span class="p_del">-</span>
<span class="p_del">-int run_guest(struct lg_cpu *cpu, unsigned long __user *user);</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Helper macros to obtain the first 12 or the last 20 bits, this is only the</span>
<span class="p_del">- * first step in the migration to the kernel types.  pte_pfn is already defined</span>
<span class="p_del">- * in the kernel.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define pgd_flags(x)	(pgd_val(x) &amp; ~PAGE_MASK)</span>
<span class="p_del">-#define pgd_pfn(x)	(pgd_val(x) &gt;&gt; PAGE_SHIFT)</span>
<span class="p_del">-#define pmd_flags(x)    (pmd_val(x) &amp; ~PAGE_MASK)</span>
<span class="p_del">-#define pmd_pfn(x)	(pmd_val(x) &gt;&gt; PAGE_SHIFT)</span>
<span class="p_del">-</span>
<span class="p_del">-/* interrupts_and_traps.c: */</span>
<span class="p_del">-unsigned int interrupt_pending(struct lg_cpu *cpu, bool *more);</span>
<span class="p_del">-void try_deliver_interrupt(struct lg_cpu *cpu, unsigned int irq, bool more);</span>
<span class="p_del">-void set_interrupt(struct lg_cpu *cpu, unsigned int irq);</span>
<span class="p_del">-bool deliver_trap(struct lg_cpu *cpu, unsigned int num);</span>
<span class="p_del">-void load_guest_idt_entry(struct lg_cpu *cpu, unsigned int i,</span>
<span class="p_del">-			  u32 low, u32 hi);</span>
<span class="p_del">-void guest_set_stack(struct lg_cpu *cpu, u32 seg, u32 esp, unsigned int pages);</span>
<span class="p_del">-void pin_stack_pages(struct lg_cpu *cpu);</span>
<span class="p_del">-void setup_default_idt_entries(struct lguest_ro_state *state,</span>
<span class="p_del">-			       const unsigned long *def);</span>
<span class="p_del">-void copy_traps(const struct lg_cpu *cpu, struct desc_struct *idt,</span>
<span class="p_del">-		const unsigned long *def);</span>
<span class="p_del">-void guest_set_clockevent(struct lg_cpu *cpu, unsigned long delta);</span>
<span class="p_del">-bool send_notify_to_eventfd(struct lg_cpu *cpu);</span>
<span class="p_del">-void init_clockdev(struct lg_cpu *cpu);</span>
<span class="p_del">-bool check_syscall_vector(struct lguest *lg);</span>
<span class="p_del">-bool could_be_syscall(unsigned int num);</span>
<span class="p_del">-int init_interrupts(void);</span>
<span class="p_del">-void free_interrupts(void);</span>
<span class="p_del">-</span>
<span class="p_del">-/* segments.c: */</span>
<span class="p_del">-void setup_default_gdt_entries(struct lguest_ro_state *state);</span>
<span class="p_del">-void setup_guest_gdt(struct lg_cpu *cpu);</span>
<span class="p_del">-void load_guest_gdt_entry(struct lg_cpu *cpu, unsigned int i,</span>
<span class="p_del">-			  u32 low, u32 hi);</span>
<span class="p_del">-void guest_load_tls(struct lg_cpu *cpu, unsigned long tls_array);</span>
<span class="p_del">-void copy_gdt(const struct lg_cpu *cpu, struct desc_struct *gdt);</span>
<span class="p_del">-void copy_gdt_tls(const struct lg_cpu *cpu, struct desc_struct *gdt);</span>
<span class="p_del">-</span>
<span class="p_del">-/* page_tables.c: */</span>
<span class="p_del">-int init_guest_pagetable(struct lguest *lg);</span>
<span class="p_del">-void free_guest_pagetable(struct lguest *lg);</span>
<span class="p_del">-void guest_new_pagetable(struct lg_cpu *cpu, unsigned long pgtable);</span>
<span class="p_del">-void guest_set_pgd(struct lguest *lg, unsigned long gpgdir, u32 i);</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-void guest_set_pmd(struct lguest *lg, unsigned long gpgdir, u32 i);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-void guest_pagetable_clear_all(struct lg_cpu *cpu);</span>
<span class="p_del">-void guest_pagetable_flush_user(struct lg_cpu *cpu);</span>
<span class="p_del">-void guest_set_pte(struct lg_cpu *cpu, unsigned long gpgdir,</span>
<span class="p_del">-		   unsigned long vaddr, pte_t val);</span>
<span class="p_del">-void map_switcher_in_guest(struct lg_cpu *cpu, struct lguest_pages *pages);</span>
<span class="p_del">-bool demand_page(struct lg_cpu *cpu, unsigned long cr2, int errcode,</span>
<span class="p_del">-		 unsigned long *iomem);</span>
<span class="p_del">-void pin_page(struct lg_cpu *cpu, unsigned long vaddr);</span>
<span class="p_del">-bool __guest_pa(struct lg_cpu *cpu, unsigned long vaddr, unsigned long *paddr);</span>
<span class="p_del">-unsigned long guest_pa(struct lg_cpu *cpu, unsigned long vaddr);</span>
<span class="p_del">-void page_table_guest_data_init(struct lg_cpu *cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-/* &lt;arch&gt;/core.c: */</span>
<span class="p_del">-void lguest_arch_host_init(void);</span>
<span class="p_del">-void lguest_arch_host_fini(void);</span>
<span class="p_del">-void lguest_arch_run_guest(struct lg_cpu *cpu);</span>
<span class="p_del">-void lguest_arch_handle_trap(struct lg_cpu *cpu);</span>
<span class="p_del">-int lguest_arch_init_hypercalls(struct lg_cpu *cpu);</span>
<span class="p_del">-int lguest_arch_do_hcall(struct lg_cpu *cpu, struct hcall_args *args);</span>
<span class="p_del">-void lguest_arch_setup_regs(struct lg_cpu *cpu, unsigned long start);</span>
<span class="p_del">-unsigned long *lguest_arch_regptr(struct lg_cpu *cpu, size_t reg_off, bool any);</span>
<span class="p_del">-</span>
<span class="p_del">-/* &lt;arch&gt;/switcher.S: */</span>
<span class="p_del">-extern char start_switcher_text[], end_switcher_text[], switch_to_guest[];</span>
<span class="p_del">-</span>
<span class="p_del">-/* lguest_user.c: */</span>
<span class="p_del">-int lguest_device_init(void);</span>
<span class="p_del">-void lguest_device_remove(void);</span>
<span class="p_del">-</span>
<span class="p_del">-/* hypercalls.c: */</span>
<span class="p_del">-void do_hypercalls(struct lg_cpu *cpu);</span>
<span class="p_del">-void write_timestamp(struct lg_cpu *cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:035</span>
<span class="p_del">- * Let&#39;s step aside for the moment, to study one important routine that&#39;s used</span>
<span class="p_del">- * widely in the Host code.</span>
<span class="p_del">- *</span>
<span class="p_del">- * There are many cases where the Guest can do something invalid, like pass crap</span>
<span class="p_del">- * to a hypercall.  Since only the Guest kernel can make hypercalls, it&#39;s quite</span>
<span class="p_del">- * acceptable to simply terminate the Guest and give the Launcher a nicely</span>
<span class="p_del">- * formatted reason.  It&#39;s also simpler for the Guest itself, which doesn&#39;t</span>
<span class="p_del">- * need to check most hypercalls for &quot;success&quot;; if you&#39;re still running, it</span>
<span class="p_del">- * succeeded.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Once this is called, the Guest will never run again, so most Host code can</span>
<span class="p_del">- * call this then continue as if nothing had happened.  This means many</span>
<span class="p_del">- * functions don&#39;t have to explicitly return an error code, which keeps the</span>
<span class="p_del">- * code simple.</span>
<span class="p_del">- *</span>
<span class="p_del">- * It also means that this can be called more than once: only the first one is</span>
<span class="p_del">- * remembered.  The only trick is that we still need to kill the Guest even if</span>
<span class="p_del">- * we can&#39;t allocate memory to store the reason.  Linux has a neat way of</span>
<span class="p_del">- * packing error codes into invalid pointers, so we use that here.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Like any macro which uses an &quot;if&quot;, it is safely wrapped in a run-once &quot;do {</span>
<span class="p_del">- * } while(0)&quot;.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define kill_guest(cpu, fmt...)					\</span>
<span class="p_del">-do {								\</span>
<span class="p_del">-	if (!(cpu)-&gt;lg-&gt;dead) {					\</span>
<span class="p_del">-		(cpu)-&gt;lg-&gt;dead = kasprintf(GFP_ATOMIC, fmt);	\</span>
<span class="p_del">-		if (!(cpu)-&gt;lg-&gt;dead)				\</span>
<span class="p_del">-			(cpu)-&gt;lg-&gt;dead = ERR_PTR(-ENOMEM);	\</span>
<span class="p_del">-	}							\</span>
<span class="p_del">-} while(0)</span>
<span class="p_del">-/* (End of aside) :*/</span>
<span class="p_del">-</span>
<span class="p_del">-#endif	/* __ASSEMBLY__ */</span>
<span class="p_del">-#endif	/* _LGUEST_H */</span>
<span class="p_header">diff --git a/drivers/lguest/lguest_user.c b/drivers/lguest/lguest_user.c</span>
deleted file mode 100644
<span class="p_header">index 1a6787bc9386..000000000000</span>
<span class="p_header">--- a/drivers/lguest/lguest_user.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,446 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:200 This contains all the /dev/lguest code, whereby the userspace</span>
<span class="p_del">- * launcher controls and communicates with the Guest.  For example,</span>
<span class="p_del">- * the first write will tell us the Guest&#39;s memory layout and entry</span>
<span class="p_del">- * point.  A read will run the Guest until something happens, such as</span>
<span class="p_del">- * a signal or the Guest accessing a device.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-#include &lt;linux/uaccess.h&gt;</span>
<span class="p_del">-#include &lt;linux/miscdevice.h&gt;</span>
<span class="p_del">-#include &lt;linux/fs.h&gt;</span>
<span class="p_del">-#include &lt;linux/sched.h&gt;</span>
<span class="p_del">-#include &lt;linux/sched/mm.h&gt;</span>
<span class="p_del">-#include &lt;linux/file.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-#include &lt;linux/export.h&gt;</span>
<span class="p_del">-#include &quot;lg.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:052</span>
<span class="p_del">-  The Launcher can get the registers, and also set some of them.</span>
<span class="p_del">-*/</span>
<span class="p_del">-static int getreg_setup(struct lg_cpu *cpu, const unsigned long __user *input)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long which;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We re-use the ptrace structure to specify which register to read. */</span>
<span class="p_del">-	if (get_user(which, input) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We set up the cpu register pointer, and their next read will</span>
<span class="p_del">-	 * actually get the value (instead of running the guest).</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The last argument &#39;true&#39; says we can access any register.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;reg_read = lguest_arch_regptr(cpu, which, true);</span>
<span class="p_del">-	if (!cpu-&gt;reg_read)</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* And because this is a write() call, we return the length used. */</span>
<span class="p_del">-	return sizeof(unsigned long) * 2;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int setreg(struct lg_cpu *cpu, const unsigned long __user *input)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long which, value, *reg;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We re-use the ptrace structure to specify which register to read. */</span>
<span class="p_del">-	if (get_user(which, input) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	input++;</span>
<span class="p_del">-	if (get_user(value, input) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The last argument &#39;false&#39; means we can&#39;t access all registers. */</span>
<span class="p_del">-	reg = lguest_arch_regptr(cpu, which, false);</span>
<span class="p_del">-	if (!reg)</span>
<span class="p_del">-		return -ENOENT;</span>
<span class="p_del">-</span>
<span class="p_del">-	*reg = value;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* And because this is a write() call, we return the length used. */</span>
<span class="p_del">-	return sizeof(unsigned long) * 3;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:050</span>
<span class="p_del">- * Sending an interrupt is done by writing LHREQ_IRQ and an interrupt</span>
<span class="p_del">- * number to /dev/lguest.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int user_send_irq(struct lg_cpu *cpu, const unsigned long __user *input)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long irq;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (get_user(irq, input) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	if (irq &gt;= LGUEST_IRQS)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Next time the Guest runs, the core code will see if it can deliver</span>
<span class="p_del">-	 * this interrupt.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	set_interrupt(cpu, irq);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:053</span>
<span class="p_del">- * Deliver a trap: this is used by the Launcher if it can&#39;t emulate</span>
<span class="p_del">- * an instruction.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int trap(struct lg_cpu *cpu, const unsigned long __user *input)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long trapnum;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (get_user(trapnum, input) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!deliver_trap(cpu, trapnum))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:040</span>
<span class="p_del">- * Once our Guest is initialized, the Launcher makes it run by reading</span>
<span class="p_del">- * from /dev/lguest.</span>
<span class="p_del">- */</span>
<span class="p_del">-static ssize_t read(struct file *file, char __user *user, size_t size,loff_t*o)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct lguest *lg = file-&gt;private_data;</span>
<span class="p_del">-	struct lg_cpu *cpu;</span>
<span class="p_del">-	unsigned int cpu_id = *o;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* You must write LHREQ_INITIALIZE first! */</span>
<span class="p_del">-	if (!lg)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Watch out for arbitrary vcpu indexes! */</span>
<span class="p_del">-	if (cpu_id &gt;= lg-&gt;nr_cpus)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	cpu = &amp;lg-&gt;cpus[cpu_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If you&#39;re not the task which owns the Guest, go away. */</span>
<span class="p_del">-	if (current != cpu-&gt;tsk)</span>
<span class="p_del">-		return -EPERM;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If the Guest is already dead, we indicate why */</span>
<span class="p_del">-	if (lg-&gt;dead) {</span>
<span class="p_del">-		size_t len;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* lg-&gt;dead either contains an error code, or a string. */</span>
<span class="p_del">-		if (IS_ERR(lg-&gt;dead))</span>
<span class="p_del">-			return PTR_ERR(lg-&gt;dead);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* We can only return as much as the buffer they read with. */</span>
<span class="p_del">-		len = min(size, strlen(lg-&gt;dead)+1);</span>
<span class="p_del">-		if (copy_to_user(user, lg-&gt;dead, len) != 0)</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		return len;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If we returned from read() last time because the Guest sent I/O,</span>
<span class="p_del">-	 * clear the flag.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (cpu-&gt;pending.trap)</span>
<span class="p_del">-		cpu-&gt;pending.trap = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Run the Guest until something interesting happens. */</span>
<span class="p_del">-	return run_guest(cpu, (unsigned long __user *)user);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:025</span>
<span class="p_del">- * This actually initializes a CPU.  For the moment, a Guest is only</span>
<span class="p_del">- * uniprocessor, so &quot;id&quot; is always 0.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int lg_cpu_start(struct lg_cpu *cpu, unsigned id, unsigned long start_ip)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* We have a limited number of CPUs in the lguest struct. */</span>
<span class="p_del">-	if (id &gt;= ARRAY_SIZE(cpu-&gt;lg-&gt;cpus))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set up this CPU&#39;s id, and pointer back to the lguest struct. */</span>
<span class="p_del">-	cpu-&gt;id = id;</span>
<span class="p_del">-	cpu-&gt;lg = container_of(cpu, struct lguest, cpus[id]);</span>
<span class="p_del">-	cpu-&gt;lg-&gt;nr_cpus++;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Each CPU has a timer it can set. */</span>
<span class="p_del">-	init_clockdev(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need a complete page for the Guest registers: they are accessible</span>
<span class="p_del">-	 * to the Guest and we can only grant it access to whole pages.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;regs_page = get_zeroed_page(GFP_KERNEL);</span>
<span class="p_del">-	if (!cpu-&gt;regs_page)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We actually put the registers at the end of the page. */</span>
<span class="p_del">-	cpu-&gt;regs = (void *)cpu-&gt;regs_page + PAGE_SIZE - sizeof(*cpu-&gt;regs);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now we initialize the Guest&#39;s registers, handing it the start</span>
<span class="p_del">-	 * address.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	lguest_arch_setup_regs(cpu, start_ip);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We keep a pointer to the Launcher task (ie. current task) for when</span>
<span class="p_del">-	 * other Guests want to wake this one (eg. console input).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;tsk = current;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to keep a pointer to the Launcher&#39;s memory map, because if</span>
<span class="p_del">-	 * the Launcher dies we need to clean it up.  If we don&#39;t keep a</span>
<span class="p_del">-	 * reference, it is destroyed before close() is called.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;mm = get_task_mm(cpu-&gt;tsk);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We remember which CPU&#39;s pages this Guest used last, for optimization</span>
<span class="p_del">-	 * when the same Guest runs on the same CPU twice.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;last_pages = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* No error == success. */</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:020</span>
<span class="p_del">- * The initialization write supplies 3 pointer sized (32 or 64 bit) values (in</span>
<span class="p_del">- * addition to the LHREQ_INITIALIZE value).  These are:</span>
<span class="p_del">- *</span>
<span class="p_del">- * base: The start of the Guest-physical memory inside the Launcher memory.</span>
<span class="p_del">- *</span>
<span class="p_del">- * pfnlimit: The highest (Guest-physical) page number the Guest should be</span>
<span class="p_del">- * allowed to access.  The Guest memory lives inside the Launcher, so it sets</span>
<span class="p_del">- * this to ensure the Guest can only reach its own memory.</span>
<span class="p_del">- *</span>
<span class="p_del">- * start: The first instruction to execute (&quot;eip&quot; in x86-speak).</span>
<span class="p_del">- */</span>
<span class="p_del">-static int initialize(struct file *file, const unsigned long __user *input)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* &quot;struct lguest&quot; contains all we (the Host) know about a Guest. */</span>
<span class="p_del">-	struct lguest *lg;</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-	unsigned long args[4];</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We grab the Big Lguest lock, which protects against multiple</span>
<span class="p_del">-	 * simultaneous initializations.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mutex_lock(&amp;lguest_lock);</span>
<span class="p_del">-	/* You can&#39;t initialize twice!  Close the device and start again... */</span>
<span class="p_del">-	if (file-&gt;private_data) {</span>
<span class="p_del">-		err = -EBUSY;</span>
<span class="p_del">-		goto unlock;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(args, input, sizeof(args)) != 0) {</span>
<span class="p_del">-		err = -EFAULT;</span>
<span class="p_del">-		goto unlock;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	lg = kzalloc(sizeof(*lg), GFP_KERNEL);</span>
<span class="p_del">-	if (!lg) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		goto unlock;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Populate the easy fields of our &quot;struct lguest&quot; */</span>
<span class="p_del">-	lg-&gt;mem_base = (void __user *)args[0];</span>
<span class="p_del">-	lg-&gt;pfn_limit = args[1];</span>
<span class="p_del">-	lg-&gt;device_limit = args[3];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This is the first cpu (cpu 0) and it will start booting at args[2] */</span>
<span class="p_del">-	err = lg_cpu_start(&amp;lg-&gt;cpus[0], 0, args[2]);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto free_lg;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Initialize the Guest&#39;s shadow page tables.  This allocates</span>
<span class="p_del">-	 * memory, so can fail.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	err = init_guest_pagetable(lg);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto free_regs;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We keep our &quot;struct lguest&quot; in the file&#39;s private_data. */</span>
<span class="p_del">-	file-&gt;private_data = lg;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;lguest_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* And because this is a write() call, we return the length used. */</span>
<span class="p_del">-	return sizeof(args);</span>
<span class="p_del">-</span>
<span class="p_del">-free_regs:</span>
<span class="p_del">-	/* FIXME: This should be in free_vcpu */</span>
<span class="p_del">-	free_page(lg-&gt;cpus[0].regs_page);</span>
<span class="p_del">-free_lg:</span>
<span class="p_del">-	kfree(lg);</span>
<span class="p_del">-unlock:</span>
<span class="p_del">-	mutex_unlock(&amp;lguest_lock);</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:010</span>
<span class="p_del">- * The first operation the Launcher does must be a write.  All writes</span>
<span class="p_del">- * start with an unsigned long number: for the first write this must be</span>
<span class="p_del">- * LHREQ_INITIALIZE to set up the Guest.  After that the Launcher can use</span>
<span class="p_del">- * writes of other values to send interrupts or set up receipt of notifications.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Note that we overload the &quot;offset&quot; in the /dev/lguest file to indicate what</span>
<span class="p_del">- * CPU number we&#39;re dealing with.  Currently this is always 0 since we only</span>
<span class="p_del">- * support uniprocessor Guests, but you can see the beginnings of SMP support</span>
<span class="p_del">- * here.</span>
<span class="p_del">- */</span>
<span class="p_del">-static ssize_t write(struct file *file, const char __user *in,</span>
<span class="p_del">-		     size_t size, loff_t *off)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Once the Guest is initialized, we hold the &quot;struct lguest&quot; in the</span>
<span class="p_del">-	 * file private data.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	struct lguest *lg = file-&gt;private_data;</span>
<span class="p_del">-	const unsigned long __user *input = (const unsigned long __user *)in;</span>
<span class="p_del">-	unsigned long req;</span>
<span class="p_del">-	struct lg_cpu *uninitialized_var(cpu);</span>
<span class="p_del">-	unsigned int cpu_id = *off;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The first value tells us what this request is. */</span>
<span class="p_del">-	if (get_user(req, input) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	input++;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If you haven&#39;t initialized, you must do that first. */</span>
<span class="p_del">-	if (req != LHREQ_INITIALIZE) {</span>
<span class="p_del">-		if (!lg || (cpu_id &gt;= lg-&gt;nr_cpus))</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		cpu = &amp;lg-&gt;cpus[cpu_id];</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Once the Guest is dead, you can only read() why it died. */</span>
<span class="p_del">-		if (lg-&gt;dead)</span>
<span class="p_del">-			return -ENOENT;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (req) {</span>
<span class="p_del">-	case LHREQ_INITIALIZE:</span>
<span class="p_del">-		return initialize(file, input);</span>
<span class="p_del">-	case LHREQ_IRQ:</span>
<span class="p_del">-		return user_send_irq(cpu, input);</span>
<span class="p_del">-	case LHREQ_GETREG:</span>
<span class="p_del">-		return getreg_setup(cpu, input);</span>
<span class="p_del">-	case LHREQ_SETREG:</span>
<span class="p_del">-		return setreg(cpu, input);</span>
<span class="p_del">-	case LHREQ_TRAP:</span>
<span class="p_del">-		return trap(cpu, input);</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int open(struct inode *inode, struct file *file)</span>
<span class="p_del">-{</span>
<span class="p_del">-	file-&gt;private_data = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:060</span>
<span class="p_del">- * The final piece of interface code is the close() routine.  It reverses</span>
<span class="p_del">- * everything done in initialize().  This is usually called because the</span>
<span class="p_del">- * Launcher exited.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Note that the close routine returns 0 or a negative error number: it can&#39;t</span>
<span class="p_del">- * really fail, but it can whine.  I blame Sun for this wart, and K&amp;R C for</span>
<span class="p_del">- * letting them do it.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-static int close(struct inode *inode, struct file *file)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct lguest *lg = file-&gt;private_data;</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If we never successfully initialized, there&#39;s nothing to clean up */</span>
<span class="p_del">-	if (!lg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need the big lock, to protect from inter-guest I/O and other</span>
<span class="p_del">-	 * Launchers initializing guests.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mutex_lock(&amp;lguest_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Free up the shadow page tables for the Guest. */</span>
<span class="p_del">-	free_guest_pagetable(lg);</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; lg-&gt;nr_cpus; i++) {</span>
<span class="p_del">-		/* Cancels the hrtimer set via LHCALL_SET_CLOCKEVENT. */</span>
<span class="p_del">-		hrtimer_cancel(&amp;lg-&gt;cpus[i].hrt);</span>
<span class="p_del">-		/* We can free up the register page we allocated. */</span>
<span class="p_del">-		free_page(lg-&gt;cpus[i].regs_page);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Now all the memory cleanups are done, it&#39;s safe to release</span>
<span class="p_del">-		 * the Launcher&#39;s memory management structure.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		mmput(lg-&gt;cpus[i].mm);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If lg-&gt;dead doesn&#39;t contain an error code it will be NULL or a</span>
<span class="p_del">-	 * kmalloc()ed string, either of which is ok to hand to kfree().</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!IS_ERR(lg-&gt;dead))</span>
<span class="p_del">-		kfree(lg-&gt;dead);</span>
<span class="p_del">-	/* Free the memory allocated to the lguest_struct */</span>
<span class="p_del">-	kfree(lg);</span>
<span class="p_del">-	/* Release lock and exit. */</span>
<span class="p_del">-	mutex_unlock(&amp;lguest_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:000</span>
<span class="p_del">- * Welcome to our journey through the Launcher!</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Launcher is the Host userspace program which sets up, runs and services</span>
<span class="p_del">- * the Guest.  In fact, many comments in the Drivers which refer to &quot;the Host&quot;</span>
<span class="p_del">- * doing things are inaccurate: the Launcher does all the device handling for</span>
<span class="p_del">- * the Guest, but the Guest can&#39;t know that.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Just to confuse you: to the Host kernel, the Launcher *is* the Guest and we</span>
<span class="p_del">- * shall see more of that later.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We begin our understanding with the Host kernel interface which the Launcher</span>
<span class="p_del">- * uses: reading and writing a character device called /dev/lguest.  All the</span>
<span class="p_del">- * work happens in the read(), write() and close() routines:</span>
<span class="p_del">- */</span>
<span class="p_del">-static const struct file_operations lguest_fops = {</span>
<span class="p_del">-	.owner	 = THIS_MODULE,</span>
<span class="p_del">-	.open	 = open,</span>
<span class="p_del">-	.release = close,</span>
<span class="p_del">-	.write	 = write,</span>
<span class="p_del">-	.read	 = read,</span>
<span class="p_del">-	.llseek  = default_llseek,</span>
<span class="p_del">-};</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is a textbook example of a &quot;misc&quot; character device.  Populate a &quot;struct</span>
<span class="p_del">- * miscdevice&quot; and register it with misc_register().</span>
<span class="p_del">- */</span>
<span class="p_del">-static struct miscdevice lguest_dev = {</span>
<span class="p_del">-	.minor	= MISC_DYNAMIC_MINOR,</span>
<span class="p_del">-	.name	= &quot;lguest&quot;,</span>
<span class="p_del">-	.fops	= &amp;lguest_fops,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-int __init lguest_device_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return misc_register(&amp;lguest_dev);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __exit lguest_device_remove(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	misc_deregister(&amp;lguest_dev);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/lguest/page_tables.c b/drivers/lguest/page_tables.c</span>
deleted file mode 100644
<span class="p_header">index 0bc127e9f16a..000000000000</span>
<span class="p_header">--- a/drivers/lguest/page_tables.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,1239 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:700</span>
<span class="p_del">- * The pagetable code, on the other hand, still shows the scars of</span>
<span class="p_del">- * previous encounters.  It&#39;s functional, and as neat as it can be in the</span>
<span class="p_del">- * circumstances, but be wary, for these things are subtle and break easily.</span>
<span class="p_del">- * The Guest provides a virtual to physical mapping, but we can neither trust</span>
<span class="p_del">- * it nor use it: we verify and convert it here then point the CPU to the</span>
<span class="p_del">- * converted Guest pages when running the Guest.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* Copyright (C) Rusty Russell IBM Corporation 2013.</span>
<span class="p_del">- * GPL v2 and any later version */</span>
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
<span class="p_del">-#include &lt;linux/gfp.h&gt;</span>
<span class="p_del">-#include &lt;linux/types.h&gt;</span>
<span class="p_del">-#include &lt;linux/spinlock.h&gt;</span>
<span class="p_del">-#include &lt;linux/random.h&gt;</span>
<span class="p_del">-#include &lt;linux/percpu.h&gt;</span>
<span class="p_del">-#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_del">-#include &lt;linux/uaccess.h&gt;</span>
<span class="p_del">-#include &quot;lg.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:008</span>
<span class="p_del">- * We hold reference to pages, which prevents them from being swapped.</span>
<span class="p_del">- * It&#39;d be nice to have a callback in the &quot;struct mm_struct&quot; when Linux wants</span>
<span class="p_del">- * to swap out.  If we had this, and a shrinker callback to trim PTE pages, we</span>
<span class="p_del">- * could probably consider launching Guests as non-root.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:300</span>
<span class="p_del">- * The Page Table Code</span>
<span class="p_del">- *</span>
<span class="p_del">- * We use two-level page tables for the Guest, or three-level with PAE.  If</span>
<span class="p_del">- * you&#39;re not entirely comfortable with virtual addresses, physical addresses</span>
<span class="p_del">- * and page tables then I recommend you review arch/x86/lguest/boot.c&#39;s &quot;Page</span>
<span class="p_del">- * Table Handling&quot; (with diagrams!).</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Guest keeps page tables, but we maintain the actual ones here: these are</span>
<span class="p_del">- * called &quot;shadow&quot; page tables.  Which is a very Guest-centric name: these are</span>
<span class="p_del">- * the real page tables the CPU uses, although we keep them up to date to</span>
<span class="p_del">- * reflect the Guest&#39;s.  (See what I mean about weird naming?  Since when do</span>
<span class="p_del">- * shadows reflect anything?)</span>
<span class="p_del">- *</span>
<span class="p_del">- * Anyway, this is the most complicated part of the Host code.  There are seven</span>
<span class="p_del">- * parts to this:</span>
<span class="p_del">- *  (i) Looking up a page table entry when the Guest faults,</span>
<span class="p_del">- *  (ii) Making sure the Guest stack is mapped,</span>
<span class="p_del">- *  (iii) Setting up a page table entry when the Guest tells us one has changed,</span>
<span class="p_del">- *  (iv) Switching page tables,</span>
<span class="p_del">- *  (v) Flushing (throwing away) page tables,</span>
<span class="p_del">- *  (vi) Mapping the Switcher when the Guest is about to run,</span>
<span class="p_del">- *  (vii) Setting up the page tables initially.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Switcher uses the complete top PTE page.  That&#39;s 1024 PTE entries (4MB)</span>
<span class="p_del">- * or 512 PTE entries with PAE (2MB).</span>
<span class="p_del">- */</span>
<span class="p_del">-#define SWITCHER_PGD_INDEX (PTRS_PER_PGD - 1)</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * For PAE we need the PMD index as well. We use the last 2MB, so we</span>
<span class="p_del">- * will need the last pmd entry of the last pmd page.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-#define CHECK_GPGD_MASK		_PAGE_PRESENT</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define CHECK_GPGD_MASK		_PAGE_TABLE</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:320</span>
<span class="p_del">- * The page table code is curly enough to need helper functions to keep it</span>
<span class="p_del">- * clear and clean.  The kernel itself provides many of them; one advantage</span>
<span class="p_del">- * of insisting that the Guest and Host use the same CONFIG_X86_PAE setting.</span>
<span class="p_del">- *</span>
<span class="p_del">- * There are two functions which return pointers to the shadow (aka &quot;real&quot;)</span>
<span class="p_del">- * page tables.</span>
<span class="p_del">- *</span>
<span class="p_del">- * spgd_addr() takes the virtual address and returns a pointer to the top-level</span>
<span class="p_del">- * page directory entry (PGD) for that address.  Since we keep track of several</span>
<span class="p_del">- * page tables, the &quot;i&quot; argument tells us which one we&#39;re interested in (it&#39;s</span>
<span class="p_del">- * usually the current one).</span>
<span class="p_del">- */</span>
<span class="p_del">-static pgd_t *spgd_addr(struct lg_cpu *cpu, u32 i, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int index = pgd_index(vaddr);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Return a pointer index&#39;th pgd entry for the i&#39;th page table. */</span>
<span class="p_del">-	return &amp;cpu-&gt;lg-&gt;pgdirs[i].pgdir[index];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine then takes the PGD entry given above, which contains the</span>
<span class="p_del">- * address of the PMD page.  It then returns a pointer to the PMD entry for the</span>
<span class="p_del">- * given address.</span>
<span class="p_del">- */</span>
<span class="p_del">-static pmd_t *spmd_addr(struct lg_cpu *cpu, pgd_t spgd, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int index = pmd_index(vaddr);</span>
<span class="p_del">-	pmd_t *page;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* You should never call this if the PGD entry wasn&#39;t valid */</span>
<span class="p_del">-	BUG_ON(!(pgd_flags(spgd) &amp; _PAGE_PRESENT));</span>
<span class="p_del">-	page = __va(pgd_pfn(spgd) &lt;&lt; PAGE_SHIFT);</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;page[index];</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine then takes the page directory entry returned above, which</span>
<span class="p_del">- * contains the address of the page table entry (PTE) page.  It then returns a</span>
<span class="p_del">- * pointer to the PTE entry for the given address.</span>
<span class="p_del">- */</span>
<span class="p_del">-static pte_t *spte_addr(struct lg_cpu *cpu, pgd_t spgd, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	pmd_t *pmd = spmd_addr(cpu, spgd, vaddr);</span>
<span class="p_del">-	pte_t *page = __va(pmd_pfn(*pmd) &lt;&lt; PAGE_SHIFT);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* You should never call this if the PMD entry wasn&#39;t valid */</span>
<span class="p_del">-	BUG_ON(!(pmd_flags(*pmd) &amp; _PAGE_PRESENT));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	pte_t *page = __va(pgd_pfn(spgd) &lt;&lt; PAGE_SHIFT);</span>
<span class="p_del">-	/* You should never call this if the PGD entry wasn&#39;t valid */</span>
<span class="p_del">-	BUG_ON(!(pgd_flags(spgd) &amp; _PAGE_PRESENT));</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;page[pte_index(vaddr)];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * These functions are just like the above, except they access the Guest</span>
<span class="p_del">- * page tables.  Hence they return a Guest address.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long gpgd_addr(struct lg_cpu *cpu, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int index = vaddr &gt;&gt; (PGDIR_SHIFT);</span>
<span class="p_del">-	return cpu-&gt;lg-&gt;pgdirs[cpu-&gt;cpu_pgd].gpgdir + index * sizeof(pgd_t);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-/* Follow the PGD to the PMD. */</span>
<span class="p_del">-static unsigned long gpmd_addr(pgd_t gpgd, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long gpage = pgd_pfn(gpgd) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-	BUG_ON(!(pgd_flags(gpgd) &amp; _PAGE_PRESENT));</span>
<span class="p_del">-	return gpage + pmd_index(vaddr) * sizeof(pmd_t);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Follow the PMD to the PTE. */</span>
<span class="p_del">-static unsigned long gpte_addr(struct lg_cpu *cpu,</span>
<span class="p_del">-			       pmd_t gpmd, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long gpage = pmd_pfn(gpmd) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(!(pmd_flags(gpmd) &amp; _PAGE_PRESENT));</span>
<span class="p_del">-	return gpage + pte_index(vaddr) * sizeof(pte_t);</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-/* Follow the PGD to the PTE (no mid-level for !PAE). */</span>
<span class="p_del">-static unsigned long gpte_addr(struct lg_cpu *cpu,</span>
<span class="p_del">-				pgd_t gpgd, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long gpage = pgd_pfn(gpgd) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(!(pgd_flags(gpgd) &amp; _PAGE_PRESENT));</span>
<span class="p_del">-	return gpage + pte_index(vaddr) * sizeof(pte_t);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:007</span>
<span class="p_del">- * get_pfn is slow: we could probably try to grab batches of pages here as</span>
<span class="p_del">- * an optimization (ie. pre-faulting).</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:350</span>
<span class="p_del">- * This routine takes a page number given by the Guest and converts it to</span>
<span class="p_del">- * an actual, physical page number.  It can fail for several reasons: the</span>
<span class="p_del">- * virtual address might not be mapped by the Launcher, the write flag is set</span>
<span class="p_del">- * and the page is read-only, or the write flag was set and the page was</span>
<span class="p_del">- * shared so had to be copied, but we ran out of memory.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This holds a reference to the page, so release_pte() is careful to put that</span>
<span class="p_del">- * back.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long get_pfn(unsigned long virtpfn, int write)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct page *page;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* gup me one page at this address please! */</span>
<span class="p_del">-	if (get_user_pages_fast(virtpfn &lt;&lt; PAGE_SHIFT, 1, write, &amp;page) == 1)</span>
<span class="p_del">-		return page_to_pfn(page);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This value indicates failure. */</span>
<span class="p_del">-	return -1UL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:340</span>
<span class="p_del">- * Converting a Guest page table entry to a shadow (ie. real) page table</span>
<span class="p_del">- * entry can be a little tricky.  The flags are (almost) the same, but the</span>
<span class="p_del">- * Guest PTE contains a virtual page number: the CPU needs the real page</span>
<span class="p_del">- * number.</span>
<span class="p_del">- */</span>
<span class="p_del">-static pte_t gpte_to_spte(struct lg_cpu *cpu, pte_t gpte, int write)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long pfn, base, flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Guest sets the global flag, because it thinks that it is using</span>
<span class="p_del">-	 * PGE.  We only told it to use PGE so it would tell us whether it was</span>
<span class="p_del">-	 * flushing a kernel mapping or a userspace mapping.  We don&#39;t actually</span>
<span class="p_del">-	 * use the global bit, so throw it away.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	flags = (pte_flags(gpte) &amp; ~_PAGE_GLOBAL);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The Guest&#39;s pages are offset inside the Launcher. */</span>
<span class="p_del">-	base = (unsigned long)cpu-&gt;lg-&gt;mem_base / PAGE_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need a temporary &quot;unsigned long&quot; variable to hold the answer from</span>
<span class="p_del">-	 * get_pfn(), because it returns 0xFFFFFFFF on failure, which wouldn&#39;t</span>
<span class="p_del">-	 * fit in spte.pfn.  get_pfn() finds the real physical number of the</span>
<span class="p_del">-	 * page, given the virtual number.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pfn = get_pfn(base + pte_pfn(gpte), write);</span>
<span class="p_del">-	if (pfn == -1UL) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;failed to get page %lu&quot;, pte_pfn(gpte));</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * When we destroy the Guest, we&#39;ll go through the shadow page</span>
<span class="p_del">-		 * tables and release_pte() them.  Make sure we don&#39;t think</span>
<span class="p_del">-		 * this one is valid!</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		flags = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* Now we assemble our shadow PTE from the page number and flags. */</span>
<span class="p_del">-	return pfn_pte(pfn, __pgprot(flags));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:460 And to complete the chain, release_pte() looks like this: */</span>
<span class="p_del">-static void release_pte(pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Remember that get_user_pages_fast() took a reference to the page, in</span>
<span class="p_del">-	 * get_pfn()?  We have to put it back now.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (pte_flags(pte) &amp; _PAGE_PRESENT)</span>
<span class="p_del">-		put_page(pte_page(pte));</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-static bool gpte_in_iomem(struct lg_cpu *cpu, pte_t gpte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* We don&#39;t handle large pages. */</span>
<span class="p_del">-	if (pte_flags(gpte) &amp; _PAGE_PSE)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	return (pte_pfn(gpte) &gt;= cpu-&gt;lg-&gt;pfn_limit</span>
<span class="p_del">-		&amp;&amp; pte_pfn(gpte) &lt; cpu-&gt;lg-&gt;device_limit);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool check_gpte(struct lg_cpu *cpu, pte_t gpte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((pte_flags(gpte) &amp; _PAGE_PSE) ||</span>
<span class="p_del">-	    pte_pfn(gpte) &gt;= cpu-&gt;lg-&gt;pfn_limit) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad page table entry&quot;);</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool check_gpgd(struct lg_cpu *cpu, pgd_t gpgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((pgd_flags(gpgd) &amp; ~CHECK_GPGD_MASK) ||</span>
<span class="p_del">-	    (pgd_pfn(gpgd) &gt;= cpu-&gt;lg-&gt;pfn_limit)) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad page directory entry&quot;);</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-static bool check_gpmd(struct lg_cpu *cpu, pmd_t gpmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((pmd_flags(gpmd) &amp; ~_PAGE_TABLE) ||</span>
<span class="p_del">-	    (pmd_pfn(gpmd) &gt;= cpu-&gt;lg-&gt;pfn_limit)) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad page middle directory entry&quot;);</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:331</span>
<span class="p_del">- * This is the core routine to walk the shadow page tables and find the page</span>
<span class="p_del">- * table entry for a specific address.</span>
<span class="p_del">- *</span>
<span class="p_del">- * If allocate is set, then we allocate any missing levels, setting the flags</span>
<span class="p_del">- * on the new page directory and mid-level directories using the arguments</span>
<span class="p_del">- * (which are copied from the Guest&#39;s page table entries).</span>
<span class="p_del">- */</span>
<span class="p_del">-static pte_t *find_spte(struct lg_cpu *cpu, unsigned long vaddr, bool allocate,</span>
<span class="p_del">-			int pgd_flags, int pmd_flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *spgd;</span>
<span class="p_del">-	/* Mid level for PAE. */</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	pmd_t *spmd;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get top level entry. */</span>
<span class="p_del">-	spgd = spgd_addr(cpu, cpu-&gt;cpu_pgd, vaddr);</span>
<span class="p_del">-	if (!(pgd_flags(*spgd) &amp; _PAGE_PRESENT)) {</span>
<span class="p_del">-		/* No shadow entry: allocate a new shadow PTE page. */</span>
<span class="p_del">-		unsigned long ptepage;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* If they didn&#39;t want us to allocate anything, stop. */</span>
<span class="p_del">-		if (!allocate)</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		ptepage = get_zeroed_page(GFP_KERNEL);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This is not really the Guest&#39;s fault, but killing it is</span>
<span class="p_del">-		 * simple for this corner case.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!ptepage) {</span>
<span class="p_del">-			kill_guest(cpu, &quot;out of memory allocating pte page&quot;);</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * And we copy the flags to the shadow PGD entry.  The page</span>
<span class="p_del">-		 * number in the shadow PGD is the page we just allocated.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		set_pgd(spgd, __pgd(__pa(ptepage) | pgd_flags));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Intel&#39;s Physical Address Extension actually uses three levels of</span>
<span class="p_del">-	 * page tables, so we need to look in the mid-level.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	/* Now look at the mid-level shadow entry. */</span>
<span class="p_del">-	spmd = spmd_addr(cpu, *spgd, vaddr);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(pmd_flags(*spmd) &amp; _PAGE_PRESENT)) {</span>
<span class="p_del">-		/* No shadow entry: allocate a new shadow PTE page. */</span>
<span class="p_del">-		unsigned long ptepage;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* If they didn&#39;t want us to allocate anything, stop. */</span>
<span class="p_del">-		if (!allocate)</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		ptepage = get_zeroed_page(GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This is not really the Guest&#39;s fault, but killing it is</span>
<span class="p_del">-		 * simple for this corner case.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!ptepage) {</span>
<span class="p_del">-			kill_guest(cpu, &quot;out of memory allocating pmd page&quot;);</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * And we copy the flags to the shadow PMD entry.  The page</span>
<span class="p_del">-		 * number in the shadow PMD is the page we just allocated.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		set_pmd(spmd, __pmd(__pa(ptepage) | pmd_flags));</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get the pointer to the shadow PTE entry we&#39;re going to set. */</span>
<span class="p_del">-	return spte_addr(cpu, *spgd, vaddr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:330</span>
<span class="p_del">- * (i) Looking up a page table entry when the Guest faults.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We saw this call in run_guest(): when we see a page fault in the Guest, we</span>
<span class="p_del">- * come here.  That&#39;s because we only set up the shadow page tables lazily as</span>
<span class="p_del">- * they&#39;re needed, so we get page faults all the time and quietly fix them up</span>
<span class="p_del">- * and return to the Guest without it knowing.</span>
<span class="p_del">- *</span>
<span class="p_del">- * If we fixed up the fault (ie. we mapped the address), this routine returns</span>
<span class="p_del">- * true.  Otherwise, it was a real fault and we need to tell the Guest.</span>
<span class="p_del">- *</span>
<span class="p_del">- * There&#39;s a corner case: they&#39;re trying to access memory between</span>
<span class="p_del">- * pfn_limit and device_limit, which is I/O memory.  In this case, we</span>
<span class="p_del">- * return false and set @iomem to the physical address, so the the</span>
<span class="p_del">- * Launcher can handle the instruction manually.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool demand_page(struct lg_cpu *cpu, unsigned long vaddr, int errcode,</span>
<span class="p_del">-		 unsigned long *iomem)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long gpte_ptr;</span>
<span class="p_del">-	pte_t gpte;</span>
<span class="p_del">-	pte_t *spte;</span>
<span class="p_del">-	pmd_t gpmd;</span>
<span class="p_del">-	pgd_t gpgd;</span>
<span class="p_del">-</span>
<span class="p_del">-	*iomem = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We never demand page the Switcher, so trying is a mistake. */</span>
<span class="p_del">-	if (vaddr &gt;= switcher_addr)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First step: get the top-level Guest page table entry. */</span>
<span class="p_del">-	if (unlikely(cpu-&gt;linear_pages)) {</span>
<span class="p_del">-		/* Faking up a linear mapping. */</span>
<span class="p_del">-		gpgd = __pgd(CHECK_GPGD_MASK);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		gpgd = lgread(cpu, gpgd_addr(cpu, vaddr), pgd_t);</span>
<span class="p_del">-		/* Toplevel not present?  We can&#39;t map it in. */</span>
<span class="p_del">-		if (!(pgd_flags(gpgd) &amp; _PAGE_PRESENT))</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* </span>
<span class="p_del">-		 * This kills the Guest if it has weird flags or tries to</span>
<span class="p_del">-		 * refer to a &quot;physical&quot; address outside the bounds.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!check_gpgd(cpu, gpgd))</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This &quot;mid-level&quot; entry is only used for non-linear, PAE mode. */</span>
<span class="p_del">-	gpmd = __pmd(_PAGE_TABLE);</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	if (likely(!cpu-&gt;linear_pages)) {</span>
<span class="p_del">-		gpmd = lgread(cpu, gpmd_addr(gpgd, vaddr), pmd_t);</span>
<span class="p_del">-		/* Middle level not present?  We can&#39;t map it in. */</span>
<span class="p_del">-		if (!(pmd_flags(gpmd) &amp; _PAGE_PRESENT))</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* </span>
<span class="p_del">-		 * This kills the Guest if it has weird flags or tries to</span>
<span class="p_del">-		 * refer to a &quot;physical&quot; address outside the bounds.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!check_gpmd(cpu, gpmd))</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * OK, now we look at the lower level in the Guest page table: keep its</span>
<span class="p_del">-	 * address, because we might update it later.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	gpte_ptr = gpte_addr(cpu, gpmd, vaddr);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * OK, now we look at the lower level in the Guest page table: keep its</span>
<span class="p_del">-	 * address, because we might update it later.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	gpte_ptr = gpte_addr(cpu, gpgd, vaddr);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(cpu-&gt;linear_pages)) {</span>
<span class="p_del">-		/* Linear?  Make up a PTE which points to same page. */</span>
<span class="p_del">-		gpte = __pte((vaddr &amp; PAGE_MASK) | _PAGE_RW | _PAGE_PRESENT);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* Read the actual PTE value. */</span>
<span class="p_del">-		gpte = lgread(cpu, gpte_ptr, pte_t);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If this page isn&#39;t in the Guest page tables, we can&#39;t page it in. */</span>
<span class="p_del">-	if (!(pte_flags(gpte) &amp; _PAGE_PRESENT))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Check they&#39;re not trying to write to a page the Guest wants</span>
<span class="p_del">-	 * read-only (bit 2 of errcode == write).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((errcode &amp; 2) &amp;&amp; !(pte_flags(gpte) &amp; _PAGE_RW))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* User access to a kernel-only page? (bit 3 == user access) */</span>
<span class="p_del">-	if ((errcode &amp; 4) &amp;&amp; !(pte_flags(gpte) &amp; _PAGE_USER))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If they&#39;re accessing io memory, we expect a fault. */</span>
<span class="p_del">-	if (gpte_in_iomem(cpu, gpte)) {</span>
<span class="p_del">-		*iomem = (pte_pfn(gpte) &lt;&lt; PAGE_SHIFT) | (vaddr &amp; ~PAGE_MASK);</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Check that the Guest PTE flags are OK, and the page number is below</span>
<span class="p_del">-	 * the pfn_limit (ie. not mapping the Launcher binary).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!check_gpte(cpu, gpte))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Add the _PAGE_ACCESSED and (for a write) _PAGE_DIRTY flag */</span>
<span class="p_del">-	gpte = pte_mkyoung(gpte);</span>
<span class="p_del">-	if (errcode &amp; 2)</span>
<span class="p_del">-		gpte = pte_mkdirty(gpte);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get the pointer to the shadow PTE entry we&#39;re going to set. */</span>
<span class="p_del">-	spte = find_spte(cpu, vaddr, true, pgd_flags(gpgd), pmd_flags(gpmd));</span>
<span class="p_del">-	if (!spte)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If there was a valid shadow PTE entry here before, we release it.</span>
<span class="p_del">-	 * This can happen with a write to a previously read-only entry.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	release_pte(*spte);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If this is a write, we insist that the Guest page is writable (the</span>
<span class="p_del">-	 * final arg to gpte_to_spte()).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (pte_dirty(gpte))</span>
<span class="p_del">-		*spte = gpte_to_spte(cpu, gpte, 1);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If this is a read, don&#39;t set the &quot;writable&quot; bit in the page</span>
<span class="p_del">-		 * table entry, even if the Guest says it&#39;s writable.  That way</span>
<span class="p_del">-		 * we will come back here when a write does actually occur, so</span>
<span class="p_del">-		 * we can update the Guest&#39;s _PAGE_DIRTY flag.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		set_pte(spte, gpte_to_spte(cpu, pte_wrprotect(gpte), 0));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Finally, we write the Guest PTE entry back: we&#39;ve set the</span>
<span class="p_del">-	 * _PAGE_ACCESSED and maybe the _PAGE_DIRTY flags.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (likely(!cpu-&gt;linear_pages))</span>
<span class="p_del">-		lgwrite(cpu, gpte_ptr, pte_t, gpte);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The fault is fixed, the page table is populated, the mapping</span>
<span class="p_del">-	 * manipulated, the result returned and the code complete.  A small</span>
<span class="p_del">-	 * delay and a trace of alliteration are the only indications the Guest</span>
<span class="p_del">-	 * has that a page fault occurred at all.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:360</span>
<span class="p_del">- * (ii) Making sure the Guest stack is mapped.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Remember that direct traps into the Guest need a mapped Guest kernel stack.</span>
<span class="p_del">- * pin_stack_pages() calls us here: we could simply call demand_page(), but as</span>
<span class="p_del">- * we&#39;ve seen that logic is quite long, and usually the stack pages are already</span>
<span class="p_del">- * mapped, so it&#39;s overkill.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is a quick version which answers the question: is this virtual address</span>
<span class="p_del">- * mapped by the shadow page tables, and is it writable?</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool page_writable(struct lg_cpu *cpu, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pte_t *spte;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* You can&#39;t put your stack in the Switcher! */</span>
<span class="p_del">-	if (vaddr &gt;= switcher_addr)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If there&#39;s no shadow PTE, it&#39;s not writable. */</span>
<span class="p_del">-	spte = find_spte(cpu, vaddr, false, 0, 0);</span>
<span class="p_del">-	if (!spte)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Check the flags on the pte entry itself: it must be present and</span>
<span class="p_del">-	 * writable.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	flags = pte_flags(*spte);</span>
<span class="p_del">-	return (flags &amp; (_PAGE_PRESENT|_PAGE_RW)) == (_PAGE_PRESENT|_PAGE_RW);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * So, when pin_stack_pages() asks us to pin a page, we check if it&#39;s already</span>
<span class="p_del">- * in the page tables, and if not, we call demand_page() with error code 2</span>
<span class="p_del">- * (meaning &quot;write&quot;).</span>
<span class="p_del">- */</span>
<span class="p_del">-void pin_page(struct lg_cpu *cpu, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long iomem;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!page_writable(cpu, vaddr) &amp;&amp; !demand_page(cpu, vaddr, 2, &amp;iomem))</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad stack page %#lx&quot;, vaddr);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-static void release_pmd(pmd_t *spmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If the entry&#39;s not present, there&#39;s nothing to release. */</span>
<span class="p_del">-	if (pmd_flags(*spmd) &amp; _PAGE_PRESENT) {</span>
<span class="p_del">-		unsigned int i;</span>
<span class="p_del">-		pte_t *ptepage = __va(pmd_pfn(*spmd) &lt;&lt; PAGE_SHIFT);</span>
<span class="p_del">-		/* For each entry in the page, we might need to release it. */</span>
<span class="p_del">-		for (i = 0; i &lt; PTRS_PER_PTE; i++)</span>
<span class="p_del">-			release_pte(ptepage[i]);</span>
<span class="p_del">-		/* Now we can free the page of PTEs */</span>
<span class="p_del">-		free_page((long)ptepage);</span>
<span class="p_del">-		/* And zero out the PMD entry so we never release it twice. */</span>
<span class="p_del">-		set_pmd(spmd, __pmd(0));</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void release_pgd(pgd_t *spgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If the entry&#39;s not present, there&#39;s nothing to release. */</span>
<span class="p_del">-	if (pgd_flags(*spgd) &amp; _PAGE_PRESENT) {</span>
<span class="p_del">-		unsigned int i;</span>
<span class="p_del">-		pmd_t *pmdpage = __va(pgd_pfn(*spgd) &lt;&lt; PAGE_SHIFT);</span>
<span class="p_del">-</span>
<span class="p_del">-		for (i = 0; i &lt; PTRS_PER_PMD; i++)</span>
<span class="p_del">-			release_pmd(&amp;pmdpage[i]);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Now we can free the page of PMDs */</span>
<span class="p_del">-		free_page((long)pmdpage);</span>
<span class="p_del">-		/* And zero out the PGD entry so we never release it twice. */</span>
<span class="p_del">-		set_pgd(spgd, __pgd(0));</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#else /* !CONFIG_X86_PAE */</span>
<span class="p_del">-/*H:450</span>
<span class="p_del">- * If we chase down the release_pgd() code, the non-PAE version looks like</span>
<span class="p_del">- * this.  The PAE version is almost identical, but instead of calling</span>
<span class="p_del">- * release_pte it calls release_pmd(), which looks much like this.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void release_pgd(pgd_t *spgd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If the entry&#39;s not present, there&#39;s nothing to release. */</span>
<span class="p_del">-	if (pgd_flags(*spgd) &amp; _PAGE_PRESENT) {</span>
<span class="p_del">-		unsigned int i;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Converting the pfn to find the actual PTE page is easy: turn</span>
<span class="p_del">-		 * the page number into a physical address, then convert to a</span>
<span class="p_del">-		 * virtual address (easy for kernel pages like this one).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		pte_t *ptepage = __va(pgd_pfn(*spgd) &lt;&lt; PAGE_SHIFT);</span>
<span class="p_del">-		/* For each entry in the page, we might need to release it. */</span>
<span class="p_del">-		for (i = 0; i &lt; PTRS_PER_PTE; i++)</span>
<span class="p_del">-			release_pte(ptepage[i]);</span>
<span class="p_del">-		/* Now we can free the page of PTEs */</span>
<span class="p_del">-		free_page((long)ptepage);</span>
<span class="p_del">-		/* And zero out the PGD entry so we never release it twice. */</span>
<span class="p_del">-		*spgd = __pgd(0);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:445</span>
<span class="p_del">- * We saw flush_user_mappings() twice: once from the flush_user_mappings()</span>
<span class="p_del">- * hypercall and once in new_pgdir() when we re-used a top-level pgdir page.</span>
<span class="p_del">- * It simply releases every PTE page from 0 up to the Guest&#39;s kernel address.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void flush_user_mappings(struct lguest *lg, int idx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-	/* Release every pgd entry up to the kernel&#39;s address. */</span>
<span class="p_del">-	for (i = 0; i &lt; pgd_index(lg-&gt;kernel_address); i++)</span>
<span class="p_del">-		release_pgd(lg-&gt;pgdirs[idx].pgdir + i);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:440</span>
<span class="p_del">- * (v) Flushing (throwing away) page tables,</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Guest has a hypercall to throw away the page tables: it&#39;s used when a</span>
<span class="p_del">- * large number of mappings have been changed.</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_pagetable_flush_user(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Drop the userspace part of the current page table. */</span>
<span class="p_del">-	flush_user_mappings(cpu-&gt;lg, cpu-&gt;cpu_pgd);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* We walk down the guest page tables to get a guest-physical address */</span>
<span class="p_del">-bool __guest_pa(struct lg_cpu *cpu, unsigned long vaddr, unsigned long *paddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t gpgd;</span>
<span class="p_del">-	pte_t gpte;</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	pmd_t gpmd;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Still not set up?  Just map 1:1. */</span>
<span class="p_del">-	if (unlikely(cpu-&gt;linear_pages)) {</span>
<span class="p_del">-		*paddr = vaddr;</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First step: get the top-level Guest page table entry. */</span>
<span class="p_del">-	gpgd = lgread(cpu, gpgd_addr(cpu, vaddr), pgd_t);</span>
<span class="p_del">-	/* Toplevel not present?  We can&#39;t map it in. */</span>
<span class="p_del">-	if (!(pgd_flags(gpgd) &amp; _PAGE_PRESENT))</span>
<span class="p_del">-		goto fail;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	gpmd = lgread(cpu, gpmd_addr(gpgd, vaddr), pmd_t);</span>
<span class="p_del">-	if (!(pmd_flags(gpmd) &amp; _PAGE_PRESENT))</span>
<span class="p_del">-		goto fail;</span>
<span class="p_del">-	gpte = lgread(cpu, gpte_addr(cpu, gpmd, vaddr), pte_t);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	gpte = lgread(cpu, gpte_addr(cpu, gpgd, vaddr), pte_t);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	if (!(pte_flags(gpte) &amp; _PAGE_PRESENT))</span>
<span class="p_del">-		goto fail;</span>
<span class="p_del">-</span>
<span class="p_del">-	*paddr = pte_pfn(gpte) * PAGE_SIZE | (vaddr &amp; ~PAGE_MASK);</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-</span>
<span class="p_del">-fail:</span>
<span class="p_del">-	*paddr = -1UL;</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is the version we normally use: kills the Guest if it uses a</span>
<span class="p_del">- * bad address</span>
<span class="p_del">- */</span>
<span class="p_del">-unsigned long guest_pa(struct lg_cpu *cpu, unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long paddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!__guest_pa(cpu, vaddr, &amp;paddr))</span>
<span class="p_del">-		kill_guest(cpu, &quot;Bad address %#lx&quot;, vaddr);</span>
<span class="p_del">-	return paddr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We keep several page tables.  This is a simple routine to find the page</span>
<span class="p_del">- * table (if any) corresponding to this top-level address the Guest has given</span>
<span class="p_del">- * us.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned int find_pgdir(struct lguest *lg, unsigned long pgtable)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(lg-&gt;pgdirs); i++)</span>
<span class="p_del">-		if (lg-&gt;pgdirs[i].pgdir &amp;&amp; lg-&gt;pgdirs[i].gpgdir == pgtable)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	return i;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:435</span>
<span class="p_del">- * And this is us, creating the new page directory.  If we really do</span>
<span class="p_del">- * allocate a new one (and so the kernel parts are not there), we set</span>
<span class="p_del">- * blank_pgdir.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned int new_pgdir(struct lg_cpu *cpu,</span>
<span class="p_del">-			      unsigned long gpgdir,</span>
<span class="p_del">-			      int *blank_pgdir)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int next;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We pick one entry at random to throw out.  Choosing the Least</span>
<span class="p_del">-	 * Recently Used might be better, but this is easy.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	next = prandom_u32() % ARRAY_SIZE(cpu-&gt;lg-&gt;pgdirs);</span>
<span class="p_del">-	/* If it&#39;s never been allocated at all before, try now. */</span>
<span class="p_del">-	if (!cpu-&gt;lg-&gt;pgdirs[next].pgdir) {</span>
<span class="p_del">-		cpu-&gt;lg-&gt;pgdirs[next].pgdir =</span>
<span class="p_del">-					(pgd_t *)get_zeroed_page(GFP_KERNEL);</span>
<span class="p_del">-		/* If the allocation fails, just keep using the one we have */</span>
<span class="p_del">-		if (!cpu-&gt;lg-&gt;pgdirs[next].pgdir)</span>
<span class="p_del">-			next = cpu-&gt;cpu_pgd;</span>
<span class="p_del">-		else {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * This is a blank page, so there are no kernel</span>
<span class="p_del">-			 * mappings: caller must map the stack!</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			*blank_pgdir = 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* Record which Guest toplevel this shadows. */</span>
<span class="p_del">-	cpu-&gt;lg-&gt;pgdirs[next].gpgdir = gpgdir;</span>
<span class="p_del">-	/* Release all the non-kernel mappings. */</span>
<span class="p_del">-	flush_user_mappings(cpu-&gt;lg, next);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This hasn&#39;t run on any CPU at all. */</span>
<span class="p_del">-	cpu-&gt;lg-&gt;pgdirs[next].last_host_cpu = -1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return next;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:501</span>
<span class="p_del">- * We do need the Switcher code mapped at all times, so we allocate that</span>
<span class="p_del">- * part of the Guest page table here.  We map the Switcher code immediately,</span>
<span class="p_del">- * but defer mapping of the guest register page and IDT/LDT etc page until</span>
<span class="p_del">- * just before we run the guest in map_switcher_in_guest().</span>
<span class="p_del">- *</span>
<span class="p_del">- * We *could* do this setup in map_switcher_in_guest(), but at that point</span>
<span class="p_del">- * we&#39;ve interrupts disabled, and allocating pages like that is fraught: we</span>
<span class="p_del">- * can&#39;t sleep if we need to free up some memory.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool allocate_switcher_mapping(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; TOTAL_SWITCHER_PAGES; i++) {</span>
<span class="p_del">-		pte_t *pte = find_spte(cpu, switcher_addr + i * PAGE_SIZE, true,</span>
<span class="p_del">-				       CHECK_GPGD_MASK, _PAGE_TABLE);</span>
<span class="p_del">-		if (!pte)</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Map the switcher page if not already there.  It might</span>
<span class="p_del">-		 * already be there because we call allocate_switcher_mapping()</span>
<span class="p_del">-		 * in guest_set_pgd() just in case it did discard our Switcher</span>
<span class="p_del">-		 * mapping, but it probably didn&#39;t.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (i == 0 &amp;&amp; !(pte_flags(*pte) &amp; _PAGE_PRESENT)) {</span>
<span class="p_del">-			/* Get a reference to the Switcher page. */</span>
<span class="p_del">-			get_page(lg_switcher_pages[0]);</span>
<span class="p_del">-			/* Create a read-only, exectuable, kernel-style PTE */</span>
<span class="p_del">-			set_pte(pte,</span>
<span class="p_del">-				mk_pte(lg_switcher_pages[0], PAGE_KERNEL_RX));</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	cpu-&gt;lg-&gt;pgdirs[cpu-&gt;cpu_pgd].switcher_mapped = true;</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:470</span>
<span class="p_del">- * Finally, a routine which throws away everything: all PGD entries in all</span>
<span class="p_del">- * the shadow page tables, including the Guest&#39;s kernel mappings.  This is used</span>
<span class="p_del">- * when we destroy the Guest.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void release_all_pagetables(struct lguest *lg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i, j;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Every shadow pagetable this Guest has */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(lg-&gt;pgdirs); i++) {</span>
<span class="p_del">-		if (!lg-&gt;pgdirs[i].pgdir)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Every PGD entry. */</span>
<span class="p_del">-		for (j = 0; j &lt; PTRS_PER_PGD; j++)</span>
<span class="p_del">-			release_pgd(lg-&gt;pgdirs[i].pgdir + j);</span>
<span class="p_del">-		lg-&gt;pgdirs[i].switcher_mapped = false;</span>
<span class="p_del">-		lg-&gt;pgdirs[i].last_host_cpu = -1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We also throw away everything when a Guest tells us it&#39;s changed a kernel</span>
<span class="p_del">- * mapping.  Since kernel mappings are in every page table, it&#39;s easiest to</span>
<span class="p_del">- * throw them all away.  This traps the Guest in amber for a while as</span>
<span class="p_del">- * everything faults back in, but it&#39;s rare.</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_pagetable_clear_all(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	release_all_pagetables(cpu-&gt;lg);</span>
<span class="p_del">-	/* We need the Guest kernel stack mapped again. */</span>
<span class="p_del">-	pin_stack_pages(cpu);</span>
<span class="p_del">-	/* And we need Switcher allocated. */</span>
<span class="p_del">-	if (!allocate_switcher_mapping(cpu))</span>
<span class="p_del">-		kill_guest(cpu, &quot;Cannot populate switcher mapping&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:430</span>
<span class="p_del">- * (iv) Switching page tables</span>
<span class="p_del">- *</span>
<span class="p_del">- * Now we&#39;ve seen all the page table setting and manipulation, let&#39;s see</span>
<span class="p_del">- * what happens when the Guest changes page tables (ie. changes the top-level</span>
<span class="p_del">- * pgdir).  This occurs on almost every context switch.</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_new_pagetable(struct lg_cpu *cpu, unsigned long pgtable)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int newpgdir, repin = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The very first time they call this, we&#39;re actually running without</span>
<span class="p_del">-	 * any page tables; we&#39;ve been making it up.  Throw them away now.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (unlikely(cpu-&gt;linear_pages)) {</span>
<span class="p_del">-		release_all_pagetables(cpu-&gt;lg);</span>
<span class="p_del">-		cpu-&gt;linear_pages = false;</span>
<span class="p_del">-		/* Force allocation of a new pgdir. */</span>
<span class="p_del">-		newpgdir = ARRAY_SIZE(cpu-&gt;lg-&gt;pgdirs);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* Look to see if we have this one already. */</span>
<span class="p_del">-		newpgdir = find_pgdir(cpu-&gt;lg, pgtable);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If not, we allocate or mug an existing one: if it&#39;s a fresh one,</span>
<span class="p_del">-	 * repin gets set to 1.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (newpgdir == ARRAY_SIZE(cpu-&gt;lg-&gt;pgdirs))</span>
<span class="p_del">-		newpgdir = new_pgdir(cpu, pgtable, &amp;repin);</span>
<span class="p_del">-	/* Change the current pgd index to the new one. */</span>
<span class="p_del">-	cpu-&gt;cpu_pgd = newpgdir;</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If it was completely blank, we map in the Guest kernel stack and</span>
<span class="p_del">-	 * the Switcher.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (repin)</span>
<span class="p_del">-		pin_stack_pages(cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!cpu-&gt;lg-&gt;pgdirs[cpu-&gt;cpu_pgd].switcher_mapped) {</span>
<span class="p_del">-		if (!allocate_switcher_mapping(cpu))</span>
<span class="p_del">-			kill_guest(cpu, &quot;Cannot populate switcher mapping&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:009</span>
<span class="p_del">- * Since we throw away all mappings when a kernel mapping changes, our</span>
<span class="p_del">- * performance sucks for guests using highmem.  In fact, a guest with</span>
<span class="p_del">- * PAGE_OFFSET 0xc0000000 (the default) and more than about 700MB of RAM is</span>
<span class="p_del">- * usually slower than a Guest with less memory.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This, of course, cannot be fixed.  It would take some kind of... well, I</span>
<span class="p_del">- * don&#39;t know, but the term &quot;puissant code-fu&quot; comes to mind.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:420</span>
<span class="p_del">- * This is the routine which actually sets the page table entry for then</span>
<span class="p_del">- * &quot;idx&quot;&#39;th shadow page table.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Normally, we can just throw out the old entry and replace it with 0: if they</span>
<span class="p_del">- * use it demand_page() will put the new entry in.  We need to do this anyway:</span>
<span class="p_del">- * The Guest expects _PAGE_ACCESSED to be set on its PTE the first time a page</span>
<span class="p_del">- * is read from, and _PAGE_DIRTY when it&#39;s written to.</span>
<span class="p_del">- *</span>
<span class="p_del">- * But Avi Kivity pointed out that most Operating Systems (Linux included) set</span>
<span class="p_del">- * these bits on PTEs immediately anyway.  This is done to save the CPU from</span>
<span class="p_del">- * having to update them, but it helps us the same way: if they set</span>
<span class="p_del">- * _PAGE_ACCESSED then we can put a read-only PTE entry in immediately, and if</span>
<span class="p_del">- * they set _PAGE_DIRTY then we can put a writable PTE entry in immediately.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __guest_set_pte(struct lg_cpu *cpu, int idx,</span>
<span class="p_del">-		       unsigned long vaddr, pte_t gpte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Look up the matching shadow page directory entry. */</span>
<span class="p_del">-	pgd_t *spgd = spgd_addr(cpu, idx, vaddr);</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-	pmd_t *spmd;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If the top level isn&#39;t present, there&#39;s no entry to update. */</span>
<span class="p_del">-	if (pgd_flags(*spgd) &amp; _PAGE_PRESENT) {</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-		spmd = spmd_addr(cpu, *spgd, vaddr);</span>
<span class="p_del">-		if (pmd_flags(*spmd) &amp; _PAGE_PRESENT) {</span>
<span class="p_del">-#endif</span>
<span class="p_del">-			/* Otherwise, start by releasing the existing entry. */</span>
<span class="p_del">-			pte_t *spte = spte_addr(cpu, *spgd, vaddr);</span>
<span class="p_del">-			release_pte(*spte);</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * If they&#39;re setting this entry as dirty or accessed,</span>
<span class="p_del">-			 * we might as well put that entry they&#39;ve given us in</span>
<span class="p_del">-			 * now.  This shaves 10% off a copy-on-write</span>
<span class="p_del">-			 * micro-benchmark.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if ((pte_flags(gpte) &amp; (_PAGE_DIRTY | _PAGE_ACCESSED))</span>
<span class="p_del">-			    &amp;&amp; !gpte_in_iomem(cpu, gpte)) {</span>
<span class="p_del">-				if (!check_gpte(cpu, gpte))</span>
<span class="p_del">-					return;</span>
<span class="p_del">-				set_pte(spte,</span>
<span class="p_del">-					gpte_to_spte(cpu, gpte,</span>
<span class="p_del">-						pte_flags(gpte) &amp; _PAGE_DIRTY));</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * Otherwise kill it and we can demand_page()</span>
<span class="p_del">-				 * it in later.</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				set_pte(spte, __pte(0));</span>
<span class="p_del">-			}</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-		}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:410</span>
<span class="p_del">- * Updating a PTE entry is a little trickier.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We keep track of several different page tables (the Guest uses one for each</span>
<span class="p_del">- * process, so it makes sense to cache at least a few).  Each of these have</span>
<span class="p_del">- * identical kernel parts: ie. every mapping above PAGE_OFFSET is the same for</span>
<span class="p_del">- * all processes.  So when the page table above that address changes, we update</span>
<span class="p_del">- * all the page tables, not just the current one.  This is rare.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The benefit is that when we have to track a new page table, we can keep all</span>
<span class="p_del">- * the kernel mappings.  This speeds up context switch immensely.</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_set_pte(struct lg_cpu *cpu,</span>
<span class="p_del">-		   unsigned long gpgdir, unsigned long vaddr, pte_t gpte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* We don&#39;t let you remap the Switcher; we need it to get back! */</span>
<span class="p_del">-	if (vaddr &gt;= switcher_addr) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;attempt to set pte into Switcher pages&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Kernel mappings must be changed on all top levels.  Slow, but doesn&#39;t</span>
<span class="p_del">-	 * happen often.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (vaddr &gt;= cpu-&gt;lg-&gt;kernel_address) {</span>
<span class="p_del">-		unsigned int i;</span>
<span class="p_del">-		for (i = 0; i &lt; ARRAY_SIZE(cpu-&gt;lg-&gt;pgdirs); i++)</span>
<span class="p_del">-			if (cpu-&gt;lg-&gt;pgdirs[i].pgdir)</span>
<span class="p_del">-				__guest_set_pte(cpu, i, vaddr, gpte);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* Is this page table one we have a shadow for? */</span>
<span class="p_del">-		int pgdir = find_pgdir(cpu-&gt;lg, gpgdir);</span>
<span class="p_del">-		if (pgdir != ARRAY_SIZE(cpu-&gt;lg-&gt;pgdirs))</span>
<span class="p_del">-			/* If so, do the update. */</span>
<span class="p_del">-			__guest_set_pte(cpu, pgdir, vaddr, gpte);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:400</span>
<span class="p_del">- * (iii) Setting up a page table entry when the Guest tells us one has changed.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Just like we did in interrupts_and_traps.c, it makes sense for us to deal</span>
<span class="p_del">- * with the other side of page tables while we&#39;re here: what happens when the</span>
<span class="p_del">- * Guest asks for a page table to be updated?</span>
<span class="p_del">- *</span>
<span class="p_del">- * We already saw that demand_page() will fill in the shadow page tables when</span>
<span class="p_del">- * needed, so we can simply remove shadow page table entries whenever the Guest</span>
<span class="p_del">- * tells us they&#39;ve changed.  When the Guest tries to use the new entry it will</span>
<span class="p_del">- * fault and demand_page() will fix it up.</span>
<span class="p_del">- *</span>
<span class="p_del">- * So with that in mind here&#39;s our code to update a (top-level) PGD entry:</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_set_pgd(struct lguest *lg, unsigned long gpgdir, u32 idx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int pgdir;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (idx &gt; PTRS_PER_PGD) {</span>
<span class="p_del">-		kill_guest(&amp;lg-&gt;cpus[0], &quot;Attempt to set pgd %u/%u&quot;,</span>
<span class="p_del">-			   idx, PTRS_PER_PGD);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If they&#39;re talking about a page table we have a shadow for... */</span>
<span class="p_del">-	pgdir = find_pgdir(lg, gpgdir);</span>
<span class="p_del">-	if (pgdir &lt; ARRAY_SIZE(lg-&gt;pgdirs)) {</span>
<span class="p_del">-		/* ... throw it away. */</span>
<span class="p_del">-		release_pgd(lg-&gt;pgdirs[pgdir].pgdir + idx);</span>
<span class="p_del">-		/* That might have been the Switcher mapping, remap it. */</span>
<span class="p_del">-		if (!allocate_switcher_mapping(&amp;lg-&gt;cpus[0])) {</span>
<span class="p_del">-			kill_guest(&amp;lg-&gt;cpus[0],</span>
<span class="p_del">-				   &quot;Cannot populate switcher mapping&quot;);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		lg-&gt;pgdirs[pgdir].last_host_cpu = -1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_PAE</span>
<span class="p_del">-/* For setting a mid-level, we just throw everything away.  It&#39;s easy. */</span>
<span class="p_del">-void guest_set_pmd(struct lguest *lg, unsigned long pmdp, u32 idx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	guest_pagetable_clear_all(&amp;lg-&gt;cpus[0]);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:500</span>
<span class="p_del">- * (vii) Setting up the page tables initially.</span>
<span class="p_del">- *</span>
<span class="p_del">- * When a Guest is first created, set initialize a shadow page table which</span>
<span class="p_del">- * we will populate on future faults.  The Guest doesn&#39;t have any actual</span>
<span class="p_del">- * pagetables yet, so we set linear_pages to tell demand_page() to fake it</span>
<span class="p_del">- * for the moment.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We do need the Switcher to be mapped at all times, so we allocate that</span>
<span class="p_del">- * part of the Guest page table here.</span>
<span class="p_del">- */</span>
<span class="p_del">-int init_guest_pagetable(struct lguest *lg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct lg_cpu *cpu = &amp;lg-&gt;cpus[0];</span>
<span class="p_del">-	int allocated = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* lg (and lg-&gt;cpus[]) starts zeroed: this allocates a new pgdir */</span>
<span class="p_del">-	cpu-&gt;cpu_pgd = new_pgdir(cpu, 0, &amp;allocated);</span>
<span class="p_del">-	if (!allocated)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We start with a linear mapping until the initialize. */</span>
<span class="p_del">-	cpu-&gt;linear_pages = true;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Allocate the page tables for the Switcher. */</span>
<span class="p_del">-	if (!allocate_switcher_mapping(cpu)) {</span>
<span class="p_del">-		release_all_pagetables(lg);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:508 When the Guest calls LHCALL_LGUEST_INIT we do more setup. */</span>
<span class="p_del">-void page_table_guest_data_init(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We tell the Guest that it can&#39;t use the virtual addresses</span>
<span class="p_del">-	 * used by the Switcher.  This trick is equivalent to 4GB -</span>
<span class="p_del">-	 * switcher_addr.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	u32 top = ~switcher_addr + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We get the kernel address: above this is all kernel memory. */</span>
<span class="p_del">-	if (get_user(cpu-&gt;lg-&gt;kernel_address,</span>
<span class="p_del">-		     &amp;cpu-&gt;lg-&gt;lguest_data-&gt;kernel_address)</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We tell the Guest that it can&#39;t use the top virtual</span>
<span class="p_del">-		 * addresses (used by the Switcher).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-	    || put_user(top, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;reserve_mem)) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad guest page %p&quot;, cpu-&gt;lg-&gt;lguest_data);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * In flush_user_mappings() we loop from 0 to</span>
<span class="p_del">-	 * &quot;pgd_index(lg-&gt;kernel_address)&quot;.  This assumes it won&#39;t hit the</span>
<span class="p_del">-	 * Switcher mappings, so check that now.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (cpu-&gt;lg-&gt;kernel_address &gt;= switcher_addr)</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad kernel address %#lx&quot;,</span>
<span class="p_del">-				 cpu-&gt;lg-&gt;kernel_address);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* When a Guest dies, our cleanup is fairly simple. */</span>
<span class="p_del">-void free_guest_pagetable(struct lguest *lg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Throw away all page table pages. */</span>
<span class="p_del">-	release_all_pagetables(lg);</span>
<span class="p_del">-	/* Now free the top levels: free_page() can handle 0 just fine. */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(lg-&gt;pgdirs); i++)</span>
<span class="p_del">-		free_page((long)lg-&gt;pgdirs[i].pgdir);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:481</span>
<span class="p_del">- * This clears the Switcher mappings for cpu #i.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void remove_switcher_percpu_map(struct lg_cpu *cpu, unsigned int i)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long base = switcher_addr + PAGE_SIZE + i * PAGE_SIZE*2;</span>
<span class="p_del">-	pte_t *pte;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the mappings for both pages. */</span>
<span class="p_del">-	pte = find_spte(cpu, base, false, 0, 0);</span>
<span class="p_del">-	release_pte(*pte);</span>
<span class="p_del">-	set_pte(pte, __pte(0));</span>
<span class="p_del">-</span>
<span class="p_del">-	pte = find_spte(cpu, base + PAGE_SIZE, false, 0, 0);</span>
<span class="p_del">-	release_pte(*pte);</span>
<span class="p_del">-	set_pte(pte, __pte(0));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:480</span>
<span class="p_del">- * (vi) Mapping the Switcher when the Guest is about to run.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Switcher and the two pages for this CPU need to be visible in the Guest</span>
<span class="p_del">- * (and not the pages for other CPUs).</span>
<span class="p_del">- *</span>
<span class="p_del">- * The pages for the pagetables have all been allocated before: we just need</span>
<span class="p_del">- * to make sure the actual PTEs are up-to-date for the CPU we&#39;re about to run</span>
<span class="p_del">- * on.</span>
<span class="p_del">- */</span>
<span class="p_del">-void map_switcher_in_guest(struct lg_cpu *cpu, struct lguest_pages *pages)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long base;</span>
<span class="p_del">-	struct page *percpu_switcher_page, *regs_page;</span>
<span class="p_del">-	pte_t *pte;</span>
<span class="p_del">-	struct pgdir *pgdir = &amp;cpu-&gt;lg-&gt;pgdirs[cpu-&gt;cpu_pgd];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Switcher page should always be mapped by now! */</span>
<span class="p_del">-	BUG_ON(!pgdir-&gt;switcher_mapped);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* </span>
<span class="p_del">-	 * Remember that we have two pages for each Host CPU, so we can run a</span>
<span class="p_del">-	 * Guest on each CPU without them interfering.  We need to make sure</span>
<span class="p_del">-	 * those pages are mapped correctly in the Guest, but since we usually</span>
<span class="p_del">-	 * run on the same CPU, we cache that, and only update the mappings</span>
<span class="p_del">-	 * when we move.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (pgdir-&gt;last_host_cpu == raw_smp_processor_id())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* -1 means unknown so we remove everything. */</span>
<span class="p_del">-	if (pgdir-&gt;last_host_cpu == -1) {</span>
<span class="p_del">-		unsigned int i;</span>
<span class="p_del">-		for_each_possible_cpu(i)</span>
<span class="p_del">-			remove_switcher_percpu_map(cpu, i);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* We know exactly what CPU mapping to remove. */</span>
<span class="p_del">-		remove_switcher_percpu_map(cpu, pgdir-&gt;last_host_cpu);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * When we&#39;re running the Guest, we want the Guest&#39;s &quot;regs&quot; page to</span>
<span class="p_del">-	 * appear where the first Switcher page for this CPU is.  This is an</span>
<span class="p_del">-	 * optimization: when the Switcher saves the Guest registers, it saves</span>
<span class="p_del">-	 * them into the first page of this CPU&#39;s &quot;struct lguest_pages&quot;: if we</span>
<span class="p_del">-	 * make sure the Guest&#39;s register page is already mapped there, we</span>
<span class="p_del">-	 * don&#39;t have to copy them out again.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	/* Find the shadow PTE for this regs page. */</span>
<span class="p_del">-	base = switcher_addr + PAGE_SIZE</span>
<span class="p_del">-		+ raw_smp_processor_id() * sizeof(struct lguest_pages);</span>
<span class="p_del">-	pte = find_spte(cpu, base, false, 0, 0);</span>
<span class="p_del">-	regs_page = pfn_to_page(__pa(cpu-&gt;regs_page) &gt;&gt; PAGE_SHIFT);</span>
<span class="p_del">-	get_page(regs_page);</span>
<span class="p_del">-	set_pte(pte, mk_pte(regs_page, __pgprot(__PAGE_KERNEL &amp; ~_PAGE_GLOBAL)));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We map the second page of the struct lguest_pages read-only in</span>
<span class="p_del">-	 * the Guest: the IDT, GDT and other things it&#39;s not supposed to</span>
<span class="p_del">-	 * change.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pte = find_spte(cpu, base + PAGE_SIZE, false, 0, 0);</span>
<span class="p_del">-	percpu_switcher_page</span>
<span class="p_del">-		= lg_switcher_pages[1 + raw_smp_processor_id()*2 + 1];</span>
<span class="p_del">-	get_page(percpu_switcher_page);</span>
<span class="p_del">-	set_pte(pte, mk_pte(percpu_switcher_page,</span>
<span class="p_del">-			    __pgprot(__PAGE_KERNEL_RO &amp; ~_PAGE_GLOBAL)));</span>
<span class="p_del">-</span>
<span class="p_del">-	pgdir-&gt;last_host_cpu = raw_smp_processor_id();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:490</span>
<span class="p_del">- * We&#39;ve made it through the page table code.  Perhaps our tired brains are</span>
<span class="p_del">- * still processing the details, or perhaps we&#39;re simply glad it&#39;s over.</span>
<span class="p_del">- *</span>
<span class="p_del">- * If nothing else, note that all this complexity in juggling shadow page tables</span>
<span class="p_del">- * in sync with the Guest&#39;s page tables is for one reason: for most Guests this</span>
<span class="p_del">- * page table dance determines how bad performance will be.  This is why Xen</span>
<span class="p_del">- * uses exotic direct Guest pagetable manipulation, and why both Intel and AMD</span>
<span class="p_del">- * have implemented shadow page table support directly into hardware.</span>
<span class="p_del">- *</span>
<span class="p_del">- * There is just one file remaining in the Host.</span>
<span class="p_del">- */</span>
<span class="p_header">diff --git a/drivers/lguest/segments.c b/drivers/lguest/segments.c</span>
deleted file mode 100644
<span class="p_header">index c4fb424dfddb..000000000000</span>
<span class="p_header">--- a/drivers/lguest/segments.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,228 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:600</span>
<span class="p_del">- * The x86 architecture has segments, which involve a table of descriptors</span>
<span class="p_del">- * which can be used to do funky things with virtual address interpretation.</span>
<span class="p_del">- * We originally used to use segments so the Guest couldn&#39;t alter the</span>
<span class="p_del">- * Guest&lt;-&gt;Host Switcher, and then we had to trim Guest segments, and restore</span>
<span class="p_del">- * for userspace per-thread segments, but trim again for on userspace-&gt;kernel</span>
<span class="p_del">- * transitions...  This nightmarish creation was contained within this file,</span>
<span class="p_del">- * where we knew not to tread without heavy armament and a change of underwear.</span>
<span class="p_del">- *</span>
<span class="p_del">- * In these modern times, the segment handling code consists of simple sanity</span>
<span class="p_del">- * checks, and the worst you&#39;ll experience reading this code is butterfly-rash</span>
<span class="p_del">- * from frolicking through its parklike serenity.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-#include &quot;lg.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:600</span>
<span class="p_del">- * Segments &amp; The Global Descriptor Table</span>
<span class="p_del">- *</span>
<span class="p_del">- * (That title sounds like a bad Nerdcore group.  Not to suggest that there are</span>
<span class="p_del">- * any good Nerdcore groups, but in high school a friend of mine had a band</span>
<span class="p_del">- * called Joe Fish and the Chips, so there are definitely worse band names).</span>
<span class="p_del">- *</span>
<span class="p_del">- * To refresh: the GDT is a table of 8-byte values describing segments.  Once</span>
<span class="p_del">- * set up, these segments can be loaded into one of the 6 &quot;segment registers&quot;.</span>
<span class="p_del">- *</span>
<span class="p_del">- * GDT entries are passed around as &quot;struct desc_struct&quot;s, which like IDT</span>
<span class="p_del">- * entries are split into two 32-bit members, &quot;a&quot; and &quot;b&quot;.  One day, someone</span>
<span class="p_del">- * will clean that up, and be declared a Hero.  (No pressure, I&#39;m just saying).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Anyway, the GDT entry contains a base (the start address of the segment), a</span>
<span class="p_del">- * limit (the size of the segment - 1), and some flags.  Sounds simple, and it</span>
<span class="p_del">- * would be, except those zany Intel engineers decided that it was too boring</span>
<span class="p_del">- * to put the base at one end, the limit at the other, and the flags in</span>
<span class="p_del">- * between.  They decided to shotgun the bits at random throughout the 8 bytes,</span>
<span class="p_del">- * like so:</span>
<span class="p_del">- *</span>
<span class="p_del">- * 0               16                     40       48  52  56     63</span>
<span class="p_del">- * [ limit part 1 ][     base part 1     ][ flags ][li][fl][base ]</span>
<span class="p_del">- *                                                  mit ags part 2</span>
<span class="p_del">- *                                                part 2</span>
<span class="p_del">- *</span>
<span class="p_del">- * As a result, this file contains a certain amount of magic numeracy.  Let&#39;s</span>
<span class="p_del">- * begin.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * There are several entries we don&#39;t let the Guest set.  The TSS entry is the</span>
<span class="p_del">- * &quot;Task State Segment&quot; which controls all kinds of delicate things.  The</span>
<span class="p_del">- * LGUEST_CS and LGUEST_DS entries are reserved for the Switcher, and the</span>
<span class="p_del">- * the Guest can&#39;t be trusted to deal with double faults.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool ignored_gdt(unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (num == GDT_ENTRY_TSS</span>
<span class="p_del">-		|| num == GDT_ENTRY_LGUEST_CS</span>
<span class="p_del">-		|| num == GDT_ENTRY_LGUEST_DS</span>
<span class="p_del">-		|| num == GDT_ENTRY_DOUBLEFAULT_TSS);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:630</span>
<span class="p_del">- * Once the Guest gave us new GDT entries, we fix them up a little.  We</span>
<span class="p_del">- * don&#39;t care if they&#39;re invalid: the worst that can happen is a General</span>
<span class="p_del">- * Protection Fault in the Switcher when it restores a Guest segment register</span>
<span class="p_del">- * which tries to use that entry.  Then we kill the Guest for causing such a</span>
<span class="p_del">- * mess: the message will be &quot;unhandled trap 256&quot;.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void fixup_gdt_table(struct lg_cpu *cpu, unsigned start, unsigned end)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = start; i &lt; end; i++) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We never copy these ones to real GDT, so we don&#39;t care what</span>
<span class="p_del">-		 * they say</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ignored_gdt(i))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Segment descriptors contain a privilege level: the Guest is</span>
<span class="p_del">-		 * sometimes careless and leaves this as 0, even though it&#39;s</span>
<span class="p_del">-		 * running at privilege level 1.  If so, we fix it here.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (cpu-&gt;arch.gdt[i].dpl == 0)</span>
<span class="p_del">-			cpu-&gt;arch.gdt[i].dpl |= GUEST_PL;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Each descriptor has an &quot;accessed&quot; bit.  If we don&#39;t set it</span>
<span class="p_del">-		 * now, the CPU will try to set it when the Guest first loads</span>
<span class="p_del">-		 * that entry into a segment register.  But the GDT isn&#39;t</span>
<span class="p_del">-		 * writable by the Guest, so bad things can happen.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		cpu-&gt;arch.gdt[i].type |= 0x1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:610</span>
<span class="p_del">- * Like the IDT, we never simply use the GDT the Guest gives us.  We keep</span>
<span class="p_del">- * a GDT for each CPU, and copy across the Guest&#39;s entries each time we want to</span>
<span class="p_del">- * run the Guest on that CPU.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This routine is called at boot or modprobe time for each CPU to set up the</span>
<span class="p_del">- * constant GDT entries: the ones which are the same no matter what Guest we&#39;re</span>
<span class="p_del">- * running.</span>
<span class="p_del">- */</span>
<span class="p_del">-void setup_default_gdt_entries(struct lguest_ro_state *state)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct desc_struct *gdt = state-&gt;guest_gdt;</span>
<span class="p_del">-	unsigned long tss = (unsigned long)&amp;state-&gt;guest_tss;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The Switcher segments are full 0-4G segments, privilege level 0 */</span>
<span class="p_del">-	gdt[GDT_ENTRY_LGUEST_CS] = FULL_EXEC_SEGMENT;</span>
<span class="p_del">-	gdt[GDT_ENTRY_LGUEST_DS] = FULL_SEGMENT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The TSS segment refers to the TSS entry for this particular CPU.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].a = 0;</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].b = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].limit0 = 0x67;</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].base0  = tss &amp; 0xFFFF;</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].base1  = (tss &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].base2  = tss &gt;&gt; 24;</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].type   = 0x9; /* 32-bit TSS (available) */</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].p      = 0x1; /* Entry is present */</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].dpl    = 0x0; /* Privilege level 0 */</span>
<span class="p_del">-	gdt[GDT_ENTRY_TSS].s      = 0x0; /* system segment */</span>
<span class="p_del">-</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine sets up the initial Guest GDT for booting.  All entries start</span>
<span class="p_del">- * as 0 (unusable).</span>
<span class="p_del">- */</span>
<span class="p_del">-void setup_guest_gdt(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Start with full 0-4G segments...except the Guest is allowed to use</span>
<span class="p_del">-	 * them, so set the privilege level appropriately in the flags.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;arch.gdt[GDT_ENTRY_KERNEL_CS] = FULL_EXEC_SEGMENT;</span>
<span class="p_del">-	cpu-&gt;arch.gdt[GDT_ENTRY_KERNEL_DS] = FULL_SEGMENT;</span>
<span class="p_del">-	cpu-&gt;arch.gdt[GDT_ENTRY_KERNEL_CS].dpl |= GUEST_PL;</span>
<span class="p_del">-	cpu-&gt;arch.gdt[GDT_ENTRY_KERNEL_DS].dpl |= GUEST_PL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:650</span>
<span class="p_del">- * An optimization of copy_gdt(), for just the three &quot;thead-local storage&quot;</span>
<span class="p_del">- * entries.</span>
<span class="p_del">- */</span>
<span class="p_del">-void copy_gdt_tls(const struct lg_cpu *cpu, struct desc_struct *gdt)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = GDT_ENTRY_TLS_MIN; i &lt;= GDT_ENTRY_TLS_MAX; i++)</span>
<span class="p_del">-		gdt[i] = cpu-&gt;arch.gdt[i];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:640</span>
<span class="p_del">- * When the Guest is run on a different CPU, or the GDT entries have changed,</span>
<span class="p_del">- * copy_gdt() is called to copy the Guest&#39;s GDT entries across to this CPU&#39;s</span>
<span class="p_del">- * GDT.</span>
<span class="p_del">- */</span>
<span class="p_del">-void copy_gdt(const struct lg_cpu *cpu, struct desc_struct *gdt)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The default entries from setup_default_gdt_entries() are not</span>
<span class="p_del">-	 * replaced.  See ignored_gdt() above.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; GDT_ENTRIES; i++)</span>
<span class="p_del">-		if (!ignored_gdt(i))</span>
<span class="p_del">-			gdt[i] = cpu-&gt;arch.gdt[i];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:620</span>
<span class="p_del">- * This is where the Guest asks us to load a new GDT entry</span>
<span class="p_del">- * (LHCALL_LOAD_GDT_ENTRY).  We tweak the entry and copy it in.</span>
<span class="p_del">- */</span>
<span class="p_del">-void load_guest_gdt_entry(struct lg_cpu *cpu, u32 num, u32 lo, u32 hi)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We assume the Guest has the same number of GDT entries as the</span>
<span class="p_del">-	 * Host, otherwise we&#39;d have to dynamically allocate the Guest GDT.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (num &gt;= ARRAY_SIZE(cpu-&gt;arch.gdt)) {</span>
<span class="p_del">-		kill_guest(cpu, &quot;too many gdt entries %i&quot;, num);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set it up, then fix it. */</span>
<span class="p_del">-	cpu-&gt;arch.gdt[num].a = lo;</span>
<span class="p_del">-	cpu-&gt;arch.gdt[num].b = hi;</span>
<span class="p_del">-	fixup_gdt_table(cpu, num, num+1);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Mark that the GDT changed so the core knows it has to copy it again,</span>
<span class="p_del">-	 * even if the Guest is run on the same CPU.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;changed |= CHANGED_GDT;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is the fast-track version for just changing the three TLS entries.</span>
<span class="p_del">- * Remember that this happens on every context switch, so it&#39;s worth</span>
<span class="p_del">- * optimizing.  But wouldn&#39;t it be neater to have a single hypercall to cover</span>
<span class="p_del">- * both cases?</span>
<span class="p_del">- */</span>
<span class="p_del">-void guest_load_tls(struct lg_cpu *cpu, unsigned long gtls)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct desc_struct *tls = &amp;cpu-&gt;arch.gdt[GDT_ENTRY_TLS_MIN];</span>
<span class="p_del">-</span>
<span class="p_del">-	__lgread(cpu, tls, gtls, sizeof(*tls)*GDT_ENTRY_TLS_ENTRIES);</span>
<span class="p_del">-	fixup_gdt_table(cpu, GDT_ENTRY_TLS_MIN, GDT_ENTRY_TLS_MAX+1);</span>
<span class="p_del">-	/* Note that just the TLS entries have changed. */</span>
<span class="p_del">-	cpu-&gt;changed |= CHANGED_GDT_TLS;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:660</span>
<span class="p_del">- * With this, we have finished the Host.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Five of the seven parts of our task are complete.  You have made it through</span>
<span class="p_del">- * the Bit of Despair (I think that&#39;s somewhere in the page table code,</span>
<span class="p_del">- * myself).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Next, we examine &quot;make Switcher&quot;.  It&#39;s short, but intense.</span>
<span class="p_del">- */</span>
<span class="p_header">diff --git a/drivers/lguest/x86/core.c b/drivers/lguest/x86/core.c</span>
deleted file mode 100644
<span class="p_header">index b4f79b923aea..000000000000</span>
<span class="p_header">--- a/drivers/lguest/x86/core.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,724 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2006, Rusty Russell &lt;rusty@rustcorp.com.au&gt; IBM Corporation.</span>
<span class="p_del">- * Copyright (C) 2007, Jes Sorensen &lt;jes@sgi.com&gt; SGI.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License as published by</span>
<span class="p_del">- * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_del">- * (at your option) any later version.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful, but</span>
<span class="p_del">- * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_del">- * NON INFRINGEMENT.  See the GNU General Public License for more</span>
<span class="p_del">- * details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="p_del">- */</span>
<span class="p_del">-/*P:450</span>
<span class="p_del">- * This file contains the x86-specific lguest code.  It used to be all</span>
<span class="p_del">- * mixed in with drivers/lguest/core.c but several foolhardy code slashers</span>
<span class="p_del">- * wrestled most of the dependencies out to here in preparation for porting</span>
<span class="p_del">- * lguest to other architectures (see what I mean by foolhardy?).</span>
<span class="p_del">- *</span>
<span class="p_del">- * This also contains a couple of non-obvious setup and teardown pieces which</span>
<span class="p_del">- * were implemented after days of debugging pain.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-#include &lt;linux/kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/start_kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/string.h&gt;</span>
<span class="p_del">-#include &lt;linux/console.h&gt;</span>
<span class="p_del">-#include &lt;linux/screen_info.h&gt;</span>
<span class="p_del">-#include &lt;linux/irq.h&gt;</span>
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/clocksource.h&gt;</span>
<span class="p_del">-#include &lt;linux/clockchips.h&gt;</span>
<span class="p_del">-#include &lt;linux/cpu.h&gt;</span>
<span class="p_del">-#include &lt;linux/lguest.h&gt;</span>
<span class="p_del">-#include &lt;linux/lguest_launcher.h&gt;</span>
<span class="p_del">-#include &lt;asm/paravirt.h&gt;</span>
<span class="p_del">-#include &lt;asm/param.h&gt;</span>
<span class="p_del">-#include &lt;asm/page.h&gt;</span>
<span class="p_del">-#include &lt;asm/pgtable.h&gt;</span>
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
<span class="p_del">-#include &lt;asm/setup.h&gt;</span>
<span class="p_del">-#include &lt;asm/lguest.h&gt;</span>
<span class="p_del">-#include &lt;linux/uaccess.h&gt;</span>
<span class="p_del">-#include &lt;asm/fpu/internal.h&gt;</span>
<span class="p_del">-#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_del">-#include &quot;../lg.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-static int cpu_had_pge;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct {</span>
<span class="p_del">-	unsigned long offset;</span>
<span class="p_del">-	unsigned short segment;</span>
<span class="p_del">-} lguest_entry;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Offset from where switcher.S was compiled to where we&#39;ve copied it */</span>
<span class="p_del">-static unsigned long switcher_offset(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return switcher_addr - (unsigned long)start_switcher_text;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This cpu&#39;s struct lguest_pages (after the Switcher text page) */</span>
<span class="p_del">-static struct lguest_pages *lguest_pages(unsigned int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return &amp;(((struct lguest_pages *)(switcher_addr + PAGE_SIZE))[cpu]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static DEFINE_PER_CPU(struct lg_cpu *, lg_last_cpu);</span>
<span class="p_del">-</span>
<span class="p_del">-/*S:010</span>
<span class="p_del">- * We approach the Switcher.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Remember that each CPU has two pages which are visible to the Guest when it</span>
<span class="p_del">- * runs on that CPU.  This has to contain the state for that Guest: we copy the</span>
<span class="p_del">- * state in just before we run the Guest.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Each Guest has &quot;changed&quot; flags which indicate what has changed in the Guest</span>
<span class="p_del">- * since it last ran.  We saw this set in interrupts_and_traps.c and</span>
<span class="p_del">- * segments.c.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void copy_in_guest_info(struct lg_cpu *cpu, struct lguest_pages *pages)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Copying all this data can be quite expensive.  We usually run the</span>
<span class="p_del">-	 * same Guest we ran last time (and that Guest hasn&#39;t run anywhere else</span>
<span class="p_del">-	 * meanwhile).  If that&#39;s not the case, we pretend everything in the</span>
<span class="p_del">-	 * Guest has changed.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (__this_cpu_read(lg_last_cpu) != cpu || cpu-&gt;last_pages != pages) {</span>
<span class="p_del">-		__this_cpu_write(lg_last_cpu, cpu);</span>
<span class="p_del">-		cpu-&gt;last_pages = pages;</span>
<span class="p_del">-		cpu-&gt;changed = CHANGED_ALL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * These copies are pretty cheap, so we do them unconditionally: */</span>
<span class="p_del">-	/* Save the current Host top-level page directory.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pages-&gt;state.host_cr3 = __pa(current-&gt;mm-&gt;pgd);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set up the Guest&#39;s page tables to see this CPU&#39;s pages (and no</span>
<span class="p_del">-	 * other CPU&#39;s pages).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	map_switcher_in_guest(cpu, pages);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set up the two &quot;TSS&quot; members which tell the CPU what stack to use</span>
<span class="p_del">-	 * for traps which do directly into the Guest (ie. traps at privilege</span>
<span class="p_del">-	 * level 1).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pages-&gt;state.guest_tss.sp1 = cpu-&gt;esp1;</span>
<span class="p_del">-	pages-&gt;state.guest_tss.ss1 = cpu-&gt;ss1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Copy direct-to-Guest trap entries. */</span>
<span class="p_del">-	if (cpu-&gt;changed &amp; CHANGED_IDT)</span>
<span class="p_del">-		copy_traps(cpu, pages-&gt;state.guest_idt, default_idt_entries);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Copy all GDT entries which the Guest can change. */</span>
<span class="p_del">-	if (cpu-&gt;changed &amp; CHANGED_GDT)</span>
<span class="p_del">-		copy_gdt(cpu, pages-&gt;state.guest_gdt);</span>
<span class="p_del">-	/* If only the TLS entries have changed, copy them. */</span>
<span class="p_del">-	else if (cpu-&gt;changed &amp; CHANGED_GDT_TLS)</span>
<span class="p_del">-		copy_gdt_tls(cpu, pages-&gt;state.guest_gdt);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Mark the Guest as unchanged for next time. */</span>
<span class="p_del">-	cpu-&gt;changed = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Finally: the code to actually call into the Switcher to run the Guest. */</span>
<span class="p_del">-static void run_guest_once(struct lg_cpu *cpu, struct lguest_pages *pages)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* This is a dummy value we need for GCC&#39;s sake. */</span>
<span class="p_del">-	unsigned int clobber;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Copy the guest-specific information into this CPU&#39;s &quot;struct</span>
<span class="p_del">-	 * lguest_pages&quot;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	copy_in_guest_info(cpu, pages);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set the trap number to 256 (impossible value).  If we fault while</span>
<span class="p_del">-	 * switching to the Guest (bad segment registers or bug), this will</span>
<span class="p_del">-	 * cause us to abort the Guest.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;regs-&gt;trapnum = 256;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now: we push the &quot;eflags&quot; register on the stack, then do an &quot;lcall&quot;.</span>
<span class="p_del">-	 * This is how we change from using the kernel code segment to using</span>
<span class="p_del">-	 * the dedicated lguest code segment, as well as jumping into the</span>
<span class="p_del">-	 * Switcher.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The lcall also pushes the old code segment (KERNEL_CS) onto the</span>
<span class="p_del">-	 * stack, then the address of this call.  This stack layout happens to</span>
<span class="p_del">-	 * exactly match the stack layout created by an interrupt...</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	asm volatile(&quot;pushf; lcall *%4&quot;</span>
<span class="p_del">-		     /*</span>
<span class="p_del">-		      * This is how we tell GCC that %eax (&quot;a&quot;) and %ebx (&quot;b&quot;)</span>
<span class="p_del">-		      * are changed by this routine.  The &quot;=&quot; means output.</span>
<span class="p_del">-		      */</span>
<span class="p_del">-		     : &quot;=a&quot;(clobber), &quot;=b&quot;(clobber)</span>
<span class="p_del">-		     /*</span>
<span class="p_del">-		      * %eax contains the pages pointer.  (&quot;0&quot; refers to the</span>
<span class="p_del">-		      * 0-th argument above, ie &quot;a&quot;).  %ebx contains the</span>
<span class="p_del">-		      * physical address of the Guest&#39;s top-level page</span>
<span class="p_del">-		      * directory.</span>
<span class="p_del">-		      */</span>
<span class="p_del">-		     : &quot;0&quot;(pages), </span>
<span class="p_del">-		       &quot;1&quot;(__pa(cpu-&gt;lg-&gt;pgdirs[cpu-&gt;cpu_pgd].pgdir)),</span>
<span class="p_del">-		       &quot;m&quot;(lguest_entry)</span>
<span class="p_del">-		     /*</span>
<span class="p_del">-		      * We tell gcc that all these registers could change,</span>
<span class="p_del">-		      * which means we don&#39;t have to save and restore them in</span>
<span class="p_del">-		      * the Switcher.</span>
<span class="p_del">-		      */</span>
<span class="p_del">-		     : &quot;memory&quot;, &quot;%edx&quot;, &quot;%ecx&quot;, &quot;%edi&quot;, &quot;%esi&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-unsigned long *lguest_arch_regptr(struct lg_cpu *cpu, size_t reg_off, bool any)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (reg_off) {</span>
<span class="p_del">-	case offsetof(struct pt_regs, bx):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;ebx;</span>
<span class="p_del">-	case offsetof(struct pt_regs, cx):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;ecx;</span>
<span class="p_del">-	case offsetof(struct pt_regs, dx):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;edx;</span>
<span class="p_del">-	case offsetof(struct pt_regs, si):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;esi;</span>
<span class="p_del">-	case offsetof(struct pt_regs, di):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;edi;</span>
<span class="p_del">-	case offsetof(struct pt_regs, bp):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;ebp;</span>
<span class="p_del">-	case offsetof(struct pt_regs, ax):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;eax;</span>
<span class="p_del">-	case offsetof(struct pt_regs, ip):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;eip;</span>
<span class="p_del">-	case offsetof(struct pt_regs, sp):</span>
<span class="p_del">-		return &amp;cpu-&gt;regs-&gt;esp;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Launcher can read these, but we don&#39;t allow any setting. */</span>
<span class="p_del">-	if (any) {</span>
<span class="p_del">-		switch (reg_off) {</span>
<span class="p_del">-		case offsetof(struct pt_regs, ds):</span>
<span class="p_del">-			return &amp;cpu-&gt;regs-&gt;ds;</span>
<span class="p_del">-		case offsetof(struct pt_regs, es):</span>
<span class="p_del">-			return &amp;cpu-&gt;regs-&gt;es;</span>
<span class="p_del">-		case offsetof(struct pt_regs, fs):</span>
<span class="p_del">-			return &amp;cpu-&gt;regs-&gt;fs;</span>
<span class="p_del">-		case offsetof(struct pt_regs, gs):</span>
<span class="p_del">-			return &amp;cpu-&gt;regs-&gt;gs;</span>
<span class="p_del">-		case offsetof(struct pt_regs, cs):</span>
<span class="p_del">-			return &amp;cpu-&gt;regs-&gt;cs;</span>
<span class="p_del">-		case offsetof(struct pt_regs, flags):</span>
<span class="p_del">-			return &amp;cpu-&gt;regs-&gt;eflags;</span>
<span class="p_del">-		case offsetof(struct pt_regs, ss):</span>
<span class="p_del">-			return &amp;cpu-&gt;regs-&gt;ss;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:002</span>
<span class="p_del">- * There are hooks in the scheduler which we can register to tell when we</span>
<span class="p_del">- * get kicked off the CPU (preempt_notifier_register()).  This would allow us</span>
<span class="p_del">- * to lazily disable SYSENTER which would regain some performance, and should</span>
<span class="p_del">- * also simplify copy_in_guest_info().  Note that we&#39;d still need to restore</span>
<span class="p_del">- * things when we exit to Launcher userspace, but that&#39;s fairly easy.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We could also try using these hooks for PGE, but that might be too expensive.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The hooks were designed for KVM, but we can also put them to good use.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:040</span>
<span class="p_del">- * This is the i386-specific code to setup and run the Guest.  Interrupts</span>
<span class="p_del">- * are disabled: we own the CPU.</span>
<span class="p_del">- */</span>
<span class="p_del">-void lguest_arch_run_guest(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * SYSENTER is an optimized way of doing system calls.  We can&#39;t allow</span>
<span class="p_del">-	 * it because it always jumps to privilege level 0.  A normal Guest</span>
<span class="p_del">-	 * won&#39;t try it because we don&#39;t advertise it in CPUID, but a malicious</span>
<span class="p_del">-	 * Guest (or malicious Guest userspace program) could, so we tell the</span>
<span class="p_del">-	 * CPU to disable it before running the Guest.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (boot_cpu_has(X86_FEATURE_SEP))</span>
<span class="p_del">-		wrmsr(MSR_IA32_SYSENTER_CS, 0, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now we actually run the Guest.  It will return when something</span>
<span class="p_del">-	 * interesting happens, and we can examine its registers to see what it</span>
<span class="p_del">-	 * was doing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	run_guest_once(cpu, lguest_pages(raw_smp_processor_id()));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Note that the &quot;regs&quot; structure contains two extra entries which are</span>
<span class="p_del">-	 * not really registers: a trap number which says what interrupt or</span>
<span class="p_del">-	 * trap made the switcher code come back, and an error code which some</span>
<span class="p_del">-	 * traps set.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	 /* Restore SYSENTER if it&#39;s supposed to be on. */</span>
<span class="p_del">-	 if (boot_cpu_has(X86_FEATURE_SEP))</span>
<span class="p_del">-		wrmsr(MSR_IA32_SYSENTER_CS, __KERNEL_CS, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If the Guest page faulted, then the cr2 register will tell us the</span>
<span class="p_del">-	 * bad virtual address.  We have to grab this now, because once we</span>
<span class="p_del">-	 * re-enable interrupts an interrupt could fault and thus overwrite</span>
<span class="p_del">-	 * cr2, or we could even move off to a different CPU.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (cpu-&gt;regs-&gt;trapnum == 14)</span>
<span class="p_del">-		cpu-&gt;arch.last_pagefault = read_cr2();</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Similarly, if we took a trap because the Guest used the FPU,</span>
<span class="p_del">-	 * we have to restore the FPU it expects to see.</span>
<span class="p_del">-	 * fpu__restore() may sleep and we may even move off to</span>
<span class="p_del">-	 * a different CPU. So all the critical stuff should be done</span>
<span class="p_del">-	 * before this.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	else if (cpu-&gt;regs-&gt;trapnum == 7 &amp;&amp; !fpregs_active())</span>
<span class="p_del">-		fpu__restore(&amp;current-&gt;thread.fpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:130</span>
<span class="p_del">- * Now we&#39;ve examined the hypercall code; our Guest can make requests.</span>
<span class="p_del">- * Our Guest is usually so well behaved; it never tries to do things it isn&#39;t</span>
<span class="p_del">- * allowed to, and uses hypercalls instead.  Unfortunately, Linux&#39;s paravirtual</span>
<span class="p_del">- * infrastructure isn&#39;t quite complete, because it doesn&#39;t contain replacements</span>
<span class="p_del">- * for the Intel I/O instructions.  As a result, the Guest sometimes fumbles</span>
<span class="p_del">- * across one during the boot process as it probes for various things which are</span>
<span class="p_del">- * usually attached to a PC.</span>
<span class="p_del">- *</span>
<span class="p_del">- * When the Guest uses one of these instructions, we get a trap (General</span>
<span class="p_del">- * Protection Fault) and come here.  We queue this to be sent out to the</span>
<span class="p_del">- * Launcher to handle.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The eip contains the *virtual* address of the Guest&#39;s instruction:</span>
<span class="p_del">- * we copy the instruction here so the Launcher doesn&#39;t have to walk</span>
<span class="p_del">- * the page tables to decode it.  We handle the case (eg. in a kernel</span>
<span class="p_del">- * module) where the instruction is over two pages, and the pages are</span>
<span class="p_del">- * virtually but not physically contiguous.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The longest possible x86 instruction is 15 bytes, but we don&#39;t handle</span>
<span class="p_del">- * anything that strange.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void copy_from_guest(struct lg_cpu *cpu,</span>
<span class="p_del">-			    void *dst, unsigned long vaddr, size_t len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t to_page_end = PAGE_SIZE - (vaddr % PAGE_SIZE);</span>
<span class="p_del">-	unsigned long paddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(len &gt; PAGE_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If it goes over a page, copy in two parts. */</span>
<span class="p_del">-	if (len &gt; to_page_end) {</span>
<span class="p_del">-		/* But make sure the next page is mapped! */</span>
<span class="p_del">-		if (__guest_pa(cpu, vaddr + to_page_end, &amp;paddr))</span>
<span class="p_del">-			copy_from_guest(cpu, dst + to_page_end,</span>
<span class="p_del">-					vaddr + to_page_end,</span>
<span class="p_del">-					len - to_page_end);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			/* Otherwise fill with zeroes. */</span>
<span class="p_del">-			memset(dst + to_page_end, 0, len - to_page_end);</span>
<span class="p_del">-		len = to_page_end;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* This will kill the guest if it isn&#39;t mapped, but that</span>
<span class="p_del">-	 * shouldn&#39;t happen. */</span>
<span class="p_del">-	__lgread(cpu, dst, guest_pa(cpu, vaddr), len);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-static void setup_emulate_insn(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpu-&gt;pending.trap = 13;</span>
<span class="p_del">-	copy_from_guest(cpu, cpu-&gt;pending.insn, cpu-&gt;regs-&gt;eip,</span>
<span class="p_del">-			sizeof(cpu-&gt;pending.insn));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void setup_iomem_insn(struct lg_cpu *cpu, unsigned long iomem_addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cpu-&gt;pending.trap = 14;</span>
<span class="p_del">-	cpu-&gt;pending.addr = iomem_addr;</span>
<span class="p_del">-	copy_from_guest(cpu, cpu-&gt;pending.insn, cpu-&gt;regs-&gt;eip,</span>
<span class="p_del">-			sizeof(cpu-&gt;pending.insn));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:050 Once we&#39;ve re-enabled interrupts, we look at why the Guest exited. */</span>
<span class="p_del">-void lguest_arch_handle_trap(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long iomem_addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (cpu-&gt;regs-&gt;trapnum) {</span>
<span class="p_del">-	case 13: /* We&#39;ve intercepted a General Protection Fault. */</span>
<span class="p_del">-		/* Hand to Launcher to emulate those pesky IN and OUT insns */</span>
<span class="p_del">-		if (cpu-&gt;regs-&gt;errcode == 0) {</span>
<span class="p_del">-			setup_emulate_insn(cpu);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 14: /* We&#39;ve intercepted a Page Fault. */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The Guest accessed a virtual address that wasn&#39;t mapped.</span>
<span class="p_del">-		 * This happens a lot: we don&#39;t actually set up most of the page</span>
<span class="p_del">-		 * tables for the Guest at all when we start: as it runs it asks</span>
<span class="p_del">-		 * for more and more, and we set them up as required. In this</span>
<span class="p_del">-		 * case, we don&#39;t even tell the Guest that the fault happened.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * The errcode tells whether this was a read or a write, and</span>
<span class="p_del">-		 * whether kernel or userspace code.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (demand_page(cpu, cpu-&gt;arch.last_pagefault,</span>
<span class="p_del">-				cpu-&gt;regs-&gt;errcode, &amp;iomem_addr))</span>
<span class="p_del">-			return;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Was this an access to memory mapped IO? */</span>
<span class="p_del">-		if (iomem_addr) {</span>
<span class="p_del">-			/* Tell Launcher, let it handle it. */</span>
<span class="p_del">-			setup_iomem_insn(cpu, iomem_addr);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * OK, it&#39;s really not there (or not OK): the Guest needs to</span>
<span class="p_del">-		 * know.  We write out the cr2 value so it knows where the</span>
<span class="p_del">-		 * fault occurred.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Note that if the Guest were really messed up, this could</span>
<span class="p_del">-		 * happen before it&#39;s done the LHCALL_LGUEST_INIT hypercall, so</span>
<span class="p_del">-		 * lg-&gt;lguest_data could be NULL</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (cpu-&gt;lg-&gt;lguest_data &amp;&amp;</span>
<span class="p_del">-		    put_user(cpu-&gt;arch.last_pagefault,</span>
<span class="p_del">-			     &amp;cpu-&gt;lg-&gt;lguest_data-&gt;cr2))</span>
<span class="p_del">-			kill_guest(cpu, &quot;Writing cr2&quot;);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 7: /* We&#39;ve intercepted a Device Not Available fault. */</span>
<span class="p_del">-		/* No special handling is needed here. */</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 32 ... 255:</span>
<span class="p_del">-		/* This might be a syscall. */</span>
<span class="p_del">-		if (could_be_syscall(cpu-&gt;regs-&gt;trapnum))</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Other values mean a real interrupt occurred, in which case</span>
<span class="p_del">-		 * the Host handler has already been run. We just do a</span>
<span class="p_del">-		 * friendly check if another process should now be run, then</span>
<span class="p_del">-		 * return to run the Guest again.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		cond_resched();</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	case LGUEST_TRAP_ENTRY:</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Our &#39;struct hcall_args&#39; maps directly over our regs: we set</span>
<span class="p_del">-		 * up the pointer now to indicate a hypercall is pending.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		cpu-&gt;hcall = (struct hcall_args *)cpu-&gt;regs;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We didn&#39;t handle the trap, so it needs to go to the Guest. */</span>
<span class="p_del">-	if (!deliver_trap(cpu, cpu-&gt;regs-&gt;trapnum))</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If the Guest doesn&#39;t have a handler (either it hasn&#39;t</span>
<span class="p_del">-		 * registered any yet, or it&#39;s one of the faults we don&#39;t let</span>
<span class="p_del">-		 * it handle), it dies with this cryptic error message.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		kill_guest(cpu, &quot;unhandled trap %li at %#lx (%#lx)&quot;,</span>
<span class="p_del">-			   cpu-&gt;regs-&gt;trapnum, cpu-&gt;regs-&gt;eip,</span>
<span class="p_del">-			   cpu-&gt;regs-&gt;trapnum == 14 ? cpu-&gt;arch.last_pagefault</span>
<span class="p_del">-			   : cpu-&gt;regs-&gt;errcode);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Now we can look at each of the routines this calls, in increasing order of</span>
<span class="p_del">- * complexity: do_hypercalls(), emulate_insn(), maybe_do_interrupt(),</span>
<span class="p_del">- * deliver_trap() and demand_page().  After all those, we&#39;ll be ready to</span>
<span class="p_del">- * examine the Switcher, and our philosophical understanding of the Host/Guest</span>
<span class="p_del">- * duality will be complete.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-static void adjust_pge(void *on)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (on)</span>
<span class="p_del">-		cr4_set_bits(X86_CR4_PGE);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		cr4_clear_bits(X86_CR4_PGE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:020</span>
<span class="p_del">- * Now the Switcher is mapped and every thing else is ready, we need to do</span>
<span class="p_del">- * some more i386-specific initialization.</span>
<span class="p_del">- */</span>
<span class="p_del">-void __init lguest_arch_host_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Most of the x86/switcher_32.S doesn&#39;t care that it&#39;s been moved; on</span>
<span class="p_del">-	 * Intel, jumps are relative, and it doesn&#39;t access any references to</span>
<span class="p_del">-	 * external code or data.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The only exception is the interrupt handlers in switcher.S: their</span>
<span class="p_del">-	 * addresses are placed in a table (default_idt_entries), so we need to</span>
<span class="p_del">-	 * update the table with the new addresses.  switcher_offset() is a</span>
<span class="p_del">-	 * convenience function which returns the distance between the</span>
<span class="p_del">-	 * compiled-in switcher code and the high-mapped copy we just made.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; IDT_ENTRIES; i++)</span>
<span class="p_del">-		default_idt_entries[i] += switcher_offset();</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Set up the Switcher&#39;s per-cpu areas.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Each CPU gets two pages of its own within the high-mapped region</span>
<span class="p_del">-	 * (aka. &quot;struct lguest_pages&quot;).  Much of this can be initialized now,</span>
<span class="p_del">-	 * but some depends on what Guest we are running (which is set up in</span>
<span class="p_del">-	 * copy_in_guest_info()).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for_each_possible_cpu(i) {</span>
<span class="p_del">-		/* lguest_pages() returns this CPU&#39;s two pages. */</span>
<span class="p_del">-		struct lguest_pages *pages = lguest_pages(i);</span>
<span class="p_del">-		/* This is a convenience pointer to make the code neater. */</span>
<span class="p_del">-		struct lguest_ro_state *state = &amp;pages-&gt;state;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The Global Descriptor Table: the Host has a different one</span>
<span class="p_del">-		 * for each CPU.  We keep a descriptor for the GDT which says</span>
<span class="p_del">-		 * where it is and how big it is (the size is actually the last</span>
<span class="p_del">-		 * byte, not the size, hence the &quot;-1&quot;).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		state-&gt;host_gdt_desc.size = GDT_SIZE-1;</span>
<span class="p_del">-		state-&gt;host_gdt_desc.address = (long)get_cpu_gdt_rw(i);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * All CPUs on the Host use the same Interrupt Descriptor</span>
<span class="p_del">-		 * Table, so we just use store_idt(), which gets this CPU&#39;s IDT</span>
<span class="p_del">-		 * descriptor.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		store_idt(&amp;state-&gt;host_idt_desc);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The descriptors for the Guest&#39;s GDT and IDT can be filled</span>
<span class="p_del">-		 * out now, too.  We copy the GDT &amp; IDT into -&gt;guest_gdt and</span>
<span class="p_del">-		 * -&gt;guest_idt before actually running the Guest.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		state-&gt;guest_idt_desc.size = sizeof(state-&gt;guest_idt)-1;</span>
<span class="p_del">-		state-&gt;guest_idt_desc.address = (long)&amp;state-&gt;guest_idt;</span>
<span class="p_del">-		state-&gt;guest_gdt_desc.size = sizeof(state-&gt;guest_gdt)-1;</span>
<span class="p_del">-		state-&gt;guest_gdt_desc.address = (long)&amp;state-&gt;guest_gdt;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We know where we want the stack to be when the Guest enters</span>
<span class="p_del">-		 * the Switcher: in pages-&gt;regs.  The stack grows upwards, so</span>
<span class="p_del">-		 * we start it at the end of that structure.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		state-&gt;guest_tss.sp0 = (long)(&amp;pages-&gt;regs + 1);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * And this is the GDT entry to use for the stack: we keep a</span>
<span class="p_del">-		 * couple of special LGUEST entries.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		state-&gt;guest_tss.ss0 = LGUEST_DS;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * x86 can have a finegrained bitmap which indicates what I/O</span>
<span class="p_del">-		 * ports the process can use.  We set it to the end of our</span>
<span class="p_del">-		 * structure, meaning &quot;none&quot;.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		state-&gt;guest_tss.io_bitmap_base = sizeof(state-&gt;guest_tss);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Some GDT entries are the same across all Guests, so we can</span>
<span class="p_del">-		 * set them up now.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		setup_default_gdt_entries(state);</span>
<span class="p_del">-		/* Most IDT entries are the same for all Guests, too.*/</span>
<span class="p_del">-		setup_default_idt_entries(state, default_idt_entries);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The Host needs to be able to use the LGUEST segments on this</span>
<span class="p_del">-		 * CPU, too, so put them in the Host GDT.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		get_cpu_gdt_rw(i)[GDT_ENTRY_LGUEST_CS] = FULL_EXEC_SEGMENT;</span>
<span class="p_del">-		get_cpu_gdt_rw(i)[GDT_ENTRY_LGUEST_DS] = FULL_SEGMENT;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * In the Switcher, we want the %cs segment register to use the</span>
<span class="p_del">-	 * LGUEST_CS GDT entry: we&#39;ve put that in the Host and Guest GDTs, so</span>
<span class="p_del">-	 * it will be undisturbed when we switch.  To change %cs and jump we</span>
<span class="p_del">-	 * need this structure to feed to Intel&#39;s &quot;lcall&quot; instruction.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	lguest_entry.offset = (long)switch_to_guest + switcher_offset();</span>
<span class="p_del">-	lguest_entry.segment = LGUEST_CS;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Finally, we need to turn off &quot;Page Global Enable&quot;.  PGE is an</span>
<span class="p_del">-	 * optimization where page table entries are specially marked to show</span>
<span class="p_del">-	 * they never change.  The Host kernel marks all the kernel pages this</span>
<span class="p_del">-	 * way because it&#39;s always present, even when userspace is running.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Lguest breaks this: unbeknownst to the rest of the Host kernel, we</span>
<span class="p_del">-	 * switch to the Guest kernel.  If you don&#39;t disable this on all CPUs,</span>
<span class="p_del">-	 * you&#39;ll get really weird bugs that you&#39;ll chase for two days.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * I used to turn PGE off every time we switched to the Guest and back</span>
<span class="p_del">-	 * on when we return, but that slowed the Switcher down noticibly.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We don&#39;t need the complexity of CPUs coming and going while we&#39;re</span>
<span class="p_del">-	 * doing this.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	get_online_cpus();</span>
<span class="p_del">-	if (boot_cpu_has(X86_FEATURE_PGE)) { /* We have a broader idea of &quot;global&quot;. */</span>
<span class="p_del">-		/* Remember that this was originally set (for cleanup). */</span>
<span class="p_del">-		cpu_had_pge = 1;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * adjust_pge is a helper function which sets or unsets the PGE</span>
<span class="p_del">-		 * bit on its CPU, depending on the argument (0 == unset).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		on_each_cpu(adjust_pge, (void *)0, 1);</span>
<span class="p_del">-		/* Turn off the feature in the global feature set. */</span>
<span class="p_del">-		clear_cpu_cap(&amp;boot_cpu_data, X86_FEATURE_PGE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	put_online_cpus();</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-void __exit lguest_arch_host_fini(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* If we had PGE before we started, turn it back on now. */</span>
<span class="p_del">-	get_online_cpus();</span>
<span class="p_del">-	if (cpu_had_pge) {</span>
<span class="p_del">-		set_cpu_cap(&amp;boot_cpu_data, X86_FEATURE_PGE);</span>
<span class="p_del">-		/* adjust_pge&#39;s argument &quot;1&quot; means set PGE. */</span>
<span class="p_del">-		on_each_cpu(adjust_pge, (void *)1, 1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	put_online_cpus();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:122 The i386-specific hypercalls simply farm out to the right functions. */</span>
<span class="p_del">-int lguest_arch_do_hcall(struct lg_cpu *cpu, struct hcall_args *args)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (args-&gt;arg0) {</span>
<span class="p_del">-	case LHCALL_LOAD_GDT_ENTRY:</span>
<span class="p_del">-		load_guest_gdt_entry(cpu, args-&gt;arg1, args-&gt;arg2, args-&gt;arg3);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_LOAD_IDT_ENTRY:</span>
<span class="p_del">-		load_guest_idt_entry(cpu, args-&gt;arg1, args-&gt;arg2, args-&gt;arg3);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case LHCALL_LOAD_TLS:</span>
<span class="p_del">-		guest_load_tls(cpu, args-&gt;arg1);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* Bad Guest.  Bad! */</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*H:126 i386-specific hypercall initialization: */</span>
<span class="p_del">-int lguest_arch_init_hypercalls(struct lg_cpu *cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 tsc_speed;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The pointer to the Guest&#39;s &quot;struct lguest_data&quot; is the only argument.</span>
<span class="p_del">-	 * We check that address now.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!lguest_address_ok(cpu-&gt;lg, cpu-&gt;hcall-&gt;arg1,</span>
<span class="p_del">-			       sizeof(*cpu-&gt;lg-&gt;lguest_data)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Having checked it, we simply set lg-&gt;lguest_data to point straight</span>
<span class="p_del">-	 * into the Launcher&#39;s memory at the right place and then use</span>
<span class="p_del">-	 * copy_to_user/from_user from now on, instead of lgread/write.  I put</span>
<span class="p_del">-	 * this in to show that I&#39;m not immune to writing stupid</span>
<span class="p_del">-	 * optimizations.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cpu-&gt;lg-&gt;lguest_data = cpu-&gt;lg-&gt;mem_base + cpu-&gt;hcall-&gt;arg1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We insist that the Time Stamp Counter exist and doesn&#39;t change with</span>
<span class="p_del">-	 * cpu frequency.  Some devious chip manufacturers decided that TSC</span>
<span class="p_del">-	 * changes could be handled in software.  I decided that time going</span>
<span class="p_del">-	 * backwards might be good for benchmarks, but it&#39;s bad for users.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We also insist that the TSC be stable: the kernel detects unreliable</span>
<span class="p_del">-	 * TSCs for its own purposes, and we use that here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (boot_cpu_has(X86_FEATURE_CONSTANT_TSC) &amp;&amp; !check_tsc_unstable())</span>
<span class="p_del">-		tsc_speed = tsc_khz;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		tsc_speed = 0;</span>
<span class="p_del">-	if (put_user(tsc_speed, &amp;cpu-&gt;lg-&gt;lguest_data-&gt;tsc_khz))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The interrupt code might not like the system call vector. */</span>
<span class="p_del">-	if (!check_syscall_vector(cpu-&gt;lg))</span>
<span class="p_del">-		kill_guest(cpu, &quot;bad syscall vector&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:030</span>
<span class="p_del">- * Most of the Guest&#39;s registers are left alone: we used get_zeroed_page() to</span>
<span class="p_del">- * allocate the structure, so they will be 0.</span>
<span class="p_del">- */</span>
<span class="p_del">-void lguest_arch_setup_regs(struct lg_cpu *cpu, unsigned long start)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct lguest_regs *regs = cpu-&gt;regs;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * There are four &quot;segment&quot; registers which the Guest needs to boot:</span>
<span class="p_del">-	 * The &quot;code segment&quot; register (cs) refers to the kernel code segment</span>
<span class="p_del">-	 * __KERNEL_CS, and the &quot;data&quot;, &quot;extra&quot; and &quot;stack&quot; segment registers</span>
<span class="p_del">-	 * refer to the kernel data segment __KERNEL_DS.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The privilege level is packed into the lower bits.  The Guest runs</span>
<span class="p_del">-	 * at privilege level 1 (GUEST_PL).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	regs-&gt;ds = regs-&gt;es = regs-&gt;ss = __KERNEL_DS|GUEST_PL;</span>
<span class="p_del">-	regs-&gt;cs = __KERNEL_CS|GUEST_PL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The &quot;eflags&quot; register contains miscellaneous flags.  Bit 1 (0x002)</span>
<span class="p_del">-	 * is supposed to always be &quot;1&quot;.  Bit 9 (0x200) controls whether</span>
<span class="p_del">-	 * interrupts are enabled.  We always leave interrupts enabled while</span>
<span class="p_del">-	 * running the Guest.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	regs-&gt;eflags = X86_EFLAGS_IF | X86_EFLAGS_FIXED;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The &quot;Extended Instruction Pointer&quot; register says where the Guest is</span>
<span class="p_del">-	 * running.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	regs-&gt;eip = start;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * %esi points to our boot information, at physical address 0, so don&#39;t</span>
<span class="p_del">-	 * touch it.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* There are a couple of GDT entries the Guest expects at boot. */</span>
<span class="p_del">-	setup_guest_gdt(cpu);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/drivers/lguest/x86/switcher_32.S b/drivers/lguest/x86/switcher_32.S</span>
deleted file mode 100644
<span class="p_header">index 40634b0db9f7..000000000000</span>
<span class="p_header">--- a/drivers/lguest/x86/switcher_32.S</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,388 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:900</span>
<span class="p_del">- * This is the Switcher: code which sits at 0xFFC00000 (or 0xFFE00000) astride</span>
<span class="p_del">- * both the Host and Guest to do the low-level Guest&lt;-&gt;Host switch.  It is as</span>
<span class="p_del">- * simple as it can be made, but it&#39;s naturally very specific to x86.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You have now completed Preparation.  If this has whet your appetite; if you</span>
<span class="p_del">- * are feeling invigorated and refreshed then the next, more challenging stage</span>
<span class="p_del">- * can be found in &quot;make Guest&quot;.</span>
<span class="p_del">- :*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:012</span>
<span class="p_del">- * Lguest is meant to be simple: my rule of thumb is that 1% more LOC must</span>
<span class="p_del">- * gain at least 1% more performance.  Since neither LOC nor performance can be</span>
<span class="p_del">- * measured beforehand, it generally means implementing a feature then deciding</span>
<span class="p_del">- * if it&#39;s worth it.  And once it&#39;s implemented, who can say no?</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is why I haven&#39;t implemented this idea myself.  I want to, but I</span>
<span class="p_del">- * haven&#39;t.  You could, though.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The main place where lguest performance sucks is Guest page faulting.  When</span>
<span class="p_del">- * a Guest userspace process hits an unmapped page we switch back to the Host,</span>
<span class="p_del">- * walk the page tables, find it&#39;s not mapped, switch back to the Guest page</span>
<span class="p_del">- * fault handler, which calls a hypercall to set the page table entry, then</span>
<span class="p_del">- * finally returns to userspace.  That&#39;s two round-trips.</span>
<span class="p_del">- *</span>
<span class="p_del">- * If we had a small walker in the Switcher, we could quickly check the Guest</span>
<span class="p_del">- * page table and if the page isn&#39;t mapped, immediately reflect the fault back</span>
<span class="p_del">- * into the Guest.  This means the Switcher would have to know the top of the</span>
<span class="p_del">- * Guest page table and the page fault handler address.</span>
<span class="p_del">- *</span>
<span class="p_del">- * For simplicity, the Guest should only handle the case where the privilege</span>
<span class="p_del">- * level of the fault is 3 and probably only not present or write faults.  It</span>
<span class="p_del">- * should also detect recursive faults, and hand the original fault to the</span>
<span class="p_del">- * Host (which is actually really easy).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Two questions remain.  Would the performance gain outweigh the complexity?</span>
<span class="p_del">- * And who would write the verse documenting it?</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:011</span>
<span class="p_del">- * Lguest64 handles NMI.  This gave me NMI envy (until I looked at their</span>
<span class="p_del">- * code).  It&#39;s worth doing though, since it would let us use oprofile in the</span>
<span class="p_del">- * Host when a Guest is running.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*S:100</span>
<span class="p_del">- * Welcome to the Switcher itself!</span>
<span class="p_del">- *</span>
<span class="p_del">- * This file contains the low-level code which changes the CPU to run the Guest</span>
<span class="p_del">- * code, and returns to the Host when something happens.  Understand this, and</span>
<span class="p_del">- * you understand the heart of our journey.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Because this is in assembler rather than C, our tale switches from prose to</span>
<span class="p_del">- * verse.  First I tried limericks:</span>
<span class="p_del">- *</span>
<span class="p_del">- *	There once was an eax reg,</span>
<span class="p_del">- *	To which our pointer was fed,</span>
<span class="p_del">- *	It needed an add,</span>
<span class="p_del">- *	Which asm-offsets.h had</span>
<span class="p_del">- *	But this limerick is hurting my head.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Next I tried haikus, but fitting the required reference to the seasons in</span>
<span class="p_del">- * every stanza was quickly becoming tiresome:</span>
<span class="p_del">- *</span>
<span class="p_del">- *	The %eax reg</span>
<span class="p_del">- *	Holds &quot;struct lguest_pages&quot; now:</span>
<span class="p_del">- *	Cherry blossoms fall.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Then I started with Heroic Verse, but the rhyming requirement leeched away</span>
<span class="p_del">- * the content density and led to some uniquely awful oblique rhymes:</span>
<span class="p_del">- *</span>
<span class="p_del">- *	These constants are coming from struct offsets</span>
<span class="p_del">- *	For use within the asm switcher text.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Finally, I settled for something between heroic hexameter, and normal prose</span>
<span class="p_del">- * with inappropriate linebreaks.  Anyway, it aint no Shakespeare.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-// Not all kernel headers work from assembler</span>
<span class="p_del">-// But these ones are needed: the ENTRY() define</span>
<span class="p_del">-// And constants extracted from struct offsets</span>
<span class="p_del">-// To avoid magic numbers and breakage:</span>
<span class="p_del">-// Should they change the compiler can&#39;t save us</span>
<span class="p_del">-// Down here in the depths of assembler code.</span>
<span class="p_del">-#include &lt;linux/linkage.h&gt;</span>
<span class="p_del">-#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_del">-#include &lt;asm/page.h&gt;</span>
<span class="p_del">-#include &lt;asm/segment.h&gt;</span>
<span class="p_del">-#include &lt;asm/lguest.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-// We mark the start of the code to copy</span>
<span class="p_del">-// It&#39;s placed in .text tho it&#39;s never run here</span>
<span class="p_del">-// You&#39;ll see the trick macro at the end</span>
<span class="p_del">-// Which interleaves data and text to effect.</span>
<span class="p_del">-.text</span>
<span class="p_del">-ENTRY(start_switcher_text)</span>
<span class="p_del">-</span>
<span class="p_del">-// When we reach switch_to_guest we have just left</span>
<span class="p_del">-// The safe and comforting shores of C code</span>
<span class="p_del">-// %eax has the &quot;struct lguest_pages&quot; to use</span>
<span class="p_del">-// Where we save state and still see it from the Guest</span>
<span class="p_del">-// And %ebx holds the Guest shadow pagetable:</span>
<span class="p_del">-// Once set we have truly left Host behind.</span>
<span class="p_del">-ENTRY(switch_to_guest)</span>
<span class="p_del">-	// We told gcc all its regs could fade,</span>
<span class="p_del">-	// Clobbered by our journey into the Guest</span>
<span class="p_del">-	// We could have saved them, if we tried</span>
<span class="p_del">-	// But time is our master and cycles count.</span>
<span class="p_del">-</span>
<span class="p_del">-	// Segment registers must be saved for the Host</span>
<span class="p_del">-	// We push them on the Host stack for later</span>
<span class="p_del">-	pushl	%es</span>
<span class="p_del">-	pushl	%ds</span>
<span class="p_del">-	pushl	%gs</span>
<span class="p_del">-	pushl	%fs</span>
<span class="p_del">-	// But the compiler is fickle, and heeds</span>
<span class="p_del">-	// No warning of %ebp clobbers</span>
<span class="p_del">-	// When frame pointers are used.  That register</span>
<span class="p_del">-	// Must be saved and restored or chaos strikes.</span>
<span class="p_del">-	pushl	%ebp</span>
<span class="p_del">-	// The Host&#39;s stack is done, now save it away</span>
<span class="p_del">-	// In our &quot;struct lguest_pages&quot; at offset</span>
<span class="p_del">-	// Distilled into asm-offsets.h</span>
<span class="p_del">-	movl	%esp, LGUEST_PAGES_host_sp(%eax)</span>
<span class="p_del">-</span>
<span class="p_del">-	// All saved and there&#39;s now five steps before us:</span>
<span class="p_del">-	// Stack, GDT, IDT, TSS</span>
<span class="p_del">-	// Then last of all the page tables are flipped.</span>
<span class="p_del">-</span>
<span class="p_del">-	// Yet beware that our stack pointer must be</span>
<span class="p_del">-	// Always valid lest an NMI hits</span>
<span class="p_del">-	// %edx does the duty here as we juggle</span>
<span class="p_del">-	// %eax is lguest_pages: our stack lies within.</span>
<span class="p_del">-	movl	%eax, %edx</span>
<span class="p_del">-	addl	$LGUEST_PAGES_regs, %edx</span>
<span class="p_del">-	movl	%edx, %esp</span>
<span class="p_del">-</span>
<span class="p_del">-	// The Guest&#39;s GDT we so carefully</span>
<span class="p_del">-	// Placed in the &quot;struct lguest_pages&quot; before</span>
<span class="p_del">-	lgdt	LGUEST_PAGES_guest_gdt_desc(%eax)</span>
<span class="p_del">-</span>
<span class="p_del">-	// The Guest&#39;s IDT we did partially</span>
<span class="p_del">-	// Copy to &quot;struct lguest_pages&quot; as well.</span>
<span class="p_del">-	lidt	LGUEST_PAGES_guest_idt_desc(%eax)</span>
<span class="p_del">-</span>
<span class="p_del">-	// The TSS entry which controls traps</span>
<span class="p_del">-	// Must be loaded up with &quot;ltr&quot; now:</span>
<span class="p_del">-	// The GDT entry that TSS uses </span>
<span class="p_del">-	// Changes type when we load it: damn Intel!</span>
<span class="p_del">-	// For after we switch over our page tables</span>
<span class="p_del">-	// That entry will be read-only: we&#39;d crash.</span>
<span class="p_del">-	movl	$(GDT_ENTRY_TSS*8), %edx</span>
<span class="p_del">-	ltr	%dx</span>
<span class="p_del">-</span>
<span class="p_del">-	// Look back now, before we take this last step!</span>
<span class="p_del">-	// The Host&#39;s TSS entry was also marked used;</span>
<span class="p_del">-	// Let&#39;s clear it again for our return.</span>
<span class="p_del">-	// The GDT descriptor of the Host</span>
<span class="p_del">-	// Points to the table after two &quot;size&quot; bytes</span>
<span class="p_del">-	movl	(LGUEST_PAGES_host_gdt_desc+2)(%eax), %edx</span>
<span class="p_del">-	// Clear &quot;used&quot; from type field (byte 5, bit 2)</span>
<span class="p_del">-	andb	$0xFD, (GDT_ENTRY_TSS*8 + 5)(%edx)</span>
<span class="p_del">-</span>
<span class="p_del">-	// Once our page table&#39;s switched, the Guest is live!</span>
<span class="p_del">-	// The Host fades as we run this final step.</span>
<span class="p_del">-	// Our &quot;struct lguest_pages&quot; is now read-only.</span>
<span class="p_del">-	movl	%ebx, %cr3</span>
<span class="p_del">-</span>
<span class="p_del">-	// The page table change did one tricky thing:</span>
<span class="p_del">-	// The Guest&#39;s register page has been mapped</span>
<span class="p_del">-	// Writable under our %esp (stack) --</span>
<span class="p_del">-	// We can simply pop off all Guest regs.</span>
<span class="p_del">-	popl	%eax</span>
<span class="p_del">-	popl	%ebx</span>
<span class="p_del">-	popl	%ecx</span>
<span class="p_del">-	popl	%edx</span>
<span class="p_del">-	popl	%esi</span>
<span class="p_del">-	popl	%edi</span>
<span class="p_del">-	popl	%ebp</span>
<span class="p_del">-	popl	%gs</span>
<span class="p_del">-	popl	%fs</span>
<span class="p_del">-	popl	%ds</span>
<span class="p_del">-	popl	%es</span>
<span class="p_del">-</span>
<span class="p_del">-	// Near the base of the stack lurk two strange fields</span>
<span class="p_del">-	// Which we fill as we exit the Guest</span>
<span class="p_del">-	// These are the trap number and its error</span>
<span class="p_del">-	// We can simply step past them on our way.</span>
<span class="p_del">-	addl	$8, %esp</span>
<span class="p_del">-</span>
<span class="p_del">-	// The last five stack slots hold return address</span>
<span class="p_del">-	// And everything needed to switch privilege</span>
<span class="p_del">-	// From Switcher&#39;s level 0 to Guest&#39;s 1,</span>
<span class="p_del">-	// And the stack where the Guest had last left it.</span>
<span class="p_del">-	// Interrupts are turned back on: we are Guest.</span>
<span class="p_del">-	iret</span>
<span class="p_del">-</span>
<span class="p_del">-// We tread two paths to switch back to the Host</span>
<span class="p_del">-// Yet both must save Guest state and restore Host</span>
<span class="p_del">-// So we put the routine in a macro.</span>
<span class="p_del">-#define SWITCH_TO_HOST							\</span>
<span class="p_del">-	/* We save the Guest state: all registers first			\</span>
<span class="p_del">-	 * Laid out just as &quot;struct lguest_regs&quot; defines */		\</span>
<span class="p_del">-	pushl	%es;							\</span>
<span class="p_del">-	pushl	%ds;							\</span>
<span class="p_del">-	pushl	%fs;							\</span>
<span class="p_del">-	pushl	%gs;							\</span>
<span class="p_del">-	pushl	%ebp;							\</span>
<span class="p_del">-	pushl	%edi;							\</span>
<span class="p_del">-	pushl	%esi;							\</span>
<span class="p_del">-	pushl	%edx;							\</span>
<span class="p_del">-	pushl	%ecx;							\</span>
<span class="p_del">-	pushl	%ebx;							\</span>
<span class="p_del">-	pushl	%eax;							\</span>
<span class="p_del">-	/* Our stack and our code are using segments			\</span>
<span class="p_del">-	 * Set in the TSS and IDT					\</span>
<span class="p_del">-	 * Yet if we were to touch data we&#39;d use			\</span>
<span class="p_del">-	 * Whatever data segment the Guest had.				\</span>
<span class="p_del">-	 * Load the lguest ds segment for now. */			\</span>
<span class="p_del">-	movl	$(LGUEST_DS), %eax;					\</span>
<span class="p_del">-	movl	%eax, %ds;						\</span>
<span class="p_del">-	/* So where are we?  Which CPU, which struct?			\</span>
<span class="p_del">-	 * The stack is our clue: our TSS starts			\</span>
<span class="p_del">-	 * It at the end of &quot;struct lguest_pages&quot;.			\</span>
<span class="p_del">-	 * Or we may have stumbled while restoring			\</span>
<span class="p_del">-	 * Our Guest segment regs while in switch_to_guest,		\</span>
<span class="p_del">-	 * The fault pushed atop that part-unwound stack.		\</span>
<span class="p_del">-	 * If we round the stack down to the page start			\</span>
<span class="p_del">-	 * We&#39;re at the start of &quot;struct lguest_pages&quot;. */		\</span>
<span class="p_del">-	movl	%esp, %eax;						\</span>
<span class="p_del">-	andl	$(~(1 &lt;&lt; PAGE_SHIFT - 1)), %eax;			\</span>
<span class="p_del">-	/* Save our trap number: the switch will obscure it		\</span>
<span class="p_del">-	 * (In the Host the Guest regs are not mapped here)		\</span>
<span class="p_del">-	 * %ebx holds it safe for deliver_to_host */			\</span>
<span class="p_del">-	movl	LGUEST_PAGES_regs_trapnum(%eax), %ebx;			\</span>
<span class="p_del">-	/* The Host GDT, IDT and stack!					\</span>
<span class="p_del">-	 * All these lie safely hidden from the Guest:			\</span>
<span class="p_del">-	 * We must return to the Host page tables			\</span>
<span class="p_del">-	 * (Hence that was saved in struct lguest_pages) */		\</span>
<span class="p_del">-	movl	LGUEST_PAGES_host_cr3(%eax), %edx;			\</span>
<span class="p_del">-	movl	%edx, %cr3;						\</span>
<span class="p_del">-	/* As before, when we looked back at the Host			\</span>
<span class="p_del">-	 * As we left and marked TSS unused				\</span>
<span class="p_del">-	 * So must we now for the Guest left behind. */			\</span>
<span class="p_del">-	andb	$0xFD, (LGUEST_PAGES_guest_gdt+GDT_ENTRY_TSS*8+5)(%eax); \</span>
<span class="p_del">-	/* Switch to Host&#39;s GDT, IDT. */				\</span>
<span class="p_del">-	lgdt	LGUEST_PAGES_host_gdt_desc(%eax);			\</span>
<span class="p_del">-	lidt	LGUEST_PAGES_host_idt_desc(%eax);			\</span>
<span class="p_del">-	/* Restore the Host&#39;s stack where its saved regs lie */		\</span>
<span class="p_del">-	movl	LGUEST_PAGES_host_sp(%eax), %esp;			\</span>
<span class="p_del">-	/* Last the TSS: our Host is returned */			\</span>
<span class="p_del">-	movl	$(GDT_ENTRY_TSS*8), %edx;				\</span>
<span class="p_del">-	ltr	%dx;							\</span>
<span class="p_del">-	/* Restore now the regs saved right at the first. */		\</span>
<span class="p_del">-	popl	%ebp;							\</span>
<span class="p_del">-	popl	%fs;							\</span>
<span class="p_del">-	popl	%gs;							\</span>
<span class="p_del">-	popl	%ds;							\</span>
<span class="p_del">-	popl	%es</span>
<span class="p_del">-</span>
<span class="p_del">-// The first path is trod when the Guest has trapped:</span>
<span class="p_del">-// (Which trap it was has been pushed on the stack).</span>
<span class="p_del">-// We need only switch back, and the Host will decode</span>
<span class="p_del">-// Why we came home, and what needs to be done.</span>
<span class="p_del">-return_to_host:</span>
<span class="p_del">-	SWITCH_TO_HOST</span>
<span class="p_del">-	iret</span>
<span class="p_del">-</span>
<span class="p_del">-// We are lead to the second path like so:</span>
<span class="p_del">-// An interrupt, with some cause external</span>
<span class="p_del">-// Has ajerked us rudely from the Guest&#39;s code</span>
<span class="p_del">-// Again we must return home to the Host</span>
<span class="p_del">-deliver_to_host:</span>
<span class="p_del">-	SWITCH_TO_HOST</span>
<span class="p_del">-	// But now we must go home via that place</span>
<span class="p_del">-	// Where that interrupt was supposed to go</span>
<span class="p_del">-	// Had we not been ensconced, running the Guest.</span>
<span class="p_del">-	// Here we see the trickness of run_guest_once():</span>
<span class="p_del">-	// The Host stack is formed like an interrupt</span>
<span class="p_del">-	// With EIP, CS and EFLAGS layered.</span>
<span class="p_del">-	// Interrupt handlers end with &quot;iret&quot;</span>
<span class="p_del">-	// And that will take us home at long long last.</span>
<span class="p_del">-</span>
<span class="p_del">-	// But first we must find the handler to call!</span>
<span class="p_del">-	// The IDT descriptor for the Host</span>
<span class="p_del">-	// Has two bytes for size, and four for address:</span>
<span class="p_del">-	// %edx will hold it for us for now.</span>
<span class="p_del">-	movl	(LGUEST_PAGES_host_idt_desc+2)(%eax), %edx</span>
<span class="p_del">-	// We now know the table address we need,</span>
<span class="p_del">-	// And saved the trap&#39;s number inside %ebx.</span>
<span class="p_del">-	// Yet the pointer to the handler is smeared</span>
<span class="p_del">-	// Across the bits of the table entry.</span>
<span class="p_del">-	// What oracle can tell us how to extract</span>
<span class="p_del">-	// From such a convoluted encoding?</span>
<span class="p_del">-	// I consulted gcc, and it gave</span>
<span class="p_del">-	// These instructions, which I gladly credit:</span>
<span class="p_del">-	leal	(%edx,%ebx,8), %eax</span>
<span class="p_del">-	movzwl	(%eax),%edx</span>
<span class="p_del">-	movl	4(%eax), %eax</span>
<span class="p_del">-	xorw	%ax, %ax</span>
<span class="p_del">-	orl	%eax, %edx</span>
<span class="p_del">-	// Now the address of the handler&#39;s in %edx</span>
<span class="p_del">-	// We call it now: its &quot;iret&quot; drops us home.</span>
<span class="p_del">-	jmp	*%edx</span>
<span class="p_del">-</span>
<span class="p_del">-// Every interrupt can come to us here</span>
<span class="p_del">-// But we must truly tell each apart.</span>
<span class="p_del">-// They number two hundred and fifty six</span>
<span class="p_del">-// And each must land in a different spot,</span>
<span class="p_del">-// Push its number on stack, and join the stream.</span>
<span class="p_del">-</span>
<span class="p_del">-// And worse, a mere six of the traps stand apart</span>
<span class="p_del">-// And push on their stack an addition:</span>
<span class="p_del">-// An error number, thirty two bits long</span>
<span class="p_del">-// So we punish the other two fifty</span>
<span class="p_del">-// And make them push a zero so they match.</span>
<span class="p_del">-</span>
<span class="p_del">-// Yet two fifty six entries is long</span>
<span class="p_del">-// And all will look most the same as the last</span>
<span class="p_del">-// So we create a macro which can make</span>
<span class="p_del">-// As many entries as we need to fill.</span>
<span class="p_del">-</span>
<span class="p_del">-// Note the change to .data then .text:</span>
<span class="p_del">-// We plant the address of each entry</span>
<span class="p_del">-// Into a (data) table for the Host</span>
<span class="p_del">-// To know where each Guest interrupt should go.</span>
<span class="p_del">-.macro IRQ_STUB N TARGET</span>
<span class="p_del">-	.data; .long 1f; .text; 1:</span>
<span class="p_del">- // Trap eight, ten through fourteen and seventeen</span>
<span class="p_del">- // Supply an error number.  Else zero.</span>
<span class="p_del">- .if (\N &lt;&gt; 8) &amp;&amp; (\N &lt; 10 || \N &gt; 14) &amp;&amp; (\N &lt;&gt; 17)</span>
<span class="p_del">-	pushl	$0</span>
<span class="p_del">- .endif</span>
<span class="p_del">-	pushl	$\N</span>
<span class="p_del">-	jmp	\TARGET</span>
<span class="p_del">-	ALIGN</span>
<span class="p_del">-.endm</span>
<span class="p_del">-</span>
<span class="p_del">-// This macro creates numerous entries</span>
<span class="p_del">-// Using GAS macros which out-power C&#39;s.</span>
<span class="p_del">-.macro IRQ_STUBS FIRST LAST TARGET</span>
<span class="p_del">- irq=\FIRST</span>
<span class="p_del">- .rept \LAST-\FIRST+1</span>
<span class="p_del">-	IRQ_STUB irq \TARGET</span>
<span class="p_del">-  irq=irq+1</span>
<span class="p_del">- .endr</span>
<span class="p_del">-.endm</span>
<span class="p_del">-</span>
<span class="p_del">-// Here&#39;s the marker for our pointer table</span>
<span class="p_del">-// Laid in the data section just before</span>
<span class="p_del">-// Each macro places the address of code</span>
<span class="p_del">-// Forming an array: each one points to text</span>
<span class="p_del">-// Which handles interrupt in its turn.</span>
<span class="p_del">-.data</span>
<span class="p_del">-.global default_idt_entries</span>
<span class="p_del">-default_idt_entries:</span>
<span class="p_del">-.text</span>
<span class="p_del">-	// The first two traps go straight back to the Host</span>
<span class="p_del">-	IRQ_STUBS 0 1 return_to_host</span>
<span class="p_del">-	// We&#39;ll say nothing, yet, about NMI</span>
<span class="p_del">-	IRQ_STUB 2 handle_nmi</span>
<span class="p_del">-	// Other traps also return to the Host</span>
<span class="p_del">-	IRQ_STUBS 3 31 return_to_host</span>
<span class="p_del">-	// All interrupts go via their handlers</span>
<span class="p_del">-	IRQ_STUBS 32 127 deliver_to_host</span>
<span class="p_del">-	// &#39;Cept system calls coming from userspace</span>
<span class="p_del">-	// Are to go to the Guest, never the Host.</span>
<span class="p_del">-	IRQ_STUB 128 return_to_host</span>
<span class="p_del">-	IRQ_STUBS 129 255 deliver_to_host</span>
<span class="p_del">-</span>
<span class="p_del">-// The NMI, what a fabulous beast</span>
<span class="p_del">-// Which swoops in and stops us no matter that</span>
<span class="p_del">-// We&#39;re suspended between heaven and hell,</span>
<span class="p_del">-// (Or more likely between the Host and Guest)</span>
<span class="p_del">-// When in it comes!  We are dazed and confused</span>
<span class="p_del">-// So we do the simplest thing which one can.</span>
<span class="p_del">-// Though we&#39;ve pushed the trap number and zero</span>
<span class="p_del">-// We discard them, return, and hope we live.</span>
<span class="p_del">-handle_nmi:</span>
<span class="p_del">-	addl	$8, %esp</span>
<span class="p_del">-	iret</span>
<span class="p_del">-</span>
<span class="p_del">-// We are done; all that&#39;s left is Mastery</span>
<span class="p_del">-// And &quot;make Mastery&quot; is a journey long</span>
<span class="p_del">-// Designed to make your fingers itch to code.</span>
<span class="p_del">-</span>
<span class="p_del">-// Here ends the text, the file and poem.</span>
<span class="p_del">-ENTRY(end_switcher_text)</span>
<span class="p_header">diff --git a/drivers/net/Kconfig b/drivers/net/Kconfig</span>
<span class="p_header">index 83a1616903f8..aba0d652095b 100644</span>
<span class="p_header">--- a/drivers/net/Kconfig</span>
<span class="p_header">+++ b/drivers/net/Kconfig</span>
<span class="p_chunk">@@ -333,7 +333,7 @@</span> <span class="p_context"> config VIRTIO_NET</span>
 	depends on VIRTIO
 	---help---
 	  This is the virtual network driver for virtio.  It can be used with
<span class="p_del">-	  lguest or QEMU based VMMs (like KVM or Xen).  Say Y or M.</span>
<span class="p_add">+	  QEMU based VMMs (like KVM or Xen).  Say Y or M.</span>
 
 config NLMON
 	tristate &quot;Virtual netlink monitoring device&quot;
<span class="p_header">diff --git a/drivers/tty/hvc/Kconfig b/drivers/tty/hvc/Kconfig</span>
<span class="p_header">index b8d5ea0ae26b..fec457edad14 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/Kconfig</span>
<span class="p_header">+++ b/drivers/tty/hvc/Kconfig</span>
<span class="p_chunk">@@ -4,7 +4,7 @@</span> <span class="p_context"> config HVC_DRIVER</span>
 	bool
 	help
 	  Generic &quot;hypervisor virtual console&quot; infrastructure for various
<span class="p_del">-	  hypervisors (pSeries, iSeries, Xen, lguest).</span>
<span class="p_add">+	  hypervisors (pSeries, iSeries, Xen).</span>
 	  It will automatically be selected if one of the back-end console drivers
 	  is selected.
 
<span class="p_header">diff --git a/drivers/virtio/Kconfig b/drivers/virtio/Kconfig</span>
<span class="p_header">index 623f72334fa5..cff773f15b7e 100644</span>
<span class="p_header">--- a/drivers/virtio/Kconfig</span>
<span class="p_header">+++ b/drivers/virtio/Kconfig</span>
<span class="p_chunk">@@ -2,8 +2,8 @@</span> <span class="p_context"> config VIRTIO</span>
 	tristate
 	---help---
 	  This option is selected by any driver which implements the virtio
<span class="p_del">-	  bus, such as CONFIG_VIRTIO_PCI, CONFIG_VIRTIO_MMIO, CONFIG_LGUEST,</span>
<span class="p_del">-	  CONFIG_RPMSG or CONFIG_S390_GUEST.</span>
<span class="p_add">+	  bus, such as CONFIG_VIRTIO_PCI, CONFIG_VIRTIO_MMIO, CONFIG_RPMSG</span>
<span class="p_add">+	  or CONFIG_S390_GUEST.</span>
 
 menu &quot;Virtio drivers&quot;
 
<span class="p_header">diff --git a/include/linux/lguest.h b/include/linux/lguest.h</span>
deleted file mode 100644
<span class="p_header">index 6db19f35f7c5..000000000000</span>
<span class="p_header">--- a/include/linux/lguest.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,73 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Things the lguest guest needs to know.  Note: like all lguest interfaces,</span>
<span class="p_del">- * this is subject to wild and random change between versions.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifndef _LINUX_LGUEST_H</span>
<span class="p_del">-#define _LINUX_LGUEST_H</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef __ASSEMBLY__</span>
<span class="p_del">-#include &lt;linux/time.h&gt;</span>
<span class="p_del">-#include &lt;asm/irq.h&gt;</span>
<span class="p_del">-#include &lt;asm/lguest_hcall.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#define LG_CLOCK_MIN_DELTA	100UL</span>
<span class="p_del">-#define LG_CLOCK_MAX_DELTA	ULONG_MAX</span>
<span class="p_del">-</span>
<span class="p_del">-/*G:031</span>
<span class="p_del">- * The second method of communicating with the Host is to via &quot;struct</span>
<span class="p_del">- * lguest_data&quot;.  Once the Guest&#39;s initialization hypercall tells the Host where</span>
<span class="p_del">- * this is, the Guest and Host both publish information in it.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-struct lguest_data {</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 512 == enabled (same as eflags in normal hardware).  The Guest</span>
<span class="p_del">-	 * changes interrupts so often that a hypercall is too slow.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	unsigned int irq_enabled;</span>
<span class="p_del">-	/* Fine-grained interrupt disabling by the Guest */</span>
<span class="p_del">-	DECLARE_BITMAP(blocked_interrupts, LGUEST_IRQS);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Host writes the virtual address of the last page fault here,</span>
<span class="p_del">-	 * which saves the Guest a hypercall.  CR2 is the native register where</span>
<span class="p_del">-	 * this address would normally be found.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	unsigned long cr2;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Wallclock time set by the Host. */</span>
<span class="p_del">-	struct timespec time;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Interrupt pending set by the Host.  The Guest should do a hypercall</span>
<span class="p_del">-	 * if it re-enables interrupts and sees this set (to X86_EFLAGS_IF).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	int irq_pending;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Async hypercall ring.  Instead of directly making hypercalls, we can</span>
<span class="p_del">-	 * place them in here for processing the next time the Host wants.</span>
<span class="p_del">-	 * This batching can be quite efficient.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 0xFF == done (set by Host), 0 == pending (set by Guest). */</span>
<span class="p_del">-	u8 hcall_status[LHCALL_RING_SIZE];</span>
<span class="p_del">-	/* The actual registers for the hypercalls. */</span>
<span class="p_del">-	struct hcall_args hcalls[LHCALL_RING_SIZE];</span>
<span class="p_del">-</span>
<span class="p_del">-/* Fields initialized by the Host at boot: */</span>
<span class="p_del">-	/* Memory not to try to access */</span>
<span class="p_del">-	unsigned long reserve_mem;</span>
<span class="p_del">-	/* KHz for the TSC clock. */</span>
<span class="p_del">-	u32 tsc_khz;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Fields initialized by the Guest at boot: */</span>
<span class="p_del">-	/* Instruction to suppress interrupts even if enabled */</span>
<span class="p_del">-	unsigned long noirq_iret;</span>
<span class="p_del">-	/* Address above which page tables are all identical. */</span>
<span class="p_del">-	unsigned long kernel_address;</span>
<span class="p_del">-	/* The vector to try to use for system calls (0x40 or 0x80). */</span>
<span class="p_del">-	unsigned int syscall_vec;</span>
<span class="p_del">-};</span>
<span class="p_del">-extern struct lguest_data lguest_data;</span>
<span class="p_del">-#endif /* __ASSEMBLY__ */</span>
<span class="p_del">-#endif	/* _LINUX_LGUEST_H */</span>
<span class="p_header">diff --git a/include/linux/lguest_launcher.h b/include/linux/lguest_launcher.h</span>
deleted file mode 100644
<span class="p_header">index acd5b12565cc..000000000000</span>
<span class="p_header">--- a/include/linux/lguest_launcher.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,44 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef _LINUX_LGUEST_LAUNCHER</span>
<span class="p_del">-#define _LINUX_LGUEST_LAUNCHER</span>
<span class="p_del">-/* Everything the &quot;lguest&quot; userspace program needs to know. */</span>
<span class="p_del">-#include &lt;linux/types.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/*D:010</span>
<span class="p_del">- * Drivers</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Guest needs devices to do anything useful.  Since we don&#39;t let it touch</span>
<span class="p_del">- * real devices (think of the damage it could do!) we provide virtual devices.</span>
<span class="p_del">- * We emulate a PCI bus with virtio devices on it; we used to have our own</span>
<span class="p_del">- * lguest bus which was far simpler, but this tests the virtio 1.0 standard.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Virtio devices are also used by kvm, so we can simply reuse their optimized</span>
<span class="p_del">- * device drivers.  And one day when everyone uses virtio, my plan will be</span>
<span class="p_del">- * complete.  Bwahahahah!</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/* Write command first word is a request. */</span>
<span class="p_del">-enum lguest_req</span>
<span class="p_del">-{</span>
<span class="p_del">-	LHREQ_INITIALIZE, /* + base, pfnlimit, start */</span>
<span class="p_del">-	LHREQ_GETDMA, /* No longer used */</span>
<span class="p_del">-	LHREQ_IRQ, /* + irq */</span>
<span class="p_del">-	LHREQ_BREAK, /* No longer used */</span>
<span class="p_del">-	LHREQ_EVENTFD, /* No longer used. */</span>
<span class="p_del">-	LHREQ_GETREG, /* + offset within struct pt_regs (then read value). */</span>
<span class="p_del">-	LHREQ_SETREG, /* + offset within struct pt_regs, value. */</span>
<span class="p_del">-	LHREQ_TRAP, /* + trap number to deliver to guest. */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is what read() of the lguest fd populates.  trap ==</span>
<span class="p_del">- * LGUEST_TRAP_ENTRY for an LHCALL_NOTIFY (addr is the</span>
<span class="p_del">- * argument), 14 for a page fault in the MMIO region (addr is</span>
<span class="p_del">- * the trap address, insn is the instruction), or 13 for a GPF</span>
<span class="p_del">- * (insn is the instruction).</span>
<span class="p_del">- */</span>
<span class="p_del">-struct lguest_pending {</span>
<span class="p_del">-	__u8 trap;</span>
<span class="p_del">-	__u8 insn[7];</span>
<span class="p_del">-	__u32 addr;</span>
<span class="p_del">-};</span>
<span class="p_del">-#endif /* _LINUX_LGUEST_LAUNCHER */</span>
<span class="p_header">diff --git a/include/uapi/linux/virtio_ring.h b/include/uapi/linux/virtio_ring.h</span>
<span class="p_header">index c07295969b7e..6d5d5faa989b 100644</span>
<span class="p_header">--- a/include/uapi/linux/virtio_ring.h</span>
<span class="p_header">+++ b/include/uapi/linux/virtio_ring.h</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 #ifndef _UAPI_LINUX_VIRTIO_RING_H
 #define _UAPI_LINUX_VIRTIO_RING_H
<span class="p_del">-/* An interface for efficient virtio implementation, currently for use by KVM</span>
<span class="p_del">- * and lguest, but hopefully others soon.  Do NOT change this since it will</span>
<span class="p_add">+/* An interface for efficient virtio implementation, currently for use by KVM,</span>
<span class="p_add">+ * but hopefully others soon.  Do NOT change this since it will</span>
  * break existing servers and clients.
  *
  * This header is BSD licensed so anyone can use the definitions to implement
<span class="p_header">diff --git a/tools/Makefile b/tools/Makefile</span>
<span class="p_header">index 221e1ce78b06..a19b176b914b 100644</span>
<span class="p_header">--- a/tools/Makefile</span>
<span class="p_header">+++ b/tools/Makefile</span>
<span class="p_chunk">@@ -18,7 +18,6 @@</span> <span class="p_context"> help:</span>
 	@echo &#39;  iio                    - IIO tools&#39;
 	@echo &#39;  kvm_stat               - top-like utility for displaying kvm statistics&#39;
 	@echo &#39;  leds                   - LEDs  tools&#39;
<span class="p_del">-	@echo &#39;  lguest                 - a minimal 32-bit x86 hypervisor&#39;</span>
 	@echo &#39;  liblockdep             - user-space wrapper for kernel locking-validator&#39;
 	@echo &#39;  net                    - misc networking tools&#39;
 	@echo &#39;  perf                   - Linux performance measurement and analysis tool&#39;
<span class="p_chunk">@@ -90,7 +89,7 @@</span> <span class="p_context"> freefall: FORCE</span>
 kvm_stat: FORCE
 	$(call descend,kvm/$@)
 
<span class="p_del">-all: acpi cgroup cpupower gpio hv firewire lguest liblockdep \</span>
<span class="p_add">+all: acpi cgroup cpupower gpio hv firewire liblockdep \</span>
 		perf selftests turbostat usb \
 		virtio vm net x86_energy_perf_policy \
 		tmon freefall objtool kvm_stat
<span class="p_chunk">@@ -101,7 +100,7 @@</span> <span class="p_context"> acpi_install:</span>
 cpupower_install:
 	$(call descend,power/$(@:_install=),install)
 
<span class="p_del">-cgroup_install firewire_install gpio_install hv_install lguest_install perf_install usb_install virtio_install vm_install net_install objtool_install:</span>
<span class="p_add">+cgroup_install firewire_install gpio_install hv_install perf_install usb_install virtio_install vm_install net_install objtool_install:</span>
 	$(call descend,$(@:_install=),install)
 
 liblockdep_install:
<span class="p_chunk">@@ -123,7 +122,7 @@</span> <span class="p_context"> kvm_stat_install:</span>
 	$(call descend,kvm/$(@:_install=),install)
 
 install: acpi_install cgroup_install cpupower_install gpio_install \
<span class="p_del">-		hv_install firewire_install lguest_install liblockdep_install \</span>
<span class="p_add">+		hv_install firewire_install liblockdep_install \</span>
 		perf_install selftests_install turbostat_install usb_install \
 		virtio_install vm_install net_install x86_energy_perf_policy_install \
 		tmon_install freefall_install objtool_install kvm_stat_install
<span class="p_chunk">@@ -134,7 +133,7 @@</span> <span class="p_context"> acpi_clean:</span>
 cpupower_clean:
 	$(call descend,power/cpupower,clean)
 
<span class="p_del">-cgroup_clean hv_clean firewire_clean lguest_clean spi_clean usb_clean virtio_clean vm_clean net_clean iio_clean gpio_clean objtool_clean leds_clean:</span>
<span class="p_add">+cgroup_clean hv_clean firewire_clean spi_clean usb_clean virtio_clean vm_clean net_clean iio_clean gpio_clean objtool_clean leds_clean:</span>
 	$(call descend,$(@:_clean=),clean)
 
 liblockdep_clean:
<span class="p_chunk">@@ -168,7 +167,7 @@</span> <span class="p_context"> freefall_clean:</span>
 build_clean:
 	$(call descend,build,clean)
 
<span class="p_del">-clean: acpi_clean cgroup_clean cpupower_clean hv_clean firewire_clean lguest_clean \</span>
<span class="p_add">+clean: acpi_clean cgroup_clean cpupower_clean hv_clean firewire_clean \</span>
 		perf_clean selftests_clean turbostat_clean spi_clean usb_clean virtio_clean \
 		vm_clean net_clean iio_clean x86_energy_perf_policy_clean tmon_clean \
 		freefall_clean build_clean libbpf_clean libsubcmd_clean liblockdep_clean \
<span class="p_header">diff --git a/tools/lguest/.gitignore b/tools/lguest/.gitignore</span>
deleted file mode 100644
<span class="p_header">index 8d9a8383a52e..000000000000</span>
<span class="p_header">--- a/tools/lguest/.gitignore</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,2 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-lguest</span>
<span class="p_del">-include</span>
<span class="p_header">diff --git a/tools/lguest/Makefile b/tools/lguest/Makefile</span>
deleted file mode 100644
<span class="p_header">index d04599a79802..000000000000</span>
<span class="p_header">--- a/tools/lguest/Makefile</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,14 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-# This creates the demonstration utility &quot;lguest&quot; which runs a Linux guest.</span>
<span class="p_del">-CFLAGS:=-m32 -Wall -Wmissing-declarations -Wmissing-prototypes -O3 -U_FORTIFY_SOURCE -Iinclude</span>
<span class="p_del">-</span>
<span class="p_del">-all: lguest</span>
<span class="p_del">-</span>
<span class="p_del">-include/linux/virtio_types.h: ../../include/uapi/linux/virtio_types.h</span>
<span class="p_del">-	mkdir -p include/linux 2&gt;&amp;1 || true</span>
<span class="p_del">-	ln -sf ../../../../include/uapi/linux/virtio_types.h $@</span>
<span class="p_del">-</span>
<span class="p_del">-lguest: include/linux/virtio_types.h</span>
<span class="p_del">-</span>
<span class="p_del">-clean:</span>
<span class="p_del">-	rm -f lguest</span>
<span class="p_del">-	rm -rf include</span>
<span class="p_header">diff --git a/tools/lguest/extract b/tools/lguest/extract</span>
deleted file mode 100644
<span class="p_header">index 7730bb6e4b94..000000000000</span>
<span class="p_header">--- a/tools/lguest/extract</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,58 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#! /bin/sh</span>
<span class="p_del">-</span>
<span class="p_del">-set -e</span>
<span class="p_del">-</span>
<span class="p_del">-PREFIX=$1</span>
<span class="p_del">-shift</span>
<span class="p_del">-</span>
<span class="p_del">-trap &#39;rm -r $TMPDIR&#39; 0</span>
<span class="p_del">-TMPDIR=`mktemp -d`</span>
<span class="p_del">-</span>
<span class="p_del">-exec 3&gt;/dev/null</span>
<span class="p_del">-for f; do</span>
<span class="p_del">-    while IFS=&quot;</span>
<span class="p_del">-&quot; read -r LINE; do</span>
<span class="p_del">-	case &quot;$LINE&quot; in</span>
<span class="p_del">-	    *$PREFIX:[0-9]*:\**)</span>
<span class="p_del">-		NUM=`echo &quot;$LINE&quot; | sed &quot;s/.*$PREFIX:\([0-9]*\).*/\1/&quot;`</span>
<span class="p_del">-		if [ -f $TMPDIR/$NUM ]; then</span>
<span class="p_del">-		    echo &quot;$TMPDIR/$NUM already exits prior to $f&quot;</span>
<span class="p_del">-		    exit 1</span>
<span class="p_del">-		fi</span>
<span class="p_del">-		exec 3&gt;&gt;$TMPDIR/$NUM</span>
<span class="p_del">-		echo $f | sed &#39;s,\.\./,,g&#39; &gt; $TMPDIR/.$NUM</span>
<span class="p_del">-		/bin/echo &quot;$LINE&quot; | sed -e &quot;s/$PREFIX:[0-9]*//&quot; -e &quot;s/:\*/*/&quot; &gt;&amp;3</span>
<span class="p_del">-		;;</span>
<span class="p_del">-	    *$PREFIX:[0-9]*)</span>
<span class="p_del">-		NUM=`echo &quot;$LINE&quot; | sed &quot;s/.*$PREFIX:\([0-9]*\).*/\1/&quot;`</span>
<span class="p_del">-		if [ -f $TMPDIR/$NUM ]; then</span>
<span class="p_del">-		    echo &quot;$TMPDIR/$NUM already exits prior to $f&quot;</span>
<span class="p_del">-		    exit 1</span>
<span class="p_del">-		fi</span>
<span class="p_del">-		exec 3&gt;&gt;$TMPDIR/$NUM</span>
<span class="p_del">-		echo $f | sed &#39;s,\.\./,,g&#39; &gt; $TMPDIR/.$NUM</span>
<span class="p_del">-		/bin/echo &quot;$LINE&quot; | sed &quot;s/$PREFIX:[0-9]*//&quot; &gt;&amp;3</span>
<span class="p_del">-		;;</span>
<span class="p_del">-	    *:\**)</span>
<span class="p_del">-		/bin/echo &quot;$LINE&quot; | sed -e &quot;s/:\*/*/&quot; -e &quot;s,/\*\*/,,&quot; &gt;&amp;3</span>
<span class="p_del">-		echo &gt;&amp;3</span>
<span class="p_del">-		exec 3&gt;/dev/null</span>
<span class="p_del">-		;;</span>
<span class="p_del">-	    *)</span>
<span class="p_del">-		/bin/echo &quot;$LINE&quot; &gt;&amp;3</span>
<span class="p_del">-		;;</span>
<span class="p_del">-	esac</span>
<span class="p_del">-    done &lt; $f</span>
<span class="p_del">-    echo &gt;&amp;3</span>
<span class="p_del">-    exec 3&gt;/dev/null</span>
<span class="p_del">-done</span>
<span class="p_del">-</span>
<span class="p_del">-LASTFILE=&quot;&quot;</span>
<span class="p_del">-for f in $TMPDIR/*; do</span>
<span class="p_del">-    if [ &quot;$LASTFILE&quot; != $(cat $TMPDIR/.$(basename $f) ) ]; then</span>
<span class="p_del">-	LASTFILE=$(cat $TMPDIR/.$(basename $f) )</span>
<span class="p_del">-	echo &quot;[ $LASTFILE ]&quot;</span>
<span class="p_del">-    fi</span>
<span class="p_del">-    cat $f</span>
<span class="p_del">-done</span>
<span class="p_del">-</span>
<span class="p_header">diff --git a/tools/lguest/lguest.c b/tools/lguest/lguest.c</span>
deleted file mode 100644
<span class="p_header">index 897cd6f3f687..000000000000</span>
<span class="p_header">--- a/tools/lguest/lguest.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,3420 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*P:100</span>
<span class="p_del">- * This is the Launcher code, a simple program which lays out the &quot;physical&quot;</span>
<span class="p_del">- * memory for the new Guest by mapping the kernel image and the virtual</span>
<span class="p_del">- * devices, then opens /dev/lguest to tell the kernel about the Guest and</span>
<span class="p_del">- * control it.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-#define _LARGEFILE64_SOURCE</span>
<span class="p_del">-#define _GNU_SOURCE</span>
<span class="p_del">-#include &lt;stdio.h&gt;</span>
<span class="p_del">-#include &lt;string.h&gt;</span>
<span class="p_del">-#include &lt;unistd.h&gt;</span>
<span class="p_del">-#include &lt;err.h&gt;</span>
<span class="p_del">-#include &lt;stdint.h&gt;</span>
<span class="p_del">-#include &lt;stdlib.h&gt;</span>
<span class="p_del">-#include &lt;elf.h&gt;</span>
<span class="p_del">-#include &lt;sys/mman.h&gt;</span>
<span class="p_del">-#include &lt;sys/param.h&gt;</span>
<span class="p_del">-#include &lt;sys/types.h&gt;</span>
<span class="p_del">-#include &lt;sys/stat.h&gt;</span>
<span class="p_del">-#include &lt;sys/wait.h&gt;</span>
<span class="p_del">-#include &lt;sys/eventfd.h&gt;</span>
<span class="p_del">-#include &lt;fcntl.h&gt;</span>
<span class="p_del">-#include &lt;stdbool.h&gt;</span>
<span class="p_del">-#include &lt;errno.h&gt;</span>
<span class="p_del">-#include &lt;ctype.h&gt;</span>
<span class="p_del">-#include &lt;sys/socket.h&gt;</span>
<span class="p_del">-#include &lt;sys/ioctl.h&gt;</span>
<span class="p_del">-#include &lt;sys/time.h&gt;</span>
<span class="p_del">-#include &lt;time.h&gt;</span>
<span class="p_del">-#include &lt;netinet/in.h&gt;</span>
<span class="p_del">-#include &lt;net/if.h&gt;</span>
<span class="p_del">-#include &lt;linux/sockios.h&gt;</span>
<span class="p_del">-#include &lt;linux/if_tun.h&gt;</span>
<span class="p_del">-#include &lt;sys/uio.h&gt;</span>
<span class="p_del">-#include &lt;termios.h&gt;</span>
<span class="p_del">-#include &lt;getopt.h&gt;</span>
<span class="p_del">-#include &lt;assert.h&gt;</span>
<span class="p_del">-#include &lt;sched.h&gt;</span>
<span class="p_del">-#include &lt;limits.h&gt;</span>
<span class="p_del">-#include &lt;stddef.h&gt;</span>
<span class="p_del">-#include &lt;signal.h&gt;</span>
<span class="p_del">-#include &lt;pwd.h&gt;</span>
<span class="p_del">-#include &lt;grp.h&gt;</span>
<span class="p_del">-#include &lt;sys/user.h&gt;</span>
<span class="p_del">-#include &lt;linux/pci_regs.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef VIRTIO_F_ANY_LAYOUT</span>
<span class="p_del">-#define VIRTIO_F_ANY_LAYOUT		27</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:110</span>
<span class="p_del">- * We can ignore the 43 include files we need for this program, but I do want</span>
<span class="p_del">- * to draw attention to the use of kernel-style types.</span>
<span class="p_del">- *</span>
<span class="p_del">- * As Linus said, &quot;C is a Spartan language, and so should your naming be.&quot;  I</span>
<span class="p_del">- * like these abbreviations, so we define them here.  Note that u64 is always</span>
<span class="p_del">- * unsigned long long, which works on all Linux systems: this means that we can</span>
<span class="p_del">- * use %llu in printf for any u64.</span>
<span class="p_del">- */</span>
<span class="p_del">-typedef unsigned long long u64;</span>
<span class="p_del">-typedef uint32_t u32;</span>
<span class="p_del">-typedef uint16_t u16;</span>
<span class="p_del">-typedef uint8_t u8;</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-#define VIRTIO_CONFIG_NO_LEGACY</span>
<span class="p_del">-#define VIRTIO_PCI_NO_LEGACY</span>
<span class="p_del">-#define VIRTIO_BLK_NO_LEGACY</span>
<span class="p_del">-#define VIRTIO_NET_NO_LEGACY</span>
<span class="p_del">-</span>
<span class="p_del">-/* Use in-kernel ones, which defines VIRTIO_F_VERSION_1 */</span>
<span class="p_del">-#include &quot;../../include/uapi/linux/virtio_config.h&quot;</span>
<span class="p_del">-#include &quot;../../include/uapi/linux/virtio_net.h&quot;</span>
<span class="p_del">-#include &quot;../../include/uapi/linux/virtio_blk.h&quot;</span>
<span class="p_del">-#include &quot;../../include/uapi/linux/virtio_console.h&quot;</span>
<span class="p_del">-#include &quot;../../include/uapi/linux/virtio_rng.h&quot;</span>
<span class="p_del">-#include &lt;linux/virtio_ring.h&gt;</span>
<span class="p_del">-#include &quot;../../include/uapi/linux/virtio_pci.h&quot;</span>
<span class="p_del">-#include &lt;asm/bootparam.h&gt;</span>
<span class="p_del">-#include &quot;../../include/linux/lguest_launcher.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-#define BRIDGE_PFX &quot;bridge:&quot;</span>
<span class="p_del">-#ifndef SIOCBRADDIF</span>
<span class="p_del">-#define SIOCBRADDIF	0x89a2		/* add interface to bridge      */</span>
<span class="p_del">-#endif</span>
<span class="p_del">-/* We can have up to 256 pages for devices. */</span>
<span class="p_del">-#define DEVICE_PAGES 256</span>
<span class="p_del">-/* This will occupy 3 pages: it must be a power of 2. */</span>
<span class="p_del">-#define VIRTQUEUE_NUM 256</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:120</span>
<span class="p_del">- * verbose is both a global flag and a macro.  The C preprocessor allows</span>
<span class="p_del">- * this, and although I wouldn&#39;t recommend it, it works quite nicely here.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool verbose;</span>
<span class="p_del">-#define verbose(args...) \</span>
<span class="p_del">-	do { if (verbose) printf(args); } while(0)</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* The pointer to the start of guest memory. */</span>
<span class="p_del">-static void *guest_base;</span>
<span class="p_del">-/* The maximum guest physical address allowed, and maximum possible. */</span>
<span class="p_del">-static unsigned long guest_limit, guest_max, guest_mmio;</span>
<span class="p_del">-/* The /dev/lguest file descriptor. */</span>
<span class="p_del">-static int lguest_fd;</span>
<span class="p_del">-</span>
<span class="p_del">-/* a per-cpu variable indicating whose vcpu is currently running */</span>
<span class="p_del">-static unsigned int __thread cpu_id;</span>
<span class="p_del">-</span>
<span class="p_del">-/* 5 bit device number in the PCI_CONFIG_ADDR =&gt; 32 only */</span>
<span class="p_del">-#define MAX_PCI_DEVICES 32</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is our list of devices. */</span>
<span class="p_del">-struct device_list {</span>
<span class="p_del">-	/* Counter to assign interrupt numbers. */</span>
<span class="p_del">-	unsigned int next_irq;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Counter to print out convenient device numbers. */</span>
<span class="p_del">-	unsigned int device_num;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* PCI devices. */</span>
<span class="p_del">-	struct device *pci[MAX_PCI_DEVICES];</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* The list of Guest devices, based on command line arguments. */</span>
<span class="p_del">-static struct device_list devices;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Just like struct virtio_pci_cfg_cap in uapi/linux/virtio_pci.h,</span>
<span class="p_del">- * but uses a u32 explicitly for the data.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct virtio_pci_cfg_cap_u32 {</span>
<span class="p_del">-	struct virtio_pci_cap cap;</span>
<span class="p_del">-	u32 pci_cfg_data; /* Data for BAR access. */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct virtio_pci_mmio {</span>
<span class="p_del">-	struct virtio_pci_common_cfg cfg;</span>
<span class="p_del">-	u16 notify;</span>
<span class="p_del">-	u8 isr;</span>
<span class="p_del">-	u8 padding;</span>
<span class="p_del">-	/* Device-specific configuration follows this. */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the layout (little-endian) of the PCI config space. */</span>
<span class="p_del">-struct pci_config {</span>
<span class="p_del">-	u16 vendor_id, device_id;</span>
<span class="p_del">-	u16 command, status;</span>
<span class="p_del">-	u8 revid, prog_if, subclass, class;</span>
<span class="p_del">-	u8 cacheline_size, lat_timer, header_type, bist;</span>
<span class="p_del">-	u32 bar[6];</span>
<span class="p_del">-	u32 cardbus_cis_ptr;</span>
<span class="p_del">-	u16 subsystem_vendor_id, subsystem_device_id;</span>
<span class="p_del">-	u32 expansion_rom_addr;</span>
<span class="p_del">-	u8 capabilities, reserved1[3];</span>
<span class="p_del">-	u32 reserved2;</span>
<span class="p_del">-	u8 irq_line, irq_pin, min_grant, max_latency;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now, this is the linked capability list. */</span>
<span class="p_del">-	struct virtio_pci_cap common;</span>
<span class="p_del">-	struct virtio_pci_notify_cap notify;</span>
<span class="p_del">-	struct virtio_pci_cap isr;</span>
<span class="p_del">-	struct virtio_pci_cap device;</span>
<span class="p_del">-	struct virtio_pci_cfg_cap_u32 cfg_access;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* The device structure describes a single device. */</span>
<span class="p_del">-struct device {</span>
<span class="p_del">-	/* The name of this device, for --verbose. */</span>
<span class="p_del">-	const char *name;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Any queues attached to this device */</span>
<span class="p_del">-	struct virtqueue *vq;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Is it operational */</span>
<span class="p_del">-	bool running;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Has it written FEATURES_OK but not re-checked it? */</span>
<span class="p_del">-	bool wrote_features_ok;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* PCI configuration */</span>
<span class="p_del">-	union {</span>
<span class="p_del">-		struct pci_config config;</span>
<span class="p_del">-		u32 config_words[sizeof(struct pci_config) / sizeof(u32)];</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Features we offer, and those accepted. */</span>
<span class="p_del">-	u64 features, features_accepted;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Device-specific config hangs off the end of this. */</span>
<span class="p_del">-	struct virtio_pci_mmio *mmio;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* PCI MMIO resources (all in BAR0) */</span>
<span class="p_del">-	size_t mmio_size;</span>
<span class="p_del">-	u32 mmio_addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Device-specific data. */</span>
<span class="p_del">-	void *priv;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* The virtqueue structure describes a queue attached to a device. */</span>
<span class="p_del">-struct virtqueue {</span>
<span class="p_del">-	struct virtqueue *next;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Which device owns me. */</span>
<span class="p_del">-	struct device *dev;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Name for printing errors. */</span>
<span class="p_del">-	const char *name;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The actual ring of buffers. */</span>
<span class="p_del">-	struct vring vring;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The information about this virtqueue (we only use queue_size on) */</span>
<span class="p_del">-	struct virtio_pci_common_cfg pci_config;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Last available index we saw. */</span>
<span class="p_del">-	u16 last_avail_idx;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* How many are used since we sent last irq? */</span>
<span class="p_del">-	unsigned int pending_used;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Eventfd where Guest notifications arrive. */</span>
<span class="p_del">-	int eventfd;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Function for the thread which is servicing this virtqueue. */</span>
<span class="p_del">-	void (*service)(struct virtqueue *vq);</span>
<span class="p_del">-	pid_t thread;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* Remember the arguments to the program so we can &quot;reboot&quot; */</span>
<span class="p_del">-static char **main_args;</span>
<span class="p_del">-</span>
<span class="p_del">-/* The original tty settings to restore on exit. */</span>
<span class="p_del">-static struct termios orig_term;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We have to be careful with barriers: our devices are all run in separate</span>
<span class="p_del">- * threads and so we need to make sure that changes visible to the Guest happen</span>
<span class="p_del">- * in precise order.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define wmb() __asm__ __volatile__(&quot;&quot; : : : &quot;memory&quot;)</span>
<span class="p_del">-#define rmb() __asm__ __volatile__(&quot;lock; addl $0,0(%%esp)&quot; : : : &quot;memory&quot;)</span>
<span class="p_del">-#define mb() __asm__ __volatile__(&quot;lock; addl $0,0(%%esp)&quot; : : : &quot;memory&quot;)</span>
<span class="p_del">-</span>
<span class="p_del">-/* Wrapper for the last available index.  Makes it easier to change. */</span>
<span class="p_del">-#define lg_last_avail(vq)	((vq)-&gt;last_avail_idx)</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The virtio configuration space is defined to be little-endian.  x86 is</span>
<span class="p_del">- * little-endian too, but it&#39;s nice to be explicit so we have these helpers.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define cpu_to_le16(v16) (v16)</span>
<span class="p_del">-#define cpu_to_le32(v32) (v32)</span>
<span class="p_del">-#define cpu_to_le64(v64) (v64)</span>
<span class="p_del">-#define le16_to_cpu(v16) (v16)</span>
<span class="p_del">-#define le32_to_cpu(v32) (v32)</span>
<span class="p_del">-#define le64_to_cpu(v64) (v64)</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * A real device would ignore weird/non-compliant driver behaviour.  We</span>
<span class="p_del">- * stop and flag it, to help debugging Linux problems.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define bad_driver(d, fmt, ...) \</span>
<span class="p_del">-	errx(1, &quot;%s: bad driver: &quot; fmt, (d)-&gt;name, ## __VA_ARGS__)</span>
<span class="p_del">-#define bad_driver_vq(vq, fmt, ...)			       \</span>
<span class="p_del">-	errx(1, &quot;%s vq %s: bad driver: &quot; fmt, (vq)-&gt;dev-&gt;name, \</span>
<span class="p_del">-	     vq-&gt;name, ## __VA_ARGS__)</span>
<span class="p_del">-</span>
<span class="p_del">-/* Is this iovec empty? */</span>
<span class="p_del">-static bool iov_empty(const struct iovec iov[], unsigned int num_iov)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_iov; i++)</span>
<span class="p_del">-		if (iov[i].iov_len)</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Take len bytes from the front of this iovec. */</span>
<span class="p_del">-static void iov_consume(struct device *d,</span>
<span class="p_del">-			struct iovec iov[], unsigned num_iov,</span>
<span class="p_del">-			void *dest, unsigned len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_iov; i++) {</span>
<span class="p_del">-		unsigned int used;</span>
<span class="p_del">-</span>
<span class="p_del">-		used = iov[i].iov_len &lt; len ? iov[i].iov_len : len;</span>
<span class="p_del">-		if (dest) {</span>
<span class="p_del">-			memcpy(dest, iov[i].iov_base, used);</span>
<span class="p_del">-			dest += used;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		iov[i].iov_base += used;</span>
<span class="p_del">-		iov[i].iov_len -= used;</span>
<span class="p_del">-		len -= used;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (len != 0)</span>
<span class="p_del">-		bad_driver(d, &quot;iovec too short!&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:100</span>
<span class="p_del">- * The Launcher code itself takes us out into userspace, that scary place where</span>
<span class="p_del">- * pointers run wild and free!  Unfortunately, like most userspace programs,</span>
<span class="p_del">- * it&#39;s quite boring (which is why everyone likes to hack on the kernel!).</span>
<span class="p_del">- * Perhaps if you make up an Lguest Drinking Game at this point, it will get</span>
<span class="p_del">- * you through this section.  Or, maybe not.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The Launcher sets up a big chunk of memory to be the Guest&#39;s &quot;physical&quot;</span>
<span class="p_del">- * memory and stores it in &quot;guest_base&quot;.  In other words, Guest physical ==</span>
<span class="p_del">- * Launcher virtual with an offset.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This can be tough to get your head around, but usually it just means that we</span>
<span class="p_del">- * use these trivial conversion functions when the Guest gives us its</span>
<span class="p_del">- * &quot;physical&quot; addresses:</span>
<span class="p_del">- */</span>
<span class="p_del">-static void *from_guest_phys(unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return guest_base + addr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned long to_guest_phys(const void *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (addr - guest_base);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:130</span>
<span class="p_del">- * Loading the Kernel.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We start with couple of simple helper routines.  open_or_die() avoids</span>
<span class="p_del">- * error-checking code cluttering the callers:</span>
<span class="p_del">- */</span>
<span class="p_del">-static int open_or_die(const char *name, int flags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int fd = open(name, flags);</span>
<span class="p_del">-	if (fd &lt; 0)</span>
<span class="p_del">-		err(1, &quot;Failed to open %s&quot;, name);</span>
<span class="p_del">-	return fd;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* map_zeroed_pages() takes a number of pages. */</span>
<span class="p_del">-static void *map_zeroed_pages(unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int fd = open_or_die(&quot;/dev/zero&quot;, O_RDONLY);</span>
<span class="p_del">-	void *addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We use a private mapping (ie. if we write to the page, it will be</span>
<span class="p_del">-	 * copied). We allocate an extra two pages PROT_NONE to act as guard</span>
<span class="p_del">-	 * pages against read/write attempts that exceed allocated space.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	addr = mmap(NULL, getpagesize() * (num+2),</span>
<span class="p_del">-		    PROT_NONE, MAP_PRIVATE, fd, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (addr == MAP_FAILED)</span>
<span class="p_del">-		err(1, &quot;Mmapping %u pages of /dev/zero&quot;, num);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mprotect(addr + getpagesize(), getpagesize() * num,</span>
<span class="p_del">-		     PROT_READ|PROT_WRITE) == -1)</span>
<span class="p_del">-		err(1, &quot;mprotect rw %u pages failed&quot;, num);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * One neat mmap feature is that you can close the fd, and it</span>
<span class="p_del">-	 * stays mapped.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	close(fd);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Return address after PROT_NONE page */</span>
<span class="p_del">-	return addr + getpagesize();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Get some bytes which won&#39;t be mapped into the guest. */</span>
<span class="p_del">-static unsigned long get_mmio_region(size_t size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long addr = guest_mmio;</span>
<span class="p_del">-	size_t i;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!size)</span>
<span class="p_del">-		return addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Size has to be a power of 2 (and multiple of 16) */</span>
<span class="p_del">-	for (i = 1; i &lt; size; i &lt;&lt;= 1);</span>
<span class="p_del">-</span>
<span class="p_del">-	guest_mmio += i;</span>
<span class="p_del">-</span>
<span class="p_del">-	return addr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine is used to load the kernel or initrd.  It tries mmap, but if</span>
<span class="p_del">- * that fails (Plan 9&#39;s kernel file isn&#39;t nicely aligned on page boundaries),</span>
<span class="p_del">- * it falls back to reading the memory in.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void map_at(int fd, void *addr, unsigned long offset, unsigned long len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ssize_t r;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We map writable even though for some segments are marked read-only.</span>
<span class="p_del">-	 * The kernel really wants to be writable: it patches its own</span>
<span class="p_del">-	 * instructions.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * MAP_PRIVATE means that the page won&#39;t be copied until a write is</span>
<span class="p_del">-	 * done to it.  This allows us to share untouched memory between</span>
<span class="p_del">-	 * Guests.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mmap(addr, len, PROT_READ|PROT_WRITE,</span>
<span class="p_del">-		 MAP_FIXED|MAP_PRIVATE, fd, offset) != MAP_FAILED)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* pread does a seek and a read in one shot: saves a few lines. */</span>
<span class="p_del">-	r = pread(fd, addr, len, offset);</span>
<span class="p_del">-	if (r != len)</span>
<span class="p_del">-		err(1, &quot;Reading offset %lu len %lu gave %zi&quot;, offset, len, r);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine takes an open vmlinux image, which is in ELF, and maps it into</span>
<span class="p_del">- * the Guest memory.  ELF = Embedded Linking Format, which is the format used</span>
<span class="p_del">- * by all modern binaries on Linux including the kernel.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The ELF headers give *two* addresses: a physical address, and a virtual</span>
<span class="p_del">- * address.  We use the physical address; the Guest will map itself to the</span>
<span class="p_del">- * virtual address.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We return the starting address.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long map_elf(int elf_fd, const Elf32_Ehdr *ehdr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	Elf32_Phdr phdr[ehdr-&gt;e_phnum];</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Sanity checks on the main ELF header: an x86 executable with a</span>
<span class="p_del">-	 * reasonable number of correctly-sized program headers.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ehdr-&gt;e_type != ET_EXEC</span>
<span class="p_del">-	    || ehdr-&gt;e_machine != EM_386</span>
<span class="p_del">-	    || ehdr-&gt;e_phentsize != sizeof(Elf32_Phdr)</span>
<span class="p_del">-	    || ehdr-&gt;e_phnum &lt; 1 || ehdr-&gt;e_phnum &gt; 65536U/sizeof(Elf32_Phdr))</span>
<span class="p_del">-		errx(1, &quot;Malformed elf header&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * An ELF executable contains an ELF header and a number of &quot;program&quot;</span>
<span class="p_del">-	 * headers which indicate which parts (&quot;segments&quot;) of the program to</span>
<span class="p_del">-	 * load where.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We read in all the program headers at once: */</span>
<span class="p_del">-	if (lseek(elf_fd, ehdr-&gt;e_phoff, SEEK_SET) &lt; 0)</span>
<span class="p_del">-		err(1, &quot;Seeking to program headers&quot;);</span>
<span class="p_del">-	if (read(elf_fd, phdr, sizeof(phdr)) != sizeof(phdr))</span>
<span class="p_del">-		err(1, &quot;Reading program headers&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Try all the headers: there are usually only three.  A read-only one,</span>
<span class="p_del">-	 * a read-write one, and a &quot;note&quot; section which we don&#39;t load.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 0; i &lt; ehdr-&gt;e_phnum; i++) {</span>
<span class="p_del">-		/* If this isn&#39;t a loadable segment, we ignore it */</span>
<span class="p_del">-		if (phdr[i].p_type != PT_LOAD)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		verbose(&quot;Section %i: size %i addr %p\n&quot;,</span>
<span class="p_del">-			i, phdr[i].p_memsz, (void *)phdr[i].p_paddr);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* We map this section of the file at its physical address. */</span>
<span class="p_del">-		map_at(elf_fd, from_guest_phys(phdr[i].p_paddr),</span>
<span class="p_del">-		       phdr[i].p_offset, phdr[i].p_filesz);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The entry point is given in the ELF header. */</span>
<span class="p_del">-	return ehdr-&gt;e_entry;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:150</span>
<span class="p_del">- * A bzImage, unlike an ELF file, is not meant to be loaded.  You&#39;re supposed</span>
<span class="p_del">- * to jump into it and it will unpack itself.  We used to have to perform some</span>
<span class="p_del">- * hairy magic because the unpacking code scared me.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Fortunately, Jeremy Fitzhardinge convinced me it wasn&#39;t that hard and wrote</span>
<span class="p_del">- * a small patch to jump over the tricky bits in the Guest, so now we just read</span>
<span class="p_del">- * the funky header so we know where in the file to load, and away we go!</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long load_bzimage(int fd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct boot_params boot;</span>
<span class="p_del">-	int r;</span>
<span class="p_del">-	/* Modern bzImages get loaded at 1M. */</span>
<span class="p_del">-	void *p = from_guest_phys(0x100000);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Go back to the start of the file and read the header.  It should be</span>
<span class="p_del">-	 * a Linux boot header (see Documentation/x86/boot.txt)</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	lseek(fd, 0, SEEK_SET);</span>
<span class="p_del">-	read(fd, &amp;boot, sizeof(boot));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Inside the setup_hdr, we expect the magic &quot;HdrS&quot; */</span>
<span class="p_del">-	if (memcmp(&amp;boot.hdr.header, &quot;HdrS&quot;, 4) != 0)</span>
<span class="p_del">-		errx(1, &quot;This doesn&#39;t look like a bzImage to me&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Skip over the extra sectors of the header. */</span>
<span class="p_del">-	lseek(fd, (boot.hdr.setup_sects+1) * 512, SEEK_SET);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now read everything into memory. in nice big chunks. */</span>
<span class="p_del">-	while ((r = read(fd, p, 65536)) &gt; 0)</span>
<span class="p_del">-		p += r;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Finally, code32_start tells us where to enter the kernel. */</span>
<span class="p_del">-	return boot.hdr.code32_start;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:140</span>
<span class="p_del">- * Loading the kernel is easy when it&#39;s a &quot;vmlinux&quot;, but most kernels</span>
<span class="p_del">- * come wrapped up in the self-decompressing &quot;bzImage&quot; format.  With a little</span>
<span class="p_del">- * work, we can load those, too.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long load_kernel(int fd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	Elf32_Ehdr hdr;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Read in the first few bytes. */</span>
<span class="p_del">-	if (read(fd, &amp;hdr, sizeof(hdr)) != sizeof(hdr))</span>
<span class="p_del">-		err(1, &quot;Reading kernel&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If it&#39;s an ELF file, it starts with &quot;\177ELF&quot; */</span>
<span class="p_del">-	if (memcmp(hdr.e_ident, ELFMAG, SELFMAG) == 0)</span>
<span class="p_del">-		return map_elf(fd, &amp;hdr);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Otherwise we assume it&#39;s a bzImage, and try to load it. */</span>
<span class="p_del">-	return load_bzimage(fd);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is a trivial little helper to align pages.  Andi Kleen hated it because</span>
<span class="p_del">- * it calls getpagesize() twice: &quot;it&#39;s dumb code.&quot;</span>
<span class="p_del">- *</span>
<span class="p_del">- * Kernel guys get really het up about optimization, even when it&#39;s not</span>
<span class="p_del">- * necessary.  I leave this code as a reaction against that.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline unsigned long page_align(unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Add upwards and truncate downwards. */</span>
<span class="p_del">-	return ((addr + getpagesize()-1) &amp; ~(getpagesize()-1));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:180</span>
<span class="p_del">- * An &quot;initial ram disk&quot; is a disk image loaded into memory along with the</span>
<span class="p_del">- * kernel which the kernel can use to boot from without needing any drivers.</span>
<span class="p_del">- * Most distributions now use this as standard: the initrd contains the code to</span>
<span class="p_del">- * load the appropriate driver modules for the current machine.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Importantly, James Morris works for RedHat, and Fedora uses initrds for its</span>
<span class="p_del">- * kernels.  He sent me this (and tells me when I break it).</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned long load_initrd(const char *name, unsigned long mem)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ifd;</span>
<span class="p_del">-	struct stat st;</span>
<span class="p_del">-	unsigned long len;</span>
<span class="p_del">-</span>
<span class="p_del">-	ifd = open_or_die(name, O_RDONLY);</span>
<span class="p_del">-	/* fstat() is needed to get the file size. */</span>
<span class="p_del">-	if (fstat(ifd, &amp;st) &lt; 0)</span>
<span class="p_del">-		err(1, &quot;fstat() on initrd &#39;%s&#39;&quot;, name);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We map the initrd at the top of memory, but mmap wants it to be</span>
<span class="p_del">-	 * page-aligned, so we round the size up for that.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	len = page_align(st.st_size);</span>
<span class="p_del">-	map_at(ifd, from_guest_phys(mem - len), 0, st.st_size);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Once a file is mapped, you can close the file descriptor.  It&#39;s a</span>
<span class="p_del">-	 * little odd, but quite useful.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	close(ifd);</span>
<span class="p_del">-	verbose(&quot;mapped initrd %s size=%lu @ %p\n&quot;, name, len, (void*)mem-len);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We return the initrd size. */</span>
<span class="p_del">-	return len;</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Simple routine to roll all the commandline arguments together with spaces</span>
<span class="p_del">- * between them.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void concat(char *dst, char *args[])</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i, len = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; args[i]; i++) {</span>
<span class="p_del">-		if (i) {</span>
<span class="p_del">-			strcat(dst+len, &quot; &quot;);</span>
<span class="p_del">-			len++;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		strcpy(dst+len, args[i]);</span>
<span class="p_del">-		len += strlen(args[i]);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* In case it&#39;s empty. */</span>
<span class="p_del">-	dst[len] = &#39;\0&#39;;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:185</span>
<span class="p_del">- * This is where we actually tell the kernel to initialize the Guest.  We</span>
<span class="p_del">- * saw the arguments it expects when we looked at initialize() in lguest_user.c:</span>
<span class="p_del">- * the base of Guest &quot;physical&quot; memory, the top physical page to allow and the</span>
<span class="p_del">- * entry point for the Guest.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void tell_kernel(unsigned long start)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long args[] = { LHREQ_INITIALIZE,</span>
<span class="p_del">-				 (unsigned long)guest_base,</span>
<span class="p_del">-				 guest_limit / getpagesize(), start,</span>
<span class="p_del">-				 (guest_mmio+getpagesize()-1) / getpagesize() };</span>
<span class="p_del">-	verbose(&quot;Guest: %p - %p (%#lx, MMIO %#lx)\n&quot;,</span>
<span class="p_del">-		guest_base, guest_base + guest_limit,</span>
<span class="p_del">-		guest_limit, guest_mmio);</span>
<span class="p_del">-	lguest_fd = open_or_die(&quot;/dev/lguest&quot;, O_RDWR);</span>
<span class="p_del">-	if (write(lguest_fd, args, sizeof(args)) &lt; 0)</span>
<span class="p_del">-		err(1, &quot;Writing to /dev/lguest&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:200</span>
<span class="p_del">- * Device Handling.</span>
<span class="p_del">- *</span>
<span class="p_del">- * When the Guest gives us a buffer, it sends an array of addresses and sizes.</span>
<span class="p_del">- * We need to make sure it&#39;s not trying to reach into the Launcher itself, so</span>
<span class="p_del">- * we have a convenient routine which checks it and exits with an error message</span>
<span class="p_del">- * if something funny is going on:</span>
<span class="p_del">- */</span>
<span class="p_del">-static void *_check_pointer(struct device *d,</span>
<span class="p_del">-			    unsigned long addr, unsigned int size,</span>
<span class="p_del">-			    unsigned int line)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Check if the requested address and size exceeds the allocated memory,</span>
<span class="p_del">-	 * or addr + size wraps around.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((addr + size) &gt; guest_limit || (addr + size) &lt; addr)</span>
<span class="p_del">-		bad_driver(d, &quot;%s:%i: Invalid address %#lx&quot;,</span>
<span class="p_del">-			   __FILE__, line, addr);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We return a pointer for the caller&#39;s convenience, now we know it&#39;s</span>
<span class="p_del">-	 * safe to use.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return from_guest_phys(addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-/* A macro which transparently hands the line number to the real function. */</span>
<span class="p_del">-#define check_pointer(d,addr,size) _check_pointer(d, addr, size, __LINE__)</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Each buffer in the virtqueues is actually a chain of descriptors.  This</span>
<span class="p_del">- * function returns the next descriptor in the chain, or vq-&gt;vring.num if we&#39;re</span>
<span class="p_del">- * at the end.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned next_desc(struct device *d, struct vring_desc *desc,</span>
<span class="p_del">-			  unsigned int i, unsigned int max)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int next;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If this descriptor says it doesn&#39;t chain, we&#39;re done. */</span>
<span class="p_del">-	if (!(desc[i].flags &amp; VRING_DESC_F_NEXT))</span>
<span class="p_del">-		return max;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check they&#39;re not leading us off end of descriptors. */</span>
<span class="p_del">-	next = desc[i].next;</span>
<span class="p_del">-	/* Make sure compiler knows to grab that: we don&#39;t want it changing! */</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (next &gt;= max)</span>
<span class="p_del">-		bad_driver(d, &quot;Desc next is %u&quot;, next);</span>
<span class="p_del">-</span>
<span class="p_del">-	return next;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This actually sends the interrupt for this virtqueue, if we&#39;ve used a</span>
<span class="p_del">- * buffer.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void trigger_irq(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long buf[] = { LHREQ_IRQ, vq-&gt;dev-&gt;config.irq_line };</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Don&#39;t inform them if nothing used. */</span>
<span class="p_del">-	if (!vq-&gt;pending_used)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	vq-&gt;pending_used = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 2.4.7.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  If the VIRTIO_F_EVENT_IDX feature bit is not negotiated:</span>
<span class="p_del">-	 *    The driver MUST set flags to 0 or 1. </span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (vq-&gt;vring.avail-&gt;flags &gt; 1)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;avail-&gt;flags = %u\n&quot;, vq-&gt;vring.avail-&gt;flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 2.4.7.2:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  If the VIRTIO_F_EVENT_IDX feature bit is not negotiated:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *     - The device MUST ignore the used_event value.</span>
<span class="p_del">-	 *     - After the device writes a descriptor index into the used ring:</span>
<span class="p_del">-	 *         - If flags is 1, the device SHOULD NOT send an interrupt.</span>
<span class="p_del">-	 *         - If flags is 0, the device MUST send an interrupt.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (vq-&gt;vring.avail-&gt;flags &amp; VRING_AVAIL_F_NO_INTERRUPT) {</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.5.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  If MSI-X capability is disabled, the device MUST set the Queue</span>
<span class="p_del">-	 *  Interrupt bit in ISR status before sending a virtqueue notification</span>
<span class="p_del">-	 *  to the driver.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	vq-&gt;dev-&gt;mmio-&gt;isr = 0x1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Send the Guest an interrupt tell them we used something up. */</span>
<span class="p_del">-	if (write(lguest_fd, buf, sizeof(buf)) != 0)</span>
<span class="p_del">-		err(1, &quot;Triggering irq %i&quot;, vq-&gt;dev-&gt;config.irq_line);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This looks in the virtqueue for the first available buffer, and converts</span>
<span class="p_del">- * it to an iovec for convenient access.  Since descriptors consist of some</span>
<span class="p_del">- * number of output then some number of input descriptors, it&#39;s actually two</span>
<span class="p_del">- * iovecs, but we pack them into one and note how many of each there were.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This function waits if necessary, and returns the descriptor number found.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned wait_for_vq_desc(struct virtqueue *vq,</span>
<span class="p_del">-				 struct iovec iov[],</span>
<span class="p_del">-				 unsigned int *out_num, unsigned int *in_num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i, head, max;</span>
<span class="p_del">-	struct vring_desc *desc;</span>
<span class="p_del">-	u16 last_avail = lg_last_avail(vq);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 2.4.7.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *   The driver MUST handle spurious interrupts from the device.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * That&#39;s why this is a while loop.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* There&#39;s nothing available? */</span>
<span class="p_del">-	while (last_avail == vq-&gt;vring.avail-&gt;idx) {</span>
<span class="p_del">-		u64 event;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Since we&#39;re about to sleep, now is a good time to tell the</span>
<span class="p_del">-		 * Guest about what we&#39;ve used up to now.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		trigger_irq(vq);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* OK, now we need to know about added descriptors. */</span>
<span class="p_del">-		vq-&gt;vring.used-&gt;flags &amp;= ~VRING_USED_F_NO_NOTIFY;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * They could have slipped one in as we were doing that: make</span>
<span class="p_del">-		 * sure it&#39;s written, then check again.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		mb();</span>
<span class="p_del">-		if (last_avail != vq-&gt;vring.avail-&gt;idx) {</span>
<span class="p_del">-			vq-&gt;vring.used-&gt;flags |= VRING_USED_F_NO_NOTIFY;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Nothing new?  Wait for eventfd to tell us they refilled. */</span>
<span class="p_del">-		if (read(vq-&gt;eventfd, &amp;event, sizeof(event)) != sizeof(event))</span>
<span class="p_del">-			errx(1, &quot;Event read failed?&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* We don&#39;t need to be notified again. */</span>
<span class="p_del">-		vq-&gt;vring.used-&gt;flags |= VRING_USED_F_NO_NOTIFY;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check it isn&#39;t doing very strange things with descriptor numbers. */</span>
<span class="p_del">-	if ((u16)(vq-&gt;vring.avail-&gt;idx - last_avail) &gt; vq-&gt;vring.num)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Guest moved used index from %u to %u&quot;,</span>
<span class="p_del">-			      last_avail, vq-&gt;vring.avail-&gt;idx);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* </span>
<span class="p_del">-	 * Make sure we read the descriptor number *after* we read the ring</span>
<span class="p_del">-	 * update; don&#39;t let the cpu or compiler change the order.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	rmb();</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Grab the next descriptor number they&#39;re advertising, and increment</span>
<span class="p_del">-	 * the index we&#39;ve seen.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	head = vq-&gt;vring.avail-&gt;ring[last_avail % vq-&gt;vring.num];</span>
<span class="p_del">-	lg_last_avail(vq)++;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If their number is silly, that&#39;s a fatal mistake. */</span>
<span class="p_del">-	if (head &gt;= vq-&gt;vring.num)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Guest says index %u is available&quot;, head);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* When we start there are none of either input nor output. */</span>
<span class="p_del">-	*out_num = *in_num = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	max = vq-&gt;vring.num;</span>
<span class="p_del">-	desc = vq-&gt;vring.desc;</span>
<span class="p_del">-	i = head;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We have to read the descriptor after we read the descriptor number,</span>
<span class="p_del">-	 * but there&#39;s a data dependency there so the CPU shouldn&#39;t reorder</span>
<span class="p_del">-	 * that: no rmb() required.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If this is an indirect entry, then this buffer contains a</span>
<span class="p_del">-		 * descriptor table which we handle as if it&#39;s any normal</span>
<span class="p_del">-		 * descriptor chain.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (desc[i].flags &amp; VRING_DESC_F_INDIRECT) {</span>
<span class="p_del">-			/* 2.4.5.3.1:</span>
<span class="p_del">-			 *</span>
<span class="p_del">-			 *  The driver MUST NOT set the VIRTQ_DESC_F_INDIRECT</span>
<span class="p_del">-			 *  flag unless the VIRTIO_F_INDIRECT_DESC feature was</span>
<span class="p_del">-			 *  negotiated.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (!(vq-&gt;dev-&gt;features_accepted &amp;</span>
<span class="p_del">-			      (1&lt;&lt;VIRTIO_RING_F_INDIRECT_DESC)))</span>
<span class="p_del">-				bad_driver_vq(vq, &quot;vq indirect not negotiated&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * 2.4.5.3.1:</span>
<span class="p_del">-			 *</span>
<span class="p_del">-			 *   The driver MUST NOT set the VIRTQ_DESC_F_INDIRECT</span>
<span class="p_del">-			 *   flag within an indirect descriptor (ie. only one</span>
<span class="p_del">-			 *   table per descriptor).</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (desc != vq-&gt;vring.desc)</span>
<span class="p_del">-				bad_driver_vq(vq, &quot;Indirect within indirect&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Proposed update VIRTIO-134 spells this out:</span>
<span class="p_del">-			 *</span>
<span class="p_del">-			 *   A driver MUST NOT set both VIRTQ_DESC_F_INDIRECT</span>
<span class="p_del">-			 *   and VIRTQ_DESC_F_NEXT in flags.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (desc[i].flags &amp; VRING_DESC_F_NEXT)</span>
<span class="p_del">-				bad_driver_vq(vq, &quot;indirect and next together&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (desc[i].len % sizeof(struct vring_desc))</span>
<span class="p_del">-				bad_driver_vq(vq,</span>
<span class="p_del">-					      &quot;Invalid size for indirect table&quot;);</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * 2.4.5.3.2:</span>
<span class="p_del">-			 *</span>
<span class="p_del">-			 *  The device MUST ignore the write-only flag</span>
<span class="p_del">-			 *  (flags&amp;VIRTQ_DESC_F_WRITE) in the descriptor that</span>
<span class="p_del">-			 *  refers to an indirect table.</span>
<span class="p_del">-			 *</span>
<span class="p_del">-			 * We ignore it here: :)</span>
<span class="p_del">-			 */</span>
<span class="p_del">-</span>
<span class="p_del">-			max = desc[i].len / sizeof(struct vring_desc);</span>
<span class="p_del">-			desc = check_pointer(vq-&gt;dev, desc[i].addr, desc[i].len);</span>
<span class="p_del">-			i = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-			/* 2.4.5.3.1:</span>
<span class="p_del">-			 *</span>
<span class="p_del">-			 *  A driver MUST NOT create a descriptor chain longer</span>
<span class="p_del">-			 *  than the Queue Size of the device.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (max &gt; vq-&gt;pci_config.queue_size)</span>
<span class="p_del">-				bad_driver_vq(vq,</span>
<span class="p_del">-					      &quot;indirect has too many entries&quot;);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Grab the first descriptor, and check it&#39;s OK. */</span>
<span class="p_del">-		iov[*out_num + *in_num].iov_len = desc[i].len;</span>
<span class="p_del">-		iov[*out_num + *in_num].iov_base</span>
<span class="p_del">-			= check_pointer(vq-&gt;dev, desc[i].addr, desc[i].len);</span>
<span class="p_del">-		/* If this is an input descriptor, increment that count. */</span>
<span class="p_del">-		if (desc[i].flags &amp; VRING_DESC_F_WRITE)</span>
<span class="p_del">-			(*in_num)++;</span>
<span class="p_del">-		else {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * If it&#39;s an output descriptor, they&#39;re all supposed</span>
<span class="p_del">-			 * to come before any input descriptors.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (*in_num)</span>
<span class="p_del">-				bad_driver_vq(vq,</span>
<span class="p_del">-					      &quot;Descriptor has out after in&quot;);</span>
<span class="p_del">-			(*out_num)++;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* If we&#39;ve got too many, that implies a descriptor loop. */</span>
<span class="p_del">-		if (*out_num + *in_num &gt; max)</span>
<span class="p_del">-			bad_driver_vq(vq, &quot;Looped descriptor&quot;);</span>
<span class="p_del">-	} while ((i = next_desc(vq-&gt;dev, desc, i, max)) != max);</span>
<span class="p_del">-</span>
<span class="p_del">-	return head;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * After we&#39;ve used one of their buffers, we tell the Guest about it.  Sometime</span>
<span class="p_del">- * later we&#39;ll want to send them an interrupt using trigger_irq(); note that</span>
<span class="p_del">- * wait_for_vq_desc() does that for us if it has to wait.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void add_used(struct virtqueue *vq, unsigned int head, int len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct vring_used_elem *used;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The virtqueue contains a ring of used buffers.  Get a pointer to the</span>
<span class="p_del">-	 * next entry in that used ring.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	used = &amp;vq-&gt;vring.used-&gt;ring[vq-&gt;vring.used-&gt;idx % vq-&gt;vring.num];</span>
<span class="p_del">-	used-&gt;id = head;</span>
<span class="p_del">-	used-&gt;len = len;</span>
<span class="p_del">-	/* Make sure buffer is written before we update index. */</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-	vq-&gt;vring.used-&gt;idx++;</span>
<span class="p_del">-	vq-&gt;pending_used++;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* And here&#39;s the combo meal deal.  Supersize me! */</span>
<span class="p_del">-static void add_used_and_trigger(struct virtqueue *vq, unsigned head, int len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	add_used(vq, head, len);</span>
<span class="p_del">-	trigger_irq(vq);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Console</span>
<span class="p_del">- *</span>
<span class="p_del">- * We associate some data with the console for our exit hack.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct console_abort {</span>
<span class="p_del">-	/* How many times have they hit ^C? */</span>
<span class="p_del">-	int count;</span>
<span class="p_del">-	/* When did they start? */</span>
<span class="p_del">-	struct timeval start;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the routine which handles console input (ie. stdin). */</span>
<span class="p_del">-static void console_input(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int len;</span>
<span class="p_del">-	unsigned int head, in_num, out_num;</span>
<span class="p_del">-	struct console_abort *abort = vq-&gt;dev-&gt;priv;</span>
<span class="p_del">-	struct iovec iov[vq-&gt;vring.num];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Make sure there&#39;s a descriptor available. */</span>
<span class="p_del">-	head = wait_for_vq_desc(vq, iov, &amp;out_num, &amp;in_num);</span>
<span class="p_del">-	if (out_num)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Output buffers in console in queue?&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Read into it.  This is where we usually wait. */</span>
<span class="p_del">-	len = readv(STDIN_FILENO, iov, in_num);</span>
<span class="p_del">-	if (len &lt;= 0) {</span>
<span class="p_del">-		/* Ran out of input? */</span>
<span class="p_del">-		warnx(&quot;Failed to get console input, ignoring console.&quot;);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * For simplicity, dying threads kill the whole Launcher.  So</span>
<span class="p_del">-		 * just nap here.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		for (;;)</span>
<span class="p_del">-			pause();</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Tell the Guest we used a buffer. */</span>
<span class="p_del">-	add_used_and_trigger(vq, head, len);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Three ^C within one second?  Exit.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * This is such a hack, but works surprisingly well.  Each ^C has to</span>
<span class="p_del">-	 * be in a buffer by itself, so they can&#39;t be too fast.  But we check</span>
<span class="p_del">-	 * that we get three within about a second, so they can&#39;t be too</span>
<span class="p_del">-	 * slow.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (len != 1 || ((char *)iov[0].iov_base)[0] != 3) {</span>
<span class="p_del">-		abort-&gt;count = 0;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	abort-&gt;count++;</span>
<span class="p_del">-	if (abort-&gt;count == 1)</span>
<span class="p_del">-		gettimeofday(&amp;abort-&gt;start, NULL);</span>
<span class="p_del">-	else if (abort-&gt;count == 3) {</span>
<span class="p_del">-		struct timeval now;</span>
<span class="p_del">-		gettimeofday(&amp;now, NULL);</span>
<span class="p_del">-		/* Kill all Launcher processes with SIGINT, like normal ^C */</span>
<span class="p_del">-		if (now.tv_sec &lt;= abort-&gt;start.tv_sec+1)</span>
<span class="p_del">-			kill(0, SIGINT);</span>
<span class="p_del">-		abort-&gt;count = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the routine which handles console output (ie. stdout). */</span>
<span class="p_del">-static void console_output(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int head, out, in;</span>
<span class="p_del">-	struct iovec iov[vq-&gt;vring.num];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We usually wait in here, for the Guest to give us something. */</span>
<span class="p_del">-	head = wait_for_vq_desc(vq, iov, &amp;out, &amp;in);</span>
<span class="p_del">-	if (in)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Input buffers in console output queue?&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* writev can return a partial write, so we loop here. */</span>
<span class="p_del">-	while (!iov_empty(iov, out)) {</span>
<span class="p_del">-		int len = writev(STDOUT_FILENO, iov, out);</span>
<span class="p_del">-		if (len &lt;= 0) {</span>
<span class="p_del">-			warn(&quot;Write to stdout gave %i (%d)&quot;, len, errno);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		iov_consume(vq-&gt;dev, iov, out, NULL, len);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We&#39;re finished with that buffer: if we&#39;re going to sleep,</span>
<span class="p_del">-	 * wait_for_vq_desc() will prod the Guest with an interrupt.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	add_used(vq, head, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * The Network</span>
<span class="p_del">- *</span>
<span class="p_del">- * Handling output for network is also simple: we get all the output buffers</span>
<span class="p_del">- * and write them to /dev/net/tun.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct net_info {</span>
<span class="p_del">-	int tunfd;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void net_output(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct net_info *net_info = vq-&gt;dev-&gt;priv;</span>
<span class="p_del">-	unsigned int head, out, in;</span>
<span class="p_del">-	struct iovec iov[vq-&gt;vring.num];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We usually wait in here for the Guest to give us a packet. */</span>
<span class="p_del">-	head = wait_for_vq_desc(vq, iov, &amp;out, &amp;in);</span>
<span class="p_del">-	if (in)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Input buffers in net output queue?&quot;);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Send the whole thing through to /dev/net/tun.  It expects the exact</span>
<span class="p_del">-	 * same format: what a coincidence!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (writev(net_info-&gt;tunfd, iov, out) &lt; 0)</span>
<span class="p_del">-		warnx(&quot;Write to tun failed (%d)?&quot;, errno);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Done with that one; wait_for_vq_desc() will send the interrupt if</span>
<span class="p_del">-	 * all packets are processed.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	add_used(vq, head, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Handling network input is a bit trickier, because I&#39;ve tried to optimize it.</span>
<span class="p_del">- *</span>
<span class="p_del">- * First we have a helper routine which tells is if from this file descriptor</span>
<span class="p_del">- * (ie. the /dev/net/tun device) will block:</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool will_block(int fd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	fd_set fdset;</span>
<span class="p_del">-	struct timeval zero = { 0, 0 };</span>
<span class="p_del">-	FD_ZERO(&amp;fdset);</span>
<span class="p_del">-	FD_SET(fd, &amp;fdset);</span>
<span class="p_del">-	return select(fd+1, &amp;fdset, NULL, NULL, &amp;zero) != 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This handles packets coming in from the tun device to our Guest.  Like all</span>
<span class="p_del">- * service routines, it gets called again as soon as it returns, so you don&#39;t</span>
<span class="p_del">- * see a while(1) loop here.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void net_input(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int len;</span>
<span class="p_del">-	unsigned int head, out, in;</span>
<span class="p_del">-	struct iovec iov[vq-&gt;vring.num];</span>
<span class="p_del">-	struct net_info *net_info = vq-&gt;dev-&gt;priv;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Get a descriptor to write an incoming packet into.  This will also</span>
<span class="p_del">-	 * send an interrupt if they&#39;re out of descriptors.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	head = wait_for_vq_desc(vq, iov, &amp;out, &amp;in);</span>
<span class="p_del">-	if (out)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Output buffers in net input queue?&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If it looks like we&#39;ll block reading from the tun device, send them</span>
<span class="p_del">-	 * an interrupt.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (vq-&gt;pending_used &amp;&amp; will_block(net_info-&gt;tunfd))</span>
<span class="p_del">-		trigger_irq(vq);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Read in the packet.  This is where we normally wait (when there&#39;s no</span>
<span class="p_del">-	 * incoming network traffic).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	len = readv(net_info-&gt;tunfd, iov, in);</span>
<span class="p_del">-	if (len &lt;= 0)</span>
<span class="p_del">-		warn(&quot;Failed to read from tun (%d).&quot;, errno);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Mark that packet buffer as used, but don&#39;t interrupt here.  We want</span>
<span class="p_del">-	 * to wait until we&#39;ve done as much work as we can.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	add_used(vq, head, len);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* This is the helper to create threads: run the service routine in a loop. */</span>
<span class="p_del">-static int do_thread(void *_vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtqueue *vq = _vq;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (;;)</span>
<span class="p_del">-		vq-&gt;service(vq);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * When a child dies, we kill our entire process group with SIGTERM.  This</span>
<span class="p_del">- * also has the side effect that the shell restores the console for us!</span>
<span class="p_del">- */</span>
<span class="p_del">-static void kill_launcher(int signal)</span>
<span class="p_del">-{</span>
<span class="p_del">-	kill(0, SIGTERM);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void reset_vq_pci_config(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	vq-&gt;pci_config.queue_size = VIRTQUEUE_NUM;</span>
<span class="p_del">-	vq-&gt;pci_config.queue_enable = 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void reset_device(struct device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtqueue *vq;</span>
<span class="p_del">-</span>
<span class="p_del">-	verbose(&quot;Resetting device %s\n&quot;, dev-&gt;name);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear any features they&#39;ve acked. */</span>
<span class="p_del">-	dev-&gt;features_accepted = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We&#39;re going to be explicitly killing threads, so ignore them. */</span>
<span class="p_del">-	signal(SIGCHLD, SIG_IGN);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.3.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *   The device MUST present a 0 in queue_enable on reset. </span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * This means we set it here, and reset the saved ones in every vq.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	dev-&gt;mmio-&gt;cfg.queue_enable = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get rid of the virtqueue threads */</span>
<span class="p_del">-	for (vq = dev-&gt;vq; vq; vq = vq-&gt;next) {</span>
<span class="p_del">-		vq-&gt;last_avail_idx = 0;</span>
<span class="p_del">-		reset_vq_pci_config(vq);</span>
<span class="p_del">-		if (vq-&gt;thread != (pid_t)-1) {</span>
<span class="p_del">-			kill(vq-&gt;thread, SIGTERM);</span>
<span class="p_del">-			waitpid(vq-&gt;thread, NULL, 0);</span>
<span class="p_del">-			vq-&gt;thread = (pid_t)-1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dev-&gt;running = false;</span>
<span class="p_del">-	dev-&gt;wrote_features_ok = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now we care if threads die. */</span>
<span class="p_del">-	signal(SIGCHLD, (void *)kill_launcher);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void cleanup_devices(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 1; i &lt; MAX_PCI_DEVICES; i++) {</span>
<span class="p_del">-		struct device *d = devices.pci[i];</span>
<span class="p_del">-		if (!d)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		reset_device(d);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If we saved off the original terminal settings, restore them now. */</span>
<span class="p_del">-	if (orig_term.c_lflag &amp; (ISIG|ICANON|ECHO))</span>
<span class="p_del">-		tcsetattr(STDIN_FILENO, TCSANOW, &amp;orig_term);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:217</span>
<span class="p_del">- * We do PCI.  This is mainly done to let us test the kernel virtio PCI</span>
<span class="p_del">- * code.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/* Linux expects a PCI host bridge: ours is a dummy, and first on the bus. */</span>
<span class="p_del">-static struct device pci_host_bridge;</span>
<span class="p_del">-</span>
<span class="p_del">-static void init_pci_host_bridge(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pci_host_bridge.name = &quot;PCI Host Bridge&quot;;</span>
<span class="p_del">-	pci_host_bridge.config.class = 0x06; /* bridge */</span>
<span class="p_del">-	pci_host_bridge.config.subclass = 0; /* host bridge */</span>
<span class="p_del">-	devices.pci[0] = &amp;pci_host_bridge;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* The IO ports used to read the PCI config space. */</span>
<span class="p_del">-#define PCI_CONFIG_ADDR 0xCF8</span>
<span class="p_del">-#define PCI_CONFIG_DATA 0xCFC</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Not really portable, but does help readability: this is what the Guest</span>
<span class="p_del">- * writes to the PCI_CONFIG_ADDR IO port.</span>
<span class="p_del">- */</span>
<span class="p_del">-union pci_config_addr {</span>
<span class="p_del">-	struct {</span>
<span class="p_del">-		unsigned mbz: 2;</span>
<span class="p_del">-		unsigned offset: 6;</span>
<span class="p_del">-		unsigned funcnum: 3;</span>
<span class="p_del">-		unsigned devnum: 5;</span>
<span class="p_del">-		unsigned busnum: 8;</span>
<span class="p_del">-		unsigned reserved: 7;</span>
<span class="p_del">-		unsigned enabled : 1;</span>
<span class="p_del">-	} bits;</span>
<span class="p_del">-	u32 val;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We cache what they wrote to the address port, so we know what they&#39;re</span>
<span class="p_del">- * talking about when they access the data port.</span>
<span class="p_del">- */</span>
<span class="p_del">-static union pci_config_addr pci_config_addr;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct device *find_pci_device(unsigned int index)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return devices.pci[index];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* PCI can do 1, 2 and 4 byte reads; we handle that here. */</span>
<span class="p_del">-static void ioread(u16 off, u32 v, u32 mask, u32 *val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	assert(off &lt; 4);</span>
<span class="p_del">-	assert(mask == 0xFF || mask == 0xFFFF || mask == 0xFFFFFFFF);</span>
<span class="p_del">-	*val = (v &gt;&gt; (off * 8)) &amp; mask;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* PCI can do 1, 2 and 4 byte writes; we handle that here. */</span>
<span class="p_del">-static void iowrite(u16 off, u32 v, u32 mask, u32 *dst)</span>
<span class="p_del">-{</span>
<span class="p_del">-	assert(off &lt; 4);</span>
<span class="p_del">-	assert(mask == 0xFF || mask == 0xFFFF || mask == 0xFFFFFFFF);</span>
<span class="p_del">-	*dst &amp;= ~(mask &lt;&lt; (off * 8));</span>
<span class="p_del">-	*dst |= (v &amp; mask) &lt;&lt; (off * 8);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Where PCI_CONFIG_DATA accesses depends on the previous write to</span>
<span class="p_del">- * PCI_CONFIG_ADDR.</span>
<span class="p_del">- */</span>
<span class="p_del">-static struct device *dev_and_reg(u32 *reg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!pci_config_addr.bits.enabled)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pci_config_addr.bits.funcnum != 0)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pci_config_addr.bits.busnum != 0)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pci_config_addr.bits.offset * 4 &gt;= sizeof(struct pci_config))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	*reg = pci_config_addr.bits.offset;</span>
<span class="p_del">-	return find_pci_device(pci_config_addr.bits.devnum);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We can get invalid combinations of values while they&#39;re writing, so we</span>
<span class="p_del">- * only fault if they try to write with some invalid bar/offset/length.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool valid_bar_access(struct device *d,</span>
<span class="p_del">-			     struct virtio_pci_cfg_cap_u32 *cfg_access)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* We only have 1 bar (BAR0) */</span>
<span class="p_del">-	if (cfg_access-&gt;cap.bar != 0)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check it&#39;s within BAR0. */</span>
<span class="p_del">-	if (cfg_access-&gt;cap.offset &gt;= d-&gt;mmio_size</span>
<span class="p_del">-	    || cfg_access-&gt;cap.offset + cfg_access-&gt;cap.length &gt; d-&gt;mmio_size)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check length is 1, 2 or 4. */</span>
<span class="p_del">-	if (cfg_access-&gt;cap.length != 1</span>
<span class="p_del">-	    &amp;&amp; cfg_access-&gt;cap.length != 2</span>
<span class="p_del">-	    &amp;&amp; cfg_access-&gt;cap.length != 4)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.7.2:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The driver MUST NOT write a cap.offset which is not a multiple of</span>
<span class="p_del">-	 *  cap.length (ie. all accesses MUST be aligned).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (cfg_access-&gt;cap.offset % cfg_access-&gt;cap.length != 0)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Return pointer into word in BAR0. */</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Is this accessing the PCI config address port?. */</span>
<span class="p_del">-static bool is_pci_addr_port(u16 port)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return port &gt;= PCI_CONFIG_ADDR &amp;&amp; port &lt; PCI_CONFIG_ADDR + 4;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool pci_addr_iowrite(u16 port, u32 mask, u32 val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	iowrite(port - PCI_CONFIG_ADDR, val, mask,</span>
<span class="p_del">-		&amp;pci_config_addr.val);</span>
<span class="p_del">-	verbose(&quot;PCI%s: %#x/%x: bus %u dev %u func %u reg %u\n&quot;,</span>
<span class="p_del">-		pci_config_addr.bits.enabled ? &quot;&quot; : &quot; DISABLED&quot;,</span>
<span class="p_del">-		val, mask,</span>
<span class="p_del">-		pci_config_addr.bits.busnum,</span>
<span class="p_del">-		pci_config_addr.bits.devnum,</span>
<span class="p_del">-		pci_config_addr.bits.funcnum,</span>
<span class="p_del">-		pci_config_addr.bits.offset);</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pci_addr_ioread(u16 port, u32 mask, u32 *val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ioread(port - PCI_CONFIG_ADDR, pci_config_addr.val, mask, val);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Is this accessing the PCI config data port?. */</span>
<span class="p_del">-static bool is_pci_data_port(u16 port)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return port &gt;= PCI_CONFIG_DATA &amp;&amp; port &lt; PCI_CONFIG_DATA + 4;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void emulate_mmio_write(struct device *d, u32 off, u32 val, u32 mask);</span>
<span class="p_del">-</span>
<span class="p_del">-static bool pci_data_iowrite(u16 port, u32 mask, u32 val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 reg, portoff;</span>
<span class="p_del">-	struct device *d = dev_and_reg(&amp;reg);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Complain if they don&#39;t belong to a device. */</span>
<span class="p_del">-	if (!d)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* They can do 1 byte writes, etc. */</span>
<span class="p_del">-	portoff = port - PCI_CONFIG_DATA;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * PCI uses a weird way to determine the BAR size: the OS</span>
<span class="p_del">-	 * writes all 1&#39;s, and sees which ones stick.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (&amp;d-&gt;config_words[reg] == &amp;d-&gt;config.bar[0]) {</span>
<span class="p_del">-		int i;</span>
<span class="p_del">-</span>
<span class="p_del">-		iowrite(portoff, val, mask, &amp;d-&gt;config.bar[0]);</span>
<span class="p_del">-		for (i = 0; (1 &lt;&lt; i) &lt; d-&gt;mmio_size; i++)</span>
<span class="p_del">-			d-&gt;config.bar[0] &amp;= ~(1 &lt;&lt; i);</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	} else if ((&amp;d-&gt;config_words[reg] &gt; &amp;d-&gt;config.bar[0]</span>
<span class="p_del">-		    &amp;&amp; &amp;d-&gt;config_words[reg] &lt;= &amp;d-&gt;config.bar[6])</span>
<span class="p_del">-		   || &amp;d-&gt;config_words[reg] == &amp;d-&gt;config.expansion_rom_addr) {</span>
<span class="p_del">-		/* Allow writing to any other BAR, or expansion ROM */</span>
<span class="p_del">-		iowrite(portoff, val, mask, &amp;d-&gt;config_words[reg]);</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-		/* We let them override latency timer and cacheline size */</span>
<span class="p_del">-	} else if (&amp;d-&gt;config_words[reg] == (void *)&amp;d-&gt;config.cacheline_size) {</span>
<span class="p_del">-		/* Only let them change the first two fields. */</span>
<span class="p_del">-		if (mask == 0xFFFFFFFF)</span>
<span class="p_del">-			mask = 0xFFFF;</span>
<span class="p_del">-		iowrite(portoff, val, mask, &amp;d-&gt;config_words[reg]);</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	} else if (&amp;d-&gt;config_words[reg] == (void *)&amp;d-&gt;config.command</span>
<span class="p_del">-		   &amp;&amp; mask == 0xFFFF) {</span>
<span class="p_del">-		/* Ignore command writes. */</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	} else if (&amp;d-&gt;config_words[reg]</span>
<span class="p_del">-		   == (void *)&amp;d-&gt;config.cfg_access.cap.bar</span>
<span class="p_del">-		   || &amp;d-&gt;config_words[reg]</span>
<span class="p_del">-		   == &amp;d-&gt;config.cfg_access.cap.length</span>
<span class="p_del">-		   || &amp;d-&gt;config_words[reg]</span>
<span class="p_del">-		   == &amp;d-&gt;config.cfg_access.cap.offset) {</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The VIRTIO_PCI_CAP_PCI_CFG capability</span>
<span class="p_del">-		 * provides a backdoor to access the MMIO</span>
<span class="p_del">-		 * regions without mapping them.  Weird, but</span>
<span class="p_del">-		 * useful.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		iowrite(portoff, val, mask, &amp;d-&gt;config_words[reg]);</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	} else if (&amp;d-&gt;config_words[reg] == &amp;d-&gt;config.cfg_access.pci_cfg_data) {</span>
<span class="p_del">-		u32 write_mask;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.7.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  Upon detecting driver write access to pci_cfg_data, the</span>
<span class="p_del">-		 *  device MUST execute a write access at offset cap.offset at</span>
<span class="p_del">-		 *  BAR selected by cap.bar using the first cap.length bytes</span>
<span class="p_del">-		 *  from pci_cfg_data.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Must be bar 0 */</span>
<span class="p_del">-		if (!valid_bar_access(d, &amp;d-&gt;config.cfg_access))</span>
<span class="p_del">-			return false;</span>
<span class="p_del">-</span>
<span class="p_del">-		iowrite(portoff, val, mask, &amp;d-&gt;config.cfg_access.pci_cfg_data);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Now emulate a write.  The mask we use is set by</span>
<span class="p_del">-		 * len, *not* this write!</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		write_mask = (1ULL&lt;&lt;(8*d-&gt;config.cfg_access.cap.length)) - 1;</span>
<span class="p_del">-		verbose(&quot;Window writing %#x/%#x to bar %u, offset %u len %u\n&quot;,</span>
<span class="p_del">-			d-&gt;config.cfg_access.pci_cfg_data, write_mask,</span>
<span class="p_del">-			d-&gt;config.cfg_access.cap.bar,</span>
<span class="p_del">-			d-&gt;config.cfg_access.cap.offset,</span>
<span class="p_del">-			d-&gt;config.cfg_access.cap.length);</span>
<span class="p_del">-</span>
<span class="p_del">-		emulate_mmio_write(d, d-&gt;config.cfg_access.cap.offset,</span>
<span class="p_del">-				   d-&gt;config.cfg_access.pci_cfg_data,</span>
<span class="p_del">-				   write_mask);</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The driver MUST NOT write into any field of the capability</span>
<span class="p_del">-	 *  structure, with the exception of those with cap_type</span>
<span class="p_del">-	 *  VIRTIO_PCI_CAP_PCI_CFG...</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 emulate_mmio_read(struct device *d, u32 off, u32 mask);</span>
<span class="p_del">-</span>
<span class="p_del">-static void pci_data_ioread(u16 port, u32 mask, u32 *val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 reg;</span>
<span class="p_del">-	struct device *d = dev_and_reg(&amp;reg);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!d)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Read through the PCI MMIO access window is special */</span>
<span class="p_del">-	if (&amp;d-&gt;config_words[reg] == &amp;d-&gt;config.cfg_access.pci_cfg_data) {</span>
<span class="p_del">-		u32 read_mask;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.7.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  Upon detecting driver read access to pci_cfg_data, the</span>
<span class="p_del">-		 *  device MUST execute a read access of length cap.length at</span>
<span class="p_del">-		 *  offset cap.offset at BAR selected by cap.bar and store the</span>
<span class="p_del">-		 *  first cap.length bytes in pci_cfg_data.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		/* Must be bar 0 */</span>
<span class="p_del">-		if (!valid_bar_access(d, &amp;d-&gt;config.cfg_access))</span>
<span class="p_del">-			bad_driver(d,</span>
<span class="p_del">-			     &quot;Invalid cfg_access to bar%u, offset %u len %u&quot;,</span>
<span class="p_del">-			     d-&gt;config.cfg_access.cap.bar,</span>
<span class="p_del">-			     d-&gt;config.cfg_access.cap.offset,</span>
<span class="p_del">-			     d-&gt;config.cfg_access.cap.length);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Read into the window.  The mask we use is set by</span>
<span class="p_del">-		 * len, *not* this read!</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		read_mask = (1ULL&lt;&lt;(8*d-&gt;config.cfg_access.cap.length))-1;</span>
<span class="p_del">-		d-&gt;config.cfg_access.pci_cfg_data</span>
<span class="p_del">-			= emulate_mmio_read(d,</span>
<span class="p_del">-					    d-&gt;config.cfg_access.cap.offset,</span>
<span class="p_del">-					    read_mask);</span>
<span class="p_del">-		verbose(&quot;Window read %#x/%#x from bar %u, offset %u len %u\n&quot;,</span>
<span class="p_del">-			d-&gt;config.cfg_access.pci_cfg_data, read_mask,</span>
<span class="p_del">-			d-&gt;config.cfg_access.cap.bar,</span>
<span class="p_del">-			d-&gt;config.cfg_access.cap.offset,</span>
<span class="p_del">-			d-&gt;config.cfg_access.cap.length);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	ioread(port - PCI_CONFIG_DATA, d-&gt;config_words[reg], mask, val);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:216</span>
<span class="p_del">- * This is where we emulate a handful of Guest instructions.  It&#39;s ugly</span>
<span class="p_del">- * and we used to do it in the kernel but it grew over time.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * We use the ptrace syscall&#39;s pt_regs struct to talk about registers</span>
<span class="p_del">- * to lguest: these macros convert the names to the offsets.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define getreg(name) getreg_off(offsetof(struct user_regs_struct, name))</span>
<span class="p_del">-#define setreg(name, val) \</span>
<span class="p_del">-	setreg_off(offsetof(struct user_regs_struct, name), (val))</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 getreg_off(size_t offset)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 r;</span>
<span class="p_del">-	unsigned long args[] = { LHREQ_GETREG, offset };</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pwrite(lguest_fd, args, sizeof(args), cpu_id) &lt; 0)</span>
<span class="p_del">-		err(1, &quot;Getting register %u&quot;, offset);</span>
<span class="p_del">-	if (pread(lguest_fd, &amp;r, sizeof(r), cpu_id) != sizeof(r))</span>
<span class="p_del">-		err(1, &quot;Reading register %u&quot;, offset);</span>
<span class="p_del">-</span>
<span class="p_del">-	return r;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void setreg_off(size_t offset, u32 val)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long args[] = { LHREQ_SETREG, offset, val };</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pwrite(lguest_fd, args, sizeof(args), cpu_id) &lt; 0)</span>
<span class="p_del">-		err(1, &quot;Setting register %u&quot;, offset);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Get register by instruction encoding */</span>
<span class="p_del">-static u32 getreg_num(unsigned regnum, u32 mask)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* 8 bit ops use regnums 4-7 for high parts of word */</span>
<span class="p_del">-	if (mask == 0xFF &amp;&amp; (regnum &amp; 0x4))</span>
<span class="p_del">-		return getreg_num(regnum &amp; 0x3, 0xFFFF) &gt;&gt; 8;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (regnum) {</span>
<span class="p_del">-	case 0: return getreg(eax) &amp; mask;</span>
<span class="p_del">-	case 1: return getreg(ecx) &amp; mask;</span>
<span class="p_del">-	case 2: return getreg(edx) &amp; mask;</span>
<span class="p_del">-	case 3: return getreg(ebx) &amp; mask;</span>
<span class="p_del">-	case 4: return getreg(esp) &amp; mask;</span>
<span class="p_del">-	case 5: return getreg(ebp) &amp; mask;</span>
<span class="p_del">-	case 6: return getreg(esi) &amp; mask;</span>
<span class="p_del">-	case 7: return getreg(edi) &amp; mask;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	abort();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Set register by instruction encoding */</span>
<span class="p_del">-static void setreg_num(unsigned regnum, u32 val, u32 mask)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Don&#39;t try to set bits out of range */</span>
<span class="p_del">-	assert(~(val &amp; ~mask));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 8 bit ops use regnums 4-7 for high parts of word */</span>
<span class="p_del">-	if (mask == 0xFF &amp;&amp; (regnum &amp; 0x4)) {</span>
<span class="p_del">-		/* Construct the 16 bits we want. */</span>
<span class="p_del">-		val = (val &lt;&lt; 8) | getreg_num(regnum &amp; 0x3, 0xFF);</span>
<span class="p_del">-		setreg_num(regnum &amp; 0x3, val, 0xFFFF);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (regnum) {</span>
<span class="p_del">-	case 0: setreg(eax, val | (getreg(eax) &amp; ~mask)); return;</span>
<span class="p_del">-	case 1: setreg(ecx, val | (getreg(ecx) &amp; ~mask)); return;</span>
<span class="p_del">-	case 2: setreg(edx, val | (getreg(edx) &amp; ~mask)); return;</span>
<span class="p_del">-	case 3: setreg(ebx, val | (getreg(ebx) &amp; ~mask)); return;</span>
<span class="p_del">-	case 4: setreg(esp, val | (getreg(esp) &amp; ~mask)); return;</span>
<span class="p_del">-	case 5: setreg(ebp, val | (getreg(ebp) &amp; ~mask)); return;</span>
<span class="p_del">-	case 6: setreg(esi, val | (getreg(esi) &amp; ~mask)); return;</span>
<span class="p_del">-	case 7: setreg(edi, val | (getreg(edi) &amp; ~mask)); return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	abort();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Get bytes of displacement appended to instruction, from r/m encoding */</span>
<span class="p_del">-static u32 insn_displacement_len(u8 mod_reg_rm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Switch on the mod bits */</span>
<span class="p_del">-	switch (mod_reg_rm &gt;&gt; 6) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		/* If mod == 0, and r/m == 101, 16-bit displacement follows */</span>
<span class="p_del">-		if ((mod_reg_rm &amp; 0x7) == 0x5)</span>
<span class="p_del">-			return 2;</span>
<span class="p_del">-		/* Normally, mod == 0 means no literal displacement */</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	case 1:</span>
<span class="p_del">-		/* One byte displacement */</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	case 2:</span>
<span class="p_del">-		/* Four byte displacement */</span>
<span class="p_del">-		return 4;</span>
<span class="p_del">-	case 3:</span>
<span class="p_del">-		/* Register mode */</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	abort();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void emulate_insn(const u8 insn[])</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long args[] = { LHREQ_TRAP, 13 };</span>
<span class="p_del">-	unsigned int insnlen = 0, in = 0, small_operand = 0, byte_access;</span>
<span class="p_del">-	unsigned int eax, port, mask;</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Default is to return all-ones on IO port reads, which traditionally</span>
<span class="p_del">-	 * means &quot;there&#39;s nothing there&quot;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	u32 val = 0xFFFFFFFF;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This must be the Guest kernel trying to do something, not userspace!</span>
<span class="p_del">-	 * The bottom two bits of the CS segment register are the privilege</span>
<span class="p_del">-	 * level.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((getreg(xcs) &amp; 3) != 0x1)</span>
<span class="p_del">-		goto no_emulate;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Decoding x86 instructions is icky. */</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Around 2.6.33, the kernel started using an emulation for the</span>
<span class="p_del">-	 * cmpxchg8b instruction in early boot on many configurations.  This</span>
<span class="p_del">-	 * code isn&#39;t paravirtualized, and it tries to disable interrupts.</span>
<span class="p_del">-	 * Ignore it, which will Mostly Work.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (insn[insnlen] == 0xfa) {</span>
<span class="p_del">-		/* &quot;cli&quot;, or Clear Interrupt Enable instruction.  Skip it. */</span>
<span class="p_del">-		insnlen = 1;</span>
<span class="p_del">-		goto skip_insn;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 0x66 is an &quot;operand prefix&quot;.  It means a 16, not 32 bit in/out.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (insn[insnlen] == 0x66) {</span>
<span class="p_del">-		small_operand = 1;</span>
<span class="p_del">-		/* The instruction is 1 byte so far, read the next byte. */</span>
<span class="p_del">-		insnlen = 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If the lower bit isn&#39;t set, it&#39;s a single byte access */</span>
<span class="p_del">-	byte_access = !(insn[insnlen] &amp; 1);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Now we can ignore the lower bit and decode the 4 opcodes</span>
<span class="p_del">-	 * we need to emulate.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	switch (insn[insnlen] &amp; 0xFE) {</span>
<span class="p_del">-	case 0xE4: /* in     &lt;next byte&gt;,%al */</span>
<span class="p_del">-		port = insn[insnlen+1];</span>
<span class="p_del">-		insnlen += 2;</span>
<span class="p_del">-		in = 1;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 0xEC: /* in     (%dx),%al */</span>
<span class="p_del">-		port = getreg(edx) &amp; 0xFFFF;</span>
<span class="p_del">-		insnlen += 1;</span>
<span class="p_del">-		in = 1;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 0xE6: /* out    %al,&lt;next byte&gt; */</span>
<span class="p_del">-		port = insn[insnlen+1];</span>
<span class="p_del">-		insnlen += 2;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case 0xEE: /* out    %al,(%dx) */</span>
<span class="p_del">-		port = getreg(edx) &amp; 0xFFFF;</span>
<span class="p_del">-		insnlen += 1;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* OK, we don&#39;t know what this is, can&#39;t emulate. */</span>
<span class="p_del">-		goto no_emulate;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set a mask of the 1, 2 or 4 bytes, depending on size of IO */</span>
<span class="p_del">-	if (byte_access)</span>
<span class="p_del">-		mask = 0xFF;</span>
<span class="p_del">-	else if (small_operand)</span>
<span class="p_del">-		mask = 0xFFFF;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		mask = 0xFFFFFFFF;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If it was an &quot;IN&quot; instruction, they expect the result to be read</span>
<span class="p_del">-	 * into %eax, so we change %eax.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	eax = getreg(eax);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (in) {</span>
<span class="p_del">-		/* This is the PS/2 keyboard status; 1 means ready for output */</span>
<span class="p_del">-		if (port == 0x64)</span>
<span class="p_del">-			val = 1;</span>
<span class="p_del">-		else if (is_pci_addr_port(port))</span>
<span class="p_del">-			pci_addr_ioread(port, mask, &amp;val);</span>
<span class="p_del">-		else if (is_pci_data_port(port))</span>
<span class="p_del">-			pci_data_ioread(port, mask, &amp;val);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Clear the bits we&#39;re about to read */</span>
<span class="p_del">-		eax &amp;= ~mask;</span>
<span class="p_del">-		/* Copy bits in from val. */</span>
<span class="p_del">-		eax |= val &amp; mask;</span>
<span class="p_del">-		/* Now update the register. */</span>
<span class="p_del">-		setreg(eax, eax);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (is_pci_addr_port(port)) {</span>
<span class="p_del">-			if (!pci_addr_iowrite(port, mask, eax))</span>
<span class="p_del">-				goto bad_io;</span>
<span class="p_del">-		} else if (is_pci_data_port(port)) {</span>
<span class="p_del">-			if (!pci_data_iowrite(port, mask, eax))</span>
<span class="p_del">-				goto bad_io;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* There are many other ports, eg. CMOS clock, serial</span>
<span class="p_del">-		 * and parallel ports, so we ignore them all. */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	verbose(&quot;IO %s of %x to %u: %#08x\n&quot;,</span>
<span class="p_del">-		in ? &quot;IN&quot; : &quot;OUT&quot;, mask, port, eax);</span>
<span class="p_del">-skip_insn:</span>
<span class="p_del">-	/* Finally, we&#39;ve &quot;done&quot; the instruction, so move past it. */</span>
<span class="p_del">-	setreg(eip, getreg(eip) + insnlen);</span>
<span class="p_del">-	return;</span>
<span class="p_del">-</span>
<span class="p_del">-bad_io:</span>
<span class="p_del">-	warnx(&quot;Attempt to %s port %u (%#x mask)&quot;,</span>
<span class="p_del">-	      in ? &quot;read from&quot; : &quot;write to&quot;, port, mask);</span>
<span class="p_del">-</span>
<span class="p_del">-no_emulate:</span>
<span class="p_del">-	/* Inject trap into Guest. */</span>
<span class="p_del">-	if (write(lguest_fd, args, sizeof(args)) &lt; 0)</span>
<span class="p_del">-		err(1, &quot;Reinjecting trap 13 for fault at %#x&quot;, getreg(eip));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct device *find_mmio_region(unsigned long paddr, u32 *off)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 1; i &lt; MAX_PCI_DEVICES; i++) {</span>
<span class="p_del">-		struct device *d = devices.pci[i];</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!d)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (paddr &lt; d-&gt;mmio_addr)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (paddr &gt;= d-&gt;mmio_addr + d-&gt;mmio_size)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		*off = paddr - d-&gt;mmio_addr;</span>
<span class="p_del">-		return d;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* FIXME: Use vq array. */</span>
<span class="p_del">-static struct virtqueue *vq_by_num(struct device *d, u32 num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtqueue *vq = d-&gt;vq;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (num-- &amp;&amp; vq)</span>
<span class="p_del">-		vq = vq-&gt;next;</span>
<span class="p_del">-</span>
<span class="p_del">-	return vq;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void save_vq_config(const struct virtio_pci_common_cfg *cfg,</span>
<span class="p_del">-			   struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	vq-&gt;pci_config = *cfg;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void restore_vq_config(struct virtio_pci_common_cfg *cfg,</span>
<span class="p_del">-			      struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Only restore the per-vq part */</span>
<span class="p_del">-	size_t off = offsetof(struct virtio_pci_common_cfg, queue_size);</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy((void *)cfg + off, (void *)&amp;vq-&gt;pci_config + off,</span>
<span class="p_del">-	       sizeof(*cfg) - off);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * 4.1.4.3.2:</span>
<span class="p_del">- *</span>
<span class="p_del">- *  The driver MUST configure the other virtqueue fields before</span>
<span class="p_del">- *  enabling the virtqueue with queue_enable.</span>
<span class="p_del">- *</span>
<span class="p_del">- * When they enable the virtqueue, we check that their setup is valid.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void check_virtqueue(struct device *d, struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Because lguest is 32 bit, all the descriptor high bits must be 0 */</span>
<span class="p_del">-	if (vq-&gt;pci_config.queue_desc_hi</span>
<span class="p_del">-	    || vq-&gt;pci_config.queue_avail_hi</span>
<span class="p_del">-	    || vq-&gt;pci_config.queue_used_hi)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;invalid 64-bit queue address&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 2.4.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The driver MUST ensure that the physical address of the first byte</span>
<span class="p_del">-	 *  of each virtqueue part is a multiple of the specified alignment</span>
<span class="p_del">-	 *  value in the above table.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (vq-&gt;pci_config.queue_desc_lo % 16</span>
<span class="p_del">-	    || vq-&gt;pci_config.queue_avail_lo % 2</span>
<span class="p_del">-	    || vq-&gt;pci_config.queue_used_lo % 4)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;invalid alignment in queue addresses&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialize the virtqueue and check they&#39;re all in range. */</span>
<span class="p_del">-	vq-&gt;vring.num = vq-&gt;pci_config.queue_size;</span>
<span class="p_del">-	vq-&gt;vring.desc = check_pointer(vq-&gt;dev,</span>
<span class="p_del">-				       vq-&gt;pci_config.queue_desc_lo,</span>
<span class="p_del">-				       sizeof(*vq-&gt;vring.desc) * vq-&gt;vring.num);</span>
<span class="p_del">-	vq-&gt;vring.avail = check_pointer(vq-&gt;dev,</span>
<span class="p_del">-					vq-&gt;pci_config.queue_avail_lo,</span>
<span class="p_del">-					sizeof(*vq-&gt;vring.avail)</span>
<span class="p_del">-					+ (sizeof(vq-&gt;vring.avail-&gt;ring[0])</span>
<span class="p_del">-					   * vq-&gt;vring.num));</span>
<span class="p_del">-	vq-&gt;vring.used = check_pointer(vq-&gt;dev,</span>
<span class="p_del">-				       vq-&gt;pci_config.queue_used_lo,</span>
<span class="p_del">-				       sizeof(*vq-&gt;vring.used)</span>
<span class="p_del">-				       + (sizeof(vq-&gt;vring.used-&gt;ring[0])</span>
<span class="p_del">-					  * vq-&gt;vring.num));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 2.4.9.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *   The driver MUST initialize flags in the used ring to 0</span>
<span class="p_del">-	 *   when allocating the used ring.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (vq-&gt;vring.used-&gt;flags != 0)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;invalid initial used.flags %#x&quot;,</span>
<span class="p_del">-			      vq-&gt;vring.used-&gt;flags);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void start_virtqueue(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Create stack for thread.  Since the stack grows upwards, we point</span>
<span class="p_del">-	 * the stack pointer to the end of this region.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	char *stack = malloc(32768);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Create a zero-initialized eventfd. */</span>
<span class="p_del">-	vq-&gt;eventfd = eventfd(0, 0);</span>
<span class="p_del">-	if (vq-&gt;eventfd &lt; 0)</span>
<span class="p_del">-		err(1, &quot;Creating eventfd&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * CLONE_VM: because it has to access the Guest memory, and SIGCHLD so</span>
<span class="p_del">-	 * we get a signal if it dies.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	vq-&gt;thread = clone(do_thread, stack + 32768, CLONE_VM | SIGCHLD, vq);</span>
<span class="p_del">-	if (vq-&gt;thread == (pid_t)-1)</span>
<span class="p_del">-		err(1, &quot;Creating clone&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void start_virtqueues(struct device *d)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtqueue *vq;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (vq = d-&gt;vq; vq; vq = vq-&gt;next) {</span>
<span class="p_del">-		if (vq-&gt;pci_config.queue_enable)</span>
<span class="p_del">-			start_virtqueue(vq);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void emulate_mmio_write(struct device *d, u32 off, u32 val, u32 mask)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtqueue *vq;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (off) {</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.device_feature_select):</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * The device MUST present the feature bits it is offering in</span>
<span class="p_del">-		 * device_feature, starting at bit device_feature_select ∗ 32</span>
<span class="p_del">-		 * for any device_feature_select written by the driver</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (val == 0)</span>
<span class="p_del">-			d-&gt;mmio-&gt;cfg.device_feature = d-&gt;features;</span>
<span class="p_del">-		else if (val == 1)</span>
<span class="p_del">-			d-&gt;mmio-&gt;cfg.device_feature = (d-&gt;features &gt;&gt; 32);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			d-&gt;mmio-&gt;cfg.device_feature = 0;</span>
<span class="p_del">-		goto feature_write_through32;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.guest_feature_select):</span>
<span class="p_del">-		if (val &gt; 1)</span>
<span class="p_del">-			bad_driver(d, &quot;Unexpected driver select %u&quot;, val);</span>
<span class="p_del">-		goto feature_write_through32;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.guest_feature):</span>
<span class="p_del">-		if (d-&gt;mmio-&gt;cfg.guest_feature_select == 0) {</span>
<span class="p_del">-			d-&gt;features_accepted &amp;= ~((u64)0xFFFFFFFF);</span>
<span class="p_del">-			d-&gt;features_accepted |= val;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			assert(d-&gt;mmio-&gt;cfg.guest_feature_select == 1);</span>
<span class="p_del">-			d-&gt;features_accepted &amp;= 0xFFFFFFFF;</span>
<span class="p_del">-			d-&gt;features_accepted |= ((u64)val) &lt;&lt; 32;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 2.2.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *   The driver MUST NOT accept a feature which the device did</span>
<span class="p_del">-		 *   not offer</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (d-&gt;features_accepted &amp; ~d-&gt;features)</span>
<span class="p_del">-			bad_driver(d, &quot;over-accepted features %#llx of %#llx&quot;,</span>
<span class="p_del">-				   d-&gt;features_accepted, d-&gt;features);</span>
<span class="p_del">-		goto feature_write_through32;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.device_status): {</span>
<span class="p_del">-		u8 prev;</span>
<span class="p_del">-</span>
<span class="p_del">-		verbose(&quot;%s: device status -&gt; %#x\n&quot;, d-&gt;name, val);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.1:</span>
<span class="p_del">-		 * </span>
<span class="p_del">-		 *  The device MUST reset when 0 is written to device_status,</span>
<span class="p_del">-		 *  and present a 0 in device_status once that is done.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (val == 0) {</span>
<span class="p_del">-			reset_device(d);</span>
<span class="p_del">-			goto write_through8;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* 2.1.1: The driver MUST NOT clear a device status bit. */</span>
<span class="p_del">-		if (d-&gt;mmio-&gt;cfg.device_status &amp; ~val)</span>
<span class="p_del">-			bad_driver(d, &quot;unset of device status bit %#x -&gt; %#x&quot;,</span>
<span class="p_del">-				   d-&gt;mmio-&gt;cfg.device_status, val);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 2.1.2:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The device MUST NOT consume buffers or notify the driver</span>
<span class="p_del">-		 *  before DRIVER_OK.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (val &amp; VIRTIO_CONFIG_S_DRIVER_OK</span>
<span class="p_del">-		    &amp;&amp; !(d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_DRIVER_OK))</span>
<span class="p_del">-			start_virtqueues(d);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 3.1.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *   The driver MUST follow this sequence to initialize a device:</span>
<span class="p_del">-		 *   - Reset the device.</span>
<span class="p_del">-		 *   - Set the ACKNOWLEDGE status bit: the guest OS has</span>
<span class="p_del">-                 *     notice the device.</span>
<span class="p_del">-		 *   - Set the DRIVER status bit: the guest OS knows how</span>
<span class="p_del">-                 *     to drive the device.</span>
<span class="p_del">-		 *   - Read device feature bits, and write the subset</span>
<span class="p_del">-		 *     of feature bits understood by the OS and driver</span>
<span class="p_del">-		 *     to the device. During this step the driver MAY</span>
<span class="p_del">-		 *     read (but MUST NOT write) the device-specific</span>
<span class="p_del">-		 *     configuration fields to check that it can</span>
<span class="p_del">-		 *     support the device before accepting it.</span>
<span class="p_del">-		 *   - Set the FEATURES_OK status bit.  The driver</span>
<span class="p_del">-		 *     MUST not accept new feature bits after this</span>
<span class="p_del">-		 *     step.</span>
<span class="p_del">-		 *   - Re-read device status to ensure the FEATURES_OK</span>
<span class="p_del">-		 *     bit is still set: otherwise, the device does</span>
<span class="p_del">-		 *     not support our subset of features and the</span>
<span class="p_del">-		 *     device is unusable.</span>
<span class="p_del">-		 *   - Perform device-specific setup, including</span>
<span class="p_del">-		 *     discovery of virtqueues for the device,</span>
<span class="p_del">-		 *     optional per-bus setup, reading and possibly</span>
<span class="p_del">-		 *     writing the device’s virtio configuration</span>
<span class="p_del">-		 *     space, and population of virtqueues.</span>
<span class="p_del">-		 *   - Set the DRIVER_OK status bit. At this point the</span>
<span class="p_del">-                 *     device is “live”.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		prev = 0;</span>
<span class="p_del">-		switch (val &amp; ~d-&gt;mmio-&gt;cfg.device_status) {</span>
<span class="p_del">-		case VIRTIO_CONFIG_S_DRIVER_OK:</span>
<span class="p_del">-			prev |= VIRTIO_CONFIG_S_FEATURES_OK; /* fall thru */</span>
<span class="p_del">-		case VIRTIO_CONFIG_S_FEATURES_OK:</span>
<span class="p_del">-			prev |= VIRTIO_CONFIG_S_DRIVER; /* fall thru */</span>
<span class="p_del">-		case VIRTIO_CONFIG_S_DRIVER:</span>
<span class="p_del">-			prev |= VIRTIO_CONFIG_S_ACKNOWLEDGE; /* fall thru */</span>
<span class="p_del">-		case VIRTIO_CONFIG_S_ACKNOWLEDGE:</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			bad_driver(d, &quot;unknown device status bit %#x -&gt; %#x&quot;,</span>
<span class="p_del">-				   d-&gt;mmio-&gt;cfg.device_status, val);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (d-&gt;mmio-&gt;cfg.device_status != prev)</span>
<span class="p_del">-			bad_driver(d, &quot;unexpected status transition %#x -&gt; %#x&quot;,</span>
<span class="p_del">-				   d-&gt;mmio-&gt;cfg.device_status, val);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* If they just wrote FEATURES_OK, we make sure they read */</span>
<span class="p_del">-		switch (val &amp; ~d-&gt;mmio-&gt;cfg.device_status) {</span>
<span class="p_del">-		case VIRTIO_CONFIG_S_FEATURES_OK:</span>
<span class="p_del">-			d-&gt;wrote_features_ok = true;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case VIRTIO_CONFIG_S_DRIVER_OK:</span>
<span class="p_del">-			if (d-&gt;wrote_features_ok)</span>
<span class="p_del">-				bad_driver(d, &quot;did not re-read FEATURES_OK&quot;);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		goto write_through8;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_select):</span>
<span class="p_del">-		vq = vq_by_num(d, val);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The device MUST present a 0 in queue_size if the virtqueue</span>
<span class="p_del">-		 *  corresponding to the current queue_select is unavailable.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!vq) {</span>
<span class="p_del">-			d-&gt;mmio-&gt;cfg.queue_size = 0;</span>
<span class="p_del">-			goto write_through16;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* Save registers for old vq, if it was a valid vq */</span>
<span class="p_del">-		if (d-&gt;mmio-&gt;cfg.queue_size)</span>
<span class="p_del">-			save_vq_config(&amp;d-&gt;mmio-&gt;cfg,</span>
<span class="p_del">-				       vq_by_num(d, d-&gt;mmio-&gt;cfg.queue_select));</span>
<span class="p_del">-		/* Restore the registers for the queue they asked for */</span>
<span class="p_del">-		restore_vq_config(&amp;d-&gt;mmio-&gt;cfg, vq);</span>
<span class="p_del">-		goto write_through16;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_size):</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.2:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The driver MUST NOT write a value which is not a power of 2</span>
<span class="p_del">-		 *  to queue_size.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (val &amp; (val-1))</span>
<span class="p_del">-			bad_driver(d, &quot;invalid queue size %u&quot;, val);</span>
<span class="p_del">-		if (d-&gt;mmio-&gt;cfg.queue_enable)</span>
<span class="p_del">-			bad_driver(d, &quot;changing queue size on live device&quot;);</span>
<span class="p_del">-		goto write_through16;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_msix_vector):</span>
<span class="p_del">-		bad_driver(d, &quot;attempt to set MSIX vector to %u&quot;, val);</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_enable): {</span>
<span class="p_del">-		struct virtqueue *vq = vq_by_num(d, d-&gt;mmio-&gt;cfg.queue_select);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.2:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The driver MUST NOT write a 0 to queue_enable.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (val != 1)</span>
<span class="p_del">-			bad_driver(d, &quot;setting queue_enable to %u&quot;, val);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 3.1.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  7. Perform device-specific setup, including discovery of</span>
<span class="p_del">-		 *     virtqueues for the device, optional per-bus setup,</span>
<span class="p_del">-		 *     reading and possibly writing the device’s virtio</span>
<span class="p_del">-		 *     configuration space, and population of virtqueues.</span>
<span class="p_del">-		 *  8. Set the DRIVER_OK status bit.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * All our devices require all virtqueues to be enabled, so</span>
<span class="p_del">-		 * they should have done that before setting DRIVER_OK.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_DRIVER_OK)</span>
<span class="p_del">-			bad_driver(d, &quot;enabling vq after DRIVER_OK&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		d-&gt;mmio-&gt;cfg.queue_enable = val;</span>
<span class="p_del">-		save_vq_config(&amp;d-&gt;mmio-&gt;cfg, vq);</span>
<span class="p_del">-		check_virtqueue(d, vq);</span>
<span class="p_del">-		goto write_through16;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_notify_off):</span>
<span class="p_del">-		bad_driver(d, &quot;attempt to write to queue_notify_off&quot;);</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_desc_lo):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_desc_hi):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_avail_lo):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_avail_hi):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_used_lo):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.queue_used_hi):</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.2:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The driver MUST configure the other virtqueue fields before</span>
<span class="p_del">-		 *  enabling the virtqueue with queue_enable.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (d-&gt;mmio-&gt;cfg.queue_enable)</span>
<span class="p_del">-			bad_driver(d, &quot;changing queue on live device&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 3.1.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The driver MUST follow this sequence to initialize a device:</span>
<span class="p_del">-		 *...</span>
<span class="p_del">-		 *  5. Set the FEATURES_OK status bit. The driver MUST not</span>
<span class="p_del">-		 *  accept new feature bits after this step.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!(d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_FEATURES_OK))</span>
<span class="p_del">-			bad_driver(d, &quot;setting up vq before FEATURES_OK&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 *  6. Re-read device status to ensure the FEATURES_OK bit is</span>
<span class="p_del">-		 *     still set...</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (d-&gt;wrote_features_ok)</span>
<span class="p_del">-			bad_driver(d, &quot;didn&#39;t re-read FEATURES_OK before setup&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		goto write_through32;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, notify):</span>
<span class="p_del">-		vq = vq_by_num(d, val);</span>
<span class="p_del">-		if (!vq)</span>
<span class="p_del">-			bad_driver(d, &quot;Invalid vq notification on %u&quot;, val);</span>
<span class="p_del">-		/* Notify the process handling this vq by adding 1 to eventfd */</span>
<span class="p_del">-		write(vq-&gt;eventfd, &quot;\1\0\0\0\0\0\0\0&quot;, 8);</span>
<span class="p_del">-		goto write_through16;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, isr):</span>
<span class="p_del">-		bad_driver(d, &quot;Unexpected write to isr&quot;);</span>
<span class="p_del">-	/* Weird corner case: write to emerg_wr of console */</span>
<span class="p_del">-	case sizeof(struct virtio_pci_mmio)</span>
<span class="p_del">-		+ offsetof(struct virtio_console_config, emerg_wr):</span>
<span class="p_del">-		if (strcmp(d-&gt;name, &quot;console&quot;) == 0) {</span>
<span class="p_del">-			char c = val;</span>
<span class="p_del">-			write(STDOUT_FILENO, &amp;c, 1);</span>
<span class="p_del">-			goto write_through32;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* Fall through... */</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.2:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *   The driver MUST NOT write to device_feature, num_queues,</span>
<span class="p_del">-		 *   config_generation or queue_notify_off.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		bad_driver(d, &quot;Unexpected write to offset %u&quot;, off);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-feature_write_through32:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 3.1.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *   The driver MUST follow this sequence to initialize a device:</span>
<span class="p_del">-	 *...</span>
<span class="p_del">-	 *   - Set the DRIVER status bit: the guest OS knows how</span>
<span class="p_del">-	 *     to drive the device.</span>
<span class="p_del">-	 *   - Read device feature bits, and write the subset</span>
<span class="p_del">-	 *     of feature bits understood by the OS and driver</span>
<span class="p_del">-	 *     to the device.</span>
<span class="p_del">-	 *...</span>
<span class="p_del">-	 *   - Set the FEATURES_OK status bit. The driver MUST not</span>
<span class="p_del">-	 *     accept new feature bits after this step.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!(d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_DRIVER))</span>
<span class="p_del">-		bad_driver(d, &quot;feature write before VIRTIO_CONFIG_S_DRIVER&quot;);</span>
<span class="p_del">-	if (d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_FEATURES_OK)</span>
<span class="p_del">-		bad_driver(d, &quot;feature write after VIRTIO_CONFIG_S_FEATURES_OK&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.3.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The driver MUST access each field using the “natural” access</span>
<span class="p_del">-	 *  method, i.e. 32-bit accesses for 32-bit fields, 16-bit accesses for</span>
<span class="p_del">-	 *  16-bit fields and 8-bit accesses for 8-bit fields.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-write_through32:</span>
<span class="p_del">-	if (mask != 0xFFFFFFFF) {</span>
<span class="p_del">-		bad_driver(d, &quot;non-32-bit write to offset %u (%#x)&quot;,</span>
<span class="p_del">-			   off, getreg(eip));</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	memcpy((char *)d-&gt;mmio + off, &amp;val, 4);</span>
<span class="p_del">-	return;</span>
<span class="p_del">-</span>
<span class="p_del">-write_through16:</span>
<span class="p_del">-	if (mask != 0xFFFF)</span>
<span class="p_del">-		bad_driver(d, &quot;non-16-bit write to offset %u (%#x)&quot;,</span>
<span class="p_del">-			   off, getreg(eip));</span>
<span class="p_del">-	memcpy((char *)d-&gt;mmio + off, &amp;val, 2);</span>
<span class="p_del">-	return;</span>
<span class="p_del">-</span>
<span class="p_del">-write_through8:</span>
<span class="p_del">-	if (mask != 0xFF)</span>
<span class="p_del">-		bad_driver(d, &quot;non-8-bit write to offset %u (%#x)&quot;,</span>
<span class="p_del">-			   off, getreg(eip));</span>
<span class="p_del">-	memcpy((char *)d-&gt;mmio + off, &amp;val, 1);</span>
<span class="p_del">-	return;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 emulate_mmio_read(struct device *d, u32 off, u32 mask)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 isr;</span>
<span class="p_del">-	u32 val = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (off) {</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.device_feature_select):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.device_feature):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.guest_feature_select):</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.guest_feature):</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 3.1.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *   The driver MUST follow this sequence to initialize a device:</span>
<span class="p_del">-		 *...</span>
<span class="p_del">-		 *   - Set the DRIVER status bit: the guest OS knows how</span>
<span class="p_del">-		 *     to drive the device.</span>
<span class="p_del">-		 *   - Read device feature bits, and write the subset</span>
<span class="p_del">-		 *     of feature bits understood by the OS and driver</span>
<span class="p_del">-		 *     to the device.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!(d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_DRIVER))</span>
<span class="p_del">-			bad_driver(d,</span>
<span class="p_del">-				   &quot;feature read before VIRTIO_CONFIG_S_DRIVER&quot;);</span>
<span class="p_del">-		goto read_through32;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.msix_config):</span>
<span class="p_del">-		bad_driver(d, &quot;read of msix_config&quot;);</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.num_queues):</span>
<span class="p_del">-		goto read_through16;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.device_status):</span>
<span class="p_del">-		/* As they did read, any write of FEATURES_OK is now fine. */</span>
<span class="p_del">-		d-&gt;wrote_features_ok = false;</span>
<span class="p_del">-		goto read_through8;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, cfg.config_generation):</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.3.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The device MUST present a changed config_generation after</span>
<span class="p_del">-		 *  the driver has read a device-specific configuration value</span>
<span class="p_del">-		 *  which has changed since any part of the device-specific</span>
<span class="p_del">-		 *  configuration was last read.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * This is simple: none of our devices change config, so this</span>
<span class="p_del">-		 * is always 0.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		goto read_through8;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, notify):</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 3.1.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *   The driver MUST NOT notify the device before setting</span>
<span class="p_del">-		 *   DRIVER_OK.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!(d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_DRIVER_OK))</span>
<span class="p_del">-			bad_driver(d, &quot;notify before VIRTIO_CONFIG_S_DRIVER_OK&quot;);</span>
<span class="p_del">-		goto read_through16;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, isr):</span>
<span class="p_del">-		if (mask != 0xFF)</span>
<span class="p_del">-			bad_driver(d, &quot;non-8-bit read from offset %u (%#x)&quot;,</span>
<span class="p_del">-				   off, getreg(eip));</span>
<span class="p_del">-		isr = d-&gt;mmio-&gt;isr;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 4.1.4.5.1:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  The device MUST reset ISR status to 0 on driver read. </span>
<span class="p_del">-		 */</span>
<span class="p_del">-		d-&gt;mmio-&gt;isr = 0;</span>
<span class="p_del">-		return isr;</span>
<span class="p_del">-	case offsetof(struct virtio_pci_mmio, padding):</span>
<span class="p_del">-		bad_driver(d, &quot;read from padding (%#x)&quot;, getreg(eip));</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		/* Read from device config space, beware unaligned overflow */</span>
<span class="p_del">-		if (off &gt; d-&gt;mmio_size - 4)</span>
<span class="p_del">-			bad_driver(d, &quot;read past end (%#x)&quot;, getreg(eip));</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * 3.1.1:</span>
<span class="p_del">-		 *  The driver MUST follow this sequence to initialize a device:</span>
<span class="p_del">-		 *...</span>
<span class="p_del">-		 *  3. Set the DRIVER status bit: the guest OS knows how to</span>
<span class="p_del">-		 *  drive the device.</span>
<span class="p_del">-		 *  4. Read device feature bits, and write the subset of</span>
<span class="p_del">-		 *  feature bits understood by the OS and driver to the</span>
<span class="p_del">-		 *  device. During this step the driver MAY read (but MUST NOT</span>
<span class="p_del">-		 *  write) the device-specific configuration fields to check</span>
<span class="p_del">-		 *  that it can support the device before accepting it.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!(d-&gt;mmio-&gt;cfg.device_status &amp; VIRTIO_CONFIG_S_DRIVER))</span>
<span class="p_del">-			bad_driver(d,</span>
<span class="p_del">-				   &quot;config read before VIRTIO_CONFIG_S_DRIVER&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mask == 0xFFFFFFFF)</span>
<span class="p_del">-			goto read_through32;</span>
<span class="p_del">-		else if (mask == 0xFFFF)</span>
<span class="p_del">-			goto read_through16;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			goto read_through8;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.3.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The driver MUST access each field using the “natural” access</span>
<span class="p_del">-	 *  method, i.e. 32-bit accesses for 32-bit fields, 16-bit accesses for</span>
<span class="p_del">-	 *  16-bit fields and 8-bit accesses for 8-bit fields.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-read_through32:</span>
<span class="p_del">-	if (mask != 0xFFFFFFFF)</span>
<span class="p_del">-		bad_driver(d, &quot;non-32-bit read to offset %u (%#x)&quot;,</span>
<span class="p_del">-			   off, getreg(eip));</span>
<span class="p_del">-	memcpy(&amp;val, (char *)d-&gt;mmio + off, 4);</span>
<span class="p_del">-	return val;</span>
<span class="p_del">-</span>
<span class="p_del">-read_through16:</span>
<span class="p_del">-	if (mask != 0xFFFF)</span>
<span class="p_del">-		bad_driver(d, &quot;non-16-bit read to offset %u (%#x)&quot;,</span>
<span class="p_del">-			   off, getreg(eip));</span>
<span class="p_del">-	memcpy(&amp;val, (char *)d-&gt;mmio + off, 2);</span>
<span class="p_del">-	return val;</span>
<span class="p_del">-</span>
<span class="p_del">-read_through8:</span>
<span class="p_del">-	if (mask != 0xFF)</span>
<span class="p_del">-		bad_driver(d, &quot;non-8-bit read to offset %u (%#x)&quot;,</span>
<span class="p_del">-			   off, getreg(eip));</span>
<span class="p_del">-	memcpy(&amp;val, (char *)d-&gt;mmio + off, 1);</span>
<span class="p_del">-	return val;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void emulate_mmio(unsigned long paddr, const u8 *insn)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 val, off, mask = 0xFFFFFFFF, insnlen = 0;</span>
<span class="p_del">-	struct device *d = find_mmio_region(paddr, &amp;off);</span>
<span class="p_del">-	unsigned long args[] = { LHREQ_TRAP, 14 };</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!d) {</span>
<span class="p_del">-		warnx(&quot;MMIO touching %#08lx (not a device)&quot;, paddr);</span>
<span class="p_del">-		goto reinject;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Prefix makes it a 16 bit op */</span>
<span class="p_del">-	if (insn[0] == 0x66) {</span>
<span class="p_del">-		mask = 0xFFFF;</span>
<span class="p_del">-		insnlen++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* iowrite */</span>
<span class="p_del">-	if (insn[insnlen] == 0x89) {</span>
<span class="p_del">-		/* Next byte is r/m byte: bits 3-5 are register. */</span>
<span class="p_del">-		val = getreg_num((insn[insnlen+1] &gt;&gt; 3) &amp; 0x7, mask);</span>
<span class="p_del">-		emulate_mmio_write(d, off, val, mask);</span>
<span class="p_del">-		insnlen += 2 + insn_displacement_len(insn[insnlen+1]);</span>
<span class="p_del">-	} else if (insn[insnlen] == 0x8b) { /* ioread */</span>
<span class="p_del">-		/* Next byte is r/m byte: bits 3-5 are register. */</span>
<span class="p_del">-		val = emulate_mmio_read(d, off, mask);</span>
<span class="p_del">-		setreg_num((insn[insnlen+1] &gt;&gt; 3) &amp; 0x7, val, mask);</span>
<span class="p_del">-		insnlen += 2 + insn_displacement_len(insn[insnlen+1]);</span>
<span class="p_del">-	} else if (insn[0] == 0x88) { /* 8-bit iowrite */</span>
<span class="p_del">-		mask = 0xff;</span>
<span class="p_del">-		/* Next byte is r/m byte: bits 3-5 are register. */</span>
<span class="p_del">-		val = getreg_num((insn[1] &gt;&gt; 3) &amp; 0x7, mask);</span>
<span class="p_del">-		emulate_mmio_write(d, off, val, mask);</span>
<span class="p_del">-		insnlen = 2 + insn_displacement_len(insn[1]);</span>
<span class="p_del">-	} else if (insn[0] == 0x8a) { /* 8-bit ioread */</span>
<span class="p_del">-		mask = 0xff;</span>
<span class="p_del">-		val = emulate_mmio_read(d, off, mask);</span>
<span class="p_del">-		setreg_num((insn[1] &gt;&gt; 3) &amp; 0x7, val, mask);</span>
<span class="p_del">-		insnlen = 2 + insn_displacement_len(insn[1]);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		warnx(&quot;Unknown MMIO instruction touching %#08lx:&quot;</span>
<span class="p_del">-		     &quot; %02x %02x %02x %02x at %u&quot;,</span>
<span class="p_del">-		     paddr, insn[0], insn[1], insn[2], insn[3], getreg(eip));</span>
<span class="p_del">-	reinject:</span>
<span class="p_del">-		/* Inject trap into Guest. */</span>
<span class="p_del">-		if (write(lguest_fd, args, sizeof(args)) &lt; 0)</span>
<span class="p_del">-			err(1, &quot;Reinjecting trap 14 for fault at %#x&quot;,</span>
<span class="p_del">-			    getreg(eip));</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Finally, we&#39;ve &quot;done&quot; the instruction, so move past it. */</span>
<span class="p_del">-	setreg(eip, getreg(eip) + insnlen);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:190</span>
<span class="p_del">- * Device Setup</span>
<span class="p_del">- *</span>
<span class="p_del">- * All devices need a descriptor so the Guest knows it exists, and a &quot;struct</span>
<span class="p_del">- * device&quot; so the Launcher can keep track of it.  We have common helper</span>
<span class="p_del">- * routines to allocate and manage them.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void add_pci_virtqueue(struct device *dev,</span>
<span class="p_del">-			      void (*service)(struct virtqueue *),</span>
<span class="p_del">-			      const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct virtqueue **i, *vq = malloc(sizeof(*vq));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialize the virtqueue */</span>
<span class="p_del">-	vq-&gt;next = NULL;</span>
<span class="p_del">-	vq-&gt;last_avail_idx = 0;</span>
<span class="p_del">-	vq-&gt;dev = dev;</span>
<span class="p_del">-	vq-&gt;name = name;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This is the routine the service thread will run, and its Process ID</span>
<span class="p_del">-	 * once it&#39;s running.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	vq-&gt;service = service;</span>
<span class="p_del">-	vq-&gt;thread = (pid_t)-1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialize the configuration. */</span>
<span class="p_del">-	reset_vq_pci_config(vq);</span>
<span class="p_del">-	vq-&gt;pci_config.queue_notify_off = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Add one to the number of queues */</span>
<span class="p_del">-	vq-&gt;dev-&gt;mmio-&gt;cfg.num_queues++;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Add to tail of list, so dev-&gt;vq is first vq, dev-&gt;vq-&gt;next is</span>
<span class="p_del">-	 * second.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = &amp;dev-&gt;vq; *i; i = &amp;(*i)-&gt;next);</span>
<span class="p_del">-	*i = vq;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* The Guest accesses the feature bits via the PCI common config MMIO region */</span>
<span class="p_del">-static void add_pci_feature(struct device *dev, unsigned bit)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dev-&gt;features |= (1ULL &lt;&lt; bit);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* For devices with no config. */</span>
<span class="p_del">-static void no_device_config(struct device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dev-&gt;mmio_addr = get_mmio_region(dev-&gt;mmio_size);</span>
<span class="p_del">-</span>
<span class="p_del">-	dev-&gt;config.bar[0] = dev-&gt;mmio_addr;</span>
<span class="p_del">-	/* Bottom 4 bits must be zero */</span>
<span class="p_del">-	assert(~(dev-&gt;config.bar[0] &amp; 0xF));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* This puts the device config into BAR0 */</span>
<span class="p_del">-static void set_device_config(struct device *dev, const void *conf, size_t len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Set up BAR 0 */</span>
<span class="p_del">-	dev-&gt;mmio_size += len;</span>
<span class="p_del">-	dev-&gt;mmio = realloc(dev-&gt;mmio, dev-&gt;mmio_size);</span>
<span class="p_del">-	memcpy(dev-&gt;mmio + 1, conf, len);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.6:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The device MUST present at least one VIRTIO_PCI_CAP_DEVICE_CFG</span>
<span class="p_del">-	 *  capability for any device type which has a device-specific</span>
<span class="p_del">-	 *  configuration.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	/* Hook up device cfg */</span>
<span class="p_del">-	dev-&gt;config.cfg_access.cap.cap_next</span>
<span class="p_del">-		= offsetof(struct pci_config, device);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.6.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The offset for the device-specific configuration MUST be 4-byte</span>
<span class="p_del">-	 *  aligned.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	assert(dev-&gt;config.cfg_access.cap.cap_next % 4 == 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Fix up device cfg field length. */</span>
<span class="p_del">-	dev-&gt;config.device.length = len;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The rest is the same as the no-config case */</span>
<span class="p_del">-	no_device_config(dev);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void init_cap(struct virtio_pci_cap *cap, size_t caplen, int type,</span>
<span class="p_del">-		     size_t bar_offset, size_t bar_bytes, u8 next)</span>
<span class="p_del">-{</span>
<span class="p_del">-	cap-&gt;cap_vndr = PCI_CAP_ID_VNDR;</span>
<span class="p_del">-	cap-&gt;cap_next = next;</span>
<span class="p_del">-	cap-&gt;cap_len = caplen;</span>
<span class="p_del">-	cap-&gt;cfg_type = type;</span>
<span class="p_del">-	cap-&gt;bar = 0;</span>
<span class="p_del">-	memset(cap-&gt;padding, 0, sizeof(cap-&gt;padding));</span>
<span class="p_del">-	cap-&gt;offset = bar_offset;</span>
<span class="p_del">-	cap-&gt;length = bar_bytes;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This sets up the pci_config structure, as defined in the virtio 1.0</span>
<span class="p_del">- * standard (and PCI standard).</span>
<span class="p_del">- */</span>
<span class="p_del">-static void init_pci_config(struct pci_config *pci, u16 type,</span>
<span class="p_del">-			    u8 class, u8 subclass)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t bar_offset, bar_len;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.4.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The device MUST either present notify_off_multiplier as an even</span>
<span class="p_del">-	 *  power of 2, or present notify_off_multiplier as 0.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * 2.1.2:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *   The device MUST initialize device status to 0 upon reset. </span>
<span class="p_del">-	 */</span>
<span class="p_del">-	memset(pci, 0, sizeof(*pci));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 4.1.2.1: Devices MUST have the PCI Vendor ID 0x1AF4 */</span>
<span class="p_del">-	pci-&gt;vendor_id = 0x1AF4;</span>
<span class="p_del">-	/* 4.1.2.1: ... PCI Device ID calculated by adding 0x1040 ... */</span>
<span class="p_del">-	pci-&gt;device_id = 0x1040 + type;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * PCI have specific codes for different types of devices.</span>
<span class="p_del">-	 * Linux doesn&#39;t care, but it&#39;s a good clue for people looking</span>
<span class="p_del">-	 * at the device.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pci-&gt;class = class;</span>
<span class="p_del">-	pci-&gt;subclass = subclass;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.2.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  Non-transitional devices SHOULD have a PCI Revision ID of 1 or</span>
<span class="p_del">-	 *  higher</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pci-&gt;revid = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.2.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  Non-transitional devices SHOULD have a PCI Subsystem Device ID of</span>
<span class="p_del">-	 *  0x40 or higher.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pci-&gt;subsystem_device_id = 0x40;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We use our dummy interrupt controller, and irq_line is the irq */</span>
<span class="p_del">-	pci-&gt;irq_line = devices.next_irq++;</span>
<span class="p_del">-	pci-&gt;irq_pin = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Support for extended capabilities. */</span>
<span class="p_del">-	pci-&gt;status = (1 &lt;&lt; 4);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Link them in. */</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.3.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The device MUST present at least one common configuration</span>
<span class="p_del">-	 *  capability.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	pci-&gt;capabilities = offsetof(struct pci_config, common);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* 4.1.4.3.1 ... offset MUST be 4-byte aligned. */</span>
<span class="p_del">-	assert(pci-&gt;capabilities % 4 == 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	bar_offset = offsetof(struct virtio_pci_mmio, cfg);</span>
<span class="p_del">-	bar_len = sizeof(((struct virtio_pci_mmio *)0)-&gt;cfg);</span>
<span class="p_del">-	init_cap(&amp;pci-&gt;common, sizeof(pci-&gt;common), VIRTIO_PCI_CAP_COMMON_CFG,</span>
<span class="p_del">-		 bar_offset, bar_len,</span>
<span class="p_del">-		 offsetof(struct pci_config, notify));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.4.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The device MUST present at least one notification capability.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	bar_offset += bar_len;</span>
<span class="p_del">-	bar_len = sizeof(((struct virtio_pci_mmio *)0)-&gt;notify);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.4.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The cap.offset MUST be 2-byte aligned.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	assert(pci-&gt;common.cap_next % 2 == 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* FIXME: Use a non-zero notify_off, for per-queue notification? */</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.4.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The value cap.length presented by the device MUST be at least 2 and</span>
<span class="p_del">-	 *  MUST be large enough to support queue notification offsets for all</span>
<span class="p_del">-	 *  supported queues in all possible configurations.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	assert(bar_len &gt;= 2);</span>
<span class="p_del">-</span>
<span class="p_del">-	init_cap(&amp;pci-&gt;notify.cap, sizeof(pci-&gt;notify),</span>
<span class="p_del">-		 VIRTIO_PCI_CAP_NOTIFY_CFG,</span>
<span class="p_del">-		 bar_offset, bar_len,</span>
<span class="p_del">-		 offsetof(struct pci_config, isr));</span>
<span class="p_del">-</span>
<span class="p_del">-	bar_offset += bar_len;</span>
<span class="p_del">-	bar_len = sizeof(((struct virtio_pci_mmio *)0)-&gt;isr);</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.5.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *  The device MUST present at least one VIRTIO_PCI_CAP_ISR_CFG</span>
<span class="p_del">-	 *  capability.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	init_cap(&amp;pci-&gt;isr, sizeof(pci-&gt;isr),</span>
<span class="p_del">-		 VIRTIO_PCI_CAP_ISR_CFG,</span>
<span class="p_del">-		 bar_offset, bar_len,</span>
<span class="p_del">-		 offsetof(struct pci_config, cfg_access));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * 4.1.4.7.1:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The device MUST present at least one VIRTIO_PCI_CAP_PCI_CFG</span>
<span class="p_del">-	 * capability.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	/* This doesn&#39;t have any presence in the BAR */</span>
<span class="p_del">-	init_cap(&amp;pci-&gt;cfg_access.cap, sizeof(pci-&gt;cfg_access),</span>
<span class="p_del">-		 VIRTIO_PCI_CAP_PCI_CFG,</span>
<span class="p_del">-		 0, 0, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	bar_offset += bar_len + sizeof(((struct virtio_pci_mmio *)0)-&gt;padding);</span>
<span class="p_del">-	assert(bar_offset == sizeof(struct virtio_pci_mmio));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This gets sewn in and length set in set_device_config().</span>
<span class="p_del">-	 * Some devices don&#39;t have a device configuration interface, so</span>
<span class="p_del">-	 * we never expose this if we don&#39;t call set_device_config().</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	init_cap(&amp;pci-&gt;device, sizeof(pci-&gt;device), VIRTIO_PCI_CAP_DEVICE_CFG,</span>
<span class="p_del">-		 bar_offset, 0, 0);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This routine does all the creation and setup of a new device, but we don&#39;t</span>
<span class="p_del">- * actually place the MMIO region until we know the size (if any) of the</span>
<span class="p_del">- * device-specific config.  And we don&#39;t actually start the service threads</span>
<span class="p_del">- * until later.</span>
<span class="p_del">- *</span>
<span class="p_del">- * See what I mean about userspace being boring?</span>
<span class="p_del">- */</span>
<span class="p_del">-static struct device *new_pci_device(const char *name, u16 type,</span>
<span class="p_del">-				     u8 class, u8 subclass)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct device *dev = malloc(sizeof(*dev));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now we populate the fields one at a time. */</span>
<span class="p_del">-	dev-&gt;name = name;</span>
<span class="p_del">-	dev-&gt;vq = NULL;</span>
<span class="p_del">-	dev-&gt;running = false;</span>
<span class="p_del">-	dev-&gt;wrote_features_ok = false;</span>
<span class="p_del">-	dev-&gt;mmio_size = sizeof(struct virtio_pci_mmio);</span>
<span class="p_del">-	dev-&gt;mmio = calloc(1, dev-&gt;mmio_size);</span>
<span class="p_del">-	dev-&gt;features = (u64)1 &lt;&lt; VIRTIO_F_VERSION_1;</span>
<span class="p_del">-	dev-&gt;features_accepted = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (devices.device_num + 1 &gt;= MAX_PCI_DEVICES)</span>
<span class="p_del">-		errx(1, &quot;Can only handle 31 PCI devices&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	init_pci_config(&amp;dev-&gt;config, type, class, subclass);</span>
<span class="p_del">-	assert(!devices.pci[devices.device_num+1]);</span>
<span class="p_del">-	devices.pci[++devices.device_num] = dev;</span>
<span class="p_del">-</span>
<span class="p_del">-	return dev;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Our first setup routine is the console.  It&#39;s a fairly simple device, but</span>
<span class="p_del">- * UNIX tty handling makes it uglier than it could be.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void setup_console(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct device *dev;</span>
<span class="p_del">-	struct virtio_console_config conf;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If we can save the initial standard input settings... */</span>
<span class="p_del">-	if (tcgetattr(STDIN_FILENO, &amp;orig_term) == 0) {</span>
<span class="p_del">-		struct termios term = orig_term;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Then we turn off echo, line buffering and ^C etc: We want a</span>
<span class="p_del">-		 * raw input stream to the Guest.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		term.c_lflag &amp;= ~(ISIG|ICANON|ECHO);</span>
<span class="p_del">-		tcsetattr(STDIN_FILENO, TCSANOW, &amp;term);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	dev = new_pci_device(&quot;console&quot;, VIRTIO_ID_CONSOLE, 0x07, 0x00);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We store the console state in dev-&gt;priv, and initialize it. */</span>
<span class="p_del">-	dev-&gt;priv = malloc(sizeof(struct console_abort));</span>
<span class="p_del">-	((struct console_abort *)dev-&gt;priv)-&gt;count = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The console needs two virtqueues: the input then the output.  When</span>
<span class="p_del">-	 * they put something the input queue, we make sure we&#39;re listening to</span>
<span class="p_del">-	 * stdin.  When they put something in the output queue, we write it to</span>
<span class="p_del">-	 * stdout.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	add_pci_virtqueue(dev, console_input, &quot;input&quot;);</span>
<span class="p_del">-	add_pci_virtqueue(dev, console_output, &quot;output&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We need a configuration area for the emerg_wr early writes. */</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_CONSOLE_F_EMERG_WRITE);</span>
<span class="p_del">-	set_device_config(dev, &amp;conf, sizeof(conf));</span>
<span class="p_del">-</span>
<span class="p_del">-	verbose(&quot;device %u: console\n&quot;, devices.device_num);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:010</span>
<span class="p_del">- * Inter-guest networking is an interesting area.  Simplest is to have a</span>
<span class="p_del">- * --sharenet=&lt;name&gt; option which opens or creates a named pipe.  This can be</span>
<span class="p_del">- * used to send packets to another guest in a 1:1 manner.</span>
<span class="p_del">- *</span>
<span class="p_del">- * More sophisticated is to use one of the tools developed for project like UML</span>
<span class="p_del">- * to do networking.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Faster is to do virtio bonding in kernel.  Doing this 1:1 would be</span>
<span class="p_del">- * completely generic (&quot;here&#39;s my vring, attach to your vring&quot;) and would work</span>
<span class="p_del">- * for any traffic.  Of course, namespace and permissions issues need to be</span>
<span class="p_del">- * dealt with.  A more sophisticated &quot;multi-channel&quot; virtio_net.c could hide</span>
<span class="p_del">- * multiple inter-guest channels behind one interface, although it would</span>
<span class="p_del">- * require some manner of hotplugging new virtio channels.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Finally, we could use a virtio network switch in the kernel, ie. vhost.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 str2ip(const char *ipaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int b[4];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (sscanf(ipaddr, &quot;%u.%u.%u.%u&quot;, &amp;b[0], &amp;b[1], &amp;b[2], &amp;b[3]) != 4)</span>
<span class="p_del">-		errx(1, &quot;Failed to parse IP address &#39;%s&#39;&quot;, ipaddr);</span>
<span class="p_del">-	return (b[0] &lt;&lt; 24) | (b[1] &lt;&lt; 16) | (b[2] &lt;&lt; 8) | b[3];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void str2mac(const char *macaddr, unsigned char mac[6])</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int m[6];</span>
<span class="p_del">-	if (sscanf(macaddr, &quot;%02x:%02x:%02x:%02x:%02x:%02x&quot;,</span>
<span class="p_del">-		   &amp;m[0], &amp;m[1], &amp;m[2], &amp;m[3], &amp;m[4], &amp;m[5]) != 6)</span>
<span class="p_del">-		errx(1, &quot;Failed to parse mac address &#39;%s&#39;&quot;, macaddr);</span>
<span class="p_del">-	mac[0] = m[0];</span>
<span class="p_del">-	mac[1] = m[1];</span>
<span class="p_del">-	mac[2] = m[2];</span>
<span class="p_del">-	mac[3] = m[3];</span>
<span class="p_del">-	mac[4] = m[4];</span>
<span class="p_del">-	mac[5] = m[5];</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This code is &quot;adapted&quot; from libbridge: it attaches the Host end of the</span>
<span class="p_del">- * network device to the bridge device specified by the command line.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is yet another James Morris contribution (I&#39;m an IP-level guy, so I</span>
<span class="p_del">- * dislike bridging), and I just try not to break it.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void add_to_bridge(int fd, const char *if_name, const char *br_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ifidx;</span>
<span class="p_del">-	struct ifreq ifr;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!*br_name)</span>
<span class="p_del">-		errx(1, &quot;must specify bridge name&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	ifidx = if_nametoindex(if_name);</span>
<span class="p_del">-	if (!ifidx)</span>
<span class="p_del">-		errx(1, &quot;interface %s does not exist!&quot;, if_name);</span>
<span class="p_del">-</span>
<span class="p_del">-	strncpy(ifr.ifr_name, br_name, IFNAMSIZ);</span>
<span class="p_del">-	ifr.ifr_name[IFNAMSIZ-1] = &#39;\0&#39;;</span>
<span class="p_del">-	ifr.ifr_ifindex = ifidx;</span>
<span class="p_del">-	if (ioctl(fd, SIOCBRADDIF, &amp;ifr) &lt; 0)</span>
<span class="p_del">-		err(1, &quot;can&#39;t add %s to bridge %s&quot;, if_name, br_name);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This sets up the Host end of the network device with an IP address, brings</span>
<span class="p_del">- * it up so packets will flow, the copies the MAC address into the hwaddr</span>
<span class="p_del">- * pointer.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void configure_device(int fd, const char *tapif, u32 ipaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ifreq ifr;</span>
<span class="p_del">-	struct sockaddr_in sin;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(&amp;ifr, 0, sizeof(ifr));</span>
<span class="p_del">-	strcpy(ifr.ifr_name, tapif);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Don&#39;t read these incantations.  Just cut &amp; paste them like I did! */</span>
<span class="p_del">-	sin.sin_family = AF_INET;</span>
<span class="p_del">-	sin.sin_addr.s_addr = htonl(ipaddr);</span>
<span class="p_del">-	memcpy(&amp;ifr.ifr_addr, &amp;sin, sizeof(sin));</span>
<span class="p_del">-	if (ioctl(fd, SIOCSIFADDR, &amp;ifr) != 0)</span>
<span class="p_del">-		err(1, &quot;Setting %s interface address&quot;, tapif);</span>
<span class="p_del">-	ifr.ifr_flags = IFF_UP;</span>
<span class="p_del">-	if (ioctl(fd, SIOCSIFFLAGS, &amp;ifr) != 0)</span>
<span class="p_del">-		err(1, &quot;Bringing interface %s up&quot;, tapif);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int get_tun_device(char tapif[IFNAMSIZ])</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ifreq ifr;</span>
<span class="p_del">-	int vnet_hdr_sz;</span>
<span class="p_del">-	int netfd;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Start with this zeroed.  Messy but sure. */</span>
<span class="p_del">-	memset(&amp;ifr, 0, sizeof(ifr));</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We open the /dev/net/tun device and tell it we want a tap device.  A</span>
<span class="p_del">-	 * tap device is like a tun device, only somehow different.  To tell</span>
<span class="p_del">-	 * the truth, I completely blundered my way through this code, but it</span>
<span class="p_del">-	 * works now!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	netfd = open_or_die(&quot;/dev/net/tun&quot;, O_RDWR);</span>
<span class="p_del">-	ifr.ifr_flags = IFF_TAP | IFF_NO_PI | IFF_VNET_HDR;</span>
<span class="p_del">-	strcpy(ifr.ifr_name, &quot;tap%d&quot;);</span>
<span class="p_del">-	if (ioctl(netfd, TUNSETIFF, &amp;ifr) != 0)</span>
<span class="p_del">-		err(1, &quot;configuring /dev/net/tun&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ioctl(netfd, TUNSETOFFLOAD,</span>
<span class="p_del">-		  TUN_F_CSUM|TUN_F_TSO4|TUN_F_TSO6|TUN_F_TSO_ECN) != 0)</span>
<span class="p_del">-		err(1, &quot;Could not set features for tun device&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We don&#39;t need checksums calculated for packets coming in this</span>
<span class="p_del">-	 * device: trust us!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ioctl(netfd, TUNSETNOCSUM, 1);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * In virtio before 1.0 (aka legacy virtio), we added a 16-bit</span>
<span class="p_del">-	 * field at the end of the network header iff</span>
<span class="p_del">-	 * VIRTIO_NET_F_MRG_RXBUF was negotiated.  For virtio 1.0,</span>
<span class="p_del">-	 * that became the norm, but we need to tell the tun device</span>
<span class="p_del">-	 * about our expanded header (which is called</span>
<span class="p_del">-	 * virtio_net_hdr_mrg_rxbuf in the legacy system).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	vnet_hdr_sz = sizeof(struct virtio_net_hdr_v1);</span>
<span class="p_del">-	if (ioctl(netfd, TUNSETVNETHDRSZ, &amp;vnet_hdr_sz) != 0)</span>
<span class="p_del">-		err(1, &quot;Setting tun header size to %u&quot;, vnet_hdr_sz);</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(tapif, ifr.ifr_name, IFNAMSIZ);</span>
<span class="p_del">-	return netfd;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:195</span>
<span class="p_del">- * Our network is a Host&lt;-&gt;Guest network.  This can either use bridging or</span>
<span class="p_del">- * routing, but the principle is the same: it uses the &quot;tun&quot; device to inject</span>
<span class="p_del">- * packets into the Host as if they came in from a normal network card.  We</span>
<span class="p_del">- * just shunt packets between the Guest and the tun device.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void setup_tun_net(char *arg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct device *dev;</span>
<span class="p_del">-	struct net_info *net_info = malloc(sizeof(*net_info));</span>
<span class="p_del">-	int ipfd;</span>
<span class="p_del">-	u32 ip = INADDR_ANY;</span>
<span class="p_del">-	bool bridging = false;</span>
<span class="p_del">-	char tapif[IFNAMSIZ], *p;</span>
<span class="p_del">-	struct virtio_net_config conf;</span>
<span class="p_del">-</span>
<span class="p_del">-	net_info-&gt;tunfd = get_tun_device(tapif);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First we create a new network device. */</span>
<span class="p_del">-	dev = new_pci_device(&quot;net&quot;, VIRTIO_ID_NET, 0x02, 0x00);</span>
<span class="p_del">-	dev-&gt;priv = net_info;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Network devices need a recv and a send queue, just like console. */</span>
<span class="p_del">-	add_pci_virtqueue(dev, net_input, &quot;rx&quot;);</span>
<span class="p_del">-	add_pci_virtqueue(dev, net_output, &quot;tx&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need a socket to perform the magic network ioctls to bring up the</span>
<span class="p_del">-	 * tap interface, connect to the bridge etc.  Any socket will do!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ipfd = socket(PF_INET, SOCK_DGRAM, IPPROTO_IP);</span>
<span class="p_del">-	if (ipfd &lt; 0)</span>
<span class="p_del">-		err(1, &quot;opening IP socket&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If the command line was --tunnet=bridge:&lt;name&gt; do bridging. */</span>
<span class="p_del">-	if (!strncmp(BRIDGE_PFX, arg, strlen(BRIDGE_PFX))) {</span>
<span class="p_del">-		arg += strlen(BRIDGE_PFX);</span>
<span class="p_del">-		bridging = true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* A mac address may follow the bridge name or IP address */</span>
<span class="p_del">-	p = strchr(arg, &#39;:&#39;);</span>
<span class="p_del">-	if (p) {</span>
<span class="p_del">-		str2mac(p+1, conf.mac);</span>
<span class="p_del">-		add_pci_feature(dev, VIRTIO_NET_F_MAC);</span>
<span class="p_del">-		*p = &#39;\0&#39;;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* arg is now either an IP address or a bridge name */</span>
<span class="p_del">-	if (bridging)</span>
<span class="p_del">-		add_to_bridge(ipfd, tapif, arg);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		ip = str2ip(arg);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set up the tun device. */</span>
<span class="p_del">-	configure_device(ipfd, tapif, ip);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Expect Guest to handle everything except UFO */</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_CSUM);</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_GUEST_CSUM);</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_GUEST_TSO4);</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_GUEST_TSO6);</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_GUEST_ECN);</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_HOST_TSO4);</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_HOST_TSO6);</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_NET_F_HOST_ECN);</span>
<span class="p_del">-	/* We handle indirect ring entries */</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_RING_F_INDIRECT_DESC);</span>
<span class="p_del">-	set_device_config(dev, &amp;conf, sizeof(conf));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We don&#39;t need the socket any more; setup is done. */</span>
<span class="p_del">-	close(ipfd);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (bridging)</span>
<span class="p_del">-		verbose(&quot;device %u: tun %s attached to bridge: %s\n&quot;,</span>
<span class="p_del">-			devices.device_num, tapif, arg);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		verbose(&quot;device %u: tun %s: %s\n&quot;,</span>
<span class="p_del">-			devices.device_num, tapif, arg);</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/* This hangs off device-&gt;priv. */</span>
<span class="p_del">-struct vblk_info {</span>
<span class="p_del">-	/* The size of the file. */</span>
<span class="p_del">-	off64_t len;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The file descriptor for the file. */</span>
<span class="p_del">-	int fd;</span>
<span class="p_del">-</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:210</span>
<span class="p_del">- * The Disk</span>
<span class="p_del">- *</span>
<span class="p_del">- * The disk only has one virtqueue, so it only has one thread.  It is really</span>
<span class="p_del">- * simple: the Guest asks for a block number and we read or write that position</span>
<span class="p_del">- * in the file.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Before we serviced each virtqueue in a separate thread, that was unacceptably</span>
<span class="p_del">- * slow: the Guest waits until the read is finished before running anything</span>
<span class="p_del">- * else, even if it could have been doing useful work.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We could have used async I/O, except it&#39;s reputed to suck so hard that</span>
<span class="p_del">- * characters actually go missing from your code when you try to use it.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void blk_request(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct vblk_info *vblk = vq-&gt;dev-&gt;priv;</span>
<span class="p_del">-	unsigned int head, out_num, in_num, wlen;</span>
<span class="p_del">-	int ret, i;</span>
<span class="p_del">-	u8 *in;</span>
<span class="p_del">-	struct virtio_blk_outhdr out;</span>
<span class="p_del">-	struct iovec iov[vq-&gt;vring.num];</span>
<span class="p_del">-	off64_t off;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Get the next request, where we normally wait.  It triggers the</span>
<span class="p_del">-	 * interrupt to acknowledge previously serviced requests (if any).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	head = wait_for_vq_desc(vq, iov, &amp;out_num, &amp;in_num);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Copy the output header from the front of the iov (adjusts iov) */</span>
<span class="p_del">-	iov_consume(vq-&gt;dev, iov, out_num, &amp;out, sizeof(out));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Find and trim end of iov input array, for our status byte. */</span>
<span class="p_del">-	in = NULL;</span>
<span class="p_del">-	for (i = out_num + in_num - 1; i &gt;= out_num; i--) {</span>
<span class="p_del">-		if (iov[i].iov_len &gt; 0) {</span>
<span class="p_del">-			in = iov[i].iov_base + iov[i].iov_len - 1;</span>
<span class="p_del">-			iov[i].iov_len--;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (!in)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Bad virtblk cmd with no room for status&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * For historical reasons, block operations are expressed in 512 byte</span>
<span class="p_del">-	 * &quot;sectors&quot;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	off = out.sector * 512;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (out.type &amp; VIRTIO_BLK_T_OUT) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Write</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Move to the right location in the block file.  This can fail</span>
<span class="p_del">-		 * if they try to write past end.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (lseek64(vblk-&gt;fd, off, SEEK_SET) != off)</span>
<span class="p_del">-			err(1, &quot;Bad seek to sector %llu&quot;, out.sector);</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = writev(vblk-&gt;fd, iov, out_num);</span>
<span class="p_del">-		verbose(&quot;WRITE to sector %llu: %i\n&quot;, out.sector, ret);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Grr... Now we know how long the descriptor they sent was, we</span>
<span class="p_del">-		 * make sure they didn&#39;t try to write over the end of the block</span>
<span class="p_del">-		 * file (possibly extending it).</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ret &gt; 0 &amp;&amp; off + ret &gt; vblk-&gt;len) {</span>
<span class="p_del">-			/* Trim it back to the correct length */</span>
<span class="p_del">-			ftruncate64(vblk-&gt;fd, vblk-&gt;len);</span>
<span class="p_del">-			/* Die, bad Guest, die. */</span>
<span class="p_del">-			bad_driver_vq(vq, &quot;Write past end %llu+%u&quot;, off, ret);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		wlen = sizeof(*in);</span>
<span class="p_del">-		*in = (ret &gt;= 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR);</span>
<span class="p_del">-	} else if (out.type &amp; VIRTIO_BLK_T_FLUSH) {</span>
<span class="p_del">-		/* Flush */</span>
<span class="p_del">-		ret = fdatasync(vblk-&gt;fd);</span>
<span class="p_del">-		verbose(&quot;FLUSH fdatasync: %i\n&quot;, ret);</span>
<span class="p_del">-		wlen = sizeof(*in);</span>
<span class="p_del">-		*in = (ret &gt;= 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Read</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Move to the right location in the block file.  This can fail</span>
<span class="p_del">-		 * if they try to read past end.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (lseek64(vblk-&gt;fd, off, SEEK_SET) != off)</span>
<span class="p_del">-			err(1, &quot;Bad seek to sector %llu&quot;, out.sector);</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = readv(vblk-&gt;fd, iov + out_num, in_num);</span>
<span class="p_del">-		if (ret &gt;= 0) {</span>
<span class="p_del">-			wlen = sizeof(*in) + ret;</span>
<span class="p_del">-			*in = VIRTIO_BLK_S_OK;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			wlen = sizeof(*in);</span>
<span class="p_del">-			*in = VIRTIO_BLK_S_IOERR;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Finished that request. */</span>
<span class="p_del">-	add_used(vq, head, wlen);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:198 This actually sets up a virtual block device. */</span>
<span class="p_del">-static void setup_block_file(const char *filename)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct device *dev;</span>
<span class="p_del">-	struct vblk_info *vblk;</span>
<span class="p_del">-	struct virtio_blk_config conf;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Create the device. */</span>
<span class="p_del">-	dev = new_pci_device(&quot;block&quot;, VIRTIO_ID_BLOCK, 0x01, 0x80);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The device has one virtqueue, where the Guest places requests. */</span>
<span class="p_del">-	add_pci_virtqueue(dev, blk_request, &quot;request&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Allocate the room for our own bookkeeping */</span>
<span class="p_del">-	vblk = dev-&gt;priv = malloc(sizeof(*vblk));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First we open the file and store the length. */</span>
<span class="p_del">-	vblk-&gt;fd = open_or_die(filename, O_RDWR|O_LARGEFILE);</span>
<span class="p_del">-	vblk-&gt;len = lseek64(vblk-&gt;fd, 0, SEEK_END);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Tell Guest how many sectors this device has. */</span>
<span class="p_del">-	conf.capacity = cpu_to_le64(vblk-&gt;len / 512);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Tell Guest not to put in too many descriptors at once: two are used</span>
<span class="p_del">-	 * for the in and out elements.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	add_pci_feature(dev, VIRTIO_BLK_F_SEG_MAX);</span>
<span class="p_del">-	conf.seg_max = cpu_to_le32(VIRTQUEUE_NUM - 2);</span>
<span class="p_del">-</span>
<span class="p_del">-	set_device_config(dev, &amp;conf, sizeof(struct virtio_blk_config));</span>
<span class="p_del">-</span>
<span class="p_del">-	verbose(&quot;device %u: virtblock %llu sectors\n&quot;,</span>
<span class="p_del">-		devices.device_num, le64_to_cpu(conf.capacity));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:211</span>
<span class="p_del">- * Our random number generator device reads from /dev/urandom into the Guest&#39;s</span>
<span class="p_del">- * input buffers.  The usual case is that the Guest doesn&#39;t want random numbers</span>
<span class="p_del">- * and so has no buffers although /dev/urandom is still readable, whereas</span>
<span class="p_del">- * console is the reverse.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The same logic applies, however.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct rng_info {</span>
<span class="p_del">-	int rfd;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void rng_input(struct virtqueue *vq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int len;</span>
<span class="p_del">-	unsigned int head, in_num, out_num, totlen = 0;</span>
<span class="p_del">-	struct rng_info *rng_info = vq-&gt;dev-&gt;priv;</span>
<span class="p_del">-	struct iovec iov[vq-&gt;vring.num];</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First we need a buffer from the Guests&#39;s virtqueue. */</span>
<span class="p_del">-	head = wait_for_vq_desc(vq, iov, &amp;out_num, &amp;in_num);</span>
<span class="p_del">-	if (out_num)</span>
<span class="p_del">-		bad_driver_vq(vq, &quot;Output buffers in rng?&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Just like the console write, we loop to cover the whole iovec.</span>
<span class="p_del">-	 * In this case, short reads actually happen quite a bit.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	while (!iov_empty(iov, in_num)) {</span>
<span class="p_del">-		len = readv(rng_info-&gt;rfd, iov, in_num);</span>
<span class="p_del">-		if (len &lt;= 0)</span>
<span class="p_del">-			err(1, &quot;Read from /dev/urandom gave %i&quot;, len);</span>
<span class="p_del">-		iov_consume(vq-&gt;dev, iov, in_num, NULL, len);</span>
<span class="p_del">-		totlen += len;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Tell the Guest about the new input. */</span>
<span class="p_del">-	add_used(vq, head, totlen);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:199</span>
<span class="p_del">- * This creates a &quot;hardware&quot; random number device for the Guest.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void setup_rng(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct device *dev;</span>
<span class="p_del">-	struct rng_info *rng_info = malloc(sizeof(*rng_info));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Our device&#39;s private info simply contains the /dev/urandom fd. */</span>
<span class="p_del">-	rng_info-&gt;rfd = open_or_die(&quot;/dev/urandom&quot;, O_RDONLY);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Create the new device. */</span>
<span class="p_del">-	dev = new_pci_device(&quot;rng&quot;, VIRTIO_ID_RNG, 0xff, 0);</span>
<span class="p_del">-	dev-&gt;priv = rng_info;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The device has one virtqueue, where the Guest places inbufs. */</span>
<span class="p_del">-	add_pci_virtqueue(dev, rng_input, &quot;input&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We don&#39;t have any configuration space */</span>
<span class="p_del">-	no_device_config(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	verbose(&quot;device %u: rng\n&quot;, devices.device_num);</span>
<span class="p_del">-}</span>
<span class="p_del">-/* That&#39;s the end of device setup. */</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:230 Reboot is pretty easy: clean up and exec() the Launcher afresh. */</span>
<span class="p_del">-static void __attribute__((noreturn)) restart_guest(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Since we don&#39;t track all open fds, we simply close everything beyond</span>
<span class="p_del">-	 * stderr.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 3; i &lt; FD_SETSIZE; i++)</span>
<span class="p_del">-		close(i);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Reset all the devices (kills all threads). */</span>
<span class="p_del">-	cleanup_devices();</span>
<span class="p_del">-</span>
<span class="p_del">-	execv(main_args[0], main_args);</span>
<span class="p_del">-	err(1, &quot;Could not exec %s&quot;, main_args[0]);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:220</span>
<span class="p_del">- * Finally we reach the core of the Launcher which runs the Guest, serves</span>
<span class="p_del">- * its input and output, and finally, lays it to rest.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void __attribute__((noreturn)) run_guest(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	for (;;) {</span>
<span class="p_del">-		struct lguest_pending notify;</span>
<span class="p_del">-		int readval;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* We read from the /dev/lguest device to run the Guest. */</span>
<span class="p_del">-		readval = pread(lguest_fd, &amp;notify, sizeof(notify), cpu_id);</span>
<span class="p_del">-		if (readval == sizeof(notify)) {</span>
<span class="p_del">-			if (notify.trap == 13) {</span>
<span class="p_del">-				verbose(&quot;Emulating instruction at %#x\n&quot;,</span>
<span class="p_del">-					getreg(eip));</span>
<span class="p_del">-				emulate_insn(notify.insn);</span>
<span class="p_del">-			} else if (notify.trap == 14) {</span>
<span class="p_del">-				verbose(&quot;Emulating MMIO at %#x\n&quot;,</span>
<span class="p_del">-					getreg(eip));</span>
<span class="p_del">-				emulate_mmio(notify.addr, notify.insn);</span>
<span class="p_del">-			} else</span>
<span class="p_del">-				errx(1, &quot;Unknown trap %i addr %#08x\n&quot;,</span>
<span class="p_del">-				     notify.trap, notify.addr);</span>
<span class="p_del">-		/* ENOENT means the Guest died.  Reading tells us why. */</span>
<span class="p_del">-		} else if (errno == ENOENT) {</span>
<span class="p_del">-			char reason[1024] = { 0 };</span>
<span class="p_del">-			pread(lguest_fd, reason, sizeof(reason)-1, cpu_id);</span>
<span class="p_del">-			errx(1, &quot;%s&quot;, reason);</span>
<span class="p_del">-		/* ERESTART means that we need to reboot the guest */</span>
<span class="p_del">-		} else if (errno == ERESTART) {</span>
<span class="p_del">-			restart_guest();</span>
<span class="p_del">-		/* Anything else means a bug or incompatible change. */</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			err(1, &quot;Running guest failed&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-/*L:240</span>
<span class="p_del">- * This is the end of the Launcher.  The good news: we are over halfway</span>
<span class="p_del">- * through!  The bad news: the most fiendish part of the code still lies ahead</span>
<span class="p_del">- * of us.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Are you ready?  Take a deep breath and join me in the core of the Host, in</span>
<span class="p_del">- * &quot;make Host&quot;.</span>
<span class="p_del">-:*/</span>
<span class="p_del">-</span>
<span class="p_del">-static struct option opts[] = {</span>
<span class="p_del">-	{ &quot;verbose&quot;, 0, NULL, &#39;v&#39; },</span>
<span class="p_del">-	{ &quot;tunnet&quot;, 1, NULL, &#39;t&#39; },</span>
<span class="p_del">-	{ &quot;block&quot;, 1, NULL, &#39;b&#39; },</span>
<span class="p_del">-	{ &quot;rng&quot;, 0, NULL, &#39;r&#39; },</span>
<span class="p_del">-	{ &quot;initrd&quot;, 1, NULL, &#39;i&#39; },</span>
<span class="p_del">-	{ &quot;username&quot;, 1, NULL, &#39;u&#39; },</span>
<span class="p_del">-	{ &quot;chroot&quot;, 1, NULL, &#39;c&#39; },</span>
<span class="p_del">-	{ NULL },</span>
<span class="p_del">-};</span>
<span class="p_del">-static void usage(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	errx(1, &quot;Usage: lguest [--verbose] &quot;</span>
<span class="p_del">-	     &quot;[--tunnet=(&lt;ipaddr&gt;:&lt;macaddr&gt;|bridge:&lt;bridgename&gt;:&lt;macaddr&gt;)\n&quot;</span>
<span class="p_del">-	     &quot;|--block=&lt;filename&gt;|--initrd=&lt;filename&gt;]...\n&quot;</span>
<span class="p_del">-	     &quot;&lt;mem-in-mb&gt; vmlinux [args...]&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*L:105 The main routine is where the real work begins: */</span>
<span class="p_del">-int main(int argc, char *argv[])</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Memory, code startpoint and size of the (optional) initrd. */</span>
<span class="p_del">-	unsigned long mem = 0, start, initrd_size = 0;</span>
<span class="p_del">-	/* Two temporaries. */</span>
<span class="p_del">-	int i, c;</span>
<span class="p_del">-	/* The boot information for the Guest. */</span>
<span class="p_del">-	struct boot_params *boot;</span>
<span class="p_del">-	/* If they specify an initrd file to load. */</span>
<span class="p_del">-	const char *initrd_name = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Password structure for initgroups/setres[gu]id */</span>
<span class="p_del">-	struct passwd *user_details = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Directory to chroot to */</span>
<span class="p_del">-	char *chroot_path = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save the args: we &quot;reboot&quot; by execing ourselves again. */</span>
<span class="p_del">-	main_args = argv;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * First we initialize the device list.  We remember next interrupt</span>
<span class="p_del">-	 * number to use for devices (1: remember that 0 is used by the timer).</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	devices.next_irq = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We&#39;re CPU 0.  In fact, that&#39;s the only CPU possible right now. */</span>
<span class="p_del">-	cpu_id = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to know how much memory so we can set up the device</span>
<span class="p_del">-	 * descriptor and memory pages for the devices as we parse the command</span>
<span class="p_del">-	 * line.  So we quickly look through the arguments to find the amount</span>
<span class="p_del">-	 * of memory now.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (i = 1; i &lt; argc; i++) {</span>
<span class="p_del">-		if (argv[i][0] != &#39;-&#39;) {</span>
<span class="p_del">-			mem = atoi(argv[i]) * 1024 * 1024;</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We start by mapping anonymous pages over all of</span>
<span class="p_del">-			 * guest-physical memory range.  This fills it with 0,</span>
<span class="p_del">-			 * and ensures that the Guest won&#39;t be killed when it</span>
<span class="p_del">-			 * tries to access it.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			guest_base = map_zeroed_pages(mem / getpagesize()</span>
<span class="p_del">-						      + DEVICE_PAGES);</span>
<span class="p_del">-			guest_limit = mem;</span>
<span class="p_del">-			guest_max = guest_mmio = mem + DEVICE_PAGES*getpagesize();</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If we exit via err(), this kills all the threads, restores tty. */</span>
<span class="p_del">-	atexit(cleanup_devices);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We always have a console device, and it&#39;s always device 1. */</span>
<span class="p_del">-	setup_console();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The options are fairly straight-forward */</span>
<span class="p_del">-	while ((c = getopt_long(argc, argv, &quot;v&quot;, opts, NULL)) != EOF) {</span>
<span class="p_del">-		switch (c) {</span>
<span class="p_del">-		case &#39;v&#39;:</span>
<span class="p_del">-			verbose = true;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case &#39;t&#39;:</span>
<span class="p_del">-			setup_tun_net(optarg);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case &#39;b&#39;:</span>
<span class="p_del">-			setup_block_file(optarg);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case &#39;r&#39;:</span>
<span class="p_del">-			setup_rng();</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case &#39;i&#39;:</span>
<span class="p_del">-			initrd_name = optarg;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case &#39;u&#39;:</span>
<span class="p_del">-			user_details = getpwnam(optarg);</span>
<span class="p_del">-			if (!user_details)</span>
<span class="p_del">-				err(1, &quot;getpwnam failed, incorrect username?&quot;);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case &#39;c&#39;:</span>
<span class="p_del">-			chroot_path = optarg;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		default:</span>
<span class="p_del">-			warnx(&quot;Unknown argument %s&quot;, argv[optind]);</span>
<span class="p_del">-			usage();</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * After the other arguments we expect memory and kernel image name,</span>
<span class="p_del">-	 * followed by command line arguments for the kernel.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (optind + 2 &gt; argc)</span>
<span class="p_del">-		usage();</span>
<span class="p_del">-</span>
<span class="p_del">-	verbose(&quot;Guest base is at %p\n&quot;, guest_base);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialize the (fake) PCI host bridge device. */</span>
<span class="p_del">-	init_pci_host_bridge();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now we load the kernel */</span>
<span class="p_del">-	start = load_kernel(open_or_die(argv[optind+1], O_RDONLY));</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Boot information is stashed at physical address 0 */</span>
<span class="p_del">-	boot = from_guest_phys(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Map the initrd image if requested (at top of physical memory) */</span>
<span class="p_del">-	if (initrd_name) {</span>
<span class="p_del">-		initrd_size = load_initrd(initrd_name, mem);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * These are the location in the Linux boot header where the</span>
<span class="p_del">-		 * start and size of the initrd are expected to be found.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		boot-&gt;hdr.ramdisk_image = mem - initrd_size;</span>
<span class="p_del">-		boot-&gt;hdr.ramdisk_size = initrd_size;</span>
<span class="p_del">-		/* The bootloader type 0xFF means &quot;unknown&quot;; that&#39;s OK. */</span>
<span class="p_del">-		boot-&gt;hdr.type_of_loader = 0xFF;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The Linux boot header contains an &quot;E820&quot; memory map: ours is a</span>
<span class="p_del">-	 * simple, single region.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	boot-&gt;e820_entries = 1;</span>
<span class="p_del">-	boot-&gt;e820_table[0] = ((struct e820_entry) { 0, mem, E820_TYPE_RAM });</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The boot header contains a command line pointer: we put the command</span>
<span class="p_del">-	 * line after the boot header.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	boot-&gt;hdr.cmd_line_ptr = to_guest_phys(boot + 1);</span>
<span class="p_del">-	/* We use a simple helper to copy the arguments separated by spaces. */</span>
<span class="p_del">-	concat((char *)(boot + 1), argv+optind+2);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set kernel alignment to 16M (CONFIG_PHYSICAL_ALIGN) */</span>
<span class="p_del">-	boot-&gt;hdr.kernel_alignment = 0x1000000;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Boot protocol version: 2.07 supports the fields for lguest. */</span>
<span class="p_del">-	boot-&gt;hdr.version = 0x207;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* X86_SUBARCH_LGUEST tells the Guest it&#39;s an lguest. */</span>
<span class="p_del">-	boot-&gt;hdr.hardware_subarch = X86_SUBARCH_LGUEST;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Tell the entry path not to try to reload segment registers. */</span>
<span class="p_del">-	boot-&gt;hdr.loadflags |= KEEP_SEGMENTS;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We don&#39;t support tboot: */</span>
<span class="p_del">-	boot-&gt;tboot_addr = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Ensure this is 0 to prevent APM from loading: */</span>
<span class="p_del">-	boot-&gt;apm_bios_info.version = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We tell the kernel to initialize the Guest. */</span>
<span class="p_del">-	tell_kernel(start);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Ensure that we terminate if a device-servicing child dies. */</span>
<span class="p_del">-	signal(SIGCHLD, kill_launcher);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If requested, chroot to a directory */</span>
<span class="p_del">-	if (chroot_path) {</span>
<span class="p_del">-		if (chroot(chroot_path) != 0)</span>
<span class="p_del">-			err(1, &quot;chroot(\&quot;%s\&quot;) failed&quot;, chroot_path);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (chdir(&quot;/&quot;) != 0)</span>
<span class="p_del">-			err(1, &quot;chdir(\&quot;/\&quot;) failed&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		verbose(&quot;chroot done\n&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If requested, drop privileges */</span>
<span class="p_del">-	if (user_details) {</span>
<span class="p_del">-		uid_t u;</span>
<span class="p_del">-		gid_t g;</span>
<span class="p_del">-</span>
<span class="p_del">-		u = user_details-&gt;pw_uid;</span>
<span class="p_del">-		g = user_details-&gt;pw_gid;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (initgroups(user_details-&gt;pw_name, g) != 0)</span>
<span class="p_del">-			err(1, &quot;initgroups failed&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (setresgid(g, g, g) != 0)</span>
<span class="p_del">-			err(1, &quot;setresgid failed&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (setresuid(u, u, u) != 0)</span>
<span class="p_del">-			err(1, &quot;setresuid failed&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-		verbose(&quot;Dropping privileges completed\n&quot;);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Finally, run the Guest.  This doesn&#39;t return. */</span>
<span class="p_del">-	run_guest();</span>
<span class="p_del">-}</span>
<span class="p_del">-/*:*/</span>
<span class="p_del">-</span>
<span class="p_del">-/*M:999</span>
<span class="p_del">- * Mastery is done: you now know everything I do.</span>
<span class="p_del">- *</span>
<span class="p_del">- * But surely you have seen code, features and bugs in your wanderings which</span>
<span class="p_del">- * you now yearn to attack?  That is the real game, and I look forward to you</span>
<span class="p_del">- * patching and forking lguest into the Your-Name-Here-visor.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Farewell, and good coding!</span>
<span class="p_del">- * Rusty Russell.</span>
<span class="p_del">- */</span>
<span class="p_header">diff --git a/tools/lguest/lguest.txt b/tools/lguest/lguest.txt</span>
deleted file mode 100644
<span class="p_header">index 06e1f4649511..000000000000</span>
<span class="p_header">--- a/tools/lguest/lguest.txt</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,125 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-      __</span>
<span class="p_del">- (___()&#39;`;  Rusty&#39;s Remarkably Unreliable Guide to Lguest</span>
<span class="p_del">- /,    /`      - or, A Young Coder&#39;s Illustrated Hypervisor</span>
<span class="p_del">- \\&quot;--\\    http://lguest.ozlabs.org</span>
<span class="p_del">-</span>
<span class="p_del">-Lguest is designed to be a minimal 32-bit x86 hypervisor for the Linux kernel,</span>
<span class="p_del">-for Linux developers and users to experiment with virtualization with the</span>
<span class="p_del">-minimum of complexity.  Nonetheless, it should have sufficient features to</span>
<span class="p_del">-make it useful for specific tasks, and, of course, you are encouraged to fork</span>
<span class="p_del">-and enhance it (see drivers/lguest/README).</span>
<span class="p_del">-</span>
<span class="p_del">-Features:</span>
<span class="p_del">-</span>
<span class="p_del">-- Kernel module which runs in a normal kernel.</span>
<span class="p_del">-- Simple I/O model for communication.</span>
<span class="p_del">-- Simple program to create new guests.</span>
<span class="p_del">-- Logo contains cute puppies: http://lguest.ozlabs.org</span>
<span class="p_del">-</span>
<span class="p_del">-Developer features:</span>
<span class="p_del">-</span>
<span class="p_del">-- Fun to hack on.</span>
<span class="p_del">-- No ABI: being tied to a specific kernel anyway, you can change anything.</span>
<span class="p_del">-- Many opportunities for improvement or feature implementation.</span>
<span class="p_del">-</span>
<span class="p_del">-Running Lguest:</span>
<span class="p_del">-</span>
<span class="p_del">-- The easiest way to run lguest is to use same kernel as guest and host.</span>
<span class="p_del">-  You can configure them differently, but usually it&#39;s easiest not to.</span>
<span class="p_del">-</span>
<span class="p_del">-  You will need to configure your kernel with the following options:</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;Processor type and features&quot;:</span>
<span class="p_del">-     &quot;Paravirtualized guest support&quot; = Y</span>
<span class="p_del">-        &quot;Lguest guest support&quot; = Y</span>
<span class="p_del">-     &quot;High Memory Support&quot; = off/4GB</span>
<span class="p_del">-     &quot;Alignment value to which kernel should be aligned&quot; = 0x100000</span>
<span class="p_del">-        (CONFIG_PARAVIRT=y, CONFIG_LGUEST_GUEST=y, CONFIG_HIGHMEM64G=n and</span>
<span class="p_del">-         CONFIG_PHYSICAL_ALIGN=0x100000)</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;Device Drivers&quot;:</span>
<span class="p_del">-     &quot;Block devices&quot;</span>
<span class="p_del">-        &quot;Virtio block driver&quot; = M/Y</span>
<span class="p_del">-     &quot;Network device support&quot;</span>
<span class="p_del">-        &quot;Universal TUN/TAP device driver support&quot; = M/Y</span>
<span class="p_del">-        &quot;Virtio network driver&quot; = M/Y</span>
<span class="p_del">-           (CONFIG_VIRTIO_BLK=m, CONFIG_VIRTIO_NET=m and CONFIG_TUN=m)</span>
<span class="p_del">-</span>
<span class="p_del">-  &quot;Virtualization&quot;</span>
<span class="p_del">-     &quot;Linux hypervisor example code&quot; = M/Y</span>
<span class="p_del">-        (CONFIG_LGUEST=m)</span>
<span class="p_del">-</span>
<span class="p_del">-- A tool called &quot;lguest&quot; is available in this directory: type &quot;make&quot;</span>
<span class="p_del">-  to build it.  If you didn&#39;t build your kernel in-tree, use &quot;make</span>
<span class="p_del">-  O=&lt;builddir&gt;&quot;.</span>
<span class="p_del">-</span>
<span class="p_del">-- Create or find a root disk image.  There are several useful ones</span>
<span class="p_del">-  around, such as the xm-test tiny root image at</span>
<span class="p_del">-	  http://xm-test.xensource.com/ramdisks/initrd-1.1-i386.img</span>
<span class="p_del">-</span>
<span class="p_del">-  For more serious work, I usually use a distribution ISO image and</span>
<span class="p_del">-  install it under qemu, then make multiple copies:</span>
<span class="p_del">-</span>
<span class="p_del">-	  dd if=/dev/zero of=rootfile bs=1M count=2048</span>
<span class="p_del">-	  qemu -cdrom image.iso -hda rootfile -net user -net nic -boot d</span>
<span class="p_del">-</span>
<span class="p_del">-  Make sure that you install a getty on /dev/hvc0 if you want to log in on the</span>
<span class="p_del">-  console!</span>
<span class="p_del">-</span>
<span class="p_del">-- &quot;modprobe lg&quot; if you built it as a module.</span>
<span class="p_del">-</span>
<span class="p_del">-- Run an lguest as root:</span>
<span class="p_del">-</span>
<span class="p_del">-      tools/lguest/lguest 64 vmlinux --tunnet=192.168.19.1 \</span>
<span class="p_del">-        --block=rootfile root=/dev/vda</span>
<span class="p_del">-</span>
<span class="p_del">-   Explanation:</span>
<span class="p_del">-    64: the amount of memory to use, in MB.</span>
<span class="p_del">-</span>
<span class="p_del">-    vmlinux: the kernel image found in the top of your build directory.  You</span>
<span class="p_del">-       can also use a standard bzImage.</span>
<span class="p_del">-</span>
<span class="p_del">-    --tunnet=192.168.19.1: configures a &quot;tap&quot; device for networking with this</span>
<span class="p_del">-       IP address.</span>
<span class="p_del">-</span>
<span class="p_del">-    --block=rootfile: a file or block device which becomes /dev/vda</span>
<span class="p_del">-       inside the guest.</span>
<span class="p_del">-</span>
<span class="p_del">-    root=/dev/vda: this (and anything else on the command line) are</span>
<span class="p_del">-       kernel boot parameters.</span>
<span class="p_del">-</span>
<span class="p_del">-- Configuring networking.  I usually have the host masquerade, using</span>
<span class="p_del">-  &quot;iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&quot; and &quot;echo 1 &gt;</span>
<span class="p_del">-  /proc/sys/net/ipv4/ip_forward&quot;.  In this example, I would configure</span>
<span class="p_del">-  eth0 inside the guest at 192.168.19.2.</span>
<span class="p_del">-</span>
<span class="p_del">-  Another method is to bridge the tap device to an external interface</span>
<span class="p_del">-  using --tunnet=bridge:&lt;bridgename&gt;, and perhaps run dhcp on the guest</span>
<span class="p_del">-  to obtain an IP address.  The bridge needs to be configured first:</span>
<span class="p_del">-  this option simply adds the tap interface to it.</span>
<span class="p_del">-</span>
<span class="p_del">-  A simple example on my system:</span>
<span class="p_del">-</span>
<span class="p_del">-    ifconfig eth0 0.0.0.0</span>
<span class="p_del">-    brctl addbr lg0</span>
<span class="p_del">-    ifconfig lg0 up</span>
<span class="p_del">-    brctl addif lg0 eth0</span>
<span class="p_del">-    dhclient lg0</span>
<span class="p_del">-</span>
<span class="p_del">-  Then use --tunnet=bridge:lg0 when launching the guest.</span>
<span class="p_del">-</span>
<span class="p_del">-  See:</span>
<span class="p_del">-  </span>
<span class="p_del">-    http://www.linuxfoundation.org/collaborate/workgroups/networking/bridge</span>
<span class="p_del">-    </span>
<span class="p_del">-  for general information on how to get bridging to work.</span>
<span class="p_del">-</span>
<span class="p_del">-- Random number generation. Using the --rng option will provide a</span>
<span class="p_del">-  /dev/hwrng in the guest that will read from the host&#39;s /dev/random.</span>
<span class="p_del">-  Use this option in conjunction with rng-tools (see ../hw_random.txt)</span>
<span class="p_del">-  to provide entropy to the guest kernel&#39;s /dev/random.</span>
<span class="p_del">-</span>
<span class="p_del">-There is a helpful mailing list at http://ozlabs.org/mailman/listinfo/lguest</span>
<span class="p_del">-</span>
<span class="p_del">-Good luck!</span>
<span class="p_del">-Rusty Russell rusty@rustcorp.com.au.</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



