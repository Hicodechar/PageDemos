
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>arm: perf: Add event descriptions - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    arm: perf: Add event descriptions</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=88861">Drew Richardson</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 4, 2015, 12:15 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150804001522.GA13214@dreric01-gentoo.localdomain&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6933511/mbox/"
   >mbox</a>
|
   <a href="/patch/6933511/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6933511/">/patch/6933511/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id C5F8BC05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  4 Aug 2015 00:16:52 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id BF0D4205FF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  4 Aug 2015 00:16:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 7742D205F7
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  4 Aug 2015 00:16:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755858AbbHDAQK (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 3 Aug 2015 20:16:10 -0400
Received: from foss.arm.com ([217.140.101.70]:55698 &quot;EHLO foss.arm.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1753640AbbHDAQI (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 3 Aug 2015 20:16:08 -0400
Received: from usa-sjc-imap-foss1.foss.arm.com (unknown [10.72.51.249])
	by usa-sjc-mx-foss1.foss.arm.com (Postfix) with ESMTP id 3D62F75;
	Mon,  3 Aug 2015 17:16:11 -0700 (PDT)
Received: from localhost (usa-sjc-imap-foss1.foss.arm.com [10.72.51.249])
	by usa-sjc-imap-foss1.foss.arm.com (Postfix) with ESMTPSA id
	9055D3F318; Mon,  3 Aug 2015 17:16:06 -0700 (PDT)
Date: Mon, 3 Aug 2015 17:15:26 -0700
From: Drew Richardson &lt;drew.richardson@arm.com&gt;
To: Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;, Ingo Molnar &lt;mingo@redhat.com&gt;,
	Arnaldo Carvalho de Melo &lt;acme@kernel.org&gt;,
	Will Deacon &lt;will.deacon@arm.com&gt;, Russell King &lt;linux@arm.linux.org.uk&gt;,
	linux-kernel@vger.kernel.org, linux-arm-kernel@lists.infradead.org
Cc: Wade Cherry &lt;wade.cherry@arm.com&gt;
Subject: [PATCH] arm: perf: Add event descriptions
Message-ID: &lt;20150804001522.GA13214@dreric01-gentoo.localdomain&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=88861">Drew Richardson</a> - Aug. 4, 2015, 12:15 a.m.</div>
<pre class="content">
Add additional information about hardware events to make counters self
describing. This makes the hardware PMUs easier to use as perf list
contains the possible events instead of users having to refer to
documentation like the ARM TRMs. This could also allow tools like
oprofile to support PMUs without requiring an update.
<span class="signed-off-by">
Signed-off-by: Drew Richardson &lt;drew.richardson@arm.com&gt;</span>
---
 arch/arm/kernel/perf_event.c    |   1 +
 arch/arm/kernel/perf_event_v7.c | 617 ++++++++++++++++++++++++++++++++++++++++
 2 files changed, 618 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=88861">Drew Richardson</a> - Aug. 17, 2015, 8:58 p.m.</div>
<pre class="content">
On Tue, Aug 04, 2015 at 01:15:23AM +0100, Drew Richardson wrote:
<span class="quote">&gt; Add additional information about hardware events to make counters self</span>
<span class="quote">&gt; describing. This makes the hardware PMUs easier to use as perf list</span>
<span class="quote">&gt; contains the possible events instead of users having to refer to</span>
<span class="quote">&gt; documentation like the ARM TRMs. This could also allow tools like</span>
<span class="quote">&gt; oprofile to support PMUs without requiring an update.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Drew Richardson &lt;drew.richardson@arm.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm/kernel/perf_event.c    |   1 +</span>
<span class="quote">&gt;  arch/arm/kernel/perf_event_v7.c | 617 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  2 files changed, 618 insertions(+)</span>

Any concerns with merging this?

Thanks,

Drew
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=88861">Drew Richardson</a> - Aug. 17, 2015, 9:40 p.m.</div>
<pre class="content">
On Wed, Aug 26, 2015 at 05:51:49PM +0100, Will Deacon wrote:
<span class="quote">&gt; On Mon, Aug 17, 2015 at 09:58:09PM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt; On Tue, Aug 04, 2015 at 01:15:23AM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt; &gt; Add additional information about hardware events to make counters self</span>
<span class="quote">&gt; &gt; &gt; describing. This makes the hardware PMUs easier to use as perf list</span>
<span class="quote">&gt; &gt; &gt; contains the possible events instead of users having to refer to</span>
<span class="quote">&gt; &gt; &gt; documentation like the ARM TRMs. This could also allow tools like</span>
<span class="quote">&gt; &gt; &gt; oprofile to support PMUs without requiring an update.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Signed-off-by: Drew Richardson &lt;drew.richardson@arm.com&gt;</span>
<span class="quote">&gt; &gt; &gt; ---</span>
<span class="quote">&gt; &gt; &gt;  arch/arm/kernel/perf_event.c    |   1 +</span>
<span class="quote">&gt; &gt; &gt;  arch/arm/kernel/perf_event_v7.c | 617 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt; &gt;  2 files changed, 618 insertions(+)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Any concerns with merging this?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We should revisit this after the merge window (since the ARM perf code is</span>
<span class="quote">&gt; moving out to drivers/)</span>

Not a problem
<span class="quote">
&gt; but I do have reservations about putting all these</span>
<span class="quote">&gt; strings into the kernel. Why can&#39;t we put this into something like libpfm</span>
<span class="quote">&gt; instead?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Will</span>
<span class="quote">&gt; </span>

My intent is to make it easier for people to use hardware counters on
ARM, particularly with new CPUs. Currently, the developer of the tool
needs to extract the event information from the ARM TRMs, add it to
their tool and make a new release. This work is done by multiple
tools, for example for the Cortex-A15:

http://sourceforge.net/p/perfmon2/libpfm4/ci/master/tree/lib/events/arm_cortex_a15_events.h
http://sourceforge.net/p/oprofile/oprofile/ci/master/tree/events/arm/armv7-ca15/events
https://github.com/ARM-software/gator/blob/master/daemon/events-Cortex-A15.xml

There are likely more tools, these are the ones I could easily
find. Note that the new ARM Cortex-A72 isn&#39;t supported by most of
them. And the perf command line tool doesn&#39;t have any of this.

Once the tool supports the new CPUs events the user needs to make sure
they&#39;re running a recent version of the tool that contains these
events for their new ARM CPU. Technically the user could add the event
information themselves and upstream the change, but not all users will
do this.

So my suggestion to solve the problem is that the kernel can have the
list of events as proposed in the patch. This is already done for some
PMUs like arm-ccn and arm-cci. If the tool doesn&#39;t support the
particular CPU, they can fall back to the event list provided by the
kernel. There will be some information missing like user-friendly
descriptions of the events, but it&#39;s hopefully enough that users can
do what they need to do and update their tool at a later time.

I&#39;d be glad to wrap this all in a config option so users can disable
it to reduce bloat. Perhaps there is some other central location
outside the kernel that could store this information?

Thanks,

Drew
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - Aug. 26, 2015, 4:51 p.m.</div>
<pre class="content">
On Mon, Aug 17, 2015 at 09:58:09PM +0100, Drew Richardson wrote:
<span class="quote">&gt; On Tue, Aug 04, 2015 at 01:15:23AM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt; Add additional information about hardware events to make counters self</span>
<span class="quote">&gt; &gt; describing. This makes the hardware PMUs easier to use as perf list</span>
<span class="quote">&gt; &gt; contains the possible events instead of users having to refer to</span>
<span class="quote">&gt; &gt; documentation like the ARM TRMs. This could also allow tools like</span>
<span class="quote">&gt; &gt; oprofile to support PMUs without requiring an update.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Drew Richardson &lt;drew.richardson@arm.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  arch/arm/kernel/perf_event.c    |   1 +</span>
<span class="quote">&gt; &gt;  arch/arm/kernel/perf_event_v7.c | 617 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  2 files changed, 618 insertions(+)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Any concerns with merging this?</span>

We should revisit this after the merge window (since the ARM perf code is
moving out to drivers/), but I do have reservations about putting all these
strings into the kernel. Why can&#39;t we put this into something like libpfm
instead?

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=88861">Drew Richardson</a> - Sept. 24, 2015, 5:31 p.m.</div>
<pre class="content">
On Mon, Aug 17, 2015 at 10:40:35PM +0100, Drew Richardson wrote:
<span class="quote">&gt; On Wed, Aug 26, 2015 at 05:51:49PM +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; On Mon, Aug 17, 2015 at 09:58:09PM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt; &gt; On Tue, Aug 04, 2015 at 01:15:23AM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; Add additional information about hardware events to make counters self</span>
<span class="quote">&gt; &gt; &gt; &gt; describing. This makes the hardware PMUs easier to use as perf list</span>
<span class="quote">&gt; &gt; &gt; &gt; contains the possible events instead of users having to refer to</span>
<span class="quote">&gt; &gt; &gt; &gt; documentation like the ARM TRMs. This could also allow tools like</span>
<span class="quote">&gt; &gt; &gt; &gt; oprofile to support PMUs without requiring an update.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Signed-off-by: Drew Richardson &lt;drew.richardson@arm.com&gt;</span>
<span class="quote">&gt; &gt; &gt; &gt; ---</span>
<span class="quote">&gt; &gt; &gt; &gt;  arch/arm/kernel/perf_event.c    |   1 +</span>
<span class="quote">&gt; &gt; &gt; &gt;  arch/arm/kernel/perf_event_v7.c | 617 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt; &gt; &gt;  2 files changed, 618 insertions(+)</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Any concerns with merging this?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; We should revisit this after the merge window (since the ARM perf code is</span>
<span class="quote">&gt; &gt; moving out to drivers/)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Not a problem</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; but I do have reservations about putting all these</span>
<span class="quote">&gt; &gt; strings into the kernel. Why can&#39;t we put this into something like libpfm</span>
<span class="quote">&gt; &gt; instead?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Will</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; My intent is to make it easier for people to use hardware counters on</span>
<span class="quote">&gt; ARM, particularly with new CPUs. Currently, the developer of the tool</span>
<span class="quote">&gt; needs to extract the event information from the ARM TRMs, add it to</span>
<span class="quote">&gt; their tool and make a new release. This work is done by multiple</span>
<span class="quote">&gt; tools, for example for the Cortex-A15:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; http://sourceforge.net/p/perfmon2/libpfm4/ci/master/tree/lib/events/arm_cortex_a15_events.h</span>
<span class="quote">&gt; http://sourceforge.net/p/oprofile/oprofile/ci/master/tree/events/arm/armv7-ca15/events</span>
<span class="quote">&gt; https://github.com/ARM-software/gator/blob/master/daemon/events-Cortex-A15.xml</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There are likely more tools, these are the ones I could easily</span>
<span class="quote">&gt; find. Note that the new ARM Cortex-A72 isn&#39;t supported by most of</span>
<span class="quote">&gt; them. And the perf command line tool doesn&#39;t have any of this.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Once the tool supports the new CPUs events the user needs to make sure</span>
<span class="quote">&gt; they&#39;re running a recent version of the tool that contains these</span>
<span class="quote">&gt; events for their new ARM CPU. Technically the user could add the event</span>
<span class="quote">&gt; information themselves and upstream the change, but not all users will</span>
<span class="quote">&gt; do this.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So my suggestion to solve the problem is that the kernel can have the</span>
<span class="quote">&gt; list of events as proposed in the patch. This is already done for some</span>
<span class="quote">&gt; PMUs like arm-ccn and arm-cci. If the tool doesn&#39;t support the</span>
<span class="quote">&gt; particular CPU, they can fall back to the event list provided by the</span>
<span class="quote">&gt; kernel. There will be some information missing like user-friendly</span>
<span class="quote">&gt; descriptions of the events, but it&#39;s hopefully enough that users can</span>
<span class="quote">&gt; do what they need to do and update their tool at a later time.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;d be glad to wrap this all in a config option so users can disable</span>
<span class="quote">&gt; it to reduce bloat. Perhaps there is some other central location</span>
<span class="quote">&gt; outside the kernel that could store this information?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Drew</span>

Will,

Have you had a chance to review this again? I also noticed that my x86
machines have something similar, although not as few events as I&#39;m
proposing to add.

$ ls /sys/bus/event_source/devices/cpu/events/
cycles-ct  el-capacity  el-start    tx-abort     tx-conflict
cycles-t   el-commit    mem-loads   tx-capacity  tx-start
el-abort   el-conflict  mem-stores  tx-commit

Thanks,

Drew
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - Sept. 24, 2015, 5:52 p.m.</div>
<pre class="content">
Hi Drew,

On Mon, Aug 17, 2015 at 10:40:36PM +0100, Drew Richardson wrote:
<span class="quote">&gt; On Wed, Aug 26, 2015 at 05:51:49PM +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; but I do have reservations about putting all these</span>
<span class="quote">&gt; &gt; strings into the kernel. Why can&#39;t we put this into something like libpfm</span>
<span class="quote">&gt; &gt; instead?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; My intent is to make it easier for people to use hardware counters on</span>
<span class="quote">&gt; ARM, particularly with new CPUs. Currently, the developer of the tool</span>
<span class="quote">&gt; needs to extract the event information from the ARM TRMs, add it to</span>
<span class="quote">&gt; their tool and make a new release. This work is done by multiple</span>
<span class="quote">&gt; tools, for example for the Cortex-A15:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; http://sourceforge.net/p/perfmon2/libpfm4/ci/master/tree/lib/events/arm_cortex_a15_events.h</span>
<span class="quote">&gt; http://sourceforge.net/p/oprofile/oprofile/ci/master/tree/events/arm/armv7-ca15/events</span>
<span class="quote">&gt; https://github.com/ARM-software/gator/blob/master/daemon/events-Cortex-A15.xml</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; There are likely more tools, these are the ones I could easily</span>
<span class="quote">&gt; find. Note that the new ARM Cortex-A72 isn&#39;t supported by most of</span>
<span class="quote">&gt; them. And the perf command line tool doesn&#39;t have any of this.</span>

So to repeat the question, why can&#39;t libpfm be used instead? It doesn&#39;t seem
like it would be too much work to integrate that with the perf tool.
<span class="quote">
&gt; Once the tool supports the new CPUs events the user needs to make sure</span>
<span class="quote">&gt; they&#39;re running a recent version of the tool that contains these</span>
<span class="quote">&gt; events for their new ARM CPU. Technically the user could add the event</span>
<span class="quote">&gt; information themselves and upstream the change, but not all users will</span>
<span class="quote">&gt; do this.</span>

How does moving this into the kernel remove the need to upstream new
event descriptions?
<span class="quote">
&gt; So my suggestion to solve the problem is that the kernel can have the</span>
<span class="quote">&gt; list of events as proposed in the patch.</span>

Sorry, but I just don&#39;t buy this argument. Your problem is that the user
needs to be running an up-to-date perf tool, but with your proposed
solution, you&#39;re asking them to update the *kernel* instead, which is
(unfortunately) one of the hardest pieces of software to upgrade on a
typical ARM platform.
<span class="quote">
&gt; This is already done for some PMUs like arm-ccn and arm-cci. If the tool</span>
<span class="quote">&gt; doesn&#39;t support the particular CPU, they can fall back to the event list</span>
<span class="quote">&gt; provided by the kernel. There will be some information missing like</span>
<span class="quote">&gt; user-friendly descriptions of the events, but it&#39;s hopefully enough that</span>
<span class="quote">&gt; users can do what they need to do and update their tool at a later time.</span>

The problem is somewhat simpler for system PMUs, which don&#39;t suffer from
the variations that we encounter on the CPU side and are also less uniform.

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - Oct. 7, 2015, 11:20 a.m.</div>
<pre class="content">
Hi again, Drew,

On Thu, Sep 24, 2015 at 06:52:57PM +0100, Will Deacon wrote:
<span class="quote">&gt; On Mon, Aug 17, 2015 at 10:40:36PM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt; So my suggestion to solve the problem is that the kernel can have the</span>
<span class="quote">&gt; &gt; list of events as proposed in the patch.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Sorry, but I just don&#39;t buy this argument. Your problem is that the user</span>
<span class="quote">&gt; needs to be running an up-to-date perf tool, but with your proposed</span>
<span class="quote">&gt; solution, you&#39;re asking them to update the *kernel* instead, which is</span>
<span class="quote">&gt; (unfortunately) one of the hardest pieces of software to upgrade on a</span>
<span class="quote">&gt; typical ARM platform.</span>

I&#39;ve spent some time thinking about this and, actually, it makes sense
to do this for the architected events. These event numbers are guaranteed
to be portable between CPUs, so if we expose those through sysfs then
we don&#39;t have this dependency on updating the kernel for newer cores
(well, once the initial period without your patch has expired). It&#39;s the
noon-portable, micro-architectural events that I object to.

So how about you roll a new version of this patch just exposing the
architected events and making use of the macros in perf_event.h to make
it a bit tidier (PMU_EVENT_ATTR, PMU_EVENT_ATTR_STRING etc)?

Be aware that there&#39;s a fair amount of arm64 perf patches queue for 4.4,
since we&#39;re moving over to the code in drivers/perf/. Hopefully these
will appear on the arm64 for-next/core branch shortly.

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41311">Christopher Covington</a> - Oct. 27, 2015, 3:46 p.m.</div>
<pre class="content">
On 10/07/2015 07:20 AM, Will Deacon wrote:
<span class="quote">&gt; Hi again, Drew,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Thu, Sep 24, 2015 at 06:52:57PM +0100, Will Deacon wrote:</span>
<span class="quote">&gt;&gt; On Mon, Aug 17, 2015 at 10:40:36PM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt;&gt;&gt; So my suggestion to solve the problem is that the kernel can have the</span>
<span class="quote">&gt;&gt;&gt; list of events as proposed in the patch.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Sorry, but I just don&#39;t buy this argument. Your problem is that the user</span>
<span class="quote">&gt;&gt; needs to be running an up-to-date perf tool, but with your proposed</span>
<span class="quote">&gt;&gt; solution, you&#39;re asking them to update the *kernel* instead, which is</span>
<span class="quote">&gt;&gt; (unfortunately) one of the hardest pieces of software to upgrade on a</span>
<span class="quote">&gt;&gt; typical ARM platform.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;ve spent some time thinking about this and, actually, it makes sense</span>
<span class="quote">&gt; to do this for the architected events. These event numbers are guaranteed</span>
<span class="quote">&gt; to be portable between CPUs, so if we expose those through sysfs then</span>
<span class="quote">&gt; we don&#39;t have this dependency on updating the kernel for newer cores</span>
<span class="quote">&gt; (well, once the initial period without your patch has expired). It&#39;s the</span>
<span class="quote">&gt; noon-portable, micro-architectural events that I object to.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So how about you roll a new version of this patch just exposing the</span>
<span class="quote">&gt; architected events and making use of the macros in perf_event.h to make</span>
<span class="quote">&gt; it a bit tidier (PMU_EVENT_ATTR, PMU_EVENT_ATTR_STRING etc)?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Be aware that there&#39;s a fair amount of arm64 perf patches queue for 4.4,</span>
<span class="quote">&gt; since we&#39;re moving over to the code in drivers/perf/. Hopefully these</span>
<span class="quote">&gt; will appear on the arm64 for-next/core branch shortly.</span>

Have you considered using OF/ACPI to describe this aspect of the hardware?

Thanks,
Christopher Covington
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=30282">Mark Rutland</a> - Oct. 27, 2015, 4:04 p.m.</div>
<pre class="content">
On Tue, Oct 27, 2015 at 11:46:12AM -0400, Christopher Covington wrote:
<span class="quote">&gt; On 10/07/2015 07:20 AM, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; Hi again, Drew,</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; On Thu, Sep 24, 2015 at 06:52:57PM +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt;&gt; On Mon, Aug 17, 2015 at 10:40:36PM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; So my suggestion to solve the problem is that the kernel can have the</span>
<span class="quote">&gt; &gt;&gt;&gt; list of events as proposed in the patch.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Sorry, but I just don&#39;t buy this argument. Your problem is that the user</span>
<span class="quote">&gt; &gt;&gt; needs to be running an up-to-date perf tool, but with your proposed</span>
<span class="quote">&gt; &gt;&gt; solution, you&#39;re asking them to update the *kernel* instead, which is</span>
<span class="quote">&gt; &gt;&gt; (unfortunately) one of the hardest pieces of software to upgrade on a</span>
<span class="quote">&gt; &gt;&gt; typical ARM platform.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I&#39;ve spent some time thinking about this and, actually, it makes sense</span>
<span class="quote">&gt; &gt; to do this for the architected events. These event numbers are guaranteed</span>
<span class="quote">&gt; &gt; to be portable between CPUs, so if we expose those through sysfs then</span>
<span class="quote">&gt; &gt; we don&#39;t have this dependency on updating the kernel for newer cores</span>
<span class="quote">&gt; &gt; (well, once the initial period without your patch has expired). It&#39;s the</span>
<span class="quote">&gt; &gt; noon-portable, micro-architectural events that I object to.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So how about you roll a new version of this patch just exposing the</span>
<span class="quote">&gt; &gt; architected events and making use of the macros in perf_event.h to make</span>
<span class="quote">&gt; &gt; it a bit tidier (PMU_EVENT_ATTR, PMU_EVENT_ATTR_STRING etc)?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Be aware that there&#39;s a fair amount of arm64 perf patches queue for 4.4,</span>
<span class="quote">&gt; &gt; since we&#39;re moving over to the code in drivers/perf/. Hopefully these</span>
<span class="quote">&gt; &gt; will appear on the arm64 for-next/core branch shortly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Have you considered using OF/ACPI to describe this aspect of the hardware?</span>

FW-provided data structures are going to be harder to upgrade than the
kernel, so the same argument applies as with placing this data in the
kernel (if anything, more strongly).

Thanks,
Mark.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41311">Christopher Covington</a> - Oct. 28, 2015, 2:14 p.m.</div>
<pre class="content">
On 10/27/2015 12:04 PM, Mark Rutland wrote:
<span class="quote">&gt; On Tue, Oct 27, 2015 at 11:46:12AM -0400, Christopher Covington wrote:</span>
<span class="quote">&gt;&gt; On 10/07/2015 07:20 AM, Will Deacon wrote:</span>
<span class="quote">&gt;&gt;&gt; Hi again, Drew,</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; On Thu, Sep 24, 2015 at 06:52:57PM +0100, Will Deacon wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Mon, Aug 17, 2015 at 10:40:36PM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; So my suggestion to solve the problem is that the kernel can have the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; list of events as proposed in the patch.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; Sorry, but I just don&#39;t buy this argument. Your problem is that the user</span>
<span class="quote">&gt;&gt;&gt;&gt; needs to be running an up-to-date perf tool, but with your proposed</span>
<span class="quote">&gt;&gt;&gt;&gt; solution, you&#39;re asking them to update the *kernel* instead, which is</span>
<span class="quote">&gt;&gt;&gt;&gt; (unfortunately) one of the hardest pieces of software to upgrade on a</span>
<span class="quote">&gt;&gt;&gt;&gt; typical ARM platform.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I&#39;ve spent some time thinking about this and, actually, it makes sense</span>
<span class="quote">&gt;&gt;&gt; to do this for the architected events. These event numbers are guaranteed</span>
<span class="quote">&gt;&gt;&gt; to be portable between CPUs, so if we expose those through sysfs then</span>
<span class="quote">&gt;&gt;&gt; we don&#39;t have this dependency on updating the kernel for newer cores</span>
<span class="quote">&gt;&gt;&gt; (well, once the initial period without your patch has expired). It&#39;s the</span>
<span class="quote">&gt;&gt;&gt; noon-portable, micro-architectural events that I object to.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; So how about you roll a new version of this patch just exposing the</span>
<span class="quote">&gt;&gt;&gt; architected events and making use of the macros in perf_event.h to make</span>
<span class="quote">&gt;&gt;&gt; it a bit tidier (PMU_EVENT_ATTR, PMU_EVENT_ATTR_STRING etc)?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Be aware that there&#39;s a fair amount of arm64 perf patches queue for 4.4,</span>
<span class="quote">&gt;&gt;&gt; since we&#39;re moving over to the code in drivers/perf/. Hopefully these</span>
<span class="quote">&gt;&gt;&gt; will appear on the arm64 for-next/core branch shortly.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Have you considered using OF/ACPI to describe this aspect of the hardware?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; FW-provided data structures are going to be harder to upgrade than the</span>
<span class="quote">&gt; kernel, so the same argument applies as with placing this data in the</span>
<span class="quote">&gt; kernel (if anything, more strongly).</span>

A convenient place for workarounds is great, when necessary, but I don&#39;t see
why Plan A for hardware description should be anything other than standardized
hardware description mechanisms.

Why are you eager to inflate the expectations of firmware when it comes to
power state coordination but reluctant to rely on firmware for describing
performance monitor events?

Christopher Covington
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=30282">Mark Rutland</a> - Oct. 28, 2015, 2:29 p.m.</div>
<pre class="content">
On Wed, Oct 28, 2015 at 10:14:24AM -0400, Christopher Covington wrote:
<span class="quote">&gt; On 10/27/2015 12:04 PM, Mark Rutland wrote:</span>
<span class="quote">&gt; &gt; On Tue, Oct 27, 2015 at 11:46:12AM -0400, Christopher Covington wrote:</span>
<span class="quote">&gt; &gt;&gt; On 10/07/2015 07:20 AM, Will Deacon wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; Hi again, Drew,</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; On Thu, Sep 24, 2015 at 06:52:57PM +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; On Mon, Aug 17, 2015 at 10:40:36PM +0100, Drew Richardson wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; So my suggestion to solve the problem is that the kernel can have the</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt; list of events as proposed in the patch.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; Sorry, but I just don&#39;t buy this argument. Your problem is that the user</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; needs to be running an up-to-date perf tool, but with your proposed</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; solution, you&#39;re asking them to update the *kernel* instead, which is</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; (unfortunately) one of the hardest pieces of software to upgrade on a</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt; typical ARM platform.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; I&#39;ve spent some time thinking about this and, actually, it makes sense</span>
<span class="quote">&gt; &gt;&gt;&gt; to do this for the architected events. These event numbers are guaranteed</span>
<span class="quote">&gt; &gt;&gt;&gt; to be portable between CPUs, so if we expose those through sysfs then</span>
<span class="quote">&gt; &gt;&gt;&gt; we don&#39;t have this dependency on updating the kernel for newer cores</span>
<span class="quote">&gt; &gt;&gt;&gt; (well, once the initial period without your patch has expired). It&#39;s the</span>
<span class="quote">&gt; &gt;&gt;&gt; noon-portable, micro-architectural events that I object to.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; So how about you roll a new version of this patch just exposing the</span>
<span class="quote">&gt; &gt;&gt;&gt; architected events and making use of the macros in perf_event.h to make</span>
<span class="quote">&gt; &gt;&gt;&gt; it a bit tidier (PMU_EVENT_ATTR, PMU_EVENT_ATTR_STRING etc)?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Be aware that there&#39;s a fair amount of arm64 perf patches queue for 4.4,</span>
<span class="quote">&gt; &gt;&gt;&gt; since we&#39;re moving over to the code in drivers/perf/. Hopefully these</span>
<span class="quote">&gt; &gt;&gt;&gt; will appear on the arm64 for-next/core branch shortly.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Have you considered using OF/ACPI to describe this aspect of the hardware?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; FW-provided data structures are going to be harder to upgrade than the</span>
<span class="quote">&gt; &gt; kernel, so the same argument applies as with placing this data in the</span>
<span class="quote">&gt; &gt; kernel (if anything, more strongly).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A convenient place for workarounds is great, when necessary, but I don&#39;t see</span>
<span class="quote">&gt; why Plan A for hardware description should be anything other than standardized</span>
<span class="quote">&gt; hardware description mechanisms.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why are you eager to inflate the expectations of firmware when it comes to</span>
<span class="quote">&gt; power state coordination but reluctant to rely on firmware for describing</span>
<span class="quote">&gt; performance monitor events?</span>

Firmware has the responsibility to describe the integration details of
the PMU (the interrupt routing), because that varies between platforms.
The set of supported events does not, for a given PMU (e.g. the events
supported by a Cortex-A57 are the same regardless of whether it&#39;s
integrated an ARM Juno or an AMD Seattle), and are effectively part of
the programming model of the device.

Power state coordination is very much platform specific; and is not
comparable.

Thanks,
Mark.
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/kernel/perf_event.c b/arch/arm/kernel/perf_event.c</span>
<span class="p_header">index 54272e0be713..a7f2c84bae15 100644</span>
<span class="p_header">--- a/arch/arm/kernel/perf_event.c</span>
<span class="p_header">+++ b/arch/arm/kernel/perf_event.c</span>
<span class="p_chunk">@@ -548,6 +548,7 @@</span> <span class="p_context"> static void armpmu_init(struct arm_pmu *armpmu)</span>
 		.stop		= armpmu_stop,
 		.read		= armpmu_read,
 		.filter_match	= armpmu_filter_match,
<span class="p_add">+		.attr_groups	= armpmu-&gt;pmu.attr_groups,</span>
 	};
 }
 
<span class="p_header">diff --git a/arch/arm/kernel/perf_event_v7.c b/arch/arm/kernel/perf_event_v7.c</span>
<span class="p_header">index f9b37f876e20..d46bc78b5997 100644</span>
<span class="p_header">--- a/arch/arm/kernel/perf_event_v7.c</span>
<span class="p_header">+++ b/arch/arm/kernel/perf_event_v7.c</span>
<span class="p_chunk">@@ -547,6 +547,616 @@</span> <span class="p_context"> static const unsigned scorpion_perf_cache_map[PERF_COUNT_HW_CACHE_MAX]</span>
 	[C(BPU)][C(OP_WRITE)][C(RESULT_MISS)] = ARMV7_PERFCTR_PC_BRANCH_MIS_PRED,
 };
 
<span class="p_add">+static ssize_t armv7_event_show(struct device *dev,</span>
<span class="p_add">+				struct device_attribute *attr, char *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dev_ext_attribute *ea = container_of(attr,</span>
<span class="p_add">+						    struct dev_ext_attribute,</span>
<span class="p_add">+						    attr);</span>
<span class="p_add">+</span>
<span class="p_add">+	return snprintf(buf, PAGE_SIZE, &quot;%s\n&quot;, (char *)ea-&gt;var);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARMV7_EVENT_ATTR(config, name) \</span>
<span class="p_add">+	struct dev_ext_attribute armv7_event_attr_##config##_##name = \</span>
<span class="p_add">+		{ __ATTR(name, S_IRUGO, armv7_event_show, NULL), \</span>
<span class="p_add">+		  &quot;config=0x&quot; #config }</span>
<span class="p_add">+</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(00, sw_incr);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(01, l1i_cache_refill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(02, l1i_tlb_refill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(03, l1d_cache_refill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(04, l1d_cache);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(05, l1d_tlb_refill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(06, ld_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(07, st_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(08, inst_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(09, exc_taken);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(0a, exc_return);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(0b, cid_write_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(0c, pc_write_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(0d, br_immed_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(0e, br_return_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(0f, unaligned_ldst_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(10, br_mis_pred);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(11, cpu_cycles);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(12, br_pred);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(13, mem_access);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(14, l1i_cache);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(15, l1d_cache_wb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(16, l2d_cache);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(17, l2d_cache_refill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(18, l2d_cache_wb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(19, bus_access);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(1a, memory_error);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(1b, inst_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(1c, ttbr_write_retired);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(1d, bus_cycles);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(40, java_bc_exec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(40, l1d_cache_ld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(40, wb_full);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(41, java_swbc_exec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(41, l1d_cache_st);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(41, l2_store_merged);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(42, jazelle_branch_executed);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(42, l1d_cache_refill_ld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(42, l2_store_bufferable);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(43, l1d_cache_refill_st);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(43, l2_access);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(44, l2_miss);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(45, axi_read);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(46, axi_write);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(46, l1d_cache_wb_victim);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(47, l1d_cache_wb_clean);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(47, mem_replay);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(48, l1d_cache_inval);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(48, mem_replay_unaligned);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(49, l1d_miss_hash);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4a, l1i_miss_hash);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4b, l1d_page_coloring);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4c, l1d_hit_neon);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4c, l1d_tlb_refill_ld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4d, l1d_access_neon);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4d, l1d_tlb_refill_st);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4e, l2_access_neon);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(4f, l2_hit_neon);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(50, coherent_miss);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(50, l1i_access);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(50, l2d_cache_ld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(51, coherent_hit);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(51, l2d_cache_st);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(51, return_mispredict);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(52, branch_mispredict);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(52, l2d_cache_refill_ld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(53, branch_predict_taken);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(53, l2d_cache_refill_st);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(54, branch_predictable_taken);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(55, operation_issued);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(56, inst_stall);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(56, l2d_cache_wb_victim);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(57, inst_issued);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(57, l2d_cache_wb_clean);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(58, l2d_cache_inval);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(58, stall_neon_data);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(59, stall_neon_inst);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(5a, int_neon_busy);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(60, bus_access_ld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(60, stall_inst);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(61, bus_access_st);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(61, stall_data);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(62, bus_access_shared);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(62, stall_tlb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(63, bus_access_not_shared);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(63, strex_pass);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(64, bus_access_normal);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(64, strex_failed);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(65, bus_access_periph);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(65, data_evict);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(66, issue_no_dispatch);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(66, mem_access_ld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(67, issue_empty);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(67, mem_access_st);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(68, inst_exec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(68, unaligned_ld_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(69, cache_linefill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(69, unaligned_st_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6a, prefetch_linefill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6a, unaligned_ldst_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6b, prefetch_hit);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6c, ldrex_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6d, strex_pass_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6e, predictable_ret);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6e, strex_fail_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(6f, strex_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(70, inst_main_exec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(70, ld_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(70, pmuextin0);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(71, inst_second_exec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(71, pmuextin1);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(71, st_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(72, inst_load_store);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(72, ldst_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(72, pmuextin);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(73, dp_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(73, inst_fp);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(74, ase_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(74, inst_neon);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(75, vfp_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(76, pc_write_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(78, br_immed_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(79, br_return_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(7a, br_indirect_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(7c, isb_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(7d, dsb_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(7e, dmb_spec);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(80, stall_pld);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(81, exc_undef);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(81, stall_write);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(82, stall_inst_tlb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(83, stall_data_tlb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(84, stall_inst_mtlb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(85, stall_data_mtlb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(86, exc_irq);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(86, stall_dmb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(87, exc_fiq);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(8a, clock_int);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(8a, exc_hvc);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(8b, clock_data);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(8c, clock_neon);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(8d, tlb_inst);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(8e, tlb_data);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(90, inst_isb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(91, inst_dsb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(92, inst_dmb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(93, ext_irq);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c0, ext_mem_req);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c0, stall_inst_linefill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c1, ext_mem_req_nc);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c1, stall_inst_tlb);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c2, cache_tag);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c2, prefetch_linefill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c3, cache_data);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c3, prefetch_linefill_drop);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c4, cache_btac);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c4, read_alloc_enter);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c5, read_alloc);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c7, etm_out0);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c8, etm_out1);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(c9, stall_sb_full);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(ca, local_cluster_snoop);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(d3, busy_lsu);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(d8, busy_lsi);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(d9, busy_dpi);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(da, busy_dei);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(db, neon_cond_fail);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(dc, trap_hv);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(de, ptm_extout0);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(df, ptm_extout1);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e0, mmu_walk);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e1, mmu_s1_walk);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e2, mmu_s2_walk);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e3, mmu_lsu_walk);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e4, mmu_inst_walk);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e5, mmu_pre_walk);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e6, mmu_cp15_walk);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e7, tlb_pld_refill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e8, tlb_cp15_refill);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(e9, tlb_flush);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(ea, tlb_access);</span>
<span class="p_add">+static ARMV7_EVENT_ATTR(eb, tlb_miss);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *armv7_a8_event_attrs[] = {</span>
<span class="p_add">+	&amp;armv7_event_attr_00_sw_incr.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_01_l1i_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_02_l1i_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_03_l1d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_04_l1d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_05_l1d_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_06_ld_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_07_st_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_08_inst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_09_exc_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0a_exc_return.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0b_cid_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0c_pc_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0d_br_immed_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0e_br_return_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0f_unaligned_ldst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_10_br_mis_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_11_cpu_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_12_br_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_40_wb_full.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_41_l2_store_merged.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_42_l2_store_bufferable.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_43_l2_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_44_l2_miss.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_45_axi_read.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_46_axi_write.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_47_mem_replay.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_48_mem_replay_unaligned.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_49_l1d_miss_hash.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4a_l1i_miss_hash.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4b_l1d_page_coloring.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4c_l1d_hit_neon.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4d_l1d_access_neon.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4e_l2_access_neon.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4f_l2_hit_neon.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_50_l1i_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_51_return_mispredict.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_52_branch_mispredict.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_53_branch_predict_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_54_branch_predictable_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_55_operation_issued.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_56_inst_stall.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_57_inst_issued.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_58_stall_neon_data.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_59_stall_neon_inst.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_5a_int_neon_busy.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_70_pmuextin0.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_71_pmuextin1.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_72_pmuextin.attr.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group armv7_a8_events_attr_group = {</span>
<span class="p_add">+	.name = &quot;events&quot;,</span>
<span class="p_add">+	.attrs = armv7_a8_event_attrs,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *armv7_a8_attr_groups[] = {</span>
<span class="p_add">+	&amp;armv7_a8_events_attr_group,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *armv7_a9_event_attrs[] = {</span>
<span class="p_add">+	&amp;armv7_event_attr_00_sw_incr.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_01_l1i_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_02_l1i_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_03_l1d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_04_l1d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_05_l1d_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_06_ld_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_07_st_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_09_exc_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0a_exc_return.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0b_cid_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0c_pc_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0d_br_immed_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0f_unaligned_ldst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_10_br_mis_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_11_cpu_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_12_br_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_40_java_bc_exec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_41_java_swbc_exec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_42_jazelle_branch_executed.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_50_coherent_miss.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_51_coherent_hit.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_60_stall_inst.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_61_stall_data.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_62_stall_tlb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_63_strex_pass.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_64_strex_failed.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_65_data_evict.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_66_issue_no_dispatch.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_67_issue_empty.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_68_inst_exec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_69_cache_linefill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6a_prefetch_linefill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6b_prefetch_hit.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6e_predictable_ret.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_70_inst_main_exec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_71_inst_second_exec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_72_inst_load_store.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_73_inst_fp.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_74_inst_neon.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_80_stall_pld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_81_stall_write.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_82_stall_inst_tlb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_83_stall_data_tlb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_84_stall_inst_mtlb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_85_stall_data_mtlb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_86_stall_dmb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_8a_clock_int.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_8b_clock_data.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_8c_clock_neon.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_8d_tlb_inst.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_8e_tlb_data.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_90_inst_isb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_91_inst_dsb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_92_inst_dmb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_93_ext_irq.attr.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group armv7_a9_events_attr_group = {</span>
<span class="p_add">+	.name = &quot;events&quot;,</span>
<span class="p_add">+	.attrs = armv7_a9_event_attrs,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *armv7_a9_attr_groups[] = {</span>
<span class="p_add">+	&amp;armv7_a9_events_attr_group,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *armv7_a5_event_attrs[] = {</span>
<span class="p_add">+	&amp;armv7_event_attr_00_sw_incr.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_01_l1i_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_02_l1i_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_03_l1d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_04_l1d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_05_l1d_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_06_ld_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_07_st_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_08_inst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_09_exc_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0a_exc_return.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0b_cid_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0c_pc_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0d_br_immed_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0e_br_return_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0f_unaligned_ldst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_10_br_mis_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_11_cpu_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_12_br_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_13_mem_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_14_l1i_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_15_l1d_cache_wb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_86_exc_irq.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_87_exc_fiq.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c0_ext_mem_req.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c1_ext_mem_req_nc.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c2_prefetch_linefill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c3_prefetch_linefill_drop.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c4_read_alloc_enter.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c5_read_alloc.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c7_etm_out0.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c8_etm_out1.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c9_stall_sb_full.attr.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group armv7_a5_events_attr_group = {</span>
<span class="p_add">+	.name = &quot;events&quot;,</span>
<span class="p_add">+	.attrs = armv7_a5_event_attrs,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *armv7_a5_attr_groups[] = {</span>
<span class="p_add">+	&amp;armv7_a5_events_attr_group,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *armv7_a15_event_attrs[] = {</span>
<span class="p_add">+	&amp;armv7_event_attr_00_sw_incr.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_01_l1i_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_02_l1i_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_03_l1d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_04_l1d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_05_l1d_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_08_inst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_09_exc_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0a_exc_return.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0b_cid_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_10_br_mis_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_11_cpu_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_12_br_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_13_mem_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_14_l1i_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_15_l1d_cache_wb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_16_l2d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_17_l2d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_18_l2d_cache_wb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_19_bus_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1a_memory_error.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1b_inst_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1c_ttbr_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1d_bus_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_40_l1d_cache_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_41_l1d_cache_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_42_l1d_cache_refill_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_43_l1d_cache_refill_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_46_l1d_cache_wb_victim.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_47_l1d_cache_wb_clean.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_48_l1d_cache_inval.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4c_l1d_tlb_refill_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_4d_l1d_tlb_refill_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_50_l2d_cache_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_51_l2d_cache_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_52_l2d_cache_refill_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_53_l2d_cache_refill_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_56_l2d_cache_wb_victim.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_57_l2d_cache_wb_clean.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_58_l2d_cache_inval.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_60_bus_access_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_61_bus_access_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_62_bus_access_shared.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_63_bus_access_not_shared.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_64_bus_access_normal.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_65_bus_access_periph.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_66_mem_access_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_67_mem_access_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_68_unaligned_ld_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_69_unaligned_st_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6a_unaligned_ldst_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6c_ldrex_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6d_strex_pass_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6e_strex_fail_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_70_ld_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_71_st_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_72_ldst_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_73_dp_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_74_ase_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_75_vfp_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_76_pc_write_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_78_br_immed_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_79_br_return_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7a_br_indirect_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7c_isb_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7d_dsb_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7e_dmb_spec.attr.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group armv7_a15_events_attr_group = {</span>
<span class="p_add">+	.name = &quot;events&quot;,</span>
<span class="p_add">+	.attrs = armv7_a15_event_attrs,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *armv7_a15_attr_groups[] = {</span>
<span class="p_add">+	&amp;armv7_a15_events_attr_group,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *armv7_a7_event_attrs[] = {</span>
<span class="p_add">+	&amp;armv7_event_attr_00_sw_incr.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_01_l1i_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_02_l1i_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_03_l1d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_04_l1d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_05_l1d_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_06_ld_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_07_st_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_08_inst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_09_exc_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0a_exc_return.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0b_cid_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0c_pc_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0d_br_immed_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0e_br_return_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0f_unaligned_ldst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_10_br_mis_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_11_cpu_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_12_br_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_13_mem_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_14_l1i_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_15_l1d_cache_wb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_16_l2d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_17_l2d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_18_l2d_cache_wb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_19_bus_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1d_bus_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_60_bus_access_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_61_bus_access_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_86_exc_irq.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_87_exc_fiq.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c0_ext_mem_req.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c1_ext_mem_req_nc.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c2_prefetch_linefill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c3_prefetch_linefill_drop.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c4_read_alloc_enter.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c5_read_alloc.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c7_etm_out0.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c8_etm_out1.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c9_stall_sb_full.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_ca_local_cluster_snoop.attr.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group armv7_a7_events_attr_group = {</span>
<span class="p_add">+	.name = &quot;events&quot;,</span>
<span class="p_add">+	.attrs = armv7_a7_event_attrs,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *armv7_a7_attr_groups[] = {</span>
<span class="p_add">+	&amp;armv7_a7_events_attr_group,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *armv7_a17_event_attrs[] = {</span>
<span class="p_add">+	&amp;armv7_event_attr_01_l1i_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_02_l1i_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_03_l1d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_04_l1d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_05_l1d_tlb_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_08_inst_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_09_exc_taken.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0a_exc_return.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_0b_cid_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_10_br_mis_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_11_cpu_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_12_br_pred.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_13_mem_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_14_l1i_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_15_l1d_cache_wb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_16_l2d_cache.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_17_l2d_cache_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_18_l2d_cache_wb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_19_bus_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1b_inst_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1c_ttbr_write_retired.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_1d_bus_cycles.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_40_l1d_cache_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_41_l1d_cache_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_50_l2d_cache_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_51_l2d_cache_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_56_l2d_cache_wb_victim.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_57_l2d_cache_wb_clean.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_58_l2d_cache_inval.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_62_bus_access_shared.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_63_bus_access_not_shared.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_64_bus_access_normal.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_65_bus_access_periph.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_66_mem_access_ld.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_67_mem_access_st.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_68_unaligned_ld_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_69_unaligned_st_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6a_unaligned_ldst_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6c_ldrex_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6e_strex_fail_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_6f_strex_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_70_ld_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_71_st_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_72_ldst_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_73_dp_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_74_ase_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_75_vfp_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_76_pc_write_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_78_br_immed_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_79_br_return_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7a_br_indirect_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7c_isb_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7d_dsb_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_7e_dmb_spec.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_81_exc_undef.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_8a_exc_hvc.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c0_stall_inst_linefill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c1_stall_inst_tlb.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c2_cache_tag.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c3_cache_data.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_c4_cache_btac.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_ca_local_cluster_snoop.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_d3_busy_lsu.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_d8_busy_lsi.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_d9_busy_dpi.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_da_busy_dei.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_db_neon_cond_fail.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_dc_trap_hv.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_de_ptm_extout0.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_df_ptm_extout1.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e0_mmu_walk.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e1_mmu_s1_walk.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e2_mmu_s2_walk.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e3_mmu_lsu_walk.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e4_mmu_inst_walk.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e5_mmu_pre_walk.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e6_mmu_cp15_walk.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e7_tlb_pld_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e8_tlb_cp15_refill.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_e9_tlb_flush.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_ea_tlb_access.attr.attr,</span>
<span class="p_add">+	&amp;armv7_event_attr_eb_tlb_miss.attr.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group armv7_a17_events_attr_group = {</span>
<span class="p_add">+	.name = &quot;events&quot;,</span>
<span class="p_add">+	.attrs = armv7_a17_event_attrs,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *armv7_a17_attr_groups[] = {</span>
<span class="p_add">+	&amp;armv7_a17_events_attr_group,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Perf Events&#39; indices
  */
<span class="p_chunk">@@ -1085,6 +1695,7 @@</span> <span class="p_context"> static int armv7_a8_pmu_init(struct arm_pmu *cpu_pmu)</span>
 	armv7pmu_init(cpu_pmu);
 	cpu_pmu-&gt;name		= &quot;armv7_cortex_a8&quot;;
 	cpu_pmu-&gt;map_event	= armv7_a8_map_event;
<span class="p_add">+	cpu_pmu-&gt;pmu.attr_groups = armv7_a8_attr_groups;</span>
 	return armv7_probe_num_events(cpu_pmu);
 }
 
<span class="p_chunk">@@ -1093,6 +1704,7 @@</span> <span class="p_context"> static int armv7_a9_pmu_init(struct arm_pmu *cpu_pmu)</span>
 	armv7pmu_init(cpu_pmu);
 	cpu_pmu-&gt;name		= &quot;armv7_cortex_a9&quot;;
 	cpu_pmu-&gt;map_event	= armv7_a9_map_event;
<span class="p_add">+	cpu_pmu-&gt;pmu.attr_groups = armv7_a9_attr_groups;</span>
 	return armv7_probe_num_events(cpu_pmu);
 }
 
<span class="p_chunk">@@ -1101,6 +1713,7 @@</span> <span class="p_context"> static int armv7_a5_pmu_init(struct arm_pmu *cpu_pmu)</span>
 	armv7pmu_init(cpu_pmu);
 	cpu_pmu-&gt;name		= &quot;armv7_cortex_a5&quot;;
 	cpu_pmu-&gt;map_event	= armv7_a5_map_event;
<span class="p_add">+	cpu_pmu-&gt;pmu.attr_groups = armv7_a5_attr_groups;</span>
 	return armv7_probe_num_events(cpu_pmu);
 }
 
<span class="p_chunk">@@ -1110,6 +1723,7 @@</span> <span class="p_context"> static int armv7_a15_pmu_init(struct arm_pmu *cpu_pmu)</span>
 	cpu_pmu-&gt;name		= &quot;armv7_cortex_a15&quot;;
 	cpu_pmu-&gt;map_event	= armv7_a15_map_event;
 	cpu_pmu-&gt;set_event_filter = armv7pmu_set_event_filter;
<span class="p_add">+	cpu_pmu-&gt;pmu.attr_groups = armv7_a15_attr_groups;</span>
 	return armv7_probe_num_events(cpu_pmu);
 }
 
<span class="p_chunk">@@ -1119,6 +1733,7 @@</span> <span class="p_context"> static int armv7_a7_pmu_init(struct arm_pmu *cpu_pmu)</span>
 	cpu_pmu-&gt;name		= &quot;armv7_cortex_a7&quot;;
 	cpu_pmu-&gt;map_event	= armv7_a7_map_event;
 	cpu_pmu-&gt;set_event_filter = armv7pmu_set_event_filter;
<span class="p_add">+	cpu_pmu-&gt;pmu.attr_groups = armv7_a7_attr_groups;</span>
 	return armv7_probe_num_events(cpu_pmu);
 }
 
<span class="p_chunk">@@ -1128,6 +1743,7 @@</span> <span class="p_context"> static int armv7_a12_pmu_init(struct arm_pmu *cpu_pmu)</span>
 	cpu_pmu-&gt;name		= &quot;armv7_cortex_a12&quot;;
 	cpu_pmu-&gt;map_event	= armv7_a12_map_event;
 	cpu_pmu-&gt;set_event_filter = armv7pmu_set_event_filter;
<span class="p_add">+	cpu_pmu-&gt;pmu.attr_groups = armv7_a17_attr_groups;</span>
 	return armv7_probe_num_events(cpu_pmu);
 }
 
<span class="p_chunk">@@ -1135,6 +1751,7 @@</span> <span class="p_context"> static int armv7_a17_pmu_init(struct arm_pmu *cpu_pmu)</span>
 {
 	int ret = armv7_a12_pmu_init(cpu_pmu);
 	cpu_pmu-&gt;name = &quot;armv7_cortex_a17&quot;;
<span class="p_add">+	cpu_pmu-&gt;pmu.attr_groups = armv7_a17_attr_groups;</span>
 	return ret;
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



