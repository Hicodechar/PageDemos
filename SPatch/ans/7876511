
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v5] arm64: Add support for PTE contiguous bit. - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v5] arm64: Add support for PTE contiguous bit.</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=142331">David Woods</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 17, 2015, 7:31 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1450380686-20911-1-git-send-email-dwoods@ezchip.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7876511/mbox/"
   >mbox</a>
|
   <a href="/patch/7876511/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7876511/">/patch/7876511/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 324E59F349
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 17 Dec 2015 19:31:52 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id ABEB820396
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 17 Dec 2015 19:31:50 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 1EAF620272
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 17 Dec 2015 19:31:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754764AbbLQTbg (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 17 Dec 2015 14:31:36 -0500
Received: from mail-db3hn0245.outbound.protection.outlook.com
	([157.55.234.245]:52736
	&quot;EHLO emea01-db3-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1752482AbbLQTbe (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 17 Dec 2015 14:31:34 -0500
Received: from DB4PR02CA0022.eurprd02.prod.outlook.com (10.242.174.150) by
	DB4PR02MB0447.eurprd02.prod.outlook.com (10.141.44.11) with Microsoft
	SMTP Server (TLS) id 15.1.355.16; Thu, 17 Dec 2015 19:31:31 +0000
Received: from DB3FFO11FD019.protection.gbl (2a01:111:f400:7e04::148) by
	DB4PR02CA0022.outlook.office365.com (2a01:111:e400:983b::22) with
	Microsoft SMTP Server (TLS) id 15.1.361.13 via Frontend Transport;
	Thu, 17 Dec 2015 19:31:31 +0000
Authentication-Results: spf=fail (sender IP is 12.216.194.146)
	smtp.mailfrom=ezchip.com; ezchip.com; dkim=none (message not signed)
	header.d=none; ezchip.com;
	dmarc=none action=none header.from=ezchip.com; 
Received-SPF: Fail (protection.outlook.com: domain of ezchip.com does not
	designate 12.216.194.146 as permitted sender)
	receiver=protection.outlook.com; client-ip=12.216.194.146;
	helo=ld-2.internal.tilera.com;
Received: from ld-2.internal.tilera.com (12.216.194.146) by
	DB3FFO11FD019.mail.protection.outlook.com (10.47.217.50) with
	Microsoft SMTP Server (TLS) id 15.1.355.15 via Frontend Transport;
	Thu, 17 Dec 2015 19:31:30 +0000
Received: (from dwoods@localhost)
	by ld-2.internal.tilera.com (8.14.4/8.14.4/Submit) id tBHJVS7Z020974; 
	Thu, 17 Dec 2015 14:31:28 -0500
From: David Woods &lt;dwoods@ezchip.com&gt;
To: &lt;dwoods@ezchip.com&gt;
CC: &lt;catalin.marinas@arm.com&gt;, &lt;will.deacon@arm.com&gt;,
	&lt;steve.capper@linaro.org&gt;, &lt;jeremy.linton@arm.com&gt;,
	&lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-mm@kvack.org&gt;,
	&lt;cmetcalf@ezchip.com&gt;
Subject: [PATCH v5] arm64: Add support for PTE contiguous bit.
Date: Thu, 17 Dec 2015 14:31:26 -0500
Message-ID: &lt;1450380686-20911-1-git-send-email-dwoods@ezchip.com&gt;
X-Mailer: git-send-email 2.1.2
X-EOPAttributedMessage: 0
X-Microsoft-Exchange-Diagnostics: 1; DB3FFO11FD019;
	1:UnuX8KmxTHZ/YAxzrbSjNdgHSCD9a64lU8rBhPR+++DzA4hkV312iFUkI4OX7NJwRMoRPNAaqe4BQt4SloCidPUGEL8CGV/cY80Yyno3YYJEW0+U4d40SKGgWiu2JgcaVhaf7pns4zFnf9JUQ9ZPOpmw7P0fTkoKKNMpyzFWU7Wy+20BFglOJ+2qLwFw+6RlR56oVs+nquS7GYD+/u0wUupWtjBedlgwOlNE2BPnDa9TLGSO/6Vo/Bk9vBtqFvkPeE0edQRo3yfec+U3M+1lfnIIMT8vR1YaKCgFx04ppYibEi7pn/1I5HlHFsx2LWiXCINlJxAehdGU81S9UZcWl87uQHgVEd4uy6SicqX+NjBDsWlmXTlJkyDWKcIuU4QL
X-Forefront-Antispam-Report: CIP:12.216.194.146; CTRY:US; IPV:NLI; EFV:NLI;
	SFV:SPM;
	SFS:(10009020)(6009001)(2980300002)(1109001)(1110001)(339900001)(189002)(199003)(6200100001)(50986999)(42186005)(6806005)(2351001)(87936001)(110136002)(229853001)(575784001)(5008740100001)(5001970100001)(4001430100002)(4001450100002)(50466002)(85426001)(7049001)(106466001)(104016004)(86362001)(189998001)(33646002)(47776003)(92566002)(105606002)(107886002)(1096002)(50226001)(11100500001)(586003)(1220700001)(19580405001)(5003940100001)(19580395003)(48376002)(36756003)(1880700004);
	DIR:OUT; SFP:1501; SCL:5; SRVR:DB4PR02MB0447;
	H:ld-2.internal.tilera.com; FPR:; SPF:Fail;
	PTR:wb-fw1.tilera.com; MX:1; A:1; LANG:en; 
MIME-Version: 1.0
Content-Type: text/plain
X-Microsoft-Exchange-Diagnostics: 1; DB4PR02MB0447;
	2:Vg9xiPgRM0O5YIC3RjPJ8qtEMONMZkUL/m0wtyWetnwgJFoITSlr+sG8Q/ftNbm+oYDj+Gc+CQqY4CLEsgtgSzobHUYowYeevfbsDls0LrGYPxDXpmoY0UZQen+JVsId/QAAC7iabipyBT6718WIAg==;
	3:0l7wEQVXtltujw7xzRVaiMBfTNXIyT6eQPwlxJGYUag9yRbXUwAw+qg4Kbkmwni1ZuB6WgutgIJLpzgBJaBCiuKnY2l6b6m0Sm5HcG4RSkT3KaS/Y6l+OUHPxzns0tVddC6RNEnMvUYIOPbPeBDFFmDEdu8XtF0QOiFN/jSPMs2ND4HcYuewkrrubxgIB6ltZRz8vsbDTRZWDmQPGi2Dw3FcyDG87SPKbp/Z/GHIwAU=;
	25:wsKeOH18sLmwT5Xol7YSZn2T1bsID8JDFXlOvUzfqwxpwPpEbXVKH8r7GTiW123f9PVTphmiLUOOT2LBH9s742x5F2/VnkcjD3li9Vf0sGfb0h+0M4CbFnwxiHCe/HKe4leKjdpLxMU1Aa0nFgWa/OkMf8UWpm1IGYJ/ZKq4Ly4EGB5RD6B5s05+scou91FO8hlHayL0NtvDc7uP3T2u9zhY0hE1GmvWRmSydqguUtOFoHohYjG+kybcZ1gu7QIJIcnWkw5RHgaE/6RqnI0BuA==;
	20:xeui6AGb0KUnATmerRG/MveNtXbPCNMsQWKvCGrhGXr7Sc2oI5SI8azwK/0ltsHFD49WAWnt6z2Rh8VYs1I8yo6GxdIfCN/hyvTwn0fChEVwSLbv/lcyfLMEyMUOXoRVuA09aOtsPQSapOm4IEs0R2MLOVaj67XumifK9X3EoQY=
X-Microsoft-Antispam: UriScan:;BCL:0;PCL:0;RULEID:;SRVR:DB4PR02MB0447;
X-Microsoft-Antispam-PRVS: &lt;DB4PR02MB044741124082E2AD665A4BB7BCE00@DB4PR02MB0447.eurprd02.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(121898900299872);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(601004)(2401047)(5005006)(520078)(8121501046)(3002001)(10201501046);
	SRVR:DB4PR02MB0447; BCL:0; PCL:0; RULEID:; SRVR:DB4PR02MB0447;
X-Microsoft-Exchange-Diagnostics: 1; DB4PR02MB0447;
	4:iUa02yew7CE3s+Z/Pw/eHdsYphpO8fOhWjh61M4Z5zpDb0DCdyhiq7VFu9GJtf/GfxQKPupsEMrR4O0g4bVMdN61y2f/I8KbMfmuzwZPOTP4GdDljMSX5UAozRetzqWvZZtlTWdpA1o+l5N+WoZjUOXgetzQ/D+hBrQzc2nsXSTs829dBllNrhp2NzcjA1nEUA3dauZbrgJJYZeTph5PWypPfG5jFCtEANuq6mVG2iwPg8wMXFFM1YputgAbZOkifxgw34wGx4jF4z9MzUhg6++o13GQsbiK6FktXP1qPoFxTGKLjm6HQ1bhoCORiicTj+ovBBNNJ10r5Br5F3AlaeS2FtC6EPS/MoG9BWe4MUkh/VgKGVe/38jAAidnT0EAPwiOT9TGmVgw1hee5Aa1vmnKbJRPP40eEhbFEO4b7cv7EiHelLEYvh1jgZDalgoY
X-Forefront-PRVS: 07935ACF08
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; DB4PR02MB0447;
	23:48IAcjMlsB7B1tGV/uzHtkRNrzYZ3jnrVhXdZSgxE?=
	=?us-ascii?Q?Wsv3Cq2g2Xc9LZeVclgEdSqmvSZB6z05UsFR/wVWstR9mewHgGiqsdhORRbd?=
	=?us-ascii?Q?IYPfhbwV4SAOfDPQcF2OSxorpixA68P5q1z2mmPeKjNJYdeXNe8FwMDsczCy?=
	=?us-ascii?Q?4KfEAD7NqnusMtPoseYEVWutB9/aet0YQki4LvGsFinwni9wM+8b2z49LjYz?=
	=?us-ascii?Q?cGM2HoITW78248IR29Sv/dQu3Ak5CZUnyBlWK3Ku4uAnzdeHA2SjTBz1QLH6?=
	=?us-ascii?Q?ApLxrcaq+zzOvvPJucVm/J53kFqt3jYmMctuDMjGY6UY2SBElKnI0j5ptMAM?=
	=?us-ascii?Q?GmtdXnzjD1hdK8dF43+namDjoTg52oDDgx1DRf1yLDc96jP6ALL9upfpM+9L?=
	=?us-ascii?Q?ReLNaBeln4/ti4cOBuMwGF//Hmf9bi9tCsnbgoy2Mwey3tJhAAYOTl/3qZtt?=
	=?us-ascii?Q?DLkKh2YXXmUOeWEQUKXy906mF9PzKLcEoOi5tI9cwsMvrTFTIzMc+X3Aqr6q?=
	=?us-ascii?Q?pNw6j8U+/mzXEejHW8Qj6k8qmhMKgWa5VP+Esn2M/yuCTFkFXKFuR4i7vf//?=
	=?us-ascii?Q?Xt+B/3Bg1uVQPJ3iad4693Ap3ysyYL1F1oypnllv6CFbTS0UOtjoR+pOu8to?=
	=?us-ascii?Q?vNASlqhqmfxr80Rh3rrhcLfqyQBE0QxJAz4rW6R5fjyLO1uyyaEl1bASrexm?=
	=?us-ascii?Q?FQzLnQsMBlb3Kyeffjbodg5u3ppawMwQfq3RfkxD1yZwOhNZBiyhs0EqYU/a?=
	=?us-ascii?Q?vqgoTUK1AJe5p/SvpbA0BcJLBhqian5i8T1flv3qa5ETc0qq+fagrWyKnpHe?=
	=?us-ascii?Q?TVvflKY14kom+/gqCG+zRsejCNupRxLxVeYHi2RFVmcK3Gc5F8SMu6nZUHOh?=
	=?us-ascii?Q?jxM4bzGZAbnJfc1dE8/UlMOanC5jfK4q/phSJOod9tmMmrtZSURVMizwq8B/?=
	=?us-ascii?Q?Jt9iLncgtPzz0XnsZBPYk0o8Kd9efslNdYxTW/AFy8sPDAprHRwsGRzRoAJt?=
	=?us-ascii?Q?BIYV3ZsxFTqt0HBWiSqM+uUwV32XbADhI+o6x6CJBpDpPx4duJ3F0YU/dMBD?=
	=?us-ascii?Q?ct2L13OKrqPYA2vDG5q0yHDVh0B2hfygVtmk5U1kGSpg/pMZrnmPSP1Uiax/?=
	=?us-ascii?Q?V5gOTSefWOxlY4lbEQHrpoCJ348b36tH/XDw946I2ObeMWXP3cJlwvChye9p?=
	=?us-ascii?Q?CevnAr9aP2Yk4E=3D?=
X-Microsoft-Exchange-Diagnostics: 1; DB4PR02MB0447;
	5:JAaNPVYOsjjhOyAqQ7120QjLnOb/Z+ngyo7hlkTOzlLr8iyLmB9YfKdCD9TahVlNfdGZYlCoTCEM8nD18sRdo/CKRQnl4xnoYBlcemQecmc0gI5+hByexRuOM4lom8MN6Fng8xmg0Tjaz6cJ+u7Siw==;
	24:GKlGzaEv0mtQd/Y7/8AR1RbAsb+h4v09EpwQYnAKwJbhjlglVw0OJ7YDdwNkf64kI/l0h6Yu6BRDgmf+LFUTBg==
SpamDiagnosticOutput: 1:22
SpamDiagnosticMetadata: 00000000%2D0000%2D0000%2D0000%2D000000000000
X-OriginatorOrg: ezchip.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 17 Dec 2015 19:31:30.6024
	(UTC)
X-MS-Exchange-CrossTenant-Id: 0fc16e0a-3cd3-4092-8b2f-0a42cff122c3
X-MS-Exchange-CrossTenant-OriginalAttributedTenantConnectingIp: TenantId=0fc16e0a-3cd3-4092-8b2f-0a42cff122c3;
	Ip=[12.216.194.146]; Helo=[ld-2.internal.tilera.com]
X-MS-Exchange-CrossTenant-FromEntityHeader: HybridOnPrem
X-MS-Exchange-Transport-CrossTenantHeadersStamped: DB4PR02MB0447
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-3.8 required=5.0 tests=AXB_X_FF_SEZ_S,BAYES_00,
	RCVD_IN_DNSWL_HI, T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=142331">David Woods</a> - Dec. 17, 2015, 7:31 p.m.</div>
<pre class="content">
The arm64 MMU supports a Contiguous bit which is a hint that the TTE
is one of a set of contiguous entries which can be cached in a single
TLB entry.  Supporting this bit adds new intermediate huge page sizes.

The set of huge page sizes available depends on the base page size.
Without using contiguous pages the huge page sizes are as follows.

 4KB:   2MB  1GB
64KB: 512MB

With a 4KB granule, the contiguous bit groups together sets of 16 pages
and with a 64KB granule it groups sets of 32 pages.  This enables two new
huge page sizes in each case, so that the full set of available sizes
is as follows.

 4KB:  64KB   2MB  32MB  1GB
64KB:   2MB 512MB  16GB

If a 16KB granule is used then the contiguous bit groups 128 pages
at the PTE level and 32 pages at the PMD level.

If the base page size is set to 64KB then 2MB pages are enabled by
default.  It is possible in the future to make 2MB the default huge
page size for both 4KB and 64KB granules.
<span class="signed-off-by">
Signed-off-by: David Woods &lt;dwoods@ezchip.com&gt;</span>
<span class="reviewed-by">Reviewed-by: Chris Metcalf &lt;cmetcalf@ezchip.com&gt;</span>
---

Version 5 cleans up issues building with STRICT_MM_TYPECHECKS defined
pointed out by Steve Capper.

 arch/arm64/Kconfig                     |   3 -
 arch/arm64/include/asm/hugetlb.h       |  44 ++----
 arch/arm64/include/asm/pgtable-hwdef.h |  18 ++-
 arch/arm64/include/asm/pgtable.h       |  10 +-
 arch/arm64/mm/hugetlbpage.c            | 274 ++++++++++++++++++++++++++++++++-
 include/linux/hugetlb.h                |   2 -
 6 files changed, 313 insertions(+), 38 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=64911">Steve Capper</a> - Dec. 21, 2015, 7:10 a.m.</div>
<pre class="content">
On 17 December 2015 at 19:31, David Woods &lt;dwoods@ezchip.com&gt; wrote:
<span class="quote">&gt; The arm64 MMU supports a Contiguous bit which is a hint that the TTE</span>
<span class="quote">&gt; is one of a set of contiguous entries which can be cached in a single</span>
<span class="quote">&gt; TLB entry.  Supporting this bit adds new intermediate huge page sizes.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The set of huge page sizes available depends on the base page size.</span>
<span class="quote">&gt; Without using contiguous pages the huge page sizes are as follows.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  4KB:   2MB  1GB</span>
<span class="quote">&gt; 64KB: 512MB</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; With a 4KB granule, the contiguous bit groups together sets of 16 pages</span>
<span class="quote">&gt; and with a 64KB granule it groups sets of 32 pages.  This enables two new</span>
<span class="quote">&gt; huge page sizes in each case, so that the full set of available sizes</span>
<span class="quote">&gt; is as follows.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  4KB:  64KB   2MB  32MB  1GB</span>
<span class="quote">&gt; 64KB:   2MB 512MB  16GB</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If a 16KB granule is used then the contiguous bit groups 128 pages</span>
<span class="quote">&gt; at the PTE level and 32 pages at the PMD level.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If the base page size is set to 64KB then 2MB pages are enabled by</span>
<span class="quote">&gt; default.  It is possible in the future to make 2MB the default huge</span>
<span class="quote">&gt; page size for both 4KB and 64KB granules.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: David Woods &lt;dwoods@ezchip.com&gt;</span>
<span class="quote">&gt; Reviewed-by: Chris Metcalf &lt;cmetcalf@ezchip.com&gt;</span>

Thanks for this David, this looks great to me. Please add:
<span class="reviewed-by">Reviewed-by: Steve Capper &lt;steve.capper@linaro.org&gt;</span>

...and have a great Christmas break.
<span class="quote">
&gt; ---</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Version 5 cleans up issues building with STRICT_MM_TYPECHECKS defined</span>
<span class="quote">&gt; pointed out by Steve Capper.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  arch/arm64/Kconfig                     |   3 -</span>
<span class="quote">&gt;  arch/arm64/include/asm/hugetlb.h       |  44 ++----</span>
<span class="quote">&gt;  arch/arm64/include/asm/pgtable-hwdef.h |  18 ++-</span>
<span class="quote">&gt;  arch/arm64/include/asm/pgtable.h       |  10 +-</span>
<span class="quote">&gt;  arch/arm64/mm/hugetlbpage.c            | 274 ++++++++++++++++++++++++++++++++-</span>
<span class="quote">&gt;  include/linux/hugetlb.h                |   2 -</span>
<span class="quote">&gt;  6 files changed, 313 insertions(+), 38 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="quote">&gt; index 4876459..ffa3c54 100644</span>
<span class="quote">&gt; --- a/arch/arm64/Kconfig</span>
<span class="quote">&gt; +++ b/arch/arm64/Kconfig</span>
<span class="quote">&gt; @@ -530,9 +530,6 @@ config HW_PERF_EVENTS</span>
<span class="quote">&gt;  config SYS_SUPPORTS_HUGETLBFS</span>
<span class="quote">&gt;         def_bool y</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -config ARCH_WANT_GENERAL_HUGETLB</span>
<span class="quote">&gt; -       def_bool y</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  config ARCH_WANT_HUGE_PMD_SHARE</span>
<span class="quote">&gt;         def_bool y if ARM64_4K_PAGES || (ARM64_16K_PAGES &amp;&amp; !ARM64_VA_BITS_36)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/hugetlb.h b/arch/arm64/include/asm/hugetlb.h</span>
<span class="quote">&gt; index bb4052e..bbc1e35 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/hugetlb.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/hugetlb.h</span>
<span class="quote">&gt; @@ -26,36 +26,7 @@ static inline pte_t huge_ptep_get(pte_t *ptep)</span>
<span class="quote">&gt;         return *ptep;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -static inline void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="quote">&gt; -                                  pte_t *ptep, pte_t pte)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -       set_pte_at(mm, addr, ptep, pte);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static inline void huge_ptep_clear_flush(struct vm_area_struct *vma,</span>
<span class="quote">&gt; -                                        unsigned long addr, pte_t *ptep)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -       ptep_clear_flush(vma, addr, ptep);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static inline void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="quote">&gt; -                                          unsigned long addr, pte_t *ptep)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -       ptep_set_wrprotect(mm, addr, ptep);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -static inline pte_t huge_ptep_get_and_clear(struct mm_struct *mm,</span>
<span class="quote">&gt; -                                           unsigned long addr, pte_t *ptep)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -       return ptep_get_and_clear(mm, addr, ptep);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static inline int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="quote">&gt; -                                            unsigned long addr, pte_t *ptep,</span>
<span class="quote">&gt; -                                            pte_t pte, int dirty)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -       return ptep_set_access_flags(vma, addr, ptep, pte, dirty);</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  static inline void hugetlb_free_pgd_range(struct mmu_gather *tlb,</span>
<span class="quote">&gt;                                           unsigned long addr, unsigned long end,</span>
<span class="quote">&gt; @@ -97,4 +68,19 @@ static inline void arch_clear_hugepage_flags(struct page *page)</span>
<span class="quote">&gt;         clear_bit(PG_dcache_clean, &amp;page-&gt;flags);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +extern pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="quote">&gt; +                               struct page *page, int writable);</span>
<span class="quote">&gt; +#define arch_make_huge_pte arch_make_huge_pte</span>
<span class="quote">&gt; +extern void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="quote">&gt; +                           pte_t *ptep, pte_t pte);</span>
<span class="quote">&gt; +extern int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="quote">&gt; +                                     unsigned long addr, pte_t *ptep,</span>
<span class="quote">&gt; +                                     pte_t pte, int dirty);</span>
<span class="quote">&gt; +extern pte_t huge_ptep_get_and_clear(struct mm_struct *mm,</span>
<span class="quote">&gt; +                                    unsigned long addr, pte_t *ptep);</span>
<span class="quote">&gt; +extern void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="quote">&gt; +                                   unsigned long addr, pte_t *ptep);</span>
<span class="quote">&gt; +extern void huge_ptep_clear_flush(struct vm_area_struct *vma,</span>
<span class="quote">&gt; +                                 unsigned long addr, pte_t *ptep);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  #endif /* __ASM_HUGETLB_H */</span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="quote">&gt; index d6739e8..5c25b83 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="quote">&gt; @@ -90,7 +90,23 @@</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Contiguous page definitions.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; -#define CONT_PTES              (_AC(1, UL) &lt;&lt; CONT_SHIFT)</span>
<span class="quote">&gt; +#ifdef CONFIG_ARM64_64K_PAGES</span>
<span class="quote">&gt; +#define CONT_PTE_SHIFT         5</span>
<span class="quote">&gt; +#define CONT_PMD_SHIFT         5</span>
<span class="quote">&gt; +#elif defined(CONFIG_ARM64_16K_PAGES)</span>
<span class="quote">&gt; +#define CONT_PTE_SHIFT         7</span>
<span class="quote">&gt; +#define CONT_PMD_SHIFT         5</span>
<span class="quote">&gt; +#else</span>
<span class="quote">&gt; +#define CONT_PTE_SHIFT         4</span>
<span class="quote">&gt; +#define CONT_PMD_SHIFT         4</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define CONT_PTES              (1 &lt;&lt; CONT_PTE_SHIFT)</span>
<span class="quote">&gt; +#define CONT_PTE_SIZE          (CONT_PTES * PAGE_SIZE)</span>
<span class="quote">&gt; +#define CONT_PTE_MASK          (~(CONT_PTE_SIZE - 1))</span>
<span class="quote">&gt; +#define CONT_PMDS              (1 &lt;&lt; CONT_PMD_SHIFT)</span>
<span class="quote">&gt; +#define CONT_PMD_SIZE          (CONT_PMDS * PMD_SIZE)</span>
<span class="quote">&gt; +#define CONT_PMD_MASK          (~(CONT_PMD_SIZE - 1))</span>
<span class="quote">&gt;  /* the the numerical offset of the PTE within a range of CONT_PTES */</span>
<span class="quote">&gt;  #define CONT_RANGE_OFFSET(addr) (((addr)&gt;&gt;PAGE_SHIFT)&amp;(CONT_PTES-1))</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="quote">&gt; index 450b355..35a318c 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/pgtable.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="quote">&gt; @@ -227,7 +227,8 @@ static inline pte_t pte_mkspecial(pte_t pte)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  static inline pte_t pte_mkcont(pte_t pte)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -       return set_pte_bit(pte, __pgprot(PTE_CONT));</span>
<span class="quote">&gt; +       pte = set_pte_bit(pte, __pgprot(PTE_CONT));</span>
<span class="quote">&gt; +       return set_pte_bit(pte, __pgprot(PTE_TYPE_PAGE));</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  static inline pte_t pte_mknoncont(pte_t pte)</span>
<span class="quote">&gt; @@ -235,6 +236,11 @@ static inline pte_t pte_mknoncont(pte_t pte)</span>
<span class="quote">&gt;         return clear_pte_bit(pte, __pgprot(PTE_CONT));</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static inline pmd_t pmd_mkcont(pmd_t pmd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       return __pmd(pmd_val(pmd) | PMD_SECT_CONT);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static inline void set_pte(pte_t *ptep, pte_t pte)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;         *ptep = pte;</span>
<span class="quote">&gt; @@ -304,7 +310,7 @@ static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * Hugetlb definitions.</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; -#define HUGE_MAX_HSTATE                2</span>
<span class="quote">&gt; +#define HUGE_MAX_HSTATE                4</span>
<span class="quote">&gt;  #define HPAGE_SHIFT            PMD_SHIFT</span>
<span class="quote">&gt;  #define HPAGE_SIZE             (_AC(1, UL) &lt;&lt; HPAGE_SHIFT)</span>
<span class="quote">&gt;  #define HPAGE_MASK             (~(HPAGE_SIZE - 1))</span>
<span class="quote">&gt; diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="quote">&gt; index 383b03f..82d607c 100644</span>
<span class="quote">&gt; --- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="quote">&gt; +++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="quote">&gt; @@ -41,17 +41,289 @@ int pud_huge(pud_t pud)</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static int find_num_contig(struct mm_struct *mm, unsigned long addr,</span>
<span class="quote">&gt; +                          pte_t *ptep, pte_t pte, size_t *pgsize)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       pgd_t *pgd = pgd_offset(mm, addr);</span>
<span class="quote">&gt; +       pud_t *pud;</span>
<span class="quote">&gt; +       pmd_t *pmd;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       *pgsize = PAGE_SIZE;</span>
<span class="quote">&gt; +       if (!pte_cont(pte))</span>
<span class="quote">&gt; +               return 1;</span>
<span class="quote">&gt; +       if (!pgd_present(*pgd)) {</span>
<span class="quote">&gt; +               VM_BUG_ON(!pgd_present(*pgd));</span>
<span class="quote">&gt; +               return 1;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       pud = pud_offset(pgd, addr);</span>
<span class="quote">&gt; +       if (!pud_present(*pud)) {</span>
<span class="quote">&gt; +               VM_BUG_ON(!pud_present(*pud));</span>
<span class="quote">&gt; +               return 1;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       pmd = pmd_offset(pud, addr);</span>
<span class="quote">&gt; +       if (!pmd_present(*pmd)) {</span>
<span class="quote">&gt; +               VM_BUG_ON(!pmd_present(*pmd));</span>
<span class="quote">&gt; +               return 1;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       if ((pte_t *)pmd == ptep) {</span>
<span class="quote">&gt; +               *pgsize = PMD_SIZE;</span>
<span class="quote">&gt; +               return CONT_PMDS;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return CONT_PTES;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="quote">&gt; +                           pte_t *ptep, pte_t pte)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       size_t pgsize;</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +       int ncontig = find_num_contig(mm, addr, ptep, pte, &amp;pgsize);</span>
<span class="quote">&gt; +       unsigned long pfn;</span>
<span class="quote">&gt; +       pgprot_t hugeprot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (ncontig == 1) {</span>
<span class="quote">&gt; +               set_pte_at(mm, addr, ptep, pte);</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pfn = pte_pfn(pte);</span>
<span class="quote">&gt; +       hugeprot = __pgprot(pte_val(pfn_pte(pfn, __pgprot(0))) ^ pte_val(pte));</span>
<span class="quote">&gt; +       for (i = 0; i &lt; ncontig; i++) {</span>
<span class="quote">&gt; +               pr_debug(&quot;%s: set pte %p to 0x%llx\n&quot;, __func__, ptep,</span>
<span class="quote">&gt; +                        pte_val(pfn_pte(pfn, hugeprot)));</span>
<span class="quote">&gt; +               set_pte_at(mm, addr, ptep, pfn_pte(pfn, hugeprot));</span>
<span class="quote">&gt; +               ptep++;</span>
<span class="quote">&gt; +               pfn += pgsize &gt;&gt; PAGE_SHIFT;</span>
<span class="quote">&gt; +               addr += pgsize;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +pte_t *huge_pte_alloc(struct mm_struct *mm,</span>
<span class="quote">&gt; +                     unsigned long addr, unsigned long sz)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       pgd_t *pgd;</span>
<span class="quote">&gt; +       pud_t *pud;</span>
<span class="quote">&gt; +       pte_t *pte = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pr_debug(&quot;%s: addr:0x%lx sz:0x%lx\n&quot;, __func__, addr, sz);</span>
<span class="quote">&gt; +       pgd = pgd_offset(mm, addr);</span>
<span class="quote">&gt; +       pud = pud_alloc(mm, pgd, addr);</span>
<span class="quote">&gt; +       if (!pud)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (sz == PUD_SIZE) {</span>
<span class="quote">&gt; +               pte = (pte_t *)pud;</span>
<span class="quote">&gt; +       } else if (sz == (PAGE_SIZE * CONT_PTES)) {</span>
<span class="quote">&gt; +               pmd_t *pmd = pmd_alloc(mm, pud, addr);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               WARN_ON(addr &amp; (sz - 1));</span>
<span class="quote">&gt; +               /*</span>
<span class="quote">&gt; +                * Note that if this code were ever ported to the</span>
<span class="quote">&gt; +                * 32-bit arm platform then it will cause trouble in</span>
<span class="quote">&gt; +                * the case where CONFIG_HIGHPTE is set, since there</span>
<span class="quote">&gt; +                * will be no pte_unmap() to correspond with this</span>
<span class="quote">&gt; +                * pte_alloc_map().</span>
<span class="quote">&gt; +                */</span>
<span class="quote">&gt; +               pte = pte_alloc_map(mm, NULL, pmd, addr);</span>
<span class="quote">&gt; +       } else if (sz == PMD_SIZE) {</span>
<span class="quote">&gt; +               if (IS_ENABLED(CONFIG_ARCH_WANT_HUGE_PMD_SHARE) &amp;&amp;</span>
<span class="quote">&gt; +                   pud_none(*pud))</span>
<span class="quote">&gt; +                       pte = huge_pmd_share(mm, addr, pud);</span>
<span class="quote">&gt; +               else</span>
<span class="quote">&gt; +                       pte = (pte_t *)pmd_alloc(mm, pud, addr);</span>
<span class="quote">&gt; +       } else if (sz == (PMD_SIZE * CONT_PMDS)) {</span>
<span class="quote">&gt; +               pmd_t *pmd;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               pmd = pmd_alloc(mm, pud, addr);</span>
<span class="quote">&gt; +               WARN_ON(addr &amp; (sz - 1));</span>
<span class="quote">&gt; +               return (pte_t *)pmd;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pr_debug(&quot;%s: addr:0x%lx sz:0x%lx ret pte=%p/0x%llx\n&quot;, __func__, addr,</span>
<span class="quote">&gt; +              sz, pte, pte_val(*pte));</span>
<span class="quote">&gt; +       return pte;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       pgd_t *pgd;</span>
<span class="quote">&gt; +       pud_t *pud;</span>
<span class="quote">&gt; +       pmd_t *pmd = NULL;</span>
<span class="quote">&gt; +       pte_t *pte = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgd = pgd_offset(mm, addr);</span>
<span class="quote">&gt; +       pr_debug(&quot;%s: addr:0x%lx pgd:%p\n&quot;, __func__, addr, pgd);</span>
<span class="quote">&gt; +       if (!pgd_present(*pgd))</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +       pud = pud_offset(pgd, addr);</span>
<span class="quote">&gt; +       if (!pud_present(*pud))</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (pud_huge(*pud))</span>
<span class="quote">&gt; +               return (pte_t *)pud;</span>
<span class="quote">&gt; +       pmd = pmd_offset(pud, addr);</span>
<span class="quote">&gt; +       if (!pmd_present(*pmd))</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (pte_cont(pmd_pte(*pmd))) {</span>
<span class="quote">&gt; +               pmd = pmd_offset(</span>
<span class="quote">&gt; +                       pud, (addr &amp; CONT_PMD_MASK));</span>
<span class="quote">&gt; +               return (pte_t *)pmd;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       if (pmd_huge(*pmd))</span>
<span class="quote">&gt; +               return (pte_t *)pmd;</span>
<span class="quote">&gt; +       pte = pte_offset_kernel(pmd, addr);</span>
<span class="quote">&gt; +       if (pte_present(*pte) &amp;&amp; pte_cont(*pte)) {</span>
<span class="quote">&gt; +               pte = pte_offset_kernel(</span>
<span class="quote">&gt; +                       pmd, (addr &amp; CONT_PTE_MASK));</span>
<span class="quote">&gt; +               return pte;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return NULL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="quote">&gt; +                        struct page *page, int writable)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       size_t pagesize = huge_page_size(hstate_vma(vma));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (pagesize == CONT_PTE_SIZE) {</span>
<span class="quote">&gt; +               entry = pte_mkcont(entry);</span>
<span class="quote">&gt; +       } else if (pagesize == CONT_PMD_SIZE) {</span>
<span class="quote">&gt; +               entry = pmd_pte(pmd_mkcont(pte_pmd(entry)));</span>
<span class="quote">&gt; +       } else if (pagesize != PUD_SIZE &amp;&amp; pagesize != PMD_SIZE) {</span>
<span class="quote">&gt; +               pr_warn(&quot;%s: unrecognized huge page size 0x%lx\n&quot;,</span>
<span class="quote">&gt; +                       __func__, pagesize);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return entry;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +pte_t huge_ptep_get_and_clear(struct mm_struct *mm,</span>
<span class="quote">&gt; +                             unsigned long addr, pte_t *ptep)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       pte_t pte;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (pte_cont(*ptep)) {</span>
<span class="quote">&gt; +               int ncontig, i;</span>
<span class="quote">&gt; +               size_t pgsize;</span>
<span class="quote">&gt; +               pte_t *cpte;</span>
<span class="quote">&gt; +               bool is_dirty = false;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               cpte = huge_pte_offset(mm, addr);</span>
<span class="quote">&gt; +               ncontig = find_num_contig(mm, addr, cpte, *cpte, &amp;pgsize);</span>
<span class="quote">&gt; +               /* save the 1st pte to return */</span>
<span class="quote">&gt; +               pte = ptep_get_and_clear(mm, addr, cpte);</span>
<span class="quote">&gt; +               for (i = 1; i &lt; ncontig; ++i) {</span>
<span class="quote">&gt; +                       /*</span>
<span class="quote">&gt; +                        * If HW_AFDBM is enabled, then the HW could</span>
<span class="quote">&gt; +                        * turn on the dirty bit for any of the page</span>
<span class="quote">&gt; +                        * in the set, so check them all.</span>
<span class="quote">&gt; +                        */</span>
<span class="quote">&gt; +                       ++cpte;</span>
<span class="quote">&gt; +                       if (pte_dirty(ptep_get_and_clear(mm, addr, cpte)))</span>
<span class="quote">&gt; +                               is_dirty = true;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               if (is_dirty)</span>
<span class="quote">&gt; +                       return pte_mkdirty(pte);</span>
<span class="quote">&gt; +               else</span>
<span class="quote">&gt; +                       return pte;</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               return ptep_get_and_clear(mm, addr, ptep);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="quote">&gt; +                              unsigned long addr, pte_t *ptep,</span>
<span class="quote">&gt; +                              pte_t pte, int dirty)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       pte_t *cpte;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (pte_cont(pte)) {</span>
<span class="quote">&gt; +               int ncontig, i, changed = 0;</span>
<span class="quote">&gt; +               size_t pgsize = 0;</span>
<span class="quote">&gt; +               unsigned long pfn = pte_pfn(pte);</span>
<span class="quote">&gt; +               /* Select all bits except the pfn */</span>
<span class="quote">&gt; +               pgprot_t hugeprot =</span>
<span class="quote">&gt; +                       __pgprot(pte_val(pfn_pte(pfn, __pgprot(0))) ^</span>
<span class="quote">&gt; +                                pte_val(pte));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               cpte = huge_pte_offset(vma-&gt;vm_mm, addr);</span>
<span class="quote">&gt; +               pfn = pte_pfn(*cpte);</span>
<span class="quote">&gt; +               ncontig = find_num_contig(vma-&gt;vm_mm, addr, cpte,</span>
<span class="quote">&gt; +                                         *cpte, &amp;pgsize);</span>
<span class="quote">&gt; +               for (i = 0; i &lt; ncontig; ++i, ++cpte) {</span>
<span class="quote">&gt; +                       changed = ptep_set_access_flags(vma, addr, cpte,</span>
<span class="quote">&gt; +                                                       pfn_pte(pfn,</span>
<span class="quote">&gt; +                                                               hugeprot),</span>
<span class="quote">&gt; +                                                       dirty);</span>
<span class="quote">&gt; +                       pfn += pgsize &gt;&gt; PAGE_SHIFT;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               return changed;</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               return ptep_set_access_flags(vma, addr, ptep, pte, dirty);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="quote">&gt; +                            unsigned long addr, pte_t *ptep)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       if (pte_cont(*ptep)) {</span>
<span class="quote">&gt; +               int ncontig, i;</span>
<span class="quote">&gt; +               pte_t *cpte;</span>
<span class="quote">&gt; +               size_t pgsize = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               cpte = huge_pte_offset(mm, addr);</span>
<span class="quote">&gt; +               ncontig = find_num_contig(mm, addr, cpte, *cpte, &amp;pgsize);</span>
<span class="quote">&gt; +               for (i = 0; i &lt; ncontig; ++i, ++cpte)</span>
<span class="quote">&gt; +                       ptep_set_wrprotect(mm, addr, cpte);</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               ptep_set_wrprotect(mm, addr, ptep);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void huge_ptep_clear_flush(struct vm_area_struct *vma,</span>
<span class="quote">&gt; +                          unsigned long addr, pte_t *ptep)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       if (pte_cont(*ptep)) {</span>
<span class="quote">&gt; +               int ncontig, i;</span>
<span class="quote">&gt; +               pte_t *cpte;</span>
<span class="quote">&gt; +               size_t pgsize = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               cpte = huge_pte_offset(vma-&gt;vm_mm, addr);</span>
<span class="quote">&gt; +               ncontig = find_num_contig(vma-&gt;vm_mm, addr, cpte,</span>
<span class="quote">&gt; +                                         *cpte, &amp;pgsize);</span>
<span class="quote">&gt; +               for (i = 0; i &lt; ncontig; ++i, ++cpte)</span>
<span class="quote">&gt; +                       ptep_clear_flush(vma, addr, cpte);</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               ptep_clear_flush(vma, addr, ptep);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static __init int setup_hugepagesz(char *opt)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;         unsigned long ps = memparse(opt, &amp;opt);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;         if (ps == PMD_SIZE) {</span>
<span class="quote">&gt;                 hugetlb_add_hstate(PMD_SHIFT - PAGE_SHIFT);</span>
<span class="quote">&gt;         } else if (ps == PUD_SIZE) {</span>
<span class="quote">&gt;                 hugetlb_add_hstate(PUD_SHIFT - PAGE_SHIFT);</span>
<span class="quote">&gt; +       } else if (ps == (PAGE_SIZE * CONT_PTES)) {</span>
<span class="quote">&gt; +               hugetlb_add_hstate(CONT_PTE_SHIFT);</span>
<span class="quote">&gt; +       } else if (ps == (PMD_SIZE * CONT_PMDS)) {</span>
<span class="quote">&gt; +               hugetlb_add_hstate((PMD_SHIFT + CONT_PMD_SHIFT) - PAGE_SHIFT);</span>
<span class="quote">&gt;         } else {</span>
<span class="quote">&gt; -               pr_err(&quot;hugepagesz: Unsupported page size %lu M\n&quot;, ps &gt;&gt; 20);</span>
<span class="quote">&gt; +               pr_err(&quot;hugepagesz: Unsupported page size %lu K\n&quot;, ps &gt;&gt; 10);</span>
<span class="quote">&gt;                 return 0;</span>
<span class="quote">&gt;         }</span>
<span class="quote">&gt;         return 1;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  __setup(&quot;hugepagesz=&quot;, setup_hugepagesz);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifdef CONFIG_ARM64_64K_PAGES</span>
<span class="quote">&gt; +static __init int add_default_hugepagesz(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       if (size_to_hstate(CONT_PTES * PAGE_SIZE) == NULL)</span>
<span class="quote">&gt; +               hugetlb_add_hstate(CONT_PMD_SHIFT);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +arch_initcall(add_default_hugepagesz);</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="quote">&gt; index 685c262..b0eb064 100644</span>
<span class="quote">&gt; --- a/include/linux/hugetlb.h</span>
<span class="quote">&gt; +++ b/include/linux/hugetlb.h</span>
<span class="quote">&gt; @@ -96,9 +96,7 @@ u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,</span>
<span class="quote">&gt;                                 struct address_space *mapping,</span>
<span class="quote">&gt;                                 pgoff_t idx, unsigned long address);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -#ifdef CONFIG_ARCH_WANT_HUGE_PMD_SHARE</span>
<span class="quote">&gt;  pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud);</span>
<span class="quote">&gt; -#endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  extern int hugepages_treat_as_movable;</span>
<span class="quote">&gt;  extern int sysctl_hugetlb_shm_group;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; 2.1.2</span>
<span class="quote">&gt;</span>
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="p_header">index 4876459..ffa3c54 100644</span>
<span class="p_header">--- a/arch/arm64/Kconfig</span>
<span class="p_header">+++ b/arch/arm64/Kconfig</span>
<span class="p_chunk">@@ -530,9 +530,6 @@</span> <span class="p_context"> config HW_PERF_EVENTS</span>
 config SYS_SUPPORTS_HUGETLBFS
 	def_bool y
 
<span class="p_del">-config ARCH_WANT_GENERAL_HUGETLB</span>
<span class="p_del">-	def_bool y</span>
<span class="p_del">-</span>
 config ARCH_WANT_HUGE_PMD_SHARE
 	def_bool y if ARM64_4K_PAGES || (ARM64_16K_PAGES &amp;&amp; !ARM64_VA_BITS_36)
 
<span class="p_header">diff --git a/arch/arm64/include/asm/hugetlb.h b/arch/arm64/include/asm/hugetlb.h</span>
<span class="p_header">index bb4052e..bbc1e35 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -26,36 +26,7 @@</span> <span class="p_context"> static inline pte_t huge_ptep_get(pte_t *ptep)</span>
 	return *ptep;
 }
 
<span class="p_del">-static inline void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_del">-				   pte_t *ptep, pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	set_pte_at(mm, addr, ptep, pte);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void huge_ptep_clear_flush(struct vm_area_struct *vma,</span>
<span class="p_del">-					 unsigned long addr, pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ptep_clear_flush(vma, addr, ptep);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="p_del">-					   unsigned long addr, pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ptep_set_wrprotect(mm, addr, ptep);</span>
<span class="p_del">-}</span>
 
<span class="p_del">-static inline pte_t huge_ptep_get_and_clear(struct mm_struct *mm,</span>
<span class="p_del">-					    unsigned long addr, pte_t *ptep)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return ptep_get_and_clear(mm, addr, ptep);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_del">-					     unsigned long addr, pte_t *ptep,</span>
<span class="p_del">-					     pte_t pte, int dirty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return ptep_set_access_flags(vma, addr, ptep, pte, dirty);</span>
<span class="p_del">-}</span>
 
 static inline void hugetlb_free_pgd_range(struct mmu_gather *tlb,
 					  unsigned long addr, unsigned long end,
<span class="p_chunk">@@ -97,4 +68,19 @@</span> <span class="p_context"> static inline void arch_clear_hugepage_flags(struct page *page)</span>
 	clear_bit(PG_dcache_clean, &amp;page-&gt;flags);
 }
 
<span class="p_add">+extern pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="p_add">+				struct page *page, int writable);</span>
<span class="p_add">+#define arch_make_huge_pte arch_make_huge_pte</span>
<span class="p_add">+extern void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+			    pte_t *ptep, pte_t pte);</span>
<span class="p_add">+extern int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+				      unsigned long addr, pte_t *ptep,</span>
<span class="p_add">+				      pte_t pte, int dirty);</span>
<span class="p_add">+extern pte_t huge_ptep_get_and_clear(struct mm_struct *mm,</span>
<span class="p_add">+				     unsigned long addr, pte_t *ptep);</span>
<span class="p_add">+extern void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="p_add">+				    unsigned long addr, pte_t *ptep);</span>
<span class="p_add">+extern void huge_ptep_clear_flush(struct vm_area_struct *vma,</span>
<span class="p_add">+				  unsigned long addr, pte_t *ptep);</span>
<span class="p_add">+</span>
 #endif /* __ASM_HUGETLB_H */
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">index d6739e8..5c25b83 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_chunk">@@ -90,7 +90,23 @@</span> <span class="p_context"></span>
 /*
  * Contiguous page definitions.
  */
<span class="p_del">-#define CONT_PTES		(_AC(1, UL) &lt;&lt; CONT_SHIFT)</span>
<span class="p_add">+#ifdef CONFIG_ARM64_64K_PAGES</span>
<span class="p_add">+#define CONT_PTE_SHIFT		5</span>
<span class="p_add">+#define CONT_PMD_SHIFT		5</span>
<span class="p_add">+#elif defined(CONFIG_ARM64_16K_PAGES)</span>
<span class="p_add">+#define CONT_PTE_SHIFT		7</span>
<span class="p_add">+#define CONT_PMD_SHIFT		5</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define CONT_PTE_SHIFT		4</span>
<span class="p_add">+#define CONT_PMD_SHIFT		4</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define CONT_PTES		(1 &lt;&lt; CONT_PTE_SHIFT)</span>
<span class="p_add">+#define CONT_PTE_SIZE		(CONT_PTES * PAGE_SIZE)</span>
<span class="p_add">+#define CONT_PTE_MASK		(~(CONT_PTE_SIZE - 1))</span>
<span class="p_add">+#define CONT_PMDS		(1 &lt;&lt; CONT_PMD_SHIFT)</span>
<span class="p_add">+#define CONT_PMD_SIZE		(CONT_PMDS * PMD_SIZE)</span>
<span class="p_add">+#define CONT_PMD_MASK		(~(CONT_PMD_SIZE - 1))</span>
 /* the the numerical offset of the PTE within a range of CONT_PTES */
 #define CONT_RANGE_OFFSET(addr) (((addr)&gt;&gt;PAGE_SHIFT)&amp;(CONT_PTES-1))
 
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">index 450b355..35a318c 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -227,7 +227,8 @@</span> <span class="p_context"> static inline pte_t pte_mkspecial(pte_t pte)</span>
 
 static inline pte_t pte_mkcont(pte_t pte)
 {
<span class="p_del">-	return set_pte_bit(pte, __pgprot(PTE_CONT));</span>
<span class="p_add">+	pte = set_pte_bit(pte, __pgprot(PTE_CONT));</span>
<span class="p_add">+	return set_pte_bit(pte, __pgprot(PTE_TYPE_PAGE));</span>
 }
 
 static inline pte_t pte_mknoncont(pte_t pte)
<span class="p_chunk">@@ -235,6 +236,11 @@</span> <span class="p_context"> static inline pte_t pte_mknoncont(pte_t pte)</span>
 	return clear_pte_bit(pte, __pgprot(PTE_CONT));
 }
 
<span class="p_add">+static inline pmd_t pmd_mkcont(pmd_t pmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __pmd(pmd_val(pmd) | PMD_SECT_CONT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void set_pte(pte_t *ptep, pte_t pte)
 {
 	*ptep = pte;
<span class="p_chunk">@@ -304,7 +310,7 @@</span> <span class="p_context"> static inline void set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
 /*
  * Hugetlb definitions.
  */
<span class="p_del">-#define HUGE_MAX_HSTATE		2</span>
<span class="p_add">+#define HUGE_MAX_HSTATE		4</span>
 #define HPAGE_SHIFT		PMD_SHIFT
 #define HPAGE_SIZE		(_AC(1, UL) &lt;&lt; HPAGE_SHIFT)
 #define HPAGE_MASK		(~(HPAGE_SIZE - 1))
<span class="p_header">diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">index 383b03f..82d607c 100644</span>
<span class="p_header">--- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -41,17 +41,289 @@</span> <span class="p_context"> int pud_huge(pud_t pud)</span>
 #endif
 }
 
<span class="p_add">+static int find_num_contig(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+			   pte_t *ptep, pte_t pte, size_t *pgsize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd = pgd_offset(mm, addr);</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+	*pgsize = PAGE_SIZE;</span>
<span class="p_add">+	if (!pte_cont(pte))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	if (!pgd_present(*pgd)) {</span>
<span class="p_add">+		VM_BUG_ON(!pgd_present(*pgd));</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pud = pud_offset(pgd, addr);</span>
<span class="p_add">+	if (!pud_present(*pud)) {</span>
<span class="p_add">+		VM_BUG_ON(!pud_present(*pud));</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pmd = pmd_offset(pud, addr);</span>
<span class="p_add">+	if (!pmd_present(*pmd)) {</span>
<span class="p_add">+		VM_BUG_ON(!pmd_present(*pmd));</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if ((pte_t *)pmd == ptep) {</span>
<span class="p_add">+		*pgsize = PMD_SIZE;</span>
<span class="p_add">+		return CONT_PMDS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return CONT_PTES;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
<span class="p_add">+			    pte_t *ptep, pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t pgsize;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int ncontig = find_num_contig(mm, addr, ptep, pte, &amp;pgsize);</span>
<span class="p_add">+	unsigned long pfn;</span>
<span class="p_add">+	pgprot_t hugeprot;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ncontig == 1) {</span>
<span class="p_add">+		set_pte_at(mm, addr, ptep, pte);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pfn = pte_pfn(pte);</span>
<span class="p_add">+	hugeprot = __pgprot(pte_val(pfn_pte(pfn, __pgprot(0))) ^ pte_val(pte));</span>
<span class="p_add">+	for (i = 0; i &lt; ncontig; i++) {</span>
<span class="p_add">+		pr_debug(&quot;%s: set pte %p to 0x%llx\n&quot;, __func__, ptep,</span>
<span class="p_add">+			 pte_val(pfn_pte(pfn, hugeprot)));</span>
<span class="p_add">+		set_pte_at(mm, addr, ptep, pfn_pte(pfn, hugeprot));</span>
<span class="p_add">+		ptep++;</span>
<span class="p_add">+		pfn += pgsize &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		addr += pgsize;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+pte_t *huge_pte_alloc(struct mm_struct *mm,</span>
<span class="p_add">+		      unsigned long addr, unsigned long sz)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	pte_t *pte = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;%s: addr:0x%lx sz:0x%lx\n&quot;, __func__, addr, sz);</span>
<span class="p_add">+	pgd = pgd_offset(mm, addr);</span>
<span class="p_add">+	pud = pud_alloc(mm, pgd, addr);</span>
<span class="p_add">+	if (!pud)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sz == PUD_SIZE) {</span>
<span class="p_add">+		pte = (pte_t *)pud;</span>
<span class="p_add">+	} else if (sz == (PAGE_SIZE * CONT_PTES)) {</span>
<span class="p_add">+		pmd_t *pmd = pmd_alloc(mm, pud, addr);</span>
<span class="p_add">+</span>
<span class="p_add">+		WARN_ON(addr &amp; (sz - 1));</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Note that if this code were ever ported to the</span>
<span class="p_add">+		 * 32-bit arm platform then it will cause trouble in</span>
<span class="p_add">+		 * the case where CONFIG_HIGHPTE is set, since there</span>
<span class="p_add">+		 * will be no pte_unmap() to correspond with this</span>
<span class="p_add">+		 * pte_alloc_map().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		pte = pte_alloc_map(mm, NULL, pmd, addr);</span>
<span class="p_add">+	} else if (sz == PMD_SIZE) {</span>
<span class="p_add">+		if (IS_ENABLED(CONFIG_ARCH_WANT_HUGE_PMD_SHARE) &amp;&amp;</span>
<span class="p_add">+		    pud_none(*pud))</span>
<span class="p_add">+			pte = huge_pmd_share(mm, addr, pud);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pte = (pte_t *)pmd_alloc(mm, pud, addr);</span>
<span class="p_add">+	} else if (sz == (PMD_SIZE * CONT_PMDS)) {</span>
<span class="p_add">+		pmd_t *pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+		pmd = pmd_alloc(mm, pud, addr);</span>
<span class="p_add">+		WARN_ON(addr &amp; (sz - 1));</span>
<span class="p_add">+		return (pte_t *)pmd;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;%s: addr:0x%lx sz:0x%lx ret pte=%p/0x%llx\n&quot;, __func__, addr,</span>
<span class="p_add">+	       sz, pte, pte_val(*pte));</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+pte_t *huge_pte_offset(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	pmd_t *pmd = NULL;</span>
<span class="p_add">+	pte_t *pte = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = pgd_offset(mm, addr);</span>
<span class="p_add">+	pr_debug(&quot;%s: addr:0x%lx pgd:%p\n&quot;, __func__, addr, pgd);</span>
<span class="p_add">+	if (!pgd_present(*pgd))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	pud = pud_offset(pgd, addr);</span>
<span class="p_add">+	if (!pud_present(*pud))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pud_huge(*pud))</span>
<span class="p_add">+		return (pte_t *)pud;</span>
<span class="p_add">+	pmd = pmd_offset(pud, addr);</span>
<span class="p_add">+	if (!pmd_present(*pmd))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pte_cont(pmd_pte(*pmd))) {</span>
<span class="p_add">+		pmd = pmd_offset(</span>
<span class="p_add">+			pud, (addr &amp; CONT_PMD_MASK));</span>
<span class="p_add">+		return (pte_t *)pmd;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (pmd_huge(*pmd))</span>
<span class="p_add">+		return (pte_t *)pmd;</span>
<span class="p_add">+	pte = pte_offset_kernel(pmd, addr);</span>
<span class="p_add">+	if (pte_present(*pte) &amp;&amp; pte_cont(*pte)) {</span>
<span class="p_add">+		pte = pte_offset_kernel(</span>
<span class="p_add">+			pmd, (addr &amp; CONT_PTE_MASK));</span>
<span class="p_add">+		return pte;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+pte_t arch_make_huge_pte(pte_t entry, struct vm_area_struct *vma,</span>
<span class="p_add">+			 struct page *page, int writable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t pagesize = huge_page_size(hstate_vma(vma));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pagesize == CONT_PTE_SIZE) {</span>
<span class="p_add">+		entry = pte_mkcont(entry);</span>
<span class="p_add">+	} else if (pagesize == CONT_PMD_SIZE) {</span>
<span class="p_add">+		entry = pmd_pte(pmd_mkcont(pte_pmd(entry)));</span>
<span class="p_add">+	} else if (pagesize != PUD_SIZE &amp;&amp; pagesize != PMD_SIZE) {</span>
<span class="p_add">+		pr_warn(&quot;%s: unrecognized huge page size 0x%lx\n&quot;,</span>
<span class="p_add">+			__func__, pagesize);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return entry;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+pte_t huge_ptep_get_and_clear(struct mm_struct *mm,</span>
<span class="p_add">+			      unsigned long addr, pte_t *ptep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pte_cont(*ptep)) {</span>
<span class="p_add">+		int ncontig, i;</span>
<span class="p_add">+		size_t pgsize;</span>
<span class="p_add">+		pte_t *cpte;</span>
<span class="p_add">+		bool is_dirty = false;</span>
<span class="p_add">+</span>
<span class="p_add">+		cpte = huge_pte_offset(mm, addr);</span>
<span class="p_add">+		ncontig = find_num_contig(mm, addr, cpte, *cpte, &amp;pgsize);</span>
<span class="p_add">+		/* save the 1st pte to return */</span>
<span class="p_add">+		pte = ptep_get_and_clear(mm, addr, cpte);</span>
<span class="p_add">+		for (i = 1; i &lt; ncontig; ++i) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If HW_AFDBM is enabled, then the HW could</span>
<span class="p_add">+			 * turn on the dirty bit for any of the page</span>
<span class="p_add">+			 * in the set, so check them all.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			++cpte;</span>
<span class="p_add">+			if (pte_dirty(ptep_get_and_clear(mm, addr, cpte)))</span>
<span class="p_add">+				is_dirty = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (is_dirty)</span>
<span class="p_add">+			return pte_mkdirty(pte);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return pte;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return ptep_get_and_clear(mm, addr, ptep);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int huge_ptep_set_access_flags(struct vm_area_struct *vma,</span>
<span class="p_add">+			       unsigned long addr, pte_t *ptep,</span>
<span class="p_add">+			       pte_t pte, int dirty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t *cpte;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pte_cont(pte)) {</span>
<span class="p_add">+		int ncontig, i, changed = 0;</span>
<span class="p_add">+		size_t pgsize = 0;</span>
<span class="p_add">+		unsigned long pfn = pte_pfn(pte);</span>
<span class="p_add">+		/* Select all bits except the pfn */</span>
<span class="p_add">+		pgprot_t hugeprot =</span>
<span class="p_add">+			__pgprot(pte_val(pfn_pte(pfn, __pgprot(0))) ^</span>
<span class="p_add">+				 pte_val(pte));</span>
<span class="p_add">+</span>
<span class="p_add">+		cpte = huge_pte_offset(vma-&gt;vm_mm, addr);</span>
<span class="p_add">+		pfn = pte_pfn(*cpte);</span>
<span class="p_add">+		ncontig = find_num_contig(vma-&gt;vm_mm, addr, cpte,</span>
<span class="p_add">+					  *cpte, &amp;pgsize);</span>
<span class="p_add">+		for (i = 0; i &lt; ncontig; ++i, ++cpte) {</span>
<span class="p_add">+			changed = ptep_set_access_flags(vma, addr, cpte,</span>
<span class="p_add">+							pfn_pte(pfn,</span>
<span class="p_add">+								hugeprot),</span>
<span class="p_add">+							dirty);</span>
<span class="p_add">+			pfn += pgsize &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return changed;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return ptep_set_access_flags(vma, addr, ptep, pte, dirty);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void huge_ptep_set_wrprotect(struct mm_struct *mm,</span>
<span class="p_add">+			     unsigned long addr, pte_t *ptep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pte_cont(*ptep)) {</span>
<span class="p_add">+		int ncontig, i;</span>
<span class="p_add">+		pte_t *cpte;</span>
<span class="p_add">+		size_t pgsize = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		cpte = huge_pte_offset(mm, addr);</span>
<span class="p_add">+		ncontig = find_num_contig(mm, addr, cpte, *cpte, &amp;pgsize);</span>
<span class="p_add">+		for (i = 0; i &lt; ncontig; ++i, ++cpte)</span>
<span class="p_add">+			ptep_set_wrprotect(mm, addr, cpte);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ptep_set_wrprotect(mm, addr, ptep);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void huge_ptep_clear_flush(struct vm_area_struct *vma,</span>
<span class="p_add">+			   unsigned long addr, pte_t *ptep)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pte_cont(*ptep)) {</span>
<span class="p_add">+		int ncontig, i;</span>
<span class="p_add">+		pte_t *cpte;</span>
<span class="p_add">+		size_t pgsize = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		cpte = huge_pte_offset(vma-&gt;vm_mm, addr);</span>
<span class="p_add">+		ncontig = find_num_contig(vma-&gt;vm_mm, addr, cpte,</span>
<span class="p_add">+					  *cpte, &amp;pgsize);</span>
<span class="p_add">+		for (i = 0; i &lt; ncontig; ++i, ++cpte)</span>
<span class="p_add">+			ptep_clear_flush(vma, addr, cpte);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ptep_clear_flush(vma, addr, ptep);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __init int setup_hugepagesz(char *opt)
 {
 	unsigned long ps = memparse(opt, &amp;opt);
<span class="p_add">+</span>
 	if (ps == PMD_SIZE) {
 		hugetlb_add_hstate(PMD_SHIFT - PAGE_SHIFT);
 	} else if (ps == PUD_SIZE) {
 		hugetlb_add_hstate(PUD_SHIFT - PAGE_SHIFT);
<span class="p_add">+	} else if (ps == (PAGE_SIZE * CONT_PTES)) {</span>
<span class="p_add">+		hugetlb_add_hstate(CONT_PTE_SHIFT);</span>
<span class="p_add">+	} else if (ps == (PMD_SIZE * CONT_PMDS)) {</span>
<span class="p_add">+		hugetlb_add_hstate((PMD_SHIFT + CONT_PMD_SHIFT) - PAGE_SHIFT);</span>
 	} else {
<span class="p_del">-		pr_err(&quot;hugepagesz: Unsupported page size %lu M\n&quot;, ps &gt;&gt; 20);</span>
<span class="p_add">+		pr_err(&quot;hugepagesz: Unsupported page size %lu K\n&quot;, ps &gt;&gt; 10);</span>
 		return 0;
 	}
 	return 1;
 }
 __setup(&quot;hugepagesz=&quot;, setup_hugepagesz);
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_ARM64_64K_PAGES</span>
<span class="p_add">+static __init int add_default_hugepagesz(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (size_to_hstate(CONT_PTES * PAGE_SIZE) == NULL)</span>
<span class="p_add">+		hugetlb_add_hstate(CONT_PMD_SHIFT);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(add_default_hugepagesz);</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index 685c262..b0eb064 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -96,9 +96,7 @@</span> <span class="p_context"> u32 hugetlb_fault_mutex_hash(struct hstate *h, struct mm_struct *mm,</span>
 				struct address_space *mapping,
 				pgoff_t idx, unsigned long address);
 
<span class="p_del">-#ifdef CONFIG_ARCH_WANT_HUGE_PMD_SHARE</span>
 pte_t *huge_pmd_share(struct mm_struct *mm, unsigned long addr, pud_t *pud);
<span class="p_del">-#endif</span>
 
 extern int hugepages_treat_as_movable;
 extern int sysctl_hugetlb_shm_group;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



