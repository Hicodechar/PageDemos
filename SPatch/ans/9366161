
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.24 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.24</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 7, 2016, 2:35 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161007143541.GB26504@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9366161/mbox/"
   >mbox</a>
|
   <a href="/patch/9366161/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9366161/">/patch/9366161/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D300E6075E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Oct 2016 14:36:06 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BC67C29658
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Oct 2016 14:36:06 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id B07B32965C; Fri,  7 Oct 2016 14:36:06 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 331092965B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  7 Oct 2016 14:36:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756704AbcJGOfx (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 7 Oct 2016 10:35:53 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:57954 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752930AbcJGOfe (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 7 Oct 2016 10:35:34 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 0442994D;
	Fri,  7 Oct 2016 14:35:32 +0000 (UTC)
Date: Fri, 7 Oct 2016 16:35:41 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.24
Message-ID: &lt;20161007143541.GB26504@kroah.com&gt;
References: &lt;20161007143534.GA26504@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161007143534.GA26504@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 7, 2016, 2:35 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt b/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt</span>
<span class="p_header">index d00bfd8624a5..e0381c28773d 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/regulator/qcom,spmi-regulator.txt</span>
<span class="p_chunk">@@ -81,9 +81,9 @@</span> <span class="p_context"> pm8916:</span>
 	l14, l15, l16, l17, l18
 
 pm8941:
<span class="p_del">-	s1, s2, s3, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13, l14,</span>
<span class="p_del">-	l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, lvs1, lvs2, lvs3,</span>
<span class="p_del">-	mvs1, mvs2</span>
<span class="p_add">+	s1, s2, s3, s4, l1, l2, l3, l4, l5, l6, l7, l8, l9, l10, l11, l12, l13,</span>
<span class="p_add">+	l14, l15, l16, l17, l18, l19, l20, l21, l22, l23, l24, lvs1, lvs2, lvs3,</span>
<span class="p_add">+	5vs1, 5vs2</span>
 
 The content of each sub-node is defined by the standard binding for regulators -
 see regulator.txt - with additional custom properties described below:
<span class="p_header">diff --git a/Documentation/pinctrl.txt b/Documentation/pinctrl.txt</span>
<span class="p_header">index 4976389e432d..dd15a699ee1c 100644</span>
<span class="p_header">--- a/Documentation/pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/pinctrl.txt</span>
<span class="p_chunk">@@ -831,7 +831,7 @@</span> <span class="p_context"> separate memory range only intended for GPIO driving, and the register</span>
 range dealing with pin config and pin multiplexing get placed into a
 different memory range and a separate section of the data sheet.
 
<span class="p_del">-A flag &quot;strict&quot; in struct pinctrl_desc is available to check and deny</span>
<span class="p_add">+A flag &quot;strict&quot; in struct pinmux_ops is available to check and deny</span>
 simultaneous access to the same pin from GPIO and pin multiplexing
 consumers on hardware of this type. The pinctrl driver should set this flag
 accordingly.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 95421b688f23..cdbc185c3539 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 23</span>
<span class="p_add">+SUBLEVEL = 24</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/compressed/head.S b/arch/arm/boot/compressed/head.S</span>
<span class="p_header">index 06e983f59980..856913705169 100644</span>
<span class="p_header">--- a/arch/arm/boot/compressed/head.S</span>
<span class="p_header">+++ b/arch/arm/boot/compressed/head.S</span>
<span class="p_chunk">@@ -776,7 +776,7 @@</span> <span class="p_context"> __armv7_mmu_cache_on:</span>
 		orrne	r0, r0, #1		@ MMU enabled
 		movne	r1, #0xfffffffd		@ domain 0 = client
 		bic     r6, r6, #1 &lt;&lt; 31        @ 32-bit translation system
<span class="p_del">-		bic     r6, r6, #3 &lt;&lt; 0         @ use only ttbr0</span>
<span class="p_add">+		bic     r6, r6, #(7 &lt;&lt; 0) | (1 &lt;&lt; 4)	@ use only ttbr0</span>
 		mcrne	p15, 0, r3, c2, c0, 0	@ load page table pointer
 		mcrne	p15, 0, r1, c3, c0, 0	@ load domain access control
 		mcrne   p15, 0, r6, c2, c0, 2   @ load ttb control
<span class="p_header">diff --git a/arch/arm/boot/dts/sun5i-a13.dtsi b/arch/arm/boot/dts/sun5i-a13.dtsi</span>
<span class="p_header">index d910d3a6c41c..84bdba480d5a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun5i-a13.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun5i-a13.dtsi</span>
<span class="p_chunk">@@ -83,7 +83,7 @@</span> <span class="p_context"></span>
 			trips {
 				cpu_alert0: cpu_alert0 {
 					/* milliCelsius */
<span class="p_del">-					temperature = &lt;850000&gt;;</span>
<span class="p_add">+					temperature = &lt;85000&gt;;</span>
 					hysteresis = &lt;2000&gt;;
 					type = &quot;passive&quot;;
 				};
<span class="p_header">diff --git a/arch/arm/common/sa1111.c b/arch/arm/common/sa1111.c</span>
<span class="p_header">index 3d224941b541..a3a9ad4dc3c6 100644</span>
<span class="p_header">--- a/arch/arm/common/sa1111.c</span>
<span class="p_header">+++ b/arch/arm/common/sa1111.c</span>
<span class="p_chunk">@@ -869,9 +869,9 @@</span> <span class="p_context"> struct sa1111_save_data {</span>
 
 #ifdef CONFIG_PM
 
<span class="p_del">-static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
<span class="p_add">+static int sa1111_suspend_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags;
 	unsigned int val;
<span class="p_chunk">@@ -934,9 +934,9 @@</span> <span class="p_context"> static int sa1111_suspend(struct platform_device *dev, pm_message_t state)</span>
  *	restored by their respective drivers, and must be called
  *	via LDM after this function.
  */
<span class="p_del">-static int sa1111_resume(struct platform_device *dev)</span>
<span class="p_add">+static int sa1111_resume_noirq(struct device *dev)</span>
 {
<span class="p_del">-	struct sa1111 *sachip = platform_get_drvdata(dev);</span>
<span class="p_add">+	struct sa1111 *sachip = dev_get_drvdata(dev);</span>
 	struct sa1111_save_data *save;
 	unsigned long flags, id;
 	void __iomem *base;
<span class="p_chunk">@@ -952,7 +952,7 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 	id = sa1111_readl(sachip-&gt;base + SA1111_SKID);
 	if ((id &amp; SKID_ID_MASK) != SKID_SA1111_ID) {
 		__sa1111_remove(sachip);
<span class="p_del">-		platform_set_drvdata(dev, NULL);</span>
<span class="p_add">+		dev_set_drvdata(dev, NULL);</span>
 		kfree(save);
 		return 0;
 	}
<span class="p_chunk">@@ -1003,8 +1003,8 @@</span> <span class="p_context"> static int sa1111_resume(struct platform_device *dev)</span>
 }
 
 #else
<span class="p_del">-#define sa1111_suspend NULL</span>
<span class="p_del">-#define sa1111_resume  NULL</span>
<span class="p_add">+#define sa1111_suspend_noirq NULL</span>
<span class="p_add">+#define sa1111_resume_noirq  NULL</span>
 #endif
 
 static int sa1111_probe(struct platform_device *pdev)
<span class="p_chunk">@@ -1038,6 +1038,11 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 	return 0;
 }
 
<span class="p_add">+static struct dev_pm_ops sa1111_pm_ops = {</span>
<span class="p_add">+	.suspend_noirq = sa1111_suspend_noirq,</span>
<span class="p_add">+	.resume_noirq = sa1111_resume_noirq,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  *	Not sure if this should be on the system bus or not yet.
  *	We really want some way to register a system device at
<span class="p_chunk">@@ -1050,10 +1055,9 @@</span> <span class="p_context"> static int sa1111_remove(struct platform_device *pdev)</span>
 static struct platform_driver sa1111_device_driver = {
 	.probe		= sa1111_probe,
 	.remove		= sa1111_remove,
<span class="p_del">-	.suspend	= sa1111_suspend,</span>
<span class="p_del">-	.resume		= sa1111_resume,</span>
 	.driver		= {
 		.name	= &quot;sa1111&quot;,
<span class="p_add">+		.pm	= &amp;sa1111_pm_ops,</span>
 	},
 };
 
<span class="p_header">diff --git a/arch/arm/include/asm/dma-mapping.h b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">index ccb3aa64640d..b91a2d17a521 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"> static inline dma_addr_t virt_to_dma(struct device *dev, void *addr)</span>
 /* The ARM override for dma_max_pfn() */
 static inline unsigned long dma_max_pfn(struct device *dev)
 {
<span class="p_del">-	return PHYS_PFN_OFFSET + dma_to_pfn(dev, *dev-&gt;dma_mask);</span>
<span class="p_add">+	return dma_to_pfn(dev, *dev-&gt;dma_mask);</span>
 }
 #define dma_max_pfn(dev) dma_max_pfn(dev)
 
<span class="p_header">diff --git a/arch/arm/kernel/devtree.c b/arch/arm/kernel/devtree.c</span>
<span class="p_header">index 65addcbf5b30..b3b950fc8ea0 100644</span>
<span class="p_header">--- a/arch/arm/kernel/devtree.c</span>
<span class="p_header">+++ b/arch/arm/kernel/devtree.c</span>
<span class="p_chunk">@@ -87,6 +87,8 @@</span> <span class="p_context"> void __init arm_dt_init_cpu_maps(void)</span>
 		return;
 
 	for_each_child_of_node(cpus, cpu) {
<span class="p_add">+		const __be32 *cell;</span>
<span class="p_add">+		int prop_bytes;</span>
 		u32 hwid;
 
 		if (of_node_cmp(cpu-&gt;type, &quot;cpu&quot;))
<span class="p_chunk">@@ -98,7 +100,8 @@</span> <span class="p_context"> void __init arm_dt_init_cpu_maps(void)</span>
 		 * properties is considered invalid to build the
 		 * cpu_logical_map.
 		 */
<span class="p_del">-		if (of_property_read_u32(cpu, &quot;reg&quot;, &amp;hwid)) {</span>
<span class="p_add">+		cell = of_get_property(cpu, &quot;reg&quot;, &amp;prop_bytes);</span>
<span class="p_add">+		if (!cell || prop_bytes &lt; sizeof(*cell)) {</span>
 			pr_debug(&quot; * %s missing reg property\n&quot;,
 				     cpu-&gt;full_name);
 			of_node_put(cpu);
<span class="p_chunk">@@ -106,10 +109,15 @@</span> <span class="p_context"> void __init arm_dt_init_cpu_maps(void)</span>
 		}
 
 		/*
<span class="p_del">-		 * 8 MSBs must be set to 0 in the DT since the reg property</span>
<span class="p_add">+		 * Bits n:24 must be set to 0 in the DT since the reg property</span>
 		 * defines the MPIDR[23:0].
 		 */
<span class="p_del">-		if (hwid &amp; ~MPIDR_HWID_BITMASK) {</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			hwid = be32_to_cpu(*cell++);</span>
<span class="p_add">+			prop_bytes -= sizeof(*cell);</span>
<span class="p_add">+		} while (!hwid &amp;&amp; prop_bytes &gt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (prop_bytes || (hwid &amp; ~MPIDR_HWID_BITMASK)) {</span>
 			of_node_put(cpu);
 			return;
 		}
<span class="p_header">diff --git a/arch/arm/mach-sa1100/clock.c b/arch/arm/mach-sa1100/clock.c</span>
<span class="p_header">index cbf53bb9c814..0db46895c82a 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/clock.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/clock.c</span>
<span class="p_chunk">@@ -125,6 +125,8 @@</span> <span class="p_context"> static unsigned long clk_36864_get_rate(struct clk *clk)</span>
 }
 
 static struct clkops clk_36864_ops = {
<span class="p_add">+	.enable		= clk_cpu_enable,</span>
<span class="p_add">+	.disable	= clk_cpu_disable,</span>
 	.get_rate	= clk_36864_get_rate,
 };
 
<span class="p_chunk">@@ -140,9 +142,8 @@</span> <span class="p_context"> static struct clk_lookup sa11xx_clkregs[] = {</span>
 	CLKDEV_INIT(NULL, &quot;OSTIMER0&quot;, &amp;clk_36864),
 };
 
<span class="p_del">-static int __init sa11xx_clk_init(void)</span>
<span class="p_add">+int __init sa11xx_clk_init(void)</span>
 {
 	clkdev_add_table(sa11xx_clkregs, ARRAY_SIZE(sa11xx_clkregs));
 	return 0;
 }
<span class="p_del">-core_initcall(sa11xx_clk_init);</span>
<span class="p_header">diff --git a/arch/arm/mach-sa1100/generic.c b/arch/arm/mach-sa1100/generic.c</span>
<span class="p_header">index 345e63f4eb71..3e09beddb6e8 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/generic.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/generic.c</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"></span>
 
 #include &lt;mach/hardware.h&gt;
 #include &lt;mach/irqs.h&gt;
<span class="p_add">+#include &lt;mach/reset.h&gt;</span>
 
 #include &quot;generic.h&quot;
 #include &lt;clocksource/pxa.h&gt;
<span class="p_chunk">@@ -95,6 +96,8 @@</span> <span class="p_context"> static void sa1100_power_off(void)</span>
 
 void sa11x0_restart(enum reboot_mode mode, const char *cmd)
 {
<span class="p_add">+	clear_reset_status(RESET_STATUS_ALL);</span>
<span class="p_add">+</span>
 	if (mode == REBOOT_SOFT) {
 		/* Jump into ROM at address 0 */
 		soft_restart(0);
<span class="p_chunk">@@ -388,6 +391,7 @@</span> <span class="p_context"> void __init sa1100_init_irq(void)</span>
 	sa11x0_init_irq_nodt(IRQ_GPIO0_SC, irq_resource.start);
 
 	sa1100_init_gpio();
<span class="p_add">+	sa11xx_clk_init();</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/arm/mach-sa1100/generic.h b/arch/arm/mach-sa1100/generic.h</span>
<span class="p_header">index 0d92e119b36b..68199b603ff7 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/generic.h</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/generic.h</span>
<span class="p_chunk">@@ -44,3 +44,5 @@</span> <span class="p_context"> int sa11x0_pm_init(void);</span>
 #else
 static inline int sa11x0_pm_init(void) { return 0; }
 #endif
<span class="p_add">+</span>
<span class="p_add">+int sa11xx_clk_init(void);</span>
<span class="p_header">diff --git a/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c b/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c</span>
<span class="p_header">index 62437b57813e..73e3adbc1330 100644</span>
<span class="p_header">--- a/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c</span>
<span class="p_header">+++ b/arch/arm/mach-shmobile/regulator-quirk-rcar-gen2.c</span>
<span class="p_chunk">@@ -41,39 +41,26 @@</span> <span class="p_context"></span>
 
 #define REGULATOR_IRQ_MASK	BIT(2)	/* IRQ2, active low */
 
<span class="p_del">-static void __iomem *irqc;</span>
<span class="p_del">-</span>
<span class="p_del">-static const u8 da9063_mask_regs[] = {</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_A,</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_B,</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_C,</span>
<span class="p_del">-	DA9063_REG_IRQ_MASK_D,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* DA9210 System Control and Event Registers */</span>
<span class="p_add">+/* start of DA9210 System Control and Event Registers */</span>
 #define DA9210_REG_MASK_A		0x54
<span class="p_del">-#define DA9210_REG_MASK_B		0x55</span>
<span class="p_del">-</span>
<span class="p_del">-static const u8 da9210_mask_regs[] = {</span>
<span class="p_del">-	DA9210_REG_MASK_A,</span>
<span class="p_del">-	DA9210_REG_MASK_B,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void da9xxx_mask_irqs(struct i2c_client *client, const u8 regs[],</span>
<span class="p_del">-			     unsigned int nregs)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int i;</span>
 
<span class="p_del">-	dev_info(&amp;client-&gt;dev, &quot;Masking %s interrupt sources\n&quot;, client-&gt;name);</span>
<span class="p_add">+static void __iomem *irqc;</span>
 
<span class="p_del">-	for (i = 0; i &lt; nregs; i++) {</span>
<span class="p_del">-		int error = i2c_smbus_write_byte_data(client, regs[i], ~0);</span>
<span class="p_del">-		if (error) {</span>
<span class="p_del">-			dev_err(&amp;client-&gt;dev, &quot;i2c error %d\n&quot;, error);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_add">+/* first byte sets the memory pointer, following are consecutive reg values */</span>
<span class="p_add">+static u8 da9063_irq_clr[] = { DA9063_REG_IRQ_MASK_A, 0xff, 0xff, 0xff, 0xff };</span>
<span class="p_add">+static u8 da9210_irq_clr[] = { DA9210_REG_MASK_A, 0xff, 0xff };</span>
<span class="p_add">+</span>
<span class="p_add">+static struct i2c_msg da9xxx_msgs[2] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = 0x58,</span>
<span class="p_add">+		.len = ARRAY_SIZE(da9063_irq_clr),</span>
<span class="p_add">+		.buf = da9063_irq_clr,</span>
<span class="p_add">+	}, {</span>
<span class="p_add">+		.addr = 0x68,</span>
<span class="p_add">+		.len = ARRAY_SIZE(da9210_irq_clr),</span>
<span class="p_add">+		.buf = da9210_irq_clr,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
 
 static int regulator_quirk_notify(struct notifier_block *nb,
 				  unsigned long action, void *data)
<span class="p_chunk">@@ -93,12 +80,15 @@</span> <span class="p_context"> static int regulator_quirk_notify(struct notifier_block *nb,</span>
 	client = to_i2c_client(dev);
 	dev_dbg(dev, &quot;Detected %s\n&quot;, client-&gt;name);
 
<span class="p_del">-	if ((client-&gt;addr == 0x58 &amp;&amp; !strcmp(client-&gt;name, &quot;da9063&quot;)))</span>
<span class="p_del">-		da9xxx_mask_irqs(client, da9063_mask_regs,</span>
<span class="p_del">-				 ARRAY_SIZE(da9063_mask_regs));</span>
<span class="p_del">-	else if (client-&gt;addr == 0x68 &amp;&amp; !strcmp(client-&gt;name, &quot;da9210&quot;))</span>
<span class="p_del">-		da9xxx_mask_irqs(client, da9210_mask_regs,</span>
<span class="p_del">-				 ARRAY_SIZE(da9210_mask_regs));</span>
<span class="p_add">+	if ((client-&gt;addr == 0x58 &amp;&amp; !strcmp(client-&gt;name, &quot;da9063&quot;)) ||</span>
<span class="p_add">+	    (client-&gt;addr == 0x68 &amp;&amp; !strcmp(client-&gt;name, &quot;da9210&quot;))) {</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_info(&amp;client-&gt;dev, &quot;clearing da9063/da9210 interrupts\n&quot;);</span>
<span class="p_add">+		ret = i2c_transfer(client-&gt;adapter, da9xxx_msgs, ARRAY_SIZE(da9xxx_msgs));</span>
<span class="p_add">+		if (ret != ARRAY_SIZE(da9xxx_msgs))</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;i2c error %d\n&quot;, ret);</span>
<span class="p_add">+	}</span>
 
 	mon = ioread32(irqc + IRQC_MONITOR);
 	if (mon &amp; REGULATOR_IRQ_MASK)
<span class="p_header">diff --git a/arch/arm64/kernel/debug-monitors.c b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">index e51f27ac13fd..c8875b64be90 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_chunk">@@ -422,8 +422,10 @@</span> <span class="p_context"> int kernel_active_single_step(void)</span>
 /* ptrace API */
 void user_enable_single_step(struct task_struct *task)
 {
<span class="p_del">-	set_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP);</span>
<span class="p_del">-	set_regs_spsr_ss(task_pt_regs(task));</span>
<span class="p_add">+	struct thread_info *ti = task_thread_info(task);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!test_and_set_ti_thread_flag(ti, TIF_SINGLESTEP))</span>
<span class="p_add">+		set_regs_spsr_ss(task_pt_regs(task));</span>
 }
 
 void user_disable_single_step(struct task_struct *task)
<span class="p_header">diff --git a/arch/avr32/mach-at32ap/pio.c b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">index 4f61378c3453..456128174b17 100644</span>
<span class="p_header">--- a/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_header">+++ b/arch/avr32/mach-at32ap/pio.c</span>
<span class="p_chunk">@@ -435,7 +435,7 @@</span> <span class="p_context"> void __init at32_init_pio(struct platform_device *pdev)</span>
 	struct resource *regs;
 	struct pio_device *pio;
 
<span class="p_del">-	if (pdev-&gt;id &gt; MAX_NR_PIO_DEVICES) {</span>
<span class="p_add">+	if (pdev-&gt;id &gt;= MAX_NR_PIO_DEVICES) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;only %d PIO devices supported\n&quot;,
 			MAX_NR_PIO_DEVICES);
 		return;
<span class="p_header">diff --git a/arch/mips/include/asm/uprobes.h b/arch/mips/include/asm/uprobes.h</span>
<span class="p_header">index 34c325c674c4..70a4a2f173ff 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/uprobes.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/uprobes.h</span>
<span class="p_chunk">@@ -36,7 +36,6 @@</span> <span class="p_context"> struct arch_uprobe {</span>
 	unsigned long	resume_epc;
 	u32	insn[2];
 	u32	ixol[2];
<span class="p_del">-	union	mips_instruction orig_inst[MAX_UINSN_BYTES / 4];</span>
 };
 
 struct arch_uprobe_task {
<span class="p_header">diff --git a/arch/mips/kernel/uprobes.c b/arch/mips/kernel/uprobes.c</span>
<span class="p_header">index 8452d933a645..4e7b89f2e244 100644</span>
<span class="p_header">--- a/arch/mips/kernel/uprobes.c</span>
<span class="p_header">+++ b/arch/mips/kernel/uprobes.c</span>
<span class="p_chunk">@@ -157,7 +157,6 @@</span> <span class="p_context"> bool is_trap_insn(uprobe_opcode_t *insn)</span>
 int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs)
 {
 	struct uprobe_task *utask = current-&gt;utask;
<span class="p_del">-	union mips_instruction insn;</span>
 
 	/*
 	 * Now find the EPC where to resume after the breakpoint has been
<span class="p_chunk">@@ -168,10 +167,10 @@</span> <span class="p_context"> int arch_uprobe_pre_xol(struct arch_uprobe *aup, struct pt_regs *regs)</span>
 		unsigned long epc;
 
 		epc = regs-&gt;cp0_epc;
<span class="p_del">-		__compute_return_epc_for_insn(regs, insn);</span>
<span class="p_add">+		__compute_return_epc_for_insn(regs,</span>
<span class="p_add">+			(union mips_instruction) aup-&gt;insn[0]);</span>
 		aup-&gt;resume_epc = regs-&gt;cp0_epc;
 	}
<span class="p_del">-</span>
 	utask-&gt;autask.saved_trap_nr = current-&gt;thread.trap_nr;
 	current-&gt;thread.trap_nr = UPROBE_TRAP_NR;
 	regs-&gt;cp0_epc = current-&gt;utask-&gt;xol_vaddr;
<span class="p_chunk">@@ -257,7 +256,7 @@</span> <span class="p_context"> unsigned long arch_uretprobe_hijack_return_addr(</span>
 	ra = regs-&gt;regs[31];
 
 	/* Replace the return address with the trampoline address */
<span class="p_del">-	regs-&gt;regs[31] = ra;</span>
<span class="p_add">+	regs-&gt;regs[31] = trampoline_vaddr;</span>
 
 	return ra;
 }
<span class="p_chunk">@@ -280,24 +279,6 @@</span> <span class="p_context"> int __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm,</span>
 	return uprobe_write_opcode(mm, vaddr, UPROBE_SWBP_INSN);
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * set_orig_insn - Restore the original instruction.</span>
<span class="p_del">- * @mm: the probed process address space.</span>
<span class="p_del">- * @auprobe: arch specific probepoint information.</span>
<span class="p_del">- * @vaddr: the virtual address to insert the opcode.</span>
<span class="p_del">- *</span>
<span class="p_del">- * For mm @mm, restore the original opcode (opcode) at @vaddr.</span>
<span class="p_del">- * Return 0 (success) or a negative errno.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This overrides the weak version in kernel/events/uprobes.c.</span>
<span class="p_del">- */</span>
<span class="p_del">-int set_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm,</span>
<span class="p_del">-		 unsigned long vaddr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return uprobe_write_opcode(mm, vaddr,</span>
<span class="p_del">-			*(uprobe_opcode_t *)&amp;auprobe-&gt;orig_inst[0].word);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void __weak arch_uprobe_copy_ixol(struct page *page, unsigned long vaddr,
 				  void *src, unsigned long len)
 {
<span class="p_header">diff --git a/arch/mips/mti-malta/malta-setup.c b/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_header">index 4740c82fb97a..36b09b2ea972 100644</span>
<span class="p_header">--- a/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_header">+++ b/arch/mips/mti-malta/malta-setup.c</span>
<span class="p_chunk">@@ -39,6 +39,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/console.h&gt;
 #endif
 
<span class="p_add">+#define ROCIT_CONFIG_GEN0		0x1f403000</span>
<span class="p_add">+#define  ROCIT_CONFIG_GEN0_PCI_IOCU	BIT(7)</span>
<span class="p_add">+</span>
 extern void malta_be_init(void);
 extern int malta_be_handler(struct pt_regs *regs, int is_fixup);
 
<span class="p_chunk">@@ -107,6 +110,8 @@</span> <span class="p_context"> static void __init fd_activate(void)</span>
 static int __init plat_enable_iocoherency(void)
 {
 	int supported = 0;
<span class="p_add">+	u32 cfg;</span>
<span class="p_add">+</span>
 	if (mips_revision_sconid == MIPS_REVISION_SCON_BONITO) {
 		if (BONITO_PCICACHECTRL &amp; BONITO_PCICACHECTRL_CPUCOH_PRES) {
 			BONITO_PCICACHECTRL |= BONITO_PCICACHECTRL_CPUCOH_EN;
<span class="p_chunk">@@ -129,7 +134,8 @@</span> <span class="p_context"> static int __init plat_enable_iocoherency(void)</span>
 	} else if (mips_cm_numiocu() != 0) {
 		/* Nothing special needs to be done to enable coherency */
 		pr_info(&quot;CMP IOCU detected\n&quot;);
<span class="p_del">-		if ((*(unsigned int *)0xbf403000 &amp; 0x81) != 0x81) {</span>
<span class="p_add">+		cfg = __raw_readl((u32 *)CKSEG1ADDR(ROCIT_CONFIG_GEN0));</span>
<span class="p_add">+		if (!(cfg &amp; ROCIT_CONFIG_GEN0_PCI_IOCU)) {</span>
 			pr_crit(&quot;IOCU OPERATION DISABLED BY SWITCH - DEFAULTING TO SW IO COHERENCY\n&quot;);
 			return 0;
 		}
<span class="p_header">diff --git a/arch/powerpc/kernel/prom_init.c b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">index b7e86e00048f..7b89e7b305e6 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_chunk">@@ -694,7 +694,7 @@</span> <span class="p_context"> unsigned char ibm_architecture_vec[] = {</span>
 	OV4_MIN_ENT_CAP,		/* minimum VP entitled capacity */
 
 	/* option vector 5: PAPR/OF options */
<span class="p_del">-	VECTOR_LENGTH(18),		/* length */</span>
<span class="p_add">+	VECTOR_LENGTH(21),		/* length */</span>
 	0,				/* don&#39;t ignore, don&#39;t halt */
 	OV5_FEAT(OV5_LPAR) | OV5_FEAT(OV5_SPLPAR) | OV5_FEAT(OV5_LARGE_PAGES) |
 	OV5_FEAT(OV5_DRCONF_MEMORY) | OV5_FEAT(OV5_DONATE_DEDICATE_CPU) |
<span class="p_chunk">@@ -725,8 +725,11 @@</span> <span class="p_context"> unsigned char ibm_architecture_vec[] = {</span>
 	0,
 	0,
 	OV5_FEAT(OV5_PFO_HW_RNG) | OV5_FEAT(OV5_PFO_HW_ENCR) |
<span class="p_del">-	OV5_FEAT(OV5_PFO_HW_842),</span>
<span class="p_del">-	OV5_FEAT(OV5_SUB_PROCESSORS),</span>
<span class="p_add">+	OV5_FEAT(OV5_PFO_HW_842),				/* Byte 17 */</span>
<span class="p_add">+	0,							/* Byte 18 */</span>
<span class="p_add">+	0,							/* Byte 19 */</span>
<span class="p_add">+	0,							/* Byte 20 */</span>
<span class="p_add">+	OV5_FEAT(OV5_SUB_PROCESSORS),				/* Byte 21 */</span>
 
 	/* option vector 6: IBM PAPR hints */
 	VECTOR_LENGTH(3),		/* length */
<span class="p_header">diff --git a/arch/tile/include/asm/elf.h b/arch/tile/include/asm/elf.h</span>
<span class="p_header">index c505d77e4d06..e9d54a06736f 100644</span>
<span class="p_header">--- a/arch/tile/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/tile/include/asm/elf.h</span>
<span class="p_chunk">@@ -129,6 +129,7 @@</span> <span class="p_context"> extern int dump_task_regs(struct task_struct *, elf_gregset_t *);</span>
 struct linux_binprm;
 extern int arch_setup_additional_pages(struct linux_binprm *bprm,
 				       int executable_stack);
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO \
 do { \
 	NEW_AUX_ENT(AT_SYSINFO_EHDR, VDSO_BASE); \
<span class="p_header">diff --git a/arch/tile/include/uapi/asm/auxvec.h b/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_header">index c93e92709f14..f497123ed980 100644</span>
<span class="p_header">--- a/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/tile/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -18,4 +18,6 @@</span> <span class="p_context"></span>
 /* The vDSO location. */
 #define AT_SYSINFO_EHDR         33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif /* _ASM_TILE_AUXVEC_H */
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 3142218e546f..6433e28dc9c8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"> DECLARE_PER_CPU_SHARED_ALIGNED(struct tlb_state, cpu_tlbstate);</span>
 /* Initialize cr4 shadow for this CPU. */
 static inline void cr4_init_shadow(void)
 {
<span class="p_del">-	this_cpu_write(cpu_tlbstate.cr4, __read_cr4());</span>
<span class="p_add">+	this_cpu_write(cpu_tlbstate.cr4, __read_cr4_safe());</span>
 }
 
 /* Set in this cpu&#39;s CR4. */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index c2b7522cbf35..2b49b113d65d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -737,21 +737,20 @@</span> <span class="p_context"> static void __init early_identify_cpu(struct cpuinfo_x86 *c)</span>
 		identify_cpu_without_cpuid(c);
 
 	/* cyrix could have cpuid enabled via c_identify()*/
<span class="p_del">-	if (!have_cpuid_p())</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	if (have_cpuid_p()) {</span>
<span class="p_add">+		cpu_detect(c);</span>
<span class="p_add">+		get_cpu_vendor(c);</span>
<span class="p_add">+		get_cpu_cap(c);</span>
 
<span class="p_del">-	cpu_detect(c);</span>
<span class="p_del">-	get_cpu_vendor(c);</span>
<span class="p_del">-	get_cpu_cap(c);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (this_cpu-&gt;c_early_init)</span>
<span class="p_del">-		this_cpu-&gt;c_early_init(c);</span>
<span class="p_add">+		if (this_cpu-&gt;c_early_init)</span>
<span class="p_add">+			this_cpu-&gt;c_early_init(c);</span>
 
<span class="p_del">-	c-&gt;cpu_index = 0;</span>
<span class="p_del">-	filter_cpuid_features(c, false);</span>
<span class="p_add">+		c-&gt;cpu_index = 0;</span>
<span class="p_add">+		filter_cpuid_features(c, false);</span>
 
<span class="p_del">-	if (this_cpu-&gt;c_bsp_init)</span>
<span class="p_del">-		this_cpu-&gt;c_bsp_init(c);</span>
<span class="p_add">+		if (this_cpu-&gt;c_bsp_init)</span>
<span class="p_add">+			this_cpu-&gt;c_bsp_init(c);</span>
<span class="p_add">+	}</span>
 
 	setup_force_cpu_cap(X86_FEATURE_ALWAYS);
 	fpu__init_system(c);
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 4589b6feeb7b..268df707b5ce 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -408,6 +408,7 @@</span> <span class="p_context"> struct nested_vmx {</span>
 	struct list_head vmcs02_pool;
 	int vmcs02_num;
 	u64 vmcs01_tsc_offset;
<span class="p_add">+	bool change_vmcs01_virtual_x2apic_mode;</span>
 	/* L2 must run next, and mustn&#39;t decide to exit to L1. */
 	bool nested_run_pending;
 	/*
<span class="p_chunk">@@ -8184,6 +8185,12 @@</span> <span class="p_context"> static void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)</span>
 {
 	u32 sec_exec_control;
 
<span class="p_add">+	/* Postpone execution until vmcs01 is the current VMCS. */</span>
<span class="p_add">+	if (is_guest_mode(vcpu)) {</span>
<span class="p_add">+		to_vmx(vcpu)-&gt;nested.change_vmcs01_virtual_x2apic_mode = true;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * There is not point to enable virtualize x2apic without enable
 	 * apicv
<span class="p_chunk">@@ -10483,6 +10490,12 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
 	/* Update TSC_OFFSET if TSC was changed while L2 ran */
 	vmcs_write64(TSC_OFFSET, vmx-&gt;nested.vmcs01_tsc_offset);
 
<span class="p_add">+	if (vmx-&gt;nested.change_vmcs01_virtual_x2apic_mode) {</span>
<span class="p_add">+		vmx-&gt;nested.change_vmcs01_virtual_x2apic_mode = false;</span>
<span class="p_add">+		vmx_set_virtual_x2apic_mode(vcpu,</span>
<span class="p_add">+				vcpu-&gt;arch.apic_base &amp; X2APIC_ENABLE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* This is needed for same reason as it was needed in prepare_vmcs02 */
 	vmx-&gt;host_rsp = 0;
 
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 839b1e17481b..c3e461ec40e4 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -780,7 +780,7 @@</span> <span class="p_context"> static void __blk_mq_run_hw_queue(struct blk_mq_hw_ctx *hctx)</span>
 		switch (ret) {
 		case BLK_MQ_RQ_QUEUE_OK:
 			queued++;
<span class="p_del">-			continue;</span>
<span class="p_add">+			break;</span>
 		case BLK_MQ_RQ_QUEUE_BUSY:
 			list_add(&amp;rq-&gt;queuelist, &amp;rq_list);
 			__blk_mq_requeue_request(rq);
<span class="p_header">diff --git a/drivers/acpi/acpica/hwxface.c b/drivers/acpi/acpica/hwxface.c</span>
<span class="p_header">index 5f97468df8ff..b2e50d8007fe 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/hwxface.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/hwxface.c</span>
<span class="p_chunk">@@ -504,11 +504,20 @@</span> <span class="p_context"> acpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)</span>
 	 * Evaluate the \_Sx namespace object containing the register values
 	 * for this state
 	 */
<span class="p_del">-	info-&gt;relative_pathname =</span>
<span class="p_del">-	    ACPI_CAST_PTR(char, acpi_gbl_sleep_state_names[sleep_state]);</span>
<span class="p_add">+	info-&gt;relative_pathname = ACPI_CAST_PTR(char,</span>
<span class="p_add">+						acpi_gbl_sleep_state_names</span>
<span class="p_add">+						[sleep_state]);</span>
<span class="p_add">+</span>
 	status = acpi_ns_evaluate(info);
 	if (ACPI_FAILURE(status)) {
<span class="p_del">-		goto cleanup;</span>
<span class="p_add">+		if (status == AE_NOT_FOUND) {</span>
<span class="p_add">+</span>
<span class="p_add">+			/* The _Sx states are optional, ignore NOT_FOUND */</span>
<span class="p_add">+</span>
<span class="p_add">+			goto final_cleanup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		goto warning_cleanup;</span>
 	}
 
 	/* Must have a return object */
<span class="p_chunk">@@ -517,7 +526,7 @@</span> <span class="p_context"> acpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)</span>
 		ACPI_ERROR((AE_INFO, &quot;No Sleep State object returned from [%s]&quot;,
 			    info-&gt;relative_pathname));
 		status = AE_AML_NO_RETURN_VALUE;
<span class="p_del">-		goto cleanup;</span>
<span class="p_add">+		goto warning_cleanup;</span>
 	}
 
 	/* Return object must be of type Package */
<span class="p_chunk">@@ -526,7 +535,7 @@</span> <span class="p_context"> acpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)</span>
 		ACPI_ERROR((AE_INFO,
 			    &quot;Sleep State return object is not a Package&quot;));
 		status = AE_AML_OPERAND_TYPE;
<span class="p_del">-		goto cleanup1;</span>
<span class="p_add">+		goto return_value_cleanup;</span>
 	}
 
 	/*
<span class="p_chunk">@@ -570,16 +579,17 @@</span> <span class="p_context"> acpi_get_sleep_type_data(u8 sleep_state, u8 *sleep_type_a, u8 *sleep_type_b)</span>
 		break;
 	}
 
<span class="p_del">-cleanup1:</span>
<span class="p_add">+return_value_cleanup:</span>
 	acpi_ut_remove_reference(info-&gt;return_object);
 
<span class="p_del">-cleanup:</span>
<span class="p_add">+warning_cleanup:</span>
 	if (ACPI_FAILURE(status)) {
 		ACPI_EXCEPTION((AE_INFO, status,
 				&quot;While evaluating Sleep State [%s]&quot;,
 				info-&gt;relative_pathname));
 	}
 
<span class="p_add">+final_cleanup:</span>
 	ACPI_FREE(info);
 	return_ACPI_STATUS(status);
 }
<span class="p_header">diff --git a/drivers/char/hw_random/omap-rng.c b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">index 8a1432e8bb80..01d4be2c354b 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_chunk">@@ -384,7 +384,12 @@</span> <span class="p_context"> static int omap_rng_probe(struct platform_device *pdev)</span>
 	}
 
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);</span>
<span class="p_add">+		pm_runtime_put_noidle(&amp;pdev-&gt;dev);</span>
<span class="p_add">+		goto err_ioremap;</span>
<span class="p_add">+	}</span>
 
 	ret = (dev-&gt;of_node) ? of_get_omap_rng_device_details(priv, pdev) :
 				get_omap_rng_device_details(priv);
<span class="p_chunk">@@ -435,8 +440,15 @@</span> <span class="p_context"> static int __maybe_unused omap_rng_suspend(struct device *dev)</span>
 static int __maybe_unused omap_rng_resume(struct device *dev)
 {
 	struct omap_rng_dev *priv = dev_get_drvdata(dev);
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pm_runtime_get_sync(dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);</span>
<span class="p_add">+		pm_runtime_put_noidle(dev);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	pm_runtime_get_sync(dev);</span>
 	priv-&gt;pdata-&gt;init(priv);
 
 	return 0;
<span class="p_header">diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">index c12130485fc1..678af51fb29e 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_chunk">@@ -657,7 +657,7 @@</span> <span class="p_context"> ssize_t tpm2_get_tpm_pt(struct tpm_chip *chip, u32 property_id,  u32 *value,</span>
 
 	rc = tpm_transmit_cmd(chip, &amp;cmd, sizeof(cmd), desc);
 	if (!rc)
<span class="p_del">-		*value = cmd.params.get_tpm_pt_out.value;</span>
<span class="p_add">+		*value = be32_to_cpu(cmd.params.get_tpm_pt_out.value);</span>
 
 	return rc;
 }
<span class="p_header">diff --git a/drivers/clk/clk-xgene.c b/drivers/clk/clk-xgene.c</span>
<span class="p_header">index 10224b01b97c..b134a8b15e2c 100644</span>
<span class="p_header">--- a/drivers/clk/clk-xgene.c</span>
<span class="p_header">+++ b/drivers/clk/clk-xgene.c</span>
<span class="p_chunk">@@ -351,8 +351,8 @@</span> <span class="p_context"> static int xgene_clk_set_rate(struct clk_hw *hw, unsigned long rate,</span>
 		/* Set new divider */
 		data = xgene_clk_read(pclk-&gt;param.divider_reg +
 				pclk-&gt;param.reg_divider_offset);
<span class="p_del">-		data &amp;= ~((1 &lt;&lt; pclk-&gt;param.reg_divider_width) - 1)</span>
<span class="p_del">-				&lt;&lt; pclk-&gt;param.reg_divider_shift;</span>
<span class="p_add">+		data &amp;= ~(((1 &lt;&lt; pclk-&gt;param.reg_divider_width) - 1)</span>
<span class="p_add">+				&lt;&lt; pclk-&gt;param.reg_divider_shift);</span>
 		data |= divider;
 		xgene_clk_write(data, pclk-&gt;param.divider_reg +
 					pclk-&gt;param.reg_divider_offset);
<span class="p_header">diff --git a/drivers/dma/at_xdmac.c b/drivers/dma/at_xdmac.c</span>
<span class="p_header">index e44a1bfb0250..9d05d7dbcfa9 100644</span>
<span class="p_header">--- a/drivers/dma/at_xdmac.c</span>
<span class="p_header">+++ b/drivers/dma/at_xdmac.c</span>
<span class="p_chunk">@@ -1183,8 +1183,8 @@</span> <span class="p_context"> static struct at_xdmac_desc *at_xdmac_memset_create_desc(struct dma_chan *chan,</span>
 	desc-&gt;lld.mbr_cfg = chan_cc;
 
 	dev_dbg(chan2dev(chan),
<span class="p_del">-		&quot;%s: lld: mbr_da=%pad, mbr_ds=%pad, mbr_ubc=0x%08x, mbr_cfg=0x%08x\n&quot;,</span>
<span class="p_del">-		__func__, &amp;desc-&gt;lld.mbr_da, &amp;desc-&gt;lld.mbr_ds, desc-&gt;lld.mbr_ubc,</span>
<span class="p_add">+		&quot;%s: lld: mbr_da=%pad, mbr_ds=0x%08x, mbr_ubc=0x%08x, mbr_cfg=0x%08x\n&quot;,</span>
<span class="p_add">+		__func__, &amp;desc-&gt;lld.mbr_da, desc-&gt;lld.mbr_ds, desc-&gt;lld.mbr_ubc,</span>
 		desc-&gt;lld.mbr_cfg);
 
 	return desc;
<span class="p_chunk">@@ -2055,7 +2055,7 @@</span> <span class="p_context"> err_dma_unregister:</span>
 err_clk_disable:
 	clk_disable_unprepare(atxdmac-&gt;clk);
 err_free_irq:
<span class="p_del">-	free_irq(atxdmac-&gt;irq, atxdmac-&gt;dma.dev);</span>
<span class="p_add">+	free_irq(atxdmac-&gt;irq, atxdmac);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -2071,7 +2071,7 @@</span> <span class="p_context"> static int at_xdmac_remove(struct platform_device *pdev)</span>
 
 	synchronize_irq(atxdmac-&gt;irq);
 
<span class="p_del">-	free_irq(atxdmac-&gt;irq, atxdmac-&gt;dma.dev);</span>
<span class="p_add">+	free_irq(atxdmac-&gt;irq, atxdmac);</span>
 
 	for (i = 0; i &lt; atxdmac-&gt;dma.chancnt; i++) {
 		struct at_xdmac_chan *atchan = &amp;atxdmac-&gt;chan[i];
<span class="p_header">diff --git a/drivers/gpio/gpio-sa1100.c b/drivers/gpio/gpio-sa1100.c</span>
<span class="p_header">index 990fa9023e22..3b6bce0518ab 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-sa1100.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-sa1100.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> static int sa1100_gpio_irqdomain_map(struct irq_domain *d,</span>
 {
 	irq_set_chip_and_handler(irq, &amp;sa1100_gpio_irq_chip,
 				 handle_edge_irq);
<span class="p_del">-	irq_set_noprobe(irq);</span>
<span class="p_add">+	irq_set_probe(irq);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c</span>
<span class="p_header">index bfcc6408a772..b7f4b826febe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/fifo/dmanv04.c</span>
<span class="p_chunk">@@ -36,7 +36,10 @@</span> <span class="p_context"> nv04_fifo_dma_object_dtor(struct nvkm_fifo_chan *base, int cookie)</span>
 {
 	struct nv04_fifo_chan *chan = nv04_fifo_chan(base);
 	struct nvkm_instmem *imem = chan-&gt;fifo-&gt;base.engine.subdev.device-&gt;imem;
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;chan-&gt;fifo-&gt;base.engine.subdev.mutex);</span>
 	nvkm_ramht_remove(imem-&gt;ramht, cookie);
<span class="p_add">+	mutex_unlock(&amp;chan-&gt;fifo-&gt;base.engine.subdev.mutex);</span>
 }
 
 static int
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index caa73de584a5..3aaa07dafc00 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -3015,6 +3015,12 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 	if (rdev-&gt;pdev-&gt;device == 0x6811 &amp;&amp;
 	    rdev-&gt;pdev-&gt;revision == 0x81)
 		max_mclk = 120000;
<span class="p_add">+	/* limit sclk/mclk on Jet parts for stability */</span>
<span class="p_add">+	if (rdev-&gt;pdev-&gt;device == 0x6665 &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;revision == 0xc3) {</span>
<span class="p_add">+		max_sclk = 75000;</span>
<span class="p_add">+		max_mclk = 80000;</span>
<span class="p_add">+	}</span>
 
 	if (rps-&gt;vce_active) {
 		rps-&gt;evclk = rdev-&gt;pm.dpm.vce_states[rdev-&gt;pm.dpm.vce_level].evclk;
<span class="p_header">diff --git a/drivers/hwmon/adt7411.c b/drivers/hwmon/adt7411.c</span>
<span class="p_header">index 827c03703128..a7f886961830 100644</span>
<span class="p_header">--- a/drivers/hwmon/adt7411.c</span>
<span class="p_header">+++ b/drivers/hwmon/adt7411.c</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 
 #define ADT7411_REG_CFG1			0x18
 #define ADT7411_CFG1_START_MONITOR		(1 &lt;&lt; 0)
<span class="p_add">+#define ADT7411_CFG1_RESERVED_BIT3		(1 &lt;&lt; 3)</span>
 
 #define ADT7411_REG_CFG2			0x19
 #define ADT7411_CFG2_DISABLE_AVG		(1 &lt;&lt; 5)
<span class="p_chunk">@@ -296,8 +297,10 @@</span> <span class="p_context"> static int adt7411_probe(struct i2c_client *client,</span>
 	mutex_init(&amp;data-&gt;device_lock);
 	mutex_init(&amp;data-&gt;update_lock);
 
<span class="p_add">+	/* According to the datasheet, we must only write 1 to bit 3 */</span>
 	ret = adt7411_modify_bit(client, ADT7411_REG_CFG1,
<span class="p_del">-				 ADT7411_CFG1_START_MONITOR, 1);</span>
<span class="p_add">+				 ADT7411_CFG1_RESERVED_BIT3</span>
<span class="p_add">+				 | ADT7411_CFG1_START_MONITOR, 1);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_header">diff --git a/drivers/infiniband/core/multicast.c b/drivers/infiniband/core/multicast.c</span>
<span class="p_header">index bb6685fb08c6..6aa648cb5381 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/multicast.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/multicast.c</span>
<span class="p_chunk">@@ -106,7 +106,6 @@</span> <span class="p_context"> struct mcast_group {</span>
 	atomic_t		refcount;
 	enum mcast_group_state	state;
 	struct ib_sa_query	*query;
<span class="p_del">-	int			query_id;</span>
 	u16			pkey_index;
 	u8			leave_state;
 	int			retries;
<span class="p_chunk">@@ -339,11 +338,7 @@</span> <span class="p_context"> static int send_join(struct mcast_group *group, struct mcast_member *member)</span>
 				       member-&gt;multicast.comp_mask,
 				       3000, GFP_KERNEL, join_handler, group,
 				       &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static int send_leave(struct mcast_group *group, u8 leave_state)
<span class="p_chunk">@@ -363,11 +358,7 @@</span> <span class="p_context"> static int send_leave(struct mcast_group *group, u8 leave_state)</span>
 				       IB_SA_MCMEMBER_REC_JOIN_STATE,
 				       3000, GFP_KERNEL, leave_handler,
 				       group, &amp;group-&gt;query);
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		group-&gt;query_id = ret;</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return (ret &gt; 0) ? 0 : ret;</span>
 }
 
 static void join_group(struct mcast_group *group, struct mcast_member *member,
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 05179f47bbde..d862b9b7910e 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -1080,6 +1080,27 @@</span> <span class="p_context"> void handle_port_mgmt_change_event(struct work_struct *work)</span>
 
 		/* Generate GUID changed event */
 		if (changed_attr &amp; MLX4_EQ_PORT_INFO_GID_PFX_CHANGE_MASK) {
<span class="p_add">+			if (mlx4_is_master(dev-&gt;dev)) {</span>
<span class="p_add">+				union ib_gid gid;</span>
<span class="p_add">+				int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (!eqe-&gt;event.port_mgmt_change.params.port_info.gid_prefix)</span>
<span class="p_add">+					err = __mlx4_ib_query_gid(&amp;dev-&gt;ib_dev, port, 0, &amp;gid, 1);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					gid.global.subnet_prefix =</span>
<span class="p_add">+						eqe-&gt;event.port_mgmt_change.params.port_info.gid_prefix;</span>
<span class="p_add">+				if (err) {</span>
<span class="p_add">+					pr_warn(&quot;Could not change QP1 subnet prefix for port %d: query_gid error (%d)\n&quot;,</span>
<span class="p_add">+						port, err);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					pr_debug(&quot;Changing QP1 subnet prefix for port %d. old=0x%llx. new=0x%llx\n&quot;,</span>
<span class="p_add">+						 port,</span>
<span class="p_add">+						 (u64)atomic64_read(&amp;dev-&gt;sriov.demux[port - 1].subnet_prefix),</span>
<span class="p_add">+						 be64_to_cpu(gid.global.subnet_prefix));</span>
<span class="p_add">+					atomic64_set(&amp;dev-&gt;sriov.demux[port - 1].subnet_prefix,</span>
<span class="p_add">+						     be64_to_cpu(gid.global.subnet_prefix));</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
 			mlx4_ib_dispatch_event(dev, port, IB_EVENT_GID_CHANGE);
 			/*if master, notify all slaves*/
 			if (mlx4_is_master(dev-&gt;dev))
<span class="p_chunk">@@ -2154,6 +2175,8 @@</span> <span class="p_context"> int mlx4_ib_init_sriov(struct mlx4_ib_dev *dev)</span>
 		if (err)
 			goto demux_err;
 		dev-&gt;sriov.demux[i].guid_cache[0] = gid.global.interface_id;
<span class="p_add">+		atomic64_set(&amp;dev-&gt;sriov.demux[i].subnet_prefix,</span>
<span class="p_add">+			     be64_to_cpu(gid.global.subnet_prefix));</span>
 		err = alloc_pv_object(dev, mlx4_master_func_num(dev-&gt;dev), i + 1,
 				      &amp;dev-&gt;sriov.sqps[i]);
 		if (err)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mcg.c b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">index 99451d887266..36ec8aa048aa 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mcg.c</span>
<span class="p_chunk">@@ -489,7 +489,7 @@</span> <span class="p_context"> static u8 get_leave_state(struct mcast_group *group)</span>
 		if (!group-&gt;members[i])
 			leave_state |= (1 &lt;&lt; i);
 
<span class="p_del">-	return leave_state &amp; (group-&gt;rec.scope_join_state &amp; 7);</span>
<span class="p_add">+	return leave_state &amp; (group-&gt;rec.scope_join_state &amp; 0xf);</span>
 }
 
 static int join_group(struct mcast_group *group, int slave, u8 join_mask)
<span class="p_chunk">@@ -564,8 +564,8 @@</span> <span class="p_context"> static void mlx4_ib_mcg_timeout_handler(struct work_struct *work)</span>
 		} else
 			mcg_warn_group(group, &quot;DRIVER BUG\n&quot;);
 	} else if (group-&gt;state == MCAST_LEAVE_SENT) {
<span class="p_del">-		if (group-&gt;rec.scope_join_state &amp; 7)</span>
<span class="p_del">-			group-&gt;rec.scope_join_state &amp;= 0xf8;</span>
<span class="p_add">+		if (group-&gt;rec.scope_join_state &amp; 0xf)</span>
<span class="p_add">+			group-&gt;rec.scope_join_state &amp;= 0xf0;</span>
 		group-&gt;state = MCAST_IDLE;
 		mutex_unlock(&amp;group-&gt;lock);
 		if (release_group(group, 1))
<span class="p_chunk">@@ -605,7 +605,7 @@</span> <span class="p_context"> static int handle_leave_req(struct mcast_group *group, u8 leave_mask,</span>
 static int handle_join_req(struct mcast_group *group, u8 join_mask,
 			   struct mcast_req *req)
 {
<span class="p_del">-	u8 group_join_state = group-&gt;rec.scope_join_state &amp; 7;</span>
<span class="p_add">+	u8 group_join_state = group-&gt;rec.scope_join_state &amp; 0xf;</span>
 	int ref = 0;
 	u16 status;
 	struct ib_sa_mcmember_data *sa_data = (struct ib_sa_mcmember_data *)req-&gt;sa_mad.data;
<span class="p_chunk">@@ -690,8 +690,8 @@</span> <span class="p_context"> static void mlx4_ib_mcg_work_handler(struct work_struct *work)</span>
 			u8 cur_join_state;
 
 			resp_join_state = ((struct ib_sa_mcmember_data *)
<span class="p_del">-						group-&gt;response_sa_mad.data)-&gt;scope_join_state &amp; 7;</span>
<span class="p_del">-			cur_join_state = group-&gt;rec.scope_join_state &amp; 7;</span>
<span class="p_add">+						group-&gt;response_sa_mad.data)-&gt;scope_join_state &amp; 0xf;</span>
<span class="p_add">+			cur_join_state = group-&gt;rec.scope_join_state &amp; 0xf;</span>
 
 			if (method == IB_MGMT_METHOD_GET_RESP) {
 				/* successfull join */
<span class="p_chunk">@@ -710,7 +710,7 @@</span> <span class="p_context"> process_requests:</span>
 		req = list_first_entry(&amp;group-&gt;pending_list, struct mcast_req,
 				       group_list);
 		sa_data = (struct ib_sa_mcmember_data *)req-&gt;sa_mad.data;
<span class="p_del">-		req_join_state = sa_data-&gt;scope_join_state &amp; 0x7;</span>
<span class="p_add">+		req_join_state = sa_data-&gt;scope_join_state &amp; 0xf;</span>
 
 		/* For a leave request, we will immediately answer the VF, and
 		 * update our internal counters. The actual leave will be sent
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mlx4_ib.h b/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_header">index 1caa11edac03..78f29e91653a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mlx4_ib.h</span>
<span class="p_chunk">@@ -441,7 +441,7 @@</span> <span class="p_context"> struct mlx4_ib_demux_ctx {</span>
 	struct workqueue_struct *wq;
 	struct workqueue_struct *ud_wq;
 	spinlock_t ud_lock;
<span class="p_del">-	__be64 subnet_prefix;</span>
<span class="p_add">+	atomic64_t subnet_prefix;</span>
 	__be64 guid_cache[128];
 	struct mlx4_ib_dev *dev;
 	/* the following lock protects both mcg_table and mcg_mgid0_list */
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index ea1e2ddaddf5..f350f2d61c15 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2331,24 +2331,27 @@</span> <span class="p_context"> static int build_mlx_header(struct mlx4_ib_sqp *sqp, struct ib_ud_wr *wr,</span>
 		sqp-&gt;ud_header.grh.flow_label    =
 			ah-&gt;av.ib.sl_tclass_flowlabel &amp; cpu_to_be32(0xfffff);
 		sqp-&gt;ud_header.grh.hop_limit     = ah-&gt;av.ib.hop_limit;
<span class="p_del">-		if (is_eth)</span>
<span class="p_add">+		if (is_eth) {</span>
 			memcpy(sqp-&gt;ud_header.grh.source_gid.raw, sgid.raw, 16);
<span class="p_del">-		else {</span>
<span class="p_del">-		if (mlx4_is_mfunc(to_mdev(ib_dev)-&gt;dev)) {</span>
<span class="p_del">-			/* When multi-function is enabled, the ib_core gid</span>
<span class="p_del">-			 * indexes don&#39;t necessarily match the hw ones, so</span>
<span class="p_del">-			 * we must use our own cache */</span>
<span class="p_del">-			sqp-&gt;ud_header.grh.source_gid.global.subnet_prefix =</span>
<span class="p_del">-				to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_del">-						       subnet_prefix;</span>
<span class="p_del">-			sqp-&gt;ud_header.grh.source_gid.global.interface_id =</span>
<span class="p_del">-				to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_del">-					       guid_cache[ah-&gt;av.ib.gid_index];</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			ib_get_cached_gid(ib_dev,</span>
<span class="p_del">-					  be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24,</span>
<span class="p_del">-					  ah-&gt;av.ib.gid_index,</span>
<span class="p_del">-					  &amp;sqp-&gt;ud_header.grh.source_gid, NULL);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (mlx4_is_mfunc(to_mdev(ib_dev)-&gt;dev)) {</span>
<span class="p_add">+				/* When multi-function is enabled, the ib_core gid</span>
<span class="p_add">+				 * indexes don&#39;t necessarily match the hw ones, so</span>
<span class="p_add">+				 * we must use our own cache</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				sqp-&gt;ud_header.grh.source_gid.global.subnet_prefix =</span>
<span class="p_add">+					cpu_to_be64(atomic64_read(&amp;(to_mdev(ib_dev)-&gt;sriov.</span>
<span class="p_add">+								    demux[sqp-&gt;qp.port - 1].</span>
<span class="p_add">+								    subnet_prefix)));</span>
<span class="p_add">+				sqp-&gt;ud_header.grh.source_gid.global.interface_id =</span>
<span class="p_add">+					to_mdev(ib_dev)-&gt;sriov.demux[sqp-&gt;qp.port - 1].</span>
<span class="p_add">+						       guid_cache[ah-&gt;av.ib.gid_index];</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				ib_get_cached_gid(ib_dev,</span>
<span class="p_add">+						  be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24,</span>
<span class="p_add">+						  ah-&gt;av.ib.gid_index,</span>
<span class="p_add">+						  &amp;sqp-&gt;ud_header.grh.source_gid, NULL);</span>
<span class="p_add">+			}</span>
 		}
 		memcpy(sqp-&gt;ud_header.grh.destination_gid.raw,
 		       ah-&gt;av.ib.dgid, 16);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib.h b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">index 3ede10309754..69a151ae8261 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib.h</span>
<span class="p_chunk">@@ -472,6 +472,7 @@</span> <span class="p_context"> void ipoib_send(struct net_device *dev, struct sk_buff *skb,</span>
 		struct ipoib_ah *address, u32 qpn);
 void ipoib_reap_ah(struct work_struct *work);
 
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid);</span>
 void ipoib_mark_paths_invalid(struct net_device *dev);
 void ipoib_flush_paths(struct net_device *dev);
 struct ipoib_dev_priv *ipoib_intf_alloc(const char *format);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_cm.c b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">index 3ae9726efb98..8ca75af0e6d1 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_cm.c</span>
<span class="p_chunk">@@ -1299,6 +1299,8 @@</span> <span class="p_context"> void ipoib_cm_destroy_tx(struct ipoib_cm_tx *tx)</span>
 	}
 }
 
<span class="p_add">+#define QPN_AND_OPTIONS_OFFSET	4</span>
<span class="p_add">+</span>
 static void ipoib_cm_tx_start(struct work_struct *work)
 {
 	struct ipoib_dev_priv *priv = container_of(work, struct ipoib_dev_priv,
<span class="p_chunk">@@ -1307,6 +1309,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 	struct ipoib_neigh *neigh;
 	struct ipoib_cm_tx *p;
 	unsigned long flags;
<span class="p_add">+	struct ipoib_path *path;</span>
 	int ret;
 
 	struct ib_sa_path_rec pathrec;
<span class="p_chunk">@@ -1319,7 +1322,19 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		p = list_entry(priv-&gt;cm.start_list.next, typeof(*p), list);
 		list_del_init(&amp;p-&gt;list);
 		neigh = p-&gt;neigh;
<span class="p_add">+</span>
 		qpn = IPOIB_QPN(neigh-&gt;daddr);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * As long as the search is with these 2 locks,</span>
<span class="p_add">+		 * path existence indicates its validity.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		path = __path_find(dev, neigh-&gt;daddr + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+		if (!path) {</span>
<span class="p_add">+			pr_info(&quot;%s ignore not valid path %pI6\n&quot;,</span>
<span class="p_add">+				__func__,</span>
<span class="p_add">+				neigh-&gt;daddr + QPN_AND_OPTIONS_OFFSET);</span>
<span class="p_add">+			goto free_neigh;</span>
<span class="p_add">+		}</span>
 		memcpy(&amp;pathrec, &amp;p-&gt;path-&gt;pathrec, sizeof pathrec);
 
 		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -1331,6 +1346,7 @@</span> <span class="p_context"> static void ipoib_cm_tx_start(struct work_struct *work)</span>
 		spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
 		if (ret) {
<span class="p_add">+free_neigh:</span>
 			neigh = p-&gt;neigh;
 			if (neigh) {
 				neigh-&gt;cm = NULL;
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">index fa9c42ff1fb0..85de078fb0ce 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_chunk">@@ -1028,8 +1028,17 @@</span> <span class="p_context"> static void __ipoib_ib_dev_flush(struct ipoib_dev_priv *priv,</span>
 	}
 
 	if (level == IPOIB_FLUSH_LIGHT) {
<span class="p_add">+		int oper_up;</span>
 		ipoib_mark_paths_invalid(dev);
<span class="p_add">+		/* Set IPoIB operation as down to prevent races between:</span>
<span class="p_add">+		 * the flush flow which leaves MCG and on the fly joins</span>
<span class="p_add">+		 * which can happen during that time. mcast restart task</span>
<span class="p_add">+		 * should deal with join requests we missed.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		oper_up = test_and_clear_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 		ipoib_mcast_dev_flush(dev);
<span class="p_add">+		if (oper_up)</span>
<span class="p_add">+			set_bit(IPOIB_FLAG_OPER_UP, &amp;priv-&gt;flags);</span>
 		ipoib_flush_ah(dev);
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 942dffca6a9d..5f7681b975d0 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -481,7 +481,7 @@</span> <span class="p_context"> int ipoib_set_mode(struct net_device *dev, const char *buf)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-static struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
<span class="p_add">+struct ipoib_path *__path_find(struct net_device *dev, void *gid)</span>
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 	struct rb_node *n = priv-&gt;path_tree.rb_node;
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3.c b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">index 2fc499a2207e..44aa57edf207 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3.c</span>
<span class="p_chunk">@@ -544,7 +544,7 @@</span> <span class="p_context"> static struct notifier_block gic_cpu_notifier = {</span>
 static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,
 				   unsigned long cluster_id)
 {
<span class="p_del">-	int cpu = *base_cpu;</span>
<span class="p_add">+	int next_cpu, cpu = *base_cpu;</span>
 	unsigned long mpidr = cpu_logical_map(cpu);
 	u16 tlist = 0;
 
<span class="p_chunk">@@ -558,9 +558,10 @@</span> <span class="p_context"> static u16 gic_compute_target_list(int *base_cpu, const struct cpumask *mask,</span>
 
 		tlist |= 1 &lt;&lt; (mpidr &amp; 0xf);
 
<span class="p_del">-		cpu = cpumask_next(cpu, mask);</span>
<span class="p_del">-		if (cpu &gt;= nr_cpu_ids)</span>
<span class="p_add">+		next_cpu = cpumask_next(cpu, mask);</span>
<span class="p_add">+		if (next_cpu &gt;= nr_cpu_ids)</span>
 			goto out;
<span class="p_add">+		cpu = next_cpu;</span>
 
 		mpidr = cpu_logical_map(cpu);
 
<span class="p_header">diff --git a/drivers/md/dm-log-writes.c b/drivers/md/dm-log-writes.c</span>
<span class="p_header">index d8956b4a7b09..c8b513ee117c 100644</span>
<span class="p_header">--- a/drivers/md/dm-log-writes.c</span>
<span class="p_header">+++ b/drivers/md/dm-log-writes.c</span>
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> static int log_one_block(struct log_writes_c *lc,</span>
 	sector++;
 
 	atomic_inc(&amp;lc-&gt;io_blocks);
<span class="p_del">-	bio = bio_alloc(GFP_KERNEL, block-&gt;vec_cnt);</span>
<span class="p_add">+	bio = bio_alloc(GFP_KERNEL, min(block-&gt;vec_cnt, BIO_MAX_PAGES));</span>
 	if (!bio) {
 		DMERR(&quot;Couldn&#39;t alloc log bio&quot;);
 		goto error;
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> static int log_one_block(struct log_writes_c *lc,</span>
 		if (ret != block-&gt;vecs[i].bv_len) {
 			atomic_inc(&amp;lc-&gt;io_blocks);
 			submit_bio(WRITE, bio);
<span class="p_del">-			bio = bio_alloc(GFP_KERNEL, block-&gt;vec_cnt - i);</span>
<span class="p_add">+			bio = bio_alloc(GFP_KERNEL, min(block-&gt;vec_cnt - i, BIO_MAX_PAGES));</span>
 			if (!bio) {
 				DMERR(&quot;Couldn&#39;t alloc log bio&quot;);
 				goto error;
<span class="p_header">diff --git a/drivers/media/usb/em28xx/em28xx-i2c.c b/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_header">index a19b5c8b56ff..1a9e1e556706 100644</span>
<span class="p_header">--- a/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_header">+++ b/drivers/media/usb/em28xx/em28xx-i2c.c</span>
<span class="p_chunk">@@ -507,9 +507,8 @@</span> <span class="p_context"> static int em28xx_i2c_xfer(struct i2c_adapter *i2c_adap,</span>
 	if (dev-&gt;disconnected)
 		return -ENODEV;
 
<span class="p_del">-	rc = rt_mutex_trylock(&amp;dev-&gt;i2c_bus_lock);</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_del">-		return rc;</span>
<span class="p_add">+	if (!rt_mutex_trylock(&amp;dev-&gt;i2c_bus_lock))</span>
<span class="p_add">+		return -EAGAIN;</span>
 
 	/* Switch I2C bus if needed */
 	if (bus != dev-&gt;cur_i2c_bus &amp;&amp;
<span class="p_header">diff --git a/drivers/media/usb/gspca/cpia1.c b/drivers/media/usb/gspca/cpia1.c</span>
<span class="p_header">index f23df4a9d8c5..52b88e9e656b 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/cpia1.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/cpia1.c</span>
<span class="p_chunk">@@ -1624,7 +1624,7 @@</span> <span class="p_context"> static int sd_start(struct gspca_dev *gspca_dev)</span>
 
 static void sd_stopN(struct gspca_dev *gspca_dev)
 {
<span class="p_del">-	struct sd *sd = (struct sd *) gspca_dev;</span>
<span class="p_add">+	struct sd *sd __maybe_unused = (struct sd *) gspca_dev;</span>
 
 	command_pause(gspca_dev);
 
<span class="p_header">diff --git a/drivers/media/usb/gspca/konica.c b/drivers/media/usb/gspca/konica.c</span>
<span class="p_header">index 39c96bb4c985..0712b1bc90b4 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/konica.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/konica.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static int sd_start(struct gspca_dev *gspca_dev)</span>
 
 static void sd_stopN(struct gspca_dev *gspca_dev)
 {
<span class="p_del">-	struct sd *sd = (struct sd *) gspca_dev;</span>
<span class="p_add">+	struct sd *sd __maybe_unused = (struct sd *) gspca_dev;</span>
 
 	konica_stream_off(gspca_dev);
 #if IS_ENABLED(CONFIG_INPUT)
<span class="p_header">diff --git a/drivers/media/usb/gspca/t613.c b/drivers/media/usb/gspca/t613.c</span>
<span class="p_header">index e2cc4e5a0ccb..bb52fc1fe598 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/t613.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/t613.c</span>
<span class="p_chunk">@@ -837,7 +837,7 @@</span> <span class="p_context"> static void sd_pkt_scan(struct gspca_dev *gspca_dev,</span>
 			u8 *data,			/* isoc packet */
 			int len)			/* iso packet length */
 {
<span class="p_del">-	struct sd *sd = (struct sd *) gspca_dev;</span>
<span class="p_add">+	struct sd *sd __maybe_unused = (struct sd *) gspca_dev;</span>
 	int pkt_type;
 
 	if (data[0] == 0x5a) {
<span class="p_header">diff --git a/drivers/mmc/host/pxamci.c b/drivers/mmc/host/pxamci.c</span>
<span class="p_header">index 28a057fae0a1..72bbb12fb938 100644</span>
<span class="p_header">--- a/drivers/mmc/host/pxamci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/pxamci.c</span>
<span class="p_chunk">@@ -798,14 +798,16 @@</span> <span class="p_context"> static int pxamci_probe(struct platform_device *pdev)</span>
 		gpio_direction_output(gpio_power,
 				      host-&gt;pdata-&gt;gpio_power_invert);
 	}
<span class="p_del">-	if (gpio_is_valid(gpio_ro))</span>
<span class="p_add">+	if (gpio_is_valid(gpio_ro)) {</span>
 		ret = mmc_gpio_request_ro(mmc, gpio_ro);
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Failed requesting gpio_ro %d\n&quot;, gpio_ro);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		mmc-&gt;caps2 |= host-&gt;pdata-&gt;gpio_card_ro_invert ?</span>
<span class="p_del">-			0 : MMC_CAP2_RO_ACTIVE_HIGH;</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev, &quot;Failed requesting gpio_ro %d\n&quot;,</span>
<span class="p_add">+				gpio_ro);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			mmc-&gt;caps2 |= host-&gt;pdata-&gt;gpio_card_ro_invert ?</span>
<span class="p_add">+				0 : MMC_CAP2_RO_ACTIVE_HIGH;</span>
<span class="p_add">+		}</span>
 	}
 
 	if (gpio_is_valid(gpio_cd))
<span class="p_header">diff --git a/drivers/mtd/nand/davinci_nand.c b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">index c72313d66cf6..bc054a5ed7f8 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/davinci_nand.c</span>
<span class="p_chunk">@@ -241,6 +241,9 @@</span> <span class="p_context"> static void nand_davinci_hwctl_4bit(struct mtd_info *mtd, int mode)</span>
 	unsigned long flags;
 	u32 val;
 
<span class="p_add">+	/* Reset ECC hardware */</span>
<span class="p_add">+	davinci_nand_readl(info, NAND_4BIT_ECC1_OFFSET);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;davinci_nand_lock, flags);
 
 	/* Start 4-bit ECC calculation for read/write */
<span class="p_header">diff --git a/drivers/net/can/dev.c b/drivers/net/can/dev.c</span>
<span class="p_header">index ad535a854e5c..eab132778e67 100644</span>
<span class="p_header">--- a/drivers/net/can/dev.c</span>
<span class="p_header">+++ b/drivers/net/can/dev.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/netdevice.h&gt;
 #include &lt;linux/if_arp.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/can.h&gt;
 #include &lt;linux/can/dev.h&gt;
 #include &lt;linux/can/skb.h&gt;
<span class="p_chunk">@@ -471,9 +472,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(can_free_echo_skb);</span>
 /*
  * CAN device restart for bus-off recovery
  */
<span class="p_del">-static void can_restart(unsigned long data)</span>
<span class="p_add">+static void can_restart(struct net_device *dev)</span>
 {
<span class="p_del">-	struct net_device *dev = (struct net_device *)data;</span>
 	struct can_priv *priv = netdev_priv(dev);
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	struct sk_buff *skb;
<span class="p_chunk">@@ -513,6 +513,14 @@</span> <span class="p_context"> restart:</span>
 		netdev_err(dev, &quot;Error %d during restart&quot;, err);
 }
 
<span class="p_add">+static void can_restart_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct delayed_work *dwork = to_delayed_work(work);</span>
<span class="p_add">+	struct can_priv *priv = container_of(dwork, struct can_priv, restart_work);</span>
<span class="p_add">+</span>
<span class="p_add">+	can_restart(priv-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int can_restart_now(struct net_device *dev)
 {
 	struct can_priv *priv = netdev_priv(dev);
<span class="p_chunk">@@ -526,8 +534,8 @@</span> <span class="p_context"> int can_restart_now(struct net_device *dev)</span>
 	if (priv-&gt;state != CAN_STATE_BUS_OFF)
 		return -EBUSY;
 
<span class="p_del">-	/* Runs as soon as possible in the timer context */</span>
<span class="p_del">-	mod_timer(&amp;priv-&gt;restart_timer, jiffies);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
<span class="p_add">+	can_restart(dev);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -548,8 +556,8 @@</span> <span class="p_context"> void can_bus_off(struct net_device *dev)</span>
 	netif_carrier_off(dev);
 
 	if (priv-&gt;restart_ms)
<span class="p_del">-		mod_timer(&amp;priv-&gt;restart_timer,</span>
<span class="p_del">-			  jiffies + (priv-&gt;restart_ms * HZ) / 1000);</span>
<span class="p_add">+		schedule_delayed_work(&amp;priv-&gt;restart_work,</span>
<span class="p_add">+				      msecs_to_jiffies(priv-&gt;restart_ms));</span>
 }
 EXPORT_SYMBOL_GPL(can_bus_off);
 
<span class="p_chunk">@@ -658,6 +666,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 		return NULL;
 
 	priv = netdev_priv(dev);
<span class="p_add">+	priv-&gt;dev = dev;</span>
 
 	if (echo_skb_max) {
 		priv-&gt;echo_skb_max = echo_skb_max;
<span class="p_chunk">@@ -667,7 +676,7 @@</span> <span class="p_context"> struct net_device *alloc_candev(int sizeof_priv, unsigned int echo_skb_max)</span>
 
 	priv-&gt;state = CAN_STATE_STOPPED;
 
<span class="p_del">-	init_timer(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;priv-&gt;restart_work, can_restart_work);</span>
 
 	return dev;
 }
<span class="p_chunk">@@ -748,8 +757,6 @@</span> <span class="p_context"> int open_candev(struct net_device *dev)</span>
 	if (!netif_carrier_ok(dev))
 		netif_carrier_on(dev);
 
<span class="p_del">-	setup_timer(&amp;priv-&gt;restart_timer, can_restart, (unsigned long)dev);</span>
<span class="p_del">-</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(open_candev);
<span class="p_chunk">@@ -764,7 +771,7 @@</span> <span class="p_context"> void close_candev(struct net_device *dev)</span>
 {
 	struct can_priv *priv = netdev_priv(dev);
 
<span class="p_del">-	del_timer_sync(&amp;priv-&gt;restart_timer);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;priv-&gt;restart_work);</span>
 	can_flush_echo_skb(dev);
 }
 EXPORT_SYMBOL_GPL(close_candev);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_common.c b/drivers/net/ethernet/intel/i40e/i40e_common.c</span>
<span class="p_header">index 2d74c6e4d7b6..1cf715c72683 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_common.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_common.c</span>
<span class="p_chunk">@@ -302,13 +302,15 @@</span> <span class="p_context"> void i40e_debug_aq(struct i40e_hw *hw, enum i40e_debug_mask mask, void *desc,</span>
 		   void *buffer, u16 buf_len)
 {
 	struct i40e_aq_desc *aq_desc = (struct i40e_aq_desc *)desc;
<span class="p_del">-	u16 len = le16_to_cpu(aq_desc-&gt;datalen);</span>
<span class="p_add">+	u16 len;</span>
 	u8 *buf = (u8 *)buffer;
 	u16 i = 0;
 
 	if ((!(mask &amp; hw-&gt;debug_mask)) || (desc == NULL))
 		return;
 
<span class="p_add">+	len = le16_to_cpu(aq_desc-&gt;datalen);</span>
<span class="p_add">+</span>
 	i40e_debug(hw, mask,
 		   &quot;AQ CMD: opcode 0x%04X, flags 0x%04X, datalen 0x%04X, retval 0x%04X\n&quot;,
 		   le16_to_cpu(aq_desc-&gt;opcode),
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_header">index 8b4561e8ce1a..ef493271c712 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c</span>
<span class="p_chunk">@@ -4176,7 +4176,7 @@</span> <span class="p_context"> static void ath9k_hw_ar9300_set_board_values(struct ath_hw *ah,</span>
 	if (!AR_SREV_9330(ah) &amp;&amp; !AR_SREV_9340(ah) &amp;&amp; !AR_SREV_9531(ah))
 		ar9003_hw_internal_regulator_apply(ah);
 	ar9003_hw_apply_tuning_caps(ah);
<span class="p_del">-	ar9003_hw_apply_minccapwr_thresh(ah, chan);</span>
<span class="p_add">+	ar9003_hw_apply_minccapwr_thresh(ah, is2ghz);</span>
 	ar9003_hw_txend_to_xpa_off_apply(ah, is2ghz);
 	ar9003_hw_thermometer_apply(ah);
 	ar9003_hw_thermo_cal_apply(ah);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c b/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_header">index 410a6645d316..59cef6c69fe8 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmfmac/bcmsdh.c</span>
<span class="p_chunk">@@ -726,8 +726,10 @@</span> <span class="p_context"> int brcmf_sdiod_recv_chain(struct brcmf_sdio_dev *sdiodev,</span>
 			return -ENOMEM;
 		err = brcmf_sdiod_buffrw(sdiodev, SDIO_FUNC_2, false, addr,
 					 glom_skb);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			brcmu_pkt_buf_free_skb(glom_skb);</span>
 			goto done;
<span class="p_add">+		}</span>
 
 		skb_queue_walk(pktq, skb) {
 			memcpy(skb-&gt;data, glom_skb-&gt;data, skb-&gt;len);
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmsmac/dma.c b/drivers/net/wireless/brcm80211/brcmsmac/dma.c</span>
<span class="p_header">index 796f5f9d5d5a..b7df576bb84d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmsmac/dma.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmsmac/dma.c</span>
<span class="p_chunk">@@ -1079,8 +1079,10 @@</span> <span class="p_context"> bool dma_rxfill(struct dma_pub *pub)</span>
 
 		pa = dma_map_single(di-&gt;dmadev, p-&gt;data, di-&gt;rxbufsize,
 				    DMA_FROM_DEVICE);
<span class="p_del">-		if (dma_mapping_error(di-&gt;dmadev, pa))</span>
<span class="p_add">+		if (dma_mapping_error(di-&gt;dmadev, pa)) {</span>
<span class="p_add">+			brcmu_pkt_buf_free_skb(p);</span>
 			return false;
<span class="p_add">+		}</span>
 
 		/* save the free packet pointer */
 		di-&gt;rxp[rxout] = p;
<span class="p_header">diff --git a/drivers/net/wireless/brcm80211/brcmsmac/stf.c b/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">index dd9162722495..0ab865de1491 100644</span>
<span class="p_header">--- a/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_header">+++ b/drivers/net/wireless/brcm80211/brcmsmac/stf.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> void</span>
 brcms_c_stf_ss_algo_channel_get(struct brcms_c_info *wlc, u16 *ss_algo_channel,
 			    u16 chanspec)
 {
<span class="p_del">-	struct tx_power power;</span>
<span class="p_add">+	struct tx_power power = { };</span>
 	u8 siso_mcs_id, cdd_mcs_id, stbc_mcs_id;
 
 	/* Clear previous settings */
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/fw.c b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">index 610c442c7ab2..9584f950fd2f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_chunk">@@ -935,7 +935,8 @@</span> <span class="p_context"> int iwl_mvm_start_fw_dbg_conf(struct iwl_mvm *mvm, u8 conf_id)</span>
 	}
 
 	mvm-&gt;fw_dbg_conf = conf_id;
<span class="p_del">-	return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int iwl_mvm_config_ltr(struct iwl_mvm *mvm)
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index f96ab2f4b90e..ce12717e656a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -3992,8 +3992,8 @@</span> <span class="p_context"> static int iwl_mvm_mac_get_survey(struct ieee80211_hw *hw, int idx,</span>
 	if (idx != 0)
 		return -ENOENT;
 
<span class="p_del">-	if (fw_has_capa(&amp;mvm-&gt;fw-&gt;ucode_capa,</span>
<span class="p_del">-			IWL_UCODE_TLV_CAPA_RADIO_BEACON_STATS))</span>
<span class="p_add">+	if (!fw_has_capa(&amp;mvm-&gt;fw-&gt;ucode_capa,</span>
<span class="p_add">+			 IWL_UCODE_TLV_CAPA_RADIO_BEACON_STATS))</span>
 		return -ENOENT;
 
 	mutex_lock(&amp;mvm-&gt;mutex);
<span class="p_chunk">@@ -4039,8 +4039,8 @@</span> <span class="p_context"> static void iwl_mvm_mac_sta_statistics(struct ieee80211_hw *hw,</span>
 	struct iwl_mvm_vif *mvmvif = iwl_mvm_vif_from_mac80211(vif);
 	struct iwl_mvm_sta *mvmsta = iwl_mvm_sta_from_mac80211(sta);
 
<span class="p_del">-	if (fw_has_capa(&amp;mvm-&gt;fw-&gt;ucode_capa,</span>
<span class="p_del">-			IWL_UCODE_TLV_CAPA_RADIO_BEACON_STATS))</span>
<span class="p_add">+	if (!fw_has_capa(&amp;mvm-&gt;fw-&gt;ucode_capa,</span>
<span class="p_add">+			 IWL_UCODE_TLV_CAPA_RADIO_BEACON_STATS))</span>
 		return;
 
 	/* if beacon filtering isn&#39;t on mac80211 does it anyway */
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/sf.c b/drivers/net/wireless/iwlwifi/mvm/sf.c</span>
<span class="p_header">index b0f59fdd287c..d7d72adb6343 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/sf.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/sf.c</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> static int iwl_mvm_sf_config(struct iwl_mvm *mvm, u8 sta_id,</span>
 			     enum iwl_sf_state new_state)
 {
 	struct iwl_sf_cfg_cmd sf_cmd = {
<span class="p_del">-		.state = cpu_to_le32(SF_FULL_ON),</span>
<span class="p_add">+		.state = cpu_to_le32(new_state),</span>
 	};
 	struct ieee80211_sta *sta;
 	int ret = 0;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/tx.c b/drivers/net/wireless/iwlwifi/pcie/tx.c</span>
<span class="p_header">index a8c8a4a7420b..8dfe6b2bc703 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/tx.c</span>
<span class="p_chunk">@@ -1508,9 +1508,9 @@</span> <span class="p_context"> static int iwl_pcie_enqueue_hcmd(struct iwl_trans *trans,</span>
 
 	/* start the TFD with the scratchbuf */
 	scratch_size = min_t(int, copy_size, IWL_HCMD_SCRATCHBUF_SIZE);
<span class="p_del">-	memcpy(&amp;txq-&gt;scratchbufs[q-&gt;write_ptr], &amp;out_cmd-&gt;hdr, scratch_size);</span>
<span class="p_add">+	memcpy(&amp;txq-&gt;scratchbufs[idx], &amp;out_cmd-&gt;hdr, scratch_size);</span>
 	iwl_pcie_txq_build_tfd(trans, txq,
<span class="p_del">-			       iwl_pcie_get_scratchbuf_dma(txq, q-&gt;write_ptr),</span>
<span class="p_add">+			       iwl_pcie_get_scratchbuf_dma(txq, idx),</span>
 			       scratch_size, true);
 
 	/* map first command fragment, if any remains */
<span class="p_header">diff --git a/drivers/nfc/fdp/fdp.c b/drivers/nfc/fdp/fdp.c</span>
<span class="p_header">index ccb07a1b153d..23e53780728b 100644</span>
<span class="p_header">--- a/drivers/nfc/fdp/fdp.c</span>
<span class="p_header">+++ b/drivers/nfc/fdp/fdp.c</span>
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> static int fdp_nci_patch_otp(struct nci_dev *ndev)</span>
 {
 	struct fdp_nci_info *info = nci_get_drvdata(ndev);
 	struct device *dev = &amp;info-&gt;phy-&gt;i2c_dev-&gt;dev;
<span class="p_del">-	u8 conn_id;</span>
<span class="p_add">+	int conn_id;</span>
 	int r = 0;
 
 	if (info-&gt;otp_version &gt;= info-&gt;otp_patch_version)
<span class="p_chunk">@@ -423,7 +423,7 @@</span> <span class="p_context"> static int fdp_nci_patch_ram(struct nci_dev *ndev)</span>
 {
 	struct fdp_nci_info *info = nci_get_drvdata(ndev);
 	struct device *dev = &amp;info-&gt;phy-&gt;i2c_dev-&gt;dev;
<span class="p_del">-	u8 conn_id;</span>
<span class="p_add">+	int conn_id;</span>
 	int r = 0;
 
 	if (info-&gt;ram_version &gt;= info-&gt;ram_patch_version)
<span class="p_header">diff --git a/drivers/perf/arm_pmu.c b/drivers/perf/arm_pmu.c</span>
<span class="p_header">index be3755c973e9..8af1f900ea65 100644</span>
<span class="p_header">--- a/drivers/perf/arm_pmu.c</span>
<span class="p_header">+++ b/drivers/perf/arm_pmu.c</span>
<span class="p_chunk">@@ -815,6 +815,7 @@</span> <span class="p_context"> static int of_pmu_irq_cfg(struct arm_pmu *pmu)</span>
 			if (i &gt; 0 &amp;&amp; spi != using_spi) {
 				pr_err(&quot;PPI/SPI IRQ type mismatch for %s!\n&quot;,
 					dn-&gt;name);
<span class="p_add">+				of_node_put(dn);</span>
 				kfree(irqs);
 				return -EINVAL;
 			}
<span class="p_header">diff --git a/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c b/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c</span>
<span class="p_header">index 589872cc8adb..a19c29c79b0a 100644</span>
<span class="p_header">--- a/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/uniphier/pinctrl-uniphier-core.c</span>
<span class="p_chunk">@@ -73,6 +73,12 @@</span> <span class="p_context"> static void uniphier_pctl_pin_dbg_show(struct pinctrl_dev *pctldev,</span>
 	case UNIPHIER_PIN_PULL_DOWN:
 		pull_dir = &quot;DOWN&quot;;
 		break;
<span class="p_add">+	case UNIPHIER_PIN_PULL_UP_FIXED:</span>
<span class="p_add">+		pull_dir = &quot;UP(FIXED)&quot;;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case UNIPHIER_PIN_PULL_DOWN_FIXED:</span>
<span class="p_add">+		pull_dir = &quot;DOWN(FIXED)&quot;;</span>
<span class="p_add">+		break;</span>
 	case UNIPHIER_PIN_PULL_NONE:
 		pull_dir = &quot;NONE&quot;;
 		break;
<span class="p_header">diff --git a/drivers/regulator/qcom_smd-regulator.c b/drivers/regulator/qcom_smd-regulator.c</span>
<span class="p_header">index 6fa0c7d13290..4bda998afdef 100644</span>
<span class="p_header">--- a/drivers/regulator/qcom_smd-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/qcom_smd-regulator.c</span>
<span class="p_chunk">@@ -166,29 +166,30 @@</span> <span class="p_context"> static const struct regulator_desc pm8x41_hfsmps = {</span>
 static const struct regulator_desc pm8841_ftsmps = {
 	.linear_ranges = (struct regulator_linear_range[]) {
 		REGULATOR_LINEAR_RANGE(350000,  0, 184, 5000),
<span class="p_del">-		REGULATOR_LINEAR_RANGE(700000, 185, 339, 10000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(1280000, 185, 261, 10000),</span>
 	},
 	.n_linear_ranges = 2,
<span class="p_del">-	.n_voltages = 340,</span>
<span class="p_add">+	.n_voltages = 262,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
 static const struct regulator_desc pm8941_boost = {
 	.linear_ranges = (struct regulator_linear_range[]) {
<span class="p_del">-		REGULATOR_LINEAR_RANGE(4000000, 0, 15, 100000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(4000000, 0, 30, 50000),</span>
 	},
 	.n_linear_ranges = 1,
<span class="p_del">-	.n_voltages = 16,</span>
<span class="p_add">+	.n_voltages = 31,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
 static const struct regulator_desc pm8941_pldo = {
 	.linear_ranges = (struct regulator_linear_range[]) {
<span class="p_del">-		REGULATOR_LINEAR_RANGE( 750000,  0,  30, 25000),</span>
<span class="p_del">-		REGULATOR_LINEAR_RANGE(1500000, 31, 99, 50000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE( 750000,  0,  63, 12500),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(1550000, 64, 126, 25000),</span>
<span class="p_add">+		REGULATOR_LINEAR_RANGE(3100000, 127, 163, 50000),</span>
 	},
<span class="p_del">-	.n_linear_ranges = 2,</span>
<span class="p_del">-	.n_voltages = 100,</span>
<span class="p_add">+	.n_linear_ranges = 3,</span>
<span class="p_add">+	.n_voltages = 164,</span>
 	.ops = &amp;rpm_smps_ldo_ops,
 };
 
<span class="p_header">diff --git a/drivers/regulator/qcom_spmi-regulator.c b/drivers/regulator/qcom_spmi-regulator.c</span>
<span class="p_header">index 88a5dc88badc..fee6457e3111 100644</span>
<span class="p_header">--- a/drivers/regulator/qcom_spmi-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/qcom_spmi-regulator.c</span>
<span class="p_chunk">@@ -1050,6 +1050,8 @@</span> <span class="p_context"> static struct regulator_ops spmi_vs_ops = {</span>
 	.set_pull_down		= spmi_regulator_common_set_pull_down,
 	.set_soft_start		= spmi_regulator_common_set_soft_start,
 	.set_over_current_protection = spmi_regulator_vs_ocp,
<span class="p_add">+	.set_mode		= spmi_regulator_common_set_mode,</span>
<span class="p_add">+	.get_mode		= spmi_regulator_common_get_mode,</span>
 };
 
 static struct regulator_ops spmi_boost_ops = {
<span class="p_chunk">@@ -1440,6 +1442,7 @@</span> <span class="p_context"> static const struct spmi_regulator_data pm8941_regulators[] = {</span>
 	{ &quot;s1&quot;, 0x1400, &quot;vdd_s1&quot;, },
 	{ &quot;s2&quot;, 0x1700, &quot;vdd_s2&quot;, },
 	{ &quot;s3&quot;, 0x1a00, &quot;vdd_s3&quot;, },
<span class="p_add">+	{ &quot;s4&quot;, 0xa000, },</span>
 	{ &quot;l1&quot;, 0x4000, &quot;vdd_l1_l3&quot;, },
 	{ &quot;l2&quot;, 0x4100, &quot;vdd_l2_lvs_1_2_3&quot;, },
 	{ &quot;l3&quot;, 0x4200, &quot;vdd_l1_l3&quot;, },
<span class="p_chunk">@@ -1467,8 +1470,8 @@</span> <span class="p_context"> static const struct spmi_regulator_data pm8941_regulators[] = {</span>
 	{ &quot;lvs1&quot;, 0x8000, &quot;vdd_l2_lvs_1_2_3&quot;, },
 	{ &quot;lvs2&quot;, 0x8100, &quot;vdd_l2_lvs_1_2_3&quot;, },
 	{ &quot;lvs3&quot;, 0x8200, &quot;vdd_l2_lvs_1_2_3&quot;, },
<span class="p_del">-	{ &quot;mvs1&quot;, 0x8300, &quot;vin_5vs&quot;, },</span>
<span class="p_del">-	{ &quot;mvs2&quot;, 0x8400, &quot;vin_5vs&quot;, },</span>
<span class="p_add">+	{ &quot;5vs1&quot;, 0x8300, &quot;vin_5vs&quot;, &quot;ocp-5vs1&quot;, },</span>
<span class="p_add">+	{ &quot;5vs2&quot;, 0x8400, &quot;vin_5vs&quot;, &quot;ocp-5vs2&quot;, },</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/scsi/fnic/fnic_fcs.c b/drivers/scsi/fnic/fnic_fcs.c</span>
<span class="p_header">index 67669a9e73c1..f3a33312a9a6 100644</span>
<span class="p_header">--- a/drivers/scsi/fnic/fnic_fcs.c</span>
<span class="p_header">+++ b/drivers/scsi/fnic/fnic_fcs.c</span>
<span class="p_chunk">@@ -954,8 +954,8 @@</span> <span class="p_context"> int fnic_alloc_rq_frame(struct vnic_rq *rq)</span>
 	skb_put(skb, len);
 	pa = pci_map_single(fnic-&gt;pdev, skb-&gt;data, len, PCI_DMA_FROMDEVICE);
 
<span class="p_del">-	r = pci_dma_mapping_error(fnic-&gt;pdev, pa);</span>
<span class="p_del">-	if (r) {</span>
<span class="p_add">+	if (pci_dma_mapping_error(fnic-&gt;pdev, pa)) {</span>
<span class="p_add">+		r = -ENOMEM;</span>
 		printk(KERN_ERR &quot;PCI mapping failed with error %d\n&quot;, r);
 		goto free_skb;
 	}
<span class="p_chunk">@@ -1093,8 +1093,8 @@</span> <span class="p_context"> static int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp)</span>
 
 	pa = pci_map_single(fnic-&gt;pdev, eth_hdr, tot_len, PCI_DMA_TODEVICE);
 
<span class="p_del">-	ret = pci_dma_mapping_error(fnic-&gt;pdev, pa);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (pci_dma_mapping_error(fnic-&gt;pdev, pa)) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
 		printk(KERN_ERR &quot;DMA map failed with error %d\n&quot;, ret);
 		goto free_skb_on_err;
 	}
<span class="p_header">diff --git a/drivers/spi/spi-sh-msiof.c b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">index a7934ab00b96..d22de4c8c399 100644</span>
<span class="p_header">--- a/drivers/spi/spi-sh-msiof.c</span>
<span class="p_header">+++ b/drivers/spi/spi-sh-msiof.c</span>
<span class="p_chunk">@@ -263,6 +263,9 @@</span> <span class="p_context"> static void sh_msiof_spi_set_clk_regs(struct sh_msiof_spi_priv *p,</span>
 
 	for (k = 0; k &lt; ARRAY_SIZE(sh_msiof_spi_div_table); k++) {
 		brps = DIV_ROUND_UP(div, sh_msiof_spi_div_table[k].div);
<span class="p_add">+		/* SCR_BRDV_DIV_1 is valid only if BRPS is x 1/1 or x 1/2 */</span>
<span class="p_add">+		if (sh_msiof_spi_div_table[k].div == 1 &amp;&amp; brps &gt; 2)</span>
<span class="p_add">+			continue;</span>
 		if (brps &lt;= 32) /* max of brdv is 32 */
 			break;
 	}
<span class="p_header">diff --git a/drivers/staging/fbtft/fbtft-core.c b/drivers/staging/fbtft/fbtft-core.c</span>
<span class="p_header">index b1e45161eefc..18c2b6daf588 100644</span>
<span class="p_header">--- a/drivers/staging/fbtft/fbtft-core.c</span>
<span class="p_header">+++ b/drivers/staging/fbtft/fbtft-core.c</span>
<span class="p_chunk">@@ -392,11 +392,11 @@</span> <span class="p_context"> static void fbtft_update_display(struct fbtft_par *par, unsigned start_line,</span>
 
 	if (unlikely(timeit)) {
 		ts_end = ktime_get();
<span class="p_del">-		if (ktime_to_ns(par-&gt;update_time))</span>
<span class="p_add">+		if (!ktime_to_ns(par-&gt;update_time))</span>
 			par-&gt;update_time = ts_start;
 
<span class="p_del">-		par-&gt;update_time = ts_start;</span>
 		fps = ktime_us_delta(ts_start, par-&gt;update_time);
<span class="p_add">+		par-&gt;update_time = ts_start;</span>
 		fps = fps ? 1000000 / fps : 0;
 
 		throughput = ktime_us_delta(ts_end, ts_start);
<span class="p_header">diff --git a/drivers/usb/class/usbtmc.c b/drivers/usb/class/usbtmc.c</span>
<span class="p_header">index 7a11a8263171..deaddb950c20 100644</span>
<span class="p_header">--- a/drivers/usb/class/usbtmc.c</span>
<span class="p_header">+++ b/drivers/usb/class/usbtmc.c</span>
<span class="p_chunk">@@ -121,6 +121,7 @@</span> <span class="p_context"> static void usbtmc_delete(struct kref *kref)</span>
 	struct usbtmc_device_data *data = to_usbtmc_data(kref);
 
 	usb_put_dev(data-&gt;usb_dev);
<span class="p_add">+	kfree(data);</span>
 }
 
 static int usbtmc_open(struct inode *inode, struct file *filp)
<span class="p_chunk">@@ -1104,7 +1105,7 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 
 	dev_dbg(&amp;intf-&gt;dev, &quot;%s called\n&quot;, __func__);
 
<span class="p_del">-	data = devm_kzalloc(&amp;intf-&gt;dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
 	if (!data)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/fsl_qe_udc.c b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">index c73689b72f95..b38a33584d4a 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_chunk">@@ -1878,11 +1878,8 @@</span> <span class="p_context"> static int qe_get_frame(struct usb_gadget *gadget)</span>
 
 	tmp = in_be16(&amp;udc-&gt;usb_param-&gt;frame_n);
 	if (tmp &amp; 0x8000)
<span class="p_del">-		tmp = tmp &amp; 0x07ff;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		tmp = -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return (int)tmp;</span>
<span class="p_add">+		return tmp &amp; 0x07ff;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int fsl_qe_start(struct usb_gadget *gadget,
<span class="p_header">diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">index 7771be3ac178..4dd531ac5a7f 100644</span>
<span class="p_header">--- a/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">+++ b/drivers/usb/misc/legousbtower.c</span>
<span class="p_chunk">@@ -898,24 +898,6 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 	dev-&gt;interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev-&gt;interrupt_in_endpoint-&gt;bInterval;
 	dev-&gt;interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev-&gt;interrupt_out_endpoint-&gt;bInterval;
 
<span class="p_del">-	/* we can register the device now, as it is ready */</span>
<span class="p_del">-	usb_set_intfdata (interface, dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	retval = usb_register_dev (interface, &amp;tower_class);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (retval) {</span>
<span class="p_del">-		/* something prevented us from registering this driver */</span>
<span class="p_del">-		dev_err(idev, &quot;Not able to get a minor for this device.\n&quot;);</span>
<span class="p_del">-		usb_set_intfdata (interface, NULL);</span>
<span class="p_del">-		goto error;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dev-&gt;minor = interface-&gt;minor;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* let the user know what node this device is now attached to */</span>
<span class="p_del">-	dev_info(&amp;interface-&gt;dev, &quot;LEGO USB Tower #%d now attached to major &quot;</span>
<span class="p_del">-		 &quot;%d minor %d\n&quot;, (dev-&gt;minor - LEGO_USB_TOWER_MINOR_BASE),</span>
<span class="p_del">-		 USB_MAJOR, dev-&gt;minor);</span>
<span class="p_del">-</span>
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
<span class="p_chunk">@@ -936,6 +918,23 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
<span class="p_add">+	/* we can register the device now, as it is ready */</span>
<span class="p_add">+	usb_set_intfdata (interface, dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	retval = usb_register_dev (interface, &amp;tower_class);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (retval) {</span>
<span class="p_add">+		/* something prevented us from registering this driver */</span>
<span class="p_add">+		dev_err(idev, &quot;Not able to get a minor for this device.\n&quot;);</span>
<span class="p_add">+		usb_set_intfdata (interface, NULL);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dev-&gt;minor = interface-&gt;minor;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let the user know what node this device is now attached to */</span>
<span class="p_add">+	dev_info(&amp;interface-&gt;dev, &quot;LEGO USB Tower #%d now attached to major &quot;</span>
<span class="p_add">+		 &quot;%d minor %d\n&quot;, (dev-&gt;minor - LEGO_USB_TOWER_MINOR_BASE),</span>
<span class="p_add">+		 USB_MAJOR, dev-&gt;minor);</span>
 
 exit:
 	return retval;
<span class="p_header">diff --git a/drivers/usb/musb/musb_host.c b/drivers/usb/musb/musb_host.c</span>
<span class="p_header">index 59a63a0b7985..e0a083f6ab68 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_host.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_host.c</span>
<span class="p_chunk">@@ -661,7 +661,7 @@</span> <span class="p_context"> static int musb_tx_dma_set_mode_mentor(struct dma_controller *dma,</span>
 		csr &amp;= ~(MUSB_TXCSR_AUTOSET | MUSB_TXCSR_DMAMODE);
 		csr |= MUSB_TXCSR_DMAENAB; /* against programmer&#39;s guide */
 	}
<span class="p_del">-	channel-&gt;desired_mode = mode;</span>
<span class="p_add">+	channel-&gt;desired_mode = *mode;</span>
 	musb_writew(epio, MUSB_TXCSR, csr);
 
 	return 0;
<span class="p_chunk">@@ -2008,10 +2008,8 @@</span> <span class="p_context"> void musb_host_rx(struct musb *musb, u8 epnum)</span>
 				qh-&gt;offset,
 				urb-&gt;transfer_buffer_length);
 
<span class="p_del">-			done = musb_rx_dma_in_inventra_cppi41(c, hw_ep, qh,</span>
<span class="p_del">-							      urb, xfer_len,</span>
<span class="p_del">-							      iso_err);</span>
<span class="p_del">-			if (done)</span>
<span class="p_add">+			if (musb_rx_dma_in_inventra_cppi41(c, hw_ep, qh, urb,</span>
<span class="p_add">+							   xfer_len, iso_err))</span>
 				goto finish;
 			else
 				dev_err(musb-&gt;controller, &quot;error: rx_dma failed\n&quot;);
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index a2b43a6e7fa7..6eccded3bc33 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8411) }, /* Kyocera GPS Module */
 	{ USB_DEVICE(0x10C4, 0x8418) }, /* IRZ Automation Teleport SG-10 GSM/GPRS Modem */
 	{ USB_DEVICE(0x10C4, 0x846E) }, /* BEI USB Sensor Interface (VCP) */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8470) }, /* Juniper Networks BX Series System Console */</span>
 	{ USB_DEVICE(0x10C4, 0x8477) }, /* Balluff RFID */
 	{ USB_DEVICE(0x10C4, 0x84B6) }, /* Starizona Hyperion */
 	{ USB_DEVICE(0x10C4, 0x85EA) }, /* AC-Services IBUS-IF */
<span class="p_chunk">@@ -784,7 +785,7 @@</span> <span class="p_context"> static void cp210x_set_termios(struct tty_struct *tty,</span>
 		} else {
 			modem_ctl[0] &amp;= ~0x7B;
 			modem_ctl[0] |= 0x01;
<span class="p_del">-			modem_ctl[1] |= 0x40;</span>
<span class="p_add">+			modem_ctl[1] = 0x40;</span>
 			dev_dbg(dev, &quot;%s - flow control = NONE\n&quot;, __func__);
 		}
 
<span class="p_header">diff --git a/fs/aio.c b/fs/aio.c</span>
<span class="p_header">index 155f84253f33..fe4f49212b99 100644</span>
<span class="p_header">--- a/fs/aio.c</span>
<span class="p_header">+++ b/fs/aio.c</span>
<span class="p_chunk">@@ -239,7 +239,12 @@</span> <span class="p_context"> static struct dentry *aio_mount(struct file_system_type *fs_type,</span>
 	static const struct dentry_operations ops = {
 		.d_dname	= simple_dname,
 	};
<span class="p_del">-	return mount_pseudo(fs_type, &quot;aio:&quot;, NULL, &amp;ops, AIO_RING_MAGIC);</span>
<span class="p_add">+	struct dentry *root = mount_pseudo(fs_type, &quot;aio:&quot;, NULL, &amp;ops,</span>
<span class="p_add">+					   AIO_RING_MAGIC);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ERR(root))</span>
<span class="p_add">+		root-&gt;d_sb-&gt;s_iflags |= SB_I_NOEXEC;</span>
<span class="p_add">+	return root;</span>
 }
 
 /* aio_setup
<span class="p_header">diff --git a/fs/ceph/inode.c b/fs/ceph/inode.c</span>
<span class="p_header">index 498dcfa2dcdb..d98536c8abfc 100644</span>
<span class="p_header">--- a/fs/ceph/inode.c</span>
<span class="p_header">+++ b/fs/ceph/inode.c</span>
<span class="p_chunk">@@ -1358,15 +1358,20 @@</span> <span class="p_context"> static int fill_readdir_cache(struct inode *dir, struct dentry *dn,</span>
 
 	if (!ctl-&gt;page || pgoff != page_index(ctl-&gt;page)) {
 		ceph_readdir_cache_release(ctl);
<span class="p_del">-		ctl-&gt;page  = grab_cache_page(&amp;dir-&gt;i_data, pgoff);</span>
<span class="p_add">+		if (idx == 0)</span>
<span class="p_add">+			ctl-&gt;page = grab_cache_page(&amp;dir-&gt;i_data, pgoff);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			ctl-&gt;page = find_lock_page(&amp;dir-&gt;i_data, pgoff);</span>
 		if (!ctl-&gt;page) {
 			ctl-&gt;index = -1;
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_add">+			return idx == 0 ? -ENOMEM : 0;</span>
 		}
 		/* reading/filling the cache are serialized by
 		 * i_mutex, no need to use page lock */
 		unlock_page(ctl-&gt;page);
 		ctl-&gt;dentries = kmap(ctl-&gt;page);
<span class="p_add">+		if (idx == 0)</span>
<span class="p_add">+			memset(ctl-&gt;dentries, 0, PAGE_CACHE_SIZE);</span>
 	}
 
 	if (req-&gt;r_dir_release_cnt == atomic64_read(&amp;ci-&gt;i_release_count) &amp;&amp;
<span class="p_header">diff --git a/fs/nfs/callback_xdr.c b/fs/nfs/callback_xdr.c</span>
<span class="p_header">index 646cdac73488..e2e857affbf2 100644</span>
<span class="p_header">--- a/fs/nfs/callback_xdr.c</span>
<span class="p_header">+++ b/fs/nfs/callback_xdr.c</span>
<span class="p_chunk">@@ -912,7 +912,7 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	if (hdr_arg.minorversion == 0) {
 		cps.clp = nfs4_find_client_ident(SVC_NET(rqstp), hdr_arg.cb_ident);
 		if (!cps.clp || !check_gss_callback_principal(cps.clp, rqstp))
<span class="p_del">-			return rpc_drop_reply;</span>
<span class="p_add">+			goto out_invalidcred;</span>
 	}
 
 	cps.minorversion = hdr_arg.minorversion;
<span class="p_chunk">@@ -940,6 +940,10 @@</span> <span class="p_context"> static __be32 nfs4_callback_compound(struct svc_rqst *rqstp, void *argp, void *r</span>
 	nfs_put_client(cps.clp);
 	dprintk(&quot;%s: done, status = %u\n&quot;, __func__, ntohl(status));
 	return rpc_success;
<span class="p_add">+</span>
<span class="p_add">+out_invalidcred:</span>
<span class="p_add">+	pr_warn_ratelimited(&quot;NFS: NFSv4 callback contains invalid cred\n&quot;);</span>
<span class="p_add">+	return rpc_autherr_badcred;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/filelayout/filelayout.c b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">index 02ec07973bc4..fd8da630fd22 100644</span>
<span class="p_header">--- a/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">+++ b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_chunk">@@ -374,8 +374,7 @@</span> <span class="p_context"> static int filelayout_commit_done_cb(struct rpc_task *task,</span>
 		return -EAGAIN;
 	}
 
<span class="p_del">-	if (data-&gt;verf.committed == NFS_UNSTABLE)</span>
<span class="p_del">-		pnfs_set_layoutcommit(data-&gt;inode, data-&gt;lseg, data-&gt;lwb);</span>
<span class="p_add">+	pnfs_set_layoutcommit(data-&gt;inode, data-&gt;lseg, data-&gt;lwb);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">index 2a2e2d8ddee5..54313322ee5b 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_chunk">@@ -1414,8 +1414,7 @@</span> <span class="p_context"> static int ff_layout_commit_done_cb(struct rpc_task *task,</span>
 		return -EAGAIN;
 	}
 
<span class="p_del">-	if (data-&gt;verf.committed == NFS_UNSTABLE</span>
<span class="p_del">-	    &amp;&amp; ff_layout_need_layoutcommit(data-&gt;lseg))</span>
<span class="p_add">+	if (ff_layout_need_layoutcommit(data-&gt;lseg))</span>
 		pnfs_set_layoutcommit(data-&gt;inode, data-&gt;lseg, data-&gt;lwb);
 
 	return 0;
<span class="p_header">diff --git a/fs/pstore/inode.c b/fs/pstore/inode.c</span>
<span class="p_header">index d8c439d813ce..ac6c78fe19cf 100644</span>
<span class="p_header">--- a/fs/pstore/inode.c</span>
<span class="p_header">+++ b/fs/pstore/inode.c</span>
<span class="p_chunk">@@ -178,7 +178,6 @@</span> <span class="p_context"> static loff_t pstore_file_llseek(struct file *file, loff_t off, int whence)</span>
 }
 
 static const struct file_operations pstore_file_operations = {
<span class="p_del">-	.owner		= THIS_MODULE,</span>
 	.open		= pstore_file_open,
 	.read		= pstore_file_read,
 	.llseek		= pstore_file_llseek,
<span class="p_header">diff --git a/include/linux/can/dev.h b/include/linux/can/dev.h</span>
<span class="p_header">index 5261751f6bd4..5f5270941ba0 100644</span>
<span class="p_header">--- a/include/linux/can/dev.h</span>
<span class="p_header">+++ b/include/linux/can/dev.h</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"> enum can_mode {</span>
  * CAN common private data
  */
 struct can_priv {
<span class="p_add">+	struct net_device *dev;</span>
 	struct can_device_stats can_stats;
 
 	struct can_bittiming bittiming, data_bittiming;
<span class="p_chunk">@@ -47,7 +48,7 @@</span> <span class="p_context"> struct can_priv {</span>
 	u32 ctrlmode_static;	/* static enabled options for driver/hardware */
 
 	int restart_ms;
<span class="p_del">-	struct timer_list restart_timer;</span>
<span class="p_add">+	struct delayed_work restart_work;</span>
 
 	int (*do_set_bittiming)(struct net_device *dev);
 	int (*do_set_data_bittiming)(struct net_device *dev);
<span class="p_header">diff --git a/include/linux/nvmem-consumer.h b/include/linux/nvmem-consumer.h</span>
<span class="p_header">index 9bb77d3ed6e0..c2256d746543 100644</span>
<span class="p_header">--- a/include/linux/nvmem-consumer.h</span>
<span class="p_header">+++ b/include/linux/nvmem-consumer.h</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> static inline void nvmem_cell_put(struct nvmem_cell *cell)</span>
 {
 }
 
<span class="p_del">-static inline char *nvmem_cell_read(struct nvmem_cell *cell, size_t *len)</span>
<span class="p_add">+static inline void *nvmem_cell_read(struct nvmem_cell *cell, size_t *len)</span>
 {
 	return ERR_PTR(-ENOSYS);
 }
<span class="p_header">diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h</span>
<span class="p_header">index fa7bc29925c9..ef17db6caaed 100644</span>
<span class="p_header">--- a/include/linux/sysctl.h</span>
<span class="p_header">+++ b/include/linux/sysctl.h</span>
<span class="p_chunk">@@ -41,6 +41,8 @@</span> <span class="p_context"> extern int proc_dostring(struct ctl_table *, int,</span>
 			 void __user *, size_t *, loff_t *);
 extern int proc_dointvec(struct ctl_table *, int,
 			 void __user *, size_t *, loff_t *);
<span class="p_add">+extern int proc_douintvec(struct ctl_table *, int,</span>
<span class="p_add">+			 void __user *, size_t *, loff_t *);</span>
 extern int proc_dointvec_minmax(struct ctl_table *, int,
 				void __user *, size_t *, loff_t *);
 extern int proc_dointvec_jiffies(struct ctl_table *, int,
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index b9279a2844d8..b271353d5202 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -324,8 +324,7 @@</span> <span class="p_context"> static struct file_system_type cpuset_fs_type = {</span>
 /*
  * Return in pmask the portion of a cpusets&#39;s cpus_allowed that
  * are online.  If none are online, walk up the cpuset hierarchy
<span class="p_del">- * until we find one that does have some online cpus.  The top</span>
<span class="p_del">- * cpuset always has some cpus online.</span>
<span class="p_add">+ * until we find one that does have some online cpus.</span>
  *
  * One way or another, we guarantee to return some non-empty subset
  * of cpu_online_mask.
<span class="p_chunk">@@ -334,8 +333,20 @@</span> <span class="p_context"> static struct file_system_type cpuset_fs_type = {</span>
  */
 static void guarantee_online_cpus(struct cpuset *cs, struct cpumask *pmask)
 {
<span class="p_del">-	while (!cpumask_intersects(cs-&gt;effective_cpus, cpu_online_mask))</span>
<span class="p_add">+	while (!cpumask_intersects(cs-&gt;effective_cpus, cpu_online_mask)) {</span>
 		cs = parent_cs(cs);
<span class="p_add">+		if (unlikely(!cs)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The top cpuset doesn&#39;t have any online cpu as a</span>
<span class="p_add">+			 * consequence of a race between cpuset_hotplug_work</span>
<span class="p_add">+			 * and cpu hotplug notifier.  But we know the top</span>
<span class="p_add">+			 * cpuset&#39;s effective_cpus is on its way to to be</span>
<span class="p_add">+			 * identical to cpu_online_mask.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			cpumask_copy(pmask, cpu_online_mask);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	cpumask_and(pmask, cs-&gt;effective_cpus, cpu_online_mask);
 }
 
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 12ecd4f0329f..bc6371b0e4fb 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -1539,12 +1539,33 @@</span> <span class="p_context"> static int __init perf_workqueue_init(void)</span>
 
 core_initcall(perf_workqueue_init);
 
<span class="p_del">-static inline int pmu_filter_match(struct perf_event *event)</span>
<span class="p_add">+static inline int __pmu_filter_match(struct perf_event *event)</span>
 {
 	struct pmu *pmu = event-&gt;pmu;
 	return pmu-&gt;filter_match ? pmu-&gt;filter_match(event) : 1;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Check whether we should attempt to schedule an event group based on</span>
<span class="p_add">+ * PMU-specific filtering. An event group can consist of HW and SW events,</span>
<span class="p_add">+ * potentially with a SW leader, so we must check all the filters, to</span>
<span class="p_add">+ * determine whether a group is schedulable:</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int pmu_filter_match(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event *child;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!__pmu_filter_match(event))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(child, &amp;event-&gt;sibling_list, group_entry) {</span>
<span class="p_add">+		if (!__pmu_filter_match(child))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int
 event_filter_match(struct perf_event *event)
 {
<span class="p_header">diff --git a/kernel/fork.c b/kernel/fork.c</span>
<span class="p_header">index 8860d1f50d24..7161ebe67cbb 100644</span>
<span class="p_header">--- a/kernel/fork.c</span>
<span class="p_header">+++ b/kernel/fork.c</span>
<span class="p_chunk">@@ -901,14 +901,12 @@</span> <span class="p_context"> void mm_release(struct task_struct *tsk, struct mm_struct *mm)</span>
 	deactivate_mm(tsk, mm);
 
 	/*
<span class="p_del">-	 * If we&#39;re exiting normally, clear a user-space tid field if</span>
<span class="p_del">-	 * requested.  We leave this alone when dying by signal, to leave</span>
<span class="p_del">-	 * the value intact in a core dump, and to save the unnecessary</span>
<span class="p_del">-	 * trouble, say, a killed vfork parent shouldn&#39;t touch this mm.</span>
<span class="p_del">-	 * Userland only wants this done for a sys_exit.</span>
<span class="p_add">+	 * Signal userspace if we&#39;re not exiting with a core dump</span>
<span class="p_add">+	 * because we want to leave the value intact for debugging</span>
<span class="p_add">+	 * purposes.</span>
 	 */
 	if (tsk-&gt;clear_child_tid) {
<span class="p_del">-		if (!(tsk-&gt;flags &amp; PF_SIGNALED) &amp;&amp;</span>
<span class="p_add">+		if (!(tsk-&gt;signal-&gt;flags &amp; SIGNAL_GROUP_COREDUMP) &amp;&amp;</span>
 		    atomic_read(&amp;mm-&gt;mm_users) &gt; 1) {
 			/*
 			 * We don&#39;t check the error code - if userspace has
<span class="p_header">diff --git a/kernel/printk/braille.c b/kernel/printk/braille.c</span>
<span class="p_header">index 276762f3a460..d5760c42f042 100644</span>
<span class="p_header">--- a/kernel/printk/braille.c</span>
<span class="p_header">+++ b/kernel/printk/braille.c</span>
<span class="p_chunk">@@ -9,10 +9,10 @@</span> <span class="p_context"></span>
 
 char *_braille_console_setup(char **str, char **brl_options)
 {
<span class="p_del">-	if (!memcmp(*str, &quot;brl,&quot;, 4)) {</span>
<span class="p_add">+	if (!strncmp(*str, &quot;brl,&quot;, 4)) {</span>
 		*brl_options = &quot;&quot;;
 		*str += 4;
<span class="p_del">-	} else if (!memcmp(str, &quot;brl=&quot;, 4)) {</span>
<span class="p_add">+	} else if (!strncmp(*str, &quot;brl=&quot;, 4)) {</span>
 		*brl_options = *str + 4;
 		*str = strchr(*brl_options, &#39;,&#39;);
 		if (!*str)
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index 2781141a89f9..999e025bf68e 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -2051,6 +2051,21 @@</span> <span class="p_context"> static int do_proc_dointvec_conv(bool *negp, unsigned long *lvalp,</span>
 	return 0;
 }
 
<span class="p_add">+static int do_proc_douintvec_conv(bool *negp, unsigned long *lvalp,</span>
<span class="p_add">+				 int *valp,</span>
<span class="p_add">+				 int write, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (write) {</span>
<span class="p_add">+		if (*negp)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		*valp = *lvalp;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		unsigned int val = *valp;</span>
<span class="p_add">+		*lvalp = (unsigned long)val;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const char proc_wspace_sep[] = { &#39; &#39;, &#39;\t&#39;, &#39;\n&#39; };
 
 static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,
<span class="p_chunk">@@ -2178,8 +2193,27 @@</span> <span class="p_context"> static int do_proc_dointvec(struct ctl_table *table, int write,</span>
 int proc_dointvec(struct ctl_table *table, int write,
 		     void __user *buffer, size_t *lenp, loff_t *ppos)
 {
<span class="p_del">-    return do_proc_dointvec(table,write,buffer,lenp,ppos,</span>
<span class="p_del">-		    	    NULL,NULL);</span>
<span class="p_add">+	return do_proc_dointvec(table, write, buffer, lenp, ppos, NULL, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * proc_douintvec - read a vector of unsigned integers</span>
<span class="p_add">+ * @table: the sysctl table</span>
<span class="p_add">+ * @write: %TRUE if this is a write to the sysctl file</span>
<span class="p_add">+ * @buffer: the user buffer</span>
<span class="p_add">+ * @lenp: the size of the user buffer</span>
<span class="p_add">+ * @ppos: file position</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Reads/writes up to table-&gt;maxlen/sizeof(unsigned int) unsigned integer</span>
<span class="p_add">+ * values from/to the user buffer, treated as an ASCII string.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 on success.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int proc_douintvec(struct ctl_table *table, int write,</span>
<span class="p_add">+		     void __user *buffer, size_t *lenp, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return do_proc_dointvec(table, write, buffer, lenp, ppos,</span>
<span class="p_add">+				do_proc_douintvec_conv, NULL);</span>
 }
 
 /*
<span class="p_chunk">@@ -2792,6 +2826,12 @@</span> <span class="p_context"> int proc_dointvec(struct ctl_table *table, int write,</span>
 	return -ENOSYS;
 }
 
<span class="p_add">+int proc_douintvec(struct ctl_table *table, int write,</span>
<span class="p_add">+		  void __user *buffer, size_t *lenp, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -ENOSYS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int proc_dointvec_minmax(struct ctl_table *table, int write,
 		    void __user *buffer, size_t *lenp, loff_t *ppos)
 {
<span class="p_chunk">@@ -2837,6 +2877,7 @@</span> <span class="p_context"> int proc_doulongvec_ms_jiffies_minmax(struct ctl_table *table, int write,</span>
  * exception granted :-)
  */
 EXPORT_SYMBOL(proc_dointvec);
<span class="p_add">+EXPORT_SYMBOL(proc_douintvec);</span>
 EXPORT_SYMBOL(proc_dointvec_jiffies);
 EXPORT_SYMBOL(proc_dointvec_minmax);
 EXPORT_SYMBOL(proc_dointvec_userhz_jiffies);
<span class="p_header">diff --git a/mm/ksm.c b/mm/ksm.c</span>
<span class="p_header">index b5cd647daa52..2f028e6d0831 100644</span>
<span class="p_header">--- a/mm/ksm.c</span>
<span class="p_header">+++ b/mm/ksm.c</span>
<span class="p_chunk">@@ -283,7 +283,8 @@</span> <span class="p_context"> static inline struct rmap_item *alloc_rmap_item(void)</span>
 {
 	struct rmap_item *rmap_item;
 
<span class="p_del">-	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL);</span>
<span class="p_add">+	rmap_item = kmem_cache_zalloc(rmap_item_cache, GFP_KERNEL |</span>
<span class="p_add">+						__GFP_NORETRY | __GFP_NOWARN);</span>
 	if (rmap_item)
 		ksm_rmap_items++;
 	return rmap_item;
<span class="p_header">diff --git a/net/batman-adv/originator.c b/net/batman-adv/originator.c</span>
<span class="p_header">index 17851d3aaf22..6282f021ddfb 100644</span>
<span class="p_header">--- a/net/batman-adv/originator.c</span>
<span class="p_header">+++ b/net/batman-adv/originator.c</span>
<span class="p_chunk">@@ -197,18 +197,12 @@</span> <span class="p_context"> static void batadv_neigh_node_release(struct batadv_neigh_node *neigh_node)</span>
 {
 	struct hlist_node *node_tmp;
 	struct batadv_neigh_ifinfo *neigh_ifinfo;
<span class="p_del">-	struct batadv_algo_ops *bao;</span>
<span class="p_del">-</span>
<span class="p_del">-	bao = neigh_node-&gt;orig_node-&gt;bat_priv-&gt;bat_algo_ops;</span>
 
 	hlist_for_each_entry_safe(neigh_ifinfo, node_tmp,
 				  &amp;neigh_node-&gt;ifinfo_list, list) {
 		batadv_neigh_ifinfo_free_ref(neigh_ifinfo);
 	}
 
<span class="p_del">-	if (bao-&gt;bat_neigh_free)</span>
<span class="p_del">-		bao-&gt;bat_neigh_free(neigh_node);</span>
<span class="p_del">-</span>
 	batadv_hardif_free_ref(neigh_node-&gt;if_incoming);
 
 	kfree_rcu(neigh_node, rcu);
<span class="p_header">diff --git a/net/batman-adv/types.h b/net/batman-adv/types.h</span>
<span class="p_header">index d260efd70499..cbd347c2e4a5 100644</span>
<span class="p_header">--- a/net/batman-adv/types.h</span>
<span class="p_header">+++ b/net/batman-adv/types.h</span>
<span class="p_chunk">@@ -1136,8 +1136,6 @@</span> <span class="p_context"> struct batadv_forw_packet {</span>
  * @bat_neigh_is_equiv_or_better: check if neigh1 is equally good or better
  *  than neigh2 for their respective outgoing interface from the metric
  *  prospective
<span class="p_del">- * @bat_neigh_free: free the resources allocated by the routing algorithm for a</span>
<span class="p_del">- *  neigh_node object</span>
  * @bat_orig_print: print the originator table (optional)
  * @bat_orig_free: free the resources allocated by the routing algorithm for an
  *  orig_node object
<span class="p_chunk">@@ -1165,7 +1163,6 @@</span> <span class="p_context"> struct batadv_algo_ops {</span>
 		 struct batadv_hard_iface *if_outgoing1,
 		 struct batadv_neigh_node *neigh2,
 		 struct batadv_hard_iface *if_outgoing2);
<span class="p_del">-	void (*bat_neigh_free)(struct batadv_neigh_node *neigh);</span>
 	/* orig_node handling API */
 	void (*bat_orig_print)(struct batadv_priv *priv, struct seq_file *seq,
 			       struct batadv_hard_iface *hard_iface);
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_sync.c b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">index 803001a45aa1..1b07578bedf3 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_sync.c</span>
<span class="p_chunk">@@ -1545,7 +1545,8 @@</span> <span class="p_context"> error:</span>
 /*
  *      Set up receiving multicast socket over UDP
  */
<span class="p_del">-static struct socket *make_receive_sock(struct netns_ipvs *ipvs, int id)</span>
<span class="p_add">+static struct socket *make_receive_sock(struct netns_ipvs *ipvs, int id,</span>
<span class="p_add">+					int ifindex)</span>
 {
 	/* multicast addr */
 	union ipvs_sockaddr mcast_addr;
<span class="p_chunk">@@ -1566,6 +1567,7 @@</span> <span class="p_context"> static struct socket *make_receive_sock(struct netns_ipvs *ipvs, int id)</span>
 		set_sock_size(sock-&gt;sk, 0, result);
 
 	get_mcast_sockaddr(&amp;mcast_addr, &amp;salen, &amp;ipvs-&gt;bcfg, id);
<span class="p_add">+	sock-&gt;sk-&gt;sk_bound_dev_if = ifindex;</span>
 	result = sock-&gt;ops-&gt;bind(sock, (struct sockaddr *)&amp;mcast_addr, salen);
 	if (result &lt; 0) {
 		pr_err(&quot;Error binding to the multicast addr\n&quot;);
<span class="p_chunk">@@ -1868,7 +1870,7 @@</span> <span class="p_context"> int start_sync_thread(struct netns_ipvs *ipvs, struct ipvs_sync_daemon_cfg *c,</span>
 		if (state == IP_VS_STATE_MASTER)
 			sock = make_send_sock(ipvs, id);
 		else
<span class="p_del">-			sock = make_receive_sock(ipvs, id);</span>
<span class="p_add">+			sock = make_receive_sock(ipvs, id, dev-&gt;ifindex);</span>
 		if (IS_ERR(sock)) {
 			result = PTR_ERR(sock);
 			goto outtinfo;
<span class="p_header">diff --git a/net/sunrpc/svc.c b/net/sunrpc/svc.c</span>
<span class="p_header">index cc9852897395..c5b0cb4f4056 100644</span>
<span class="p_header">--- a/net/sunrpc/svc.c</span>
<span class="p_header">+++ b/net/sunrpc/svc.c</span>
<span class="p_chunk">@@ -1188,11 +1188,17 @@</span> <span class="p_context"> svc_process_common(struct svc_rqst *rqstp, struct kvec *argv, struct kvec *resv)</span>
 		*statp = procp-&gt;pc_func(rqstp, rqstp-&gt;rq_argp, rqstp-&gt;rq_resp);
 
 		/* Encode reply */
<span class="p_del">-		if (test_bit(RQ_DROPME, &amp;rqstp-&gt;rq_flags)) {</span>
<span class="p_add">+		if (*statp == rpc_drop_reply ||</span>
<span class="p_add">+		    test_bit(RQ_DROPME, &amp;rqstp-&gt;rq_flags)) {</span>
 			if (procp-&gt;pc_release)
 				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);
 			goto dropit;
 		}
<span class="p_add">+		if (*statp == rpc_autherr_badcred) {</span>
<span class="p_add">+			if (procp-&gt;pc_release)</span>
<span class="p_add">+				procp-&gt;pc_release(rqstp, NULL, rqstp-&gt;rq_resp);</span>
<span class="p_add">+			goto err_bad_auth;</span>
<span class="p_add">+		}</span>
 		if (*statp == rpc_success &amp;&amp;
 		    (xdr = procp-&gt;pc_encode) &amp;&amp;
 		    !xdr(rqstp, resv-&gt;iov_base+resv-&gt;iov_len, rqstp-&gt;rq_resp)) {
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index 600af5878e75..36cd715986bc 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> enum {</span>
 	CXT_FIXUP_HP_530,
 	CXT_FIXUP_CAP_MIX_AMP_5047,
 	CXT_FIXUP_MUTE_LED_EAPD,
<span class="p_add">+	CXT_FIXUP_HP_SPECTRE,</span>
 };
 
 /* for hda_fixup_thinkpad_acpi() */
<span class="p_chunk">@@ -765,6 +766,14 @@</span> <span class="p_context"> static const struct hda_fixup cxt_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cxt_fixup_mute_led_eapd,
 	},
<span class="p_add">+	[CXT_FIXUP_HP_SPECTRE] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			/* enable NID 0x1d for the speaker on top */</span>
<span class="p_add">+			{ 0x1d, 0x91170111 },</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk cxt5045_fixups[] = {
<span class="p_chunk">@@ -814,6 +823,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x0543, &quot;Acer Aspire One 522&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054c, &quot;Acer Aspire 3830TG&quot;, CXT_FIXUP_ASPIRE_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054f, &quot;Acer Aspire 4830T&quot;, CXT_FIXUP_ASPIRE_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x8174, &quot;HP Spectre x360&quot;, CXT_FIXUP_HP_SPECTRE),</span>
 	SND_PCI_QUIRK(0x1043, 0x138d, &quot;Asus&quot;, CXT_FIXUP_HEADPHONE_MIC_PIN),
 	SND_PCI_QUIRK(0x152d, 0x0833, &quot;OLPC XO-1.5&quot;, CXT_FIXUP_OLPC_XO),
 	SND_PCI_QUIRK(0x17aa, 0x20f2, &quot;Lenovo T400&quot;, CXT_PINCFG_LENOVO_TP410),
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index eaee626ab185..b1fa50aed888 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5790,6 +5790,13 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{0x14, 0x90170110}, \
 	{0x15, 0x0221401f}
 
<span class="p_add">+#define ALC295_STANDARD_PINS \</span>
<span class="p_add">+	{0x12, 0xb7a60130}, \</span>
<span class="p_add">+	{0x14, 0x90170110}, \</span>
<span class="p_add">+	{0x17, 0x21014020}, \</span>
<span class="p_add">+	{0x18, 0x21a19030}, \</span>
<span class="p_add">+	{0x21, 0x04211020}</span>
<span class="p_add">+</span>
 #define ALC298_STANDARD_PINS \
 	{0x12, 0x90a60130}, \
 	{0x21, 0x03211020}
<span class="p_chunk">@@ -5830,6 +5837,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x14, 0x90170120},
 		{0x21, 0x02211030}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x1b, 0x02011020},</span>
<span class="p_add">+		{0x21, 0x0221101f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x14, 0x90170130},
 		{0x1b, 0x01014020},
 		{0x21, 0x0221103f}),
<span class="p_chunk">@@ -5895,6 +5906,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x14, 0x90170120},
 		{0x21, 0x02211030}),
 	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x12, 0xb7a60130},</span>
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x21, 0x02211020}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		ALC256_STANDARD_PINS),
 	SND_HDA_PIN_QUIRK(0x10ec0280, 0x103c, &quot;HP&quot;, ALC280_FIXUP_HP_GPIO4,
 		{0x12, 0x90a60130},
<span class="p_chunk">@@ -6005,6 +6020,8 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 	SND_HDA_PIN_QUIRK(0x10ec0293, 0x1028, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC292_STANDARD_PINS,
 		{0x13, 0x90a60140}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0295, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC295_STANDARD_PINS),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0298, 0x1028, &quot;Dell&quot;, ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC298_STANDARD_PINS,
 		{0x17, 0x90170110}),
<span class="p_header">diff --git a/sound/soc/intel/skylake/skl.c b/sound/soc/intel/skylake/skl.c</span>
<span class="p_header">index caa69c4598a6..b4844f78266f 100644</span>
<span class="p_header">--- a/sound/soc/intel/skylake/skl.c</span>
<span class="p_header">+++ b/sound/soc/intel/skylake/skl.c</span>
<span class="p_chunk">@@ -464,8 +464,10 @@</span> <span class="p_context"> static int skl_probe(struct pci_dev *pci,</span>
 
 	skl-&gt;nhlt = skl_nhlt_init(bus-&gt;dev);
 
<span class="p_del">-	if (skl-&gt;nhlt == NULL)</span>
<span class="p_add">+	if (skl-&gt;nhlt == NULL) {</span>
<span class="p_add">+		err = -ENODEV;</span>
 		goto out_free;
<span class="p_add">+	}</span>
 
 	pci_set_drvdata(skl-&gt;pci, ebus);
 
<span class="p_header">diff --git a/sound/soc/omap/omap-mcpdm.c b/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_header">index b837265ac3e9..8d0d45d330e7 100644</span>
<span class="p_header">--- a/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_header">+++ b/sound/soc/omap/omap-mcpdm.c</span>
<span class="p_chunk">@@ -390,8 +390,8 @@</span> <span class="p_context"> static int omap_mcpdm_probe(struct snd_soc_dai *dai)</span>
 	pm_runtime_get_sync(mcpdm-&gt;dev);
 	omap_mcpdm_write(mcpdm, MCPDM_REG_CTRL, 0x00);
 
<span class="p_del">-	ret = devm_request_irq(mcpdm-&gt;dev, mcpdm-&gt;irq, omap_mcpdm_irq_handler,</span>
<span class="p_del">-				0, &quot;McPDM&quot;, (void *)mcpdm);</span>
<span class="p_add">+	ret = request_irq(mcpdm-&gt;irq, omap_mcpdm_irq_handler, 0, &quot;McPDM&quot;,</span>
<span class="p_add">+			  (void *)mcpdm);</span>
 
 	pm_runtime_put_sync(mcpdm-&gt;dev);
 
<span class="p_chunk">@@ -416,6 +416,7 @@</span> <span class="p_context"> static int omap_mcpdm_remove(struct snd_soc_dai *dai)</span>
 {
 	struct omap_mcpdm *mcpdm = snd_soc_dai_get_drvdata(dai);
 
<span class="p_add">+	free_irq(mcpdm-&gt;irq, (void *)mcpdm);</span>
 	pm_runtime_disable(mcpdm-&gt;dev);
 
 	return 0;
<span class="p_header">diff --git a/tools/vm/slabinfo.c b/tools/vm/slabinfo.c</span>
<span class="p_header">index 86e698d07e20..499b8819d4c6 100644</span>
<span class="p_header">--- a/tools/vm/slabinfo.c</span>
<span class="p_header">+++ b/tools/vm/slabinfo.c</span>
<span class="p_chunk">@@ -510,10 +510,11 @@</span> <span class="p_context"> static void slab_stats(struct slabinfo *s)</span>
 			s-&gt;alloc_node_mismatch, (s-&gt;alloc_node_mismatch * 100) / total);
 	}
 
<span class="p_del">-	if (s-&gt;cmpxchg_double_fail || s-&gt;cmpxchg_double_cpu_fail)</span>
<span class="p_add">+	if (s-&gt;cmpxchg_double_fail || s-&gt;cmpxchg_double_cpu_fail) {</span>
 		printf(&quot;\nCmpxchg_double Looping\n------------------------\n&quot;);
 		printf(&quot;Locked Cmpxchg Double redos   %lu\nUnlocked Cmpxchg Double redos %lu\n&quot;,
 			s-&gt;cmpxchg_double_fail, s-&gt;cmpxchg_double_cpu_fail);
<span class="p_add">+	}</span>
 }
 
 static void report(struct slabinfo *s)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



