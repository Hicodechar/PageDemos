
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.104 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.104</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 5, 2017, 2:04 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171205140453.GB21479@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10092963/mbox/"
   >mbox</a>
|
   <a href="/patch/10092963/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10092963/">/patch/10092963/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	AC38B6035E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:04:59 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9678420182
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:04:59 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 8AEDF289B2; Tue,  5 Dec 2017 14:04:59 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1CFD720182
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:04:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753279AbdLEOEy (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 5 Dec 2017 09:04:54 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:46290 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752554AbdLEOEq (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 5 Dec 2017 09:04:46 -0500
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 4E22E9AF;
	Tue,  5 Dec 2017 14:04:45 +0000 (UTC)
Date: Tue, 5 Dec 2017 15:04:53 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.104
Message-ID: &lt;20171205140453.GB21479@kroah.com&gt;
References: &lt;20171205140449.GA21479@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171205140449.GA21479@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 5, 2017, 2:04 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f5a51cd7ca49..55500e023f61 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 103</span>
<span class="p_add">+SUBLEVEL = 104</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts b/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts</span>
<span class="p_header">index 5b0430041ec6..fec92cd36ae3 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"></span>
 	interrupts-extended = &lt;&amp;intc 83 &amp;omap3_pmx_core 0x11a&gt;;
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;mmc1_pins &amp;mmc1_cd&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio4 31 IRQ_TYPE_LEVEL_LOW&gt;;		/* gpio127 */</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio4 31 GPIO_ACTIVE_LOW&gt;;		/* gpio127 */</span>
 	vmmc-supply = &lt;&amp;vmmc1&gt;;
 	bus-width = &lt;4&gt;;
 	cap-power-off-card;
<span class="p_header">diff --git a/arch/x86/include/asm/efi.h b/arch/x86/include/asm/efi.h</span>
<span class="p_header">index 0010c78c4998..8fd9e637629a 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/efi.h</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/fpu/api.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_add">+#include &lt;asm/tlb.h&gt;</span>
 
 /*
  * We map the EFI regions needed for runtime services non-contiguously,
<span class="p_chunk">@@ -64,6 +65,17 @@</span> <span class="p_context"> extern u64 asmlinkage efi_call(void *fp, ...);</span>
 
 #define efi_call_phys(f, args...)		efi_call((f), args)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Scratch space used for switching the pagetable in the EFI stub</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct efi_scratch {</span>
<span class="p_add">+	u64	r15;</span>
<span class="p_add">+	u64	prev_cr3;</span>
<span class="p_add">+	pgd_t	*efi_pgt;</span>
<span class="p_add">+	bool	use_pgd;</span>
<span class="p_add">+	u64	phys_stack;</span>
<span class="p_add">+} __packed;</span>
<span class="p_add">+</span>
 #define efi_call_virt(f, ...)						\
 ({									\
 	efi_status_t __s;						\
<span class="p_chunk">@@ -71,7 +83,20 @@</span> <span class="p_context"> extern u64 asmlinkage efi_call(void *fp, ...);</span>
 	efi_sync_low_kernel_mappings();					\
 	preempt_disable();						\
 	__kernel_fpu_begin();						\
<span class="p_add">+									\</span>
<span class="p_add">+	if (efi_scratch.use_pgd) {					\</span>
<span class="p_add">+		efi_scratch.prev_cr3 = read_cr3();			\</span>
<span class="p_add">+		write_cr3((unsigned long)efi_scratch.efi_pgt);		\</span>
<span class="p_add">+		__flush_tlb_all();					\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+									\</span>
 	__s = efi_call((void *)efi.systab-&gt;runtime-&gt;f, __VA_ARGS__);	\
<span class="p_add">+									\</span>
<span class="p_add">+	if (efi_scratch.use_pgd) {					\</span>
<span class="p_add">+		write_cr3(efi_scratch.prev_cr3);			\</span>
<span class="p_add">+		__flush_tlb_all();					\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+									\</span>
 	__kernel_fpu_end();						\
 	preempt_enable();						\
 	__s;								\
<span class="p_chunk">@@ -111,6 +136,7 @@</span> <span class="p_context"> extern void __init efi_memory_uc(u64 addr, unsigned long size);</span>
 extern void __init efi_map_region(efi_memory_desc_t *md);
 extern void __init efi_map_region_fixed(efi_memory_desc_t *md);
 extern void efi_sync_low_kernel_mappings(void);
<span class="p_add">+extern int __init efi_alloc_page_tables(void);</span>
 extern int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages);
 extern void __init old_map_region(efi_memory_desc_t *md);
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 4e1b254c3695..4b1152e57340 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -1696,6 +1696,8 @@</span> <span class="p_context"> static int ud_interception(struct vcpu_svm *svm)</span>
 	int er;
 
 	er = emulate_instruction(&amp;svm-&gt;vcpu, EMULTYPE_TRAP_UD);
<span class="p_add">+	if (er == EMULATE_USER_EXIT)</span>
<span class="p_add">+		return 0;</span>
 	if (er != EMULATE_DONE)
 		kvm_queue_exception(&amp;svm-&gt;vcpu, UD_VECTOR);
 	return 1;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 67ba0d8f87c7..253a8c8207bb 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -5267,6 +5267,8 @@</span> <span class="p_context"> static int handle_exception(struct kvm_vcpu *vcpu)</span>
 			return 1;
 		}
 		er = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);
<span class="p_add">+		if (er == EMULATE_USER_EXIT)</span>
<span class="p_add">+			return 0;</span>
 		if (er != EMULATE_DONE)
 			kvm_queue_exception(vcpu, UD_VECTOR);
 		return 1;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 3ffd5900da5b..df81717a92f3 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -1812,6 +1812,9 @@</span> <span class="p_context"> static int kvm_guest_time_update(struct kvm_vcpu *v)</span>
 	 */
 	BUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);
 
<span class="p_add">+	if (guest_hv_clock.version &amp; 1)</span>
<span class="p_add">+		++guest_hv_clock.version;  /* first time write, random junk */</span>
<span class="p_add">+</span>
 	vcpu-&gt;hv_clock.version = guest_hv_clock.version + 1;
 	kvm_write_guest_cached(v-&gt;kvm, &amp;vcpu-&gt;pv_time,
 				&amp;vcpu-&gt;hv_clock,
<span class="p_chunk">@@ -5426,6 +5429,8 @@</span> <span class="p_context"> int x86_emulate_instruction(struct kvm_vcpu *vcpu,</span>
 			if (reexecute_instruction(vcpu, cr2, write_fault_to_spt,
 						emulation_type))
 				return EMULATE_DONE;
<span class="p_add">+			if (ctxt-&gt;have_exception &amp;&amp; inject_emulated_exception(vcpu))</span>
<span class="p_add">+				return EMULATE_DONE;</span>
 			if (emulation_type &amp; EMULTYPE_SKIP)
 				return EMULATE_FAIL;
 			return handle_emulation_failure(vcpu);
<span class="p_header">diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c</span>
<span class="p_header">index b599a780a5a9..a0fe62e3f4a3 100644</span>
<span class="p_header">--- a/arch/x86/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/x86/mm/pageattr.c</span>
<span class="p_chunk">@@ -911,15 +911,10 @@</span> <span class="p_context"> static void populate_pte(struct cpa_data *cpa,</span>
 	pte = pte_offset_kernel(pmd, start);
 
 	while (num_pages-- &amp;&amp; start &lt; end) {
<span class="p_del">-</span>
<span class="p_del">-		/* deal with the NX bit */</span>
<span class="p_del">-		if (!(pgprot_val(pgprot) &amp; _PAGE_NX))</span>
<span class="p_del">-			cpa-&gt;pfn &amp;= ~_PAGE_NX;</span>
<span class="p_del">-</span>
<span class="p_del">-		set_pte(pte, pfn_pte(cpa-&gt;pfn &gt;&gt; PAGE_SHIFT, pgprot));</span>
<span class="p_add">+		set_pte(pte, pfn_pte(cpa-&gt;pfn, pgprot));</span>
 
 		start	 += PAGE_SIZE;
<span class="p_del">-		cpa-&gt;pfn += PAGE_SIZE;</span>
<span class="p_add">+		cpa-&gt;pfn++;</span>
 		pte++;
 	}
 }
<span class="p_chunk">@@ -975,11 +970,11 @@</span> <span class="p_context"> static int populate_pmd(struct cpa_data *cpa,</span>
 
 		pmd = pmd_offset(pud, start);
 
<span class="p_del">-		set_pmd(pmd, __pmd(cpa-&gt;pfn | _PAGE_PSE |</span>
<span class="p_add">+		set_pmd(pmd, __pmd(cpa-&gt;pfn &lt;&lt; PAGE_SHIFT | _PAGE_PSE |</span>
 				   massage_pgprot(pmd_pgprot)));
 
 		start	  += PMD_SIZE;
<span class="p_del">-		cpa-&gt;pfn  += PMD_SIZE;</span>
<span class="p_add">+		cpa-&gt;pfn  += PMD_SIZE &gt;&gt; PAGE_SHIFT;</span>
 		cur_pages += PMD_SIZE &gt;&gt; PAGE_SHIFT;
 	}
 
<span class="p_chunk">@@ -1048,11 +1043,11 @@</span> <span class="p_context"> static int populate_pud(struct cpa_data *cpa, unsigned long start, pgd_t *pgd,</span>
 	 * Map everything starting from the Gb boundary, possibly with 1G pages
 	 */
 	while (end - start &gt;= PUD_SIZE) {
<span class="p_del">-		set_pud(pud, __pud(cpa-&gt;pfn | _PAGE_PSE |</span>
<span class="p_add">+		set_pud(pud, __pud(cpa-&gt;pfn &lt;&lt; PAGE_SHIFT | _PAGE_PSE |</span>
 				   massage_pgprot(pud_pgprot)));
 
 		start	  += PUD_SIZE;
<span class="p_del">-		cpa-&gt;pfn  += PUD_SIZE;</span>
<span class="p_add">+		cpa-&gt;pfn  += PUD_SIZE &gt;&gt; PAGE_SHIFT;</span>
 		cur_pages += PUD_SIZE &gt;&gt; PAGE_SHIFT;
 		pud++;
 	}
<span class="p_header">diff --git a/arch/x86/platform/efi/efi-bgrt.c b/arch/x86/platform/efi/efi-bgrt.c</span>
<span class="p_header">index ea48449b2e63..64fbc7e33226 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi-bgrt.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi-bgrt.c</span>
<span class="p_chunk">@@ -28,8 +28,7 @@</span> <span class="p_context"> struct bmp_header {</span>
 void __init efi_bgrt_init(void)
 {
 	acpi_status status;
<span class="p_del">-	void __iomem *image;</span>
<span class="p_del">-	bool ioremapped = false;</span>
<span class="p_add">+	void *image;</span>
 	struct bmp_header bmp_header;
 
 	if (acpi_disabled)
<span class="p_chunk">@@ -70,20 +69,14 @@</span> <span class="p_context"> void __init efi_bgrt_init(void)</span>
 		return;
 	}
 
<span class="p_del">-	image = efi_lookup_mapped_addr(bgrt_tab-&gt;image_address);</span>
<span class="p_add">+	image = memremap(bgrt_tab-&gt;image_address, sizeof(bmp_header), MEMREMAP_WB);</span>
 	if (!image) {
<span class="p_del">-		image = early_ioremap(bgrt_tab-&gt;image_address,</span>
<span class="p_del">-				       sizeof(bmp_header));</span>
<span class="p_del">-		ioremapped = true;</span>
<span class="p_del">-		if (!image) {</span>
<span class="p_del">-			pr_err(&quot;Ignoring BGRT: failed to map image header memory\n&quot;);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		pr_err(&quot;Ignoring BGRT: failed to map image header memory\n&quot;);</span>
<span class="p_add">+		return;</span>
 	}
 
<span class="p_del">-	memcpy_fromio(&amp;bmp_header, image, sizeof(bmp_header));</span>
<span class="p_del">-	if (ioremapped)</span>
<span class="p_del">-		early_iounmap(image, sizeof(bmp_header));</span>
<span class="p_add">+	memcpy(&amp;bmp_header, image, sizeof(bmp_header));</span>
<span class="p_add">+	memunmap(image);</span>
 	bgrt_image_size = bmp_header.size;
 
 	bgrt_image = kmalloc(bgrt_image_size, GFP_KERNEL | __GFP_NOWARN);
<span class="p_chunk">@@ -93,18 +86,14 @@</span> <span class="p_context"> void __init efi_bgrt_init(void)</span>
 		return;
 	}
 
<span class="p_del">-	if (ioremapped) {</span>
<span class="p_del">-		image = early_ioremap(bgrt_tab-&gt;image_address,</span>
<span class="p_del">-				       bmp_header.size);</span>
<span class="p_del">-		if (!image) {</span>
<span class="p_del">-			pr_err(&quot;Ignoring BGRT: failed to map image memory\n&quot;);</span>
<span class="p_del">-			kfree(bgrt_image);</span>
<span class="p_del">-			bgrt_image = NULL;</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	image = memremap(bgrt_tab-&gt;image_address, bmp_header.size, MEMREMAP_WB);</span>
<span class="p_add">+	if (!image) {</span>
<span class="p_add">+		pr_err(&quot;Ignoring BGRT: failed to map image memory\n&quot;);</span>
<span class="p_add">+		kfree(bgrt_image);</span>
<span class="p_add">+		bgrt_image = NULL;</span>
<span class="p_add">+		return;</span>
 	}
 
<span class="p_del">-	memcpy_fromio(bgrt_image, image, bgrt_image_size);</span>
<span class="p_del">-	if (ioremapped)</span>
<span class="p_del">-		early_iounmap(image, bmp_header.size);</span>
<span class="p_add">+	memcpy(bgrt_image, image, bgrt_image_size);</span>
<span class="p_add">+	memunmap(image);</span>
 }
<span class="p_header">diff --git a/arch/x86/platform/efi/efi.c b/arch/x86/platform/efi/efi.c</span>
<span class="p_header">index ad285404ea7f..3c1f3cd7b2ba 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi.c</span>
<span class="p_chunk">@@ -869,7 +869,7 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
  * This function will switch the EFI runtime services to virtual mode.
  * Essentially, we look through the EFI memmap and map every region that
  * has the runtime attribute bit set in its memory descriptor into the
<span class="p_del">- * -&gt;trampoline_pgd page table using a top-down VA allocation scheme.</span>
<span class="p_add">+ * efi_pgd page table.</span>
  *
  * The old method which used to update that memory descriptor with the
  * virtual address obtained from ioremap() is still supported when the
<span class="p_chunk">@@ -879,8 +879,8 @@</span> <span class="p_context"> static void __init kexec_enter_virtual_mode(void)</span>
  *
  * The new method does a pagetable switch in a preemption-safe manner
  * so that we&#39;re in a different address space when calling a runtime
<span class="p_del">- * function. For function arguments passing we do copy the PGDs of the</span>
<span class="p_del">- * kernel page table into -&gt;trampoline_pgd prior to each call.</span>
<span class="p_add">+ * function. For function arguments passing we do copy the PUDs of the</span>
<span class="p_add">+ * kernel page table into efi_pgd prior to each call.</span>
  *
  * Specially for kexec boot, efi runtime maps in previous kernel should
  * be passed in via setup_data. In that case runtime ranges will be mapped
<span class="p_chunk">@@ -895,6 +895,12 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 
 	efi.systab = NULL;
 
<span class="p_add">+	if (efi_alloc_page_tables()) {</span>
<span class="p_add">+		pr_err(&quot;Failed to allocate EFI page tables\n&quot;);</span>
<span class="p_add">+		clear_bit(EFI_RUNTIME_SERVICES, &amp;efi.flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	efi_merge_regions();
 	new_memmap = efi_map_regions(&amp;count, &amp;pg_shift);
 	if (!new_memmap) {
<span class="p_chunk">@@ -954,28 +960,11 @@</span> <span class="p_context"> static void __init __efi_enter_virtual_mode(void)</span>
 	efi_runtime_mkexec();
 
 	/*
<span class="p_del">-	 * We mapped the descriptor array into the EFI pagetable above but we&#39;re</span>
<span class="p_del">-	 * not unmapping it here. Here&#39;s why:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We&#39;re copying select PGDs from the kernel page table to the EFI page</span>
<span class="p_del">-	 * table and when we do so and make changes to those PGDs like unmapping</span>
<span class="p_del">-	 * stuff from them, those changes appear in the kernel page table and we</span>
<span class="p_del">-	 * go boom.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * From setup_real_mode():</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * ...</span>
<span class="p_del">-	 * trampoline_pgd[0] = init_level4_pgt[pgd_index(__PAGE_OFFSET)].pgd;</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * In this particular case, our allocation is in PGD 0 of the EFI page</span>
<span class="p_del">-	 * table but we&#39;ve copied that PGD from PGD[272] of the EFI page table:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *	pgd_index(__PAGE_OFFSET = 0xffff880000000000) = 272</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * where the direct memory mapping in kernel space is.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * new_memmap&#39;s VA comes from that direct mapping and thus clearing it,</span>
<span class="p_del">-	 * it would get cleared in the kernel page table too.</span>
<span class="p_add">+	 * We mapped the descriptor array into the EFI pagetable above</span>
<span class="p_add">+	 * but we&#39;re not unmapping it here because if we&#39;re running in</span>
<span class="p_add">+	 * EFI mixed mode we need all of memory to be accessible when</span>
<span class="p_add">+	 * we pass parameters to the EFI runtime services in the</span>
<span class="p_add">+	 * thunking code.</span>
 	 *
 	 * efi_cleanup_page_tables(__pa(new_memmap), 1 &lt;&lt; pg_shift);
 	 */
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_32.c b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">index ed5b67338294..58d669bc8250 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_32.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_32.c</span>
<span class="p_chunk">@@ -38,6 +38,11 @@</span> <span class="p_context"></span>
  * say 0 - 3G.
  */
 
<span class="p_add">+int __init efi_alloc_page_tables(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void efi_sync_low_kernel_mappings(void) {}
 void __init efi_dump_pagetable(void) {}
 int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_64.c b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">index a0ac0f9c307f..18dfaad71c99 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_64.c</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_64.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/fixmap.h&gt;
 #include &lt;asm/realmode.h&gt;
 #include &lt;asm/time.h&gt;
<span class="p_add">+#include &lt;asm/pgalloc.h&gt;</span>
 
 /*
  * We allocate runtime services regions bottom-up, starting from -4G, i.e.
<span class="p_chunk">@@ -47,16 +48,7 @@</span> <span class="p_context"></span>
  */
 static u64 efi_va = EFI_VA_START;
 
<span class="p_del">-/*</span>
<span class="p_del">- * Scratch space used for switching the pagetable in the EFI stub</span>
<span class="p_del">- */</span>
<span class="p_del">-struct efi_scratch {</span>
<span class="p_del">-	u64 r15;</span>
<span class="p_del">-	u64 prev_cr3;</span>
<span class="p_del">-	pgd_t *efi_pgt;</span>
<span class="p_del">-	bool use_pgd;</span>
<span class="p_del">-	u64 phys_stack;</span>
<span class="p_del">-} __packed;</span>
<span class="p_add">+struct efi_scratch efi_scratch;</span>
 
 static void __init early_code_mapping_set_exec(int executable)
 {
<span class="p_chunk">@@ -83,8 +75,11 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 	int pgd;
 	int n_pgds;
 
<span class="p_del">-	if (!efi_enabled(EFI_OLD_MEMMAP))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="p_add">+		save_pgd = (pgd_t *)read_cr3();</span>
<span class="p_add">+		write_cr3((unsigned long)efi_scratch.efi_pgt);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	early_code_mapping_set_exec(1);
 
<span class="p_chunk">@@ -96,6 +91,7 @@</span> <span class="p_context"> pgd_t * __init efi_call_phys_prolog(void)</span>
 		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));
 	}
<span class="p_add">+out:</span>
 	__flush_tlb_all();
 
 	return save_pgd;
<span class="p_chunk">@@ -109,8 +105,11 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	int pgd_idx;
 	int nr_pgds;
 
<span class="p_del">-	if (!save_pgd)</span>
<span class="p_add">+	if (!efi_enabled(EFI_OLD_MEMMAP)) {</span>
<span class="p_add">+		write_cr3((unsigned long)save_pgd);</span>
<span class="p_add">+		__flush_tlb_all();</span>
 		return;
<span class="p_add">+	}</span>
 
 	nr_pgds = DIV_ROUND_UP((max_pfn &lt;&lt; PAGE_SHIFT) , PGDIR_SIZE);
 
<span class="p_chunk">@@ -123,27 +122,97 @@</span> <span class="p_context"> void __init efi_call_phys_epilog(pgd_t *save_pgd)</span>
 	early_code_mapping_set_exec(0);
 }
 
<span class="p_add">+static pgd_t *efi_pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We need our own copy of the higher levels of the page tables</span>
<span class="p_add">+ * because we want to avoid inserting EFI region mappings (EFI_VA_END</span>
<span class="p_add">+ * to EFI_VA_START) into the standard kernel page tables. Everything</span>
<span class="p_add">+ * else can be shared, see efi_sync_low_kernel_mappings().</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __init efi_alloc_page_tables(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	gfp_t gfp_mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (efi_enabled(EFI_OLD_MEMMAP))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	gfp_mask = GFP_KERNEL | __GFP_NOTRACK | __GFP_REPEAT | __GFP_ZERO;</span>
<span class="p_add">+	efi_pgd = (pgd_t *)__get_free_page(gfp_mask);</span>
<span class="p_add">+	if (!efi_pgd)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd = efi_pgd + pgd_index(EFI_VA_END);</span>
<span class="p_add">+</span>
<span class="p_add">+	pud = pud_alloc_one(NULL, 0);</span>
<span class="p_add">+	if (!pud) {</span>
<span class="p_add">+		free_page((unsigned long)efi_pgd);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_populate(NULL, pgd, pud);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Add low kernel mappings for passing arguments to EFI functions.
  */
 void efi_sync_low_kernel_mappings(void)
 {
<span class="p_del">-	unsigned num_pgds;</span>
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_add">+	unsigned num_entries;</span>
<span class="p_add">+	pgd_t *pgd_k, *pgd_efi;</span>
<span class="p_add">+	pud_t *pud_k, *pud_efi;</span>
 
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return;
 
<span class="p_del">-	num_pgds = pgd_index(MODULES_END - 1) - pgd_index(PAGE_OFFSET);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We can share all PGD entries apart from the one entry that</span>
<span class="p_add">+	 * covers the EFI runtime mapping space.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Make sure the EFI runtime region mappings are guaranteed to</span>
<span class="p_add">+	 * only span a single PGD entry and that the entry also maps</span>
<span class="p_add">+	 * other important kernel regions.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON(pgd_index(EFI_VA_END) != pgd_index(MODULES_END));</span>
<span class="p_add">+	BUILD_BUG_ON((EFI_VA_START &amp; PGDIR_MASK) !=</span>
<span class="p_add">+			(EFI_VA_END &amp; PGDIR_MASK));</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_efi = efi_pgd + pgd_index(PAGE_OFFSET);</span>
<span class="p_add">+	pgd_k = pgd_offset_k(PAGE_OFFSET);</span>
 
<span class="p_del">-	memcpy(pgd + pgd_index(PAGE_OFFSET),</span>
<span class="p_del">-		init_mm.pgd + pgd_index(PAGE_OFFSET),</span>
<span class="p_del">-		sizeof(pgd_t) * num_pgds);</span>
<span class="p_add">+	num_entries = pgd_index(EFI_VA_END) - pgd_index(PAGE_OFFSET);</span>
<span class="p_add">+	memcpy(pgd_efi, pgd_k, sizeof(pgd_t) * num_entries);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We share all the PUD entries apart from those that map the</span>
<span class="p_add">+	 * EFI regions. Copy around them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON((EFI_VA_START &amp; ~PUD_MASK) != 0);</span>
<span class="p_add">+	BUILD_BUG_ON((EFI_VA_END &amp; ~PUD_MASK) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_efi = efi_pgd + pgd_index(EFI_VA_END);</span>
<span class="p_add">+	pud_efi = pud_offset(pgd_efi, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_k = pgd_offset_k(EFI_VA_END);</span>
<span class="p_add">+	pud_k = pud_offset(pgd_k, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	num_entries = pud_index(EFI_VA_END);</span>
<span class="p_add">+	memcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);</span>
<span class="p_add">+</span>
<span class="p_add">+	pud_efi = pud_offset(pgd_efi, EFI_VA_START);</span>
<span class="p_add">+	pud_k = pud_offset(pgd_k, EFI_VA_START);</span>
<span class="p_add">+</span>
<span class="p_add">+	num_entries = PTRS_PER_PUD - pud_index(EFI_VA_START);</span>
<span class="p_add">+	memcpy(pud_efi, pud_k, sizeof(pud_t) * num_entries);</span>
 }
 
 int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)
 {
<span class="p_del">-	unsigned long text;</span>
<span class="p_add">+	unsigned long pfn, text;</span>
 	struct page *page;
 	unsigned npages;
 	pgd_t *pgd;
<span class="p_chunk">@@ -151,8 +220,8 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	if (efi_enabled(EFI_OLD_MEMMAP))
 		return 0;
 
<span class="p_del">-	efi_scratch.efi_pgt = (pgd_t *)(unsigned long)real_mode_header-&gt;trampoline_pgd;</span>
<span class="p_del">-	pgd = __va(efi_scratch.efi_pgt);</span>
<span class="p_add">+	efi_scratch.efi_pgt = (pgd_t *)__pa(efi_pgd);</span>
<span class="p_add">+	pgd = efi_pgd;</span>
 
 	/*
 	 * It can happen that the physical address of new_memmap lands in memory
<span class="p_chunk">@@ -160,7 +229,8 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 	 * and ident-map those pages containing the map before calling
 	 * phys_efi_set_virtual_address_map().
 	 */
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, pa_memmap, pa_memmap, num_pages, _PAGE_NX)) {</span>
<span class="p_add">+	pfn = pa_memmap &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, pfn, pa_memmap, num_pages, _PAGE_NX)) {</span>
 		pr_err(&quot;Error ident-mapping new memmap (0x%lx)!\n&quot;, pa_memmap);
 		return 1;
 	}
<span class="p_chunk">@@ -185,8 +255,9 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 
 	npages = (_end - _text) &gt;&gt; PAGE_SHIFT;
 	text = __pa(_text);
<span class="p_add">+	pfn = text &gt;&gt; PAGE_SHIFT;</span>
 
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, text &gt;&gt; PAGE_SHIFT, text, npages, 0)) {</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, pfn, text, npages, 0)) {</span>
 		pr_err(&quot;Failed to map kernel text 1:1\n&quot;);
 		return 1;
 	}
<span class="p_chunk">@@ -196,20 +267,20 @@</span> <span class="p_context"> int __init efi_setup_page_tables(unsigned long pa_memmap, unsigned num_pages)</span>
 
 void __init efi_cleanup_page_tables(unsigned long pa_memmap, unsigned num_pages)
 {
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	kernel_unmap_pages_in_pgd(pgd, pa_memmap, num_pages);</span>
<span class="p_add">+	kernel_unmap_pages_in_pgd(efi_pgd, pa_memmap, num_pages);</span>
 }
 
 static void __init __map_region(efi_memory_desc_t *md, u64 va)
 {
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_del">-	unsigned long pf = 0;</span>
<span class="p_add">+	unsigned long flags = 0;</span>
<span class="p_add">+	unsigned long pfn;</span>
<span class="p_add">+	pgd_t *pgd = efi_pgd;</span>
 
 	if (!(md-&gt;attribute &amp; EFI_MEMORY_WB))
<span class="p_del">-		pf |= _PAGE_PCD;</span>
<span class="p_add">+		flags |= _PAGE_PCD;</span>
 
<span class="p_del">-	if (kernel_map_pages_in_pgd(pgd, md-&gt;phys_addr, va, md-&gt;num_pages, pf))</span>
<span class="p_add">+	pfn = md-&gt;phys_addr &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (kernel_map_pages_in_pgd(pgd, pfn, va, md-&gt;num_pages, flags))</span>
 		pr_warn(&quot;Error mapping PA 0x%llx -&gt; VA 0x%llx!\n&quot;,
 			   md-&gt;phys_addr, va);
 }
<span class="p_chunk">@@ -312,9 +383,7 @@</span> <span class="p_context"> void __init efi_runtime_mkexec(void)</span>
 void __init efi_dump_pagetable(void)
 {
 #ifdef CONFIG_EFI_PGT_DUMP
<span class="p_del">-	pgd_t *pgd = (pgd_t *)__va(real_mode_header-&gt;trampoline_pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-	ptdump_walk_pgd_level(NULL, pgd);</span>
<span class="p_add">+	ptdump_walk_pgd_level(NULL, efi_pgd);</span>
 #endif
 }
 
<span class="p_header">diff --git a/arch/x86/platform/efi/efi_stub_64.S b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">index 86d0f9e08dd9..32020cb8bb08 100644</span>
<span class="p_header">--- a/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_header">+++ b/arch/x86/platform/efi/efi_stub_64.S</span>
<span class="p_chunk">@@ -38,41 +38,6 @@</span> <span class="p_context"></span>
 	mov %rsi, %cr0;			\
 	mov (%rsp), %rsp
 
<span class="p_del">-	/* stolen from gcc */</span>
<span class="p_del">-	.macro FLUSH_TLB_ALL</span>
<span class="p_del">-	movq %r15, efi_scratch(%rip)</span>
<span class="p_del">-	movq %r14, efi_scratch+8(%rip)</span>
<span class="p_del">-	movq %cr4, %r15</span>
<span class="p_del">-	movq %r15, %r14</span>
<span class="p_del">-	andb $0x7f, %r14b</span>
<span class="p_del">-	movq %r14, %cr4</span>
<span class="p_del">-	movq %r15, %cr4</span>
<span class="p_del">-	movq efi_scratch+8(%rip), %r14</span>
<span class="p_del">-	movq efi_scratch(%rip), %r15</span>
<span class="p_del">-	.endm</span>
<span class="p_del">-</span>
<span class="p_del">-	.macro SWITCH_PGT</span>
<span class="p_del">-	cmpb $0, efi_scratch+24(%rip)</span>
<span class="p_del">-	je 1f</span>
<span class="p_del">-	movq %r15, efi_scratch(%rip)		# r15</span>
<span class="p_del">-	# save previous CR3</span>
<span class="p_del">-	movq %cr3, %r15</span>
<span class="p_del">-	movq %r15, efi_scratch+8(%rip)		# prev_cr3</span>
<span class="p_del">-	movq efi_scratch+16(%rip), %r15		# EFI pgt</span>
<span class="p_del">-	movq %r15, %cr3</span>
<span class="p_del">-	1:</span>
<span class="p_del">-	.endm</span>
<span class="p_del">-</span>
<span class="p_del">-	.macro RESTORE_PGT</span>
<span class="p_del">-	cmpb $0, efi_scratch+24(%rip)</span>
<span class="p_del">-	je 2f</span>
<span class="p_del">-	movq efi_scratch+8(%rip), %r15</span>
<span class="p_del">-	movq %r15, %cr3</span>
<span class="p_del">-	movq efi_scratch(%rip), %r15</span>
<span class="p_del">-	FLUSH_TLB_ALL</span>
<span class="p_del">-	2:</span>
<span class="p_del">-	.endm</span>
<span class="p_del">-</span>
 ENTRY(efi_call)
 	SAVE_XMM
 	mov (%rsp), %rax
<span class="p_chunk">@@ -83,16 +48,8 @@</span> <span class="p_context"> ENTRY(efi_call)</span>
 	mov %r8, %r9
 	mov %rcx, %r8
 	mov %rsi, %rcx
<span class="p_del">-	SWITCH_PGT</span>
 	call *%rdi
<span class="p_del">-	RESTORE_PGT</span>
 	addq $48, %rsp
 	RESTORE_XMM
 	ret
 ENDPROC(efi_call)
<span class="p_del">-</span>
<span class="p_del">-	.data</span>
<span class="p_del">-ENTRY(efi_scratch)</span>
<span class="p_del">-	.fill 3,8,0</span>
<span class="p_del">-	.byte 0</span>
<span class="p_del">-	.quad 0</span>
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 3b52677f459a..0cd8f039602e 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -325,38 +325,6 @@</span> <span class="p_context"> u64 __init efi_mem_desc_end(efi_memory_desc_t *md)</span>
 	return end;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * We can&#39;t ioremap data in EFI boot services RAM, because we&#39;ve already mapped</span>
<span class="p_del">- * it as RAM.  So, look it up in the existing EFI memory map instead.  Only</span>
<span class="p_del">- * callable after efi_enter_virtual_mode and before efi_free_boot_services.</span>
<span class="p_del">- */</span>
<span class="p_del">-void __iomem *efi_lookup_mapped_addr(u64 phys_addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct efi_memory_map *map;</span>
<span class="p_del">-	void *p;</span>
<span class="p_del">-	map = efi.memmap;</span>
<span class="p_del">-	if (!map)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	if (WARN_ON(!map-&gt;map))</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	for (p = map-&gt;map; p &lt; map-&gt;map_end; p += map-&gt;desc_size) {</span>
<span class="p_del">-		efi_memory_desc_t *md = p;</span>
<span class="p_del">-		u64 size = md-&gt;num_pages &lt;&lt; EFI_PAGE_SHIFT;</span>
<span class="p_del">-		u64 end = md-&gt;phys_addr + size;</span>
<span class="p_del">-		if (!(md-&gt;attribute &amp; EFI_MEMORY_RUNTIME) &amp;&amp;</span>
<span class="p_del">-		    md-&gt;type != EFI_BOOT_SERVICES_CODE &amp;&amp;</span>
<span class="p_del">-		    md-&gt;type != EFI_BOOT_SERVICES_DATA)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (!md-&gt;virt_addr)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (phys_addr &gt;= md-&gt;phys_addr &amp;&amp; phys_addr &lt; end) {</span>
<span class="p_del">-			phys_addr += md-&gt;virt_addr - md-&gt;phys_addr;</span>
<span class="p_del">-			return (__force void __iomem *)(unsigned long)phys_addr;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static __initdata efi_config_table_type_t common_tables[] = {
 	{ACPI_20_TABLE_GUID, &quot;ACPI 2.0&quot;, &amp;efi.acpi20},
 	{ACPI_TABLE_GUID, &quot;ACPI&quot;, &amp;efi.acpi},
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index f4cae5357e40..3e90ddcbb24a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -1575,34 +1575,32 @@</span> <span class="p_context"> void amdgpu_atombios_scratch_regs_restore(struct amdgpu_device *adev)</span>
 		WREG32(mmBIOS_SCRATCH_0 + i, adev-&gt;bios_scratch[i]);
 }
 
<span class="p_del">-/* Atom needs data in little endian format</span>
<span class="p_del">- * so swap as appropriate when copying data to</span>
<span class="p_del">- * or from atom. Note that atom operates on</span>
<span class="p_del">- * dw units.</span>
<span class="p_add">+/* Atom needs data in little endian format so swap as appropriate when copying</span>
<span class="p_add">+ * data to or from atom. Note that atom operates on dw units.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=true when sending data to atom and provide at least</span>
<span class="p_add">+ * ALIGN(num_bytes,4) bytes in the dst buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=false when receiving data from atom and provide ALIGN(num_bytes,4)</span>
<span class="p_add">+ * byes in the src buffer.</span>
  */
 void amdgpu_atombios_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)
 {
 #ifdef __BIG_ENDIAN
<span class="p_del">-	u8 src_tmp[20], dst_tmp[20]; /* used for byteswapping */</span>
<span class="p_del">-	u32 *dst32, *src32;</span>
<span class="p_add">+	u32 src_tmp[5], dst_tmp[5];</span>
 	int i;
<span class="p_add">+	u8 align_num_bytes = ALIGN(num_bytes, 4);</span>
 
<span class="p_del">-	memcpy(src_tmp, src, num_bytes);</span>
<span class="p_del">-	src32 = (u32 *)src_tmp;</span>
<span class="p_del">-	dst32 = (u32 *)dst_tmp;</span>
 	if (to_le) {
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = cpu_to_le32(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, num_bytes);</span>
<span class="p_add">+		memcpy(src_tmp, src, num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = cpu_to_le32(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, align_num_bytes);</span>
 	} else {
<span class="p_del">-		u8 dws = num_bytes &amp; ~3;</span>
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = le32_to_cpu(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, dws);</span>
<span class="p_del">-		if (num_bytes % 4) {</span>
<span class="p_del">-			for (i = 0; i &lt; (num_bytes % 4); i++)</span>
<span class="p_del">-				dst[dws+i] = dst_tmp[dws+i];</span>
<span class="p_del">-		}</span>
<span class="p_add">+		memcpy(src_tmp, src, align_num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = le32_to_cpu(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, num_bytes);</span>
 	}
 #else
 	memcpy(dst, src, num_bytes);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index f3bee54c414f..cb4313c68f71 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -440,7 +440,9 @@</span> <span class="p_context"> static bool</span>
 gmbus_is_index_read(struct i2c_msg *msgs, int i, int num)
 {
 	return (i + 1 &lt; num &amp;&amp;
<span class="p_del">-		!(msgs[i].flags &amp; I2C_M_RD) &amp;&amp; msgs[i].len &lt;= 2 &amp;&amp;</span>
<span class="p_add">+		msgs[i].addr == msgs[i + 1].addr &amp;&amp;</span>
<span class="p_add">+		!(msgs[i].flags &amp; I2C_M_RD) &amp;&amp;</span>
<span class="p_add">+		(msgs[i].len == 1 || msgs[i].len == 2) &amp;&amp;</span>
 		(msgs[i + 1].flags &amp; I2C_M_RD));
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">index f97b73ec4713..f418c002d323 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_chunk">@@ -352,6 +352,7 @@</span> <span class="p_context"> static int panel_simple_remove(struct device *dev)</span>
 	drm_panel_remove(&amp;panel-&gt;base);
 
 	panel_simple_disable(&amp;panel-&gt;base);
<span class="p_add">+	panel_simple_unprepare(&amp;panel-&gt;base);</span>
 
 	if (panel-&gt;ddc)
 		put_device(&amp;panel-&gt;ddc-&gt;dev);
<span class="p_chunk">@@ -367,6 +368,7 @@</span> <span class="p_context"> static void panel_simple_shutdown(struct device *dev)</span>
 	struct panel_simple *panel = dev_get_drvdata(dev);
 
 	panel_simple_disable(&amp;panel-&gt;base);
<span class="p_add">+	panel_simple_unprepare(&amp;panel-&gt;base);</span>
 }
 
 static const struct drm_display_mode ampire_am800480r3tmqwa1h_mode = {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index b5760851195c..0c6216a6ee9e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -45,34 +45,32 @@</span> <span class="p_context"> static char *pre_emph_names[] = {</span>
 
 /***** radeon AUX functions *****/
 
<span class="p_del">-/* Atom needs data in little endian format</span>
<span class="p_del">- * so swap as appropriate when copying data to</span>
<span class="p_del">- * or from atom. Note that atom operates on</span>
<span class="p_del">- * dw units.</span>
<span class="p_add">+/* Atom needs data in little endian format so swap as appropriate when copying</span>
<span class="p_add">+ * data to or from atom. Note that atom operates on dw units.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=true when sending data to atom and provide at least</span>
<span class="p_add">+ * ALIGN(num_bytes,4) bytes in the dst buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=false when receiving data from atom and provide ALIGN(num_bytes,4)</span>
<span class="p_add">+ * byes in the src buffer.</span>
  */
 void radeon_atom_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)
 {
 #ifdef __BIG_ENDIAN
<span class="p_del">-	u8 src_tmp[20], dst_tmp[20]; /* used for byteswapping */</span>
<span class="p_del">-	u32 *dst32, *src32;</span>
<span class="p_add">+	u32 src_tmp[5], dst_tmp[5];</span>
 	int i;
<span class="p_add">+	u8 align_num_bytes = ALIGN(num_bytes, 4);</span>
 
<span class="p_del">-	memcpy(src_tmp, src, num_bytes);</span>
<span class="p_del">-	src32 = (u32 *)src_tmp;</span>
<span class="p_del">-	dst32 = (u32 *)dst_tmp;</span>
 	if (to_le) {
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = cpu_to_le32(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, num_bytes);</span>
<span class="p_add">+		memcpy(src_tmp, src, num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = cpu_to_le32(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, align_num_bytes);</span>
 	} else {
<span class="p_del">-		u8 dws = num_bytes &amp; ~3;</span>
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = le32_to_cpu(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, dws);</span>
<span class="p_del">-		if (num_bytes % 4) {</span>
<span class="p_del">-			for (i = 0; i &lt; (num_bytes % 4); i++)</span>
<span class="p_del">-				dst[dws+i] = dst_tmp[dws+i];</span>
<span class="p_del">-		}</span>
<span class="p_add">+		memcpy(src_tmp, src, align_num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = le32_to_cpu(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, num_bytes);</span>
 	}
 #else
 	memcpy(dst, src, num_bytes);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_fb.c b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">index 26da2f4d7b4f..a2937a693591 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_chunk">@@ -226,7 +226,6 @@</span> <span class="p_context"> static int radeonfb_create(struct drm_fb_helper *helper,</span>
 	}
 
 	info-&gt;par = rfbdev;
<span class="p_del">-	info-&gt;skip_vt_switch = true;</span>
 
 	ret = radeon_framebuffer_init(rdev-&gt;ddev, &amp;rfbdev-&gt;rfb, &amp;mode_cmd, gobj);
 	if (ret) {
<span class="p_header">diff --git a/drivers/md/bcache/alloc.c b/drivers/md/bcache/alloc.c</span>
<span class="p_header">index ea47980949ef..4d46f2ce606f 100644</span>
<span class="p_header">--- a/drivers/md/bcache/alloc.c</span>
<span class="p_header">+++ b/drivers/md/bcache/alloc.c</span>
<span class="p_chunk">@@ -479,7 +479,7 @@</span> <span class="p_context"> int __bch_bucket_alloc_set(struct cache_set *c, unsigned reserve,</span>
 		if (b == -1)
 			goto err;
 
<span class="p_del">-		k-&gt;ptr[i] = PTR(ca-&gt;buckets[b].gen,</span>
<span class="p_add">+		k-&gt;ptr[i] = MAKE_PTR(ca-&gt;buckets[b].gen,</span>
 				bucket_to_sector(c, b),
 				ca-&gt;sb.nr_this_dev);
 
<span class="p_header">diff --git a/drivers/md/bcache/extents.c b/drivers/md/bcache/extents.c</span>
<span class="p_header">index 243de0bf15cd..4bf15182c4da 100644</span>
<span class="p_header">--- a/drivers/md/bcache/extents.c</span>
<span class="p_header">+++ b/drivers/md/bcache/extents.c</span>
<span class="p_chunk">@@ -584,7 +584,7 @@</span> <span class="p_context"> static bool bch_extent_merge(struct btree_keys *bk, struct bkey *l, struct bkey</span>
 		return false;
 
 	for (i = 0; i &lt; KEY_PTRS(l); i++)
<span class="p_del">-		if (l-&gt;ptr[i] + PTR(0, KEY_SIZE(l), 0) != r-&gt;ptr[i] ||</span>
<span class="p_add">+		if (l-&gt;ptr[i] + MAKE_PTR(0, KEY_SIZE(l), 0) != r-&gt;ptr[i] ||</span>
 		    PTR_BUCKET_NR(b-&gt;c, l, i) != PTR_BUCKET_NR(b-&gt;c, r, i))
 			return false;
 
<span class="p_header">diff --git a/drivers/md/bcache/journal.c b/drivers/md/bcache/journal.c</span>
<span class="p_header">index 29eba7219b01..6ed066a0e7c0 100644</span>
<span class="p_header">--- a/drivers/md/bcache/journal.c</span>
<span class="p_header">+++ b/drivers/md/bcache/journal.c</span>
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> static void journal_reclaim(struct cache_set *c)</span>
 			continue;
 
 		ja-&gt;cur_idx = next;
<span class="p_del">-		k-&gt;ptr[n++] = PTR(0,</span>
<span class="p_add">+		k-&gt;ptr[n++] = MAKE_PTR(0,</span>
 				  bucket_to_sector(c, ca-&gt;sb.d[ja-&gt;cur_idx]),
 				  ca-&gt;sb.nr_this_dev);
 	}
<span class="p_header">diff --git a/drivers/misc/eeprom/at24.c b/drivers/misc/eeprom/at24.c</span>
<span class="p_header">index 5d7c0900fa1b..f112c5bc082a 100644</span>
<span class="p_header">--- a/drivers/misc/eeprom/at24.c</span>
<span class="p_header">+++ b/drivers/misc/eeprom/at24.c</span>
<span class="p_chunk">@@ -257,6 +257,9 @@</span> <span class="p_context"> static ssize_t at24_read(struct at24_data *at24,</span>
 	if (unlikely(!count))
 		return count;
 
<span class="p_add">+	if (off + count &gt; at24-&gt;chip.byte_len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 * Read data from chip, protecting against concurrent updates
 	 * from this host, but not from other I2C masters.
<span class="p_chunk">@@ -311,6 +314,9 @@</span> <span class="p_context"> static ssize_t at24_eeprom_write(struct at24_data *at24, const char *buf,</span>
 	unsigned long timeout, write_time;
 	unsigned next_page;
 
<span class="p_add">+	if (offset + count &gt; at24-&gt;chip.byte_len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Get corresponding I2C address and adjust offset */
 	client = at24_translate_offset(at24, &amp;offset);
 
<span class="p_header">diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c</span>
<span class="p_header">index 972ff844cf5a..cf7c7bc1e940 100644</span>
<span class="p_header">--- a/drivers/mmc/core/bus.c</span>
<span class="p_header">+++ b/drivers/mmc/core/bus.c</span>
<span class="p_chunk">@@ -155,6 +155,9 @@</span> <span class="p_context"> static int mmc_bus_suspend(struct device *dev)</span>
 		return ret;
 
 	ret = host-&gt;bus_ops-&gt;suspend(host);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pm_generic_resume(dev);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 54ab48827258..7ba109e8cf88 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2663,15 +2663,18 @@</span> <span class="p_context"> static int panic_nand_write(struct mtd_info *mtd, loff_t to, size_t len,</span>
 			    size_t *retlen, const uint8_t *buf)
 {
 	struct nand_chip *chip = mtd-&gt;priv;
<span class="p_add">+	int chipnr = (int)(to &gt;&gt; chip-&gt;chip_shift);</span>
 	struct mtd_oob_ops ops;
 	int ret;
 
<span class="p_del">-	/* Wait for the device to get ready */</span>
<span class="p_del">-	panic_nand_wait(mtd, chip, 400);</span>
<span class="p_del">-</span>
 	/* Grab the device */
 	panic_nand_get_device(chip, mtd, FL_WRITING);
 
<span class="p_add">+	chip-&gt;select_chip(mtd, chipnr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for the device to get ready */</span>
<span class="p_add">+	panic_nand_wait(mtd, chip, 400);</span>
<span class="p_add">+</span>
 	memset(&amp;ops, 0, sizeof(ops));
 	ops.len = len;
 	ops.datbuf = (uint8_t *)buf;
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index c36a03fa7678..260f94b019c9 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -3361,13 +3361,6 @@</span> <span class="p_context"> again:</span>
 		goto again;
 	}
 
<span class="p_del">-	/* We&#39;ve already setup this transaction, go ahead and exit */</span>
<span class="p_del">-	if (block_group-&gt;cache_generation == trans-&gt;transid &amp;&amp;</span>
<span class="p_del">-	    i_size_read(inode)) {</span>
<span class="p_del">-		dcs = BTRFS_DC_SETUP;</span>
<span class="p_del">-		goto out_put;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/*
 	 * We want to set the generation to 0, that way if anything goes wrong
 	 * from here on out we know not to trust this cache when we load up next
<span class="p_chunk">@@ -3391,6 +3384,13 @@</span> <span class="p_context"> again:</span>
 	}
 	WARN_ON(ret);
 
<span class="p_add">+	/* We&#39;ve already setup this transaction, go ahead and exit */</span>
<span class="p_add">+	if (block_group-&gt;cache_generation == trans-&gt;transid &amp;&amp;</span>
<span class="p_add">+	    i_size_read(inode)) {</span>
<span class="p_add">+		dcs = BTRFS_DC_SETUP;</span>
<span class="p_add">+		goto out_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (i_size_read(inode) &gt; 0) {
 		ret = btrfs_check_trunc_cache_free_space(root,
 					&amp;root-&gt;fs_info-&gt;global_block_rsv);
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index 348e0a05bd18..44e09483d2cd 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -1260,7 +1260,7 @@</span> <span class="p_context"> static int nfs_weak_revalidate(struct dentry *dentry, unsigned int flags)</span>
 		return 0;
 	}
 
<span class="p_del">-	error = nfs_revalidate_inode(NFS_SERVER(inode), inode);</span>
<span class="p_add">+	error = nfs_lookup_verify_inode(inode, flags);</span>
 	dfprintk(LOOKUPCACHE, &quot;NFS: %s: inode %lu is %s\n&quot;,
 			__func__, inode-&gt;i_ino, error ? &quot;invalid&quot; : &quot;valid&quot;);
 	return !error;
<span class="p_chunk">@@ -1420,6 +1420,7 @@</span> <span class="p_context"> static int nfs4_lookup_revalidate(struct dentry *, unsigned int);</span>
 
 const struct dentry_operations nfs4_dentry_operations = {
 	.d_revalidate	= nfs4_lookup_revalidate,
<span class="p_add">+	.d_weak_revalidate	= nfs_weak_revalidate,</span>
 	.d_delete	= nfs_dentry_delete,
 	.d_iput		= nfs_dentry_iput,
 	.d_automount	= nfs_d_automount,
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index 421935f3d909..11c67e8b939d 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -3379,7 +3379,9 @@</span> <span class="p_context"> nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 		/* ignore lock owners */
 		if (local-&gt;st_stateowner-&gt;so_is_open_owner == 0)
 			continue;
<span class="p_del">-		if (local-&gt;st_stateowner == &amp;oo-&gt;oo_owner) {</span>
<span class="p_add">+		if (local-&gt;st_stateowner != &amp;oo-&gt;oo_owner)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (local-&gt;st_stid.sc_type == NFS4_OPEN_STID) {</span>
 			ret = local;
 			atomic_inc(&amp;ret-&gt;st_stid.sc_count);
 			break;
<span class="p_chunk">@@ -3388,6 +3390,52 @@</span> <span class="p_context"> nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 	return ret;
 }
 
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_verify_open_stid(struct nfs4_stid *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 ret = nfs_ok;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (s-&gt;sc_type) {</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NFS4_CLOSED_STID:</span>
<span class="p_add">+	case NFS4_CLOSED_DELEG_STID:</span>
<span class="p_add">+		ret = nfserr_bad_stateid;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NFS4_REVOKED_DELEG_STID:</span>
<span class="p_add">+		ret = nfserr_deleg_revoked;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Lock the stateid st_mutex, and deal with races with CLOSE */</span>
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_lock_ol_stateid(struct nfs4_ol_stateid *stp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	ret = nfsd4_verify_open_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_add">+	if (ret != nfs_ok)</span>
<span class="p_add">+		mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct nfs4_ol_stateid *</span>
<span class="p_add">+nfsd4_find_and_lock_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs4_ol_stateid *stp;</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		spin_lock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		stp = nfsd4_find_existing_open(fp, open);</span>
<span class="p_add">+		spin_unlock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		if (!stp || nfsd4_lock_ol_stateid(stp) == nfs_ok)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		nfs4_put_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return stp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct nfs4_openowner *
 alloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,
 			   struct nfsd4_compound_state *cstate)
<span class="p_chunk">@@ -3420,23 +3468,27 @@</span> <span class="p_context"> alloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,</span>
 }
 
 static struct nfs4_ol_stateid *
<span class="p_del">-init_open_stateid(struct nfs4_ol_stateid *stp, struct nfs4_file *fp,</span>
<span class="p_del">-		struct nfsd4_open *open)</span>
<span class="p_add">+init_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 {
 
 	struct nfs4_openowner *oo = open-&gt;op_openowner;
 	struct nfs4_ol_stateid *retstp = NULL;
<span class="p_add">+	struct nfs4_ol_stateid *stp;</span>
 
<span class="p_add">+	stp = open-&gt;op_stp;</span>
 	/* We are moving these outside of the spinlocks to avoid the warnings */
 	mutex_init(&amp;stp-&gt;st_mutex);
 	mutex_lock(&amp;stp-&gt;st_mutex);
 
<span class="p_add">+retry:</span>
 	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 	spin_lock(&amp;fp-&gt;fi_lock);
 
 	retstp = nfsd4_find_existing_open(fp, open);
 	if (retstp)
 		goto out_unlock;
<span class="p_add">+</span>
<span class="p_add">+	open-&gt;op_stp = NULL;</span>
 	atomic_inc(&amp;stp-&gt;st_stid.sc_count);
 	stp-&gt;st_stid.sc_type = NFS4_OPEN_STID;
 	INIT_LIST_HEAD(&amp;stp-&gt;st_locks);
<span class="p_chunk">@@ -3453,11 +3505,16 @@</span> <span class="p_context"> out_unlock:</span>
 	spin_unlock(&amp;fp-&gt;fi_lock);
 	spin_unlock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 	if (retstp) {
<span class="p_del">-		mutex_lock(&amp;retstp-&gt;st_mutex);</span>
<span class="p_del">-		/* Not that we need to, just for neatness */</span>
<span class="p_add">+		/* Handle races with CLOSE */</span>
<span class="p_add">+		if (nfsd4_lock_ol_stateid(retstp) != nfs_ok) {</span>
<span class="p_add">+			nfs4_put_stid(&amp;retstp-&gt;st_stid);</span>
<span class="p_add">+			goto retry;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* To keep mutex tracking happy */</span>
 		mutex_unlock(&amp;stp-&gt;st_mutex);
<span class="p_add">+		stp = retstp;</span>
 	}
<span class="p_del">-	return retstp;</span>
<span class="p_add">+	return stp;</span>
 }
 
 /*
<span class="p_chunk">@@ -4260,9 +4317,9 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 	struct nfs4_client *cl = open-&gt;op_openowner-&gt;oo_owner.so_client;
 	struct nfs4_file *fp = NULL;
 	struct nfs4_ol_stateid *stp = NULL;
<span class="p_del">-	struct nfs4_ol_stateid *swapstp = NULL;</span>
 	struct nfs4_delegation *dp = NULL;
 	__be32 status;
<span class="p_add">+	bool new_stp = false;</span>
 
 	/*
 	 * Lookup file; if found, lookup stateid and check open request,
<span class="p_chunk">@@ -4274,9 +4331,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 		status = nfs4_check_deleg(cl, open, &amp;dp);
 		if (status)
 			goto out;
<span class="p_del">-		spin_lock(&amp;fp-&gt;fi_lock);</span>
<span class="p_del">-		stp = nfsd4_find_existing_open(fp, open);</span>
<span class="p_del">-		spin_unlock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		stp = nfsd4_find_and_lock_existing_open(fp, open);</span>
 	} else {
 		open-&gt;op_file = NULL;
 		status = nfserr_bad_stateid;
<span class="p_chunk">@@ -4284,41 +4339,31 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 			goto out;
 	}
 
<span class="p_add">+	if (!stp) {</span>
<span class="p_add">+		stp = init_open_stateid(fp, open);</span>
<span class="p_add">+		if (!open-&gt;op_stp)</span>
<span class="p_add">+			new_stp = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * OPEN the file, or upgrade an existing OPEN.
 	 * If truncate fails, the OPEN fails.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * stp is already locked.</span>
 	 */
<span class="p_del">-	if (stp) {</span>
<span class="p_add">+	if (!new_stp) {</span>
 		/* Stateid was found, this is an OPEN upgrade */
<span class="p_del">-		mutex_lock(&amp;stp-&gt;st_mutex);</span>
 		status = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);
 		if (status) {
 			mutex_unlock(&amp;stp-&gt;st_mutex);
 			goto out;
 		}
 	} else {
<span class="p_del">-		stp = open-&gt;op_stp;</span>
<span class="p_del">-		open-&gt;op_stp = NULL;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * init_open_stateid() either returns a locked stateid</span>
<span class="p_del">-		 * it found, or initializes and locks the new one we passed in</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		swapstp = init_open_stateid(stp, fp, open);</span>
<span class="p_del">-		if (swapstp) {</span>
<span class="p_del">-			nfs4_put_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_del">-			stp = swapstp;</span>
<span class="p_del">-			status = nfs4_upgrade_open(rqstp, fp, current_fh,</span>
<span class="p_del">-						stp, open);</span>
<span class="p_del">-			if (status) {</span>
<span class="p_del">-				mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			goto upgrade_out;</span>
<span class="p_del">-		}</span>
 		status = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);
 		if (status) {
<span class="p_del">-			mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+			stp-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 			release_open_stateid(stp);
<span class="p_add">+			mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 			goto out;
 		}
 
<span class="p_chunk">@@ -4327,7 +4372,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 		if (stp-&gt;st_clnt_odstate == open-&gt;op_odstate)
 			open-&gt;op_odstate = NULL;
 	}
<span class="p_del">-upgrade_out:</span>
<span class="p_add">+</span>
 	nfs4_inc_and_copy_stateid(&amp;open-&gt;op_stateid, &amp;stp-&gt;st_stid);
 	mutex_unlock(&amp;stp-&gt;st_mutex);
 
<span class="p_chunk">@@ -5153,7 +5198,6 @@</span> <span class="p_context"> static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)</span>
 	bool unhashed;
 	LIST_HEAD(reaplist);
 
<span class="p_del">-	s-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 	spin_lock(&amp;clp-&gt;cl_lock);
 	unhashed = unhash_open_stateid(s, &amp;reaplist);
 
<span class="p_chunk">@@ -5192,10 +5236,12 @@</span> <span class="p_context"> nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 	nfsd4_bump_seqid(cstate, status);
 	if (status)
 		goto out; 
<span class="p_add">+</span>
<span class="p_add">+	stp-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 	nfs4_inc_and_copy_stateid(&amp;close-&gt;cl_stateid, &amp;stp-&gt;st_stid);
<span class="p_del">-	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 
 	nfsd4_close_open_stateid(stp);
<span class="p_add">+	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 
 	/* put reference from nfs4_preprocess_seqid_op */
 	nfs4_put_stid(&amp;stp-&gt;st_stid);
<span class="p_header">diff --git a/include/linux/netlink.h b/include/linux/netlink.h</span>
<span class="p_header">index 639e9b8b0e4d..0b41959aab9f 100644</span>
<span class="p_header">--- a/include/linux/netlink.h</span>
<span class="p_header">+++ b/include/linux/netlink.h</span>
<span class="p_chunk">@@ -131,6 +131,7 @@</span> <span class="p_context"> netlink_skb_clone(struct sk_buff *skb, gfp_t gfp_mask)</span>
 struct netlink_callback {
 	struct sk_buff		*skb;
 	const struct nlmsghdr	*nlh;
<span class="p_add">+	int			(*start)(struct netlink_callback *);</span>
 	int			(*dump)(struct sk_buff * skb,
 					struct netlink_callback *cb);
 	int			(*done)(struct netlink_callback *cb);
<span class="p_chunk">@@ -153,6 +154,7 @@</span> <span class="p_context"> struct nlmsghdr *</span>
 __nlmsg_put(struct sk_buff *skb, u32 portid, u32 seq, int type, int len, int flags);
 
 struct netlink_dump_control {
<span class="p_add">+	int (*start)(struct netlink_callback *);</span>
 	int (*dump)(struct sk_buff *skb, struct netlink_callback *);
 	int (*done)(struct netlink_callback *);
 	void *data;
<span class="p_header">diff --git a/include/net/genetlink.h b/include/net/genetlink.h</span>
<span class="p_header">index 1b6b6dcb018d..43c0e771f417 100644</span>
<span class="p_header">--- a/include/net/genetlink.h</span>
<span class="p_header">+++ b/include/net/genetlink.h</span>
<span class="p_chunk">@@ -114,6 +114,7 @@</span> <span class="p_context"> static inline void genl_info_net_set(struct genl_info *info, struct net *net)</span>
  * @flags: flags
  * @policy: attribute validation policy
  * @doit: standard command callback
<span class="p_add">+ * @start: start callback for dumps</span>
  * @dumpit: callback for dumpers
  * @done: completion callback for dumps
  * @ops_list: operations list
<span class="p_chunk">@@ -122,6 +123,7 @@</span> <span class="p_context"> struct genl_ops {</span>
 	const struct nla_policy	*policy;
 	int		       (*doit)(struct sk_buff *skb,
 				       struct genl_info *info);
<span class="p_add">+	int		       (*start)(struct netlink_callback *cb);</span>
 	int		       (*dumpit)(struct sk_buff *skb,
 					 struct netlink_callback *cb);
 	int		       (*done)(struct netlink_callback *cb);
<span class="p_header">diff --git a/include/uapi/linux/bcache.h b/include/uapi/linux/bcache.h</span>
<span class="p_header">index 22b6ad31c706..8562b1cb776b 100644</span>
<span class="p_header">--- a/include/uapi/linux/bcache.h</span>
<span class="p_header">+++ b/include/uapi/linux/bcache.h</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> PTR_FIELD(PTR_GEN,			0,  8)</span>
 
 #define PTR_CHECK_DEV			((1 &lt;&lt; PTR_DEV_BITS) - 1)
 
<span class="p_del">-#define PTR(gen, offset, dev)						\</span>
<span class="p_add">+#define MAKE_PTR(gen, offset, dev)					\</span>
 	((((__u64) dev) &lt;&lt; 51) | ((__u64) offset) &lt;&lt; 8 | gen)
 
 /* Bkey utility code */
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 6c6f5ccfcda1..8f3769ec8575 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1304,17 +1304,11 @@</span> <span class="p_context"> struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,</span>
 	VM_BUG_ON_PAGE(!PageHead(page), page);
 	if (flags &amp; FOLL_TOUCH) {
 		pmd_t _pmd;
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We should set the dirty bit only for FOLL_WRITE but</span>
<span class="p_del">-		 * for now the dirty bit in the pmd is meaningless.</span>
<span class="p_del">-		 * And if the dirty bit will become meaningful and</span>
<span class="p_del">-		 * we&#39;ll only set it with FOLL_WRITE, an atomic</span>
<span class="p_del">-		 * set_bit will be required on the pmd to set the</span>
<span class="p_del">-		 * young bit, instead of the current set_pmd_at.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		_pmd = pmd_mkyoung(pmd_mkdirty(*pmd));</span>
<span class="p_add">+		_pmd = pmd_mkyoung(*pmd);</span>
<span class="p_add">+		if (flags &amp; FOLL_WRITE)</span>
<span class="p_add">+			_pmd = pmd_mkdirty(_pmd);</span>
 		if (pmdp_set_access_flags(vma, addr &amp; HPAGE_PMD_MASK,
<span class="p_del">-					  pmd, _pmd,  1))</span>
<span class="p_add">+					  pmd, _pmd, flags &amp; FOLL_WRITE))</span>
 			update_mmu_cache_pmd(vma, addr, pmd);
 	}
 	if ((flags &amp; FOLL_MLOCK) &amp;&amp; (vma-&gt;vm_flags &amp; VM_LOCKED)) {
<span class="p_header">diff --git a/mm/madvise.c b/mm/madvise.c</span>
<span class="p_header">index c889fcbb530e..2a0f9a4504f1 100644</span>
<span class="p_header">--- a/mm/madvise.c</span>
<span class="p_header">+++ b/mm/madvise.c</span>
<span class="p_chunk">@@ -223,15 +223,14 @@</span> <span class="p_context"> static long madvise_willneed(struct vm_area_struct *vma,</span>
 {
 	struct file *file = vma-&gt;vm_file;
 
<span class="p_add">+	*prev = vma;</span>
 #ifdef CONFIG_SWAP
 	if (!file) {
<span class="p_del">-		*prev = vma;</span>
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file-&gt;f_mapping)) {
<span class="p_del">-		*prev = vma;</span>
 		force_shm_swapin_readahead(vma, start, end,
 					file-&gt;f_mapping);
 		return 0;
<span class="p_chunk">@@ -246,7 +245,6 @@</span> <span class="p_context"> static long madvise_willneed(struct vm_area_struct *vma,</span>
 		return 0;
 	}
 
<span class="p_del">-	*prev = vma;</span>
 	start = ((start - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;
 	if (end &gt; vma-&gt;vm_end)
 		end = vma-&gt;vm_end;
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 9ecdd61c6463..a87afc4f3c91 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2203,6 +2203,7 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 
 	cb = &amp;nlk-&gt;cb;
 	memset(cb, 0, sizeof(*cb));
<span class="p_add">+	cb-&gt;start = control-&gt;start;</span>
 	cb-&gt;dump = control-&gt;dump;
 	cb-&gt;done = control-&gt;done;
 	cb-&gt;nlh = nlh;
<span class="p_chunk">@@ -2216,6 +2217,9 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 
 	mutex_unlock(nlk-&gt;cb_mutex);
 
<span class="p_add">+	if (cb-&gt;start)</span>
<span class="p_add">+		cb-&gt;start(cb);</span>
<span class="p_add">+</span>
 	ret = netlink_dump(sk);
 	sock_put(sk);
 
<span class="p_header">diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c</span>
<span class="p_header">index bc0e504f33a6..8e63662c6fb0 100644</span>
<span class="p_header">--- a/net/netlink/genetlink.c</span>
<span class="p_header">+++ b/net/netlink/genetlink.c</span>
<span class="p_chunk">@@ -513,6 +513,20 @@</span> <span class="p_context"> void *genlmsg_put(struct sk_buff *skb, u32 portid, u32 seq,</span>
 }
 EXPORT_SYMBOL(genlmsg_put);
 
<span class="p_add">+static int genl_lock_start(struct netlink_callback *cb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* our ops are always const - netlink API doesn&#39;t propagate that */</span>
<span class="p_add">+	const struct genl_ops *ops = cb-&gt;data;</span>
<span class="p_add">+	int rc = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ops-&gt;start) {</span>
<span class="p_add">+		genl_lock();</span>
<span class="p_add">+		rc = ops-&gt;start(cb);</span>
<span class="p_add">+		genl_unlock();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int genl_lock_dumpit(struct sk_buff *skb, struct netlink_callback *cb)
 {
 	/* our ops are always const - netlink API doesn&#39;t propagate that */
<span class="p_chunk">@@ -577,6 +591,7 @@</span> <span class="p_context"> static int genl_family_rcv_msg(struct genl_family *family,</span>
 				.module = family-&gt;module,
 				/* we have const, but the netlink API doesn&#39;t */
 				.data = (void *)ops,
<span class="p_add">+				.start = genl_lock_start,</span>
 				.dump = genl_lock_dumpit,
 				.done = genl_lock_done,
 			};
<span class="p_chunk">@@ -588,6 +603,7 @@</span> <span class="p_context"> static int genl_family_rcv_msg(struct genl_family *family,</span>
 		} else {
 			struct netlink_dump_control c = {
 				.module = family-&gt;module,
<span class="p_add">+				.start = ops-&gt;start,</span>
 				.dump = ops-&gt;dumpit,
 				.done = ops-&gt;done,
 			};
<span class="p_header">diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c</span>
<span class="p_header">index 7a5a64e70b4d..76944a4839a5 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_user.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_user.c</span>
<span class="p_chunk">@@ -1652,32 +1652,34 @@</span> <span class="p_context"> static int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr</span>
 
 static int xfrm_dump_policy_done(struct netlink_callback *cb)
 {
<span class="p_del">-	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &amp;cb-&gt;args[1];</span>
<span class="p_add">+	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb-&gt;args;</span>
 	struct net *net = sock_net(cb-&gt;skb-&gt;sk);
 
 	xfrm_policy_walk_done(walk, net);
 	return 0;
 }
 
<span class="p_add">+static int xfrm_dump_policy_start(struct netlink_callback *cb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb-&gt;args;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(*walk) &gt; sizeof(cb-&gt;args));</span>
<span class="p_add">+</span>
<span class="p_add">+	xfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)
 {
 	struct net *net = sock_net(skb-&gt;sk);
<span class="p_del">-	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &amp;cb-&gt;args[1];</span>
<span class="p_add">+	struct xfrm_policy_walk *walk = (struct xfrm_policy_walk *)cb-&gt;args;</span>
 	struct xfrm_dump_info info;
 
<span class="p_del">-	BUILD_BUG_ON(sizeof(struct xfrm_policy_walk) &gt;</span>
<span class="p_del">-		     sizeof(cb-&gt;args) - sizeof(cb-&gt;args[0]));</span>
<span class="p_del">-</span>
 	info.in_skb = cb-&gt;skb;
 	info.out_skb = skb;
 	info.nlmsg_seq = cb-&gt;nlh-&gt;nlmsg_seq;
 	info.nlmsg_flags = NLM_F_MULTI;
 
<span class="p_del">-	if (!cb-&gt;args[0]) {</span>
<span class="p_del">-		cb-&gt;args[0] = 1;</span>
<span class="p_del">-		xfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	(void) xfrm_policy_walk(net, walk, dump_one_policy, &amp;info);
 
 	return skb-&gt;len;
<span class="p_chunk">@@ -2415,6 +2417,7 @@</span> <span class="p_context"> static const struct nla_policy xfrma_spd_policy[XFRMA_SPD_MAX+1] = {</span>
 
 static const struct xfrm_link {
 	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);
<span class="p_add">+	int (*start)(struct netlink_callback *);</span>
 	int (*dump)(struct sk_buff *, struct netlink_callback *);
 	int (*done)(struct netlink_callback *);
 	const struct nla_policy *nla_pol;
<span class="p_chunk">@@ -2428,6 +2431,7 @@</span> <span class="p_context"> static const struct xfrm_link {</span>
 	[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },
 	[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },
 	[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,
<span class="p_add">+						   .start = xfrm_dump_policy_start,</span>
 						   .dump = xfrm_dump_policy,
 						   .done = xfrm_dump_policy_done },
 	[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },
<span class="p_chunk">@@ -2479,6 +2483,7 @@</span> <span class="p_context"> static int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)</span>
 
 		{
 			struct netlink_dump_control c = {
<span class="p_add">+				.start = link-&gt;start,</span>
 				.dump = link-&gt;dump,
 				.done = link-&gt;done,
 			};

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



