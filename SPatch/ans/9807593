
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.11.7 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.11.7</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 24, 2017, 5:12 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170624051241.GB27462@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9807593/mbox/"
   >mbox</a>
|
   <a href="/patch/9807593/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9807593/">/patch/9807593/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	6BAEA603F3 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 24 Jun 2017 05:13:13 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 456902854A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 24 Jun 2017 05:13:13 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 384AD28558; Sat, 24 Jun 2017 05:13:13 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 02BE62854A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 24 Jun 2017 05:13:07 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751373AbdFXFND (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 24 Jun 2017 01:13:03 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:45356 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751314AbdFXFM4 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 24 Jun 2017 01:12:56 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id A9C64415;
	Sat, 24 Jun 2017 05:12:47 +0000 (UTC)
Date: Sat, 24 Jun 2017 07:12:41 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.11.7
Message-ID: &lt;20170624051241.GB27462@kroah.com&gt;
References: &lt;20170624051229.GA27462@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170624051229.GA27462@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 24, 2017, 5:12 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/admin-guide/kernel-parameters.txt b/Documentation/admin-guide/kernel-parameters.txt</span>
<span class="p_header">index facc20a3f962..952319b73e61 100644</span>
<span class="p_header">--- a/Documentation/admin-guide/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/admin-guide/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3779,6 +3779,13 @@</span> <span class="p_context"></span>
 	spia_pedr=
 	spia_peddr=
 
<span class="p_add">+	stack_guard_gap=	[MM]</span>
<span class="p_add">+			override the default stack gap protection. The value</span>
<span class="p_add">+			is in page units and it defines how many pages prior</span>
<span class="p_add">+			to (for stacks growing down) resp. after (for stacks</span>
<span class="p_add">+			growing up) the main stack are reserved for no other</span>
<span class="p_add">+			mapping. Default value is 256 pages.</span>
<span class="p_add">+</span>
 	stacktrace	[FTRACE]
 			Enabled the stack tracer on boot up.
 
<span class="p_header">diff --git a/Documentation/devicetree/bindings/mfd/axp20x.txt b/Documentation/devicetree/bindings/mfd/axp20x.txt</span>
<span class="p_header">index 8f3ad9ab4637..b41d2601c6ba 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/mfd/axp20x.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/mfd/axp20x.txt</span>
<span class="p_chunk">@@ -28,6 +28,9 @@</span> <span class="p_context"> Optional properties:</span>
 		  regulator to drive the OTG VBus, rather then as an input pin
 		  which signals whether the board is driving OTG VBus or not.
 
<span class="p_add">+- x-powers,master-mode: Boolean (axp806 only). Set this when the PMIC is</span>
<span class="p_add">+			wired for master mode. The default is slave mode.</span>
<span class="p_add">+</span>
 - &lt;input&gt;-supply: a phandle to the regulator supply node. May be omitted if
 		  inputs are unregulated, such as using the IPSOUT output
 		  from the PMIC.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index e46e99cbe5d1..1b0fe238d633 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 11
<span class="p_del">-SUBLEVEL = 6</span>
<span class="p_add">+SUBLEVEL = 7</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arc/mm/mmap.c b/arch/arc/mm/mmap.c</span>
<span class="p_header">index 3e25e8d6486b..2e13683dfb24 100644</span>
<span class="p_header">--- a/arch/arc/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arc/mm/mmap.c</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/arm/boot/dts/am335x-sl50.dts b/arch/arm/boot/dts/am335x-sl50.dts</span>
<span class="p_header">index c5d2589c55fc..fc864a855991 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am335x-sl50.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am335x-sl50.dts</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"></span>
 
 	mmc1_pins: pinmux_mmc1_pins {
 		pinctrl-single,pins = &lt;
<span class="p_del">-			AM33XX_IOPAD(0x960, PIN_INPUT | MUX_MODE7)		/* spi0_cs1.gpio0_6 */</span>
<span class="p_add">+			AM33XX_IOPAD(0x96c, PIN_INPUT | MUX_MODE7)		/* uart0_rtsn.gpio1_9 */</span>
 		&gt;;
 	};
 
<span class="p_chunk">@@ -280,10 +280,6 @@</span> <span class="p_context"></span>
 			AM33XX_IOPAD(0x834, PIN_INPUT_PULLUP | MUX_MODE7)	/* nKbdReset - gpmc_ad13.gpio1_13 */
 			AM33XX_IOPAD(0x838, PIN_INPUT_PULLUP | MUX_MODE7)	/* nDispReset - gpmc_ad14.gpio1_14 */
 			AM33XX_IOPAD(0x844, PIN_INPUT_PULLUP | MUX_MODE7)	/* USB1_enPower - gpmc_a1.gpio1_17 */
<span class="p_del">-			/* AVR Programming - SPI Bus (bit bang) - Screen and Keyboard */</span>
<span class="p_del">-			AM33XX_IOPAD(0x954, PIN_INPUT_PULLUP | MUX_MODE7)	/* Kbd/Disp/BattMOSI spi0_d0.gpio0_3 */</span>
<span class="p_del">-			AM33XX_IOPAD(0x958, PIN_INPUT_PULLUP | MUX_MODE7)	/* Kbd/Disp/BattMISO spi0_d1.gpio0_4 */</span>
<span class="p_del">-			AM33XX_IOPAD(0x950, PIN_INPUT_PULLUP | MUX_MODE7)	/* Kbd/Disp/BattSCLK spi0_clk.gpio0_2 */</span>
 			/* PDI Bus - Battery system */
 			AM33XX_IOPAD(0x840, PIN_INPUT_PULLUP | MUX_MODE7)	/* nBattReset  gpmc_a0.gpio1_16 */
 			AM33XX_IOPAD(0x83c, PIN_INPUT_PULLUP | MUX_MODE7)	/* BattPDIData gpmc_ad15.gpio1_15 */
<span class="p_chunk">@@ -384,7 +380,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;mmc1_pins&gt;;
 	bus-width = &lt;4&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio0 6 GPIO_ACTIVE_LOW&gt;;</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio1 9 GPIO_ACTIVE_LOW&gt;;</span>
 	vmmc-supply = &lt;&amp;vmmcsd_fixed&gt;;
 };
 
<span class="p_header">diff --git a/arch/arm/mm/mmap.c b/arch/arm/mm/mmap.c</span>
<span class="p_header">index 2239fde10b80..f0701d8d24df 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmap.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/frv/mm/elf-fdpic.c b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">index da82c25301e7..46aa289c5102 100644</span>
<span class="p_header">--- a/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">+++ b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current-&gt;mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			goto success;
 	}
 
<span class="p_header">diff --git a/arch/mips/boot/Makefile b/arch/mips/boot/Makefile</span>
<span class="p_header">index 2728a9a9c7c5..145b5ce8eb7e 100644</span>
<span class="p_header">--- a/arch/mips/boot/Makefile</span>
<span class="p_header">+++ b/arch/mips/boot/Makefile</span>
<span class="p_chunk">@@ -128,19 +128,19 @@</span> <span class="p_context"> quiet_cmd_cpp_its_S = ITS     $@</span>
 			-DADDR_BITS=$(ADDR_BITS) \
 			-DADDR_CELLS=$(itb_addr_cells)
 
<span class="p_del">-$(obj)/vmlinux.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,none,vmlinux.bin)
 
<span class="p_del">-$(obj)/vmlinux.gz.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.gz.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,gzip,vmlinux.bin.gz)
 
<span class="p_del">-$(obj)/vmlinux.bz2.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.bz2.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX)  FORCE</span>
 	$(call if_changed_dep,cpp_its_S,bzip2,vmlinux.bin.bz2)
 
<span class="p_del">-$(obj)/vmlinux.lzma.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.lzma.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,lzma,vmlinux.bin.lzma)
 
<span class="p_del">-$(obj)/vmlinux.lzo.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.lzo.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,lzo,vmlinux.bin.lzo)
 
 quiet_cmd_itb-image = ITB     $@
<span class="p_header">diff --git a/arch/mips/kernel/branch.c b/arch/mips/kernel/branch.c</span>
<span class="p_header">index b11facd11c9d..f702a459a830 100644</span>
<span class="p_header">--- a/arch/mips/kernel/branch.c</span>
<span class="p_header">+++ b/arch/mips/kernel/branch.c</span>
<span class="p_chunk">@@ -804,8 +804,10 @@</span> <span class="p_context"> int __compute_return_epc_for_insn(struct pt_regs *regs,</span>
 			break;
 		}
 		/* Compact branch: BNEZC || JIALC */
<span class="p_del">-		if (insn.i_format.rs)</span>
<span class="p_add">+		if (!insn.i_format.rs) {</span>
<span class="p_add">+			/* JIALC: set $31/ra */</span>
 			regs-&gt;regs[31] = epc + 4;
<span class="p_add">+		}</span>
 		regs-&gt;cp0_epc += 8;
 		break;
 #endif
<span class="p_header">diff --git a/arch/mips/mm/mmap.c b/arch/mips/mm/mmap.c</span>
<span class="p_header">index 64dd8bdd92c3..28adeabe851f 100644</span>
<span class="p_header">--- a/arch/mips/mm/mmap.c</span>
<span class="p_header">+++ b/arch/mips/mm/mmap.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static unsigned long arch_get_unmapped_area_common(struct file *filp,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">index e5288638a1d9..378a754ca186 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	unsigned long task_size = TASK_SIZE;
 	int do_color_align, last_mmap;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -117,9 +117,10 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		else
 			addr = PAGE_ALIGN(addr);
 
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_chunk">@@ -143,7 +144,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	int do_color_align, last_mmap;
<span class="p_chunk">@@ -177,9 +178,11 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = COLOR_ALIGN(addr, last_mmap, pgoff);
 		else
 			addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/dump_linuxpagetables.c b/arch/powerpc/mm/dump_linuxpagetables.c</span>
<span class="p_header">index 292214afe0f1..e1b6c8bf0627 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/dump_linuxpagetables.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/dump_linuxpagetables.c</span>
<span class="p_chunk">@@ -57,6 +57,8 @@</span> <span class="p_context"> struct pg_state {</span>
 	struct seq_file *seq;
 	const struct addr_marker *marker;
 	unsigned long start_address;
<span class="p_add">+	unsigned long start_pa;</span>
<span class="p_add">+	unsigned long last_pa;</span>
 	unsigned int level;
 	u64 current_flags;
 };
<span class="p_chunk">@@ -253,7 +255,9 @@</span> <span class="p_context"> static void dump_addr(struct pg_state *st, unsigned long addr)</span>
 	const char *unit = units;
 	unsigned long delta;
 
<span class="p_del">-	seq_printf(st-&gt;seq, &quot;0x%016lx-0x%016lx   &quot;, st-&gt;start_address, addr-1);</span>
<span class="p_add">+	seq_printf(st-&gt;seq, &quot;0x%016lx-0x%016lx &quot;, st-&gt;start_address, addr-1);</span>
<span class="p_add">+	seq_printf(st-&gt;seq, &quot;0x%016lx &quot;, st-&gt;start_pa);</span>
<span class="p_add">+</span>
 	delta = (addr - st-&gt;start_address) &gt;&gt; 10;
 	/* Work out what appropriate unit to use */
 	while (!(delta &amp; 1023) &amp;&amp; unit[1]) {
<span class="p_chunk">@@ -268,11 +272,15 @@</span> <span class="p_context"> static void note_page(struct pg_state *st, unsigned long addr,</span>
 	       unsigned int level, u64 val)
 {
 	u64 flag = val &amp; pg_level[level].mask;
<span class="p_add">+	u64 pa = val &amp; PTE_RPN_MASK;</span>
<span class="p_add">+</span>
 	/* At first no level is set */
 	if (!st-&gt;level) {
 		st-&gt;level = level;
 		st-&gt;current_flags = flag;
 		st-&gt;start_address = addr;
<span class="p_add">+		st-&gt;start_pa = pa;</span>
<span class="p_add">+		st-&gt;last_pa = pa;</span>
 		seq_printf(st-&gt;seq, &quot;---[ %s ]---\n&quot;, st-&gt;marker-&gt;name);
 	/*
 	 * Dump the section of virtual memory when:
<span class="p_chunk">@@ -280,9 +288,11 @@</span> <span class="p_context"> static void note_page(struct pg_state *st, unsigned long addr,</span>
 	 *   - we change levels in the tree.
 	 *   - the address is in a different section of memory and is thus
 	 *   used for a different purpose, regardless of the flags.
<span class="p_add">+	 *   - the pa of this page is not adjacent to the last inspected page</span>
 	 */
 	} else if (flag != st-&gt;current_flags || level != st-&gt;level ||
<span class="p_del">-		   addr &gt;= st-&gt;marker[1].start_address) {</span>
<span class="p_add">+		   addr &gt;= st-&gt;marker[1].start_address ||</span>
<span class="p_add">+		   pa != st-&gt;last_pa + PAGE_SIZE) {</span>
 
 		/* Check the PTE flags */
 		if (st-&gt;current_flags) {
<span class="p_chunk">@@ -306,8 +316,12 @@</span> <span class="p_context"> static void note_page(struct pg_state *st, unsigned long addr,</span>
 			seq_printf(st-&gt;seq, &quot;---[ %s ]---\n&quot;, st-&gt;marker-&gt;name);
 		}
 		st-&gt;start_address = addr;
<span class="p_add">+		st-&gt;start_pa = pa;</span>
<span class="p_add">+		st-&gt;last_pa = pa;</span>
 		st-&gt;current_flags = flag;
 		st-&gt;level = level;
<span class="p_add">+	} else {</span>
<span class="p_add">+		st-&gt;last_pa = pa;</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/powerpc/mm/hugetlbpage-radix.c b/arch/powerpc/mm/hugetlbpage-radix.c</span>
<span class="p_header">index 35254a678456..a2b2d97f7eda 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hugetlbpage-radix.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hugetlbpage-radix.c</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> radix__hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	/*
<span class="p_header">diff --git a/arch/powerpc/mm/mmap.c b/arch/powerpc/mm/mmap.c</span>
<span class="p_header">index a5d9ef59debe..04a6493b68ad 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/mmap.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/mmap.c</span>
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> radix__arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> radix__arch_get_unmapped_area_topdown(struct file *filp,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/slice.c b/arch/powerpc/mm/slice.c</span>
<span class="p_header">index 2b27458902ee..c4d5c9c61e0f 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/slice.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/slice.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int slice_area_is_free(struct mm_struct *mm, unsigned long addr,</span>
 	if ((mm-&gt;task_size - len) &lt; addr)
 		return 0;
 	vma = find_vma(mm, addr);
<span class="p_del">-	return (!vma || (addr + len) &lt;= vma-&gt;vm_start);</span>
<span class="p_add">+	return (!vma || (addr + len) &lt;= vm_start_gap(vma));</span>
 }
 
 static int slice_low_has_vma(struct mm_struct *mm, unsigned long slice)
<span class="p_header">diff --git a/arch/s390/mm/mmap.c b/arch/s390/mm/mmap.c</span>
<span class="p_header">index 50618614881f..531e9d5f803a 100644</span>
<span class="p_header">--- a/arch/s390/mm/mmap.c</span>
<span class="p_header">+++ b/arch/s390/mm/mmap.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sh/mm/mmap.c b/arch/sh/mm/mmap.c</span>
<span class="p_header">index 08e7af0be4a7..6a1a1297baae 100644</span>
<span class="p_header">--- a/arch/sh/mm/mmap.c</span>
<span class="p_header">+++ b/arch/sh/mm/mmap.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index ef4520efc813..043544d0cda3 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/mm/hugetlbpage.c b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">index 7c29d38e6b99..88855e383b34 100644</span>
<span class="p_header">--- a/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/tile/mm/hugetlbpage.c b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">index cb10153b5c9f..03e5cc4e76e4 100644</span>
<span class="p_header">--- a/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -233,7 +233,7 @@</span> <span class="p_context"> unsigned long hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (current-&gt;mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/kernel/sys_x86_64.c b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">index 50215a4b9347..3123e6d00a1b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_chunk">@@ -141,7 +141,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (end - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/x86/mm/hugetlbpage.c b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">index c5066a260803..7d09827d7083 100644</span>
<span class="p_header">--- a/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/mm/numa_32.c b/arch/x86/mm/numa_32.c</span>
<span class="p_header">index 6b7ce6279133..aca6295350f3 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa_32.c</span>
<span class="p_chunk">@@ -100,5 +100,6 @@</span> <span class="p_context"> void __init initmem_init(void)</span>
 	printk(KERN_DEBUG &quot;High memory starts at vaddr %08lx\n&quot;,
 			(ulong) pfn_to_kaddr(highstart_pfn));
 
<span class="p_add">+	__vmalloc_start_set = true;</span>
 	setup_bootmem_allocator();
 }
<span class="p_header">diff --git a/arch/xtensa/kernel/syscall.c b/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">index 06937928cb72..74afbf02d07e 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/syscall.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		/* At this point:  (!vmm || addr &lt; vmm-&gt;vm_end). */
 		if (TASK_SIZE - len &lt; addr)
 			return -ENOMEM;
<span class="p_del">-		if (!vmm || addr + len &lt;= vmm-&gt;vm_start)</span>
<span class="p_add">+		if (!vmm || addr + len &lt;= vm_start_gap(vmm))</span>
 			return addr;
 		addr = vmm-&gt;vm_end;
 		if (flags &amp; MAP_SHARED)
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">index 992f7c20760f..88220ff3e1c2 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_chunk">@@ -185,8 +185,8 @@</span> <span class="p_context"> static ssize_t store_down_threshold(struct gov_attr_set *attr_set,</span>
 	int ret;
 	ret = sscanf(buf, &quot;%u&quot;, &amp;input);
 
<span class="p_del">-	/* cannot be lower than 11 otherwise freq will not fall */</span>
<span class="p_del">-	if (ret != 1 || input &lt; 11 || input &gt; 100 ||</span>
<span class="p_add">+	/* cannot be lower than 1 otherwise freq will not fall */</span>
<span class="p_add">+	if (ret != 1 || input &lt; 1 || input &gt; 100 ||</span>
 			input &gt;= dbs_data-&gt;up_threshold)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">index 33541acdf329..b22e5522d630 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_chunk">@@ -1207,8 +1207,11 @@</span> <span class="p_context"> static void dce_v10_0_program_watermarks(struct amdgpu_device *adev,</span>
 	u32 tmp, wm_mask, lb_vblank_lead_lines = 0;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 
 		/* watermark for high clocks */
 		if (adev-&gt;pm.dpm_enabled) {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">index 1388f8a44a2b..f2b2b80b63f7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_chunk">@@ -1176,8 +1176,11 @@</span> <span class="p_context"> static void dce_v11_0_program_watermarks(struct amdgpu_device *adev,</span>
 	u32 tmp, wm_mask, lb_vblank_lead_lines = 0;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 
 		/* watermark for high clocks */
 		if (adev-&gt;pm.dpm_enabled) {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c</span>
<span class="p_header">index ea5365580b2d..89a8113e42e5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c</span>
<span class="p_chunk">@@ -983,8 +983,11 @@</span> <span class="p_context"> static void dce_v6_0_program_watermarks(struct amdgpu_device *adev,</span>
 	fixed20_12 a, b, c;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 		priority_a_cnt = 0;
 		priority_b_cnt = 0;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">index e52fc925b414..daf8e381c563 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_chunk">@@ -1091,8 +1091,11 @@</span> <span class="p_context"> static void dce_v8_0_program_watermarks(struct amdgpu_device *adev,</span>
 	u32 tmp, wm_mask, lb_vblank_lead_lines = 0;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 
 		/* watermark for high clocks */
 		if (adev-&gt;pm.dpm_enabled) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_shrinker.c b/drivers/gpu/drm/i915/i915_gem_shrinker.c</span>
<span class="p_header">index 70b3832a79dd..a08c2b47fbb3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_shrinker.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_shrinker.c</span>
<span class="p_chunk">@@ -59,9 +59,6 @@</span> <span class="p_context"> static void i915_gem_shrinker_unlock(struct drm_device *dev, bool unlock)</span>
 		return;
 
 	mutex_unlock(&amp;dev-&gt;struct_mutex);
<span class="p_del">-</span>
<span class="p_del">-	/* expedite the RCU grace period to free some request slabs */</span>
<span class="p_del">-	synchronize_rcu_expedited();</span>
 }
 
 static bool any_vma_pinned(struct drm_i915_gem_object *obj)
<span class="p_chunk">@@ -271,8 +268,6 @@</span> <span class="p_context"> unsigned long i915_gem_shrink_all(struct drm_i915_private *dev_priv)</span>
 				I915_SHRINK_BOUND |
 				I915_SHRINK_UNBOUND |
 				I915_SHRINK_ACTIVE);
<span class="p_del">-	synchronize_rcu(); /* wait for our earlier RCU delayed slab frees */</span>
<span class="p_del">-</span>
 	return freed;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_pvinfo.h b/drivers/gpu/drm/i915/i915_pvinfo.h</span>
<span class="p_header">index c0cb2974caac..2cfe96d3e5d1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_pvinfo.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_pvinfo.h</span>
<span class="p_chunk">@@ -36,10 +36,6 @@</span> <span class="p_context"></span>
 #define VGT_VERSION_MAJOR 1
 #define VGT_VERSION_MINOR 0
 
<span class="p_del">-#define INTEL_VGT_IF_VERSION_ENCODE(major, minor) ((major) &lt;&lt; 16 | (minor))</span>
<span class="p_del">-#define INTEL_VGT_IF_VERSION \</span>
<span class="p_del">-	INTEL_VGT_IF_VERSION_ENCODE(VGT_VERSION_MAJOR, VGT_VERSION_MINOR)</span>
<span class="p_del">-</span>
 /*
  * notifications from guest to vgpu device model
  */
<span class="p_chunk">@@ -55,8 +51,8 @@</span> <span class="p_context"> enum vgt_g2v_type {</span>
 
 struct vgt_if {
 	u64 magic;		/* VGT_MAGIC */
<span class="p_del">-	uint16_t version_major;</span>
<span class="p_del">-	uint16_t version_minor;</span>
<span class="p_add">+	u16 version_major;</span>
<span class="p_add">+	u16 version_minor;</span>
 	u32 vgt_id;		/* ID of vGT instance */
 	u32 rsv1[12];		/* pad to offset 0x40 */
 	/*
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_vgpu.c b/drivers/gpu/drm/i915/i915_vgpu.c</span>
<span class="p_header">index d0abfd08a01c..2c782510618f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_vgpu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_vgpu.c</span>
<span class="p_chunk">@@ -60,8 +60,8 @@</span> <span class="p_context"></span>
  */
 void i915_check_vgpu(struct drm_i915_private *dev_priv)
 {
<span class="p_del">-	uint64_t magic;</span>
<span class="p_del">-	uint32_t version;</span>
<span class="p_add">+	u64 magic;</span>
<span class="p_add">+	u16 version_major;</span>
 
 	BUILD_BUG_ON(sizeof(struct vgt_if) != VGT_PVINFO_SIZE);
 
<span class="p_chunk">@@ -69,10 +69,8 @@</span> <span class="p_context"> void i915_check_vgpu(struct drm_i915_private *dev_priv)</span>
 	if (magic != VGT_MAGIC)
 		return;
 
<span class="p_del">-	version = INTEL_VGT_IF_VERSION_ENCODE(</span>
<span class="p_del">-		__raw_i915_read16(dev_priv, vgtif_reg(version_major)),</span>
<span class="p_del">-		__raw_i915_read16(dev_priv, vgtif_reg(version_minor)));</span>
<span class="p_del">-	if (version != INTEL_VGT_IF_VERSION) {</span>
<span class="p_add">+	version_major = __raw_i915_read16(dev_priv, vgtif_reg(version_major));</span>
<span class="p_add">+	if (version_major &lt; VGT_VERSION_MAJOR) {</span>
 		DRM_INFO(&quot;VGT interface version mismatch!\n&quot;);
 		return;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 5370dbec7a7d..24cee1d6754c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -4633,7 +4633,7 @@</span> <span class="p_context"> static void cpt_verify_modeset(struct drm_device *dev, int pipe)</span>
 
 static int
 skl_update_scaler(struct intel_crtc_state *crtc_state, bool force_detach,
<span class="p_del">-		  unsigned scaler_user, int *scaler_id, unsigned int rotation,</span>
<span class="p_add">+		  unsigned int scaler_user, int *scaler_id,</span>
 		  int src_w, int src_h, int dst_w, int dst_h)
 {
 	struct intel_crtc_scaler_state *scaler_state =
<span class="p_chunk">@@ -4642,9 +4642,12 @@</span> <span class="p_context"> skl_update_scaler(struct intel_crtc_state *crtc_state, bool force_detach,</span>
 		to_intel_crtc(crtc_state-&gt;base.crtc);
 	int need_scaling;
 
<span class="p_del">-	need_scaling = drm_rotation_90_or_270(rotation) ?</span>
<span class="p_del">-		(src_h != dst_w || src_w != dst_h):</span>
<span class="p_del">-		(src_w != dst_w || src_h != dst_h);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Src coordinates are already rotated by 270 degrees for</span>
<span class="p_add">+	 * the 90/270 degree plane rotation cases (to match the</span>
<span class="p_add">+	 * GTT mapping), hence no need to account for rotation here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_scaling = src_w != dst_w || src_h != dst_h;</span>
 
 	/*
 	 * if plane is being disabled or scaler is no more required or force detach
<span class="p_chunk">@@ -4706,7 +4709,7 @@</span> <span class="p_context"> int skl_update_scaler_crtc(struct intel_crtc_state *state)</span>
 	const struct drm_display_mode *adjusted_mode = &amp;state-&gt;base.adjusted_mode;
 
 	return skl_update_scaler(state, !state-&gt;base.active, SKL_CRTC_INDEX,
<span class="p_del">-		&amp;state-&gt;scaler_state.scaler_id, DRM_ROTATE_0,</span>
<span class="p_add">+		&amp;state-&gt;scaler_state.scaler_id,</span>
 		state-&gt;pipe_src_w, state-&gt;pipe_src_h,
 		adjusted_mode-&gt;crtc_hdisplay, adjusted_mode-&gt;crtc_vdisplay);
 }
<span class="p_chunk">@@ -4735,7 +4738,6 @@</span> <span class="p_context"> static int skl_update_scaler_plane(struct intel_crtc_state *crtc_state,</span>
 	ret = skl_update_scaler(crtc_state, force_detach,
 				drm_plane_index(&amp;intel_plane-&gt;base),
 				&amp;plane_state-&gt;scaler_id,
<span class="p_del">-				plane_state-&gt;base.rotation,</span>
 				drm_rect_width(&amp;plane_state-&gt;base.src) &gt;&gt; 16,
 				drm_rect_height(&amp;plane_state-&gt;base.src) &gt;&gt; 16,
 				drm_rect_width(&amp;plane_state-&gt;base.dst),
<span class="p_header">diff --git a/drivers/gpu/drm/mediatek/mtk_hdmi.c b/drivers/gpu/drm/mediatek/mtk_hdmi.c</span>
<span class="p_header">index c26251260b83..b43aa29d3dac 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/mediatek/mtk_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/mediatek/mtk_hdmi.c</span>
<span class="p_chunk">@@ -1062,7 +1062,7 @@</span> <span class="p_context"> static int mtk_hdmi_setup_vendor_specific_infoframe(struct mtk_hdmi *hdmi,</span>
 	}
 
 	err = hdmi_vendor_infoframe_pack(&amp;frame, buffer, sizeof(buffer));
<span class="p_del">-	if (err) {</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		dev_err(hdmi-&gt;dev, &quot;Failed to pack vendor infoframe: %zd\n&quot;,
 			err);
 		return err;
<span class="p_header">diff --git a/drivers/gpu/drm/mxsfb/mxsfb_crtc.c b/drivers/gpu/drm/mxsfb/mxsfb_crtc.c</span>
<span class="p_header">index 1144e0c9e894..0abe77675b76 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/mxsfb/mxsfb_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/mxsfb/mxsfb_crtc.c</span>
<span class="p_chunk">@@ -35,6 +35,13 @@</span> <span class="p_context"></span>
 #include &quot;mxsfb_drv.h&quot;
 #include &quot;mxsfb_regs.h&quot;
 
<span class="p_add">+#define MXS_SET_ADDR		0x4</span>
<span class="p_add">+#define MXS_CLR_ADDR		0x8</span>
<span class="p_add">+#define MODULE_CLKGATE		BIT(30)</span>
<span class="p_add">+#define MODULE_SFTRST		BIT(31)</span>
<span class="p_add">+/* 1 second delay should be plenty of time for block reset */</span>
<span class="p_add">+#define RESET_TIMEOUT		1000000</span>
<span class="p_add">+</span>
 static u32 set_hsync_pulse_width(struct mxsfb_drm_private *mxsfb, u32 val)
 {
 	return (val &amp; mxsfb-&gt;devdata-&gt;hs_wdth_mask) &lt;&lt;
<span class="p_chunk">@@ -159,6 +166,36 @@</span> <span class="p_context"> static void mxsfb_disable_controller(struct mxsfb_drm_private *mxsfb)</span>
 		clk_disable_unprepare(mxsfb-&gt;clk_disp_axi);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Clear the bit and poll it cleared.  This is usually called with</span>
<span class="p_add">+ * a reset address and mask being either SFTRST(bit 31) or CLKGATE</span>
<span class="p_add">+ * (bit 30).</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int clear_poll_bit(void __iomem *addr, u32 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(mask, addr + MXS_CLR_ADDR);</span>
<span class="p_add">+	return readl_poll_timeout(addr, reg, !(reg &amp; mask), 0, RESET_TIMEOUT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mxsfb_reset_block(void __iomem *reset_addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clear_poll_bit(reset_addr, MODULE_SFTRST);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(MODULE_CLKGATE, reset_addr + MXS_CLR_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clear_poll_bit(reset_addr, MODULE_SFTRST);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return clear_poll_bit(reset_addr, MODULE_CLKGATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void mxsfb_crtc_mode_set_nofb(struct mxsfb_drm_private *mxsfb)
 {
 	struct drm_display_mode *m = &amp;mxsfb-&gt;pipe.crtc.state-&gt;adjusted_mode;
<span class="p_chunk">@@ -173,6 +210,11 @@</span> <span class="p_context"> static void mxsfb_crtc_mode_set_nofb(struct mxsfb_drm_private *mxsfb)</span>
 	 */
 	mxsfb_enable_axi_clk(mxsfb);
 
<span class="p_add">+	/* Mandatory eLCDIF reset as per the Reference Manual */</span>
<span class="p_add">+	err = mxsfb_reset_block(mxsfb-&gt;base);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* Clear the FIFOs */
 	writel(CTRL1_FIFO_CLEAR, mxsfb-&gt;base + LCDC_CTRL1 + REG_SET);
 
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_bo.c b/drivers/gpu/drm/vc4/vc4_bo.c</span>
<span class="p_header">index 3f6704cf6608..ec9023bd935b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_bo.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_bo.c</span>
<span class="p_chunk">@@ -313,6 +313,14 @@</span> <span class="p_context"> void vc4_free_object(struct drm_gem_object *gem_bo)</span>
 		goto out;
 	}
 
<span class="p_add">+	/* If this object was partially constructed but CMA allocation</span>
<span class="p_add">+	 * had failed, just free it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!bo-&gt;base.vaddr) {</span>
<span class="p_add">+		vc4_bo_destroy(bo);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	cache_list = vc4_get_cache_list_for_size(dev, gem_bo-&gt;size);
 	if (!cache_list) {
 		vc4_bo_destroy(bo);
<span class="p_header">diff --git a/drivers/iio/adc/meson_saradc.c b/drivers/iio/adc/meson_saradc.c</span>
<span class="p_header">index 89def6034f40..115445dce6f4 100644</span>
<span class="p_header">--- a/drivers/iio/adc/meson_saradc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/meson_saradc.c</span>
<span class="p_chunk">@@ -440,13 +440,13 @@</span> <span class="p_context"> static void meson_sar_adc_unlock(struct iio_dev *indio_dev)</span>
 static void meson_sar_adc_clear_fifo(struct iio_dev *indio_dev)
 {
 	struct meson_sar_adc_priv *priv = iio_priv(indio_dev);
<span class="p_del">-	int count;</span>
<span class="p_add">+	unsigned int count, tmp;</span>
 
 	for (count = 0; count &lt; MESON_SAR_ADC_MAX_FIFO_SIZE; count++) {
 		if (!meson_sar_adc_get_fifo_count(indio_dev))
 			break;
 
<span class="p_del">-		regmap_read(priv-&gt;regmap, MESON_SAR_ADC_FIFO_RD, 0);</span>
<span class="p_add">+		regmap_read(priv-&gt;regmap, MESON_SAR_ADC_FIFO_RD, &amp;tmp);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">index 4282ceca3d8f..6cbed7eb118a 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_chunk">@@ -614,7 +614,7 @@</span> <span class="p_context"> static int tiadc_probe(struct platform_device *pdev)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	indio_dev = devm_iio_device_alloc(&amp;pdev-&gt;dev, sizeof(*indio_dev));</span>
<span class="p_add">+	indio_dev = devm_iio_device_alloc(&amp;pdev-&gt;dev, sizeof(*adc_dev));</span>
 	if (indio_dev == NULL) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to allocate iio device\n&quot;);
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">index b9fcbf18aa99..5faea370ab57 100644</span>
<span class="p_header">--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"> static const int accel_scale[] = {598, 1196, 2392, 4785};</span>
 static const struct inv_mpu6050_reg_map reg_set_6500 = {
 	.sample_rate_div	= INV_MPU6050_REG_SAMPLE_RATE_DIV,
 	.lpf                    = INV_MPU6050_REG_CONFIG,
<span class="p_add">+	.accel_lpf              = INV_MPU6500_REG_ACCEL_CONFIG_2,</span>
 	.user_ctrl              = INV_MPU6050_REG_USER_CTRL,
 	.fifo_en                = INV_MPU6050_REG_FIFO_EN,
 	.gyro_config            = INV_MPU6050_REG_GYRO_CONFIG,
<span class="p_chunk">@@ -205,6 +206,37 @@</span> <span class="p_context"> int inv_mpu6050_set_power_itg(struct inv_mpu6050_state *st, bool power_on)</span>
 EXPORT_SYMBOL_GPL(inv_mpu6050_set_power_itg);
 
 /**
<span class="p_add">+ *  inv_mpu6050_set_lpf_regs() - set low pass filter registers, chip dependent</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  MPU60xx/MPU9150 use only 1 register for accelerometer + gyroscope</span>
<span class="p_add">+ *  MPU6500 and above have a dedicated register for accelerometer</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int inv_mpu6050_set_lpf_regs(struct inv_mpu6050_state *st,</span>
<span class="p_add">+				    enum inv_mpu6050_filter_e val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+</span>
<span class="p_add">+	result = regmap_write(st-&gt;map, st-&gt;reg-&gt;lpf, val);</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		return result;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (st-&gt;chip_type) {</span>
<span class="p_add">+	case INV_MPU6050:</span>
<span class="p_add">+	case INV_MPU6000:</span>
<span class="p_add">+	case INV_MPU9150:</span>
<span class="p_add">+		/* old chips, nothing to do */</span>
<span class="p_add">+		result = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		/* set accel lpf */</span>
<span class="p_add">+		result = regmap_write(st-&gt;map, st-&gt;reg-&gt;accel_lpf, val);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  *  inv_mpu6050_init_config() - Initialize hardware, disable FIFO.
  *
  *  Initial configuration:
<span class="p_chunk">@@ -227,8 +259,7 @@</span> <span class="p_context"> static int inv_mpu6050_init_config(struct iio_dev *indio_dev)</span>
 	if (result)
 		return result;
 
<span class="p_del">-	d = INV_MPU6050_FILTER_20HZ;</span>
<span class="p_del">-	result = regmap_write(st-&gt;map, st-&gt;reg-&gt;lpf, d);</span>
<span class="p_add">+	result = inv_mpu6050_set_lpf_regs(st, INV_MPU6050_FILTER_20HZ);</span>
 	if (result)
 		return result;
 
<span class="p_chunk">@@ -531,6 +562,8 @@</span> <span class="p_context"> static int inv_mpu6050_write_raw(struct iio_dev *indio_dev,</span>
  *                  would be alising. This function basically search for the
  *                  correct low pass parameters based on the fifo rate, e.g,
  *                  sampling frequency.
<span class="p_add">+ *</span>
<span class="p_add">+ *  lpf is set automatically when setting sampling rate to avoid any aliases.</span>
  */
 static int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)
 {
<span class="p_chunk">@@ -546,7 +579,7 @@</span> <span class="p_context"> static int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)</span>
 	while ((h &lt; hz[i]) &amp;&amp; (i &lt; ARRAY_SIZE(d) - 1))
 		i++;
 	data = d[i];
<span class="p_del">-	result = regmap_write(st-&gt;map, st-&gt;reg-&gt;lpf, data);</span>
<span class="p_add">+	result = inv_mpu6050_set_lpf_regs(st, data);</span>
 	if (result)
 		return result;
 	st-&gt;chip_config.lpf = data;
<span class="p_header">diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h b/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h</span>
<span class="p_header">index f0e8c5dd9fae..d851581bb0b8 100644</span>
<span class="p_header">--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h</span>
<span class="p_header">+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"></span>
  *  struct inv_mpu6050_reg_map - Notable registers.
  *  @sample_rate_div:	Divider applied to gyro output rate.
  *  @lpf:		Configures internal low pass filter.
<span class="p_add">+ *  @accel_lpf:		Configures accelerometer low pass filter.</span>
  *  @user_ctrl:		Enables/resets the FIFO.
  *  @fifo_en:		Determines which data will appear in FIFO.
  *  @gyro_config:	gyro config register.
<span class="p_chunk">@@ -47,6 +48,7 @@</span> <span class="p_context"></span>
 struct inv_mpu6050_reg_map {
 	u8 sample_rate_div;
 	u8 lpf;
<span class="p_add">+	u8 accel_lpf;</span>
 	u8 user_ctrl;
 	u8 fifo_en;
 	u8 gyro_config;
<span class="p_chunk">@@ -187,6 +189,7 @@</span> <span class="p_context"> struct inv_mpu6050_state {</span>
 #define INV_MPU6050_FIFO_THRESHOLD           500
 
 /* mpu6500 registers */
<span class="p_add">+#define INV_MPU6500_REG_ACCEL_CONFIG_2      0x1D</span>
 #define INV_MPU6500_REG_ACCEL_OFFSET        0x77
 
 /* delay time in milliseconds */
<span class="p_header">diff --git a/drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_core.c b/drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_core.c</span>
<span class="p_header">index c92ddcc190e2..463196668c6b 100644</span>
<span class="p_header">--- a/drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/st_lsm6dsx/st_lsm6dsx_core.c</span>
<span class="p_chunk">@@ -298,32 +298,40 @@</span> <span class="p_context"> static int st_lsm6dsx_set_full_scale(struct st_lsm6dsx_sensor *sensor,</span>
 	return 0;
 }
 
<span class="p_del">-static int st_lsm6dsx_set_odr(struct st_lsm6dsx_sensor *sensor, u16 odr)</span>
<span class="p_add">+static int st_lsm6dsx_check_odr(struct st_lsm6dsx_sensor *sensor, u16 odr,</span>
<span class="p_add">+				u8 *val)</span>
 {
<span class="p_del">-	enum st_lsm6dsx_sensor_id id = sensor-&gt;id;</span>
<span class="p_del">-	int i, err;</span>
<span class="p_del">-	u8 val;</span>
<span class="p_add">+	int i;</span>
 
 	for (i = 0; i &lt; ST_LSM6DSX_ODR_LIST_SIZE; i++)
<span class="p_del">-		if (st_lsm6dsx_odr_table[id].odr_avl[i].hz == odr)</span>
<span class="p_add">+		if (st_lsm6dsx_odr_table[sensor-&gt;id].odr_avl[i].hz == odr)</span>
 			break;
 
 	if (i == ST_LSM6DSX_ODR_LIST_SIZE)
 		return -EINVAL;
 
<span class="p_del">-	val = st_lsm6dsx_odr_table[id].odr_avl[i].val;</span>
<span class="p_del">-	err = st_lsm6dsx_write_with_mask(sensor-&gt;hw,</span>
<span class="p_del">-					 st_lsm6dsx_odr_table[id].reg.addr,</span>
<span class="p_del">-					 st_lsm6dsx_odr_table[id].reg.mask,</span>
<span class="p_del">-					 val);</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
<span class="p_add">+	*val = st_lsm6dsx_odr_table[sensor-&gt;id].odr_avl[i].val;</span>
 	sensor-&gt;odr = odr;
 
 	return 0;
 }
 
<span class="p_add">+static int st_lsm6dsx_set_odr(struct st_lsm6dsx_sensor *sensor, u16 odr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	enum st_lsm6dsx_sensor_id id = sensor-&gt;id;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	u8 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = st_lsm6dsx_check_odr(sensor, odr, &amp;val);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return st_lsm6dsx_write_with_mask(sensor-&gt;hw,</span>
<span class="p_add">+					  st_lsm6dsx_odr_table[id].reg.addr,</span>
<span class="p_add">+					  st_lsm6dsx_odr_table[id].reg.mask,</span>
<span class="p_add">+					  val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int st_lsm6dsx_sensor_enable(struct st_lsm6dsx_sensor *sensor)
 {
 	int err;
<span class="p_chunk">@@ -426,9 +434,12 @@</span> <span class="p_context"> static int st_lsm6dsx_write_raw(struct iio_dev *iio_dev,</span>
 	case IIO_CHAN_INFO_SCALE:
 		err = st_lsm6dsx_set_full_scale(sensor, val2);
 		break;
<span class="p_del">-	case IIO_CHAN_INFO_SAMP_FREQ:</span>
<span class="p_del">-		err = st_lsm6dsx_set_odr(sensor, val);</span>
<span class="p_add">+	case IIO_CHAN_INFO_SAMP_FREQ: {</span>
<span class="p_add">+		u8 data;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = st_lsm6dsx_check_odr(sensor, val, &amp;data);</span>
 		break;
<span class="p_add">+	}</span>
 	default:
 		err = -EINVAL;
 		break;
<span class="p_header">diff --git a/drivers/iio/proximity/as3935.c b/drivers/iio/proximity/as3935.c</span>
<span class="p_header">index 268210ea4990..24fb54398a3b 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/as3935.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/as3935.c</span>
<span class="p_chunk">@@ -269,8 +269,6 @@</span> <span class="p_context"> static irqreturn_t as3935_interrupt_handler(int irq, void *private)</span>
 
 static void calibrate_as3935(struct as3935_state *st)
 {
<span class="p_del">-	mutex_lock(&amp;st-&gt;lock);</span>
<span class="p_del">-</span>
 	/* mask disturber interrupt bit */
 	as3935_write(st, AS3935_INT, BIT(5));
 
<span class="p_chunk">@@ -280,8 +278,6 @@</span> <span class="p_context"> static void calibrate_as3935(struct as3935_state *st)</span>
 
 	mdelay(2);
 	as3935_write(st, AS3935_TUNE_CAP, (st-&gt;tune_cap / TUNE_CAP_DIV));
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;st-&gt;lock);</span>
 }
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_chunk">@@ -318,6 +314,8 @@</span> <span class="p_context"> static int as3935_resume(struct device *dev)</span>
 	val &amp;= ~AS3935_AFE_PWR_BIT;
 	ret = as3935_write(st, AS3935_AFE_GAIN, val);
 
<span class="p_add">+	calibrate_as3935(st);</span>
<span class="p_add">+</span>
 err_resume:
 	mutex_unlock(&amp;st-&gt;lock);
 
<span class="p_header">diff --git a/drivers/media/cec/cec-api.c b/drivers/media/cec/cec-api.c</span>
<span class="p_header">index 8950b6c9d6a9..4cd65751cb63 100644</span>
<span class="p_header">--- a/drivers/media/cec/cec-api.c</span>
<span class="p_header">+++ b/drivers/media/cec/cec-api.c</span>
<span class="p_chunk">@@ -267,16 +267,10 @@</span> <span class="p_context"> static long cec_receive(struct cec_adapter *adap, struct cec_fh *fh,</span>
 			bool block, struct cec_msg __user *parg)
 {
 	struct cec_msg msg = {};
<span class="p_del">-	long err = 0;</span>
<span class="p_add">+	long err;</span>
 
 	if (copy_from_user(&amp;msg, parg, sizeof(msg)))
 		return -EFAULT;
<span class="p_del">-	mutex_lock(&amp;adap-&gt;lock);</span>
<span class="p_del">-	if (!adap-&gt;is_configured &amp;&amp; fh-&gt;mode_follower &lt; CEC_MODE_MONITOR)</span>
<span class="p_del">-		err = -ENONET;</span>
<span class="p_del">-	mutex_unlock(&amp;adap-&gt;lock);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
 
 	err = cec_receive_msg(fh, &amp;msg, block);
 	if (err)
<span class="p_header">diff --git a/drivers/media/platform/coda/coda-common.c b/drivers/media/platform/coda/coda-common.c</span>
<span class="p_header">index eb6548f46cba..5024b460fb66 100644</span>
<span class="p_header">--- a/drivers/media/platform/coda/coda-common.c</span>
<span class="p_header">+++ b/drivers/media/platform/coda/coda-common.c</span>
<span class="p_chunk">@@ -2126,7 +2126,12 @@</span> <span class="p_context"> static void coda_fw_callback(const struct firmware *fw, void *context);</span>
 
 static int coda_firmware_request(struct coda_dev *dev)
 {
<span class="p_del">-	char *fw = dev-&gt;devtype-&gt;firmware[dev-&gt;firmware];</span>
<span class="p_add">+	char *fw;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev-&gt;firmware &gt;= ARRAY_SIZE(dev-&gt;devtype-&gt;firmware))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	fw = dev-&gt;devtype-&gt;firmware[dev-&gt;firmware];</span>
 
 	dev_dbg(&amp;dev-&gt;plat_dev-&gt;dev, &quot;requesting firmware &#39;%s&#39; for %s\n&quot;, fw,
 		coda_product_name(dev-&gt;devtype-&gt;product));
<span class="p_chunk">@@ -2142,16 +2147,16 @@</span> <span class="p_context"> static void coda_fw_callback(const struct firmware *fw, void *context)</span>
 	struct platform_device *pdev = dev-&gt;plat_dev;
 	int i, ret;
 
<span class="p_del">-	if (!fw &amp;&amp; dev-&gt;firmware == 1) {</span>
<span class="p_del">-		v4l2_err(&amp;dev-&gt;v4l2_dev, &quot;firmware request failed\n&quot;);</span>
<span class="p_del">-		goto put_pm;</span>
<span class="p_del">-	}</span>
 	if (!fw) {
<span class="p_del">-		dev-&gt;firmware = 1;</span>
<span class="p_del">-		coda_firmware_request(dev);</span>
<span class="p_add">+		dev-&gt;firmware++;</span>
<span class="p_add">+		ret = coda_firmware_request(dev);</span>
<span class="p_add">+		if (ret &lt; 0) {</span>
<span class="p_add">+			v4l2_err(&amp;dev-&gt;v4l2_dev, &quot;firmware request failed\n&quot;);</span>
<span class="p_add">+			goto put_pm;</span>
<span class="p_add">+		}</span>
 		return;
 	}
<span class="p_del">-	if (dev-&gt;firmware == 1) {</span>
<span class="p_add">+	if (dev-&gt;firmware &gt; 0) {</span>
 		/*
 		 * Since we can&#39;t suppress warnings for failed asynchronous
 		 * firmware requests, report that the fallback firmware was
<span class="p_header">diff --git a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">index 4af2fb5c85d5..7252f113df2f 100644</span>
<span class="p_header">--- a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">+++ b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_chunk">@@ -118,15 +118,10 @@</span> <span class="p_context"> int pvr2_eeprom_analyze(struct pvr2_hdw *hdw)</span>
 	memset(&amp;tvdata,0,sizeof(tvdata));
 
 	eeprom = pvr2_eeprom_fetch(hdw);
<span class="p_del">-	if (!eeprom) return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	{</span>
<span class="p_del">-		struct i2c_client fake_client;</span>
<span class="p_del">-		/* Newer version expects a useless client interface */</span>
<span class="p_del">-		fake_client.addr = hdw-&gt;eeprom_addr;</span>
<span class="p_del">-		fake_client.adapter = &amp;hdw-&gt;i2c_adap;</span>
<span class="p_del">-		tveeprom_hauppauge_analog(&amp;fake_client,&amp;tvdata,eeprom);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!eeprom)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	tveeprom_hauppauge_analog(NULL, &amp;tvdata, eeprom);</span>
 
 	trace_eeprom(&quot;eeprom assumed v4l tveeprom module&quot;);
 	trace_eeprom(&quot;eeprom direct call results:&quot;);
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 7c1d390ea438..28e1bf64923e 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -868,7 +868,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(vb2_core_create_bufs);</span>
 
 void *vb2_plane_vaddr(struct vb2_buffer *vb, unsigned int plane_no)
 {
<span class="p_del">-	if (plane_no &gt; vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
<span class="p_add">+	if (plane_no &gt;= vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
 		return NULL;
 
 	return call_ptr_memop(vb, vaddr, vb-&gt;planes[plane_no].mem_priv);
<span class="p_header">diff --git a/drivers/mfd/axp20x.c b/drivers/mfd/axp20x.c</span>
<span class="p_header">index 25115fe2acdf..05129004ed90 100644</span>
<span class="p_header">--- a/drivers/mfd/axp20x.c</span>
<span class="p_header">+++ b/drivers/mfd/axp20x.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 
 #define AXP20X_OFF	0x80
 
<span class="p_add">+#define AXP806_REG_ADDR_EXT_ADDR_MASTER_MODE	0</span>
 #define AXP806_REG_ADDR_EXT_ADDR_SLAVE_MODE	BIT(4)
 
 static const char * const axp20x_model_names[] = {
<span class="p_chunk">@@ -877,15 +878,19 @@</span> <span class="p_context"> int axp20x_device_probe(struct axp20x_dev *axp20x)</span>
 	 * the these device addressing bits (in the upper 4 bits of the
 	 * registers) match.
 	 *
<span class="p_del">-	 * Since we only support an AXP806 chained to an AXP809 in slave</span>
<span class="p_del">-	 * mode, and there isn&#39;t any existing hardware which uses AXP806</span>
<span class="p_del">-	 * in master mode, or has 2 AXP806s in the same system, we can</span>
<span class="p_del">-	 * just program the register address extension to the slave mode</span>
<span class="p_del">-	 * address.</span>
<span class="p_add">+	 * By default we support an AXP806 chained to an AXP809 in slave</span>
<span class="p_add">+	 * mode. Boards which use an AXP806 in master mode can set the</span>
<span class="p_add">+	 * property &quot;x-powers,master-mode&quot; to override the default.</span>
 	 */
<span class="p_del">-	if (axp20x-&gt;variant == AXP806_ID)</span>
<span class="p_del">-		regmap_write(axp20x-&gt;regmap, AXP806_REG_ADDR_EXT,</span>
<span class="p_del">-			     AXP806_REG_ADDR_EXT_ADDR_SLAVE_MODE);</span>
<span class="p_add">+	if (axp20x-&gt;variant == AXP806_ID) {</span>
<span class="p_add">+		if (of_property_read_bool(axp20x-&gt;dev-&gt;of_node,</span>
<span class="p_add">+					  &quot;x-powers,master-mode&quot;))</span>
<span class="p_add">+			regmap_write(axp20x-&gt;regmap, AXP806_REG_ADDR_EXT,</span>
<span class="p_add">+				     AXP806_REG_ADDR_EXT_ADDR_MASTER_MODE);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			regmap_write(axp20x-&gt;regmap, AXP806_REG_ADDR_EXT,</span>
<span class="p_add">+				     AXP806_REG_ADDR_EXT_ADDR_SLAVE_MODE);</span>
<span class="p_add">+	}</span>
 
 	ret = regmap_add_irq_chip(axp20x-&gt;regmap, axp20x-&gt;irq,
 			  IRQF_ONESHOT | IRQF_SHARED | axp20x-&gt;irq_flags,
<span class="p_header">diff --git a/drivers/mfd/motorola-cpcap.c b/drivers/mfd/motorola-cpcap.c</span>
<span class="p_header">index 6aeada7d7ce5..bc26079e9737 100644</span>
<span class="p_header">--- a/drivers/mfd/motorola-cpcap.c</span>
<span class="p_header">+++ b/drivers/mfd/motorola-cpcap.c</span>
<span class="p_chunk">@@ -71,6 +71,7 @@</span> <span class="p_context"> static struct regmap_irq_chip cpcap_irq_chip[CPCAP_NR_IRQ_CHIPS] = {</span>
 		.ack_base = CPCAP_REG_MI1,
 		.mask_base = CPCAP_REG_MIM1,
 		.use_ack = true,
<span class="p_add">+		.ack_invert = true,</span>
 	},
 	{
 		.name = &quot;cpcap-m2&quot;,
<span class="p_chunk">@@ -79,6 +80,7 @@</span> <span class="p_context"> static struct regmap_irq_chip cpcap_irq_chip[CPCAP_NR_IRQ_CHIPS] = {</span>
 		.ack_base = CPCAP_REG_MI2,
 		.mask_base = CPCAP_REG_MIM2,
 		.use_ack = true,
<span class="p_add">+		.ack_invert = true,</span>
 	},
 	{
 		.name = &quot;cpcap1-4&quot;,
<span class="p_chunk">@@ -86,8 +88,8 @@</span> <span class="p_context"> static struct regmap_irq_chip cpcap_irq_chip[CPCAP_NR_IRQ_CHIPS] = {</span>
 		.status_base = CPCAP_REG_INT1,
 		.ack_base = CPCAP_REG_INT1,
 		.mask_base = CPCAP_REG_INTM1,
<span class="p_del">-		.type_base = CPCAP_REG_INTS1,</span>
 		.use_ack = true,
<span class="p_add">+		.ack_invert = true,</span>
 	},
 };
 
<span class="p_chunk">@@ -126,7 +128,7 @@</span> <span class="p_context"> static int cpcap_init_irq_chip(struct cpcap_ddata *cpcap, int irq_chip,</span>
 
 	ret = devm_regmap_add_irq_chip(&amp;cpcap-&gt;spi-&gt;dev, cpcap-&gt;regmap,
 				       cpcap-&gt;spi-&gt;irq,
<span class="p_del">-				       IRQF_TRIGGER_RISING |</span>
<span class="p_add">+				       irq_get_trigger_type(cpcap-&gt;spi-&gt;irq) |</span>
 				       IRQF_SHARED, -1,
 				       chip, &amp;cpcap-&gt;irqdata[irq_chip]);
 	if (ret) {
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index 1aa74c4c3ced..9d167c9af2c6 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -377,8 +377,8 @@</span> <span class="p_context"> int omap_tll_init(struct usbhs_omap_platform_data *pdata)</span>
 				 * and use SDR Mode
 				 */
 				reg &amp;= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
<span class="p_del">-					| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF</span>
 					| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
<span class="p_add">+				reg |= OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;</span>
 			} else if (pdata-&gt;port_mode[i] ==
 					OMAP_EHCI_PORT_MODE_HSIC) {
 				/*
<span class="p_header">diff --git a/drivers/misc/c2port/c2port-duramar2150.c b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">index 5484301d57d9..3dc61ea7dc64 100644</span>
<span class="p_header">--- a/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">+++ b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_chunk">@@ -129,8 +129,8 @@</span> <span class="p_context"> static int __init duramar2150_c2port_init(void)</span>
 
 	duramar2150_c2port_dev = c2port_device_register(&quot;uc&quot;,
 					&amp;duramar2150_c2port_ops, NULL);
<span class="p_del">-	if (!duramar2150_c2port_dev) {</span>
<span class="p_del">-		ret = -ENODEV;</span>
<span class="p_add">+	if (IS_ERR(duramar2150_c2port_dev)) {</span>
<span class="p_add">+		ret = PTR_ERR(duramar2150_c2port_dev);</span>
 		goto free_region;
 	}
 
<span class="p_header">diff --git a/drivers/mtd/maps/Makefile b/drivers/mtd/maps/Makefile</span>
<span class="p_header">index aef1846b4de2..5a09a72ab112 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/Makefile</span>
<span class="p_header">+++ b/drivers/mtd/maps/Makefile</span>
<span class="p_chunk">@@ -17,12 +17,10 @@</span> <span class="p_context"> obj-$(CONFIG_MTD_CK804XROM)	+= ck804xrom.o</span>
 obj-$(CONFIG_MTD_TSUNAMI)	+= tsunami_flash.o
 obj-$(CONFIG_MTD_PXA2XX)	+= pxa2xx-flash.o
 obj-$(CONFIG_MTD_PHYSMAP)	+= physmap.o
<span class="p_del">-ifdef CONFIG_MTD_PHYSMAP_OF_VERSATILE</span>
<span class="p_del">-physmap_of-objs += physmap_of_versatile.o</span>
<span class="p_del">-endif</span>
<span class="p_del">-ifdef CONFIG_MTD_PHYSMAP_OF_GEMINI</span>
<span class="p_del">-physmap_of-objs += physmap_of_gemini.o</span>
<span class="p_del">-endif</span>
<span class="p_add">+physmap_of-objs-y		+= physmap_of_core.o</span>
<span class="p_add">+physmap_of-objs-$(CONFIG_MTD_PHYSMAP_OF_VERSATILE) += physmap_of_versatile.o</span>
<span class="p_add">+physmap_of-objs-$(CONFIG_MTD_PHYSMAP_OF_GEMINI) += physmap_of_gemini.o</span>
<span class="p_add">+physmap_of-objs			:= $(physmap_of-objs-y)</span>
 obj-$(CONFIG_MTD_PHYSMAP_OF)	+= physmap_of.o
 obj-$(CONFIG_MTD_PISMO)		+= pismo.o
 obj-$(CONFIG_MTD_PMC_MSP_EVM)   += pmcmsp-flash.o
<span class="p_header">diff --git a/drivers/mtd/maps/physmap_of.c b/drivers/mtd/maps/physmap_of.c</span>
deleted file mode 100644
<span class="p_header">index 14e8909c9955..000000000000</span>
<span class="p_header">--- a/drivers/mtd/maps/physmap_of.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,389 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Flash mappings described by the OF (or flattened) device tree</span>
<span class="p_del">- *</span>
<span class="p_del">- * Copyright (C) 2006 MontaVista Software Inc.</span>
<span class="p_del">- * Author: Vitaly Wool &lt;vwool@ru.mvista.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * Revised to handle newer style flash binding by:</span>
<span class="p_del">- *   Copyright (C) 2007 David Gibson, IBM Corporation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute  it and/or modify it</span>
<span class="p_del">- * under  the terms of  the GNU General  Public License as published by the</span>
<span class="p_del">- * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_del">- * option) any later version.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/types.h&gt;</span>
<span class="p_del">-#include &lt;linux/device.h&gt;</span>
<span class="p_del">-#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="p_del">-#include &lt;linux/mtd/map.h&gt;</span>
<span class="p_del">-#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="p_del">-#include &lt;linux/mtd/concat.h&gt;</span>
<span class="p_del">-#include &lt;linux/of.h&gt;</span>
<span class="p_del">-#include &lt;linux/of_address.h&gt;</span>
<span class="p_del">-#include &lt;linux/of_platform.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-#include &quot;physmap_of_gemini.h&quot;</span>
<span class="p_del">-#include &quot;physmap_of_versatile.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-struct of_flash_list {</span>
<span class="p_del">-	struct mtd_info *mtd;</span>
<span class="p_del">-	struct map_info map;</span>
<span class="p_del">-	struct resource *res;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct of_flash {</span>
<span class="p_del">-	struct mtd_info		*cmtd;</span>
<span class="p_del">-	int list_size; /* number of elements in of_flash_list */</span>
<span class="p_del">-	struct of_flash_list	list[0];</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int of_flash_remove(struct platform_device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct of_flash *info;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	info = dev_get_drvdata(&amp;dev-&gt;dev);</span>
<span class="p_del">-	if (!info)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	dev_set_drvdata(&amp;dev-&gt;dev, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (info-&gt;cmtd) {</span>
<span class="p_del">-		mtd_device_unregister(info-&gt;cmtd);</span>
<span class="p_del">-		if (info-&gt;cmtd != info-&gt;list[0].mtd)</span>
<span class="p_del">-			mtd_concat_destroy(info-&gt;cmtd);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; info-&gt;list_size; i++) {</span>
<span class="p_del">-		if (info-&gt;list[i].mtd)</span>
<span class="p_del">-			map_destroy(info-&gt;list[i].mtd);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (info-&gt;list[i].map.virt)</span>
<span class="p_del">-			iounmap(info-&gt;list[i].map.virt);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (info-&gt;list[i].res) {</span>
<span class="p_del">-			release_resource(info-&gt;list[i].res);</span>
<span class="p_del">-			kfree(info-&gt;list[i].res);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const char * const rom_probe_types[] = {</span>
<span class="p_del">-	&quot;cfi_probe&quot;, &quot;jedec_probe&quot;, &quot;map_rom&quot; };</span>
<span class="p_del">-</span>
<span class="p_del">-/* Helper function to handle probing of the obsolete &quot;direct-mapped&quot;</span>
<span class="p_del">- * compatible binding, which has an extra &quot;probe-type&quot; property</span>
<span class="p_del">- * describing the type of flash probe necessary. */</span>
<span class="p_del">-static struct mtd_info *obsolete_probe(struct platform_device *dev,</span>
<span class="p_del">-				       struct map_info *map)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct device_node *dp = dev-&gt;dev.of_node;</span>
<span class="p_del">-	const char *of_probe;</span>
<span class="p_del">-	struct mtd_info *mtd;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_warn(&amp;dev-&gt;dev, &quot;Device tree uses obsolete \&quot;direct-mapped\&quot; &quot;</span>
<span class="p_del">-		 &quot;flash binding\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	of_probe = of_get_property(dp, &quot;probe-type&quot;, NULL);</span>
<span class="p_del">-	if (!of_probe) {</span>
<span class="p_del">-		for (i = 0; i &lt; ARRAY_SIZE(rom_probe_types); i++) {</span>
<span class="p_del">-			mtd = do_map_probe(rom_probe_types[i], map);</span>
<span class="p_del">-			if (mtd)</span>
<span class="p_del">-				return mtd;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	} else if (strcmp(of_probe, &quot;CFI&quot;) == 0) {</span>
<span class="p_del">-		return do_map_probe(&quot;cfi_probe&quot;, map);</span>
<span class="p_del">-	} else if (strcmp(of_probe, &quot;JEDEC&quot;) == 0) {</span>
<span class="p_del">-		return do_map_probe(&quot;jedec_probe&quot;, map);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (strcmp(of_probe, &quot;ROM&quot;) != 0)</span>
<span class="p_del">-			dev_warn(&amp;dev-&gt;dev, &quot;obsolete_probe: don&#39;t know probe &quot;</span>
<span class="p_del">-				 &quot;type &#39;%s&#39;, mapping as rom\n&quot;, of_probe);</span>
<span class="p_del">-		return do_map_probe(&quot;map_rom&quot;, map);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* When partitions are set we look for a linux,part-probe property which</span>
<span class="p_del">-   specifies the list of partition probers to use. If none is given then the</span>
<span class="p_del">-   default is use. These take precedence over other device tree</span>
<span class="p_del">-   information. */</span>
<span class="p_del">-static const char * const part_probe_types_def[] = {</span>
<span class="p_del">-	&quot;cmdlinepart&quot;, &quot;RedBoot&quot;, &quot;ofpart&quot;, &quot;ofoldpart&quot;, NULL };</span>
<span class="p_del">-</span>
<span class="p_del">-static const char * const *of_get_probes(struct device_node *dp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const char *cp;</span>
<span class="p_del">-	int cplen;</span>
<span class="p_del">-	unsigned int l;</span>
<span class="p_del">-	unsigned int count;</span>
<span class="p_del">-	const char **res;</span>
<span class="p_del">-</span>
<span class="p_del">-	cp = of_get_property(dp, &quot;linux,part-probe&quot;, &amp;cplen);</span>
<span class="p_del">-	if (cp == NULL)</span>
<span class="p_del">-		return part_probe_types_def;</span>
<span class="p_del">-</span>
<span class="p_del">-	count = 0;</span>
<span class="p_del">-	for (l = 0; l != cplen; l++)</span>
<span class="p_del">-		if (cp[l] == 0)</span>
<span class="p_del">-			count++;</span>
<span class="p_del">-</span>
<span class="p_del">-	res = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);</span>
<span class="p_del">-	if (!res)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-	count = 0;</span>
<span class="p_del">-	while (cplen &gt; 0) {</span>
<span class="p_del">-		res[count] = cp;</span>
<span class="p_del">-		l = strlen(cp) + 1;</span>
<span class="p_del">-		cp += l;</span>
<span class="p_del">-		cplen -= l;</span>
<span class="p_del">-		count++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return res;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void of_free_probes(const char * const *probes)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (probes != part_probe_types_def)</span>
<span class="p_del">-		kfree(probes);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct of_device_id of_flash_match[];</span>
<span class="p_del">-static int of_flash_probe(struct platform_device *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const char * const *part_probe_types;</span>
<span class="p_del">-	const struct of_device_id *match;</span>
<span class="p_del">-	struct device_node *dp = dev-&gt;dev.of_node;</span>
<span class="p_del">-	struct resource res;</span>
<span class="p_del">-	struct of_flash *info;</span>
<span class="p_del">-	const char *probe_type;</span>
<span class="p_del">-	const __be32 *width;</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-	int count;</span>
<span class="p_del">-	const __be32 *p;</span>
<span class="p_del">-	int reg_tuple_size;</span>
<span class="p_del">-	struct mtd_info **mtd_list = NULL;</span>
<span class="p_del">-	resource_size_t res_size;</span>
<span class="p_del">-	bool map_indirect;</span>
<span class="p_del">-	const char *mtd_name = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	match = of_match_device(of_flash_match, &amp;dev-&gt;dev);</span>
<span class="p_del">-	if (!match)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	probe_type = match-&gt;data;</span>
<span class="p_del">-</span>
<span class="p_del">-	reg_tuple_size = (of_n_addr_cells(dp) + of_n_size_cells(dp)) * sizeof(u32);</span>
<span class="p_del">-</span>
<span class="p_del">-	of_property_read_string(dp, &quot;linux,mtd-name&quot;, &amp;mtd_name);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Get number of &quot;reg&quot; tuples. Scan for MTD devices on area&#39;s</span>
<span class="p_del">-	 * described by each &quot;reg&quot; region. This makes it possible (including</span>
<span class="p_del">-	 * the concat support) to support the Intel P30 48F4400 chips which</span>
<span class="p_del">-	 * consists internally of 2 non-identical NOR chips on one die.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	p = of_get_property(dp, &quot;reg&quot;, &amp;count);</span>
<span class="p_del">-	if (!p || count % reg_tuple_size != 0) {</span>
<span class="p_del">-		dev_err(&amp;dev-&gt;dev, &quot;Malformed reg property on %s\n&quot;,</span>
<span class="p_del">-				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_del">-		err = -EINVAL;</span>
<span class="p_del">-		goto err_flash_remove;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	count /= reg_tuple_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	map_indirect = of_property_read_bool(dp, &quot;no-unaligned-direct-access&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	err = -ENOMEM;</span>
<span class="p_del">-	info = devm_kzalloc(&amp;dev-&gt;dev,</span>
<span class="p_del">-			    sizeof(struct of_flash) +</span>
<span class="p_del">-			    sizeof(struct of_flash_list) * count, GFP_KERNEL);</span>
<span class="p_del">-	if (!info)</span>
<span class="p_del">-		goto err_flash_remove;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_set_drvdata(&amp;dev-&gt;dev, info);</span>
<span class="p_del">-</span>
<span class="p_del">-	mtd_list = kzalloc(sizeof(*mtd_list) * count, GFP_KERNEL);</span>
<span class="p_del">-	if (!mtd_list)</span>
<span class="p_del">-		goto err_flash_remove;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; count; i++) {</span>
<span class="p_del">-		err = -ENXIO;</span>
<span class="p_del">-		if (of_address_to_resource(dp, i, &amp;res)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Continue with next register tuple if this</span>
<span class="p_del">-			 * one is not mappable</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		dev_dbg(&amp;dev-&gt;dev, &quot;of_flash device: %pR\n&quot;, &amp;res);</span>
<span class="p_del">-</span>
<span class="p_del">-		err = -EBUSY;</span>
<span class="p_del">-		res_size = resource_size(&amp;res);</span>
<span class="p_del">-		info-&gt;list[i].res = request_mem_region(res.start, res_size,</span>
<span class="p_del">-						       dev_name(&amp;dev-&gt;dev));</span>
<span class="p_del">-		if (!info-&gt;list[i].res)</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-</span>
<span class="p_del">-		err = -ENXIO;</span>
<span class="p_del">-		width = of_get_property(dp, &quot;bank-width&quot;, NULL);</span>
<span class="p_del">-		if (!width) {</span>
<span class="p_del">-			dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get bank width from device&quot;</span>
<span class="p_del">-				&quot; tree\n&quot;);</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		info-&gt;list[i].map.name = mtd_name ?: dev_name(&amp;dev-&gt;dev);</span>
<span class="p_del">-		info-&gt;list[i].map.phys = res.start;</span>
<span class="p_del">-		info-&gt;list[i].map.size = res_size;</span>
<span class="p_del">-		info-&gt;list[i].map.bankwidth = be32_to_cpup(width);</span>
<span class="p_del">-		info-&gt;list[i].map.device_node = dp;</span>
<span class="p_del">-</span>
<span class="p_del">-		err = of_flash_probe_gemini(dev, dp, &amp;info-&gt;list[i].map);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-		err = of_flash_probe_versatile(dev, dp, &amp;info-&gt;list[i].map);</span>
<span class="p_del">-		if (err)</span>
<span class="p_del">-			return err;</span>
<span class="p_del">-</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		info-&gt;list[i].map.virt = ioremap(info-&gt;list[i].map.phys,</span>
<span class="p_del">-						 info-&gt;list[i].map.size);</span>
<span class="p_del">-		if (!info-&gt;list[i].map.virt) {</span>
<span class="p_del">-			dev_err(&amp;dev-&gt;dev, &quot;Failed to ioremap() flash&quot;</span>
<span class="p_del">-				&quot; region\n&quot;);</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		simple_map_init(&amp;info-&gt;list[i].map);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * On some platforms (e.g. MPC5200) a direct 1:1 mapping</span>
<span class="p_del">-		 * may cause problems with JFFS2 usage, as the local bus (LPB)</span>
<span class="p_del">-		 * doesn&#39;t support unaligned accesses as implemented in the</span>
<span class="p_del">-		 * JFFS2 code via memcpy(). By setting NO_XIP, the</span>
<span class="p_del">-		 * flash will not be exposed directly to the MTD users</span>
<span class="p_del">-		 * (e.g. JFFS2) any more.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (map_indirect)</span>
<span class="p_del">-			info-&gt;list[i].map.phys = NO_XIP;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (probe_type) {</span>
<span class="p_del">-			info-&gt;list[i].mtd = do_map_probe(probe_type,</span>
<span class="p_del">-							 &amp;info-&gt;list[i].map);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			info-&gt;list[i].mtd = obsolete_probe(dev,</span>
<span class="p_del">-							   &amp;info-&gt;list[i].map);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Fall back to mapping region as ROM */</span>
<span class="p_del">-		if (!info-&gt;list[i].mtd) {</span>
<span class="p_del">-			dev_warn(&amp;dev-&gt;dev,</span>
<span class="p_del">-				&quot;do_map_probe() failed for type %s\n&quot;,</span>
<span class="p_del">-				 probe_type);</span>
<span class="p_del">-</span>
<span class="p_del">-			info-&gt;list[i].mtd = do_map_probe(&quot;map_rom&quot;,</span>
<span class="p_del">-							 &amp;info-&gt;list[i].map);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		mtd_list[i] = info-&gt;list[i].mtd;</span>
<span class="p_del">-</span>
<span class="p_del">-		err = -ENXIO;</span>
<span class="p_del">-		if (!info-&gt;list[i].mtd) {</span>
<span class="p_del">-			dev_err(&amp;dev-&gt;dev, &quot;do_map_probe() failed\n&quot;);</span>
<span class="p_del">-			goto err_out;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			info-&gt;list_size++;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		info-&gt;list[i].mtd-&gt;dev.parent = &amp;dev-&gt;dev;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	err = 0;</span>
<span class="p_del">-	info-&gt;cmtd = NULL;</span>
<span class="p_del">-	if (info-&gt;list_size == 1) {</span>
<span class="p_del">-		info-&gt;cmtd = info-&gt;list[0].mtd;</span>
<span class="p_del">-	} else if (info-&gt;list_size &gt; 1) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We detected multiple devices. Concatenate them together.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		info-&gt;cmtd = mtd_concat_create(mtd_list, info-&gt;list_size,</span>
<span class="p_del">-					       dev_name(&amp;dev-&gt;dev));</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (info-&gt;cmtd == NULL)</span>
<span class="p_del">-		err = -ENXIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto err_out;</span>
<span class="p_del">-</span>
<span class="p_del">-	info-&gt;cmtd-&gt;dev.parent = &amp;dev-&gt;dev;</span>
<span class="p_del">-	mtd_set_of_node(info-&gt;cmtd, dp);</span>
<span class="p_del">-	part_probe_types = of_get_probes(dp);</span>
<span class="p_del">-	if (!part_probe_types) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		goto err_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mtd_device_parse_register(info-&gt;cmtd, part_probe_types, NULL,</span>
<span class="p_del">-			NULL, 0);</span>
<span class="p_del">-	of_free_probes(part_probe_types);</span>
<span class="p_del">-</span>
<span class="p_del">-	kfree(mtd_list);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-err_out:</span>
<span class="p_del">-	kfree(mtd_list);</span>
<span class="p_del">-err_flash_remove:</span>
<span class="p_del">-	of_flash_remove(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	return err;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct of_device_id of_flash_match[] = {</span>
<span class="p_del">-	{</span>
<span class="p_del">-		.compatible	= &quot;cfi-flash&quot;,</span>
<span class="p_del">-		.data		= (void *)&quot;cfi_probe&quot;,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
<span class="p_del">-		/* FIXME: JEDEC chips can&#39;t be safely and reliably</span>
<span class="p_del">-		 * probed, although the mtd code gets it right in</span>
<span class="p_del">-		 * practice most of the time.  We should use the</span>
<span class="p_del">-		 * vendor and device ids specified by the binding to</span>
<span class="p_del">-		 * bypass the heuristic probe code, but the mtd layer</span>
<span class="p_del">-		 * provides, at present, no interface for doing so</span>
<span class="p_del">-		 * :(. */</span>
<span class="p_del">-		.compatible	= &quot;jedec-flash&quot;,</span>
<span class="p_del">-		.data		= (void *)&quot;jedec_probe&quot;,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
<span class="p_del">-		.compatible     = &quot;mtd-ram&quot;,</span>
<span class="p_del">-		.data           = (void *)&quot;map_ram&quot;,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
<span class="p_del">-		.compatible     = &quot;mtd-rom&quot;,</span>
<span class="p_del">-		.data           = (void *)&quot;map_rom&quot;,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
<span class="p_del">-		.type		= &quot;rom&quot;,</span>
<span class="p_del">-		.compatible	= &quot;direct-mapped&quot;</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{ },</span>
<span class="p_del">-};</span>
<span class="p_del">-MODULE_DEVICE_TABLE(of, of_flash_match);</span>
<span class="p_del">-</span>
<span class="p_del">-static struct platform_driver of_flash_driver = {</span>
<span class="p_del">-	.driver = {</span>
<span class="p_del">-		.name = &quot;of-flash&quot;,</span>
<span class="p_del">-		.of_match_table = of_flash_match,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	.probe		= of_flash_probe,</span>
<span class="p_del">-	.remove		= of_flash_remove,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-module_platform_driver(of_flash_driver);</span>
<span class="p_del">-</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_del">-MODULE_AUTHOR(&quot;Vitaly Wool &lt;vwool@ru.mvista.com&gt;&quot;);</span>
<span class="p_del">-MODULE_DESCRIPTION(&quot;Device tree based MTD map driver&quot;);</span>
<span class="p_header">diff --git a/drivers/mtd/maps/physmap_of_core.c b/drivers/mtd/maps/physmap_of_core.c</span>
new file mode 100644
<span class="p_header">index 000000000000..14e8909c9955</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/mtd/maps/physmap_of_core.c</span>
<span class="p_chunk">@@ -0,0 +1,389 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Flash mappings described by the OF (or flattened) device tree</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2006 MontaVista Software Inc.</span>
<span class="p_add">+ * Author: Vitaly Wool &lt;vwool@ru.mvista.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Revised to handle newer style flash binding by:</span>
<span class="p_add">+ *   Copyright (C) 2007 David Gibson, IBM Corporation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute  it and/or modify it</span>
<span class="p_add">+ * under  the terms of  the GNU General  Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;linux/device.h&gt;</span>
<span class="p_add">+#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="p_add">+#include &lt;linux/mtd/map.h&gt;</span>
<span class="p_add">+#include &lt;linux/mtd/partitions.h&gt;</span>
<span class="p_add">+#include &lt;linux/mtd/concat.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &quot;physmap_of_gemini.h&quot;</span>
<span class="p_add">+#include &quot;physmap_of_versatile.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+struct of_flash_list {</span>
<span class="p_add">+	struct mtd_info *mtd;</span>
<span class="p_add">+	struct map_info map;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct of_flash {</span>
<span class="p_add">+	struct mtd_info		*cmtd;</span>
<span class="p_add">+	int list_size; /* number of elements in of_flash_list */</span>
<span class="p_add">+	struct of_flash_list	list[0];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int of_flash_remove(struct platform_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct of_flash *info;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	info = dev_get_drvdata(&amp;dev-&gt;dev);</span>
<span class="p_add">+	if (!info)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	dev_set_drvdata(&amp;dev-&gt;dev, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (info-&gt;cmtd) {</span>
<span class="p_add">+		mtd_device_unregister(info-&gt;cmtd);</span>
<span class="p_add">+		if (info-&gt;cmtd != info-&gt;list[0].mtd)</span>
<span class="p_add">+			mtd_concat_destroy(info-&gt;cmtd);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; info-&gt;list_size; i++) {</span>
<span class="p_add">+		if (info-&gt;list[i].mtd)</span>
<span class="p_add">+			map_destroy(info-&gt;list[i].mtd);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (info-&gt;list[i].map.virt)</span>
<span class="p_add">+			iounmap(info-&gt;list[i].map.virt);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (info-&gt;list[i].res) {</span>
<span class="p_add">+			release_resource(info-&gt;list[i].res);</span>
<span class="p_add">+			kfree(info-&gt;list[i].res);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const rom_probe_types[] = {</span>
<span class="p_add">+	&quot;cfi_probe&quot;, &quot;jedec_probe&quot;, &quot;map_rom&quot; };</span>
<span class="p_add">+</span>
<span class="p_add">+/* Helper function to handle probing of the obsolete &quot;direct-mapped&quot;</span>
<span class="p_add">+ * compatible binding, which has an extra &quot;probe-type&quot; property</span>
<span class="p_add">+ * describing the type of flash probe necessary. */</span>
<span class="p_add">+static struct mtd_info *obsolete_probe(struct platform_device *dev,</span>
<span class="p_add">+				       struct map_info *map)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dp = dev-&gt;dev.of_node;</span>
<span class="p_add">+	const char *of_probe;</span>
<span class="p_add">+	struct mtd_info *mtd;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_warn(&amp;dev-&gt;dev, &quot;Device tree uses obsolete \&quot;direct-mapped\&quot; &quot;</span>
<span class="p_add">+		 &quot;flash binding\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	of_probe = of_get_property(dp, &quot;probe-type&quot;, NULL);</span>
<span class="p_add">+	if (!of_probe) {</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(rom_probe_types); i++) {</span>
<span class="p_add">+			mtd = do_map_probe(rom_probe_types[i], map);</span>
<span class="p_add">+			if (mtd)</span>
<span class="p_add">+				return mtd;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	} else if (strcmp(of_probe, &quot;CFI&quot;) == 0) {</span>
<span class="p_add">+		return do_map_probe(&quot;cfi_probe&quot;, map);</span>
<span class="p_add">+	} else if (strcmp(of_probe, &quot;JEDEC&quot;) == 0) {</span>
<span class="p_add">+		return do_map_probe(&quot;jedec_probe&quot;, map);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (strcmp(of_probe, &quot;ROM&quot;) != 0)</span>
<span class="p_add">+			dev_warn(&amp;dev-&gt;dev, &quot;obsolete_probe: don&#39;t know probe &quot;</span>
<span class="p_add">+				 &quot;type &#39;%s&#39;, mapping as rom\n&quot;, of_probe);</span>
<span class="p_add">+		return do_map_probe(&quot;map_rom&quot;, map);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* When partitions are set we look for a linux,part-probe property which</span>
<span class="p_add">+   specifies the list of partition probers to use. If none is given then the</span>
<span class="p_add">+   default is use. These take precedence over other device tree</span>
<span class="p_add">+   information. */</span>
<span class="p_add">+static const char * const part_probe_types_def[] = {</span>
<span class="p_add">+	&quot;cmdlinepart&quot;, &quot;RedBoot&quot;, &quot;ofpart&quot;, &quot;ofoldpart&quot;, NULL };</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const *of_get_probes(struct device_node *dp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char *cp;</span>
<span class="p_add">+	int cplen;</span>
<span class="p_add">+	unsigned int l;</span>
<span class="p_add">+	unsigned int count;</span>
<span class="p_add">+	const char **res;</span>
<span class="p_add">+</span>
<span class="p_add">+	cp = of_get_property(dp, &quot;linux,part-probe&quot;, &amp;cplen);</span>
<span class="p_add">+	if (cp == NULL)</span>
<span class="p_add">+		return part_probe_types_def;</span>
<span class="p_add">+</span>
<span class="p_add">+	count = 0;</span>
<span class="p_add">+	for (l = 0; l != cplen; l++)</span>
<span class="p_add">+		if (cp[l] == 0)</span>
<span class="p_add">+			count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = kzalloc((count + 1)*sizeof(*res), GFP_KERNEL);</span>
<span class="p_add">+	if (!res)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	count = 0;</span>
<span class="p_add">+	while (cplen &gt; 0) {</span>
<span class="p_add">+		res[count] = cp;</span>
<span class="p_add">+		l = strlen(cp) + 1;</span>
<span class="p_add">+		cp += l;</span>
<span class="p_add">+		cplen -= l;</span>
<span class="p_add">+		count++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void of_free_probes(const char * const *probes)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (probes != part_probe_types_def)</span>
<span class="p_add">+		kfree(probes);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id of_flash_match[];</span>
<span class="p_add">+static int of_flash_probe(struct platform_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char * const *part_probe_types;</span>
<span class="p_add">+	const struct of_device_id *match;</span>
<span class="p_add">+	struct device_node *dp = dev-&gt;dev.of_node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	struct of_flash *info;</span>
<span class="p_add">+	const char *probe_type;</span>
<span class="p_add">+	const __be32 *width;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int count;</span>
<span class="p_add">+	const __be32 *p;</span>
<span class="p_add">+	int reg_tuple_size;</span>
<span class="p_add">+	struct mtd_info **mtd_list = NULL;</span>
<span class="p_add">+	resource_size_t res_size;</span>
<span class="p_add">+	bool map_indirect;</span>
<span class="p_add">+	const char *mtd_name = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	match = of_match_device(of_flash_match, &amp;dev-&gt;dev);</span>
<span class="p_add">+	if (!match)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	probe_type = match-&gt;data;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg_tuple_size = (of_n_addr_cells(dp) + of_n_size_cells(dp)) * sizeof(u32);</span>
<span class="p_add">+</span>
<span class="p_add">+	of_property_read_string(dp, &quot;linux,mtd-name&quot;, &amp;mtd_name);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Get number of &quot;reg&quot; tuples. Scan for MTD devices on area&#39;s</span>
<span class="p_add">+	 * described by each &quot;reg&quot; region. This makes it possible (including</span>
<span class="p_add">+	 * the concat support) to support the Intel P30 48F4400 chips which</span>
<span class="p_add">+	 * consists internally of 2 non-identical NOR chips on one die.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	p = of_get_property(dp, &quot;reg&quot;, &amp;count);</span>
<span class="p_add">+	if (!p || count % reg_tuple_size != 0) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;dev, &quot;Malformed reg property on %s\n&quot;,</span>
<span class="p_add">+				dev-&gt;dev.of_node-&gt;full_name);</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		goto err_flash_remove;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	count /= reg_tuple_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	map_indirect = of_property_read_bool(dp, &quot;no-unaligned-direct-access&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = -ENOMEM;</span>
<span class="p_add">+	info = devm_kzalloc(&amp;dev-&gt;dev,</span>
<span class="p_add">+			    sizeof(struct of_flash) +</span>
<span class="p_add">+			    sizeof(struct of_flash_list) * count, GFP_KERNEL);</span>
<span class="p_add">+	if (!info)</span>
<span class="p_add">+		goto err_flash_remove;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_set_drvdata(&amp;dev-&gt;dev, info);</span>
<span class="p_add">+</span>
<span class="p_add">+	mtd_list = kzalloc(sizeof(*mtd_list) * count, GFP_KERNEL);</span>
<span class="p_add">+	if (!mtd_list)</span>
<span class="p_add">+		goto err_flash_remove;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; count; i++) {</span>
<span class="p_add">+		err = -ENXIO;</span>
<span class="p_add">+		if (of_address_to_resource(dp, i, &amp;res)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Continue with next register tuple if this</span>
<span class="p_add">+			 * one is not mappable</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(&amp;dev-&gt;dev, &quot;of_flash device: %pR\n&quot;, &amp;res);</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+		res_size = resource_size(&amp;res);</span>
<span class="p_add">+		info-&gt;list[i].res = request_mem_region(res.start, res_size,</span>
<span class="p_add">+						       dev_name(&amp;dev-&gt;dev));</span>
<span class="p_add">+		if (!info-&gt;list[i].res)</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -ENXIO;</span>
<span class="p_add">+		width = of_get_property(dp, &quot;bank-width&quot;, NULL);</span>
<span class="p_add">+		if (!width) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;Can&#39;t get bank width from device&quot;</span>
<span class="p_add">+				&quot; tree\n&quot;);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		info-&gt;list[i].map.name = mtd_name ?: dev_name(&amp;dev-&gt;dev);</span>
<span class="p_add">+		info-&gt;list[i].map.phys = res.start;</span>
<span class="p_add">+		info-&gt;list[i].map.size = res_size;</span>
<span class="p_add">+		info-&gt;list[i].map.bankwidth = be32_to_cpup(width);</span>
<span class="p_add">+		info-&gt;list[i].map.device_node = dp;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = of_flash_probe_gemini(dev, dp, &amp;info-&gt;list[i].map);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		err = of_flash_probe_versatile(dev, dp, &amp;info-&gt;list[i].map);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		info-&gt;list[i].map.virt = ioremap(info-&gt;list[i].map.phys,</span>
<span class="p_add">+						 info-&gt;list[i].map.size);</span>
<span class="p_add">+		if (!info-&gt;list[i].map.virt) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;Failed to ioremap() flash&quot;</span>
<span class="p_add">+				&quot; region\n&quot;);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		simple_map_init(&amp;info-&gt;list[i].map);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * On some platforms (e.g. MPC5200) a direct 1:1 mapping</span>
<span class="p_add">+		 * may cause problems with JFFS2 usage, as the local bus (LPB)</span>
<span class="p_add">+		 * doesn&#39;t support unaligned accesses as implemented in the</span>
<span class="p_add">+		 * JFFS2 code via memcpy(). By setting NO_XIP, the</span>
<span class="p_add">+		 * flash will not be exposed directly to the MTD users</span>
<span class="p_add">+		 * (e.g. JFFS2) any more.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (map_indirect)</span>
<span class="p_add">+			info-&gt;list[i].map.phys = NO_XIP;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (probe_type) {</span>
<span class="p_add">+			info-&gt;list[i].mtd = do_map_probe(probe_type,</span>
<span class="p_add">+							 &amp;info-&gt;list[i].map);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			info-&gt;list[i].mtd = obsolete_probe(dev,</span>
<span class="p_add">+							   &amp;info-&gt;list[i].map);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Fall back to mapping region as ROM */</span>
<span class="p_add">+		if (!info-&gt;list[i].mtd) {</span>
<span class="p_add">+			dev_warn(&amp;dev-&gt;dev,</span>
<span class="p_add">+				&quot;do_map_probe() failed for type %s\n&quot;,</span>
<span class="p_add">+				 probe_type);</span>
<span class="p_add">+</span>
<span class="p_add">+			info-&gt;list[i].mtd = do_map_probe(&quot;map_rom&quot;,</span>
<span class="p_add">+							 &amp;info-&gt;list[i].map);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mtd_list[i] = info-&gt;list[i].mtd;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = -ENXIO;</span>
<span class="p_add">+		if (!info-&gt;list[i].mtd) {</span>
<span class="p_add">+			dev_err(&amp;dev-&gt;dev, &quot;do_map_probe() failed\n&quot;);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			info-&gt;list_size++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		info-&gt;list[i].mtd-&gt;dev.parent = &amp;dev-&gt;dev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+	info-&gt;cmtd = NULL;</span>
<span class="p_add">+	if (info-&gt;list_size == 1) {</span>
<span class="p_add">+		info-&gt;cmtd = info-&gt;list[0].mtd;</span>
<span class="p_add">+	} else if (info-&gt;list_size &gt; 1) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We detected multiple devices. Concatenate them together.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		info-&gt;cmtd = mtd_concat_create(mtd_list, info-&gt;list_size,</span>
<span class="p_add">+					       dev_name(&amp;dev-&gt;dev));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (info-&gt;cmtd == NULL)</span>
<span class="p_add">+		err = -ENXIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+</span>
<span class="p_add">+	info-&gt;cmtd-&gt;dev.parent = &amp;dev-&gt;dev;</span>
<span class="p_add">+	mtd_set_of_node(info-&gt;cmtd, dp);</span>
<span class="p_add">+	part_probe_types = of_get_probes(dp);</span>
<span class="p_add">+	if (!part_probe_types) {</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mtd_device_parse_register(info-&gt;cmtd, part_probe_types, NULL,</span>
<span class="p_add">+			NULL, 0);</span>
<span class="p_add">+	of_free_probes(part_probe_types);</span>
<span class="p_add">+</span>
<span class="p_add">+	kfree(mtd_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_out:</span>
<span class="p_add">+	kfree(mtd_list);</span>
<span class="p_add">+err_flash_remove:</span>
<span class="p_add">+	of_flash_remove(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id of_flash_match[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible	= &quot;cfi-flash&quot;,</span>
<span class="p_add">+		.data		= (void *)&quot;cfi_probe&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* FIXME: JEDEC chips can&#39;t be safely and reliably</span>
<span class="p_add">+		 * probed, although the mtd code gets it right in</span>
<span class="p_add">+		 * practice most of the time.  We should use the</span>
<span class="p_add">+		 * vendor and device ids specified by the binding to</span>
<span class="p_add">+		 * bypass the heuristic probe code, but the mtd layer</span>
<span class="p_add">+		 * provides, at present, no interface for doing so</span>
<span class="p_add">+		 * :(. */</span>
<span class="p_add">+		.compatible	= &quot;jedec-flash&quot;,</span>
<span class="p_add">+		.data		= (void *)&quot;jedec_probe&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible     = &quot;mtd-ram&quot;,</span>
<span class="p_add">+		.data           = (void *)&quot;map_ram&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible     = &quot;mtd-rom&quot;,</span>
<span class="p_add">+		.data           = (void *)&quot;map_rom&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.type		= &quot;rom&quot;,</span>
<span class="p_add">+		.compatible	= &quot;direct-mapped&quot;</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ },</span>
<span class="p_add">+};</span>
<span class="p_add">+MODULE_DEVICE_TABLE(of, of_flash_match);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver of_flash_driver = {</span>
<span class="p_add">+	.driver = {</span>
<span class="p_add">+		.name = &quot;of-flash&quot;,</span>
<span class="p_add">+		.of_match_table = of_flash_match,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	.probe		= of_flash_probe,</span>
<span class="p_add">+	.remove		= of_flash_remove,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+module_platform_driver(of_flash_driver);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Vitaly Wool &lt;vwool@ru.mvista.com&gt;&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;Device tree based MTD map driver&quot;);</span>
<span class="p_header">diff --git a/drivers/net/can/usb/gs_usb.c b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">index eecee7f8dfb7..afcc1312dbaf 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_chunk">@@ -265,6 +265,8 @@</span> <span class="p_context"> static int gs_cmd_reset(struct gs_usb *gsusb, struct gs_can *gsdev)</span>
 			     sizeof(*dm),
 			     1000);
 
<span class="p_add">+	kfree(dm);</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/drivers/phy/phy-rcar-gen3-usb2.c b/drivers/phy/phy-rcar-gen3-usb2.c</span>
<span class="p_header">index afb4d048d3e9..54c34298a000 100644</span>
<span class="p_header">--- a/drivers/phy/phy-rcar-gen3-usb2.c</span>
<span class="p_header">+++ b/drivers/phy/phy-rcar-gen3-usb2.c</span>
<span class="p_chunk">@@ -20,6 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/of_address.h&gt;
 #include &lt;linux/phy/phy.h&gt;
 #include &lt;linux/platform_device.h&gt;
<span class="p_add">+#include &lt;linux/pm_runtime.h&gt;</span>
 #include &lt;linux/regulator/consumer.h&gt;
 #include &lt;linux/workqueue.h&gt;
 
<span class="p_chunk">@@ -395,7 +396,7 @@</span> <span class="p_context"> static int rcar_gen3_phy_usb2_probe(struct platform_device *pdev)</span>
 	struct rcar_gen3_chan *channel;
 	struct phy_provider *provider;
 	struct resource *res;
<span class="p_del">-	int irq;</span>
<span class="p_add">+	int irq, ret = 0;</span>
 
 	if (!dev-&gt;of_node) {
 		dev_err(dev, &quot;This driver needs device tree\n&quot;);
<span class="p_chunk">@@ -434,17 +435,24 @@</span> <span class="p_context"> static int rcar_gen3_phy_usb2_probe(struct platform_device *pdev)</span>
 		}
 	}
 
<span class="p_del">-	/* devm_phy_create() will call pm_runtime_enable(dev); */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * devm_phy_create() will call pm_runtime_enable(&amp;phy-&gt;dev);</span>
<span class="p_add">+	 * And then, phy-core will manage runtime pm for this device.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pm_runtime_enable(dev);</span>
 	channel-&gt;phy = devm_phy_create(dev, NULL, &amp;rcar_gen3_phy_usb2_ops);
 	if (IS_ERR(channel-&gt;phy)) {
 		dev_err(dev, &quot;Failed to create USB2 PHY\n&quot;);
<span class="p_del">-		return PTR_ERR(channel-&gt;phy);</span>
<span class="p_add">+		ret = PTR_ERR(channel-&gt;phy);</span>
<span class="p_add">+		goto error;</span>
 	}
 
 	channel-&gt;vbus = devm_regulator_get_optional(dev, &quot;vbus&quot;);
 	if (IS_ERR(channel-&gt;vbus)) {
<span class="p_del">-		if (PTR_ERR(channel-&gt;vbus) == -EPROBE_DEFER)</span>
<span class="p_del">-			return PTR_ERR(channel-&gt;vbus);</span>
<span class="p_add">+		if (PTR_ERR(channel-&gt;vbus) == -EPROBE_DEFER) {</span>
<span class="p_add">+			ret = PTR_ERR(channel-&gt;vbus);</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+		}</span>
 		channel-&gt;vbus = NULL;
 	}
 
<span class="p_chunk">@@ -454,15 +462,22 @@</span> <span class="p_context"> static int rcar_gen3_phy_usb2_probe(struct platform_device *pdev)</span>
 	provider = devm_of_phy_provider_register(dev, of_phy_simple_xlate);
 	if (IS_ERR(provider)) {
 		dev_err(dev, &quot;Failed to register PHY provider\n&quot;);
<span class="p_add">+		ret = PTR_ERR(provider);</span>
<span class="p_add">+		goto error;</span>
 	} else if (channel-&gt;has_otg) {
 		int ret;
 
 		ret = device_create_file(dev, &amp;dev_attr_role);
 		if (ret &lt; 0)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto error;</span>
 	}
 
<span class="p_del">-	return PTR_ERR_OR_ZERO(provider);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+error:</span>
<span class="p_add">+	pm_runtime_disable(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int rcar_gen3_phy_usb2_remove(struct platform_device *pdev)
<span class="p_chunk">@@ -472,6 +487,8 @@</span> <span class="p_context"> static int rcar_gen3_phy_usb2_remove(struct platform_device *pdev)</span>
 	if (channel-&gt;has_otg)
 		device_remove_file(&amp;pdev-&gt;dev, &amp;dev_attr_role);
 
<span class="p_add">+	pm_runtime_disable(&amp;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	return 0;
 };
 
<span class="p_header">diff --git a/drivers/staging/iio/cdc/ad7152.c b/drivers/staging/iio/cdc/ad7152.c</span>
<span class="p_header">index b91b50f345bd..c1a68ebb529c 100644</span>
<span class="p_header">--- a/drivers/staging/iio/cdc/ad7152.c</span>
<span class="p_header">+++ b/drivers/staging/iio/cdc/ad7152.c</span>
<span class="p_chunk">@@ -231,16 +231,12 @@</span> <span class="p_context"> static int ad7152_write_raw_samp_freq(struct device *dev, int val)</span>
 	if (i &gt;= ARRAY_SIZE(ad7152_filter_rate_table))
 		i = ARRAY_SIZE(ad7152_filter_rate_table) - 1;
 
<span class="p_del">-	mutex_lock(&amp;chip-&gt;state_lock);</span>
 	ret = i2c_smbus_write_byte_data(chip-&gt;client,
 					AD7152_REG_CFG2, AD7152_CFG2_OSR(i));
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		mutex_unlock(&amp;chip-&gt;state_lock);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
 		return ret;
<span class="p_del">-	}</span>
 
 	chip-&gt;filter_rate_setup = i;
<span class="p_del">-	mutex_unlock(&amp;chip-&gt;state_lock);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/staging/iio/light/tsl2x7x_core.c b/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_header">index ea15bc1c300c..197201a70d59 100644</span>
<span class="p_header">--- a/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_chunk">@@ -854,7 +854,7 @@</span> <span class="p_context"> void tsl2x7x_prox_calculate(int *data, int length,</span>
 		tmp = data[i] - statP-&gt;mean;
 		sample_sum += tmp * tmp;
 	}
<span class="p_del">-	statP-&gt;stddev = int_sqrt((long)sample_sum) / length;</span>
<span class="p_add">+	statP-&gt;stddev = int_sqrt((long)sample_sum / length);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/staging/media/platform/bcm2835/bcm2835-camera.c b/drivers/staging/media/platform/bcm2835/bcm2835-camera.c</span>
<span class="p_header">index ca15a698e018..c4dad30dd133 100644</span>
<span class="p_header">--- a/drivers/staging/media/platform/bcm2835/bcm2835-camera.c</span>
<span class="p_header">+++ b/drivers/staging/media/platform/bcm2835/bcm2835-camera.c</span>
<span class="p_chunk">@@ -1901,6 +1901,7 @@</span> <span class="p_context"> static int __init bm2835_mmal_init(void)</span>
 	unsigned int num_cameras;
 	struct vchiq_mmal_instance *instance;
 	unsigned int resolutions[MAX_BCM2835_CAMERAS][2];
<span class="p_add">+	int i;</span>
 
 	ret = vchiq_mmal_init(&amp;instance);
 	if (ret &lt; 0)
<span class="p_chunk">@@ -1914,8 +1915,10 @@</span> <span class="p_context"> static int __init bm2835_mmal_init(void)</span>
 
 	for (camera = 0; camera &lt; num_cameras; camera++) {
 		dev = kzalloc(sizeof(struct bm2835_mmal_dev), GFP_KERNEL);
<span class="p_del">-		if (!dev)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_add">+		if (!dev) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto cleanup_gdev;</span>
<span class="p_add">+		}</span>
 
 		dev-&gt;camera_num = camera;
 		dev-&gt;max_width = resolutions[camera][0];
<span class="p_chunk">@@ -1998,9 +2001,10 @@</span> <span class="p_context"> static int __init bm2835_mmal_init(void)</span>
 free_dev:
 	kfree(dev);
 
<span class="p_del">-	for ( ; camera &gt; 0; camera--) {</span>
<span class="p_del">-		bcm2835_cleanup_instance(gdev[camera]);</span>
<span class="p_del">-		gdev[camera] = NULL;</span>
<span class="p_add">+cleanup_gdev:</span>
<span class="p_add">+	for (i = 0; i &lt; camera; i++) {</span>
<span class="p_add">+		bcm2835_cleanup_instance(gdev[i]);</span>
<span class="p_add">+		gdev[i] = NULL;</span>
 	}
 	pr_info(&quot;%s: error %d while loading driver\n&quot;,
 		BM2835_MMAL_MODULE_NAME, ret);
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_ap.c b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">index 1c8fa3a1f5bb..88f0420b58a9 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_chunk">@@ -888,7 +888,7 @@</span> <span class="p_context"> int rtw_check_beacon_data(struct adapter *padapter, u8 *pbuf,  int len)</span>
 		return _FAIL;
 
 
<span class="p_del">-	if (len &gt; MAX_IE_SZ)</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; MAX_IE_SZ)</span>
 		return _FAIL;
 
 	pbss_network-&gt;IELength = len;
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_lpss.c b/drivers/tty/serial/8250/8250_lpss.c</span>
<span class="p_header">index f3ea90f0e411..7dddd7e6a01c 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_lpss.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_lpss.c</span>
<span class="p_chunk">@@ -183,7 +183,6 @@</span> <span class="p_context"> static void qrk_serial_setup_dma(struct lpss8250 *lpss, struct uart_port *port)</span>
 	if (ret)
 		return;
 
<span class="p_del">-	pci_set_master(pdev);</span>
 	pci_try_set_mwi(pdev);
 
 	/* Special DMA address for UART */
<span class="p_chunk">@@ -216,6 +215,8 @@</span> <span class="p_context"> static int qrk_serial_setup(struct lpss8250 *lpss, struct uart_port *port)</span>
 	struct pci_dev *pdev = to_pci_dev(port-&gt;dev);
 	int ret;
 
<span class="p_add">+	pci_set_master(pdev);</span>
<span class="p_add">+</span>
 	ret = pci_alloc_irq_vectors(pdev, 1, 1, PCI_IRQ_ALL_TYPES);
 	if (ret &lt; 0)
 		return ret;
<span class="p_header">diff --git a/drivers/tty/serial/efm32-uart.c b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">index ebd8569f9ad5..9fff25be87f9 100644</span>
<span class="p_header">--- a/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">+++ b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #define UARTn_FRAME		0x04
 #define UARTn_FRAME_DATABITS__MASK	0x000f
 #define UARTn_FRAME_DATABITS(n)		((n) - 3)
<span class="p_add">+#define UARTn_FRAME_PARITY__MASK	0x0300</span>
 #define UARTn_FRAME_PARITY_NONE		0x0000
 #define UARTn_FRAME_PARITY_EVEN		0x0200
 #define UARTn_FRAME_PARITY_ODD		0x0300
<span class="p_chunk">@@ -572,12 +573,16 @@</span> <span class="p_context"> static void efm32_uart_console_get_options(struct efm32_uart_port *efm_port,</span>
 			16 * (4 + (clkdiv &gt;&gt; 6)));
 
 	frame = efm32_uart_read32(efm_port, UARTn_FRAME);
<span class="p_del">-	if (frame &amp; UARTn_FRAME_PARITY_ODD)</span>
<span class="p_add">+	switch (frame &amp; UARTn_FRAME_PARITY__MASK) {</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_ODD:</span>
 		*parity = &#39;o&#39;;
<span class="p_del">-	else if (frame &amp; UARTn_FRAME_PARITY_EVEN)</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_EVEN:</span>
 		*parity = &#39;e&#39;;
<span class="p_del">-	else</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
 		*parity = &#39;n&#39;;
<span class="p_add">+	}</span>
 
 	*bits = (frame &amp; UARTn_FRAME_DATABITS__MASK) -
 			UARTn_FRAME_DATABITS(4) + 4;
<span class="p_header">diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">index 1df57461ece4..ebbe05e2fb57 100644</span>
<span class="p_header">--- a/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/sh-sci.c</span>
<span class="p_chunk">@@ -683,24 +683,37 @@</span> <span class="p_context"> static void sci_init_pins(struct uart_port *port, unsigned int cflag)</span>
 	}
 
 	if (port-&gt;type == PORT_SCIFA || port-&gt;type == PORT_SCIFB) {
<span class="p_add">+		u16 data = serial_port_in(port, SCPDR);</span>
 		u16 ctrl = serial_port_in(port, SCPCR);
 
 		/* Enable RXD and TXD pin functions */
 		ctrl &amp;= ~(SCPCR_RXDC | SCPCR_TXDC);
 		if (to_sci_port(port)-&gt;has_rtscts) {
<span class="p_del">-			/* RTS# is output, driven 1 */</span>
<span class="p_del">-			ctrl |= SCPCR_RTSC;</span>
<span class="p_del">-			serial_port_out(port, SCPDR,</span>
<span class="p_del">-				serial_port_in(port, SCPDR) | SCPDR_RTSD);</span>
<span class="p_add">+			/* RTS# is output, active low, unless autorts */</span>
<span class="p_add">+			if (!(port-&gt;mctrl &amp; TIOCM_RTS)) {</span>
<span class="p_add">+				ctrl |= SCPCR_RTSC;</span>
<span class="p_add">+				data |= SCPDR_RTSD;</span>
<span class="p_add">+			} else if (!s-&gt;autorts) {</span>
<span class="p_add">+				ctrl |= SCPCR_RTSC;</span>
<span class="p_add">+				data &amp;= ~SCPDR_RTSD;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/* Enable RTS# pin function */</span>
<span class="p_add">+				ctrl &amp;= ~SCPCR_RTSC;</span>
<span class="p_add">+			}</span>
 			/* Enable CTS# pin function */
 			ctrl &amp;= ~SCPCR_CTSC;
 		}
<span class="p_add">+		serial_port_out(port, SCPDR, data);</span>
 		serial_port_out(port, SCPCR, ctrl);
 	} else if (sci_getreg(port, SCSPTR)-&gt;size) {
 		u16 status = serial_port_in(port, SCSPTR);
 
<span class="p_del">-		/* RTS# is output, driven 1 */</span>
<span class="p_del">-		status |= SCSPTR_RTSIO | SCSPTR_RTSDT;</span>
<span class="p_add">+		/* RTS# is always output; and active low, unless autorts */</span>
<span class="p_add">+		status |= SCSPTR_RTSIO;</span>
<span class="p_add">+		if (!(port-&gt;mctrl &amp; TIOCM_RTS))</span>
<span class="p_add">+			status |= SCSPTR_RTSDT;</span>
<span class="p_add">+		else if (!s-&gt;autorts)</span>
<span class="p_add">+			status &amp;= ~SCSPTR_RTSDT;</span>
 		/* CTS# and SCK are inputs */
 		status &amp;= ~(SCSPTR_CTSIO | SCSPTR_SCKIO);
 		serial_port_out(port, SCSPTR, status);
<span class="p_chunk">@@ -2376,6 +2389,10 @@</span> <span class="p_context"> static void sci_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 
 		serial_port_out(port, SCFCR, ctrl);
 	}
<span class="p_add">+	if (port-&gt;flags &amp; UPF_HARD_FLOW) {</span>
<span class="p_add">+		/* Refresh (Auto) RTS */</span>
<span class="p_add">+		sci_set_mctrl(port, port-&gt;mctrl);</span>
<span class="p_add">+	}</span>
 
 	scr_val |= SCSCR_RE | SCSCR_TE |
 		   (s-&gt;cfg-&gt;scscr &amp; ~(SCSCR_CKE1 | SCSCR_CKE0));
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 6a857e875633..3e28ff1651b4 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -2535,6 +2535,7 @@</span> <span class="p_context"> struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,</span>
 		hcd-&gt;bandwidth_mutex = kmalloc(sizeof(*hcd-&gt;bandwidth_mutex),
 				GFP_KERNEL);
 		if (!hcd-&gt;bandwidth_mutex) {
<span class="p_add">+			kfree(hcd-&gt;address0_mutex);</span>
 			kfree(hcd);
 			dev_dbg(dev, &quot;hcd bandwidth mutex alloc failed\n&quot;);
 			return NULL;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index f77a4ebde7d5..b8bb20d7acdb 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -1336,7 +1336,13 @@</span> <span class="p_context"> static int hub_configure(struct usb_hub *hub,</span>
 	if (ret &lt; 0) {
 		message = &quot;can&#39;t read hub descriptor&quot;;
 		goto fail;
<span class="p_del">-	} else if (hub-&gt;descriptor-&gt;bNbrPorts &gt; USB_MAXCHILDREN) {</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	maxchild = USB_MAXCHILDREN;</span>
<span class="p_add">+	if (hub_is_superspeed(hdev))</span>
<span class="p_add">+		maxchild = min_t(unsigned, maxchild, USB_SS_MAXPORTS);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hub-&gt;descriptor-&gt;bNbrPorts &gt; maxchild) {</span>
 		message = &quot;hub has too many ports!&quot;;
 		ret = -ENODEV;
 		goto fail;
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 81199f6ee3bc..2776da016685 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1258,14 +1258,24 @@</span> <span class="p_context"> static int __dwc3_gadget_ep_queue(struct dwc3_ep *dep, struct dwc3_request *req)</span>
 				__dwc3_gadget_start_isoc(dwc, dep, cur_uf);
 				dep-&gt;flags &amp;= ~DWC3_EP_PENDING_REQUEST;
 			}
<span class="p_add">+			return 0;</span>
 		}
<span class="p_del">-		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((dep-&gt;flags &amp; DWC3_EP_BUSY) &amp;&amp;</span>
<span class="p_add">+		    !(dep-&gt;flags &amp; DWC3_EP_MISSED_ISOC)) {</span>
<span class="p_add">+			WARN_ON_ONCE(!dep-&gt;resource_index);</span>
<span class="p_add">+			ret = __dwc3_gadget_kick_transfer(dep,</span>
<span class="p_add">+							  dep-&gt;resource_index);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	if (!dwc3_calc_trbs_left(dep))
 		return 0;
 
 	ret = __dwc3_gadget_kick_transfer(dep, 0);
<span class="p_add">+out:</span>
 	if (ret == -EBUSY)
 		ret = 0;
 
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index a2c916869293..fc4bbdd0fbd6 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -1182,8 +1182,10 @@</span> <span class="p_context"> dev_release (struct inode *inode, struct file *fd)</span>
 
 	/* closing ep0 === shutdown all */
 
<span class="p_del">-	if (dev-&gt;gadget_registered)</span>
<span class="p_add">+	if (dev-&gt;gadget_registered) {</span>
 		usb_gadget_unregister_driver (&amp;gadgetfs_driver);
<span class="p_add">+		dev-&gt;gadget_registered = false;</span>
<span class="p_add">+	}</span>
 
 	/* at this point &quot;good&quot; hardware has disconnected the
 	 * device from USB; the host won&#39;t see it any more.
<span class="p_chunk">@@ -1676,9 +1678,10 @@</span> <span class="p_context"> static void</span>
 gadgetfs_suspend (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
<span class="p_add">+	unsigned long		flags;</span>
 
 	INFO (dev, &quot;suspended from state %d\n&quot;, dev-&gt;state);
<span class="p_del">-	spin_lock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span>
 	switch (dev-&gt;state) {
 	case STATE_DEV_SETUP:		// VERY odd... host died??
 	case STATE_DEV_CONNECTED:
<span class="p_chunk">@@ -1689,7 +1692,7 @@</span> <span class="p_context"> gadgetfs_suspend (struct usb_gadget *gadget)</span>
 	default:
 		break;
 	}
<span class="p_del">-	spin_unlock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span>
 }
 
 static struct usb_gadget_driver gadgetfs_driver = {
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index 8cabc5944d5f..d5ec2e4f5359 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -442,23 +442,16 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 		/* Report reset and disconnect events to the driver */
 		if (dum-&gt;driver &amp;&amp; (disconnect || reset)) {
 			stop_activity(dum);
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
 			if (reset)
 				usb_gadget_udc_reset(&amp;dum-&gt;gadget, dum-&gt;driver);
 			else
 				dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
 		}
 	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {
<span class="p_del">-		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)</span>
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		} else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)</span>
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		}</span>
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
<span class="p_chunk">@@ -983,7 +976,9 @@</span> <span class="p_context"> static int dummy_udc_stop(struct usb_gadget *g)</span>
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
 	dum-&gt;driver = NULL;
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -2008,7 +2003,7 @@</span> <span class="p_context"> ss_hub_descriptor(struct usb_hub_descriptor *desc)</span>
 			HUB_CHAR_COMMON_OCPM);
 	desc-&gt;bNbrPorts = 1;
 	desc-&gt;u.ss.bHubHdrDecLat = 0x04; /* Worst case: 0.4 micro sec*/
<span class="p_del">-	desc-&gt;u.ss.DeviceRemovable = 0xffff;</span>
<span class="p_add">+	desc-&gt;u.ss.DeviceRemovable = 0;</span>
 }
 
 static inline void hub_descriptor(struct usb_hub_descriptor *desc)
<span class="p_chunk">@@ -2020,8 +2015,8 @@</span> <span class="p_context"> static inline void hub_descriptor(struct usb_hub_descriptor *desc)</span>
 			HUB_CHAR_INDV_PORT_LPSM |
 			HUB_CHAR_COMMON_OCPM);
 	desc-&gt;bNbrPorts = 1;
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[0] = 0xff;</span>
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[0] = 0;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;	/* PortPwrCtrlMask */</span>
 }
 
 static int dummy_hub_control(
<span class="p_header">diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">index 3828c2ec8623..1904bb192faf 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_chunk">@@ -2470,11 +2470,8 @@</span> <span class="p_context"> static void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)</span>
 		nuke(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
<span class="p_del">-	if (driver) {</span>
<span class="p_del">-		spin_unlock(&amp;dev-&gt;lock);</span>
<span class="p_add">+	if (driver)</span>
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
<span class="p_del">-		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_del">-	}</span>
 
 	usb_reinit(dev);
 }
<span class="p_chunk">@@ -3348,8 +3345,6 @@</span> <span class="p_context"> static void handle_stat0_irqs(struct net2280 *dev, u32 stat)</span>
 		BIT(PCI_RETRY_ABORT_INTERRUPT))
 
 static void handle_stat1_irqs(struct net2280 *dev, u32 stat)
<span class="p_del">-__releases(dev-&gt;lock)</span>
<span class="p_del">-__acquires(dev-&gt;lock)</span>
 {
 	struct net2280_ep	*ep;
 	u32			tmp, num, mask, scratch;
<span class="p_chunk">@@ -3390,14 +3385,12 @@</span> <span class="p_context"> __acquires(dev-&gt;lock)</span>
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				ep0_start(dev);
<span class="p_del">-				spin_unlock(&amp;dev-&gt;lock);</span>
 				if (reset)
 					usb_gadget_udc_reset
 						(&amp;dev-&gt;gadget, dev-&gt;driver);
 				else
 					(dev-&gt;driver-&gt;disconnect)
 						(&amp;dev-&gt;gadget);
<span class="p_del">-				spin_lock(&amp;dev-&gt;lock);</span>
 				return;
 			}
 		}
<span class="p_header">diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">index 2218f91e92a6..20a6b1a4f26e 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_chunk">@@ -1401,7 +1401,13 @@</span> <span class="p_context"> static void usb3_request_done_pipen(struct renesas_usb3 *usb3,</span>
 				    struct renesas_usb3_request *usb3_req,
 				    int status)
 {
<span class="p_del">-	usb3_pn_stop(usb3);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;usb3-&gt;lock, flags);</span>
<span class="p_add">+	if (usb3_pn_change(usb3, usb3_ep-&gt;num))</span>
<span class="p_add">+		usb3_pn_stop(usb3);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;usb3-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	usb3_disable_pipe_irq(usb3, usb3_ep-&gt;num);
 	usb3_request_done(usb3_ep, usb3_req, status);
 
<span class="p_chunk">@@ -1430,30 +1436,46 @@</span> <span class="p_context"> static void usb3_irq_epc_pipen_bfrdy(struct renesas_usb3 *usb3, int num)</span>
 {
 	struct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, num);
 	struct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);
<span class="p_add">+	bool done = false;</span>
 
 	if (!usb3_req)
 		return;
 
<span class="p_add">+	spin_lock(&amp;usb3-&gt;lock);</span>
<span class="p_add">+	if (usb3_pn_change(usb3, num))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (usb3_ep-&gt;dir_in) {
 		/* Do not stop the IN pipe here to detect LSTTR interrupt */
 		if (!usb3_write_pipe(usb3_ep, usb3_req, USB3_PN_WRITE))
 			usb3_clear_bit(usb3, PN_INT_BFRDY, USB3_PN_INT_ENA);
 	} else {
 		if (!usb3_read_pipe(usb3_ep, usb3_req, USB3_PN_READ))
<span class="p_del">-			usb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);</span>
<span class="p_add">+			done = true;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	/* need to unlock because usb3_request_done_pipen() locks it */</span>
<span class="p_add">+	spin_unlock(&amp;usb3-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (done)</span>
<span class="p_add">+		usb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);</span>
 }
 
 static void usb3_irq_epc_pipen(struct renesas_usb3 *usb3, int num)
 {
 	u32 pn_int_sta;
 
<span class="p_del">-	if (usb3_pn_change(usb3, num) &lt; 0)</span>
<span class="p_add">+	spin_lock(&amp;usb3-&gt;lock);</span>
<span class="p_add">+	if (usb3_pn_change(usb3, num) &lt; 0) {</span>
<span class="p_add">+		spin_unlock(&amp;usb3-&gt;lock);</span>
 		return;
<span class="p_add">+	}</span>
 
 	pn_int_sta = usb3_read(usb3, USB3_PN_INT_STA);
 	pn_int_sta &amp;= usb3_read(usb3, USB3_PN_INT_ENA);
 	usb3_write(usb3, pn_int_sta, USB3_PN_INT_STA);
<span class="p_add">+	spin_unlock(&amp;usb3-&gt;lock);</span>
 	if (pn_int_sta &amp; PN_INT_LSTTR)
 		usb3_irq_epc_pipen_lsttr(usb3, num);
 	if (pn_int_sta &amp; PN_INT_BFRDY)
<span class="p_chunk">@@ -1707,6 +1729,9 @@</span> <span class="p_context"> static int renesas_usb3_start(struct usb_gadget *gadget,</span>
 	/* hook up the driver */
 	usb3-&gt;driver = driver;
 
<span class="p_add">+	pm_runtime_enable(usb3_to_dev(usb3));</span>
<span class="p_add">+	pm_runtime_get_sync(usb3_to_dev(usb3));</span>
<span class="p_add">+</span>
 	renesas_usb3_init_controller(usb3);
 
 	return 0;
<span class="p_chunk">@@ -1715,14 +1740,14 @@</span> <span class="p_context"> static int renesas_usb3_start(struct usb_gadget *gadget,</span>
 static int renesas_usb3_stop(struct usb_gadget *gadget)
 {
 	struct renesas_usb3 *usb3 = gadget_to_renesas_usb3(gadget);
<span class="p_del">-	unsigned long flags;</span>
 
<span class="p_del">-	spin_lock_irqsave(&amp;usb3-&gt;lock, flags);</span>
 	usb3-&gt;softconnect = false;
 	usb3-&gt;gadget.speed = USB_SPEED_UNKNOWN;
 	usb3-&gt;driver = NULL;
 	renesas_usb3_stop_controller(usb3);
<span class="p_del">-	spin_unlock_irqrestore(&amp;usb3-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_put(usb3_to_dev(usb3));</span>
<span class="p_add">+	pm_runtime_disable(usb3_to_dev(usb3));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1761,9 +1786,6 @@</span> <span class="p_context"> static int renesas_usb3_remove(struct platform_device *pdev)</span>
 {
 	struct renesas_usb3 *usb3 = platform_get_drvdata(pdev);
 
<span class="p_del">-	pm_runtime_put(&amp;pdev-&gt;dev);</span>
<span class="p_del">-	pm_runtime_disable(&amp;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	usb_del_gadget_udc(&amp;usb3-&gt;gadget);
 
 	__renesas_usb3_ep_free_request(usb3-&gt;ep0_req);
<span class="p_chunk">@@ -1948,9 +1970,6 @@</span> <span class="p_context"> static int renesas_usb3_probe(struct platform_device *pdev)</span>
 
 	usb3-&gt;workaround_for_vbus = priv-&gt;workaround_for_vbus;
 
<span class="p_del">-	pm_runtime_enable(&amp;pdev-&gt;dev);</span>
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	dev_info(&amp;pdev-&gt;dev, &quot;probed\n&quot;);
 
 	return 0;
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index bfa7fa3d2eea..7bf78be1fd32 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -1269,7 +1269,7 @@</span> <span class="p_context"> static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)</span>
 			time = 30;
 			break;
 		default:
<span class="p_del">-			time = 300;</span>
<span class="p_add">+			time = 50;</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1785,6 +1785,7 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 		pipe = td-&gt;pipe;
 		pipe_stop(r8a66597, pipe);
 
<span class="p_add">+		/* Select a different address or endpoint */</span>
 		new_td = td;
 		do {
 			list_move_tail(&amp;new_td-&gt;queue,
<span class="p_chunk">@@ -1794,7 +1795,8 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 				new_td = td;
 				break;
 			}
<span class="p_del">-		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address);</span>
<span class="p_add">+		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address &amp;&amp;</span>
<span class="p_add">+			td-&gt;pipe-&gt;info.epnum == new_td-&gt;pipe-&gt;info.epnum);</span>
 
 		start_transfer(r8a66597, new_td);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 96e133f4f7e7..4f28cfebe302 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -2128,11 +2128,12 @@</span> <span class="p_context"> static void xhci_add_in_port(struct xhci_hcd *xhci, unsigned int num_ports,</span>
 {
 	u32 temp, port_offset, port_count;
 	int i;
<span class="p_del">-	u8 major_revision;</span>
<span class="p_add">+	u8 major_revision, minor_revision;</span>
 	struct xhci_hub *rhub;
 
 	temp = readl(addr);
 	major_revision = XHCI_EXT_PORT_MAJOR(temp);
<span class="p_add">+	minor_revision = XHCI_EXT_PORT_MINOR(temp);</span>
 
 	if (major_revision == 0x03) {
 		rhub = &amp;xhci-&gt;usb3_rhub;
<span class="p_chunk">@@ -2146,7 +2147,9 @@</span> <span class="p_context"> static void xhci_add_in_port(struct xhci_hcd *xhci, unsigned int num_ports,</span>
 		return;
 	}
 	rhub-&gt;maj_rev = XHCI_EXT_PORT_MAJOR(temp);
<span class="p_del">-	rhub-&gt;min_rev = XHCI_EXT_PORT_MINOR(temp);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rhub-&gt;min_rev &lt; minor_revision)</span>
<span class="p_add">+		rhub-&gt;min_rev = minor_revision;</span>
 
 	/* Port offset and count in the third dword, see section 7.2 */
 	temp = readl(addr + 2);
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index fcf1f3f63e7a..1bcf971141c0 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -201,6 +201,9 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;
 			pdev-&gt;device == 0x1042)
 		xhci-&gt;quirks |= XHCI_BROKEN_STREAMS;
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;</span>
<span class="p_add">+			pdev-&gt;device == 0x1142)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;</span>
 
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_TI &amp;&amp; pdev-&gt;device == 0x8241)
 		xhci-&gt;quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_7;
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_hcd.c b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">index e4cb9f0625e8..be0911049c97 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_chunk">@@ -235,14 +235,19 @@</span> <span class="p_context"> static int vhci_hub_status(struct usb_hcd *hcd, char *buf)</span>
 
 static inline void hub_descriptor(struct usb_hub_descriptor *desc)
 {
<span class="p_add">+	int width;</span>
<span class="p_add">+</span>
 	memset(desc, 0, sizeof(*desc));
 	desc-&gt;bDescriptorType = USB_DT_HUB;
<span class="p_del">-	desc-&gt;bDescLength = 9;</span>
 	desc-&gt;wHubCharacteristics = cpu_to_le16(
 		HUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_COMMON_OCPM);
<span class="p_add">+</span>
 	desc-&gt;bNbrPorts = VHCI_HC_PORTS;
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[0] = 0xff;</span>
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;</span>
<span class="p_add">+	BUILD_BUG_ON(VHCI_HC_PORTS &gt; USB_MAXCHILDREN);</span>
<span class="p_add">+	width = desc-&gt;bNbrPorts / 8 + 1;</span>
<span class="p_add">+	desc-&gt;bDescLength = USB_DT_HUB_NONVAR_SIZE + 2 * width;</span>
<span class="p_add">+	memset(&amp;desc-&gt;u.hs.DeviceRemovable[0], 0, width);</span>
<span class="p_add">+	memset(&amp;desc-&gt;u.hs.DeviceRemovable[width], 0xff, width);</span>
 }
 
 static int vhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 34adf9b9c053..b7f1fda40422 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -664,6 +664,12 @@</span> <span class="p_context"> static int virtballoon_restore(struct virtio_device *vdev)</span>
 }
 #endif
 
<span class="p_add">+static int virtballoon_validate(struct virtio_device *vdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__virtio_clear_bit(vdev, VIRTIO_F_IOMMU_PLATFORM);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static unsigned int features[] = {
 	VIRTIO_BALLOON_F_MUST_TELL_HOST,
 	VIRTIO_BALLOON_F_STATS_VQ,
<span class="p_chunk">@@ -676,6 +682,7 @@</span> <span class="p_context"> static struct virtio_driver virtio_balloon_driver = {</span>
 	.driver.name =	KBUILD_MODNAME,
 	.driver.owner =	THIS_MODULE,
 	.id_table =	id_table,
<span class="p_add">+	.validate =	virtballoon_validate,</span>
 	.probe =	virtballoon_probe,
 	.remove =	virtballoon_remove,
 	.config_changed = virtballoon_changed,
<span class="p_header">diff --git a/fs/btrfs/hash.c b/fs/btrfs/hash.c</span>
<span class="p_header">index a97fdc156a03..baacc1866861 100644</span>
<span class="p_header">--- a/fs/btrfs/hash.c</span>
<span class="p_header">+++ b/fs/btrfs/hash.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"> u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)</span>
 {
 	SHASH_DESC_ON_STACK(shash, tfm);
 	u32 *ctx = (u32 *)shash_desc_ctx(shash);
<span class="p_add">+	u32 retval;</span>
 	int err;
 
 	shash-&gt;tfm = tfm;
<span class="p_chunk">@@ -47,5 +48,7 @@</span> <span class="p_context"> u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)</span>
 	err = crypto_shash_update(shash, address, length);
 	BUG_ON(err);
 
<span class="p_del">-	return *ctx;</span>
<span class="p_add">+	retval = *ctx;</span>
<span class="p_add">+	barrier_data(ctx);</span>
<span class="p_add">+	return retval;</span>
 }
<span class="p_header">diff --git a/fs/configfs/symlink.c b/fs/configfs/symlink.c</span>
<span class="p_header">index a6ab012a2c6a..c8aabba502f6 100644</span>
<span class="p_header">--- a/fs/configfs/symlink.c</span>
<span class="p_header">+++ b/fs/configfs/symlink.c</span>
<span class="p_chunk">@@ -83,14 +83,13 @@</span> <span class="p_context"> static int create_link(struct config_item *parent_item,</span>
 	ret = -ENOMEM;
 	sl = kmalloc(sizeof(struct configfs_symlink), GFP_KERNEL);
 	if (sl) {
<span class="p_del">-		sl-&gt;sl_target = config_item_get(item);</span>
 		spin_lock(&amp;configfs_dirent_lock);
 		if (target_sd-&gt;s_type &amp; CONFIGFS_USET_DROPPING) {
 			spin_unlock(&amp;configfs_dirent_lock);
<span class="p_del">-			config_item_put(item);</span>
 			kfree(sl);
 			return -ENOENT;
 		}
<span class="p_add">+		sl-&gt;sl_target = config_item_get(item);</span>
 		list_add(&amp;sl-&gt;sl_list, &amp;target_sd-&gt;s_links);
 		spin_unlock(&amp;configfs_dirent_lock);
 		ret = configfs_create_link(sl, parent_item-&gt;ci_dentry,
<span class="p_header">diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h</span>
<span class="p_header">index 05d7e2cefc56..90b4a76528d0 100644</span>
<span class="p_header">--- a/fs/f2fs/f2fs.h</span>
<span class="p_header">+++ b/fs/f2fs/f2fs.h</span>
<span class="p_chunk">@@ -1007,6 +1007,7 @@</span> <span class="p_context"> static inline u32 f2fs_crc32(struct f2fs_sb_info *sbi, const void *address,</span>
 {
 	SHASH_DESC_ON_STACK(shash, sbi-&gt;s_chksum_driver);
 	u32 *ctx = (u32 *)shash_desc_ctx(shash);
<span class="p_add">+	u32 retval;</span>
 	int err;
 
 	shash-&gt;tfm = sbi-&gt;s_chksum_driver;
<span class="p_chunk">@@ -1016,7 +1017,9 @@</span> <span class="p_context"> static inline u32 f2fs_crc32(struct f2fs_sb_info *sbi, const void *address,</span>
 	err = crypto_shash_update(shash, address, length);
 	BUG_ON(err);
 
<span class="p_del">-	return *ctx;</span>
<span class="p_add">+	retval = *ctx;</span>
<span class="p_add">+	barrier_data(ctx);</span>
<span class="p_add">+	return retval;</span>
 }
 
 static inline bool f2fs_crc_valid(struct f2fs_sb_info *sbi, __u32 blk_crc,
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index dde861387a40..d44f5456eb9b 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -200,7 +200,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index 312578089544..f4016826255a 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -300,11 +300,7 @@</span> <span class="p_context"> show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)</span>
 
 	/* We don&#39;t show the stack guard page in /proc/maps */
 	start = vma-&gt;vm_start;
<span class="p_del">-	if (stack_guard_page_start(vma, start))</span>
<span class="p_del">-		start += PAGE_SIZE;</span>
 	end = vma-&gt;vm_end;
<span class="p_del">-	if (stack_guard_page_end(vma, end))</span>
<span class="p_del">-		end -= PAGE_SIZE;</span>
 
 	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);
 	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,
<span class="p_header">diff --git a/fs/read_write.c b/fs/read_write.c</span>
<span class="p_header">index c4f88afbc67f..f77eb2262eb9 100644</span>
<span class="p_header">--- a/fs/read_write.c</span>
<span class="p_header">+++ b/fs/read_write.c</span>
<span class="p_chunk">@@ -1210,7 +1210,7 @@</span> <span class="p_context"> static size_t compat_writev(struct file *file,</span>
 	if (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))
 		goto out;
 
<span class="p_del">-	ret = compat_do_readv_writev(WRITE, file, vec, vlen, pos, 0);</span>
<span class="p_add">+	ret = compat_do_readv_writev(WRITE, file, vec, vlen, pos, flags);</span>
 
 out:
 	if (ret &gt; 0)
<span class="p_header">diff --git a/fs/userfaultfd.c b/fs/userfaultfd.c</span>
<span class="p_header">index f7555fc25877..1d622f276e3a 100644</span>
<span class="p_header">--- a/fs/userfaultfd.c</span>
<span class="p_header">+++ b/fs/userfaultfd.c</span>
<span class="p_chunk">@@ -340,9 +340,28 @@</span> <span class="p_context"> int handle_userfault(struct vm_fault *vmf, unsigned long reason)</span>
 	bool must_wait, return_to_userland;
 	long blocking_state;
 
<span class="p_del">-	BUG_ON(!rwsem_is_locked(&amp;mm-&gt;mmap_sem));</span>
<span class="p_del">-</span>
 	ret = VM_FAULT_SIGBUS;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We don&#39;t do userfault handling for the final child pid update.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We also don&#39;t do userfault handling during</span>
<span class="p_add">+	 * coredumping. hugetlbfs has the special</span>
<span class="p_add">+	 * follow_hugetlb_page() to skip missing pages in the</span>
<span class="p_add">+	 * FOLL_DUMP case, anon memory also checks for FOLL_DUMP with</span>
<span class="p_add">+	 * the no_page_table() helper in follow_page_mask(), but the</span>
<span class="p_add">+	 * shmem_vm_ops-&gt;fault method is invoked even during</span>
<span class="p_add">+	 * coredumping without mmap_sem and it ends up here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (current-&gt;flags &amp; (PF_EXITING|PF_DUMPCORE))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Coredumping runs without mmap_sem so we can only check that</span>
<span class="p_add">+	 * the mmap_sem is held, if PF_DUMPCORE was not set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WARN_ON_ONCE(!rwsem_is_locked(&amp;mm-&gt;mmap_sem));</span>
<span class="p_add">+</span>
 	ctx = vmf-&gt;vma-&gt;vm_userfaultfd_ctx.ctx;
 	if (!ctx)
 		goto out;
<span class="p_chunk">@@ -361,12 +380,6 @@</span> <span class="p_context"> int handle_userfault(struct vm_fault *vmf, unsigned long reason)</span>
 		goto out;
 
 	/*
<span class="p_del">-	 * We don&#39;t do userfault handling for the final child pid update.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (current-&gt;flags &amp; PF_EXITING)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * Check that we can return VM_FAULT_RETRY.
 	 *
 	 * NOTE: it should become possible to return VM_FAULT_RETRY
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 018b134f6427..cec423ba6d4b 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1381,12 +1381,6 @@</span> <span class="p_context"> int clear_page_dirty_for_io(struct page *page);</span>
 
 int get_cmdline(struct task_struct *task, char *buffer, int buflen);
 
<span class="p_del">-/* Is the vma a continuation of the stack vma above it? */</span>
<span class="p_del">-static inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_end == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSDOWN);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline bool vma_is_anonymous(struct vm_area_struct *vma)
 {
 	return !vma-&gt;vm_ops;
<span class="p_chunk">@@ -1402,28 +1396,6 @@</span> <span class="p_context"> bool vma_is_shmem(struct vm_area_struct *vma);</span>
 static inline bool vma_is_shmem(struct vm_area_struct *vma) { return false; }
 #endif
 
<span class="p_del">-static inline int stack_guard_page_start(struct vm_area_struct *vma,</span>
<span class="p_del">-					     unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_start == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsdown(vma-&gt;vm_prev, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Is the vma a continuation of the stack vma below it? */</span>
<span class="p_del">-static inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_start == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSUP);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int stack_guard_page_end(struct vm_area_struct *vma,</span>
<span class="p_del">-					   unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_end == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsup(vma-&gt;vm_next, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int vma_is_stack_for_current(struct vm_area_struct *vma);
 
 extern unsigned long move_page_tables(struct vm_area_struct *vma,
<span class="p_chunk">@@ -2210,6 +2182,7 @@</span> <span class="p_context"> void page_cache_async_readahead(struct address_space *mapping,</span>
 				pgoff_t offset,
 				unsigned long size);
 
<span class="p_add">+extern unsigned long stack_guard_gap;</span>
 /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
 
<span class="p_chunk">@@ -2238,6 +2211,30 @@</span> <span class="p_context"> static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * m</span>
 	return vma;
 }
 
<span class="p_add">+static inline unsigned long vm_start_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_start = vma-&gt;vm_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSDOWN) {</span>
<span class="p_add">+		vm_start -= stack_guard_gap;</span>
<span class="p_add">+		if (vm_start &gt; vma-&gt;vm_start)</span>
<span class="p_add">+			vm_start = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_start;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long vm_end_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSUP) {</span>
<span class="p_add">+		vm_end += stack_guard_gap;</span>
<span class="p_add">+		if (vm_end &lt; vma-&gt;vm_end)</span>
<span class="p_add">+			vm_end = -PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_end;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long vma_pages(struct vm_area_struct *vma)
 {
 	return (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
<span class="p_header">diff --git a/include/uapi/linux/usb/ch11.h b/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">index 361297e96f58..576c704e3fb8 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch11.h</span>
<span class="p_chunk">@@ -22,6 +22,9 @@</span> <span class="p_context"></span>
  */
 #define USB_MAXCHILDREN		31
 
<span class="p_add">+/* See USB 3.1 spec Table 10-5 */</span>
<span class="p_add">+#define USB_SS_MAXPORTS		15</span>
<span class="p_add">+</span>
 /*
  * Hub request types
  */
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index a4afe5cc5af1..36dc72a54982 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1310,8 +1310,10 @@</span> <span class="p_context"> __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)</span>
 			ret = __irq_set_trigger(desc,
 						new-&gt;flags &amp; IRQF_TRIGGER_MASK);
 
<span class="p_del">-			if (ret)</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				irq_release_resources(desc);</span>
 				goto out_mask;
<span class="p_add">+			}</span>
 		}
 
 		desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 3b31fc05a0f1..8119ea560688 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -5533,7 +5533,7 @@</span> <span class="p_context"> void idle_task_exit(void)</span>
 	BUG_ON(cpu_online(smp_processor_id()));
 
 	if (mm != &amp;init_mm) {
<span class="p_del">-		switch_mm_irqs_off(mm, &amp;init_mm, current);</span>
<span class="p_add">+		switch_mm(mm, &amp;init_mm, current);</span>
 		finish_arch_post_lock_switch();
 	}
 	mmdrop(mm);
<span class="p_header">diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c</span>
<span class="p_header">index ce3a31e8eb36..d4847cd73d6b 100644</span>
<span class="p_header">--- a/kernel/time/alarmtimer.c</span>
<span class="p_header">+++ b/kernel/time/alarmtimer.c</span>
<span class="p_chunk">@@ -387,7 +387,7 @@</span> <span class="p_context"> void alarm_start_relative(struct alarm *alarm, ktime_t start)</span>
 {
 	struct alarm_base *base = &amp;alarm_bases[alarm-&gt;type];
 
<span class="p_del">-	start = ktime_add(start, base-&gt;gettime());</span>
<span class="p_add">+	start = ktime_add_safe(start, base-&gt;gettime());</span>
 	alarm_start(alarm, start);
 }
 EXPORT_SYMBOL_GPL(alarm_start_relative);
<span class="p_chunk">@@ -475,7 +475,7 @@</span> <span class="p_context"> u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)</span>
 		overrun++;
 	}
 
<span class="p_del">-	alarm-&gt;node.expires = ktime_add(alarm-&gt;node.expires, interval);</span>
<span class="p_add">+	alarm-&gt;node.expires = ktime_add_safe(alarm-&gt;node.expires, interval);</span>
 	return overrun;
 }
 EXPORT_SYMBOL_GPL(alarm_forward);
<span class="p_chunk">@@ -660,13 +660,21 @@</span> <span class="p_context"> static int alarm_timer_set(struct k_itimer *timr, int flags,</span>
 
 	/* start the timer */
 	timr-&gt;it.alarm.interval = timespec_to_ktime(new_setting-&gt;it_interval);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Rate limit to the tick as a hot fix to prevent DOS. Will be</span>
<span class="p_add">+	 * mopped up later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (timr-&gt;it.alarm.interval &lt; TICK_NSEC)</span>
<span class="p_add">+		timr-&gt;it.alarm.interval = TICK_NSEC;</span>
<span class="p_add">+</span>
 	exp = timespec_to_ktime(new_setting-&gt;it_value);
 	/* Convert (if necessary) to absolute time */
 	if (flags != TIMER_ABSTIME) {
 		ktime_t now;
 
 		now = alarm_bases[timr-&gt;it.alarm.alarmtimer.type].gettime();
<span class="p_del">-		exp = ktime_add(now, exp);</span>
<span class="p_add">+		exp = ktime_add_safe(now, exp);</span>
 	}
 
 	alarm_start(&amp;timr-&gt;it.alarm.alarmtimer, exp);
<span class="p_header">diff --git a/lib/libcrc32c.c b/lib/libcrc32c.c</span>
<span class="p_header">index 74a54b7f2562..9f79547d1b97 100644</span>
<span class="p_header">--- a/lib/libcrc32c.c</span>
<span class="p_header">+++ b/lib/libcrc32c.c</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> static struct crypto_shash *tfm;</span>
 u32 crc32c(u32 crc, const void *address, unsigned int length)
 {
 	SHASH_DESC_ON_STACK(shash, tfm);
<span class="p_del">-	u32 *ctx = (u32 *)shash_desc_ctx(shash);</span>
<span class="p_add">+	u32 ret, *ctx = (u32 *)shash_desc_ctx(shash);</span>
 	int err;
 
 	shash-&gt;tfm = tfm;
<span class="p_chunk">@@ -53,7 +53,9 @@</span> <span class="p_context"> u32 crc32c(u32 crc, const void *address, unsigned int length)</span>
 	err = crypto_shash_update(shash, address, length);
 	BUG_ON(err);
 
<span class="p_del">-	return *ctx;</span>
<span class="p_add">+	ret = *ctx;</span>
<span class="p_add">+	barrier_data(ctx);</span>
<span class="p_add">+	return ret;</span>
 }
 
 EXPORT_SYMBOL(crc32c);
<span class="p_header">diff --git a/mm/gup.c b/mm/gup.c</span>
<span class="p_header">index fb87cbf37e52..1466f3545870 100644</span>
<span class="p_header">--- a/mm/gup.c</span>
<span class="p_header">+++ b/mm/gup.c</span>
<span class="p_chunk">@@ -387,11 +387,6 @@</span> <span class="p_context"> static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,</span>
 	/* mlock all present pages, but do not fault in new pages */
 	if ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
 		return -ENOENT;
<span class="p_del">-	/* For mm_populate(), just skip the stack guard page. */</span>
<span class="p_del">-	if ((*flags &amp; FOLL_POPULATE) &amp;&amp;</span>
<span class="p_del">-			(stack_guard_page_start(vma, address) ||</span>
<span class="p_del">-			 stack_guard_page_end(vma, address + PAGE_SIZE)))</span>
<span class="p_del">-		return -ENOENT;</span>
 	if (*flags &amp; FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (*flags &amp; FOLL_REMOTE)
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index f3c4f9d22821..209b33e8c247 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1412,8 +1412,11 @@</span> <span class="p_context"> int do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t pmd)</span>
 	 */
 	if (unlikely(pmd_trans_migrating(*vmf-&gt;pmd))) {
 		page = pmd_page(*vmf-&gt;pmd);
<span class="p_add">+		if (!get_page_unless_zero(page))</span>
<span class="p_add">+			goto out_unlock;</span>
 		spin_unlock(vmf-&gt;ptl);
 		wait_on_page_locked(page);
<span class="p_add">+		put_page(page);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -1445,9 +1448,12 @@</span> <span class="p_context"> int do_huge_pmd_numa_page(struct vm_fault *vmf, pmd_t pmd)</span>
 
 	/* Migration could have started since the pmd_trans_migrating check */
 	if (!page_locked) {
<span class="p_add">+		page_nid = -1;</span>
<span class="p_add">+		if (!get_page_unless_zero(page))</span>
<span class="p_add">+			goto out_unlock;</span>
 		spin_unlock(vmf-&gt;ptl);
 		wait_on_page_locked(page);
<span class="p_del">-		page_nid = -1;</span>
<span class="p_add">+		put_page(page);</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index d7780dfdf541..b85d3d9fc026 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1175,7 +1175,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * page_remove_rmap() in try_to_unmap_one(). So to determine page status
 	 * correctly, we save a copy of the page flags at this time.
 	 */
<span class="p_del">-	page_flags = p-&gt;flags;</span>
<span class="p_add">+	if (PageHuge(p))</span>
<span class="p_add">+		page_flags = hpage-&gt;flags;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		page_flags = p-&gt;flags;</span>
 
 	/*
 	 * unpoison always clear PG_hwpoison inside page lock
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 2437dc08ab36..44a4dfc31682 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -2855,40 +2855,6 @@</span> <span class="p_context"> int do_swap_page(struct vm_fault *vmf)</span>
 }
 
 /*
<span class="p_del">- * This is like a special single-page &quot;expand_{down|up}wards()&quot;,</span>
<span class="p_del">- * except we must first make sure that &#39;address{-|+}PAGE_SIZE&#39;</span>
<span class="p_del">- * doesn&#39;t hit another vma.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)</span>
<span class="p_del">-{</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp; address == vma-&gt;vm_start) {</span>
<span class="p_del">-		struct vm_area_struct *prev = vma-&gt;vm_prev;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Is there a mapping abutting this one below?</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * That&#39;s only ok if it&#39;s the same stack mapping</span>
<span class="p_del">-		 * that has gotten split..</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (prev &amp;&amp; prev-&gt;vm_end == address)</span>
<span class="p_del">-			return prev-&gt;vm_flags &amp; VM_GROWSDOWN ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_downwards(vma, address - PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp; address + PAGE_SIZE == vma-&gt;vm_end) {</span>
<span class="p_del">-		struct vm_area_struct *next = vma-&gt;vm_next;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* As VM_GROWSDOWN but s/below/above/ */</span>
<span class="p_del">-		if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE)</span>
<span class="p_del">-			return next-&gt;vm_flags &amp; VM_GROWSUP ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_upwards(vma, address + PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
<span class="p_chunk">@@ -2904,10 +2870,6 @@</span> <span class="p_context"> static int do_anonymous_page(struct vm_fault *vmf)</span>
 	if (vma-&gt;vm_flags &amp; VM_SHARED)
 		return VM_FAULT_SIGBUS;
 
<span class="p_del">-	/* Check if we need to add a guard page to the stack */</span>
<span class="p_del">-	if (check_stack_guard_page(vma, vmf-&gt;address) &lt; 0)</span>
<span class="p_del">-		return VM_FAULT_SIGSEGV;</span>
<span class="p_del">-</span>
 	/*
 	 * Use pte_alloc() instead of pte_alloc_map().  We can&#39;t run
 	 * pte_offset_map() on pmds where a huge pmd might be created
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index bfbe8856d134..cde1262776dd 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -183,6 +183,7 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	unsigned long retval;
 	unsigned long newbrk, oldbrk;
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_add">+	struct vm_area_struct *next;</span>
 	unsigned long min_brk;
 	bool populate;
 	LIST_HEAD(uf);
<span class="p_chunk">@@ -229,7 +230,8 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	}
 
 	/* Check against existing mmap mappings. */
<span class="p_del">-	if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</span>
<span class="p_add">+	next = find_vma(mm, oldbrk);</span>
<span class="p_add">+	if (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))</span>
 		goto out;
 
 	/* Ok, looks good - let it rip. */
<span class="p_chunk">@@ -253,10 +255,22 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 
 static long vma_compute_subtree_gap(struct vm_area_struct *vma)
 {
<span class="p_del">-	unsigned long max, subtree_gap;</span>
<span class="p_del">-	max = vma-&gt;vm_start;</span>
<span class="p_del">-	if (vma-&gt;vm_prev)</span>
<span class="p_del">-		max -= vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_add">+	unsigned long max, prev_end, subtree_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we</span>
<span class="p_add">+	 * allow two stack_guard_gaps between them here, and when choosing</span>
<span class="p_add">+	 * an unmapped area; whereas when expanding we only require one.</span>
<span class="p_add">+	 * That&#39;s a little inconsistent, but keeps the code here simpler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	max = vm_start_gap(vma);</span>
<span class="p_add">+	if (vma-&gt;vm_prev) {</span>
<span class="p_add">+		prev_end = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+		if (max &gt; prev_end)</span>
<span class="p_add">+			max -= prev_end;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max = 0;</span>
<span class="p_add">+	}</span>
 	if (vma-&gt;vm_rb.rb_left) {
 		subtree_gap = rb_entry(vma-&gt;vm_rb.rb_left,
 				struct vm_area_struct, vm_rb)-&gt;rb_subtree_gap;
<span class="p_chunk">@@ -352,7 +366,7 @@</span> <span class="p_context"> static void validate_mm(struct mm_struct *mm)</span>
 			anon_vma_unlock_read(anon_vma);
 		}
 
<span class="p_del">-		highest_address = vma-&gt;vm_end;</span>
<span class="p_add">+		highest_address = vm_end_gap(vma);</span>
 		vma = vma-&gt;vm_next;
 		i++;
 	}
<span class="p_chunk">@@ -541,7 +555,7 @@</span> <span class="p_context"> void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (vma-&gt;vm_next)
 		vma_gap_update(vma-&gt;vm_next);
 	else
<span class="p_del">-		mm-&gt;highest_vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 
 	/*
 	 * vma-&gt;vm_prev wasn&#39;t known when we followed the rbtree to find the
<span class="p_chunk">@@ -856,7 +870,7 @@</span> <span class="p_context"> int __vma_adjust(struct vm_area_struct *vma, unsigned long start,</span>
 			vma_gap_update(vma);
 		if (end_changed) {
 			if (!next)
<span class="p_del">-				mm-&gt;highest_vm_end = end;</span>
<span class="p_add">+				mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 			else if (!adjust_next)
 				vma_gap_update(next);
 		}
<span class="p_chunk">@@ -941,7 +955,7 @@</span> <span class="p_context"> int __vma_adjust(struct vm_area_struct *vma, unsigned long start,</span>
 			 * mm-&gt;highest_vm_end doesn&#39;t need any update
 			 * in remove_next == 1 case.
 			 */
<span class="p_del">-			VM_WARN_ON(mm-&gt;highest_vm_end != end);</span>
<span class="p_add">+			VM_WARN_ON(mm-&gt;highest_vm_end != vm_end_gap(vma));</span>
 		}
 	}
 	if (insert &amp;&amp; file)
<span class="p_chunk">@@ -1787,7 +1801,7 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit left subtree if it looks promising */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &gt;= low_limit &amp;&amp; vma-&gt;vm_rb.rb_left) {
 			struct vm_area_struct *left =
 				rb_entry(vma-&gt;vm_rb.rb_left,
<span class="p_chunk">@@ -1798,12 +1812,13 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 			}
 		}
 
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 check_current:
 		/* Check if current node has a suitable gap */
 		if (gap_start &gt; high_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_end &gt;= low_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_end &gt;= low_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit right subtree if it looks promising */
<span class="p_chunk">@@ -1825,8 +1840,8 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 			vma = rb_entry(rb_parent(prev),
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_left) {
<span class="p_del">-				gap_start = vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_del">-				gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+				gap_start = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+				gap_end = vm_start_gap(vma);</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1890,7 +1905,7 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit right subtree if it looks promising */
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 		if (gap_start &lt;= high_limit &amp;&amp; vma-&gt;vm_rb.rb_right) {
 			struct vm_area_struct *right =
 				rb_entry(vma-&gt;vm_rb.rb_right,
<span class="p_chunk">@@ -1903,10 +1918,11 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 check_current:
 		/* Check if current node has a suitable gap */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &lt; low_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_start &lt;= high_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_start &lt;= high_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit left subtree if it looks promising */
<span class="p_chunk">@@ -1929,7 +1945,7 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_right) {
 				gap_start = vma-&gt;vm_prev ?
<span class="p_del">-					vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+					vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1967,7 +1983,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct vm_unmapped_area_info info;
 
 	if (len &gt; TASK_SIZE - mmap_min_addr)
<span class="p_chunk">@@ -1978,9 +1994,10 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -2003,7 +2020,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -2018,9 +2035,10 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+				(!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -2155,21 +2173,19 @@</span> <span class="p_context"> find_vma_prev(struct mm_struct *mm, unsigned long addr,</span>
  * update accounting. This is shared with both the
  * grow-up and grow-down cases.
  */
<span class="p_del">-static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)</span>
<span class="p_add">+static int acct_stack_growth(struct vm_area_struct *vma,</span>
<span class="p_add">+			     unsigned long size, unsigned long grow)</span>
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
 	struct rlimit *rlim = current-&gt;signal-&gt;rlim;
<span class="p_del">-	unsigned long new_start, actual_size;</span>
<span class="p_add">+	unsigned long new_start;</span>
 
 	/* address space limit tests */
 	if (!may_expand_vm(mm, vma-&gt;vm_flags, grow))
 		return -ENOMEM;
 
 	/* Stack limit test */
<span class="p_del">-	actual_size = size;</span>
<span class="p_del">-	if (size &amp;&amp; (vma-&gt;vm_flags &amp; (VM_GROWSUP | VM_GROWSDOWN)))</span>
<span class="p_del">-		actual_size -= PAGE_SIZE;</span>
<span class="p_del">-	if (actual_size &gt; READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
<span class="p_add">+	if (size &gt; READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
 		return -ENOMEM;
 
 	/* mlock limit tests */
<span class="p_chunk">@@ -2207,16 +2223,32 @@</span> <span class="p_context"> static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns</span>
 int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
<span class="p_add">+	struct vm_area_struct *next;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error = 0;
 
 	if (!(vma-&gt;vm_flags &amp; VM_GROWSUP))
 		return -EFAULT;
 
<span class="p_del">-	/* Guard against wrapping around to address 0. */</span>
<span class="p_del">-	if (address &lt; PAGE_ALIGN(address+4))</span>
<span class="p_del">-		address = PAGE_ALIGN(address+4);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	/* Guard against exceeding limits of the address space. */</span>
<span class="p_add">+	address &amp;= PAGE_MASK;</span>
<span class="p_add">+	if (address &gt;= TASK_SIZE)</span>
 		return -ENOMEM;
<span class="p_add">+	address += PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address + stack_guard_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Guard against overflow */</span>
<span class="p_add">+	if (gap_addr &lt; address || gap_addr &gt; TASK_SIZE)</span>
<span class="p_add">+		gap_addr = TASK_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	next = vma-&gt;vm_next;</span>
<span class="p_add">+	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr) {</span>
<span class="p_add">+		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
 
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
<span class="p_chunk">@@ -2261,7 +2293,7 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 				if (vma-&gt;vm_next)
 					vma_gap_update(vma-&gt;vm_next);
 				else
<span class="p_del">-					mm-&gt;highest_vm_end = address;</span>
<span class="p_add">+					mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 				spin_unlock(&amp;mm-&gt;page_table_lock);
 
 				perf_event_mmap(vma);
<span class="p_chunk">@@ -2282,6 +2314,8 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 				   unsigned long address)
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
<span class="p_add">+	struct vm_area_struct *prev;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error;
 
 	address &amp;= PAGE_MASK;
<span class="p_chunk">@@ -2289,6 +2323,17 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	if (error)
 		return error;
 
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address - stack_guard_gap;</span>
<span class="p_add">+	if (gap_addr &gt; address)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	prev = vma-&gt;vm_prev;</span>
<span class="p_add">+	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr) {</span>
<span class="p_add">+		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
 		return -ENOMEM;
<span class="p_chunk">@@ -2343,28 +2388,25 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	return error;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Note how expand_stack() refuses to expand the stack all the way to</span>
<span class="p_del">- * abut the next virtual mapping, *unless* that mapping itself is also</span>
<span class="p_del">- * a stack mapping. We want to leave room for a guard page, after all</span>
<span class="p_del">- * (the guard page itself is not added here, that is done by the</span>
<span class="p_del">- * actual page faulting logic)</span>
<span class="p_del">- *</span>
<span class="p_del">- * This matches the behavior of the guard page logic (see mm/memory.c:</span>
<span class="p_del">- * check_stack_guard_page()), which only allows the guard page to be</span>
<span class="p_del">- * removed under these circumstances.</span>
<span class="p_del">- */</span>
<span class="p_add">+/* enforced gap between the expanding stack and other mappings. */</span>
<span class="p_add">+unsigned long stack_guard_gap = 256UL&lt;&lt;PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init cmdline_parse_stack_guard_gap(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long val;</span>
<span class="p_add">+	char *endptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = simple_strtoul(p, &amp;endptr, 10);</span>
<span class="p_add">+	if (!*endptr)</span>
<span class="p_add">+		stack_guard_gap = val &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;stack_guard_gap=&quot;, cmdline_parse_stack_guard_gap);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_STACK_GROWSUP
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *next;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	next = vma-&gt;vm_next;</span>
<span class="p_del">-	if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE) {</span>
<span class="p_del">-		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_upwards(vma, address);
 }
 
<span class="p_chunk">@@ -2386,14 +2428,6 @@</span> <span class="p_context"> find_extend_vma(struct mm_struct *mm, unsigned long addr)</span>
 #else
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *prev;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	prev = vma-&gt;vm_prev;</span>
<span class="p_del">-	if (prev &amp;&amp; prev-&gt;vm_end == address) {</span>
<span class="p_del">-		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_downwards(vma, address);
 }
 
<span class="p_chunk">@@ -2491,7 +2525,7 @@</span> <span class="p_context"> detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		vma-&gt;vm_prev = prev;
 		vma_gap_update(vma);
 	} else
<span class="p_del">-		mm-&gt;highest_vm_end = prev ? prev-&gt;vm_end : 0;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = prev ? vm_end_gap(prev) : 0;</span>
 	tail_vma-&gt;vm_next = NULL;
 
 	/* Kill the cache */
<span class="p_header">diff --git a/mm/swap_cgroup.c b/mm/swap_cgroup.c</span>
<span class="p_header">index ac6318a064d3..3405b4ee1757 100644</span>
<span class="p_header">--- a/mm/swap_cgroup.c</span>
<span class="p_header">+++ b/mm/swap_cgroup.c</span>
<span class="p_chunk">@@ -48,6 +48,9 @@</span> <span class="p_context"> static int swap_cgroup_prepare(int type)</span>
 		if (!page)
 			goto not_enough_page;
 		ctrl-&gt;map[idx] = page;
<span class="p_add">+</span>
<span class="p_add">+		if (!(idx % SWAP_CLUSTER_MAX))</span>
<span class="p_add">+			cond_resched();</span>
 	}
 	return 0;
 not_enough_page:
<span class="p_header">diff --git a/net/ipv6/ila/ila_xlat.c b/net/ipv6/ila/ila_xlat.c</span>
<span class="p_header">index af8f52ee7180..38ae62bb5ed7 100644</span>
<span class="p_header">--- a/net/ipv6/ila/ila_xlat.c</span>
<span class="p_header">+++ b/net/ipv6/ila/ila_xlat.c</span>
<span class="p_chunk">@@ -68,6 +68,7 @@</span> <span class="p_context"> static inline u32 ila_locator_hash(struct ila_locator loc)</span>
 {
 	u32 *v = (u32 *)loc.v32;
 
<span class="p_add">+	__ila_hash_secret_init();</span>
 	return jhash_2words(v[0], v[1], hashrnd);
 }
 
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index ac879bb17870..cd3d47818836 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -862,6 +862,8 @@</span> <span class="p_context"> static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,</span>
 	default:
 		return -EINVAL;
 	}
<span class="p_add">+	sdata-&gt;u.ap.req_smps = sdata-&gt;smps_mode;</span>
<span class="p_add">+</span>
 	sdata-&gt;needed_rx_chains = sdata-&gt;local-&gt;rx_chains;
 
 	sdata-&gt;vif.bss_conf.beacon_int = params-&gt;beacon_interval;
<span class="p_header">diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c</span>
<span class="p_header">index 98999d3d5262..62d13eabe17f 100644</span>
<span class="p_header">--- a/net/mac80211/ibss.c</span>
<span class="p_header">+++ b/net/mac80211/ibss.c</span>
<span class="p_chunk">@@ -66,6 +66,8 @@</span> <span class="p_context"> ieee80211_ibss_build_presp(struct ieee80211_sub_if_data *sdata,</span>
 		    2 + (IEEE80211_MAX_SUPP_RATES - 8) +
 		    2 + sizeof(struct ieee80211_ht_cap) +
 		    2 + sizeof(struct ieee80211_ht_operation) +
<span class="p_add">+		    2 + sizeof(struct ieee80211_vht_cap) +</span>
<span class="p_add">+		    2 + sizeof(struct ieee80211_vht_operation) +</span>
 		    ifibss-&gt;ie_len;
 	presp = kzalloc(sizeof(*presp) + frame_len, GFP_KERNEL);
 	if (!presp)
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 4d7543d1a62c..a654c25f7858 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -1587,12 +1587,16 @@</span> <span class="p_context"> ieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)</span>
 	 */
 	if (!ieee80211_hw_check(&amp;sta-&gt;local-&gt;hw, AP_LINK_PS) &amp;&amp;
 	    !ieee80211_has_morefrags(hdr-&gt;frame_control) &amp;&amp;
<span class="p_add">+	    !ieee80211_is_back_req(hdr-&gt;frame_control) &amp;&amp;</span>
 	    !(status-&gt;rx_flags &amp; IEEE80211_RX_DEFERRED_RELEASE) &amp;&amp;
 	    (rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP ||
 	     rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN) &amp;&amp;
<span class="p_del">-	    /* PM bit is only checked in frames where it isn&#39;t reserved,</span>
<span class="p_add">+	    /*</span>
<span class="p_add">+	     * PM bit is only checked in frames where it isn&#39;t reserved,</span>
 	     * in AP mode it&#39;s reserved in non-bufferable management frames
 	     * (cf. IEEE 802.11-2012 8.2.4.1.7 Power Management field)
<span class="p_add">+	     * BAR frames should be ignored as specified in</span>
<span class="p_add">+	     * IEEE 802.11-2012 10.2.1.2.</span>
 	     */
 	    (!ieee80211_is_mgmt(hdr-&gt;frame_control) ||
 	     ieee80211_is_bufferable_mmpdu(hdr-&gt;frame_control))) {
<span class="p_chunk">@@ -2466,7 +2470,8 @@</span> <span class="p_context"> ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)</span>
 		if (is_multicast_ether_addr(hdr-&gt;addr1)) {
 			mpp_addr = hdr-&gt;addr3;
 			proxied_addr = mesh_hdr-&gt;eaddr1;
<span class="p_del">-		} else if (mesh_hdr-&gt;flags &amp; MESH_FLAGS_AE_A5_A6) {</span>
<span class="p_add">+		} else if ((mesh_hdr-&gt;flags &amp; MESH_FLAGS_AE) ==</span>
<span class="p_add">+			    MESH_FLAGS_AE_A5_A6) {</span>
 			/* has_a4 already checked in ieee80211_rx_mesh_check */
 			mpp_addr = hdr-&gt;addr4;
 			proxied_addr = mesh_hdr-&gt;eaddr2;
<span class="p_header">diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c</span>
<span class="p_header">index 3323a2fb289b..1a9d1e56c705 100644</span>
<span class="p_header">--- a/net/mac80211/sta_info.c</span>
<span class="p_header">+++ b/net/mac80211/sta_info.c</span>
<span class="p_chunk">@@ -2143,7 +2143,7 @@</span> <span class="p_context"> void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo)</span>
 			struct ieee80211_sta_rx_stats *cpurxs;
 
 			cpurxs = per_cpu_ptr(sta-&gt;pcpu_rx_stats, cpu);
<span class="p_del">-			sinfo-&gt;rx_packets += cpurxs-&gt;dropped;</span>
<span class="p_add">+			sinfo-&gt;rx_dropped_misc += cpurxs-&gt;dropped;</span>
 		}
 	}
 
<span class="p_header">diff --git a/net/mac80211/wpa.c b/net/mac80211/wpa.c</span>
<span class="p_header">index c1ef22df865f..cc19614ff4e6 100644</span>
<span class="p_header">--- a/net/mac80211/wpa.c</span>
<span class="p_header">+++ b/net/mac80211/wpa.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/unaligned.h&gt;
 #include &lt;net/mac80211.h&gt;
 #include &lt;crypto/aes.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 
 #include &quot;ieee80211_i.h&quot;
 #include &quot;michael.h&quot;
<span class="p_chunk">@@ -153,7 +154,7 @@</span> <span class="p_context"> ieee80211_rx_h_michael_mic_verify(struct ieee80211_rx_data *rx)</span>
 	data_len = skb-&gt;len - hdrlen - MICHAEL_MIC_LEN;
 	key = &amp;rx-&gt;key-&gt;conf.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];
 	michael_mic(key, hdr, data, data_len, mic);
<span class="p_del">-	if (memcmp(mic, data + data_len, MICHAEL_MIC_LEN) != 0)</span>
<span class="p_add">+	if (crypto_memneq(mic, data + data_len, MICHAEL_MIC_LEN))</span>
 		goto mic_fail;
 
 	/* remove Michael MIC from payload */
<span class="p_chunk">@@ -1048,7 +1049,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx)</span>
 		bip_aad(skb, aad);
 		ieee80211_aes_cmac(key-&gt;u.aes_cmac.tfm, aad,
 				   skb-&gt;data + 24, skb-&gt;len - 24, mic);
<span class="p_del">-		if (memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		if (crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_cmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_chunk">@@ -1098,7 +1099,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_cmac_256_decrypt(struct ieee80211_rx_data *rx)</span>
 		bip_aad(skb, aad);
 		ieee80211_aes_cmac_256(key-&gt;u.aes_cmac.tfm, aad,
 				       skb-&gt;data + 24, skb-&gt;len - 24, mic);
<span class="p_del">-		if (memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		if (crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_cmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_chunk">@@ -1202,7 +1203,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_gmac_decrypt(struct ieee80211_rx_data *rx)</span>
 		if (ieee80211_aes_gmac(key-&gt;u.aes_gmac.tfm, aad, nonce,
 				       skb-&gt;data + 24, skb-&gt;len - 24,
 				       mic) &lt; 0 ||
<span class="p_del">-		    memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		    crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_gmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_header">diff --git a/net/wireless/util.c b/net/wireless/util.c</span>
<span class="p_header">index 68e5f2ecee1a..8b862ab76947 100644</span>
<span class="p_header">--- a/net/wireless/util.c</span>
<span class="p_header">+++ b/net/wireless/util.c</span>
<span class="p_chunk">@@ -454,6 +454,8 @@</span> <span class="p_context"> int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,</span>
 	if (iftype == NL80211_IFTYPE_MESH_POINT)
 		skb_copy_bits(skb, hdrlen, &amp;mesh_flags, 1);
 
<span class="p_add">+	mesh_flags &amp;= MESH_FLAGS_AE;</span>
<span class="p_add">+</span>
 	switch (hdr-&gt;frame_control &amp;
 		cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) {
 	case cpu_to_le16(IEEE80211_FCTL_TODS):
<span class="p_chunk">@@ -469,9 +471,9 @@</span> <span class="p_context"> int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,</span>
 			     iftype != NL80211_IFTYPE_STATION))
 			return -1;
 		if (iftype == NL80211_IFTYPE_MESH_POINT) {
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A4)</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A4)</span>
 				return -1;
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A5_A6) {</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A5_A6) {</span>
 				skb_copy_bits(skb, hdrlen +
 					offsetof(struct ieee80211s_hdr, eaddr1),
 					tmp.h_dest, 2 * ETH_ALEN);
<span class="p_chunk">@@ -487,9 +489,9 @@</span> <span class="p_context"> int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,</span>
 		     ether_addr_equal(tmp.h_source, addr)))
 			return -1;
 		if (iftype == NL80211_IFTYPE_MESH_POINT) {
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A5_A6)</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A5_A6)</span>
 				return -1;
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A4)</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A4)</span>
 				skb_copy_bits(skb, hdrlen +
 					offsetof(struct ieee80211s_hdr, eaddr1),
 					tmp.h_source, ETH_ALEN);
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index 0c2ac318aa7f..71fc0b5570d1 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -1106,10 +1106,8 @@</span> <span class="p_context"> static int selinux_parse_opts_str(char *options,</span>
 
 	opts-&gt;mnt_opts_flags = kcalloc(NUM_SEL_MNT_OPTS, sizeof(int),
 				       GFP_KERNEL);
<span class="p_del">-	if (!opts-&gt;mnt_opts_flags) {</span>
<span class="p_del">-		kfree(opts-&gt;mnt_opts);</span>
<span class="p_add">+	if (!opts-&gt;mnt_opts_flags)</span>
 		goto out_err;
<span class="p_del">-	}</span>
 
 	if (fscontext) {
 		opts-&gt;mnt_opts[num_mnt_opts] = fscontext;
<span class="p_chunk">@@ -1132,6 +1130,7 @@</span> <span class="p_context"> static int selinux_parse_opts_str(char *options,</span>
 	return 0;
 
 out_err:
<span class="p_add">+	security_free_mnt_opts(opts);</span>
 	kfree(context);
 	kfree(defcontext);
 	kfree(fscontext);
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index c8256a89375a..23d685636a67 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -369,8 +369,10 @@</span> <span class="p_context"> enum {</span>
 #define IS_KBL_LP(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x9d71)
 #define IS_KBL_H(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa2f0)
 #define IS_BXT(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x5a98)
<span class="p_add">+#define IS_GLK(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x3198)</span>
 #define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci)) || \
<span class="p_del">-			IS_KBL(pci) || IS_KBL_LP(pci) || IS_KBL_H(pci)</span>
<span class="p_add">+			IS_KBL(pci) || IS_KBL_LP(pci) || IS_KBL_H(pci)	|| \</span>
<span class="p_add">+			IS_GLK(pci)</span>
 
 static char *driver_short_names[] = {
 	[AZX_DRIVER_ICH] = &quot;HDA Intel&quot;,
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 01eff6ce6401..d7b0b0a3a2db 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1364,7 +1364,7 @@</span> <span class="p_context"> u64 snd_usb_interface_dsd_format_quirks(struct snd_usb_audio *chip,</span>
 	/* Amanero Combo384 USB interface with native DSD support */
 	case USB_ID(0x16d0, 0x071a):
 		if (fp-&gt;altsetting == 2) {
<span class="p_del">-			switch (chip-&gt;dev-&gt;descriptor.bcdDevice) {</span>
<span class="p_add">+			switch (le16_to_cpu(chip-&gt;dev-&gt;descriptor.bcdDevice)) {</span>
 			case 0x199:
 				return SNDRV_PCM_FMTBIT_DSD_U32_LE;
 			case 0x19b:

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



