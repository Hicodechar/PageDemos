
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[2/8] iommu/mediatek: Add mt2712 IOMMU support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [2/8] iommu/mediatek: Add mt2712 IOMMU support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=123111">Yong Wu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 11, 2017, 9:56 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1502445377-26936-3-git-send-email-yong.wu@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9895273/mbox/"
   >mbox</a>
|
   <a href="/patch/9895273/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9895273/">/patch/9895273/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3418B602DA for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Aug 2017 09:57:02 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 23C8B28A06
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Aug 2017 09:57:02 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 172EE28A0D; Fri, 11 Aug 2017 09:57:02 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4F4A728A06
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 11 Aug 2017 09:57:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752822AbdHKJ4x (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 11 Aug 2017 05:56:53 -0400
Received: from mailgw01.mediatek.com ([210.61.82.183]:27757 &quot;EHLO
	mailgw01.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S1751842AbdHKJ4t (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 11 Aug 2017 05:56:49 -0400
Received: from mtkcas06.mediatek.inc [(172.21.101.30)] by
	mailgw01.mediatek.com (envelope-from &lt;yong.wu@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 578697443; Fri, 11 Aug 2017 17:56:46 +0800
Received: from mtkcas09.mediatek.inc (172.21.101.178) by
	mtkmbs08n1.mediatek.inc (172.21.101.55) with Microsoft SMTP Server
	(TLS) id 15.0.1210.3; Fri, 11 Aug 2017 17:56:44 +0800
Received: from localhost.localdomain (10.17.3.153) by mtkcas09.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 15.0.1210.3 via
	Frontend Transport; Fri, 11 Aug 2017 17:56:43 +0800
From: Yong Wu &lt;yong.wu@mediatek.com&gt;
To: Joerg Roedel &lt;joro@8bytes.org&gt;, Rob Herring &lt;robh+dt@kernel.org&gt;,
	Matthias Brugger &lt;matthias.bgg@gmail.com&gt;,
	Robin Murphy &lt;robin.murphy@arm.com&gt;
CC: Will Deacon &lt;will.deacon@arm.com&gt;, Daniel Kurtz &lt;djkurtz@google.com&gt;,
	Tomasz Figa &lt;tfiga@google.com&gt;, Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	&lt;linux-mediatek@lists.infradead.org&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;, &lt;arnd@arndb.de&gt;,
	&lt;honghui.zhang@mediatek.com&gt;, &lt;k.zhang@mediatek.com&gt;,
	&lt;cloud.chou@mediatek.com&gt;, Arvind Yadav &lt;arvind.yadav.cs@gmail.com&gt;,
	&lt;youlin.pei@mediatek.com&gt;, &lt;yong.wu@mediatek.com&gt;
Subject: [PATCH 2/8] iommu/mediatek: Add mt2712 IOMMU support
Date: Fri, 11 Aug 2017 17:56:11 +0800
Message-ID: &lt;1502445377-26936-3-git-send-email-yong.wu@mediatek.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1502445377-26936-1-git-send-email-yong.wu@mediatek.com&gt;
References: &lt;1502445377-26936-1-git-send-email-yong.wu@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Aug. 11, 2017, 9:56 a.m.</div>
<pre class="content">
The M4U IP blocks in mt2712 is MTK&#39;s generation2 M4U which use the
Short-descriptor like mt8173, and most of the HW registers are the
same.

The difference is that there are 2 M4U HWs in mt2712 while there&#39;s
only one in mt8173. The purpose of 2 M4U HWs is for balance the
bandwidth.

Normally if there are 2 M4U HWs, there should be 2 iommu domains,
each M4U has a iommu domain.
<span class="signed-off-by">
Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
---
This patch also include a minor issue:
suspend while there is no iommu client. it will hang because
there is no iommu domain at that time.
---
 drivers/iommu/mtk_iommu.c | 48 ++++++++++++++++++++++++++++++++---------------
 drivers/iommu/mtk_iommu.h |  7 +++++++
 drivers/memory/mtk-smi.c  | 40 ++++++++++++++++++++++++++++++++++++---
 3 files changed, 77 insertions(+), 18 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - Aug. 11, 2017, 5:24 p.m.</div>
<pre class="content">
On 11/08/17 10:56, Yong Wu wrote:
<span class="quote">&gt; The M4U IP blocks in mt2712 is MTK&#39;s generation2 M4U which use the</span>
<span class="quote">&gt; Short-descriptor like mt8173, and most of the HW registers are the</span>
<span class="quote">&gt; same.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The difference is that there are 2 M4U HWs in mt2712 while there&#39;s</span>
<span class="quote">&gt; only one in mt8173. The purpose of 2 M4U HWs is for balance the</span>
<span class="quote">&gt; bandwidth.</span>

Heh, I never imagined that theoretical argument I made against global
data in the original driver would become reality so soon :D
<span class="quote">
&gt; Normally if there are 2 M4U HWs, there should be 2 iommu domains,</span>
<span class="quote">&gt; each M4U has a iommu domain.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt; This patch also include a minor issue:</span>
<span class="quote">&gt; suspend while there is no iommu client. it will hang because</span>
<span class="quote">&gt; there is no iommu domain at that time.</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/iommu/mtk_iommu.c | 48 ++++++++++++++++++++++++++++++++---------------</span>
<span class="quote">&gt;  drivers/iommu/mtk_iommu.h |  7 +++++++</span>
<span class="quote">&gt;  drivers/memory/mtk-smi.c  | 40 ++++++++++++++++++++++++++++++++++++---</span>
<span class="quote">&gt;  3 files changed, 77 insertions(+), 18 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; index 91c6d36..da6cedb 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; @@ -54,7 +54,9 @@</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define REG_MMU_CTRL_REG			0x110</span>
<span class="quote">&gt;  #define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="quote">&gt; +/* The TF-protect-select is bit[5:4] in mt2712 while it&#39;s bit[6:5] in mt8173.*/</span>
<span class="quote">&gt;  #define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="quote">&gt; +#define F_MMU_TF_PROT_SEL(prot)			(((prot) &amp; 0x3) &lt;&lt; 4)</span>

In my opinion PROTECT vs. PROT here is too confusing for its own good...
<span class="quote">
&gt;  #define REG_MMU_IVRP_PADDR			0x114</span>
<span class="quote">&gt;  #define F_MMU_IVRP_PA_SET(pa, ext)		(((pa) &gt;&gt; 1) | ((!!(ext)) &lt;&lt; 31))</span>
<span class="quote">&gt; @@ -301,10 +303,6 @@ static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt;  			data-&gt;m4u_dom = NULL;</span>
<span class="quote">&gt;  			return ret;</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt; -	} else if (data-&gt;m4u_dom != dom) {</span>
<span class="quote">&gt; -		/* All the client devices should be in the same m4u domain */</span>
<span class="quote">&gt; -		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="quote">&gt; -		return -EPERM;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	mtk_iommu_config(data, dev, true);</span>
<span class="quote">&gt; @@ -464,8 +462,12 @@ static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt;  		return ret;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; -		F_MMU_TF_PROTECT_SEL(2);</span>
<span class="quote">&gt; +	if (data-&gt;m4u_type == M4U_MT8173) {</span>
<span class="quote">&gt; +		regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; +			F_MMU_TF_PROTECT_SEL(2);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		regval = F_MMU_TF_PROT_SEL(2);</span>

...and it would be a bit more obvious to just use
F_MMU_TF_PROTECT_SEL(2) &gt;&gt; 1 here (with the comment from above).
Alternatively, the really bullet-proof option would be something like:

#define F_MMU_TF_PROTECT_SEL_SHIFT(data) \
	((data)-&gt;m4u_type == MT2172 ? 4 : 5)
#define F_MMU_TF_PROTECT_SEL(prot, data) \
	((prot) &amp; 0x3) &lt;&lt; F_MMU_TF_PROTECT_SEL_SHIFT(data))
<span class="quote">
&gt; +	}</span>
<span class="quote">&gt;  	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	regval = F_L2_MULIT_HIT_EN |</span>
<span class="quote">&gt; @@ -487,9 +489,11 @@ static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base, data-&gt;enable_4GB),</span>
<span class="quote">&gt;  		       data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  	writel_relaxed(0, data-&gt;base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; -	writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* It&#39;s MISC control register whose default value is ok except mt8173.*/</span>
<span class="quote">&gt; +	if (data-&gt;m4u_type == M4U_MT8173)</span>
<span class="quote">&gt; +		writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt;  			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="quote">&gt; @@ -521,6 +525,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;  	if (!data)</span>
<span class="quote">&gt;  		return -ENOMEM;</span>
<span class="quote">&gt;  	data-&gt;dev = dev;</span>
<span class="quote">&gt; +	data-&gt;m4u_type = (enum mtk_iommu_type)of_device_get_match_data(dev);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt;  	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; @@ -554,6 +559,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;  	for (i = 0; i &lt; larb_nr; i++) {</span>
<span class="quote">&gt;  		struct device_node *larbnode;</span>
<span class="quote">&gt;  		struct platform_device *plarbdev;</span>
<span class="quote">&gt; +		unsigned int id;</span>

Strictly, this should be u32...
<span class="quote">
&gt;  </span>
<span class="quote">&gt;  		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="quote">&gt;  		if (!larbnode)</span>
<span class="quote">&gt; @@ -562,6 +568,10 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;  		if (!of_device_is_available(larbnode))</span>
<span class="quote">&gt;  			continue;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +		ret = of_property_read_u32(larbnode, &quot;mediatek,larb-id&quot;, &amp;id);</span>
<span class="quote">&gt; +		if (ret)/* The id is consecutive if there is no this property */</span>
<span class="quote">&gt; +			id = i;</span>

...but wouldn&#39;t it make more sense for the SMI driver to handle this?
Admittedly it looks like only this driver knows the default IDs thanks
to the ordering of the phandle args, but the SMI driver could at least
initialise larb-&gt;larbid to some sentinel value which could be detected
and replaced with i here.
<span class="quote">
&gt; +</span>
<span class="quote">&gt;  		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt;  		if (!plarbdev) {</span>
<span class="quote">&gt;  			plarbdev = of_platform_device_create(</span>
<span class="quote">&gt; @@ -572,7 +582,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;  				return -EPROBE_DEFER;</span>
<span class="quote">&gt;  			}</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt; -		data-&gt;smi_imu.larb_imu[i].dev = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; +		data-&gt;smi_imu.larb_imu[id].dev = &amp;plarbdev-&gt;dev;</span>

Changing the way the larb_imu array is indexed also seems to create a
worrying inconsistency with mtk_iommu_v1.
<span class="quote">
&gt;  		component_match_add_release(dev, &amp;match, release_of,</span>
<span class="quote">&gt;  					    compare_of, larbnode);</span>
<span class="quote">&gt; @@ -640,8 +650,6 @@ static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt;  	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt;  	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="quote">&gt; -		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt;  	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="quote">&gt;  		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt;  	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; @@ -650,15 +658,19 @@ static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt;  	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt;  	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base, data-&gt;enable_4GB),</span>
<span class="quote">&gt;  		       base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +	if (data-&gt;m4u_dom)</span>
<span class="quote">&gt; +		writel(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="quote">&gt; +		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="quote">&gt; +static const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="quote">&gt;  	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="quote">&gt; -	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="quote">&gt; +	{ .compatible = &quot;mediatek,mt2712-m4u&quot;, .data = (void *)M4U_MT2712},</span>
<span class="quote">&gt; +	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, .data = (void *)M4U_MT8173},</span>
<span class="quote">&gt;  	{}</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -667,16 +679,20 @@ static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt;  	.remove	= mtk_iommu_remove,</span>
<span class="quote">&gt;  	.driver	= {</span>
<span class="quote">&gt;  		.name = &quot;mtk-iommu&quot;,</span>
<span class="quote">&gt; -		.of_match_table = mtk_iommu_of_ids,</span>
<span class="quote">&gt; +		.of_match_table = of_match_ptr(mtk_iommu_of_ids),</span>
<span class="quote">&gt;  		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; +	static bool init_done;</span>
<span class="quote">&gt;  	int ret;</span>
<span class="quote">&gt;  	struct platform_device *pdev;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	if (init_done)</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +</span>

Actually, you can simply get rid of the whole init_fn now - the
IOMMU_OF_DECLARE() table only remains as a way to identify built-in
drivers for the probe-deferral decision. Hopefully the dodgy-looking
forced creation of plarbdev in probe could go away as well.
<span class="quote">
&gt;  	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="quote">&gt;  	if (!pdev)</span>
<span class="quote">&gt;  		return -ENOMEM;</span>
<span class="quote">&gt; @@ -686,8 +702,10 @@ static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="quote">&gt;  		pr_err(&quot;%s: Failed to register driver\n&quot;, __func__);</span>
<span class="quote">&gt;  		return ret;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; +	init_done = true;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; +IOMMU_OF_DECLARE(mt8173m4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; +IOMMU_OF_DECLARE(mt2712m4u, &quot;mediatek,mt2712-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; diff --git a/drivers/iommu/mtk_iommu.h b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; index c06cc91..cd729a3 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; +++ b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; @@ -34,6 +34,12 @@ struct mtk_iommu_suspend_reg {</span>
<span class="quote">&gt;  	u32				int_main_control;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +enum mtk_iommu_type {</span>
<span class="quote">&gt; +	M4U_MT2701,</span>
<span class="quote">&gt; +	M4U_MT2712,</span>
<span class="quote">&gt; +	M4U_MT8173,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  struct mtk_iommu_domain;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  struct mtk_iommu_data {</span>
<span class="quote">&gt; @@ -50,6 +56,7 @@ struct mtk_iommu_data {</span>
<span class="quote">&gt;  	bool				tlb_flush_active;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	struct iommu_device		iommu;</span>
<span class="quote">&gt; +	enum mtk_iommu_type		m4u_type;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static inline int compare_of(struct device *dev, void *data)</span>
<span class="quote">&gt; diff --git a/drivers/memory/mtk-smi.c b/drivers/memory/mtk-smi.c</span>
<span class="quote">&gt; index 13f8c45..ec06d2b 100644</span>
<span class="quote">&gt; --- a/drivers/memory/mtk-smi.c</span>
<span class="quote">&gt; +++ b/drivers/memory/mtk-smi.c</span>
<span class="quote">&gt; @@ -23,7 +23,10 @@</span>
<span class="quote">&gt;  #include &lt;soc/mediatek/smi.h&gt;</span>
<span class="quote">&gt;  #include &lt;dt-bindings/memory/mt2701-larb-port.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/* mt8173 */</span>
<span class="quote">&gt;  #define SMI_LARB_MMU_EN		0xf00</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* mt2701 */</span>
<span class="quote">&gt;  #define REG_SMI_SECUR_CON_BASE		0x5c0</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /* every register control 8 port, register offset 0x4 */</span>
<span class="quote">&gt; @@ -41,6 +44,10 @@</span>
<span class="quote">&gt;  /* mt2701 domain should be set to 3 */</span>
<span class="quote">&gt;  #define SMI_SECUR_CON_VAL_DOMAIN(id)	(0x3 &lt;&lt; ((((id) &amp; 0x7) &lt;&lt; 2) + 1))</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/* mt2712 */</span>
<span class="quote">&gt; +#define SMI_LARB_NONSEC_CON(id)	(0x380 + (id * 4))</span>
<span class="quote">&gt; +#define F_MMU_EN		BIT(0)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  struct mtk_smi_larb_gen {</span>
<span class="quote">&gt;  	bool need_larbid;</span>
<span class="quote">&gt;  	int port_in_larb[MTK_LARB_NR_MAX + 1];</span>
<span class="quote">&gt; @@ -149,7 +156,7 @@ void mtk_smi_larb_put(struct device *larbdev)</span>
<span class="quote">&gt;  	struct mtk_smi_iommu *smi_iommu = data;</span>
<span class="quote">&gt;  	unsigned int         i;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	for (i = 0; i &lt; smi_iommu-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; +	for (i = 0; i &lt; MTK_LARB_NR_MAX; i++) {</span>

This initially looked suspicious, but I guess it&#39;s related to the
earlier change to indexing. As a result we seem to have a bit of a
redundant mess where some things are using larb-&gt;larbid and others are
relying on inferring it from the index in larb_imu.

I&#39;m not sure whether it would end up better to use larbid consistently
everywhere, or to convert everything to make make larb_imu officially a
sparse array indexed by ID (and thus remove smi_iommu-&gt;larb_nr and
larb-&gt;larbid), but a weird mix of both is not a great idea.
<span class="quote">
&gt;  		if (dev == smi_iommu-&gt;larb_imu[i].dev) {</span>
<span class="quote">&gt;  			/* The &#39;mmu&#39; may be updated in iommu-attach/detach. */</span>
<span class="quote">&gt;  			larb-&gt;mmu = &amp;smi_iommu-&gt;larb_imu[i].mmu;</span>
<span class="quote">&gt; @@ -159,13 +166,28 @@ void mtk_smi_larb_put(struct device *larbdev)</span>
<span class="quote">&gt;  	return -ENODEV;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -static void mtk_smi_larb_config_port(struct device *dev)</span>
<span class="quote">&gt; +static void mtk_smi_larb_config_port_mt8173(struct device *dev)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct mtk_smi_larb *larb = dev_get_drvdata(dev);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	writel(*larb-&gt;mmu, larb-&gt;base + SMI_LARB_MMU_EN);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static void mtk_smi_larb_config_port_mt2712(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mtk_smi_larb *larb = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +	u32 reg;</span>
<span class="quote">&gt; +	int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; 32; i++) {</span>
<span class="quote">&gt; +		if (*larb-&gt;mmu &amp; BIT(i)) {</span>

Seeing this immediately make me think of:

	unsigned long enable = *larb-&gt;mmu;

	for_each_set_bit(i, &amp;enable, 32) {
		...
	}

but maybe that&#39;s overkill :/

Robin.
<span class="quote">
&gt; +			reg = readl_relaxed(larb-&gt;base +</span>
<span class="quote">&gt; +					    SMI_LARB_NONSEC_CON(i));</span>
<span class="quote">&gt; +			reg |= F_MMU_EN;</span>
<span class="quote">&gt; +			writel(reg, larb-&gt;base + SMI_LARB_NONSEC_CON(i));</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -211,7 +233,11 @@ static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static const struct mtk_smi_larb_gen mtk_smi_larb_mt8173 = {</span>
<span class="quote">&gt;  	/* mt8173 do not need the port in larb */</span>
<span class="quote">&gt; -	.config_port = mtk_smi_larb_config_port,</span>
<span class="quote">&gt; +	.config_port = mtk_smi_larb_config_port_mt8173,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct mtk_smi_larb_gen mtk_smi_larb_mt2712 = {</span>
<span class="quote">&gt; +	.config_port = mtk_smi_larb_config_port_mt2712,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static const struct mtk_smi_larb_gen mtk_smi_larb_mt2701 = {</span>
<span class="quote">&gt; @@ -232,6 +258,10 @@ static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
<span class="quote">&gt;  		.compatible = &quot;mediatek,mt2701-smi-larb&quot;,</span>
<span class="quote">&gt;  		.data = &amp;mtk_smi_larb_mt2701</span>
<span class="quote">&gt;  	},</span>
<span class="quote">&gt; +	{</span>
<span class="quote">&gt; +		.compatible = &quot;mediatek,mt2712-smi-larb&quot;,</span>
<span class="quote">&gt; +		.data = &amp;mtk_smi_larb_mt2712</span>
<span class="quote">&gt; +	},</span>
<span class="quote">&gt;  	{}</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -318,6 +348,10 @@ static int mtk_smi_larb_remove(struct platform_device *pdev)</span>
<span class="quote">&gt;  		.compatible = &quot;mediatek,mt2701-smi-common&quot;,</span>
<span class="quote">&gt;  		.data = (void *)MTK_SMI_GEN1</span>
<span class="quote">&gt;  	},</span>
<span class="quote">&gt; +	{</span>
<span class="quote">&gt; +		.compatible = &quot;mediatek,mt2712-smi-common&quot;,</span>
<span class="quote">&gt; +		.data = (void *)MTK_SMI_GEN2</span>
<span class="quote">&gt; +	},</span>
<span class="quote">&gt;  	{}</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - Aug. 12, 2017, 10:04 a.m.</div>
<pre class="content">
On Fri, 2017-08-11 at 18:24 +0100, Robin Murphy wrote:
<span class="quote">&gt; On 11/08/17 10:56, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; The M4U IP blocks in mt2712 is MTK&#39;s generation2 M4U which use the</span>
<span class="quote">&gt; &gt; Short-descriptor like mt8173, and most of the HW registers are the</span>
<span class="quote">&gt; &gt; same.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The difference is that there are 2 M4U HWs in mt2712 while there&#39;s</span>
<span class="quote">&gt; &gt; only one in mt8173. The purpose of 2 M4U HWs is for balance the</span>
<span class="quote">&gt; &gt; bandwidth.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Heh, I never imagined that theoretical argument I made against global</span>
<span class="quote">&gt; data in the original driver would become reality so soon :D</span>

Sorry for this.

The global data you said should be &quot;static LIST_HEAD(m4ulist); &quot;

Actually, After this patch, the mt2712 IOMMU can work successfully.

In order to simplify the IOMMU client code, we add that global data to
merge 2 IOMMU domains into one, then they don&#39;t need map the iova range
from a iommu domain into another.

I&#39;m not familiar with SMMU. The SMMU should have so many iommu
domains(each context bank has one.). So how the SMMU deal with this
case: Does the modules in different context banks need share the iova?
How does they share the iova?
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; Normally if there are 2 M4U HWs, there should be 2 iommu domains,</span>
<span class="quote">&gt; &gt; each M4U has a iommu domain.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt; This patch also include a minor issue:</span>
<span class="quote">&gt; &gt; suspend while there is no iommu client. it will hang because</span>
<span class="quote">&gt; &gt; there is no iommu domain at that time.</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  drivers/iommu/mtk_iommu.c | 48 ++++++++++++++++++++++++++++++++---------------</span>
<span class="quote">&gt; &gt;  drivers/iommu/mtk_iommu.h |  7 +++++++</span>
<span class="quote">&gt; &gt;  drivers/memory/mtk-smi.c  | 40 ++++++++++++++++++++++++++++++++++++---</span>
<span class="quote">&gt; &gt;  3 files changed, 77 insertions(+), 18 deletions(-)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; &gt; index 91c6d36..da6cedb 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/mtk_iommu.c</span>
<span class="quote">&gt; &gt; @@ -54,7 +54,9 @@</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  #define REG_MMU_CTRL_REG			0x110</span>
<span class="quote">&gt; &gt;  #define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="quote">&gt; &gt; +/* The TF-protect-select is bit[5:4] in mt2712 while it&#39;s bit[6:5] in mt8173.*/</span>
<span class="quote">&gt; &gt;  #define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="quote">&gt; &gt; +#define F_MMU_TF_PROT_SEL(prot)			(((prot) &amp; 0x3) &lt;&lt; 4)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In my opinion PROTECT vs. PROT here is too confusing for its own good...</span>

.Both the strings are from the coda released by our HW DE..

And your suggestion looks better. I will use:

/* mt2712 is named by F_MMU_TF_PROT_SEL */
#define F_MMU_TF_PROTECT_SEL_SHIFT(data) \
 	((data)-&gt;m4u_type == MT2172 ? 4 : 5)
#define F_MMU_TF_PROTECT_SEL(prot, data) \
 	((prot) &amp; 0x3) &lt;&lt; F_MMU_TF_PROTECT_SEL_SHIFT(data))
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;  #define REG_MMU_IVRP_PADDR			0x114</span>
<span class="quote">&gt; &gt;  #define F_MMU_IVRP_PA_SET(pa, ext)		(((pa) &gt;&gt; 1) | ((!!(ext)) &lt;&lt; 31))</span>
<span class="quote">&gt; &gt; @@ -301,10 +303,6 @@ static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="quote">&gt; &gt;  			data-&gt;m4u_dom = NULL;</span>
<span class="quote">&gt; &gt;  			return ret;</span>
<span class="quote">&gt; &gt;  		}</span>
<span class="quote">&gt; &gt; -	} else if (data-&gt;m4u_dom != dom) {</span>
<span class="quote">&gt; &gt; -		/* All the client devices should be in the same m4u domain */</span>
<span class="quote">&gt; &gt; -		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="quote">&gt; &gt; -		return -EPERM;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	mtk_iommu_config(data, dev, true);</span>
<span class="quote">&gt; &gt; @@ -464,8 +462,12 @@ static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt; &gt;  		return ret;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; &gt; -		F_MMU_TF_PROTECT_SEL(2);</span>
<span class="quote">&gt; &gt; +	if (data-&gt;m4u_type == M4U_MT8173) {</span>
<span class="quote">&gt; &gt; +		regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="quote">&gt; &gt; +			F_MMU_TF_PROTECT_SEL(2);</span>
<span class="quote">&gt; &gt; +	} else {</span>
<span class="quote">&gt; &gt; +		regval = F_MMU_TF_PROT_SEL(2);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...and it would be a bit more obvious to just use</span>
<span class="quote">&gt; F_MMU_TF_PROTECT_SEL(2) &gt;&gt; 1 here (with the comment from above).</span>
<span class="quote">&gt; Alternatively, the really bullet-proof option would be something like:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; #define F_MMU_TF_PROTECT_SEL_SHIFT(data) \</span>
<span class="quote">&gt; 	((data)-&gt;m4u_type == MT2172 ? 4 : 5)</span>
<span class="quote">&gt; #define F_MMU_TF_PROTECT_SEL(prot, data) \</span>
<span class="quote">&gt; 	((prot) &amp; 0x3) &lt;&lt; F_MMU_TF_PROTECT_SEL_SHIFT(data))</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt;  	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	regval = F_L2_MULIT_HIT_EN |</span>
<span class="quote">&gt; &gt; @@ -487,9 +489,11 @@ static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base, data-&gt;enable_4GB),</span>
<span class="quote">&gt; &gt;  		       data-&gt;base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; -</span>
<span class="quote">&gt; &gt;  	writel_relaxed(0, data-&gt;base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; &gt; -	writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	/* It&#39;s MISC control register whose default value is ok except mt8173.*/</span>
<span class="quote">&gt; &gt; +	if (data-&gt;m4u_type == M4U_MT8173)</span>
<span class="quote">&gt; &gt; +		writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="quote">&gt; &gt;  			     dev_name(data-&gt;dev), (void *)data)) {</span>
<span class="quote">&gt; &gt; @@ -521,6 +525,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt;  	if (!data)</span>
<span class="quote">&gt; &gt;  		return -ENOMEM;</span>
<span class="quote">&gt; &gt;  	data-&gt;dev = dev;</span>
<span class="quote">&gt; &gt; +	data-&gt;m4u_type = (enum mtk_iommu_type)of_device_get_match_data(dev);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="quote">&gt; &gt;  	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="quote">&gt; &gt; @@ -554,6 +559,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt;  	for (i = 0; i &lt; larb_nr; i++) {</span>
<span class="quote">&gt; &gt;  		struct device_node *larbnode;</span>
<span class="quote">&gt; &gt;  		struct platform_device *plarbdev;</span>
<span class="quote">&gt; &gt; +		unsigned int id;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Strictly, this should be u32...</span>

OK.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);</span>
<span class="quote">&gt; &gt;  		if (!larbnode)</span>
<span class="quote">&gt; &gt; @@ -562,6 +568,10 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt;  		if (!of_device_is_available(larbnode))</span>
<span class="quote">&gt; &gt;  			continue;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +		ret = of_property_read_u32(larbnode, &quot;mediatek,larb-id&quot;, &amp;id);</span>
<span class="quote">&gt; &gt; +		if (ret)/* The id is consecutive if there is no this property */</span>
<span class="quote">&gt; &gt; +			id = i;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...but wouldn&#39;t it make more sense for the SMI driver to handle this?</span>
<span class="quote">&gt; Admittedly it looks like only this driver knows the default IDs thanks</span>
<span class="quote">&gt; to the ordering of the phandle args, but the SMI driver could at least</span>
<span class="quote">&gt; initialise larb-&gt;larbid to some sentinel value which could be detected</span>
<span class="quote">&gt; and replaced with i here.</span>

From the HW diagram before, the &quot;mediatek,larbs&quot; is
&quot;mediatek,larbs = &lt;&amp;larb0 &amp;larb1 &amp;larb2 &amp;larb3 &amp;larb6&gt;&quot; in M4U0. and
&quot;mediatek,larbs = &lt;&amp;larb4 &amp;larb5 &amp;larb7&gt;&quot; in M4U1.

Both are not consecutive..this is different with mt8173 and mt2701.

The problem is that: In the mtk_iommu_config, it will get the larbid via
&quot;larbid = MTK_M4U_TO_LARB(fwspec-&gt;ids[i])&quot;.
This function will get the right larbid.

Thus I have to initialize the array &quot;data-&gt;smi_imu.larb_imu&quot; with the
real lardid here.

SMI driver will probe defer because it is delayed by MTK power-domain.
It will be very late to initialize the larb-id. So currently IOMMU
initialize the array &quot;smi_imu.larb_imu&quot; according to the real larbid,
and later SMI driver read the array to get the iommu information about
each larb.
Thus, is there some other way the SMI driver can help handle this?

About &quot;the ordering of the phandle args&quot;, I have requested it must 
sort in the binding description of &quot;mediatek,larbs&quot;.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; &gt;  		if (!plarbdev) {</span>
<span class="quote">&gt; &gt;  			plarbdev = of_platform_device_create(</span>
<span class="quote">&gt; &gt; @@ -572,7 +582,7 @@ static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt;  				return -EPROBE_DEFER;</span>
<span class="quote">&gt; &gt;  			}</span>
<span class="quote">&gt; &gt;  		}</span>
<span class="quote">&gt; &gt; -		data-&gt;smi_imu.larb_imu[i].dev = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +		data-&gt;smi_imu.larb_imu[id].dev = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Changing the way the larb_imu array is indexed also seems to create a</span>
<span class="quote">&gt; worrying inconsistency with mtk_iommu_v1.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;  		component_match_add_release(dev, &amp;match, release_of,</span>
<span class="quote">&gt; &gt;  					    compare_of, larbnode);</span>
<span class="quote">&gt; &gt; @@ -640,8 +650,6 @@ static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; &gt;  	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;</span>
<span class="quote">&gt; &gt;  	void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="quote">&gt; &gt; -		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt;  	writel_relaxed(reg-&gt;standard_axi_mode,</span>
<span class="quote">&gt; &gt;  		       base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt;  	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; &gt; @@ -650,15 +658,19 @@ static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; &gt;  	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; &gt;  	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base, data-&gt;enable_4GB),</span>
<span class="quote">&gt; &gt;  		       base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; +	if (data-&gt;m4u_dom)</span>
<span class="quote">&gt; &gt; +		writel(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="quote">&gt; &gt; +		       base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt;  	return 0;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="quote">&gt; &gt; +static const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="quote">&gt; &gt;  	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="quote">&gt; &gt; -	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="quote">&gt; &gt; +	{ .compatible = &quot;mediatek,mt2712-m4u&quot;, .data = (void *)M4U_MT2712},</span>
<span class="quote">&gt; &gt; +	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, .data = (void *)M4U_MT8173},</span>
<span class="quote">&gt; &gt;  	{}</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; @@ -667,16 +679,20 @@ static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; &gt;  	.remove	= mtk_iommu_remove,</span>
<span class="quote">&gt; &gt;  	.driver	= {</span>
<span class="quote">&gt; &gt;  		.name = &quot;mtk-iommu&quot;,</span>
<span class="quote">&gt; &gt; -		.of_match_table = mtk_iommu_of_ids,</span>
<span class="quote">&gt; &gt; +		.of_match_table = of_match_ptr(mtk_iommu_of_ids),</span>
<span class="quote">&gt; &gt;  		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; +	static bool init_done;</span>
<span class="quote">&gt; &gt;  	int ret;</span>
<span class="quote">&gt; &gt;  	struct platform_device *pdev;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +	if (init_done)</span>
<span class="quote">&gt; &gt; +		return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Actually, you can simply get rid of the whole init_fn now - the</span>

Thanks. It looks ok after I change here to subsys_initcall.
<span class="quote">
&gt; IOMMU_OF_DECLARE() table only remains as a way to identify built-in</span>
<span class="quote">&gt; drivers for the probe-deferral decision. Hopefully the dodgy-looking</span>

Do you means that IOMMU_OF_DECLARE is needed by probe-deferral drivers?

I tested a deferal driver without IOMMU_OF_DEDCALRE.It could also enter
our of_late. all the flow looks normal.
<span class="quote">
&gt; forced creation of plarbdev in probe could go away as well.</span>

Yes. I can get rid of it.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;  	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="quote">&gt; &gt;  	if (!pdev)</span>
<span class="quote">&gt; &gt;  		return -ENOMEM;</span>
<span class="quote">&gt; &gt; @@ -686,8 +702,10 @@ static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="quote">&gt; &gt;  		pr_err(&quot;%s: Failed to register driver\n&quot;, __func__);</span>
<span class="quote">&gt; &gt;  		return ret;</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt; +	init_done = true;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	return 0;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; &gt; +IOMMU_OF_DECLARE(mt8173m4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; &gt; +IOMMU_OF_DECLARE(mt2712m4u, &quot;mediatek,mt2712-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/mtk_iommu.h b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; &gt; index c06cc91..cd729a3 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/mtk_iommu.h</span>
<span class="quote">&gt; &gt; @@ -34,6 +34,12 @@ struct mtk_iommu_suspend_reg {</span>
<span class="quote">&gt; &gt;  	u32				int_main_control;</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +enum mtk_iommu_type {</span>
<span class="quote">&gt; &gt; +	M4U_MT2701,</span>
<span class="quote">&gt; &gt; +	M4U_MT2712,</span>
<span class="quote">&gt; &gt; +	M4U_MT8173,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  struct mtk_iommu_domain;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  struct mtk_iommu_data {</span>
<span class="quote">&gt; &gt; @@ -50,6 +56,7 @@ struct mtk_iommu_data {</span>
<span class="quote">&gt; &gt;  	bool				tlb_flush_active;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	struct iommu_device		iommu;</span>
<span class="quote">&gt; &gt; +	enum mtk_iommu_type		m4u_type;</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static inline int compare_of(struct device *dev, void *data)</span>
<span class="quote">&gt; &gt; diff --git a/drivers/memory/mtk-smi.c b/drivers/memory/mtk-smi.c</span>
<span class="quote">&gt; &gt; index 13f8c45..ec06d2b 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/memory/mtk-smi.c</span>
<span class="quote">&gt; &gt; +++ b/drivers/memory/mtk-smi.c</span>
<span class="quote">&gt; &gt; @@ -23,7 +23,10 @@</span>
<span class="quote">&gt; &gt;  #include &lt;soc/mediatek/smi.h&gt;</span>
<span class="quote">&gt; &gt;  #include &lt;dt-bindings/memory/mt2701-larb-port.h&gt;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +/* mt8173 */</span>
<span class="quote">&gt; &gt;  #define SMI_LARB_MMU_EN		0xf00</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +/* mt2701 */</span>
<span class="quote">&gt; &gt;  #define REG_SMI_SECUR_CON_BASE		0x5c0</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  /* every register control 8 port, register offset 0x4 */</span>
<span class="quote">&gt; &gt; @@ -41,6 +44,10 @@</span>
<span class="quote">&gt; &gt;  /* mt2701 domain should be set to 3 */</span>
<span class="quote">&gt; &gt;  #define SMI_SECUR_CON_VAL_DOMAIN(id)	(0x3 &lt;&lt; ((((id) &amp; 0x7) &lt;&lt; 2) + 1))</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +/* mt2712 */</span>
<span class="quote">&gt; &gt; +#define SMI_LARB_NONSEC_CON(id)	(0x380 + (id * 4))</span>
<span class="quote">&gt; &gt; +#define F_MMU_EN		BIT(0)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  struct mtk_smi_larb_gen {</span>
<span class="quote">&gt; &gt;  	bool need_larbid;</span>
<span class="quote">&gt; &gt;  	int port_in_larb[MTK_LARB_NR_MAX + 1];</span>
<span class="quote">&gt; &gt; @@ -149,7 +156,7 @@ void mtk_smi_larb_put(struct device *larbdev)</span>
<span class="quote">&gt; &gt;  	struct mtk_smi_iommu *smi_iommu = data;</span>
<span class="quote">&gt; &gt;  	unsigned int         i;</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -	for (i = 0; i &lt; smi_iommu-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; MTK_LARB_NR_MAX; i++) {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This initially looked suspicious, but I guess it&#39;s related to the</span>
<span class="quote">&gt; earlier change to indexing. As a result we seem to have a bit of a</span>
<span class="quote">&gt; redundant mess where some things are using larb-&gt;larbid and others are</span>
<span class="quote">&gt; relying on inferring it from the index in larb_imu.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m not sure whether it would end up better to use larbid consistently</span>
<span class="quote">&gt; everywhere, or to convert everything to make make larb_imu officially a</span>
<span class="quote">&gt; sparse array indexed by ID (and thus remove smi_iommu-&gt;larb_nr and</span>
<span class="quote">&gt; larb-&gt;larbid), but a weird mix of both is not a great idea.</span>

see above.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt;  		if (dev == smi_iommu-&gt;larb_imu[i].dev) {</span>
<span class="quote">&gt; &gt;  			/* The &#39;mmu&#39; may be updated in iommu-attach/detach. */</span>
<span class="quote">&gt; &gt;  			larb-&gt;mmu = &amp;smi_iommu-&gt;larb_imu[i].mmu;</span>
<span class="quote">&gt; &gt; @@ -159,13 +166,28 @@ void mtk_smi_larb_put(struct device *larbdev)</span>
<span class="quote">&gt; &gt;  	return -ENODEV;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; -static void mtk_smi_larb_config_port(struct device *dev)</span>
<span class="quote">&gt; &gt; +static void mtk_smi_larb_config_port_mt8173(struct device *dev)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;  	struct mtk_smi_larb *larb = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	writel(*larb-&gt;mmu, larb-&gt;base + SMI_LARB_MMU_EN);</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; +static void mtk_smi_larb_config_port_mt2712(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	struct mtk_smi_larb *larb = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt; +	u32 reg;</span>
<span class="quote">&gt; &gt; +	int i;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	for (i = 0; i &lt; 32; i++) {</span>
<span class="quote">&gt; &gt; +		if (*larb-&gt;mmu &amp; BIT(i)) {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Seeing this immediately make me think of:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	unsigned long enable = *larb-&gt;mmu;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	for_each_set_bit(i, &amp;enable, 32) {</span>
<span class="quote">&gt; 		...</span>
<span class="quote">&gt; 	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; but maybe that&#39;s overkill :/</span>

Good enough..I will use &quot;u32&quot; to instead of &quot;unsigned long&quot; above.
<span class="quote">
&gt; </span>
<span class="quote">&gt; Robin.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +			reg = readl_relaxed(larb-&gt;base +</span>
<span class="quote">&gt; &gt; +					    SMI_LARB_NONSEC_CON(i));</span>
<span class="quote">&gt; &gt; +			reg |= F_MMU_EN;</span>
<span class="quote">&gt; &gt; +			writel(reg, larb-&gt;base + SMI_LARB_NONSEC_CON(i));</span>
<span class="quote">&gt; &gt; +		}</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; @@ -211,7 +233,11 @@ static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static const struct mtk_smi_larb_gen mtk_smi_larb_mt8173 = {</span>
<span class="quote">&gt; &gt;  	/* mt8173 do not need the port in larb */</span>
<span class="quote">&gt; &gt; -	.config_port = mtk_smi_larb_config_port,</span>
<span class="quote">&gt; &gt; +	.config_port = mtk_smi_larb_config_port_mt8173,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static const struct mtk_smi_larb_gen mtk_smi_larb_mt2712 = {</span>
<span class="quote">&gt; &gt; +	.config_port = mtk_smi_larb_config_port_mt2712,</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  static const struct mtk_smi_larb_gen mtk_smi_larb_mt2701 = {</span>
<span class="quote">&gt; &gt; @@ -232,6 +258,10 @@ static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
<span class="quote">&gt; &gt;  		.compatible = &quot;mediatek,mt2701-smi-larb&quot;,</span>
<span class="quote">&gt; &gt;  		.data = &amp;mtk_smi_larb_mt2701</span>
<span class="quote">&gt; &gt;  	},</span>
<span class="quote">&gt; &gt; +	{</span>
<span class="quote">&gt; &gt; +		.compatible = &quot;mediatek,mt2712-smi-larb&quot;,</span>
<span class="quote">&gt; &gt; +		.data = &amp;mtk_smi_larb_mt2712</span>
<span class="quote">&gt; &gt; +	},</span>
<span class="quote">&gt; &gt;  	{}</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; @@ -318,6 +348,10 @@ static int mtk_smi_larb_remove(struct platform_device *pdev)</span>
<span class="quote">&gt; &gt;  		.compatible = &quot;mediatek,mt2701-smi-common&quot;,</span>
<span class="quote">&gt; &gt;  		.data = (void *)MTK_SMI_GEN1</span>
<span class="quote">&gt; &gt;  	},</span>
<span class="quote">&gt; &gt; +	{</span>
<span class="quote">&gt; &gt; +		.compatible = &quot;mediatek,mt2712-smi-common&quot;,</span>
<span class="quote">&gt; &gt; +		.data = (void *)MTK_SMI_GEN2</span>
<span class="quote">&gt; &gt; +	},</span>
<span class="quote">&gt; &gt;  	{}</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
<span class="p_header">index 91c6d36..da6cedb 100644</span>
<span class="p_header">--- a/drivers/iommu/mtk_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.c</span>
<span class="p_chunk">@@ -54,7 +54,9 @@</span> <span class="p_context"></span>
 
 #define REG_MMU_CTRL_REG			0x110
 #define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)
<span class="p_add">+/* The TF-protect-select is bit[5:4] in mt2712 while it&#39;s bit[6:5] in mt8173.*/</span>
 #define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)
<span class="p_add">+#define F_MMU_TF_PROT_SEL(prot)			(((prot) &amp; 0x3) &lt;&lt; 4)</span>
 
 #define REG_MMU_IVRP_PADDR			0x114
 #define F_MMU_IVRP_PA_SET(pa, ext)		(((pa) &gt;&gt; 1) | ((!!(ext)) &lt;&lt; 31))
<span class="p_chunk">@@ -301,10 +303,6 @@</span> <span class="p_context"> static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
 			data-&gt;m4u_dom = NULL;
 			return ret;
 		}
<span class="p_del">-	} else if (data-&gt;m4u_dom != dom) {</span>
<span class="p_del">-		/* All the client devices should be in the same m4u domain */</span>
<span class="p_del">-		dev_err(dev, &quot;try to attach into the error iommu domain\n&quot;);</span>
<span class="p_del">-		return -EPERM;</span>
 	}
 
 	mtk_iommu_config(data, dev, true);
<span class="p_chunk">@@ -464,8 +462,12 @@</span> <span class="p_context"> static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
 		return ret;
 	}
 
<span class="p_del">-	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="p_del">-		F_MMU_TF_PROTECT_SEL(2);</span>
<span class="p_add">+	if (data-&gt;m4u_type == M4U_MT8173) {</span>
<span class="p_add">+		regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="p_add">+			F_MMU_TF_PROTECT_SEL(2);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		regval = F_MMU_TF_PROT_SEL(2);</span>
<span class="p_add">+	}</span>
 	writel_relaxed(regval, data-&gt;base + REG_MMU_CTRL_REG);
 
 	regval = F_L2_MULIT_HIT_EN |
<span class="p_chunk">@@ -487,9 +489,11 @@</span> <span class="p_context"> static int mtk_iommu_hw_init(const struct mtk_iommu_data *data)</span>
 
 	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base, data-&gt;enable_4GB),
 		       data-&gt;base + REG_MMU_IVRP_PADDR);
<span class="p_del">-</span>
 	writel_relaxed(0, data-&gt;base + REG_MMU_DCM_DIS);
<span class="p_del">-	writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It&#39;s MISC control register whose default value is ok except mt8173.*/</span>
<span class="p_add">+	if (data-&gt;m4u_type == M4U_MT8173)</span>
<span class="p_add">+		writel_relaxed(0, data-&gt;base + REG_MMU_STANDARD_AXI_MODE);</span>
 
 	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,
 			     dev_name(data-&gt;dev), (void *)data)) {
<span class="p_chunk">@@ -521,6 +525,7 @@</span> <span class="p_context"> static int mtk_iommu_probe(struct platform_device *pdev)</span>
 	if (!data)
 		return -ENOMEM;
 	data-&gt;dev = dev;
<span class="p_add">+	data-&gt;m4u_type = (enum mtk_iommu_type)of_device_get_match_data(dev);</span>
 
 	/* Protect memory. HW will access here while translation fault.*/
 	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);
<span class="p_chunk">@@ -554,6 +559,7 @@</span> <span class="p_context"> static int mtk_iommu_probe(struct platform_device *pdev)</span>
 	for (i = 0; i &lt; larb_nr; i++) {
 		struct device_node *larbnode;
 		struct platform_device *plarbdev;
<span class="p_add">+		unsigned int id;</span>
 
 		larbnode = of_parse_phandle(dev-&gt;of_node, &quot;mediatek,larbs&quot;, i);
 		if (!larbnode)
<span class="p_chunk">@@ -562,6 +568,10 @@</span> <span class="p_context"> static int mtk_iommu_probe(struct platform_device *pdev)</span>
 		if (!of_device_is_available(larbnode))
 			continue;
 
<span class="p_add">+		ret = of_property_read_u32(larbnode, &quot;mediatek,larb-id&quot;, &amp;id);</span>
<span class="p_add">+		if (ret)/* The id is consecutive if there is no this property */</span>
<span class="p_add">+			id = i;</span>
<span class="p_add">+</span>
 		plarbdev = of_find_device_by_node(larbnode);
 		if (!plarbdev) {
 			plarbdev = of_platform_device_create(
<span class="p_chunk">@@ -572,7 +582,7 @@</span> <span class="p_context"> static int mtk_iommu_probe(struct platform_device *pdev)</span>
 				return -EPROBE_DEFER;
 			}
 		}
<span class="p_del">-		data-&gt;smi_imu.larb_imu[i].dev = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+		data-&gt;smi_imu.larb_imu[id].dev = &amp;plarbdev-&gt;dev;</span>
 
 		component_match_add_release(dev, &amp;match, release_of,
 					    compare_of, larbnode);
<span class="p_chunk">@@ -640,8 +650,6 @@</span> <span class="p_context"> static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
 	struct mtk_iommu_suspend_reg *reg = &amp;data-&gt;reg;
 	void __iomem *base = data-&gt;base;
 
<span class="p_del">-	writel_relaxed(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="p_del">-		       base + REG_MMU_PT_BASE_ADDR);</span>
 	writel_relaxed(reg-&gt;standard_axi_mode,
 		       base + REG_MMU_STANDARD_AXI_MODE);
 	writel_relaxed(reg-&gt;dcm_dis, base + REG_MMU_DCM_DIS);
<span class="p_chunk">@@ -650,15 +658,19 @@</span> <span class="p_context"> static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
 	writel_relaxed(reg-&gt;int_main_control, base + REG_MMU_INT_MAIN_CONTROL);
 	writel_relaxed(F_MMU_IVRP_PA_SET(data-&gt;protect_base, data-&gt;enable_4GB),
 		       base + REG_MMU_IVRP_PADDR);
<span class="p_add">+	if (data-&gt;m4u_dom)</span>
<span class="p_add">+		writel(data-&gt;m4u_dom-&gt;cfg.arm_v7s_cfg.ttbr[0],</span>
<span class="p_add">+		       base + REG_MMU_PT_BASE_ADDR);</span>
 	return 0;
 }
 
<span class="p_del">-const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="p_add">+static const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
 	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)
 };
 
 static const struct of_device_id mtk_iommu_of_ids[] = {
<span class="p_del">-	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt2712-m4u&quot;, .data = (void *)M4U_MT2712},</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, .data = (void *)M4U_MT8173},</span>
 	{}
 };
 
<span class="p_chunk">@@ -667,16 +679,20 @@</span> <span class="p_context"> static int __maybe_unused mtk_iommu_resume(struct device *dev)</span>
 	.remove	= mtk_iommu_remove,
 	.driver	= {
 		.name = &quot;mtk-iommu&quot;,
<span class="p_del">-		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+		.of_match_table = of_match_ptr(mtk_iommu_of_ids),</span>
 		.pm = &amp;mtk_iommu_pm_ops,
 	}
 };
 
 static int mtk_iommu_init_fn(struct device_node *np)
 {
<span class="p_add">+	static bool init_done;</span>
 	int ret;
 	struct platform_device *pdev;
 
<span class="p_add">+	if (init_done)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);
 	if (!pdev)
 		return -ENOMEM;
<span class="p_chunk">@@ -686,8 +702,10 @@</span> <span class="p_context"> static int mtk_iommu_init_fn(struct device_node *np)</span>
 		pr_err(&quot;%s: Failed to register driver\n&quot;, __func__);
 		return ret;
 	}
<span class="p_add">+	init_done = true;</span>
 
 	return 0;
 }
 
<span class="p_del">-IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="p_add">+IOMMU_OF_DECLARE(mt8173m4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="p_add">+IOMMU_OF_DECLARE(mt2712m4u, &quot;mediatek,mt2712-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.h b/drivers/iommu/mtk_iommu.h</span>
<span class="p_header">index c06cc91..cd729a3 100644</span>
<span class="p_header">--- a/drivers/iommu/mtk_iommu.h</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.h</span>
<span class="p_chunk">@@ -34,6 +34,12 @@</span> <span class="p_context"> struct mtk_iommu_suspend_reg {</span>
 	u32				int_main_control;
 };
 
<span class="p_add">+enum mtk_iommu_type {</span>
<span class="p_add">+	M4U_MT2701,</span>
<span class="p_add">+	M4U_MT2712,</span>
<span class="p_add">+	M4U_MT8173,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct mtk_iommu_domain;
 
 struct mtk_iommu_data {
<span class="p_chunk">@@ -50,6 +56,7 @@</span> <span class="p_context"> struct mtk_iommu_data {</span>
 	bool				tlb_flush_active;
 
 	struct iommu_device		iommu;
<span class="p_add">+	enum mtk_iommu_type		m4u_type;</span>
 };
 
 static inline int compare_of(struct device *dev, void *data)
<span class="p_header">diff --git a/drivers/memory/mtk-smi.c b/drivers/memory/mtk-smi.c</span>
<span class="p_header">index 13f8c45..ec06d2b 100644</span>
<span class="p_header">--- a/drivers/memory/mtk-smi.c</span>
<span class="p_header">+++ b/drivers/memory/mtk-smi.c</span>
<span class="p_chunk">@@ -23,7 +23,10 @@</span> <span class="p_context"></span>
 #include &lt;soc/mediatek/smi.h&gt;
 #include &lt;dt-bindings/memory/mt2701-larb-port.h&gt;
 
<span class="p_add">+/* mt8173 */</span>
 #define SMI_LARB_MMU_EN		0xf00
<span class="p_add">+</span>
<span class="p_add">+/* mt2701 */</span>
 #define REG_SMI_SECUR_CON_BASE		0x5c0
 
 /* every register control 8 port, register offset 0x4 */
<span class="p_chunk">@@ -41,6 +44,10 @@</span> <span class="p_context"></span>
 /* mt2701 domain should be set to 3 */
 #define SMI_SECUR_CON_VAL_DOMAIN(id)	(0x3 &lt;&lt; ((((id) &amp; 0x7) &lt;&lt; 2) + 1))
 
<span class="p_add">+/* mt2712 */</span>
<span class="p_add">+#define SMI_LARB_NONSEC_CON(id)	(0x380 + (id * 4))</span>
<span class="p_add">+#define F_MMU_EN		BIT(0)</span>
<span class="p_add">+</span>
 struct mtk_smi_larb_gen {
 	bool need_larbid;
 	int port_in_larb[MTK_LARB_NR_MAX + 1];
<span class="p_chunk">@@ -149,7 +156,7 @@</span> <span class="p_context"> void mtk_smi_larb_put(struct device *larbdev)</span>
 	struct mtk_smi_iommu *smi_iommu = data;
 	unsigned int         i;
 
<span class="p_del">-	for (i = 0; i &lt; smi_iommu-&gt;larb_nr; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; MTK_LARB_NR_MAX; i++) {</span>
 		if (dev == smi_iommu-&gt;larb_imu[i].dev) {
 			/* The &#39;mmu&#39; may be updated in iommu-attach/detach. */
 			larb-&gt;mmu = &amp;smi_iommu-&gt;larb_imu[i].mmu;
<span class="p_chunk">@@ -159,13 +166,28 @@</span> <span class="p_context"> void mtk_smi_larb_put(struct device *larbdev)</span>
 	return -ENODEV;
 }
 
<span class="p_del">-static void mtk_smi_larb_config_port(struct device *dev)</span>
<span class="p_add">+static void mtk_smi_larb_config_port_mt8173(struct device *dev)</span>
 {
 	struct mtk_smi_larb *larb = dev_get_drvdata(dev);
 
 	writel(*larb-&gt;mmu, larb-&gt;base + SMI_LARB_MMU_EN);
 }
 
<span class="p_add">+static void mtk_smi_larb_config_port_mt2712(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_smi_larb *larb = dev_get_drvdata(dev);</span>
<span class="p_add">+	u32 reg;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 32; i++) {</span>
<span class="p_add">+		if (*larb-&gt;mmu &amp; BIT(i)) {</span>
<span class="p_add">+			reg = readl_relaxed(larb-&gt;base +</span>
<span class="p_add">+					    SMI_LARB_NONSEC_CON(i));</span>
<span class="p_add">+			reg |= F_MMU_EN;</span>
<span class="p_add">+			writel(reg, larb-&gt;base + SMI_LARB_NONSEC_CON(i));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 static void mtk_smi_larb_config_port_gen1(struct device *dev)
 {
<span class="p_chunk">@@ -211,7 +233,11 @@</span> <span class="p_context"> static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
 
 static const struct mtk_smi_larb_gen mtk_smi_larb_mt8173 = {
 	/* mt8173 do not need the port in larb */
<span class="p_del">-	.config_port = mtk_smi_larb_config_port,</span>
<span class="p_add">+	.config_port = mtk_smi_larb_config_port_mt8173,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct mtk_smi_larb_gen mtk_smi_larb_mt2712 = {</span>
<span class="p_add">+	.config_port = mtk_smi_larb_config_port_mt2712,</span>
 };
 
 static const struct mtk_smi_larb_gen mtk_smi_larb_mt2701 = {
<span class="p_chunk">@@ -232,6 +258,10 @@</span> <span class="p_context"> static void mtk_smi_larb_config_port_gen1(struct device *dev)</span>
 		.compatible = &quot;mediatek,mt2701-smi-larb&quot;,
 		.data = &amp;mtk_smi_larb_mt2701
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible = &quot;mediatek,mt2712-smi-larb&quot;,</span>
<span class="p_add">+		.data = &amp;mtk_smi_larb_mt2712</span>
<span class="p_add">+	},</span>
 	{}
 };
 
<span class="p_chunk">@@ -318,6 +348,10 @@</span> <span class="p_context"> static int mtk_smi_larb_remove(struct platform_device *pdev)</span>
 		.compatible = &quot;mediatek,mt2701-smi-common&quot;,
 		.data = (void *)MTK_SMI_GEN1
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.compatible = &quot;mediatek,mt2712-smi-common&quot;,</span>
<span class="p_add">+		.data = (void *)MTK_SMI_GEN2</span>
<span class="p_add">+	},</span>
 	{}
 };
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



