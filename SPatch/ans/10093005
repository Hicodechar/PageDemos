
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.67 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.67</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 5, 2017, 2:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171205140715.GB21957@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10093005/mbox/"
   >mbox</a>
|
   <a href="/patch/10093005/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10093005/">/patch/10093005/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	F3F406035E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:10:21 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9ED7429799
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:10:21 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 9B4942982B; Tue,  5 Dec 2017 14:10:21 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4DA2029799
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  5 Dec 2017 14:10:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753283AbdLEOKF (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 5 Dec 2017 09:10:05 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:46504 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752910AbdLEOHI (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 5 Dec 2017 09:07:08 -0500
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id EDCF9C0C;
	Tue,  5 Dec 2017 14:07:06 +0000 (UTC)
Date: Tue, 5 Dec 2017 15:07:15 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.67
Message-ID: &lt;20171205140715.GB21957@kroah.com&gt;
References: &lt;20171205140708.GA21957@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171205140708.GA21957@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 5, 2017, 2:07 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/hwmon/jc42.txt b/Documentation/devicetree/bindings/hwmon/jc42.txt</span>
<span class="p_header">index 07a250498fbb..f569db58f64a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/hwmon/jc42.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/hwmon/jc42.txt</span>
<span class="p_chunk">@@ -34,6 +34,10 @@</span> <span class="p_context"> Required properties:</span>
 
 - reg: I2C address
 
<span class="p_add">+Optional properties:</span>
<span class="p_add">+- smbus-timeout-disable: When set, the smbus timeout function will be disabled.</span>
<span class="p_add">+			 This is not supported on all chips.</span>
<span class="p_add">+</span>
 Example:
 
 temp-sensor@1a {
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 8e62f9e2a08c..70546af61a0a 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 66</span>
<span class="p_add">+SUBLEVEL = 67</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts b/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts</span>
<span class="p_header">index 08cce17a25a0..b4575bbaf085 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-torpedo-37xx-devkit.dts</span>
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"></span>
 	interrupts-extended = &lt;&amp;intc 83 &amp;omap3_pmx_core 0x11a&gt;;
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;mmc1_pins &amp;mmc1_cd&gt;;
<span class="p_del">-	cd-gpios = &lt;&amp;gpio4 31 IRQ_TYPE_LEVEL_LOW&gt;;		/* gpio127 */</span>
<span class="p_add">+	cd-gpios = &lt;&amp;gpio4 31 GPIO_ACTIVE_LOW&gt;;		/* gpio127 */</span>
 	vmmc-supply = &lt;&amp;vmmc1&gt;;
 	bus-width = &lt;4&gt;;
 	cap-power-off-card;
<span class="p_chunk">@@ -249,9 +249,9 @@</span> <span class="p_context"></span>
 			OMAP3_CORE1_IOPAD(0x2110, PIN_INPUT | MUX_MODE0)   /* cam_xclka.cam_xclka */
 			OMAP3_CORE1_IOPAD(0x2112, PIN_INPUT | MUX_MODE0)   /* cam_pclk.cam_pclk */
 
<span class="p_del">-			OMAP3_CORE1_IOPAD(0x2114, PIN_INPUT | MUX_MODE0)   /* cam_d0.cam_d0 */</span>
<span class="p_del">-			OMAP3_CORE1_IOPAD(0x2116, PIN_INPUT | MUX_MODE0)   /* cam_d1.cam_d1 */</span>
<span class="p_del">-			OMAP3_CORE1_IOPAD(0x2118, PIN_INPUT | MUX_MODE0)   /* cam_d2.cam_d2 */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x2116, PIN_INPUT | MUX_MODE0)   /* cam_d0.cam_d0 */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x2118, PIN_INPUT | MUX_MODE0)   /* cam_d1.cam_d1 */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x211a, PIN_INPUT | MUX_MODE0)   /* cam_d2.cam_d2 */</span>
 			OMAP3_CORE1_IOPAD(0x211c, PIN_INPUT | MUX_MODE0)   /* cam_d3.cam_d3 */
 			OMAP3_CORE1_IOPAD(0x211e, PIN_INPUT | MUX_MODE0)   /* cam_d4.cam_d4 */
 			OMAP3_CORE1_IOPAD(0x2120, PIN_INPUT | MUX_MODE0)   /* cam_d5.cam_d5 */
<span class="p_header">diff --git a/arch/arm/mach-omap2/pdata-quirks.c b/arch/arm/mach-omap2/pdata-quirks.c</span>
<span class="p_header">index 770216baa737..da310bb779b9 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/pdata-quirks.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/pdata-quirks.c</span>
<span class="p_chunk">@@ -162,7 +162,7 @@</span> <span class="p_context"> static struct ti_st_plat_data wilink7_pdata = {</span>
 	.nshutdown_gpio = 162,
 	.dev_name = &quot;/dev/ttyO1&quot;,
 	.flow_cntrl = 1,
<span class="p_del">-	.baud_rate = 300000,</span>
<span class="p_add">+	.baud_rate = 3000000,</span>
 };
 
 static struct platform_device wl128x_device = {
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index be9df513141e..e7b0e7ff4c58 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -54,19 +54,15 @@</span> <span class="p_context"> ENTRY(native_usergs_sysret64)</span>
 ENDPROC(native_usergs_sysret64)
 #endif /* CONFIG_PARAVIRT */
 
<span class="p_del">-.macro TRACE_IRQS_FLAGS flags:req</span>
<span class="p_add">+.macro TRACE_IRQS_IRETQ</span>
 #ifdef CONFIG_TRACE_IRQFLAGS
<span class="p_del">-	bt	$9, \flags		/* interrupts off? */</span>
<span class="p_add">+	bt	$9, EFLAGS(%rsp)		/* interrupts off? */</span>
 	jnc	1f
 	TRACE_IRQS_ON
 1:
 #endif
 .endm
 
<span class="p_del">-.macro TRACE_IRQS_IRETQ</span>
<span class="p_del">-	TRACE_IRQS_FLAGS EFLAGS(%rsp)</span>
<span class="p_del">-.endm</span>
<span class="p_del">-</span>
 /*
  * When dynamic function tracer is enabled it will add a breakpoint
  * to all locations that it is about to modify, sync CPUs, update
<span class="p_chunk">@@ -872,13 +868,11 @@</span> <span class="p_context"> idtentry simd_coprocessor_error		do_simd_coprocessor_error	has_error_code=0</span>
 ENTRY(native_load_gs_index)
 	pushfq
 	DISABLE_INTERRUPTS(CLBR_ANY &amp; ~CLBR_RDI)
<span class="p_del">-	TRACE_IRQS_OFF</span>
 	SWAPGS
 .Lgs_change:
 	movl	%edi, %gs
 2:	ALTERNATIVE &quot;&quot;, &quot;mfence&quot;, X86_BUG_SWAPGS_FENCE
 	SWAPGS
<span class="p_del">-	TRACE_IRQS_FLAGS (%rsp)</span>
 	popfq
 	ret
 END(native_load_gs_index)
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 3f05c044720b..b24b3c6d686e 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -246,9 +246,14 @@</span> <span class="p_context"> static inline void kvm_apic_set_ldr(struct kvm_lapic *apic, u32 id)</span>
 	recalculate_apic_map(apic-&gt;vcpu-&gt;kvm);
 }
 
<span class="p_add">+static inline u32 kvm_apic_calc_x2apic_ldr(u32 id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ((id &gt;&gt; 4) &lt;&lt; 16) | (1 &lt;&lt; (id &amp; 0xf));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void kvm_apic_set_x2apic_id(struct kvm_lapic *apic, u32 id)
 {
<span class="p_del">-	u32 ldr = ((id &gt;&gt; 4) &lt;&lt; 16) | (1 &lt;&lt; (id &amp; 0xf));</span>
<span class="p_add">+	u32 ldr = kvm_apic_calc_x2apic_ldr(id);</span>
 
 	kvm_lapic_set_reg(apic, APIC_ID, id);
 	kvm_lapic_set_reg(apic, APIC_LDR, ldr);
<span class="p_chunk">@@ -2029,6 +2034,7 @@</span> <span class="p_context"> static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,</span>
 {
 	if (apic_x2apic_mode(vcpu-&gt;arch.apic)) {
 		u32 *id = (u32 *)(s-&gt;regs + APIC_ID);
<span class="p_add">+		u32 *ldr = (u32 *)(s-&gt;regs + APIC_LDR);</span>
 
 		if (vcpu-&gt;kvm-&gt;arch.x2apic_format) {
 			if (*id != vcpu-&gt;vcpu_id)
<span class="p_chunk">@@ -2039,6 +2045,10 @@</span> <span class="p_context"> static int kvm_apic_state_fixup(struct kvm_vcpu *vcpu,</span>
 			else
 				*id &lt;&lt;= 24;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/* In x2APIC mode, the LDR is fixed and based on the id */</span>
<span class="p_add">+		if (set)</span>
<span class="p_add">+			*ldr = kvm_apic_calc_x2apic_ldr(*id);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 4fbf0c94f2d1..23f1a6bd7a0d 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -2149,6 +2149,8 @@</span> <span class="p_context"> static int ud_interception(struct vcpu_svm *svm)</span>
 	int er;
 
 	er = emulate_instruction(&amp;svm-&gt;vcpu, EMULTYPE_TRAP_UD);
<span class="p_add">+	if (er == EMULATE_USER_EXIT)</span>
<span class="p_add">+		return 0;</span>
 	if (er != EMULATE_DONE)
 		kvm_queue_exception(&amp;svm-&gt;vcpu, UD_VECTOR);
 	return 1;
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 0f0b27d96f27..f0d3de153e29 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -5502,6 +5502,8 @@</span> <span class="p_context"> static int handle_exception(struct kvm_vcpu *vcpu)</span>
 			return 1;
 		}
 		er = emulate_instruction(vcpu, EMULTYPE_TRAP_UD);
<span class="p_add">+		if (er == EMULATE_USER_EXIT)</span>
<span class="p_add">+			return 0;</span>
 		if (er != EMULATE_DONE)
 			kvm_queue_exception(vcpu, UD_VECTOR);
 		return 1;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 595f8149c0d9..02d45296a97c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -1797,6 +1797,9 @@</span> <span class="p_context"> static void kvm_setup_pvclock_page(struct kvm_vcpu *v)</span>
 	 */
 	BUILD_BUG_ON(offsetof(struct pvclock_vcpu_time_info, version) != 0);
 
<span class="p_add">+	if (guest_hv_clock.version &amp; 1)</span>
<span class="p_add">+		++guest_hv_clock.version;  /* first time write, random junk */</span>
<span class="p_add">+</span>
 	vcpu-&gt;hv_clock.version = guest_hv_clock.version + 1;
 	kvm_write_guest_cached(v-&gt;kvm, &amp;vcpu-&gt;pv_time,
 				&amp;vcpu-&gt;hv_clock,
<span class="p_chunk">@@ -5576,6 +5579,8 @@</span> <span class="p_context"> int x86_emulate_instruction(struct kvm_vcpu *vcpu,</span>
 			if (reexecute_instruction(vcpu, cr2, write_fault_to_spt,
 						emulation_type))
 				return EMULATE_DONE;
<span class="p_add">+			if (ctxt-&gt;have_exception &amp;&amp; inject_emulated_exception(vcpu))</span>
<span class="p_add">+				return EMULATE_DONE;</span>
 			if (emulation_type &amp; EMULTYPE_SKIP)
 				return EMULATE_FAIL;
 			return handle_emulation_failure(vcpu);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index f8fdbd1378a7..26afdffab5a0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -1788,34 +1788,32 @@</span> <span class="p_context"> void amdgpu_atombios_scratch_regs_restore(struct amdgpu_device *adev)</span>
 		WREG32(mmBIOS_SCRATCH_0 + i, adev-&gt;bios_scratch[i]);
 }
 
<span class="p_del">-/* Atom needs data in little endian format</span>
<span class="p_del">- * so swap as appropriate when copying data to</span>
<span class="p_del">- * or from atom. Note that atom operates on</span>
<span class="p_del">- * dw units.</span>
<span class="p_add">+/* Atom needs data in little endian format so swap as appropriate when copying</span>
<span class="p_add">+ * data to or from atom. Note that atom operates on dw units.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=true when sending data to atom and provide at least</span>
<span class="p_add">+ * ALIGN(num_bytes,4) bytes in the dst buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=false when receiving data from atom and provide ALIGN(num_bytes,4)</span>
<span class="p_add">+ * byes in the src buffer.</span>
  */
 void amdgpu_atombios_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)
 {
 #ifdef __BIG_ENDIAN
<span class="p_del">-	u8 src_tmp[20], dst_tmp[20]; /* used for byteswapping */</span>
<span class="p_del">-	u32 *dst32, *src32;</span>
<span class="p_add">+	u32 src_tmp[5], dst_tmp[5];</span>
 	int i;
<span class="p_add">+	u8 align_num_bytes = ALIGN(num_bytes, 4);</span>
 
<span class="p_del">-	memcpy(src_tmp, src, num_bytes);</span>
<span class="p_del">-	src32 = (u32 *)src_tmp;</span>
<span class="p_del">-	dst32 = (u32 *)dst_tmp;</span>
 	if (to_le) {
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = cpu_to_le32(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, num_bytes);</span>
<span class="p_add">+		memcpy(src_tmp, src, num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = cpu_to_le32(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, align_num_bytes);</span>
 	} else {
<span class="p_del">-		u8 dws = num_bytes &amp; ~3;</span>
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = le32_to_cpu(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, dws);</span>
<span class="p_del">-		if (num_bytes % 4) {</span>
<span class="p_del">-			for (i = 0; i &lt; (num_bytes % 4); i++)</span>
<span class="p_del">-				dst[dws+i] = dst_tmp[dws+i];</span>
<span class="p_del">-		}</span>
<span class="p_add">+		memcpy(src_tmp, src, align_num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = le32_to_cpu(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, num_bytes);</span>
 	}
 #else
 	memcpy(dst, src, num_bytes);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">index 743a12df6971..3bb2b9b5ef9c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vce.c</span>
<span class="p_chunk">@@ -648,7 +648,7 @@</span> <span class="p_context"> int amdgpu_vce_ring_parse_cs(struct amdgpu_cs_parser *p, uint32_t ib_idx)</span>
 	uint32_t allocated = 0;
 	uint32_t tmp, handle = 0;
 	uint32_t *size = &amp;tmp;
<span class="p_del">-	int i, r, idx = 0;</span>
<span class="p_add">+	int i, r = 0, idx = 0;</span>
 
 	r = amdgpu_cs_sysvm_access_required(p);
 	if (r)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_header">index 968c4260d7a7..47503759906b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vm.c</span>
<span class="p_chunk">@@ -744,7 +744,7 @@</span> <span class="p_context"> static int amdgpu_vm_update_pd_or_shadow(struct amdgpu_device *adev,</span>
 int amdgpu_vm_update_page_directory(struct amdgpu_device *adev,
                                    struct amdgpu_vm *vm)
 {
<span class="p_del">-	int r;</span>
<span class="p_add">+	int r = 0;</span>
 
 	r = amdgpu_vm_update_pd_or_shadow(adev, vm, true);
 	if (r)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c b/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c</span>
<span class="p_header">index 4477c55a58e3..a8b59b3decd8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/process_pptables_v1_0.c</span>
<span class="p_chunk">@@ -850,9 +850,9 @@</span> <span class="p_context"> static int init_over_drive_limits(</span>
 		const ATOM_Tonga_POWERPLAYTABLE *powerplay_table)
 {
 	hwmgr-&gt;platform_descriptor.overdriveLimit.engineClock =
<span class="p_del">-		le16_to_cpu(powerplay_table-&gt;ulMaxODEngineClock);</span>
<span class="p_add">+		le32_to_cpu(powerplay_table-&gt;ulMaxODEngineClock);</span>
 	hwmgr-&gt;platform_descriptor.overdriveLimit.memoryClock =
<span class="p_del">-		le16_to_cpu(powerplay_table-&gt;ulMaxODMemoryClock);</span>
<span class="p_add">+		le32_to_cpu(powerplay_table-&gt;ulMaxODMemoryClock);</span>
 
 	hwmgr-&gt;platform_descriptor.minOverdriveVDDC = 0;
 	hwmgr-&gt;platform_descriptor.maxOverdriveVDDC = 0;
<span class="p_header">diff --git a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c</span>
<span class="p_header">index 7e7a4d43d6b6..0f563c954520 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/hisilicon/kirin/kirin_drm_ade.c</span>
<span class="p_chunk">@@ -521,9 +521,12 @@</span> <span class="p_context"> static void ade_crtc_atomic_begin(struct drm_crtc *crtc,</span>
 {
 	struct ade_crtc *acrtc = to_ade_crtc(crtc);
 	struct ade_hw_ctx *ctx = acrtc-&gt;ctx;
<span class="p_add">+	struct drm_display_mode *mode = &amp;crtc-&gt;state-&gt;mode;</span>
<span class="p_add">+	struct drm_display_mode *adj_mode = &amp;crtc-&gt;state-&gt;adjusted_mode;</span>
 
 	if (!ctx-&gt;power_on)
 		(void)ade_power_up(ctx);
<span class="p_add">+	ade_ldi_set_mode(acrtc, mode, adj_mode);</span>
 }
 
 static void ade_crtc_atomic_flush(struct drm_crtc *crtc,
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index 79aab9ad6faa..6769aa1b6922 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -430,7 +430,9 @@</span> <span class="p_context"> static bool</span>
 gmbus_is_index_read(struct i2c_msg *msgs, int i, int num)
 {
 	return (i + 1 &lt; num &amp;&amp;
<span class="p_del">-		!(msgs[i].flags &amp; I2C_M_RD) &amp;&amp; msgs[i].len &lt;= 2 &amp;&amp;</span>
<span class="p_add">+		msgs[i].addr == msgs[i + 1].addr &amp;&amp;</span>
<span class="p_add">+		!(msgs[i].flags &amp; I2C_M_RD) &amp;&amp;</span>
<span class="p_add">+		(msgs[i].len == 1 || msgs[i].len == 2) &amp;&amp;</span>
 		(msgs[i + 1].flags &amp; I2C_M_RD));
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">index 27cb42467b20..6f65846b1783 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/panel/panel-simple.c</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> static int panel_simple_remove(struct device *dev)</span>
 	drm_panel_remove(&amp;panel-&gt;base);
 
 	panel_simple_disable(&amp;panel-&gt;base);
<span class="p_add">+	panel_simple_unprepare(&amp;panel-&gt;base);</span>
 
 	if (panel-&gt;ddc)
 		put_device(&amp;panel-&gt;ddc-&gt;dev);
<span class="p_chunk">@@ -384,6 +385,7 @@</span> <span class="p_context"> static void panel_simple_shutdown(struct device *dev)</span>
 	struct panel_simple *panel = dev_get_drvdata(dev);
 
 	panel_simple_disable(&amp;panel-&gt;base);
<span class="p_add">+	panel_simple_unprepare(&amp;panel-&gt;base);</span>
 }
 
 static const struct drm_display_mode ampire_am800480r3tmqwa1h_mode = {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index 432cb46f6a34..fd7682bf335d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -45,34 +45,32 @@</span> <span class="p_context"> static char *pre_emph_names[] = {</span>
 
 /***** radeon AUX functions *****/
 
<span class="p_del">-/* Atom needs data in little endian format</span>
<span class="p_del">- * so swap as appropriate when copying data to</span>
<span class="p_del">- * or from atom. Note that atom operates on</span>
<span class="p_del">- * dw units.</span>
<span class="p_add">+/* Atom needs data in little endian format so swap as appropriate when copying</span>
<span class="p_add">+ * data to or from atom. Note that atom operates on dw units.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=true when sending data to atom and provide at least</span>
<span class="p_add">+ * ALIGN(num_bytes,4) bytes in the dst buffer.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Use to_le=false when receiving data from atom and provide ALIGN(num_bytes,4)</span>
<span class="p_add">+ * byes in the src buffer.</span>
  */
 void radeon_atom_copy_swap(u8 *dst, u8 *src, u8 num_bytes, bool to_le)
 {
 #ifdef __BIG_ENDIAN
<span class="p_del">-	u8 src_tmp[20], dst_tmp[20]; /* used for byteswapping */</span>
<span class="p_del">-	u32 *dst32, *src32;</span>
<span class="p_add">+	u32 src_tmp[5], dst_tmp[5];</span>
 	int i;
<span class="p_add">+	u8 align_num_bytes = ALIGN(num_bytes, 4);</span>
 
<span class="p_del">-	memcpy(src_tmp, src, num_bytes);</span>
<span class="p_del">-	src32 = (u32 *)src_tmp;</span>
<span class="p_del">-	dst32 = (u32 *)dst_tmp;</span>
 	if (to_le) {
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = cpu_to_le32(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, num_bytes);</span>
<span class="p_add">+		memcpy(src_tmp, src, num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = cpu_to_le32(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, align_num_bytes);</span>
 	} else {
<span class="p_del">-		u8 dws = num_bytes &amp; ~3;</span>
<span class="p_del">-		for (i = 0; i &lt; ((num_bytes + 3) / 4); i++)</span>
<span class="p_del">-			dst32[i] = le32_to_cpu(src32[i]);</span>
<span class="p_del">-		memcpy(dst, dst_tmp, dws);</span>
<span class="p_del">-		if (num_bytes % 4) {</span>
<span class="p_del">-			for (i = 0; i &lt; (num_bytes % 4); i++)</span>
<span class="p_del">-				dst[dws+i] = dst_tmp[dws+i];</span>
<span class="p_del">-		}</span>
<span class="p_add">+		memcpy(src_tmp, src, align_num_bytes);</span>
<span class="p_add">+		for (i = 0; i &lt; align_num_bytes / 4; i++)</span>
<span class="p_add">+			dst_tmp[i] = le32_to_cpu(src_tmp[i]);</span>
<span class="p_add">+		memcpy(dst, dst_tmp, num_bytes);</span>
 	}
 #else
 	memcpy(dst, src, num_bytes);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_fb.c b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">index 0daad446d2c7..af84705b82ed 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_chunk">@@ -252,7 +252,6 @@</span> <span class="p_context"> static int radeonfb_create(struct drm_fb_helper *helper,</span>
 	}
 
 	info-&gt;par = rfbdev;
<span class="p_del">-	info-&gt;skip_vt_switch = true;</span>
 
 	ret = radeon_framebuffer_init(rdev-&gt;ddev, &amp;rfbdev-&gt;rfb, &amp;mode_cmd, gobj);
 	if (ret) {
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_bo_util.c b/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_header">index bf6e21655c57..7d22f9874d5f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_bo_util.c</span>
<span class="p_chunk">@@ -473,6 +473,7 @@</span> <span class="p_context"> static int ttm_buffer_object_transfer(struct ttm_buffer_object *bo,</span>
 	INIT_LIST_HEAD(&amp;fbo-&gt;lru);
 	INIT_LIST_HEAD(&amp;fbo-&gt;swap);
 	INIT_LIST_HEAD(&amp;fbo-&gt;io_reserve_lru);
<span class="p_add">+	mutex_init(&amp;fbo-&gt;wu_mutex);</span>
 	fbo-&gt;moving = NULL;
 	drm_vma_node_reset(&amp;fbo-&gt;vma_node);
 	atomic_set(&amp;fbo-&gt;cpu_writers, 0);
<span class="p_header">diff --git a/drivers/hwmon/jc42.c b/drivers/hwmon/jc42.c</span>
<span class="p_header">index 1bf22eff0b08..0f1f6421845f 100644</span>
<span class="p_header">--- a/drivers/hwmon/jc42.c</span>
<span class="p_header">+++ b/drivers/hwmon/jc42.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
<span class="p_add">+#include &lt;linux/bitops.h&gt;</span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_chunk">@@ -45,6 +46,7 @@</span> <span class="p_context"> static const unsigned short normal_i2c[] = {</span>
 #define JC42_REG_TEMP		0x05
 #define JC42_REG_MANID		0x06
 #define JC42_REG_DEVICEID	0x07
<span class="p_add">+#define JC42_REG_SMBUS		0x22 /* NXP and Atmel, possibly others? */</span>
 
 /* Status bits in temperature register */
 #define JC42_ALARM_CRIT_BIT	15
<span class="p_chunk">@@ -73,6 +75,9 @@</span> <span class="p_context"> static const unsigned short normal_i2c[] = {</span>
 #define ONS_MANID		0x1b09  /* ON Semiconductor */
 #define STM_MANID		0x104a  /* ST Microelectronics */
 
<span class="p_add">+/* SMBUS register */</span>
<span class="p_add">+#define SMBUS_STMOUT		BIT(7)  /* SMBus time-out, active low */</span>
<span class="p_add">+</span>
 /* Supported chips */
 
 /* Analog Devices */
<span class="p_chunk">@@ -476,6 +481,22 @@</span> <span class="p_context"> static int jc42_probe(struct i2c_client *client, const struct i2c_device_id *id)</span>
 
 	data-&gt;extended = !!(cap &amp; JC42_CAP_RANGE);
 
<span class="p_add">+	if (device_property_read_bool(dev, &quot;smbus-timeout-disable&quot;)) {</span>
<span class="p_add">+		int smbus;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Not all chips support this register, but from a</span>
<span class="p_add">+		 * quick read of various datasheets no chip appears</span>
<span class="p_add">+		 * incompatible with the below attempt to disable</span>
<span class="p_add">+		 * the timeout. And the whole thing is opt-in...</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smbus = i2c_smbus_read_word_swapped(client, JC42_REG_SMBUS);</span>
<span class="p_add">+		if (smbus &lt; 0)</span>
<span class="p_add">+			return smbus;</span>
<span class="p_add">+		i2c_smbus_write_word_swapped(client, JC42_REG_SMBUS,</span>
<span class="p_add">+					     smbus | SMBUS_STMOUT);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	config = i2c_smbus_read_word_swapped(client, JC42_REG_CONFIG);
 	if (config &lt; 0)
 		return config;
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-i801.c b/drivers/i2c/busses/i2c-i801.c</span>
<span class="p_header">index eb3627f35d12..e6fe21a6135b 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-i801.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-i801.c</span>
<span class="p_chunk">@@ -1592,6 +1592,9 @@</span> <span class="p_context"> static int i801_probe(struct pci_dev *dev, const struct pci_device_id *id)</span>
 	/* Default timeout in interrupt mode: 200 ms */
 	priv-&gt;adapter.timeout = HZ / 5;
 
<span class="p_add">+	if (dev-&gt;irq == IRQ_NOTCONNECTED)</span>
<span class="p_add">+		priv-&gt;features &amp;= ~FEATURE_IRQ;</span>
<span class="p_add">+</span>
 	if (priv-&gt;features &amp; FEATURE_IRQ) {
 		u16 pcictl, pcists;
 
<span class="p_header">diff --git a/drivers/md/bcache/alloc.c b/drivers/md/bcache/alloc.c</span>
<span class="p_header">index 3fba31cea66e..537903bf9add 100644</span>
<span class="p_header">--- a/drivers/md/bcache/alloc.c</span>
<span class="p_header">+++ b/drivers/md/bcache/alloc.c</span>
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> int __bch_bucket_alloc_set(struct cache_set *c, unsigned reserve,</span>
 		if (b == -1)
 			goto err;
 
<span class="p_del">-		k-&gt;ptr[i] = PTR(ca-&gt;buckets[b].gen,</span>
<span class="p_add">+		k-&gt;ptr[i] = MAKE_PTR(ca-&gt;buckets[b].gen,</span>
 				bucket_to_sector(c, b),
 				ca-&gt;sb.nr_this_dev);
 
<span class="p_header">diff --git a/drivers/md/bcache/extents.c b/drivers/md/bcache/extents.c</span>
<span class="p_header">index 243de0bf15cd..4bf15182c4da 100644</span>
<span class="p_header">--- a/drivers/md/bcache/extents.c</span>
<span class="p_header">+++ b/drivers/md/bcache/extents.c</span>
<span class="p_chunk">@@ -584,7 +584,7 @@</span> <span class="p_context"> static bool bch_extent_merge(struct btree_keys *bk, struct bkey *l, struct bkey</span>
 		return false;
 
 	for (i = 0; i &lt; KEY_PTRS(l); i++)
<span class="p_del">-		if (l-&gt;ptr[i] + PTR(0, KEY_SIZE(l), 0) != r-&gt;ptr[i] ||</span>
<span class="p_add">+		if (l-&gt;ptr[i] + MAKE_PTR(0, KEY_SIZE(l), 0) != r-&gt;ptr[i] ||</span>
 		    PTR_BUCKET_NR(b-&gt;c, l, i) != PTR_BUCKET_NR(b-&gt;c, r, i))
 			return false;
 
<span class="p_header">diff --git a/drivers/md/bcache/journal.c b/drivers/md/bcache/journal.c</span>
<span class="p_header">index 6925023e12d4..08f20b7cd199 100644</span>
<span class="p_header">--- a/drivers/md/bcache/journal.c</span>
<span class="p_header">+++ b/drivers/md/bcache/journal.c</span>
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> static void journal_reclaim(struct cache_set *c)</span>
 			continue;
 
 		ja-&gt;cur_idx = next;
<span class="p_del">-		k-&gt;ptr[n++] = PTR(0,</span>
<span class="p_add">+		k-&gt;ptr[n++] = MAKE_PTR(0,</span>
 				  bucket_to_sector(c, ca-&gt;sb.d[ja-&gt;cur_idx]),
 				  ca-&gt;sb.nr_this_dev);
 	}
<span class="p_header">diff --git a/drivers/mfd/twl4030-power.c b/drivers/mfd/twl4030-power.c</span>
<span class="p_header">index 1beb722f6080..e1e69a480c56 100644</span>
<span class="p_header">--- a/drivers/mfd/twl4030-power.c</span>
<span class="p_header">+++ b/drivers/mfd/twl4030-power.c</span>
<span class="p_chunk">@@ -701,6 +701,7 @@</span> <span class="p_context"> static struct twl4030_ins omap3_wrst_seq[] = {</span>
 	TWL_RESOURCE_RESET(RES_MAIN_REF),
 	TWL_RESOURCE_GROUP_RESET(RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R2),
 	TWL_RESOURCE_RESET(RES_VUSB_3V1),
<span class="p_add">+	TWL_RESOURCE_RESET(RES_VMMC1),</span>
 	TWL_RESOURCE_GROUP_RESET(RES_GRP_ALL, RES_TYPE_R0, RES_TYPE2_R1),
 	TWL_RESOURCE_GROUP_RESET(RES_GRP_RC, RES_TYPE_ALL, RES_TYPE2_R0),
 	TWL_RESOURCE_ON(RES_RESET),
<span class="p_header">diff --git a/drivers/misc/eeprom/at24.c b/drivers/misc/eeprom/at24.c</span>
<span class="p_header">index 051b14766ef9..19c10dc56513 100644</span>
<span class="p_header">--- a/drivers/misc/eeprom/at24.c</span>
<span class="p_header">+++ b/drivers/misc/eeprom/at24.c</span>
<span class="p_chunk">@@ -365,7 +365,8 @@</span> <span class="p_context"> static ssize_t at24_eeprom_read_mac(struct at24_data *at24, char *buf,</span>
 	memset(msg, 0, sizeof(msg));
 	msg[0].addr = client-&gt;addr;
 	msg[0].buf = addrbuf;
<span class="p_del">-	addrbuf[0] = 0x90 + offset;</span>
<span class="p_add">+	/* EUI-48 starts from 0x9a, EUI-64 from 0x98 */</span>
<span class="p_add">+	addrbuf[0] = 0xa0 - at24-&gt;chip.byte_len + offset;</span>
 	msg[0].len = 1;
 	msg[1].addr = client-&gt;addr;
 	msg[1].flags = I2C_M_RD;
<span class="p_chunk">@@ -506,6 +507,9 @@</span> <span class="p_context"> static int at24_read(void *priv, unsigned int off, void *val, size_t count)</span>
 	if (unlikely(!count))
 		return count;
 
<span class="p_add">+	if (off + count &gt; at24-&gt;chip.byte_len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 * Read data from chip, protecting against concurrent updates
 	 * from this host, but not from other I2C masters.
<span class="p_chunk">@@ -538,6 +542,9 @@</span> <span class="p_context"> static int at24_write(void *priv, unsigned int off, void *val, size_t count)</span>
 	if (unlikely(!count))
 		return -EINVAL;
 
<span class="p_add">+	if (off + count &gt; at24-&gt;chip.byte_len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 * Write data to chip, protecting against concurrent updates
 	 * from this host, but not from other I2C masters.
<span class="p_chunk">@@ -638,6 +645,16 @@</span> <span class="p_context"> static int at24_probe(struct i2c_client *client, const struct i2c_device_id *id)</span>
 		dev_warn(&amp;client-&gt;dev,
 			&quot;page_size looks suspicious (no power of 2)!\n&quot;);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * REVISIT: the size of the EUI-48 byte array is 6 in at24mac402, while</span>
<span class="p_add">+	 * the call to ilog2() in AT24_DEVICE_MAGIC() rounds it down to 4.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Eventually we&#39;ll get rid of the magic values altoghether in favor of</span>
<span class="p_add">+	 * real structs, but for now just manually set the right size.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (chip.flags &amp; AT24_FLAG_MAC &amp;&amp; chip.byte_len == 4)</span>
<span class="p_add">+		chip.byte_len = 6;</span>
<span class="p_add">+</span>
 	/* Use I2C operations unless we&#39;re stuck with SMBus extensions. */
 	if (!i2c_check_functionality(client-&gt;adapter, I2C_FUNC_I2C)) {
 		if (chip.flags &amp; AT24_FLAG_ADDR16)
<span class="p_header">diff --git a/drivers/mmc/core/bus.c b/drivers/mmc/core/bus.c</span>
<span class="p_header">index c64266f5a399..60ebe5b4500b 100644</span>
<span class="p_header">--- a/drivers/mmc/core/bus.c</span>
<span class="p_header">+++ b/drivers/mmc/core/bus.c</span>
<span class="p_chunk">@@ -155,6 +155,9 @@</span> <span class="p_context"> static int mmc_bus_suspend(struct device *dev)</span>
 		return ret;
 
 	ret = host-&gt;bus_ops-&gt;suspend(host);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pm_generic_resume(dev);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 4f4a627f6b20..0c6de9f12ee8 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -752,7 +752,7 @@</span> <span class="p_context"> MMC_DEV_ATTR(enhanced_area_offset, &quot;%llu\n&quot;,</span>
 MMC_DEV_ATTR(enhanced_area_size, &quot;%u\n&quot;, card-&gt;ext_csd.enhanced_area_size);
 MMC_DEV_ATTR(raw_rpmb_size_mult, &quot;%#x\n&quot;, card-&gt;ext_csd.raw_rpmb_size_mult);
 MMC_DEV_ATTR(rel_sectors, &quot;%#x\n&quot;, card-&gt;ext_csd.rel_sectors);
<span class="p_del">-MMC_DEV_ATTR(ocr, &quot;%08x\n&quot;, card-&gt;ocr);</span>
<span class="p_add">+MMC_DEV_ATTR(ocr, &quot;0x%08x\n&quot;, card-&gt;ocr);</span>
 
 static ssize_t mmc_fwrev_show(struct device *dev,
 			      struct device_attribute *attr,
<span class="p_header">diff --git a/drivers/mmc/core/sd.c b/drivers/mmc/core/sd.c</span>
<span class="p_header">index f6f40a1673ae..f09148a4ab55 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sd.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sd.c</span>
<span class="p_chunk">@@ -683,7 +683,7 @@</span> <span class="p_context"> MMC_DEV_ATTR(manfid, &quot;0x%06x\n&quot;, card-&gt;cid.manfid);</span>
 MMC_DEV_ATTR(name, &quot;%s\n&quot;, card-&gt;cid.prod_name);
 MMC_DEV_ATTR(oemid, &quot;0x%04x\n&quot;, card-&gt;cid.oemid);
 MMC_DEV_ATTR(serial, &quot;0x%08x\n&quot;, card-&gt;cid.serial);
<span class="p_del">-MMC_DEV_ATTR(ocr, &quot;%08x\n&quot;, card-&gt;ocr);</span>
<span class="p_add">+MMC_DEV_ATTR(ocr, &quot;0x%08x\n&quot;, card-&gt;ocr);</span>
 
 
 static ssize_t mmc_dsr_show(struct device *dev,
<span class="p_header">diff --git a/drivers/nvme/host/nvme.h b/drivers/nvme/host/nvme.h</span>
<span class="p_header">index 8edafd8cb8ce..5c52a6182765 100644</span>
<span class="p_header">--- a/drivers/nvme/host/nvme.h</span>
<span class="p_header">+++ b/drivers/nvme/host/nvme.h</span>
<span class="p_chunk">@@ -84,7 +84,7 @@</span> <span class="p_context"> enum nvme_quirks {</span>
  * NVME_QUIRK_DELAY_BEFORE_CHK_RDY quirk enabled. The value (in ms) was
  * found empirically.
  */
<span class="p_del">-#define NVME_QUIRK_DELAY_AMOUNT		2000</span>
<span class="p_add">+#define NVME_QUIRK_DELAY_AMOUNT		2300</span>
 
 enum nvme_ctrl_state {
 	NVME_CTRL_NEW,
<span class="p_header">diff --git a/drivers/nvme/host/pci.c b/drivers/nvme/host/pci.c</span>
<span class="p_header">index 54ea90f89b70..e48ecb9303ca 100644</span>
<span class="p_header">--- a/drivers/nvme/host/pci.c</span>
<span class="p_header">+++ b/drivers/nvme/host/pci.c</span>
<span class="p_chunk">@@ -2109,6 +2109,8 @@</span> <span class="p_context"> static const struct pci_device_id nvme_id_table[] = {</span>
 		.driver_data = NVME_QUIRK_IDENTIFY_CNS, },
 	{ PCI_DEVICE(0x1c58, 0x0003),	/* HGST adapter */
 		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, },
<span class="p_add">+	{ PCI_DEVICE(0x1c58, 0x0023),	/* WDC SN200 adapter */</span>
<span class="p_add">+		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, },</span>
 	{ PCI_DEVICE(0x1c5f, 0x0540),	/* Memblaze Pblaze4 adapter */
 		.driver_data = NVME_QUIRK_DELAY_BEFORE_CHK_RDY, },
 	{ PCI_DEVICE_CLASS(PCI_CLASS_STORAGE_EXPRESS, 0xffffff) },
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index 705bb5f5a87f..c4cff5cc9c93 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -3397,13 +3397,6 @@</span> <span class="p_context"> static int cache_save_setup(struct btrfs_block_group_cache *block_group,</span>
 		goto again;
 	}
 
<span class="p_del">-	/* We&#39;ve already setup this transaction, go ahead and exit */</span>
<span class="p_del">-	if (block_group-&gt;cache_generation == trans-&gt;transid &amp;&amp;</span>
<span class="p_del">-	    i_size_read(inode)) {</span>
<span class="p_del">-		dcs = BTRFS_DC_SETUP;</span>
<span class="p_del">-		goto out_put;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/*
 	 * We want to set the generation to 0, that way if anything goes wrong
 	 * from here on out we know not to trust this cache when we load up next
<span class="p_chunk">@@ -3427,6 +3420,13 @@</span> <span class="p_context"> static int cache_save_setup(struct btrfs_block_group_cache *block_group,</span>
 	}
 	WARN_ON(ret);
 
<span class="p_add">+	/* We&#39;ve already setup this transaction, go ahead and exit */</span>
<span class="p_add">+	if (block_group-&gt;cache_generation == trans-&gt;transid &amp;&amp;</span>
<span class="p_add">+	    i_size_read(inode)) {</span>
<span class="p_add">+		dcs = BTRFS_DC_SETUP;</span>
<span class="p_add">+		goto out_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (i_size_read(inode) &gt; 0) {
 		ret = btrfs_check_trunc_cache_free_space(root,
 					&amp;root-&gt;fs_info-&gt;global_block_rsv);
<span class="p_header">diff --git a/fs/nfs/dir.c b/fs/nfs/dir.c</span>
<span class="p_header">index d04ec3814779..65566d5fcf39 100644</span>
<span class="p_header">--- a/fs/nfs/dir.c</span>
<span class="p_header">+++ b/fs/nfs/dir.c</span>
<span class="p_chunk">@@ -1292,7 +1292,7 @@</span> <span class="p_context"> static int nfs_weak_revalidate(struct dentry *dentry, unsigned int flags)</span>
 		return 0;
 	}
 
<span class="p_del">-	error = nfs_revalidate_inode(NFS_SERVER(inode), inode);</span>
<span class="p_add">+	error = nfs_lookup_verify_inode(inode, flags);</span>
 	dfprintk(LOOKUPCACHE, &quot;NFS: %s: inode %lu is %s\n&quot;,
 			__func__, inode-&gt;i_ino, error ? &quot;invalid&quot; : &quot;valid&quot;);
 	return !error;
<span class="p_chunk">@@ -1443,6 +1443,7 @@</span> <span class="p_context"> static int nfs4_lookup_revalidate(struct dentry *, unsigned int);</span>
 
 const struct dentry_operations nfs4_dentry_operations = {
 	.d_revalidate	= nfs4_lookup_revalidate,
<span class="p_add">+	.d_weak_revalidate	= nfs_weak_revalidate,</span>
 	.d_delete	= nfs_dentry_delete,
 	.d_iput		= nfs_dentry_iput,
 	.d_automount	= nfs_d_automount,
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index ec2a69dac536..9ebb2d7c8182 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -3513,7 +3513,9 @@</span> <span class="p_context"> nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 		/* ignore lock owners */
 		if (local-&gt;st_stateowner-&gt;so_is_open_owner == 0)
 			continue;
<span class="p_del">-		if (local-&gt;st_stateowner == &amp;oo-&gt;oo_owner) {</span>
<span class="p_add">+		if (local-&gt;st_stateowner != &amp;oo-&gt;oo_owner)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (local-&gt;st_stid.sc_type == NFS4_OPEN_STID) {</span>
 			ret = local;
 			atomic_inc(&amp;ret-&gt;st_stid.sc_count);
 			break;
<span class="p_chunk">@@ -3522,6 +3524,52 @@</span> <span class="p_context"> nfsd4_find_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 	return ret;
 }
 
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_verify_open_stid(struct nfs4_stid *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 ret = nfs_ok;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (s-&gt;sc_type) {</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NFS4_CLOSED_STID:</span>
<span class="p_add">+	case NFS4_CLOSED_DELEG_STID:</span>
<span class="p_add">+		ret = nfserr_bad_stateid;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NFS4_REVOKED_DELEG_STID:</span>
<span class="p_add">+		ret = nfserr_deleg_revoked;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Lock the stateid st_mutex, and deal with races with CLOSE */</span>
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_lock_ol_stateid(struct nfs4_ol_stateid *stp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__be32 ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	ret = nfsd4_verify_open_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_add">+	if (ret != nfs_ok)</span>
<span class="p_add">+		mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct nfs4_ol_stateid *</span>
<span class="p_add">+nfsd4_find_and_lock_existing_open(struct nfs4_file *fp, struct nfsd4_open *open)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs4_ol_stateid *stp;</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		spin_lock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		stp = nfsd4_find_existing_open(fp, open);</span>
<span class="p_add">+		spin_unlock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		if (!stp || nfsd4_lock_ol_stateid(stp) == nfs_ok)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		nfs4_put_stid(&amp;stp-&gt;st_stid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return stp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct nfs4_openowner *
 alloc_init_open_stateowner(unsigned int strhashval, struct nfsd4_open *open,
 			   struct nfsd4_compound_state *cstate)
<span class="p_chunk">@@ -3566,6 +3614,7 @@</span> <span class="p_context"> init_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 	mutex_init(&amp;stp-&gt;st_mutex);
 	mutex_lock(&amp;stp-&gt;st_mutex);
 
<span class="p_add">+retry:</span>
 	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 	spin_lock(&amp;fp-&gt;fi_lock);
 
<span class="p_chunk">@@ -3590,7 +3639,11 @@</span> <span class="p_context"> init_open_stateid(struct nfs4_file *fp, struct nfsd4_open *open)</span>
 	spin_unlock(&amp;fp-&gt;fi_lock);
 	spin_unlock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);
 	if (retstp) {
<span class="p_del">-		mutex_lock(&amp;retstp-&gt;st_mutex);</span>
<span class="p_add">+		/* Handle races with CLOSE */</span>
<span class="p_add">+		if (nfsd4_lock_ol_stateid(retstp) != nfs_ok) {</span>
<span class="p_add">+			nfs4_put_stid(&amp;retstp-&gt;st_stid);</span>
<span class="p_add">+			goto retry;</span>
<span class="p_add">+		}</span>
 		/* To keep mutex tracking happy */
 		mutex_unlock(&amp;stp-&gt;st_mutex);
 		stp = retstp;
<span class="p_chunk">@@ -4400,6 +4453,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 	struct nfs4_ol_stateid *stp = NULL;
 	struct nfs4_delegation *dp = NULL;
 	__be32 status;
<span class="p_add">+	bool new_stp = false;</span>
 
 	/*
 	 * Lookup file; if found, lookup stateid and check open request,
<span class="p_chunk">@@ -4411,9 +4465,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 		status = nfs4_check_deleg(cl, open, &amp;dp);
 		if (status)
 			goto out;
<span class="p_del">-		spin_lock(&amp;fp-&gt;fi_lock);</span>
<span class="p_del">-		stp = nfsd4_find_existing_open(fp, open);</span>
<span class="p_del">-		spin_unlock(&amp;fp-&gt;fi_lock);</span>
<span class="p_add">+		stp = nfsd4_find_and_lock_existing_open(fp, open);</span>
 	} else {
 		open-&gt;op_file = NULL;
 		status = nfserr_bad_stateid;
<span class="p_chunk">@@ -4421,35 +4473,31 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 			goto out;
 	}
 
<span class="p_add">+	if (!stp) {</span>
<span class="p_add">+		stp = init_open_stateid(fp, open);</span>
<span class="p_add">+		if (!open-&gt;op_stp)</span>
<span class="p_add">+			new_stp = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * OPEN the file, or upgrade an existing OPEN.
 	 * If truncate fails, the OPEN fails.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * stp is already locked.</span>
 	 */
<span class="p_del">-	if (stp) {</span>
<span class="p_add">+	if (!new_stp) {</span>
 		/* Stateid was found, this is an OPEN upgrade */
<span class="p_del">-		mutex_lock(&amp;stp-&gt;st_mutex);</span>
 		status = nfs4_upgrade_open(rqstp, fp, current_fh, stp, open);
 		if (status) {
 			mutex_unlock(&amp;stp-&gt;st_mutex);
 			goto out;
 		}
 	} else {
<span class="p_del">-		/* stp is returned locked. */</span>
<span class="p_del">-		stp = init_open_stateid(fp, open);</span>
<span class="p_del">-		/* See if we lost the race to some other thread */</span>
<span class="p_del">-		if (stp-&gt;st_access_bmap != 0) {</span>
<span class="p_del">-			status = nfs4_upgrade_open(rqstp, fp, current_fh,</span>
<span class="p_del">-						stp, open);</span>
<span class="p_del">-			if (status) {</span>
<span class="p_del">-				mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_del">-				goto out;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			goto upgrade_out;</span>
<span class="p_del">-		}</span>
 		status = nfs4_get_vfs_file(rqstp, fp, current_fh, stp, open);
 		if (status) {
<span class="p_del">-			mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+			stp-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 			release_open_stateid(stp);
<span class="p_add">+			mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 			goto out;
 		}
 
<span class="p_chunk">@@ -4458,7 +4506,7 @@</span> <span class="p_context"> nfsd4_process_open2(struct svc_rqst *rqstp, struct svc_fh *current_fh, struct nf</span>
 		if (stp-&gt;st_clnt_odstate == open-&gt;op_odstate)
 			open-&gt;op_odstate = NULL;
 	}
<span class="p_del">-upgrade_out:</span>
<span class="p_add">+</span>
 	nfs4_inc_and_copy_stateid(&amp;open-&gt;op_stateid, &amp;stp-&gt;st_stid);
 	mutex_unlock(&amp;stp-&gt;st_mutex);
 
<span class="p_chunk">@@ -4684,7 +4732,7 @@</span> <span class="p_context"> nfs4_laundromat(struct nfsd_net *nn)</span>
 	spin_unlock(&amp;nn-&gt;blocked_locks_lock);
 
 	while (!list_empty(&amp;reaplist)) {
<span class="p_del">-		nbl = list_first_entry(&amp;nn-&gt;blocked_locks_lru,</span>
<span class="p_add">+		nbl = list_first_entry(&amp;reaplist,</span>
 					struct nfsd4_blocked_lock, nbl_lru);
 		list_del_init(&amp;nbl-&gt;nbl_lru);
 		posix_unblock_lock(&amp;nbl-&gt;nbl_lock);
<span class="p_chunk">@@ -5314,7 +5362,6 @@</span> <span class="p_context"> static void nfsd4_close_open_stateid(struct nfs4_ol_stateid *s)</span>
 	bool unhashed;
 	LIST_HEAD(reaplist);
 
<span class="p_del">-	s-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 	spin_lock(&amp;clp-&gt;cl_lock);
 	unhashed = unhash_open_stateid(s, &amp;reaplist);
 
<span class="p_chunk">@@ -5353,10 +5400,12 @@</span> <span class="p_context"> nfsd4_close(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 	nfsd4_bump_seqid(cstate, status);
 	if (status)
 		goto out; 
<span class="p_add">+</span>
<span class="p_add">+	stp-&gt;st_stid.sc_type = NFS4_CLOSED_STID;</span>
 	nfs4_inc_and_copy_stateid(&amp;close-&gt;cl_stateid, &amp;stp-&gt;st_stid);
<span class="p_del">-	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 
 	nfsd4_close_open_stateid(stp);
<span class="p_add">+	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
 
 	/* put reference from nfs4_preprocess_seqid_op */
 	nfs4_put_stid(&amp;stp-&gt;st_stid);
<span class="p_chunk">@@ -7094,7 +7143,7 @@</span> <span class="p_context"> nfs4_state_shutdown_net(struct net *net)</span>
 	spin_unlock(&amp;nn-&gt;blocked_locks_lock);
 
 	while (!list_empty(&amp;reaplist)) {
<span class="p_del">-		nbl = list_first_entry(&amp;nn-&gt;blocked_locks_lru,</span>
<span class="p_add">+		nbl = list_first_entry(&amp;reaplist,</span>
 					struct nfsd4_blocked_lock, nbl_lru);
 		list_del_init(&amp;nbl-&gt;nbl_lru);
 		posix_unblock_lock(&amp;nbl-&gt;nbl_lock);
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 6c9e1ad12831..2217e2f18247 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -347,6 +347,7 @@</span> <span class="p_context"> struct fault_env {</span>
 struct vm_operations_struct {
 	void (*open)(struct vm_area_struct * area);
 	void (*close)(struct vm_area_struct * area);
<span class="p_add">+	int (*split)(struct vm_area_struct * area, unsigned long addr);</span>
 	int (*mremap)(struct vm_area_struct * area);
 	int (*fault)(struct vm_area_struct *vma, struct vm_fault *vmf);
 	int (*pmd_fault)(struct vm_area_struct *, unsigned long address,
<span class="p_header">diff --git a/include/uapi/linux/bcache.h b/include/uapi/linux/bcache.h</span>
<span class="p_header">index 22b6ad31c706..8562b1cb776b 100644</span>
<span class="p_header">--- a/include/uapi/linux/bcache.h</span>
<span class="p_header">+++ b/include/uapi/linux/bcache.h</span>
<span class="p_chunk">@@ -90,7 +90,7 @@</span> <span class="p_context"> PTR_FIELD(PTR_GEN,			0,  8)</span>
 
 #define PTR_CHECK_DEV			((1 &lt;&lt; PTR_DEV_BITS) - 1)
 
<span class="p_del">-#define PTR(gen, offset, dev)						\</span>
<span class="p_add">+#define MAKE_PTR(gen, offset, dev)					\</span>
 	((((__u64) dev) &lt;&lt; 51) | ((__u64) offset) &lt;&lt; 8 | gen)
 
 /* Bkey utility code */
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 8258e9eee806..3cae1dcf069c 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -745,20 +745,15 @@</span> <span class="p_context"> int vmf_insert_pfn_pmd(struct vm_area_struct *vma, unsigned long addr,</span>
 EXPORT_SYMBOL_GPL(vmf_insert_pfn_pmd);
 
 static void touch_pmd(struct vm_area_struct *vma, unsigned long addr,
<span class="p_del">-		pmd_t *pmd)</span>
<span class="p_add">+		pmd_t *pmd, int flags)</span>
 {
 	pmd_t _pmd;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We should set the dirty bit only for FOLL_WRITE but for now</span>
<span class="p_del">-	 * the dirty bit in the pmd is meaningless.  And if the dirty</span>
<span class="p_del">-	 * bit will become meaningful and we&#39;ll only set it with</span>
<span class="p_del">-	 * FOLL_WRITE, an atomic set_bit will be required on the pmd to</span>
<span class="p_del">-	 * set the young bit, instead of the current set_pmd_at.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	_pmd = pmd_mkyoung(pmd_mkdirty(*pmd));</span>
<span class="p_add">+	_pmd = pmd_mkyoung(*pmd);</span>
<span class="p_add">+	if (flags &amp; FOLL_WRITE)</span>
<span class="p_add">+		_pmd = pmd_mkdirty(_pmd);</span>
 	if (pmdp_set_access_flags(vma, addr &amp; HPAGE_PMD_MASK,
<span class="p_del">-				pmd, _pmd,  1))</span>
<span class="p_add">+				pmd, _pmd, flags &amp; FOLL_WRITE))</span>
 		update_mmu_cache_pmd(vma, addr, pmd);
 }
 
<span class="p_chunk">@@ -787,7 +782,7 @@</span> <span class="p_context"> struct page *follow_devmap_pmd(struct vm_area_struct *vma, unsigned long addr,</span>
 		return NULL;
 
 	if (flags &amp; FOLL_TOUCH)
<span class="p_del">-		touch_pmd(vma, addr, pmd);</span>
<span class="p_add">+		touch_pmd(vma, addr, pmd, flags);</span>
 
 	/*
 	 * device mapped pages can only be returned if the
<span class="p_chunk">@@ -1158,7 +1153,7 @@</span> <span class="p_context"> struct page *follow_trans_huge_pmd(struct vm_area_struct *vma,</span>
 	page = pmd_page(*pmd);
 	VM_BUG_ON_PAGE(!PageHead(page) &amp;&amp; !is_zone_device_page(page), page);
 	if (flags &amp; FOLL_TOUCH)
<span class="p_del">-		touch_pmd(vma, addr, pmd);</span>
<span class="p_add">+		touch_pmd(vma, addr, pmd, flags);</span>
 	if ((flags &amp; FOLL_MLOCK) &amp;&amp; (vma-&gt;vm_flags &amp; VM_LOCKED)) {
 		/*
 		 * We don&#39;t mlock() pte-mapped THPs. This way we can avoid
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 65c36acf8a6b..6ff65c405243 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -3135,6 +3135,13 @@</span> <span class="p_context"> static void hugetlb_vm_op_close(struct vm_area_struct *vma)</span>
 	}
 }
 
<span class="p_add">+static int hugetlb_vm_op_split(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (addr &amp; ~(huge_page_mask(hstate_vma(vma))))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * We cannot handle pagefaults against hugetlb pages at all.  They cause
  * handle_mm_fault() to try to instantiate regular-sized pages in the
<span class="p_chunk">@@ -3151,6 +3158,7 @@</span> <span class="p_context"> const struct vm_operations_struct hugetlb_vm_ops = {</span>
 	.fault = hugetlb_vm_op_fault,
 	.open = hugetlb_vm_op_open,
 	.close = hugetlb_vm_op_close,
<span class="p_add">+	.split = hugetlb_vm_op_split,</span>
 };
 
 static pte_t make_huge_pte(struct vm_area_struct *vma, struct page *page,
<span class="p_header">diff --git a/mm/madvise.c b/mm/madvise.c</span>
<span class="p_header">index 55f30ec32e5b..a49afe08698b 100644</span>
<span class="p_header">--- a/mm/madvise.c</span>
<span class="p_header">+++ b/mm/madvise.c</span>
<span class="p_chunk">@@ -228,15 +228,14 @@</span> <span class="p_context"> static long madvise_willneed(struct vm_area_struct *vma,</span>
 {
 	struct file *file = vma-&gt;vm_file;
 
<span class="p_add">+	*prev = vma;</span>
 #ifdef CONFIG_SWAP
 	if (!file) {
<span class="p_del">-		*prev = vma;</span>
 		force_swapin_readahead(vma, start, end);
 		return 0;
 	}
 
 	if (shmem_mapping(file-&gt;f_mapping)) {
<span class="p_del">-		*prev = vma;</span>
 		force_shm_swapin_readahead(vma, start, end,
 					file-&gt;f_mapping);
 		return 0;
<span class="p_chunk">@@ -251,7 +250,6 @@</span> <span class="p_context"> static long madvise_willneed(struct vm_area_struct *vma,</span>
 		return 0;
 	}
 
<span class="p_del">-	*prev = vma;</span>
 	start = ((start - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;
 	if (end &gt; vma-&gt;vm_end)
 		end = vma-&gt;vm_end;
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 75d263bd8739..5b48adb4aa56 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -2538,9 +2538,11 @@</span> <span class="p_context"> static int __split_vma(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	struct vm_area_struct *new;
 	int err;
 
<span class="p_del">-	if (is_vm_hugetlb_page(vma) &amp;&amp; (addr &amp;</span>
<span class="p_del">-					~(huge_page_mask(hstate_vma(vma)))))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	if (vma-&gt;vm_ops &amp;&amp; vma-&gt;vm_ops-&gt;split) {</span>
<span class="p_add">+		err = vma-&gt;vm_ops-&gt;split(vma, addr);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
 
 	new = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);
 	if (!new)
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index 4a044134ce84..ef5ee56095e8 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -7309,11 +7309,18 @@</span> <span class="p_context"> int alloc_contig_range(unsigned long start, unsigned long end,</span>
 
 	/*
 	 * In case of -EBUSY, we&#39;d like to know which page causes problem.
<span class="p_del">-	 * So, just fall through. We will check it in test_pages_isolated().</span>
<span class="p_add">+	 * So, just fall through. test_pages_isolated() has a tracepoint</span>
<span class="p_add">+	 * which will report the busy page.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * It is possible that busy pages could become available before</span>
<span class="p_add">+	 * the call to test_pages_isolated, and the range will actually be</span>
<span class="p_add">+	 * allocated.  So, if we fall through be sure to clear ret so that</span>
<span class="p_add">+	 * -EBUSY is not accidentally used or returned to caller.</span>
 	 */
 	ret = __alloc_contig_migrate_range(&amp;cc, start, end);
 	if (ret &amp;&amp; ret != -EBUSY)
 		goto done;
<span class="p_add">+	ret =0;</span>
 
 	/*
 	 * Pages from [start, end) are within a MAX_ORDER_NR_PAGES

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



