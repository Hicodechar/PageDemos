
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.36 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.36</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 5, 2017, 2:09 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170705140942.GB2634@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9826593/mbox/"
   >mbox</a>
|
   <a href="/patch/9826593/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9826593/">/patch/9826593/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	3E69760317 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:10:07 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 00B06283C0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:10:07 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id E7E4328543; Wed,  5 Jul 2017 14:10:06 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 03E54283C0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  5 Jul 2017 14:09:57 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752011AbdGEOJw (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 5 Jul 2017 10:09:52 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:60362 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751964AbdGEOJp (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 5 Jul 2017 10:09:45 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id A3FA1BE7;
	Wed,  5 Jul 2017 14:09:42 +0000 (UTC)
Date: Wed, 5 Jul 2017 16:09:42 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.36
Message-ID: &lt;20170705140942.GB2634@kroah.com&gt;
References: &lt;20170705140934.GA2634@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170705140934.GA2634@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - July 5, 2017, 2:09 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/net/mediatek-net.txt b/Documentation/devicetree/bindings/net/mediatek-net.txt</span>
<span class="p_header">index c010fafc66a8..c7194e87d5f4 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/net/mediatek-net.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/net/mediatek-net.txt</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"> have dual GMAC each represented by a child node..</span>
 * Ethernet controller node
 
 Required properties:
<span class="p_del">-- compatible: Should be &quot;mediatek,mt7623-eth&quot;</span>
<span class="p_add">+- compatible: Should be &quot;mediatek,mt2701-eth&quot;</span>
 - reg: Address and length of the register set for the device
 - interrupts: Should contain the three frame engines interrupts in numeric
 	order. These are fe_int0, fe_int1 and fe_int2.
<span class="p_header">diff --git a/Documentation/devicetree/bindings/net/phy.txt b/Documentation/devicetree/bindings/net/phy.txt</span>
<span class="p_header">index bc1c3c8bf8fa..62bdc5f2bf16 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/net/phy.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/net/phy.txt</span>
<span class="p_chunk">@@ -35,6 +35,15 @@</span> <span class="p_context"> Optional Properties:</span>
 - broken-turn-around: If set, indicates the PHY device does not correctly
   release the turn around line low at the end of a MDIO transaction.
 
<span class="p_add">+- eee-broken-100tx:</span>
<span class="p_add">+- eee-broken-1000t:</span>
<span class="p_add">+- eee-broken-10gt:</span>
<span class="p_add">+- eee-broken-1000kx:</span>
<span class="p_add">+- eee-broken-10gkx4:</span>
<span class="p_add">+- eee-broken-10gkr:</span>
<span class="p_add">+  Mark the corresponding energy efficient ethernet mode as broken and</span>
<span class="p_add">+  request the ethernet to stop advertising it.</span>
<span class="p_add">+</span>
 Example:
 
 ethernet-phy@0 {
<span class="p_header">diff --git a/Documentation/devicetree/bindings/net/ti,dp83867.txt b/Documentation/devicetree/bindings/net/ti,dp83867.txt</span>
<span class="p_header">index 5d21141a68b5..75bcaa355880 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/net/ti,dp83867.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/net/ti,dp83867.txt</span>
<span class="p_chunk">@@ -3,9 +3,11 @@</span> <span class="p_context"></span>
 Required properties:
 	- reg - The ID number for the phy, usually a small integer
 	- ti,rx-internal-delay - RGMII Receive Clock Delay - see dt-bindings/net/ti-dp83867.h
<span class="p_del">-		for applicable values</span>
<span class="p_add">+		for applicable values. Required only if interface type is</span>
<span class="p_add">+		PHY_INTERFACE_MODE_RGMII_ID or PHY_INTERFACE_MODE_RGMII_RXID</span>
 	- ti,tx-internal-delay - RGMII Transmit Clock Delay - see dt-bindings/net/ti-dp83867.h
<span class="p_del">-		for applicable values</span>
<span class="p_add">+		for applicable values. Required only if interface type is</span>
<span class="p_add">+		PHY_INTERFACE_MODE_RGMII_ID or PHY_INTERFACE_MODE_RGMII_TXID</span>
 	- ti,fifo-depth - Transmitt FIFO depth- see dt-bindings/net/ti-dp83867.h
 		for applicable values
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 0a8d47465f97..4263dca12f07 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 35</span>
<span class="p_add">+SUBLEVEL = 36</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">index 8f9a69ca818c..efe53998c961 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"></span>
 &amp;i2c3 {
 	clock-frequency = &lt;400000&gt;;
 	at24@50 {
<span class="p_del">-		compatible = &quot;at24,24c02&quot;;</span>
<span class="p_add">+		compatible = &quot;atmel,24c64&quot;;</span>
 		readonly;
 		reg = &lt;0x50&gt;;
 	};
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c</span>
<span class="p_header">index e920dd83e443..f989145480c8 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_device.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_device.c</span>
<span class="p_chunk">@@ -222,6 +222,14 @@</span> <span class="p_context"> static int _omap_device_notifier_call(struct notifier_block *nb,</span>
 				dev_err(dev, &quot;failed to idle\n&quot;);
 		}
 		break;
<span class="p_add">+	case BUS_NOTIFY_BIND_DRIVER:</span>
<span class="p_add">+		od = to_omap_device(pdev);</span>
<span class="p_add">+		if (od &amp;&amp; (od-&gt;_state == OMAP_DEVICE_STATE_ENABLED) &amp;&amp;</span>
<span class="p_add">+		    pm_runtime_status_suspended(dev)) {</span>
<span class="p_add">+			od-&gt;_driver_status = BUS_NOTIFY_BIND_DRIVER;</span>
<span class="p_add">+			pm_runtime_set_active(dev);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
 	case BUS_NOTIFY_ADD_DEVICE:
 		if (pdev-&gt;dev.of_node)
 			omap_device_build_from_dt(pdev);
<span class="p_header">diff --git a/arch/arm/mm/mmu.c b/arch/arm/mm/mmu.c</span>
<span class="p_header">index 5cbfd9f86412..f7c741358f37 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmu.c</span>
<span class="p_chunk">@@ -1211,15 +1211,15 @@</span> <span class="p_context"> void __init adjust_lowmem_bounds(void)</span>
 
 	high_memory = __va(arm_lowmem_limit - 1) + 1;
 
<span class="p_add">+	if (!memblock_limit)</span>
<span class="p_add">+		memblock_limit = arm_lowmem_limit;</span>
<span class="p_add">+</span>
 	/*
 	 * Round the memblock limit down to a pmd size.  This
 	 * helps to ensure that we will allocate memory from the
 	 * last full pmd, which should be mapped.
 	 */
<span class="p_del">-	if (memblock_limit)</span>
<span class="p_del">-		memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
<span class="p_del">-	if (!memblock_limit)</span>
<span class="p_del">-		memblock_limit = arm_lowmem_limit;</span>
<span class="p_add">+	memblock_limit = round_down(memblock_limit, PMD_SIZE);</span>
 
 	if (!IS_ENABLED(CONFIG_HIGHMEM) || cache_is_vipt_aliasing()) {
 		if (memblock_end_of_DRAM() &gt; arm_lowmem_limit) {
<span class="p_header">diff --git a/arch/arm64/boot/dts/amlogic/meson-gxbb-odroidc2.dts b/arch/arm64/boot/dts/amlogic/meson-gxbb-odroidc2.dts</span>
<span class="p_header">index e6e3491d48a5..f150a4c63efe 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/amlogic/meson-gxbb-odroidc2.dts</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/amlogic/meson-gxbb-odroidc2.dts</span>
<span class="p_chunk">@@ -85,6 +85,18 @@</span> <span class="p_context"></span>
 	status = &quot;okay&quot;;
 	pinctrl-0 = &lt;&amp;eth_pins&gt;;
 	pinctrl-names = &quot;default&quot;;
<span class="p_add">+	phy-handle = &lt;&amp;eth_phy0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+	mdio {</span>
<span class="p_add">+		compatible = &quot;snps,dwmac-mdio&quot;;</span>
<span class="p_add">+		#address-cells = &lt;1&gt;;</span>
<span class="p_add">+		#size-cells = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+		eth_phy0: ethernet-phy@0 {</span>
<span class="p_add">+			reg = &lt;0&gt;;</span>
<span class="p_add">+			eee-broken-1000t;</span>
<span class="p_add">+		};</span>
<span class="p_add">+	};</span>
 };
 
 &amp;ir {
<span class="p_header">diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">index e517088d635f..de04879bc8b8 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/acpi.h</span>
<span class="p_chunk">@@ -22,9 +22,9 @@</span> <span class="p_context"></span>
 #define ACPI_MADT_GICC_LENGTH	\
 	(acpi_gbl_FADT.header.revision &lt; 6 ? 76 : 80)
 
<span class="p_del">-#define BAD_MADT_GICC_ENTRY(entry, end)						\</span>
<span class="p_del">-	(!(entry) || (unsigned long)(entry) + sizeof(*(entry)) &gt; (end) ||	\</span>
<span class="p_del">-	 (entry)-&gt;header.length != ACPI_MADT_GICC_LENGTH)</span>
<span class="p_add">+#define BAD_MADT_GICC_ENTRY(entry, end)					\</span>
<span class="p_add">+	(!(entry) || (entry)-&gt;header.length != ACPI_MADT_GICC_LENGTH ||	\</span>
<span class="p_add">+	(unsigned long)(entry) + ACPI_MADT_GICC_LENGTH &gt; (end))</span>
 
 /* Basic configuration for ACPI */
 #ifdef	CONFIG_ACPI
<span class="p_header">diff --git a/arch/arm64/include/asm/assembler.h b/arch/arm64/include/asm/assembler.h</span>
<span class="p_header">index 28bfe6132eb6..851290d2bfe3 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/assembler.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/assembler.h</span>
<span class="p_chunk">@@ -155,22 +155,25 @@</span> <span class="p_context"> lr	.req	x30		// link register</span>
 
 /*
  * Pseudo-ops for PC-relative adr/ldr/str &lt;reg&gt;, &lt;symbol&gt; where
<span class="p_del">- * &lt;symbol&gt; is within the range +/- 4 GB of the PC.</span>
<span class="p_add">+ * &lt;symbol&gt; is within the range +/- 4 GB of the PC when running</span>
<span class="p_add">+ * in core kernel context. In module context, a movz/movk sequence</span>
<span class="p_add">+ * is used, since modules may be loaded far away from the kernel</span>
<span class="p_add">+ * when KASLR is in effect.</span>
  */
 	/*
 	 * @dst: destination register (64 bit wide)
 	 * @sym: name of the symbol
<span class="p_del">-	 * @tmp: optional scratch register to be used if &lt;dst&gt; == sp, which</span>
<span class="p_del">-	 *       is not allowed in an adrp instruction</span>
 	 */
<span class="p_del">-	.macro	adr_l, dst, sym, tmp=</span>
<span class="p_del">-	.ifb	\tmp</span>
<span class="p_add">+	.macro	adr_l, dst, sym</span>
<span class="p_add">+#ifndef MODULE</span>
 	adrp	\dst, \sym
 	add	\dst, \dst, :lo12:\sym
<span class="p_del">-	.else</span>
<span class="p_del">-	adrp	\tmp, \sym</span>
<span class="p_del">-	add	\dst, \tmp, :lo12:\sym</span>
<span class="p_del">-	.endif</span>
<span class="p_add">+#else</span>
<span class="p_add">+	movz	\dst, #:abs_g3:\sym</span>
<span class="p_add">+	movk	\dst, #:abs_g2_nc:\sym</span>
<span class="p_add">+	movk	\dst, #:abs_g1_nc:\sym</span>
<span class="p_add">+	movk	\dst, #:abs_g0_nc:\sym</span>
<span class="p_add">+#endif</span>
 	.endm
 
 	/*
<span class="p_chunk">@@ -181,6 +184,7 @@</span> <span class="p_context"> lr	.req	x30		// link register</span>
 	 *       the address
 	 */
 	.macro	ldr_l, dst, sym, tmp=
<span class="p_add">+#ifndef MODULE</span>
 	.ifb	\tmp
 	adrp	\dst, \sym
 	ldr	\dst, [\dst, :lo12:\sym]
<span class="p_chunk">@@ -188,6 +192,15 @@</span> <span class="p_context"> lr	.req	x30		// link register</span>
 	adrp	\tmp, \sym
 	ldr	\dst, [\tmp, :lo12:\sym]
 	.endif
<span class="p_add">+#else</span>
<span class="p_add">+	.ifb	\tmp</span>
<span class="p_add">+	adr_l	\dst, \sym</span>
<span class="p_add">+	ldr	\dst, [\dst]</span>
<span class="p_add">+	.else</span>
<span class="p_add">+	adr_l	\tmp, \sym</span>
<span class="p_add">+	ldr	\dst, [\tmp]</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+#endif</span>
 	.endm
 
 	/*
<span class="p_chunk">@@ -197,8 +210,13 @@</span> <span class="p_context"> lr	.req	x30		// link register</span>
 	 *       while &lt;src&gt; needs to be preserved.
 	 */
 	.macro	str_l, src, sym, tmp
<span class="p_add">+#ifndef MODULE</span>
 	adrp	\tmp, \sym
 	str	\src, [\tmp, :lo12:\sym]
<span class="p_add">+#else</span>
<span class="p_add">+	adr_l	\tmp, \sym</span>
<span class="p_add">+	str	\src, [\tmp]</span>
<span class="p_add">+#endif</span>
 	.endm
 
 	/*
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index 8507703dabe4..a70f7d3361c4 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -934,7 +934,7 @@</span> <span class="p_context"> static bool have_cpu_die(void)</span>
 #ifdef CONFIG_HOTPLUG_CPU
 	int any_cpu = raw_smp_processor_id();
 
<span class="p_del">-	if (cpu_ops[any_cpu]-&gt;cpu_die)</span>
<span class="p_add">+	if (cpu_ops[any_cpu] &amp;&amp; cpu_ops[any_cpu]-&gt;cpu_die)</span>
 		return true;
 #endif
 	return false;
<span class="p_header">diff --git a/arch/mips/kernel/entry.S b/arch/mips/kernel/entry.S</span>
<span class="p_header">index 7791840cf22c..db07793f7b43 100644</span>
<span class="p_header">--- a/arch/mips/kernel/entry.S</span>
<span class="p_header">+++ b/arch/mips/kernel/entry.S</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/asm.h&gt;
 #include &lt;asm/asmmacro.h&gt;
 #include &lt;asm/compiler.h&gt;
<span class="p_add">+#include &lt;asm/irqflags.h&gt;</span>
 #include &lt;asm/regdef.h&gt;
 #include &lt;asm/mipsregs.h&gt;
 #include &lt;asm/stackframe.h&gt;
<span class="p_chunk">@@ -137,6 +138,7 @@</span> <span class="p_context"> work_pending:</span>
 	andi	t0, a2, _TIF_NEED_RESCHED # a2 is preloaded with TI_FLAGS
 	beqz	t0, work_notifysig
 work_resched:
<span class="p_add">+	TRACE_IRQS_OFF</span>
 	jal	schedule
 
 	local_irq_disable		# make sure need_resched and
<span class="p_chunk">@@ -173,6 +175,7 @@</span> <span class="p_context"> syscall_exit_work:</span>
 	beqz	t0, work_pending	# trace bit set?
 	local_irq_enable		# could let syscall_trace_leave()
 					# call schedule() instead
<span class="p_add">+	TRACE_IRQS_ON</span>
 	move	a0, sp
 	jal	syscall_trace_leave
 	b	resume_userspace
<span class="p_header">diff --git a/arch/mips/kernel/head.S b/arch/mips/kernel/head.S</span>
<span class="p_header">index cf052204eb0a..d1bb506adc10 100644</span>
<span class="p_header">--- a/arch/mips/kernel/head.S</span>
<span class="p_header">+++ b/arch/mips/kernel/head.S</span>
<span class="p_chunk">@@ -106,8 +106,8 @@</span> <span class="p_context"> NESTED(kernel_entry, 16, sp)			# kernel entry point</span>
 	beq		t0, t1, dtb_found
 #endif
 	li		t1, -2
<span class="p_del">-	beq		a0, t1, dtb_found</span>
 	move		t2, a1
<span class="p_add">+	beq		a0, t1, dtb_found</span>
 
 	li		t2, 0
 dtb_found:
<span class="p_header">diff --git a/arch/mips/kernel/pm-cps.c b/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">index 7cf653e21423..60c4d4599639 100644</span>
<span class="p_header">--- a/arch/mips/kernel/pm-cps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/pm-cps.c</span>
<span class="p_chunk">@@ -56,7 +56,6 @@</span> <span class="p_context"> DECLARE_BITMAP(state_support, CPS_PM_STATE_COUNT);</span>
  * state. Actually per-core rather than per-CPU.
  */
 static DEFINE_PER_CPU_ALIGNED(u32*, ready_count);
<span class="p_del">-static DEFINE_PER_CPU_ALIGNED(void*, ready_count_alloc);</span>
 
 /* Indicates online CPUs coupled with the current CPU */
 static DEFINE_PER_CPU_ALIGNED(cpumask_t, online_coupled);
<span class="p_chunk">@@ -642,7 +641,6 @@</span> <span class="p_context"> static int cps_pm_online_cpu(unsigned int cpu)</span>
 {
 	enum cps_pm_state state;
 	unsigned core = cpu_data[cpu].core;
<span class="p_del">-	unsigned dlinesz = cpu_data[cpu].dcache.linesz;</span>
 	void *entry_fn, *core_rc;
 
 	for (state = CPS_PM_NC_WAIT; state &lt; CPS_PM_STATE_COUNT; state++) {
<span class="p_chunk">@@ -662,16 +660,11 @@</span> <span class="p_context"> static int cps_pm_online_cpu(unsigned int cpu)</span>
 	}
 
 	if (!per_cpu(ready_count, core)) {
<span class="p_del">-		core_rc = kmalloc(dlinesz * 2, GFP_KERNEL);</span>
<span class="p_add">+		core_rc = kmalloc(sizeof(u32), GFP_KERNEL);</span>
 		if (!core_rc) {
 			pr_err(&quot;Failed allocate core %u ready_count\n&quot;, core);
 			return -ENOMEM;
 		}
<span class="p_del">-		per_cpu(ready_count_alloc, core) = core_rc;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Ensure ready_count is aligned to a cacheline boundary */</span>
<span class="p_del">-		core_rc += dlinesz - 1;</span>
<span class="p_del">-		core_rc = (void *)((unsigned long)core_rc &amp; ~(dlinesz - 1));</span>
 		per_cpu(ready_count, core) = core_rc;
 	}
 
<span class="p_header">diff --git a/arch/mips/kernel/traps.c b/arch/mips/kernel/traps.c</span>
<span class="p_header">index ec87ef93267b..b0b29cb6f3d8 100644</span>
<span class="p_header">--- a/arch/mips/kernel/traps.c</span>
<span class="p_header">+++ b/arch/mips/kernel/traps.c</span>
<span class="p_chunk">@@ -199,6 +199,8 @@</span> <span class="p_context"> void show_stack(struct task_struct *task, unsigned long *sp)</span>
 {
 	struct pt_regs regs;
 	mm_segment_t old_fs = get_fs();
<span class="p_add">+</span>
<span class="p_add">+	regs.cp0_status = KSU_KERNEL;</span>
 	if (sp) {
 		regs.regs[29] = (unsigned long)sp;
 		regs.regs[31] = 0;
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh.c b/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">index f25731627d7f..e5bfbf62827a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh.c</span>
<span class="p_chunk">@@ -298,9 +298,17 @@</span> <span class="p_context"> void eeh_slot_error_detail(struct eeh_pe *pe, int severity)</span>
 	 *
 	 * For pHyp, we have to enable IO for log retrieval. Otherwise,
 	 * 0xFF&#39;s is always returned from PCI config space.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * When the @severity is EEH_LOG_PERM, the PE is going to be</span>
<span class="p_add">+	 * removed. Prior to that, the drivers for devices included in</span>
<span class="p_add">+	 * the PE will be closed. The drivers rely on working IO path</span>
<span class="p_add">+	 * to bring the devices to quiet state. Otherwise, PCI traffic</span>
<span class="p_add">+	 * from those devices after they are removed is like to cause</span>
<span class="p_add">+	 * another unexpected EEH error.</span>
 	 */
 	if (!(pe-&gt;type &amp; EEH_PE_PHB)) {
<span class="p_del">-		if (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG))</span>
<span class="p_add">+		if (eeh_has_flag(EEH_ENABLE_IO_FOR_LOG) ||</span>
<span class="p_add">+		    severity == EEH_LOG_PERM)</span>
 			eeh_pci_enable(pe, EEH_OPT_THAW_MMIO);
 
 		/*
<span class="p_header">diff --git a/arch/s390/include/asm/ctl_reg.h b/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_header">index d7697ab802f6..8e136b88cdf4 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/ctl_reg.h</span>
<span class="p_chunk">@@ -15,7 +15,9 @@</span> <span class="p_context"></span>
 	BUILD_BUG_ON(sizeof(addrtype) != (high - low + 1) * sizeof(long));\
 	asm volatile(							\
 		&quot;	lctlg	%1,%2,%0\n&quot;				\
<span class="p_del">-		: : &quot;Q&quot; (*(addrtype *)(&amp;array)), &quot;i&quot; (low), &quot;i&quot; (high));\</span>
<span class="p_add">+		:							\</span>
<span class="p_add">+		: &quot;Q&quot; (*(addrtype *)(&amp;array)), &quot;i&quot; (low), &quot;i&quot; (high)	\</span>
<span class="p_add">+		: &quot;memory&quot;);						\</span>
 }
 
 #define __ctl_store(array, low, high) {					\
<span class="p_header">diff --git a/arch/sparc/kernel/irq_64.c b/arch/sparc/kernel/irq_64.c</span>
<span class="p_header">index e1b1ce63a328..5cbf03c14981 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/irq_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/irq_64.c</span>
<span class="p_chunk">@@ -1021,7 +1021,7 @@</span> <span class="p_context"> static void __init alloc_one_queue(unsigned long *pa_ptr, unsigned long qmask)</span>
 	unsigned long order = get_order(size);
 	unsigned long p;
 
<span class="p_del">-	p = __get_free_pages(GFP_KERNEL, order);</span>
<span class="p_add">+	p = __get_free_pages(GFP_KERNEL | __GFP_ZERO, order);</span>
 	if (!p) {
 		prom_printf(&quot;SUN4V: Error, cannot allocate queue.\n&quot;);
 		prom_halt();
<span class="p_header">diff --git a/arch/sparc/kernel/traps_64.c b/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">index 496fa926e1e0..d44fb806bbd7 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/traps_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/traps_64.c</span>
<span class="p_chunk">@@ -2051,6 +2051,73 @@</span> <span class="p_context"> void sun4v_resum_overflow(struct pt_regs *regs)</span>
 	atomic_inc(&amp;sun4v_resum_oflow_cnt);
 }
 
<span class="p_add">+/* Given a set of registers, get the virtual addressi that was being accessed</span>
<span class="p_add">+ * by the faulting instructions at tpc.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned long sun4v_get_vaddr(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int insn;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!copy_from_user(&amp;insn, (void __user *)regs-&gt;tpc, 4)) {</span>
<span class="p_add">+		return compute_effective_address(regs, insn,</span>
<span class="p_add">+						 (insn &gt;&gt; 25) &amp; 0x1f);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Attempt to handle non-resumable errors generated from userspace.</span>
<span class="p_add">+ * Returns true if the signal was handled, false otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool sun4v_nonresum_error_user_handled(struct pt_regs *regs,</span>
<span class="p_add">+				  struct sun4v_error_entry *ent) {</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned int attrs = ent-&gt;err_attrs;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (attrs &amp; SUN4V_ERR_ATTRS_MEMORY) {</span>
<span class="p_add">+		unsigned long addr = ent-&gt;err_raddr;</span>
<span class="p_add">+		siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (addr == ~(u64)0) {</span>
<span class="p_add">+			/* This seems highly unlikely to ever occur */</span>
<span class="p_add">+			pr_emerg(&quot;SUN4V NON-RECOVERABLE ERROR: Memory error detected in unknown location!\n&quot;);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			unsigned long page_cnt = DIV_ROUND_UP(ent-&gt;err_size,</span>
<span class="p_add">+							      PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Break the unfortunate news. */</span>
<span class="p_add">+			pr_emerg(&quot;SUN4V NON-RECOVERABLE ERROR: Memory failed at %016lX\n&quot;,</span>
<span class="p_add">+				 addr);</span>
<span class="p_add">+			pr_emerg(&quot;SUN4V NON-RECOVERABLE ERROR:   Claiming %lu ages.\n&quot;,</span>
<span class="p_add">+				 page_cnt);</span>
<span class="p_add">+</span>
<span class="p_add">+			while (page_cnt-- &gt; 0) {</span>
<span class="p_add">+				if (pfn_valid(addr &gt;&gt; PAGE_SHIFT))</span>
<span class="p_add">+					get_page(pfn_to_page(addr &gt;&gt; PAGE_SHIFT));</span>
<span class="p_add">+				addr += PAGE_SIZE;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		info.si_signo = SIGKILL;</span>
<span class="p_add">+		info.si_errno = 0;</span>
<span class="p_add">+		info.si_trapno = 0;</span>
<span class="p_add">+		force_sig_info(info.si_signo, &amp;info, current);</span>
<span class="p_add">+</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (attrs &amp; SUN4V_ERR_ATTRS_PIO) {</span>
<span class="p_add">+		siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+		info.si_signo = SIGBUS;</span>
<span class="p_add">+		info.si_code = BUS_ADRERR;</span>
<span class="p_add">+		info.si_addr = (void __user *)sun4v_get_vaddr(regs);</span>
<span class="p_add">+		force_sig_info(info.si_signo, &amp;info, current);</span>
<span class="p_add">+</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Default to doing nothing */</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* We run with %pil set to PIL_NORMAL_MAX and PSTATE_IE enabled in %pstate.
  * Log the event, clear the first word of the entry, and die.
  */
<span class="p_chunk">@@ -2075,6 +2142,12 @@</span> <span class="p_context"> void sun4v_nonresum_error(struct pt_regs *regs, unsigned long offset)</span>
 
 	put_cpu();
 
<span class="p_add">+	if (!(regs-&gt;tstate &amp; TSTATE_PRIV) &amp;&amp;</span>
<span class="p_add">+	    sun4v_nonresum_error_user_handled(regs, &amp;local_copy)) {</span>
<span class="p_add">+		/* DON&#39;T PANIC: This userspace error was handled. */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PCI
 	/* Check for the special PCI poke sequence. */
 	if (pci_poke_in_progress &amp;&amp; pci_poke_cpu == cpu) {
<span class="p_header">diff --git a/arch/x86/boot/compressed/kaslr.c b/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_header">index a66854d99ee1..6de58f1bd7ec 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_chunk">@@ -430,9 +430,6 @@</span> <span class="p_context"> void choose_random_location(unsigned long input,</span>
 {
 	unsigned long random_addr, min_addr;
 
<span class="p_del">-	/* By default, keep output position unchanged. */</span>
<span class="p_del">-	*virt_addr = *output;</span>
<span class="p_del">-</span>
 	if (cmdline_find_option_bool(&quot;nokaslr&quot;)) {
 		warn(&quot;KASLR disabled: &#39;nokaslr&#39; on cmdline.&quot;);
 		return;
<span class="p_header">diff --git a/arch/x86/boot/compressed/misc.c b/arch/x86/boot/compressed/misc.c</span>
<span class="p_header">index b3c5a5f030ce..c945acd8fa33 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/misc.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/misc.c</span>
<span class="p_chunk">@@ -338,7 +338,7 @@</span> <span class="p_context"> asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,</span>
 				  unsigned long output_len)
 {
 	const unsigned long kernel_total_size = VO__end - VO__text;
<span class="p_del">-	unsigned long virt_addr = (unsigned long)output;</span>
<span class="p_add">+	unsigned long virt_addr = LOAD_PHYSICAL_ADDR;</span>
 
 	/* Retain x86 boot parameters pointer passed from startup_32/64. */
 	boot_params = rmode;
<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> asmlinkage __visible void *extract_kernel(void *rmode, memptr heap,</span>
 #ifndef CONFIG_RELOCATABLE
 	if ((unsigned long)output != LOAD_PHYSICAL_ADDR)
 		error(&quot;Destination address does not match LOAD_PHYSICAL_ADDR&quot;);
<span class="p_del">-	if ((unsigned long)output != virt_addr)</span>
<span class="p_add">+	if (virt_addr != LOAD_PHYSICAL_ADDR)</span>
 		error(&quot;Destination virtual address changed when not relocatable&quot;);
 #endif
 
<span class="p_header">diff --git a/arch/x86/boot/compressed/misc.h b/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">index 1c8355eadbd1..766a5211f827 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/misc.h</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/misc.h</span>
<span class="p_chunk">@@ -81,8 +81,6 @@</span> <span class="p_context"> static inline void choose_random_location(unsigned long input,</span>
 					  unsigned long output_size,
 					  unsigned long *virt_addr)
 {
<span class="p_del">-	/* No change from existing output location. */</span>
<span class="p_del">-	*virt_addr = *output;</span>
 }
 #endif
 
<span class="p_header">diff --git a/arch/x86/events/core.c b/arch/x86/events/core.c</span>
<span class="p_header">index 38623e219816..9604b2574d6c 100644</span>
<span class="p_header">--- a/arch/x86/events/core.c</span>
<span class="p_header">+++ b/arch/x86/events/core.c</span>
<span class="p_chunk">@@ -505,6 +505,10 @@</span> <span class="p_context"> int x86_pmu_hw_config(struct perf_event *event)</span>
 
 		if (event-&gt;attr.precise_ip &gt; precise)
 			return -EOPNOTSUPP;
<span class="p_add">+</span>
<span class="p_add">+		/* There&#39;s no sense in having PEBS for non sampling events: */</span>
<span class="p_add">+		if (!is_sampling_event(event))</span>
<span class="p_add">+			return -EINVAL;</span>
 	}
 	/*
 	 * check that PEBS LBR correction does not conflict with
<span class="p_header">diff --git a/arch/x86/events/intel/core.c b/arch/x86/events/intel/core.c</span>
<span class="p_header">index 3bdb917716b1..f0f197f459b5 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/core.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/core.c</span>
<span class="p_chunk">@@ -3164,13 +3164,16 @@</span> <span class="p_context"> static void intel_pmu_cpu_starting(int cpu)</span>
 
 	if (x86_pmu.flags &amp; PMU_FL_EXCL_CNTRS) {
 		for_each_cpu(i, topology_sibling_cpumask(cpu)) {
<span class="p_add">+			struct cpu_hw_events *sibling;</span>
 			struct intel_excl_cntrs *c;
 
<span class="p_del">-			c = per_cpu(cpu_hw_events, i).excl_cntrs;</span>
<span class="p_add">+			sibling = &amp;per_cpu(cpu_hw_events, i);</span>
<span class="p_add">+			c = sibling-&gt;excl_cntrs;</span>
 			if (c &amp;&amp; c-&gt;core_id == core_id) {
 				cpuc-&gt;kfree_on_online[1] = cpuc-&gt;excl_cntrs;
 				cpuc-&gt;excl_cntrs = c;
<span class="p_del">-				cpuc-&gt;excl_thread_id = 1;</span>
<span class="p_add">+				if (!sibling-&gt;excl_thread_id)</span>
<span class="p_add">+					cpuc-&gt;excl_thread_id = 1;</span>
 				break;
 			}
 		}
<span class="p_chunk">@@ -3975,7 +3978,7 @@</span> <span class="p_context"> __init int intel_pmu_init(void)</span>
 		     x86_pmu.num_counters, INTEL_PMC_MAX_GENERIC);
 		x86_pmu.num_counters = INTEL_PMC_MAX_GENERIC;
 	}
<span class="p_del">-	x86_pmu.intel_ctrl = (1 &lt;&lt; x86_pmu.num_counters) - 1;</span>
<span class="p_add">+	x86_pmu.intel_ctrl = (1ULL &lt;&lt; x86_pmu.num_counters) - 1;</span>
 
 	if (x86_pmu.num_counters_fixed &gt; INTEL_PMC_MAX_FIXED) {
 		WARN(1, KERN_ERR &quot;hw perf events fixed %d &gt; max(%d), clipping!&quot;,
<span class="p_header">diff --git a/arch/x86/events/intel/uncore_snbep.c b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">index 272427700d48..afe8024e9e95 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_chunk">@@ -2686,7 +2686,7 @@</span> <span class="p_context"> static struct intel_uncore_type *hswep_msr_uncores[] = {</span>
 
 void hswep_uncore_cpu_init(void)
 {
<span class="p_del">-	int pkg = topology_phys_to_logical_pkg(0);</span>
<span class="p_add">+	int pkg = boot_cpu_data.logical_proc_id;</span>
 
 	if (hswep_uncore_cbox.num_boxes &gt; boot_cpu_data.x86_max_cores)
 		hswep_uncore_cbox.num_boxes = boot_cpu_data.x86_max_cores;
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_emulate.h b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">index e9cd7befcb76..19d14ac23ef9 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -221,6 +221,9 @@</span> <span class="p_context"> struct x86_emulate_ops {</span>
 	void (*get_cpuid)(struct x86_emulate_ctxt *ctxt,
 			  u32 *eax, u32 *ebx, u32 *ecx, u32 *edx);
 	void (*set_nmi_mask)(struct x86_emulate_ctxt *ctxt, bool masked);
<span class="p_add">+</span>
<span class="p_add">+	unsigned (*get_hflags)(struct x86_emulate_ctxt *ctxt);</span>
<span class="p_add">+	void (*set_hflags)(struct x86_emulate_ctxt *ctxt, unsigned hflags);</span>
 };
 
 typedef u32 __attribute__((vector_size(16))) sse128_t;
<span class="p_chunk">@@ -290,7 +293,6 @@</span> <span class="p_context"> struct x86_emulate_ctxt {</span>
 
 	/* interruptibility state, as a result of execution of STI or MOV SS */
 	int interruptibility;
<span class="p_del">-	int emul_flags;</span>
 
 	bool perm_ok; /* do not check permissions if true */
 	bool ud;	/* inject an #UD if host doesn&#39;t support insn */
<span class="p_header">diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c</span>
<span class="p_header">index eea88fe5d969..6e57edf33d75 100644</span>
<span class="p_header">--- a/arch/x86/kernel/tsc.c</span>
<span class="p_header">+++ b/arch/x86/kernel/tsc.c</span>
<span class="p_chunk">@@ -694,6 +694,7 @@</span> <span class="p_context"> unsigned long native_calibrate_tsc(void)</span>
 			crystal_khz = 24000;	/* 24.0 MHz */
 			break;
 		case INTEL_FAM6_SKYLAKE_X:
<span class="p_add">+		case INTEL_FAM6_ATOM_DENVERTON:</span>
 			crystal_khz = 25000;	/* 25.0 MHz */
 			break;
 		case INTEL_FAM6_ATOM_GOLDMONT:
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 9f676adcdfc2..de36660751b5 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -2543,7 +2543,7 @@</span> <span class="p_context"> static int em_rsm(struct x86_emulate_ctxt *ctxt)</span>
 	u64 smbase;
 	int ret;
 
<span class="p_del">-	if ((ctxt-&gt;emul_flags &amp; X86EMUL_SMM_MASK) == 0)</span>
<span class="p_add">+	if ((ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp; X86EMUL_SMM_MASK) == 0)</span>
 		return emulate_ud(ctxt);
 
 	/*
<span class="p_chunk">@@ -2592,11 +2592,11 @@</span> <span class="p_context"> static int em_rsm(struct x86_emulate_ctxt *ctxt)</span>
 		return X86EMUL_UNHANDLEABLE;
 	}
 
<span class="p_del">-	if ((ctxt-&gt;emul_flags &amp; X86EMUL_SMM_INSIDE_NMI_MASK) == 0)</span>
<span class="p_add">+	if ((ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp; X86EMUL_SMM_INSIDE_NMI_MASK) == 0)</span>
 		ctxt-&gt;ops-&gt;set_nmi_mask(ctxt, false);
 
<span class="p_del">-	ctxt-&gt;emul_flags &amp;= ~X86EMUL_SMM_INSIDE_NMI_MASK;</span>
<span class="p_del">-	ctxt-&gt;emul_flags &amp;= ~X86EMUL_SMM_MASK;</span>
<span class="p_add">+	ctxt-&gt;ops-&gt;set_hflags(ctxt, ctxt-&gt;ops-&gt;get_hflags(ctxt) &amp;</span>
<span class="p_add">+		~(X86EMUL_SMM_INSIDE_NMI_MASK | X86EMUL_SMM_MASK));</span>
 	return X86EMUL_CONTINUE;
 }
 
<span class="p_chunk">@@ -5312,6 +5312,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 	const struct x86_emulate_ops *ops = ctxt-&gt;ops;
 	int rc = X86EMUL_CONTINUE;
 	int saved_dst_type = ctxt-&gt;dst.type;
<span class="p_add">+	unsigned emul_flags;</span>
 
 	ctxt-&gt;mem_read.pos = 0;
 
<span class="p_chunk">@@ -5326,6 +5327,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 		goto done;
 	}
 
<span class="p_add">+	emul_flags = ctxt-&gt;ops-&gt;get_hflags(ctxt);</span>
 	if (unlikely(ctxt-&gt;d &amp;
 		     (No64|Undefined|Sse|Mmx|Intercept|CheckPerm|Priv|Prot|String))) {
 		if ((ctxt-&gt;mode == X86EMUL_MODE_PROT64 &amp;&amp; (ctxt-&gt;d &amp; No64)) ||
<span class="p_chunk">@@ -5359,7 +5361,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 				fetch_possible_mmx_operand(ctxt, &amp;ctxt-&gt;dst);
 		}
 
<span class="p_del">-		if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; ctxt-&gt;intercept) {</span>
<span class="p_add">+		if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; ctxt-&gt;intercept) {</span>
 			rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 						      X86_ICPT_PRE_EXCEPT);
 			if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -5388,7 +5390,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 				goto done;
 		}
 
<span class="p_del">-		if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
<span class="p_add">+		if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
 			rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 						      X86_ICPT_POST_EXCEPT);
 			if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -5442,7 +5444,7 @@</span> <span class="p_context"> int x86_emulate_insn(struct x86_emulate_ctxt *ctxt)</span>
 
 special_insn:
 
<span class="p_del">-	if (unlikely(ctxt-&gt;emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
<span class="p_add">+	if (unlikely(emul_flags &amp; X86EMUL_GUEST_MASK) &amp;&amp; (ctxt-&gt;d &amp; Intercept)) {</span>
 		rc = emulator_check_intercept(ctxt, ctxt-&gt;intercept,
 					      X86_ICPT_POST_MEMACCESS);
 		if (rc != X86EMUL_CONTINUE)
<span class="p_header">diff --git a/arch/x86/kvm/pmu_intel.c b/arch/x86/kvm/pmu_intel.c</span>
<span class="p_header">index 9d4a8504a95a..5ab4a364348e 100644</span>
<span class="p_header">--- a/arch/x86/kvm/pmu_intel.c</span>
<span class="p_header">+++ b/arch/x86/kvm/pmu_intel.c</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> static void intel_pmu_refresh(struct kvm_vcpu *vcpu)</span>
 			((u64)1 &lt;&lt; edx.split.bit_width_fixed) - 1;
 	}
 
<span class="p_del">-	pmu-&gt;global_ctrl = ((1 &lt;&lt; pmu-&gt;nr_arch_gp_counters) - 1) |</span>
<span class="p_add">+	pmu-&gt;global_ctrl = ((1ull &lt;&lt; pmu-&gt;nr_arch_gp_counters) - 1) |</span>
 		(((1ull &lt;&lt; pmu-&gt;nr_arch_fixed_counters) - 1) &lt;&lt; INTEL_PMC_IDX_FIXED);
 	pmu-&gt;global_ctrl_mask = ~pmu-&gt;global_ctrl;
 
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 89b98e07211f..04e6bbbd8736 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -2455,7 +2455,7 @@</span> <span class="p_context"> static int nested_vmx_check_exception(struct kvm_vcpu *vcpu, unsigned nr)</span>
 	if (!(vmcs12-&gt;exception_bitmap &amp; (1u &lt;&lt; nr)))
 		return 0;
 
<span class="p_del">-	nested_vmx_vmexit(vcpu, to_vmx(vcpu)-&gt;exit_reason,</span>
<span class="p_add">+	nested_vmx_vmexit(vcpu, EXIT_REASON_EXCEPTION_NMI,</span>
 			  vmcs_read32(VM_EXIT_INTR_INFO),
 			  vmcs_readl(EXIT_QUALIFICATION));
 	return 1;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 62cde4f67c72..3dbcb09c19cf 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -4999,6 +4999,8 @@</span> <span class="p_context"> static bool emulator_get_segment(struct x86_emulate_ctxt *ctxt, u16 *selector,</span>
 
 	if (var.unusable) {
 		memset(desc, 0, sizeof(*desc));
<span class="p_add">+		if (base3)</span>
<span class="p_add">+			*base3 = 0;</span>
 		return false;
 	}
 
<span class="p_chunk">@@ -5154,6 +5156,16 @@</span> <span class="p_context"> static void emulator_set_nmi_mask(struct x86_emulate_ctxt *ctxt, bool masked)</span>
 	kvm_x86_ops-&gt;set_nmi_mask(emul_to_vcpu(ctxt), masked);
 }
 
<span class="p_add">+static unsigned emulator_get_hflags(struct x86_emulate_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return emul_to_vcpu(ctxt)-&gt;arch.hflags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void emulator_set_hflags(struct x86_emulate_ctxt *ctxt, unsigned emul_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kvm_set_hflags(emul_to_vcpu(ctxt), emul_flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct x86_emulate_ops emulate_ops = {
 	.read_gpr            = emulator_read_gpr,
 	.write_gpr           = emulator_write_gpr,
<span class="p_chunk">@@ -5193,6 +5205,8 @@</span> <span class="p_context"> static const struct x86_emulate_ops emulate_ops = {</span>
 	.intercept           = emulator_intercept,
 	.get_cpuid           = emulator_get_cpuid,
 	.set_nmi_mask        = emulator_set_nmi_mask,
<span class="p_add">+	.get_hflags          = emulator_get_hflags,</span>
<span class="p_add">+	.set_hflags          = emulator_set_hflags,</span>
 };
 
 static void toggle_interruptibility(struct kvm_vcpu *vcpu, u32 mask)
<span class="p_chunk">@@ -5245,7 +5259,6 @@</span> <span class="p_context"> static void init_emulate_ctxt(struct kvm_vcpu *vcpu)</span>
 	BUILD_BUG_ON(HF_GUEST_MASK != X86EMUL_GUEST_MASK);
 	BUILD_BUG_ON(HF_SMM_MASK != X86EMUL_SMM_MASK);
 	BUILD_BUG_ON(HF_SMM_INSIDE_NMI_MASK != X86EMUL_SMM_INSIDE_NMI_MASK);
<span class="p_del">-	ctxt-&gt;emul_flags = vcpu-&gt;arch.hflags;</span>
 
 	init_decode_cache(ctxt);
 	vcpu-&gt;arch.emulate_regs_need_sync_from_vcpu = false;
<span class="p_chunk">@@ -5636,8 +5649,6 @@</span> <span class="p_context"> int x86_emulate_instruction(struct kvm_vcpu *vcpu,</span>
 		unsigned long rflags = kvm_x86_ops-&gt;get_rflags(vcpu);
 		toggle_interruptibility(vcpu, ctxt-&gt;interruptibility);
 		vcpu-&gt;arch.emulate_regs_need_sync_to_vcpu = false;
<span class="p_del">-		if (vcpu-&gt;arch.hflags != ctxt-&gt;emul_flags)</span>
<span class="p_del">-			kvm_set_hflags(vcpu, ctxt-&gt;emul_flags);</span>
 		kvm_rip_write(vcpu, ctxt-&gt;eip);
 		if (r == EMULATE_DONE)
 			kvm_vcpu_check_singlestep(vcpu, rflags, &amp;r);
<span class="p_chunk">@@ -6111,7 +6122,8 @@</span> <span class="p_context"> static int emulator_fix_hypercall(struct x86_emulate_ctxt *ctxt)</span>
 
 	kvm_x86_ops-&gt;patch_hypercall(vcpu, instruction);
 
<span class="p_del">-	return emulator_write_emulated(ctxt, rip, instruction, 3, NULL);</span>
<span class="p_add">+	return emulator_write_emulated(ctxt, rip, instruction, 3,</span>
<span class="p_add">+		&amp;ctxt-&gt;exception);</span>
 }
 
 static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)
<span class="p_header">diff --git a/arch/x86/mm/init_64.c b/arch/x86/mm/init_64.c</span>
<span class="p_header">index 14b9dd71d9e8..9a324fc8bed8 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_64.c</span>
<span class="p_chunk">@@ -94,10 +94,10 @@</span> <span class="p_context"> __setup(&quot;noexec32=&quot;, nonx32_setup);</span>
  */
 void sync_global_pgds(unsigned long start, unsigned long end, int removed)
 {
<span class="p_del">-	unsigned long address;</span>
<span class="p_add">+	unsigned long addr;</span>
 
<span class="p_del">-	for (address = start; address &lt;= end; address += PGDIR_SIZE) {</span>
<span class="p_del">-		const pgd_t *pgd_ref = pgd_offset_k(address);</span>
<span class="p_add">+	for (addr = start; addr &lt;= end; addr = ALIGN(addr + 1, PGDIR_SIZE)) {</span>
<span class="p_add">+		const pgd_t *pgd_ref = pgd_offset_k(addr);</span>
 		struct page *page;
 
 		/*
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> void sync_global_pgds(unsigned long start, unsigned long end, int removed)</span>
 			pgd_t *pgd;
 			spinlock_t *pgt_lock;
 
<span class="p_del">-			pgd = (pgd_t *)page_address(page) + pgd_index(address);</span>
<span class="p_add">+			pgd = (pgd_t *)page_address(page) + pgd_index(addr);</span>
 			/* the pgt_lock only for Xen */
 			pgt_lock = &amp;pgd_page_get_mm(page)-&gt;page_table_lock;
 			spin_lock(pgt_lock);
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index e4f800999b32..a75103e7f963 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> siginfo_t *mpx_generate_siginfo(struct pt_regs *regs)</span>
 	 * We were not able to extract an address from the instruction,
 	 * probably because there was something invalid in it.
 	 */
<span class="p_del">-	if (info-&gt;si_addr == (void *)-1) {</span>
<span class="p_add">+	if (info-&gt;si_addr == (void __user *)-1) {</span>
 		err = -EINVAL;
 		goto err_out;
 	}
<span class="p_chunk">@@ -525,15 +525,7 @@</span> <span class="p_context"> int mpx_handle_bd_fault(void)</span>
 	if (!kernel_managing_mpx_tables(current-&gt;mm))
 		return -EINVAL;
 
<span class="p_del">-	if (do_mpx_bt_fault()) {</span>
<span class="p_del">-		force_sig(SIGSEGV, current);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The force_sig() is essentially &quot;handling&quot; this</span>
<span class="p_del">-		 * exception, so we do not pass up the error</span>
<span class="p_del">-		 * from do_mpx_bt_fault().</span>
<span class="p_del">-		 */</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return do_mpx_bt_fault();</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index a7655f6caf7d..75fb01109f94 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -263,8 +263,6 @@</span> <span class="p_context"> void native_flush_tlb_others(const struct cpumask *cpumask,</span>
 {
 	struct flush_tlb_info info;
 
<span class="p_del">-	if (end == 0)</span>
<span class="p_del">-		end = start + PAGE_SIZE;</span>
 	info.flush_mm = mm;
 	info.flush_start = start;
 	info.flush_end = end;
<span class="p_chunk">@@ -393,7 +391,7 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, start, 0UL);</span>
<span class="p_add">+		flush_tlb_others(mm_cpumask(mm), mm, start, start + PAGE_SIZE);</span>
 
 	preempt_enable();
 }
<span class="p_header">diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">index c42202d63567..d6eaaa25d1cc 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_chunk">@@ -609,8 +609,6 @@</span> <span class="p_context"> int xen_blkif_schedule(void *arg)</span>
 	unsigned long timeout;
 	int ret;
 
<span class="p_del">-	xen_blkif_get(blkif);</span>
<span class="p_del">-</span>
 	set_freezable();
 	while (!kthread_should_stop()) {
 		if (try_to_freeze())
<span class="p_chunk">@@ -665,7 +663,6 @@</span> <span class="p_context"> int xen_blkif_schedule(void *arg)</span>
 		print_stats(ring);
 
 	ring-&gt;xenblkd = NULL;
<span class="p_del">-	xen_blkif_put(blkif);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/block/xen-blkback/xenbus.c b/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_header">index 9b69fe410c08..5dfe6e8af140 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_chunk">@@ -255,7 +255,6 @@</span> <span class="p_context"> static int xen_blkif_disconnect(struct xen_blkif *blkif)</span>
 		if (ring-&gt;xenblkd) {
 			kthread_stop(ring-&gt;xenblkd);
 			wake_up(&amp;ring-&gt;shutdown_wq);
<span class="p_del">-			ring-&gt;xenblkd = NULL;</span>
 		}
 
 		/* The above kthread_stop() guarantees that at this point we
<span class="p_chunk">@@ -316,8 +315,10 @@</span> <span class="p_context"> static int xen_blkif_disconnect(struct xen_blkif *blkif)</span>
 static void xen_blkif_free(struct xen_blkif *blkif)
 {
 
<span class="p_del">-	xen_blkif_disconnect(blkif);</span>
<span class="p_add">+	WARN_ON(xen_blkif_disconnect(blkif));</span>
 	xen_vbd_free(&amp;blkif-&gt;vbd);
<span class="p_add">+	kfree(blkif-&gt;be-&gt;mode);</span>
<span class="p_add">+	kfree(blkif-&gt;be);</span>
 
 	/* Make sure everything is drained before shutting down */
 	kmem_cache_free(xen_blkif_cachep, blkif);
<span class="p_chunk">@@ -512,8 +513,6 @@</span> <span class="p_context"> static int xen_blkbk_remove(struct xenbus_device *dev)</span>
 
 	/* Put the reference we set in xen_blkif_alloc(). */
 	xen_blkif_put(be-&gt;blkif);
<span class="p_del">-	kfree(be-&gt;mode);</span>
<span class="p_del">-	kfree(be);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index 471a301d63e3..8f890c1aca57 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -1870,7 +1870,7 @@</span> <span class="p_context"> static void config_work_handler(struct work_struct *work)</span>
 {
 	struct ports_device *portdev;
 
<span class="p_del">-	portdev = container_of(work, struct ports_device, control_work);</span>
<span class="p_add">+	portdev = container_of(work, struct ports_device, config_work);</span>
 	if (!use_multiport(portdev)) {
 		struct virtio_device *vdev;
 		struct port *port;
<span class="p_header">diff --git a/drivers/clk/clk-scpi.c b/drivers/clk/clk-scpi.c</span>
<span class="p_header">index 2a3e9d8e88b0..96d37175d0ad 100644</span>
<span class="p_header">--- a/drivers/clk/clk-scpi.c</span>
<span class="p_header">+++ b/drivers/clk/clk-scpi.c</span>
<span class="p_chunk">@@ -290,13 +290,15 @@</span> <span class="p_context"> static int scpi_clocks_probe(struct platform_device *pdev)</span>
 			of_node_put(child);
 			return ret;
 		}
<span class="p_del">-	}</span>
<span class="p_del">-	/* Add the virtual cpufreq device */</span>
<span class="p_del">-	cpufreq_dev = platform_device_register_simple(&quot;scpi-cpufreq&quot;,</span>
<span class="p_del">-						      -1, NULL, 0);</span>
<span class="p_del">-	if (IS_ERR(cpufreq_dev))</span>
<span class="p_del">-		pr_warn(&quot;unable to register cpufreq device&quot;);</span>
 
<span class="p_add">+		if (match-&gt;data != &amp;scpi_dvfs_ops)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		/* Add the virtual cpufreq device if it&#39;s DVFS clock provider */</span>
<span class="p_add">+		cpufreq_dev = platform_device_register_simple(&quot;scpi-cpufreq&quot;,</span>
<span class="p_add">+							      -1, NULL, 0);</span>
<span class="p_add">+		if (IS_ERR(cpufreq_dev))</span>
<span class="p_add">+			pr_warn(&quot;unable to register cpufreq device&quot;);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/cpufreq/s3c2416-cpufreq.c b/drivers/cpufreq/s3c2416-cpufreq.c</span>
<span class="p_header">index d6d425773fa4..5b2db3c6568f 100644</span>
<span class="p_header">--- a/drivers/cpufreq/s3c2416-cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/s3c2416-cpufreq.c</span>
<span class="p_chunk">@@ -400,7 +400,6 @@</span> <span class="p_context"> static int s3c2416_cpufreq_driver_init(struct cpufreq_policy *policy)</span>
 	rate = clk_get_rate(s3c_freq-&gt;hclk);
 	if (rate &lt; 133 * 1000 * 1000) {
 		pr_err(&quot;cpufreq: HCLK not at 133MHz\n&quot;);
<span class="p_del">-		clk_put(s3c_freq-&gt;hclk);</span>
 		ret = -EINVAL;
 		goto err_armclk;
 	}
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index 92159313361b..f2bb5122d2c2 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -707,7 +707,8 @@</span> <span class="p_context"> static irqreturn_t lineevent_irq_thread(int irq, void *p)</span>
 
 	ge.timestamp = ktime_get_real_ns();
 
<span class="p_del">-	if (le-&gt;eflags &amp; GPIOEVENT_REQUEST_BOTH_EDGES) {</span>
<span class="p_add">+	if (le-&gt;eflags &amp; GPIOEVENT_REQUEST_RISING_EDGE</span>
<span class="p_add">+	    &amp;&amp; le-&gt;eflags &amp; GPIOEVENT_REQUEST_FALLING_EDGE) {</span>
 		int level = gpiod_get_value_cansleep(le-&gt;desc);
 
 		if (level)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c</span>
<span class="p_header">index 82dc8d20e28a..bfb4b91869e7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_cs.c</span>
<span class="p_chunk">@@ -83,6 +83,13 @@</span> <span class="p_context"> int amdgpu_cs_get_ring(struct amdgpu_device *adev, u32 ip_type,</span>
 		}
 		break;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!(*out_ring &amp;&amp; (*out_ring)-&gt;adev)) {</span>
<span class="p_add">+		DRM_ERROR(&quot;Ring %d is not initialized on IP %d\n&quot;,</span>
<span class="p_add">+			  ring, ip_type);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/si_dpm.c b/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_header">index 6f3c89178b6a..4cb347e88cf0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/si_dpm.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> MODULE_FIRMWARE(&quot;radeon/oland_smc.bin&quot;);</span>
 MODULE_FIRMWARE(&quot;radeon/oland_k_smc.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/hainan_smc.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/hainan_k_smc.bin&quot;);
<span class="p_add">+MODULE_FIRMWARE(&quot;radeon/banks_k_2_smc.bin&quot;);</span>
 
 union power_info {
 	struct _ATOM_POWERPLAY_INFO info;
<span class="p_chunk">@@ -7721,10 +7722,11 @@</span> <span class="p_context"> static int si_dpm_init_microcode(struct amdgpu_device *adev)</span>
 			((adev-&gt;pdev-&gt;device == 0x6660) ||
 			(adev-&gt;pdev-&gt;device == 0x6663) ||
 			(adev-&gt;pdev-&gt;device == 0x6665) ||
<span class="p_del">-			(adev-&gt;pdev-&gt;device == 0x6667))) ||</span>
<span class="p_del">-		    ((adev-&gt;pdev-&gt;revision == 0xc3) &amp;&amp;</span>
<span class="p_del">-			(adev-&gt;pdev-&gt;device == 0x6665)))</span>
<span class="p_add">+			 (adev-&gt;pdev-&gt;device == 0x6667))))</span>
 			chip_name = &quot;hainan_k&quot;;
<span class="p_add">+		else if ((adev-&gt;pdev-&gt;revision == 0xc3) &amp;&amp;</span>
<span class="p_add">+			 (adev-&gt;pdev-&gt;device == 0x6665))</span>
<span class="p_add">+			chip_name = &quot;banks_k_2&quot;;</span>
 		else
 			chip_name = &quot;hainan&quot;;
 		break;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c</span>
<span class="p_header">index 6feed726e299..50f0cf2788b7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/vce_v3_0.c</span>
<span class="p_chunk">@@ -43,9 +43,13 @@</span> <span class="p_context"></span>
 
 #define GRBM_GFX_INDEX__VCE_INSTANCE__SHIFT	0x04
 #define GRBM_GFX_INDEX__VCE_INSTANCE_MASK	0x10
<span class="p_add">+#define GRBM_GFX_INDEX__VCE_ALL_PIPE		0x07</span>
<span class="p_add">+</span>
 #define mmVCE_LMI_VCPU_CACHE_40BIT_BAR0	0x8616
 #define mmVCE_LMI_VCPU_CACHE_40BIT_BAR1	0x8617
 #define mmVCE_LMI_VCPU_CACHE_40BIT_BAR2	0x8618
<span class="p_add">+#define mmGRBM_GFX_INDEX_DEFAULT 0xE0000000</span>
<span class="p_add">+</span>
 #define VCE_STATUS_VCPU_REPORT_FW_LOADED_MASK	0x02
 
 #define VCE_V3_0_FW_SIZE	(384 * 1024)
<span class="p_chunk">@@ -54,6 +58,9 @@</span> <span class="p_context"></span>
 
 #define FW_52_8_3	((52 &lt;&lt; 24) | (8 &lt;&lt; 16) | (3 &lt;&lt; 8))
 
<span class="p_add">+#define GET_VCE_INSTANCE(i)  ((i) &lt;&lt; GRBM_GFX_INDEX__VCE_INSTANCE__SHIFT \</span>
<span class="p_add">+					| GRBM_GFX_INDEX__VCE_ALL_PIPE)</span>
<span class="p_add">+</span>
 static void vce_v3_0_mc_resume(struct amdgpu_device *adev, int idx);
 static void vce_v3_0_set_ring_funcs(struct amdgpu_device *adev);
 static void vce_v3_0_set_irq_funcs(struct amdgpu_device *adev);
<span class="p_chunk">@@ -249,7 +256,7 @@</span> <span class="p_context"> static int vce_v3_0_start(struct amdgpu_device *adev)</span>
 		if (adev-&gt;vce.harvest_config &amp; (1 &lt;&lt; idx))
 			continue;
 
<span class="p_del">-		WREG32_FIELD(GRBM_GFX_INDEX, VCE_INSTANCE, idx);</span>
<span class="p_add">+		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(idx));</span>
 		vce_v3_0_mc_resume(adev, idx);
 		WREG32_FIELD(VCE_STATUS, JOB_BUSY, 1);
 
<span class="p_chunk">@@ -273,7 +280,7 @@</span> <span class="p_context"> static int vce_v3_0_start(struct amdgpu_device *adev)</span>
 		}
 	}
 
<span class="p_del">-	WREG32_FIELD(GRBM_GFX_INDEX, VCE_INSTANCE, 0);</span>
<span class="p_add">+	WREG32(mmGRBM_GFX_INDEX, mmGRBM_GFX_INDEX_DEFAULT);</span>
 	mutex_unlock(&amp;adev-&gt;grbm_idx_mutex);
 
 	return 0;
<span class="p_chunk">@@ -288,7 +295,7 @@</span> <span class="p_context"> static int vce_v3_0_stop(struct amdgpu_device *adev)</span>
 		if (adev-&gt;vce.harvest_config &amp; (1 &lt;&lt; idx))
 			continue;
 
<span class="p_del">-		WREG32_FIELD(GRBM_GFX_INDEX, VCE_INSTANCE, idx);</span>
<span class="p_add">+		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(idx));</span>
 
 		if (adev-&gt;asic_type &gt;= CHIP_STONEY)
 			WREG32_P(mmVCE_VCPU_CNTL, 0, ~0x200001);
<span class="p_chunk">@@ -306,7 +313,7 @@</span> <span class="p_context"> static int vce_v3_0_stop(struct amdgpu_device *adev)</span>
 			vce_v3_0_set_vce_sw_clock_gating(adev, false);
 	}
 
<span class="p_del">-	WREG32_FIELD(GRBM_GFX_INDEX, VCE_INSTANCE, 0);</span>
<span class="p_add">+	WREG32(mmGRBM_GFX_INDEX, mmGRBM_GFX_INDEX_DEFAULT);</span>
 	mutex_unlock(&amp;adev-&gt;grbm_idx_mutex);
 
 	return 0;
<span class="p_chunk">@@ -586,17 +593,17 @@</span> <span class="p_context"> static bool vce_v3_0_check_soft_reset(void *handle)</span>
 	 * VCE team suggest use bit 3--bit 6 for busy status check
 	 */
 	mutex_lock(&amp;adev-&gt;grbm_idx_mutex);
<span class="p_del">-	WREG32_FIELD(GRBM_GFX_INDEX, INSTANCE_INDEX, 0);</span>
<span class="p_add">+	WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(0));</span>
 	if (RREG32(mmVCE_STATUS) &amp; AMDGPU_VCE_STATUS_BUSY_MASK) {
 		srbm_soft_reset = REG_SET_FIELD(srbm_soft_reset, SRBM_SOFT_RESET, SOFT_RESET_VCE0, 1);
 		srbm_soft_reset = REG_SET_FIELD(srbm_soft_reset, SRBM_SOFT_RESET, SOFT_RESET_VCE1, 1);
 	}
<span class="p_del">-	WREG32_FIELD(GRBM_GFX_INDEX, INSTANCE_INDEX, 0x10);</span>
<span class="p_add">+	WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(1));</span>
 	if (RREG32(mmVCE_STATUS) &amp; AMDGPU_VCE_STATUS_BUSY_MASK) {
 		srbm_soft_reset = REG_SET_FIELD(srbm_soft_reset, SRBM_SOFT_RESET, SOFT_RESET_VCE0, 1);
 		srbm_soft_reset = REG_SET_FIELD(srbm_soft_reset, SRBM_SOFT_RESET, SOFT_RESET_VCE1, 1);
 	}
<span class="p_del">-	WREG32_FIELD(GRBM_GFX_INDEX, INSTANCE_INDEX, 0);</span>
<span class="p_add">+	WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(0));</span>
 	mutex_unlock(&amp;adev-&gt;grbm_idx_mutex);
 
 	if (srbm_soft_reset) {
<span class="p_chunk">@@ -734,7 +741,7 @@</span> <span class="p_context"> static int vce_v3_0_set_clockgating_state(void *handle,</span>
 		if (adev-&gt;vce.harvest_config &amp; (1 &lt;&lt; i))
 			continue;
 
<span class="p_del">-		WREG32_FIELD(GRBM_GFX_INDEX, VCE_INSTANCE, i);</span>
<span class="p_add">+		WREG32(mmGRBM_GFX_INDEX, GET_VCE_INSTANCE(i));</span>
 
 		if (enable) {
 			/* initialize VCE_CLOCK_GATING_A: Clock ON/OFF delay */
<span class="p_chunk">@@ -753,7 +760,7 @@</span> <span class="p_context"> static int vce_v3_0_set_clockgating_state(void *handle,</span>
 		vce_v3_0_set_vce_sw_clock_gating(adev, enable);
 	}
 
<span class="p_del">-	WREG32_FIELD(GRBM_GFX_INDEX, VCE_INSTANCE, 0);</span>
<span class="p_add">+	WREG32(mmGRBM_GFX_INDEX, mmGRBM_GFX_INDEX_DEFAULT);</span>
 	mutex_unlock(&amp;adev-&gt;grbm_idx_mutex);
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/cz_clockpowergating.c b/drivers/gpu/drm/amd/powerplay/hwmgr/cz_clockpowergating.c</span>
<span class="p_header">index 2028980f1ed4..5b261c1dcc9f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/hwmgr/cz_clockpowergating.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/cz_clockpowergating.c</span>
<span class="p_chunk">@@ -200,7 +200,7 @@</span> <span class="p_context"> int cz_dpm_powergate_vce(struct pp_hwmgr *hwmgr, bool bgate)</span>
 				cgs_set_clockgating_state(
 							hwmgr-&gt;device,
 							AMD_IP_BLOCK_TYPE_VCE,
<span class="p_del">-							AMD_CG_STATE_UNGATE);</span>
<span class="p_add">+							AMD_CG_STATE_GATE);</span>
 				cgs_set_powergating_state(
 							hwmgr-&gt;device,
 							AMD_IP_BLOCK_TYPE_VCE,
<span class="p_chunk">@@ -218,7 +218,7 @@</span> <span class="p_context"> int cz_dpm_powergate_vce(struct pp_hwmgr *hwmgr, bool bgate)</span>
 				cgs_set_clockgating_state(
 							hwmgr-&gt;device,
 							AMD_IP_BLOCK_TYPE_VCE,
<span class="p_del">-							AMD_PG_STATE_GATE);</span>
<span class="p_add">+							AMD_PG_STATE_UNGATE);</span>
 				cz_dpm_update_vce_dpm(hwmgr);
 				cz_enable_disable_vce_dpm(hwmgr, true);
 				return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/hwmgr/cz_hwmgr.c b/drivers/gpu/drm/amd/powerplay/hwmgr/cz_hwmgr.c</span>
<span class="p_header">index 960424913496..189ec94c6ff9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/hwmgr/cz_hwmgr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/hwmgr/cz_hwmgr.c</span>
<span class="p_chunk">@@ -1402,14 +1402,22 @@</span> <span class="p_context"> int  cz_dpm_update_vce_dpm(struct pp_hwmgr *hwmgr)</span>
 					     cz_hwmgr-&gt;vce_dpm.hard_min_clk,
 						PPSMC_MSG_SetEclkHardMin));
 	} else {
<span class="p_del">-		/*EPR# 419220 -HW limitation to to */</span>
<span class="p_del">-		cz_hwmgr-&gt;vce_dpm.hard_min_clk = hwmgr-&gt;vce_arbiter.ecclk;</span>
<span class="p_del">-		smum_send_msg_to_smc_with_parameter(hwmgr-&gt;smumgr,</span>
<span class="p_del">-					    PPSMC_MSG_SetEclkHardMin,</span>
<span class="p_del">-					    cz_get_eclk_level(hwmgr,</span>
<span class="p_del">-				     cz_hwmgr-&gt;vce_dpm.hard_min_clk,</span>
<span class="p_del">-					  PPSMC_MSG_SetEclkHardMin));</span>
<span class="p_del">-</span>
<span class="p_add">+		/*Program HardMin based on the vce_arbiter.ecclk */</span>
<span class="p_add">+		if (hwmgr-&gt;vce_arbiter.ecclk == 0) {</span>
<span class="p_add">+			smum_send_msg_to_smc_with_parameter(hwmgr-&gt;smumgr,</span>
<span class="p_add">+					    PPSMC_MSG_SetEclkHardMin, 0);</span>
<span class="p_add">+		/* disable ECLK DPM 0. Otherwise VCE could hang if</span>
<span class="p_add">+		 * switching SCLK from DPM 0 to 6/7 */</span>
<span class="p_add">+			smum_send_msg_to_smc_with_parameter(hwmgr-&gt;smumgr,</span>
<span class="p_add">+					PPSMC_MSG_SetEclkSoftMin, 1);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			cz_hwmgr-&gt;vce_dpm.hard_min_clk = hwmgr-&gt;vce_arbiter.ecclk;</span>
<span class="p_add">+			smum_send_msg_to_smc_with_parameter(hwmgr-&gt;smumgr,</span>
<span class="p_add">+						PPSMC_MSG_SetEclkHardMin,</span>
<span class="p_add">+						cz_get_eclk_level(hwmgr,</span>
<span class="p_add">+						cz_hwmgr-&gt;vce_dpm.hard_min_clk,</span>
<span class="p_add">+						PPSMC_MSG_SetEclkHardMin));</span>
<span class="p_add">+		}</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_drv.h b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">index 7abda94fc2cf..3bedcf7ddd2a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_drv.h</span>
<span class="p_chunk">@@ -113,7 +113,11 @@</span> <span class="p_context"> struct ast_private {</span>
 	struct ttm_bo_kmap_obj cache_kmap;
 	int next_cursor;
 	bool support_wide_screen;
<span class="p_del">-	bool DisableP2A;</span>
<span class="p_add">+	enum {</span>
<span class="p_add">+		ast_use_p2a,</span>
<span class="p_add">+		ast_use_dt,</span>
<span class="p_add">+		ast_use_defaults</span>
<span class="p_add">+	} config_mode;</span>
 
 	enum ast_tx_chip tx_chip_type;
 	u8 dp501_maxclk;
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_main.c b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">index 533e762d036d..fb9976254224 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_main.c</span>
<span class="p_chunk">@@ -62,13 +62,84 @@</span> <span class="p_context"> uint8_t ast_get_index_reg_mask(struct ast_private *ast,</span>
 	return ret;
 }
 
<span class="p_add">+static void ast_detect_config_mode(struct drm_device *dev, u32 *scu_rev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np = dev-&gt;pdev-&gt;dev.of_node;</span>
<span class="p_add">+	struct ast_private *ast = dev-&gt;dev_private;</span>
<span class="p_add">+	uint32_t data, jregd0, jregd1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Defaults */</span>
<span class="p_add">+	ast-&gt;config_mode = ast_use_defaults;</span>
<span class="p_add">+	*scu_rev = 0xffffffff;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check if we have device-tree properties */</span>
<span class="p_add">+	if (np &amp;&amp; !of_property_read_u32(np, &quot;aspeed,scu-revision-id&quot;,</span>
<span class="p_add">+					scu_rev)) {</span>
<span class="p_add">+		/* We do, disable P2A access */</span>
<span class="p_add">+		ast-&gt;config_mode = ast_use_dt;</span>
<span class="p_add">+		DRM_INFO(&quot;Using device-tree for configuration\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Not all families have a P2A bridge */</span>
<span class="p_add">+	if (dev-&gt;pdev-&gt;device != PCI_CHIP_AST2000)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The BMC will set SCU 0x40 D[12] to 1 if the P2 bridge</span>
<span class="p_add">+	 * is disabled. We force using P2A if VGA only mode bit</span>
<span class="p_add">+	 * is set D[7]</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	jregd0 = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd0, 0xff);</span>
<span class="p_add">+	jregd1 = ast_get_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xd1, 0xff);</span>
<span class="p_add">+	if (!(jregd0 &amp; 0x80) || !(jregd1 &amp; 0x10)) {</span>
<span class="p_add">+		/* Double check it&#39;s actually working */</span>
<span class="p_add">+		data = ast_read32(ast, 0xf004);</span>
<span class="p_add">+		if (data != 0xFFFFFFFF) {</span>
<span class="p_add">+			/* P2A works, grab silicon revision */</span>
<span class="p_add">+			ast-&gt;config_mode = ast_use_p2a;</span>
<span class="p_add">+</span>
<span class="p_add">+			DRM_INFO(&quot;Using P2A bridge for configuration\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Read SCU7c (silicon revision register) */</span>
<span class="p_add">+			ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_add">+			ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_add">+			*scu_rev = ast_read32(ast, 0x1207c);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We have a P2A bridge but it&#39;s disabled */</span>
<span class="p_add">+	DRM_INFO(&quot;P2A bridge disabled, using default configuration\n&quot;);</span>
<span class="p_add">+}</span>
 
 static int ast_detect_chip(struct drm_device *dev, bool *need_post)
 {
 	struct ast_private *ast = dev-&gt;dev_private;
<span class="p_del">-	uint32_t data, jreg;</span>
<span class="p_add">+	uint32_t jreg, scu_rev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If VGA isn&#39;t enabled, we need to enable now or subsequent</span>
<span class="p_add">+	 * access to the scratch registers will fail. We also inform</span>
<span class="p_add">+	 * our caller that it needs to POST the chip</span>
<span class="p_add">+	 * (Assumption: VGA not enabled -&gt; need to POST)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ast_is_vga_enabled(dev)) {</span>
<span class="p_add">+		ast_enable_vga(dev);</span>
<span class="p_add">+		DRM_INFO(&quot;VGA not enabled on entry, requesting chip POST\n&quot;);</span>
<span class="p_add">+		*need_post = true;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		*need_post = false;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable extended register access */</span>
<span class="p_add">+	ast_enable_mmio(dev);</span>
 	ast_open_key(ast);
 
<span class="p_add">+	/* Find out whether P2A works or whether to use device-tree */</span>
<span class="p_add">+	ast_detect_config_mode(dev, &amp;scu_rev);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Identify chipset */</span>
 	if (dev-&gt;pdev-&gt;device == PCI_CHIP_AST1180) {
 		ast-&gt;chip = AST1100;
 		DRM_INFO(&quot;AST 1180 detected\n&quot;);
<span class="p_chunk">@@ -80,12 +151,7 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 			ast-&gt;chip = AST2300;
 			DRM_INFO(&quot;AST 2300 detected\n&quot;);
 		} else if (dev-&gt;pdev-&gt;revision &gt;= 0x10) {
<span class="p_del">-			uint32_t data;</span>
<span class="p_del">-			ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_del">-			ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_del">-</span>
<span class="p_del">-			data = ast_read32(ast, 0x1207c);</span>
<span class="p_del">-			switch (data &amp; 0x0300) {</span>
<span class="p_add">+			switch (scu_rev &amp; 0x0300) {</span>
 			case 0x0200:
 				ast-&gt;chip = AST1100;
 				DRM_INFO(&quot;AST 1100 detected\n&quot;);
<span class="p_chunk">@@ -110,26 +176,6 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 		}
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If VGA isn&#39;t enabled, we need to enable now or subsequent</span>
<span class="p_del">-	 * access to the scratch registers will fail. We also inform</span>
<span class="p_del">-	 * our caller that it needs to POST the chip</span>
<span class="p_del">-	 * (Assumption: VGA not enabled -&gt; need to POST)</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!ast_is_vga_enabled(dev)) {</span>
<span class="p_del">-		ast_enable_vga(dev);</span>
<span class="p_del">-		ast_enable_mmio(dev);</span>
<span class="p_del">-		DRM_INFO(&quot;VGA not enabled on entry, requesting chip POST\n&quot;);</span>
<span class="p_del">-		*need_post = true;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		*need_post = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Check P2A Access */</span>
<span class="p_del">-	ast-&gt;DisableP2A = true;</span>
<span class="p_del">-	data = ast_read32(ast, 0xf004);</span>
<span class="p_del">-	if (data != 0xFFFFFFFF)</span>
<span class="p_del">-		ast-&gt;DisableP2A = false;</span>
<span class="p_del">-</span>
 	/* Check if we support wide screen */
 	switch (ast-&gt;chip) {
 	case AST1180:
<span class="p_chunk">@@ -146,17 +192,12 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 			ast-&gt;support_wide_screen = true;
 		else {
 			ast-&gt;support_wide_screen = false;
<span class="p_del">-			if (ast-&gt;DisableP2A == false) {</span>
<span class="p_del">-				/* Read SCU7c (silicon revision register) */</span>
<span class="p_del">-				ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_del">-				ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_del">-				data = ast_read32(ast, 0x1207c);</span>
<span class="p_del">-				data &amp;= 0x300;</span>
<span class="p_del">-				if (ast-&gt;chip == AST2300 &amp;&amp; data == 0x0) /* ast1300 */</span>
<span class="p_del">-					ast-&gt;support_wide_screen = true;</span>
<span class="p_del">-				if (ast-&gt;chip == AST2400 &amp;&amp; data == 0x100) /* ast1400 */</span>
<span class="p_del">-					ast-&gt;support_wide_screen = true;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			if (ast-&gt;chip == AST2300 &amp;&amp;</span>
<span class="p_add">+			    (scu_rev &amp; 0x300) == 0x0) /* ast1300 */</span>
<span class="p_add">+				ast-&gt;support_wide_screen = true;</span>
<span class="p_add">+			if (ast-&gt;chip == AST2400 &amp;&amp;</span>
<span class="p_add">+			    (scu_rev &amp; 0x300) == 0x100) /* ast1400 */</span>
<span class="p_add">+				ast-&gt;support_wide_screen = true;</span>
 		}
 		break;
 	}
<span class="p_chunk">@@ -220,85 +261,102 @@</span> <span class="p_context"> static int ast_detect_chip(struct drm_device *dev, bool *need_post)</span>
 
 static int ast_get_dram_info(struct drm_device *dev)
 {
<span class="p_add">+	struct device_node *np = dev-&gt;pdev-&gt;dev.of_node;</span>
 	struct ast_private *ast = dev-&gt;dev_private;
<span class="p_del">-	uint32_t data, data2;</span>
<span class="p_del">-	uint32_t denum, num, div, ref_pll;</span>
<span class="p_add">+	uint32_t mcr_cfg, mcr_scu_mpll, mcr_scu_strap;</span>
<span class="p_add">+	uint32_t denum, num, div, ref_pll, dsel;</span>
 
<span class="p_del">-	if (ast-&gt;DisableP2A)</span>
<span class="p_del">-	{</span>
<span class="p_add">+	switch (ast-&gt;config_mode) {</span>
<span class="p_add">+	case ast_use_dt:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If some properties are missing, use reasonable</span>
<span class="p_add">+		 * defaults for AST2400</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;aspeed,mcr-configuration&quot;,</span>
<span class="p_add">+					 &amp;mcr_cfg))</span>
<span class="p_add">+			mcr_cfg = 0x00000577;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;aspeed,mcr-scu-mpll&quot;,</span>
<span class="p_add">+					 &amp;mcr_scu_mpll))</span>
<span class="p_add">+			mcr_scu_mpll = 0x000050C0;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;aspeed,mcr-scu-strap&quot;,</span>
<span class="p_add">+					 &amp;mcr_scu_strap))</span>
<span class="p_add">+			mcr_scu_strap = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case ast_use_p2a:</span>
<span class="p_add">+		ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_add">+		ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_add">+		mcr_cfg = ast_read32(ast, 0x10004);</span>
<span class="p_add">+		mcr_scu_mpll = ast_read32(ast, 0x10120);</span>
<span class="p_add">+		mcr_scu_strap = ast_read32(ast, 0x10170);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case ast_use_defaults:</span>
<span class="p_add">+	default:</span>
 		ast-&gt;dram_bus_width = 16;
 		ast-&gt;dram_type = AST_DRAM_1Gx16;
 		ast-&gt;mclk = 396;
<span class="p_add">+		return 0;</span>
 	}
<span class="p_del">-	else</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ast_write32(ast, 0xf004, 0x1e6e0000);</span>
<span class="p_del">-		ast_write32(ast, 0xf000, 0x1);</span>
<span class="p_del">-		data = ast_read32(ast, 0x10004);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (data &amp; 0x40)</span>
<span class="p_del">-			ast-&gt;dram_bus_width = 16;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ast-&gt;dram_bus_width = 32;</span>
 
<span class="p_del">-		if (ast-&gt;chip == AST2300 || ast-&gt;chip == AST2400) {</span>
<span class="p_del">-			switch (data &amp; 0x03) {</span>
<span class="p_del">-			case 0:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			default:</span>
<span class="p_del">-			case 1:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 2:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_2Gx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 3:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_4Gx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			switch (data &amp; 0x0c) {</span>
<span class="p_del">-			case 0:</span>
<span class="p_del">-			case 4:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 8:</span>
<span class="p_del">-				if (data &amp; 0x40)</span>
<span class="p_del">-					ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
<span class="p_del">-				else</span>
<span class="p_del">-					ast-&gt;dram_type = AST_DRAM_512Mx32;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 0xc:</span>
<span class="p_del">-				ast-&gt;dram_type = AST_DRAM_1Gx32;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (mcr_cfg &amp; 0x40)</span>
<span class="p_add">+		ast-&gt;dram_bus_width = 16;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ast-&gt;dram_bus_width = 32;</span>
 
<span class="p_del">-		data = ast_read32(ast, 0x10120);</span>
<span class="p_del">-		data2 = ast_read32(ast, 0x10170);</span>
<span class="p_del">-		if (data2 &amp; 0x2000)</span>
<span class="p_del">-			ref_pll = 14318;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ref_pll = 12000;</span>
<span class="p_del">-</span>
<span class="p_del">-		denum = data &amp; 0x1f;</span>
<span class="p_del">-		num = (data &amp; 0x3fe0) &gt;&gt; 5;</span>
<span class="p_del">-		data = (data &amp; 0xc000) &gt;&gt; 14;</span>
<span class="p_del">-		switch (data) {</span>
<span class="p_del">-		case 3:</span>
<span class="p_del">-			div = 0x4;</span>
<span class="p_add">+	if (ast-&gt;chip == AST2300 || ast-&gt;chip == AST2400) {</span>
<span class="p_add">+		switch (mcr_cfg &amp; 0x03) {</span>
<span class="p_add">+		case 0:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
 			break;
<span class="p_del">-		case 2:</span>
<span class="p_add">+		default:</span>
 		case 1:
<span class="p_del">-			div = 0x2;</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
 			break;
<span class="p_del">-		default:</span>
<span class="p_del">-			div = 0x1;</span>
<span class="p_add">+		case 2:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_2Gx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 3:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_4Gx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		switch (mcr_cfg &amp; 0x0c) {</span>
<span class="p_add">+		case 0:</span>
<span class="p_add">+		case 4:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_512Mx16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 8:</span>
<span class="p_add">+			if (mcr_cfg &amp; 0x40)</span>
<span class="p_add">+				ast-&gt;dram_type = AST_DRAM_1Gx16;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				ast-&gt;dram_type = AST_DRAM_512Mx32;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0xc:</span>
<span class="p_add">+			ast-&gt;dram_type = AST_DRAM_1Gx32;</span>
 			break;
 		}
<span class="p_del">-		ast-&gt;mclk = ref_pll * (num + 2) / (denum + 2) * (div * 1000);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (mcr_scu_strap &amp; 0x2000)</span>
<span class="p_add">+		ref_pll = 14318;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ref_pll = 12000;</span>
<span class="p_add">+</span>
<span class="p_add">+	denum = mcr_scu_mpll &amp; 0x1f;</span>
<span class="p_add">+	num = (mcr_scu_mpll &amp; 0x3fe0) &gt;&gt; 5;</span>
<span class="p_add">+	dsel = (mcr_scu_mpll &amp; 0xc000) &gt;&gt; 14;</span>
<span class="p_add">+	switch (dsel) {</span>
<span class="p_add">+	case 3:</span>
<span class="p_add">+		div = 0x4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		div = 0x2;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		div = 0x1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ast-&gt;mclk = ref_pll * (num + 2) / (denum + 2) * (div * 1000);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/ast/ast_post.c b/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_header">index 270e8fb2803f..c7c58becb25d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ast/ast_post.c</span>
<span class="p_chunk">@@ -375,17 +375,14 @@</span> <span class="p_context"> void ast_post_gpu(struct drm_device *dev)</span>
 	ast_enable_mmio(dev);
 	ast_set_def_ext_reg(dev);
 
<span class="p_del">-	if (ast-&gt;DisableP2A == false)</span>
<span class="p_del">-	{</span>
<span class="p_add">+	if (ast-&gt;config_mode == ast_use_p2a) {</span>
 		if (ast-&gt;chip == AST2300 || ast-&gt;chip == AST2400)
 			ast_init_dram_2300(dev);
 		else
 			ast_init_dram_reg(dev);
 
 		ast_init_3rdtx(dev);
<span class="p_del">-	}</span>
<span class="p_del">-	else</span>
<span class="p_del">-	{</span>
<span class="p_add">+	} else {</span>
 		if (ast-&gt;tx_chip_type != AST_TX_NONE)
 			ast_set_index_reg_mask(ast, AST_IO_CRTC_PORT, 0xa3, 0xcf, 0x80);	/* Enable DVO */
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/etnaviv/etnaviv_mmu.c b/drivers/gpu/drm/etnaviv/etnaviv_mmu.c</span>
<span class="p_header">index 169ac96e8f08..fe0e85b41310 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/etnaviv/etnaviv_mmu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/etnaviv/etnaviv_mmu.c</span>
<span class="p_chunk">@@ -116,9 +116,14 @@</span> <span class="p_context"> static int etnaviv_iommu_find_iova(struct etnaviv_iommu *mmu,</span>
 		struct list_head list;
 		bool found;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * XXX: The DRM_MM_SEARCH_BELOW is really a hack to trick</span>
<span class="p_add">+		 * drm_mm into giving out a low IOVA after address space</span>
<span class="p_add">+		 * rollover. This needs a proper fix.</span>
<span class="p_add">+		 */</span>
 		ret = drm_mm_insert_node_in_range(&amp;mmu-&gt;mm, node,
 			size, 0, mmu-&gt;last_iova, ~0UL,
<span class="p_del">-			DRM_MM_SEARCH_DEFAULT);</span>
<span class="p_add">+			mmu-&gt;last_iova ? DRM_MM_SEARCH_DEFAULT : DRM_MM_SEARCH_BELOW);</span>
 
 		if (ret != -ENOSPC)
 			break;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index 3333e8a45933..b75d809c292e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -115,6 +115,8 @@</span> <span class="p_context"> MODULE_FIRMWARE(&quot;radeon/hainan_rlc.bin&quot;);</span>
 MODULE_FIRMWARE(&quot;radeon/hainan_smc.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/hainan_k_smc.bin&quot;);
 
<span class="p_add">+MODULE_FIRMWARE(&quot;radeon/si58_mc.bin&quot;);</span>
<span class="p_add">+</span>
 static u32 si_get_cu_active_bitmap(struct radeon_device *rdev, u32 se, u32 sh);
 static void si_pcie_gen3_enable(struct radeon_device *rdev);
 static void si_program_aspm(struct radeon_device *rdev);
<span class="p_chunk">@@ -1650,6 +1652,7 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 	int err;
 	int new_fw = 0;
 	bool new_smc = false;
<span class="p_add">+	bool si58_fw = false;</span>
 
 	DRM_DEBUG(&quot;\n&quot;);
 
<span class="p_chunk">@@ -1742,6 +1745,10 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 	default: BUG();
 	}
 
<span class="p_add">+	/* this memory configuration requires special firmware */</span>
<span class="p_add">+	if (((RREG32(MC_SEQ_MISC0) &amp; 0xff000000) &gt;&gt; 24) == 0x58)</span>
<span class="p_add">+		si58_fw = true;</span>
<span class="p_add">+</span>
 	DRM_INFO(&quot;Loading %s Microcode\n&quot;, new_chip_name);
 
 	snprintf(fw_name, sizeof(fw_name), &quot;radeon/%s_pfp.bin&quot;, new_chip_name);
<span class="p_chunk">@@ -1845,7 +1852,10 @@</span> <span class="p_context"> static int si_init_microcode(struct radeon_device *rdev)</span>
 		}
 	}
 
<span class="p_del">-	snprintf(fw_name, sizeof(fw_name), &quot;radeon/%s_mc.bin&quot;, new_chip_name);</span>
<span class="p_add">+	if (si58_fw)</span>
<span class="p_add">+		snprintf(fw_name, sizeof(fw_name), &quot;radeon/si58_mc.bin&quot;);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		snprintf(fw_name, sizeof(fw_name), &quot;radeon/%s_mc.bin&quot;, new_chip_name);</span>
 	err = request_firmware(&amp;rdev-&gt;mc_fw, fw_name, rdev-&gt;dev);
 	if (err) {
 		snprintf(fw_name, sizeof(fw_name), &quot;radeon/%s_mc2.bin&quot;, chip_name);
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c b/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_header">index 13db8a2851ed..1f013d45c9e9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_cmdbuf_res.c</span>
<span class="p_chunk">@@ -321,6 +321,7 @@</span> <span class="p_context"> void vmw_cmdbuf_res_man_destroy(struct vmw_cmdbuf_res_manager *man)</span>
 	list_for_each_entry_safe(entry, next, &amp;man-&gt;list, head)
 		vmw_cmdbuf_res_free(man, entry);
 
<span class="p_add">+	drm_ht_remove(&amp;man-&gt;resources);</span>
 	kfree(man);
 }
 
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index b1bce804fe97..8008e06b7efe 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -427,6 +427,15 @@</span> <span class="p_context"> static int i2c_hid_hwreset(struct i2c_client *client)</span>
 	if (ret)
 		goto out_unlock;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The HID over I2C specification states that if a DEVICE needs time</span>
<span class="p_add">+	 * after the PWR_ON request, it should utilise CLOCK stretching.</span>
<span class="p_add">+	 * However, it has been observered that the Windows driver provides a</span>
<span class="p_add">+	 * 1ms sleep between the PWR_ON and RESET requests and that some devices</span>
<span class="p_add">+	 * rely on this.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	usleep_range(1000, 5000);</span>
<span class="p_add">+</span>
 	i2c_hid_dbg(ihid, &quot;resetting...\n&quot;);
 
 	ret = i2c_hid_command(client, &amp;hid_reset_cmd, NULL, 0);
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-brcmstb.c b/drivers/i2c/busses/i2c-brcmstb.c</span>
<span class="p_header">index 0652281662a8..78792b4d6437 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-brcmstb.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-brcmstb.c</span>
<span class="p_chunk">@@ -465,6 +465,7 @@</span> <span class="p_context"> static int brcmstb_i2c_xfer(struct i2c_adapter *adapter,</span>
 	u8 *tmp_buf;
 	int len = 0;
 	int xfersz = brcmstb_i2c_get_xfersz(dev);
<span class="p_add">+	u32 cond, cond_per_msg;</span>
 
 	if (dev-&gt;is_suspended)
 		return -EBUSY;
<span class="p_chunk">@@ -481,10 +482,11 @@</span> <span class="p_context"> static int brcmstb_i2c_xfer(struct i2c_adapter *adapter,</span>
 			pmsg-&gt;buf ? pmsg-&gt;buf[0] : &#39;0&#39;, pmsg-&gt;len);
 
 		if (i &lt; (num - 1) &amp;&amp; (msgs[i + 1].flags &amp; I2C_M_NOSTART))
<span class="p_del">-			brcmstb_set_i2c_start_stop(dev, ~(COND_START_STOP));</span>
<span class="p_add">+			cond = ~COND_START_STOP;</span>
 		else
<span class="p_del">-			brcmstb_set_i2c_start_stop(dev,</span>
<span class="p_del">-						   COND_RESTART | COND_NOSTOP);</span>
<span class="p_add">+			cond = COND_RESTART | COND_NOSTOP;</span>
<span class="p_add">+</span>
<span class="p_add">+		brcmstb_set_i2c_start_stop(dev, cond);</span>
 
 		/* Send slave address */
 		if (!(pmsg-&gt;flags &amp; I2C_M_NOSTART)) {
<span class="p_chunk">@@ -497,13 +499,24 @@</span> <span class="p_context"> static int brcmstb_i2c_xfer(struct i2c_adapter *adapter,</span>
 			}
 		}
 
<span class="p_add">+		cond_per_msg = cond;</span>
<span class="p_add">+</span>
 		/* Perform data transfer */
 		while (len) {
 			bytes_to_xfer = min(len, xfersz);
 
<span class="p_del">-			if (len &lt;= xfersz &amp;&amp; i == (num - 1))</span>
<span class="p_del">-				brcmstb_set_i2c_start_stop(dev,</span>
<span class="p_del">-							   ~(COND_START_STOP));</span>
<span class="p_add">+			if (len &lt;= xfersz) {</span>
<span class="p_add">+				if (i == (num - 1))</span>
<span class="p_add">+					cond_per_msg = cond_per_msg &amp;</span>
<span class="p_add">+						~(COND_RESTART | COND_NOSTOP);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					cond_per_msg = cond;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				cond_per_msg = (cond_per_msg &amp; ~COND_RESTART) |</span>
<span class="p_add">+					COND_NOSTOP;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			brcmstb_set_i2c_start_stop(dev, cond_per_msg);</span>
 
 			rc = brcmstb_i2c_xfer_bsc_data(dev, tmp_buf,
 						       bytes_to_xfer, pmsg);
<span class="p_chunk">@@ -512,6 +525,8 @@</span> <span class="p_context"> static int brcmstb_i2c_xfer(struct i2c_adapter *adapter,</span>
 
 			len -=  bytes_to_xfer;
 			tmp_buf += bytes_to_xfer;
<span class="p_add">+</span>
<span class="p_add">+			cond_per_msg = COND_NOSTART | COND_NOSTOP;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c</span>
<span class="p_header">index 71232e5fabf6..20ec34761b39 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hns/hns_roce_hw_v1.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hns/hns_roce_hw_v1.c</span>
<span class="p_chunk">@@ -1267,6 +1267,7 @@</span> <span class="p_context"> void hns_roce_v1_cq_set_ci(struct hns_roce_cq *hr_cq, u32 cons_index)</span>
 	u32 doorbell[2];
 
 	doorbell[0] = cons_index &amp; ((hr_cq-&gt;cq_depth &lt;&lt; 1) - 1);
<span class="p_add">+	doorbell[1] = 0;</span>
 	roce_set_bit(doorbell[1], ROCEE_DB_OTHERS_H_ROCEE_DB_OTH_HW_SYNS_S, 1);
 	roce_set_field(doorbell[1], ROCEE_DB_OTHERS_H_ROCEE_DB_OTH_CMD_M,
 		       ROCEE_DB_OTHERS_H_ROCEE_DB_OTH_CMD_S, 3);
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 11a13b5be73a..41800b6d492e 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -3857,11 +3857,9 @@</span> <span class="p_context"> static void irte_ga_prepare(void *entry,</span>
 			    u8 vector, u32 dest_apicid, int devid)
 {
 	struct irte_ga *irte = (struct irte_ga *) entry;
<span class="p_del">-	struct iommu_dev_data *dev_data = search_dev_data(devid);</span>
 
 	irte-&gt;lo.val                      = 0;
 	irte-&gt;hi.val                      = 0;
<span class="p_del">-	irte-&gt;lo.fields_remap.guest_mode  = dev_data ? dev_data-&gt;use_vapic : 0;</span>
 	irte-&gt;lo.fields_remap.int_type    = delivery_mode;
 	irte-&gt;lo.fields_remap.dm          = dest_mode;
 	irte-&gt;hi.fields.vector            = vector;
<span class="p_chunk">@@ -3917,10 +3915,10 @@</span> <span class="p_context"> static void irte_ga_set_affinity(void *entry, u16 devid, u16 index,</span>
 	struct irte_ga *irte = (struct irte_ga *) entry;
 	struct iommu_dev_data *dev_data = search_dev_data(devid);
 
<span class="p_del">-	if (!dev_data || !dev_data-&gt;use_vapic) {</span>
<span class="p_add">+	if (!dev_data || !dev_data-&gt;use_vapic ||</span>
<span class="p_add">+	    !irte-&gt;lo.fields_remap.guest_mode) {</span>
 		irte-&gt;hi.fields.vector = vector;
 		irte-&gt;lo.fields_remap.destination = dest_apicid;
<span class="p_del">-		irte-&gt;lo.fields_remap.guest_mode = 0;</span>
 		modify_irte_ga(devid, index, irte, NULL);
 	}
 }
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_v2.c b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">index f8ed8c95b685..a0b4ac64b9ff 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_chunk">@@ -695,9 +695,9 @@</span> <span class="p_context"> int amd_iommu_bind_pasid(struct pci_dev *pdev, int pasid,</span>
 
 out_unregister:
 	mmu_notifier_unregister(&amp;pasid_state-&gt;mn, mm);
<span class="p_add">+	mmput(mm);</span>
 
 out_free:
<span class="p_del">-	mmput(mm);</span>
 	free_pasid_state(pasid_state);
 
 out:
<span class="p_header">diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c</span>
<span class="p_header">index c5ab8667e6f2..1520e7f02c2f 100644</span>
<span class="p_header">--- a/drivers/iommu/dma-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/dma-iommu.c</span>
<span class="p_chunk">@@ -112,8 +112,7 @@</span> <span class="p_context"> static void iova_reserve_pci_windows(struct pci_dev *dev,</span>
 	unsigned long lo, hi;
 
 	resource_list_for_each_entry(window, &amp;bridge-&gt;windows) {
<span class="p_del">-		if (resource_type(window-&gt;res) != IORESOURCE_MEM &amp;&amp;</span>
<span class="p_del">-		    resource_type(window-&gt;res) != IORESOURCE_IO)</span>
<span class="p_add">+		if (resource_type(window-&gt;res) != IORESOURCE_MEM)</span>
 			continue;
 
 		lo = iova_pfn(iovad, window-&gt;res-&gt;start - window-&gt;offset);
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 87fcbf71b85a..002f8a421efa 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -1144,7 +1144,7 @@</span> <span class="p_context"> static void dma_pte_free_level(struct dmar_domain *domain, int level,</span>
 		if (!dma_pte_present(pte) || dma_pte_superpage(pte))
 			goto next;
 
<span class="p_del">-		level_pfn = pfn &amp; level_mask(level - 1);</span>
<span class="p_add">+		level_pfn = pfn &amp; level_mask(level);</span>
 		level_pte = phys_to_virt(dma_pte_addr(pte));
 
 		if (level &gt; 2)
<span class="p_header">diff --git a/drivers/iommu/iommu.c b/drivers/iommu/iommu.c</span>
<span class="p_header">index 9a2f1960873b..87d3060f8609 100644</span>
<span class="p_header">--- a/drivers/iommu/iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/iommu.c</span>
<span class="p_chunk">@@ -383,36 +383,30 @@</span> <span class="p_context"> int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
 	device-&gt;dev = dev;
 
 	ret = sysfs_create_link(&amp;dev-&gt;kobj, &amp;group-&gt;kobj, &quot;iommu_group&quot;);
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		kfree(device);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_free_device;</span>
 
 	device-&gt;name = kasprintf(GFP_KERNEL, &quot;%s&quot;, kobject_name(&amp;dev-&gt;kobj));
 rename:
 	if (!device-&gt;name) {
<span class="p_del">-		sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="p_del">-		kfree(device);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_remove_link;</span>
 	}
 
 	ret = sysfs_create_link_nowarn(group-&gt;devices_kobj,
 				       &amp;dev-&gt;kobj, device-&gt;name);
 	if (ret) {
<span class="p_del">-		kfree(device-&gt;name);</span>
 		if (ret == -EEXIST &amp;&amp; i &gt;= 0) {
 			/*
 			 * Account for the slim chance of collision
 			 * and append an instance to the name.
 			 */
<span class="p_add">+			kfree(device-&gt;name);</span>
 			device-&gt;name = kasprintf(GFP_KERNEL, &quot;%s.%d&quot;,
 						 kobject_name(&amp;dev-&gt;kobj), i++);
 			goto rename;
 		}
<span class="p_del">-</span>
<span class="p_del">-		sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="p_del">-		kfree(device);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_free_name;</span>
 	}
 
 	kobject_get(group-&gt;devices_kobj);
<span class="p_chunk">@@ -424,8 +418,10 @@</span> <span class="p_context"> int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
 	mutex_lock(&amp;group-&gt;mutex);
 	list_add_tail(&amp;device-&gt;list, &amp;group-&gt;devices);
 	if (group-&gt;domain)
<span class="p_del">-		__iommu_attach_device(group-&gt;domain, dev);</span>
<span class="p_add">+		ret = __iommu_attach_device(group-&gt;domain, dev);</span>
 	mutex_unlock(&amp;group-&gt;mutex);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_put_group;</span>
 
 	/* Notify any listeners about change to group. */
 	blocking_notifier_call_chain(&amp;group-&gt;notifier,
<span class="p_chunk">@@ -436,6 +432,21 @@</span> <span class="p_context"> int iommu_group_add_device(struct iommu_group *group, struct device *dev)</span>
 	pr_info(&quot;Adding device %s to group %d\n&quot;, dev_name(dev), group-&gt;id);
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err_put_group:</span>
<span class="p_add">+	mutex_lock(&amp;group-&gt;mutex);</span>
<span class="p_add">+	list_del(&amp;device-&gt;list);</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;mutex);</span>
<span class="p_add">+	dev-&gt;iommu_group = NULL;</span>
<span class="p_add">+	kobject_put(group-&gt;devices_kobj);</span>
<span class="p_add">+err_free_name:</span>
<span class="p_add">+	kfree(device-&gt;name);</span>
<span class="p_add">+err_remove_link:</span>
<span class="p_add">+	sysfs_remove_link(&amp;dev-&gt;kobj, &quot;iommu_group&quot;);</span>
<span class="p_add">+err_free_device:</span>
<span class="p_add">+	kfree(device);</span>
<span class="p_add">+	pr_err(&quot;Failed to add device %s to group %d: %d\n&quot;, dev_name(dev), group-&gt;id, ret);</span>
<span class="p_add">+	return ret;</span>
 }
 EXPORT_SYMBOL_GPL(iommu_group_add_device);
 
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index be869a990e38..0b678b5da4c4 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -1095,6 +1095,19 @@</span> <span class="p_context"> static void process_prepared_discard_passdown_pt1(struct dm_thin_new_mapping *m)</span>
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Increment the unmapped blocks.  This prevents a race between the</span>
<span class="p_add">+	 * passdown io and reallocation of freed blocks.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	r = dm_pool_inc_data_range(pool-&gt;pmd, m-&gt;data_block, data_end);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		metadata_operation_failed(pool, &quot;dm_pool_inc_data_range&quot;, r);</span>
<span class="p_add">+		bio_io_error(m-&gt;bio);</span>
<span class="p_add">+		cell_defer_no_holder(tc, m-&gt;cell);</span>
<span class="p_add">+		mempool_free(m, pool-&gt;mapping_pool);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	discard_parent = bio_alloc(GFP_NOIO, 1);
 	if (!discard_parent) {
 		DMWARN(&quot;%s: unable to allocate top level discard bio for passdown. Skipping passdown.&quot;,
<span class="p_chunk">@@ -1115,19 +1128,6 @@</span> <span class="p_context"> static void process_prepared_discard_passdown_pt1(struct dm_thin_new_mapping *m)</span>
 			end_discard(&amp;op, r);
 		}
 	}
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Increment the unmapped blocks.  This prevents a race between the</span>
<span class="p_del">-	 * passdown io and reallocation of freed blocks.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	r = dm_pool_inc_data_range(pool-&gt;pmd, m-&gt;data_block, data_end);</span>
<span class="p_del">-	if (r) {</span>
<span class="p_del">-		metadata_operation_failed(pool, &quot;dm_pool_inc_data_range&quot;, r);</span>
<span class="p_del">-		bio_io_error(m-&gt;bio);</span>
<span class="p_del">-		cell_defer_no_holder(tc, m-&gt;cell);</span>
<span class="p_del">-		mempool_free(m, pool-&gt;mapping_pool);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 }
 
 static void process_prepared_discard_passdown_pt2(struct dm_thin_new_mapping *m)
<span class="p_header">diff --git a/drivers/mtd/nand/brcmnand/brcmnand.c b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">index 9d2424bfdbf5..d9fab2222eb3 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_chunk">@@ -101,6 +101,9 @@</span> <span class="p_context"> struct brcm_nand_dma_desc {</span>
 #define BRCMNAND_MIN_BLOCKSIZE	(8 * 1024)
 #define BRCMNAND_MIN_DEVSIZE	(4ULL * 1024 * 1024)
 
<span class="p_add">+#define NAND_CTRL_RDY			(INTFC_CTLR_READY | INTFC_FLASH_READY)</span>
<span class="p_add">+#define NAND_POLL_STATUS_TIMEOUT_MS	100</span>
<span class="p_add">+</span>
 /* Controller feature flags */
 enum {
 	BRCMNAND_HAS_1K_SECTORS			= BIT(0),
<span class="p_chunk">@@ -765,6 +768,31 @@</span> <span class="p_context"> enum {</span>
 	CS_SELECT_AUTO_DEVICE_ID_CFG		= BIT(30),
 };
 
<span class="p_add">+static int bcmnand_ctrl_poll_status(struct brcmnand_controller *ctrl,</span>
<span class="p_add">+				    u32 mask, u32 expected_val,</span>
<span class="p_add">+				    unsigned long timeout_ms)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long limit;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!timeout_ms)</span>
<span class="p_add">+		timeout_ms = NAND_POLL_STATUS_TIMEOUT_MS;</span>
<span class="p_add">+</span>
<span class="p_add">+	limit = jiffies + msecs_to_jiffies(timeout_ms);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		val = brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS);</span>
<span class="p_add">+		if ((val &amp; mask) == expected_val)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		cpu_relax();</span>
<span class="p_add">+	} while (time_after(limit, jiffies));</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_warn(ctrl-&gt;dev, &quot;timeout on status poll (expected %x got %x)\n&quot;,</span>
<span class="p_add">+		 expected_val, val &amp; mask);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -ETIMEDOUT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void brcmnand_set_wp(struct brcmnand_controller *ctrl, bool en)
 {
 	u32 val = en ? CS_SELECT_NAND_WP : 0;
<span class="p_chunk">@@ -1024,12 +1052,39 @@</span> <span class="p_context"> static void brcmnand_wp(struct mtd_info *mtd, int wp)</span>
 
 	if ((ctrl-&gt;features &amp; BRCMNAND_HAS_WP) &amp;&amp; wp_on == 1) {
 		static int old_wp = -1;
<span class="p_add">+		int ret;</span>
 
 		if (old_wp != wp) {
 			dev_dbg(ctrl-&gt;dev, &quot;WP %s\n&quot;, wp ? &quot;on&quot; : &quot;off&quot;);
 			old_wp = wp;
 		}
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * make sure ctrl/flash ready before and after</span>
<span class="p_add">+		 * changing state of #WP pin</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = bcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY,</span>
<span class="p_add">+					       NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY, 0);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
 		brcmnand_set_wp(ctrl, wp);
<span class="p_add">+		chip-&gt;cmdfunc(mtd, NAND_CMD_STATUS, -1, -1);</span>
<span class="p_add">+		/* NAND_STATUS_WP 0x00 = protected, 0x80 = not protected */</span>
<span class="p_add">+		ret = bcmnand_ctrl_poll_status(ctrl,</span>
<span class="p_add">+					       NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY |</span>
<span class="p_add">+					       NAND_STATUS_WP,</span>
<span class="p_add">+					       NAND_CTRL_RDY |</span>
<span class="p_add">+					       NAND_STATUS_READY |</span>
<span class="p_add">+					       (wp ? 0 : NAND_STATUS_WP), 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			dev_err_ratelimited(&amp;host-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    &quot;nand #WP expected %s\n&quot;,</span>
<span class="p_add">+					    wp ? &quot;on&quot; : &quot;off&quot;);</span>
 	}
 }
 
<span class="p_chunk">@@ -1157,15 +1212,15 @@</span> <span class="p_context"> static irqreturn_t brcmnand_dma_irq(int irq, void *data)</span>
 static void brcmnand_send_cmd(struct brcmnand_host *host, int cmd)
 {
 	struct brcmnand_controller *ctrl = host-&gt;ctrl;
<span class="p_del">-	u32 intfc;</span>
<span class="p_add">+	int ret;</span>
 
 	dev_dbg(ctrl-&gt;dev, &quot;send native cmd %d addr_lo 0x%x\n&quot;, cmd,
 		brcmnand_read_reg(ctrl, BRCMNAND_CMD_ADDRESS));
 	BUG_ON(ctrl-&gt;cmd_pending != 0);
 	ctrl-&gt;cmd_pending = cmd;
 
<span class="p_del">-	intfc = brcmnand_read_reg(ctrl, BRCMNAND_INTFC_STATUS);</span>
<span class="p_del">-	WARN_ON(!(intfc &amp; INTFC_CTLR_READY));</span>
<span class="p_add">+	ret = bcmnand_ctrl_poll_status(ctrl, NAND_CTRL_RDY, NAND_CTRL_RDY, 0);</span>
<span class="p_add">+	WARN_ON(ret);</span>
 
 	mb(); /* flush previous writes */
 	brcmnand_write_reg(ctrl, BRCMNAND_CMD_START,
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">index ca106d4275cc..3424435a39dd 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-dev.c</span>
<span class="p_chunk">@@ -2825,8 +2825,10 @@</span> <span class="p_context"> static int xgbe_init(struct xgbe_prv_data *pdata)</span>
 
 	/* Flush Tx queues */
 	ret = xgbe_flush_tx_queues(pdata);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		netdev_err(pdata-&gt;netdev, &quot;error flushing TX queues\n&quot;);</span>
 		return ret;
<span class="p_add">+	}</span>
 
 	/*
 	 * Initialize DMA related features
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">index 0f0f30149e5a..1e4e8b245cd5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_chunk">@@ -877,7 +877,9 @@</span> <span class="p_context"> static int xgbe_start(struct xgbe_prv_data *pdata)</span>
 
 	DBGPR(&quot;--&gt;xgbe_start\n&quot;);
 
<span class="p_del">-	hw_if-&gt;init(pdata);</span>
<span class="p_add">+	ret = hw_if-&gt;init(pdata);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	ret = phy_if-&gt;phy_start(pdata);
 	if (ret)
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">index 5cc0f8cfec87..20e569bd978a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_chunk">@@ -1097,7 +1097,7 @@</span> <span class="p_context"> static struct sk_buff *bnxt_gro_func_5730x(struct bnxt_tpa_info *tpa_info,</span>
 {
 #ifdef CONFIG_INET
 	struct tcphdr *th;
<span class="p_del">-	int len, nw_off, tcp_opt_len;</span>
<span class="p_add">+	int len, nw_off, tcp_opt_len = 0;</span>
 
 	if (tcp_ts)
 		tcp_opt_len = 12;
<span class="p_header">diff --git a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c</span>
<span class="p_header">index 679679a4ccb2..e858b1af788d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cavium/thunder/thunder_bgx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/cavium/thunder/thunder_bgx.c</span>
<span class="p_chunk">@@ -48,8 +48,9 @@</span> <span class="p_context"> struct lmac {</span>
 struct bgx {
 	u8			bgx_id;
 	struct	lmac		lmac[MAX_LMAC_PER_BGX];
<span class="p_del">-	int			lmac_count;</span>
<span class="p_add">+	u8			lmac_count;</span>
 	u8			max_lmac;
<span class="p_add">+	u8                      acpi_lmac_idx;</span>
 	void __iomem		*reg_base;
 	struct pci_dev		*pdev;
 	bool                    is_dlm;
<span class="p_chunk">@@ -1159,13 +1160,13 @@</span> <span class="p_context"> static acpi_status bgx_acpi_register_phy(acpi_handle handle,</span>
 	if (acpi_bus_get_device(handle, &amp;adev))
 		goto out;
 
<span class="p_del">-	acpi_get_mac_address(dev, adev, bgx-&gt;lmac[bgx-&gt;lmac_count].mac);</span>
<span class="p_add">+	acpi_get_mac_address(dev, adev, bgx-&gt;lmac[bgx-&gt;acpi_lmac_idx].mac);</span>
 
<span class="p_del">-	SET_NETDEV_DEV(&amp;bgx-&gt;lmac[bgx-&gt;lmac_count].netdev, dev);</span>
<span class="p_add">+	SET_NETDEV_DEV(&amp;bgx-&gt;lmac[bgx-&gt;acpi_lmac_idx].netdev, dev);</span>
 
<span class="p_del">-	bgx-&gt;lmac[bgx-&gt;lmac_count].lmacid = bgx-&gt;lmac_count;</span>
<span class="p_add">+	bgx-&gt;lmac[bgx-&gt;acpi_lmac_idx].lmacid = bgx-&gt;acpi_lmac_idx;</span>
<span class="p_add">+	bgx-&gt;acpi_lmac_idx++; /* move to next LMAC */</span>
 out:
<span class="p_del">-	bgx-&gt;lmac_count++;</span>
 	return AE_OK;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">index 0e74529a4209..30e855004c57 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_chunk">@@ -1118,7 +1118,7 @@</span> <span class="p_context"> int be_cmd_pmac_add(struct be_adapter *adapter, u8 *mac_addr,</span>
 err:
 	mutex_unlock(&amp;adapter-&gt;mcc_lock);
 
<span class="p_del">-	 if (status == MCC_STATUS_UNAUTHORIZED_REQUEST)</span>
<span class="p_add">+	 if (base_status(status) == MCC_STATUS_UNAUTHORIZED_REQUEST)</span>
 		status = -EPERM;
 
 	return status;
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index 9711ca4510fa..b3c9cbef766e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -319,6 +319,13 @@</span> <span class="p_context"> static int be_mac_addr_set(struct net_device *netdev, void *p)</span>
 	if (ether_addr_equal(addr-&gt;sa_data, adapter-&gt;dev_mac))
 		return 0;
 
<span class="p_add">+	/* BE3 VFs without FILTMGMT privilege are not allowed to set its MAC</span>
<span class="p_add">+	 * address</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (BEx_chip(adapter) &amp;&amp; be_virtfn(adapter) &amp;&amp;</span>
<span class="p_add">+	    !check_privilege(adapter, BE_PRIV_FILTMGMT))</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+</span>
 	/* if device is not running, copy MAC to netdev-&gt;dev_addr */
 	if (!netif_running(netdev))
 		goto done;
<span class="p_chunk">@@ -3630,7 +3637,11 @@</span> <span class="p_context"> static void be_rx_qs_destroy(struct be_adapter *adapter)</span>
 
 static void be_disable_if_filters(struct be_adapter *adapter)
 {
<span class="p_del">-	be_dev_mac_del(adapter, adapter-&gt;pmac_id[0]);</span>
<span class="p_add">+	/* Don&#39;t delete MAC on BE3 VFs without FILTMGMT privilege  */</span>
<span class="p_add">+	if (!BEx_chip(adapter) || !be_virtfn(adapter) ||</span>
<span class="p_add">+	    check_privilege(adapter, BE_PRIV_FILTMGMT))</span>
<span class="p_add">+		be_dev_mac_del(adapter, adapter-&gt;pmac_id[0]);</span>
<span class="p_add">+</span>
 	be_clear_uc_list(adapter);
 	be_clear_mc_list(adapter);
 
<span class="p_chunk">@@ -3783,8 +3794,9 @@</span> <span class="p_context"> static int be_enable_if_filters(struct be_adapter *adapter)</span>
 	if (status)
 		return status;
 
<span class="p_del">-	/* For BE3 VFs, the PF programs the initial MAC address */</span>
<span class="p_del">-	if (!(BEx_chip(adapter) &amp;&amp; be_virtfn(adapter))) {</span>
<span class="p_add">+	/* Don&#39;t add MAC on BE3 VFs without FILTMGMT privilege */</span>
<span class="p_add">+	if (!BEx_chip(adapter) || !be_virtfn(adapter) ||</span>
<span class="p_add">+	    check_privilege(adapter, BE_PRIV_FILTMGMT)) {</span>
 		status = be_dev_mac_add(adapter, adapter-&gt;netdev-&gt;dev_addr);
 		if (status)
 			return status;
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/gianfar.c b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">index d391beebe591..3f4e71148808 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/gianfar.c</span>
<span class="p_chunk">@@ -2951,7 +2951,7 @@</span> <span class="p_context"> static bool gfar_add_rx_frag(struct gfar_rx_buff *rxb, u32 lstatus,</span>
 	}
 
 	/* try reuse page */
<span class="p_del">-	if (unlikely(page_count(page) != 1))</span>
<span class="p_add">+	if (unlikely(page_count(page) != 1 || page_is_pfmemalloc(page)))</span>
 		return false;
 
 	/* change offset to the other half */
<span class="p_header">diff --git a/drivers/net/ethernet/ibm/ibmveth.c b/drivers/net/ethernet/ibm/ibmveth.c</span>
<span class="p_header">index 03dca732e4c6..b375ae9f98ef 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ibm/ibmveth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ibm/ibmveth.c</span>
<span class="p_chunk">@@ -1604,8 +1604,11 @@</span> <span class="p_context"> static int ibmveth_probe(struct vio_dev *dev, const struct vio_device_id *id)</span>
 	netdev-&gt;netdev_ops = &amp;ibmveth_netdev_ops;
 	netdev-&gt;ethtool_ops = &amp;netdev_ethtool_ops;
 	SET_NETDEV_DEV(netdev, &amp;dev-&gt;dev);
<span class="p_del">-	netdev-&gt;hw_features = NETIF_F_SG | NETIF_F_RXCSUM |</span>
<span class="p_del">-		NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;</span>
<span class="p_add">+	netdev-&gt;hw_features = NETIF_F_SG;</span>
<span class="p_add">+	if (vio_get_attribute(dev, &quot;ibm,illan-options&quot;, NULL) != NULL) {</span>
<span class="p_add">+		netdev-&gt;hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |</span>
<span class="p_add">+				       NETIF_F_RXCSUM;</span>
<span class="p_add">+	}</span>
 
 	netdev-&gt;features |= netdev-&gt;hw_features;
 
<span class="p_header">diff --git a/drivers/net/ethernet/korina.c b/drivers/net/ethernet/korina.c</span>
<span class="p_header">index 1799fe1415df..c051987aab83 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/korina.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/korina.c</span>
<span class="p_chunk">@@ -900,10 +900,10 @@</span> <span class="p_context"> static void korina_restart_task(struct work_struct *work)</span>
 				DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR,
 				&amp;lp-&gt;rx_dma_regs-&gt;dmasm);
 
<span class="p_del">-	korina_free_ring(dev);</span>
<span class="p_del">-</span>
 	napi_disable(&amp;lp-&gt;napi);
 
<span class="p_add">+	korina_free_ring(dev);</span>
<span class="p_add">+</span>
 	if (korina_init(dev) &lt; 0) {
 		printk(KERN_ERR &quot;%s: cannot restart device\n&quot;, dev-&gt;name);
 		return;
<span class="p_chunk">@@ -1064,12 +1064,12 @@</span> <span class="p_context"> static int korina_close(struct net_device *dev)</span>
 	tmp = tmp | DMA_STAT_DONE | DMA_STAT_HALT | DMA_STAT_ERR;
 	writel(tmp, &amp;lp-&gt;rx_dma_regs-&gt;dmasm);
 
<span class="p_del">-	korina_free_ring(dev);</span>
<span class="p_del">-</span>
 	napi_disable(&amp;lp-&gt;napi);
 
 	cancel_work_sync(&amp;lp-&gt;restart_task);
 
<span class="p_add">+	korina_free_ring(dev);</span>
<span class="p_add">+</span>
 	free_irq(lp-&gt;rx_irq, dev);
 	free_irq(lp-&gt;tx_irq, dev);
 	free_irq(lp-&gt;ovr_irq, dev);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">index cd3638e6fe25..0509996957d9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c</span>
<span class="p_chunk">@@ -554,8 +554,9 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 			break;
 
 		case MLX4_EVENT_TYPE_SRQ_LIMIT:
<span class="p_del">-			mlx4_dbg(dev, &quot;%s: MLX4_EVENT_TYPE_SRQ_LIMIT\n&quot;,</span>
<span class="p_del">-				 __func__);</span>
<span class="p_add">+			mlx4_dbg(dev, &quot;%s: MLX4_EVENT_TYPE_SRQ_LIMIT. srq_no=0x%x, eq 0x%x\n&quot;,</span>
<span class="p_add">+				 __func__, be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_add">+				 eq-&gt;eqn);</span>
 		case MLX4_EVENT_TYPE_SRQ_CATAS_ERROR:
 			if (mlx4_is_master(dev)) {
 				/* forward only to slave owning the SRQ */
<span class="p_chunk">@@ -570,15 +571,19 @@</span> <span class="p_context"> static int mlx4_eq_int(struct mlx4_dev *dev, struct mlx4_eq *eq)</span>
 						  eq-&gt;eqn, eq-&gt;cons_index, ret);
 					break;
 				}
<span class="p_del">-				mlx4_warn(dev, &quot;%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\n&quot;,</span>
<span class="p_del">-					  __func__, slave,</span>
<span class="p_del">-					  be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_del">-					  eqe-&gt;type, eqe-&gt;subtype);</span>
<span class="p_add">+				if (eqe-&gt;type ==</span>
<span class="p_add">+				    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)</span>
<span class="p_add">+					mlx4_warn(dev, &quot;%s: slave:%d, srq_no:0x%x, event: %02x(%02x)\n&quot;,</span>
<span class="p_add">+						  __func__, slave,</span>
<span class="p_add">+						  be32_to_cpu(eqe-&gt;event.srq.srqn),</span>
<span class="p_add">+						  eqe-&gt;type, eqe-&gt;subtype);</span>
 
 				if (!ret &amp;&amp; slave != dev-&gt;caps.function) {
<span class="p_del">-					mlx4_warn(dev, &quot;%s: sending event %02x(%02x) to slave:%d\n&quot;,</span>
<span class="p_del">-						  __func__, eqe-&gt;type,</span>
<span class="p_del">-						  eqe-&gt;subtype, slave);</span>
<span class="p_add">+					if (eqe-&gt;type ==</span>
<span class="p_add">+					    MLX4_EVENT_TYPE_SRQ_CATAS_ERROR)</span>
<span class="p_add">+						mlx4_warn(dev, &quot;%s: sending event %02x(%02x) to slave:%d\n&quot;,</span>
<span class="p_add">+							  __func__, eqe-&gt;type,</span>
<span class="p_add">+							  eqe-&gt;subtype, slave);</span>
 					mlx4_slave_event(dev, slave, eqe);
 					break;
 				}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en.h b/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_header">index 21ce0b701143..6180ad45be18 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en.h</span>
<span class="p_chunk">@@ -283,13 +283,15 @@</span> <span class="p_context"> struct mlx5e_dma_info {</span>
 
 struct mlx5e_rx_am_stats {
 	int ppms; /* packets per msec */
<span class="p_add">+	int bpms; /* bytes per msec */</span>
 	int epms; /* events per msec */
 };
 
 struct mlx5e_rx_am_sample {
<span class="p_del">-	ktime_t		time;</span>
<span class="p_del">-	unsigned int	pkt_ctr;</span>
<span class="p_del">-	u16		event_ctr;</span>
<span class="p_add">+	ktime_t	time;</span>
<span class="p_add">+	u32	pkt_ctr;</span>
<span class="p_add">+	u32	byte_ctr;</span>
<span class="p_add">+	u16	event_ctr;</span>
 };
 
 struct mlx5e_rx_am { /* Adaptive Moderation */
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c</span>
<span class="p_header">index 3744e2f79ecf..da1d73fe1a81 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_ethtool.c</span>
<span class="p_chunk">@@ -1183,11 +1183,11 @@</span> <span class="p_context"> static int mlx5e_get_ts_info(struct net_device *dev,</span>
 				 SOF_TIMESTAMPING_RX_HARDWARE |
 				 SOF_TIMESTAMPING_RAW_HARDWARE;
 
<span class="p_del">-	info-&gt;tx_types = (BIT(1) &lt;&lt; HWTSTAMP_TX_OFF) |</span>
<span class="p_del">-			 (BIT(1) &lt;&lt; HWTSTAMP_TX_ON);</span>
<span class="p_add">+	info-&gt;tx_types = BIT(HWTSTAMP_TX_OFF) |</span>
<span class="p_add">+			 BIT(HWTSTAMP_TX_ON);</span>
 
<span class="p_del">-	info-&gt;rx_filters = (BIT(1) &lt;&lt; HWTSTAMP_FILTER_NONE) |</span>
<span class="p_del">-			   (BIT(1) &lt;&lt; HWTSTAMP_FILTER_ALL);</span>
<span class="p_add">+	info-&gt;rx_filters = BIT(HWTSTAMP_FILTER_NONE) |</span>
<span class="p_add">+			   BIT(HWTSTAMP_FILTER_ALL);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">index d4fa851ced2a..ea582342dd8f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_chunk">@@ -3846,7 +3846,8 @@</span> <span class="p_context"> struct net_device *mlx5e_create_netdev(struct mlx5_core_dev *mdev,</span>
 	return netdev;
 
 err_cleanup_nic:
<span class="p_del">-	profile-&gt;cleanup(priv);</span>
<span class="p_add">+	if (profile-&gt;cleanup)</span>
<span class="p_add">+		profile-&gt;cleanup(priv);</span>
 	free_netdev(netdev);
 
 	return NULL;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c</span>
<span class="p_header">index cbfac06b7ffd..23ccec4cb7f5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx_am.c</span>
<span class="p_chunk">@@ -183,28 +183,27 @@</span> <span class="p_context"> static void mlx5e_am_exit_parking(struct mlx5e_rx_am *am)</span>
 	mlx5e_am_step(am);
 }
 
<span class="p_add">+#define IS_SIGNIFICANT_DIFF(val, ref) \</span>
<span class="p_add">+	(((100 * abs((val) - (ref))) / (ref)) &gt; 10) /* more than 10% difference */</span>
<span class="p_add">+</span>
 static int mlx5e_am_stats_compare(struct mlx5e_rx_am_stats *curr,
 				  struct mlx5e_rx_am_stats *prev)
 {
<span class="p_del">-	int diff;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!prev-&gt;ppms)</span>
<span class="p_del">-		return curr-&gt;ppms ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+	if (!prev-&gt;bpms)</span>
<span class="p_add">+		return curr-&gt;bpms ? MLX5E_AM_STATS_BETTER :</span>
 				    MLX5E_AM_STATS_SAME;
 
<span class="p_del">-	diff = curr-&gt;ppms - prev-&gt;ppms;</span>
<span class="p_del">-	if (((100 * abs(diff)) / prev-&gt;ppms) &gt; 10) /* more than 10% diff */</span>
<span class="p_del">-		return (diff &gt; 0) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_del">-				    MLX5E_AM_STATS_WORSE;</span>
<span class="p_add">+	if (IS_SIGNIFICANT_DIFF(curr-&gt;bpms, prev-&gt;bpms))</span>
<span class="p_add">+		return (curr-&gt;bpms &gt; prev-&gt;bpms) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+						   MLX5E_AM_STATS_WORSE;</span>
 
<span class="p_del">-	if (!prev-&gt;epms)</span>
<span class="p_del">-		return curr-&gt;epms ? MLX5E_AM_STATS_WORSE :</span>
<span class="p_del">-				    MLX5E_AM_STATS_SAME;</span>
<span class="p_add">+	if (IS_SIGNIFICANT_DIFF(curr-&gt;ppms, prev-&gt;ppms))</span>
<span class="p_add">+		return (curr-&gt;ppms &gt; prev-&gt;ppms) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+						   MLX5E_AM_STATS_WORSE;</span>
 
<span class="p_del">-	diff = curr-&gt;epms - prev-&gt;epms;</span>
<span class="p_del">-	if (((100 * abs(diff)) / prev-&gt;epms) &gt; 10) /* more than 10% diff */</span>
<span class="p_del">-		return (diff &lt; 0) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_del">-				    MLX5E_AM_STATS_WORSE;</span>
<span class="p_add">+	if (IS_SIGNIFICANT_DIFF(curr-&gt;epms, prev-&gt;epms))</span>
<span class="p_add">+		return (curr-&gt;epms &lt; prev-&gt;epms) ? MLX5E_AM_STATS_BETTER :</span>
<span class="p_add">+						   MLX5E_AM_STATS_WORSE;</span>
 
 	return MLX5E_AM_STATS_SAME;
 }
<span class="p_chunk">@@ -266,10 +265,13 @@</span> <span class="p_context"> static void mlx5e_am_sample(struct mlx5e_rq *rq,</span>
 {
 	s-&gt;time	     = ktime_get();
 	s-&gt;pkt_ctr   = rq-&gt;stats.packets;
<span class="p_add">+	s-&gt;byte_ctr  = rq-&gt;stats.bytes;</span>
 	s-&gt;event_ctr = rq-&gt;cq.event_ctr;
 }
 
 #define MLX5E_AM_NEVENTS 64
<span class="p_add">+#define BITS_PER_TYPE(type) (sizeof(type) * BITS_PER_BYTE)</span>
<span class="p_add">+#define BIT_GAP(bits, end, start) ((((end) - (start)) + BIT_ULL(bits)) &amp; (BIT_ULL(bits) - 1))</span>
 
 static void mlx5e_am_calc_stats(struct mlx5e_rx_am_sample *start,
 				struct mlx5e_rx_am_sample *end,
<span class="p_chunk">@@ -277,13 +279,17 @@</span> <span class="p_context"> static void mlx5e_am_calc_stats(struct mlx5e_rx_am_sample *start,</span>
 {
 	/* u32 holds up to 71 minutes, should be enough */
 	u32 delta_us = ktime_us_delta(end-&gt;time, start-&gt;time);
<span class="p_del">-	unsigned int npkts = end-&gt;pkt_ctr - start-&gt;pkt_ctr;</span>
<span class="p_add">+	u32 npkts = BIT_GAP(BITS_PER_TYPE(u32), end-&gt;pkt_ctr, start-&gt;pkt_ctr);</span>
<span class="p_add">+	u32 nbytes = BIT_GAP(BITS_PER_TYPE(u32), end-&gt;byte_ctr,</span>
<span class="p_add">+			     start-&gt;byte_ctr);</span>
 
 	if (!delta_us)
 		return;
 
<span class="p_del">-	curr_stats-&gt;ppms =            (npkts * USEC_PER_MSEC) / delta_us;</span>
<span class="p_del">-	curr_stats-&gt;epms = (MLX5E_AM_NEVENTS * USEC_PER_MSEC) / delta_us;</span>
<span class="p_add">+	curr_stats-&gt;ppms = DIV_ROUND_UP(npkts * USEC_PER_MSEC, delta_us);</span>
<span class="p_add">+	curr_stats-&gt;bpms = DIV_ROUND_UP(nbytes * USEC_PER_MSEC, delta_us);</span>
<span class="p_add">+	curr_stats-&gt;epms = DIV_ROUND_UP(MLX5E_AM_NEVENTS * USEC_PER_MSEC,</span>
<span class="p_add">+					delta_us);</span>
 }
 
 void mlx5e_rx_am_work(struct work_struct *work)
<span class="p_chunk">@@ -308,7 +314,8 @@</span> <span class="p_context"> void mlx5e_rx_am(struct mlx5e_rq *rq)</span>
 
 	switch (am-&gt;state) {
 	case MLX5E_AM_MEASURE_IN_PROGRESS:
<span class="p_del">-		nevents = rq-&gt;cq.event_ctr - am-&gt;start_sample.event_ctr;</span>
<span class="p_add">+		nevents = BIT_GAP(BITS_PER_TYPE(u16), rq-&gt;cq.event_ctr,</span>
<span class="p_add">+				  am-&gt;start_sample.event_ctr);</span>
 		if (nevents &lt; MLX5E_AM_NEVENTS)
 			break;
 		mlx5e_am_sample(rq, &amp;end_sample);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/main.c b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">index d776db79e325..5bea0bf2b484 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/main.c</span>
<span class="p_chunk">@@ -155,8 +155,9 @@</span> <span class="p_context"> static struct mlx5_profile profile[] = {</span>
 	},
 };
 
<span class="p_del">-#define FW_INIT_TIMEOUT_MILI	2000</span>
<span class="p_del">-#define FW_INIT_WAIT_MS		2</span>
<span class="p_add">+#define FW_INIT_TIMEOUT_MILI		2000</span>
<span class="p_add">+#define FW_INIT_WAIT_MS			2</span>
<span class="p_add">+#define FW_PRE_INIT_TIMEOUT_MILI	10000</span>
 
 static int wait_fw_init(struct mlx5_core_dev *dev, u32 max_wait_mili)
 {
<span class="p_chunk">@@ -956,6 +957,15 @@</span> <span class="p_context"> static int mlx5_load_one(struct mlx5_core_dev *dev, struct mlx5_priv *priv,</span>
 	 */
 	dev-&gt;state = MLX5_DEVICE_STATE_UP;
 
<span class="p_add">+	/* wait for firmware to accept initialization segments configurations</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = wait_fw_init(dev, FW_PRE_INIT_TIMEOUT_MILI);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;dev-&gt;pdev-&gt;dev, &quot;Firmware over %d MS in pre-initializing state, aborting\n&quot;,</span>
<span class="p_add">+			FW_PRE_INIT_TIMEOUT_MILI);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = mlx5_cmd_init(dev);
 	if (err) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed initializing command interface, aborting\n&quot;);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_header">index 690563099313..9e31a3390154 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_chunk">@@ -1178,7 +1178,8 @@</span> <span class="p_context"> static int mlxsw_sp_nexthop_mac_update(struct mlxsw_sp *mlxsw_sp, u32 adj_index,</span>
 
 static int
 mlxsw_sp_nexthop_group_mac_update(struct mlxsw_sp *mlxsw_sp,
<span class="p_del">-				  struct mlxsw_sp_nexthop_group *nh_grp)</span>
<span class="p_add">+				  struct mlxsw_sp_nexthop_group *nh_grp,</span>
<span class="p_add">+				  bool reallocate)</span>
 {
 	u32 adj_index = nh_grp-&gt;adj_index; /* base */
 	struct mlxsw_sp_nexthop *nh;
<span class="p_chunk">@@ -1193,7 +1194,7 @@</span> <span class="p_context"> mlxsw_sp_nexthop_group_mac_update(struct mlxsw_sp *mlxsw_sp,</span>
 			continue;
 		}
 
<span class="p_del">-		if (nh-&gt;update) {</span>
<span class="p_add">+		if (nh-&gt;update || reallocate) {</span>
 			err = mlxsw_sp_nexthop_mac_update(mlxsw_sp,
 							  adj_index, nh);
 			if (err)
<span class="p_chunk">@@ -1254,7 +1255,8 @@</span> <span class="p_context"> mlxsw_sp_nexthop_group_refresh(struct mlxsw_sp *mlxsw_sp,</span>
 		/* Nothing was added or removed, so no need to reallocate. Just
 		 * update MAC on existing adjacency indexes.
 		 */
<span class="p_del">-		err = mlxsw_sp_nexthop_group_mac_update(mlxsw_sp, nh_grp);</span>
<span class="p_add">+		err = mlxsw_sp_nexthop_group_mac_update(mlxsw_sp, nh_grp,</span>
<span class="p_add">+							false);</span>
 		if (err) {
 			dev_warn(mlxsw_sp-&gt;bus_info-&gt;dev, &quot;Failed to update neigh MAC in adjacency table.\n&quot;);
 			goto set_trap;
<span class="p_chunk">@@ -1282,7 +1284,7 @@</span> <span class="p_context"> mlxsw_sp_nexthop_group_refresh(struct mlxsw_sp *mlxsw_sp,</span>
 	nh_grp-&gt;adj_index_valid = 1;
 	nh_grp-&gt;adj_index = adj_index;
 	nh_grp-&gt;ecmp_size = ecmp_size;
<span class="p_del">-	err = mlxsw_sp_nexthop_group_mac_update(mlxsw_sp, nh_grp);</span>
<span class="p_add">+	err = mlxsw_sp_nexthop_group_mac_update(mlxsw_sp, nh_grp, true);</span>
 	if (err) {
 		dev_warn(mlxsw_sp-&gt;bus_info-&gt;dev, &quot;Failed to update neigh MAC in adjacency table.\n&quot;);
 		goto set_trap;
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/ravb_main.c b/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_header">index 510ff62584d6..11623aad0e8e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/ravb_main.c</span>
<span class="p_chunk">@@ -229,18 +229,6 @@</span> <span class="p_context"> static void ravb_ring_free(struct net_device *ndev, int q)</span>
 	int ring_size;
 	int i;
 
<span class="p_del">-	/* Free RX skb ringbuffer */</span>
<span class="p_del">-	if (priv-&gt;rx_skb[q]) {</span>
<span class="p_del">-		for (i = 0; i &lt; priv-&gt;num_rx_ring[q]; i++)</span>
<span class="p_del">-			dev_kfree_skb(priv-&gt;rx_skb[q][i]);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	kfree(priv-&gt;rx_skb[q]);</span>
<span class="p_del">-	priv-&gt;rx_skb[q] = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Free aligned TX buffers */</span>
<span class="p_del">-	kfree(priv-&gt;tx_align[q]);</span>
<span class="p_del">-	priv-&gt;tx_align[q] = NULL;</span>
<span class="p_del">-</span>
 	if (priv-&gt;rx_ring[q]) {
 		for (i = 0; i &lt; priv-&gt;num_rx_ring[q]; i++) {
 			struct ravb_ex_rx_desc *desc = &amp;priv-&gt;rx_ring[q][i];
<span class="p_chunk">@@ -269,6 +257,18 @@</span> <span class="p_context"> static void ravb_ring_free(struct net_device *ndev, int q)</span>
 		priv-&gt;tx_ring[q] = NULL;
 	}
 
<span class="p_add">+	/* Free RX skb ringbuffer */</span>
<span class="p_add">+	if (priv-&gt;rx_skb[q]) {</span>
<span class="p_add">+		for (i = 0; i &lt; priv-&gt;num_rx_ring[q]; i++)</span>
<span class="p_add">+			dev_kfree_skb(priv-&gt;rx_skb[q][i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	kfree(priv-&gt;rx_skb[q]);</span>
<span class="p_add">+	priv-&gt;rx_skb[q] = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Free aligned TX buffers */</span>
<span class="p_add">+	kfree(priv-&gt;tx_align[q]);</span>
<span class="p_add">+	priv-&gt;tx_align[q] = NULL;</span>
<span class="p_add">+</span>
 	/* Free TX skb ringbuffer.
 	 * SKBs are freed by ravb_tx_free() call above.
 	 */
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/falcon.c b/drivers/net/ethernet/sfc/falcon.c</span>
<span class="p_header">index 1a7092602aec..1bfb21465ace 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/falcon.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/falcon.c</span>
<span class="p_chunk">@@ -2801,6 +2801,11 @@</span> <span class="p_context"> const struct efx_nic_type falcon_a1_nic_type = {</span>
 	.timer_period_max =  1 &lt;&lt; FRF_AB_TC_TIMER_VAL_WIDTH,
 	.offload_features = NETIF_F_IP_CSUM,
 	.mcdi_max_ver = -1,
<span class="p_add">+#ifdef CONFIG_SFC_SRIOV</span>
<span class="p_add">+	.vswitching_probe = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_restore = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_remove = efx_port_dummy_op_void,</span>
<span class="p_add">+#endif</span>
 };
 
 const struct efx_nic_type falcon_b0_nic_type = {
<span class="p_chunk">@@ -2902,4 +2907,9 @@</span> <span class="p_context"> const struct efx_nic_type falcon_b0_nic_type = {</span>
 	.offload_features = NETIF_F_IP_CSUM | NETIF_F_RXHASH | NETIF_F_NTUPLE,
 	.mcdi_max_ver = -1,
 	.max_rx_ip_filters = FR_BZ_RX_FILTER_TBL0_ROWS,
<span class="p_add">+#ifdef CONFIG_SFC_SRIOV</span>
<span class="p_add">+	.vswitching_probe = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_restore = efx_port_dummy_op_int,</span>
<span class="p_add">+	.vswitching_remove = efx_port_dummy_op_void,</span>
<span class="p_add">+#endif</span>
 };
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c</span>
<span class="p_header">index ac3d39c69509..890e4b083f4f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c</span>
<span class="p_chunk">@@ -346,6 +346,7 @@</span> <span class="p_context"> void stmmac_remove_config_dt(struct platform_device *pdev,</span>
 	if (of_phy_is_fixed_link(np))
 		of_phy_deregister_fixed_link(np);
 	of_node_put(plat-&gt;phy_node);
<span class="p_add">+	of_node_put(plat-&gt;mdio_node);</span>
 }
 #else
 struct plat_stmmacenet_data *
<span class="p_header">diff --git a/drivers/net/phy/dp83848.c b/drivers/net/phy/dp83848.c</span>
<span class="p_header">index 800b39f06279..a10d0e7fc5f7 100644</span>
<span class="p_header">--- a/drivers/net/phy/dp83848.c</span>
<span class="p_header">+++ b/drivers/net/phy/dp83848.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/phy.h&gt;
 
 #define TI_DP83848C_PHY_ID		0x20005ca0
<span class="p_add">+#define TI_DP83620_PHY_ID		0x20005ce0</span>
 #define NS_DP83848C_PHY_ID		0x20005c90
 #define TLK10X_PHY_ID			0x2000a210
 #define TI_DP83822_PHY_ID		0x2000a240
<span class="p_chunk">@@ -77,6 +78,7 @@</span> <span class="p_context"> static int dp83848_config_intr(struct phy_device *phydev)</span>
 static struct mdio_device_id __maybe_unused dp83848_tbl[] = {
 	{ TI_DP83848C_PHY_ID, 0xfffffff0 },
 	{ NS_DP83848C_PHY_ID, 0xfffffff0 },
<span class="p_add">+	{ TI_DP83620_PHY_ID, 0xfffffff0 },</span>
 	{ TLK10X_PHY_ID, 0xfffffff0 },
 	{ TI_DP83822_PHY_ID, 0xfffffff0 },
 	{ }
<span class="p_chunk">@@ -106,6 +108,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(mdio, dp83848_tbl);</span>
 static struct phy_driver dp83848_driver[] = {
 	DP83848_PHY_DRIVER(TI_DP83848C_PHY_ID, &quot;TI DP83848C 10/100 Mbps PHY&quot;),
 	DP83848_PHY_DRIVER(NS_DP83848C_PHY_ID, &quot;NS DP83848C 10/100 Mbps PHY&quot;),
<span class="p_add">+	DP83848_PHY_DRIVER(TI_DP83620_PHY_ID, &quot;TI DP83620 10/100 Mbps PHY&quot;),</span>
 	DP83848_PHY_DRIVER(TLK10X_PHY_ID, &quot;TI TLK10X 10/100 Mbps PHY&quot;),
 	DP83848_PHY_DRIVER(TI_DP83822_PHY_ID, &quot;TI DP83822 10/100 Mbps PHY&quot;),
 };
<span class="p_header">diff --git a/drivers/net/phy/dp83867.c b/drivers/net/phy/dp83867.c</span>
<span class="p_header">index 91177a4a32ad..4cad95552cf1 100644</span>
<span class="p_header">--- a/drivers/net/phy/dp83867.c</span>
<span class="p_header">+++ b/drivers/net/phy/dp83867.c</span>
<span class="p_chunk">@@ -113,12 +113,16 @@</span> <span class="p_context"> static int dp83867_of_init(struct phy_device *phydev)</span>
 
 	ret = of_property_read_u32(of_node, &quot;ti,rx-internal-delay&quot;,
 				   &amp;dp83867-&gt;rx_id_delay);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret &amp;&amp;</span>
<span class="p_add">+	    (phydev-&gt;interface == PHY_INTERFACE_MODE_RGMII_ID ||</span>
<span class="p_add">+	     phydev-&gt;interface == PHY_INTERFACE_MODE_RGMII_RXID))</span>
 		return ret;
 
 	ret = of_property_read_u32(of_node, &quot;ti,tx-internal-delay&quot;,
 				   &amp;dp83867-&gt;tx_id_delay);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret &amp;&amp;</span>
<span class="p_add">+	    (phydev-&gt;interface == PHY_INTERFACE_MODE_RGMII_ID ||</span>
<span class="p_add">+	     phydev-&gt;interface == PHY_INTERFACE_MODE_RGMII_TXID))</span>
 		return ret;
 
 	return of_property_read_u32(of_node, &quot;ti,fifo-depth&quot;,
<span class="p_header">diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c</span>
<span class="p_header">index 2f70f80de27f..c60c147708c4 100644</span>
<span class="p_header">--- a/drivers/net/phy/marvell.c</span>
<span class="p_header">+++ b/drivers/net/phy/marvell.c</span>
<span class="p_chunk">@@ -1200,7 +1200,8 @@</span> <span class="p_context"> static int marvell_read_status(struct phy_device *phydev)</span>
 	int err;
 
 	/* Check the fiber mode first */
<span class="p_del">-	if (phydev-&gt;supported &amp; SUPPORTED_FIBRE) {</span>
<span class="p_add">+	if (phydev-&gt;supported &amp; SUPPORTED_FIBRE &amp;&amp;</span>
<span class="p_add">+	    phydev-&gt;interface != PHY_INTERFACE_MODE_SGMII) {</span>
 		err = phy_write(phydev, MII_MARVELL_PHY_PAGE, MII_M1111_FIBER);
 		if (err &lt; 0)
 			goto error;
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index a9be26f1f677..edd30ebbf275 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -1384,6 +1384,9 @@</span> <span class="p_context"> int phy_ethtool_set_eee(struct phy_device *phydev, struct ethtool_eee *data)</span>
 {
 	int val = ethtool_adv_to_mmd_eee_adv_t(data-&gt;advertised);
 
<span class="p_add">+	/* Mask prohibited EEE modes */</span>
<span class="p_add">+	val &amp;= ~phydev-&gt;eee_broken_modes;</span>
<span class="p_add">+</span>
 	phy_write_mmd_indirect(phydev, MDIO_AN_EEE_ADV, MDIO_MMD_AN, val);
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c</span>
<span class="p_header">index 14d57d0d1c04..32b555a72e13 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy_device.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy_device.c</span>
<span class="p_chunk">@@ -1146,6 +1146,43 @@</span> <span class="p_context"> static int genphy_config_advert(struct phy_device *phydev)</span>
 }
 
 /**
<span class="p_add">+ * genphy_config_eee_advert - disable unwanted eee mode advertisement</span>
<span class="p_add">+ * @phydev: target phy_device struct</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Description: Writes MDIO_AN_EEE_ADV after disabling unsupported energy</span>
<span class="p_add">+ *   efficent ethernet modes. Returns 0 if the PHY&#39;s advertisement hasn&#39;t</span>
<span class="p_add">+ *   changed, and 1 if it has changed.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int genphy_config_eee_advert(struct phy_device *phydev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int broken = phydev-&gt;eee_broken_modes;</span>
<span class="p_add">+	int old_adv, adv;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Nothing to disable */</span>
<span class="p_add">+	if (!broken)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If the following call fails, we assume that EEE is not</span>
<span class="p_add">+	 * supported by the phy. If we read 0, EEE is not advertised</span>
<span class="p_add">+	 * In both case, we don&#39;t need to continue</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	adv = phy_read_mmd_indirect(phydev, MDIO_AN_EEE_ADV, MDIO_MMD_AN);</span>
<span class="p_add">+	if (adv &lt;= 0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	old_adv = adv;</span>
<span class="p_add">+	adv &amp;= ~broken;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Advertising remains unchanged with the broken mask */</span>
<span class="p_add">+	if (old_adv == adv)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	phy_write_mmd_indirect(phydev, MDIO_AN_EEE_ADV, MDIO_MMD_AN, adv);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * genphy_setup_forced - configures/forces speed/duplex from @phydev
  * @phydev: target phy_device struct
  *
<span class="p_chunk">@@ -1203,15 +1240,20 @@</span> <span class="p_context"> EXPORT_SYMBOL(genphy_restart_aneg);</span>
  */
 int genphy_config_aneg(struct phy_device *phydev)
 {
<span class="p_del">-	int result;</span>
<span class="p_add">+	int err, changed;</span>
<span class="p_add">+</span>
<span class="p_add">+	changed = genphy_config_eee_advert(phydev);</span>
 
 	if (AUTONEG_ENABLE != phydev-&gt;autoneg)
 		return genphy_setup_forced(phydev);
 
<span class="p_del">-	result = genphy_config_advert(phydev);</span>
<span class="p_del">-	if (result &lt; 0) /* error */</span>
<span class="p_del">-		return result;</span>
<span class="p_del">-	if (result == 0) {</span>
<span class="p_add">+	err = genphy_config_advert(phydev);</span>
<span class="p_add">+	if (err &lt; 0) /* error */</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	changed |= err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (changed == 0) {</span>
 		/* Advertisement hasn&#39;t changed, but maybe aneg was never on to
 		 * begin with?  Or maybe phy was isolated?
 		 */
<span class="p_chunk">@@ -1221,16 +1263,16 @@</span> <span class="p_context"> int genphy_config_aneg(struct phy_device *phydev)</span>
 			return ctl;
 
 		if (!(ctl &amp; BMCR_ANENABLE) || (ctl &amp; BMCR_ISOLATE))
<span class="p_del">-			result = 1; /* do restart aneg */</span>
<span class="p_add">+			changed = 1; /* do restart aneg */</span>
 	}
 
 	/* Only restart aneg if we are advertising something different
 	 * than we were before.
 	 */
<span class="p_del">-	if (result &gt; 0)</span>
<span class="p_del">-		result = genphy_restart_aneg(phydev);</span>
<span class="p_add">+	if (changed &gt; 0)</span>
<span class="p_add">+		return genphy_restart_aneg(phydev);</span>
 
<span class="p_del">-	return result;</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL(genphy_config_aneg);
 
<span class="p_chunk">@@ -1588,6 +1630,33 @@</span> <span class="p_context"> static void of_set_phy_supported(struct phy_device *phydev)</span>
 		__set_phy_supported(phydev, max_speed);
 }
 
<span class="p_add">+static void of_set_phy_eee_broken(struct phy_device *phydev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node = phydev-&gt;mdio.dev.of_node;</span>
<span class="p_add">+	u32 broken = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_OF_MDIO))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!node)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(node, &quot;eee-broken-100tx&quot;))</span>
<span class="p_add">+		broken |= MDIO_EEE_100TX;</span>
<span class="p_add">+	if (of_property_read_bool(node, &quot;eee-broken-1000t&quot;))</span>
<span class="p_add">+		broken |= MDIO_EEE_1000T;</span>
<span class="p_add">+	if (of_property_read_bool(node, &quot;eee-broken-10gt&quot;))</span>
<span class="p_add">+		broken |= MDIO_EEE_10GT;</span>
<span class="p_add">+	if (of_property_read_bool(node, &quot;eee-broken-1000kx&quot;))</span>
<span class="p_add">+		broken |= MDIO_EEE_1000KX;</span>
<span class="p_add">+	if (of_property_read_bool(node, &quot;eee-broken-10gkx4&quot;))</span>
<span class="p_add">+		broken |= MDIO_EEE_10GKX4;</span>
<span class="p_add">+	if (of_property_read_bool(node, &quot;eee-broken-10gkr&quot;))</span>
<span class="p_add">+		broken |= MDIO_EEE_10GKR;</span>
<span class="p_add">+</span>
<span class="p_add">+	phydev-&gt;eee_broken_modes = broken;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * phy_probe - probe and init a PHY device
  * @dev: device to probe and init
<span class="p_chunk">@@ -1625,6 +1694,11 @@</span> <span class="p_context"> static int phy_probe(struct device *dev)</span>
 	of_set_phy_supported(phydev);
 	phydev-&gt;advertising = phydev-&gt;supported;
 
<span class="p_add">+	/* Get the EEE modes we want to prohibit. We will ask</span>
<span class="p_add">+	 * the PHY stop advertising these mode later on</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	of_set_phy_eee_broken(phydev);</span>
<span class="p_add">+</span>
 	/* Set the state to READY by default */
 	phydev-&gt;state = PHY_READY;
 
<span class="p_header">diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c</span>
<span class="p_header">index 7ca99899972e..1568aedddfc9 100644</span>
<span class="p_header">--- a/drivers/net/virtio_net.c</span>
<span class="p_header">+++ b/drivers/net/virtio_net.c</span>
<span class="p_chunk">@@ -47,8 +47,16 @@</span> <span class="p_context"> module_param(gso, bool, 0444);</span>
  */
 DECLARE_EWMA(pkt_len, 1, 64)
 
<span class="p_add">+/* With mergeable buffers we align buffer address and use the low bits to</span>
<span class="p_add">+ * encode its true size. Buffer size is up to 1 page so we need to align to</span>
<span class="p_add">+ * square root of page size to ensure we reserve enough bits to encode the true</span>
<span class="p_add">+ * size.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define MERGEABLE_BUFFER_MIN_ALIGN_SHIFT ((PAGE_SHIFT + 1) / 2)</span>
<span class="p_add">+</span>
 /* Minimum alignment for mergeable packet buffers. */
<span class="p_del">-#define MERGEABLE_BUFFER_ALIGN max(L1_CACHE_BYTES, 256)</span>
<span class="p_add">+#define MERGEABLE_BUFFER_ALIGN max(L1_CACHE_BYTES, \</span>
<span class="p_add">+				   1 &lt;&lt; MERGEABLE_BUFFER_MIN_ALIGN_SHIFT)</span>
 
 #define VIRTNET_DRIVER_VERSION &quot;1.0.0&quot;
 
<span class="p_header">diff --git a/drivers/net/vrf.c b/drivers/net/vrf.c</span>
<span class="p_header">index ee02605a0f89..642df9391193 100644</span>
<span class="p_header">--- a/drivers/net/vrf.c</span>
<span class="p_header">+++ b/drivers/net/vrf.c</span>
<span class="p_chunk">@@ -36,12 +36,14 @@</span> <span class="p_context"></span>
 #include &lt;net/addrconf.h&gt;
 #include &lt;net/l3mdev.h&gt;
 #include &lt;net/fib_rules.h&gt;
<span class="p_add">+#include &lt;net/netns/generic.h&gt;</span>
 
 #define DRV_NAME	&quot;vrf&quot;
 #define DRV_VERSION	&quot;1.0&quot;
 
 #define FIB_RULE_PREF  1000       /* default preference for FIB rules */
<span class="p_del">-static bool add_fib_rules = true;</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int vrf_net_id;</span>
 
 struct net_vrf {
 	struct rtable __rcu	*rth;
<span class="p_chunk">@@ -1237,6 +1239,8 @@</span> <span class="p_context"> static int vrf_newlink(struct net *src_net, struct net_device *dev,</span>
 		       struct nlattr *tb[], struct nlattr *data[])
 {
 	struct net_vrf *vrf = netdev_priv(dev);
<span class="p_add">+	bool *add_fib_rules;</span>
<span class="p_add">+	struct net *net;</span>
 	int err;
 
 	if (!data || !data[IFLA_VRF_TABLE])
<span class="p_chunk">@@ -1252,13 +1256,15 @@</span> <span class="p_context"> static int vrf_newlink(struct net *src_net, struct net_device *dev,</span>
 	if (err)
 		goto out;
 
<span class="p_del">-	if (add_fib_rules) {</span>
<span class="p_add">+	net = dev_net(dev);</span>
<span class="p_add">+	add_fib_rules = net_generic(net, vrf_net_id);</span>
<span class="p_add">+	if (*add_fib_rules) {</span>
 		err = vrf_add_fib_rules(dev);
 		if (err) {
 			unregister_netdevice(dev);
 			goto out;
 		}
<span class="p_del">-		add_fib_rules = false;</span>
<span class="p_add">+		*add_fib_rules = false;</span>
 	}
 
 out:
<span class="p_chunk">@@ -1341,16 +1347,38 @@</span> <span class="p_context"> static struct notifier_block vrf_notifier_block __read_mostly = {</span>
 	.notifier_call = vrf_device_event,
 };
 
<span class="p_add">+/* Initialize per network namespace state */</span>
<span class="p_add">+static int __net_init vrf_netns_init(struct net *net)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool *add_fib_rules = net_generic(net, vrf_net_id);</span>
<span class="p_add">+</span>
<span class="p_add">+	*add_fib_rules = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pernet_operations vrf_net_ops __net_initdata = {</span>
<span class="p_add">+	.init = vrf_netns_init,</span>
<span class="p_add">+	.id   = &amp;vrf_net_id,</span>
<span class="p_add">+	.size = sizeof(bool),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int __init vrf_init_module(void)
 {
 	int rc;
 
 	register_netdevice_notifier(&amp;vrf_notifier_block);
 
<span class="p_del">-	rc = rtnl_link_register(&amp;vrf_link_ops);</span>
<span class="p_add">+	rc = register_pernet_subsys(&amp;vrf_net_ops);</span>
 	if (rc &lt; 0)
 		goto error;
 
<span class="p_add">+	rc = rtnl_link_register(&amp;vrf_link_ops);</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		unregister_pernet_subsys(&amp;vrf_net_ops);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 
 error:
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 55c4408892be..963e5339a4d7 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -2285,7 +2285,7 @@</span> <span class="p_context"> static void vxlan_cleanup(unsigned long arg)</span>
 				= container_of(p, struct vxlan_fdb, hlist);
 			unsigned long timeout;
 
<span class="p_del">-			if (f-&gt;state &amp; NUD_PERMANENT)</span>
<span class="p_add">+			if (f-&gt;state &amp; (NUD_PERMANENT | NUD_NOARP))</span>
 				continue;
 
 			timeout = f-&gt;used + vxlan-&gt;cfg.age_interval * HZ;
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">index 78d9966a3957..0f5dde1f2248 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c</span>
<span class="p_chunk">@@ -5913,7 +5913,6 @@</span> <span class="p_context"> static int brcmf_construct_chaninfo(struct brcmf_cfg80211_info *cfg,</span>
 	u32 i, j;
 	u32 total;
 	u32 chaninfo;
<span class="p_del">-	u32 index;</span>
 
 	pbuf = kzalloc(BRCMF_DCMD_MEDLEN, GFP_KERNEL);
 
<span class="p_chunk">@@ -5961,33 +5960,36 @@</span> <span class="p_context"> static int brcmf_construct_chaninfo(struct brcmf_cfg80211_info *cfg,</span>
 		    ch.bw == BRCMU_CHAN_BW_80)
 			continue;
 
<span class="p_del">-		channel = band-&gt;channels;</span>
<span class="p_del">-		index = band-&gt;n_channels;</span>
<span class="p_add">+		channel = NULL;</span>
 		for (j = 0; j &lt; band-&gt;n_channels; j++) {
<span class="p_del">-			if (channel[j].hw_value == ch.control_ch_num) {</span>
<span class="p_del">-				index = j;</span>
<span class="p_add">+			if (band-&gt;channels[j].hw_value == ch.control_ch_num) {</span>
<span class="p_add">+				channel = &amp;band-&gt;channels[j];</span>
 				break;
 			}
 		}
<span class="p_del">-		channel[index].center_freq =</span>
<span class="p_del">-			ieee80211_channel_to_frequency(ch.control_ch_num,</span>
<span class="p_del">-						       band-&gt;band);</span>
<span class="p_del">-		channel[index].hw_value = ch.control_ch_num;</span>
<span class="p_add">+		if (!channel) {</span>
<span class="p_add">+			/* It seems firmware supports some channel we never</span>
<span class="p_add">+			 * considered. Something new in IEEE standard?</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			brcmf_err(&quot;Ignoring unexpected firmware channel %d\n&quot;,</span>
<span class="p_add">+				  ch.control_ch_num);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
 		/* assuming the chanspecs order is HT20,
 		 * HT40 upper, HT40 lower, and VHT80.
 		 */
 		if (ch.bw == BRCMU_CHAN_BW_80) {
<span class="p_del">-			channel[index].flags &amp;= ~IEEE80211_CHAN_NO_80MHZ;</span>
<span class="p_add">+			channel-&gt;flags &amp;= ~IEEE80211_CHAN_NO_80MHZ;</span>
 		} else if (ch.bw == BRCMU_CHAN_BW_40) {
<span class="p_del">-			brcmf_update_bw40_channel_flag(&amp;channel[index], &amp;ch);</span>
<span class="p_add">+			brcmf_update_bw40_channel_flag(channel, &amp;ch);</span>
 		} else {
 			/* enable the channel and disable other bandwidths
 			 * for now as mentioned order assure they are enabled
 			 * for subsequent chanspecs.
 			 */
<span class="p_del">-			channel[index].flags = IEEE80211_CHAN_NO_HT40 |</span>
<span class="p_del">-					       IEEE80211_CHAN_NO_80MHZ;</span>
<span class="p_add">+			channel-&gt;flags = IEEE80211_CHAN_NO_HT40 |</span>
<span class="p_add">+					 IEEE80211_CHAN_NO_80MHZ;</span>
 			ch.bw = BRCMU_CHAN_BW_20;
 			cfg-&gt;d11inf.encchspec(&amp;ch);
 			chaninfo = ch.chspec;
<span class="p_chunk">@@ -5995,11 +5997,11 @@</span> <span class="p_context"> static int brcmf_construct_chaninfo(struct brcmf_cfg80211_info *cfg,</span>
 						       &amp;chaninfo);
 			if (!err) {
 				if (chaninfo &amp; WL_CHAN_RADAR)
<span class="p_del">-					channel[index].flags |=</span>
<span class="p_add">+					channel-&gt;flags |=</span>
 						(IEEE80211_CHAN_RADAR |
 						 IEEE80211_CHAN_NO_IR);
 				if (chaninfo &amp; WL_CHAN_PASSIVE)
<span class="p_del">-					channel[index].flags |=</span>
<span class="p_add">+					channel-&gt;flags |=</span>
 						IEEE80211_CHAN_NO_IR;
 			}
 		}
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c</span>
<span class="p_header">index 63a051be832e..bec7d9c46087 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c</span>
<span class="p_chunk">@@ -843,8 +843,10 @@</span> <span class="p_context"> static void iwl_mvm_thermal_zone_unregister(struct iwl_mvm *mvm)</span>
 		return;
 
 	IWL_DEBUG_TEMP(mvm, &quot;Thermal zone device unregister\n&quot;);
<span class="p_del">-	thermal_zone_device_unregister(mvm-&gt;tz_device.tzone);</span>
<span class="p_del">-	mvm-&gt;tz_device.tzone = NULL;</span>
<span class="p_add">+	if (mvm-&gt;tz_device.tzone) {</span>
<span class="p_add">+		thermal_zone_device_unregister(mvm-&gt;tz_device.tzone);</span>
<span class="p_add">+		mvm-&gt;tz_device.tzone = NULL;</span>
<span class="p_add">+	}</span>
 }
 
 static void iwl_mvm_cooling_device_unregister(struct iwl_mvm *mvm)
<span class="p_chunk">@@ -853,8 +855,10 @@</span> <span class="p_context"> static void iwl_mvm_cooling_device_unregister(struct iwl_mvm *mvm)</span>
 		return;
 
 	IWL_DEBUG_TEMP(mvm, &quot;Cooling device unregister\n&quot;);
<span class="p_del">-	thermal_cooling_device_unregister(mvm-&gt;cooling_dev.cdev);</span>
<span class="p_del">-	mvm-&gt;cooling_dev.cdev = NULL;</span>
<span class="p_add">+	if (mvm-&gt;cooling_dev.cdev) {</span>
<span class="p_add">+		thermal_cooling_device_unregister(mvm-&gt;cooling_dev.cdev);</span>
<span class="p_add">+		mvm-&gt;cooling_dev.cdev = NULL;</span>
<span class="p_add">+	}</span>
 }
 #endif /* CONFIG_THERMAL */
 
<span class="p_header">diff --git a/drivers/net/xen-netback/interface.c b/drivers/net/xen-netback/interface.c</span>
<span class="p_header">index 74dc2bf71428..b009d7966b46 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/interface.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/interface.c</span>
<span class="p_chunk">@@ -221,18 +221,18 @@</span> <span class="p_context"> static struct net_device_stats *xenvif_get_stats(struct net_device *dev)</span>
 {
 	struct xenvif *vif = netdev_priv(dev);
 	struct xenvif_queue *queue = NULL;
<span class="p_del">-	unsigned int num_queues = vif-&gt;num_queues;</span>
 	unsigned long rx_bytes = 0;
 	unsigned long rx_packets = 0;
 	unsigned long tx_bytes = 0;
 	unsigned long tx_packets = 0;
 	unsigned int index;
 
<span class="p_add">+	spin_lock(&amp;vif-&gt;lock);</span>
 	if (vif-&gt;queues == NULL)
 		goto out;
 
 	/* Aggregate tx and rx stats from each queue */
<span class="p_del">-	for (index = 0; index &lt; num_queues; ++index) {</span>
<span class="p_add">+	for (index = 0; index &lt; vif-&gt;num_queues; ++index) {</span>
 		queue = &amp;vif-&gt;queues[index];
 		rx_bytes += queue-&gt;stats.rx_bytes;
 		rx_packets += queue-&gt;stats.rx_packets;
<span class="p_chunk">@@ -241,6 +241,8 @@</span> <span class="p_context"> static struct net_device_stats *xenvif_get_stats(struct net_device *dev)</span>
 	}
 
 out:
<span class="p_add">+	spin_unlock(&amp;vif-&gt;lock);</span>
<span class="p_add">+</span>
 	vif-&gt;dev-&gt;stats.rx_bytes = rx_bytes;
 	vif-&gt;dev-&gt;stats.rx_packets = rx_packets;
 	vif-&gt;dev-&gt;stats.tx_bytes = tx_bytes;
<span class="p_header">diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">index 8674e188b697..b44f37fff890 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_chunk">@@ -493,11 +493,22 @@</span> <span class="p_context"> static int backend_create_xenvif(struct backend_info *be)</span>
 static void backend_disconnect(struct backend_info *be)
 {
 	if (be-&gt;vif) {
<span class="p_add">+		unsigned int queue_index;</span>
<span class="p_add">+</span>
 		xen_unregister_watchers(be-&gt;vif);
 #ifdef CONFIG_DEBUG_FS
 		xenvif_debugfs_delif(be-&gt;vif);
 #endif /* CONFIG_DEBUG_FS */
 		xenvif_disconnect_data(be-&gt;vif);
<span class="p_add">+		for (queue_index = 0; queue_index &lt; be-&gt;vif-&gt;num_queues; ++queue_index)</span>
<span class="p_add">+			xenvif_deinit_queue(&amp;be-&gt;vif-&gt;queues[queue_index]);</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;be-&gt;vif-&gt;lock);</span>
<span class="p_add">+		vfree(be-&gt;vif-&gt;queues);</span>
<span class="p_add">+		be-&gt;vif-&gt;num_queues = 0;</span>
<span class="p_add">+		be-&gt;vif-&gt;queues = NULL;</span>
<span class="p_add">+		spin_unlock(&amp;be-&gt;vif-&gt;lock);</span>
<span class="p_add">+</span>
 		xenvif_disconnect_ctrl(be-&gt;vif);
 	}
 }
<span class="p_chunk">@@ -1040,6 +1051,8 @@</span> <span class="p_context"> static void connect(struct backend_info *be)</span>
 err:
 	if (be-&gt;vif-&gt;num_queues &gt; 0)
 		xenvif_disconnect_data(be-&gt;vif); /* Clean up existing queues */
<span class="p_add">+	for (queue_index = 0; queue_index &lt; be-&gt;vif-&gt;num_queues; ++queue_index)</span>
<span class="p_add">+		xenvif_deinit_queue(&amp;be-&gt;vif-&gt;queues[queue_index]);</span>
 	vfree(be-&gt;vif-&gt;queues);
 	be-&gt;vif-&gt;queues = NULL;
 	be-&gt;vif-&gt;num_queues = 0;
<span class="p_header">diff --git a/drivers/net/xen-netfront.c b/drivers/net/xen-netfront.c</span>
<span class="p_header">index 0cdcb2169083..599cf5090030 100644</span>
<span class="p_header">--- a/drivers/net/xen-netfront.c</span>
<span class="p_header">+++ b/drivers/net/xen-netfront.c</span>
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> static void xennet_alloc_rx_buffers(struct netfront_queue *queue)</span>
 	queue-&gt;rx.req_prod_pvt = req_prod;
 
 	/* Not enough requests? Try again later. */
<span class="p_del">-	if (req_prod - queue-&gt;rx.rsp_cons &lt; NET_RX_SLOTS_MIN) {</span>
<span class="p_add">+	if (req_prod - queue-&gt;rx.sring-&gt;req_prod &lt; NET_RX_SLOTS_MIN) {</span>
 		mod_timer(&amp;queue-&gt;rx_refill_timer, jiffies + (HZ/10));
 		return;
 	}
<span class="p_header">diff --git a/drivers/nvdimm/pmem.c b/drivers/nvdimm/pmem.c</span>
<span class="p_header">index b4808590870c..3456f532077c 100644</span>
<span class="p_header">--- a/drivers/nvdimm/pmem.c</span>
<span class="p_header">+++ b/drivers/nvdimm/pmem.c</span>
<span class="p_chunk">@@ -87,7 +87,9 @@</span> <span class="p_context"> static int read_pmem(struct page *page, unsigned int off,</span>
 
 	rc = memcpy_from_pmem(mem + off, pmem_addr, len);
 	kunmap_atomic(mem);
<span class="p_del">-	return rc;</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int pmem_do_bvec(struct pmem_device *pmem, struct page *page,
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-intel.c b/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_header">index 01443762e570..b40a074822cf 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_chunk">@@ -353,6 +353,21 @@</span> <span class="p_context"> static int intel_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,</span>
 	return 0;
 }
 
<span class="p_add">+static void __intel_gpio_set_direction(void __iomem *padcfg0, bool input)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 value;</span>
<span class="p_add">+</span>
<span class="p_add">+	value = readl(padcfg0);</span>
<span class="p_add">+	if (input) {</span>
<span class="p_add">+		value &amp;= ~PADCFG0_GPIORXDIS;</span>
<span class="p_add">+		value |= PADCFG0_GPIOTXDIS;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		value &amp;= ~PADCFG0_GPIOTXDIS;</span>
<span class="p_add">+		value |= PADCFG0_GPIORXDIS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel(value, padcfg0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int intel_gpio_request_enable(struct pinctrl_dev *pctldev,
 				     struct pinctrl_gpio_range *range,
 				     unsigned pin)
<span class="p_chunk">@@ -375,11 +390,11 @@</span> <span class="p_context"> static int intel_gpio_request_enable(struct pinctrl_dev *pctldev,</span>
 	/* Disable SCI/SMI/NMI generation */
 	value &amp;= ~(PADCFG0_GPIROUTIOXAPIC | PADCFG0_GPIROUTSCI);
 	value &amp;= ~(PADCFG0_GPIROUTSMI | PADCFG0_GPIROUTNMI);
<span class="p_del">-	/* Disable TX buffer and enable RX (this will be input) */</span>
<span class="p_del">-	value &amp;= ~PADCFG0_GPIORXDIS;</span>
<span class="p_del">-	value |= PADCFG0_GPIOTXDIS;</span>
 	writel(value, padcfg0);
 
<span class="p_add">+	/* Disable TX buffer and enable RX (this will be input) */</span>
<span class="p_add">+	__intel_gpio_set_direction(padcfg0, true);</span>
<span class="p_add">+</span>
 	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);
 
 	return 0;
<span class="p_chunk">@@ -392,18 +407,11 @@</span> <span class="p_context"> static int intel_gpio_set_direction(struct pinctrl_dev *pctldev,</span>
 	struct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
 	void __iomem *padcfg0;
 	unsigned long flags;
<span class="p_del">-	u32 value;</span>
 
 	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);
 
 	padcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);
<span class="p_del">-</span>
<span class="p_del">-	value = readl(padcfg0);</span>
<span class="p_del">-	if (input)</span>
<span class="p_del">-		value |= PADCFG0_GPIOTXDIS;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		value &amp;= ~PADCFG0_GPIOTXDIS;</span>
<span class="p_del">-	writel(value, padcfg0);</span>
<span class="p_add">+	__intel_gpio_set_direction(padcfg0, input);</span>
 
 	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);
 
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index a7614fc542b5..2f1615e00cb4 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -813,6 +813,7 @@</span> <span class="p_context"> static void ideapad_acpi_notify(acpi_handle handle, u32 event, void *data)</span>
 			case 8:
 			case 7:
 			case 6:
<span class="p_add">+			case 1:</span>
 				ideapad_input_report(priv, vpc_bit);
 				break;
 			case 5:
<span class="p_header">diff --git a/drivers/regulator/tps65086-regulator.c b/drivers/regulator/tps65086-regulator.c</span>
<span class="p_header">index caf174ffa316..6dbf3cf3951e 100644</span>
<span class="p_header">--- a/drivers/regulator/tps65086-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/tps65086-regulator.c</span>
<span class="p_chunk">@@ -156,19 +156,19 @@</span> <span class="p_context"> static struct tps65086_regulator regulators[] = {</span>
 			   VDOA23_VID_MASK, TPS65086_LDOA3CTRL, BIT(0),
 			   tps65086_ldoa23_ranges, 0, 0),
 	TPS65086_SWITCH(&quot;SWA1&quot;, &quot;swa1&quot;, SWA1, TPS65086_SWVTT_EN, BIT(5)),
<span class="p_del">-	TPS65086_SWITCH(&quot;SWB1&quot;, &quot;swa2&quot;, SWB1, TPS65086_SWVTT_EN, BIT(6)),</span>
<span class="p_del">-	TPS65086_SWITCH(&quot;SWB2&quot;, &quot;swa3&quot;, SWB2, TPS65086_SWVTT_EN, BIT(7)),</span>
<span class="p_add">+	TPS65086_SWITCH(&quot;SWB1&quot;, &quot;swb1&quot;, SWB1, TPS65086_SWVTT_EN, BIT(6)),</span>
<span class="p_add">+	TPS65086_SWITCH(&quot;SWB2&quot;, &quot;swb2&quot;, SWB2, TPS65086_SWVTT_EN, BIT(7)),</span>
 	TPS65086_SWITCH(&quot;VTT&quot;, &quot;vtt&quot;, VTT, TPS65086_SWVTT_EN, BIT(4)),
 };
 
<span class="p_del">-static int tps65086_of_parse_cb(struct device_node *dev,</span>
<span class="p_add">+static int tps65086_of_parse_cb(struct device_node *node,</span>
 				const struct regulator_desc *desc,
 				struct regulator_config *config)
 {
 	int ret;
 
 	/* Check for 25mV step mode */
<span class="p_del">-	if (of_property_read_bool(config-&gt;of_node, &quot;ti,regulator-step-size-25mv&quot;)) {</span>
<span class="p_add">+	if (of_property_read_bool(node, &quot;ti,regulator-step-size-25mv&quot;)) {</span>
 		switch (desc-&gt;id) {
 		case BUCK1:
 		case BUCK2:
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> static int tps65086_of_parse_cb(struct device_node *dev,</span>
 	}
 
 	/* Check for decay mode */
<span class="p_del">-	if (desc-&gt;id &lt;= BUCK6 &amp;&amp; of_property_read_bool(config-&gt;of_node, &quot;ti,regulator-decay&quot;)) {</span>
<span class="p_add">+	if (desc-&gt;id &lt;= BUCK6 &amp;&amp; of_property_read_bool(node, &quot;ti,regulator-decay&quot;)) {</span>
 		ret = regmap_write_bits(config-&gt;regmap,
 					regulators[desc-&gt;id].decay_reg,
 					regulators[desc-&gt;id].decay_mask,
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">index b7d54bfb1df9..7b696d108112 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_chunk">@@ -3590,12 +3590,14 @@</span> <span class="p_context"> lpfc_els_free_iocb(struct lpfc_hba *phba, struct lpfc_iocbq *elsiocb)</span>
 		} else {
 			buf_ptr1 = (struct lpfc_dmabuf *) elsiocb-&gt;context2;
 			lpfc_els_free_data(phba, buf_ptr1);
<span class="p_add">+			elsiocb-&gt;context2 = NULL;</span>
 		}
 	}
 
 	if (elsiocb-&gt;context3) {
 		buf_ptr = (struct lpfc_dmabuf *) elsiocb-&gt;context3;
 		lpfc_els_free_bpl(phba, buf_ptr);
<span class="p_add">+		elsiocb-&gt;context3 = NULL;</span>
 	}
 	lpfc_sli_release_iocbq(phba, elsiocb);
 	return 0;
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_sli.c b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">index 49b4c798de18..2d4f4b58dcfa 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_sli.c</span>
<span class="p_chunk">@@ -5951,18 +5951,25 @@</span> <span class="p_context"> lpfc_sli4_alloc_resource_identifiers(struct lpfc_hba *phba)</span>
 
  free_vfi_bmask:
 	kfree(phba-&gt;sli4_hba.vfi_bmask);
<span class="p_add">+	phba-&gt;sli4_hba.vfi_bmask = NULL;</span>
  free_xri_ids:
 	kfree(phba-&gt;sli4_hba.xri_ids);
<span class="p_add">+	phba-&gt;sli4_hba.xri_ids = NULL;</span>
  free_xri_bmask:
 	kfree(phba-&gt;sli4_hba.xri_bmask);
<span class="p_add">+	phba-&gt;sli4_hba.xri_bmask = NULL;</span>
  free_vpi_ids:
 	kfree(phba-&gt;vpi_ids);
<span class="p_add">+	phba-&gt;vpi_ids = NULL;</span>
  free_vpi_bmask:
 	kfree(phba-&gt;vpi_bmask);
<span class="p_add">+	phba-&gt;vpi_bmask = NULL;</span>
  free_rpi_ids:
 	kfree(phba-&gt;sli4_hba.rpi_ids);
<span class="p_add">+	phba-&gt;sli4_hba.rpi_ids = NULL;</span>
  free_rpi_bmask:
 	kfree(phba-&gt;sli4_hba.rpi_bmask);
<span class="p_add">+	phba-&gt;sli4_hba.rpi_bmask = NULL;</span>
  err_exit:
 	return rc;
 }
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_def.h b/drivers/scsi/qla2xxx/qla_def.h</span>
<span class="p_header">index 8e63a7b90277..91ec0689c714 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_def.h</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_def.h</span>
<span class="p_chunk">@@ -1555,7 +1555,8 @@</span> <span class="p_context"> typedef struct {</span>
 struct atio {
 	uint8_t		entry_type;		/* Entry type. */
 	uint8_t		entry_count;		/* Entry count. */
<span class="p_del">-	uint8_t		data[58];</span>
<span class="p_add">+	__le16		attr_n_length;</span>
<span class="p_add">+	uint8_t		data[56];</span>
 	uint32_t	signature;
 #define ATIO_PROCESSED 0xDEADDEAD		/* Signature */
 };
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_isr.c b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">index 068c4e47fac9..bddaabb288d4 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_isr.c</span>
<span class="p_chunk">@@ -2487,6 +2487,10 @@</span> <span class="p_context"> qla2x00_error_entry(scsi_qla_host_t *vha, struct rsp_que *rsp, sts_entry_t *pkt)</span>
 	if (pkt-&gt;entry_status &amp; RF_BUSY)
 		res = DID_BUS_BUSY &lt;&lt; 16;
 
<span class="p_add">+	if (pkt-&gt;entry_type == NOTIFY_ACK_TYPE &amp;&amp;</span>
<span class="p_add">+	    pkt-&gt;handle == QLA_TGT_SKIP_HANDLE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	sp = qla2x00_get_sp_from_handle(vha, func, req, pkt);
 	if (sp) {
 		sp-&gt;done(ha, sp, res);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.c b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">index feab7ea8e823..91f5f55a8a9b 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.c</span>
<span class="p_chunk">@@ -3067,7 +3067,7 @@</span> <span class="p_context"> static int __qlt_send_term_imm_notif(struct scsi_qla_host *vha,</span>
 
 	pkt-&gt;entry_type = NOTIFY_ACK_TYPE;
 	pkt-&gt;entry_count = 1;
<span class="p_del">-	pkt-&gt;handle = QLA_TGT_SKIP_HANDLE | CTIO_COMPLETION_HANDLE_MARK;</span>
<span class="p_add">+	pkt-&gt;handle = QLA_TGT_SKIP_HANDLE;</span>
 
 	nack = (struct nack_to_isp *)pkt;
 	nack-&gt;ox_id = ntfy-&gt;ox_id;
<span class="p_chunk">@@ -6463,12 +6463,29 @@</span> <span class="p_context"> qlt_24xx_process_atio_queue(struct scsi_qla_host *vha, uint8_t ha_locked)</span>
 	if (!vha-&gt;flags.online)
 		return;
 
<span class="p_del">-	while (ha-&gt;tgt.atio_ring_ptr-&gt;signature != ATIO_PROCESSED) {</span>
<span class="p_add">+	while ((ha-&gt;tgt.atio_ring_ptr-&gt;signature != ATIO_PROCESSED) ||</span>
<span class="p_add">+	    fcpcmd_is_corrupted(ha-&gt;tgt.atio_ring_ptr)) {</span>
 		pkt = (struct atio_from_isp *)ha-&gt;tgt.atio_ring_ptr;
 		cnt = pkt-&gt;u.raw.entry_count;
 
<span class="p_del">-		qlt_24xx_atio_pkt_all_vps(vha, (struct atio_from_isp *)pkt,</span>
<span class="p_del">-		    ha_locked);</span>
<span class="p_add">+		if (unlikely(fcpcmd_is_corrupted(ha-&gt;tgt.atio_ring_ptr))) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This packet is corrupted. The header + payload</span>
<span class="p_add">+			 * can not be trusted. There is no point in passing</span>
<span class="p_add">+			 * it further up.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ql_log(ql_log_warn, vha, 0xffff,</span>
<span class="p_add">+			    &quot;corrupted fcp frame SID[%3phN] OXID[%04x] EXCG[%x] %64phN\n&quot;,</span>
<span class="p_add">+			    pkt-&gt;u.isp24.fcp_hdr.s_id,</span>
<span class="p_add">+			    be16_to_cpu(pkt-&gt;u.isp24.fcp_hdr.ox_id),</span>
<span class="p_add">+			    le32_to_cpu(pkt-&gt;u.isp24.exchange_addr), pkt);</span>
<span class="p_add">+</span>
<span class="p_add">+			adjust_corrupted_atio(pkt);</span>
<span class="p_add">+			qlt_send_term_exchange(vha, NULL, pkt, ha_locked, 0);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			qlt_24xx_atio_pkt_all_vps(vha,</span>
<span class="p_add">+			    (struct atio_from_isp *)pkt, ha_locked);</span>
<span class="p_add">+		}</span>
 
 		for (i = 0; i &lt; cnt; i++) {
 			ha-&gt;tgt.atio_ring_index++;
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_target.h b/drivers/scsi/qla2xxx/qla_target.h</span>
<span class="p_header">index f26c5f60eedd..0824a8164a24 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_target.h</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_target.h</span>
<span class="p_chunk">@@ -427,13 +427,33 @@</span> <span class="p_context"> struct atio_from_isp {</span>
 		struct {
 			uint8_t  entry_type;	/* Entry type. */
 			uint8_t  entry_count;	/* Entry count. */
<span class="p_del">-			uint8_t  data[58];</span>
<span class="p_add">+			__le16	 attr_n_length;</span>
<span class="p_add">+#define FCP_CMD_LENGTH_MASK 0x0fff</span>
<span class="p_add">+#define FCP_CMD_LENGTH_MIN  0x38</span>
<span class="p_add">+			uint8_t  data[56];</span>
 			uint32_t signature;
 #define ATIO_PROCESSED 0xDEADDEAD		/* Signature */
 		} raw;
 	} u;
 } __packed;
 
<span class="p_add">+static inline int fcpcmd_is_corrupted(struct atio *atio)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (atio-&gt;entry_type == ATIO_TYPE7 &amp;&amp;</span>
<span class="p_add">+	    (le16_to_cpu(atio-&gt;attr_n_length &amp; FCP_CMD_LENGTH_MASK) &lt;</span>
<span class="p_add">+	    FCP_CMD_LENGTH_MIN))</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* adjust corrupted atio so we won&#39;t trip over the same entry again. */</span>
<span class="p_add">+static inline void adjust_corrupted_atio(struct atio_from_isp *atio)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atio-&gt;u.raw.attr_n_length = cpu_to_le16(FCP_CMD_LENGTH_MIN);</span>
<span class="p_add">+	atio-&gt;u.isp24.fcp_cmnd.add_cdb_len = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define CTIO_TYPE7 0x12 /* Continue target I/O entry (for 24xx) */
 
 /*
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 931af0793951..13ac7e57a35d 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -2572,7 +2572,8 @@</span> <span class="p_context"> sd_read_cache_type(struct scsi_disk *sdkp, unsigned char *buffer)</span>
 		if (sdp-&gt;broken_fua) {
 			sd_first_printk(KERN_NOTICE, sdkp, &quot;Disabling FUA\n&quot;);
 			sdkp-&gt;DPOFUA = 0;
<span class="p_del">-		} else if (sdkp-&gt;DPOFUA &amp;&amp; !sdkp-&gt;device-&gt;use_10_for_rw) {</span>
<span class="p_add">+		} else if (sdkp-&gt;DPOFUA &amp;&amp; !sdkp-&gt;device-&gt;use_10_for_rw &amp;&amp;</span>
<span class="p_add">+			   !sdkp-&gt;device-&gt;use_16_for_rw) {</span>
 			sd_first_printk(KERN_NOTICE, sdkp,
 				  &quot;Uses READ/WRITE(6), disabling FUA\n&quot;);
 			sdkp-&gt;DPOFUA = 0;
<span class="p_header">diff --git a/drivers/scsi/virtio_scsi.c b/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">index ec91bd07f00a..c680d7641311 100644</span>
<span class="p_header">--- a/drivers/scsi/virtio_scsi.c</span>
<span class="p_header">+++ b/drivers/scsi/virtio_scsi.c</span>
<span class="p_chunk">@@ -534,7 +534,9 @@</span> <span class="p_context"> static int virtscsi_queuecommand(struct virtio_scsi *vscsi,</span>
 {
 	struct Scsi_Host *shost = virtio_scsi_host(vscsi-&gt;vdev);
 	struct virtio_scsi_cmd *cmd = scsi_cmd_priv(sc);
<span class="p_add">+	unsigned long flags;</span>
 	int req_size;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(scsi_sg_count(sc) &gt; shost-&gt;sg_tablesize);
 
<span class="p_chunk">@@ -562,8 +564,15 @@</span> <span class="p_context"> static int virtscsi_queuecommand(struct virtio_scsi *vscsi,</span>
 		req_size = sizeof(cmd-&gt;req.cmd);
 	}
 
<span class="p_del">-	if (virtscsi_kick_cmd(req_vq, cmd, req_size, sizeof(cmd-&gt;resp.cmd)) != 0)</span>
<span class="p_add">+	ret = virtscsi_kick_cmd(req_vq, cmd, req_size, sizeof(cmd-&gt;resp.cmd));</span>
<span class="p_add">+	if (ret == -EIO) {</span>
<span class="p_add">+		cmd-&gt;resp.cmd.response = VIRTIO_SCSI_S_BAD_TARGET;</span>
<span class="p_add">+		spin_lock_irqsave(&amp;req_vq-&gt;vq_lock, flags);</span>
<span class="p_add">+		virtscsi_complete_cmd(vscsi, cmd);</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;req_vq-&gt;vq_lock, flags);</span>
<span class="p_add">+	} else if (ret != 0) {</span>
 		return SCSI_MLQUEUE_HOST_BUSY;
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/spi/spi-davinci.c b/drivers/spi/spi-davinci.c</span>
<span class="p_header">index d36c11b73a35..02fb96797ac8 100644</span>
<span class="p_header">--- a/drivers/spi/spi-davinci.c</span>
<span class="p_header">+++ b/drivers/spi/spi-davinci.c</span>
<span class="p_chunk">@@ -646,7 +646,7 @@</span> <span class="p_context"> static int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 			buf = t-&gt;rx_buf;
 		t-&gt;rx_dma = dma_map_single(&amp;spi-&gt;dev, buf,
 				t-&gt;len, DMA_FROM_DEVICE);
<span class="p_del">-		if (!t-&gt;rx_dma) {</span>
<span class="p_add">+		if (dma_mapping_error(&amp;spi-&gt;dev, !t-&gt;rx_dma)) {</span>
 			ret = -EFAULT;
 			goto err_rx_map;
 		}
<span class="p_chunk">@@ -660,7 +660,7 @@</span> <span class="p_context"> static int davinci_spi_bufs(struct spi_device *spi, struct spi_transfer *t)</span>
 			buf = (void *)t-&gt;tx_buf;
 		t-&gt;tx_dma = dma_map_single(&amp;spi-&gt;dev, buf,
 				t-&gt;len, DMA_TO_DEVICE);
<span class="p_del">-		if (!t-&gt;tx_dma) {</span>
<span class="p_add">+		if (dma_mapping_error(&amp;spi-&gt;dev, t-&gt;tx_dma)) {</span>
 			ret = -EFAULT;
 			goto err_tx_map;
 		}
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index 24d4492d0168..6db80635ace8 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -621,8 +621,10 @@</span> <span class="p_context"> void spi_unregister_device(struct spi_device *spi)</span>
 	if (!spi)
 		return;
 
<span class="p_del">-	if (spi-&gt;dev.of_node)</span>
<span class="p_add">+	if (spi-&gt;dev.of_node) {</span>
 		of_node_clear_flag(spi-&gt;dev.of_node, OF_POPULATED);
<span class="p_add">+		of_node_put(spi-&gt;dev.of_node);</span>
<span class="p_add">+	}</span>
 	if (ACPI_COMPANION(&amp;spi-&gt;dev))
 		acpi_device_clear_enumerated(ACPI_COMPANION(&amp;spi-&gt;dev));
 	device_unregister(&amp;spi-&gt;dev);
<span class="p_chunk">@@ -797,12 +799,12 @@</span> <span class="p_context"> static int __spi_map_msg(struct spi_master *master, struct spi_message *msg)</span>
 	if (master-&gt;dma_tx)
 		tx_dev = master-&gt;dma_tx-&gt;device-&gt;dev;
 	else
<span class="p_del">-		tx_dev = &amp;master-&gt;dev;</span>
<span class="p_add">+		tx_dev = master-&gt;dev.parent;</span>
 
 	if (master-&gt;dma_rx)
 		rx_dev = master-&gt;dma_rx-&gt;device-&gt;dev;
 	else
<span class="p_del">-		rx_dev = &amp;master-&gt;dev;</span>
<span class="p_add">+		rx_dev = master-&gt;dev.parent;</span>
 
 	list_for_each_entry(xfer, &amp;msg-&gt;transfers, transfer_list) {
 		if (!master-&gt;can_dma(master, msg-&gt;spi, xfer))
<span class="p_chunk">@@ -844,12 +846,12 @@</span> <span class="p_context"> static int __spi_unmap_msg(struct spi_master *master, struct spi_message *msg)</span>
 	if (master-&gt;dma_tx)
 		tx_dev = master-&gt;dma_tx-&gt;device-&gt;dev;
 	else
<span class="p_del">-		tx_dev = &amp;master-&gt;dev;</span>
<span class="p_add">+		tx_dev = master-&gt;dev.parent;</span>
 
 	if (master-&gt;dma_rx)
 		rx_dev = master-&gt;dma_rx-&gt;device-&gt;dev;
 	else
<span class="p_del">-		rx_dev = &amp;master-&gt;dev;</span>
<span class="p_add">+		rx_dev = master-&gt;dev.parent;</span>
 
 	list_for_each_entry(xfer, &amp;msg-&gt;transfers, transfer_list) {
 		if (!master-&gt;can_dma(master, msg-&gt;spi, xfer))
<span class="p_chunk">@@ -1589,11 +1591,13 @@</span> <span class="p_context"> of_register_spi_device(struct spi_master *master, struct device_node *nc)</span>
 	if (rc) {
 		dev_err(&amp;master-&gt;dev, &quot;spi_device register error %s\n&quot;,
 			nc-&gt;full_name);
<span class="p_del">-		goto err_out;</span>
<span class="p_add">+		goto err_of_node_put;</span>
 	}
 
 	return spi;
 
<span class="p_add">+err_of_node_put:</span>
<span class="p_add">+	of_node_put(nc);</span>
 err_out:
 	spi_dev_put(spi);
 	return ERR_PTR(rc);
<span class="p_header">diff --git a/drivers/usb/dwc2/gadget.c b/drivers/usb/dwc2/gadget.c</span>
<span class="p_header">index 24fbebc9b409..cfdd5c3da236 100644</span>
<span class="p_header">--- a/drivers/usb/dwc2/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc2/gadget.c</span>
<span class="p_chunk">@@ -2532,7 +2532,7 @@</span> <span class="p_context"> void dwc2_hsotg_core_init_disconnected(struct dwc2_hsotg *hsotg,</span>
 	/* keep other bits untouched (so e.g. forced modes are not lost) */
 	usbcfg = dwc2_readl(hsotg-&gt;regs + GUSBCFG);
 	usbcfg &amp;= ~(GUSBCFG_TOUTCAL_MASK | GUSBCFG_PHYIF16 | GUSBCFG_SRPCAP |
<span class="p_del">-		GUSBCFG_HNPCAP);</span>
<span class="p_add">+		GUSBCFG_HNPCAP | GUSBCFG_USBTRDTIM_MASK);</span>
 
 	/* set the PLL on, remove the HNP/SRP and set the PHY */
 	val = (hsotg-&gt;phyif == GUSBCFG_PHYIF8) ? 9 : 5;
<span class="p_chunk">@@ -3403,7 +3403,7 @@</span> <span class="p_context"> static void dwc2_hsotg_init(struct dwc2_hsotg *hsotg)</span>
 	/* keep other bits untouched (so e.g. forced modes are not lost) */
 	usbcfg = dwc2_readl(hsotg-&gt;regs + GUSBCFG);
 	usbcfg &amp;= ~(GUSBCFG_TOUTCAL_MASK | GUSBCFG_PHYIF16 | GUSBCFG_SRPCAP |
<span class="p_del">-		GUSBCFG_HNPCAP);</span>
<span class="p_add">+		GUSBCFG_HNPCAP | GUSBCFG_USBTRDTIM_MASK);</span>
 
 	/* set the PLL on, remove the HNP/SRP and set the PHY */
 	trdtim = (hsotg-&gt;phyif == GUSBCFG_PHYIF8) ? 9 : 5;
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 04ffd7640c33..f9c99803a43d 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -3688,6 +3688,7 @@</span> <span class="p_context"> static void ffs_closed(struct ffs_data *ffs)</span>
 {
 	struct ffs_dev *ffs_obj;
 	struct f_fs_opts *opts;
<span class="p_add">+	struct config_item *ci;</span>
 
 	ENTER();
 	ffs_dev_lock();
<span class="p_chunk">@@ -3711,8 +3712,11 @@</span> <span class="p_context"> static void ffs_closed(struct ffs_data *ffs)</span>
 	    || !atomic_read(&amp;opts-&gt;func_inst.group.cg_item.ci_kref.refcount))
 		goto done;
 
<span class="p_del">-	unregister_gadget_item(ffs_obj-&gt;opts-&gt;</span>
<span class="p_del">-			       func_inst.group.cg_item.ci_parent-&gt;ci_parent);</span>
<span class="p_add">+	ci = opts-&gt;func_inst.group.cg_item.ci_parent-&gt;ci_parent;</span>
<span class="p_add">+	ffs_dev_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	unregister_gadget_item(ci);</span>
<span class="p_add">+	return;</span>
 done:
 	ffs_dev_unlock();
 }
<span class="p_header">diff --git a/drivers/vfio/vfio_iommu_spapr_tce.c b/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_header">index 79ddcb05d126..85d3e648bdea 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio_iommu_spapr_tce.c</span>
<span class="p_chunk">@@ -1292,6 +1292,10 @@</span> <span class="p_context"> static int tce_iommu_attach_group(void *iommu_data,</span>
 	/* pr_debug(&quot;tce_vfio: Attaching group #%u to iommu %p\n&quot;,
 			iommu_group_id(iommu_group), iommu_group); */
 	table_group = iommu_group_get_iommudata(iommu_group);
<span class="p_add">+	if (!table_group) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto unlock_exit;</span>
<span class="p_add">+	}</span>
 
 	if (tce_groups_attached(container) &amp;&amp; (!table_group-&gt;ops ||
 			!table_group-&gt;ops-&gt;take_ownership ||
<span class="p_header">diff --git a/drivers/watchdog/bcm_kona_wdt.c b/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_header">index e0c98423f2c9..11a72bc2c71b 100644</span>
<span class="p_header">--- a/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/bcm_kona_wdt.c</span>
<span class="p_chunk">@@ -304,6 +304,8 @@</span> <span class="p_context"> static int bcm_kona_wdt_probe(struct platform_device *pdev)</span>
 	if (!wdt)
 		return -ENOMEM;
 
<span class="p_add">+	spin_lock_init(&amp;wdt-&gt;lock);</span>
<span class="p_add">+</span>
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 	wdt-&gt;base = devm_ioremap_resource(dev, res);
 	if (IS_ERR(wdt-&gt;base))
<span class="p_chunk">@@ -316,7 +318,6 @@</span> <span class="p_context"> static int bcm_kona_wdt_probe(struct platform_device *pdev)</span>
 		return ret;
 	}
 
<span class="p_del">-	spin_lock_init(&amp;wdt-&gt;lock);</span>
 	platform_set_drvdata(pdev, wdt);
 	watchdog_set_drvdata(&amp;bcm_kona_wdt_wdd, wdt);
 	bcm_kona_wdt_wdd.parent = &amp;pdev-&gt;dev;
<span class="p_header">diff --git a/drivers/xen/swiotlb-xen.c b/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">index 8e7a3d646531..679f79f68182 100644</span>
<span class="p_header">--- a/drivers/xen/swiotlb-xen.c</span>
<span class="p_header">+++ b/drivers/xen/swiotlb-xen.c</span>
<span class="p_chunk">@@ -409,9 +409,9 @@</span> <span class="p_context"> dma_addr_t xen_swiotlb_map_page(struct device *dev, struct page *page,</span>
 	if (map == SWIOTLB_MAP_ERROR)
 		return DMA_ERROR_CODE;
 
<span class="p_add">+	dev_addr = xen_phys_to_bus(map);</span>
 	xen_dma_map_page(dev, pfn_to_page(map &gt;&gt; PAGE_SHIFT),
 					dev_addr, map &amp; ~PAGE_MASK, size, dir, attrs);
<span class="p_del">-	dev_addr = xen_phys_to_bus(map);</span>
 
 	/*
 	 * Ensure that the address returned is DMA&#39;ble
<span class="p_chunk">@@ -567,13 +567,14 @@</span> <span class="p_context"> xen_swiotlb_map_sg_attrs(struct device *hwdev, struct scatterlist *sgl,</span>
 				sg_dma_len(sgl) = 0;
 				return 0;
 			}
<span class="p_add">+			dev_addr = xen_phys_to_bus(map);</span>
 			xen_dma_map_page(hwdev, pfn_to_page(map &gt;&gt; PAGE_SHIFT),
 						dev_addr,
 						map &amp; ~PAGE_MASK,
 						sg-&gt;length,
 						dir,
 						attrs);
<span class="p_del">-			sg-&gt;dma_address = xen_phys_to_bus(map);</span>
<span class="p_add">+			sg-&gt;dma_address = dev_addr;</span>
 		} else {
 			/* we are not interested in the dma_addr returned by
 			 * xen_dma_map_page, only in the potential cache flushes executed
<span class="p_header">diff --git a/fs/aio.c b/fs/aio.c</span>
<span class="p_header">index 428484f2f841..0fcb49ad67d4 100644</span>
<span class="p_header">--- a/fs/aio.c</span>
<span class="p_header">+++ b/fs/aio.c</span>
<span class="p_chunk">@@ -1085,7 +1085,8 @@</span> <span class="p_context"> static void aio_complete(struct kiocb *kiocb, long res, long res2)</span>
 		 * Tell lockdep we inherited freeze protection from submission
 		 * thread.
 		 */
<span class="p_del">-		__sb_writers_acquired(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);</span>
<span class="p_add">+		if (S_ISREG(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+			__sb_writers_acquired(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);</span>
 		file_end_write(file);
 	}
 
<span class="p_chunk">@@ -1492,7 +1493,8 @@</span> <span class="p_context"> static ssize_t aio_write(struct kiocb *req, struct iocb *iocb, bool vectored,</span>
 		 * by telling it the lock got released so that it doesn&#39;t
 		 * complain about held lock when we return to userspace.
 		 */
<span class="p_del">-		__sb_writers_release(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);</span>
<span class="p_add">+		if (S_ISREG(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+			__sb_writers_release(file_inode(file)-&gt;i_sb, SB_FREEZE_WRITE);</span>
 	}
 	kfree(iovec);
 	return ret;
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 2472af2798c7..cfd724f98332 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -2296,6 +2296,7 @@</span> <span class="p_context"> static int elf_core_dump(struct coredump_params *cprm)</span>
 				goto end_coredump;
 		}
 	}
<span class="p_add">+	dump_truncate(cprm);</span>
 
 	if (!elf_core_write_extra_data(cprm))
 		goto end_coredump;
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index bddbae796941..a2a014b19f18 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -4480,8 +4480,19 @@</span> <span class="p_context"> int btrfs_truncate_inode_items(struct btrfs_trans_handle *trans,</span>
 		if (found_type &gt; min_type) {
 			del_item = 1;
 		} else {
<span class="p_del">-			if (item_end &lt; new_size)</span>
<span class="p_add">+			if (item_end &lt; new_size) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * With NO_HOLES mode, for the following mapping</span>
<span class="p_add">+				 *</span>
<span class="p_add">+				 * [0-4k][hole][8k-12k]</span>
<span class="p_add">+				 *</span>
<span class="p_add">+				 * if truncating isize down to 6k, it ends up</span>
<span class="p_add">+				 * isize being 8k.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (btrfs_fs_incompat(root-&gt;fs_info, NO_HOLES))</span>
<span class="p_add">+					last_size = new_size;</span>
 				break;
<span class="p_add">+			}</span>
 			if (found_key.offset &gt;= new_size)
 				del_item = 1;
 			else
<span class="p_chunk">@@ -7235,7 +7246,6 @@</span> <span class="p_context"> static struct extent_map *btrfs_create_dio_extent(struct inode *inode,</span>
 	struct extent_map *em = NULL;
 	int ret;
 
<span class="p_del">-	down_read(&amp;BTRFS_I(inode)-&gt;dio_sem);</span>
 	if (type != BTRFS_ORDERED_NOCOW) {
 		em = create_pinned_em(inode, start, len, orig_start,
 				      block_start, block_len, orig_block_len,
<span class="p_chunk">@@ -7254,7 +7264,6 @@</span> <span class="p_context"> static struct extent_map *btrfs_create_dio_extent(struct inode *inode,</span>
 		em = ERR_PTR(ret);
 	}
  out:
<span class="p_del">-	up_read(&amp;BTRFS_I(inode)-&gt;dio_sem);</span>
 
 	return em;
 }
<span class="p_chunk">@@ -8707,6 +8716,7 @@</span> <span class="p_context"> static ssize_t btrfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)</span>
 		dio_data.unsubmitted_oe_range_start = (u64)offset;
 		dio_data.unsubmitted_oe_range_end = (u64)offset;
 		current-&gt;journal_info = &amp;dio_data;
<span class="p_add">+		down_read(&amp;BTRFS_I(inode)-&gt;dio_sem);</span>
 	} else if (test_bit(BTRFS_INODE_READDIO_NEED_LOCK,
 				     &amp;BTRFS_I(inode)-&gt;runtime_flags)) {
 		inode_dio_end(inode);
<span class="p_chunk">@@ -8719,6 +8729,7 @@</span> <span class="p_context"> static ssize_t btrfs_direct_IO(struct kiocb *iocb, struct iov_iter *iter)</span>
 				   iter, btrfs_get_blocks_direct, NULL,
 				   btrfs_submit_direct, flags);
 	if (iov_iter_rw(iter) == WRITE) {
<span class="p_add">+		up_read(&amp;BTRFS_I(inode)-&gt;dio_sem);</span>
 		current-&gt;journal_info = NULL;
 		if (ret &lt; 0 &amp;&amp; ret != -EIOCBQUEUED) {
 			if (dio_data.reserve)
<span class="p_header">diff --git a/fs/coredump.c b/fs/coredump.c</span>
<span class="p_header">index eb9c92c9b20f..4407e27beca9 100644</span>
<span class="p_header">--- a/fs/coredump.c</span>
<span class="p_header">+++ b/fs/coredump.c</span>
<span class="p_chunk">@@ -833,3 +833,21 @@</span> <span class="p_context"> int dump_align(struct coredump_params *cprm, int align)</span>
 	return mod ? dump_skip(cprm, align - mod) : 1;
 }
 EXPORT_SYMBOL(dump_align);
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Ensures that file size is big enough to contain the current file</span>
<span class="p_add">+ * postion. This prevents gdb from complaining about a truncated file</span>
<span class="p_add">+ * if the last &quot;write&quot; to the file was dump_skip.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void dump_truncate(struct coredump_params *cprm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct file *file = cprm-&gt;file;</span>
<span class="p_add">+	loff_t offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (file-&gt;f_op-&gt;llseek &amp;&amp; file-&gt;f_op-&gt;llseek != no_llseek) {</span>
<span class="p_add">+		offset = file-&gt;f_op-&gt;llseek(file, 0, SEEK_CUR);</span>
<span class="p_add">+		if (i_size_read(file-&gt;f_mapping-&gt;host) &lt; offset)</span>
<span class="p_add">+			do_truncate(file-&gt;f_path.dentry, offset, 0, file);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(dump_truncate);</span>
<span class="p_header">diff --git a/fs/nfs/callback.c b/fs/nfs/callback.c</span>
<span class="p_header">index 484bebc20bca..0a2115084c3f 100644</span>
<span class="p_header">--- a/fs/nfs/callback.c</span>
<span class="p_header">+++ b/fs/nfs/callback.c</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> static struct svc_serv *nfs_callback_create_svc(int minorversion)</span>
 		printk(KERN_WARNING &quot;nfs_callback_create_svc: no kthread, %d users??\n&quot;,
 			cb_info-&gt;users);
 
<span class="p_del">-	serv = svc_create(&amp;nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);</span>
<span class="p_add">+	serv = svc_create_pooled(&amp;nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);</span>
 	if (!serv) {
 		printk(KERN_ERR &quot;nfs_callback_create_svc: create service failed\n&quot;);
 		return ERR_PTR(-ENOMEM);
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index fc9b04941739..401ea6e4cab8 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -2343,8 +2343,6 @@</span> <span class="p_context"> static int nfs4_opendata_access(struct rpc_cred *cred,</span>
 	if ((mask &amp; ~cache.mask &amp; (MAY_READ | MAY_EXEC)) == 0)
 		return 0;
 
<span class="p_del">-	/* even though OPEN succeeded, access is denied. Close the file */</span>
<span class="p_del">-	nfs4_close_state(state, fmode);</span>
 	return -EACCES;
 }
 
<span class="p_chunk">@@ -8431,6 +8429,7 @@</span> <span class="p_context"> static void nfs4_layoutget_release(void *calldata)</span>
 	size_t max_pages = max_response_pages(server);
 
 	dprintk(&quot;--&gt; %s\n&quot;, __func__);
<span class="p_add">+	nfs4_sequence_free_slot(&amp;lgp-&gt;res.seq_res);</span>
 	nfs4_free_pages(lgp-&gt;args.layout.pages, max_pages);
 	pnfs_put_layout_hdr(NFS_I(inode)-&gt;layout);
 	put_nfs_open_context(lgp-&gt;args.ctx);
<span class="p_chunk">@@ -8505,7 +8504,6 @@</span> <span class="p_context"> nfs4_proc_layoutget(struct nfs4_layoutget *lgp, long *timeout, gfp_t gfp_flags)</span>
 	/* if layoutp-&gt;len is 0, nfs4_layoutget_prepare called rpc_exit */
 	if (status == 0 &amp;&amp; lgp-&gt;res.layoutp-&gt;len)
 		lseg = pnfs_layout_process(lgp);
<span class="p_del">-	nfs4_sequence_free_slot(&amp;lgp-&gt;res.seq_res);</span>
 	rpc_put_task(task);
 	dprintk(&quot;&lt;-- %s status=%d\n&quot;, __func__, status);
 	if (status)
<span class="p_header">diff --git a/fs/ocfs2/cluster/heartbeat.c b/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_header">index 636abcbd4650..5e8709aa1e7e 100644</span>
<span class="p_header">--- a/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_header">+++ b/fs/ocfs2/cluster/heartbeat.c</span>
<span class="p_chunk">@@ -2242,13 +2242,13 @@</span> <span class="p_context"> static void o2hb_heartbeat_group_drop_item(struct config_group *group,</span>
 	spin_unlock(&amp;o2hb_live_lock);
 }
 
<span class="p_del">-static ssize_t o2hb_heartbeat_group_threshold_show(struct config_item *item,</span>
<span class="p_add">+static ssize_t o2hb_heartbeat_group_dead_threshold_show(struct config_item *item,</span>
 		char *page)
 {
 	return sprintf(page, &quot;%u\n&quot;, o2hb_dead_threshold);
 }
 
<span class="p_del">-static ssize_t o2hb_heartbeat_group_threshold_store(struct config_item *item,</span>
<span class="p_add">+static ssize_t o2hb_heartbeat_group_dead_threshold_store(struct config_item *item,</span>
 		const char *page, size_t count)
 {
 	unsigned long tmp;
<span class="p_chunk">@@ -2297,11 +2297,11 @@</span> <span class="p_context"> static ssize_t o2hb_heartbeat_group_mode_store(struct config_item *item,</span>
 
 }
 
<span class="p_del">-CONFIGFS_ATTR(o2hb_heartbeat_group_, threshold);</span>
<span class="p_add">+CONFIGFS_ATTR(o2hb_heartbeat_group_, dead_threshold);</span>
 CONFIGFS_ATTR(o2hb_heartbeat_group_, mode);
 
 static struct configfs_attribute *o2hb_heartbeat_group_attrs[] = {
<span class="p_del">-	&amp;o2hb_heartbeat_group_attr_threshold,</span>
<span class="p_add">+	&amp;o2hb_heartbeat_group_attr_dead_threshold,</span>
 	&amp;o2hb_heartbeat_group_attr_mode,
 	NULL,
 };
<span class="p_header">diff --git a/include/linux/bpf.h b/include/linux/bpf.h</span>
<span class="p_header">index c201017b5730..97498be2ca2e 100644</span>
<span class="p_header">--- a/include/linux/bpf.h</span>
<span class="p_header">+++ b/include/linux/bpf.h</span>
<span class="p_chunk">@@ -243,6 +243,8 @@</span> <span class="p_context"> struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref);</span>
 void bpf_map_put_with_uref(struct bpf_map *map);
 void bpf_map_put(struct bpf_map *map);
 int bpf_map_precharge_memlock(u32 pages);
<span class="p_add">+void *bpf_map_area_alloc(size_t size);</span>
<span class="p_add">+void bpf_map_area_free(void *base);</span>
 
 extern int sysctl_unprivileged_bpf_disabled;
 
<span class="p_header">diff --git a/include/linux/coredump.h b/include/linux/coredump.h</span>
<span class="p_header">index d016a121a8c4..28ffa94aed6b 100644</span>
<span class="p_header">--- a/include/linux/coredump.h</span>
<span class="p_header">+++ b/include/linux/coredump.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"> struct coredump_params;</span>
 extern int dump_skip(struct coredump_params *cprm, size_t nr);
 extern int dump_emit(struct coredump_params *cprm, const void *addr, int nr);
 extern int dump_align(struct coredump_params *cprm, int align);
<span class="p_add">+extern void dump_truncate(struct coredump_params *cprm);</span>
 #ifdef CONFIG_COREDUMP
 extern void do_coredump(const siginfo_t *siginfo);
 #else
<span class="p_header">diff --git a/include/linux/phy.h b/include/linux/phy.h</span>
<span class="p_header">index bd22670e2182..6c9b1e0006ee 100644</span>
<span class="p_header">--- a/include/linux/phy.h</span>
<span class="p_header">+++ b/include/linux/phy.h</span>
<span class="p_chunk">@@ -401,6 +401,9 @@</span> <span class="p_context"> struct phy_device {</span>
 	u32 advertising;
 	u32 lp_advertising;
 
<span class="p_add">+	/* Energy efficient ethernet modes which should be prohibited */</span>
<span class="p_add">+	u32 eee_broken_modes;</span>
<span class="p_add">+</span>
 	int autoneg;
 
 	int link_timeout;
<span class="p_header">diff --git a/include/net/xfrm.h b/include/net/xfrm.h</span>
<span class="p_header">index 31947b9c21d6..835c30e491c8 100644</span>
<span class="p_header">--- a/include/net/xfrm.h</span>
<span class="p_header">+++ b/include/net/xfrm.h</span>
<span class="p_chunk">@@ -944,10 +944,6 @@</span> <span class="p_context"> struct xfrm_dst {</span>
 	struct flow_cache_object flo;
 	struct xfrm_policy *pols[XFRM_POLICY_TYPE_MAX];
 	int num_pols, num_xfrms;
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct flowi *origin;</span>
<span class="p_del">-	struct xfrm_selector *partner;</span>
<span class="p_del">-#endif</span>
 	u32 xfrm_genid;
 	u32 policy_genid;
 	u32 route_mtu_cached;
<span class="p_chunk">@@ -963,12 +959,6 @@</span> <span class="p_context"> static inline void xfrm_dst_destroy(struct xfrm_dst *xdst)</span>
 	dst_release(xdst-&gt;route);
 	if (likely(xdst-&gt;u.dst.xfrm))
 		xfrm_state_put(xdst-&gt;u.dst.xfrm);
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	kfree(xdst-&gt;origin);</span>
<span class="p_del">-	xdst-&gt;origin = NULL;</span>
<span class="p_del">-	kfree(xdst-&gt;partner);</span>
<span class="p_del">-	xdst-&gt;partner = NULL;</span>
<span class="p_del">-#endif</span>
 }
 #endif
 
<span class="p_header">diff --git a/include/uapi/linux/ethtool.h b/include/uapi/linux/ethtool.h</span>
<span class="p_header">index 8e547231c1b7..5c22e8cab24b 100644</span>
<span class="p_header">--- a/include/uapi/linux/ethtool.h</span>
<span class="p_header">+++ b/include/uapi/linux/ethtool.h</span>
<span class="p_chunk">@@ -1368,6 +1368,8 @@</span> <span class="p_context"> enum ethtool_link_mode_bit_indices {</span>
 	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT	= 44,
 	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT	= 45,
 	ETHTOOL_LINK_MODE_10000baseER_Full_BIT	= 46,
<span class="p_add">+	ETHTOOL_LINK_MODE_2500baseT_Full_BIT	= 47,</span>
<span class="p_add">+	ETHTOOL_LINK_MODE_5000baseT_Full_BIT	= 48,</span>
 
 
 	/* Last allowed bit for __ETHTOOL_LINK_MODE_LEGACY_MASK is bit
<span class="p_chunk">@@ -1377,7 +1379,7 @@</span> <span class="p_context"> enum ethtool_link_mode_bit_indices {</span>
 	 */
 
 	__ETHTOOL_LINK_MODE_LAST
<span class="p_del">-	  = ETHTOOL_LINK_MODE_10000baseER_Full_BIT,</span>
<span class="p_add">+	  = ETHTOOL_LINK_MODE_5000baseT_Full_BIT,</span>
 };
 
 #define __ETHTOOL_LINK_MODE_LEGACY_MASK(base_name)	\
<span class="p_header">diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c</span>
<span class="p_header">index a2ac051c342f..f3721e150d94 100644</span>
<span class="p_header">--- a/kernel/bpf/arraymap.c</span>
<span class="p_header">+++ b/kernel/bpf/arraymap.c</span>
<span class="p_chunk">@@ -11,7 +11,6 @@</span> <span class="p_context"></span>
  */
 #include &lt;linux/bpf.h&gt;
 #include &lt;linux/err.h&gt;
<span class="p_del">-#include &lt;linux/vmalloc.h&gt;</span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/filter.h&gt;
<span class="p_chunk">@@ -74,14 +73,10 @@</span> <span class="p_context"> static struct bpf_map *array_map_alloc(union bpf_attr *attr)</span>
 	if (array_size &gt;= U32_MAX - PAGE_SIZE)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_del">-</span>
 	/* allocate all map elements and zero-initialize them */
<span class="p_del">-	array = kzalloc(array_size, GFP_USER | __GFP_NOWARN);</span>
<span class="p_del">-	if (!array) {</span>
<span class="p_del">-		array = vzalloc(array_size);</span>
<span class="p_del">-		if (!array)</span>
<span class="p_del">-			return ERR_PTR(-ENOMEM);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	array = bpf_map_area_alloc(array_size);</span>
<span class="p_add">+	if (!array)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
 
 	/* copy mandatory map attributes */
 	array-&gt;map.map_type = attr-&gt;map_type;
<span class="p_chunk">@@ -97,7 +92,7 @@</span> <span class="p_context"> static struct bpf_map *array_map_alloc(union bpf_attr *attr)</span>
 
 	if (array_size &gt;= U32_MAX - PAGE_SIZE ||
 	    elem_size &gt; PCPU_MIN_UNIT_SIZE || bpf_array_alloc_percpu(array)) {
<span class="p_del">-		kvfree(array);</span>
<span class="p_add">+		bpf_map_area_free(array);</span>
 		return ERR_PTR(-ENOMEM);
 	}
 out:
<span class="p_chunk">@@ -262,7 +257,7 @@</span> <span class="p_context"> static void array_map_free(struct bpf_map *map)</span>
 	if (array-&gt;map.map_type == BPF_MAP_TYPE_PERCPU_ARRAY)
 		bpf_array_free_percpu(array);
 
<span class="p_del">-	kvfree(array);</span>
<span class="p_add">+	bpf_map_area_free(array);</span>
 }
 
 static const struct bpf_map_ops array_ops = {
<span class="p_chunk">@@ -319,7 +314,8 @@</span> <span class="p_context"> static void fd_array_map_free(struct bpf_map *map)</span>
 	/* make sure it&#39;s empty */
 	for (i = 0; i &lt; array-&gt;map.max_entries; i++)
 		BUG_ON(array-&gt;ptrs[i] != NULL);
<span class="p_del">-	kvfree(array);</span>
<span class="p_add">+</span>
<span class="p_add">+	bpf_map_area_free(array);</span>
 }
 
 static void *fd_array_map_lookup_elem(struct bpf_map *map, void *key)
<span class="p_header">diff --git a/kernel/bpf/hashtab.c b/kernel/bpf/hashtab.c</span>
<span class="p_header">index ad1bc67aff1b..ad2f0ed75471 100644</span>
<span class="p_header">--- a/kernel/bpf/hashtab.c</span>
<span class="p_header">+++ b/kernel/bpf/hashtab.c</span>
<span class="p_chunk">@@ -13,7 +13,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/bpf.h&gt;
 #include &lt;linux/jhash.h&gt;
 #include &lt;linux/filter.h&gt;
<span class="p_del">-#include &lt;linux/vmalloc.h&gt;</span>
 #include &quot;percpu_freelist.h&quot;
 
 struct bucket {
<span class="p_chunk">@@ -84,14 +83,15 @@</span> <span class="p_context"> static void htab_free_elems(struct bpf_htab *htab)</span>
 		free_percpu(pptr);
 	}
 free_elems:
<span class="p_del">-	vfree(htab-&gt;elems);</span>
<span class="p_add">+	bpf_map_area_free(htab-&gt;elems);</span>
 }
 
 static int prealloc_elems_and_freelist(struct bpf_htab *htab)
 {
 	int err = -ENOMEM, i;
 
<span class="p_del">-	htab-&gt;elems = vzalloc(htab-&gt;elem_size * htab-&gt;map.max_entries);</span>
<span class="p_add">+	htab-&gt;elems = bpf_map_area_alloc(htab-&gt;elem_size *</span>
<span class="p_add">+					 htab-&gt;map.max_entries);</span>
 	if (!htab-&gt;elems)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -227,14 +227,10 @@</span> <span class="p_context"> static struct bpf_map *htab_map_alloc(union bpf_attr *attr)</span>
 		goto free_htab;
 
 	err = -ENOMEM;
<span class="p_del">-	htab-&gt;buckets = kmalloc_array(htab-&gt;n_buckets, sizeof(struct bucket),</span>
<span class="p_del">-				      GFP_USER | __GFP_NOWARN);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!htab-&gt;buckets) {</span>
<span class="p_del">-		htab-&gt;buckets = vmalloc(htab-&gt;n_buckets * sizeof(struct bucket));</span>
<span class="p_del">-		if (!htab-&gt;buckets)</span>
<span class="p_del">-			goto free_htab;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	htab-&gt;buckets = bpf_map_area_alloc(htab-&gt;n_buckets *</span>
<span class="p_add">+					   sizeof(struct bucket));</span>
<span class="p_add">+	if (!htab-&gt;buckets)</span>
<span class="p_add">+		goto free_htab;</span>
 
 	for (i = 0; i &lt; htab-&gt;n_buckets; i++) {
 		INIT_HLIST_HEAD(&amp;htab-&gt;buckets[i].head);
<span class="p_chunk">@@ -258,7 +254,7 @@</span> <span class="p_context"> static struct bpf_map *htab_map_alloc(union bpf_attr *attr)</span>
 free_extra_elems:
 	free_percpu(htab-&gt;extra_elems);
 free_buckets:
<span class="p_del">-	kvfree(htab-&gt;buckets);</span>
<span class="p_add">+	bpf_map_area_free(htab-&gt;buckets);</span>
 free_htab:
 	kfree(htab);
 	return ERR_PTR(err);
<span class="p_chunk">@@ -715,7 +711,7 @@</span> <span class="p_context"> static void htab_map_free(struct bpf_map *map)</span>
 		pcpu_freelist_destroy(&amp;htab-&gt;freelist);
 	}
 	free_percpu(htab-&gt;extra_elems);
<span class="p_del">-	kvfree(htab-&gt;buckets);</span>
<span class="p_add">+	bpf_map_area_free(htab-&gt;buckets);</span>
 	kfree(htab);
 }
 
<span class="p_header">diff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c</span>
<span class="p_header">index 732ae16d12b7..be8519148c25 100644</span>
<span class="p_header">--- a/kernel/bpf/stackmap.c</span>
<span class="p_header">+++ b/kernel/bpf/stackmap.c</span>
<span class="p_chunk">@@ -7,7 +7,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/bpf.h&gt;
 #include &lt;linux/jhash.h&gt;
 #include &lt;linux/filter.h&gt;
<span class="p_del">-#include &lt;linux/vmalloc.h&gt;</span>
 #include &lt;linux/stacktrace.h&gt;
 #include &lt;linux/perf_event.h&gt;
 #include &quot;percpu_freelist.h&quot;
<span class="p_chunk">@@ -32,7 +31,7 @@</span> <span class="p_context"> static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)</span>
 	u32 elem_size = sizeof(struct stack_map_bucket) + smap-&gt;map.value_size;
 	int err;
 
<span class="p_del">-	smap-&gt;elems = vzalloc(elem_size * smap-&gt;map.max_entries);</span>
<span class="p_add">+	smap-&gt;elems = bpf_map_area_alloc(elem_size * smap-&gt;map.max_entries);</span>
 	if (!smap-&gt;elems)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -45,7 +44,7 @@</span> <span class="p_context"> static int prealloc_elems_and_freelist(struct bpf_stack_map *smap)</span>
 	return 0;
 
 free_elems:
<span class="p_del">-	vfree(smap-&gt;elems);</span>
<span class="p_add">+	bpf_map_area_free(smap-&gt;elems);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -76,12 +75,9 @@</span> <span class="p_context"> static struct bpf_map *stack_map_alloc(union bpf_attr *attr)</span>
 	if (cost &gt;= U32_MAX - PAGE_SIZE)
 		return ERR_PTR(-E2BIG);
 
<span class="p_del">-	smap = kzalloc(cost, GFP_USER | __GFP_NOWARN);</span>
<span class="p_del">-	if (!smap) {</span>
<span class="p_del">-		smap = vzalloc(cost);</span>
<span class="p_del">-		if (!smap)</span>
<span class="p_del">-			return ERR_PTR(-ENOMEM);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	smap = bpf_map_area_alloc(cost);</span>
<span class="p_add">+	if (!smap)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
 
 	err = -E2BIG;
 	cost += n_buckets * (value_size + sizeof(struct stack_map_bucket));
<span class="p_chunk">@@ -112,7 +108,7 @@</span> <span class="p_context"> static struct bpf_map *stack_map_alloc(union bpf_attr *attr)</span>
 put_buffers:
 	put_callchain_buffers();
 free_smap:
<span class="p_del">-	kvfree(smap);</span>
<span class="p_add">+	bpf_map_area_free(smap);</span>
 	return ERR_PTR(err);
 }
 
<span class="p_chunk">@@ -262,9 +258,9 @@</span> <span class="p_context"> static void stack_map_free(struct bpf_map *map)</span>
 	/* wait for bpf programs to complete before freeing stack map */
 	synchronize_rcu();
 
<span class="p_del">-	vfree(smap-&gt;elems);</span>
<span class="p_add">+	bpf_map_area_free(smap-&gt;elems);</span>
 	pcpu_freelist_destroy(&amp;smap-&gt;freelist);
<span class="p_del">-	kvfree(smap);</span>
<span class="p_add">+	bpf_map_area_free(smap);</span>
 	put_callchain_buffers();
 }
 
<span class="p_header">diff --git a/kernel/bpf/syscall.c b/kernel/bpf/syscall.c</span>
<span class="p_header">index 237f3d6a7ddc..72ea91df71c9 100644</span>
<span class="p_header">--- a/kernel/bpf/syscall.c</span>
<span class="p_header">+++ b/kernel/bpf/syscall.c</span>
<span class="p_chunk">@@ -12,6 +12,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/bpf.h&gt;
 #include &lt;linux/syscalls.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mmzone.h&gt;</span>
 #include &lt;linux/anon_inodes.h&gt;
 #include &lt;linux/file.h&gt;
 #include &lt;linux/license.h&gt;
<span class="p_chunk">@@ -48,6 +50,30 @@</span> <span class="p_context"> void bpf_register_map_type(struct bpf_map_type_list *tl)</span>
 	list_add(&amp;tl-&gt;list_node, &amp;bpf_map_types);
 }
 
<span class="p_add">+void *bpf_map_area_alloc(size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* We definitely need __GFP_NORETRY, so OOM killer doesn&#39;t</span>
<span class="p_add">+	 * trigger under memory pressure as we really just want to</span>
<span class="p_add">+	 * fail instead.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	const gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;</span>
<span class="p_add">+	void *area;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &lt;= (PAGE_SIZE &lt;&lt; PAGE_ALLOC_COSTLY_ORDER)) {</span>
<span class="p_add">+		area = kmalloc(size, GFP_USER | flags);</span>
<span class="p_add">+		if (area != NULL)</span>
<span class="p_add">+			return area;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return __vmalloc(size, GFP_KERNEL | __GFP_HIGHMEM | flags,</span>
<span class="p_add">+			 PAGE_KERNEL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void bpf_map_area_free(void *area)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kvfree(area);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int bpf_map_precharge_memlock(u32 pages)
 {
 	struct user_struct *user = get_current_user();
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 11cc1d83c770..30ccc7029d18 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -2272,7 +2272,7 @@</span> <span class="p_context"> static int  __perf_install_in_context(void *info)</span>
 	struct perf_event_context *ctx = event-&gt;ctx;
 	struct perf_cpu_context *cpuctx = __get_cpu_context(ctx);
 	struct perf_event_context *task_ctx = cpuctx-&gt;task_ctx;
<span class="p_del">-	bool activate = true;</span>
<span class="p_add">+	bool reprogram = true;</span>
 	int ret = 0;
 
 	raw_spin_lock(&amp;cpuctx-&gt;ctx.lock);
<span class="p_chunk">@@ -2280,27 +2280,26 @@</span> <span class="p_context"> static int  __perf_install_in_context(void *info)</span>
 		raw_spin_lock(&amp;ctx-&gt;lock);
 		task_ctx = ctx;
 
<span class="p_del">-		/* If we&#39;re on the wrong CPU, try again */</span>
<span class="p_del">-		if (task_cpu(ctx-&gt;task) != smp_processor_id()) {</span>
<span class="p_del">-			ret = -ESRCH;</span>
<span class="p_del">-			goto unlock;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		reprogram = (ctx-&gt;task == current);</span>
 
 		/*
<span class="p_del">-		 * If we&#39;re on the right CPU, see if the task we target is</span>
<span class="p_del">-		 * current, if not we don&#39;t have to activate the ctx, a future</span>
<span class="p_del">-		 * context switch will do that for us.</span>
<span class="p_add">+		 * If the task is running, it must be running on this CPU,</span>
<span class="p_add">+		 * otherwise we cannot reprogram things.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * If its not running, we don&#39;t care, ctx-&gt;lock will</span>
<span class="p_add">+		 * serialize against it becoming runnable.</span>
 		 */
<span class="p_del">-		if (ctx-&gt;task != current)</span>
<span class="p_del">-			activate = false;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			WARN_ON_ONCE(cpuctx-&gt;task_ctx &amp;&amp; cpuctx-&gt;task_ctx != ctx);</span>
<span class="p_add">+		if (task_curr(ctx-&gt;task) &amp;&amp; !reprogram) {</span>
<span class="p_add">+			ret = -ESRCH;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 
<span class="p_add">+		WARN_ON_ONCE(reprogram &amp;&amp; cpuctx-&gt;task_ctx &amp;&amp; cpuctx-&gt;task_ctx != ctx);</span>
 	} else if (task_ctx) {
 		raw_spin_lock(&amp;task_ctx-&gt;lock);
 	}
 
<span class="p_del">-	if (activate) {</span>
<span class="p_add">+	if (reprogram) {</span>
 		ctx_sched_out(ctx, cpuctx, EVENT_TIME);
 		add_event_to_ctx(event, ctx);
 		ctx_resched(cpuctx, task_ctx);
<span class="p_chunk">@@ -2351,13 +2350,36 @@</span> <span class="p_context"> perf_install_in_context(struct perf_event_context *ctx,</span>
 	/*
 	 * Installing events is tricky because we cannot rely on ctx-&gt;is_active
 	 * to be set in case this is the nr_events 0 -&gt; 1 transition.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Instead we use task_curr(), which tells us if the task is running.</span>
<span class="p_add">+	 * However, since we use task_curr() outside of rq::lock, we can race</span>
<span class="p_add">+	 * against the actual state. This means the result can be wrong.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we get a false positive, we retry, this is harmless.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If we get a false negative, things are complicated. If we are after</span>
<span class="p_add">+	 * perf_event_context_sched_in() ctx::lock will serialize us, and the</span>
<span class="p_add">+	 * value must be correct. If we&#39;re before, it doesn&#39;t matter since</span>
<span class="p_add">+	 * perf_event_context_sched_in() will program the counter.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However, this hinges on the remote context switch having observed</span>
<span class="p_add">+	 * our task-&gt;perf_event_ctxp[] store, such that it will in fact take</span>
<span class="p_add">+	 * ctx::lock in perf_event_context_sched_in().</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We do this by task_function_call(), if the IPI fails to hit the task</span>
<span class="p_add">+	 * we know any future context switch of task must see the</span>
<span class="p_add">+	 * perf_event_ctpx[] store.</span>
 	 */
<span class="p_del">-again:</span>
<span class="p_add">+</span>
 	/*
<span class="p_del">-	 * Cannot use task_function_call() because we need to run on the task&#39;s</span>
<span class="p_del">-	 * CPU regardless of whether its current or not.</span>
<span class="p_add">+	 * This smp_mb() orders the task-&gt;perf_event_ctxp[] store with the</span>
<span class="p_add">+	 * task_cpu() load, such that if the IPI then does not find the task</span>
<span class="p_add">+	 * running, a future context switch of that task must observe the</span>
<span class="p_add">+	 * store.</span>
 	 */
<span class="p_del">-	if (!cpu_function_call(task_cpu(task), __perf_install_in_context, event))</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+again:</span>
<span class="p_add">+	if (!task_function_call(task, __perf_install_in_context, event))</span>
 		return;
 
 	raw_spin_lock_irq(&amp;ctx-&gt;lock);
<span class="p_chunk">@@ -2371,12 +2393,16 @@</span> <span class="p_context"> perf_install_in_context(struct perf_event_context *ctx,</span>
 		raw_spin_unlock_irq(&amp;ctx-&gt;lock);
 		return;
 	}
<span class="p_del">-	raw_spin_unlock_irq(&amp;ctx-&gt;lock);</span>
 	/*
<span class="p_del">-	 * Since !ctx-&gt;is_active doesn&#39;t mean anything, we must IPI</span>
<span class="p_del">-	 * unconditionally.</span>
<span class="p_add">+	 * If the task is not running, ctx-&gt;lock will avoid it becoming so,</span>
<span class="p_add">+	 * thus we can safely install the event.</span>
 	 */
<span class="p_del">-	goto again;</span>
<span class="p_add">+	if (task_curr(task)) {</span>
<span class="p_add">+		raw_spin_unlock_irq(&amp;ctx-&gt;lock);</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	add_event_to_ctx(event, ctx);</span>
<span class="p_add">+	raw_spin_unlock_irq(&amp;ctx-&gt;lock);</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/panic.c b/kernel/panic.c</span>
<span class="p_header">index e6480e20379e..dbec387099b1 100644</span>
<span class="p_header">--- a/kernel/panic.c</span>
<span class="p_header">+++ b/kernel/panic.c</span>
<span class="p_chunk">@@ -249,7 +249,7 @@</span> <span class="p_context"> void panic(const char *fmt, ...)</span>
 		 * Delay timeout seconds before rebooting the machine.
 		 * We can&#39;t use the &quot;normal&quot; timers since we just panicked.
 		 */
<span class="p_del">-		pr_emerg(&quot;Rebooting in %d seconds..&quot;, panic_timeout);</span>
<span class="p_add">+		pr_emerg(&quot;Rebooting in %d seconds..\n&quot;, panic_timeout);</span>
 
 		for (i = 0; i &lt; panic_timeout * 1000; i += PANIC_TIMER_STEP) {
 			touch_nmi_watchdog();
<span class="p_header">diff --git a/kernel/sched/loadavg.c b/kernel/sched/loadavg.c</span>
<span class="p_header">index a2d6eb71f06b..ec91fcc09bfe 100644</span>
<span class="p_header">--- a/kernel/sched/loadavg.c</span>
<span class="p_header">+++ b/kernel/sched/loadavg.c</span>
<span class="p_chunk">@@ -201,8 +201,9 @@</span> <span class="p_context"> void calc_load_exit_idle(void)</span>
 	struct rq *this_rq = this_rq();
 
 	/*
<span class="p_del">-	 * If we&#39;re still before the sample window, we&#39;re done.</span>
<span class="p_add">+	 * If we&#39;re still before the pending sample window, we&#39;re done.</span>
 	 */
<span class="p_add">+	this_rq-&gt;calc_load_update = calc_load_update;</span>
 	if (time_before(jiffies, this_rq-&gt;calc_load_update))
 		return;
 
<span class="p_chunk">@@ -211,7 +212,6 @@</span> <span class="p_context"> void calc_load_exit_idle(void)</span>
 	 * accounted through the nohz accounting, so skip the entire deal and
 	 * sync up for the next window.
 	 */
<span class="p_del">-	this_rq-&gt;calc_load_update = calc_load_update;</span>
 	if (time_before(jiffies, this_rq-&gt;calc_load_update + 10))
 		this_rq-&gt;calc_load_update += LOAD_FREQ;
 }
<span class="p_header">diff --git a/lib/swiotlb.c b/lib/swiotlb.c</span>
<span class="p_header">index ad1d2962d129..b7812df04437 100644</span>
<span class="p_header">--- a/lib/swiotlb.c</span>
<span class="p_header">+++ b/lib/swiotlb.c</span>
<span class="p_chunk">@@ -456,11 +456,11 @@</span> <span class="p_context"> phys_addr_t swiotlb_tbl_map_single(struct device *hwdev,</span>
 		    : 1UL &lt;&lt; (BITS_PER_LONG - IO_TLB_SHIFT);
 
 	/*
<span class="p_del">-	 * For mappings greater than a page, we limit the stride (and</span>
<span class="p_del">-	 * hence alignment) to a page size.</span>
<span class="p_add">+	 * For mappings greater than or equal to a page, we limit the stride</span>
<span class="p_add">+	 * (and hence alignment) to a page size.</span>
 	 */
 	nslots = ALIGN(size, 1 &lt;&lt; IO_TLB_SHIFT) &gt;&gt; IO_TLB_SHIFT;
<span class="p_del">-	if (size &gt; PAGE_SIZE)</span>
<span class="p_add">+	if (size &gt;= PAGE_SIZE)</span>
 		stride = (1 &lt;&lt; (PAGE_SHIFT - IO_TLB_SHIFT));
 	else
 		stride = 1;
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index d5b2b759f76f..e7d5db958538 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1227,8 +1227,11 @@</span> <span class="p_context"> int do_huge_pmd_numa_page(struct fault_env *fe, pmd_t pmd)</span>
 	 */
 	if (unlikely(pmd_trans_migrating(*fe-&gt;pmd))) {
 		page = pmd_page(*fe-&gt;pmd);
<span class="p_add">+		if (!get_page_unless_zero(page))</span>
<span class="p_add">+			goto out_unlock;</span>
 		spin_unlock(fe-&gt;ptl);
 		wait_on_page_locked(page);
<span class="p_add">+		put_page(page);</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -1260,8 +1263,11 @@</span> <span class="p_context"> int do_huge_pmd_numa_page(struct fault_env *fe, pmd_t pmd)</span>
 
 	/* Migration could have started since the pmd_trans_migrating check */
 	if (!page_locked) {
<span class="p_add">+		if (!get_page_unless_zero(page))</span>
<span class="p_add">+			goto out_unlock;</span>
 		spin_unlock(fe-&gt;ptl);
 		wait_on_page_locked(page);
<span class="p_add">+		put_page(page);</span>
 		page_nid = -1;
 		goto out;
 	}
<span class="p_header">diff --git a/mm/swap_cgroup.c b/mm/swap_cgroup.c</span>
<span class="p_header">index 454d6d7509ed..3405b4ee1757 100644</span>
<span class="p_header">--- a/mm/swap_cgroup.c</span>
<span class="p_header">+++ b/mm/swap_cgroup.c</span>
<span class="p_chunk">@@ -204,6 +204,8 @@</span> <span class="p_context"> void swap_cgroup_swapoff(int type)</span>
 			struct page *page = map[i];
 			if (page)
 				__free_page(page);
<span class="p_add">+			if (!(i % SWAP_CLUSTER_MAX))</span>
<span class="p_add">+				cond_resched();</span>
 		}
 		vfree(map);
 	}
<span class="p_header">diff --git a/mm/vmalloc.c b/mm/vmalloc.c</span>
<span class="p_header">index f2481cb4e6b2..195de42bea1f 100644</span>
<span class="p_header">--- a/mm/vmalloc.c</span>
<span class="p_header">+++ b/mm/vmalloc.c</span>
<span class="p_chunk">@@ -244,11 +244,21 @@</span> <span class="p_context"> struct page *vmalloc_to_page(const void *vmalloc_addr)</span>
 	 */
 	VIRTUAL_BUG_ON(!is_vmalloc_or_module_addr(vmalloc_addr));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t dereference bad PUD or PMD (below) entries. This will also</span>
<span class="p_add">+	 * identify huge mappings, which we may encounter on architectures</span>
<span class="p_add">+	 * that define CONFIG_HAVE_ARCH_HUGE_VMAP=y. Such regions will be</span>
<span class="p_add">+	 * identified as vmalloc addresses by is_vmalloc_addr(), but are</span>
<span class="p_add">+	 * not [unambiguously] associated with a struct page, so there is</span>
<span class="p_add">+	 * no correct value to return for them.</span>
<span class="p_add">+	 */</span>
 	if (!pgd_none(*pgd)) {
 		pud_t *pud = pud_offset(pgd, addr);
<span class="p_del">-		if (!pud_none(*pud)) {</span>
<span class="p_add">+		WARN_ON_ONCE(pud_bad(*pud));</span>
<span class="p_add">+		if (!pud_none(*pud) &amp;&amp; !pud_bad(*pud)) {</span>
 			pmd_t *pmd = pmd_offset(pud, addr);
<span class="p_del">-			if (!pmd_none(*pmd)) {</span>
<span class="p_add">+			WARN_ON_ONCE(pmd_bad(*pmd));</span>
<span class="p_add">+			if (!pmd_none(*pmd) &amp;&amp; !pmd_bad(*pmd)) {</span>
 				pte_t *ptep, pte;
 
 				ptep = pte_offset_map(pmd, addr);
<span class="p_header">diff --git a/net/8021q/vlan.c b/net/8021q/vlan.c</span>
<span class="p_header">index f2531ad66b68..8d213f974448 100644</span>
<span class="p_header">--- a/net/8021q/vlan.c</span>
<span class="p_header">+++ b/net/8021q/vlan.c</span>
<span class="p_chunk">@@ -277,7 +277,8 @@</span> <span class="p_context"> static int register_vlan_device(struct net_device *real_dev, u16 vlan_id)</span>
 	return 0;
 
 out_free_newdev:
<span class="p_del">-	free_netdev(new_dev);</span>
<span class="p_add">+	if (new_dev-&gt;reg_state == NETREG_UNINITIALIZED)</span>
<span class="p_add">+		free_netdev(new_dev);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/net/caif/cfpkt_skbuff.c b/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">index 59ce1fcc220c..71b6ab240dea 100644</span>
<span class="p_header">--- a/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">+++ b/net/caif/cfpkt_skbuff.c</span>
<span class="p_chunk">@@ -81,11 +81,7 @@</span> <span class="p_context"> static struct cfpkt *cfpkt_create_pfx(u16 len, u16 pfx)</span>
 {
 	struct sk_buff *skb;
 
<span class="p_del">-	if (likely(in_interrupt()))</span>
<span class="p_del">-		skb = alloc_skb(len + pfx, GFP_ATOMIC);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		skb = alloc_skb(len + pfx, GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_add">+	skb = alloc_skb(len + pfx, GFP_ATOMIC);</span>
 	if (unlikely(skb == NULL))
 		return NULL;
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 2e04fd188081..97f806116ae9 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -1250,8 +1250,9 @@</span> <span class="p_context"> int dev_set_alias(struct net_device *dev, const char *alias, size_t len)</span>
 	if (!new_ifalias)
 		return -ENOMEM;
 	dev-&gt;ifalias = new_ifalias;
<span class="p_add">+	memcpy(dev-&gt;ifalias, alias, len);</span>
<span class="p_add">+	dev-&gt;ifalias[len] = 0;</span>
 
<span class="p_del">-	strlcpy(dev-&gt;ifalias, alias, len+1);</span>
 	return len;
 }
 
<span class="p_header">diff --git a/net/core/dst.c b/net/core/dst.c</span>
<span class="p_header">index 656b70d39690..39cc11968cf9 100644</span>
<span class="p_header">--- a/net/core/dst.c</span>
<span class="p_header">+++ b/net/core/dst.c</span>
<span class="p_chunk">@@ -470,6 +470,20 @@</span> <span class="p_context"> static int dst_dev_event(struct notifier_block *this, unsigned long event,</span>
 		spin_lock_bh(&amp;dst_garbage.lock);
 		dst = dst_garbage.list;
 		dst_garbage.list = NULL;
<span class="p_add">+		/* The code in dst_ifdown places a hold on the loopback device.</span>
<span class="p_add">+		 * If the gc entry processing is set to expire after a lengthy</span>
<span class="p_add">+		 * interval, this hold can cause netdev_wait_allrefs() to hang</span>
<span class="p_add">+		 * out and wait for a long time -- until the the loopback</span>
<span class="p_add">+		 * interface is released.  If we&#39;re really unlucky, it&#39;ll emit</span>
<span class="p_add">+		 * pr_emerg messages to console too.  Reset the interval here,</span>
<span class="p_add">+		 * so dst cleanups occur in a more timely fashion.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (dst_garbage.timer_inc &gt; DST_GC_INC) {</span>
<span class="p_add">+			dst_garbage.timer_inc = DST_GC_INC;</span>
<span class="p_add">+			dst_garbage.timer_expires = DST_GC_MIN;</span>
<span class="p_add">+			mod_delayed_work(system_wq, &amp;dst_gc_work,</span>
<span class="p_add">+					 dst_garbage.timer_expires);</span>
<span class="p_add">+		}</span>
 		spin_unlock_bh(&amp;dst_garbage.lock);
 
 		if (last)
<span class="p_header">diff --git a/net/core/ethtool.c b/net/core/ethtool.c</span>
<span class="p_header">index 072c1f4998c9..e9989b835a66 100644</span>
<span class="p_header">--- a/net/core/ethtool.c</span>
<span class="p_header">+++ b/net/core/ethtool.c</span>
<span class="p_chunk">@@ -1704,7 +1704,7 @@</span> <span class="p_context"> static noinline_for_stack int ethtool_get_channels(struct net_device *dev,</span>
 static noinline_for_stack int ethtool_set_channels(struct net_device *dev,
 						   void __user *useraddr)
 {
<span class="p_del">-	struct ethtool_channels channels, max;</span>
<span class="p_add">+	struct ethtool_channels channels, max = { .cmd = ETHTOOL_GCHANNELS };</span>
 	u32 max_rx_in_use = 0;
 
 	if (!dev-&gt;ethtool_ops-&gt;set_channels || !dev-&gt;ethtool_ops-&gt;get_channels)
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 1d9160794e55..9c6fd7f83a4a 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -937,6 +937,7 @@</span> <span class="p_context"> static noinline size_t if_nlmsg_size(const struct net_device *dev,</span>
 	       + nla_total_size(1) /* IFLA_LINKMODE */
 	       + nla_total_size(4) /* IFLA_CARRIER_CHANGES */
 	       + nla_total_size(4) /* IFLA_LINK_NETNSID */
<span class="p_add">+	       + nla_total_size(4) /* IFLA_GROUP */</span>
 	       + nla_total_size(ext_filter_mask
 			        &amp; RTEXT_FILTER_VF ? 4 : 0) /* IFLA_NUM_VF */
 	       + rtnl_vfinfo_size(dev, ext_filter_mask) /* IFLA_VFINFO_LIST */
<span class="p_chunk">@@ -1130,6 +1131,8 @@</span> <span class="p_context"> static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,</span>
 	struct ifla_vf_mac vf_mac;
 	struct ifla_vf_info ivi;
 
<span class="p_add">+	memset(&amp;ivi, 0, sizeof(ivi));</span>
<span class="p_add">+</span>
 	/* Not all SR-IOV capable drivers support the
 	 * spoofcheck and &quot;RSS query enable&quot; query.  Preset to
 	 * -1 so the user space tool can detect that the driver
<span class="p_chunk">@@ -1138,7 +1141,6 @@</span> <span class="p_context"> static noinline_for_stack int rtnl_fill_vfinfo(struct sk_buff *skb,</span>
 	ivi.spoofchk = -1;
 	ivi.rss_query_en = -1;
 	ivi.trusted = -1;
<span class="p_del">-	memset(ivi.mac, 0, sizeof(ivi.mac));</span>
 	/* The default value for VF link state is &quot;auto&quot;
 	 * IFLA_VF_LINK_STATE_AUTO which equals zero
 	 */
<span class="p_chunk">@@ -1464,6 +1466,7 @@</span> <span class="p_context"> static const struct nla_policy ifla_policy[IFLA_MAX+1] = {</span>
 	[IFLA_LINK_NETNSID]	= { .type = NLA_S32 },
 	[IFLA_PROTO_DOWN]	= { .type = NLA_U8 },
 	[IFLA_XDP]		= { .type = NLA_NESTED },
<span class="p_add">+	[IFLA_GROUP]		= { .type = NLA_U32 },</span>
 };
 
 static const struct nla_policy ifla_info_policy[IFLA_INFO_MAX+1] = {
<span class="p_header">diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c</span>
<span class="p_header">index b1dc096d22f8..403593bd2b83 100644</span>
<span class="p_header">--- a/net/decnet/dn_route.c</span>
<span class="p_header">+++ b/net/decnet/dn_route.c</span>
<span class="p_chunk">@@ -188,12 +188,6 @@</span> <span class="p_context"> static inline void dnrt_free(struct dn_route *rt)</span>
 	call_rcu_bh(&amp;rt-&gt;dst.rcu_head, dst_rcu_free);
 }
 
<span class="p_del">-static inline void dnrt_drop(struct dn_route *rt)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dst_release(&amp;rt-&gt;dst);</span>
<span class="p_del">-	call_rcu_bh(&amp;rt-&gt;dst.rcu_head, dst_rcu_free);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void dn_dst_check_expire(unsigned long dummy)
 {
 	int i;
<span class="p_chunk">@@ -248,7 +242,7 @@</span> <span class="p_context"> static int dn_dst_gc(struct dst_ops *ops)</span>
 			}
 			*rtp = rt-&gt;dst.dn_next;
 			rt-&gt;dst.dn_next = NULL;
<span class="p_del">-			dnrt_drop(rt);</span>
<span class="p_add">+			dnrt_free(rt);</span>
 			break;
 		}
 		spin_unlock_bh(&amp;dn_rt_hash_table[i].lock);
<span class="p_chunk">@@ -350,7 +344,7 @@</span> <span class="p_context"> static int dn_insert_route(struct dn_route *rt, unsigned int hash, struct dn_rou</span>
 			dst_use(&amp;rth-&gt;dst, now);
 			spin_unlock_bh(&amp;dn_rt_hash_table[hash].lock);
 
<span class="p_del">-			dnrt_drop(rt);</span>
<span class="p_add">+			dst_free(&amp;rt-&gt;dst);</span>
 			*rp = rth;
 			return 0;
 		}
<span class="p_chunk">@@ -380,7 +374,7 @@</span> <span class="p_context"> static void dn_run_flush(unsigned long dummy)</span>
 		for(; rt; rt = next) {
 			next = rcu_dereference_raw(rt-&gt;dst.dn_next);
 			RCU_INIT_POINTER(rt-&gt;dst.dn_next, NULL);
<span class="p_del">-			dst_free((struct dst_entry *)rt);</span>
<span class="p_add">+			dnrt_free(rt);</span>
 		}
 
 nothing_to_declare:
<span class="p_chunk">@@ -1187,7 +1181,7 @@</span> <span class="p_context"> static int dn_route_output_slow(struct dst_entry **pprt, const struct flowidn *o</span>
 	if (dev_out-&gt;flags &amp; IFF_LOOPBACK)
 		flags |= RTCF_LOCAL;
 
<span class="p_del">-	rt = dst_alloc(&amp;dn_dst_ops, dev_out, 1, DST_OBSOLETE_NONE, DST_HOST);</span>
<span class="p_add">+	rt = dst_alloc(&amp;dn_dst_ops, dev_out, 0, DST_OBSOLETE_NONE, DST_HOST);</span>
 	if (rt == NULL)
 		goto e_nobufs;
 
<span class="p_header">diff --git a/net/decnet/netfilter/dn_rtmsg.c b/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_header">index 85f2fdc360c2..29246bc9a7b4 100644</span>
<span class="p_header">--- a/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_header">+++ b/net/decnet/netfilter/dn_rtmsg.c</span>
<span class="p_chunk">@@ -102,7 +102,9 @@</span> <span class="p_context"> static inline void dnrmg_receive_user_skb(struct sk_buff *skb)</span>
 {
 	struct nlmsghdr *nlh = nlmsg_hdr(skb);
 
<span class="p_del">-	if (nlh-&gt;nlmsg_len &lt; sizeof(*nlh) || skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span>
<span class="p_add">+	if (skb-&gt;len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+	    nlh-&gt;nlmsg_len &lt; sizeof(*nlh) ||</span>
<span class="p_add">+	    skb-&gt;len &lt; nlh-&gt;nlmsg_len)</span>
 		return;
 
 	if (!netlink_capable(skb, CAP_NET_ADMIN))
<span class="p_header">diff --git a/net/dsa/slave.c b/net/dsa/slave.c</span>
<span class="p_header">index 3ff9d97cf56b..079d76bc204c 100644</span>
<span class="p_header">--- a/net/dsa/slave.c</span>
<span class="p_header">+++ b/net/dsa/slave.c</span>
<span class="p_chunk">@@ -1103,10 +1103,8 @@</span> <span class="p_context"> static int dsa_slave_phy_connect(struct dsa_slave_priv *p,</span>
 	/* Use already configured phy mode */
 	if (p-&gt;phy_interface == PHY_INTERFACE_MODE_NA)
 		p-&gt;phy_interface = p-&gt;phy-&gt;interface;
<span class="p_del">-	phy_connect_direct(slave_dev, p-&gt;phy, dsa_slave_adjust_link,</span>
<span class="p_del">-			   p-&gt;phy_interface);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return phy_connect_direct(slave_dev, p-&gt;phy, dsa_slave_adjust_link,</span>
<span class="p_add">+				  p-&gt;phy_interface);</span>
 }
 
 static int dsa_slave_phy_setup(struct dsa_slave_priv *p,
<span class="p_header">diff --git a/net/ipv4/igmp.c b/net/ipv4/igmp.c</span>
<span class="p_header">index 1bc623d7f754..19930da56b0a 100644</span>
<span class="p_header">--- a/net/ipv4/igmp.c</span>
<span class="p_header">+++ b/net/ipv4/igmp.c</span>
<span class="p_chunk">@@ -1112,6 +1112,7 @@</span> <span class="p_context"> static void igmpv3_add_delrec(struct in_device *in_dev, struct ip_mc_list *im)</span>
 	pmc = kzalloc(sizeof(*pmc), GFP_KERNEL);
 	if (!pmc)
 		return;
<span class="p_add">+	spin_lock_init(&amp;pmc-&gt;lock);</span>
 	spin_lock_bh(&amp;im-&gt;lock);
 	pmc-&gt;interface = im-&gt;interface;
 	in_dev_hold(in_dev);
<span class="p_chunk">@@ -2071,21 +2072,26 @@</span> <span class="p_context"> static int ip_mc_add_src(struct in_device *in_dev, __be32 *pmca, int sfmode,</span>
 
 static void ip_mc_clear_src(struct ip_mc_list *pmc)
 {
<span class="p_del">-	struct ip_sf_list *psf, *nextpsf;</span>
<span class="p_add">+	struct ip_sf_list *psf, *nextpsf, *tomb, *sources;</span>
 
<span class="p_del">-	for (psf = pmc-&gt;tomb; psf; psf = nextpsf) {</span>
<span class="p_add">+	spin_lock_bh(&amp;pmc-&gt;lock);</span>
<span class="p_add">+	tomb = pmc-&gt;tomb;</span>
<span class="p_add">+	pmc-&gt;tomb = NULL;</span>
<span class="p_add">+	sources = pmc-&gt;sources;</span>
<span class="p_add">+	pmc-&gt;sources = NULL;</span>
<span class="p_add">+	pmc-&gt;sfmode = MCAST_EXCLUDE;</span>
<span class="p_add">+	pmc-&gt;sfcount[MCAST_INCLUDE] = 0;</span>
<span class="p_add">+	pmc-&gt;sfcount[MCAST_EXCLUDE] = 1;</span>
<span class="p_add">+	spin_unlock_bh(&amp;pmc-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (psf = tomb; psf; psf = nextpsf) {</span>
 		nextpsf = psf-&gt;sf_next;
 		kfree(psf);
 	}
<span class="p_del">-	pmc-&gt;tomb = NULL;</span>
<span class="p_del">-	for (psf = pmc-&gt;sources; psf; psf = nextpsf) {</span>
<span class="p_add">+	for (psf = sources; psf; psf = nextpsf) {</span>
 		nextpsf = psf-&gt;sf_next;
 		kfree(psf);
 	}
<span class="p_del">-	pmc-&gt;sources = NULL;</span>
<span class="p_del">-	pmc-&gt;sfmode = MCAST_EXCLUDE;</span>
<span class="p_del">-	pmc-&gt;sfcount[MCAST_INCLUDE] = 0;</span>
<span class="p_del">-	pmc-&gt;sfcount[MCAST_EXCLUDE] = 1;</span>
 }
 
 /* Join a multicast group
<span class="p_header">diff --git a/net/ipv4/netfilter.c b/net/ipv4/netfilter.c</span>
<span class="p_header">index b3cc1335adbc..c0cc6aa8cfaa 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter.c</span>
<span class="p_chunk">@@ -23,7 +23,8 @@</span> <span class="p_context"> int ip_route_me_harder(struct net *net, struct sk_buff *skb, unsigned int addr_t</span>
 	struct rtable *rt;
 	struct flowi4 fl4 = {};
 	__be32 saddr = iph-&gt;saddr;
<span class="p_del">-	__u8 flags = skb-&gt;sk ? inet_sk_flowi_flags(skb-&gt;sk) : 0;</span>
<span class="p_add">+	const struct sock *sk = skb_to_full_sk(skb);</span>
<span class="p_add">+	__u8 flags = sk ? inet_sk_flowi_flags(sk) : 0;</span>
 	struct net_device *dev = skb_dst(skb)-&gt;dev;
 	unsigned int hh_len;
 
<span class="p_chunk">@@ -40,7 +41,7 @@</span> <span class="p_context"> int ip_route_me_harder(struct net *net, struct sk_buff *skb, unsigned int addr_t</span>
 	fl4.daddr = iph-&gt;daddr;
 	fl4.saddr = saddr;
 	fl4.flowi4_tos = RT_TOS(iph-&gt;tos);
<span class="p_del">-	fl4.flowi4_oif = skb-&gt;sk ? skb-&gt;sk-&gt;sk_bound_dev_if : 0;</span>
<span class="p_add">+	fl4.flowi4_oif = sk ? sk-&gt;sk_bound_dev_if : 0;</span>
 	if (!fl4.flowi4_oif)
 		fl4.flowi4_oif = l3mdev_master_ifindex(dev);
 	fl4.flowi4_mark = skb-&gt;mark;
<span class="p_chunk">@@ -61,7 +62,7 @@</span> <span class="p_context"> int ip_route_me_harder(struct net *net, struct sk_buff *skb, unsigned int addr_t</span>
 	    xfrm_decode_session(skb, flowi4_to_flowi(&amp;fl4), AF_INET) == 0) {
 		struct dst_entry *dst = skb_dst(skb);
 		skb_dst_set(skb, NULL);
<span class="p_del">-		dst = xfrm_lookup(net, dst, flowi4_to_flowi(&amp;fl4), skb-&gt;sk, 0);</span>
<span class="p_add">+		dst = xfrm_lookup(net, dst, flowi4_to_flowi(&amp;fl4), sk, 0);</span>
 		if (IS_ERR(dst))
 			return PTR_ERR(dst);
 		skb_dst_set(skb, dst);
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 045738319e8b..b6f4c42cc8ce 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -315,9 +315,9 @@</span> <span class="p_context"> static void addrconf_mod_rs_timer(struct inet6_dev *idev,</span>
 static void addrconf_mod_dad_work(struct inet6_ifaddr *ifp,
 				   unsigned long delay)
 {
<span class="p_del">-	if (!delayed_work_pending(&amp;ifp-&gt;dad_work))</span>
<span class="p_del">-		in6_ifa_hold(ifp);</span>
<span class="p_del">-	mod_delayed_work(addrconf_wq, &amp;ifp-&gt;dad_work, delay);</span>
<span class="p_add">+	in6_ifa_hold(ifp);</span>
<span class="p_add">+	if (mod_delayed_work(addrconf_wq, &amp;ifp-&gt;dad_work, delay))</span>
<span class="p_add">+		in6_ifa_put(ifp);</span>
 }
 
 static int snmp6_alloc_dev(struct inet6_dev *idev)
<span class="p_header">diff --git a/net/ipv6/fib6_rules.c b/net/ipv6/fib6_rules.c</span>
<span class="p_header">index eea23b57c6a5..ec849d88a662 100644</span>
<span class="p_header">--- a/net/ipv6/fib6_rules.c</span>
<span class="p_header">+++ b/net/ipv6/fib6_rules.c</span>
<span class="p_chunk">@@ -32,7 +32,6 @@</span> <span class="p_context"> struct fib6_rule {</span>
 struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,
 				   int flags, pol_lookup_t lookup)
 {
<span class="p_del">-	struct rt6_info *rt;</span>
 	struct fib_lookup_arg arg = {
 		.lookup_ptr = lookup,
 		.flags = FIB_LOOKUP_NOREF,
<span class="p_chunk">@@ -44,21 +43,11 @@</span> <span class="p_context"> struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,</span>
 	fib_rules_lookup(net-&gt;ipv6.fib6_rules_ops,
 			 flowi6_to_flowi(fl6), flags, &amp;arg);
 
<span class="p_del">-	rt = arg.result;</span>
<span class="p_add">+	if (arg.result)</span>
<span class="p_add">+		return arg.result;</span>
 
<span class="p_del">-	if (!rt) {</span>
<span class="p_del">-		dst_hold(&amp;net-&gt;ipv6.ip6_null_entry-&gt;dst);</span>
<span class="p_del">-		return &amp;net-&gt;ipv6.ip6_null_entry-&gt;dst;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (rt-&gt;rt6i_flags &amp; RTF_REJECT &amp;&amp;</span>
<span class="p_del">-	    rt-&gt;dst.error == -EAGAIN) {</span>
<span class="p_del">-		ip6_rt_put(rt);</span>
<span class="p_del">-		rt = net-&gt;ipv6.ip6_null_entry;</span>
<span class="p_del">-		dst_hold(&amp;rt-&gt;dst);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;rt-&gt;dst;</span>
<span class="p_add">+	dst_hold(&amp;net-&gt;ipv6.ip6_null_entry-&gt;dst);</span>
<span class="p_add">+	return &amp;net-&gt;ipv6.ip6_null_entry-&gt;dst;</span>
 }
 
 static int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,
<span class="p_chunk">@@ -121,7 +110,8 @@</span> <span class="p_context"> static int fib6_rule_action(struct fib_rule *rule, struct flowi *flp,</span>
 			flp6-&gt;saddr = saddr;
 		}
 		err = rt-&gt;dst.error;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		if (err != -EAGAIN)</span>
<span class="p_add">+			goto out;</span>
 	}
 again:
 	ip6_rt_put(rt);
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index 8c88a37392d0..636d4d893085 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -289,8 +289,7 @@</span> <span class="p_context"> struct dst_entry *fib6_rule_lookup(struct net *net, struct flowi6 *fl6,</span>
 	struct rt6_info *rt;
 
 	rt = lookup(net, net-&gt;ipv6.fib6_main_tbl, fl6, flags);
<span class="p_del">-	if (rt-&gt;rt6i_flags &amp; RTF_REJECT &amp;&amp;</span>
<span class="p_del">-	    rt-&gt;dst.error == -EAGAIN) {</span>
<span class="p_add">+	if (rt-&gt;dst.error == -EAGAIN) {</span>
 		ip6_rt_put(rt);
 		rt = net-&gt;ipv6.ip6_null_entry;
 		dst_hold(&amp;rt-&gt;dst);
<span class="p_header">diff --git a/net/ipv6/ip6_gre.c b/net/ipv6/ip6_gre.c</span>
<span class="p_header">index 0a5922055da2..d2844ee469cb 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_gre.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_gre.c</span>
<span class="p_chunk">@@ -542,11 +542,10 @@</span> <span class="p_context"> static inline int ip6gre_xmit_ipv4(struct sk_buff *skb, struct net_device *dev)</span>
 
 	memcpy(&amp;fl6, &amp;t-&gt;fl.u.ip6, sizeof(fl6));
 
<span class="p_del">-	dsfield = ipv4_get_dsfield(iph);</span>
<span class="p_del">-</span>
 	if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_TCLASS)
<span class="p_del">-		fl6.flowlabel |= htonl((__u32)iph-&gt;tos &lt;&lt; IPV6_TCLASS_SHIFT)</span>
<span class="p_del">-					  &amp; IPV6_TCLASS_MASK;</span>
<span class="p_add">+		dsfield = ipv4_get_dsfield(iph);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dsfield = ip6_tclass(t-&gt;parms.flowinfo);</span>
 	if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_FWMARK)
 		fl6.flowi6_mark = skb-&gt;mark;
 
<span class="p_chunk">@@ -582,6 +581,9 @@</span> <span class="p_context"> static inline int ip6gre_xmit_ipv6(struct sk_buff *skb, struct net_device *dev)</span>
 		return -1;
 
 	offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
<span class="p_add">+	/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb-&gt;head */</span>
<span class="p_add">+	ipv6h = ipv6_hdr(skb);</span>
<span class="p_add">+</span>
 	if (offset &gt; 0) {
 		struct ipv6_tlv_tnl_enc_lim *tel;
 		tel = (struct ipv6_tlv_tnl_enc_lim *)&amp;skb_network_header(skb)[offset];
<span class="p_chunk">@@ -596,9 +598,11 @@</span> <span class="p_context"> static inline int ip6gre_xmit_ipv6(struct sk_buff *skb, struct net_device *dev)</span>
 
 	memcpy(&amp;fl6, &amp;t-&gt;fl.u.ip6, sizeof(fl6));
 
<span class="p_del">-	dsfield = ipv6_get_dsfield(ipv6h);</span>
 	if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_TCLASS)
<span class="p_del">-		fl6.flowlabel |= (*(__be32 *) ipv6h &amp; IPV6_TCLASS_MASK);</span>
<span class="p_add">+		dsfield = ipv6_get_dsfield(ipv6h);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dsfield = ip6_tclass(t-&gt;parms.flowinfo);</span>
<span class="p_add">+</span>
 	if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_FLOWLABEL)
 		fl6.flowlabel |= ip6_flowlabel(ipv6h);
 	if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_FWMARK)
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 3ab32ac57ccd..fd649599620e 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1020,8 +1020,10 @@</span> <span class="p_context"> static int ip6_dst_lookup_tail(struct net *net, const struct sock *sk,</span>
 	}
 #endif
 	if (ipv6_addr_v4mapped(&amp;fl6-&gt;saddr) &amp;&amp;
<span class="p_del">-	    !(ipv6_addr_v4mapped(&amp;fl6-&gt;daddr) || ipv6_addr_any(&amp;fl6-&gt;daddr)))</span>
<span class="p_del">-		return -EAFNOSUPPORT;</span>
<span class="p_add">+	    !(ipv6_addr_v4mapped(&amp;fl6-&gt;daddr) || ipv6_addr_any(&amp;fl6-&gt;daddr))) {</span>
<span class="p_add">+		err = -EAFNOSUPPORT;</span>
<span class="p_add">+		goto out_err_release;</span>
<span class="p_add">+	}</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index 116b4da06820..1fc9daa7b1d6 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -1196,7 +1196,7 @@</span> <span class="p_context"> int ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev, __u8 dsfield,</span>
 	skb_push(skb, sizeof(struct ipv6hdr));
 	skb_reset_network_header(skb);
 	ipv6h = ipv6_hdr(skb);
<span class="p_del">-	ip6_flow_hdr(ipv6h, INET_ECN_encapsulate(0, dsfield),</span>
<span class="p_add">+	ip6_flow_hdr(ipv6h, dsfield,</span>
 		     ip6_make_flowlabel(net, skb, fl6-&gt;flowlabel, true, fl6));
 	ipv6h-&gt;hop_limit = hop_limit;
 	ipv6h-&gt;nexthdr = proto;
<span class="p_chunk">@@ -1231,8 +1231,6 @@</span> <span class="p_context"> ip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if (tproto != IPPROTO_IPIP &amp;&amp; tproto != 0)
 		return -1;
 
<span class="p_del">-	dsfield = ipv4_get_dsfield(iph);</span>
<span class="p_del">-</span>
 	if (t-&gt;parms.collect_md) {
 		struct ip_tunnel_info *tun_info;
 		const struct ip_tunnel_key *key;
<span class="p_chunk">@@ -1246,6 +1244,7 @@</span> <span class="p_context"> ip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		fl6.flowi6_proto = IPPROTO_IPIP;
 		fl6.daddr = key-&gt;u.ipv6.dst;
 		fl6.flowlabel = key-&gt;label;
<span class="p_add">+		dsfield = ip6_tclass(key-&gt;label);</span>
 	} else {
 		if (!(t-&gt;parms.flags &amp; IP6_TNL_F_IGN_ENCAP_LIMIT))
 			encap_limit = t-&gt;parms.encap_limit;
<span class="p_chunk">@@ -1254,8 +1253,9 @@</span> <span class="p_context"> ip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		fl6.flowi6_proto = IPPROTO_IPIP;
 
 		if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_TCLASS)
<span class="p_del">-			fl6.flowlabel |= htonl((__u32)iph-&gt;tos &lt;&lt; IPV6_TCLASS_SHIFT)</span>
<span class="p_del">-					 &amp; IPV6_TCLASS_MASK;</span>
<span class="p_add">+			dsfield = ipv4_get_dsfield(iph);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dsfield = ip6_tclass(t-&gt;parms.flowinfo);</span>
 		if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_FWMARK)
 			fl6.flowi6_mark = skb-&gt;mark;
 	}
<span class="p_chunk">@@ -1263,6 +1263,8 @@</span> <span class="p_context"> ip4ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
 		return -1;
 
<span class="p_add">+	dsfield = INET_ECN_encapsulate(dsfield, ipv4_get_dsfield(iph));</span>
<span class="p_add">+</span>
 	skb_set_inner_ipproto(skb, IPPROTO_IPIP);
 
 	err = ip6_tnl_xmit(skb, dev, dsfield, &amp;fl6, encap_limit, &amp;mtu,
<span class="p_chunk">@@ -1296,8 +1298,6 @@</span> <span class="p_context"> ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	    ip6_tnl_addr_conflict(t, ipv6h))
 		return -1;
 
<span class="p_del">-	dsfield = ipv6_get_dsfield(ipv6h);</span>
<span class="p_del">-</span>
 	if (t-&gt;parms.collect_md) {
 		struct ip_tunnel_info *tun_info;
 		const struct ip_tunnel_key *key;
<span class="p_chunk">@@ -1311,8 +1311,11 @@</span> <span class="p_context"> ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		fl6.flowi6_proto = IPPROTO_IPV6;
 		fl6.daddr = key-&gt;u.ipv6.dst;
 		fl6.flowlabel = key-&gt;label;
<span class="p_add">+		dsfield = ip6_tclass(key-&gt;label);</span>
 	} else {
 		offset = ip6_tnl_parse_tlv_enc_lim(skb, skb_network_header(skb));
<span class="p_add">+		/* ip6_tnl_parse_tlv_enc_lim() might have reallocated skb-&gt;head */</span>
<span class="p_add">+		ipv6h = ipv6_hdr(skb);</span>
 		if (offset &gt; 0) {
 			struct ipv6_tlv_tnl_enc_lim *tel;
 
<span class="p_chunk">@@ -1331,7 +1334,9 @@</span> <span class="p_context"> ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		fl6.flowi6_proto = IPPROTO_IPV6;
 
 		if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_TCLASS)
<span class="p_del">-			fl6.flowlabel |= (*(__be32 *)ipv6h &amp; IPV6_TCLASS_MASK);</span>
<span class="p_add">+			dsfield = ipv6_get_dsfield(ipv6h);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dsfield = ip6_tclass(t-&gt;parms.flowinfo);</span>
 		if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_FLOWLABEL)
 			fl6.flowlabel |= ip6_flowlabel(ipv6h);
 		if (t-&gt;parms.flags &amp; IP6_TNL_F_USE_ORIG_FWMARK)
<span class="p_chunk">@@ -1341,6 +1346,8 @@</span> <span class="p_context"> ip6ip6_tnl_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if (iptunnel_handle_offloads(skb, SKB_GSO_IPXIP6))
 		return -1;
 
<span class="p_add">+	dsfield = INET_ECN_encapsulate(dsfield, ipv6_get_dsfield(ipv6h));</span>
<span class="p_add">+</span>
 	skb_set_inner_ipproto(skb, IPPROTO_IPV6);
 
 	err = ip6_tnl_xmit(skb, dev, dsfield, &amp;fl6, encap_limit, &amp;mtu,
<span class="p_header">diff --git a/net/ipv6/proc.c b/net/ipv6/proc.c</span>
<span class="p_header">index cc8e3ae9ca73..e88bcb8ff0fd 100644</span>
<span class="p_header">--- a/net/ipv6/proc.c</span>
<span class="p_header">+++ b/net/ipv6/proc.c</span>
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> static void snmp6_seq_show_item64(struct seq_file *seq, void __percpu *mib,</span>
 	u64 buff64[SNMP_MIB_MAX];
 	int i;
 
<span class="p_del">-	memset(buff64, 0, sizeof(unsigned long) * SNMP_MIB_MAX);</span>
<span class="p_add">+	memset(buff64, 0, sizeof(u64) * SNMP_MIB_MAX);</span>
 
 	snmp_get_cpu_field64_batch(buff64, itemlist, mib, syncpoff);
 	for (i = 0; itemlist[i].name; i++)
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index f9c9ecb0cdd3..e67c28e614b9 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -1135,6 +1135,7 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 			goto out;
 	}
 
<span class="p_add">+	err = -ENOBUFS;</span>
 	key = ext_hdrs[SADB_EXT_KEY_AUTH - 1];
 	if (sa-&gt;sadb_sa_auth) {
 		int keysize = 0;
<span class="p_chunk">@@ -1146,8 +1147,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 		if (key)
 			keysize = (key-&gt;sadb_key_bits + 7) / 8;
 		x-&gt;aalg = kmalloc(sizeof(*x-&gt;aalg) + keysize, GFP_KERNEL);
<span class="p_del">-		if (!x-&gt;aalg)</span>
<span class="p_add">+		if (!x-&gt;aalg) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
 			goto out;
<span class="p_add">+		}</span>
 		strcpy(x-&gt;aalg-&gt;alg_name, a-&gt;name);
 		x-&gt;aalg-&gt;alg_key_len = 0;
 		if (key) {
<span class="p_chunk">@@ -1166,8 +1169,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 				goto out;
 			}
 			x-&gt;calg = kmalloc(sizeof(*x-&gt;calg), GFP_KERNEL);
<span class="p_del">-			if (!x-&gt;calg)</span>
<span class="p_add">+			if (!x-&gt;calg) {</span>
<span class="p_add">+				err = -ENOMEM;</span>
 				goto out;
<span class="p_add">+			}</span>
 			strcpy(x-&gt;calg-&gt;alg_name, a-&gt;name);
 			x-&gt;props.calgo = sa-&gt;sadb_sa_encrypt;
 		} else {
<span class="p_chunk">@@ -1181,8 +1186,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 			if (key)
 				keysize = (key-&gt;sadb_key_bits + 7) / 8;
 			x-&gt;ealg = kmalloc(sizeof(*x-&gt;ealg) + keysize, GFP_KERNEL);
<span class="p_del">-			if (!x-&gt;ealg)</span>
<span class="p_add">+			if (!x-&gt;ealg) {</span>
<span class="p_add">+				err = -ENOMEM;</span>
 				goto out;
<span class="p_add">+			}</span>
 			strcpy(x-&gt;ealg-&gt;alg_name, a-&gt;name);
 			x-&gt;ealg-&gt;alg_key_len = 0;
 			if (key) {
<span class="p_chunk">@@ -1227,8 +1234,10 @@</span> <span class="p_context"> static struct xfrm_state * pfkey_msg2xfrm_state(struct net *net,</span>
 		struct xfrm_encap_tmpl *natt;
 
 		x-&gt;encap = kmalloc(sizeof(*x-&gt;encap), GFP_KERNEL);
<span class="p_del">-		if (!x-&gt;encap)</span>
<span class="p_add">+		if (!x-&gt;encap) {</span>
<span class="p_add">+			err = -ENOMEM;</span>
 			goto out;
<span class="p_add">+		}</span>
 
 		natt = x-&gt;encap;
 		n_type = ext_hdrs[SADB_X_EXT_NAT_T_TYPE-1];
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index e702cb95b89b..3bce65183c95 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -278,6 +278,55 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_find(struct net *net, struct l2tp_tunnel *tunn</span>
 }
 EXPORT_SYMBOL_GPL(l2tp_session_find);
 
<span class="p_add">+/* Like l2tp_session_find() but takes a reference on the returned session.</span>
<span class="p_add">+ * Optionally calls session-&gt;ref() too if do_ref is true.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get(struct net *net,</span>
<span class="p_add">+				      struct l2tp_tunnel *tunnel,</span>
<span class="p_add">+				      u32 session_id, bool do_ref)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hlist_head *session_list;</span>
<span class="p_add">+	struct l2tp_session *session;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tunnel) {</span>
<span class="p_add">+		struct l2tp_net *pn = l2tp_pernet(net);</span>
<span class="p_add">+</span>
<span class="p_add">+		session_list = l2tp_session_id_hash_2(pn, session_id);</span>
<span class="p_add">+</span>
<span class="p_add">+		rcu_read_lock_bh();</span>
<span class="p_add">+		hlist_for_each_entry_rcu(session, session_list, global_hlist) {</span>
<span class="p_add">+			if (session-&gt;session_id == session_id) {</span>
<span class="p_add">+				l2tp_session_inc_refcount(session);</span>
<span class="p_add">+				if (do_ref &amp;&amp; session-&gt;ref)</span>
<span class="p_add">+					session-&gt;ref(session);</span>
<span class="p_add">+				rcu_read_unlock_bh();</span>
<span class="p_add">+</span>
<span class="p_add">+				return session;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		rcu_read_unlock_bh();</span>
<span class="p_add">+</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	session_list = l2tp_session_id_hash(tunnel, session_id);</span>
<span class="p_add">+	read_lock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_add">+	hlist_for_each_entry(session, session_list, hlist) {</span>
<span class="p_add">+		if (session-&gt;session_id == session_id) {</span>
<span class="p_add">+			l2tp_session_inc_refcount(session);</span>
<span class="p_add">+			if (do_ref &amp;&amp; session-&gt;ref)</span>
<span class="p_add">+				session-&gt;ref(session);</span>
<span class="p_add">+			read_unlock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			return session;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	read_unlock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(l2tp_session_get);</span>
<span class="p_add">+</span>
 struct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth,
 					  bool do_ref)
 {
<span class="p_chunk">@@ -307,7 +356,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_session_get_nth);</span>
 /* Lookup a session by interface name.
  * This is very inefficient but is only used by management interfaces.
  */
<span class="p_del">-struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname)</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get_by_ifname(struct net *net, char *ifname,</span>
<span class="p_add">+						bool do_ref)</span>
 {
 	struct l2tp_net *pn = l2tp_pernet(net);
 	int hash;
<span class="p_chunk">@@ -317,7 +367,11 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname)</span>
 	for (hash = 0; hash &lt; L2TP_HASH_SIZE_2; hash++) {
 		hlist_for_each_entry_rcu(session, &amp;pn-&gt;l2tp_session_hlist[hash], global_hlist) {
 			if (!strcmp(session-&gt;ifname, ifname)) {
<span class="p_add">+				l2tp_session_inc_refcount(session);</span>
<span class="p_add">+				if (do_ref &amp;&amp; session-&gt;ref)</span>
<span class="p_add">+					session-&gt;ref(session);</span>
 				rcu_read_unlock_bh();
<span class="p_add">+</span>
 				return session;
 			}
 		}
<span class="p_chunk">@@ -327,7 +381,49 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname)</span>
 
 	return NULL;
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(l2tp_session_find_by_ifname);</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(l2tp_session_get_by_ifname);</span>
<span class="p_add">+</span>
<span class="p_add">+static int l2tp_session_add_to_tunnel(struct l2tp_tunnel *tunnel,</span>
<span class="p_add">+				      struct l2tp_session *session)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct l2tp_session *session_walk;</span>
<span class="p_add">+	struct hlist_head *g_head;</span>
<span class="p_add">+	struct hlist_head *head;</span>
<span class="p_add">+	struct l2tp_net *pn;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = l2tp_session_id_hash(tunnel, session-&gt;session_id);</span>
<span class="p_add">+</span>
<span class="p_add">+	write_lock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_add">+	hlist_for_each_entry(session_walk, head, hlist)</span>
<span class="p_add">+		if (session_walk-&gt;session_id == session-&gt;session_id)</span>
<span class="p_add">+			goto exist;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tunnel-&gt;version == L2TP_HDR_VER_3) {</span>
<span class="p_add">+		pn = l2tp_pernet(tunnel-&gt;l2tp_net);</span>
<span class="p_add">+		g_head = l2tp_session_id_hash_2(l2tp_pernet(tunnel-&gt;l2tp_net),</span>
<span class="p_add">+						session-&gt;session_id);</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);</span>
<span class="p_add">+		hlist_for_each_entry(session_walk, g_head, global_hlist)</span>
<span class="p_add">+			if (session_walk-&gt;session_id == session-&gt;session_id)</span>
<span class="p_add">+				goto exist_glob;</span>
<span class="p_add">+</span>
<span class="p_add">+		hlist_add_head_rcu(&amp;session-&gt;global_hlist, g_head);</span>
<span class="p_add">+		spin_unlock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hlist_add_head(&amp;session-&gt;hlist, head);</span>
<span class="p_add">+	write_unlock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+exist_glob:</span>
<span class="p_add">+	spin_unlock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);</span>
<span class="p_add">+exist:</span>
<span class="p_add">+	write_unlock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EEXIST;</span>
<span class="p_add">+}</span>
 
 /* Lookup a tunnel by id
  */
<span class="p_chunk">@@ -637,6 +733,9 @@</span> <span class="p_context"> static int l2tp_recv_data_seq(struct l2tp_session *session, struct sk_buff *skb)</span>
  * a data (not control) frame before coming here. Fields up to the
  * session-id have already been parsed and ptr points to the data
  * after the session-id.
<span class="p_add">+ *</span>
<span class="p_add">+ * session-&gt;ref() must have been called prior to l2tp_recv_common().</span>
<span class="p_add">+ * session-&gt;deref() will be called automatically after skb is processed.</span>
  */
 void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,
 		      unsigned char *ptr, unsigned char *optr, u16 hdrflags,
<span class="p_chunk">@@ -646,14 +745,6 @@</span> <span class="p_context"> void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,</span>
 	int offset;
 	u32 ns, nr;
 
<span class="p_del">-	/* The ref count is increased since we now hold a pointer to</span>
<span class="p_del">-	 * the session. Take care to decrement the refcnt when exiting</span>
<span class="p_del">-	 * this function from now on...</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	l2tp_session_inc_refcount(session);</span>
<span class="p_del">-	if (session-&gt;ref)</span>
<span class="p_del">-		(*session-&gt;ref)(session);</span>
<span class="p_del">-</span>
 	/* Parse and check optional cookie */
 	if (session-&gt;peer_cookie_len &gt; 0) {
 		if (memcmp(ptr, &amp;session-&gt;peer_cookie[0], session-&gt;peer_cookie_len)) {
<span class="p_chunk">@@ -806,8 +897,6 @@</span> <span class="p_context"> void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,</span>
 	/* Try to dequeue as many skbs from reorder_q as we can. */
 	l2tp_recv_dequeue(session);
 
<span class="p_del">-	l2tp_session_dec_refcount(session);</span>
<span class="p_del">-</span>
 	return;
 
 discard:
<span class="p_chunk">@@ -816,8 +905,6 @@</span> <span class="p_context"> void l2tp_recv_common(struct l2tp_session *session, struct sk_buff *skb,</span>
 
 	if (session-&gt;deref)
 		(*session-&gt;deref)(session);
<span class="p_del">-</span>
<span class="p_del">-	l2tp_session_dec_refcount(session);</span>
 }
 EXPORT_SYMBOL(l2tp_recv_common);
 
<span class="p_chunk">@@ -924,8 +1011,14 @@</span> <span class="p_context"> static int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb,</span>
 	}
 
 	/* Find the session context */
<span class="p_del">-	session = l2tp_session_find(tunnel-&gt;l2tp_net, tunnel, session_id);</span>
<span class="p_add">+	session = l2tp_session_get(tunnel-&gt;l2tp_net, tunnel, session_id, true);</span>
 	if (!session || !session-&gt;recv_skb) {
<span class="p_add">+		if (session) {</span>
<span class="p_add">+			if (session-&gt;deref)</span>
<span class="p_add">+				session-&gt;deref(session);</span>
<span class="p_add">+			l2tp_session_dec_refcount(session);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Not found? Pass to userspace to deal with */
 		l2tp_info(tunnel, L2TP_MSG_DATA,
 			  &quot;%s: no session found (%u/%u). Passing up.\n&quot;,
<span class="p_chunk">@@ -934,6 +1027,7 @@</span> <span class="p_context"> static int l2tp_udp_recv_core(struct l2tp_tunnel *tunnel, struct sk_buff *skb,</span>
 	}
 
 	l2tp_recv_common(session, skb, ptr, optr, hdrflags, length, payload_hook);
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
 
 	return 0;
 
<span class="p_chunk">@@ -1740,6 +1834,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_session_set_header_len);</span>
 struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunnel, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)
 {
 	struct l2tp_session *session;
<span class="p_add">+	int err;</span>
 
 	session = kzalloc(sizeof(struct l2tp_session) + priv_size, GFP_KERNEL);
 	if (session != NULL) {
<span class="p_chunk">@@ -1795,6 +1890,13 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 
 		l2tp_session_set_header_len(session, tunnel-&gt;version);
 
<span class="p_add">+		err = l2tp_session_add_to_tunnel(tunnel, session);</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			kfree(session);</span>
<span class="p_add">+</span>
<span class="p_add">+			return ERR_PTR(err);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Bump the reference count. The session context is deleted
 		 * only when this drops to zero.
 		 */
<span class="p_chunk">@@ -1804,28 +1906,14 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 		/* Ensure tunnel socket isn&#39;t deleted */
 		sock_hold(tunnel-&gt;sock);
 
<span class="p_del">-		/* Add session to the tunnel&#39;s hash list */</span>
<span class="p_del">-		write_lock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_del">-		hlist_add_head(&amp;session-&gt;hlist,</span>
<span class="p_del">-			       l2tp_session_id_hash(tunnel, session_id));</span>
<span class="p_del">-		write_unlock_bh(&amp;tunnel-&gt;hlist_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* And to the global session list if L2TPv3 */</span>
<span class="p_del">-		if (tunnel-&gt;version != L2TP_HDR_VER_2) {</span>
<span class="p_del">-			struct l2tp_net *pn = l2tp_pernet(tunnel-&gt;l2tp_net);</span>
<span class="p_del">-</span>
<span class="p_del">-			spin_lock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);</span>
<span class="p_del">-			hlist_add_head_rcu(&amp;session-&gt;global_hlist,</span>
<span class="p_del">-					   l2tp_session_id_hash_2(pn, session_id));</span>
<span class="p_del">-			spin_unlock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		/* Ignore management session in session count value */
 		if (session-&gt;session_id != 0)
 			atomic_inc(&amp;l2tp_session_count);
<span class="p_add">+</span>
<span class="p_add">+		return session;</span>
 	}
 
<span class="p_del">-	return session;</span>
<span class="p_add">+	return ERR_PTR(-ENOMEM);</span>
 }
 EXPORT_SYMBOL_GPL(l2tp_session_create);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index e7233bad65e0..0095012509ac 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -240,12 +240,16 @@</span> <span class="p_context"> static inline struct l2tp_tunnel *l2tp_sock_to_tunnel(struct sock *sk)</span>
 	return tunnel;
 }
 
<span class="p_add">+struct l2tp_session *l2tp_session_get(struct net *net,</span>
<span class="p_add">+				      struct l2tp_tunnel *tunnel,</span>
<span class="p_add">+				      u32 session_id, bool do_ref);</span>
 struct l2tp_session *l2tp_session_find(struct net *net,
 				       struct l2tp_tunnel *tunnel,
 				       u32 session_id);
 struct l2tp_session *l2tp_session_get_nth(struct l2tp_tunnel *tunnel, int nth,
 					  bool do_ref);
<span class="p_del">-struct l2tp_session *l2tp_session_find_by_ifname(struct net *net, char *ifname);</span>
<span class="p_add">+struct l2tp_session *l2tp_session_get_by_ifname(struct net *net, char *ifname,</span>
<span class="p_add">+						bool do_ref);</span>
 struct l2tp_tunnel *l2tp_tunnel_find(struct net *net, u32 tunnel_id);
 struct l2tp_tunnel *l2tp_tunnel_find_nth(struct net *net, int nth);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c</span>
<span class="p_header">index 965f7e344cef..eecc64e138de 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_eth.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_eth.c</span>
<span class="p_chunk">@@ -223,12 +223,6 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 p</span>
 		goto out;
 	}
 
<span class="p_del">-	session = l2tp_session_find(net, tunnel, session_id);</span>
<span class="p_del">-	if (session) {</span>
<span class="p_del">-		rc = -EEXIST;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (cfg-&gt;ifname) {
 		dev = dev_get_by_name(net, cfg-&gt;ifname);
 		if (dev) {
<span class="p_chunk">@@ -242,8 +236,8 @@</span> <span class="p_context"> static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 p</span>
 
 	session = l2tp_session_create(sizeof(*spriv), tunnel, session_id,
 				      peer_session_id, cfg);
<span class="p_del">-	if (!session) {</span>
<span class="p_del">-		rc = -ENOMEM;</span>
<span class="p_add">+	if (IS_ERR(session)) {</span>
<span class="p_add">+		rc = PTR_ERR(session);</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index 20669537816e..3468d5635d0a 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -143,19 +143,19 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 	}
 
 	/* Ok, this is a data packet. Lookup the session. */
<span class="p_del">-	session = l2tp_session_find(net, NULL, session_id);</span>
<span class="p_del">-	if (session == NULL)</span>
<span class="p_add">+	session = l2tp_session_get(net, NULL, session_id, true);</span>
<span class="p_add">+	if (!session)</span>
 		goto discard;
 
 	tunnel = session-&gt;tunnel;
<span class="p_del">-	if (tunnel == NULL)</span>
<span class="p_del">-		goto discard;</span>
<span class="p_add">+	if (!tunnel)</span>
<span class="p_add">+		goto discard_sess;</span>
 
 	/* Trace packet contents, if enabled */
 	if (tunnel-&gt;debug &amp; L2TP_MSG_DATA) {
 		length = min(32u, skb-&gt;len);
 		if (!pskb_may_pull(skb, length))
<span class="p_del">-			goto discard;</span>
<span class="p_add">+			goto discard_sess;</span>
 
 		/* Point to L2TP header */
 		optr = ptr = skb-&gt;data;
<span class="p_chunk">@@ -165,6 +165,7 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 	}
 
 	l2tp_recv_common(session, skb, ptr, optr, 0, skb-&gt;len, tunnel-&gt;recv_payload_hook);
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
 
 	return 0;
 
<span class="p_chunk">@@ -203,6 +204,12 @@</span> <span class="p_context"> static int l2tp_ip_recv(struct sk_buff *skb)</span>
 
 	return sk_receive_skb(sk, skb, 1);
 
<span class="p_add">+discard_sess:</span>
<span class="p_add">+	if (session-&gt;deref)</span>
<span class="p_add">+		session-&gt;deref(session);</span>
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
<span class="p_add">+	goto discard;</span>
<span class="p_add">+</span>
 discard_put:
 	sock_put(sk);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index a4b0c9232bf1..b10abef6b0a0 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -156,19 +156,19 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 	}
 
 	/* Ok, this is a data packet. Lookup the session. */
<span class="p_del">-	session = l2tp_session_find(net, NULL, session_id);</span>
<span class="p_del">-	if (session == NULL)</span>
<span class="p_add">+	session = l2tp_session_get(net, NULL, session_id, true);</span>
<span class="p_add">+	if (!session)</span>
 		goto discard;
 
 	tunnel = session-&gt;tunnel;
<span class="p_del">-	if (tunnel == NULL)</span>
<span class="p_del">-		goto discard;</span>
<span class="p_add">+	if (!tunnel)</span>
<span class="p_add">+		goto discard_sess;</span>
 
 	/* Trace packet contents, if enabled */
 	if (tunnel-&gt;debug &amp; L2TP_MSG_DATA) {
 		length = min(32u, skb-&gt;len);
 		if (!pskb_may_pull(skb, length))
<span class="p_del">-			goto discard;</span>
<span class="p_add">+			goto discard_sess;</span>
 
 		/* Point to L2TP header */
 		optr = ptr = skb-&gt;data;
<span class="p_chunk">@@ -179,6 +179,8 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 
 	l2tp_recv_common(session, skb, ptr, optr, 0, skb-&gt;len,
 			 tunnel-&gt;recv_payload_hook);
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
<span class="p_add">+</span>
 	return 0;
 
 pass_up:
<span class="p_chunk">@@ -216,6 +218,12 @@</span> <span class="p_context"> static int l2tp_ip6_recv(struct sk_buff *skb)</span>
 
 	return sk_receive_skb(sk, skb, 1);
 
<span class="p_add">+discard_sess:</span>
<span class="p_add">+	if (session-&gt;deref)</span>
<span class="p_add">+		session-&gt;deref(session);</span>
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
<span class="p_add">+	goto discard;</span>
<span class="p_add">+</span>
 discard_put:
 	sock_put(sk);
 
<span class="p_header">diff --git a/net/l2tp/l2tp_netlink.c b/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">index 9f66272b163b..1ccd310d01a5 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_netlink.c</span>
<span class="p_chunk">@@ -55,7 +55,8 @@</span> <span class="p_context"> static int l2tp_nl_session_send(struct sk_buff *skb, u32 portid, u32 seq,</span>
 /* Accessed under genl lock */
 static const struct l2tp_nl_cmd_ops *l2tp_nl_cmd_ops[__L2TP_PWTYPE_MAX];
 
<span class="p_del">-static struct l2tp_session *l2tp_nl_session_find(struct genl_info *info)</span>
<span class="p_add">+static struct l2tp_session *l2tp_nl_session_get(struct genl_info *info,</span>
<span class="p_add">+						bool do_ref)</span>
 {
 	u32 tunnel_id;
 	u32 session_id;
<span class="p_chunk">@@ -66,14 +67,15 @@</span> <span class="p_context"> static struct l2tp_session *l2tp_nl_session_find(struct genl_info *info)</span>
 
 	if (info-&gt;attrs[L2TP_ATTR_IFNAME]) {
 		ifname = nla_data(info-&gt;attrs[L2TP_ATTR_IFNAME]);
<span class="p_del">-		session = l2tp_session_find_by_ifname(net, ifname);</span>
<span class="p_add">+		session = l2tp_session_get_by_ifname(net, ifname, do_ref);</span>
 	} else if ((info-&gt;attrs[L2TP_ATTR_SESSION_ID]) &amp;&amp;
 		   (info-&gt;attrs[L2TP_ATTR_CONN_ID])) {
 		tunnel_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_CONN_ID]);
 		session_id = nla_get_u32(info-&gt;attrs[L2TP_ATTR_SESSION_ID]);
 		tunnel = l2tp_tunnel_find(net, tunnel_id);
 		if (tunnel)
<span class="p_del">-			session = l2tp_session_find(net, tunnel, session_id);</span>
<span class="p_add">+			session = l2tp_session_get(net, tunnel, session_id,</span>
<span class="p_add">+						   do_ref);</span>
 	}
 
 	return session;
<span class="p_chunk">@@ -634,10 +636,12 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 			session_id, peer_session_id, &amp;cfg);
 
 	if (ret &gt;= 0) {
<span class="p_del">-		session = l2tp_session_find(net, tunnel, session_id);</span>
<span class="p_del">-		if (session)</span>
<span class="p_add">+		session = l2tp_session_get(net, tunnel, session_id, false);</span>
<span class="p_add">+		if (session) {</span>
 			ret = l2tp_session_notify(&amp;l2tp_nl_family, info, session,
 						  L2TP_CMD_SESSION_CREATE);
<span class="p_add">+			l2tp_session_dec_refcount(session);</span>
<span class="p_add">+		}</span>
 	}
 
 out:
<span class="p_chunk">@@ -650,7 +654,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_delete(struct sk_buff *skb, struct genl_info *inf</span>
 	struct l2tp_session *session;
 	u16 pw_type;
 
<span class="p_del">-	session = l2tp_nl_session_find(info);</span>
<span class="p_add">+	session = l2tp_nl_session_get(info, true);</span>
 	if (session == NULL) {
 		ret = -ENODEV;
 		goto out;
<span class="p_chunk">@@ -664,6 +668,10 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_delete(struct sk_buff *skb, struct genl_info *inf</span>
 		if (l2tp_nl_cmd_ops[pw_type] &amp;&amp; l2tp_nl_cmd_ops[pw_type]-&gt;session_delete)
 			ret = (*l2tp_nl_cmd_ops[pw_type]-&gt;session_delete)(session);
 
<span class="p_add">+	if (session-&gt;deref)</span>
<span class="p_add">+		session-&gt;deref(session);</span>
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
<span class="p_add">+</span>
 out:
 	return ret;
 }
<span class="p_chunk">@@ -673,7 +681,7 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_modify(struct sk_buff *skb, struct genl_info *inf</span>
 	int ret = 0;
 	struct l2tp_session *session;
 
<span class="p_del">-	session = l2tp_nl_session_find(info);</span>
<span class="p_add">+	session = l2tp_nl_session_get(info, false);</span>
 	if (session == NULL) {
 		ret = -ENODEV;
 		goto out;
<span class="p_chunk">@@ -708,6 +716,8 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_modify(struct sk_buff *skb, struct genl_info *inf</span>
 	ret = l2tp_session_notify(&amp;l2tp_nl_family, info,
 				  session, L2TP_CMD_SESSION_MODIFY);
 
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
<span class="p_add">+</span>
 out:
 	return ret;
 }
<span class="p_chunk">@@ -803,29 +813,34 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_get(struct sk_buff *skb, struct genl_info *info)</span>
 	struct sk_buff *msg;
 	int ret;
 
<span class="p_del">-	session = l2tp_nl_session_find(info);</span>
<span class="p_add">+	session = l2tp_nl_session_get(info, false);</span>
 	if (session == NULL) {
 		ret = -ENODEV;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!msg) {
 		ret = -ENOMEM;
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto err_ref;</span>
 	}
 
 	ret = l2tp_nl_session_send(msg, info-&gt;snd_portid, info-&gt;snd_seq,
 				   0, session, L2TP_CMD_SESSION_GET);
 	if (ret &lt; 0)
<span class="p_del">-		goto err_out;</span>
<span class="p_add">+		goto err_ref_msg;</span>
 
<span class="p_del">-	return genlmsg_unicast(genl_info_net(info), msg, info-&gt;snd_portid);</span>
<span class="p_add">+	ret = genlmsg_unicast(genl_info_net(info), msg, info-&gt;snd_portid);</span>
 
<span class="p_del">-err_out:</span>
<span class="p_del">-	nlmsg_free(msg);</span>
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
 
<span class="p_del">-out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+err_ref_msg:</span>
<span class="p_add">+	nlmsg_free(msg);</span>
<span class="p_add">+err_ref:</span>
<span class="p_add">+	l2tp_session_dec_refcount(session);</span>
<span class="p_add">+err:</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index 1387f547a09e..1696f1fd5877 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -583,6 +583,7 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	int error = 0;
 	u32 tunnel_id, peer_tunnel_id;
 	u32 session_id, peer_session_id;
<span class="p_add">+	bool drop_refcnt = false;</span>
 	int ver = 2;
 	int fd;
 
<span class="p_chunk">@@ -684,36 +685,36 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 	if (tunnel-&gt;peer_tunnel_id == 0)
 		tunnel-&gt;peer_tunnel_id = peer_tunnel_id;
 
<span class="p_del">-	/* Create session if it doesn&#39;t already exist. We handle the</span>
<span class="p_del">-	 * case where a session was previously created by the netlink</span>
<span class="p_del">-	 * interface by checking that the session doesn&#39;t already have</span>
<span class="p_del">-	 * a socket and its tunnel socket are what we expect. If any</span>
<span class="p_del">-	 * of those checks fail, return EEXIST to the caller.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	session = l2tp_session_find(sock_net(sk), tunnel, session_id);</span>
<span class="p_del">-	if (session == NULL) {</span>
<span class="p_del">-		/* Default MTU must allow space for UDP/L2TP/PPP</span>
<span class="p_del">-		 * headers.</span>
<span class="p_add">+	session = l2tp_session_get(sock_net(sk), tunnel, session_id, false);</span>
<span class="p_add">+	if (session) {</span>
<span class="p_add">+		drop_refcnt = true;</span>
<span class="p_add">+		ps = l2tp_session_priv(session);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Using a pre-existing session is fine as long as it hasn&#39;t</span>
<span class="p_add">+		 * been connected yet.</span>
 		 */
<span class="p_del">-		cfg.mtu = cfg.mru = 1500 - PPPOL2TP_HEADER_OVERHEAD;</span>
<span class="p_add">+		if (ps-&gt;sock) {</span>
<span class="p_add">+			error = -EEXIST;</span>
<span class="p_add">+			goto end;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		/* Allocate and initialize a new session context. */</span>
<span class="p_del">-		session = l2tp_session_create(sizeof(struct pppol2tp_session),</span>
<span class="p_del">-					      tunnel, session_id,</span>
<span class="p_del">-					      peer_session_id, &amp;cfg);</span>
<span class="p_del">-		if (session == NULL) {</span>
<span class="p_del">-			error = -ENOMEM;</span>
<span class="p_add">+		/* consistency checks */</span>
<span class="p_add">+		if (ps-&gt;tunnel_sock != tunnel-&gt;sock) {</span>
<span class="p_add">+			error = -EEXIST;</span>
 			goto end;
 		}
 	} else {
<span class="p_del">-		ps = l2tp_session_priv(session);</span>
<span class="p_del">-		error = -EEXIST;</span>
<span class="p_del">-		if (ps-&gt;sock != NULL)</span>
<span class="p_del">-			goto end;</span>
<span class="p_add">+		/* Default MTU must allow space for UDP/L2TP/PPP headers */</span>
<span class="p_add">+		cfg.mtu = 1500 - PPPOL2TP_HEADER_OVERHEAD;</span>
<span class="p_add">+		cfg.mru = cfg.mtu;</span>
 
<span class="p_del">-		/* consistency checks */</span>
<span class="p_del">-		if (ps-&gt;tunnel_sock != tunnel-&gt;sock)</span>
<span class="p_add">+		session = l2tp_session_create(sizeof(struct pppol2tp_session),</span>
<span class="p_add">+					      tunnel, session_id,</span>
<span class="p_add">+					      peer_session_id, &amp;cfg);</span>
<span class="p_add">+		if (IS_ERR(session)) {</span>
<span class="p_add">+			error = PTR_ERR(session);</span>
 			goto end;
<span class="p_add">+		}</span>
 	}
 
 	/* Associate session with its PPPoL2TP socket */
<span class="p_chunk">@@ -778,6 +779,8 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 		  session-&gt;name);
 
 end:
<span class="p_add">+	if (drop_refcnt)</span>
<span class="p_add">+		l2tp_session_dec_refcount(session);</span>
 	release_sock(sk);
 
 	return error;
<span class="p_chunk">@@ -805,12 +808,6 @@</span> <span class="p_context"> static int pppol2tp_session_create(struct net *net, u32 tunnel_id, u32 session_i</span>
 	if (tunnel-&gt;sock == NULL)
 		goto out;
 
<span class="p_del">-	/* Check that this session doesn&#39;t already exist */</span>
<span class="p_del">-	error = -EEXIST;</span>
<span class="p_del">-	session = l2tp_session_find(net, tunnel, session_id);</span>
<span class="p_del">-	if (session != NULL)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	/* Default MTU values. */
 	if (cfg-&gt;mtu == 0)
 		cfg-&gt;mtu = 1500 - PPPOL2TP_HEADER_OVERHEAD;
<span class="p_chunk">@@ -818,12 +815,13 @@</span> <span class="p_context"> static int pppol2tp_session_create(struct net *net, u32 tunnel_id, u32 session_i</span>
 		cfg-&gt;mru = cfg-&gt;mtu;
 
 	/* Allocate and initialize a new session context. */
<span class="p_del">-	error = -ENOMEM;</span>
 	session = l2tp_session_create(sizeof(struct pppol2tp_session),
 				      tunnel, session_id,
 				      peer_session_id, cfg);
<span class="p_del">-	if (session == NULL)</span>
<span class="p_add">+	if (IS_ERR(session)) {</span>
<span class="p_add">+		error = PTR_ERR(session);</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	ps = l2tp_session_priv(session);
 	ps-&gt;tunnel_sock = tunnel-&gt;sock;
<span class="p_chunk">@@ -1141,11 +1139,18 @@</span> <span class="p_context"> static int pppol2tp_tunnel_ioctl(struct l2tp_tunnel *tunnel,</span>
 		if (stats.session_id != 0) {
 			/* resend to session ioctl handler */
 			struct l2tp_session *session =
<span class="p_del">-				l2tp_session_find(sock_net(sk), tunnel, stats.session_id);</span>
<span class="p_del">-			if (session != NULL)</span>
<span class="p_del">-				err = pppol2tp_session_ioctl(session, cmd, arg);</span>
<span class="p_del">-			else</span>
<span class="p_add">+				l2tp_session_get(sock_net(sk), tunnel,</span>
<span class="p_add">+						 stats.session_id, true);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (session) {</span>
<span class="p_add">+				err = pppol2tp_session_ioctl(session, cmd,</span>
<span class="p_add">+							     arg);</span>
<span class="p_add">+				if (session-&gt;deref)</span>
<span class="p_add">+					session-&gt;deref(session);</span>
<span class="p_add">+				l2tp_session_dec_refcount(session);</span>
<span class="p_add">+			} else {</span>
 				err = -EBADR;
<span class="p_add">+			}</span>
 			break;
 		}
 #ifdef CONFIG_XFRM
<span class="p_header">diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c</span>
<span class="p_header">index 8d7747e98fdb..37bec0f864b7 100644</span>
<span class="p_header">--- a/net/mac80211/iface.c</span>
<span class="p_header">+++ b/net/mac80211/iface.c</span>
<span class="p_chunk">@@ -6,6 +6,7 @@</span> <span class="p_context"></span>
  * Copyright (c) 2006 Jiri Benc &lt;jbenc@suse.cz&gt;
  * Copyright 2008, Johannes Berg &lt;johannes@sipsolutions.net&gt;
  * Copyright 2013-2014  Intel Mobile Communications GmbH
<span class="p_add">+ * Copyright (c) 2016        Intel Deutschland GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
<span class="p_chunk">@@ -1307,6 +1308,26 @@</span> <span class="p_context"> static void ieee80211_iface_work(struct work_struct *work)</span>
 		} else if (ieee80211_is_action(mgmt-&gt;frame_control) &amp;&amp;
 			   mgmt-&gt;u.action.category == WLAN_CATEGORY_VHT) {
 			switch (mgmt-&gt;u.action.u.vht_group_notif.action_code) {
<span class="p_add">+			case WLAN_VHT_ACTION_OPMODE_NOTIF: {</span>
<span class="p_add">+				struct ieee80211_rx_status *status;</span>
<span class="p_add">+				enum nl80211_band band;</span>
<span class="p_add">+				u8 opmode;</span>
<span class="p_add">+</span>
<span class="p_add">+				status = IEEE80211_SKB_RXCB(skb);</span>
<span class="p_add">+				band = status-&gt;band;</span>
<span class="p_add">+				opmode = mgmt-&gt;u.action.u.vht_opmode_notif.operating_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+				mutex_lock(&amp;local-&gt;sta_mtx);</span>
<span class="p_add">+				sta = sta_info_get_bss(sdata, mgmt-&gt;sa);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (sta)</span>
<span class="p_add">+					ieee80211_vht_handle_opmode(sdata, sta,</span>
<span class="p_add">+								    opmode,</span>
<span class="p_add">+								    band);</span>
<span class="p_add">+</span>
<span class="p_add">+				mutex_unlock(&amp;local-&gt;sta_mtx);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			case WLAN_VHT_ACTION_GROUPID_MGMT:
 				ieee80211_process_mu_groups(sdata, mgmt);
 				break;
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index 1075ac24c8c5..2bb6899854d4 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -908,12 +908,17 @@</span> <span class="p_context"> int ieee80211_register_hw(struct ieee80211_hw *hw)</span>
 		supp_ht = supp_ht || sband-&gt;ht_cap.ht_supported;
 		supp_vht = supp_vht || sband-&gt;vht_cap.vht_supported;
 
<span class="p_del">-		if (sband-&gt;ht_cap.ht_supported)</span>
<span class="p_del">-			local-&gt;rx_chains =</span>
<span class="p_del">-				max(ieee80211_mcs_to_chains(&amp;sband-&gt;ht_cap.mcs),</span>
<span class="p_del">-				    local-&gt;rx_chains);</span>
<span class="p_add">+		if (!sband-&gt;ht_cap.ht_supported)</span>
<span class="p_add">+			continue;</span>
 
 		/* TODO: consider VHT for RX chains, hopefully it&#39;s the same */
<span class="p_add">+		local-&gt;rx_chains =</span>
<span class="p_add">+			max(ieee80211_mcs_to_chains(&amp;sband-&gt;ht_cap.mcs),</span>
<span class="p_add">+			    local-&gt;rx_chains);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* no need to mask, SM_PS_DISABLED has all bits set */</span>
<span class="p_add">+		sband-&gt;ht_cap.cap |= WLAN_HT_CAP_SM_PS_DISABLED &lt;&lt;</span>
<span class="p_add">+			             IEEE80211_HT_CAP_SM_PS_SHIFT;</span>
 	}
 
 	/* if low-level driver supports AP, we also support VLAN */
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index c45a0fcfb3e7..439e597fd374 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -2923,17 +2923,10 @@</span> <span class="p_context"> ieee80211_rx_h_action(struct ieee80211_rx_data *rx)</span>
 
 		switch (mgmt-&gt;u.action.u.vht_opmode_notif.action_code) {
 		case WLAN_VHT_ACTION_OPMODE_NOTIF: {
<span class="p_del">-			u8 opmode;</span>
<span class="p_del">-</span>
 			/* verify opmode is present */
 			if (len &lt; IEEE80211_MIN_ACTION_SIZE + 2)
 				goto invalid;
<span class="p_del">-</span>
<span class="p_del">-			opmode = mgmt-&gt;u.action.u.vht_opmode_notif.operating_mode;</span>
<span class="p_del">-</span>
<span class="p_del">-			ieee80211_vht_handle_opmode(rx-&gt;sdata, rx-&gt;sta,</span>
<span class="p_del">-						    opmode, status-&gt;band);</span>
<span class="p_del">-			goto handled;</span>
<span class="p_add">+			goto queue;</span>
 		}
 		case WLAN_VHT_ACTION_GROUPID_MGMT: {
 			if (len &lt; IEEE80211_MIN_ACTION_SIZE + 25)
<span class="p_header">diff --git a/net/mac80211/vht.c b/net/mac80211/vht.c</span>
<span class="p_header">index 6832bf6ab69f..43e45bb660bc 100644</span>
<span class="p_header">--- a/net/mac80211/vht.c</span>
<span class="p_header">+++ b/net/mac80211/vht.c</span>
<span class="p_chunk">@@ -527,8 +527,10 @@</span> <span class="p_context"> void ieee80211_vht_handle_opmode(struct ieee80211_sub_if_data *sdata,</span>
 
 	u32 changed = __ieee80211_vht_handle_opmode(sdata, sta, opmode, band);
 
<span class="p_del">-	if (changed &gt; 0)</span>
<span class="p_add">+	if (changed &gt; 0) {</span>
<span class="p_add">+		ieee80211_recalc_min_chandef(sdata);</span>
 		rate_control_rate_update(local, sband, sta, changed);
<span class="p_add">+	}</span>
 }
 
 void ieee80211_get_vht_mask_from_cap(__le16 vht_cap,
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index 27540455dc62..04111c1c3988 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -45,6 +45,8 @@</span> <span class="p_context"></span>
 #include &lt;net/netfilter/nf_conntrack_zones.h&gt;
 #include &lt;net/netfilter/nf_conntrack_timestamp.h&gt;
 #include &lt;net/netfilter/nf_conntrack_labels.h&gt;
<span class="p_add">+#include &lt;net/netfilter/nf_conntrack_seqadj.h&gt;</span>
<span class="p_add">+#include &lt;net/netfilter/nf_conntrack_synproxy.h&gt;</span>
 #ifdef CONFIG_NF_NAT_NEEDED
 #include &lt;net/netfilter/nf_nat_core.h&gt;
 #include &lt;net/netfilter/nf_nat_l4proto.h&gt;
<span class="p_chunk">@@ -1800,6 +1802,8 @@</span> <span class="p_context"> ctnetlink_create_conntrack(struct net *net,</span>
 	nf_ct_tstamp_ext_add(ct, GFP_ATOMIC);
 	nf_ct_ecache_ext_add(ct, 0, 0, GFP_ATOMIC);
 	nf_ct_labels_ext_add(ct);
<span class="p_add">+	nfct_seqadj_ext_add(ct);</span>
<span class="p_add">+	nfct_synproxy_ext_add(ct);</span>
 
 	/* we must add conntrack extensions before confirmation. */
 	ct-&gt;status |= IPS_CONFIRMED;
<span class="p_header">diff --git a/net/netfilter/xt_TCPMSS.c b/net/netfilter/xt_TCPMSS.c</span>
<span class="p_header">index 872db2d0e2a9..119e51fdcebc 100644</span>
<span class="p_header">--- a/net/netfilter/xt_TCPMSS.c</span>
<span class="p_header">+++ b/net/netfilter/xt_TCPMSS.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> tcpmss_mangle_packet(struct sk_buff *skb,</span>
 	tcph = (struct tcphdr *)(skb_network_header(skb) + tcphoff);
 	tcp_hdrlen = tcph-&gt;doff * 4;
 
<span class="p_del">-	if (len &lt; tcp_hdrlen)</span>
<span class="p_add">+	if (len &lt; tcp_hdrlen || tcp_hdrlen &lt; sizeof(struct tcphdr))</span>
 		return -1;
 
 	if (info-&gt;mss == XT_TCPMSS_CLAMP_PMTU) {
<span class="p_chunk">@@ -152,6 +152,10 @@</span> <span class="p_context"> tcpmss_mangle_packet(struct sk_buff *skb,</span>
 	if (len &gt; tcp_hdrlen)
 		return 0;
 
<span class="p_add">+	/* tcph-&gt;doff has 4 bits, do not wrap it to 0 */</span>
<span class="p_add">+	if (tcp_hdrlen &gt;= 15 * 4)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/*
 	 * MSS Option not found ?! add it..
 	 */
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index e1719c695174..9647e314d4fc 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static struct sctp_transport *sctp_addr_id2transport(struct sock *sk,</span>
 	union sctp_addr *laddr = (union sctp_addr *)addr;
 	struct sctp_transport *transport;
 
<span class="p_del">-	if (sctp_verify_addr(sk, laddr, af-&gt;sockaddr_len))</span>
<span class="p_add">+	if (!af || sctp_verify_addr(sk, laddr, af-&gt;sockaddr_len))</span>
 		return NULL;
 
 	addr_asoc = sctp_endpoint_lookup_assoc(sctp_sk(sk)-&gt;ep,
<span class="p_chunk">@@ -4460,13 +4460,13 @@</span> <span class="p_context"> int sctp_for_each_endpoint(int (*cb)(struct sctp_endpoint *, void *),</span>
 
 	for (head = sctp_ep_hashtable; hash &lt; sctp_ep_hashsize;
 	     hash++, head++) {
<span class="p_del">-		read_lock(&amp;head-&gt;lock);</span>
<span class="p_add">+		read_lock_bh(&amp;head-&gt;lock);</span>
 		sctp_for_each_hentry(epb, &amp;head-&gt;chain) {
 			err = cb(sctp_ep(epb), p);
 			if (err)
 				break;
 		}
<span class="p_del">-		read_unlock(&amp;head-&gt;lock);</span>
<span class="p_add">+		read_unlock_bh(&amp;head-&gt;lock);</span>
 	}
 
 	return err;
<span class="p_chunk">@@ -4506,9 +4506,8 @@</span> <span class="p_context"> int sctp_for_each_transport(int (*cb)(struct sctp_transport *, void *),</span>
 	if (err)
 		return err;
 
<span class="p_del">-	sctp_transport_get_idx(net, &amp;hti, pos);</span>
<span class="p_del">-	obj = sctp_transport_get_next(net, &amp;hti);</span>
<span class="p_del">-	for (; obj &amp;&amp; !IS_ERR(obj); obj = sctp_transport_get_next(net, &amp;hti)) {</span>
<span class="p_add">+	obj = sctp_transport_get_idx(net, &amp;hti, pos + 1);</span>
<span class="p_add">+	for (; !IS_ERR_OR_NULL(obj); obj = sctp_transport_get_next(net, &amp;hti)) {</span>
 		struct sctp_transport *transport = obj;
 
 		if (!sctp_transport_hold(transport))
<span class="p_header">diff --git a/net/tipc/discover.c b/net/tipc/discover.c</span>
<span class="p_header">index 6b109a808d4c..02462d67d191 100644</span>
<span class="p_header">--- a/net/tipc/discover.c</span>
<span class="p_header">+++ b/net/tipc/discover.c</span>
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> void tipc_disc_rcv(struct net *net, struct sk_buff *skb,</span>
 
 	/* Send response, if necessary */
 	if (respond &amp;&amp; (mtyp == DSC_REQ_MSG)) {
<span class="p_del">-		rskb = tipc_buf_acquire(MAX_H_SIZE);</span>
<span class="p_add">+		rskb = tipc_buf_acquire(MAX_H_SIZE, GFP_ATOMIC);</span>
 		if (!rskb)
 			return;
 		tipc_disc_init_msg(net, rskb, DSC_RESP_MSG, bearer);
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> int tipc_disc_create(struct net *net, struct tipc_bearer *b,</span>
 	req = kmalloc(sizeof(*req), GFP_ATOMIC);
 	if (!req)
 		return -ENOMEM;
<span class="p_del">-	req-&gt;buf = tipc_buf_acquire(MAX_H_SIZE);</span>
<span class="p_add">+	req-&gt;buf = tipc_buf_acquire(MAX_H_SIZE, GFP_ATOMIC);</span>
 	if (!req-&gt;buf) {
 		kfree(req);
 		return -ENOMEM;
<span class="p_header">diff --git a/net/tipc/link.c b/net/tipc/link.c</span>
<span class="p_header">index bda89bf9f4ff..4e8647aef01c 100644</span>
<span class="p_header">--- a/net/tipc/link.c</span>
<span class="p_header">+++ b/net/tipc/link.c</span>
<span class="p_chunk">@@ -1395,7 +1395,7 @@</span> <span class="p_context"> void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,</span>
 			msg_set_seqno(hdr, seqno++);
 		pktlen = msg_size(hdr);
 		msg_set_size(&amp;tnlhdr, pktlen + INT_H_SIZE);
<span class="p_del">-		tnlskb = tipc_buf_acquire(pktlen + INT_H_SIZE);</span>
<span class="p_add">+		tnlskb = tipc_buf_acquire(pktlen + INT_H_SIZE, GFP_ATOMIC);</span>
 		if (!tnlskb) {
 			pr_warn(&quot;%sunable to send packet\n&quot;, link_co_err);
 			return;
<span class="p_header">diff --git a/net/tipc/msg.c b/net/tipc/msg.c</span>
<span class="p_header">index 17201aa8423d..56ea0adcd285 100644</span>
<span class="p_header">--- a/net/tipc/msg.c</span>
<span class="p_header">+++ b/net/tipc/msg.c</span>
<span class="p_chunk">@@ -58,12 +58,12 @@</span> <span class="p_context"> static unsigned int align(unsigned int i)</span>
  * NOTE: Headroom is reserved to allow prepending of a data link header.
  *       There may also be unrequested tailroom present at the buffer&#39;s end.
  */
<span class="p_del">-struct sk_buff *tipc_buf_acquire(u32 size)</span>
<span class="p_add">+struct sk_buff *tipc_buf_acquire(u32 size, gfp_t gfp)</span>
 {
 	struct sk_buff *skb;
 	unsigned int buf_size = (BUF_HEADROOM + size + 3) &amp; ~3u;
 
<span class="p_del">-	skb = alloc_skb_fclone(buf_size, GFP_ATOMIC);</span>
<span class="p_add">+	skb = alloc_skb_fclone(buf_size, gfp);</span>
 	if (skb) {
 		skb_reserve(skb, BUF_HEADROOM);
 		skb_put(skb, size);
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> struct sk_buff *tipc_msg_create(uint user, uint type,</span>
 	struct tipc_msg *msg;
 	struct sk_buff *buf;
 
<span class="p_del">-	buf = tipc_buf_acquire(hdr_sz + data_sz);</span>
<span class="p_add">+	buf = tipc_buf_acquire(hdr_sz + data_sz, GFP_ATOMIC);</span>
 	if (unlikely(!buf))
 		return NULL;
 
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> int tipc_msg_build(struct tipc_msg *mhdr, struct msghdr *m,</span>
 
 	/* No fragmentation needed? */
 	if (likely(msz &lt;= pktmax)) {
<span class="p_del">-		skb = tipc_buf_acquire(msz);</span>
<span class="p_add">+		skb = tipc_buf_acquire(msz, GFP_KERNEL);</span>
 		if (unlikely(!skb))
 			return -ENOMEM;
 		skb_orphan(skb);
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> int tipc_msg_build(struct tipc_msg *mhdr, struct msghdr *m,</span>
 	msg_set_importance(&amp;pkthdr, msg_importance(mhdr));
 
 	/* Prepare first fragment */
<span class="p_del">-	skb = tipc_buf_acquire(pktmax);</span>
<span class="p_add">+	skb = tipc_buf_acquire(pktmax, GFP_KERNEL);</span>
 	if (!skb)
 		return -ENOMEM;
 	skb_orphan(skb);
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> int tipc_msg_build(struct tipc_msg *mhdr, struct msghdr *m,</span>
 			pktsz = drem + INT_H_SIZE;
 		else
 			pktsz = pktmax;
<span class="p_del">-		skb = tipc_buf_acquire(pktsz);</span>
<span class="p_add">+		skb = tipc_buf_acquire(pktsz, GFP_KERNEL);</span>
 		if (!skb) {
 			rc = -ENOMEM;
 			goto error;
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> bool tipc_msg_make_bundle(struct sk_buff **skb,  struct tipc_msg *msg,</span>
 	if (msz &gt; (max / 2))
 		return false;
 
<span class="p_del">-	_skb = tipc_buf_acquire(max);</span>
<span class="p_add">+	_skb = tipc_buf_acquire(max, GFP_ATOMIC);</span>
 	if (!_skb)
 		return false;
 
<span class="p_chunk">@@ -496,7 +496,7 @@</span> <span class="p_context"> bool tipc_msg_reverse(u32 own_node,  struct sk_buff **skb, int err)</span>
 
 	/* Never return SHORT header; expand by replacing buffer if necessary */
 	if (msg_short(hdr)) {
<span class="p_del">-		*skb = tipc_buf_acquire(BASIC_H_SIZE + dlen);</span>
<span class="p_add">+		*skb = tipc_buf_acquire(BASIC_H_SIZE + dlen, GFP_ATOMIC);</span>
 		if (!*skb)
 			goto exit;
 		memcpy((*skb)-&gt;data + BASIC_H_SIZE, msg_data(hdr), dlen);
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> bool tipc_msg_reverse(u32 own_node,  struct sk_buff **skb, int err)</span>
 	}
 
 	if (skb_cloned(_skb) &amp;&amp;
<span class="p_del">-	    pskb_expand_head(_skb, BUF_HEADROOM, BUF_TAILROOM, GFP_KERNEL))</span>
<span class="p_add">+	    pskb_expand_head(_skb, BUF_HEADROOM, BUF_TAILROOM, GFP_ATOMIC))</span>
 		goto exit;
 
 	/* Now reverse the concerned fields */
<span class="p_header">diff --git a/net/tipc/msg.h b/net/tipc/msg.h</span>
<span class="p_header">index 50a739860d37..6c0455caf302 100644</span>
<span class="p_header">--- a/net/tipc/msg.h</span>
<span class="p_header">+++ b/net/tipc/msg.h</span>
<span class="p_chunk">@@ -820,7 +820,7 @@</span> <span class="p_context"> static inline bool msg_is_reset(struct tipc_msg *hdr)</span>
 	return (msg_user(hdr) == LINK_PROTOCOL) &amp;&amp; (msg_type(hdr) == RESET_MSG);
 }
 
<span class="p_del">-struct sk_buff *tipc_buf_acquire(u32 size);</span>
<span class="p_add">+struct sk_buff *tipc_buf_acquire(u32 size, gfp_t gfp);</span>
 bool tipc_msg_validate(struct sk_buff *skb);
 bool tipc_msg_reverse(u32 own_addr, struct sk_buff **skb, int err);
 void tipc_msg_init(u32 own_addr, struct tipc_msg *m, u32 user, u32 type,
<span class="p_header">diff --git a/net/tipc/name_distr.c b/net/tipc/name_distr.c</span>
<span class="p_header">index c1cfd92de17a..23f8899e0f8c 100644</span>
<span class="p_header">--- a/net/tipc/name_distr.c</span>
<span class="p_header">+++ b/net/tipc/name_distr.c</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"> static struct sk_buff *named_prepare_buf(struct net *net, u32 type, u32 size,</span>
 					 u32 dest)
 {
 	struct tipc_net *tn = net_generic(net, tipc_net_id);
<span class="p_del">-	struct sk_buff *buf = tipc_buf_acquire(INT_H_SIZE + size);</span>
<span class="p_add">+	struct sk_buff *buf = tipc_buf_acquire(INT_H_SIZE + size, GFP_ATOMIC);</span>
 	struct tipc_msg *msg;
 
 	if (buf != NULL) {
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 2d03d5bcb5b9..915abe98174e 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -998,7 +998,8 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct path path = { NULL, NULL };
 
 	err = -EINVAL;
<span class="p_del">-	if (sunaddr-&gt;sun_family != AF_UNIX)</span>
<span class="p_add">+	if (addr_len &lt; offsetofend(struct sockaddr_un, sun_family) ||</span>
<span class="p_add">+	    sunaddr-&gt;sun_family != AF_UNIX)</span>
 		goto out;
 
 	if (addr_len == sizeof(short)) {
<span class="p_chunk">@@ -1109,6 +1110,10 @@</span> <span class="p_context"> static int unix_dgram_connect(struct socket *sock, struct sockaddr *addr,</span>
 	unsigned int hash;
 	int err;
 
<span class="p_add">+	err = -EINVAL;</span>
<span class="p_add">+	if (alen &lt; offsetofend(struct sockaddr, sa_family))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (addr-&gt;sa_family != AF_UNSPEC) {
 		err = unix_mkname(sunaddr, alen, &amp;hash);
 		if (err &lt; 0)
<span class="p_header">diff --git a/net/xfrm/xfrm_policy.c b/net/xfrm/xfrm_policy.c</span>
<span class="p_header">index e0437a7aa1a2..8da67f7c9c5a 100644</span>
<span class="p_header">--- a/net/xfrm/xfrm_policy.c</span>
<span class="p_header">+++ b/net/xfrm/xfrm_policy.c</span>
<span class="p_chunk">@@ -1808,43 +1808,6 @@</span> <span class="p_context"> static struct dst_entry *xfrm_bundle_create(struct xfrm_policy *policy,</span>
 	goto out;
 }
 
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-static int xfrm_dst_alloc_copy(void **target, const void *src, int size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!*target) {</span>
<span class="p_del">-		*target = kmalloc(size, GFP_ATOMIC);</span>
<span class="p_del">-		if (!*target)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(*target, src, size);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static int xfrm_dst_update_parent(struct dst_entry *dst,</span>
<span class="p_del">-				  const struct xfrm_selector *sel)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct xfrm_dst *xdst = (struct xfrm_dst *)dst;</span>
<span class="p_del">-	return xfrm_dst_alloc_copy((void **)&amp;(xdst-&gt;partner),</span>
<span class="p_del">-				   sel, sizeof(*sel));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int xfrm_dst_update_origin(struct dst_entry *dst,</span>
<span class="p_del">-				  const struct flowi *fl)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_XFRM_SUB_POLICY</span>
<span class="p_del">-	struct xfrm_dst *xdst = (struct xfrm_dst *)dst;</span>
<span class="p_del">-	return xfrm_dst_alloc_copy((void **)&amp;(xdst-&gt;origin), fl, sizeof(*fl));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int xfrm_expand_policies(const struct flowi *fl, u16 family,
 				struct xfrm_policy **pols,
 				int *num_pols, int *num_xfrms)
<span class="p_chunk">@@ -1916,16 +1879,6 @@</span> <span class="p_context"> xfrm_resolve_and_create_bundle(struct xfrm_policy **pols, int num_pols,</span>
 
 	xdst = (struct xfrm_dst *)dst;
 	xdst-&gt;num_xfrms = err;
<span class="p_del">-	if (num_pols &gt; 1)</span>
<span class="p_del">-		err = xfrm_dst_update_parent(dst, &amp;pols[1]-&gt;selector);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		err = xfrm_dst_update_origin(dst, fl);</span>
<span class="p_del">-	if (unlikely(err)) {</span>
<span class="p_del">-		dst_free(dst);</span>
<span class="p_del">-		XFRM_INC_STATS(net, LINUX_MIB_XFRMOUTBUNDLECHECKERROR);</span>
<span class="p_del">-		return ERR_PTR(err);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	xdst-&gt;num_pols = num_pols;
 	memcpy(xdst-&gt;pols, pols, sizeof(struct xfrm_policy *) * num_pols);
 	xdst-&gt;policy_genid = atomic_read(&amp;pols[0]-&gt;genid);
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.h b/sound/pci/hda/hda_codec.h</span>
<span class="p_header">index 373fcad840ea..776dffa88aee 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.h</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.h</span>
<span class="p_chunk">@@ -294,6 +294,8 @@</span> <span class="p_context"> struct hda_codec {</span>
 
 #define list_for_each_codec(c, bus) \
 	list_for_each_entry(c, &amp;(bus)-&gt;core.codec_list, core.list)
<span class="p_add">+#define list_for_each_codec_safe(c, n, bus)				\</span>
<span class="p_add">+	list_for_each_entry_safe(c, n, &amp;(bus)-&gt;core.codec_list, core.list)</span>
 
 /* snd_hda_codec_read/write optional flags */
 #define HDA_RW_NO_RESPONSE_FALLBACK	(1 &lt;&lt; 0)
<span class="p_header">diff --git a/sound/pci/hda/hda_controller.c b/sound/pci/hda/hda_controller.c</span>
<span class="p_header">index 500878556578..0af1132a869e 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_controller.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_controller.c</span>
<span class="p_chunk">@@ -1333,8 +1333,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(azx_probe_codecs);</span>
 /* configure each codec instance */
 int azx_codec_configure(struct azx *chip)
 {
<span class="p_del">-	struct hda_codec *codec;</span>
<span class="p_del">-	list_for_each_codec(codec, &amp;chip-&gt;bus) {</span>
<span class="p_add">+	struct hda_codec *codec, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* use _safe version here since snd_hda_codec_configure() deregisters</span>
<span class="p_add">+	 * the device upon error and deletes itself from the bus list.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	list_for_each_codec_safe(codec, next, &amp;chip-&gt;bus) {</span>
 		snd_hda_codec_configure(codec);
 	}
 	return 0;
<span class="p_header">diff --git a/sound/pci/hda/hda_generic.c b/sound/pci/hda/hda_generic.c</span>
<span class="p_header">index e7c8f4f076d5..b0bd29003b5d 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_generic.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_generic.c</span>
<span class="p_chunk">@@ -3169,6 +3169,7 @@</span> <span class="p_context"> static int check_dyn_adc_switch(struct hda_codec *codec)</span>
 						spec-&gt;input_paths[i][nums]);
 					spec-&gt;input_paths[i][nums] =
 						spec-&gt;input_paths[i][n];
<span class="p_add">+					spec-&gt;input_paths[i][n] = 0;</span>
 				}
 			}
 			nums++;
<span class="p_header">diff --git a/tools/arch/x86/lib/memcpy_64.S b/tools/arch/x86/lib/memcpy_64.S</span>
<span class="p_header">index 49e6ebac7e73..98dcc112b363 100644</span>
<span class="p_header">--- a/tools/arch/x86/lib/memcpy_64.S</span>
<span class="p_header">+++ b/tools/arch/x86/lib/memcpy_64.S</span>
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> ENDPROC(memcpy_mcsafe_unrolled)</span>
 	_ASM_EXTABLE_FAULT(.L_copy_leading_bytes, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w0, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w1, .L_memcpy_mcsafe_fail)
<span class="p_del">-	_ASM_EXTABLE_FAULT(.L_cache_w3, .L_memcpy_mcsafe_fail)</span>
<span class="p_add">+	_ASM_EXTABLE_FAULT(.L_cache_w2, .L_memcpy_mcsafe_fail)</span>
 	_ASM_EXTABLE_FAULT(.L_cache_w3, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w4, .L_memcpy_mcsafe_fail)
 	_ASM_EXTABLE_FAULT(.L_cache_w5, .L_memcpy_mcsafe_fail)
<span class="p_header">diff --git a/tools/objtool/arch/x86/decode.c b/tools/objtool/arch/x86/decode.c</span>
<span class="p_header">index 5e0dea2cdc01..039636ffb6c8 100644</span>
<span class="p_header">--- a/tools/objtool/arch/x86/decode.c</span>
<span class="p_header">+++ b/tools/objtool/arch/x86/decode.c</span>
<span class="p_chunk">@@ -150,9 +150,9 @@</span> <span class="p_context"> int arch_decode_instruction(struct elf *elf, struct section *sec,</span>
 		*type = INSN_RETURN;
 		break;
 
<span class="p_del">-	case 0xc5: /* iret */</span>
 	case 0xca: /* retf */
 	case 0xcb: /* retf */
<span class="p_add">+	case 0xcf: /* iret */</span>
 		*type = INSN_CONTEXT_SWITCH;
 		break;
 
<span class="p_header">diff --git a/tools/objtool/builtin-check.c b/tools/objtool/builtin-check.c</span>
<span class="p_header">index e8a1f699058a..b8dadb050d2b 100644</span>
<span class="p_header">--- a/tools/objtool/builtin-check.c</span>
<span class="p_header">+++ b/tools/objtool/builtin-check.c</span>
<span class="p_chunk">@@ -757,11 +757,20 @@</span> <span class="p_context"> static struct rela *find_switch_table(struct objtool_file *file,</span>
 		     insn-&gt;jump_dest-&gt;offset &gt; orig_insn-&gt;offset))
 		    break;
 
<span class="p_add">+		/* look for a relocation which references .rodata */</span>
 		text_rela = find_rela_by_dest_range(insn-&gt;sec, insn-&gt;offset,
 						    insn-&gt;len);
<span class="p_del">-		if (text_rela &amp;&amp; text_rela-&gt;sym == file-&gt;rodata-&gt;sym)</span>
<span class="p_del">-			return find_rela_by_dest(file-&gt;rodata,</span>
<span class="p_del">-						 text_rela-&gt;addend);</span>
<span class="p_add">+		if (!text_rela || text_rela-&gt;sym != file-&gt;rodata-&gt;sym)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Make sure the .rodata address isn&#39;t associated with a</span>
<span class="p_add">+		 * symbol.  gcc jump tables are anonymous data.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (find_symbol_containing(file-&gt;rodata, text_rela-&gt;addend))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		return find_rela_by_dest(file-&gt;rodata, text_rela-&gt;addend);</span>
 	}
 
 	return NULL;
<span class="p_header">diff --git a/tools/objtool/elf.c b/tools/objtool/elf.c</span>
<span class="p_header">index 0d7983ac63ef..d897702ce742 100644</span>
<span class="p_header">--- a/tools/objtool/elf.c</span>
<span class="p_header">+++ b/tools/objtool/elf.c</span>
<span class="p_chunk">@@ -85,6 +85,18 @@</span> <span class="p_context"> struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset)</span>
 	return NULL;
 }
 
<span class="p_add">+struct symbol *find_symbol_containing(struct section *sec, unsigned long offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct symbol *sym;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(sym, &amp;sec-&gt;symbol_list, list)</span>
<span class="p_add">+		if (sym-&gt;type != STT_SECTION &amp;&amp;</span>
<span class="p_add">+		    offset &gt;= sym-&gt;offset &amp;&amp; offset &lt; sym-&gt;offset + sym-&gt;len)</span>
<span class="p_add">+			return sym;</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
 				     unsigned int len)
 {
<span class="p_header">diff --git a/tools/objtool/elf.h b/tools/objtool/elf.h</span>
<span class="p_header">index aa1ff6596684..731973e1a3f5 100644</span>
<span class="p_header">--- a/tools/objtool/elf.h</span>
<span class="p_header">+++ b/tools/objtool/elf.h</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"> struct elf {</span>
 struct elf *elf_open(const char *name);
 struct section *find_section_by_name(struct elf *elf, const char *name);
 struct symbol *find_symbol_by_offset(struct section *sec, unsigned long offset);
<span class="p_add">+struct symbol *find_symbol_containing(struct section *sec, unsigned long offset);</span>
 struct rela *find_rela_by_dest(struct section *sec, unsigned long offset);
 struct rela *find_rela_by_dest_range(struct section *sec, unsigned long offset,
 				     unsigned int len);
<span class="p_header">diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c</span>
<span class="p_header">index d281ae2b54e8..1d9c02bc00f1 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-event.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-event.c</span>
<span class="p_chunk">@@ -645,18 +645,31 @@</span> <span class="p_context"> static int add_exec_to_probe_trace_events(struct probe_trace_event *tevs,</span>
 	return ret;
 }
 
<span class="p_del">-static int add_module_to_probe_trace_events(struct probe_trace_event *tevs,</span>
<span class="p_del">-					    int ntevs, const char *module)</span>
<span class="p_add">+static int</span>
<span class="p_add">+post_process_module_probe_trace_events(struct probe_trace_event *tevs,</span>
<span class="p_add">+				       int ntevs, const char *module,</span>
<span class="p_add">+				       struct debuginfo *dinfo)</span>
 {
<span class="p_add">+	Dwarf_Addr text_offs = 0;</span>
 	int i, ret = 0;
 	char *mod_name = NULL;
<span class="p_add">+	struct map *map;</span>
 
 	if (!module)
 		return 0;
 
<span class="p_del">-	mod_name = find_module_name(module);</span>
<span class="p_add">+	map = get_target_map(module, false);</span>
<span class="p_add">+	if (!map || debuginfo__get_text_offset(dinfo, &amp;text_offs, true) &lt; 0) {</span>
<span class="p_add">+		pr_warning(&quot;Failed to get ELF symbols for %s\n&quot;, module);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	mod_name = find_module_name(module);</span>
 	for (i = 0; i &lt; ntevs; i++) {
<span class="p_add">+		ret = post_process_probe_trace_point(&amp;tevs[i].point,</span>
<span class="p_add">+						map, (unsigned long)text_offs);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			break;</span>
 		tevs[i].point.module =
 			strdup(mod_name ? mod_name : module);
 		if (!tevs[i].point.module) {
<span class="p_chunk">@@ -666,6 +679,8 @@</span> <span class="p_context"> static int add_module_to_probe_trace_events(struct probe_trace_event *tevs,</span>
 	}
 
 	free(mod_name);
<span class="p_add">+	map__put(map);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -722,7 +737,7 @@</span> <span class="p_context"> arch__post_process_probe_trace_events(struct perf_probe_event *pev __maybe_unuse</span>
 static int post_process_probe_trace_events(struct perf_probe_event *pev,
 					   struct probe_trace_event *tevs,
 					   int ntevs, const char *module,
<span class="p_del">-					   bool uprobe)</span>
<span class="p_add">+					   bool uprobe, struct debuginfo *dinfo)</span>
 {
 	int ret;
 
<span class="p_chunk">@@ -730,7 +745,8 @@</span> <span class="p_context"> static int post_process_probe_trace_events(struct perf_probe_event *pev,</span>
 		ret = add_exec_to_probe_trace_events(tevs, ntevs, module);
 	else if (module)
 		/* Currently ref_reloc_sym based probe is not for drivers */
<span class="p_del">-		ret = add_module_to_probe_trace_events(tevs, ntevs, module);</span>
<span class="p_add">+		ret = post_process_module_probe_trace_events(tevs, ntevs,</span>
<span class="p_add">+							     module, dinfo);</span>
 	else
 		ret = post_process_kernel_probe_trace_events(tevs, ntevs);
 
<span class="p_chunk">@@ -774,30 +790,27 @@</span> <span class="p_context"> static int try_to_find_probe_trace_events(struct perf_probe_event *pev,</span>
 		}
 	}
 
<span class="p_del">-	debuginfo__delete(dinfo);</span>
<span class="p_del">-</span>
 	if (ntevs &gt; 0) {	/* Succeeded to find trace events */
 		pr_debug(&quot;Found %d probe_trace_events.\n&quot;, ntevs);
 		ret = post_process_probe_trace_events(pev, *tevs, ntevs,
<span class="p_del">-						pev-&gt;target, pev-&gt;uprobes);</span>
<span class="p_add">+					pev-&gt;target, pev-&gt;uprobes, dinfo);</span>
 		if (ret &lt; 0 || ret == ntevs) {
<span class="p_add">+			pr_debug(&quot;Post processing failed or all events are skipped. (%d)\n&quot;, ret);</span>
 			clear_probe_trace_events(*tevs, ntevs);
 			zfree(tevs);
<span class="p_add">+			ntevs = 0;</span>
 		}
<span class="p_del">-		if (ret != ntevs)</span>
<span class="p_del">-			return ret &lt; 0 ? ret : ntevs;</span>
<span class="p_del">-		ntevs = 0;</span>
<span class="p_del">-		/* Fall through */</span>
 	}
 
<span class="p_add">+	debuginfo__delete(dinfo);</span>
<span class="p_add">+</span>
 	if (ntevs == 0)	{	/* No error but failed to find probe point. */
 		pr_warning(&quot;Probe point &#39;%s&#39; not found.\n&quot;,
 			   synthesize_perf_probe_point(&amp;pev-&gt;point));
 		return -ENOENT;
<span class="p_del">-	}</span>
<span class="p_del">-	/* Error path : ntevs &lt; 0 */</span>
<span class="p_del">-	pr_debug(&quot;An error occurred in debuginfo analysis (%d).\n&quot;, ntevs);</span>
<span class="p_del">-	if (ntevs &lt; 0) {</span>
<span class="p_add">+	} else if (ntevs &lt; 0) {</span>
<span class="p_add">+		/* Error path : ntevs &lt; 0 */</span>
<span class="p_add">+		pr_debug(&quot;An error occurred in debuginfo analysis (%d).\n&quot;, ntevs);</span>
 		if (ntevs == -EBADF)
 			pr_warning(&quot;Warning: No dwarf info found in the vmlinux - &quot;
 				&quot;please rebuild kernel with CONFIG_DEBUG_INFO=y.\n&quot;);
<span class="p_header">diff --git a/tools/perf/util/probe-finder.c b/tools/perf/util/probe-finder.c</span>
<span class="p_header">index df4debe564da..0d9d6e0803b8 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-finder.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-finder.c</span>
<span class="p_chunk">@@ -1501,7 +1501,8 @@</span> <span class="p_context"> int debuginfo__find_available_vars_at(struct debuginfo *dbg,</span>
 }
 
 /* For the kernel module, we need a special code to get a DIE */
<span class="p_del">-static int debuginfo__get_text_offset(struct debuginfo *dbg, Dwarf_Addr *offs)</span>
<span class="p_add">+int debuginfo__get_text_offset(struct debuginfo *dbg, Dwarf_Addr *offs,</span>
<span class="p_add">+				bool adjust_offset)</span>
 {
 	int n, i;
 	Elf32_Word shndx;
<span class="p_chunk">@@ -1530,6 +1531,8 @@</span> <span class="p_context"> static int debuginfo__get_text_offset(struct debuginfo *dbg, Dwarf_Addr *offs)</span>
 			if (!shdr)
 				return -ENOENT;
 			*offs = shdr-&gt;sh_addr;
<span class="p_add">+			if (adjust_offset)</span>
<span class="p_add">+				*offs -= shdr-&gt;sh_offset;</span>
 		}
 	}
 	return 0;
<span class="p_chunk">@@ -1543,16 +1546,12 @@</span> <span class="p_context"> int debuginfo__find_probe_point(struct debuginfo *dbg, unsigned long addr,</span>
 	Dwarf_Addr _addr = 0, baseaddr = 0;
 	const char *fname = NULL, *func = NULL, *basefunc = NULL, *tmp;
 	int baseline = 0, lineno = 0, ret = 0;
<span class="p_del">-	bool reloc = false;</span>
 
<span class="p_del">-retry:</span>
<span class="p_add">+	/* We always need to relocate the address for aranges */</span>
<span class="p_add">+	if (debuginfo__get_text_offset(dbg, &amp;baseaddr, false) == 0)</span>
<span class="p_add">+		addr += baseaddr;</span>
 	/* Find cu die */
 	if (!dwarf_addrdie(dbg-&gt;dbg, (Dwarf_Addr)addr, &amp;cudie)) {
<span class="p_del">-		if (!reloc &amp;&amp; debuginfo__get_text_offset(dbg, &amp;baseaddr) == 0) {</span>
<span class="p_del">-			addr += baseaddr;</span>
<span class="p_del">-			reloc = true;</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
 		pr_warning(&quot;Failed to find debug information for address %lx\n&quot;,
 			   addr);
 		ret = -EINVAL;
<span class="p_header">diff --git a/tools/perf/util/probe-finder.h b/tools/perf/util/probe-finder.h</span>
<span class="p_header">index f1d8558f498e..2956c5198652 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-finder.h</span>
<span class="p_header">+++ b/tools/perf/util/probe-finder.h</span>
<span class="p_chunk">@@ -46,6 +46,9 @@</span> <span class="p_context"> int debuginfo__find_trace_events(struct debuginfo *dbg,</span>
 int debuginfo__find_probe_point(struct debuginfo *dbg, unsigned long addr,
 				struct perf_probe_point *ppt);
 
<span class="p_add">+int debuginfo__get_text_offset(struct debuginfo *dbg, Dwarf_Addr *offs,</span>
<span class="p_add">+			       bool adjust_offset);</span>
<span class="p_add">+</span>
 /* Find a line range */
 int debuginfo__find_line_range(struct debuginfo *dbg, struct line_range *lr);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



