
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,3/6] iommu: add ARM short descriptor page table allocator. - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,3/6] iommu: add ARM short descriptor page table allocator.</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=123111">Yong Wu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 15, 2015, 9:43 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1431683009-18158-4-git-send-email-yong.wu@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6413231/mbox/"
   >mbox</a>
|
   <a href="/patch/6413231/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6413231/">/patch/6413231/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id DBAD49F1C1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 15 May 2015 09:45:50 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 4CE7F20437
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 15 May 2015 09:45:49 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 8A59F2041E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 15 May 2015 09:45:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755034AbbEOJpk (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 15 May 2015 05:45:40 -0400
Received: from mailgw01.mediatek.com ([210.61.82.183]:41505 &quot;EHLO
	mailgw01.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S1754829AbbEOJoI (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 15 May 2015 05:44:08 -0400
X-Listener-Flag: 11101
Received: from mtkhts09.mediatek.inc [(172.21.101.70)] by
	mailgw01.mediatek.com (envelope-from &lt;yong.wu@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 1398128934; Fri, 15 May 2015 17:44:07 +0800
Received: from localhost.localdomain (10.17.3.153) by mtkhts09.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.181.6;
	Fri, 15 May 2015 17:44:05 +0800
From: Yong Wu &lt;yong.wu@mediatek.com&gt;
To: Rob Herring &lt;robh+dt@kernel.org&gt;, Joerg Roedel &lt;joro@8bytes.org&gt;,
	Matthias Brugger &lt;matthias.bgg@gmail.com&gt;
CC: Robin Murphy &lt;robin.murphy@arm.com&gt;, Will Deacon &lt;will.deacon@arm.com&gt;,
	Daniel Kurtz &lt;djkurtz@google.com&gt;, Tomasz Figa &lt;tfiga@google.com&gt;,
	Lucas Stach &lt;l.stach@pengutronix.de&gt;,
	Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	&lt;linux-mediatek@lists.infradead.org&gt;,
	Sasha Hauer &lt;kernel@pengutronix.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;, &lt;pebolle@tiscali.nl&gt;,
	&lt;arnd@arndb.de&gt;, &lt;mitchelh@codeaurora.org&gt;, &lt;k.zhang@mediatek.com&gt;,
	&lt;youhua.li@mediatek.com&gt;, Yong Wu &lt;yong.wu@mediatek.com&gt;
Subject: [PATCH v2 3/6] iommu: add ARM short descriptor page table allocator.
Date: Fri, 15 May 2015 17:43:26 +0800
Message-ID: &lt;1431683009-18158-4-git-send-email-yong.wu@mediatek.com&gt;
X-Mailer: git-send-email 1.8.1.1.dirty
In-Reply-To: &lt;1431683009-18158-1-git-send-email-yong.wu@mediatek.com&gt;
References: &lt;1431683009-18158-1-git-send-email-yong.wu@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - May 15, 2015, 9:43 a.m.</div>
<pre class="content">
This patch is for ARM Short Descriptor Format.It has 2-levels
pagetable and the allocator supports 4K/64K/1M/16M.
<span class="signed-off-by">
Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig                |   7 +
 drivers/iommu/Makefile               |   1 +
 drivers/iommu/io-pgtable-arm-short.c | 490 +++++++++++++++++++++++++++++++++++
 drivers/iommu/io-pgtable.c           |   4 +
 drivers/iommu/io-pgtable.h           |   6 +
 5 files changed, 508 insertions(+)
 create mode 100644 drivers/iommu/io-pgtable-arm-short.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - May 15, 2015, 3:30 p.m.</div>
<pre class="content">
Oops, seems I&#39;m rather behind on things - I started this review on the 
RFC, but I&#39;ll finish it here...

On 15/05/15 10:43, Yong Wu wrote:
<span class="quote">&gt; This patch is for ARM Short Descriptor Format.It has 2-levels</span>
<span class="quote">&gt; pagetable and the allocator supports 4K/64K/1M/16M.</span>
<span class="quote">&gt;</span>

 From the look of the code, this doesn&#39;t fully support partial unmaps 
(i.e. splitting block entries), am I right? That&#39;s OK for DMA-API use, 
since that doesn&#39;t permit partial unmaps anyway, but I&#39;d say it&#39;s worth 
making it clear that that&#39;s still a TODO in order for short-descriptor 
mappings to fully support arbitrary raw IOMMU API usage.
<span class="quote">
&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;   drivers/iommu/Kconfig                |   7 +</span>
<span class="quote">&gt;   drivers/iommu/Makefile               |   1 +</span>
<span class="quote">&gt;   drivers/iommu/io-pgtable-arm-short.c | 490 +++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;   drivers/iommu/io-pgtable.c           |   4 +</span>
<span class="quote">&gt;   drivers/iommu/io-pgtable.h           |   6 +</span>
<span class="quote">&gt;   5 files changed, 508 insertions(+)</span>
<span class="quote">&gt;   create mode 100644 drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; index 1ae4e54..3d2eac6 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/Kconfig</span>
<span class="quote">&gt; +++ b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; @@ -39,6 +39,13 @@ config IOMMU_IO_PGTABLE_LPAE_SELFTEST</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;            If unsure, say N here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +config IOMMU_IO_PGTABLE_SHORT</span>
<span class="quote">&gt; +       bool &quot;ARMv7/v8 Short Descriptor Format&quot;</span>
<span class="quote">&gt; +       select IOMMU_IO_PGTABLE</span>
<span class="quote">&gt; +       help</span>
<span class="quote">&gt; +         Enable support for the ARM Short descriptor pagetable format.</span>
<span class="quote">&gt; +         It has 2-levels pagetable and The allocator supports 4K/64K/1M/16M.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   endmenu</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   config IOMMU_IOVA</span>
<span class="quote">&gt; diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="quote">&gt; index 080ffab..815b3c8 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/Makefile</span>
<span class="quote">&gt; +++ b/drivers/iommu/Makefile</span>
<span class="quote">&gt; @@ -3,6 +3,7 @@ obj-$(CONFIG_IOMMU_API) += iommu-traces.o</span>
<span class="quote">&gt;   obj-$(CONFIG_IOMMU_API) += iommu-sysfs.o</span>
<span class="quote">&gt;   obj-$(CONFIG_IOMMU_IO_PGTABLE) += io-pgtable.o</span>
<span class="quote">&gt;   obj-$(CONFIG_IOMMU_IO_PGTABLE_LPAE) += io-pgtable-arm.o</span>
<span class="quote">&gt; +obj-$(CONFIG_IOMMU_IO_PGTABLE_SHORT) += io-pgtable-arm-short.o</span>
<span class="quote">&gt;   obj-$(CONFIG_IOMMU_IOVA) += iova.o</span>
<span class="quote">&gt;   obj-$(CONFIG_OF_IOMMU) += of_iommu.o</span>
<span class="quote">&gt;   obj-$(CONFIG_MSM_IOMMU) += msm_iommu.o msm_iommu_dev.o</span>
<span class="quote">&gt; diff --git a/drivers/iommu/io-pgtable-arm-short.c b/drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..cc286ce5</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; @@ -0,0 +1,490 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="quote">&gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is distributed in the hope that it will be useful,</span>
<span class="quote">&gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="quote">&gt; + * GNU General Public License for more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define pr_fmt(fmt)    &quot;arm-short-desc io-pgtable: &quot;fmt</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/err.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/errno.h&gt;</span>

Alphabetically-sorted includes, please. Also, this list doesn&#39;t look 
particularly correct - e.g. I don&#39;t think you&#39;re actually using anything 
from mm.h, but you are relying on stuff from kernel.h, slab.h, gfp.h, 
etc. being pulled in indirectly.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +#include &quot;io-pgtable.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +typedef u32 arm_short_iopte;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct arm_short_io_pgtable {</span>
<span class="quote">&gt; +       struct io_pgtable       iop;</span>
<span class="quote">&gt; +       struct kmem_cache       *ptekmem;</span>
<span class="quote">&gt; +       size_t                  pgd_size;</span>
<span class="quote">&gt; +       void                    *pgd;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define io_pgtable_short_to_data(x)                            \</span>
<span class="quote">&gt; +       container_of((x), struct arm_short_io_pgtable, iop)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define io_pgtable_ops_to_pgtable(x)                           \</span>
<span class="quote">&gt; +       container_of((x), struct io_pgtable, ops)</span>

This macro may as well be factored out into io-pgtable.h before 
duplication spreads any further. I don&#39;t see any reason for it not to 
live alongside the definition of struct io_pgtable, anyway.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +#define io_pgtable_short_ops_to_data(x)                                \</span>
<span class="quote">&gt; +       io_pgtable_short_to_data(io_pgtable_ops_to_pgtable(x))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_MAX_ADDR_BITS                        32</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_PGDIR_SHIFT                  20</span>
<span class="quote">&gt; +#define ARM_SHORT_PAGE_SHIFT                   12</span>
<span class="quote">&gt; +#define ARM_SHORT_PTRS_PER_PTE                 256</span>
<span class="quote">&gt; +#define ARM_SHORT_BYTES_PER_PTE                        1024</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* 1 level pagetable */</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE              (0x1)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE_MSK          (0x3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION           (0x2)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_SUPERSECTION      (0x2 | (1 &lt;&lt; 18))</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION_MSK       (0x3 | (1 &lt;&lt; 18))</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_IS_PAGE(pgd)      (((pgd) &amp; 0x3) == 1)</span>

This confused me on first glance looking at the places it&#39;s used, 
because it&#39;s not actually referring to a thing which is a page. Maybe 
..._IS_TABLE would be a better name?
<span class="quote">
&gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SECTION(pgd)           \</span>
<span class="quote">&gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; +               == ARM_SHORT_F_PGD_TYPE_SECTION)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(pgd)      \</span>
<span class="quote">&gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; +               == ARM_SHORT_F_PGD_TYPE_SUPERSECTION)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_B_BIT                  BIT(2)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_C_BIT                  BIT(3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_IMPLE_BIT              BIT(9)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_S_BIT                  BIT(16)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_NG_BIT                 BIT(17)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_NS_BIT_PAGE            BIT(3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_NS_BIT_SECTION         BIT(19)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_PA_PAGETABLE_MSK       0xfffffc00</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_PA_SECTION_MSK         0xfff00000</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK    0xff000000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* 2 level pagetable */</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_TYPE_GET(val)          ((val) &amp; 0x3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_TYPE_LARGE             BIT(0)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_TYPE_SMALL             BIT(1)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_B_BIT                  BIT(2)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_C_BIT                  BIT(3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_IMPLE_BIT              BIT(9)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_S_BIT                  BIT(10)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_PA_LARGE_MSK            0xffff0000</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_PA_SMALL_MSK            0xfffff000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_PGD_IDX(a)                   ((a) &gt;&gt; ARM_SHORT_PGDIR_SHIFT)</span>
<span class="quote">&gt; +#define ARM_SHORT_PTE_IDX(a)                   \</span>
<span class="quote">&gt; +       (((a) &gt;&gt; ARM_SHORT_PAGE_SHIFT) &amp; 0xff)</span>
<span class="quote">&gt; +#define ARM_SHORT_GET_PTE_VA(pgd)              \</span>
<span class="quote">&gt; +       (phys_to_virt((unsigned long)pgd &amp; ARM_SHORT_F_PGD_PA_PAGETABLE_MSK))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte *</span>
<span class="quote">&gt; +arm_short_get_pte_in_pgd(arm_short_iopte curpgd, unsigned int iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pte = ARM_SHORT_GET_PTE_VA(curpgd);</span>
<span class="quote">&gt; +       pte += ARM_SHORT_PTE_IDX(iova);</span>
<span class="quote">&gt; +       return pte;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte *</span>
<span class="quote">&gt; +arm_short_supersection_start(arm_short_iopte *pgd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       return (arm_short_iopte *)(round_down((unsigned long)pgd, (16 * 4)));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int _arm_short_check_free_pte(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; +                                    arm_short_iopte *pgd)</span>

Given that this is only returning success/failure, it should probably be 
bool rather than int.
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pte = ARM_SHORT_GET_PTE_VA(*pgd);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; ARM_SHORT_PTRS_PER_PTE; i++) {</span>
<span class="quote">&gt; +               if (pte[i] != 0)</span>
<span class="quote">&gt; +                       return 1;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Free PTE */</span>
<span class="quote">&gt; +       kmem_cache_free(data-&gt;ptekmem, pte);</span>
<span class="quote">&gt; +       *pgd = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static phys_addr_t arm_short_iova_to_phys(struct io_pgtable_ops *ops,</span>
<span class="quote">&gt; +                                         unsigned long iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; +       arm_short_iopte *pte, *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; +       phys_addr_t pa = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="quote">&gt; +               u8 pte_type;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; +               pte_type = ARM_SHORT_F_PTE_TYPE_GET(*pte);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (pte_type == ARM_SHORT_F_PTE_TYPE_LARGE) {</span>
<span class="quote">&gt; +                       pa = (*pte) &amp; ARM_SHORT_F_PTE_PA_LARGE_MSK;</span>
<span class="quote">&gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PTE_PA_LARGE_MSK);</span>
<span class="quote">&gt; +               } else if (pte_type == ARM_SHORT_F_PTE_TYPE_SMALL) {</span>
<span class="quote">&gt; +                       pa = (*pte) &amp; ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="quote">&gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PTE_PA_SMALL_MSK);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="quote">&gt; +                       pa = (*pgd) &amp; ARM_SHORT_F_PGD_PA_SECTION_MSK;</span>
<span class="quote">&gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PGD_PA_SECTION_MSK);</span>
<span class="quote">&gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="quote">&gt; +                       pa = (*pgd) &amp; ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK;</span>
<span class="quote">&gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return pa;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int arm_short_unmap(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; +                          size_t size)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; +       arm_short_iopte *pgd;</span>
<span class="quote">&gt; +       unsigned long iova_start = iova;</span>
<span class="quote">&gt; +       unsigned long long end_plus_1 = iova + size;</span>

Since everything&#39;s at page granularity, working with IOVA PFNs rather 
than raw addresses might be more convenient, and also sidesteps the 
32-bit overflow problem. On 64-bit platforms, we&#39;re wasting a whole 95 
bits of a long long here ;)
<span class="quote">
&gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       do {</span>
<span class="quote">&gt; +               pgd = (arm_short_iopte *)data-&gt;pgd + ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="quote">&gt; +                       arm_short_iopte *pte;</span>
<span class="quote">&gt; +                       unsigned int pte_offset;</span>
<span class="quote">&gt; +                       unsigned int num_to_clean;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       pte_offset = ARM_SHORT_PTE_IDX(iova);</span>
<span class="quote">&gt; +                       num_to_clean =</span>
<span class="quote">&gt; +                           min((unsigned int)((end_plus_1 - iova) / PAGE_SIZE),</span>

Shouldn&#39;t this be page size for the IOMMU, not the CPU? I&#39;m a bit slow 
today, but this looks like it might go wrong when PAGE_SIZE &gt; 4K.
<span class="quote">
&gt; +                               (ARM_SHORT_PTRS_PER_PTE - pte_offset));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       memset(pte, 0, num_to_clean * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       ret = _arm_short_check_free_pte(data, pgd);</span>
<span class="quote">&gt; +                       if (ret == 1)/* pte is not freed, need to flush pte */</span>
<span class="quote">&gt; +                               tlb-&gt;flush_pgtable(</span>
<span class="quote">&gt; +                                       pte,</span>
<span class="quote">&gt; +                                       num_to_clean * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                       cookie);</span>
<span class="quote">&gt; +                       else</span>
<span class="quote">&gt; +                               tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                                  cookie);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       iova += num_to_clean &lt;&lt; PAGE_SHIFT;</span>
<span class="quote">&gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="quote">&gt; +                       *pgd = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                          cookie);</span>
<span class="quote">&gt; +                       iova += SZ_1M;</span>
<span class="quote">&gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="quote">&gt; +                       arm_short_iopte *start;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       start = arm_short_supersection_start(pgd);</span>
<span class="quote">&gt; +                       if (unlikely(start != pgd))</span>
<span class="quote">&gt; +                               pr_warn(&quot;%s:suppersection start isn&#39;t aligned.iova=0x%lx,pgd=0x%x\n&quot;,</span>

Nit: typo in &quot;supersection&quot; here.
<span class="quote">
&gt; +                                       __func__, iova, *pgd);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       memset(start, 0, 16 * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       tlb-&gt;flush_pgtable(start, 16 * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                          cookie);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       iova = (iova + SZ_16M) &amp; (~(SZ_16M - 1));</span>

iova = ALIGN(iova + SZ_16M, SZ_16M);

Except that being unaligned in the first place is an error condition, so 
it would make more sense to just have &quot;iova += SZ_16M;&quot; here, and put 
&quot;iova = ALIGN(iova, SZ_16M) after the warning in the error path above.

Since you don&#39;t handle splitting block mappings, and you also seem to be 
missing an equivalent warning for unaligned second-level large pages, it 
might be better to simply return an error if the requested size and 
alignment don&#39;t exactly match the type of entry found, rather than let 
the page tables get into an unexpectedly inconsistent state.
<span class="quote">
&gt; +               } else {</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       } while (iova &lt; end_plus_1 &amp;&amp; iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       tlb-&gt;tlb_add_flush(iova_start, size, true, cookie);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte __arm_short_pte_port(unsigned int prot, bool large)</span>

I assume _port is a typo of _prot
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte pteprot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pteprot = ARM_SHORT_F_PTE_S_BIT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pteprot |= large ? ARM_SHORT_F_PTE_TYPE_LARGE :</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PTE_TYPE_SMALL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; +               pteprot |=  ARM_SHORT_F_PTE_B_BIT | ARM_SHORT_F_PTE_C_BIT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return pteprot;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte __arm_short_pgd_port(int prot, bool super)</span>

Ditto
<span class="quote">
&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte pgdprot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgdprot = ARM_SHORT_F_PGD_S_BIT;</span>
<span class="quote">&gt; +       pgdprot |= super ? ARM_SHORT_F_PGD_TYPE_SUPERSECTION :</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PGD_TYPE_SECTION;</span>
<span class="quote">&gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; +               pgdprot |= ARM_SHORT_F_PGD_C_BIT | ARM_SHORT_F_PGD_B_BIT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return pgdprot;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int _arm_short_map_page(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; +                              unsigned int iova, phys_addr_t pa,</span>
<span class="quote">&gt; +                              unsigned int prot, bool largepage)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; +       arm_short_iopte pgdprot, pteprot;</span>
<span class="quote">&gt; +       arm_short_iopte mask = largepage ? ARM_SHORT_F_PTE_PA_LARGE_MSK :</span>
<span class="quote">&gt; +                                               ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="quote">&gt; +       int i, ptenum = largepage ? 16 : 1;</span>
<span class="quote">&gt; +       bool ptenew = false;</span>
<span class="quote">&gt; +       void *pte_new_va;</span>
<span class="quote">&gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if ((iova | pa) &amp; (~mask)) {</span>
<span class="quote">&gt; +               pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="quote">&gt; +                      iova, &amp;pa, largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>

Nit: you may as well just have largepage ?  &quot;large&quot; : &quot;small&quot; here and 
&quot;...type=%s page...&quot; in the format string.
<span class="quote">
&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgdprot = ARM_SHORT_F_PGD_TYPE_PAGE;</span>
<span class="quote">&gt; +       if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="quote">&gt; +               pgdprot |= ARM_SHORT_F_PGD_NS_BIT_PAGE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!(*pgd)) {</span>
<span class="quote">&gt; +               pte_new_va = kmem_cache_zalloc(data-&gt;ptekmem, GFP_KERNEL);</span>
<span class="quote">&gt; +               if (unlikely(!pte_new_va)) {</span>
<span class="quote">&gt; +                       pr_err(&quot;Failed to alloc pte\n&quot;);</span>

The allocator should already print the details of a failure, so I don&#39;t 
think this adds much.
<span class="quote">
&gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               /* Check pte alignment -- must 1K align */</span>
<span class="quote">&gt; +               if (unlikely((unsigned long)pte_new_va &amp;</span>
<span class="quote">&gt; +                            (ARM_SHORT_BYTES_PER_PTE - 1))) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The new pte is not aligned! (va=0x%p)\n&quot;,</span>
<span class="quote">&gt; +                              pte_new_va);</span>
<span class="quote">&gt; +                       kmem_cache_free(data-&gt;ptekmem, (void *)pte_new_va);</span>
<span class="quote">&gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; +               }</span>

Can this ever actually happen? Besides, if kmem_cache_alloc isn&#39;t 
honouring the alignment specified in kmem_cache_create, I think the 
kernel might have bigger problems anyway...
<span class="quote">
&gt; +               ptenew = true;</span>
<span class="quote">&gt; +               *pgd = virt_to_phys(pte_new_va) | pgdprot;</span>
<span class="quote">&gt; +               kmemleak_ignore(pte_new_va);</span>
<span class="quote">&gt; +               data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                                cookie);</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               /* Someone else may have allocated for this pgd */</span>
<span class="quote">&gt; +               if (((*pgd) &amp; (~ARM_SHORT_F_PGD_PA_PAGETABLE_MSK)) != pgdprot) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The prot of old pgd is not Right!iova=0x%x pgd=0x%x pgprot=0x%x\n&quot;,</span>
<span class="quote">&gt; +                              iova, (*pgd), pgdprot);</span>
<span class="quote">&gt; +                       return -EEXIST;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pteprot = (arm_short_iopte)pa;</span>
<span class="quote">&gt; +       pteprot |= __arm_short_pte_port(prot, largepage);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pr_debug(&quot;iova:0x%x,pte:0x%p(0x%x),prot:0x%x-%s\n&quot;,</span>
<span class="quote">&gt; +                iova, pte, ARM_SHORT_PTE_IDX(iova), pteprot,</span>
<span class="quote">&gt; +                largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>

String redundancy nit again, assuming we actually need the debug output 
at all.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; ptenum; i++) {</span>
<span class="quote">&gt; +               if (pte[i]) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The To-Map pte exists!(iova=0x%x pte=0x%x i=%d)\n&quot;,</span>
<span class="quote">&gt; +                              iova, pte[i], i);</span>
<span class="quote">&gt; +                       goto err_out;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               pte[i] = pteprot;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pte, ptenum * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                        cookie);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; + err_out:</span>
<span class="quote">&gt; +       for (i--; i &gt;= 0; i--)</span>

Probably bikeshedding, but I actually had to stop and think to work out 
that this wasn&#39;t anything more special than while(i--)...
<span class="quote">
&gt; +               pte[i] = 0;</span>
<span class="quote">&gt; +       if (ptenew)</span>
<span class="quote">&gt; +               kmem_cache_free(data-&gt;ptekmem, pte_new_va);</span>
<span class="quote">&gt; +       return -EEXIST;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int _arm_short_map_section(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; +                                 unsigned int iova, phys_addr_t pa,</span>
<span class="quote">&gt; +                                 int prot, bool supersection)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte pgprot;</span>
<span class="quote">&gt; +       arm_short_iopte mask = supersection ?</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK :</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PGD_PA_SECTION_MSK;</span>
<span class="quote">&gt; +       arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +       unsigned int pgdnum = supersection ? 16 : 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if ((iova | pa) &amp; (~mask)) {</span>
<span class="quote">&gt; +               pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="quote">&gt; +                      iova, &amp;pa, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgprot = (arm_short_iopte)pa;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="quote">&gt; +               pgprot |= ARM_SHORT_F_PGD_NS_BIT_SECTION;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgprot |= __arm_short_pgd_port(prot, supersection);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pr_debug(&quot;iova:0x%x,pgd:0x%p(0x%p+0x%x),value:0x%x-%s\n&quot;,</span>
<span class="quote">&gt; +                iova, pgd, data-&gt;pgd, ARM_SHORT_PGD_IDX(iova),</span>
<span class="quote">&gt; +                pgprot, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; pgdnum; i++) {</span>
<span class="quote">&gt; +               if (unlikely(*pgd)) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The To-Map pdg exists!(iova=0x%x pgd=0x%x i=%d)\n&quot;,</span>

Typo of &quot;pgd&quot; here
<span class="quote">
&gt; +                              iova, pgd[i], i);</span>
<span class="quote">&gt; +                       goto err_out;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               pgd[i] = pgprot;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd,</span>
<span class="quote">&gt; +                                        pgdnum * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                        data-&gt;iop.cookie);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; + err_out:</span>
<span class="quote">&gt; +       for (i--; i &gt;= 0; i--)</span>
<span class="quote">&gt; +               pgd[i] = 0;</span>
<span class="quote">&gt; +       return -EEXIST;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int arm_short_map(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; +                        phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!(prot &amp; (IOMMU_READ | IOMMU_WRITE)))</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (size == SZ_4K) {/* most case */</span>
<span class="quote">&gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; +       } else if (size == SZ_64K) {</span>
<span class="quote">&gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; +       } else if (size == SZ_1M) {</span>
<span class="quote">&gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; +       } else if (size == SZ_16M) {</span>
<span class="quote">&gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; +       }</span>

I think this might be nicer as a switch statement. You could perhaps 
move the add_flush beforehand (since it&#39;s unconditional here anyway) and 
get rid of ret altogether.

Alternatively, given that map_page and map_section are so similar, maybe 
it&#39;s worth sorting out the pgprot and pgd/pte pointer for the 
page/section distinction here, then just passing those to a single 
function which maps compound/non-compound leaf entries.
<span class="quote">
&gt; +       tlb-&gt;tlb_add_flush(iova, size, true, data-&gt;iop.cookie);</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct io_pgtable *</span>
<span class="quote">&gt; +arm_short_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (cfg-&gt;ias != 32)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (cfg-&gt;oas &gt; ARM_SHORT_MAX_ADDR_BITS)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       cfg-&gt;pgsize_bitmap &amp;= SZ_4K | SZ_64K | SZ_1M | SZ_16M;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!data)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;pgd_size = SZ_16K;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;pgd = alloc_pages_exact(data-&gt;pgd_size, GFP_KERNEL | __GFP_ZERO);</span>

I think this needs __GFP_DMA too, to ensure the pgd lies below the 4GB 
boundary on arm64/LPAE systems with memory above that.
<span class="quote">
&gt; +       if (!data-&gt;pgd)</span>
<span class="quote">&gt; +               goto out_free_data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       cfg-&gt;tlb-&gt;flush_pgtable(data-&gt;pgd, data-&gt;pgd_size, cookie);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* kmem for pte */</span>
<span class="quote">&gt; +       data-&gt;ptekmem = kmem_cache_create(&quot;short-descriptor-pte&quot;,</span>
<span class="quote">&gt; +                                          ARM_SHORT_BYTES_PER_PTE,</span>
<span class="quote">&gt; +                                          ARM_SHORT_BYTES_PER_PTE,</span>
<span class="quote">&gt; +                                          0, NULL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (IS_ERR_OR_NULL(data-&gt;ptekmem)) {</span>
<span class="quote">&gt; +               pr_err(&quot;Failed to Create cached mem for PTE %ld\n&quot;,</span>
<span class="quote">&gt; +                      PTR_ERR(data-&gt;ptekmem));</span>
<span class="quote">&gt; +               goto out_free_pte;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* TTBRs */</span>
<span class="quote">&gt; +       cfg-&gt;arm_short_cfg.ttbr[0] = virt_to_phys(data-&gt;pgd);</span>
<span class="quote">&gt; +       cfg-&gt;arm_short_cfg.ttbr[1] = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       cfg-&gt;arm_short_cfg.tcr = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;iop.ops = (struct io_pgtable_ops) {</span>
<span class="quote">&gt; +               .map            = arm_short_map,</span>
<span class="quote">&gt; +               .unmap          = arm_short_unmap,</span>
<span class="quote">&gt; +               .iova_to_phys   = arm_short_iova_to_phys,</span>
<span class="quote">&gt; +       };</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return &amp;data-&gt;iop;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +out_free_pte:</span>
<span class="quote">&gt; +       free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="quote">&gt; +out_free_data:</span>
<span class="quote">&gt; +       kfree(data);</span>
<span class="quote">&gt; +       return NULL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void arm_short_free_pgtable(struct io_pgtable *iop)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_to_data(iop);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       kmem_cache_destroy(data-&gt;ptekmem);</span>
<span class="quote">&gt; +       free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="quote">&gt; +       kfree(data);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct io_pgtable_init_fns io_pgtable_arm_short_init_fns = {</span>
<span class="quote">&gt; +       .alloc  = arm_short_alloc_pgtable,</span>
<span class="quote">&gt; +       .free   = arm_short_free_pgtable,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; diff --git a/drivers/iommu/io-pgtable.c b/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; index 6436fe2..14a9b3a 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; @@ -28,6 +28,7 @@ extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s1_init_fns;</span>
<span class="quote">&gt;   extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s2_init_fns;</span>
<span class="quote">&gt;   extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s1_init_fns;</span>
<span class="quote">&gt;   extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s2_init_fns;</span>
<span class="quote">&gt; +extern struct io_pgtable_init_fns io_pgtable_arm_short_init_fns;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   static const struct io_pgtable_init_fns *</span>
<span class="quote">&gt;   io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =</span>
<span class="quote">&gt; @@ -38,6 +39,9 @@ io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =</span>
<span class="quote">&gt;          [ARM_64_LPAE_S1] = &amp;io_pgtable_arm_64_lpae_s1_init_fns,</span>
<span class="quote">&gt;          [ARM_64_LPAE_S2] = &amp;io_pgtable_arm_64_lpae_s2_init_fns,</span>
<span class="quote">&gt;   #endif</span>
<span class="quote">&gt; +#ifdef CONFIG_IOMMU_IO_PGTABLE_SHORT</span>
<span class="quote">&gt; +       [ARM_SHORT_DESC] = &amp;io_pgtable_arm_short_init_fns,</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;   };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   struct io_pgtable_ops *alloc_io_pgtable_ops(enum io_pgtable_fmt fmt,</span>
<span class="quote">&gt; diff --git a/drivers/iommu/io-pgtable.h b/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; index 10e32f6..47efaab 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; +++ b/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; @@ -9,6 +9,7 @@ enum io_pgtable_fmt {</span>
<span class="quote">&gt;          ARM_32_LPAE_S2,</span>
<span class="quote">&gt;          ARM_64_LPAE_S1,</span>
<span class="quote">&gt;          ARM_64_LPAE_S2,</span>
<span class="quote">&gt; +       ARM_SHORT_DESC,</span>
<span class="quote">&gt;          IO_PGTABLE_NUM_FMTS,</span>
<span class="quote">&gt;   };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -62,6 +63,11 @@ struct io_pgtable_cfg {</span>
<span class="quote">&gt;                          u64     vttbr;</span>
<span class="quote">&gt;                          u64     vtcr;</span>
<span class="quote">&gt;                  } arm_lpae_s2_cfg;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               struct {</span>
<span class="quote">&gt; +                       u64     ttbr[2];</span>
<span class="quote">&gt; +                       u64     tcr;</span>

The ARM ARM defines these all as 32-bit registers for the 
short-descriptor format, so I think u32 would be more appropriate - 
better to let the compiler truncate things and warn about it, than have 
the hardware do it silently at runtime ;)
<span class="quote">
&gt; +               } arm_short_cfg;</span>
<span class="quote">&gt;          };</span>
<span class="quote">&gt;   };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; 1.8.1.1.dirty</span>
<span class="quote">&gt;</span>

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - May 22, 2015, 3:14 a.m.</div>
<pre class="content">
Hi Robin,
    Thanks very much for so detail suggestion.
    please also help check my comment, the others i will change in next
time.
On Fri, 2015-05-15 at 16:30 +0100, Robin Murphy wrote:
<span class="quote">&gt; Oops, seems I&#39;m rather behind on things - I started this review on the </span>
<span class="quote">&gt; RFC, but I&#39;ll finish it here...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 15/05/15 10:43, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; This patch is for ARM Short Descriptor Format.It has 2-levels</span>
<span class="quote">&gt; &gt; pagetable and the allocator supports 4K/64K/1M/16M.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;  From the look of the code, this doesn&#39;t fully support partial unmaps </span>
<span class="quote">&gt; (i.e. splitting block entries), am I right? That&#39;s OK for DMA-API use, </span>
<span class="quote">&gt; since that doesn&#39;t permit partial unmaps anyway, but I&#39;d say it&#39;s worth </span>
<span class="quote">&gt; making it clear that that&#39;s still a TODO in order for short-descriptor </span>
<span class="quote">&gt; mappings to fully support arbitrary raw IOMMU API usage.</span>
Yes. I don&#39;t add split right now due to I check that
iommu_map/iommu_unmap make sure iova|pa be aligned.

I will add split for fully support in next version. Thanks.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;   drivers/iommu/Kconfig                |   7 +</span>
<span class="quote">&gt; &gt;   drivers/iommu/Makefile               |   1 +</span>
<span class="quote">&gt; &gt;   drivers/iommu/io-pgtable-arm-short.c | 490 +++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;   drivers/iommu/io-pgtable.c           |   4 +</span>
<span class="quote">&gt; &gt;   drivers/iommu/io-pgtable.h           |   6 +</span>
<span class="quote">&gt; &gt;   5 files changed, 508 insertions(+)</span>
<span class="quote">&gt; &gt;   create mode 100644 drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; &gt; index 1ae4e54..3d2eac6 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/Kconfig</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; &gt; @@ -39,6 +39,13 @@ config IOMMU_IO_PGTABLE_LPAE_SELFTEST</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;            If unsure, say N here.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; +config IOMMU_IO_PGTABLE_SHORT</span>
<span class="quote">&gt; &gt; +       bool &quot;ARMv7/v8 Short Descriptor Format&quot;</span>
<span class="quote">&gt; &gt; +       select IOMMU_IO_PGTABLE</span>
<span class="quote">&gt; &gt; +       help</span>
<span class="quote">&gt; &gt; +         Enable support for the ARM Short descriptor pagetable format.</span>
<span class="quote">&gt; &gt; +         It has 2-levels pagetable and The allocator supports 4K/64K/1M/16M.</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;   endmenu</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;   config IOMMU_IOVA</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="quote">&gt; &gt; index 080ffab..815b3c8 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/Makefile</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/Makefile</span>
<span class="quote">&gt; &gt; @@ -3,6 +3,7 @@ obj-$(CONFIG_IOMMU_API) += iommu-traces.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_IOMMU_API) += iommu-sysfs.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_IOMMU_IO_PGTABLE) += io-pgtable.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_IOMMU_IO_PGTABLE_LPAE) += io-pgtable-arm.o</span>
<span class="quote">&gt; &gt; +obj-$(CONFIG_IOMMU_IO_PGTABLE_SHORT) += io-pgtable-arm-short.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_IOMMU_IOVA) += iova.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_OF_IOMMU) += of_iommu.o</span>
<span class="quote">&gt; &gt;   obj-$(CONFIG_MSM_IOMMU) += msm_iommu.o msm_iommu_dev.o</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/io-pgtable-arm-short.c b/drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; &gt; new file mode 100644</span>
<span class="quote">&gt; &gt; index 0000000..cc286ce5</span>
<span class="quote">&gt; &gt; --- /dev/null</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; &gt; @@ -0,0 +1,490 @@</span>
<span class="quote">&gt; &gt; +/*</span>
<span class="quote">&gt; &gt; + * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="quote">&gt; &gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; + *</span>
<span class="quote">&gt; &gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; &gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; &gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; &gt; + *</span>
<span class="quote">&gt; &gt; + * This program is distributed in the hope that it will be useful,</span>
<span class="quote">&gt; &gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; &gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="quote">&gt; &gt; + * GNU General Public License for more details.</span>
<span class="quote">&gt; &gt; + */</span>
<span class="quote">&gt; &gt; +#define pr_fmt(fmt)    &quot;arm-short-desc io-pgtable: &quot;fmt</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#include &lt;linux/err.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; &gt; +#include &lt;linux/errno.h&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Alphabetically-sorted includes, please. Also, this list doesn&#39;t look </span>
<span class="quote">&gt; particularly correct - e.g. I don&#39;t think you&#39;re actually using anything </span>
<span class="quote">&gt; from mm.h, but you are relying on stuff from kernel.h, slab.h, gfp.h, </span>
<span class="quote">&gt; etc. being pulled in indirectly.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#include &quot;io-pgtable.h&quot;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +typedef u32 arm_short_iopte;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct arm_short_io_pgtable {</span>
<span class="quote">&gt; &gt; +       struct io_pgtable       iop;</span>
<span class="quote">&gt; &gt; +       struct kmem_cache       *ptekmem;</span>
<span class="quote">&gt; &gt; +       size_t                  pgd_size;</span>
<span class="quote">&gt; &gt; +       void                    *pgd;</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define io_pgtable_short_to_data(x)                            \</span>
<span class="quote">&gt; &gt; +       container_of((x), struct arm_short_io_pgtable, iop)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define io_pgtable_ops_to_pgtable(x)                           \</span>
<span class="quote">&gt; &gt; +       container_of((x), struct io_pgtable, ops)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This macro may as well be factored out into io-pgtable.h before </span>
<span class="quote">&gt; duplication spreads any further. I don&#39;t see any reason for it not to </span>
<span class="quote">&gt; live alongside the definition of struct io_pgtable, anyway.</span>
Thanks. I will move it into io-pgtable.h.
Then I think this also should be deleted in io-pgtable-arm.c.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define io_pgtable_short_ops_to_data(x)                                \</span>
<span class="quote">&gt; &gt; +       io_pgtable_short_to_data(io_pgtable_ops_to_pgtable(x))</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_MAX_ADDR_BITS                        32</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PGDIR_SHIFT                  20</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PAGE_SHIFT                   12</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PTRS_PER_PTE                 256</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_BYTES_PER_PTE                        1024</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +/* 1 level pagetable */</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE              (0x1)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE_MSK          (0x3)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION           (0x2)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_SUPERSECTION      (0x2 | (1 &lt;&lt; 18))</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION_MSK       (0x3 | (1 &lt;&lt; 18))</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_IS_PAGE(pgd)      (((pgd) &amp; 0x3) == 1)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This confused me on first glance looking at the places it&#39;s used, </span>
<span class="quote">&gt; because it&#39;s not actually referring to a thing which is a page. Maybe </span>
<span class="quote">&gt; ..._IS_TABLE would be a better name?</span>
Yes. It is better. From the spec, it is &quot;page table&quot;.
Then How about &quot;ARM_SHORT_F_PGD_TYPE_IS_PAGETABLE&quot;?
It is a little long, but there are only 2 lines use it and Both are not
over 80 character even though &quot;_IS_PAGETABLE&quot;.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SECTION(pgd)           \</span>
<span class="quote">&gt; &gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; &gt; +               == ARM_SHORT_F_PGD_TYPE_SECTION)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(pgd)      \</span>
<span class="quote">&gt; &gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; &gt; +               == ARM_SHORT_F_PGD_TYPE_SUPERSECTION)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_B_BIT                  BIT(2)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_C_BIT                  BIT(3)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_IMPLE_BIT              BIT(9)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_S_BIT                  BIT(16)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_NG_BIT                 BIT(17)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_NS_BIT_PAGE            BIT(3)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_NS_BIT_SECTION         BIT(19)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_PA_PAGETABLE_MSK       0xfffffc00</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_PA_SECTION_MSK         0xfff00000</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK    0xff000000</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +/* 2 level pagetable */</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_TYPE_GET(val)          ((val) &amp; 0x3)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_TYPE_LARGE             BIT(0)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_TYPE_SMALL             BIT(1)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_B_BIT                  BIT(2)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_C_BIT                  BIT(3)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_IMPLE_BIT              BIT(9)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_S_BIT                  BIT(10)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_PA_LARGE_MSK            0xffff0000</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PTE_PA_SMALL_MSK            0xfffff000</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PGD_IDX(a)                   ((a) &gt;&gt; ARM_SHORT_PGDIR_SHIFT)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PTE_IDX(a)                   \</span>
<span class="quote">&gt; &gt; +       (((a) &gt;&gt; ARM_SHORT_PAGE_SHIFT) &amp; 0xff)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_GET_PTE_VA(pgd)              \</span>
<span class="quote">&gt; &gt; +       (phys_to_virt((unsigned long)pgd &amp; ARM_SHORT_F_PGD_PA_PAGETABLE_MSK))</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static arm_short_iopte *</span>
<span class="quote">&gt; &gt; +arm_short_get_pte_in_pgd(arm_short_iopte curpgd, unsigned int iova)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pte = ARM_SHORT_GET_PTE_VA(curpgd);</span>
<span class="quote">&gt; &gt; +       pte += ARM_SHORT_PTE_IDX(iova);</span>
<span class="quote">&gt; &gt; +       return pte;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static arm_short_iopte *</span>
<span class="quote">&gt; &gt; +arm_short_supersection_start(arm_short_iopte *pgd)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       return (arm_short_iopte *)(round_down((unsigned long)pgd, (16 * 4)));</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int _arm_short_check_free_pte(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; &gt; +                                    arm_short_iopte *pgd)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Given that this is only returning success/failure, it should probably be </span>
<span class="quote">&gt; bool rather than int.</span>
Thanks.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; &gt; +       int i;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pte = ARM_SHORT_GET_PTE_VA(*pgd);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = 0; i &lt; ARM_SHORT_PTRS_PER_PTE; i++) {</span>
<span class="quote">&gt; &gt; +               if (pte[i] != 0)</span>
<span class="quote">&gt; &gt; +                       return 1;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* Free PTE */</span>
<span class="quote">&gt; &gt; +       kmem_cache_free(data-&gt;ptekmem, pte);</span>
<span class="quote">&gt; &gt; +       *pgd = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static phys_addr_t arm_short_iova_to_phys(struct io_pgtable_ops *ops,</span>
<span class="quote">&gt; &gt; +                                         unsigned long iova)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pte, *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; &gt; +       phys_addr_t pa = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="quote">&gt; &gt; +               u8 pte_type;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; &gt; +               pte_type = ARM_SHORT_F_PTE_TYPE_GET(*pte);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               if (pte_type == ARM_SHORT_F_PTE_TYPE_LARGE) {</span>
<span class="quote">&gt; &gt; +                       pa = (*pte) &amp; ARM_SHORT_F_PTE_PA_LARGE_MSK;</span>
<span class="quote">&gt; &gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PTE_PA_LARGE_MSK);</span>
<span class="quote">&gt; &gt; +               } else if (pte_type == ARM_SHORT_F_PTE_TYPE_SMALL) {</span>
<span class="quote">&gt; &gt; +                       pa = (*pte) &amp; ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="quote">&gt; &gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PTE_PA_SMALL_MSK);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       } else {</span>
<span class="quote">&gt; &gt; +               if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       pa = (*pgd) &amp; ARM_SHORT_F_PGD_PA_SECTION_MSK;</span>
<span class="quote">&gt; &gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PGD_PA_SECTION_MSK);</span>
<span class="quote">&gt; &gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       pa = (*pgd) &amp; ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK;</span>
<span class="quote">&gt; &gt; +                       pa |= iova &amp; (~ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return pa;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int arm_short_unmap(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; &gt; +                          size_t size)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pgd;</span>
<span class="quote">&gt; &gt; +       unsigned long iova_start = iova;</span>
<span class="quote">&gt; &gt; +       unsigned long long end_plus_1 = iova + size;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Since everything&#39;s at page granularity, working with IOVA PFNs rather </span>
<span class="quote">&gt; than raw addresses might be more convenient, and also sidesteps the </span>
<span class="quote">&gt; 32-bit overflow problem. On 64-bit platforms, we&#39;re wasting a whole 95 </span>
<span class="quote">&gt; bits of a long long here ;)</span>
About IOVA PFNs, if add it, we have to include &quot;iova.h&quot;. then it may add
a new relationship with other module. I am not sure it is ok.
in pg-iotable-arm.c, I also don&#39;t see it. so I don&#39;t prepare to add iova
pfn, is it ok?

iova here always is 32bit, and iova+size may over 32bit. so I use &quot;long
long&quot; here. &quot;long long&quot; always is 64bit in 32bit&amp;64bit platform?
&quot;long&quot; may be error while 32bit platform. 

I will add split and try to delete this in next version.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; &gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       do {</span>
<span class="quote">&gt; &gt; +               pgd = (arm_short_iopte *)data-&gt;pgd + ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       arm_short_iopte *pte;</span>
<span class="quote">&gt; &gt; +                       unsigned int pte_offset;</span>
<span class="quote">&gt; &gt; +                       unsigned int num_to_clean;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       pte_offset = ARM_SHORT_PTE_IDX(iova);</span>
<span class="quote">&gt; &gt; +                       num_to_clean =</span>
<span class="quote">&gt; &gt; +                           min((unsigned int)((end_plus_1 - iova) / PAGE_SIZE),</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Shouldn&#39;t this be page size for the IOMMU, not the CPU? I&#39;m a bit slow </span>
<span class="quote">&gt; today, but this looks like it might go wrong when PAGE_SIZE &gt; 4K.</span>
Thanks. Then I will add a define like this:
#define IOMMU_PAGE_SIZE_4K  SZ_4K
And I will put it into io-pgtable.h,  the io-pgtable-arm.c may also need
it.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +                               (ARM_SHORT_PTRS_PER_PTE - pte_offset));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       memset(pte, 0, num_to_clean * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       ret = _arm_short_check_free_pte(data, pgd);</span>
<span class="quote">&gt; &gt; +                       if (ret == 1)/* pte is not freed, need to flush pte */</span>
<span class="quote">&gt; &gt; +                               tlb-&gt;flush_pgtable(</span>
<span class="quote">&gt; &gt; +                                       pte,</span>
<span class="quote">&gt; &gt; +                                       num_to_clean * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                       cookie);</span>
<span class="quote">&gt; &gt; +                       else</span>
<span class="quote">&gt; &gt; +                               tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                                  cookie);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       iova += num_to_clean &lt;&lt; PAGE_SHIFT;</span>
<span class="quote">&gt; &gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       *pgd = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                          cookie);</span>
<span class="quote">&gt; &gt; +                       iova += SZ_1M;</span>
<span class="quote">&gt; &gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       arm_short_iopte *start;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       start = arm_short_supersection_start(pgd);</span>
<span class="quote">&gt; &gt; +                       if (unlikely(start != pgd))</span>
<span class="quote">&gt; &gt; +                               pr_warn(&quot;%s:suppersection start isn&#39;t aligned.iova=0x%lx,pgd=0x%x\n&quot;,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: typo in &quot;supersection&quot; here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +                                       __func__, iova, *pgd);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       memset(start, 0, 16 * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       tlb-&gt;flush_pgtable(start, 16 * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                          cookie);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       iova = (iova + SZ_16M) &amp; (~(SZ_16M - 1));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; iova = ALIGN(iova + SZ_16M, SZ_16M);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Except that being unaligned in the first place is an error condition, so </span>
<span class="quote">&gt; it would make more sense to just have &quot;iova += SZ_16M;&quot; here, and put </span>
<span class="quote">&gt; &quot;iova = ALIGN(iova, SZ_16M) after the warning in the error path above.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Since you don&#39;t handle splitting block mappings, and you also seem to be </span>
<span class="quote">&gt; missing an equivalent warning for unaligned second-level large pages, it </span>
<span class="quote">&gt; might be better to simply return an error if the requested size and </span>
<span class="quote">&gt; alignment don&#39;t exactly match the type of entry found, rather than let </span>
<span class="quote">&gt; the page tables get into an unexpectedly inconsistent state.</span>
OK. I will add split and add the align checking of start_iova for each
case..
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               } else {</span>
<span class="quote">&gt; &gt; +                       break;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       } while (iova &lt; end_plus_1 &amp;&amp; iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       tlb-&gt;tlb_add_flush(iova_start, size, true, cookie);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static arm_short_iopte __arm_short_pte_port(unsigned int prot, bool large)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I assume _port is a typo of _prot</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte pteprot;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pteprot = ARM_SHORT_F_PTE_S_BIT;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pteprot |= large ? ARM_SHORT_F_PTE_TYPE_LARGE :</span>
<span class="quote">&gt; &gt; +                               ARM_SHORT_F_PTE_TYPE_SMALL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; &gt; +               pteprot |=  ARM_SHORT_F_PTE_B_BIT | ARM_SHORT_F_PTE_C_BIT;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return pteprot;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static arm_short_iopte __arm_short_pgd_port(int prot, bool super)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ditto</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte pgdprot;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgdprot = ARM_SHORT_F_PGD_S_BIT;</span>
<span class="quote">&gt; &gt; +       pgdprot |= super ? ARM_SHORT_F_PGD_TYPE_SUPERSECTION :</span>
<span class="quote">&gt; &gt; +                               ARM_SHORT_F_PGD_TYPE_SECTION;</span>
<span class="quote">&gt; &gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; &gt; +               pgdprot |= ARM_SHORT_F_PGD_C_BIT | ARM_SHORT_F_PGD_B_BIT;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return pgdprot;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int _arm_short_map_page(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; &gt; +                              unsigned int iova, phys_addr_t pa,</span>
<span class="quote">&gt; &gt; +                              unsigned int prot, bool largepage)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte pgdprot, pteprot;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte mask = largepage ? ARM_SHORT_F_PTE_PA_LARGE_MSK :</span>
<span class="quote">&gt; &gt; +                                               ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="quote">&gt; &gt; +       int i, ptenum = largepage ? 16 : 1;</span>
<span class="quote">&gt; &gt; +       bool ptenew = false;</span>
<span class="quote">&gt; &gt; +       void *pte_new_va;</span>
<span class="quote">&gt; &gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if ((iova | pa) &amp; (~mask)) {</span>
<span class="quote">&gt; &gt; +               pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="quote">&gt; &gt; +                      iova, &amp;pa, largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: you may as well just have largepage ?  &quot;large&quot; : &quot;small&quot; here and </span>
<span class="quote">&gt; &quot;...type=%s page...&quot; in the format string.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgdprot = ARM_SHORT_F_PGD_TYPE_PAGE;</span>
<span class="quote">&gt; &gt; +       if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="quote">&gt; &gt; +               pgdprot |= ARM_SHORT_F_PGD_NS_BIT_PAGE;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (!(*pgd)) {</span>
<span class="quote">&gt; &gt; +               pte_new_va = kmem_cache_zalloc(data-&gt;ptekmem, GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +               if (unlikely(!pte_new_va)) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;Failed to alloc pte\n&quot;);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The allocator should already print the details of a failure, so I don&#39;t </span>
<span class="quote">&gt; think this adds much.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               /* Check pte alignment -- must 1K align */</span>
<span class="quote">&gt; &gt; +               if (unlikely((unsigned long)pte_new_va &amp;</span>
<span class="quote">&gt; &gt; +                            (ARM_SHORT_BYTES_PER_PTE - 1))) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;The new pte is not aligned! (va=0x%p)\n&quot;,</span>
<span class="quote">&gt; &gt; +                              pte_new_va);</span>
<span class="quote">&gt; &gt; +                       kmem_cache_free(data-&gt;ptekmem, (void *)pte_new_va);</span>
<span class="quote">&gt; &gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Can this ever actually happen? Besides, if kmem_cache_alloc isn&#39;t </span>
<span class="quote">&gt; honouring the alignment specified in kmem_cache_create, I think the </span>
<span class="quote">&gt; kernel might have bigger problems anyway...</span>
Thanks. I will delete it.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               ptenew = true;</span>
<span class="quote">&gt; &gt; +               *pgd = virt_to_phys(pte_new_va) | pgdprot;</span>
<span class="quote">&gt; &gt; +               kmemleak_ignore(pte_new_va);</span>
<span class="quote">&gt; &gt; +               data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                                cookie);</span>
<span class="quote">&gt; &gt; +       } else {</span>
<span class="quote">&gt; &gt; +               /* Someone else may have allocated for this pgd */</span>
<span class="quote">&gt; &gt; +               if (((*pgd) &amp; (~ARM_SHORT_F_PGD_PA_PAGETABLE_MSK)) != pgdprot) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;The prot of old pgd is not Right!iova=0x%x pgd=0x%x pgprot=0x%x\n&quot;,</span>
<span class="quote">&gt; &gt; +                              iova, (*pgd), pgdprot);</span>
<span class="quote">&gt; &gt; +                       return -EEXIST;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pteprot = (arm_short_iopte)pa;</span>
<span class="quote">&gt; &gt; +       pteprot |= __arm_short_pte_port(prot, largepage);</span>
<span class="quote">&gt; &gt; +</span>
[snip]
<span class="quote">&gt; &gt; +static int arm_short_map(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; &gt; +                        phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; &gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (!(prot &amp; (IOMMU_READ | IOMMU_WRITE)))</span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (size == SZ_4K) {/* most case */</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; &gt; +       } else if (size == SZ_64K) {</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; &gt; +       } else if (size == SZ_1M) {</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; &gt; +       } else if (size == SZ_16M) {</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; &gt; +       } else {</span>
<span class="quote">&gt; &gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think this might be nicer as a switch statement. You could perhaps </span>
<span class="quote">&gt; move the add_flush beforehand (since it&#39;s unconditional here anyway) and </span>
<span class="quote">&gt; get rid of ret altogether.</span>
move the add_flush before map?
if we change the pagetable firstly, then add_flush. is it better?
<span class="quote">&gt; </span>
<span class="quote">&gt; Alternatively, given that map_page and map_section are so similar, maybe </span>
<span class="quote">&gt; it&#39;s worth sorting out the pgprot and pgd/pte pointer for the </span>
<span class="quote">&gt; page/section distinction here, then just passing those to a single </span>
<span class="quote">&gt; function which maps compound/non-compound leaf entries.</span>
Ok. I will try to merge them in one function like _arm_short_map.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       tlb-&gt;tlb_add_flush(iova, size, true, data-&gt;iop.cookie);</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct io_pgtable *</span>
<span class="quote">&gt; &gt; +arm_short_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (cfg-&gt;ias != 32)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (cfg-&gt;oas &gt; ARM_SHORT_MAX_ADDR_BITS)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       cfg-&gt;pgsize_bitmap &amp;= SZ_4K | SZ_64K | SZ_1M | SZ_16M;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!data)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;pgd_size = SZ_16K;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;pgd = alloc_pages_exact(data-&gt;pgd_size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think this needs __GFP_DMA too, to ensure the pgd lies below the 4GB </span>
<span class="quote">&gt; boundary on arm64/LPAE systems with memory above that.</span>
Thanks.
<span class="quote">&gt; &gt; @@ -62,6 +63,11 @@ struct io_pgtable_cfg {</span>
<span class="quote">&gt; &gt;                          u64     vttbr;</span>
<span class="quote">&gt; &gt;                          u64     vtcr;</span>
<span class="quote">&gt; &gt;                  } arm_lpae_s2_cfg;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               struct {</span>
<span class="quote">&gt; &gt; +                       u64     ttbr[2];</span>
<span class="quote">&gt; &gt; +                       u64     tcr;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The ARM ARM defines these all as 32-bit registers for the </span>
<span class="quote">&gt; short-descriptor format, so I think u32 would be more appropriate - </span>
<span class="quote">&gt; better to let the compiler truncate things and warn about it, than have </span>
<span class="quote">&gt; the hardware do it silently at runtime ;)</span>
I will change both of them to u32.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               } arm_short_cfg;</span>
<span class="quote">&gt; &gt;          };</span>
<span class="quote">&gt; &gt;   };</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; --</span>
<span class="quote">&gt; &gt; 1.8.1.1.dirty</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - June 5, 2015, 1:12 p.m.</div>
<pre class="content">
Hello,

Thanks for the patch, it&#39;s good to see another user of the generic
IO page-table code. However, I have quite a lot of comments on the code.

On Fri, May 15, 2015 at 10:43:26AM +0100, Yong Wu wrote:
<span class="quote">&gt; This patch is for ARM Short Descriptor Format.It has 2-levels</span>
<span class="quote">&gt; pagetable and the allocator supports 4K/64K/1M/16M.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  drivers/iommu/Kconfig                |   7 +</span>
<span class="quote">&gt;  drivers/iommu/Makefile               |   1 +</span>
<span class="quote">&gt;  drivers/iommu/io-pgtable-arm-short.c | 490 +++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  drivers/iommu/io-pgtable.c           |   4 +</span>
<span class="quote">&gt;  drivers/iommu/io-pgtable.h           |   6 +</span>
<span class="quote">&gt;  5 files changed, 508 insertions(+)</span>
<span class="quote">&gt;  create mode 100644 drivers/iommu/io-pgtable-arm-short.c</span>

For some reason, I ended up reviewing this back-to-front (i.e. starting
with the init code), so apologies if the comments feel like they were
written in reverse.
<span class="quote">
&gt; diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; index 1ae4e54..3d2eac6 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/Kconfig</span>
<span class="quote">&gt; +++ b/drivers/iommu/Kconfig</span>
<span class="quote">&gt; @@ -39,6 +39,13 @@ config IOMMU_IO_PGTABLE_LPAE_SELFTEST</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;           If unsure, say N here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +config IOMMU_IO_PGTABLE_SHORT</span>
<span class="quote">&gt; +       bool &quot;ARMv7/v8 Short Descriptor Format&quot;</span>
<span class="quote">&gt; +       select IOMMU_IO_PGTABLE</span>

depends on ARM || ARM64 || COMPILE_TEST
<span class="quote">
&gt; +       help</span>
<span class="quote">&gt; +         Enable support for the ARM Short descriptor pagetable format.</span>
<span class="quote">&gt; +         It has 2-levels pagetable and The allocator supports 4K/64K/1M/16M.</span>

The second sentence is worded rather strangely.
<span class="quote">
&gt; +</span>
<span class="quote">&gt;  endmenu</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  config IOMMU_IOVA</span>
<span class="quote">&gt; diff --git a/drivers/iommu/io-pgtable-arm-short.c b/drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 0000000..cc286ce5</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; @@ -0,0 +1,490 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="quote">&gt; + * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is distributed in the hope that it will be useful,</span>
<span class="quote">&gt; + * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="quote">&gt; + * GNU General Public License for more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +#define pr_fmt(fmt)    &quot;arm-short-desc io-pgtable: &quot;fmt</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/err.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/iommu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/errno.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &quot;io-pgtable.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +typedef u32 arm_short_iopte;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct arm_short_io_pgtable {</span>
<span class="quote">&gt; +       struct io_pgtable       iop;</span>
<span class="quote">&gt; +       struct kmem_cache       *ptekmem;</span>
<span class="quote">&gt; +       size_t                  pgd_size;</span>
<span class="quote">&gt; +       void                    *pgd;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define io_pgtable_short_to_data(x)                            \</span>
<span class="quote">&gt; +       container_of((x), struct arm_short_io_pgtable, iop)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define io_pgtable_ops_to_pgtable(x)                           \</span>
<span class="quote">&gt; +       container_of((x), struct io_pgtable, ops)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define io_pgtable_short_ops_to_data(x)                                \</span>
<span class="quote">&gt; +       io_pgtable_short_to_data(io_pgtable_ops_to_pgtable(x))</span>
<span class="quote">&gt; +</span>

These are private macros, so I think you can drop the &quot;short&quot; part to,
err, keep them short.
<span class="quote">
&gt; +#define ARM_SHORT_MAX_ADDR_BITS                        32</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_PGDIR_SHIFT                  20</span>
<span class="quote">&gt; +#define ARM_SHORT_PAGE_SHIFT                   12</span>
<span class="quote">&gt; +#define ARM_SHORT_PTRS_PER_PTE                 256</span>
<span class="quote">&gt; +#define ARM_SHORT_BYTES_PER_PTE                        1024</span>

Isn&#39;t that ARM_SHORT_PTRS_PER_PTE * sizeof(arm_short_iopte)?
<span class="quote">
&gt; +/* 1 level pagetable */</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE              (0x1)</span>

I think you&#39;re using PAGE and PGTABLE interchangeably, which is really
confusing to read.
<span class="quote">
&gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE_MSK          (0x3)</span>

This is the TYPE mask.
<span class="quote">
&gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION           (0x2)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_SUPERSECTION      (0x2 | (1 &lt;&lt; 18))</span>

Are you sure this is correct? afaict, bit 0 is PXN, so you should actually
be using bit 18 to distinguihs sections and supersections.
<span class="quote">
&gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION_MSK       (0x3 | (1 &lt;&lt; 18))</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_IS_PAGE(pgd)      (((pgd) &amp; 0x3) == 1)</span>

Use your TYPE mask here.
<span class="quote">
&gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SECTION(pgd)           \</span>
<span class="quote">&gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; +               == ARM_SHORT_F_PGD_TYPE_SECTION)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(pgd)      \</span>
<span class="quote">&gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; +               == ARM_SHORT_F_PGD_TYPE_SUPERSECTION)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_B_BIT                  BIT(2)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_C_BIT                  BIT(3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_IMPLE_BIT              BIT(9)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_S_BIT                  BIT(16)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_NG_BIT                 BIT(17)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_NS_BIT_PAGE            BIT(3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_NS_BIT_SECTION         BIT(19)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_PA_PAGETABLE_MSK       0xfffffc00</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_PA_SECTION_MSK         0xfff00000</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK    0xff000000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* 2 level pagetable */</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_TYPE_GET(val)          ((val) &amp; 0x3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_TYPE_LARGE             BIT(0)</span>

Careful here, small pages can have bit 0 set for XN.
<span class="quote">
&gt; +#define ARM_SHORT_F_PTE_TYPE_SMALL             BIT(1)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_B_BIT                  BIT(2)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_C_BIT                  BIT(3)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_IMPLE_BIT              BIT(9)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_S_BIT                  BIT(10)</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_PA_LARGE_MSK            0xffff0000</span>
<span class="quote">&gt; +#define ARM_SHORT_F_PTE_PA_SMALL_MSK            0xfffff000</span>

I think you can drop the &#39;_F&#39; parts of all these macros.
<span class="quote">
&gt; +#define ARM_SHORT_PGD_IDX(a)                   ((a) &gt;&gt; ARM_SHORT_PGDIR_SHIFT)</span>
<span class="quote">&gt; +#define ARM_SHORT_PTE_IDX(a)                   \</span>
<span class="quote">&gt; +       (((a) &gt;&gt; ARM_SHORT_PAGE_SHIFT) &amp; 0xff)</span>

The 0xff comes from ARM_SHORT_PTRS_PER_PTE, right? I think you should fix
your definitions so that these are all derived from each other rather than
open-coding the constants.
<span class="quote">
&gt; +#define ARM_SHORT_GET_PTE_VA(pgd)              \</span>
<span class="quote">&gt; +       (phys_to_virt((unsigned long)pgd &amp; ARM_SHORT_F_PGD_PA_PAGETABLE_MSK))</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte *</span>
<span class="quote">&gt; +arm_short_get_pte_in_pgd(arm_short_iopte curpgd, unsigned int iova)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pte = ARM_SHORT_GET_PTE_VA(curpgd);</span>
<span class="quote">&gt; +       pte += ARM_SHORT_PTE_IDX(iova);</span>
<span class="quote">&gt; +       return pte;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte *</span>
<span class="quote">&gt; +arm_short_supersection_start(arm_short_iopte *pgd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       return (arm_short_iopte *)(round_down((unsigned long)pgd, (16 * 4)));</span>
<span class="quote">&gt; +}</span>

More magic numbers that should be derived from your global constants.
<span class="quote">
&gt; +static int _arm_short_check_free_pte(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; +                                    arm_short_iopte *pgd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pte = ARM_SHORT_GET_PTE_VA(*pgd);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; ARM_SHORT_PTRS_PER_PTE; i++) {</span>
<span class="quote">&gt; +               if (pte[i] != 0)</span>
<span class="quote">&gt; +                       return 1;</span>

-EEXIST?
<span class="quote">
&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Free PTE */</span>
<span class="quote">&gt; +       kmem_cache_free(data-&gt;ptekmem, pte);</span>
<span class="quote">&gt; +       *pgd = 0;</span>

I don&#39;t think this is safe, as there&#39;s a window where the page table
walker can see the freed pte memory.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int arm_short_unmap(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; +                          size_t size)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; +       arm_short_iopte *pgd;</span>
<span class="quote">&gt; +       unsigned long iova_start = iova;</span>
<span class="quote">&gt; +       unsigned long long end_plus_1 = iova + size;</span>
<span class="quote">&gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       do {</span>
<span class="quote">&gt; +               pgd = (arm_short_iopte *)data-&gt;pgd + ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="quote">&gt; +                       arm_short_iopte *pte;</span>
<span class="quote">&gt; +                       unsigned int pte_offset;</span>
<span class="quote">&gt; +                       unsigned int num_to_clean;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       pte_offset = ARM_SHORT_PTE_IDX(iova);</span>
<span class="quote">&gt; +                       num_to_clean =</span>
<span class="quote">&gt; +                           min((unsigned int)((end_plus_1 - iova) / PAGE_SIZE),</span>
<span class="quote">&gt; +                               (ARM_SHORT_PTRS_PER_PTE - pte_offset));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       memset(pte, 0, num_to_clean * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       ret = _arm_short_check_free_pte(data, pgd);</span>
<span class="quote">&gt; +                       if (ret == 1)/* pte is not freed, need to flush pte */</span>
<span class="quote">&gt; +                               tlb-&gt;flush_pgtable(</span>
<span class="quote">&gt; +                                       pte,</span>
<span class="quote">&gt; +                                       num_to_clean * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                       cookie);</span>
<span class="quote">&gt; +                       else</span>
<span class="quote">&gt; +                               tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                                  cookie);</span>

Hopefully this can be cleaned up when you remove the outer loop and you
can use the size parameter to figure out which level to unmap.
<span class="quote">
&gt; +                       iova += num_to_clean &lt;&lt; PAGE_SHIFT;</span>
<span class="quote">&gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="quote">&gt; +                       *pgd = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                          cookie);</span>
<span class="quote">&gt; +                       iova += SZ_1M;</span>

Again, these sizes can be derived from other page table properties that
you have.
<span class="quote">
&gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="quote">&gt; +                       arm_short_iopte *start;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       start = arm_short_supersection_start(pgd);</span>
<span class="quote">&gt; +                       if (unlikely(start != pgd))</span>
<span class="quote">&gt; +                               pr_warn(&quot;%s:suppersection start isn&#39;t aligned.iova=0x%lx,pgd=0x%x\n&quot;,</span>
<span class="quote">&gt; +                                       __func__, iova, *pgd);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       memset(start, 0, 16 * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       tlb-&gt;flush_pgtable(start, 16 * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                          cookie);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +                       iova = (iova + SZ_16M) &amp; (~(SZ_16M - 1));</span>

See later, but I think supersections should not be assumed by default.
<span class="quote">
&gt; +               } else {</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       } while (iova &lt; end_plus_1 &amp;&amp; iova);</span>

I don&#39;t think you need this loop -- unmap will be called in page-sized
chunks (where page-size refers to units as advertised in your IOMMU&#39;s
pgsize_bitmap). The tricky part is when somebody unmaps a subset of a
previous mapping that ended up using something like a section. You need
to handle that here by splitting blocks at level 1 into a table and
allocating a level 2.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       tlb-&gt;tlb_add_flush(iova_start, size, true, cookie);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>

You need to return the size of the region that you managed to unmap, so
0 isn&#39;t right here.
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte __arm_short_pte_port(unsigned int prot, bool large)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte pteprot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pteprot = ARM_SHORT_F_PTE_S_BIT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pteprot |= large ? ARM_SHORT_F_PTE_TYPE_LARGE :</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PTE_TYPE_SMALL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; +               pteprot |=  ARM_SHORT_F_PTE_B_BIT | ARM_SHORT_F_PTE_C_BIT;</span>

Where do you set TEX[0] for write-allocate?
<span class="quote">
&gt; +       return pteprot;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static arm_short_iopte __arm_short_pgd_port(int prot, bool super)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte pgdprot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgdprot = ARM_SHORT_F_PGD_S_BIT;</span>
<span class="quote">&gt; +       pgdprot |= super ? ARM_SHORT_F_PGD_TYPE_SUPERSECTION :</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PGD_TYPE_SECTION;</span>
<span class="quote">&gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; +               pgdprot |= ARM_SHORT_F_PGD_C_BIT | ARM_SHORT_F_PGD_B_BIT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return pgdprot;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int _arm_short_map_page(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; +                              unsigned int iova, phys_addr_t pa,</span>
<span class="quote">&gt; +                              unsigned int prot, bool largepage)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; +       arm_short_iopte pgdprot, pteprot;</span>
<span class="quote">&gt; +       arm_short_iopte mask = largepage ? ARM_SHORT_F_PTE_PA_LARGE_MSK :</span>
<span class="quote">&gt; +                                               ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="quote">&gt; +       int i, ptenum = largepage ? 16 : 1;</span>
<span class="quote">&gt; +       bool ptenew = false;</span>
<span class="quote">&gt; +       void *pte_new_va;</span>
<span class="quote">&gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if ((iova | pa) &amp; (~mask)) {</span>
<span class="quote">&gt; +               pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="quote">&gt; +                      iova, &amp;pa, largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgdprot = ARM_SHORT_F_PGD_TYPE_PAGE;</span>
<span class="quote">&gt; +       if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="quote">&gt; +               pgdprot |= ARM_SHORT_F_PGD_NS_BIT_PAGE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!(*pgd)) {</span>
<span class="quote">&gt; +               pte_new_va = kmem_cache_zalloc(data-&gt;ptekmem, GFP_KERNEL);</span>
<span class="quote">&gt; +               if (unlikely(!pte_new_va)) {</span>
<span class="quote">&gt; +                       pr_err(&quot;Failed to alloc pte\n&quot;);</span>
<span class="quote">&gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               /* Check pte alignment -- must 1K align */</span>
<span class="quote">&gt; +               if (unlikely((unsigned long)pte_new_va &amp;</span>
<span class="quote">&gt; +                            (ARM_SHORT_BYTES_PER_PTE - 1))) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The new pte is not aligned! (va=0x%p)\n&quot;,</span>
<span class="quote">&gt; +                              pte_new_va);</span>
<span class="quote">&gt; +                       kmem_cache_free(data-&gt;ptekmem, (void *)pte_new_va);</span>
<span class="quote">&gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; +               }</span>

How are you enforcing this alignment?
<span class="quote">
&gt; +               ptenew = true;</span>
<span class="quote">&gt; +               *pgd = virt_to_phys(pte_new_va) | pgdprot;</span>
<span class="quote">&gt; +               kmemleak_ignore(pte_new_va);</span>

Maybe you should be using alloc_pages instead of your kmem_cache (I mention
this again later on).
<span class="quote">
&gt; +               data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                                cookie);</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               /* Someone else may have allocated for this pgd */</span>
<span class="quote">&gt; +               if (((*pgd) &amp; (~ARM_SHORT_F_PGD_PA_PAGETABLE_MSK)) != pgdprot) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The prot of old pgd is not Right!iova=0x%x pgd=0x%x pgprot=0x%x\n&quot;,</span>
<span class="quote">&gt; +                              iova, (*pgd), pgdprot);</span>

You can probably just WARN here, as I do in the LPAE code. It shows a bug
in the caller of the API.
<span class="quote">
&gt; +                       return -EEXIST;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pteprot = (arm_short_iopte)pa;</span>
<span class="quote">&gt; +       pteprot |= __arm_short_pte_port(prot, largepage);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pr_debug(&quot;iova:0x%x,pte:0x%p(0x%x),prot:0x%x-%s\n&quot;,</span>
<span class="quote">&gt; +                iova, pte, ARM_SHORT_PTE_IDX(iova), pteprot,</span>
<span class="quote">&gt; +                largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; ptenum; i++) {</span>
<span class="quote">&gt; +               if (pte[i]) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The To-Map pte exists!(iova=0x%x pte=0x%x i=%d)\n&quot;,</span>
<span class="quote">&gt; +                              iova, pte[i], i);</span>
<span class="quote">&gt; +                       goto err_out;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               pte[i] = pteprot;</span>
<span class="quote">&gt; +       }</span>

I don&#39;t think you need this loop; you should only be given a page size,
like with unmap.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pte, ptenum * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                        cookie);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; + err_out:</span>
<span class="quote">&gt; +       for (i--; i &gt;= 0; i--)</span>
<span class="quote">&gt; +               pte[i] = 0;</span>
<span class="quote">&gt; +       if (ptenew)</span>
<span class="quote">&gt; +               kmem_cache_free(data-&gt;ptekmem, pte_new_va);</span>
<span class="quote">&gt; +       return -EEXIST;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int _arm_short_map_section(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; +                                 unsigned int iova, phys_addr_t pa,</span>
<span class="quote">&gt; +                                 int prot, bool supersection)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       arm_short_iopte pgprot;</span>
<span class="quote">&gt; +       arm_short_iopte mask = supersection ?</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK :</span>
<span class="quote">&gt; +                               ARM_SHORT_F_PGD_PA_SECTION_MSK;</span>
<span class="quote">&gt; +       arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +       unsigned int pgdnum = supersection ? 16 : 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if ((iova | pa) &amp; (~mask)) {</span>
<span class="quote">&gt; +               pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="quote">&gt; +                      iova, &amp;pa, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgprot = (arm_short_iopte)pa;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="quote">&gt; +               pgprot |= ARM_SHORT_F_PGD_NS_BIT_SECTION;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgprot |= __arm_short_pgd_port(prot, supersection);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pr_debug(&quot;iova:0x%x,pgd:0x%p(0x%p+0x%x),value:0x%x-%s\n&quot;,</span>
<span class="quote">&gt; +                iova, pgd, data-&gt;pgd, ARM_SHORT_PGD_IDX(iova),</span>
<span class="quote">&gt; +                pgprot, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; pgdnum; i++) {</span>
<span class="quote">&gt; +               if (unlikely(*pgd)) {</span>
<span class="quote">&gt; +                       pr_err(&quot;The To-Map pdg exists!(iova=0x%x pgd=0x%x i=%d)\n&quot;,</span>
<span class="quote">&gt; +                              iova, pgd[i], i);</span>
<span class="quote">&gt; +                       goto err_out;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               pgd[i] = pgprot;</span>
<span class="quote">&gt; +       }</span>

Similar comments here.
<span class="quote">
&gt; +       data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd,</span>
<span class="quote">&gt; +                                        pgdnum * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; +                                        data-&gt;iop.cookie);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; + err_out:</span>
<span class="quote">&gt; +       for (i--; i &gt;= 0; i--)</span>
<span class="quote">&gt; +               pgd[i] = 0;</span>
<span class="quote">&gt; +       return -EEXIST;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int arm_short_map(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; +                        phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!(prot &amp; (IOMMU_READ | IOMMU_WRITE)))</span>
<span class="quote">&gt; +               return -EINVAL;</span>

Why? You could have (another) quirk to select the access model and you
should be able to implement read+write, read-only no-exec and no-access.
<span class="quote">
&gt; +       if (size == SZ_4K) {/* most case */</span>
<span class="quote">&gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; +       } else if (size == SZ_64K) {</span>
<span class="quote">&gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; +       } else if (size == SZ_1M) {</span>
<span class="quote">&gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; +       } else if (size == SZ_16M) {</span>
<span class="quote">&gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; +       }</span>

Use a switch statement here?
<span class="quote">
&gt; +       tlb-&gt;tlb_add_flush(iova, size, true, data-&gt;iop.cookie);</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct io_pgtable *</span>
<span class="quote">&gt; +arm_short_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (cfg-&gt;ias != 32)</span>
<span class="quote">&gt; +               return NULL;</span>

I think you just need to check &#39;&gt;&#39;; VAs smaller than 32-bit can still
be translated.
<span class="quote">
&gt; +       if (cfg-&gt;oas &gt; ARM_SHORT_MAX_ADDR_BITS)</span>
<span class="quote">&gt; +               return NULL;</span>

What benefit does ARM_SHORT_MAX_ADDR_BITS offer? Why not just &#39;32&#39;?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       cfg-&gt;pgsize_bitmap &amp;= SZ_4K | SZ_64K | SZ_1M | SZ_16M;</span>

We can&#39;t support supersections unconditionally. Please add a quirk for
this, as it relies on IOMMU support.
<span class="quote">
&gt; +       data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!data)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;pgd_size = SZ_16K;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;pgd = alloc_pages_exact(data-&gt;pgd_size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="quote">&gt; +       if (!data-&gt;pgd)</span>
<span class="quote">&gt; +               goto out_free_data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       cfg-&gt;tlb-&gt;flush_pgtable(data-&gt;pgd, data-&gt;pgd_size, cookie);</span>

We may as well postpone this flush to the end of the function, given that
we can still fail at this point.
<span class="quote">
&gt; +       /* kmem for pte */</span>
<span class="quote">&gt; +       data-&gt;ptekmem = kmem_cache_create(&quot;short-descriptor-pte&quot;,</span>

A better name would be &quot;io-pgtable-arm-short&quot;, however, why can&#39;t you
just use GFP_ATOMIC in your pte allocations and do away with the cache
altogether? Also, what happens if you try to allocate multiple caches
with the same name?
<span class="quote">
&gt; +                                          ARM_SHORT_BYTES_PER_PTE,</span>
<span class="quote">&gt; +                                          ARM_SHORT_BYTES_PER_PTE,</span>
<span class="quote">&gt; +                                          0, NULL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (IS_ERR_OR_NULL(data-&gt;ptekmem)) {</span>

I think you just need a NULL check here.
<span class="quote">
&gt; +               pr_err(&quot;Failed to Create cached mem for PTE %ld\n&quot;,</span>
<span class="quote">&gt; +                      PTR_ERR(data-&gt;ptekmem));</span>

I don&#39;t think this error is particularly useful.
<span class="quote">
&gt; +               goto out_free_pte;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* TTBRs */</span>
<span class="quote">&gt; +       cfg-&gt;arm_short_cfg.ttbr[0] = virt_to_phys(data-&gt;pgd);</span>
<span class="quote">&gt; +       cfg-&gt;arm_short_cfg.ttbr[1] = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       cfg-&gt;arm_short_cfg.tcr = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;iop.ops = (struct io_pgtable_ops) {</span>
<span class="quote">&gt; +               .map            = arm_short_map,</span>
<span class="quote">&gt; +               .unmap          = arm_short_unmap,</span>
<span class="quote">&gt; +               .iova_to_phys   = arm_short_iova_to_phys,</span>
<span class="quote">&gt; +       };</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return &amp;data-&gt;iop;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +out_free_pte:</span>
<span class="quote">&gt; +       free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="quote">&gt; +out_free_data:</span>
<span class="quote">&gt; +       kfree(data);</span>
<span class="quote">&gt; +       return NULL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void arm_short_free_pgtable(struct io_pgtable *iop)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_to_data(iop);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       kmem_cache_destroy(data-&gt;ptekmem);</span>
<span class="quote">&gt; +       free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="quote">&gt; +       kfree(data);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct io_pgtable_init_fns io_pgtable_arm_short_init_fns = {</span>
<span class="quote">&gt; +       .alloc  = arm_short_alloc_pgtable,</span>
<span class="quote">&gt; +       .free   = arm_short_free_pgtable,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; diff --git a/drivers/iommu/io-pgtable.c b/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; index 6436fe2..14a9b3a 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; @@ -28,6 +28,7 @@ extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s1_init_fns;</span>
<span class="quote">&gt;  extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s2_init_fns;</span>
<span class="quote">&gt;  extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s1_init_fns;</span>
<span class="quote">&gt;  extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s2_init_fns;</span>
<span class="quote">&gt; +extern struct io_pgtable_init_fns io_pgtable_arm_short_init_fns;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  static const struct io_pgtable_init_fns *</span>
<span class="quote">&gt;  io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =</span>
<span class="quote">&gt; @@ -38,6 +39,9 @@ io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =</span>
<span class="quote">&gt;         [ARM_64_LPAE_S1] = &amp;io_pgtable_arm_64_lpae_s1_init_fns,</span>
<span class="quote">&gt;         [ARM_64_LPAE_S2] = &amp;io_pgtable_arm_64_lpae_s2_init_fns,</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt; +#ifdef CONFIG_IOMMU_IO_PGTABLE_SHORT</span>
<span class="quote">&gt; +       [ARM_SHORT_DESC] = &amp;io_pgtable_arm_short_init_fns,</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  struct io_pgtable_ops *alloc_io_pgtable_ops(enum io_pgtable_fmt fmt,</span>
<span class="quote">&gt; diff --git a/drivers/iommu/io-pgtable.h b/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; index 10e32f6..47efaab 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; +++ b/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; @@ -9,6 +9,7 @@ enum io_pgtable_fmt {</span>
<span class="quote">&gt;         ARM_32_LPAE_S2,</span>
<span class="quote">&gt;         ARM_64_LPAE_S1,</span>
<span class="quote">&gt;         ARM_64_LPAE_S2,</span>
<span class="quote">&gt; +       ARM_SHORT_DESC,</span>
<span class="quote">&gt;         IO_PGTABLE_NUM_FMTS,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; @@ -62,6 +63,11 @@ struct io_pgtable_cfg {</span>
<span class="quote">&gt;                         u64     vttbr;</span>
<span class="quote">&gt;                         u64     vtcr;</span>
<span class="quote">&gt;                 } arm_lpae_s2_cfg;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               struct {</span>
<span class="quote">&gt; +                       u64     ttbr[2];</span>
<span class="quote">&gt; +                       u64     tcr;</span>
<span class="quote">&gt; +               } arm_short_cfg;</span>

I appreciate that you&#39;re not using TEX remapping, but could we include
the NMRR and PRRR registers here (we can just zero them) too, please?
That makes it easier to support a TEX_REMAP quick later on and also sets
them to a known value.

Also, any chance of some self-tests?

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - June 26, 2015, 7:30 a.m.</div>
<pre class="content">
Hi Will,
   Thanks very much for your review.
   Sorry for reply so late, I need some time to test the split.
   I will improve in next version following your suggestion.
   There are some place please help check my comment.

On Fri, 2015-06-05 at 14:12 +0100, Will Deacon wrote:
<span class="quote">&gt; Hello,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks for the patch, it&#39;s good to see another user of the generic</span>
<span class="quote">&gt; IO page-table code. However, I have quite a lot of comments on the code.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Fri, May 15, 2015 at 10:43:26AM +0100, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; This patch is for ARM Short Descriptor Format.It has 2-levels</span>
<span class="quote">&gt; &gt; pagetable and the allocator supports 4K/64K/1M/16M.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  drivers/iommu/Kconfig                |   7 +</span>
<span class="quote">&gt; &gt;  drivers/iommu/Makefile               |   1 +</span>
<span class="quote">&gt; &gt;  drivers/iommu/io-pgtable-arm-short.c | 490 +++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  drivers/iommu/io-pgtable.c           |   4 +</span>
<span class="quote">&gt; &gt;  drivers/iommu/io-pgtable.h           |   6 +</span>
<span class="quote">&gt; &gt;  5 files changed, 508 insertions(+)</span>
<span class="quote">&gt; &gt;  create mode 100644 drivers/iommu/io-pgtable-arm-short.c</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For some reason, I ended up reviewing this back-to-front (i.e. starting</span>
<span class="quote">&gt; with the init code), so apologies if the comments feel like they were</span>
<span class="quote">&gt; written in reverse.</span>
<span class="quote">&gt; </span>
[snip]
<span class="quote">&gt; &gt; +typedef u32 arm_short_iopte;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct arm_short_io_pgtable {</span>
<span class="quote">&gt; &gt; +       struct io_pgtable       iop;</span>
<span class="quote">&gt; &gt; +       struct kmem_cache       *ptekmem;</span>
<span class="quote">&gt; &gt; +       size_t                  pgd_size;</span>
<span class="quote">&gt; &gt; +       void                    *pgd;</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define io_pgtable_short_to_data(x)                            \</span>
<span class="quote">&gt; &gt; +       container_of((x), struct arm_short_io_pgtable, iop)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define io_pgtable_ops_to_pgtable(x)                           \</span>
<span class="quote">&gt; &gt; +       container_of((x), struct io_pgtable, ops)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define io_pgtable_short_ops_to_data(x)                                \</span>
<span class="quote">&gt; &gt; +       io_pgtable_short_to_data(io_pgtable_ops_to_pgtable(x))</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; These are private macros, so I think you can drop the &quot;short&quot; part to,</span>
<span class="quote">&gt; err, keep them short.</span>

I will delete &quot;short&quot; in the definitions.

And io_pgtable_ops_to_pgtable is same with the one in LPAE.
How about move it to alongside the definition of struct io_pgtable in
io-pgtable.h and also delete it in io-pgtable-arm.c?.
<span class="quote">

&gt; &gt; +#define ARM_SHORT_MAX_ADDR_BITS                        32</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PGDIR_SHIFT                  20</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PAGE_SHIFT                   12</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_PTRS_PER_PTE                 256</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_BYTES_PER_PTE                        1024</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Isn&#39;t that ARM_SHORT_PTRS_PER_PTE * sizeof(arm_short_iopte)?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +/* 1 level pagetable */</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE              (0x1)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think you&#39;re using PAGE and PGTABLE interchangeably, which is really</span>
<span class="quote">&gt; confusing to read.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_PAGE_MSK          (0x3)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is the TYPE mask.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION           (0x2)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_SUPERSECTION      (0x2 | (1 &lt;&lt; 18))</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Are you sure this is correct? afaict, bit 0 is PXN, so you should actually</span>
<span class="quote">&gt; be using bit 18 to distinguihs sections and supersections.</span>
Thanks.
I will change all like this, is it ok?
//===
#define ARM_SHORT_PGD_TYPE_PGTABLE		BIT(0)
#define ARM_SHORT_PGD_TYPE_SECTION		BIT(1)
#define ARM_SHORT_PGD_B_BIT			BIT(2)
#define ARM_SHORT_PGD_C_BIT			BIT(3)
#define ARM_SHORT_PGD_NS_PGTABLE_BIT		BIT(3)
#define ARM_SHORT_PGD_IMPLE_BIT			BIT(9)
#define ARM_SHORT_PGD_TEX0_BIT			BIT(12)
#define ARM_SHORT_PGD_S_BIT			BIT(16)
#define ARM_SHORT_PGD_SUPERSECTION_BIT		BIT(18)
#define ARM_SHORT_PGD_NS_SECTION_BIT		BIT(19)

#define ARM_SHORT_PGD_TYPE_SUPERSECTION		\
	(ARM_SHORT_PGD_TYPE_SECTION | ARM_SHORT_PGD_SUPERSECTION_BIT)
#define ARM_SHORT_PGD_PGTABLE_MSK		(0x3)
#define ARM_SHORT_PGD_SECTION_MSK		\
	(ARM_SHORT_PGD_PGTABLE_MSK | ARM_SHORT_PGD_SUPERSECTION_BIT)
//=====
<span class="quote">
&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_SECTION_MSK       (0x3 | (1 &lt;&lt; 18))</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_IS_PAGE(pgd)      (((pgd) &amp; 0x3) == 1)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Use your TYPE mask here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SECTION(pgd)           \</span>
<span class="quote">&gt; &gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; &gt; +               == ARM_SHORT_F_PGD_TYPE_SECTION)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(pgd)      \</span>
<span class="quote">&gt; &gt; +       (((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)     \</span>
<span class="quote">&gt; &gt; +               == ARM_SHORT_F_PGD_TYPE_SUPERSECTION)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_B_BIT                  BIT(2)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_C_BIT                  BIT(3)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_IMPLE_BIT              BIT(9)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_S_BIT                  BIT(16)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_NG_BIT                 BIT(17)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_NS_BIT_PAGE            BIT(3)</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_NS_BIT_SECTION         BIT(19)</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_PA_PAGETABLE_MSK       0xfffffc00</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_PA_SECTION_MSK         0xfff00000</span>
<span class="quote">&gt; &gt; +#define ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK    0xff000000</span>
<span class="quote">&gt; &gt; +</span>
[snip]
<span class="quote">&gt; &gt; +static int _arm_short_check_free_pte(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; &gt; +                                    arm_short_iopte *pgd)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; &gt; +       int i;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pte = ARM_SHORT_GET_PTE_VA(*pgd);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = 0; i &lt; ARM_SHORT_PTRS_PER_PTE; i++) {</span>
<span class="quote">&gt; &gt; +               if (pte[i] != 0)</span>
<span class="quote">&gt; &gt; +                       return 1;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; -EEXIST?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* Free PTE */</span>
<span class="quote">&gt; &gt; +       kmem_cache_free(data-&gt;ptekmem, pte);</span>
<span class="quote">&gt; &gt; +       *pgd = 0;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t think this is safe, as there&#39;s a window where the page table</span>
<span class="quote">&gt; walker can see the freed pte memory.</span>

   Sorry, this function read badly. Originally I expected this function
could check all the ptes in the level-2 pagetable.
   I prepare to change the function name and the return type like below,
if all the pte is 0, then free whole the level-2 pagetable and return
true, if there are some other pte remain who isn&#39;t unmapped, it return
false.
static bool arm_short_free_wholepte(struct arm_short_io_pgtable *data,
				    arm_short_iopte *pgd)
<span class="quote">
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int arm_short_unmap(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; &gt; +                          size_t size)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pgd;</span>
<span class="quote">&gt; &gt; +       unsigned long iova_start = iova;</span>
<span class="quote">&gt; &gt; +       unsigned long long end_plus_1 = iova + size;</span>
<span class="quote">&gt; &gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; &gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       do {</span>
<span class="quote">&gt; &gt; +               pgd = (arm_short_iopte *)data-&gt;pgd + ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       arm_short_iopte *pte;</span>
<span class="quote">&gt; &gt; +                       unsigned int pte_offset;</span>
<span class="quote">&gt; &gt; +                       unsigned int num_to_clean;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       pte_offset = ARM_SHORT_PTE_IDX(iova);</span>
<span class="quote">&gt; &gt; +                       num_to_clean =</span>
<span class="quote">&gt; &gt; +                           min((unsigned int)((end_plus_1 - iova) / PAGE_SIZE),</span>
<span class="quote">&gt; &gt; +                               (ARM_SHORT_PTRS_PER_PTE - pte_offset));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       memset(pte, 0, num_to_clean * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       ret = _arm_short_check_free_pte(data, pgd);</span>
<span class="quote">&gt; &gt; +                       if (ret == 1)/* pte is not freed, need to flush pte */</span>
<span class="quote">&gt; &gt; +                               tlb-&gt;flush_pgtable(</span>
<span class="quote">&gt; &gt; +                                       pte,</span>
<span class="quote">&gt; &gt; +                                       num_to_clean * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                       cookie);</span>
<span class="quote">&gt; &gt; +                       else</span>
<span class="quote">&gt; &gt; +                               tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                                  cookie);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hopefully this can be cleaned up when you remove the outer loop and you</span>
<span class="quote">&gt; can use the size parameter to figure out which level to unmap.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +                       iova += num_to_clean &lt;&lt; PAGE_SHIFT;</span>
<span class="quote">&gt; &gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       *pgd = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                          cookie);</span>
<span class="quote">&gt; &gt; +                       iova += SZ_1M;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Again, these sizes can be derived from other page table properties that</span>
<span class="quote">&gt; you have.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               } else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       arm_short_iopte *start;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       start = arm_short_supersection_start(pgd);</span>
<span class="quote">&gt; &gt; +                       if (unlikely(start != pgd))</span>
<span class="quote">&gt; &gt; +                               pr_warn(&quot;%s:suppersection start isn&#39;t aligned.iova=0x%lx,pgd=0x%x\n&quot;,</span>
<span class="quote">&gt; &gt; +                                       __func__, iova, *pgd);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       memset(start, 0, 16 * sizeof(arm_short_iopte));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       tlb-&gt;flush_pgtable(start, 16 * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                          cookie);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +                       iova = (iova + SZ_16M) &amp; (~(SZ_16M - 1));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; See later, but I think supersections should not be assumed by default.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               } else {</span>
<span class="quote">&gt; &gt; +                       break;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       } while (iova &lt; end_plus_1 &amp;&amp; iova);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t think you need this loop -- unmap will be called in page-sized</span>
<span class="quote">&gt; chunks (where page-size refers to units as advertised in your IOMMU&#39;s</span>
<span class="quote">&gt; pgsize_bitmap). The tricky part is when somebody unmaps a subset of a</span>
<span class="quote">&gt; previous mapping that ended up using something like a section. You need</span>
<span class="quote">&gt; to handle that here by splitting blocks at level 1 into a table and</span>
<span class="quote">&gt; allocating a level 2.</span>

 I will delete the loop and get the size from the pagetable properties.
 About the split, I have a question,
 There are some lines in the self test of LPAE:
        //====
	/* Partial unmap */
	size = 1UL &lt;&lt; __ffs(cfg-&gt;pgsize_bitmap);
	if (ops-&gt;unmap(ops, SZ_1G + size, size) != size)
		return __FAIL(ops, i);
        //====
 If it is changed to:
      if (ops-&gt;unmap(ops, SZ_1G + 3*size, size) != size)
 or 
      if (ops-&gt;unmap(ops, SZ_1G + size, 3*size) != size)
 It seems don&#39;t work. I think it may be never happened if the map and
unmap is from iommu_map and iommu_unmap, I don&#39;t know whether somebody
will unmap subset of a previous mapping randomly like above. so I am
sure whether I should cover this two cases in short-descriptor.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       tlb-&gt;tlb_add_flush(iova_start, size, true, cookie);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You need to return the size of the region that you managed to unmap, so</span>
<span class="quote">&gt; 0 isn&#39;t right here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static arm_short_iopte __arm_short_pte_port(unsigned int prot, bool large)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte pteprot;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pteprot = ARM_SHORT_F_PTE_S_BIT;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pteprot |= large ? ARM_SHORT_F_PTE_TYPE_LARGE :</span>
<span class="quote">&gt; &gt; +                               ARM_SHORT_F_PTE_TYPE_SMALL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; &gt; +               pteprot |=  ARM_SHORT_F_PTE_B_BIT | ARM_SHORT_F_PTE_C_BIT;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Where do you set TEX[0] for write-allocate?</span>
I will add:
	if (prot &amp; IOMMU_WRITE)
		pteprot |= ARM_SHORT_PTE_TEX0_BIT;
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       return pteprot;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static arm_short_iopte __arm_short_pgd_port(int prot, bool super)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte pgdprot;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgdprot = ARM_SHORT_F_PGD_S_BIT;</span>
<span class="quote">&gt; &gt; +       pgdprot |= super ? ARM_SHORT_F_PGD_TYPE_SUPERSECTION :</span>
<span class="quote">&gt; &gt; +                               ARM_SHORT_F_PGD_TYPE_SECTION;</span>
<span class="quote">&gt; &gt; +       if (prot &amp; IOMMU_CACHE)</span>
<span class="quote">&gt; &gt; +               pgdprot |= ARM_SHORT_F_PGD_C_BIT | ARM_SHORT_F_PGD_B_BIT;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return pgdprot;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int _arm_short_map_page(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; &gt; +                              unsigned int iova, phys_addr_t pa,</span>
<span class="quote">&gt; &gt; +                              unsigned int prot, bool largepage)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pte;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte pgdprot, pteprot;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte mask = largepage ? ARM_SHORT_F_PTE_PA_LARGE_MSK :</span>
<span class="quote">&gt; &gt; +                                               ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="quote">&gt; &gt; +       int i, ptenum = largepage ? 16 : 1;</span>
<span class="quote">&gt; &gt; +       bool ptenew = false;</span>
<span class="quote">&gt; &gt; +       void *pte_new_va;</span>
<span class="quote">&gt; &gt; +       void *cookie = data-&gt;iop.cookie;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if ((iova | pa) &amp; (~mask)) {</span>
<span class="quote">&gt; &gt; +               pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="quote">&gt; &gt; +                      iova, &amp;pa, largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgdprot = ARM_SHORT_F_PGD_TYPE_PAGE;</span>
<span class="quote">&gt; &gt; +       if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="quote">&gt; &gt; +               pgdprot |= ARM_SHORT_F_PGD_NS_BIT_PAGE;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (!(*pgd)) {</span>
<span class="quote">&gt; &gt; +               pte_new_va = kmem_cache_zalloc(data-&gt;ptekmem, GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +               if (unlikely(!pte_new_va)) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;Failed to alloc pte\n&quot;);</span>
<span class="quote">&gt; &gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               /* Check pte alignment -- must 1K align */</span>
<span class="quote">&gt; &gt; +               if (unlikely((unsigned long)pte_new_va &amp;</span>
<span class="quote">&gt; &gt; +                            (ARM_SHORT_BYTES_PER_PTE - 1))) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;The new pte is not aligned! (va=0x%p)\n&quot;,</span>
<span class="quote">&gt; &gt; +                              pte_new_va);</span>
<span class="quote">&gt; &gt; +                       kmem_cache_free(data-&gt;ptekmem, (void *)pte_new_va);</span>
<span class="quote">&gt; &gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; How are you enforcing this alignment?</span>

I will delete this.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +               ptenew = true;</span>
<span class="quote">&gt; &gt; +               *pgd = virt_to_phys(pte_new_va) | pgdprot;</span>
<span class="quote">&gt; &gt; +               kmemleak_ignore(pte_new_va);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Maybe you should be using alloc_pages instead of your kmem_cache (I mention</span>
<span class="quote">&gt; this again later on).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                                cookie);</span>
<span class="quote">&gt; &gt; +       } else {</span>
<span class="quote">&gt; &gt; +               /* Someone else may have allocated for this pgd */</span>
<span class="quote">&gt; &gt; +               if (((*pgd) &amp; (~ARM_SHORT_F_PGD_PA_PAGETABLE_MSK)) != pgdprot) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;The prot of old pgd is not Right!iova=0x%x pgd=0x%x pgprot=0x%x\n&quot;,</span>
<span class="quote">&gt; &gt; +                              iova, (*pgd), pgdprot);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You can probably just WARN here, as I do in the LPAE code. It shows a bug</span>
<span class="quote">&gt; in the caller of the API.</span>
Sorry, I don&#39;t see it in LPAE, Do you mean these lines in LPAE?
        //====
	/* We require an unmap first */
	if (iopte_leaf(*ptep, lvl)) {
		WARN_ON(!selftest_running);
		return -EEXIST;
	}
        //====
It may be not the same. Here we only check whether the prot of the old
pgd is same with the current pgd.
I will change it to WARN_ON(1) too.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +                       return -EEXIST;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pteprot = (arm_short_iopte)pa;</span>
<span class="quote">&gt; &gt; +       pteprot |= __arm_short_pte_port(prot, largepage);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pr_debug(&quot;iova:0x%x,pte:0x%p(0x%x),prot:0x%x-%s\n&quot;,</span>
<span class="quote">&gt; &gt; +                iova, pte, ARM_SHORT_PTE_IDX(iova), pteprot,</span>
<span class="quote">&gt; &gt; +                largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = 0; i &lt; ptenum; i++) {</span>
<span class="quote">&gt; &gt; +               if (pte[i]) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;The To-Map pte exists!(iova=0x%x pte=0x%x i=%d)\n&quot;,</span>
<span class="quote">&gt; &gt; +                              iova, pte[i], i);</span>
<span class="quote">&gt; &gt; +                       goto err_out;</span>
I will change to WARN_ON(1) here too.
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +               pte[i] = pteprot;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t think you need this loop; you should only be given a page size,</span>
<span class="quote">&gt; like with unmap.</span>

   I am not sure I follow your meaning.The ptenum here is only 1 or 16.
It is 1 while current is small page and section. It is 16 while current
is large page or super section.
Because the descriptor should be repeated 16 consecutive, I use a loop
here.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pte, ptenum * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                        cookie);</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; + err_out:</span>
<span class="quote">&gt; &gt; +       for (i--; i &gt;= 0; i--)</span>
<span class="quote">&gt; &gt; +               pte[i] = 0;</span>
<span class="quote">&gt; &gt; +       if (ptenew)</span>
<span class="quote">&gt; &gt; +               kmem_cache_free(data-&gt;ptekmem, pte_new_va);</span>
<span class="quote">&gt; &gt; +       return -EEXIST;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int _arm_short_map_section(struct arm_short_io_pgtable *data,</span>
<span class="quote">&gt; &gt; +                                 unsigned int iova, phys_addr_t pa,</span>
<span class="quote">&gt; &gt; +                                 int prot, bool supersection)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       arm_short_iopte pgprot;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte mask = supersection ?</span>
<span class="quote">&gt; &gt; +                               ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK :</span>
<span class="quote">&gt; &gt; +                               ARM_SHORT_F_PGD_PA_SECTION_MSK;</span>
<span class="quote">&gt; &gt; +       arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="quote">&gt; &gt; +       int i;</span>
<span class="quote">&gt; &gt; +       unsigned int pgdnum = supersection ? 16 : 1;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if ((iova | pa) &amp; (~mask)) {</span>
<span class="quote">&gt; &gt; +               pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="quote">&gt; &gt; +                      iova, &amp;pa, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgprot = (arm_short_iopte)pa;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="quote">&gt; &gt; +               pgprot |= ARM_SHORT_F_PGD_NS_BIT_SECTION;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgprot |= __arm_short_pgd_port(prot, supersection);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       pr_debug(&quot;iova:0x%x,pgd:0x%p(0x%p+0x%x),value:0x%x-%s\n&quot;,</span>
<span class="quote">&gt; &gt; +                iova, pgd, data-&gt;pgd, ARM_SHORT_PGD_IDX(iova),</span>
<span class="quote">&gt; &gt; +                pgprot, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = 0; i &lt; pgdnum; i++) {</span>
<span class="quote">&gt; &gt; +               if (unlikely(*pgd)) {</span>
<span class="quote">&gt; &gt; +                       pr_err(&quot;The To-Map pdg exists!(iova=0x%x pgd=0x%x i=%d)\n&quot;,</span>
<span class="quote">&gt; &gt; +                              iova, pgd[i], i);</span>
<span class="quote">&gt; &gt; +                       goto err_out;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +               pgd[i] = pgprot;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Similar comments here.</span>
   I will merge _arm_short_map_page and _arm_short_map_section into one
function named _arm_short_map.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd,</span>
<span class="quote">&gt; &gt; +                                        pgdnum * sizeof(arm_short_iopte),</span>
<span class="quote">&gt; &gt; +                                        data-&gt;iop.cookie);</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; + err_out:</span>
<span class="quote">&gt; &gt; +       for (i--; i &gt;= 0; i--)</span>
<span class="quote">&gt; &gt; +               pgd[i] = 0;</span>
<span class="quote">&gt; &gt; +       return -EEXIST;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int arm_short_map(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="quote">&gt; &gt; +                        phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="quote">&gt; &gt; +       const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (!(prot &amp; (IOMMU_READ | IOMMU_WRITE)))</span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why? You could have (another) quirk to select the access model and you</span>
<span class="quote">&gt; should be able to implement read+write, read-only no-exec and no-access.</span>

If I follow it in LAPE like below. is it ok?
//======
	/* If no access, then nothing to do */
	if (!(iommu_prot &amp; (IOMMU_READ | IOMMU_WRITE)))
		return 0;
//=====
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       if (size == SZ_4K) {/* most case */</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; &gt; +       } else if (size == SZ_64K) {</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_page(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; &gt; +       } else if (size == SZ_1M) {</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, false);</span>
<span class="quote">&gt; &gt; +       } else if (size == SZ_16M) {</span>
<span class="quote">&gt; &gt; +               ret = _arm_short_map_section(data, iova, paddr, prot, true);</span>
<span class="quote">&gt; &gt; +       } else {</span>
<span class="quote">&gt; &gt; +               ret = -EINVAL;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Use a switch statement here?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       tlb-&gt;tlb_add_flush(iova, size, true, data-&gt;iop.cookie);</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static struct io_pgtable *</span>
<span class="quote">&gt; &gt; +arm_short_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (cfg-&gt;ias != 32)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think you just need to check &#39;&gt;&#39;; VAs smaller than 32-bit can still</span>
<span class="quote">&gt; be translated.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       if (cfg-&gt;oas &gt; ARM_SHORT_MAX_ADDR_BITS)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; What benefit does ARM_SHORT_MAX_ADDR_BITS offer? Why not just &#39;32&#39;?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       cfg-&gt;pgsize_bitmap &amp;= SZ_4K | SZ_64K | SZ_1M | SZ_16M;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We can&#39;t support supersections unconditionally. Please add a quirk for</span>
<span class="quote">&gt; this, as it relies on IOMMU support.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!data)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;pgd_size = SZ_16K;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;pgd = alloc_pages_exact(data-&gt;pgd_size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="quote">&gt; &gt; +       if (!data-&gt;pgd)</span>
<span class="quote">&gt; &gt; +               goto out_free_data;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       cfg-&gt;tlb-&gt;flush_pgtable(data-&gt;pgd, data-&gt;pgd_size, cookie);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We may as well postpone this flush to the end of the function, given that</span>
<span class="quote">&gt; we can still fail at this point.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       /* kmem for pte */</span>
<span class="quote">&gt; &gt; +       data-&gt;ptekmem = kmem_cache_create(&quot;short-descriptor-pte&quot;,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A better name would be &quot;io-pgtable-arm-short&quot;, however, why can&#39;t you</span>
<span class="quote">&gt; just use GFP_ATOMIC in your pte allocations and do away with the cache</span>
<span class="quote">&gt; altogether? Also, what happens if you try to allocate multiple caches</span>
<span class="quote">&gt; with the same name?</span>
   I will add GFP_ATOMIC in pte allocation, It is a bug Daniel has help
to fix it.
   And I am sorry. I don&#39;t know what is wrong if using kmem_cache here.
   The main reason is the size. the size of level-2 pgtable is 1KB, and
the alloc_page_exact will be 4KB. so I use kmem_cache here.
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +                                          ARM_SHORT_BYTES_PER_PTE,</span>
<span class="quote">&gt; &gt; +                                          ARM_SHORT_BYTES_PER_PTE,</span>
<span class="quote">&gt; &gt; +                                          0, NULL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (IS_ERR_OR_NULL(data-&gt;ptekmem)) {</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think you just need a NULL check here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               pr_err(&quot;Failed to Create cached mem for PTE %ld\n&quot;,</span>
<span class="quote">&gt; &gt; +                      PTR_ERR(data-&gt;ptekmem));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t think this error is particularly useful.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +               goto out_free_pte;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* TTBRs */</span>
<span class="quote">&gt; &gt; +       cfg-&gt;arm_short_cfg.ttbr[0] = virt_to_phys(data-&gt;pgd);</span>
<span class="quote">&gt; &gt; +       cfg-&gt;arm_short_cfg.ttbr[1] = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       cfg-&gt;arm_short_cfg.tcr = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;iop.ops = (struct io_pgtable_ops) {</span>
<span class="quote">&gt; &gt; +               .map            = arm_short_map,</span>
<span class="quote">&gt; &gt; +               .unmap          = arm_short_unmap,</span>
<span class="quote">&gt; &gt; +               .iova_to_phys   = arm_short_iova_to_phys,</span>
<span class="quote">&gt; &gt; +       };</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return &amp;data-&gt;iop;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +out_free_pte:</span>
<span class="quote">&gt; &gt; +       free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="quote">&gt; &gt; +out_free_data:</span>
<span class="quote">&gt; &gt; +       kfree(data);</span>
<span class="quote">&gt; &gt; +       return NULL;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void arm_short_free_pgtable(struct io_pgtable *iop)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct arm_short_io_pgtable *data = io_pgtable_short_to_data(iop);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       kmem_cache_destroy(data-&gt;ptekmem);</span>
<span class="quote">&gt; &gt; +       free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="quote">&gt; &gt; +       kfree(data);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +struct io_pgtable_init_fns io_pgtable_arm_short_init_fns = {</span>
<span class="quote">&gt; &gt; +       .alloc  = arm_short_alloc_pgtable,</span>
<span class="quote">&gt; &gt; +       .free   = arm_short_free_pgtable,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/io-pgtable.c b/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; &gt; index 6436fe2..14a9b3a 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/io-pgtable.c</span>
<span class="quote">&gt; &gt; @@ -28,6 +28,7 @@ extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s1_init_fns;</span>
<span class="quote">&gt; &gt;  extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s2_init_fns;</span>
<span class="quote">&gt; &gt;  extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s1_init_fns;</span>
<span class="quote">&gt; &gt;  extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s2_init_fns;</span>
<span class="quote">&gt; &gt; +extern struct io_pgtable_init_fns io_pgtable_arm_short_init_fns;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;  static const struct io_pgtable_init_fns *</span>
<span class="quote">&gt; &gt;  io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =</span>
<span class="quote">&gt; &gt; @@ -38,6 +39,9 @@ io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =</span>
<span class="quote">&gt; &gt;         [ARM_64_LPAE_S1] = &amp;io_pgtable_arm_64_lpae_s1_init_fns,</span>
<span class="quote">&gt; &gt;         [ARM_64_LPAE_S2] = &amp;io_pgtable_arm_64_lpae_s2_init_fns,</span>
<span class="quote">&gt; &gt;  #endif</span>
<span class="quote">&gt; &gt; +#ifdef CONFIG_IOMMU_IO_PGTABLE_SHORT</span>
<span class="quote">&gt; &gt; +       [ARM_SHORT_DESC] = &amp;io_pgtable_arm_short_init_fns,</span>
<span class="quote">&gt; &gt; +#endif</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;  struct io_pgtable_ops *alloc_io_pgtable_ops(enum io_pgtable_fmt fmt,</span>
<span class="quote">&gt; &gt; diff --git a/drivers/iommu/io-pgtable.h b/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; &gt; index 10e32f6..47efaab 100644</span>
<span class="quote">&gt; &gt; --- a/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; &gt; +++ b/drivers/iommu/io-pgtable.h</span>
<span class="quote">&gt; &gt; @@ -9,6 +9,7 @@ enum io_pgtable_fmt {</span>
<span class="quote">&gt; &gt;         ARM_32_LPAE_S2,</span>
<span class="quote">&gt; &gt;         ARM_64_LPAE_S1,</span>
<span class="quote">&gt; &gt;         ARM_64_LPAE_S2,</span>
<span class="quote">&gt; &gt; +       ARM_SHORT_DESC,</span>
<span class="quote">&gt; &gt;         IO_PGTABLE_NUM_FMTS,</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; @@ -62,6 +63,11 @@ struct io_pgtable_cfg {</span>
<span class="quote">&gt; &gt;                         u64     vttbr;</span>
<span class="quote">&gt; &gt;                         u64     vtcr;</span>
<span class="quote">&gt; &gt;                 } arm_lpae_s2_cfg;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               struct {</span>
<span class="quote">&gt; &gt; +                       u64     ttbr[2];</span>
<span class="quote">&gt; &gt; +                       u64     tcr;</span>
<span class="quote">&gt; &gt; +               } arm_short_cfg;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I appreciate that you&#39;re not using TEX remapping, but could we include</span>
<span class="quote">&gt; the NMRR and PRRR registers here (we can just zero them) too, please?</span>
<span class="quote">&gt; That makes it easier to support a TEX_REMAP quick later on and also sets</span>
<span class="quote">&gt; them to a known value.</span>
I will add them and set 0 to them.
	u32	ttbr[2];
	u32	tcr;
+	u32	nmrr;
+	u32	prrr;
   And According to Robin&#39;s suggestion, I will change to u32 in
short-descriptor.
<span class="quote">&gt; </span>
<span class="quote">&gt; Also, any chance of some self-tests?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Will</span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index 1ae4e54..3d2eac6 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -39,6 +39,13 @@</span> <span class="p_context"> config IOMMU_IO_PGTABLE_LPAE_SELFTEST</span>
 
 	  If unsure, say N here.
 
<span class="p_add">+config IOMMU_IO_PGTABLE_SHORT</span>
<span class="p_add">+	bool &quot;ARMv7/v8 Short Descriptor Format&quot;</span>
<span class="p_add">+	select IOMMU_IO_PGTABLE</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Enable support for the ARM Short descriptor pagetable format.</span>
<span class="p_add">+	  It has 2-levels pagetable and The allocator supports 4K/64K/1M/16M.</span>
<span class="p_add">+</span>
 endmenu
 
 config IOMMU_IOVA
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index 080ffab..815b3c8 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"> obj-$(CONFIG_IOMMU_API) += iommu-traces.o</span>
 obj-$(CONFIG_IOMMU_API) += iommu-sysfs.o
 obj-$(CONFIG_IOMMU_IO_PGTABLE) += io-pgtable.o
 obj-$(CONFIG_IOMMU_IO_PGTABLE_LPAE) += io-pgtable-arm.o
<span class="p_add">+obj-$(CONFIG_IOMMU_IO_PGTABLE_SHORT) += io-pgtable-arm-short.o</span>
 obj-$(CONFIG_IOMMU_IOVA) += iova.o
 obj-$(CONFIG_OF_IOMMU)	+= of_iommu.o
 obj-$(CONFIG_MSM_IOMMU) += msm_iommu.o msm_iommu_dev.o
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm-short.c b/drivers/iommu/io-pgtable-arm-short.c</span>
new file mode 100644
<span class="p_header">index 0000000..cc286ce5</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm-short.c</span>
<span class="p_chunk">@@ -0,0 +1,490 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="p_add">+ * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define pr_fmt(fmt)	&quot;arm-short-desc io-pgtable: &quot;fmt</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/errno.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;io-pgtable.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+typedef u32 arm_short_iopte;</span>
<span class="p_add">+</span>
<span class="p_add">+struct arm_short_io_pgtable {</span>
<span class="p_add">+	struct io_pgtable	iop;</span>
<span class="p_add">+	struct kmem_cache	*ptekmem;</span>
<span class="p_add">+	size_t			pgd_size;</span>
<span class="p_add">+	void			*pgd;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define io_pgtable_short_to_data(x)				\</span>
<span class="p_add">+	container_of((x), struct arm_short_io_pgtable, iop)</span>
<span class="p_add">+</span>
<span class="p_add">+#define io_pgtable_ops_to_pgtable(x)				\</span>
<span class="p_add">+	container_of((x), struct io_pgtable, ops)</span>
<span class="p_add">+</span>
<span class="p_add">+#define io_pgtable_short_ops_to_data(x)				\</span>
<span class="p_add">+	io_pgtable_short_to_data(io_pgtable_ops_to_pgtable(x))</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SHORT_MAX_ADDR_BITS			32</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SHORT_PGDIR_SHIFT			20</span>
<span class="p_add">+#define ARM_SHORT_PAGE_SHIFT			12</span>
<span class="p_add">+#define ARM_SHORT_PTRS_PER_PTE			256</span>
<span class="p_add">+#define ARM_SHORT_BYTES_PER_PTE			1024</span>
<span class="p_add">+</span>
<span class="p_add">+/* 1 level pagetable */</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_PAGE		(0x1)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_PAGE_MSK		(0x3)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_SECTION		(0x2)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_SUPERSECTION	(0x2 | (1 &lt;&lt; 18))</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_SECTION_MSK	(0x3 | (1 &lt;&lt; 18))</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_IS_PAGE(pgd)	(((pgd) &amp; 0x3) == 1)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_IS_SECTION(pgd)		\</span>
<span class="p_add">+	(((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)	\</span>
<span class="p_add">+		== ARM_SHORT_F_PGD_TYPE_SECTION)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(pgd)	\</span>
<span class="p_add">+	(((pgd) &amp; ARM_SHORT_F_PGD_TYPE_SECTION_MSK)	\</span>
<span class="p_add">+		== ARM_SHORT_F_PGD_TYPE_SUPERSECTION)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_B_BIT			BIT(2)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_C_BIT			BIT(3)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_IMPLE_BIT		BIT(9)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_S_BIT			BIT(16)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_NG_BIT			BIT(17)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_NS_BIT_PAGE		BIT(3)</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_NS_BIT_SECTION		BIT(19)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_PA_PAGETABLE_MSK	0xfffffc00</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_PA_SECTION_MSK		0xfff00000</span>
<span class="p_add">+#define ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK	0xff000000</span>
<span class="p_add">+</span>
<span class="p_add">+/* 2 level pagetable */</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_TYPE_GET(val)		((val) &amp; 0x3)</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_TYPE_LARGE		BIT(0)</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_TYPE_SMALL		BIT(1)</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_B_BIT			BIT(2)</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_C_BIT			BIT(3)</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_IMPLE_BIT		BIT(9)</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_S_BIT			BIT(10)</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_PA_LARGE_MSK            0xffff0000</span>
<span class="p_add">+#define ARM_SHORT_F_PTE_PA_SMALL_MSK            0xfffff000</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SHORT_PGD_IDX(a)			((a) &gt;&gt; ARM_SHORT_PGDIR_SHIFT)</span>
<span class="p_add">+#define ARM_SHORT_PTE_IDX(a)			\</span>
<span class="p_add">+	(((a) &gt;&gt; ARM_SHORT_PAGE_SHIFT) &amp; 0xff)</span>
<span class="p_add">+#define ARM_SHORT_GET_PTE_VA(pgd)		\</span>
<span class="p_add">+	(phys_to_virt((unsigned long)pgd &amp; ARM_SHORT_F_PGD_PA_PAGETABLE_MSK))</span>
<span class="p_add">+</span>
<span class="p_add">+static arm_short_iopte *</span>
<span class="p_add">+arm_short_get_pte_in_pgd(arm_short_iopte curpgd, unsigned int iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_short_iopte *pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = ARM_SHORT_GET_PTE_VA(curpgd);</span>
<span class="p_add">+	pte += ARM_SHORT_PTE_IDX(iova);</span>
<span class="p_add">+	return pte;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static arm_short_iopte *</span>
<span class="p_add">+arm_short_supersection_start(arm_short_iopte *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (arm_short_iopte *)(round_down((unsigned long)pgd, (16 * 4)));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int _arm_short_check_free_pte(struct arm_short_io_pgtable *data,</span>
<span class="p_add">+				     arm_short_iopte *pgd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_short_iopte *pte;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = ARM_SHORT_GET_PTE_VA(*pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARM_SHORT_PTRS_PER_PTE; i++) {</span>
<span class="p_add">+		if (pte[i] != 0)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Free PTE */</span>
<span class="p_add">+	kmem_cache_free(data-&gt;ptekmem, pte);</span>
<span class="p_add">+	*pgd = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t arm_short_iova_to_phys(struct io_pgtable_ops *ops,</span>
<span class="p_add">+					  unsigned long iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="p_add">+	arm_short_iopte *pte, *pgd = data-&gt;pgd;</span>
<span class="p_add">+	phys_addr_t pa = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="p_add">+		u8 pte_type;</span>
<span class="p_add">+</span>
<span class="p_add">+		pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="p_add">+		pte_type = ARM_SHORT_F_PTE_TYPE_GET(*pte);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pte_type == ARM_SHORT_F_PTE_TYPE_LARGE) {</span>
<span class="p_add">+			pa = (*pte) &amp; ARM_SHORT_F_PTE_PA_LARGE_MSK;</span>
<span class="p_add">+			pa |= iova &amp; (~ARM_SHORT_F_PTE_PA_LARGE_MSK);</span>
<span class="p_add">+		} else if (pte_type == ARM_SHORT_F_PTE_TYPE_SMALL) {</span>
<span class="p_add">+			pa = (*pte) &amp; ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="p_add">+			pa |= iova &amp; (~ARM_SHORT_F_PTE_PA_SMALL_MSK);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="p_add">+			pa = (*pgd) &amp; ARM_SHORT_F_PGD_PA_SECTION_MSK;</span>
<span class="p_add">+			pa |= iova &amp; (~ARM_SHORT_F_PGD_PA_SECTION_MSK);</span>
<span class="p_add">+		} else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="p_add">+			pa = (*pgd) &amp; ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK;</span>
<span class="p_add">+			pa |= iova &amp; (~ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int arm_short_unmap(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="p_add">+			   size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="p_add">+	arm_short_iopte *pgd;</span>
<span class="p_add">+	unsigned long iova_start = iova;</span>
<span class="p_add">+	unsigned long long end_plus_1 = iova + size;</span>
<span class="p_add">+	const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="p_add">+	void *cookie = data-&gt;iop.cookie;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		pgd = (arm_short_iopte *)data-&gt;pgd + ARM_SHORT_PGD_IDX(iova);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ARM_SHORT_F_PGD_TYPE_IS_PAGE(*pgd)) {</span>
<span class="p_add">+			arm_short_iopte *pte;</span>
<span class="p_add">+			unsigned int pte_offset;</span>
<span class="p_add">+			unsigned int num_to_clean;</span>
<span class="p_add">+</span>
<span class="p_add">+			pte_offset = ARM_SHORT_PTE_IDX(iova);</span>
<span class="p_add">+			num_to_clean =</span>
<span class="p_add">+			    min((unsigned int)((end_plus_1 - iova) / PAGE_SIZE),</span>
<span class="p_add">+				(ARM_SHORT_PTRS_PER_PTE - pte_offset));</span>
<span class="p_add">+</span>
<span class="p_add">+			pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="p_add">+</span>
<span class="p_add">+			memset(pte, 0, num_to_clean * sizeof(arm_short_iopte));</span>
<span class="p_add">+</span>
<span class="p_add">+			ret = _arm_short_check_free_pte(data, pgd);</span>
<span class="p_add">+			if (ret == 1)/* pte is not freed, need to flush pte */</span>
<span class="p_add">+				tlb-&gt;flush_pgtable(</span>
<span class="p_add">+					pte,</span>
<span class="p_add">+					num_to_clean * sizeof(arm_short_iopte),</span>
<span class="p_add">+					cookie);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="p_add">+						   cookie);</span>
<span class="p_add">+</span>
<span class="p_add">+			iova += num_to_clean &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+		} else if (ARM_SHORT_F_PGD_TYPE_IS_SECTION(*pgd)) {</span>
<span class="p_add">+			*pgd = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+			tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="p_add">+					   cookie);</span>
<span class="p_add">+			iova += SZ_1M;</span>
<span class="p_add">+		} else if (ARM_SHORT_F_PGD_TYPE_IS_SUPERSECTION(*pgd)) {</span>
<span class="p_add">+			arm_short_iopte *start;</span>
<span class="p_add">+</span>
<span class="p_add">+			start = arm_short_supersection_start(pgd);</span>
<span class="p_add">+			if (unlikely(start != pgd))</span>
<span class="p_add">+				pr_warn(&quot;%s:suppersection start isn&#39;t aligned.iova=0x%lx,pgd=0x%x\n&quot;,</span>
<span class="p_add">+					__func__, iova, *pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+			memset(start, 0, 16 * sizeof(arm_short_iopte));</span>
<span class="p_add">+</span>
<span class="p_add">+			tlb-&gt;flush_pgtable(start, 16 * sizeof(arm_short_iopte),</span>
<span class="p_add">+					   cookie);</span>
<span class="p_add">+</span>
<span class="p_add">+			iova = (iova + SZ_16M) &amp; (~(SZ_16M - 1));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (iova &lt; end_plus_1 &amp;&amp; iova);</span>
<span class="p_add">+</span>
<span class="p_add">+	tlb-&gt;tlb_add_flush(iova_start, size, true, cookie);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static arm_short_iopte __arm_short_pte_port(unsigned int prot, bool large)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_short_iopte pteprot;</span>
<span class="p_add">+</span>
<span class="p_add">+	pteprot = ARM_SHORT_F_PTE_S_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	pteprot |= large ? ARM_SHORT_F_PTE_TYPE_LARGE :</span>
<span class="p_add">+				ARM_SHORT_F_PTE_TYPE_SMALL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (prot &amp; IOMMU_CACHE)</span>
<span class="p_add">+		pteprot |=  ARM_SHORT_F_PTE_B_BIT | ARM_SHORT_F_PTE_C_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return pteprot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static arm_short_iopte __arm_short_pgd_port(int prot, bool super)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_short_iopte pgdprot;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgdprot = ARM_SHORT_F_PGD_S_BIT;</span>
<span class="p_add">+	pgdprot |= super ? ARM_SHORT_F_PGD_TYPE_SUPERSECTION :</span>
<span class="p_add">+				ARM_SHORT_F_PGD_TYPE_SECTION;</span>
<span class="p_add">+	if (prot &amp; IOMMU_CACHE)</span>
<span class="p_add">+		pgdprot |= ARM_SHORT_F_PGD_C_BIT | ARM_SHORT_F_PGD_B_BIT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return pgdprot;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int _arm_short_map_page(struct arm_short_io_pgtable *data,</span>
<span class="p_add">+			       unsigned int iova, phys_addr_t pa,</span>
<span class="p_add">+			       unsigned int prot, bool largepage)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="p_add">+	arm_short_iopte *pte;</span>
<span class="p_add">+	arm_short_iopte pgdprot, pteprot;</span>
<span class="p_add">+	arm_short_iopte mask = largepage ? ARM_SHORT_F_PTE_PA_LARGE_MSK :</span>
<span class="p_add">+						ARM_SHORT_F_PTE_PA_SMALL_MSK;</span>
<span class="p_add">+	int i, ptenum = largepage ? 16 : 1;</span>
<span class="p_add">+	bool ptenew = false;</span>
<span class="p_add">+	void *pte_new_va;</span>
<span class="p_add">+	void *cookie = data-&gt;iop.cookie;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((iova | pa) &amp; (~mask)) {</span>
<span class="p_add">+		pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="p_add">+		       iova, &amp;pa, largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pgdprot = ARM_SHORT_F_PGD_TYPE_PAGE;</span>
<span class="p_add">+	if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="p_add">+		pgdprot |= ARM_SHORT_F_PGD_NS_BIT_PAGE;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(*pgd)) {</span>
<span class="p_add">+		pte_new_va = kmem_cache_zalloc(data-&gt;ptekmem, GFP_KERNEL);</span>
<span class="p_add">+		if (unlikely(!pte_new_va)) {</span>
<span class="p_add">+			pr_err(&quot;Failed to alloc pte\n&quot;);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Check pte alignment -- must 1K align */</span>
<span class="p_add">+		if (unlikely((unsigned long)pte_new_va &amp;</span>
<span class="p_add">+			     (ARM_SHORT_BYTES_PER_PTE - 1))) {</span>
<span class="p_add">+			pr_err(&quot;The new pte is not aligned! (va=0x%p)\n&quot;,</span>
<span class="p_add">+			       pte_new_va);</span>
<span class="p_add">+			kmem_cache_free(data-&gt;ptekmem, (void *)pte_new_va);</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ptenew = true;</span>
<span class="p_add">+		*pgd = virt_to_phys(pte_new_va) | pgdprot;</span>
<span class="p_add">+		kmemleak_ignore(pte_new_va);</span>
<span class="p_add">+		data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd, sizeof(arm_short_iopte),</span>
<span class="p_add">+						 cookie);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* Someone else may have allocated for this pgd */</span>
<span class="p_add">+		if (((*pgd) &amp; (~ARM_SHORT_F_PGD_PA_PAGETABLE_MSK)) != pgdprot) {</span>
<span class="p_add">+			pr_err(&quot;The prot of old pgd is not Right!iova=0x%x pgd=0x%x pgprot=0x%x\n&quot;,</span>
<span class="p_add">+			       iova, (*pgd), pgdprot);</span>
<span class="p_add">+			return -EEXIST;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pteprot = (arm_short_iopte)pa;</span>
<span class="p_add">+	pteprot |= __arm_short_pte_port(prot, largepage);</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = arm_short_get_pte_in_pgd(*pgd, iova);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;iova:0x%x,pte:0x%p(0x%x),prot:0x%x-%s\n&quot;,</span>
<span class="p_add">+		 iova, pte, ARM_SHORT_PTE_IDX(iova), pteprot,</span>
<span class="p_add">+		 largepage ? &quot;large page&quot; : &quot;small page&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ptenum; i++) {</span>
<span class="p_add">+		if (pte[i]) {</span>
<span class="p_add">+			pr_err(&quot;The To-Map pte exists!(iova=0x%x pte=0x%x i=%d)\n&quot;,</span>
<span class="p_add">+			       iova, pte[i], i);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pte[i] = pteprot;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pte, ptenum * sizeof(arm_short_iopte),</span>
<span class="p_add">+					 cookie);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_out:</span>
<span class="p_add">+	for (i--; i &gt;= 0; i--)</span>
<span class="p_add">+		pte[i] = 0;</span>
<span class="p_add">+	if (ptenew)</span>
<span class="p_add">+		kmem_cache_free(data-&gt;ptekmem, pte_new_va);</span>
<span class="p_add">+	return -EEXIST;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int _arm_short_map_section(struct arm_short_io_pgtable *data,</span>
<span class="p_add">+				  unsigned int iova, phys_addr_t pa,</span>
<span class="p_add">+				  int prot, bool supersection)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_short_iopte pgprot;</span>
<span class="p_add">+	arm_short_iopte mask = supersection ?</span>
<span class="p_add">+				ARM_SHORT_F_PGD_PA_SUPERSECTION_MSK :</span>
<span class="p_add">+				ARM_SHORT_F_PGD_PA_SECTION_MSK;</span>
<span class="p_add">+	arm_short_iopte *pgd = data-&gt;pgd;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	unsigned int pgdnum = supersection ? 16 : 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((iova | pa) &amp; (~mask)) {</span>
<span class="p_add">+		pr_err(&quot;IOVA|PA Not Aligned(iova=0x%x pa=0x%pa type=%s)\n&quot;,</span>
<span class="p_add">+		       iova, &amp;pa, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pgprot = (arm_short_iopte)pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data-&gt;iop.cfg.quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)</span>
<span class="p_add">+		pgprot |= ARM_SHORT_F_PGD_NS_BIT_SECTION;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgprot |= __arm_short_pgd_port(prot, supersection);</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd += ARM_SHORT_PGD_IDX(iova);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;iova:0x%x,pgd:0x%p(0x%p+0x%x),value:0x%x-%s\n&quot;,</span>
<span class="p_add">+		 iova, pgd, data-&gt;pgd, ARM_SHORT_PGD_IDX(iova),</span>
<span class="p_add">+		 pgprot, supersection ? &quot;supersection&quot; : &quot;section&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; pgdnum; i++) {</span>
<span class="p_add">+		if (unlikely(*pgd)) {</span>
<span class="p_add">+			pr_err(&quot;The To-Map pdg exists!(iova=0x%x pgd=0x%x i=%d)\n&quot;,</span>
<span class="p_add">+			       iova, pgd[i], i);</span>
<span class="p_add">+			goto err_out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pgd[i] = pgprot;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	data-&gt;iop.cfg.tlb-&gt;flush_pgtable(pgd,</span>
<span class="p_add">+					 pgdnum * sizeof(arm_short_iopte),</span>
<span class="p_add">+					 data-&gt;iop.cookie);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+ err_out:</span>
<span class="p_add">+	for (i--; i &gt;= 0; i--)</span>
<span class="p_add">+		pgd[i] = 0;</span>
<span class="p_add">+	return -EEXIST;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int arm_short_map(struct io_pgtable_ops *ops, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct arm_short_io_pgtable *data = io_pgtable_short_ops_to_data(ops);</span>
<span class="p_add">+	const struct iommu_gather_ops *tlb = data-&gt;iop.cfg.tlb;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(prot &amp; (IOMMU_READ | IOMMU_WRITE)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size == SZ_4K) {/* most case */</span>
<span class="p_add">+		ret = _arm_short_map_page(data, iova, paddr, prot, false);</span>
<span class="p_add">+	} else if (size == SZ_64K) {</span>
<span class="p_add">+		ret = _arm_short_map_page(data, iova, paddr, prot, true);</span>
<span class="p_add">+	} else if (size == SZ_1M) {</span>
<span class="p_add">+		ret = _arm_short_map_section(data, iova, paddr, prot, false);</span>
<span class="p_add">+	} else if (size == SZ_16M) {</span>
<span class="p_add">+		ret = _arm_short_map_section(data, iova, paddr, prot, true);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	tlb-&gt;tlb_add_flush(iova, size, true, data-&gt;iop.cookie);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct io_pgtable *</span>
<span class="p_add">+arm_short_alloc_pgtable(struct io_pgtable_cfg *cfg, void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct arm_short_io_pgtable *data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cfg-&gt;ias != 32)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cfg-&gt;oas &gt; ARM_SHORT_MAX_ADDR_BITS)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	cfg-&gt;pgsize_bitmap &amp;= SZ_4K | SZ_64K | SZ_1M | SZ_16M;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;pgd_size = SZ_16K;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;pgd = alloc_pages_exact(data-&gt;pgd_size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+	if (!data-&gt;pgd)</span>
<span class="p_add">+		goto out_free_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	cfg-&gt;tlb-&gt;flush_pgtable(data-&gt;pgd, data-&gt;pgd_size, cookie);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* kmem for pte */</span>
<span class="p_add">+	data-&gt;ptekmem = kmem_cache_create(&quot;short-descriptor-pte&quot;,</span>
<span class="p_add">+					   ARM_SHORT_BYTES_PER_PTE,</span>
<span class="p_add">+					   ARM_SHORT_BYTES_PER_PTE,</span>
<span class="p_add">+					   0, NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(data-&gt;ptekmem)) {</span>
<span class="p_add">+		pr_err(&quot;Failed to Create cached mem for PTE %ld\n&quot;,</span>
<span class="p_add">+		       PTR_ERR(data-&gt;ptekmem));</span>
<span class="p_add">+		goto out_free_pte;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* TTBRs */</span>
<span class="p_add">+	cfg-&gt;arm_short_cfg.ttbr[0] = virt_to_phys(data-&gt;pgd);</span>
<span class="p_add">+	cfg-&gt;arm_short_cfg.ttbr[1] = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	cfg-&gt;arm_short_cfg.tcr = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;iop.ops = (struct io_pgtable_ops) {</span>
<span class="p_add">+		.map		= arm_short_map,</span>
<span class="p_add">+		.unmap		= arm_short_unmap,</span>
<span class="p_add">+		.iova_to_phys	= arm_short_iova_to_phys,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;data-&gt;iop;</span>
<span class="p_add">+</span>
<span class="p_add">+out_free_pte:</span>
<span class="p_add">+	free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="p_add">+out_free_data:</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void arm_short_free_pgtable(struct io_pgtable *iop)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct arm_short_io_pgtable *data = io_pgtable_short_to_data(iop);</span>
<span class="p_add">+</span>
<span class="p_add">+	kmem_cache_destroy(data-&gt;ptekmem);</span>
<span class="p_add">+	free_pages_exact(data-&gt;pgd, data-&gt;pgd_size);</span>
<span class="p_add">+	kfree(data);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct io_pgtable_init_fns io_pgtable_arm_short_init_fns = {</span>
<span class="p_add">+	.alloc	= arm_short_alloc_pgtable,</span>
<span class="p_add">+	.free	= arm_short_free_pgtable,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/drivers/iommu/io-pgtable.c b/drivers/iommu/io-pgtable.c</span>
<span class="p_header">index 6436fe2..14a9b3a 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable.c</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"> extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s1_init_fns;</span>
 extern struct io_pgtable_init_fns io_pgtable_arm_32_lpae_s2_init_fns;
 extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s1_init_fns;
 extern struct io_pgtable_init_fns io_pgtable_arm_64_lpae_s2_init_fns;
<span class="p_add">+extern struct io_pgtable_init_fns io_pgtable_arm_short_init_fns;</span>
 
 static const struct io_pgtable_init_fns *
 io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =
<span class="p_chunk">@@ -38,6 +39,9 @@</span> <span class="p_context"> io_pgtable_init_table[IO_PGTABLE_NUM_FMTS] =</span>
 	[ARM_64_LPAE_S1] = &amp;io_pgtable_arm_64_lpae_s1_init_fns,
 	[ARM_64_LPAE_S2] = &amp;io_pgtable_arm_64_lpae_s2_init_fns,
 #endif
<span class="p_add">+#ifdef CONFIG_IOMMU_IO_PGTABLE_SHORT</span>
<span class="p_add">+	[ARM_SHORT_DESC] = &amp;io_pgtable_arm_short_init_fns,</span>
<span class="p_add">+#endif</span>
 };
 
 struct io_pgtable_ops *alloc_io_pgtable_ops(enum io_pgtable_fmt fmt,
<span class="p_header">diff --git a/drivers/iommu/io-pgtable.h b/drivers/iommu/io-pgtable.h</span>
<span class="p_header">index 10e32f6..47efaab 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable.h</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable.h</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"> enum io_pgtable_fmt {</span>
 	ARM_32_LPAE_S2,
 	ARM_64_LPAE_S1,
 	ARM_64_LPAE_S2,
<span class="p_add">+	ARM_SHORT_DESC,</span>
 	IO_PGTABLE_NUM_FMTS,
 };
 
<span class="p_chunk">@@ -62,6 +63,11 @@</span> <span class="p_context"> struct io_pgtable_cfg {</span>
 			u64	vttbr;
 			u64	vtcr;
 		} arm_lpae_s2_cfg;
<span class="p_add">+</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			u64	ttbr[2];</span>
<span class="p_add">+			u64	tcr;</span>
<span class="p_add">+		} arm_short_cfg;</span>
 	};
 };
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



